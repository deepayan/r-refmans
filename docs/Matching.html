<!DOCTYPE html><html><head><title>Help for package Matching</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Matching}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#balanceUV'><p>Univariate Balance Tests</p></a></li>
<li><a href='#GenMatch'><p>Genetic Matching</p></a></li>
<li><a href='#GerberGreenImai'><p>Gerber and Green Dataset used by Imai</p></a></li>
<li><a href='#ks.boot'><p>Bootstrap Kolmogorov-Smirnov</p></a></li>
<li><a href='#lalonde'><p>Lalonde Dataset</p></a></li>
<li><a href='#Match'><p>Multivariate and Propensity Score Matching Estimator for Causal Inference</p></a></li>
<li><a href='#MatchBalance'><p>Tests for Univariate and Multivariate Balance</p></a></li>
<li><a href='#Matchby'><p>Grouped Multivariate and Propensity Score Matching</p></a></li>
<li><a href='#qqstats'><p>QQ Summary Statistics</p></a></li>
<li><a href='#summary.balanceUV'><p>Summarizing output from balanceUV</p></a></li>
<li><a href='#summary.ks.boot'><p>Summarizing output from ks.boot</p></a></li>
<li><a href='#summary.Match'><p>Summarizing output from Match</p></a></li>
<li><a href='#summary.Matchby'><p>Summarizing output from Matchby</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.10-14</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate and Propensity Score Matching with Balance
Optimization</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jasjeet Singh Sekhon &lt;jas.sekhon@yale.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for multivariate and propensity score matching 
             and for finding optimal balance based on a genetic search algorithm. 
             A variety of univariate and multivariate metrics to
             determine if balance has been obtained are also provided. For
             details, see the paper by Jasjeet Sekhon 
             (2007, &lt;<a href="https://doi.org/10.18637%2Fjss.v042.i07">doi:10.18637/jss.v042.i07</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.6.0), MASS (&ge; 7.2-1), graphics, grDevices, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, rgenoud (&ge; 2.12), testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JasjeetSekhon/Matching">https://github.com/JasjeetSekhon/Matching</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-14 02:08:55 UTC; theosaa</td>
</tr>
<tr>
<td>Author:</td>
<td>Jasjeet Singh Sekhon [aut, cre],
  Theo Saarinen [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-14 09:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='balanceUV'>Univariate Balance Tests</h2><span id='topic+balanceUV'></span>

<h3>Description</h3>

<p>This function provides a number of univariate balance metrics.
Generally, users should call <code><a href="#topic+MatchBalance">MatchBalance</a></code> and not this function
directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanceUV(Tr, Co, weights = rep(1, length(Co)), exact = FALSE, ks=FALSE,
          nboots = 1000, paired=TRUE, match=FALSE,
          weights.Tr=rep(1,length(Tr)), weights.Co=rep(1,length(Co)),
          estimand="ATT")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balanceUV_+3A_tr">Tr</code></td>
<td>
<p>A vector containing the treatment observations.</p>
</td></tr>
<tr><td><code id="balanceUV_+3A_co">Co</code></td>
<td>
<p>A vector containing the control observations.</p>
</td></tr>
<tr><td><code id="balanceUV_+3A_weights">weights</code></td>
<td>
<p>A vector containing the observation specific
weights. Only use this option when the treatment and control
observations are paired (as they are after matching).</p>
</td></tr>
<tr><td><code id="balanceUV_+3A_exact">exact</code></td>
<td>
<p>A logical flag indicating if the exact Wilcoxon test
should be used instead of the test with a correction.  See
<code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> for details.</p>
</td></tr>
<tr><td><code id="balanceUV_+3A_ks">ks</code></td>
<td>
<p> A logical flag for if the univariate bootstrap
Kolmogorov-Smirnov (KS) test should be calculated.  If the ks option
is set to true, the univariate KS test is calculated for all
non-dichotomous variables.  The bootstrap KS test is consistent even
for non-continuous variables.  See <code><a href="#topic+ks.boot">ks.boot</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="balanceUV_+3A_nboots">nboots</code></td>
<td>
<p>The number of bootstrap samples to be run for the
<code>ks</code> test.  If zero, no bootstraps are done.  Bootstrapping is
highly recommended because the bootstrapped Kolmogorov-Smirnov test
only provides correct coverage even for non-continuous covariates. At
least 500 <code>nboots</code> (preferably 1000) are
recommended for publication quality p-values.</p>
</td></tr>
<tr><td><code id="balanceUV_+3A_paired">paired</code></td>
<td>
<p>A flag for if the paired <code><a href="stats.html#topic+t.test">t.test</a></code> should be used.</p>
</td></tr>
<tr><td><code id="balanceUV_+3A_match">match</code></td>
<td>
<p>A flag for if the <code>Tr</code> and <code>Co</code> objects are the result
of a call to <code><a href="#topic+Match">Match</a></code>.</p>
</td></tr>
<tr><td><code id="balanceUV_+3A_weights.tr">weights.Tr</code></td>
<td>
<p>A vector of weights for the treated observations.</p>
</td></tr>
<tr><td><code id="balanceUV_+3A_weights.co">weights.Co</code></td>
<td>
<p>A vector of weights for the control observations.</p>
</td></tr>
<tr><td><code id="balanceUV_+3A_estimand">estimand</code></td>
<td>
<p>This determines if the standardized mean difference
returned by the <code>sdiff</code> object is standardized by the variance of
the treatment observations (which is done if the estimand is either
&quot;ATE&quot; or &quot;ATT&quot;) or by the variance of the control observations (which
is done if the estimand is &quot;ATC&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>sdiff</code></td>
<td>
<p>This is the standardized difference between the treated
and control units multiplied by 100.  That is, 100 times the mean
difference  between treatment and control units divided by the standard
deviation of the treatment
observations alone if the estimand is either <code>ATT</code> or
<code>ATE</code>.  The variance of the control observations are used if
the estimand is <code>ATC</code>.</p>
</td></tr>
<tr><td><code>sdiff.pooled</code></td>
<td>
<p>This is the standardized difference between the
treated and control units multiplied by 100 using the pooled
variance.  That is, 100 times the mean
difference between treatment and control units divided by the pooled standard deviation as in
Rosenbaum and Rubin (1985).</p>
</td></tr>
<tr><td><code>mean.Tr</code></td>
<td>
<p>The mean of the treatment group.</p>
</td></tr>
<tr><td><code>mean.Co</code></td>
<td>
<p>The mean of the control group.</p>
</td></tr>
<tr><td><code>var.Tr</code></td>
<td>
<p>The variance of the treatment group.</p>
</td></tr>
<tr><td><code>var.Co</code></td>
<td>
<p>The variance of the control group.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value from the two-sided weighted <code><a href="stats.html#topic+t.test">t.test</a></code>.</p>
</td></tr>
<tr><td><code>var.ratio</code></td>
<td>
<p>var.Tr/var.Co.</p>
</td></tr>
<tr><td><code>ks</code></td>
<td>
<p>The object returned by <code><a href="#topic+ks.boot">ks.boot</a></code>.</p>
</td></tr>
<tr><td><code>tt</code></td>
<td>
<p>The object returned by two-sided weighted
<code><a href="stats.html#topic+t.test">t.test</a></code>.</p>
</td></tr>
<tr><td><code>qqsummary</code></td>
<td>
<p>The return object from a call to
<code><a href="#topic+qqstats">qqstats</a></code> with standardization&mdash;i.e., balance test
based on the empirical CDF.</p>
</td></tr>
<tr><td><code>qqsummary.raw</code></td>
<td>
<p>The return object from a call to
<code><a href="#topic+qqstats">qqstats</a></code> without standardization&ndash;i.e., balance tests
based on the empirical QQ-plot which retain the scale of the
variable.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011.  &quot;Multivariate and Propensity Score
Matching Software with Automated Balance Optimization.&rdquo;
<em>Journal of Statistical Software</em> 42(7): 1-52.
<a href="https://doi.org/10.18637/jss.v042.i07">doi:10.18637/jss.v042.i07</a>
</p>
<p>Diamond, Alexis and Jasjeet S. Sekhon. 2013. &quot;Genetic
Matching for Estimating Causal Effects: A General Multivariate
Matching Method for Achieving Balance in Observational Studies.&rdquo;
<em>Review of Economics and Statistics</em>.  95 (3): 932&ndash;945.
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>
</p>
<p>Rosenbaum, Paul R. and Donald B. Rubin. 1985. &ldquo;Constructing a Control
Group Using Multivariate Matched Sampling Methods That Incorporate the
Propensity Score.&rdquo; <em>The American Statistician</em> 39:1 33-38.
</p>
<p>Hollander, Myles and Douglas A. Wolfe. 1973. <em>Nonparametric
statistical inference</em>. New York: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p> Also see <code><a href="#topic+summary.balanceUV">summary.balanceUV</a></code>, <code><a href="#topic+qqstats">qqstats</a></code>
<code><a href="#topic+ks.boot">ks.boot</a></code>, <code><a href="#topic+Match">Match</a></code>, <code><a href="#topic+GenMatch">GenMatch</a></code>,
<code><a href="#topic+MatchBalance">MatchBalance</a></code>,
<code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>, <code><a href="#topic+lalonde">lalonde</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lalonde)
attach(lalonde)

foo  &lt;- balanceUV(re75[treat==1],re75[treat!=1])
summary(foo)

</code></pre>

<hr>
<h2 id='GenMatch'>Genetic Matching</h2><span id='topic+GenMatch'></span>

<h3>Description</h3>

<p>This function finds optimal balance using multivariate matching where
a genetic search algorithm determines the weight each covariate is
given.  Balance is determined by examining cumulative probability
distribution functions of a variety of standardized statistics.  By
default, these statistics include t-tests and Kolmogorov-Smirnov
tests. A variety of descriptive statistics based on empirical-QQ
(eQQ) plots can also be used or any user provided measure of balance.
The statistics are not used to conduct formal hypothesis tests,
because no measure of balance is a monotonic function of bias and
because balance should be maximized without limit. The object
returned by <code>GenMatch</code> can be supplied to the <code><a href="#topic+Match">Match</a></code>
function (via the <code>Weight.matrix</code> option) to obtain causal
estimates.  <code>GenMatch</code> uses <code><a href="rgenoud.html#topic+genoud">genoud</a></code> to
perform the genetic search.  Using the <code>cluster</code> option, one may
use multiple computers, CPUs or cores to perform parallel
computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenMatch(Tr, X, BalanceMatrix=X, estimand="ATT", M=1, weights=NULL,
         pop.size = 100, max.generations=100,
         wait.generations=4, hard.generation.limit=FALSE,
         starting.values=rep(1,ncol(X)),
         fit.func="pvals",
         MemoryMatrix=TRUE,
         exact=NULL, caliper=NULL, replace=TRUE, ties=TRUE,
         CommonSupport=FALSE, nboots=0, ks=TRUE, verbose=FALSE,
         distance.tolerance=1e-05,
         tolerance=sqrt(.Machine$double.eps),
         min.weight=0, max.weight=1000,
         Domains=NULL, print.level=2,
         project.path=NULL,
         paired=TRUE, loss=1,
         data.type.integer=FALSE,
         restrict=NULL,
         cluster=FALSE, balance=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenMatch_+3A_tr">Tr</code></td>
<td>
<p> A vector indicating the observations which are in the
treatment regime and those which are not.  This can either be a
logical vector or a real vector where 0 denotes control and 1 denotes
treatment.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_x">X</code></td>
<td>
<p> A matrix containing the variables we wish to match on.
This matrix may contain the actual observed covariates or the
propensity score or a combination of both.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_balancematrix">BalanceMatrix</code></td>
<td>
<p> A matrix containing the variables we wish
to achieve balance on.  This is by default equal to <code>X</code>, but it can
in principle be a matrix which contains more or less variables than
<code>X</code> or variables which are transformed in various ways.  See
the examples.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_estimand">estimand</code></td>
<td>
<p> A character string for the estimand.  The default
estimand is &quot;ATT&quot;, the sample average treatment effect for the
treated. &quot;ATE&quot; is the sample average treatment effect, and
&quot;ATC&quot; is the sample average treatment effect for the controls.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_m">M</code></td>
<td>
<p>A scalar for the number of matches which should be
found. The default is one-to-one matching. Also see the <code>ties</code>
option.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_weights">weights</code></td>
<td>
<p> A vector the same length as <code>Y</code> which
provides observation specific weights.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_pop.size">pop.size</code></td>
<td>
<p>Population Size.  This is the number of individuals
<code><a href="rgenoud.html#topic+genoud">genoud</a></code> uses to solve the optimization problem.
The theorems proving that genetic algorithms find good solutions are
asymptotic in population size.  Therefore, it is important that this value not
be small.  See <code><a href="rgenoud.html#topic+genoud">genoud</a></code> for more details.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_max.generations">max.generations</code></td>
<td>
<p> Maximum Generations.  This is the maximum
number of generations that <code><a href="rgenoud.html#topic+genoud">genoud</a></code> will run when
optimizing.  This is a <em>soft</em> limit.  The maximum generation
limit will be binding only if <code>hard.generation.limit</code> has been
set equal to <em>TRUE</em>.  Otherwise, <code>wait.generations</code> controls
when optimization stops. See <code><a href="rgenoud.html#topic+genoud">genoud</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_wait.generations">wait.generations</code></td>
<td>
<p>If there is no improvement in the objective
function in this number of generations, optimization will stop.  The
other options controlling termination are <code>max.generations</code> and
<code>hard.generation.limit</code>.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_hard.generation.limit">hard.generation.limit</code></td>
<td>
<p> This logical variable determines if the
<code>max.generations</code> variable is a binding constraint.  If
<code>hard.generation.limit</code> is <em>FALSE</em>, then
the algorithm may exceed the <code>max.generations</code>
count if the objective function has improved within a given number of
generations (determined by <code>wait.generations</code>).</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_starting.values">starting.values</code></td>
<td>

<p>This vector's length is equal to the number of variables in <code>X</code>.  This
vector contains the starting weights each of the variables is
given. The <code>starting.values</code> vector is a way for the user
to insert <em>one</em> individual into the starting population.
<code><a href="rgenoud.html#topic+genoud">genoud</a></code> will randomly create the other individuals.  These values
correspond to the diagonal of the <code>Weight.matrix</code> as described
in detail in the <code><a href="#topic+Match">Match</a></code> function.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_fit.func">fit.func</code></td>
<td>
<p>The balance metric <code>GenMatch</code> should optimize.
The user may choose from the following or provide a function:<br />
<code>pvals</code>: maximize the p.values from (paired) t-tests and
Kolmogorov-Smirnov tests conducted for each column in
<code>BalanceMatrix</code>.  Lexical optimization is conducted&mdash;see the
<code>loss</code> option for details.<br />
<code>qqmean.mean</code>: calculate the mean standardized difference in the eQQ
plot for each variable.  Minimize the mean of these differences across
variables.<br />
<code>qqmean.max</code>:  calculate the mean standardized difference in the eQQ
plot for each variable.  Minimize the maximum of these differences across
variables.  Lexical optimization is conducted.<br />
<code>qqmedian.mean</code>: calculate the median standardized difference in the eQQ
plot for each variable.  Minimize the median of these differences across
variables.<br />
<code>qqmedian.max</code>:  calculate the median standardized difference in the eQQ
plot for each variable.  Minimize the maximum of these differences across
variables.  Lexical optimization is conducted.<br />
<code>qqmax.mean</code>: calculate the maximum standardized difference in the eQQ
plot for each variable.  Minimize the mean of these differences across
variables.<br />
<code>qqmax.max</code>:  calculate the maximum standardized difference in the eQQ
plot for each variable.  Minimize the maximum of these differences across
variables.  Lexical optimization is conducted.<br />
Users may provide their own <code>fit.func</code>. The name of the user
provided function should not be backquoted or quoted.  This function needs
to return a fit value that will be minimized, by lexical
optimization if more than one fit value is returned.  The function
should expect two arguments.  The first being the <code>matches</code> object
returned by <code>GenMatch</code>&mdash;see
below.  And the second being a matrix which contains the variables to
be balanced&mdash;i.e., the <code>BalanceMatrix</code> the user provided to
<code>GenMatch</code>. For an example see
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_memorymatrix">MemoryMatrix</code></td>
<td>

<p>This variable controls if <code><a href="rgenoud.html#topic+genoud">genoud</a></code> sets up a memory matrix.  Such a
matrix ensures that <code><a href="rgenoud.html#topic+genoud">genoud</a></code> will request the fitness evaluation
of a given set of parameters only once. The variable may be
<em>TRUE</em> or <em>FALSE</em>.  If it is <em>FALSE</em>, <code><a href="rgenoud.html#topic+genoud">genoud</a></code>
will be aggressive in
conserving memory.  The most significant negative implication of
this variable being set to <em>FALSE</em> is that <code><a href="rgenoud.html#topic+genoud">genoud</a></code> will no
longer maintain a memory
matrix of all evaluated individuals.  Therefore, <code><a href="rgenoud.html#topic+genoud">genoud</a></code> may request
evaluations which it has  previously requested.  When
the number variables in <code>X</code> is large, the memory matrix
consumes a large amount of RAM.<br />
</p>
<p><code><a href="rgenoud.html#topic+genoud">genoud</a></code>'s memory matrix will require <em>significantly</em> less
memory if the user sets <code>hard.generation.limit</code> equal
to <em>TRUE</em>.  Doing this is a good way of conserving
memory while still making use of the memory matrix structure.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_exact">exact</code></td>
<td>
<p> A logical scalar or vector for whether exact matching
should be done.  If a logical scalar is
provided, that logical value is applied to all covariates in
<code>X</code>.  If a logical vector is provided, a logical value should
be provided for each covariate in <code>X</code>. Using a logical vector
allows the user to specify exact matching for some but not other
variables.  When exact matches are not found, observations are
dropped.  <code>distance.tolerance</code> determines what is considered to
be an exact match. The <code>exact</code> option takes precedence over the
<code>caliper</code> option.  Obviously, if <code>exact</code> matching is done
using <em>all</em> of the covariates, one should not be using
<code>GenMatch</code> unless the <code>distance.tolerance</code> has been set
unusually high.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_caliper">caliper</code></td>
<td>
<p> A scalar or vector denoting the caliper(s) which
should be used when matching.  A caliper is the distance which is
acceptable for any match.  Observations which are outside of the
caliper are dropped. If a scalar caliper is provided, this caliper is
used for all covariates in <code>X</code>.  If a vector of calipers is
provided, a caliper value should be provided for each covariate in
<code>X</code>. The caliper is interpreted to be in standardized units.  For
example, <code>caliper=.25</code> means that all matches not equal to or
within .25 standard deviations of each covariate in <code>X</code> are
dropped.  The <code>ecaliper</code> object which is returned by
<code>GenMatch</code> shows the enforced caliper on the scale of the
<code>X</code> variables. Note that dropping observations generally changes
the quantity being estimated.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_replace">replace</code></td>
<td>
<p>A logical flag for whether matching should be done with
replacement.  Note that if <code>FALSE</code>, the order of matches
generally matters.  Matches will be found in the same order as the
data are sorted.  Thus, the match(es) for the first observation will
be found first, the match(es) for the second observation will be found second, etc.
Matching without replacement will generally increase bias.
Ties are randomly broken when <code>replace==FALSE</code>&mdash;see the
<code>ties</code> option for details.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_ties">ties</code></td>
<td>
<p>A logical flag for whether ties should be handled deterministically.  By
default <code>ties==TRUE</code>. If, for example, one treated observation
matches more than one control observation, the matched dataset will
include the multiple matched control observations and the matched data
will be weighted to reflect the multiple matches.  The sum of the
weighted observations will still equal the original number of
observations. If <code>ties==FALSE</code>, ties will be randomly broken.
<em>If the dataset is large and there are many ties, setting
<code>ties=FALSE</code> often results in a large speedup.</em> Whether two
potential matches are close enough to be considered tied, is
controlled by the <code>distance.tolerance</code>
option.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_commonsupport">CommonSupport</code></td>
<td>
<p>This logical flag implements the usual procedure
by which observations outside of the common support of a variable
(usually the propensity score) across treatment and control groups are
discarded.  The <code>caliper</code> option is to
be preferred to this option because <code>CommonSupport</code>, consistent
with the literature, only drops <em>outliers</em> and leaves
<em>inliers</em> while the caliper option drops both.
If <code>CommonSupport==TRUE</code>, common support will be enforced on
the first variable in the <code>X</code> matrix.  Note that dropping
observations generally changes the quantity being estimated.  Use of
this option renders it impossible to use the returned
object <code>matches</code> to reconstruct the matched dataset.
Seriously, don't use this option; use the <code>caliper</code> option instead.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_nboots">nboots</code></td>
<td>
<p>The number of bootstrap samples to be run for the
<code>ks</code> test.  By default this option is set to zero so no
bootstraps are done.  See <code><a href="#topic+ks.boot">ks.boot</a></code> for additional
details.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_ks">ks</code></td>
<td>
<p> A logical flag for if the univariate bootstrap
Kolmogorov-Smirnov (KS) test should be calculated.  If the ks option
is set to true, the univariate KS test is calculated for all
non-dichotomous variables.  The bootstrap KS test is consistent even
for non-continuous variables.  By default, the bootstrap KS test is
not used. To change this see the <code>nboots</code> option. If a given
variable is dichotomous, a t-test is used even if the KS test is requested.  See
<code><a href="#topic+ks.boot">ks.boot</a></code> for additional details.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag for whether details of each
fitness evaluation should be printed.  Verbose is set to FALSE if
the <code>cluster</code> option is used.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_distance.tolerance">distance.tolerance</code></td>
<td>
<p>This is a scalar which is used to determine
if distances between two observations are different from zero.  Values
less than <code>distance.tolerance</code> are deemed to be equal to zero.
This option can be used to perform a type of optimal matching.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_tolerance">tolerance</code></td>
<td>
<p> This is a scalar which is used to determine
numerical tolerances.  This option is used by numerical routines
such as those used to determine if a matrix is singular.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_min.weight">min.weight</code></td>
<td>
<p>This is the minimum weight any variable may be
given.</p>
</td></tr>  
<tr><td><code id="GenMatch_+3A_max.weight">max.weight</code></td>
<td>
<p>This is the maximum weight any variable may be
given.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_domains">Domains</code></td>
<td>
<p>This is a <code>ncol(X)</code> <code class="reqn">\times 2</code> matrix.
The first column is the lower bound, and the second column is the
upper bound for each variable over which <code><a href="rgenoud.html#topic+genoud">genoud</a></code> will
search for weights.  If the user does not provide this matrix, the
bounds for each variable will be determined by the <code>min.weight</code>
and <code>max.weight</code> options.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_print.level">print.level</code></td>
<td>

<p>This option controls the level of printing.  There
are four possible levels: 0 (minimal printing), 1 (normal), 2
(detailed), and 3 (debug).  If level 2 is selected, <code>GenMatch</code> will
print details about the population at each generation, including the
best individual found so far. If debug
level printing is requested, details of the <code><a href="rgenoud.html#topic+genoud">genoud</a></code>
population are printed in the &quot;genoud.pro&quot; file which is located in
the temporary <code>R</code> directory returned by the <code><a href="base.html#topic+tempdir">tempdir</a></code>
function.  See the <code>project.path</code> option for more details.
Because <code>GenMatch</code> runs may take a long time, it is important for the
user to receive feedback.  Hence, print level 2 has been set as the
default.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_project.path">project.path</code></td>
<td>
<p> This is the path of the
<code><a href="rgenoud.html#topic+genoud">genoud</a></code> project file.  By default no file is
produced unless <code>print.level=3</code>.  In that case,
<code><a href="rgenoud.html#topic+genoud">genoud</a></code> places its output in a file called
&quot;genoud.pro&quot; located in the temporary directory provided by
<code><a href="base.html#topic+tempdir">tempdir</a></code>.  If a file path is provided to the
<code>project.path</code> option, a file will be created regardless of the
<code>print.level</code>. The behavior of the project file, however, will
depend on the <code>print.level</code> chosen.  If the <code>print.level</code>
variable is set to 1, then the project file is rewritten after each
generation.  Therefore, only the currently fully completed generation
is included in the file.  If the <code>print.level</code> variable is set to
2 or higher, then each new generation is simply appended to the
project file. No project file is generated for
<code>print.level=0</code>.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_paired">paired</code></td>
<td>
<p>A flag for whether the paired <code><a href="stats.html#topic+t.test">t.test</a></code> should be
used when determining balance.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_loss">loss</code></td>
<td>
<p>The loss function to be optimized.  The default value, <code>1</code>,
implies &quot;lexical&quot; optimization: all of the balance statistics will
be sorted from the most discrepant to the least and weights will be
picked which minimize the maximum discrepancy. If multiple sets of
weights result in the same maximum discrepancy, then the second
largest discrepancy is examined to choose the best weights.  The
processes continues iteratively until ties are broken.  <br />
</p>
<p>If the value of <code>2</code> is used, then only the maximum discrepancy
is examined.  This was the default behavior prior to version 1.0.  The
user may also pass in any function she desires. Note that the
option 1 corresponds to the <code><a href="base.html#topic+sort">sort</a></code> function and option 2
to the <code><a href="base.html#topic+min">min</a></code> function.  Any user specified function
should expect a vector of balance statistics (&quot;p-values&quot;) and it
should return either a vector of values (in which case &quot;lexical&quot;
optimization will be done) or a scalar value (which will be
maximized). Some possible alternative functions are
<code><a href="base.html#topic+mean">mean</a></code> or <code><a href="stats.html#topic+median">median</a></code>.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_data.type.integer">data.type.integer</code></td>
<td>

<p>By default, floating-point weights are considered. If this option is
set to <code>TRUE</code>, search will be done over integer weights. Note
that before version 4.1, the default was to use integer weights.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_restrict">restrict</code></td>
<td>
<p>A matrix which restricts the possible matches. This
matrix has one row for each restriction and three
columns.  The first two columns contain the two observation numbers
which are to be restricted (for example 4 and 20), and the third
column is the restriction imposed on the observation-pair.
Negative numbers in the third column imply that the two observations
cannot be matched under any circumstances, and positive numbers are
passed on as the distance between the two observations for the
matching algorithm.  The most commonly used positive restriction is
<code>0</code> which implies that the two observations will always
be matched.  <br />
</p>
<p>Exclusion restriction are even more common.  For example, if we want
to exclude the observation pair 4 and 20 and the pair 6 and 55 from
being matched, the restrict matrix would be:
<code>restrict=rbind(c(4,20,-1),c(6,55,-1))</code></p>
</td></tr> <tr><td><code id="GenMatch_+3A_cluster">cluster</code></td>
<td>
<p>This
can either be an object of the 'cluster' class returned by one of
the <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> commands in the
<code>parallel</code> package or a vector of machine names so that
<code>GenMatch</code> can setup the cluster automatically. If it is the
latter, the vector should look like: <br />
<code>c("localhost","musil","musil","deckard")</code>.<br /> This vector
would create a cluster with four nodes: one on the localhost another
on &quot;deckard&quot; and two on the machine named &quot;musil&quot;.  Two nodes on a
given machine make sense if the machine has two or more chips/cores.
<code>GenMatch</code> will setup a SOCK cluster by a call to
<code><a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a></code>.  This will require the
user to type in her password for each node as the cluster is by
default created via <code>ssh</code>.  One can add on usernames to the
machine name if it differs from the current shell: &quot;username@musil&quot;.
Other cluster types, such as PVM and MPI, which do not require
passwords, can be created by directly calling
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, and then passing the returned
cluster object to <code>GenMatch</code>. For an example of how to manually
setup up a cluster with a direct call to
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> see
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.  For
an example of how to get around a firewall by ssh tunneling see:
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_balance">balance</code></td>
<td>
<p>This logical flag controls if load balancing is done
across the cluster.  Load balancing can result in better cluster
utilization; however, increased communication can reduce
performance.  This option is best used if each individual call to
<code><a href="#topic+Match">Match</a></code> takes at least several minutes to
calculate or if the nodes in the cluster vary significantly in their
performance. If cluster==FALSE, this option has no effect.</p>
</td></tr>
<tr><td><code id="GenMatch_+3A_...">...</code></td>
<td>
<p>Other options which are passed on to
<code><a href="rgenoud.html#topic+genoud">genoud</a></code>.</p>
</td></tr>  </table>


<h3>Value</h3>

 <table>
<tr><td><code>value</code></td>
<td>
<p>The fit
values at the solution.  By default, this is a vector of p-values
sorted from the smallest to the largest.  There will generally be
twice as many p-values as there are variables in
<code>BalanceMatrix</code>, unless there are dichotomous variables in this
matrix.  There is one p-value for each covariate in
<code>BalanceMatrix</code> which is the result of a paired t-test and
another p-value for each non-dichotomous variable in
<code>BalanceMatrix</code> which is the result of a Kolmogorov-Smirnov
test. Recall that these p-values cannot be interpreted as hypothesis
tests.  They are simply measures of balance.</p>
</td></tr>  <tr><td><code>par</code></td>
<td>
<p>A vector
of the weights given to each variable in <code>X</code>.</p>
</td></tr>
<tr><td><code>Weight.matrix</code></td>
<td>
<p>A matrix whose diagonal corresponds to the
weight given to each variable in <code>X</code>.  This object corresponds
to the <code>Weight.matrix</code> in the <code><a href="#topic+Match">Match</a></code> function.</p>
</td></tr>
<tr><td><code>matches</code></td>
<td>
<p>A matrix where the first column contains the row
numbers of the treated observations in the matched dataset. The
second column contains the row numbers of the control
observations. And the third column contains the weight that each
matched pair is given.  These objects may not correspond
respectively to the <code>index.treated</code>, <code>index.control</code> and
<code>weights</code> objects which are returned by <code><a href="#topic+Match">Match</a></code>
because they may be ordered in a different way. Therefore, end users
should use the objects returned by <code><a href="#topic+Match">Match</a></code> because those
are ordered in the way that users expect.</p>
</td></tr>
<tr><td><code>ecaliper</code></td>
<td>
<p>The
size of the enforced caliper on the scale of the <code>X</code> variables.
This object has the same length as the number of covariates in
<code>X</code>.</p>
</td></tr>  </table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.  
</p>


<h3>References</h3>

<p> Sekhon, Jasjeet S. 2011.  &quot;Multivariate
and Propensity Score Matching Software with Automated Balance
Optimization.&rdquo;  <em>Journal of Statistical Software</em> 42(7): 1-52.
<a href="https://doi.org/10.18637/jss.v042.i07">doi:10.18637/jss.v042.i07</a>
</p>
<p>Diamond, Alexis and Jasjeet S. Sekhon. 2013. &quot;Genetic
Matching for Estimating Causal Effects: A General Multivariate
Matching Method for Achieving Balance in Observational Studies.&rdquo;
<em>Review of Economics and Statistics</em>.  95 (3): 932&ndash;945.
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>
</p>
<p>Sekhon, Jasjeet Singh and Walter R. Mebane, Jr. 1998.  &quot;Genetic
Optimization Using Derivatives: Theory and Application to Nonlinear
Models.&rdquo; <em>Political Analysis</em>, 7: 187-210.
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a> 
</p>


<h3>See Also</h3>

<p> Also see <code><a href="#topic+Match">Match</a></code>, <code><a href="#topic+summary.Match">summary.Match</a></code>,
<code><a href="#topic+MatchBalance">MatchBalance</a></code>, <code><a href="rgenoud.html#topic+genoud">genoud</a></code>,
<code><a href="#topic+balanceUV">balanceUV</a></code>, <code><a href="#topic+qqstats">qqstats</a></code>,
<code><a href="#topic+ks.boot">ks.boot</a></code>, <code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>, <code><a href="#topic+lalonde">lalonde</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lalonde)
attach(lalonde)

#The covariates we want to match on
X = cbind(age, educ, black, hisp, married, nodegr, u74, u75, re75, re74)

#The covariates we want to obtain balance on
BalanceMat &lt;- cbind(age, educ, black, hisp, married, nodegr, u74, u75, re75, re74,
                    I(re74*re75))

#
#Let's call GenMatch() to find the optimal weight to give each
#covariate in 'X' so as we have achieved balance on the covariates in
#'BalanceMat'. This is only an example so we want GenMatch to be quick
#so the population size has been set to be only 16 via the 'pop.size'
#option. This is *WAY* too small for actual problems.
#For details see https://www.jsekhon.com.
#
genout &lt;- GenMatch(Tr=treat, X=X, BalanceMatrix=BalanceMat, estimand="ATE", M=1,
                   pop.size=16, max.generations=10, wait.generations=1)

#The outcome variable
Y=re78/1000

#
# Now that GenMatch() has found the optimal weights, let's estimate
# our causal effect of interest using those weights
#
mout &lt;- Match(Y=Y, Tr=treat, X=X, estimand="ATE", Weight.matrix=genout)
summary(mout)

#                        
#Let's determine if balance has actually been obtained on the variables of interest
#                        
mb &lt;- MatchBalance(treat~age +educ+black+ hisp+ married+ nodegr+ u74+ u75+
                   re75+ re74+ I(re74*re75),
                   match.out=mout, nboots=500)

# For more examples see: https://www.jsekhon.com.
</code></pre>

<hr>
<h2 id='GerberGreenImai'>Gerber and Green Dataset used by Imai</h2><span id='topic+GerberGreenImai'></span>

<h3>Description</h3>

<p>This is the dataset used by Imai (2005) to replicate and evaluate the
field experiment done by Gerber and Green (2000). The accompanying
demo replicates Imai's propensity score model which is then used to
estimate the causal effect of get-out-the-vote telephone calls on
turnout. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GerberGreenImai)</code></pre>


<h3>Format</h3>

<p>A data frame with 10829 observations on the following 26 variables.
</p>

<dl>
<dt>PERSONS </dt><dd><p>Number persons in household</p>
</dd>
<dt>WARD    </dt><dd><p>Ward of residence</p>
</dd>
<dt>QUESTION</dt><dd><p>Asked to commit to voting</p>
</dd>
<dt>MAILGRP </dt><dd><p>Sent mail</p>
</dd>
<dt>PHONEGRP</dt><dd><p>Phone batch #1</p>
</dd>
<dt>PERSNGRP</dt><dd><p>Personal contact attempted</p>
</dd>
<dt>APPEAL  </dt><dd><p>Content of message</p>
</dd>
<dt>CONTACT </dt><dd><p>Personal contact occurred</p>
</dd>
<dt>MAILINGS</dt><dd><p>Number of mailings sent</p>
</dd>
<dt>AGE     </dt><dd><p>Age of respondent</p>
</dd>
<dt>MAJORPTY</dt><dd><p>Democratic or Republican</p>
</dd>
<dt>VOTE96.0</dt><dd><p>Abstained in 1996</p>
</dd>
<dt>VOTE96.1</dt><dd><p>Voted in 1996</p>
</dd>
<dt>MAILCALL</dt><dd><p>Phone batch #2</p>
</dd>
<dt>VOTED98 </dt><dd><p>Voted in 1998</p>
</dd>
<dt>PHNSCRPT</dt><dd><p>Script read to phone respondents</p>
</dd>
<dt>DIS.MC  </dt><dd><p>Contacted by phone in batch #2</p>
</dd>
<dt>DIS.PHN </dt><dd><p>Contacted by phone in batch #1</p>
</dd>
<dt>PHN.C   </dt><dd><p>Contacted by phone</p>
</dd>
<dt>PHNTRT1 </dt><dd><p>Phone contact attempted (no blood or blood/civic)</p>
</dd>
<dt>PHNTRT2 </dt><dd><p>Phone contact attempted (no blood)</p>
</dd>
<dt>PHN.C1  </dt><dd><p>Contact occurred in phntrt1</p>
</dd>
<dt>PHN.C2  </dt><dd><p>Contact occurred in phntrt2</p>
</dd>
<dt>NEW     </dt><dd><p>New voter</p>
</dd>
<dt>phone   </dt><dd><p>Contacted by phone</p>
</dd>
<dt>AGE2    </dt><dd><p>Age squared</p>
</dd>
</dl>



<h3>Details</h3>

<p>The demo provided, entitled <code>GerberGreenImai</code>, uses Imai's
propensity score model to estimate the causal effect of
get-out-the-vote telephone calls on turnout. The propensity score
model fails to balance age.
</p>


<h3>References</h3>

<p>Gerber, Alan S. and Donald P. Green. 2000. &ldquo;The Effects of
Canvassing, Telephone Calls, and Direct Mail on Voter Turnout: A Field
Experiment.&rdquo; <em>American Political Science Review</em> 94: 653-663.
</p>
<p>Gerber, Alan S. and Donald P. Green. 2005. &ldquo;Correction to Gerber
and Green (2000), replication of disputed findings, and reply to
Imai (2005).&rdquo;  <em>American Political Science Review</em> 99:
301-313.
</p>
<p>Imai, Kosuke. 2005. &ldquo;Do Get-Out-The-Vote Calls Reduce Turnout?
The Importance of Statistical Methods for Field Experiments.&rdquo; 
<em>American Political Science Review</em> 99: 283-300.
</p>
<p>Hansen, Ben B. Hansen and Jake Bowers. forthcoming. &ldquo;Attributing
Effects to a Cluster Randomized Get-Out-The-Vote Campaign.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>


<h3>See Also</h3>

<p> Also see <code><a href="#topic+Match">Match</a></code> and <code><a href="#topic+MatchBalance">MatchBalance</a></code>,
<code><a href="#topic+GenMatch">GenMatch</a></code>, <code><a href="#topic+balanceUV">balanceUV</a></code>, <code><a href="#topic+ks.boot">ks.boot</a></code>
<code><a href="#topic+lalonde">lalonde</a></code>
</p>

<hr>
<h2 id='ks.boot'>Bootstrap Kolmogorov-Smirnov</h2><span id='topic+ks.boot'></span>

<h3>Description</h3>

<p>This function executes a bootstrap version of the univariate
Kolmogorov-Smirnov test which provides correct coverage even when
the distributions being compared are not entirely continuous.  Ties
are allowed with this test unlike the traditional Kolmogorov-Smirnov
test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks.boot(Tr, Co, nboots=1000, alternative = c("two.sided","less","greater"),
        print.level=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ks.boot_+3A_tr">Tr</code></td>
<td>
<p>A vector containing the treatment observations.</p>
</td></tr>
<tr><td><code id="ks.boot_+3A_co">Co</code></td>
<td>
<p>A vector containing the control observations.</p>
</td></tr>
<tr><td><code id="ks.boot_+3A_nboots">nboots</code></td>
<td>
<p>The number of bootstraps to be performed.  These are, in
fact, really Monte Carlo simulations which are preformed in order to
determine the proper p-value from the empiric.</p>
</td></tr>
<tr><td><code id="ks.boot_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of
'&quot;two.sided&quot;' (default), '&quot;less&quot;', or '&quot;greater&quot;'.  You can
specify just the initial letter.  See <code><a href="stats.html#topic+ks.test">ks.test</a></code> for details.</p>
</td></tr>
<tr><td><code id="ks.boot_+3A_print.level">print.level</code></td>
<td>
<p>If this is greater than 1, then the simulation count is
printed out while the simulations are being done.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>ks.boot.pvalue</code></td>
<td>
<p>The bootstrap p-value of the Kolmogorov-Smirnov test
for the hypothesis that the probability densities for both the
treated and control groups are the same.</p>
</td></tr>
<tr><td><code>ks</code></td>
<td>
<p>Return object from <code><a href="stats.html#topic+ks.test">ks.test</a></code>.</p>
</td></tr>
<tr><td><code>nboots</code></td>
<td>
<p>The number of bootstraps which were completed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011.  &quot;Multivariate and Propensity Score
Matching Software with Automated Balance Optimization.&rdquo;
<em>Journal of Statistical Software</em> 42(7): 1-52.
<a href="https://doi.org/10.18637/jss.v042.i07">doi:10.18637/jss.v042.i07</a>
</p>
<p>Diamond, Alexis and Jasjeet S. Sekhon. 2013. &quot;Genetic Matching for
Estimating Causal Effects: A General Multivariate Matching Method for
Achieving Balance in Observational Studies.&rdquo; <em>Review of
Economics and Statistics</em>.  95 (3): 932&ndash;945.
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>
</p>
<p>Abadie, Alberto.  2002.  &ldquo;Bootstrap Tests for Distributional Treatment
Effects in Instrumental Variable Models.&rdquo; <em>Journal of the
American Statistical Association</em>, 97:457 (March) 284-292.
</p>


<h3>See Also</h3>

<p> Also see <code><a href="#topic+summary.ks.boot">summary.ks.boot</a></code>,
<code><a href="#topic+qqstats">qqstats</a></code>, <code><a href="#topic+balanceUV">balanceUV</a></code>, <code><a href="#topic+Match">Match</a></code>,
<code><a href="#topic+GenMatch">GenMatch</a></code>, <code><a href="#topic+MatchBalance">MatchBalance</a></code>,
<code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>, <code><a href="#topic+lalonde">lalonde</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Replication of Dehejia and Wahba psid3 model
#
# Dehejia, Rajeev and Sadek Wahba. 1999.``Causal Effects in
# Non-Experimental Studies: Re-Evaluating the Evaluation of Training
# Programs.''Journal of the American Statistical Association 94 (448):
# 1053-1062.
#
data(lalonde)

#
# Estimate the propensity model
#
glm1  &lt;- glm(treat~age + I(age^2) + educ + I(educ^2) + black +
             hisp + married + nodegr + re74  + I(re74^2) + re75 + I(re75^2) +
             u74 + u75, family=binomial, data=lalonde)


#
#save data objects
#
X  &lt;- glm1$fitted
Y  &lt;- lalonde$re78
Tr  &lt;- lalonde$treat

#
# one-to-one matching with replacement (the "M=1" option).
# Estimating the treatment effect on the treated (the "estimand" option which defaults to 0).
#
rr  &lt;- Match(Y=Y,Tr=Tr,X=X,M=1);
summary(rr)

#
# Do we have balance on 1975 income after matching?
#
ks  &lt;- ks.boot(lalonde$re75[rr$index.treated], lalonde$re75[rr$index.control], nboots=500)
summary(ks)
</code></pre>

<hr>
<h2 id='lalonde'>Lalonde Dataset</h2><span id='topic+lalonde'></span>

<h3>Description</h3>

<p>Dataset used by Dehejia and Wahba (1999) to evaluate propensity score matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lalonde)</code></pre>


<h3>Format</h3>

<p>A data frame with 445 observations on the following 12 variables.
</p>

<dl>
<dt>age</dt><dd><p>age in years.</p>
</dd>
<dt>educ</dt><dd><p>years of schooling.</p>
</dd>
<dt>black</dt><dd><p>indicator variable for blacks.</p>
</dd>
<dt>hisp</dt><dd><p>indicator variable for Hispanics.</p>
</dd>
<dt>married</dt><dd><p>indicator variable for martial status.</p>
</dd>
<dt>nodegr</dt><dd><p>indicator variable for high school diploma.</p>
</dd>
<dt>re74</dt><dd><p>real earnings in 1974.</p>
</dd>
<dt>re75</dt><dd><p>real earnings in 1975.</p>
</dd>
<dt>re78</dt><dd><p>real earnings in 1978.</p>
</dd>
<dt>u74</dt><dd><p>indicator variable for earnings in 1974 being zero.</p>
</dd>
<dt>u75</dt><dd><p>indicator variable for earnings in 1975 being zero.</p>
</dd>
<dt>treat</dt><dd><p>an indicator variable for treatment status.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Two demos are provided which use this dataset.  The first,
<code>DehejiaWahba</code>, replicates one of the models from Dehejia and
Wahba (1999).  The second demo, <code>AbadieImbens</code>, replicates the
models produced by Abadie and Imbens in their Matlab code. 
Many of these models are found to produce good balance for the Lalonde
data.
</p>


<h3>References</h3>

<p>Dehejia, Rajeev and Sadek Wahba. 1999.&ldquo;Causal Effects in
Non-Experimental Studies: Re-Evaluating the
Evaluation of Training Programs.&rdquo; <em>Journal of the American Statistical
Association</em> 94 (448): 1053-1062.
</p>
<p>LaLonde, Robert. 1986.  &ldquo;Evaluating the Econometric Evaluations of
Training Programs.&rdquo;  <em>American Economic Review</em> 76:604-620.
</p>


<h3>See Also</h3>

<p> Also see <code><a href="#topic+Match">Match</a></code>, <code><a href="#topic+GenMatch">GenMatch</a></code>,
<code><a href="#topic+MatchBalance">MatchBalance</a></code>,
<code><a href="#topic+balanceUV">balanceUV</a></code>,
<code><a href="#topic+ks.boot">ks.boot</a></code>, <code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code> </p>

<hr>
<h2 id='Match'>Multivariate and Propensity Score Matching Estimator for Causal Inference</h2><span id='topic+Match'></span>

<h3>Description</h3>

<p><code>Match</code> implements a variety of algorithms for multivariate
matching including propensity score, Mahalanobis and inverse variance
matching.  The function is intended to be used in conjunction with the
<code>MatchBalance</code> function which determines the extent to which
<code>Match</code> has been able to achieve covariate balance.  In order to
do propensity score matching, one should estimate the propensity model
before calling <code>Match</code>, and then send <code>Match</code> the propensity
score to use.  <code>Match</code> enables a wide variety of matching
options including matching with or without replacement, bias
adjustment, different methods for handling ties, exact and caliper
matching, and a method for the user to fine tune the matches via a
general restriction matrix.  Variance estimators include the usual
Neyman standard errors, Abadie-Imbens standard errors, and robust
variances which do not assume a homogeneous causal effect. The
<code><a href="#topic+GenMatch">GenMatch</a></code> function can be used to <em>automatically
find balance</em> via a genetic search algorithm which determines the
optimal weight to give each covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Match(Y=NULL, Tr, X, Z = X, V = rep(1, length(Y)), estimand = "ATT", M = 1,
      BiasAdjust = FALSE, exact = NULL, caliper = NULL, replace=TRUE, ties=TRUE,
      CommonSupport=FALSE,Weight = 1, Weight.matrix = NULL, weights = NULL,
      Var.calc = 0, sample = FALSE, restrict=NULL, match.out = NULL,
      distance.tolerance = 1e-05, tolerance=sqrt(.Machine$double.eps),
      version="standard")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Match_+3A_y">Y</code></td>
<td>
<p> A vector containing the outcome of interest.
Missing values are not allowed.  An outcome vector is not required
because the matches generated will be the same regardless of the
outcomes.  Of course, without any outcomes no causal effect
estimates will be produced, only a matched dataset. </p>
</td></tr>
<tr><td><code id="Match_+3A_tr">Tr</code></td>
<td>
<p> A vector indicating the observations which are
in the treatment regime and those which are not.  This can either be a
logical vector or a real vector where 0 denotes control and 1 denotes
treatment.</p>
</td></tr>
<tr><td><code id="Match_+3A_x">X</code></td>
<td>
<p> A matrix containing the variables we wish to match on.
This matrix may contain the actual observed covariates or the
propensity score or a combination of both. All columns of this
matrix must have positive variance or <code>Match</code> will return an
error.</p>
</td></tr>
<tr><td><code id="Match_+3A_z">Z</code></td>
<td>
<p> A matrix containing the covariates for which we wish to make
bias adjustments.</p>
</td></tr>
<tr><td><code id="Match_+3A_v">V</code></td>
<td>
<p> A matrix containing the covariates for which the variance
of the causal effect may vary. Also see the <code>Var.calc</code> option,
which takes precedence.</p>
</td></tr>
<tr><td><code id="Match_+3A_estimand">estimand</code></td>
<td>
<p> A character string for the estimand.  The default
estimand is &quot;ATT&quot;, the sample average treatment effect for the
treated. &quot;ATE&quot; is the sample average treatment effect, and
&quot;ATC&quot; is the sample average treatment effect for the controls.</p>
</td></tr>
<tr><td><code id="Match_+3A_m">M</code></td>
<td>
<p>A scalar for the number of matches which should be
found. The default is one-to-one matching. Also see the <code>ties</code>
option.</p>
</td></tr>
<tr><td><code id="Match_+3A_biasadjust">BiasAdjust</code></td>
<td>
<p> A logical scalar for whether regression adjustment
should be used. See the <code>Z</code> matrix.</p>
</td></tr>
<tr><td><code id="Match_+3A_exact">exact</code></td>
<td>
<p> A logical scalar or vector for whether exact matching
should be done. If a logical scalar is provided, that logical value is
applied to all covariates in
<code>X</code>.  If a logical vector is provided, a logical value should
be provided for each covariate in <code>X</code>. Using a logical vector
allows the user to specify exact matching for some but not other
variables.  When exact matches are not found, observations are
dropped.  <code>distance.tolerance</code> determines what is considered to be an
exact match. The <code>exact</code> option takes precedence over the
<code>caliper</code> option.</p>
</td></tr>
<tr><td><code id="Match_+3A_caliper">caliper</code></td>
<td>
<p> A scalar or vector denoting the caliper(s) which
should be used when matching.  A caliper is the distance which is
acceptable for any match.  Observations which are outside of the
caliper are dropped. If a scalar caliper is provided, this caliper is
used for all covariates in <code>X</code>.  If a vector of calipers is
provided, a caliper value should be provided for each covariate in
<code>X</code>. The caliper is interpreted to be in standardized units.  For
example, <code>caliper=.25</code> means that all matches not equal to or
within .25 standard deviations of each covariate in <code>X</code> are
dropped. Note that dropping observations generally changes the
quantity being estimated.</p>
</td></tr>
<tr><td><code id="Match_+3A_replace">replace</code></td>
<td>
<p>A logical flag for whether matching should be done with
replacement.  Note that if <code>FALSE</code>, the order of matches
generally matters.  Matches will be found in the same order as the
data are sorted.  Thus, the match(es) for the first observation will
be found first, the match(es) for the second observation will be found second, etc.
Matching without replacement will generally increase bias.
Ties are randomly broken when <code>replace==FALSE</code>
&mdash;see the <code>ties</code> option for details.</p>
</td></tr>
<tr><td><code id="Match_+3A_ties">ties</code></td>
<td>
<p>A logical flag for whether ties should be handled deterministically.  By
default <code>ties==TRUE</code>. If, for example, one treated observation
matches more than one control observation, the matched dataset will
include the multiple matched control observations and the matched data
will be weighted to reflect the multiple matches.  The sum of the
weighted observations will still equal the original number of
observations. If <code>ties==FALSE</code>, ties will be randomly broken.
<em>If the dataset is large and there are many ties, setting
<code>ties=FALSE</code> often results in a large speedup.</em> Whether two
potential matches are close enough to be considered tied, is
controlled by the <code>distance.tolerance</code>
option.</p>
</td></tr>
<tr><td><code id="Match_+3A_commonsupport">CommonSupport</code></td>
<td>
<p>This logical flag implements the usual procedure
by which observations outside of the common support of a variable
(usually the propensity score) across treatment and control groups are
discarded.  The <code>caliper</code> option is to
be preferred to this option because <code>CommonSupport</code>, consistent
with the literature, only drops <em>outliers</em> and leaves
<em>inliers</em> while the caliper option drops both.
If <code>CommonSupport==TRUE</code>, common support will be enforced on
the first variable in the <code>X</code> matrix.  Note that dropping
observations generally changes the quantity being estimated. Use of
this option renders it impossible to use the returned
objects <code>index.treated</code> and <code>index.control</code> to
reconstruct the matched dataset.  The returned object <code>mdata</code>
will, however, still contain the matched dataset.  Seriously, don't
use this option; use the <code>caliper</code> option instead.</p>
</td></tr>
<tr><td><code id="Match_+3A_weight">Weight</code></td>
<td>
<p> A scalar for the type of weighting scheme the matching
algorithm should use when weighting each of the covariates in
<code>X</code>.  The default value of 1 denotes that weights are equal to
the inverse of the variances. 2 denotes the Mahalanobis distance
metric, and 3 denotes that the user will supply a weight matrix
(<code>Weight.matrix</code>).  Note that if the user supplies a
<code>Weight.matrix</code>, <code>Weight</code> will be automatically set to be
equal to 3.</p>
</td></tr>
<tr><td><code id="Match_+3A_weight.matrix">Weight.matrix</code></td>
<td>
<p> This matrix denotes the weights the matching
algorithm uses when weighting each of the covariates in <code>X</code>&mdash;see
the <code>Weight</code> option. This square matrix should have as many
columns as the number of columns of the <code>X</code> matrix. This matrix
is usually provided by a call to the <code><a href="#topic+GenMatch">GenMatch</a></code> function
which finds the optimal weight each variable should be given so as to
achieve balance on the covariates. <br />
</p>
<p>For most uses, this matrix has zeros in the off-diagonal
cells.  This matrix can be used to weight some variables more than
others.  For
example, if <code>X</code> contains three variables and we want to
match as best as we can on the first, the following would work well:
<br />
<code>&gt; Weight.matrix &lt;- diag(3)</code><br />
<code>&gt; Weight.matrix[1,1] &lt;- 1000/var(X[,1])</code> <br />
<code>&gt; Weight.matrix[2,2] &lt;- 1/var(X[,2])</code> <br />
<code>&gt; Weight.matrix[3,3] &lt;- 1/var(X[,3])</code> <br />
This code changes the weights implied by the
inverse of the variances by multiplying the first variable by a 1000
so that it is highly weighted.  In order to enforce exact matching
see the <code>exact</code> and <code>caliper</code> options.</p>
</td></tr>
<tr><td><code id="Match_+3A_weights">weights</code></td>
<td>
<p> A vector the same length as <code>Y</code> which
provides observation specific weights.</p>
</td></tr>
<tr><td><code id="Match_+3A_var.calc">Var.calc</code></td>
<td>
<p> A scalar for the variance estimate
that should be used.  By default <code>Var.calc=0</code> which means that
homoscedasticity is assumed.  For values of  <code>Var.calc &gt; 0</code>,
robust variances are calculated using <code>Var.calc</code> matches. </p>
</td></tr>
<tr><td><code id="Match_+3A_sample">sample</code></td>
<td>
<p> A logical flag for whether the population or sample
variance is returned. </p>
</td></tr>
<tr><td><code id="Match_+3A_distance.tolerance">distance.tolerance</code></td>
<td>
<p>This is a scalar which is used to determine
if distances between two observations are different from zero.  Values
less than <code>distance.tolerance</code> are deemed to be equal to zero.
This option can be used to perform a type of optimal matching</p>
</td></tr>
<tr><td><code id="Match_+3A_tolerance">tolerance</code></td>
<td>
<p> This is a scalar which is used to determine
numerical tolerances.  This option is used by numerical routines
such as those used to determine if a matrix is singular.</p>
</td></tr>
<tr><td><code id="Match_+3A_restrict">restrict</code></td>
<td>
<p>A matrix which restricts the possible matches.  This
matrix has one row for each restriction and three
columns.  The first two columns contain the two observation numbers
which are to be restricted (for example 4 and 20), and the third
column is the restriction imposed on the observation-pair.
Negative numbers in the third column imply that the two observations
cannot be matched under any circumstances, and positive numbers are
passed on as the distance between the two observations for the
matching algorithm.  The most commonly used positive restriction is
<code>0</code> which implies that the two observations will always
be matched.  <br />
</p>
<p>Exclusion restrictions are even more common.  For example, if we want
to exclude the observation pair 4 and 20 and
the pair 6 and 55 from being matched, the restrict matrix would be:
<code>restrict=rbind(c(4,20,-1),c(6,55,-1))</code></p>
</td></tr>
<tr><td><code id="Match_+3A_match.out">match.out</code></td>
<td>
<p> The return object from a previous call to
<code>Match</code>.  If this object is provided, then <code>Match</code> will
use the matches found by the previous invocation of the function.
Hence, <code>Match</code> will run faster.  This is
useful when the treatment does not vary across calls to
<code>Match</code> and one wants to use the same set of matches as found
before.  This often occurs when one is trying to estimate the causal
effect of the same treatment (<code>Tr</code>) on different outcomes
(<code>Y</code>). When using this option, be careful to use the same
arguments as used for the previous invocation of <code>Match</code> unless
you know exactly what you are doing.</p>
</td></tr>
<tr><td><code id="Match_+3A_version">version</code></td>
<td>
<p>The version of the code to be used.  The &quot;fast&quot; C/C++
version of the code does not calculate Abadie-Imbens standard errors.
Additional speed can be obtained by setting <code>ties=FALSE</code> or
<code>replace=FALSE</code> if the dataset is large and/or has many ties.
The &quot;legacy&quot; version of the code does not make a call to an optimized
C/C++ library and is included only for historical compatibility.  The
&quot;fast&quot; version of the code is significantly faster than the &quot;standard&quot;
version for large datasets, and the &quot;legacy&quot; version is much slower
than either of the other two.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be used in conjunction with the
<code>MatchBalance</code> function which checks if the results of this
function have actually achieved balance.  The results of this function
can be summarized by a call to the <code><a href="#topic+summary.Match">summary.Match</a></code>
function. If one wants to do propensity score matching, one should estimate the
propensity model before calling <code>Match</code>, and then place the
fitted values in the <code>X</code> matrix&mdash;see the provided example.  <br />
</p>
<p>The <code><a href="#topic+GenMatch">GenMatch</a></code> function can be used to <em>automatically
find balance</em> by the use of a genetic search algorithm which determines
the optimal weight to give each covariate. The object returned by
<code><a href="#topic+GenMatch">GenMatch</a></code> can be supplied to the <code>Weight.matrix</code>
option of <code>Match</code> to obtain estimates.<br />
</p>
<p><code>Match</code> is often much faster with large datasets if
<code>ties=FALSE</code> or <code>replace=FALSE</code>&mdash;i.e., if matching is done
by randomly breaking ties or without replacement.  Also see the
<code><a href="#topic+Matchby">Matchby</a></code> function.  It provides a wrapper for
<code>Match</code> which is much faster for large datasets when it can be
used.<br />
</p>
<p>Three demos are included: <code>GerberGreenImai</code>, <code>DehejiaWahba</code>,
and <code>AbadieImbens</code>.  These can be run by calling the
<code><a href="utils.html#topic+demo">demo</a></code> function such as by <code>demo(DehejiaWahba)</code>. <br />
</p>


<h3>Value</h3>

<table>
<tr><td><code>est</code></td>
<td>
<p>The estimated average causal effect.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The Abadie-Imbens standard error.  This standard error has
correct coverage if <code>X</code> consists of either covariates or a known
propensity score because it takes into account the uncertainty of the
matching procedure.  If an estimated propensity score is used, the
uncertainty involved in its estimation is not accounted for although
the uncertainty of the matching procedure itself still is.</p>
</td></tr>
<tr><td><code>est.noadj</code></td>
<td>
<p>The estimated average causal effect without any
<code>BiasAdjust</code>.  If <code>BiasAdjust</code> is not requested, this is the
same as <code>est</code>.</p>
</td></tr>
<tr><td><code>se.standard</code></td>
<td>
<p>The usual standard error.  This is the standard error
calculated on the matched data using the usual method of calculating
the difference of means (between treated and control) weighted by the
observation weights provided by <code>weights</code>.  Note that the
standard error provided by <code>se</code> takes into account the uncertainty
of the matching procedure while <code>se.standard</code> does not.  Neither
<code>se</code> nor <code>se.standard</code> take into account the uncertainty of
estimating a propensity score.  <code>se.standard</code> does
not take into account any <code>BiasAdjust</code>.  Summary of both types
of standard error results can be requested by setting the
<code>full=TRUE</code> flag when using the <code><a href="#topic+summary.Match">summary.Match</a></code>
function on the object returned by <code>Match</code>.</p>
</td></tr>
<tr><td><code>se.cond</code></td>
<td>
<p>The conditional standard error.  The practitioner
should not generally use this.</p>
</td></tr>
<tr><td><code>mdata</code></td>
<td>
<p>A list which contains the matched datasets produced by
<code>Match</code>.  Three datasets are included in this list: <code>Y</code>,
<code>Tr</code> and <code>X</code>.</p>
</td></tr>
<tr><td><code>index.treated</code></td>
<td>
<p>A vector containing the observation numbers from
the original dataset for the treated observations in the
matched dataset.  This index in conjunction with <code>index.control</code>
can be used to recover the matched dataset produced by
<code>Match</code>.  For example, the <code>X</code> matrix used by <code>Match</code>
can be recovered by
<code>rbind(X[index.treated,],X[index.control,])</code>. The user should
generally just examine the output of <code>mdata</code>.</p>
</td></tr>
<tr><td><code>index.control</code></td>
<td>
<p>A vector containing the observation numbers from
the original data for the control observations in the
matched data.  This index in conjunction with <code>index.treated</code>
can be used to recover the matched dataset produced by
<code>Match</code>.  For example, the <code>X</code> matrix used by <code>Match</code>
can be recovered by
<code>rbind(X[index.treated,],X[index.control,])</code>. The user should
generally just examine the output of <code>mdata</code>.</p>
</td></tr>
<tr><td><code>index.dropped</code></td>
<td>
<p>A vector containing the observation numbers from
the original data which were dropped (if any) in the matched dataset
because of various options such as <code>caliper</code> and
<code>exact</code>.  If no observations were dropped, this
index will be <code>NULL</code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>A vector of weights.  There is one weight for each
matched-pair in the matched dataset.  If all of the observations had a
weight of 1 on input, then each matched-pair will have a weight of 1
on output if there are no ties.</p>
</td></tr>
<tr><td><code>orig.nobs</code></td>
<td>
<p>The original number of observations in the dataset.</p>
</td></tr>
<tr><td><code>orig.wnobs</code></td>
<td>
<p>The original number of weighted observations in the
dataset.</p>
</td></tr>
<tr><td><code>orig.treated.nobs</code></td>
<td>
<p>The original number of treated observations (unweighted).</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>The number of observations in the matched dataset.</p>
</td></tr>
<tr><td><code>wnobs</code></td>
<td>
<p>The number of weighted observations in the matched dataset.</p>
</td></tr>
<tr><td><code>caliper</code></td>
<td>
<p>The <code>caliper</code> which was used.</p>
</td></tr>
<tr><td><code>ecaliper</code></td>
<td>
<p>The size of the enforced caliper on the scale of the
<code>X</code> variables.  This object has the same length as the number of
covariates in <code>X</code>.</p>
</td></tr>
<tr><td><code>exact</code></td>
<td>
<p>The value of the <code>exact</code> function argument.</p>
</td></tr>
<tr><td><code>ndrops</code></td>
<td>
<p>The number of weighted observations which were dropped
either because of caliper or exact matching.  This number, unlike
<code>ndrops.matches</code>, takes into account observation specific
weights which the user may have provided via the <code>weights</code>
argument.</p>
</td></tr>
<tr><td><code>ndrops.matches</code></td>
<td>
<p>The number of matches which were dropped either because of
caliper or exact matching.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011.  &quot;Multivariate and Propensity Score
Matching Software with Automated Balance Optimization.&rdquo;
<em>Journal of Statistical Software</em> 42(7): 1-52.
<a href="https://doi.org/10.18637/jss.v042.i07">doi:10.18637/jss.v042.i07</a>
</p>
<p>Diamond, Alexis and Jasjeet S. Sekhon. 2013. &quot;Genetic
Matching for Estimating Causal Effects: A General Multivariate
Matching Method for Achieving Balance in Observational Studies.&rdquo;
<em>Review of Economics and Statistics</em>. 95 (3): 932&ndash;945.
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>
</p>
<p>Abadie, Alberto and Guido Imbens. 2006.
&ldquo;Large Sample Properties of Matching Estimators for Average
Treatment Effects.&rdquo; <em>Econometrica</em> 74(1): 235-267.
</p>
<p>Imbens, Guido. 2004. Matching Software for Matlab and
Stata.
</p>


<h3>See Also</h3>

<p> Also see <code><a href="#topic+summary.Match">summary.Match</a></code>,
<code><a href="#topic+GenMatch">GenMatch</a></code>,
<code><a href="#topic+MatchBalance">MatchBalance</a></code>,
<code><a href="#topic+Matchby">Matchby</a></code>,
<code><a href="#topic+balanceUV">balanceUV</a></code>,
<code><a href="#topic+qqstats">qqstats</a></code>, <code><a href="#topic+ks.boot">ks.boot</a></code>,
<code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>, <code><a href="#topic+lalonde">lalonde</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Replication of Dehejia and Wahba psid3 model
#
# Dehejia, Rajeev and Sadek Wahba. 1999.``Causal Effects in
# Non-Experimental Studies: Re-Evaluating the Evaluation of Training
# Programs.''Journal of the American Statistical Association 94 (448):
# 1053-1062.

data(lalonde)

#
# Estimate the propensity model
#
glm1  &lt;- glm(treat~age + I(age^2) + educ + I(educ^2) + black +
             hisp + married + nodegr + re74  + I(re74^2) + re75 + I(re75^2) +
             u74 + u75, family=binomial, data=lalonde)


#
#save data objects
#
X  &lt;- glm1$fitted
Y  &lt;- lalonde$re78
Tr  &lt;- lalonde$treat

#
# one-to-one matching with replacement (the "M=1" option).
# Estimating the treatment effect on the treated (the "estimand" option defaults to ATT).
#
rr  &lt;- Match(Y=Y, Tr=Tr, X=X, M=1);
summary(rr)

# Let's check the covariate balance
# 'nboots' is set to small values in the interest of speed.
# Please increase to at least 500 each for publication quality p-values.
mb  &lt;- MatchBalance(treat~age + I(age^2) + educ + I(educ^2) + black +
                    hisp + married + nodegr + re74  + I(re74^2) + re75 + I(re75^2) +
                    u74 + u75, data=lalonde, match.out=rr, nboots=10)
</code></pre>

<hr>
<h2 id='MatchBalance'>Tests for Univariate and Multivariate Balance</h2><span id='topic+MatchBalance'></span>

<h3>Description</h3>

<p>This function provides a variety of balance statistics useful for
determining if balance exists in any unmatched dataset and
in matched datasets produced by the <code><a href="#topic+Match">Match</a></code>
function.  Matching is performed by the <code><a href="#topic+Match">Match</a></code> function,
and <code>MatchBalance</code> is used to determine if <code><a href="#topic+Match">Match</a></code>
was successful in achieving balance on the observed covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatchBalance(formul, data = NULL, match.out = NULL, ks = TRUE,
             nboots=500, weights=NULL, digits=5, paired=TRUE, print.level=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatchBalance_+3A_formul">formul</code></td>
<td>

<p>This formula does <em>not</em> estimate any model.  The formula is
simply an efficient way to use the R modeling language to list the
variables we wish to obtain univariate balance statistics for.  The
dependent variable in the formula is usually the treatment
indicator.  One should include many functions of the observed
covariates.  Generally, one should request balance statistics on
more higher-order terms and interactions than were used to conduct
the matching itself.</p>
</td></tr>
<tr><td><code id="MatchBalance_+3A_data">data</code></td>
<td>
<p> A data frame which contains all of the variables in the
formula.  If a data frame is not provided, the variables are
obtained via lexical scoping.</p>
</td></tr>
<tr><td><code id="MatchBalance_+3A_match.out">match.out</code></td>
<td>
<p> The output object from the <code><a href="#topic+Match">Match</a></code>
function.  If this output is included, <code><a href="#topic+MatchBalance">MatchBalance</a></code> will provide
balance statistics for both before and after matching. Otherwise
balance statistics will only be reported for the raw unmatched
data.</p>
</td></tr>
<tr><td><code id="MatchBalance_+3A_ks">ks</code></td>
<td>
<p> A logical flag for whether the univariate bootstrap
Kolmogorov-Smirnov (KS) test should be calculated.  If the ks option
is set to true, the univariate KS test is calculated for all
non-dichotomous variables.  The bootstrap KS test is consistent even
for non-continuous variables.  See <code><a href="#topic+ks.boot">ks.boot</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="MatchBalance_+3A_weights">weights</code></td>
<td>
<p>An optional vector of observation specific weights.</p>
</td></tr>
<tr><td><code id="MatchBalance_+3A_nboots">nboots</code></td>
<td>
<p>The number of bootstrap samples to be run.  If zero, no
bootstraps are done.  Bootstrapping is highly recommended because
the bootstrapped Kolmogorov-Smirnov test provides correct coverage
even when the distributions being compared are not continuous.  At
least 500 <code>nboots</code> (preferably 1000) are recommended for
publication quality p-values.</p>
</td></tr>
<tr><td><code id="MatchBalance_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits that should be
displayed.</p>
</td></tr>
<tr><td><code id="MatchBalance_+3A_paired">paired</code></td>
<td>
<p>A flag for whether the paired <code><a href="stats.html#topic+t.test">t.test</a></code> should be
used after matching.  Regardless of the value of this option, an
unpaired <code><a href="stats.html#topic+t.test">t.test</a></code> is done for the unmatched data because
it is assumed that the unmatched data were not generated by a paired
experiment.</p>
</td></tr>
<tr><td><code id="MatchBalance_+3A_print.level">print.level</code></td>
<td>
<p>The amount of printing to be done.  If zero, there is
no printing.  If one, the results are summarized.  If
two, details of the computations are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to determine if there is balance in the pre-
and/or post-matching datasets.  Difference of means between treatment
and control groups are provided as well as a variety of summary
statistics for the empirical CDF (eCDF) and empirical-QQ (eQQ) plot
between the two groups.  The eCDF results are the standardized mean,
median and maximum differences in the empirical CDF. The eQQ results
are summaries of the raw differences in the empirical-QQ plot.<br />
</p>
<p>Two univariate tests are also provided: the t-test and the bootstrap
Kolmogorov-Smirnov (KS) test. These tests should not be treated as
hypothesis tests in the usual fashion because we wish to maximize
balance without limit.  The bootstrap KS test is highly
recommended (see the <code>ks</code> and <code>nboots</code> options) because the
bootstrap KS is consistent even for non-continuous distributions.
Before matching, the two sample t-test is used; after matching, the
paired t-test is used.<br />
</p>
<p>Two multivariate tests are provided.  The KS and Chi-Square null
deviance tests.  The KS test is to be preferred over the Chi-Square
test because the Chi-Square test is not testing the relevant
hypothesis.  The null hypothesis for the KS test is equal balance
in the estimated probabilities between treated and control.  The null
hypothesis for the Chi-Square test, however, is all of the
parameters being insignificant; a comparison of residual versus null
deviance.  If the covariates being considered are discrete, this KS
test is asymptotically nonparametric as long as the logit model does
not produce zero parameter estimates.
</p>
<p><code>NA</code>'s are handled by the <code><a href="stats.html#topic+na.action">na.action</a></code> option.  But it
is highly recommended that <code>NA</code>'s not simply be deleted, but
one should check to make sure that missingness is balanced.
</p>


<h3>Value</h3>

<table>
<tr><td><code>BeforeMatching</code></td>
<td>
<p>A list containing the before matching univariate
balance statistics. That is, a list containing the results of
the  <code><a href="#topic+balanceUV">balanceUV</a></code> function applied to all of the
covariates described in <code>formul</code>.  Note that the univariate
test results for all of the variables in <code>formul</code> are printed
if <code>verbose &gt; 0</code>.</p>
</td></tr>
<tr><td><code>AfterMatching</code></td>
<td>
<p>A list containing the after matching univariate
balance statistics. That is, a list containing the results of
the  <code><a href="#topic+balanceUV">balanceUV</a></code> function applied to all of the
covariates described in <code>formul</code>.  Note that the univariate
test results for all of the variables in <code>formul</code> are printed
if <code>verbose &gt; 0</code>.  This object is <code>NULL</code>, if no matched
dataset was provided.</p>
</td></tr>
<tr><td><code>BMsmallest.p.value</code></td>
<td>
<p>The smallest p.value found across all of the
<em>before</em> matching balance tests (including t-tests and KS-tests.</p>
</td></tr>
<tr><td><code>BMsmallestVarName</code></td>
<td>
<p>The name of the variable with the
<code>BMsmallest.p.value</code> (a vector in case of ties).</p>
</td></tr>
<tr><td><code>BMsmallestVarNumber</code></td>
<td>
<p>The number of the variable with the
<code>BMsmallest.p.value</code> (a vector in case of ties).</p>
</td></tr>
<tr><td><code>AMsmallest.p.value</code></td>
<td>
<p>The smallest p.value found across all of the
<em>after</em> matching balance tests (including t-tests and
KS-tests.</p>
</td></tr>
<tr><td><code>AMsmallestVarName</code></td>
<td>
<p>The name of the variable with the
<code>AMsmallest.p.value</code> (a vector in case of ties).</p>
</td></tr>
<tr><td><code>AMsmallestVarNumber</code></td>
<td>
<p>The number of the variable with the
<code>AMsmallest.p.value</code> (a vector in case of ties).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011.  &quot;Multivariate and Propensity Score
Matching Software with Automated Balance Optimization.&rdquo;
<em>Journal of Statistical Software</em> 42(7): 1-52.
<a href="https://doi.org/10.18637/jss.v042.i07">doi:10.18637/jss.v042.i07</a>
</p>
<p>Diamond, Alexis and Jasjeet S. Sekhon. 2013. &quot;Genetic
Matching for Estimating Causal Effects: A General Multivariate
Matching Method for Achieving Balance in Observational Studies.&rdquo;
<em>Review of Economics and Statistics</em>.  95 (3): 932&ndash;945.
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>
</p>
<p>Abadie, Alberto.  2002.  &ldquo;Bootstrap Tests for Distributional Treatment
Effects in Instrumental Variable Models.&rdquo; <em>Journal of the
American Statistical Association</em>, 97:457 (March) 284-292.
</p>
<p>Hall, Peter. 1992. <em>The Bootstrap and Edgeworth Expansion</em>.  New
York: Springer-Verlag.
</p>
<p>Wilcox, Rand R. 1997. <em>Introduction to Robust Estimation</em>.  San
Diego, CA: Academic Press.
</p>
<p>William J. Conover (1971), <em>Practical nonparametric statistics</em>.
New York: John Wiley &amp; Sons. Pages 295-301 (one-sample
&quot;Kolmogorov&quot; test), 309-314 (two-sample &quot;Smirnov&quot; test).
</p>
<p>Shao, Jun and Dongsheng Tu. 1995. <em>The Jackknife and Bootstrap</em>.
New York: Springer-Verlag.
</p>


<h3>See Also</h3>

<p>Also see <code><a href="#topic+Match">Match</a></code>, <code><a href="#topic+GenMatch">GenMatch</a></code>,
<code><a href="#topic+balanceUV">balanceUV</a></code>, <code><a href="#topic+qqstats">qqstats</a></code>, <code><a href="#topic+ks.boot">ks.boot</a></code>,
<code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>, <code><a href="#topic+lalonde">lalonde</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Replication of Dehejia and Wahba psid3 model
#
# Dehejia, Rajeev and Sadek Wahba. 1999.``Causal Effects in
# Non-Experimental Studies: Re-Evaluating the Evaluation of Training
# Programs.''Journal of the American Statistical Association 94 (448):
# 1053-1062.

data(lalonde)

#
# Estimate the propensity model
#
glm1  &lt;- glm(treat~age + I(age^2) + educ + I(educ^2) + black +
             hisp + married + nodegr + re74  + I(re74^2) + re75 + I(re75^2) +
             u74 + u75, family=binomial, data=lalonde)


#
#save data objects
#
X  &lt;- glm1$fitted
Y  &lt;- lalonde$re78
Tr  &lt;- lalonde$treat

#
# one-to-one matching with replacement (the "M=1" option).
# Estimating the treatment effect on the treated (the "estimand" option which defaults to 0).
#
rr  &lt;- Match(Y=Y,Tr=Tr,X=X,M=1);

#Let's summarize the output
summary(rr)

# Let's check the covariate balance
# 'nboots' is set to small values in the interest of speed.
# Please increase to at least 500 each for publication quality p-values.
mb  &lt;- MatchBalance(treat~age + I(age^2) + educ + I(educ^2) + black +
                    hisp + married + nodegr + re74  + I(re74^2) + re75 + I(re75^2) +
                    u74 + u75, data=lalonde, match.out=rr, nboots=10)
</code></pre>

<hr>
<h2 id='Matchby'>Grouped Multivariate and Propensity Score Matching</h2><span id='topic+Matchby'></span>

<h3>Description</h3>

<p>This function is a wrapper for the <code><a href="#topic+Match">Match</a></code> function which
separates the matching problem into subgroups defined by a factor.
This is equivalent to conducting exact matching on each level of a factor.
Matches within each level are found as determined by the
usual matching options.  This function is much faster for large
datasets than the <code><a href="#topic+Match">Match</a></code> function itself.  For additional
speed, consider doing matching without replacement&mdash;see the
<code>replace</code> option.  This function is more limited than the
<code><a href="#topic+Match">Match</a></code> function.  For example, <code>Matchby</code> cannot be
used if the user wishes to provide observation specific weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Matchby(Y, Tr, X, by, estimand = "ATT", M = 1, ties=FALSE, replace=TRUE,
        exact = NULL, caliper = NULL, AI=FALSE, Var.calc=0,
        Weight = 1, Weight.matrix = NULL, distance.tolerance = 1e-05,
        tolerance = sqrt(.Machine$double.eps), print.level=1, version="Matchby", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matchby_+3A_y">Y</code></td>
<td>
<p> A vector containing the outcome of interest. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_tr">Tr</code></td>
<td>
<p> A vector indicating the observations which are
in the treatment regime and those which are not.  This can either be a
logical vector or a real vector where 0 denotes control and 1 denotes
treatment.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_x">X</code></td>
<td>
<p> A matrix containing the variables we wish to match on.
This matrix may contain the actual observed covariates or the
propensity score or a combination of both.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_by">by</code></td>
<td>
<p>A &quot;factor&quot; in the sense that <code>as.factor(by)</code> defines the
grouping, or a list of such factors in which case their
interaction is used for the grouping.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_estimand">estimand</code></td>
<td>
<p> A character string for the estimand.  The default
estimand is &quot;ATT&quot;, the sample average treatment effect for the
treated. &quot;ATE&quot; is the sample average treatment effect (for all), and
&quot;ATC&quot; is the sample average treatment effect for the controls.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_m">M</code></td>
<td>
<p> A scalar for the number of matches which should be
found. The default is one-to-one matching. Also see the
<code>ties</code> option.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_ties">ties</code></td>
<td>
<p>A logical flag for whether ties should be handled
deterministically.  By default <code>ties==TRUE</code>. If, for example, one
treated observation matches more than one control observation, the
matched dataset will include the multiple matched control observations
and the matched data will be weighted to reflect the multiple matches.
The sum of the weighted observations will still equal the original
number of observations. If <code>ties==FALSE</code>, ties will be randomly
broken.  <em>If the dataset is large and there are many ties,
setting <code>ties=FALSE</code> often results in a large speedup.</em> Whether
two potential matches are close enough to be considered tied, is
controlled by the <code>distance.tolerance</code> option.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_replace">replace</code></td>
<td>
<p>Whether matching should be done with replacement.  Note
that if <code>FALSE</code>, the order of matches generally matters.  Matches
will be found in the same order as the data is sorted.  Thus, the
match(es) for the first observation will be found first and then for
the second etc. Matching without replacement will generally increase
bias so it is not recommended.  <em>But if the dataset is large and
there are many potential matches, setting <code>replace=false</code> often
results in a large speedup and negligible or no bias.</em> Ties are
randomly broken when <code>replace==FALSE</code>&mdash;see the <code>ties</code>
option for details.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_exact">exact</code></td>
<td>
<p> A logical scalar or vector for whether exact matching
should be done.  If a logical scalar is provided, that logical value is
applied to all covariates of
<code>X</code>.  If a logical vector is provided, a logical value should
be provided for each covariate in <code>X</code>. Using a logical vector
allows the user to specify exact matching for some but not other
variables.  When exact matches are not found, observations are
dropped.  <code>distance.tolerance</code> determines what is considered to be an
exact match. The <code>exact</code> option takes precedence over the
<code>caliper</code> option.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_caliper">caliper</code></td>
<td>
<p> A scalar or vector denoting the caliper(s) which
should be used when matching.  A caliper is the distance which is
acceptable for any match.  Observations which are outside of the
caliper are dropped. If a scalar caliper is provided, this caliper is
used for all covariates in <code>X</code>.  If a vector of calipers is
provided, a caliper value should be provide for each covariate in
<code>X</code>. The caliper is interpreted to be in standardized units.  For
example, <code>caliper=.25</code> means that all matches not equal to or
within .25 standard deviations of each covariate in <code>X</code> are
dropped.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_ai">AI</code></td>
<td>
<p>A logical flag for if the Abadie-Imbens standard error
should be calculated. It is computationally expensive to calculate
with large datasets. <code>Matchby</code> can only calculate AI SEs for ATT.
To calculate AI errors with other estimands, please use the
<code><a href="#topic+Match">Match</a></code> function.  See the <code>Var.calc</code> option if one
does not want to assume homoscedasticity.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_var.calc">Var.calc</code></td>
<td>
<p>A scalar for the variance estimate
that should be used.  By default <code>Var.calc=0</code> which means that
homoscedasticity is assumed.  For values of  <code>Var.calc &gt; 0</code>,
robust variances are calculated using <code>Var.calc</code> matches.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_weight">Weight</code></td>
<td>
<p> A scalar for the type of
weighting scheme the matching algorithm should use when weighting
each of the covariates in <code>X</code>.  The default value of
1 denotes that weights are equal to the inverse of the variances. 2
denotes the Mahalanobis distance metric, and 3 denotes
that the user will supply a weight matrix (<code>Weight.matrix</code>).  Note that
if the user supplies a <code>Weight.matrix</code>, <code>Weight</code> will be automatically
set to be equal to 3.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_weight.matrix">Weight.matrix</code></td>
<td>
<p> This matrix denotes the weights the matching
algorithm uses when weighting each of the covariates in <code>X</code>&mdash;see
the <code>Weight</code> option. This square matrix should have as many
columns as the number of columns of the <code>X</code> matrix. This matrix
is usually provided by a call to the <code><a href="#topic+GenMatch">GenMatch</a></code> function
which finds the optimal weight each variable should be given so as to
achieve balance on the covariates. <br />
</p>
<p>For most uses, this matrix has zeros in the off-diagonal
cells.  This matrix can be used to weight some variables more than
others.  For
example, if <code>X</code> contains three variables and we want to
match as best as we can on the first, the following would work well:
<br />
<code>&gt; Weight.matrix &lt;- diag(3)</code><br />
<code>&gt; Weight.matrix[1,1] &lt;- 1000/var(X[,1])</code> <br />
<code>&gt; Weight.matrix[2,2] &lt;- 1/var(X[,2])</code> <br />
<code>&gt; Weight.matrix[3,3] &lt;- 1/var(X[,3])</code> <br />
This code changes the weights implied by the
inverse of the variances by multiplying the first variable by a 1000
so that it is highly weighted.  In order to enforce exact matching
see the <code>exact</code> and <code>caliper</code> options.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_distance.tolerance">distance.tolerance</code></td>
<td>
<p>This is a scalar which is used to determine if distances
between two observations are different from zero.  Values less than
<code>distance.tolerance</code> are deemed to be equal to zero.  This
option can be used to perform a type of optimal matching</p>
</td></tr>
<tr><td><code id="Matchby_+3A_tolerance">tolerance</code></td>
<td>
<p> This is a scalar which is used to determine
numerical tolerances.  This option is used by numerical routines
such as those used to determine if a matrix is singular.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_print.level">print.level</code></td>
<td>
<p>The level of printing. Set to '0' to turn off printing.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_version">version</code></td>
<td>
<p>The version of the code to be used.  The &quot;Matchby&quot; C/C++
version of the code is the fastest, and the end-user should not
change this option.</p>
</td></tr>
<tr><td><code id="Matchby_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="#topic+Match">Match</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Matchby</code> is much faster for large datasets than
<code><a href="#topic+Match">Match</a></code>.  But <code>Matchby</code> only implements a subset of
the functionality of <code><a href="#topic+Match">Match</a></code>.  For example, the
<code>restrict</code> option cannot be used, Abadie-Imbens standard errors
are not provided and bias adjustment cannot be requested.
<code>Matchby</code> is a wrapper for the <code><a href="#topic+Match">Match</a></code> function which
separates the matching problem into subgroups defined by a factor.  This
is the equivalent to doing exact matching on each factor, and the
way in which matches are found within each factor is determined by the
usual matching options. <br />
</p>
<p><em>Note that by default <code>ties=FALSE</code> although the default for
the <code>Match</code> in <code>GenMatch</code> functions is <code>TRUE</code>.  This is
done because randomly breaking ties in large datasets often results in
a great speedup.</em>  For additional speed, consider doing matching
without replacement which is often much faster when the dataset is
large&mdash;see the <code>replace</code> option. <br />
</p>
<p>There will be slight differences in the matches produced by
<code>Matchby</code> and <code><a href="#topic+Match">Match</a></code> because of how the covariates
are weighted.  When the data is broken up into separate groups (via
the <code>by</code> option), Mahalanobis distance and inverse variance
will imply different weights than when the data is taken as whole.
</p>


<h3>Value</h3>

<table>
<tr><td><code>est</code></td>
<td>
<p>The estimated average causal effect.</p>
</td></tr>
<tr><td><code>se.standard</code></td>
<td>
<p>The usual standard error.  This is the standard error
calculated on the matched data using the usual method of calculating
the difference of means (between treated and control) weighted so
that ties are taken into account.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The Abadie-Imbens standard error. This is only calculated
if the <code>AI</code> option is <code>TRUE</code>. This standard error has
correct coverage if <code>X</code> consists of either covariates or a
known propensity score because it takes into account the uncertainty
of the matching
procedure.  If an estimated propensity score is used, the
uncertainty involved in its estimation is not accounted for although the
uncertainty of the matching procedure itself still is.</p>
</td></tr>
<tr><td><code>index.treated</code></td>
<td>
<p>A vector containing the observation numbers from
the original dataset for the treated observations in the
matched dataset.  This index in conjunction with <code>index.control</code>
can be used to recover the matched dataset produced by
<code>Matchby</code>.  For example, the <code>X</code> matrix used by <code>Matchby</code>
can be recovered by
<code>rbind(X[index.treated,],X[index.control,])</code>.</p>
</td></tr>
<tr><td><code>index.control</code></td>
<td>
<p>A vector containing the observation numbers from
the original data for the control observations in the
matched data.  This index in conjunction with <code>index.treated</code>
can be used to recover the matched dataset produced by
<code>Matchby</code>.  For example, the <code>Y</code> matrix for the matched dataset
can be recovered by
<code>c(Y[index.treated],Y[index.control])</code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>The weights for each observation in the matched
dataset.</p>
</td></tr>
<tr><td><code>orig.nobs</code></td>
<td>
<p>The original number of observations in the dataset.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>The number of observations in the matched dataset.</p>
</td></tr>
<tr><td><code>wnobs</code></td>
<td>
<p>The number of weighted observations in the matched dataset.</p>
</td></tr>
<tr><td><code>orig.treated.nobs</code></td>
<td>
<p>The original number of treated observations.</p>
</td></tr>
<tr><td><code>ndrops</code></td>
<td>
<p>The number of matches which were dropped because there
were not enough observations in a given group and because of
caliper and exact matching.</p>
</td></tr>
<tr><td><code>estimand</code></td>
<td>
<p>The estimand which was estimated.</p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>The version of <code><a href="#topic+Match">Match</a></code> which was used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011.  &quot;Multivariate and Propensity Score
Matching Software with Automated Balance Optimization.&rdquo;
<em>Journal of Statistical Software</em> 42(7): 1-52.
<a href="https://doi.org/10.18637/jss.v042.i07">doi:10.18637/jss.v042.i07</a>
</p>
<p>Diamond, Alexis and Jasjeet S. Sekhon. 2013. &quot;Genetic
Matching for Estimating Causal Effects: A General Multivariate
Matching Method for Achieving Balance in Observational Studies.&rdquo;
<em>Review of Economics and Statistics</em>.  95 (3): 932&ndash;945.
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>
</p>
<p>Abadie, Alberto and Guido Imbens. 2006.
&ldquo;Large Sample Properties of Matching Estimators for Average
Treatment Effects.&rdquo; <em>Econometrica</em> 74(1): 235-267.
</p>
<p>Imbens, Guido. 2004. Matching Software for Matlab and
Stata.
</p>


<h3>See Also</h3>

<p> Also see <code><a href="#topic+Match">Match</a></code>,
<code><a href="#topic+summary.Matchby">summary.Matchby</a></code>,
<code><a href="#topic+GenMatch">GenMatch</a></code>,
<code><a href="#topic+MatchBalance">MatchBalance</a></code>,
<code><a href="#topic+balanceUV">balanceUV</a></code>,
<code><a href="#topic+qqstats">qqstats</a></code>, <code><a href="#topic+ks.boot">ks.boot</a></code>,
<code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>, <code><a href="#topic+lalonde">lalonde</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Match exactly by racial groups and then match using the propensity score within racial groups
#

data(lalonde)

#
# Estimate the Propensity Score
#
glm1  &lt;- glm(treat~age + I(age^2) + educ + I(educ^2) +
             hisp + married + nodegr + re74  + I(re74^2) + re75 + I(re75^2) +
             u74 + u75, family=binomial, data=lalonde)


#save data objects
#
X  &lt;- glm1$fitted
Y  &lt;- lalonde$re78
Tr &lt;- lalonde$treat

# one-to-one matching with replacement (the "M=1" option) after exactly
# matching on race using the 'by' option.  Estimating the treatment
# effect on the treated (the "estimand" option defaults to ATT).
rr  &lt;- Matchby(Y=Y, Tr=Tr, X=X, by=lalonde$black, M=1);
summary(rr)

# Let's check the covariate balance
# 'nboots' is set to small values in the interest of speed.
# Please increase to at least 500 each for publication quality p-values.
mb  &lt;- MatchBalance(treat~age + I(age^2) + educ + I(educ^2) + black +
                    hisp + married + nodegr + re74  + I(re74^2) + re75 + I(re75^2) +
                    u74 + u75, data=lalonde, match.out=rr, nboots=10)

</code></pre>

<hr>
<h2 id='qqstats'>QQ Summary Statistics</h2><span id='topic+qqstats'></span>

<h3>Description</h3>

<p>This function calculates a set of summary statistics for the QQ
plot of two samples of data.  The summaries are useful for determining
if the two samples are from the same distribution.  If
<code>standardize==TRUE</code>, the empirical CDF is used instead of the
empirical-QQ plot.  The later retains the scale of the variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqstats(x, y, standardize=TRUE, summary.func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqstats_+3A_x">x</code></td>
<td>
<p>The first sample.</p>
</td></tr>
<tr><td><code id="qqstats_+3A_y">y</code></td>
<td>
<p>The second sample.</p>
</td></tr>
<tr><td><code id="qqstats_+3A_standardize">standardize</code></td>
<td>
<p>A logical flag for whether the statistics should be
standardized by the empirical cumulative distribution functions of the
two samples.</p>
</td></tr>
<tr><td><code id="qqstats_+3A_summary.func">summary.func</code></td>
<td>
<p>A user provided function to summarize the
difference between the two distributions.  The function should
expect a vector of the differences as an argument and return summary
statistic.  For example, the <code><a href="stats.html#topic+quantile">quantile</a></code> function is a
legal function to pass in.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>meandiff</code></td>
<td>
<p>The mean difference between the QQ plots of the two
samples.</p>
</td></tr>
<tr><td><code>mediandiff</code></td>
<td>
<p>The median difference between the QQ plots of the
two samples.</p>
</td></tr>
<tr><td><code>maxdiff</code></td>
<td>
<p>The maximum difference between the QQ plots of the two
samples.</p>
</td></tr>
<tr><td><code>summarydiff</code></td>
<td>
<p>If the user provides a <code>summary.func</code>, the
user requested summary difference is returned.</p>
</td></tr>
<tr><td><code>summary.func</code></td>
<td>
<p>If the user provides a <code>summary.func</code>, the
function is returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011.  &quot;Multivariate and Propensity Score
Matching Software with Automated Balance Optimization.&rdquo;
<em>Journal of Statistical Software</em> 42(7): 1-52.
<a href="https://doi.org/10.18637/jss.v042.i07">doi:10.18637/jss.v042.i07</a>
</p>
<p>Diamond, Alexis and Jasjeet S. Sekhon. Forthcoming. &quot;Genetic Matching for
Estimating Causal Effects: A General Multivariate Matching Method for
Achieving Balance in Observational Studies.&rdquo; <em>Review of Economics and Statistics</em>.
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>
</p>


<h3>See Also</h3>

<p> Also see <code><a href="#topic+ks.boot">ks.boot</a></code>,
<code><a href="#topic+balanceUV">balanceUV</a></code>, <code><a href="#topic+Match">Match</a></code>,
<code><a href="#topic+GenMatch">GenMatch</a></code>,
<code><a href="#topic+MatchBalance">MatchBalance</a></code>,
<code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>, <code><a href="#topic+lalonde">lalonde</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Replication of Dehejia and Wahba psid3 model
#
# Dehejia, Rajeev and Sadek Wahba. 1999.``Causal Effects in
# Non-Experimental Studies: Re-Evaluating the Evaluation of Training
# Programs.''Journal of the American Statistical Association 94 (448):
# 1053-1062.
#

data(lalonde)

#
# Estimate the propensity model
#
glm1  &lt;- glm(treat~age + I(age^2) + educ + I(educ^2) + black +
             hisp + married + nodegr + re74  + I(re74^2) + re75 + I(re75^2) +
             u74 + u75, family=binomial, data=lalonde)


#
#save data objects
#
X  &lt;- glm1$fitted
Y  &lt;- lalonde$re78
Tr  &lt;- lalonde$treat

#
# one-to-one matching with replacement (the "M=1" option).
# Estimating the treatment effect on the treated (the "estimand" option which defaults to 0).
#
rr  &lt;- Match(Y=Y,Tr=Tr,X=X,M=1);
summary(rr)

#
# Do we have balance on 1975 income after matching?
#
qqout  &lt;- qqstats(lalonde$re75[rr$index.treated], lalonde$re75[rr$index.control])
print(qqout)
</code></pre>

<hr>
<h2 id='summary.balanceUV'>Summarizing output from balanceUV</h2><span id='topic+summary.balanceUV'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+summary">summary</a></code> method for class <code><a href="#topic+balanceUV">balanceUV</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'balanceUV'
summary(object, ..., digits=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.balanceUV_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>balanceUV</code>&quot;, usually, a
result of a call to <code><a href="#topic+balanceUV">balanceUV</a></code>.</p>
</td></tr>
<tr><td><code id="summary.balanceUV_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits that should be
displayed.</p>
</td></tr>
<tr><td><code id="summary.balanceUV_+3A_...">...</code></td>
<td>
<p>Other options for the generic summary function.</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.  
</p>


<h3>See Also</h3>

<p>Also see <code><a href="#topic+balanceUV">balanceUV</a></code>, 
<code><a href="#topic+Match">Match</a></code>, <code><a href="#topic+GenMatch">GenMatch</a></code>,
<code><a href="#topic+MatchBalance">MatchBalance</a></code>, <code><a href="#topic+qqstats">qqstats</a></code>, <code><a href="#topic+ks.boot">ks.boot</a></code>,
<code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>,
<code><a href="#topic+lalonde">lalonde</a></code>
</p>

<hr>
<h2 id='summary.ks.boot'>Summarizing output from ks.boot</h2><span id='topic+summary.ks.boot'></span><span id='topic+print.summary.ks.boot'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+summary">summary</a></code> method for class <code><a href="#topic+ks.boot">ks.boot</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ks.boot'
summary(object, ..., digits=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ks.boot_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>ks.boot</code>&quot;, usually, a
result of a call to <code><a href="#topic+ks.boot">ks.boot</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ks.boot_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits that should be
displayed.</p>
</td></tr>
<tr><td><code id="summary.ks.boot_+3A_...">...</code></td>
<td>
<p>Other options for the generic summary function.</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.  
</p>


<h3>See Also</h3>

<p>Also see <code><a href="#topic+ks.boot">ks.boot</a></code>, <code><a href="#topic+balanceUV">balanceUV</a></code>, <code><a href="#topic+qqstats">qqstats</a></code>,
<code><a href="#topic+Match">Match</a></code>, <code><a href="#topic+GenMatch">GenMatch</a></code>,
<code><a href="#topic+MatchBalance">MatchBalance</a></code>, <code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>,
<code><a href="#topic+lalonde">lalonde</a></code>
</p>

<hr>
<h2 id='summary.Match'>Summarizing output from Match</h2><span id='topic+summary.Match'></span><span id='topic+print.summary.Match'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+summary">summary</a></code> method for class <code><a href="#topic+Match">Match</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'Match'
summary(object, ... , full=FALSE, digits=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Match_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>Match</code>&quot;, usually, a
result of a call to <code><a href="#topic+Match">Match</a></code>.</p>
</td></tr>
<tr><td><code id="summary.Match_+3A_full">full</code></td>
<td>
<p>A flag for whether the unadjusted estimates and naive
standard errors should also be summarized.</p>
</td></tr>
<tr><td><code id="summary.Match_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits that should be
displayed.</p>
</td></tr>
<tr><td><code id="summary.Match_+3A_...">...</code></td>
<td>
<p>Other options for the generic summary function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.  
</p>


<h3>See Also</h3>

<p> Also see <code><a href="#topic+Match">Match</a></code>, <code><a href="#topic+GenMatch">GenMatch</a></code>,
<code><a href="#topic+MatchBalance">MatchBalance</a></code>, 
<code><a href="#topic+balanceUV">balanceUV</a></code>, <code><a href="#topic+qqstats">qqstats</a></code>, <code><a href="#topic+ks.boot">ks.boot</a></code>,
<code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>, <code><a href="#topic+lalonde">lalonde</a></code>
</p>

<hr>
<h2 id='summary.Matchby'>Summarizing output from Matchby</h2><span id='topic+summary.Matchby'></span><span id='topic+print.summary.Matchby'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+summary">summary</a></code> method for class <code><a href="#topic+Matchby">Matchby</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'Matchby'
summary(object, ... , digits=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Matchby_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>Matchby</code>&quot;, usually, a
result of a call to <code><a href="#topic+Matchby">Matchby</a></code>.</p>
</td></tr>
<tr><td><code id="summary.Matchby_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits that should be
displayed.</p>
</td></tr>
<tr><td><code id="summary.Matchby_+3A_...">...</code></td>
<td>
<p>Other options for the generic summary function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jasjeet S. Sekhon, UC Berkeley, <a href="mailto:sekhon@berkeley.edu">sekhon@berkeley.edu</a>,
<a href="https://www.jsekhon.com">https://www.jsekhon.com</a>.  
</p>


<h3>See Also</h3>

<p> Also see <code><a href="#topic+Matchby">Matchby</a></code>,  <code><a href="#topic+Match">Match</a></code>, <code><a href="#topic+GenMatch">GenMatch</a></code>,
<code><a href="#topic+MatchBalance">MatchBalance</a></code>, 
<code><a href="#topic+balanceUV">balanceUV</a></code>, <code><a href="#topic+qqstats">qqstats</a></code>, <code><a href="#topic+ks.boot">ks.boot</a></code>,
<code><a href="#topic+GerberGreenImai">GerberGreenImai</a></code>, <code><a href="#topic+lalonde">lalonde</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
