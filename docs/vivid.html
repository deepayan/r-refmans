<!DOCTYPE html><html lang="en-US"><head><title>Help for package vivid</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vivid}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.vivid'><p>as.data.frame.vivid</p></a></li>
<li><a href='#pdpPairs'><p>pdpPairs</p></a></li>
<li><a href='#pdpVars'><p>pdpVars</p></a></li>
<li><a href='#pdpZen'><p>Create a zenplot displaying partial dependence values.</p></a></li>
<li><a href='#vip2vivid'><p>vip2vivid</p></a></li>
<li><a href='#vivi'><p>vivi</p></a></li>
<li><a href='#vividReorder'><p>vividReorder</p></a></li>
<li><a href='#viviHeatmap'><p>viviHeatmap</p></a></li>
<li><a href='#viviNetwork'><p>viviNetwork</p></a></li>
<li><a href='#viviUpdate'><p>viviUpdate</p></a></li>
<li><a href='#zPath'><p>zPath</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Variable Importance and Variable Interaction Displays</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.9</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of plots for displaying variable importance and two-way variable interaction jointly. Can also display partial dependence plots laid out in a pairs plot or 'zenplots' style.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>condvis2, ggplot2, GGally, RColorBrewer, colorspace, stats,
DendSer, ggalt, dplyr, igraph, flashlight, ggnewscale, sp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>intergraph (&ge; 2.0-2), network (&ge; 1.12.0), sna (&ge; 2.3-2),
mlr, MASS, tidymodels, e1071, gridExtra, lemon, mlr3,
mlr3learners, scales, ranger, vip, knitr, rmarkdown,
randomForest, testthat (&ge; 3.0.0), labeling, zenplots, covr,
xgboost, bartMachine, caret, gbm, keras</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://alaninglis.github.io/vivid/">https://alaninglis.github.io/vivid/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-31 11:36:21 UTC; alaninglis</td>
</tr>
<tr>
<td>Author:</td>
<td>Alan Inglis [aut, cre],
  Andrew Parnell [aut],
  Catherine Hurley [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alan Inglis &lt;alan.n.inglis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-31 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.vivid'>as.data.frame.vivid</h2><span id='topic+as.data.frame.vivid'></span>

<h3>Description</h3>

<p>Takes a matrix of class <code>vivid</code> and turn it into a data frame
containing variable names, Vimp and Vint values, and the row and column index from the original
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vivid'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.vivid_+3A_x">x</code></td>
<td>
<p>A matrix of class 'vivid' to be converted to a data frame.</p>
</td></tr>
<tr><td><code id="as.data.frame.vivid_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a character vector giving the row names for the data frame. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.vivid_+3A_optional">optional</code></td>
<td>
<p>Logical. If TRUE, setting row names and converting column names (to syntactic names: see
make.names) is optional. Note that all of R's base package as.data.frame() methods use optional
only for column names treatment, basically with the meaning of data.frame(*, check.names = !optional). See also the make.names argument of the matrix method.</p>
</td></tr>
<tr><td><code id="as.data.frame.vivid_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of Vimp and Vint values and their index from the vivid matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
library(ranger)
aq &lt;- na.omit(airquality)
aq &lt;- aq[1:20,]# for speed
rF &lt;- ranger(Ozone ~ ., data = aq, importance = "permutation")
myMat &lt;- vivi(fit = rF, data = aq, response = "Ozone")
myDf &lt;- as.data.frame(myMat)
myDf

</code></pre>

<hr>
<h2 id='pdpPairs'>pdpPairs</h2><span id='topic+pdpPairs'></span>

<h3>Description</h3>

<p>Creates a pairs plot showing bivariate pdp on upper diagonal, ice/univariate pdp on the diagonal and data on the lower diagonal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdpPairs(
  data,
  fit,
  response,
  vars = NULL,
  pal = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
  fitlims = "pdp",
  gridSize = 10,
  nmax = 500,
  class = 1,
  nIce = 30,
  colorVar = NULL,
  comboImage = FALSE,
  predictFun = NULL,
  convexHull = FALSE,
  probability = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdpPairs_+3A_data">data</code></td>
<td>
<p>Data frame used for fit.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_fit">fit</code></td>
<td>
<p>A supervised machine learning model, which understands condvis2::CVpredict</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_vars">vars</code></td>
<td>
<p>The variables to plot (and their order), defaults to all variables other than response.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_pal">pal</code></td>
<td>
<p>A vector of colors to show predictions, for use with scale_fill_gradientn</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_fitlims">fitlims</code></td>
<td>
<p>Specifies the fit range for the color map. Options are a numeric vector of length 2,
&quot;pdp&quot; (default), in which cases limits are calculated from the pdp, or &quot;all&quot;, when limits are calculated from the observations and pdp.
Predictions outside fitlims are squished on the color scale.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_gridsize">gridSize</code></td>
<td>
<p>The size of the grid for evaluating the predictions.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_nmax">nmax</code></td>
<td>
<p>Uses sample of nmax data rows for the pdp.  Default is 500. Use all rows if NULL.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_class">class</code></td>
<td>
<p>Category for classification, a factor level, or a number indicating which factor level.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_nice">nIce</code></td>
<td>
<p>Number of ice curves to be plotted, defaults to 30.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_colorvar">colorVar</code></td>
<td>
<p>Which variable to colour the predictions by.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_comboimage">comboImage</code></td>
<td>
<p>If TRUE  draws pdp for mixed variable plots as an image, otherwise an interaction plot.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_predictfun">predictFun</code></td>
<td>
<p>Function of (fit, data) to extract numeric predictions from fit. Uses condvis2::CVpredict by default, which works for many fit classes.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_convexhull">convexHull</code></td>
<td>
<p>If TRUE, then the convex hull is computed and any points outside the convex hull are removed.</p>
</td></tr>
<tr><td><code id="pdpPairs_+3A_probability">probability</code></td>
<td>
<p>if TRUE, then returns the partial dependence for classification on the probability scale. If
FALSE (default), then the partial dependence is returned on a near logit scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pairs plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load in the data:
aq &lt;- na.omit(airquality)
f &lt;- lm(Ozone ~ ., data = aq)
pdpPairs(aq, f, "Ozone")

# Run a ranger model:
library(ranger)
library(MASS)
Boston1 &lt;- Boston[, c(4:6, 8, 13:14)]
Boston1$chas &lt;- factor(Boston1$chas)
fit &lt;- ranger(medv ~ ., data = Boston1, importance = "permutation")
pdpPairs(Boston1[1:30, ], fit, "medv")
pdpPairs(Boston1[1:30, ], fit, "medv", comboImage = TRUE)
viv &lt;- vivi(Boston1, fit, "medv")
# show top variables only
pdpPairs(Boston1[1:30, ], fit, "medv", comboImage = TRUE, vars = rownames(viv)[1:4])


library(ranger)
rf &lt;- ranger(Species ~ ., data = iris, probability = TRUE)
pdpPairs(iris, rf, "Species") # prediction probs for first class, setosa
pdpPairs(iris, rf, "Species", class = "versicolor") # prediction probs versicolor

</code></pre>

<hr>
<h2 id='pdpVars'>pdpVars</h2><span id='topic+pdpVars'></span>

<h3>Description</h3>

<p>Displays the individual conditional expectation (ICE) curves and aggregated partial dependence
for each variable in a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdpVars(
  data,
  fit,
  response,
  vars = NULL,
  pal = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
  gridSize = 10,
  nmax = 500,
  class = 1,
  nIce = 30,
  predictFun = NULL,
  limits = NULL,
  colorVar = NULL,
  draw = TRUE,
  probability = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdpVars_+3A_data">data</code></td>
<td>
<p>Data frame used for fit.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_fit">fit</code></td>
<td>
<p>A supervised machine learning model, which understands condvis2::CVpredict</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_vars">vars</code></td>
<td>
<p>The variables to plot (and their order), defaults to all variables other than response.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_pal">pal</code></td>
<td>
<p>A vector of colors to show predictions, for use with scale_fill_gradientn</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_gridsize">gridSize</code></td>
<td>
<p>The size of the grid for evaluating the predictions.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_nmax">nmax</code></td>
<td>
<p>Uses sample of nmax data rows for the pdp.  Default is 500. Use all rows if NULL.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_class">class</code></td>
<td>
<p>Category for classification, a factor level, or a number indicating which factor level.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_nice">nIce</code></td>
<td>
<p>Number of ice curves to be plotted, defaults to 30.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_predictfun">predictFun</code></td>
<td>
<p>Function of (fit, data) to extract numeric predictions from fit. Uses condvis2::CVpredict by default, which works for many fit classes.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_limits">limits</code></td>
<td>
<p>A vector determining the limits of the predicted values.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_colorvar">colorVar</code></td>
<td>
<p>Which variable to colour the predictions by.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_draw">draw</code></td>
<td>
<p>If FALSE, then the plot will not be drawn. Default is TRUE.</p>
</td></tr>
<tr><td><code id="pdpVars_+3A_probability">probability</code></td>
<td>
<p>if TRUE, then returns the partial dependence for classification on the probability scale. If
FALSE (default), then the partial dependence is returned on a near logit scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid displaying ICE curves and univariate partial dependence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load in the data:
aq &lt;- na.omit(airquality)
fit &lt;- lm(Ozone ~ ., data = aq)
pdpVars(aq, fit, "Ozone")

# Classification
library(ranger)
rfClassif &lt;- ranger(Species ~ ., data = iris, probability = TRUE)
pdpVars(iris, rfClassif, "Species", class = 3)

pp &lt;- pdpVars(iris, rfClassif, "Species", class = 2, draw = FALSE)
pp[[1]]
pdpVars(iris, rfClassif, "Species", class = 2, colorVar = "Species")

</code></pre>

<hr>
<h2 id='pdpZen'>Create a zenplot displaying partial dependence values.</h2><span id='topic+pdpZen'></span>

<h3>Description</h3>

<p>Constructs a zigzag expanded navigation plot (zenplot) displaying partial dependence values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdpZen(
  data,
  fit,
  response,
  zpath = NULL,
  pal = rev(RColorBrewer::brewer.pal(11, "RdYlBu")),
  fitlims = "pdp",
  gridSize = 10,
  nmax = 500,
  class = 1,
  comboImage = FALSE,
  rug = TRUE,
  predictFun = NULL,
  convexHull = FALSE,
  probability = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdpZen_+3A_data">data</code></td>
<td>
<p>Data frame used for fit</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_fit">fit</code></td>
<td>
<p>A supervised machine learning model, which understands condvis2::CVpredict</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_zpath">zpath</code></td>
<td>
<p>Plot shows consecutive pairs of these variables. Defaults to all variables other than response.
Recommend constructing zpath witn <code>calcZpath</code>.</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_pal">pal</code></td>
<td>
<p>A vector of colors to show predictions, for use with scale_fill_gradientn</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_fitlims">fitlims</code></td>
<td>
<p>Specifies the fit range for the color map. Options are a numeric vector of length 2,
&quot;pdp&quot; (default), in which cases limits are calculated from the pdp, or &quot;all&quot;, when limits are calculated from the observations and pdp
predictions outside fitlims are squished on the color scale.</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_gridsize">gridSize</code></td>
<td>
<p>The size of the grid for evaluating the predictions.</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_nmax">nmax</code></td>
<td>
<p>Uses sample of nmax data rows for the pdp.  Default is 500. Use all rows if NULL.</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_class">class</code></td>
<td>
<p>Category for classification, a factor level, or a number indicating which factor level.</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_comboimage">comboImage</code></td>
<td>
<p>If TRUE  draws pdp for mixed variable plots as an image, otherwise an interaction plot.</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_rug">rug</code></td>
<td>
<p>If TRUE adds rugs for the data to the pdp plots</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_predictfun">predictFun</code></td>
<td>
<p>Function of (fit, data) to extract numeric predictions from fit. Uses condvis2::CVpredict by default, which works for many fit classes.</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_convexhull">convexHull</code></td>
<td>
<p>If TRUE, then the convex hull is computed and any points outside the convex hull are removed.</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_probability">probability</code></td>
<td>
<p>if TRUE, then returns the partial dependence for classification on the probability scale. If
FALSE (default), then the partial dependence is returned on a near logit scale.</p>
</td></tr>
<tr><td><code id="pdpZen_+3A_...">...</code></td>
<td>
<p>passed on to zenplot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A zenplot of partial dependence values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To use this function, install zenplots and graph from Bioconductor.
if (!requireNamespace("graph", quietly = TRUE)) {
  install.packages("BiocManager")
  BiocManager::install("graph")
}
install.packages("zenplots")

library(MASS)
library(ranger)
Boston1 &lt;- Boston
Boston1$chas &lt;- factor(Boston1$chas)
rf &lt;- ranger(medv ~ ., data = Boston1)
pdpZen(Boston1[1:30, ], rf, response = "medv", zpath = names(Boston1)[1:4], comboImage = T)
# Find the top variables in rf
set.seed(123)
viv &lt;- vivi(Boston1, rf, "medv", nmax = 30) # use 30 rows, for speed
pdpZen(Boston1, rf, response = "medv", zpath = rownames(viv)[1:4], comboImage = T)
zpath &lt;- zPath(viv, cutoff = .2) # find plots whose interaction score exceeds .2
pdpZen(Boston1, rf, response = "medv", zpath = zpath, comboImage = T)

## End(Not run)
</code></pre>

<hr>
<h2 id='vip2vivid'>vip2vivid</h2><span id='topic+vip2vivid'></span>

<h3>Description</h3>

<p>Takes measured importance and interactions
from the vip package and turns them into a matrix
which can be used for plotting. Accepts any of the variable importance
methods supplied by vip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vip2vivid(importance, interaction, reorder = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vip2vivid_+3A_importance">importance</code></td>
<td>
<p>Measured importance from the vip package using <code>vi</code> function.</p>
</td></tr>
<tr><td><code id="vip2vivid_+3A_interaction">interaction</code></td>
<td>
<p>Measured interaction from the vip package using <code>vint</code> function.</p>
</td></tr>
<tr><td><code id="vip2vivid_+3A_reorder">reorder</code></td>
<td>
<p>If TRUE (default) uses DendSer to reorder the matrix of interactions and variable importances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of interaction values, with importance on the diagonal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ranger)
library(vip)
aq &lt;- na.omit(airquality) # get data
nameAq &lt;- names(aq[-1]) # get feature names

rF &lt;- ranger(Ozone ~ ., data = aq, importance = "permutation") # create ranger random forest fit
vImp &lt;- vi(rF) # vip importance
vInt &lt;- vint(rF, feature_names = nameAq) # vip interaction

vip2vivid(vImp, vInt)

## End(Not run)
</code></pre>

<hr>
<h2 id='vivi'>vivi</h2><span id='topic+vivi'></span>

<h3>Description</h3>

<p>Creates a matrix displaying variable importance on the diagonal
and variable interaction on the off-diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vivi(
  data,
  fit,
  response,
  gridSize = 50,
  importanceType = "agnostic",
  nmax = 500,
  reorder = TRUE,
  class = 1,
  predictFun = NULL,
  normalized = FALSE,
  numPerm = 4,
  showVimpError = FALSE,
  vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vivi_+3A_data">data</code></td>
<td>
<p>Data frame used for fit.</p>
</td></tr>
<tr><td><code id="vivi_+3A_fit">fit</code></td>
<td>
<p>A supervised machine learning model, which understands condvis2::CVpredict</p>
</td></tr>
<tr><td><code id="vivi_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit.</p>
</td></tr>
<tr><td><code id="vivi_+3A_gridsize">gridSize</code></td>
<td>
<p>The size of the grid for evaluating the predictions.</p>
</td></tr>
<tr><td><code id="vivi_+3A_importancetype">importanceType</code></td>
<td>
<p>Used to select the importance metric. By default, an agnostic importance
measure is used. If an embedded metric is available, then setting this argument
to the importance metric will use the selected importance values in the vivid-matrix.
Please refer to the examples given for illustration.
Alternatively, set to equal &quot;agnostic&quot; (the default) to override embedded importance measures and
return agnostic importance values.</p>
</td></tr>
<tr><td><code id="vivi_+3A_nmax">nmax</code></td>
<td>
<p>Maximum number of data rows to consider. Default is 500. Use all rows if NULL.</p>
</td></tr>
<tr><td><code id="vivi_+3A_reorder">reorder</code></td>
<td>
<p>If TRUE (default) uses DendSer to reorder the matrix of interactions and variable importances.</p>
</td></tr>
<tr><td><code id="vivi_+3A_class">class</code></td>
<td>
<p>Category for classification, a factor level, or a number indicating which factor level.</p>
</td></tr>
<tr><td><code id="vivi_+3A_predictfun">predictFun</code></td>
<td>
<p>Function of (fit, data) to extract numeric predictions from fit. Uses condvis2::CVpredict by default, which works for many fit classes.</p>
</td></tr>
<tr><td><code id="vivi_+3A_normalized">normalized</code></td>
<td>
<p>Should Friedman's H-statistic be normalized or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="vivi_+3A_numperm">numPerm</code></td>
<td>
<p>Number of permutations to perform for agnostic importance. Default is 4.</p>
</td></tr>
<tr><td><code id="vivi_+3A_showvimperror">showVimpError</code></td>
<td>
<p>Logical. If TRUE, and <code>numPerm &gt; 1</code> then a tibble containing the variable names, their importance values,
and the standard error for each importance is printed to the console.</p>
</td></tr>
<tr><td><code id="vivi_+3A_vars">vars</code></td>
<td>
<p>A vector of variable names to be assessed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the argument <code>importanceType = 'agnostic'</code>, then an agnostic permutation importance (1) is calculated.
Friedman's H statistic (2) is used for measuring the interactions. This measure is based on partial dependence curves
and relates the interaction strength of a pair of variables to the total effect strength of that variable pair.
</p>


<h3>Value</h3>

<p>A matrix of interaction values, with importance on the diagonal.
</p>


<h3>References</h3>

<p>1: Fisher A., Rudin C., Dominici F. (2018). All Models are Wrong but many are Useful: Variable Importance for Black-Box, Proprietary, or Misspecified Prediction Models, using Model Class Reliance. Arxiv.
</p>
<p>2: Friedman, J. H. and Popescu, B. E. (2008). “Predictive learning via rule ensembles.” The Annals of Applied Statistics. JSTOR, 916–54.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aq &lt;- na.omit(airquality)
f &lt;- lm(Ozone ~ ., data = aq)
m &lt;- vivi(fit = f, data = aq, response = "Ozone") # as expected all interactions are zero
viviHeatmap(m)

# Select importance metric
library(randomForest)
rf1 &lt;- randomForest(Ozone~., data = aq, importance = TRUE)
m2 &lt;- vivi(fit = rf1, data = aq, response = 'Ozone',
           importanceType = '%IncMSE') # select %IncMSE as the importance measure
viviHeatmap(m2)


library(ranger)
rf &lt;- ranger(Species ~ ., data = iris, importance = "impurity", probability = TRUE)
vivi(fit = rf, data = iris, response = "Species") # returns agnostic importance
vivi(fit = rf, data = iris, response = "Species",
     importanceType = "impurity") # returns selected 'impurity' importance.

</code></pre>

<hr>
<h2 id='vividReorder'>vividReorder</h2><span id='topic+vividReorder'></span>

<h3>Description</h3>

<p>Reorders a square matrix so that values of high importance and
interaction strength are pushed to the top left of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vividReorder(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vividReorder_+3A_d">d</code></td>
<td>
<p>A matrix such as that returned by vivi</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reordered version of d.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- lm(Sepal.Length ~ ., data = iris[, -5])
m &lt;- vivi(fit = f, data = iris[, -5], response = "Sepal.Length")
corimp &lt;- abs(cor(iris[, -5])[1, -1])
viviUpdate(m, corimp) # use correlation as importance and reorder

</code></pre>

<hr>
<h2 id='viviHeatmap'>viviHeatmap</h2><span id='topic+viviHeatmap'></span>

<h3>Description</h3>

<p>Plots a Heatmap showing variable importance on the diagonal
and variable interaction on the off-diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viviHeatmap(
  mat,
  intPal = rev(colorspace::sequential_hcl(palette = "Purples 3", n = 100)),
  impPal = rev(colorspace::sequential_hcl(palette = "Greens 3", n = 100)),
  intLims = NULL,
  impLims = NULL,
  border = FALSE,
  angle = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viviHeatmap_+3A_mat">mat</code></td>
<td>
<p>A matrix, such as that returned by vivi, of values to be plotted.</p>
</td></tr>
<tr><td><code id="viviHeatmap_+3A_intpal">intPal</code></td>
<td>
<p>A vector of colours to show interactions, for use with scale_fill_gradientn.</p>
</td></tr>
<tr><td><code id="viviHeatmap_+3A_imppal">impPal</code></td>
<td>
<p>A vector of colours to show importance, for use with scale_fill_gradientn.</p>
</td></tr>
<tr><td><code id="viviHeatmap_+3A_intlims">intLims</code></td>
<td>
<p>Specifies the fit range for the color map for interaction strength.</p>
</td></tr>
<tr><td><code id="viviHeatmap_+3A_implims">impLims</code></td>
<td>
<p>Specifies the fit range for the color map for importance.</p>
</td></tr>
<tr><td><code id="viviHeatmap_+3A_border">border</code></td>
<td>
<p>Logical. If TRUE then draw a black border around the diagonal elements.</p>
</td></tr>
<tr><td><code id="viviHeatmap_+3A_angle">angle</code></td>
<td>
<p>The angle to rotate the x-axis labels. Defaults to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap plot showing variable importance on the diagonal
and variable interaction on the off-diagonal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ranger)
aq &lt;- na.omit(airquality)
rF &lt;- ranger(Ozone ~ ., data = aq, importance = "permutation")
myMat &lt;- vivi(fit = rF, data = aq, response = "Ozone")
viviHeatmap(myMat)

</code></pre>

<hr>
<h2 id='viviNetwork'>viviNetwork</h2><span id='topic+viviNetwork'></span>

<h3>Description</h3>

<p>Create a Network plot displaying variable importance
and variable interaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viviNetwork(
  mat,
  intThreshold = NULL,
  intLims = NULL,
  impLims = NULL,
  intPal = rev(colorspace::sequential_hcl(palette = "Purples 3", n = 100)),
  impPal = rev(colorspace::sequential_hcl(palette = "Greens 3", n = 100)),
  removeNode = FALSE,
  layout = igraph::layout_in_circle,
  cluster = NULL,
  nudge_x = 0.05,
  nudge_y = 0.03,
  edgeWidths = 1:4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viviNetwork_+3A_mat">mat</code></td>
<td>
<p>A matrix, such as that returned by vivi, of values to be plotted.</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_intthreshold">intThreshold</code></td>
<td>
<p>Remove edges with weight below this value if provided.</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_intlims">intLims</code></td>
<td>
<p>Specifies the fit range for the color map for interaction strength.</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_implims">impLims</code></td>
<td>
<p>Specifies the fit range for the color map for importance.</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_intpal">intPal</code></td>
<td>
<p>A vector of colours to show interactions, for use with scale_fill_gradientn.</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_imppal">impPal</code></td>
<td>
<p>A vector of colours to show importance, for use with scale_fill_gradientn.</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_removenode">removeNode</code></td>
<td>
<p>If TRUE, then removes nodes with no connecting edges when thresholding interaction values.</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_layout">layout</code></td>
<td>
<p>igraph layout function or a numeric matrix with two columns, one row per node. Defaults to igraph::layout_as_circle</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_cluster">cluster</code></td>
<td>
<p>Either a vector of cluster memberships for nodes or an igraph clustering function.</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_nudge_x">nudge_x</code></td>
<td>
<p>Nudge (centered) labels by this amount, outward horizontally.</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Nudge (centered) labels by this amount, outward vertically.</p>
</td></tr>
<tr><td><code id="viviNetwork_+3A_edgewidths">edgeWidths</code></td>
<td>
<p>A vector specifying the scaling of the edges for the displayed graph. Values must be positive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot displaying interaction strength between variables on the edges and variable importance on the nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ranger)
aq &lt;- na.omit(airquality)
rF &lt;- ranger(Ozone ~ ., data = aq, importance = "permutation")
myMat &lt;- vivi(fit = rF, data = aq, response = "Ozone")
viviNetwork(myMat)

</code></pre>

<hr>
<h2 id='viviUpdate'>viviUpdate</h2><span id='topic+viviUpdate'></span>

<h3>Description</h3>

<p>Creates a matrix displaying updated variable importance on the diagonal
and variable interaction on the off-diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viviUpdate(mat, newImp, reorder = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viviUpdate_+3A_mat">mat</code></td>
<td>
<p>A matrix, such as that returned by <code>vivi</code>.</p>
</td></tr>
<tr><td><code id="viviUpdate_+3A_newimp">newImp</code></td>
<td>
<p>A named vector of variable importances.</p>
</td></tr>
<tr><td><code id="viviUpdate_+3A_reorder">reorder</code></td>
<td>
<p>If TRUE (default) uses DendSer to reorder the matrix of interactions and variable importances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of values, of class vivid, with updated variable importances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- lm(Sepal.Length ~ ., data = iris[, -5])
m &lt;- vivi(iris[, -5], f, "Sepal.Length")
corimp &lt;- abs(cor(iris[, -5])[1, -1])
viviUpdate(m, corimp) # use correlation as updated importance
</code></pre>

<hr>
<h2 id='zPath'>zPath</h2><span id='topic+zPath'></span>

<h3>Description</h3>

<p>Constructs a zenpath for connecting and displaying pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zPath(
  viv,
  cutoff = NULL,
  method = c("greedy.weighted", "strictly.weighted"),
  connect = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zPath_+3A_viv">viv</code></td>
<td>
<p>A matrix, created by <code>vivi</code> to be used to calculate the path.</p>
</td></tr>
<tr><td><code id="zPath_+3A_cutoff">cutoff</code></td>
<td>
<p>Do not include any variables that are below the cutoff interaction value.</p>
</td></tr>
<tr><td><code id="zPath_+3A_method">method</code></td>
<td>
<p>String indicating the method to use. The available methods are:
&quot;greedy.weighted&quot;: Sort all pairs according to a greedy (heuristic) Euler path with x as weights visiting each edge precisely once.
&quot;strictly.weighted&quot;: Strictly respect the order of the weights - so the first, second, third, and so on, adjacent pair of numbers
of the output of zenpath() corresponds to the pair with largest, second-largest, third-largest, and so on, weight.
see zenpath</p>
</td></tr>
<tr><td><code id="zPath_+3A_connect">connect</code></td>
<td>
<p>If connect is TRUE, connect the edges from separate eulerians (strictly.weighted only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Construct a path of indices to visit to order variables
</p>


<h3>Value</h3>

<p>Returns a zpath from viv showing pairs with viv entry over the cutoff
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To use this function, install zenplots and graph from Bioconductor.
if (!requireNamespace("graph", quietly = TRUE)) {
  install.packages("BiocManager")
  BiocManager::install("graph")
}
install.packages("zenplots")

aq &lt;- na.omit(airquality) * 1.0

# Run an mlr3 ranger model:
library(mlr3)
library(mlr3learners)
library(ranger)
ozonet &lt;- TaskRegr$new(id = "airQ", backend = aq, target = "Ozone")
ozonel &lt;- lrn("regr.ranger", importance = "permutation")
ozonef &lt;- ozonel$train(ozonet)

viv &lt;- vivi(aq, ozonef, "Ozone")

# Calculate Zpath:
zpath &lt;- zPath(viv, .8)
zpath

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
