<!DOCTYPE html><html><head><title>Help for package MultNonParam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MultNonParam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aov.P'><p>One-way ANOVA using permutation tests</p></a></li>
<li><a href='#betatest'><p>Permutation test of assication</p></a></li>
<li><a href='#dconcordant'><p>Calculate the probability atom of the count of concordant pairs among indpendent pairs of random variables.</p></a></li>
<li><a href='#dmannwhitney'><p>Mann Whitney Probability Mass function</p></a></li>
<li><a href='#ecdfcis'><p>Confidence Intervals for Empirical Cumulative Distribution Functions</p></a></li>
<li><a href='#exactquantileci'><p>Exact Quantile Confidence Interval</p></a></li>
<li><a href='#genscorestat'><p>Normal-theory two sample scorestatistic.</p></a></li>
<li><a href='#higgins.fisher.kruskal.test'><p>Fisher's LSD method applied to the Kruskal-Wallis test</p></a></li>
<li><a href='#kweffectsize'><p>Sample Size for the Kruskal-Wallis test.</p></a></li>
<li><a href='#kwpower'><p>Power for the Kruskal-Wallis test.</p></a></li>
<li><a href='#kwsamplesize'><p>Sample Size for the Kruskal-Wallis test.</p></a></li>
<li><a href='#mannwhitney.test'><p>Perform the Mann Whitney two-sample test</p></a></li>
<li><a href='#mood.median.test'><p>Mood's Median test, extended to odd sample sizes.</p></a></li>
<li><a href='#MultNonParam-package'><p>MultNonParam</p></a></li>
<li><a href='#nextp'><p>Next permutation</p></a></li>
<li><a href='#page.test.unbalanced'><p>Perform Page test for unbalanced two-way design</p></a></li>
<li><a href='#pairwiseprobabilities'><p>Pairwise probabilities of Exceedence</p></a></li>
<li><a href='#pconcordant'><p>Calculate the cumulative distribution of the count of concordant pairs among indpendent pairs of random variables.</p></a></li>
<li><a href='#powerplot'><p>Power Plot</p></a></li>
<li><a href='#probabilityderiv'><p>Derivative of pairwise probabilities of Exceedence</p></a></li>
<li><a href='#probest'><p>Stratified Multivariate Kawaguchi Koch Wang  Estimators</p></a></li>
<li><a href='#prostate'><p>prostate</p></a></li>
<li><a href='#qconcordant'><p>Calculate the quantiles of the count of concordant pairs among indpendent pairs of random variables.</p></a></li>
<li><a href='#sensitivity.plot'><p>Compare the sensitivity of different statistics.</p></a></li>
<li><a href='#shiftcr'><p>Nonparametric Confidence Region for a Vector Shift Parameter</p></a></li>
<li><a href='#solvencp'><p>Noncentrality Parameter for a Given Level and Power</p></a></li>
<li><a href='#sotiriou'><p>Breast cancer data set</p></a></li>
<li><a href='#symscorestat'><p>Generalization of Wilcoxon signed rank test</p></a></li>
<li><a href='#terpstra.test'><p>Perform the Terpstra version of the multi-ordered-sample test</p></a></li>
<li><a href='#terpstrapower'><p>Power for the nonparametric Terpstra test for an ordered effect.</p></a></li>
<li><a href='#testve'><p>Diagnosis for multivariate stratified Kawaguchi - Koch - Wang method</p></a></li>
<li><a href='#theil'><p>Perform the Theil nonparametric estimation and confidence interval for a slope parameter.</p></a></li>
<li><a href='#tukey.kruskal.test'><p>Tukey HSD procedure</p></a></li>
<li><a href='#twosamplesurvpvs'><p>Two Sample Omnibus Tests of Survival Curves</p></a></li>
<li><a href='#twosamplesurvtests'><p>Two Sample Omnibus Tests of Survival Curves</p></a></li>
<li><a href='#util.jplot'><p>Plot a curve, skipping bits where there is a large jump.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Nonparametric Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-29</td>
</tr>
<tr>
<td>Author:</td>
<td>John E. Kolassa [cre],
  Stephane Jankowski [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John E. Kolassa &lt;kolassa@stat.rutgers.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of multivariate nonparametric methods, selected in part to support an MS level course in nonparametric statistical methods. Methods include adjustments for multiple comparisons, implementation of multivariate Mann-Whitney-Wilcoxon testing, inversion of these tests to produce a confidence region, some permutation tests for linear models, and some algorithms for calculating exact probabilities associated with one- and two- stage testing involving Mann-Whitney-Wilcoxon statistics.  Supported by grant NSF DMS 1712839.  See Kolassa and Seifu (2013) &lt;<a href="https://doi.org/10.1016%2Fj.acra.2013.03.006">doi:10.1016/j.acra.2013.03.006</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), ICSNP</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-30 02:37:31 UTC; kolassa</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-30 04:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aov.P'>One-way ANOVA using permutation tests</h2><span id='topic+aov.P'></span>

<h3>Description</h3>

<p><code>aov.P</code> uses permutation tests instead of classic theory tests to run a one-way or two-way ANOVA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aov.P(dattab, treatment = NULL, be = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aov.P_+3A_dattab">dattab</code></td>
<td>
<p>The table on which the ANOVA has to be done, or a vector of responses.</p>
</td></tr>
<tr><td><code id="aov.P_+3A_treatment">treatment</code></td>
<td>
<p>If dattab is a table, ignored.  If dattab is a vector, a vector of treatment labels.</p>
</td></tr>
<tr><td><code id="aov.P_+3A_be">be</code></td>
<td>
<p>If dattab is a table, ignored.  If dattab is a vector, a vector of end points of blocks.  In this case, blocks must form contiguous subvectors of dattab.  If null, no blocking.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls a Fortran code to perform the permutation tests and the ANOVA.  The function has to be applied directly on a cross-table of two variables.
</p>


<h3>Value</h3>

<p>A list with fields pv, the p-value obtained with the permutation tests, and tot, the total number of permutations.
</p>

<hr>
<h2 id='betatest'>Permutation test of assication</h2><span id='topic+betatest'></span>

<h3>Description</h3>

<p>Calculate the p-value for the test of association between two variables using the permutation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betatest(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betatest_+3A_x">x</code></td>
<td>
<p>First vector to be associated.</p>
</td></tr>
<tr><td><code id="betatest_+3A_y">y</code></td>
<td>
<p>First vector to be associated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example using data from plant Qn1 from the CO2 data set.^M
betatest(CO2[CO2$Plant=="Qn1",4],CO2[CO2$Plant=="Qn1",5])
</code></pre>

<hr>
<h2 id='dconcordant'>Calculate the probability atom of the count of concordant pairs among indpendent pairs of random variables.</h2><span id='topic+dconcordant'></span>

<h3>Description</h3>

<p>Calculate the probability atom of the count of concordant pairs among indpendent pairs of random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dconcordant(ss, nn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dconcordant_+3A_ss">ss</code></td>
<td>
<p>Integer number of pairs</p>
</td></tr>
<tr><td><code id="dconcordant_+3A_nn">nn</code></td>
<td>
<p>number of pairs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>real probability
</p>

<hr>
<h2 id='dmannwhitney'>Mann Whitney Probability Mass function</h2><span id='topic+dmannwhitney'></span>

<h3>Description</h3>

<p>Calculates the Mann Whitney Probability Mass function recursively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmannwhitney(u, m, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmannwhitney_+3A_u">u</code></td>
<td>
<p>Statistic value</p>
</td></tr>
<tr><td><code id="dmannwhitney_+3A_m">m</code></td>
<td>
<p>Group 1 size</p>
</td></tr>
<tr><td><code id="dmannwhitney_+3A_n">n</code></td>
<td>
<p>Group 2 size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability that the Mann-Whitney statistic takes the value u under H0
</p>

<hr>
<h2 id='ecdfcis'>Confidence Intervals for Empirical Cumulative Distribution Functions</h2><span id='topic+ecdfcis'></span>

<h3>Description</h3>

<p>Confidence Intervals for Empirical Cumulative Distribution Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecdfcis(data, alpha = 0.05, dataname = NA, exact = TRUE, newplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecdfcis_+3A_data">data</code></td>
<td>
<p>vector of observations</p>
</td></tr>
<tr><td><code id="ecdfcis_+3A_alpha">alpha</code></td>
<td>
<p>1-confidence level.</p>
</td></tr>
<tr><td><code id="ecdfcis_+3A_dataname">dataname</code></td>
<td>
<p>Name of variable for use in axis labeling</p>
</td></tr>
<tr><td><code id="ecdfcis_+3A_exact">exact</code></td>
<td>
<p>logical value controlling whether confidence intervals are exact or asymlptotic.</p>
</td></tr>
<tr><td><code id="ecdfcis_+3A_newplot">newplot</code></td>
<td>
<p>logical value controlling whether the estimate is added to an existing plot, or whether a new plot should be constructed.</p>
</td></tr>
</table>

<hr>
<h2 id='exactquantileci'>Exact Quantile Confidence Interval</h2><span id='topic+exactquantileci'></span>

<h3>Description</h3>

<p>Calculates exact quanitle confidence intervals by inverting the generalization of the sign test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exactquantileci(xvec, tau = 0.5, alpha = 0.05, md = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exactquantileci_+3A_xvec">xvec</code></td>
<td>
<p>vector of observations</p>
</td></tr>
<tr><td><code id="exactquantileci_+3A_tau">tau</code></td>
<td>
<p>quantile to be estimated.  If this is a vector, separate intervals and tests for each value will be calculated.</p>
</td></tr>
<tr><td><code id="exactquantileci_+3A_alpha">alpha</code></td>
<td>
<p>1-confidence level.</p>
</td></tr>
<tr><td><code id="exactquantileci_+3A_md">md</code></td>
<td>
<p>null value of quantile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components cis, an array with two columns, representing lower and upper bounds, and a vector pvals, of p-values.
</p>

<hr>
<h2 id='genscorestat'>Normal-theory two sample scorestatistic.</h2><span id='topic+genscorestat'></span>

<h3>Description</h3>

<p>Calculates the p-value from the normal approximation to the permutation distribution of a two-sample score statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genscorestat(scores, group, correct = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genscorestat_+3A_scores">scores</code></td>
<td>
<p>scores of the data.</p>
</td></tr>
<tr><td><code id="genscorestat_+3A_group">group</code></td>
<td>
<p>numeric or character vector of group identities.</p>
</td></tr>
<tr><td><code id="genscorestat_+3A_correct">correct</code></td>
<td>
<p>half the minimal distance between two potential values of the score statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class htest containing the p-value.
</p>

<hr>
<h2 id='higgins.fisher.kruskal.test'>Fisher's LSD method applied to the Kruskal-Wallis test</h2><span id='topic+higgins.fisher.kruskal.test'></span>

<h3>Description</h3>

<p>This function applies a rank-based method for controlling experiment-wise error. Two hypothesis have to be respected: normality of the distribution and no ties in the data. The aim is to be able to detect, among k treatments, those who lead to significant differencies in the values for a variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>higgins.fisher.kruskal.test(resp, grp, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="higgins.fisher.kruskal.test_+3A_resp">resp</code></td>
<td>
<p>vector containing the values for the variable of interest.</p>
</td></tr>
<tr><td><code id="higgins.fisher.kruskal.test_+3A_grp">grp</code></td>
<td>
<p>vector specifying in which group is each observation.</p>
</td></tr>
<tr><td><code id="higgins.fisher.kruskal.test_+3A_alpha">alpha</code></td>
<td>
<p>level of the test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the Kruskal-Wallis test is used to test the equality of the distributions of each treatment. If the test is significant at the level <code>alpha</code>, the method can be applied.
</p>


<h3>Value</h3>

<p>A matrix with two columns. Each row indicates a combinaison of two groups that have significant different distributions.
</p>


<h3>References</h3>

<p>J.J. Higgins, (2004), <em>Introduction to Modern Nonparametric Statistics</em>, Brooks/Cole, Cengage Learning.
</p>

<hr>
<h2 id='kweffectsize'>Sample Size for the Kruskal-Wallis test.</h2><span id='topic+kweffectsize'></span>

<h3>Description</h3>

<p><code>kweffectsize</code> approximates effect size for the Kruskal-Wallis test, 
using a chi-square approximation under the null, and a non-central chi-square approximation under the alternative.  The noncentrality parameter is calculated using alternative means and the null variance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kweffectsize(
  totsamp,
  shifts,
  distname = c("normal", "logistic", "cauchy"),
  targetpower = 0.8,
  proportions = rep(1, length(shifts))/length(shifts),
  level = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kweffectsize_+3A_totsamp">totsamp</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="kweffectsize_+3A_shifts">shifts</code></td>
<td>
<p>The offsets for the various populations, under the alternative hypothesis.  This is used for direction on input.</p>
</td></tr>
<tr><td><code id="kweffectsize_+3A_distname">distname</code></td>
<td>
<p>The distribution of the underlying observations; normal and logistic are currently supported.</p>
</td></tr>
<tr><td><code id="kweffectsize_+3A_targetpower">targetpower</code></td>
<td>
<p>The distribution of the underlying observations; normal and logistic are currently supported.</p>
</td></tr>
<tr><td><code id="kweffectsize_+3A_proportions">proportions</code></td>
<td>
<p>The proportions in each group.</p>
</td></tr>
<tr><td><code id="kweffectsize_+3A_level">level</code></td>
<td>
<p>The test level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard noncentral chi-square power formula, or Monte Carlo, is used.
</p>


<h3>Value</h3>

<p>A list with components power, giving the power approximation, ncp, giving the noncentrality parameter, cv, giving the critical value, probs, giving the intermediate output from pairwiseprobability, and expect, the quantities summed before squaring in the noncentrality parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Calculate the effecct size necessary to have the desired power .8 for a test
#with the level .5 with sample size 60, group centers 0, 1, and 2, 
#normally distributed observations, evenly split among the three groups.
kweffectsize(60,c(0,1,2),"normal")
</code></pre>

<hr>
<h2 id='kwpower'>Power for the Kruskal-Wallis test.</h2><span id='topic+kwpower'></span>

<h3>Description</h3>

<p><code>kwpower</code> approximates power for the Kruskal-Wallis test, 
using a chi-square approximation under the null, and a non-central chi-square approximation under the alternative.  The noncentrality parameter is calculated using alternative means and the null variance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kwpower(
  nreps,
  shifts,
  distname = c("normal", "cauchy", "logistic"),
  level = 0.05,
  mc = 0,
  taylor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwpower_+3A_nreps">nreps</code></td>
<td>
<p>The numbers in each group.</p>
</td></tr>
<tr><td><code id="kwpower_+3A_shifts">shifts</code></td>
<td>
<p>The offsets for the various populations, under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="kwpower_+3A_distname">distname</code></td>
<td>
<p>The distribution of the underlying observations; normal, cauchy, and logistic are currently supported.</p>
</td></tr>
<tr><td><code id="kwpower_+3A_level">level</code></td>
<td>
<p>The test level.</p>
</td></tr>
<tr><td><code id="kwpower_+3A_mc">mc</code></td>
<td>
<p>0 for asymptotic calculation, or positive for mc approximation.</p>
</td></tr>
<tr><td><code id="kwpower_+3A_taylor">taylor</code></td>
<td>
<p>logical determining whether Taylor series approximation is used for probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard noncentral chi-square power formula, or Monte Carlo, is used.
</p>


<h3>Value</h3>

<p>A list with components power, giving the power approximation, ncp, giving the noncentrality parameter, cv, giving the critical value, probs, giving the intermediate output from pairwiseprobability, and expect, the quantities summed before squaring in the noncentrality parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Calculate the power for the Kruskal Wallis test for normal observations,
#10 observations in each of three groups, with groups centered at 0, 1, 2.
#Level is 0.05 by default.
kwpower(rep(10,3),c(0,1,2),"normal")
</code></pre>

<hr>
<h2 id='kwsamplesize'>Sample Size for the Kruskal-Wallis test.</h2><span id='topic+kwsamplesize'></span>

<h3>Description</h3>

<p><code>kwsamplesize</code> approximates sample size for the Kruskal-Wallis test, 
using a chi-square approximation under the null, and a non-central chi-square approximation under the alternative.  The noncentrality parameter is calculated using alternative means and the null variance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kwsamplesize(
  shifts,
  distname = c("normal", "logistic", "cauchy"),
  targetpower = 0.8,
  proportions = rep(1, length(shifts))/length(shifts),
  level = 0.05,
  taylor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwsamplesize_+3A_shifts">shifts</code></td>
<td>
<p>The offsets for the various populations, under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="kwsamplesize_+3A_distname">distname</code></td>
<td>
<p>The distribution of the underlying observations; normal and logistic are currently supported.</p>
</td></tr>
<tr><td><code id="kwsamplesize_+3A_targetpower">targetpower</code></td>
<td>
<p>The distribution of the underlying observations; normal and logistic are currently supported.</p>
</td></tr>
<tr><td><code id="kwsamplesize_+3A_proportions">proportions</code></td>
<td>
<p>The proportions in each group.</p>
</td></tr>
<tr><td><code id="kwsamplesize_+3A_level">level</code></td>
<td>
<p>The test level.</p>
</td></tr>
<tr><td><code id="kwsamplesize_+3A_taylor">taylor</code></td>
<td>
<p>Logical flag forcing the approximation of exceedence probabilities using the first derivative at zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard noncentral chi-square power formula, is used.
</p>


<h3>Value</h3>

<p>A list with the total number of observations needed to obtain approximate power, as long as this number is split amomg groups according to argument proportion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Calculate the sample size necessary to detect differences among three
#groups with centers at 0,1,2, from normal observations, using a test of
#level 0.05 and power 0.80.
kwsamplesize(c(0,1,2),"normal")
</code></pre>

<hr>
<h2 id='mannwhitney.test'>Perform the Mann Whitney two-sample test</h2><span id='topic+mannwhitney.test'></span>

<h3>Description</h3>

<p>Perform the Mann Whitney two-sample test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mannwhitney.test(x, y, alternative = c("two.sided", "less", "greater"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mannwhitney.test_+3A_x">x</code></td>
<td>
<p>A vector of values from the first sample.</p>
</td></tr>
<tr><td><code id="mannwhitney.test_+3A_y">y</code></td>
<td>
<p>A vector of values from the first sample.</p>
</td></tr>
<tr><td><code id="mannwhitney.test_+3A_alternative">alternative</code></td>
<td>
<p>Specification of alternative hypothesis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Test results of class htest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mannwhitney.test(rnorm(10),rnorm(10)+.5)
</code></pre>

<hr>
<h2 id='mood.median.test'>Mood's Median test, extended to odd sample sizes.</h2><span id='topic+mood.median.test'></span>

<h3>Description</h3>

<p>Test whether two samples come from the same distribution.  This version of Mood's median test is presented for pedagogical purposes only.  Many authors successfully argue that it is not very powerful.  The name &quot;median test&quot; is a misnomer, in that the null hypothesis is equality of distributions, and not just equality of median.  Exact calculations are not optimal for the odd sample size case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mood.median.test(x, y, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mood.median.test_+3A_x">x</code></td>
<td>
<p>First data set.</p>
</td></tr>
<tr><td><code id="mood.median.test_+3A_y">y</code></td>
<td>
<p>Second data set.</p>
</td></tr>
<tr><td><code id="mood.median.test_+3A_exact">exact</code></td>
<td>
<p>Indicator for whether the test should be done exactly or approximately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exact case reduces to Fisher's exact test.
</p>


<h3>Value</h3>

<p>The two-sided p-value.
</p>

<hr>
<h2 id='MultNonParam-package'>MultNonParam</h2><span id='topic+MultNonParam'></span><span id='topic+MultNonParam-package'></span>

<h3>Description</h3>

<p>A collection of nonparametric methods.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John E. Kolassa <a href="mailto:kolassa@stat.rutgers.edu">kolassa@stat.rutgers.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Stephane Jankowski
</p>
</li></ul>


<hr>
<h2 id='nextp'>Next permutation</h2><span id='topic+nextp'></span>

<h3>Description</h3>

<p>Cycles through permutations of first argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextp(perm, b = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextp_+3A_perm">perm</code></td>
<td>
<p>indices to be permutedj</p>
</td></tr>
<tr><td><code id="nextp_+3A_b">b</code></td>
<td>
<p>number to begin at.  Set equal to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The next permutation
</p>

<hr>
<h2 id='page.test.unbalanced'>Perform Page test for unbalanced two-way design</h2><span id='topic+page.test.unbalanced'></span>

<h3>Description</h3>

<p>Perform Page test for unbalanced two-way design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>page.test.unbalanced(x, trt, blk, sides = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="page.test.unbalanced_+3A_x">x</code></td>
<td>
<p>A vector of responses</p>
</td></tr>
<tr><td><code id="page.test.unbalanced_+3A_trt">trt</code></td>
<td>
<p>A vector of consecutive integers starting at 1 indicating treatment</p>
</td></tr>
<tr><td><code id="page.test.unbalanced_+3A_blk">blk</code></td>
<td>
<p>A vector of consecutive integers starting at 1 indicating block</p>
</td></tr>
<tr><td><code id="page.test.unbalanced_+3A_sides">sides</code></td>
<td>
<p>A single integer indicating sides.  Defaults to 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>P-value for Page test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>page.test.unbalanced(rnorm(15),rep(1:3,5),rep(1:5,rep(3,5)))
</code></pre>

<hr>
<h2 id='pairwiseprobabilities'>Pairwise probabilities of Exceedence</h2><span id='topic+pairwiseprobabilities'></span>

<h3>Description</h3>

<p><code>pairwiseprobabilities</code> calculates probabilities of one variable exceeding another,
where the variables are independent, and with identical distributions  except for a location shift.
This calculation is useful for power of Mann-Whitney-Wilcoxon, Jonckheere-Terpstra, and Kruskal-Wallis testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwiseprobabilities(
  shifts,
  distname = c("normal", "cauchy", "logistic"),
  taylor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwiseprobabilities_+3A_shifts">shifts</code></td>
<td>
<p>The offsets for the various populations, under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="pairwiseprobabilities_+3A_distname">distname</code></td>
<td>
<p>The distribution of the underlying observations; normal, cauchy, and logistic are currently supported.</p>
</td></tr>
<tr><td><code id="pairwiseprobabilities_+3A_taylor">taylor</code></td>
<td>
<p>Logical flag forcing the approximation of exeedence probabilities using a Taylor series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probabilities of particular families must be calculated analytically.
</p>


<h3>Value</h3>

<p>A matrix with as many rows and colums as there are shift parameters.  Row i and column j give the probability of an observation from group j exceeding one from group i.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pairwiseprobabilities(c(0,1,2),"normal")
</code></pre>

<hr>
<h2 id='pconcordant'>Calculate the cumulative distribution of the count of concordant pairs among indpendent pairs of random variables.</h2><span id='topic+pconcordant'></span>

<h3>Description</h3>

<p>Calculate the cumulative distribution of the count of concordant pairs among indpendent pairs of random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pconcordant(ss, nn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pconcordant_+3A_ss">ss</code></td>
<td>
<p>Integer number of pairs</p>
</td></tr>
<tr><td><code id="pconcordant_+3A_nn">nn</code></td>
<td>
<p>number of pairs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>real probability
</p>

<hr>
<h2 id='powerplot'>Power Plot</h2><span id='topic+powerplot'></span>

<h3>Description</h3>

<p>Plots powers for the Kruskall-Wallis test, via Monte Carlo and two approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerplot(
  numgrps = 3,
  thetadagger = NULL,
  nnvec = 5:30,
  nmc = 50000,
  targetpower = 0.8,
  level = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerplot_+3A_numgrps">numgrps</code></td>
<td>
<p>Number of groups to compare</p>
</td></tr>
<tr><td><code id="powerplot_+3A_thetadagger">thetadagger</code></td>
<td>
<p>Direction of effect</p>
</td></tr>
<tr><td><code id="powerplot_+3A_nnvec">nnvec</code></td>
<td>
<p>vector of numbers per group.</p>
</td></tr>
<tr><td><code id="powerplot_+3A_nmc">nmc</code></td>
<td>
<p>Number of Monte Carlo trials</p>
</td></tr>
<tr><td><code id="powerplot_+3A_targetpower">targetpower</code></td>
<td>
<p>Target power for test</p>
</td></tr>
<tr><td><code id="powerplot_+3A_level">level</code></td>
<td>
<p>level for test.</p>
</td></tr>
</table>

<hr>
<h2 id='probabilityderiv'>Derivative of pairwise probabilities of Exceedence</h2><span id='topic+probabilityderiv'></span>

<h3>Description</h3>

<p><code>probabilityderiv</code> calculates derivatives probabilities of one variable exceeding another,
where the variables are independent, and with identical distributions  except for a location shift, at the null hypothesis.
This calculation is useful for power of Mann-Whitney-Wilcoxon, Jonckheere-Terpstra, and Kruskal-Wallis testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probabilityderiv(distname = c("normal", "cauchy", "logistic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probabilityderiv_+3A_distname">distname</code></td>
<td>
<p>The distribution of the underlying observations; normal and logistic are currently supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probabilities of particular families must be calculated analytically, and then differentiated.
</p>


<h3>Value</h3>

<p>The scalar derivative.
</p>

<hr>
<h2 id='probest'>Stratified Multivariate Kawaguchi Koch Wang  Estimators</h2><span id='topic+probest'></span>

<h3>Description</h3>

<p>Function that return the estimators and their variance-covariance matrix calculated with the Kawaguchi - Koch - Wang method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probest(ds, resp, grp, str = NULL, covs = NULL, delta = NA, correct = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probest_+3A_ds">ds</code></td>
<td>
<p>The data frame to be used.</p>
</td></tr>
<tr><td><code id="probest_+3A_resp">resp</code></td>
<td>
<p>The vector of the response manifest variable. There can be more than one variable. It has to be the name of the variable as a character string.</p>
</td></tr>
<tr><td><code id="probest_+3A_grp">grp</code></td>
<td>
<p>The vector of the variable that divides the population into groups. It has to be the name of the variable as a character string.</p>
</td></tr>
<tr><td><code id="probest_+3A_str">str</code></td>
<td>
<p>The vector of the variable used for the strata. It has to be the name of the variable as a character string.</p>
</td></tr>
<tr><td><code id="probest_+3A_covs">covs</code></td>
<td>
<p>The covariates to be used in the model. It has to be the name of the variable as a character string.</p>
</td></tr>
<tr><td><code id="probest_+3A_delta">delta</code></td>
<td>
<p>Offeset for covariates.</p>
</td></tr>
<tr><td><code id="probest_+3A_correct">correct</code></td>
<td>
<p>Should the variance estimator be corrected as in Chen and Kolassa?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls a Fortran code to calculate the estimators <code>b</code> and their variance-covariance matrix <code>Vb</code>
</p>


<h3>Value</h3>

<p>A list with components b, the vector of adjusted estimates from the method, and Vb, the corresponding estimated covariance matrix.
</p>


<h3>References</h3>

<p>A. Kawaguchi, G. G. Koch and X. Wang (2012), &quot;Stratified Multivariate Mann-Whitney Estimators for the Comparison of Two Treatments with Randomization Based Covariance Adjustment&quot;, <em>Statistics in Biopharmaceutical Research</em> 3 (2) 217-231.
</p>
<p>J. E. Kolassa and Y. Seifu (2013), Nonparametric Multivariate Inference on Shift Parameters, <em>Academic Radiology</em> 20 (7), 883-888.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Breast cancer data from the MultNonParam package.
data(sotiriou)
attach(sotiriou)
#First simple plot of the data
plot(AGE,TUMOR_SIZE,pch=(recur+1),main="Age and Tumor Size",
  sub="Breast Cancer Recurrence Data",xlab="Age (years)",
  ylab="Tumor Size",col=c("blue","darkolivegreen"))
legend(31,8,legend=c("Not Recurrent","Recurrent"),
  pch=1:2,col=c("blue","darkolivegreen"))
#AGE and TUMOR_SIZE are the response variables, recur is used for the groups,
#TAMOXIFEN_TREATMENT for the stratum and ELSTON.ELLIS_GRADE is a covariate.
po&lt;-probest(sotiriou,c("AGE","TUMOR_SIZE"),"recur",
  "TAMOXIFEN_TREATMENT","ELSTON.ELLIS_GRADE")
</code></pre>

<hr>
<h2 id='prostate'>prostate</h2><span id='topic+prostate'></span>

<h3>Description</h3>

<p>221 prostate cancer patients are collected in this data set.
</p>


<h3>Format</h3>


<ul>
<li><p> hosp : Hospital in which the patient is hospitalized.
</p>
</li>
<li><p> stage : stage of the cancer.
</p>
</li>
<li><p> gleason score : used to help evaluate the prognosis of the cancer.
</p>
</li>
<li><p> psa : prostate-specific antigen.
</p>
</li>
<li><p> age : age of the patient.
</p>
</li>
<li><p> advanced : boolean. <code>TRUE</code> if the cancer is advanced.
</p>
</li></ul>



<h3>References</h3>

<p>A. V. D'Amico, R. Whittington, S. B. Malkowicz, D. Schultz, K. Blank, G. A. Broderick, J. E. Tomaszewski, A. A. Renshaw, I. Kaplan, C. J. Beard, A. Wein (1998) , <em>Biochemical outcome after radical prostatectomy, external beam radiation therapy, or interstitial radiation therapy for clinically localized prostate cancer</em>, JAMA : the journal of the American Medical Association 280 969-74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(prostate)
attach(prostate)
plot(age,psa,main="Age and PSA",sub="Prostate Cancer Data",
   xlab="Age (years)",ylab="PSA")
</code></pre>

<hr>
<h2 id='qconcordant'>Calculate the quantiles of the count of concordant pairs among indpendent pairs of random variables.</h2><span id='topic+qconcordant'></span>

<h3>Description</h3>

<p>Calculate the quantiles of the count of concordant pairs among indpendent pairs of random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qconcordant(qq, nn, exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qconcordant_+3A_qq">qq</code></td>
<td>
<p>Desired quantile</p>
</td></tr>
<tr><td><code id="qconcordant_+3A_nn">nn</code></td>
<td>
<p>number of pairs</p>
</td></tr>
<tr><td><code id="qconcordant_+3A_exact">exact</code></td>
<td>
<p>flag to trigger exact calculation when possible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer quantile
</p>

<hr>
<h2 id='sensitivity.plot'>Compare the sensitivity of different statistics.</h2><span id='topic+sensitivity.plot'></span>

<h3>Description</h3>

<p>Compare the sensitivity of different statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivity.plot(y, sub, stats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity.plot_+3A_y">y</code></td>
<td>
<p>vector of the data.</p>
</td></tr>
<tr><td><code id="sensitivity.plot_+3A_sub">sub</code></td>
<td>
<p>subtitle for the plot.</p>
</td></tr>
<tr><td><code id="sensitivity.plot_+3A_stats">stats</code></td>
<td>
<p>vector of functions to be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To compare the sensitivity, outliers are added to the original data. The shift of each statistics due to the new value is measured and plotted.
</p>

<hr>
<h2 id='shiftcr'>Nonparametric Confidence Region for a Vector Shift Parameter</h2><span id='topic+shiftcr'></span>

<h3>Description</h3>

<p>Inversion of a one-sample bivariate rank test is used to produce a confidence region.  The region is constructed by building a grid of potential parameter values, evaluating the test statistic on each grid point, collecting the p-values, and then drawing the appropriate countour of the p-values.  The grid is centered at the bivariate median of the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiftcr(xm,  hpts = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shiftcr_+3A_xm">xm</code></td>
<td>
<p>A two-column matrix of bivariate data whose two location parameters are to be estimated.</p>
</td></tr>
<tr><td><code id="shiftcr_+3A_hpts">hpts</code></td>
<td>
<p>Controls the number of grid points, by constructing a grid of 2*hpts+1 on each side.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>

<hr>
<h2 id='solvencp'>Noncentrality Parameter for a Given Level and Power</h2><span id='topic+solvencp'></span>

<h3>Description</h3>

<p>This function calculates the noncentrality parameter required to give a test whose null distribution is central chi-square and whose alternative distribution is noncentral chi-square the required level and power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solvencp(df, level = 0.05, targetpower = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solvencp_+3A_df">df</code></td>
<td>
<p>Common degrees of freedom for null and alternative distributions.</p>
</td></tr>
<tr><td><code id="solvencp_+3A_level">level</code></td>
<td>
<p>Level (that is, type I error rate) for the test.</p>
</td></tr>
<tr><td><code id="solvencp_+3A_targetpower">targetpower</code></td>
<td>
<p>Desired power</p>
</td></tr>
</table>


<h3>Value</h3>

<p>required noncentrality parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>solvencp(4)
</code></pre>

<hr>
<h2 id='sotiriou'>Breast cancer data set</h2><span id='topic+sotiriou'></span>

<h3>Description</h3>

<p>187 breast cancer patients are collected in this data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sotiriou)
</code></pre>


<h3>Format</h3>

<p>A data set with the following variables
</p>

<ul>
<li><p> AGE : Age of the patient
</p>
</li>
<li><p> TUMOR_SIZE : The size of the tumor, numeric variable
</p>
</li>
<li><p> recur : 1 if the patient has a recurent breast cancer, 0 if it is not reccurent.
</p>
</li>
<li><p> ELSTON.ELLIS_GRADE : Elston Ellis grading system in order toclassify the breast cancers. It can be a low, intermediate or high grade (high being the worst prognosis)
</p>
</li>
<li><p> TAMOXIFEN_TREATMENT : boolean. <code>TRUE</code> if the patient is treated with the Tamoxifen treatment.
</p>
</li></ul>



<h3>Source</h3>

<p>https://gdoc.georgetown.edu/gdoc/
</p>


<h3>References</h3>

<p>S. Madhavan, Y. Gusev, M. Harris, D. Tanenbaum, R. Gauba, K. Bhuvaneshwar, A. Shinohara, K. Rosso, L. Carabet, L. Song, R. Riggins, S. Dakshanamurthy, Y. Wang, S. Byers, R. Clarke, L. Weiner (2011), <em>A systems medicine platform for personalized oncology</em>, Neoplasia 13. 
</p>
<p>C. Sotiriou, P. Wirapati, S. Loi, A. Harris, S. Fox, J. Smeds, H. Nordgren, P. Farmer, V. Praz, B. Haibe-Kains, C. Desmedt, D. Larsimont, F. Cardoso, H. Peterse, D. Nuyten, M. Buyse, M. Van de Vijver, J. Bergh, M. Piccart, M. Delorenzi  (2006), <em>Gene expression profiling in breast cancer: understanding the molecular basis of histologic grade to improve prognosis</em>, Journal of the National Cancer Institute 98 262-72.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sotiriou)
plot(sotiriou$AGE,sotiriou$TUMOR_SIZE,pch=(sotiriou$recur+1),
   main="Age and Tumor Size",
   sub="Breast Cancer Recurrence Data",
   xlab="Age (years)",ylab="Tumor Size",
   col=c("blue","darkolivegreen"))
legend(31,8,legend=c("Not Recurrent","Recurrent"),pch=1:2,
   col=c("blue","darkolivegreen"))

</code></pre>

<hr>
<h2 id='symscorestat'>Generalization of Wilcoxon signed rank test</h2><span id='topic+symscorestat'></span>

<h3>Description</h3>

<p>This function returns either exact or asymptotic p-values for score tests of the null hypothesis of univariate symmetry about 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symscorestat(y, scores = NULL, exact = F, sides = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symscorestat_+3A_y">y</code></td>
<td>
<p>Vector of data on which test will be run.</p>
</td></tr>
<tr><td><code id="symscorestat_+3A_scores">scores</code></td>
<td>
<p>Scores to be used for the test.  Defaults to integers 1:length(y).</p>
</td></tr>
<tr><td><code id="symscorestat_+3A_exact">exact</code></td>
<td>
<p>Logical variable indicating whether the exact p-value should be calculate.  Default is false.</p>
</td></tr>
<tr><td><code id="symscorestat_+3A_sides">sides</code></td>
<td>
<p>Integer; 1 for one sided test rejecting for large values of the statistic, and 2 for the two-sided test.  Defaults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic considered here is the sum of scores corresponding to those entries in y that are positive.  If exact=T, the function calls a Fortran code to cycle through all permutations.  If exact=F, the expectation of the statistic is calculated as half the sum of the scores, the variance is calculated as one quarter the sum of squares of scores about their mean, and the statistic is compared to its approximating normal distribution.
</p>


<h3>Value</h3>

<p>A list with components pv, the p-value obtained with the permutation tests, and tot, the total number of rearrangements of the data considred in calculating the p-value.
</p>


<h3>References</h3>

<p>J.J. Higgins, (2004), <em>Introduction to Modern Nonparametric Statistics</em>, Brooks/Cole, Cengage Learning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symscorestat(y=c(1,-2,3,-4,5),exact=TRUE)
</code></pre>

<hr>
<h2 id='terpstra.test'>Perform the Terpstra version of the multi-ordered-sample test</h2><span id='topic+terpstra.test'></span>

<h3>Description</h3>

<p>Perform the Terpstra version of the multi-ordered-sample test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terpstra.test(x, g, alternative = c("two.sided", "less", "greater"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terpstra.test_+3A_x">x</code></td>
<td>
<p>A vector of values from all samples.</p>
</td></tr>
<tr><td><code id="terpstra.test_+3A_g">g</code></td>
<td>
<p>A vector of group labels.</p>
</td></tr>
<tr><td><code id="terpstra.test_+3A_alternative">alternative</code></td>
<td>
<p>Specification of alternative hypothesis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Test results of class htest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>terpstra.test(rnorm(15),rep(1:3,5))
</code></pre>

<hr>
<h2 id='terpstrapower'>Power for the nonparametric Terpstra test for an ordered effect.</h2><span id='topic+terpstrapower'></span>

<h3>Description</h3>

<p><code>terpstrapower</code> approximates power for the one-sided Terpstra test, 
using a normal approximation with expectations under the null and alternative, and using the null standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terpstrapower(
  nreps,
  shifts,
  distname = c("normal", "logistic"),
  level = 0.025,
  mc = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terpstrapower_+3A_nreps">nreps</code></td>
<td>
<p>The numbers in each group.</p>
</td></tr>
<tr><td><code id="terpstrapower_+3A_shifts">shifts</code></td>
<td>
<p>The offsets for the various populations, under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="terpstrapower_+3A_distname">distname</code></td>
<td>
<p>The distribution of the underlying observations; normal and logistic are currently supported.</p>
</td></tr>
<tr><td><code id="terpstrapower_+3A_level">level</code></td>
<td>
<p>The test level.</p>
</td></tr>
<tr><td><code id="terpstrapower_+3A_mc">mc</code></td>
<td>
<p>Zero indicates asymptotic calculation.  Positive for MC calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard normal-theory power formula is used.
</p>


<h3>Value</h3>

<p>A list with components power, giving the power approximation, expect, giving null and alternative expectations, var, giving the null variance, probs, giving the intermediate output from pairwiseprobability, and level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>terpstrapower(rep(10,3),c(0,1,2),"normal")
terpstrapower(c(10,10,10),0:2,"normal",mc=1000)
</code></pre>

<hr>
<h2 id='testve'>Diagnosis for multivariate stratified Kawaguchi - Koch - Wang method</h2><span id='topic+testve'></span>

<h3>Description</h3>

<p>Diagnostic tool that verifies the normality of the estimates of the probabilities b with the Kawaguchi - Koch - Wang method. The diagnostic method is based on a Monte Carlo method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testve(n, m, k, nsamp = 100, delta = 0, beta = 0, disc = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testve_+3A_n">n</code></td>
<td>
<p>number of observations in the first group.</p>
</td></tr>
<tr><td><code id="testve_+3A_m">m</code></td>
<td>
<p>number of observations in the second group.</p>
</td></tr>
<tr><td><code id="testve_+3A_k">k</code></td>
<td>
<p>number of strata.</p>
</td></tr>
<tr><td><code id="testve_+3A_nsamp">nsamp</code></td>
<td>
<p>The number of estimates that will be calculated. Must be enough to be sure that the results are interpretable.</p>
</td></tr>
<tr><td><code id="testve_+3A_delta">delta</code></td>
<td>
<p>Offset that depends on group.</p>
</td></tr>
<tr><td><code id="testve_+3A_beta">beta</code></td>
<td>
<p>Correlation between x and y.</p>
</td></tr>
<tr><td><code id="testve_+3A_disc">disc</code></td>
<td>
<p>The Mann Whitney test is designed to handle continuous data, but this method applies to discretized data; <code>disc</code> adjusts the discreteness.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions serves as a diagnosis to prove that the Kawaguchi - Koch - Wang method gives Gaussian estimates for b. It generates random data sets, to which the Mann Whitney test gets applied.  <code>y</code> is the generated response variable and <code>x</code> the generated covariable related to <code>y</code> through a regression model.
</p>


<h3>Value</h3>

<p>Nothing is returned.  A QQ plot is drawn.
</p>


<h3>References</h3>

<p>A. Kawaguchi, G. G. Koch and X. Wang (2012), &quot;Stratified Multivariate Mann-Whitney Estimators for the Comparison of Two Treatments with Randomization Based Covariance Adjustment&quot;, <em>Statistics in Biopharmaceutical Research</em> 3 (2) 217-231.
</p>
<p>J. E. Kolassa and Y. Seifu (2013), Nonparametric Multivariate Inference on Shift Parameters, <em>Academic Radiology</em> 20 (7), 883-888.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testve(10,15,3,100,0.4)
</code></pre>

<hr>
<h2 id='theil'>Perform the Theil nonparametric estimation and confidence interval for a slope parameter.</h2><span id='topic+theil'></span>

<h3>Description</h3>

<p>Perform the Theil nonparametric estimation and confidence interval for a slope parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theil(x, y, conf = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theil_+3A_x">x</code></td>
<td>
<p>A vector of values of the explanatory variable.</p>
</td></tr>
<tr><td><code id="theil_+3A_y">y</code></td>
<td>
<p>A vector of values of the response variable.</p>
</td></tr>
<tr><td><code id="theil_+3A_conf">conf</code></td>
<td>
<p>Level of confidence interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with letters and numbers.
</p>

<ul>
<li><p> est - An estimate, the median of pairwise slopes.
</p>
</li>
<li><p> ci - A vector of confidence interval endpoints.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-0:19;b&lt;-a^2.5
theil(a,b)
</code></pre>

<hr>
<h2 id='tukey.kruskal.test'>Tukey HSD procedure</h2><span id='topic+tukey.kruskal.test'></span>

<h3>Description</h3>

<p>Rank-based method for controlling experiment-wise error. Assume normality of the distribution for the variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukey.kruskal.test(resp, grp, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tukey.kruskal.test_+3A_resp">resp</code></td>
<td>
<p>vector containing the values for the variable of interest.</p>
</td></tr>
<tr><td><code id="tukey.kruskal.test_+3A_grp">grp</code></td>
<td>
<p>vector specifying in which group is each observation.</p>
</td></tr>
<tr><td><code id="tukey.kruskal.test_+3A_alpha">alpha</code></td>
<td>
<p>level of the test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original Tuckey HSD procedure is supposed to be applied for equal sample sizes. However, the <code>tukey.kruskal.test</code> function performs the Tukey-Kramer procedure that works for unequal sample sizes.
</p>


<h3>Value</h3>

<p>A logical vector for every combinaison of two groups. <code>TRUE</code> if the distribution in one group is significantly different from the distribution in the other group.
</p>


<h3>References</h3>

<p>J.J. Higgins, (2004), <em>Introduction to Modern Nonparametric Statistics</em>, Brooks/Cole, Cengage Learning.
</p>

<hr>
<h2 id='twosamplesurvpvs'>Two Sample Omnibus Tests of Survival Curves</h2><span id='topic+twosamplesurvpvs'></span>

<h3>Description</h3>

<p>Returns the Kolmogorov-Smirnov and Anderson-Darling test statistics for two right-censored data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twosamplesurvpvs(times, delta, grp, nmc = 10000, plotme = TRUE, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twosamplesurvpvs_+3A_times">times</code></td>
<td>
<p>Event and censoring times</p>
</td></tr>
<tr><td><code id="twosamplesurvpvs_+3A_delta">delta</code></td>
<td>
<p>Indicator of event (1) or censoring (0).</p>
</td></tr>
<tr><td><code id="twosamplesurvpvs_+3A_grp">grp</code></td>
<td>
<p>Variable that divides the population into groups.</p>
</td></tr>
<tr><td><code id="twosamplesurvpvs_+3A_nmc">nmc</code></td>
<td>
<p>Number of Monte Carlo samples for p value calculation</p>
</td></tr>
<tr><td><code id="twosamplesurvpvs_+3A_plotme">plotme</code></td>
<td>
<p>logical; indicates whether to plot or not.</p>
</td></tr>
<tr><td><code id="twosamplesurvpvs_+3A_exact">exact</code></td>
<td>
<p>logical; indicates whether to use exhaustive enumeration of permutations or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls a Fortran code to calculate the estimators <code>b</code> and their variance-covariance matrix <code>Vb</code>
</p>


<h3>Value</h3>

<p>A vector of length two, with the Kolmogorov-Smirnov and Anderson-Darling statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twosamplesurvpvs(rexp(20),rbinom(20,1,.5),rbinom(20,1,.5))
</code></pre>

<hr>
<h2 id='twosamplesurvtests'>Two Sample Omnibus Tests of Survival Curves</h2><span id='topic+twosamplesurvtests'></span>

<h3>Description</h3>

<p>Returns the Kolmogorov-Smirnov and Anderson-Darling test statistics for two right-censored data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twosamplesurvtests(times, delta, grp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twosamplesurvtests_+3A_times">times</code></td>
<td>
<p>Event and censoring times</p>
</td></tr>
<tr><td><code id="twosamplesurvtests_+3A_delta">delta</code></td>
<td>
<p>Indicator of event (1) or censoring (0).</p>
</td></tr>
<tr><td><code id="twosamplesurvtests_+3A_grp">grp</code></td>
<td>
<p>Variable that divides the population into groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length two, with the Kolmogorov-Smirnov and Anderson-Darling statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twosamplesurvpvs(rexp(20),rbinom(20,1,.5),rbinom(20,1,.5))
</code></pre>

<hr>
<h2 id='util.jplot'>Plot a curve, skipping bits where there is a large jump.</h2><span id='topic+util.jplot'></span>

<h3>Description</h3>

<p>Plot a curve, skipping bits where there is a large jump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>util.jplot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="util.jplot_+3A_x">x</code></td>
<td>
<p>Ordinates to be plotted.</p>
</td></tr>
<tr><td><code id="util.jplot_+3A_y">y</code></td>
<td>
<p>Abcissas to be plotted.</p>
</td></tr>
<tr><td><code id="util.jplot_+3A_...">...</code></td>
<td>
<p>Arguents passed directly to plot.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
