<!DOCTYPE html><html><head><title>Help for package artfima</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {artfima}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#artfima'><p>MLE for ARTFIMA model</p></a></li>
<li><a href='#artfima-package'><p>ARTFIMA Model Estimation</p></a></li>
<li><a href='#artfimaSDF'><p>Computation of theoretical spectral density function (SDF)</p></a></li>
<li><a href='#artfimaTACVF'><p>Autocovariance function of ARTFIMA</p></a></li>
<li><a href='#artsim'><p>Simulation of stationary ARTFIMA</p></a></li>
<li><a href='#best_glp_models'>
<p>Best AIC/BIC Models for Specified GLP</p></a></li>
<li><a href='#bestModels'><p>Best BIC Models</p></a></li>
<li><a href='#bev'>
<p>Beveridge Wheat Price Index, 1500 to 1869</p></a></li>
<li><a href='#eaglecol'>
<p>Tree-ring indicies for Douglas Fir, Colorado, 1107-1964.</p></a></li>
<li><a href='#ifisher'>
<p>Information matrix for ARTFIMA</p></a></li>
<li><a href='#nilemin'>
<p>Nile Annual Minima, 622 AD to 1284 AD</p></a></li>
<li><a href='#ogden'>
<p>Mean Annual St.  Lawrence Riverflow</p></a></li>
<li><a href='#Periodogram'>
<p>Periodogram</p></a></li>
<li><a href='#plot.artfima'><p>Plot Method for &quot;arfima&quot; Object</p></a></li>
<li><a href='#predict.artfima'>
<p>Predict method for artfima</p></a></li>
<li><a href='#print.artfima'><p>Print Method for &quot;arfima&quot; Object</p></a></li>
<li><a href='#print.bestmodels'>
<p>Print Method for &quot;bestmodels&quot; Object</p></a></li>
<li><a href='#SB32'>
<p>Turbulent flow data from Station SB32</p></a></li>
<li><a href='#seriesa'>
<p>Series A from Box and Jenkins</p></a></li>
<li><a href='#tseg'>
<p>Simulate Some Time Series Models of Interest</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>ARTFIMA Model Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-06-28</td>
</tr>
<tr>
<td>Author:</td>
<td>A. I. McLeod, Mark M. Meerschaert, Farzad Sabzikar</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>A.I. McLeod &lt;aimcleod@uwo.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit and simulate ARTFIMA. Theoretical autocovariance function and spectral density function for stationary ARTFIMA.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ltsa, gsl</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Classification/ACM:</td>
<td>G.3, G.4, I.5.1</td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62M10, 91B84</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stats.uwo.ca/faculty/aim">http://www.stats.uwo.ca/faculty/aim</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-07-13 18:58:49 UTC; IanMcLeod</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-07-14 00:28:43</td>
</tr>
</table>
<hr>
<h2 id='artfima'>MLE for ARTFIMA model</h2><span id='topic+artfima'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation of the ARTFIMA model as well as the edge cases
ARIMA and ARFIMA. Exact MLE and Whittle approximate MLE are implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artfima(z, glp = c("ARTFIMA", "ARFIMA", "ARIMA"), arimaOrder = c(0, 0, 0), 
  likAlg = c("exact", "Whittle"),  fixd = NULL, b0 = NULL, 
         lambdaMax = 3, dMax = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artfima_+3A_z">z</code></td>
<td>
<p>time series data</p>
</td></tr>
<tr><td><code id="artfima_+3A_glp">glp</code></td>
<td>
<p>general linear process type: ARTFIMA, ARFIMA or ARMA.</p>
</td></tr>
<tr><td><code id="artfima_+3A_arimaorder">arimaOrder</code></td>
<td>
<p>c(p,D,q), where p is the AR order, D is the regular difference
parameter and q is the MA order.</p>
</td></tr>
<tr><td><code id="artfima_+3A_likalg">likAlg</code></td>
<td>
<p>&quot;exact&quot; or &quot;Whittle&quot; or &quot;Whittle2&quot;</p>
</td></tr>
<tr><td><code id="artfima_+3A_fixd">fixd</code></td>
<td>
<p>only used with ARTFIMA, default setting fixd=NULL means the MLE
for the parameter d is obtained other if fixed=d0, where d0 is a numeric
value in the interval (-2, 2) the d parameter in ARTFIMA is fixed at this 
value while the remaining parameters are estimated.</p>
</td></tr>
<tr><td><code id="artfima_+3A_b0">b0</code></td>
<td>
<p>initial estimates - use only for high order AR models. See Details
and Example.</p>
</td></tr>
<tr><td><code id="artfima_+3A_lambdamax">lambdaMax</code></td>
<td>
<p>ARTFIMA boundard setting - upper limit for lambda</p>
</td></tr>
<tr><td><code id="artfima_+3A_dmax">dMax</code></td>
<td>
<p>ARTFIMA boundard setting - absolute magnitude for d. See Note and
Example</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ARFIMA and ARIMA are subsets or edge-cases
of the ARTFIMA model. The likelihood and probability density function
for these models is defined by the multivariate normal distribution.
The log-likelihood, AIC and BIC are comparable across models.
When the Whittle MLE algorithm is used, the final log-likelihood
is obtained by plugging this estimates into the exact log-likelihood.
</p>
<p>The argument b0 is provided for fitting for fitting high order AR models
with ARTFIMA. That is ARTFIMA(p,0,0) when p is large. This fitting is best done
by fitting values with p=1,2,...,pmax. For p&gt;1, set b0 equal to c(ans$b0, 0),
where ans is the output from artfima for the p-1 order model. An example
is given below. This technqiue is used by bestModels with q=0 and p&gt;3.
</p>


<h3>Value</h3>

<p>A lengthy list is produced. A terse summary is provided by the associated
print method.
</p>


<h3>Note</h3>

<p>Note: ARTFIMA parameters d and lambda on the boundary.
The output from this function is normally viewed using the print method that
has been implemented for class artfima. Check this output to see if any of 
the estimates are on the boundary. This may happen with the lambda or d 
parameter estimates in ARTFIMA. Another famous case is with the MA(1) models.
Often when this happens the model is not statistically adequate because it is
too parsimonious or otherwise mis-specified. For example an AR(1) instead
of an MA(1). See the R code for artfima if you wish to change the boundary
limits set on the parameters - only for researchers not recommended otherwise.
</p>


<h3>Author(s)</h3>

<p>A. I. McLeod, aimcleod@uwo.ca</p>


<h3>References</h3>

<p>McLeod, A.I., Yu, Hao and Krougly, Z. (2007).  
Algorithms for Linear Time Series Analysis: With R Package.  
Journal of Statistical Software  23/5 1-26.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bestModels">bestModels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>artfima(Nile) #Nile is a built in dataset in R
artfima(Nile, likAlg = "exact")
#
#fitting a high-order AR using recursion
## Not run: 
#This may take 3 to 6 hours if exact MLE used!
#But Whittle MLE doesn't work properly for this example!!
 data(SB32)
 z &lt;- SB32
 likAlg &lt;- "exact"
 pmax &lt;- 30
 startTime &lt;- proc.time()[3]
 ic &lt;- matrix(numeric(0), ncol=3, nrow=pmax+1)
 out &lt;- artfima(z, arimaOrder=c(0,0,0), likAlg=likAlg)
 ic[1, 1] &lt;- out$aic
 ic[1, 2] &lt;- out$bic
 ic[1, 3] &lt;- out$LL
 b1 &lt;- c(out$b0, 0)
 for (i in 1:pmax) {
  out &lt;- artfima(z, arimaOrder=c(i,0,0), b0=b1, likAlg=likAlg)
  b1 &lt;- c(out$b0, 0)
  ic[i+1, 1] &lt;- out$aic
  ic[i+1, 2] &lt;- out$bic
  ic[i+1, 3] &lt;- out$LL
 }
 endTime &lt;- proc.time()[3]
 (totTime &lt;- endTime-startTime)
 plot(0:pmax, ic[,1], xlab="AR order", ylab="AIC", pch=20, col="blue")
 indBest &lt;- which.min(ic[,1])
 pBest &lt;- indBest-1
 icBest &lt;- ic[indBest,1]
 abline(h=icBest, col="brown")
 abline(v=pBest, col="brown")
 plot(0:pmax, ic[,2], xlab="AR order", ylab="BIC", pch=20, col="blue")
 indBest &lt;- which.min(ic[,2])
 pBest &lt;- indBest-1
 icBest &lt;- ic[indBest,2]
 abline(h=icBest, col="brown")
 abline(v=pBest, col="brown")
 plot(0:pmax, ic[,3], xlab="AR order", ylab="log-lik", pch=20)
 
## End(Not run)#end dontrun
#
#setting new boundary limit
## Not run: 
data(SB32)
#ARTFIMA(1,0,2) - MLE for d on boundar, dHat = 10
artfima(SB32, arimaOrder=c(1,0,2))
#note:
#log-likelihood = -10901.14, AIC = 21816.29, BIC = 21862.41
#Warning: estimates converged to boundary!
#mean     -0.5558988 8.443794e-02
#d         9.9992097 1.396002e-05
#lambda    2.9304658 8.050071e-02
#phi(1)    0.9271892 6.862294e-03
#theta(1)  0.8440911 1.709824e-02
#theta(2) -0.3650004 2.744227e-02
#
#now reset upper limit dMax and lambdaMax
#NOTE - there is only a very small improvement in the log-likelihood
artfima(SB32, arimaOrder=c(1,0,2), lambdaMax=20, dMax=40)
#ARTFIMA(1,0,2), MLE Algorithm: exact, optim: BFGS
#snr = 4.665, sigmaSq = 3.38228734331338
#log-likelihood = -10900.56, AIC = 21815.12, BIC = 21861.25
#               est.    se(est.)
#mean     -0.5558988  0.08443794
#d        27.0201256 36.94182328
#lambda    3.9412050  1.38296970
#phi(1)    0.9276901  0.00676589
#theta(1)  0.8342879  0.01715041
#theta(2) -0.3644787  0.02691869

## End(Not run) 
 
</code></pre>

<hr>
<h2 id='artfima-package'>ARTFIMA Model Estimation</h2><span id='topic+artfima-package'></span>

<h3>Description</h3>

<p>Fit and simulate ARTFIMA. Theoretical autocovariance function and spectral density function for stationary ARTFIMA.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> artfima</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> ARTFIMA Model Estimation</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-06-28</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> A. I. McLeod, Mark M. Meerschaert, Farzad Sabzikar</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> A.I. McLeod &lt;aimcleod@uwo.ca&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Fit and simulate ARTFIMA. Theoretical autocovariance function and spectral density function for stationary ARTFIMA.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.1.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> ltsa, gsl</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Classification/ACM: </td><td style="text-align: left;"> G.3, G.4, I.5.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Classification/MSC: </td><td style="text-align: left;"> 62M10, 91B84</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> http://www.stats.uwo.ca/faculty/aim</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
Periodogram             Periodogram
SB32                    Turbulent flow data from Station SB32
artfima                 MLE for ARTFIMA model
artfima-package         ARTFIMA Model Estimation
artfimaSDF              Computation of theoretical spectral density
                        function (SDF)
artfimaTACVF            Autocovariance function of ARTFIMA
artsim                  Simulation of stationary ARTFIMA
bestModels              Best BIC Models
best_glp_models         Best AIC/BIC Models for Specified GLP
bev                     Beveridge Wheat Price Index, 1500 to 1869
eaglecol                Tree-ring indicies for Douglas Fir, Colorado,
                        1107-1964.
ifisher                 Information matrix for ARTFIMA
nilemin                 Nile Annual Minima, 622 AD to 1284 AD
ogden                   Mean Annual St.  Lawrence Riverflow
plot.artfima            Plot Method for "arfima" Object
predict.artfima         Predict method for artfima
print.artfima           Print Method for "arfima" Object
print.bestmodels        Print Method for "bestmodels" Object
seriesa                 Series A from Box and Jenkins
tseg                    Simulate Some Time Series Models of Interest
</pre>


<h3>Author(s)</h3>

<p>A. I. McLeod, Mark M. Meerschaert, Farzad Sabzikar
Maintainer: A.I. McLeod &lt;aimcleod@uwo.ca&gt;
</p>


<h3>References</h3>

<p>TBA</p>


<h3>See Also</h3>

<p><code>ltsa</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>artfima(rnorm(100))
</code></pre>

<hr>
<h2 id='artfimaSDF'>Computation of theoretical spectral density function (SDF)</h2><span id='topic+artfimaSDF'></span>

<h3>Description</h3>

<p>Computes the theoretical SDF at the Fourier frequencies for a time series of
length n. Used for Whittle MLE. Assumes model parameters are valid
for a stationary process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artfimaSDF(n = 100, d = 0, lambda = 0, phi = numeric(0), theta = numeric(0), 
     obj = NULL, plot=c("loglog", "log", "none"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artfimaSDF_+3A_n">n</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code id="artfimaSDF_+3A_d">d</code></td>
<td>
<p>ARTFIMA difference parameter, any real value. When d=numeric(0), 
reduces to ARMA and lambda is ignored.</p>
</td></tr>
<tr><td><code id="artfimaSDF_+3A_lambda">lambda</code></td>
<td>
<p>ARTFIMA tempered decay parameter. When lambda=numeric(0), 
reduces to ARFIMA</p>
</td></tr> 
<tr><td><code id="artfimaSDF_+3A_phi">phi</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code id="artfimaSDF_+3A_theta">theta</code></td>
<td>
<p>MA coefficients, Box-Jenkins definition</p>
</td></tr>
<tr><td><code id="artfimaSDF_+3A_obj">obj</code></td>
<td>
<p>object of class artfima</p>
</td></tr>
<tr><td><code id="artfimaSDF_+3A_plot">plot</code></td>
<td>
<p>type of plot, &quot;log-log&quot;, &quot;log&quot; or &quot;none&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Fourier frequencies, 2*pi*c(1/n, floor(n/2)/n, 1/n), are used
in the definition of the SDF. 
The SDF is normalized so that the area over (0, 0.5) equals
the variance of the time series assuming unit innovation variance.
The periodogram is normalized in the same way, so the mean of the
periodogram is an estimate of the variance of the time series.
See example below.
</p>


<h3>Value</h3>

<p>vector of length floor(n/2) containing the values of the SDF at the 
Fourier frequencies, 2*pi*c(1/n, floor(n/2)/n, 1/n).
</p>


<h3>Warning </h3>

<p>This function serves as a utility function for Whittle estimation so, for speed, we skip
the checking if the parameters d, phi, or lambda are valid
parameters for a stationary process. 
</p>


<h3>Author(s)</h3>

<p>A. I. McLeod, aimcleod@uwo.ca</p>


<h3>References</h3>

<p>TBA</p>


<h3>See Also</h3>

<p><code><a href="#topic+artfimaTACVF">artfimaTACVF</a></code>,
<code><a href="#topic+Periodogram">Periodogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- 0.8
n &lt;- 256
set.seed(4337751)
z &lt;- artsim(n, phi=phi)
VarZ &lt;- mean((z-mean(z))^2)
Ip &lt;- Periodogram(z)
length(Ip)
x &lt;- (1/n)*(1:length(Ip))
plot(x, Ip, xlab="frequency", ylab="Spectral density &amp; Periodogram", 
     main=paste("AR(1), phi =", phi), type="l", col=rgb(0,0,1,0.5))
n &lt;- 5000
y &lt;- artfimaSDF(n, phi=phi)
x &lt;- (1/n)*(1:length(y))
lines(x, y, type="l", lwd=1.25)
h &lt;- x[2]-x[1] #step length
SimpsonsRule &lt;- function(h, y) {
  n &lt;- length(y)
  h/3*sum(y * c(1, rep(c(4,2), n-1), 1))
}
AreaApprox &lt;- SimpsonsRule(h, y)
text(0.2, 50, labels=paste("Area under SDF using Simpson's Rule =", 
                           round(AreaApprox,4)))
TVarZ &lt;- 1/(1-phi^2)
text(0.2, 40, labels=paste("Theoretical AR Variance =", round(TVarZ,4)))
text(0.2, 30, labels=paste("mean(Ip) =", round(mean(Ip),4)))
text(0.2, 20, labels=paste("sample variance =", round(VarZ,4)))
</code></pre>

<hr>
<h2 id='artfimaTACVF'>Autocovariance function of ARTFIMA</h2><span id='topic+artfimaTACVF'></span>

<h3>Description</h3>

<p>Theoretical autocovariance function of ARTFIMA model</p>


<h3>Usage</h3>

<pre><code class='language-R'>artfimaTACVF(d = numeric(0), lambda = numeric(0), phi = numeric(0), 
      theta = numeric(0), maxlag, sigma2 = 1, obj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artfimaTACVF_+3A_d">d</code></td>
<td>
<p>ARTFIMA difference parameter, any real value. When d=0, reduces to 
ARMA and lambda is ignored.</p>
</td></tr>
<tr><td><code id="artfimaTACVF_+3A_lambda">lambda</code></td>
<td>
<p>ARTFIMA tempered decay parameter. When lambda=0, 
reduces to ARFIMA</p>
</td></tr> 
<tr><td><code id="artfimaTACVF_+3A_phi">phi</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code id="artfimaTACVF_+3A_theta">theta</code></td>
<td>
<p>MA coefficients, Box-Jenkins definition</p>
</td></tr>
<tr><td><code id="artfimaTACVF_+3A_maxlag">maxlag</code></td>
<td>
<p>maxlag+1 lags computed corresponding to 0,1,...,maxlag</p>
</td></tr>
<tr><td><code id="artfimaTACVF_+3A_sigma2">sigma2</code></td>
<td>
<p>innovation variance</p>
</td></tr>
<tr><td><code id="artfimaTACVF_+3A_obj">obj</code></td>
<td>
<p>output from artfima function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of length maxlag+1 of the specified autocovariances</p>


<h3>Author(s)</h3>

<p>A. I. McLeod, aimcleod@uwo.ca</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ARMAacf">ARMAacf</a></code>,
<code><a href="#topic+artfimaSDF">artfimaSDF</a></code>,
<code><a href="#topic+artsim">artsim</a></code>,
<code><a href="#topic+artfima">artfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#ARTFIMA - area under SDF equals theoretical Var(z[t])
#and sample variance = mean of periodogram
#
lambda &lt;- 0.045
d &lt;- 5/6
TVarZ &lt;- artfimaTACVF(d=d, lambda=lambda, maxlag=3)[1]
TVarZ
n &lt;- 256
set.seed(4337751)
z &lt;- artsim(n, lambda=lambda, d=d)
VarZ &lt;- mean((z-mean(z))^2)
Ip &lt;- Periodogram(z)
mean(Ip)
length(Ip)
x &lt;- (1/n)*(1:length(Ip))
plot(x, Ip, xlab="frequency", ylab="Spectral density &amp; Periodogram", 
     main=paste("lambda, d =", lambda, d), type="l", col=rgb(0,0,1,0.5))
n &lt;- 5000
y &lt;- artfimaSDF(n, lambda=lambda, d=d)
x &lt;- (1/n)*(1:length(y))
lines(x, y, type="l", lwd=1.25)
h &lt;- x[2]-x[1] #step length
SimpsonsRule &lt;- function(h, y) {
  n &lt;- length(y)
  h/3*sum(y * c(1, rep(c(4,2), n-1), 1))
}
AreaApprox &lt;- SimpsonsRule(h, y)
text(0.2, 230, labels=paste("Area under SDF using Simpson's Rule =", 
                           round(AreaApprox,4)))
text(0.2, 200, labels=paste("Theoretical ARTFIMA Variance =", round(TVarZ,4)))
text(0.2, 170, labels=paste("mean(Ip) =", round(mean(Ip),4)))
text(0.2, 140, labels=paste("sample variance =", round(VarZ,4)))
</code></pre>

<hr>
<h2 id='artsim'>Simulation of stationary ARTFIMA
</h2><span id='topic+artsim'></span>

<h3>Description</h3>

<p>Simulation of stationary ARTFIMA, ARFIMA or ARIMA or bootstrap a fitted model.
Useful for the parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artsim(n = 100, d = 0, lambda = 0, phi = numeric(0), 
    theta = numeric(0), mean = 0, sigma2 = 1, obj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artsim_+3A_n">n</code></td>
<td>

<p>length of time series
</p>
</td></tr>
<tr><td><code id="artsim_+3A_d">d</code></td>
<td>

<p>artfima difference parameter, real value greater than zero. 
If d=0, ARIMA model is used.
</p>
</td></tr>
<tr><td><code id="artsim_+3A_lambda">lambda</code></td>
<td>

<p>lambda artfima temper decay parameter, if lambda=0, ARFIMA model is simulated
</p>
</td></tr>
<tr><td><code id="artsim_+3A_phi">phi</code></td>
<td>

<p>AR coefficients
</p>
</td></tr>
<tr><td><code id="artsim_+3A_theta">theta</code></td>
<td>

<p>MA coefficients
</p>
</td></tr>
<tr><td><code id="artsim_+3A_mean">mean</code></td>
<td>

<p>mean of series
</p>
</td></tr>
<tr><td><code id="artsim_+3A_sigma2">sigma2</code></td>
<td>

<p>innovation variance
</p>
</td></tr>
<tr><td><code id="artsim_+3A_obj">obj</code></td>
<td>

<p>output from artfima(). If obj is not output from artfima() 
then the other arguments are used to determine the time series parameters, 
except for the series length n.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of length n, the simulated time series
</p>


<h3>Author(s)</h3>

<p>A. I. McLeod, aimcleod@uwo.ca
</p>


<h3>References</h3>

<p>McLeod, A.I., Yu, Hao and Krougly, Z. (2007).  
Algorithms for Linear Time Series Analysis: With R Package.  
Journal of Statistical Software  23/5 1-26.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- artsim(5000, d=5/6, lambda=0.045)
var(z)
artfimaTACVF(d=5/6, lambda=0.045, maxlag=1)[1]
</code></pre>

<hr>
<h2 id='best_glp_models'>
Best AIC/BIC Models for Specified GLP
</h2><span id='topic+best_glp_models'></span>

<h3>Description</h3>

<p>This function is used by bestModels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_glp_models(z, glp = c("ARTFIMA", "ARFIMA", "ARIMA"), p = 2, q = 2, 
   likAlg = c("exact", "Whittle"), d=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best_glp_models_+3A_z">z</code></td>
<td>

<p>time series
</p>
</td></tr>
<tr><td><code id="best_glp_models_+3A_glp">glp</code></td>
<td>

<p>glp is equal to one of the following choices: &quot;ARTFIMA&quot;, &quot;ARFIMA&quot; or &quot;ARIMA&quot;
</p>
</td></tr>
<tr><td><code id="best_glp_models_+3A_p">p</code></td>
<td>

<p>maximum order of AR component
</p>
</td></tr>
<tr><td><code id="best_glp_models_+3A_q">q</code></td>
<td>

<p>maximum order of MA component
</p>
</td></tr>
<tr><td><code id="best_glp_models_+3A_likalg">likAlg</code></td>
<td>

<p>likAlg = c(&quot;exact&quot;, &quot;Whittle&quot;))
either &quot;exact&quot; or &quot;Whittle&quot;
</p>
</td></tr>
<tr><td><code id="best_glp_models_+3A_d">d</code></td>
<td>

<p>regular integer differencing parameter
</p>
</td></tr>
<tr><td><code id="best_glp_models_+3A_...">...</code></td>
<td>
<p>optional arguments for artfima such as lambdaMax</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 4 entries:
</p>
<table>
<tr><td><code>LL</code></td>
<td>
<p>log-likelihood of models</p>
</td></tr>
<tr><td><code>artfima_time</code></td>
<td>
<p>total time</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>list with best aic models</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>list with best bic models</p>
</td></tr>
</table>
<p>Each of the components aic and bic is a list with three components:
</p>
<table>
<tr><td><code>bestaic</code></td>
<td>
<p>best aic models</p>
</td></tr>
<tr><td><code>bestbicModel</code></td>
<td>
<p>best model</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>plausability</p>
</td></tr>
</table>
<p>Similarly for the bic component.
</p>


<h3>Author(s)</h3>

<p>A. I. McLeod
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bestModels">bestModels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#takes about 4 minutes. Checking result for bestmodels()
z&lt;-tseg(1000, "BJARMA11")
ansARIMA &lt;- best_glp_models(z, glp = "ARIMA", p=2, q=2)
ansARFIMA &lt;- best_glp_models(z, glp = "ARFIMA", p=2, q=2)
ansARTFIMA &lt;- best_glp_models(z, glp = "ARTFIMA", p=2, q=2)
ansARIMA$bic$bic
ansARFIMA$bic$bic
ansARTFIMA$bic$bic
bestModels(z)

## End(Not run)
</code></pre>

<hr>
<h2 id='bestModels'>Best BIC Models</h2><span id='topic+bestModels'></span>

<h3>Description</h3>

<p>ARIMA(p,0,q), ARFIMA(p,0,q) and ARTFIMA(p,0,q) models are fit for
various p=0,1,..., and q=0,1,... and the best models according to the BIC
criterion are selected.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestModels(z, parMax = 4, nbest = 4, likAlg = c("exact", "Whittle"), 
     d=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestModels_+3A_z">z</code></td>
<td>

<p>time series data
</p>
</td></tr>
<tr><td><code id="bestModels_+3A_parmax">parMax</code></td>
<td>

<p>maximum number of parameters - see Details
</p>
</td></tr>
<tr><td><code id="bestModels_+3A_nbest">nbest</code></td>
<td>

<p>number of models in selection
</p>
</td></tr>
<tr><td><code id="bestModels_+3A_likalg">likAlg</code></td>
<td>

<p>likelihood method to use
</p>
</td></tr>
<tr><td><code id="bestModels_+3A_d">d</code></td>
<td>

<p>regular differencing parameter indicating the number of times to difference
</p>
</td></tr>
<tr><td><code id="bestModels_+3A_...">...</code></td>
<td>
<p>optional arguments for artfima such as lambdaMax</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">numPar = K</code>, where K is 
the number of structural models defined by
<code class="reqn">K = p+q+n(glp)</code>,
where <code class="reqn">n(glp) = 0, 1, 2</code> according as the model is ARIMA, ARFIMA or
ARTFIMA respectively.
</p>
<p>These models are ranked according to the AIC/BIC criterion and the best ones are 
shown.
</p>
<p>The plausibility is shown. This is defined for AIC by the eqn
<code class="reqn">p(AIC) = exp(0.5*(min(AIC)-AIC))</code>,
where AIC is the vector of AIC values. Similarly for the BIC.
</p>


<h3>Value</h3>

<p>An S3 list object, &quot;bestmodels&quot;.
Output is provided using the print method for the
&quot;bestmodels&quot;
</p>


<h3>Note</h3>

<p>There are often small differences in the likelihood among a group
of 5 or more of the best models. So the &quot;exact&quot; and &quot;Whittle&quot; likelihood
methods may produce a different ranking of the models. For this reason the
&quot;exact&quot; likelihood method may be preferred.
</p>


<h3>Author(s)</h3>

<p>A.I. McLeod
</p>


<h3>See Also</h3>

<p><code><a href="#topic+best_glp_models">best_glp_models</a></code>
<code><a href="#topic+print.bestmodels">print.bestmodels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ogden)
\dontrun{ #about 10 seconds
bestModels(ogden)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='bev'>
Beveridge Wheat Price Index, 1500 to 1869
</h2><span id='topic+bev'></span>

<h3>Description</h3>

<p>Beveridge Wheat Price Index which gives annual price data from 1500 to 1869.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bev")</code></pre>


<h3>Format</h3>

<p>The format is:
Time-Series [1:370] from 1500 to 1869: 17 19 20 15 13 14 14 14 14 11 ...
</p>


<h3>Details</h3>

<p>Baille suggests the time series is overdifferenced and is best fit
by an ARFIMA model.
</p>


<h3>Source</h3>

<p>CRAN package tseries.
</p>


<h3>References</h3>

<p>R. T. Baillie (1996): 
Long Memory Processes and Fractional Integration in Econometrics. 
Journal of Econometrics, 73, 5-59.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bev)
#series needs a log transformation as is evident from the plot
plot(bev)
## Not run: 
w &lt;- diff(bev)
bestModels(w)

## End(Not run)
</code></pre>

<hr>
<h2 id='eaglecol'>
Tree-ring indicies for Douglas Fir, Colorado, 1107-1964.
</h2><span id='topic+eaglecol'></span>

<h3>Description</h3>

<p>Tree-ring indicies for Douglas Fir, Colorado, 1107-1964.
There are 858 consecutive values.
When the environment is suboptimal, tree ring growth is limited by the climate,
usually either ambient temperature or precipitation.
For this tree-ring time series, the tree is located on a mountain
and the limiting growth factor is temperature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("eaglecol")</code></pre>


<h3>Format</h3>

<p>The format is:
Time-Series [1:858] from 1107 to 1964: 78 62 26 100 121 97 102 85 214 245 ...
</p>


<h3>Source</h3>

<p>Laboratory of Tree-ring Research (LTRR), The University of Arizona
<a href="http://ltrr.arizona.edu/">http://ltrr.arizona.edu/</a>
</p>


<h3>References</h3>

<p>Fritts, H.C. et al. (1971) 
Multivariate techniques for specifying tree-growth and climatic relationships 
and for reconstructing anomalies in Paleoclimate. 
Journal of Applied Meteorology, 10, pp.845-864.
</p>
<p>Hipel, K.W. and McLeod, A.I. (1994). 
Time Series Modelling of Water Resources and Environmental Systems.
Elsevier.
<a href="http://www.stats.uwo.ca/faculty/aim/1994Book/default.htm">http://www.stats.uwo.ca/faculty/aim/1994Book/default.htm</a>
</p>
<p>McLeod, A.I. &amp; Hipel, K.W. (1978), Preservation of the rescaled adjusted range, 
Water Resources Research 14, 491-516.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eaglecol)
plot(eaglecol)
## Not run: #confidence ellipse
library("ellipse") #needs this package!
ansTFD &lt;- artfima(eaglecol)
v &lt;- ansTFD$varbeta
bHat &lt;- c(ansTFD$dHat, ansTFD$lambdaHat)
xy &lt;- ellipse(v, centre=bHat, level=0.9)
plot(xy, type="l", lwd=2, xlab=expression(delta), ylab=expression(lambda))
points(matrix(bHat,ncol=2), pch=16, cex=3, col="blue")
#setwd("D:/DropBox/R/2016/artfima/Explore_ts_data/eaglecol")
#postscript(file="eaglecolCI.eps")
#plot(xy, type="l", lwd=2, xlab=expression(delta), ylab=expression(lambda))
#points(matrix(bHat,ncol=2), pch=16, cex=3, col="blue")
#graphics.off()

## End(Not run)
## Not run: #forecast comparison


## End(Not run)

</code></pre>

<hr>
<h2 id='ifisher'>
Information matrix for ARTFIMA
</h2><span id='topic+ifisher'></span>

<h3>Description</h3>

<p>The information matrix for the lambda and d in ARTFIMA model.
At present only the TFD and FD models are supported but it is planned
to extend this to the full ARTFIMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifisher(d = numeric(0), lambda = numeric(0), phi = numeric(0), 
  theta = numeric(0), sigma2 = 1, n = 1, obj = NULL, 
  alg = c("Fisher", "Whittle", "approx"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifisher_+3A_d">d</code></td>
<td>

<p>d parameter
</p>
</td></tr>
<tr><td><code id="ifisher_+3A_lambda">lambda</code></td>
<td>

<p>lambda parameter
</p>
</td></tr>
<tr><td><code id="ifisher_+3A_phi">phi</code></td>
<td>
<p>AR coefficients</p>
</td></tr>
<tr><td><code id="ifisher_+3A_theta">theta</code></td>
<td>
<p>MA coefficients, Box-Jenkins definition</p>
</td></tr>
<tr><td><code id="ifisher_+3A_sigma2">sigma2</code></td>
<td>

<p>innovation variance
</p>
</td></tr>
<tr><td><code id="ifisher_+3A_n">n</code></td>
<td>

<p>series length
</p>
</td></tr>
<tr><td><code id="ifisher_+3A_obj">obj</code></td>
<td>
<p>object of class artfima</p>
</td></tr>
<tr><td><code id="ifisher_+3A_alg">alg</code></td>
<td>
<p>&quot;Fisher&quot;, &quot;Whittle&quot; or &quot;approx&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the expected information matrix. The artfima() function returns
the component varbeta that is the inverse of the observed information
for a fitted model computed from the Hessian matrix.
</p>


<h3>Value</h3>

<table>
<tr><td><code>se</code></td>
<td>
<p>standard errors</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>information matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. I. McLeod
</p>


<h3>References</h3>

<p>TBA
</p>


<h3>See Also</h3>

<p><code><a href="#topic+artfima">artfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ifisher(d=0.2, lambda=0.0025)
ifisher(d=0.2, lambda=0.0025, alg="Whittle")
ifisher(d=0.2, lambda=0.0025, alg="approx")
</code></pre>

<hr>
<h2 id='nilemin'>
Nile Annual Minima, 622 AD to 1284 AD
</h2><span id='topic+nilemin'></span>

<h3>Description</h3>

<p>Annual Minimum flow of Nile River. See below for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("nilemin")</code></pre>


<h3>Format</h3>

<p>The format is:
Time-Series [1:663] from 622 to 1284: 11.57 10.88 11.69 11.69 9.84 ...
- attr(*, &quot;title&quot;)= chr &quot;#Nile River minima series&quot;
</p>


<h3>Details</h3>

<p>The minimum annual level of the Nile has been recorded over many 
centuries and was given by Toussoun (1925). The data over the 
period 622 AD to 1284 AD is considered more homogenous and reliable 
than the full dataset and has been analyzed by Beran (1994) and 
Percival and Walden (2000). 
The complete dataset is available StatLib Datasets - see:
hipel-mcleod archive, file: Minimum.
</p>


<h3>Source</h3>

<p>Toussoun, O. (1925). 
Memoire sur l'Histoire du Nil. 
In Memoires a l'Institut d'Egypte, 18, 366-404.
</p>


<h3>References</h3>

<p>Beran, J. (1994). 
Statistics for Long-Memory Processes. Chapman and Hall, New York.
</p>
<p>Percival, D.B. and Walden, A.T. (2000) 
Wavelet Methods for Time Series Analysis. 
Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nilemin)
artfima(nilemin, likAlg="Whittle")
## Not run: 
#compare exact and Whittle using bestModel()
start &lt;- proc.time()[3]
ans&lt;-bestModel(nilemin)
tot &lt;- proc.time()[3]-start
start &lt;- proc.time()[3]
ansW &lt;- bestModel(nilemin, likAlg="Whittle")
totW &lt;- proc.time()[3]-start
t &lt;- c(tot, totW)
names(t) &lt;- c("exact", "Whittle")
#compare times - about 100 seconds vs 3 seconds
t
#compare best models
ans
ansW
#AIC/BIC scores similar but rankings to change.
#ARTFIMA(0,0,0) is ranked best by both AIC and BIC
#ARIMA(2,0,1) is ranked second best by both AIC and BIC
#ARFIMA(0,0,0) is ranked 3rd by BIC and is not among top 5 by AIC

## End(Not run)
</code></pre>

<hr>
<h2 id='ogden'>
Mean Annual St.  Lawrence Riverflow
</h2><span id='topic+ogden'></span>

<h3>Description</h3>

<p>Mean Annual unregulated riverflows of the St.  Lawrence River at Ogdensburg, 
N.Y. from 1860 to 1957 is comprised of 97 consecutive observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ogden")</code></pre>


<h3>Format</h3>

<p>The format is:
Time-Series [1:97] from 1860 to 1956: 7788 8040 7733 7528 7528 ...
</p>


<h3>Details</h3>

<p>Hipel and McLeod (1994, 2005) showed this time series could be adequately
modelled using an AR(1).
</p>


<h3>Source</h3>

<p>Hipel, K.W. and McLeod, A.I., (1994, 2005).
Time Series Modelling of Water Resources and Environmental Systems.
Electronic reprint of our book orginally published in 1994.
<a href="http://www.stats.uwo.ca/faculty/aim/1994Book/">http://www.stats.uwo.ca/faculty/aim/1994Book/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ogden)
#compare fits of AR(1) and TFD
arima(ogden, order=c(1,0,0))
artfima(ogden) #this model has one more parameter

#Find AIC/BIC 3 best models. Takes about 10 sec
## Not run: 
system.time(ans &lt;- bestModels(ogden, nbest=3))
summary(ans) #summary provides plausibility as well as scores

## End(Not run)
</code></pre>

<hr>
<h2 id='Periodogram'>
Periodogram
</h2><span id='topic+Periodogram'></span>

<h3>Description</h3>

<p>Computes the raw periodogram defined by,
</p>
<p style="text-align: center;"><code class="reqn">
I(f_j) = \frac{1}{n} | sum z[t] exp(2 \pi f_j) |^2
</code>
</p>
 


<h3>Usage</h3>

<pre><code class='language-R'>Periodogram(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Periodogram_+3A_z">z</code></td>
<td>

<p>vector, time series
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected value of the periodogram equals the spectral density function.
</p>


<h3>Value</h3>

<p>the periodogram
</p>


<h3>Author(s)</h3>

<p>A. I. McLeod
</p>


<h3>See Also</h3>

<p><code><a href="#topic+artfimaSDF">artfimaSDF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sunspot.year)
Ip &lt;- Periodogram(sunspot.year)
fr &lt;- (1:length(Ip))/length(sunspot.year)
plot(fr, Ip, xlab="frequency", ylab="Periodogram")
</code></pre>

<hr>
<h2 id='plot.artfima'>Plot Method for &quot;arfima&quot; Object</h2><span id='topic+plot.artfima'></span>

<h3>Description</h3>

<p>Plots the observed periodogram and the fitted spectral density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'artfima'
plot(x, which = c("all", "logsdf", "loglogsdf", "res"),
                 mainQ = TRUE, subQ = TRUE, lag.max = 30, ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.artfima_+3A_x">x</code></td>
<td>
<p> object of class &quot;artfima&quot; </p>
</td></tr>
<tr><td><code id="plot.artfima_+3A_which">which</code></td>
<td>
<p>&quot;all&quot;, &quot;logsd&quot;, &quot;loglogsdf&quot; or &quot;res&quot; plot </p>
</td></tr>
<tr><td><code id="plot.artfima_+3A_mainq">mainQ</code></td>
<td>
<p> include plot title </p>
</td></tr>
<tr><td><code id="plot.artfima_+3A_subq">subQ</code></td>
<td>
<p> include subtitle </p>
</td></tr>
<tr><td><code id="plot.artfima_+3A_lag.max">lag.max</code></td>
<td>
<p> maximum lag in residual autocorrelation plot and test </p>
</td></tr>
<tr><td><code id="plot.artfima_+3A_...">...</code></td>
<td>
<p> optional arguments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Plot produced is a side-effect.</p>


<h3>Author(s)</h3>

<p>A. I. McLeod, aimcleod@uwo.ca</p>


<h3>See Also</h3>

<p><code><a href="#topic+artfima">artfima</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- artsim(n=500, d=5/6, lambda=0.045)
ans &lt;- artfima(z)
plot(ans)
plot(ans, which="loglogsdf", subQ=FALSE, mainQ=FALSE)
title(main="Simulated Series", sub="delta=5/6")
</code></pre>

<hr>
<h2 id='predict.artfima'>
Predict method for artfima
</h2><span id='topic+predict.artfima'></span>

<h3>Description</h3>

<p>The optimal minimum mean square error forecast and its standard deviation for
lags 1, 2, ..., n.ahead is computed at forecast origin starting at the end
of the observed series used in fitting. The exact algorithm discussed in
McLeod, Yu and Krougly is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'artfima'
predict(object, n.ahead=10, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.artfima_+3A_object">object</code></td>
<td>
<p> object of class &quot;artfima&quot; </p>
</td></tr>
<tr><td><code id="predict.artfima_+3A_n.ahead">n.ahead</code></td>
<td>
<p> number of steps ahead to forecast </p>
</td></tr>
<tr><td><code id="predict.artfima_+3A_...">...</code></td>
<td>
<p> optional arguments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two components
</p>
<table>
<tr><td><code>Forecasts</code></td>
<td>
<p>Description of 'comp1'</p>
</td></tr>
<tr><td><code>SDForecasts</code></td>
<td>
<p>Description of 'comp2'</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A. I. McLeod, aimcleod@uwo.ca</p>


<h3>References</h3>

<p>McLeod, A.I., Yu, Hao and Krougly, Z. (2007).  
Algorithms for Linear Time Series Analysis: With R Package.  
Journal of Statistical Software  23/5 1-26.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.Arima">predict.Arima</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ans &lt;- artfima(seriesa, likAlg="Whittle")
predict(ans)
#compare forecasts from ARTFIMA etc.
  ## Not run: 
ML &lt;- 10
ans &lt;- artfima(seriesa)
Ftfd &lt;- predict(ans, n.ahead=10)$Forecasts 
ans &lt;- artfima(seriesa, glp="ARIMA", arimaOrder=c(1,0,1))
Farma11 &lt;- predict(ans, n.ahead=10)$Forecasts 
ans &lt;- artfima(seriesa, glp="ARFIMA")
Ffd &lt;- predict(ans, n.ahead=10)$Forecasts
#arima(0,1,1)
ans &lt;- arima(seriesa, order=c(0,1,1))
fEWMA &lt;- predict(ans, n.ahead=10)$pred
yobs&lt;-seriesa[188:197]
xobs&lt;-188:197
y &lt;- matrix(c(yobs,Ffd,Ftfd,Farma11,fEWMA), ncol=5)
colnames(y)&lt;-c("obs", "FD", "TFD", "ARMA11","FEWMA")
x &lt;- 197+1:ML
x &lt;- matrix(c(xobs, rep(x, 4)), ncol=5)
plot(x, y, type="n", col=c("black", "red", "blue", "magenta"),
     xlab="t", ylab=expression(z[t]))
x &lt;- 197+1:ML
points(xobs, yobs, type="o", col="black")
points(x, Ffd, type="o", col="red")
points(x, Ftfd, type="o", col="blue")
points(x, Farma11, type="o", col="brown")
points(x, fEWMA, type="o", col="magenta")
legend(200, 18.1, legend=c("observed", "EWMA", "FD", "TFD", "ARMA"),
       col=c("black", "magenta", "red", "blue", "brown"),
       lty=c(rep(1,5)))
  
## End(Not run)
</code></pre>

<hr>
<h2 id='print.artfima'>Print Method for &quot;arfima&quot; Object</h2><span id='topic+print.artfima'></span>

<h3>Description</h3>

<p>Displays the fitted model.
The exact log-likelihood, AIC and BIC are shown.
The signal-to-noise ratio (snr) is defined the (sample variance minus the 
estimated innovation variance) divided by the innovation variance. 
Similar to the coefficient of determination in regression, 
it indicates how much of the randomness is captured by the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'artfima'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.artfima_+3A_x">x</code></td>
<td>
<p> object of class &quot;artfima&quot; </p>
</td></tr>
<tr><td><code id="print.artfima_+3A_...">...</code></td>
<td>
<p> optional arguments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A terse summary is displayed</p>


<h3>Author(s)</h3>

<p>A. I. McLeod, aimcleod@uwo.ca</p>


<h3>References</h3>

<p>TBA</p>


<h3>See Also</h3>

<p><code><a href="#topic+artfima">artfima</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>artfima(rnorm(100))
</code></pre>

<hr>
<h2 id='print.bestmodels'>
Print Method for &quot;bestmodels&quot; Object
</h2><span id='topic+print.bestmodels'></span>

<h3>Description</h3>

<p>Methods function for bestModels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bestmodels'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bestmodels_+3A_x">x</code></td>
<td>

<p>produced by bestModels
</p>
</td></tr>
<tr><td><code id="print.bestmodels_+3A_...">...</code></td>
<td>

<p>additional arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plausibility is shown. This is defined for AIC by the eqn
<code class="reqn">p(AIC) = exp(0.5*(min(AIC)-AIC))</code>,
where AIC is the vector of AIC values. Similarly for the BIC.
</p>


<h3>Value</h3>

<p>Data frame with 6 rows and 5 columns. The first column corresonds to best 
models,
second the second best, etc. The rows corresond respectively to the
chosen AIC models, AIC values, AIC plausibility, BIC models, BIC values and BIC
plausibility
</p>


<h3>Author(s)</h3>

<p>A. I. McLeod
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bestModels">bestModels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  #takes about 10 seconds
data(ogden)
ans&lt;-bestModels(ogden)
ans

## End(Not run)
</code></pre>

<hr>
<h2 id='SB32'>
Turbulent flow data from Station SB32
</h2><span id='topic+SB32'></span>

<h3>Description</h3>

<p>Turbulent flow water time series, Lake Huron, during 2009-2010.
Sampled every second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SB32")</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:5374] -2.2 1.4 -0.6 -0.4 -1.5 -2.6 -0.9 0.5 -0.9 1.5 ...
</p>


<h3>Details</h3>

<p>See paper by Meerschaert, Sabzikar, Phanikumar and Zeleke (2014).
</p>


<h3>References</h3>

<p>M.M. Meerschaert, Farzad Sabzikar, M.S. Phanikumar, and A. Zeleke, 
Tempered fractional time series model for turbulence in geophysical flows, 
Journal of Statistical Mechanics: Theory and Experiment, 
Vol. 2014 p. P09023 (13 pp.) doi:10.1088/1742-5468/2014/09/P09023.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SB32)
str(SB32)

#Figure from our paper
## Not run: 
ans0 &lt;- artfima(SB32, fixd=5/6)
ans1 &lt;- artfima(SB32, arimaOrder=c(1,0,2)) #best
p &lt;- ans1$arimaOrder[1]
q &lt;- ans1$arimaOrder[3]
sigmaSq1 &lt;- ans1$sigmaSq
sigmaSq0 &lt;- ans0$sigmaSq
w &lt;- SB32
n &lt;- length(w)
Ip &lt;- Periodogram(w)
fr &lt;- (1/n)*(1:length(Ip))
plot(log(fr), log(Ip), xlab="log frequency", ylab="log power", 
     type="p", col=rgb(0,0,1,0.4), pch=16)
y &lt;- sigmaSq1*artfimaSDF(n=length(SB32), obj=ans1, plot="none")
lines(log(fr), log(y), type="l", lwd=2.5, col="red")
y0 &lt;- sigmaSq0*artfimaSDF(n=length(SB32), obj=ans0, plot="none")
lines(log(fr), log(y0), type="l", lwd=3.5, col="green", lty=2)
TFD_label &lt;- expression(paste("TFD, ", delta == 5/6, ", ", 
                              hat(lambda) == 0.045))
legend(x=-8, y=-5, xjust=0, yjust=0, legend=c("ARTFIMA(1,0,2)", TFD_label), 
       lty=c(1,2), lwd=c(2.5,3.5), col=c("red", "green"), bty="n")

## End(Not run)

</code></pre>

<hr>
<h2 id='seriesa'>
Series A from Box and Jenkins
</h2><span id='topic+seriesa'></span>

<h3>Description</h3>

<p>Chemical process concentration readings every two hours is comprised
of 197 consecutive observations.
Box and Jenkins fit ARMA(1,1) and ARIMA(0,1,1) to this data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("seriesa")</code></pre>


<h3>Format</h3>

<p>The format is:
Time-Series [1:197] from 1 to 197: 17 16.6 16.3 16.1 17.1 16.9 16.8 17.4 17.1 17 ...
</p>


<h3>Source</h3>

<p>listed in Box and Jenkins book
</p>


<h3>References</h3>

<p>Box and Jenkins (1970). Time Series Analysis: Forecasting and Control.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(seriesa)
#compare ARMA(1,1) models and timings
system.time(arima(seriesa, order=c(1,0,1)))
system.time(artfima(seriesa, arimaOrder=c(1,0,1)))
#Remark: there is a slight difference due to the fact that arima() 
#uses the exact MLE for the mean parameter whereas artfima() uses
#the sample average. In practice, the difference is almost negible.
#
#Find AIC/BIC 3 best models. Takes about 15 sec
## Not run: 
system.time(ans &lt;- bestModels(seriesa, nbest=3))
summary(ans) #summary provides plausibility as well as scores

## End(Not run)
</code></pre>

<hr>
<h2 id='tseg'>
Simulate Some Time Series Models of Interest
</h2><span id='topic+tseg'></span>

<h3>Description</h3>

<p>Time series models are simulated based on some familar characteristics 
described in Details. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tseg(n, which = c("BJAR2", "BJAR1", "BJAR3", "PWAR4", "BJARMA11", "MHAR9", 
	"NileMin", "SB32"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tseg_+3A_n">n</code></td>
<td>

<p>length of series
</p>
</td></tr>
<tr><td><code id="tseg_+3A_which">which</code></td>
<td>

<p>which model
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BJAR1 is the AR(1) model fit to the sunspot series in BJR
BJAR2 is the AR(2) model fit to the sunspot series in BJR
BJAR3 is the AR(3) model fit to the sunspot series in BJR
BJAR2 is the AR(2) model fit to the sunspot series in BJR
PWAR4 is the AR(4) model, PW,
BJARMA11 is the ARMA(1,1) model fit to Series A in BJR
MHAR9 is the AR(9) model fit to the sunspot series in MHL
NileMin is ARFIMA(0,0,0), d=0.39
SB32 is ARTFIMA(0,0,0), d=5/8, lambda=0.045
</p>


<h3>Value</h3>

<p>vector of time series values
</p>


<h3>Author(s)</h3>

<p>A. I. McLeod
</p>


<h3>References</h3>

<p>BJR) Box, Jenkins and Reinsel (2005), Table 7.11
PW) Percival and Walden, 1990, p.45
MHL) McLeod, Hipel and Lennox, 1978, p.581
</p>


<h3>See Also</h3>

<p><code><a href="#topic+artsim">artsim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- tseg(5000, "MHAR9")
arima(z, order=c(9,0,0), fixed=c(NA,NA,0,0,0,0,0,0,NA,NA), transform.pars=FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
