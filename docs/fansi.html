<!DOCTYPE html><html><head><title>Help for package fansi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fansi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fansi'><p>Details About Manipulation of Strings Containing Control Sequences</p></a></li>
<li><a href='#dflt_term_cap'><p>Default Arg Helper Funs</p></a></li>
<li><a href='#fansi_lines'><p>Colorize Character Vectors</p></a></li>
<li><a href='#fwl'><p>Display Strings to Terminal</p></a></li>
<li><a href='#has_ctl'><p>Check for Presence of Control Sequences</p></a></li>
<li><a href='#has_sgr'><p>Check for Presence of Control Sequences</p></a></li>
<li><a href='#html_code_block'><p>Format Character Vector for Display as Code in HTML</p></a></li>
<li><a href='#html_esc'><p>Escape Characters With Special HTML Meaning</p></a></li>
<li><a href='#in_html'><p>Frame HTML in a Web Page And Display</p></a></li>
<li><a href='#make_styles'><p>Generate CSS Mapping Classes to Colors</p></a></li>
<li><a href='#nchar_ctl'><p>Control Sequence Aware Version of nchar</p></a></li>
<li><a href='#nchar_sgr'><p>Control Sequence Aware Version of nchar</p></a></li>
<li><a href='#normalize_state'><p>Normalize CSI and OSC Sequences</p></a></li>
<li><a href='#set_knit_hooks'><p>Set an Output Hook Convert Control Sequences to HTML in Rmarkdown</p></a></li>
<li><a href='#sgr_256'><p>Show 8 Bit CSI SGR Colors</p></a></li>
<li><a href='#sgr_to_html'><p>Convert Control Sequences to HTML Equivalents</p></a></li>
<li><a href='#state_at_end'><p>Utilities for Managing CSI and OSC State  In Strings</p></a></li>
<li><a href='#strip_ctl'><p>Strip Control Sequences</p></a></li>
<li><a href='#strip_sgr'><p>Strip Control Sequences</p></a></li>
<li><a href='#strsplit_ctl'><p>Control Sequence Aware Version of strsplit</p></a></li>
<li><a href='#strsplit_sgr'><p>Check for Presence of Control Sequences</p></a></li>
<li><a href='#strtrim_ctl'><p>Control Sequence Aware Version of strtrim</p></a></li>
<li><a href='#strtrim_sgr'><p>Control Sequence Aware Version of strtrim</p></a></li>
<li><a href='#strwrap_ctl'><p>Control Sequence Aware Version of strwrap</p></a></li>
<li><a href='#strwrap_sgr'><p>Control Sequence Aware Version of strwrap</p></a></li>
<li><a href='#substr_ctl'><p>Control Sequence Aware Version of substr</p></a></li>
<li><a href='#substr_sgr'><p>SGR Control Sequence Aware Version of substr</p></a></li>
<li><a href='#tabs_as_spaces'><p>Replace Tabs With Spaces</p></a></li>
<li><a href='#term_cap_test'><p>Test Terminal Capabilities</p></a></li>
<li><a href='#to_html'><p>Convert Control Sequences to HTML Equivalents</p></a></li>
<li><a href='#trimws_ctl'><p>Control Sequence Aware Version of trimws</p></a></li>
<li><a href='#unhandled_ctl'><p>Identify Unhandled Control Sequences</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>ANSI Control Sequence Aware String Functions</td>
</tr>
<tr>
<td>Description:</td>
<td>Counterparts to R string manipulation functions that account for
   the effects of ANSI text formatting control sequences.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/brodieG/fansi">https://github.com/brodieG/fansi</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/brodieG/fansi/issues">https://github.com/brodieG/fansi/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>unitizer, knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'constants.R' 'fansi-package.R' 'internal.R' 'load.R' 'misc.R'
'nchar.R' 'strwrap.R' 'strtrim.R' 'strsplit.R' 'substr2.R'
'trimws.R' 'tohtml.R' 'unhandled.R' 'normalize.R' 'sgr.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-06 00:59:41 UTC; bg</td>
</tr>
<tr>
<td>Author:</td>
<td>Brodie Gaslam [aut, cre],
  Elliott Sales De Andrade [ctb],
  R Core Team [cph] (UTF8 byte length calcs from src/util.c)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brodie Gaslam &lt;brodie.gaslam@yahoo.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 03:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fansi'>Details About Manipulation of Strings Containing Control Sequences</h2><span id='topic+fansi'></span><span id='topic+fansi-package'></span>

<h3>Description</h3>

<p>Counterparts to R string manipulation functions that account for
the effects of some ANSI X3.64 (a.k.a. ECMA-48, ISO-6429) control sequences.
</p>


<h3>Control Characters and Sequences</h3>

<p>Control characters and sequences are non-printing inline characters or
sequences initiated by them that can be used to modify terminal display and
behavior, for example by changing text color or cursor position.
</p>
<p>We will refer to X3.64/ECMA-48/ISO-6429 control characters and sequences as
&quot;<em>Control Sequences</em>&quot; hereafter.
</p>
<p>There are four types of <em>Control Sequences</em> that <code>fansi</code> can treat
specially:
</p>

<ul>
<li><p> &quot;C0&quot; control characters, such as tabs and carriage returns (we include
delete in this set, even though technically it is not part of it).
</p>
</li>
<li><p> Sequences starting in &quot;ESC[&quot;, also known as Control Sequence
Introducer (CSI) sequences, of which the Select Graphic Rendition (SGR)
sequences used to format terminal output are a subset.
</p>
</li>
<li><p> Sequences starting in &quot;ESC]&quot;, also known as Operating System
Commands (OSC), of which the subset beginning with &quot;8&quot; is used to encode
URI based hyperlinks.
</p>
</li>
<li><p> Sequences starting in &quot;ESC&quot; and followed by something other than &quot;[&quot; or
&quot;]&quot;.
</p>
</li></ul>

<p><em>Control Sequences</em> starting with ESC are assumed to be two characters
long (including the ESC) unless they are of the CSI or OSC variety, in which
case their length is computed as per the <a href="https://ecma-international.org/publications-and-standards/standards/ecma-48/">ECMA-48 specification</a>,
with the exception that <a href="#osc-hyperlinks">OSC hyperlinks</a> may be terminated
with BEL (&quot;\a&quot;) in addition to ST (&quot;ESC\&quot;).  <code>fansi</code> handles most common
<em>Control Sequences</em> in its parsing algorithms, but it is not a conforming
implementation of ECMA-48.  For example, there are non-CSI/OSC escape
sequences that may be longer than two characters, but <code>fansi</code> will
(incorrectly) treat them as if they were two characters long.  There are many
more unimplemented ECMA-48 specifications.
</p>
<p>In theory it is possible to encode CSI sequences with a single byte
introducing character in the 0x40-0x5F range instead of the traditional
&quot;ESC[&quot;.  Since this is rare and it conflicts with UTF-8 encoding, <code>fansi</code>
does not support it.
</p>
<p>Within <em>Control Sequences</em>, <code>fansi</code> further distinguishes CSI SGR and OSC
hyperlinks by recording format specification and URIs into string state, and
applying the same to any output strings according to the semantics of the
functions in use.  CSI SGR and OSC hyperlinks are known together as <em>Special
Sequences</em>.  See the following sections for details.
</p>
<p>Additionally, all <em>Control Sequences</em>, whether special or not,
do not count as characters, graphemes, or display width.  You can cause
<code>fansi</code> to treat particular <em>Control Sequences</em> as regular characters with
the <code>ctl</code> parameter.
</p>


<h3>CSI SGR Control Sequences</h3>

<p><strong>NOTE</strong>: not all displays support CSI SGR sequences; run
<code><a href="#topic+term_cap_test">term_cap_test</a></code> to see whether your display supports them.
</p>
<p>CSI SGR Control Sequences are the subset of CSI sequences that can be
used to change text appearance (e.g. color).  These sequences begin with
&quot;ESC[&quot; and end in &quot;m&quot;.  <code>fansi</code> interprets these sequences and writes new
ones to the output strings in such a way that the original formatting is
preserved.  In most cases this should be transparent to the user.
</p>
<p>Occasionally there may be mismatches between how <code>fansi</code> and a display
interpret the CSI SGR sequences, which may produce display artifacts.  The
most likely source of artifacts are <em>Control Sequences</em> that move
the cursor or change the display, or that <code>fansi</code> otherwise fails to
interpret, such as:
</p>

<ul>
<li><p> Unknown SGR substrings.
</p>
</li>
<li><p> &quot;C0&quot; control characters like tabs and carriage returns.
</p>
</li>
<li><p> Other escape sequences.
</p>
</li></ul>

<p>Another possible source of problems is that different displays parse
and interpret control sequences differently.  The common CSI SGR sequences
that you are likely to encounter in formatted text tend to be treated
consistently, but less common ones are not.  <code>fansi</code> tries to hew by the
ECMA-48 specification <strong>for CSI SGR control sequences</strong>, but not all
terminals do.
</p>
<p>The most likely source of problems will be 24-bit CSI SGR sequences.
For example, a 24-bit color sequence such as &quot;ESC[38;2;31;42;4&quot; is a
single foreground color to a terminal that supports it, or separate
foreground, background, faint, and underline specifications for one that does
not.  <code>fansi</code> will always interpret the sequences according to ECMA-48, but
it will warn you if encountered sequences exceed those specified by
the <code>term.cap</code> parameter or the &quot;fansi.term.cap&quot; global option.
</p>
<p><code>fansi</code> will will also warn if it encounters <em>Control Sequences</em> that it
cannot interpret.  You can turn off warnings via the <code>warn</code> parameter, which
can be set globally via the &quot;fansi.warn&quot; option.  You can work around &quot;C0&quot;
tabs characters by turning them into spaces first with <code><a href="#topic+tabs_as_spaces">tabs_as_spaces</a></code> or
with the <code>tabs.as.spaces</code> parameter available in some of the <code>fansi</code>
functions
</p>
<p><code>fansi</code> interprets CSI SGR sequences in cumulative &quot;Graphic Rendition
Combination Mode&quot;.  This means new SGR sequences add to rather than replace
previous ones, although in some cases the effect is the same as replacement
(e.g. if you have a color active and pick another one).
</p>


<h3>OSC Hyperlinks</h3>

<p>Operating System Commands are interpreted by terminal emulators typically to
engage actions external to the display of text proper, such as setting a
window title or changing the active color palette.
</p>
<p><a href="https://iterm2.com/documentation-escape-codes.html">Some terminals</a> have
added support for associating URIs to text with OSCs in a similar way to
anchors in HTML, so <code>fansi</code> interprets them and outputs or terminates them as
needed.  For example:
</p>
<div class="sourceCode"><pre>"\033]8;;xy.z\033\\LINK\033]8;;\033\\"
</pre></div>
<p>Might be interpreted as link to the URI &quot;x.z&quot;.  To make the encoding pattern
clearer, we replace &quot;\033]&quot; with &quot;&lt;OSC&gt;&quot; and &quot;\033\\&quot; with
&quot;&lt;ST&gt;&quot; below:
</p>
<div class="sourceCode"><pre>&lt;OSC&gt;8;;URI&lt;ST&gt;LINK TEXT&lt;OSC&gt;8;;&lt;ST&gt;
</pre></div>


<h3>State Interactions</h3>

<p>The cumulative nature of state as specified by SGR or OSC hyperlinks means
that unterminated strings that are spliced will interact with each other.
By extension, a substring does not inherently contain all the information
required to recreate its state as it appeared in the source document. The
default <code>fansi</code> configuration terminates extracted substrings and prepends
original state to them so they present on a stand-alone basis as they did as
part of the original string.
</p>
<p>To allow state in substrings to affect subsequent strings set <code>terminate = FALSE</code>, but you will need to manually terminate them or deal with the
consequences of not doing so (see &quot;Terminal Quirks&quot;).
</p>
<p>By default, <code>fansi</code> assumes that each element in an input character vector is
independent, but this is incorrect if the input is a single document with
each element a line in it.  In that situation state from each line should
bleed into subsequent ones.  Setting <code>carry = TRUE</code> enables the &quot;single
document&quot; interpretation.
</p>
<p>To most closely approximate what <code>writeLines(x)</code> produces on your terminal,
where <code>x</code> is a stateful string, use <code>writeLines(fansi_fun(x, carry=TRUE, terminate=FALSE))</code>.  <code>fansi_fun</code> is a stand-in for any of the <code>fansi</code> string
manipulation functions.  Note that even with a seeming &quot;null-op&quot; such as
<code>substr_ctl(x, 1, nchar_ctl(x), carry=TRUE, terminate=FALSE)</code> the output
control sequences may not match the input ones, but the output <em>should</em> look
the same if displayed to the terminal.
</p>
<p><code>fansi</code> strings will be affected by any active state in strings they are
appended to.  There are no parameters to control what happens in this case,
but <code>fansi</code> provides functions that can help the user get the desired
behavior.  <code>state_at_end</code> computes the active state the end of a string,
which can then be prepended onto the <em>input</em> of <code>fansi</code> functions so that
they are aware of the active style at the beginning of the string.
Alternatively, one could use <code>close_state(state_at_end(...))</code> and pre-pend
that to the <em>output</em> of <code>fansi</code> functions so they are unaffected by preceding
SGR.  One could also just prepend &quot;ESC[0m&quot;, but in some cases as
described in <code><a href="#topic+normalize_state">?normalize_state</a></code> that is sub-optimal.
</p>
<p>If you intend to combine stateful <code>fansi</code> manipulated strings with your own,
it may be best to set <code>normalize = TRUE</code> for improved compatibility (see
<code><a href="#topic+normalize_state">?normalize_state</a></code>.)
</p>


<h3>Terminal Quirks</h3>

<p>Some terminals (e.g. OS X terminal, ITerm2) will pre-paint the entirety of a
new line with the currently active background before writing the contents of
the line.  If there is a non-default active background color, any unwritten
columns in the new line will keep the prior background color even if the new
line changes the background color.  To avoid this be sure to use <code>terminate = TRUE</code> or to manually terminate each line with e.g.  &quot;ESC[0m&quot;.  The
problem manifests as:
</p>
<div class="sourceCode"><pre>" " = default background
"#" = new background
"&gt;" = start new background
"!" = restore default background

+-----------+
| abc\n     |
|&gt;###\n     |
|!abc\n#####| &lt;- trailing "#" after newline are from pre-paint
| abc       |
+-----------+
</pre></div>
<p>The simplest way to avoid this problem is to split input strings by any
newlines they contain, and use <code>terminate = TRUE</code> (the default).  A more
complex solution is to pad with spaces to the terminal window width before
emitting the newline to ensure the pre-paint is overpainted with the current
line's prevailing background color.
</p>


<h3>Encodings / UTF-8</h3>

<p><code>fansi</code> will convert any non-ASCII strings to UTF-8 before processing them,
and <code>fansi</code> functions that return strings will return them encoded in UTF-8.
In some cases this will be different to what base R does.  For example,
<code>substr</code> re-encodes substrings to their original encoding.
</p>
<p>Interpretation of UTF-8 strings is intended to be consistent with base R.
There are three ways things may not work out exactly as desired:
</p>

<ol>
<li> <p><code>fansi</code>, despite its best intentions, handles a UTF-8 sequence differently
to the way R does.
</p>
</li>
<li><p> R incorrectly handles a UTF-8 sequence.
</p>
</li>
<li><p> Your display incorrectly handles a UTF-8 sequence.
</p>
</li></ol>

<p>These issues are most likely to occur with invalid UTF-8 sequences,
combining character sequences, and emoji.  For example, whether special
characters such as emoji are considered one or two wide evolves as software
implements newer versions the Unicode databases.
</p>
<p>Internally, <code>fansi</code> computes the width of most UTF-8 character sequences
outside of the ASCII range using the native <code>R_nchar</code> function.  This will
cause such characters to be processed slower than ASCII characters.  Unlike R
(at least as of version 4.1), <code>fansi</code> can account for graphemes.
</p>
<p>Because <code>fansi</code> implements its own internal UTF-8 parsing it is possible
that you will see results different from those that R produces even on
strings without <em>Control Sequences</em>.
</p>


<h3>Overflow</h3>

<p>The maximum length of input character vector elements allowed by <code>fansi</code> is
the 32 bit INT_MAX, excluding the terminating NULL.  As of R4.1 this is the
limit for R character vector elements generally, but is enforced at the C
level by <code>fansi</code> nonetheless.
</p>
<p>It is possible that during processing strings that are shorter than INT_MAX
would become longer than that. <code>fansi</code> checks for that overflow and will
stop with an error if that happens.  A work-around for this situation is to
break up large strings into smaller ones.  The limit is on each element of a
character vector, not on the vector as a whole.  <code>fansi</code> will also error on
your system if <code>R_len_t</code>, the R type used to measure string lengths, is less
than the processed length of the string.
</p>


<h3>R &lt; 3.2.2 support</h3>

<p>Nominally you can build and run this package in R versions between 3.1.0 and
3.2.1.  Things should mostly work, but please be aware we do not run the test
suite under versions of R less than 3.2.2.  One key degraded capability is
width computation of wide-display characters.  Under R &lt; 3.2.2 <code>fansi</code> will
assume every character is 1 display width.  Additionally, <code>fansi</code> may not
always report malformed UTF-8 sequences as it usually does.  One
exception to this is <code><a href="#topic+nchar_ctl">nchar_ctl</a></code> as that is just a thin wrapper around
<code><a href="base.html#topic+nchar">base::nchar</a></code>.
</p>

<hr>
<h2 id='dflt_term_cap'>Default Arg Helper Funs</h2><span id='topic+dflt_term_cap'></span><span id='topic+dflt_css'></span>

<h3>Description</h3>

<p>Terminal capabilities are assumed to include bright and 256 color SGR codes.
24 bit color support is detected based on the <code>COLORTERM</code> environment
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dflt_term_cap()

dflt_css()
</code></pre>


<h3>Details</h3>

<p>Default CSS may exceed or fail to cover the interline distance when two lines
have background colors.  To ensure lines are exactly touching use
inline-block, although that has its own issues.  Otherwise specify your own
CSS.
</p>


<h3>Value</h3>

<p>character to use as default value for <code>fansi</code> parameter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+term_cap_test">term_cap_test</a></code>.
</p>

<hr>
<h2 id='fansi_lines'>Colorize Character Vectors</h2><span id='topic+fansi_lines'></span>

<h3>Description</h3>

<p>Color each element in input with one of the &quot;256 color&quot; ANSI CSI SGR codes.
This is intended for testing and demo purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fansi_lines(txt, step = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fansi_lines_+3A_txt">txt</code></td>
<td>
<p>character vector or object that can be coerced to character vector</p>
</td></tr>
<tr><td><code id="fansi_lines_+3A_step">step</code></td>
<td>
<p>integer(1L) how quickly to step through the color palette</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with each element colored
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NEWS &lt;- readLines(file.path(R.home('doc'), 'NEWS'))
writeLines(fansi_lines(NEWS[1:20]))
writeLines(fansi_lines(NEWS[1:20], step=8))
</code></pre>

<hr>
<h2 id='fwl'>Display Strings to Terminal</h2><span id='topic+fwl'></span>

<h3>Description</h3>

<p>Shortcut for <code><a href="base.html#topic+writeLines">writeLines</a></code> with an additional terminating &quot;ESC[0m&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwl(..., end = "&lt;END&gt;\033[0m")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fwl_+3A_...">...</code></td>
<td>
<p>character vectors to display.</p>
</td></tr>
<tr><td><code id="fwl_+3A_end">end</code></td>
<td>
<p>character what to output after the primary inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>whatever writeLines returns
</p>

<hr>
<h2 id='has_ctl'>Check for Presence of Control Sequences</h2><span id='topic+has_ctl'></span>

<h3>Description</h3>

<p><code>has_ctl</code> checks for any <em>Control Sequence</em>.  You can check for different
types of sequences with the <code>ctl</code> parameter.  Warnings are only emitted for
malformed CSI or OSC sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_ctl(x, ctl = "all", warn = getOption("fansi.warn", TRUE), which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_ctl_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="has_ctl_+3A_ctl">ctl</code></td>
<td>
<p>character, which <em>Control Sequences</em> should be treated
specially.  Special treatment is context dependent, and may include
detecting them and/or computing their display/character width as zero.  For
the SGR subset of the ANSI CSI sequences, and OSC hyperlinks, <code>fansi</code>
will also parse, interpret, and reapply the sequences as needed.  You can
modify whether a <em>Control Sequence</em> is treated specially with the <code>ctl</code>
parameter.
</p>

<ul>
<li><p> &quot;nl&quot;: newlines.
</p>
</li>
<li><p> &quot;c0&quot;: all other &quot;C0&quot; control characters (i.e. 0x01-0x1f, 0x7F), except
for newlines and the actual ESC (0x1B) character.
</p>
</li>
<li><p> &quot;sgr&quot;: ANSI CSI SGR sequences.
</p>
</li>
<li><p> &quot;csi&quot;: all non-SGR ANSI CSI sequences.
</p>
</li>
<li><p> &quot;url&quot;: OSC hyperlinks
</p>
</li>
<li><p> &quot;osc&quot;: all non-OSC-hyperlink OSC sequences.
</p>
</li>
<li><p> &quot;esc&quot;: all other escape sequences.
</p>
</li>
<li><p> &quot;all&quot;: all of the above, except when used in combination with any of the
above, in which case it means &quot;all but&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="has_ctl_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="has_ctl_+3A_which">which</code></td>
<td>
<p>character, deprecated in favor of <code>ctl</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical of same length as <code>x</code>; NA values in <code>x</code> result in NA values
in return
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+unhandled_ctl">unhandled_ctl</a></code> for detecting bad control sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>has_ctl("hello world")
has_ctl("hello\nworld")
has_ctl("hello\nworld", "sgr")
has_ctl("hello\033[31mworld\033[m", "sgr")
</code></pre>

<hr>
<h2 id='has_sgr'>Check for Presence of Control Sequences</h2><span id='topic+has_sgr'></span>

<h3>Description</h3>

<p>This function is deprecated in favor of the <code><a href="#topic+has_ctl">has_ctl</a></code>.  It
checks for CSI SGR and OSC hyperlink sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_sgr(x, warn = getOption("fansi.warn", TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_sgr_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="has_sgr_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical of same length as <code>x</code>; NA values in <code>x</code> result in NA values
in return
</p>

<hr>
<h2 id='html_code_block'>Format Character Vector for Display as Code in HTML</h2><span id='topic+html_code_block'></span>

<h3>Description</h3>

<p>This simulates what <code>rmarkdown</code> / <code>knitr</code> do to the output of an R markdown
chunk, at least as of <code>rmarkdown</code> 1.10.  It is useful when we override the
<code>knitr</code> output hooks so that we can have a result that still looks as if it
was run by <code>knitr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_code_block(x, class = "fansi-output")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_code_block_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="html_code_block_+3A_class">class</code></td>
<td>
<p>character vectors of classes to apply to the PRE HTML tags.  It
is the users responsibility to ensure the classes are valid CSS class
names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character(1L) <code>x</code>, with &lt;PRE&gt; and &lt;CODE&gt; HTML tags
applied and collapsed into one line with newlines as the line separator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>html_code_block(c("hello world"))
html_code_block(c("hello world"), class="pretty")
</code></pre>

<hr>
<h2 id='html_esc'>Escape Characters With Special HTML Meaning</h2><span id='topic+html_esc'></span>

<h3>Description</h3>

<p>Arbitrary text may contain characters with special meaning in HTML, which may
cause HTML display to be corrupted if they are included unescaped in a web
page.  This function escapes those special characters so they do not
interfere with the HTML markup generated by e.g. <code><a href="#topic+to_html">to_html</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_esc(x, what = getOption("fansi.html.esc", "&lt;&gt;&amp;'\""))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_esc_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="html_esc_+3A_what">what</code></td>
<td>
<p>character(1) containing any combination of ASCII characters
&quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&amp;&quot;, &quot;'&quot;, or &quot;\&quot;&quot;.  These characters are special in HTML contexts
and will be substituted by their HTML entity code.  By default, all
special characters are escaped, but in many cases &quot;&lt;&gt;&amp;&quot; or even &quot;&lt;&gt;&quot; might
be sufficient.
@return <code>x</code>, but with the <code>what</code> characters replaced by their HTML entity
codes.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Non-ASCII strings are converted to and returned in UTF-8 encoding.
</p>


<h3>See Also</h3>

<p>Other HTML functions: 
<code><a href="#topic+in_html">in_html</a>()</code>,
<code><a href="#topic+make_styles">make_styles</a>()</code>,
<code><a href="#topic+to_html">to_html</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>html_esc("day &gt; night")
html_esc("&lt;SPAN&gt;hello world&lt;/SPAN&gt;")
</code></pre>

<hr>
<h2 id='in_html'>Frame HTML in a Web Page And Display</h2><span id='topic+in_html'></span>

<h3>Description</h3>

<p>Helper function that assembles user provided HTML and CSS into a temporary
text file, and by default displays it in the browser.  Intended for use in
examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_html(x, css = character(), pre = TRUE, display = TRUE, clean = display)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_html_+3A_x">x</code></td>
<td>
<p>character vector of html encoded strings.</p>
</td></tr>
<tr><td><code id="in_html_+3A_css">css</code></td>
<td>
<p>character vector of css styles.</p>
</td></tr>
<tr><td><code id="in_html_+3A_pre">pre</code></td>
<td>
<p>TRUE (default) or FALSE, whether to wrap <code>x</code> in PRE tags.</p>
</td></tr>
<tr><td><code id="in_html_+3A_display">display</code></td>
<td>
<p>TRUE or FALSE, whether to display the resulting page in a
browser window.  If TRUE, will sleep for one second before returning, and
will delete the temporary file used to store the HTML.</p>
</td></tr>
<tr><td><code id="in_html_+3A_clean">clean</code></td>
<td>
<p>TRUE or FALSE, if TRUE and <code>display == TRUE</code>, will delete the
temporary file used for the web page, otherwise will leave it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character(1L) the file location of the page, invisibly, but keep in
mind it will have been deleted if <code>clean=TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_styles">make_styles()</a></code>.
</p>
<p>Other HTML functions: 
<code><a href="#topic+html_esc">html_esc</a>()</code>,
<code><a href="#topic+make_styles">make_styles</a>()</code>,
<code><a href="#topic+to_html">to_html</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt &lt;- "\033[31;42mHello \033[7mWorld\033[m"
writeLines(txt)
html &lt;- to_html(txt)
## Not run: 
in_html(html) # spawns a browser window

## End(Not run)
writeLines(readLines(in_html(html, display=FALSE)))
css &lt;- "SPAN {text-decoration: underline;}"
writeLines(readLines(in_html(html, css=css, display=FALSE)))
## Not run: 
in_html(html, css)

## End(Not run)
</code></pre>

<hr>
<h2 id='make_styles'>Generate CSS Mapping Classes to Colors</h2><span id='topic+make_styles'></span>

<h3>Description</h3>

<p>Given a set of class names, produce the CSS that maps them to the default
8-bit colors.  This is a helper function to generate style sheets for use
in examples with either default or remixed <code>fansi</code> colors.  In practice users
will create their own style sheets mapping their classes to their preferred
styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_styles(classes, rgb.mix = diag(3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_styles_+3A_classes">classes</code></td>
<td>
<p>a character vector of either 16, 32, or 512 class names.  The
character vectors are described in <code><a href="#topic+to_html">to_html</a></code>.</p>
</td></tr>
<tr><td><code id="make_styles_+3A_rgb.mix">rgb.mix</code></td>
<td>
<p>3 x 3 numeric matrix to remix color channels.  Given a N x 3
matrix of numeric RGB colors <code>rgb</code>, the colors used in the style sheet will
be <code>rgb %*% rgb.mix</code>.  Out of range values are clipped to the nearest bound
of the range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector that can be used as the contents of a style sheet.
</p>


<h3>See Also</h3>

<p>Other HTML functions: 
<code><a href="#topic+html_esc">html_esc</a>()</code>,
<code><a href="#topic+in_html">in_html</a>()</code>,
<code><a href="#topic+to_html">to_html</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some class strings; order matters
classes &lt;- do.call(paste, c(expand.grid(c("fg", "bg"), 0:7), sep="-"))
writeLines(classes[1:4])

## Some Default CSS
css0 &lt;- "span {font-size: 60pt; padding: 10px; display: inline-block}"

## Associated class strings to styles
css1 &lt;- make_styles(classes)
writeLines(css1[1:4])

## Generate SGR-derived HTML, mapping to classes
string &lt;- "\033[43mYellow\033[m\n\033[45mMagenta\033[m\n\033[46mCyan\033[m"
html &lt;- to_html(string, classes=classes)
writeLines(html)

## Combine in a page with styles and display in browser
## Not run: 
in_html(html, css=c(css0, css1))

## End(Not run)

## Change CSS by remixing colors, and apply to exact same HTML
mix &lt;- matrix(
  c(
    0, 1, 0,  # red output is green input
    0, 0, 1,  # green output is blue input
    1, 0, 0   # blue output is red input
  ),
  nrow=3, byrow=TRUE
)
css2 &lt;- make_styles(classes, rgb.mix=mix)
## Display in browser: same HTML but colors changed by CSS
## Not run: 
in_html(html, css=c(css0, css2))

## End(Not run)
</code></pre>

<hr>
<h2 id='nchar_ctl'>Control Sequence Aware Version of nchar</h2><span id='topic+nchar_ctl'></span><span id='topic+nzchar_ctl'></span>

<h3>Description</h3>

<p><code>nchar_ctl</code> counts all non <em>Control Sequence</em> characters.
<code>nzchar_ctl</code> returns TRUE for each input vector element that has non <em>Control
Sequence</em> sequence characters.  By default newlines and other C0 control
characters are not counted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nchar_ctl(
  x,
  type = "chars",
  allowNA = FALSE,
  keepNA = NA,
  ctl = "all",
  warn = getOption("fansi.warn", TRUE),
  strip
)

nzchar_ctl(
  x,
  keepNA = FALSE,
  ctl = "all",
  warn = getOption("fansi.warn", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nchar_ctl_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="nchar_ctl_+3A_type">type</code></td>
<td>
<p>character(1L) partial matching
<code>c("chars", "width", "graphemes")</code>, although types other than &quot;chars&quot; only
work correctly with R &gt;= 3.2.2.  See <code><a href="base.html#topic+nchar">?nchar</a></code>.</p>
</td></tr>
<tr><td><code id="nchar_ctl_+3A_allowna">allowNA</code></td>
<td>
<p>logical: should <code>NA</code> be returned for invalid
multibyte strings or <code>"bytes"</code>-encoded strings (rather than
throwing an error)?</p>
</td></tr>
<tr><td><code id="nchar_ctl_+3A_keepna">keepNA</code></td>
<td>
<p>logical: should <code>NA</code> be returned when
<code>x</code> is <code><a href="base.html#topic+NA">NA</a></code>?  If false, <code>nchar()</code> returns
<code>2</code>, as that is the number of printing characters used when
strings are written to output, and <code>nzchar()</code> is <code>TRUE</code>.  The
default for <code>nchar()</code>, <code>NA</code>, means to use <code>keepNA = TRUE</code>
unless <code>type</code> is <code>"width"</code>.</p>
</td></tr>
<tr><td><code id="nchar_ctl_+3A_ctl">ctl</code></td>
<td>
<p>character, which <em>Control Sequences</em> should be treated
specially.  Special treatment is context dependent, and may include
detecting them and/or computing their display/character width as zero.  For
the SGR subset of the ANSI CSI sequences, and OSC hyperlinks, <code>fansi</code>
will also parse, interpret, and reapply the sequences as needed.  You can
modify whether a <em>Control Sequence</em> is treated specially with the <code>ctl</code>
parameter.
</p>

<ul>
<li><p> &quot;nl&quot;: newlines.
</p>
</li>
<li><p> &quot;c0&quot;: all other &quot;C0&quot; control characters (i.e. 0x01-0x1f, 0x7F), except
for newlines and the actual ESC (0x1B) character.
</p>
</li>
<li><p> &quot;sgr&quot;: ANSI CSI SGR sequences.
</p>
</li>
<li><p> &quot;csi&quot;: all non-SGR ANSI CSI sequences.
</p>
</li>
<li><p> &quot;url&quot;: OSC hyperlinks
</p>
</li>
<li><p> &quot;osc&quot;: all non-OSC-hyperlink OSC sequences.
</p>
</li>
<li><p> &quot;esc&quot;: all other escape sequences.
</p>
</li>
<li><p> &quot;all&quot;: all of the above, except when used in combination with any of the
above, in which case it means &quot;all but&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="nchar_ctl_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="nchar_ctl_+3A_strip">strip</code></td>
<td>
<p>character, deprecated in favor of <code>ctl</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nchar_ctl</code> and <code>nzchar_ctl</code> are implemented in statically compiled code, so
in particular <code>nzchar_ctl</code> will be much faster than the otherwise equivalent
<code>nzchar(strip_ctl(...))</code>.
</p>
<p>These functions will warn if either malformed or escape or UTF-8 sequences
are encountered as they may be incorrectly interpreted.
</p>


<h3>Value</h3>

<p>Like <code><a href="base.html#topic+nchar">base::nchar</a></code>, with <em>Control Sequences</em> excluded.
</p>


<h3>Control and Special Sequences</h3>

<p><em>Control Sequences</em> are non-printing characters or sequences of characters.
<em>Special Sequences</em> are a subset of the <em>Control Sequences</em>, and include CSI
SGR sequences which can be used to change rendered appearance of text, and
OSC hyperlinks.  See <code><a href="#topic+fansi">fansi</a></code> for details.
</p>


<h3>Output Stability</h3>

<p>Several factors could affect the exact output produced by <code>fansi</code>
functions across versions of <code>fansi</code>, <code>R</code>, and/or across systems.
<strong>In general it is best not to rely on exact <code>fansi</code> output, e.g. by
embedding it in tests</strong>.
</p>
<p>Width and grapheme calculations depend on locale, Unicode database
version, and grapheme processing logic (which is still in development), among
other things.  For the most part <code>fansi</code> (currently) uses the internals of
<code>base::nchar(type='width')</code>, but there are exceptions and this may change in
the future.
</p>
<p>How a particular display format is encoded in <em>Control Sequences</em> is
not guaranteed to be stable across <code>fansi</code> versions.  Additionally, which
<em>Special Sequences</em> are re-encoded vs transcribed untouched may change.
In general we will strive to keep the rendered appearance stable.
</p>
<p>To maximize the odds of getting stable output set <code>normalize_state</code> to
<code>TRUE</code> and <code>type</code> to <code>"chars"</code> in functions that allow it, and
set <code>term.cap</code> to a specific set of capabilities.
</p>


<h3>Graphemes</h3>

<p><code>fansi</code> approximates grapheme widths and counts by using heuristics for
grapheme breaks that work for most common graphemes, including emoji
combining sequences.  The heuristic is known to work incorrectly with
invalid combining sequences, prepending marks, and sequence interruptors.
<code>fansi</code> does not provide a full implementation of grapheme break detection to
avoid carrying a copy of the Unicode grapheme breaks table, and also because
the hope is that R will add the feature eventually itself.
</p>
<p>The <a href="https://cran.r-project.org/package=utf8"><code>utf8</code></a> package provides a
conforming grapheme parsing implementation.
</p>


<h3>Note</h3>

<p>The <code>keepNA</code> parameter is ignored for R &lt; 3.2.2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+unhandled_ctl">unhandled_ctl</a></code> for detecting bad control sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nchar_ctl("\033[31m123\a\r")
## with some wide characters
cn.string &lt;-  sprintf("\033[31m%s\a\r", "\u4E00\u4E01\u4E03")
nchar_ctl(cn.string)
nchar_ctl(cn.string, type='width')

## Remember newlines are not counted by default
nchar_ctl("\t\n\r")

## The 'c0' value for the `ctl` argument does not include
## newlines.
nchar_ctl("\t\n\r", ctl="c0")
nchar_ctl("\t\n\r", ctl=c("c0", "nl"))

## The _sgr flavor only treats SGR sequences as zero width
nchar_sgr("\033[31m123")
nchar_sgr("\t\n\n123")

## All of the following are Control Sequences or C0 controls
nzchar_ctl("\n\033[42;31m\033[123P\a")
</code></pre>

<hr>
<h2 id='nchar_sgr'>Control Sequence Aware Version of nchar</h2><span id='topic+nchar_sgr'></span><span id='topic+nzchar_sgr'></span>

<h3>Description</h3>

<p>These functions are deprecated in favor of the <code><a href="#topic+nchar_ctl">nchar_ctl</a></code> and
<code><a href="#topic+nzchar_ctl">nzchar_ctl</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nchar_sgr(
  x,
  type = "chars",
  allowNA = FALSE,
  keepNA = NA,
  warn = getOption("fansi.warn", TRUE)
)

nzchar_sgr(x, keepNA = NA, warn = getOption("fansi.warn", TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nchar_sgr_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="nchar_sgr_+3A_type">type</code></td>
<td>
<p>character(1L) partial matching
<code>c("chars", "width", "graphemes")</code>, although types other than &quot;chars&quot; only
work correctly with R &gt;= 3.2.2.  See <code><a href="base.html#topic+nchar">?nchar</a></code>.</p>
</td></tr>
<tr><td><code id="nchar_sgr_+3A_allowna">allowNA</code></td>
<td>
<p>logical: should <code>NA</code> be returned for invalid
multibyte strings or <code>"bytes"</code>-encoded strings (rather than
throwing an error)?</p>
</td></tr>
<tr><td><code id="nchar_sgr_+3A_keepna">keepNA</code></td>
<td>
<p>logical: should <code>NA</code> be returned when
<code>x</code> is <code><a href="base.html#topic+NA">NA</a></code>?  If false, <code>nchar()</code> returns
<code>2</code>, as that is the number of printing characters used when
strings are written to output, and <code>nzchar()</code> is <code>TRUE</code>.  The
default for <code>nchar()</code>, <code>NA</code>, means to use <code>keepNA = TRUE</code>
unless <code>type</code> is <code>"width"</code>.</p>
</td></tr>
<tr><td><code id="nchar_sgr_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Like <code><a href="base.html#topic+nchar">base::nchar</a></code>, with <em>Control Sequences</em> excluded.
</p>

<hr>
<h2 id='normalize_state'>Normalize CSI and OSC Sequences</h2><span id='topic+normalize_state'></span>

<h3>Description</h3>

<p>Re-encodes SGR and OSC encoded URL sequences into a unique decomposed form.
Strings containing semantically identical SGR and OSC sequences that are
encoded differently should compare equal after normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_state(
  x,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  carry = getOption("fansi.carry", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_state_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="normalize_state_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="normalize_state_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="normalize_state_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each compound SGR sequence is broken up into individual tokens, superfluous
tokens are removed, and the SGR reset sequence &quot;ESC[0m&quot; (or &quot;ESC[m&quot;)
is replaced by the closing codes for whatever SGR styles are active at the
point in the string in which it appears.
</p>
<p>Unrecognized SGR codes will be dropped from the output with a warning.  The
specific order of SGR codes associated with any given SGR sequence is not
guaranteed to remain the same across different versions of <code>fansi</code>, but
should remain unchanged except for the addition of previously uninterpreted
codes to the list of interpretable codes.  There is no special significance
to the order the SGR codes are emitted in other than it should be consistent
for any given SGR state.  URLs adjacent to SGR codes are always emitted after
the SGR codes irrespective of what side they were on originally.
</p>
<p>OSC encoded URL sequences are always terminated by &quot;ESC]\&quot;, and those
between abutting URLs are omitted.  Identical abutting URLs are merged.  In
order for URLs to be considered identical both the URL and the &quot;id&quot; parameter
must be specified and be the same.  OSC URL parameters other than &quot;id&quot; are
dropped with a warning.
</p>
<p>The underlying assumption is that each element in the vector is
unaffected by SGR or OSC URLs in any other element or elsewhere.  This may
lead to surprising outcomes if these assumptions are untrue (see examples).
You may adjust this assumption with the <code>carry</code> parameter.
</p>
<p>Normalization was implemented primarily for better compatibility with
<a href="https://cran.r-project.org/package=crayon"><code>crayon</code></a> which emits SGR codes individually and assumes that each
opening code is paired up with its specific closing code, but it can also be
used to reduce the probability that strings processed with future versions of
<code>fansi</code> will produce different results than the current version.
</p>


<h3>Value</h3>

<p><code>x</code>, with all SGRs normalized.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+unhandled_ctl">unhandled_ctl</a></code> for detecting bad control sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalize_state("hello\033[42;33m world")
normalize_state("hello\033[42;33m world\033[m")
normalize_state("\033[4mhello\033[42;33m world\033[m")

## Superflous codes removed
normalize_state("\033[31;32mhello\033[m")      # only last color prevails
normalize_state("\033[31\033[32mhello\033[m")  # only last color prevails
normalize_state("\033[31mhe\033[49mllo\033[m") # unused closing

## Equivalent normalized sequences compare identical
identical(
  normalize_state("\033[31;32mhello\033[m"),
  normalize_state("\033[31mhe\033[49mllo\033[m")
)
## External SGR will defeat normalization, unless we `carry` it
red &lt;- "\033[41m"
writeLines(
  c(
    paste(red, "he\033[0mllo", "\033[0m"),
    paste(red, normalize_state("he\033[0mllo"), "\033[0m"),
    paste(red, normalize_state("he\033[0mllo", carry=red), "\033[0m")
) )
</code></pre>

<hr>
<h2 id='set_knit_hooks'>Set an Output Hook Convert Control Sequences to HTML in Rmarkdown</h2><span id='topic+set_knit_hooks'></span>

<h3>Description</h3>

<p>This is a convenience function designed for use within an <code>rmarkdown</code>
document.  It overrides the <code>knitr</code> output hooks by using
<code>knitr::knit_hooks$set</code>.  It replaces the hooks with ones that convert
<em>Control Sequences</em> into HTML.  In addition to replacing the hook functions,
this will output a &lt;STYLE&gt; HTML block to stdout.  These two actions are
side effects as a result of which R chunks in the <code>rmarkdown</code> document that
contain CSI SGR are shown in their HTML equivalent form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_knit_hooks(
  hooks,
  which = "output",
  proc.fun = function(x, class) html_code_block(to_html(html_esc(x)), class = class),
  class = sprintf("fansi fansi-%s", which),
  style = getOption("fansi.css", dflt_css()),
  split.nl = FALSE,
  .test = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_knit_hooks_+3A_hooks">hooks</code></td>
<td>
<p>list, this should the be <code>knitr::knit_hooks</code> object; we
require you pass this to avoid a run-time dependency on <code>knitr</code>.</p>
</td></tr>
<tr><td><code id="set_knit_hooks_+3A_which">which</code></td>
<td>
<p>character vector with the names of the hooks that should be
replaced, defaults to 'output', but can also contain values
'message', 'warning', and 'error'.</p>
</td></tr>
<tr><td><code id="set_knit_hooks_+3A_proc.fun">proc.fun</code></td>
<td>
<p>function that will be applied to output that contains
CSI SGR sequences.  Should accept parameters <code>x</code> and <code>class</code>, where <code>x</code> is
the output, and <code>class</code> is the CSS class that should be applied to
the &lt;PRE&gt;&lt;CODE&gt; blocks the output will be placed in.</p>
</td></tr>
<tr><td><code id="set_knit_hooks_+3A_class">class</code></td>
<td>
<p>character the CSS class to give the output chunks.  Each type of
output chunk specified in <code>which</code> will be matched position-wise to the
classes specified here.  This vector should be the same length as <code>which</code>.</p>
</td></tr>
<tr><td><code id="set_knit_hooks_+3A_style">style</code></td>
<td>
<p>character a vector of CSS styles; these will be output inside
HTML &gt;STYLE&lt; tags as a side effect.  The default value is designed to
ensure that there is no visible gap in background color with lines with
height 1.5 (as is the default setting in <code>rmarkdown</code> documents v1.1).</p>
</td></tr>
<tr><td><code id="set_knit_hooks_+3A_split.nl">split.nl</code></td>
<td>
<p>TRUE or FALSE (default), set to TRUE to split input strings
by any newlines they may contain to avoid any newlines inside SPAN tags
created by <code><a href="#topic+to_html">to_html()</a></code>.  Some markdown-&gt;html renders can be configured
to convert embedded newlines into line breaks, which may lead to a doubling
of line breaks.  With the default <code>proc.fun</code> the split strings are
recombined by <code><a href="#topic+html_code_block">html_code_block()</a></code>, but if you provide your own <code>proc.fun</code>
you'll need to account for the possibility that the character vector it
receives will have a different number of elements than the chunk output.
This argument only has an effect if chunk output contains CSI SGR
sequences.</p>
</td></tr>
<tr><td><code id="set_knit_hooks_+3A_.test">.test</code></td>
<td>
<p>TRUE or FALSE, for internal testing use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The replacement hook function tests for the presence of CSI SGR
sequences in chunk output with <code><a href="#topic+has_ctl">has_ctl</a></code>, and if it is detected then
processes it with the user provided <code>proc.fun</code>.  Chunks that do not contain
CSI SGR are passed off to the previously set hook function.  The default
<code>proc.fun</code> will run the output through <code><a href="#topic+html_esc">html_esc</a></code>, <code><a href="#topic+to_html">to_html</a></code>, and
finally <code><a href="#topic+html_code_block">html_code_block</a></code>.
</p>
<p>If you require more control than this function provides you can set the
<code>knitr</code> hooks manually with <code>knitr::knit_hooks$set</code>.  If you are seeing your
output gaining extra line breaks, look at the <code>split.nl</code> option.
</p>


<h3>Value</h3>

<p>named list with the prior output hooks for each of <code>which</code>.
</p>


<h3>Note</h3>

<p>Since we do not formally import the <code>knitr</code> functions we do not
guarantee that this function will always work properly with <code>knitr</code> /
<code>rmarkdown</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+has_ctl">has_ctl</a></code>, <code><a href="#topic+to_html">to_html</a></code>, <code><a href="#topic+html_esc">html_esc</a></code>, <code><a href="#topic+html_code_block">html_code_block</a></code>,
<a href="https://yihui.org/knitr/hooks/#output-hooks"><code>knitr</code> output hooks</a>,
<a href="https://bookdown.org/yihui/rmarkdown/language-engines.html#javascript-and-css">embedding CSS in Rmd</a>,
and the vignette <code>vignette(package='fansi', 'sgr-in-rmd')</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## The following should be done within an `rmarkdown` document chunk with
## chunk option `results` set to 'asis' and the chunk option `comment` set
## to ''.

```{r comment="", results='asis', echo=FALSE}
## Change the "output" hook to handle ANSI CSI SGR

old.hooks &lt;- set_knit_hooks(knitr::knit_hooks)

## Do the same with the warning, error, and message, and add styles for
## them (alternatively we could have done output as part of this call too)

styles &lt;- c(
  getOption('fansi.style', dflt_css()),  # default style
  "PRE.fansi CODE {background-color: transparent;}",
  "PRE.fansi-error {background-color: #DD5555;}",
  "PRE.fansi-warning {background-color: #DDDD55;}",
  "PRE.fansi-message {background-color: #EEEEEE;}"
)
old.hooks &lt;- c(
  old.hooks,
  fansi::set_knit_hooks(
    knitr::knit_hooks,
    which=c('warning', 'error', 'message'),
    style=styles
) )
```
## You may restore old hooks with the following chunk

## Restore Hooks
```{r}
do.call(knitr::knit_hooks$set, old.hooks)
```

## End(Not run)
</code></pre>

<hr>
<h2 id='sgr_256'>Show 8 Bit CSI SGR Colors</h2><span id='topic+sgr_256'></span>

<h3>Description</h3>

<p>Generates text with each 8 bit SGR code (e.g. the &quot;###&quot; in &quot;38;5;###&quot;) with
the background colored by itself, and the foreground in a contrasting color
and interesting color (we sacrifice some contrast for interest as this is
intended for demo rather than reference purposes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgr_256()
</code></pre>


<h3>Value</h3>

<p>character vector with SGR codes with background color set as
themselves.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_styles">make_styles()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>writeLines(sgr_256())
</code></pre>

<hr>
<h2 id='sgr_to_html'>Convert Control Sequences to HTML Equivalents</h2><span id='topic+sgr_to_html'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code><a href="#topic+to_html">to_html</a></code> and is kept around for legacy
reasons.  When we added capabilities for handling OSC hyperlinks, the <code>sgr_</code>
part of the name became an incomplete description of what the function
does.  The only substantive difference with the new function is this one does
not warn when the input contains unescaped &quot;&lt;&quot; or &quot;&gt;&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgr_to_html(
  x,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  classes = FALSE,
  carry = getOption("fansi.carry", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgr_to_html_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="sgr_to_html_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="sgr_to_html_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="sgr_to_html_+3A_classes">classes</code></td>
<td>
<p>FALSE (default), TRUE, or character vector of either 16,
32, or 512 class names.  Character strings may only contain ASCII
characters corresponding to letters, numbers, the hyphen, or the
underscore.  It is the user's responsibility to provide values that are
legal class names.
</p>

<ul>
<li><p> FALSE: All colors rendered as inline CSS styles.
</p>
</li>
<li><p> TRUE: Each of the 256 basic colors is mapped to a class in form
&quot;fansi-color-###&quot; (or &quot;fansi-bgcol-###&quot; for background colors)
where &quot;###&quot; is a zero padded three digit number in 0:255.  Basic colors
specified with SGR codes 30-37 (or 40-47) map to 000:007, and bright ones
specified with 90-97 (or 100-107) map to 008:015.  8 bit colors specified
with SGR codes 38;5;### or 48;5;### map directly based on the value of
&quot;###&quot;.  Implicitly, this maps the 8 bit colors in 0:7 to the basic
colors, and those in 8:15 to the bright ones even though these are not
exactly the same when using inline styles.  &quot;truecolor&quot;s specified with
38;2;#;#;# or 48;2;#;#;# do not map to classes and are rendered as inline
styles.
</p>
</li>
<li><p> character(16): The eight basic colors are mapped to the string values in
the vector, all others are rendered as inline CSS styles.  Basic colors
are mapped irrespective of whether they are encoded as the basic colors
or as 8-bit colors.  Sixteen elements are needed because there must be
eight classes for foreground colors, and eight classes for background
colors.  Classes should be ordered in ascending order of color number,
with foreground and background classes alternating starting with
foreground (see examples).
</p>
</li>
<li><p> character(32): Like character(16), except the basic and bright colors are
mapped.
</p>
</li>
<li><p> character(512): Like character(16), except the basic, bright, and all
other 8-bit colors are mapped.
</p>
</li></ul>
</td></tr>
<tr><td><code id="sgr_to_html_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the same length as <code>x</code> with all escape
sequences removed and any basic ANSI CSI SGR escape sequences applied via
SPAN HTML tags.
</p>


<h3>Note</h3>

<p>Unlike other functions, the default is <code>carry = TRUE</code> for compatibility
with semantics of prior versions of <code>fansi</code>.
</p>

<hr>
<h2 id='state_at_end'>Utilities for Managing CSI and OSC State  In Strings</h2><span id='topic+state_at_end'></span><span id='topic+close_state'></span>

<h3>Description</h3>

<p><code>state_at_end</code> reads through strings computing the accumulated SGR and
OSC hyperlinks, and outputs the active state at the end of them.
<code>close_state</code> produces the sequence that closes any SGR active and OSC
hyperlinks at the end of each input string.  If <code>normalize = FALSE</code>
(default), it will emit the reset code &quot;ESC[0m&quot; if any SGR is present.
It is more interesting for closing SGRs if <code>normalize = TRUE</code>.  Unlike
<code>state_at_end</code> and other functions <code>close_state</code> has no concept of <code>carry</code>:
it will only emit closing sequences for states explicitly active at the end
of a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state_at_end(
  x,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE)
)

close_state(
  x,
  warn = getOption("fansi.warn", TRUE),
  normalize = getOption("fansi.normalize", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state_at_end_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="state_at_end_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="state_at_end_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="state_at_end_+3A_normalize">normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
<tr><td><code id="state_at_end_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector same length as <code>x</code>.
</p>


<h3>Control and Special Sequences</h3>

<p><em>Control Sequences</em> are non-printing characters or sequences of characters.
<em>Special Sequences</em> are a subset of the <em>Control Sequences</em>, and include CSI
SGR sequences which can be used to change rendered appearance of text, and
OSC hyperlinks.  See <code><a href="#topic+fansi">fansi</a></code> for details.
</p>


<h3>Output Stability</h3>

<p>Several factors could affect the exact output produced by <code>fansi</code>
functions across versions of <code>fansi</code>, <code>R</code>, and/or across systems.
<strong>In general it is best not to rely on exact <code>fansi</code> output, e.g. by
embedding it in tests</strong>.
</p>
<p>Width and grapheme calculations depend on locale, Unicode database
version, and grapheme processing logic (which is still in development), among
other things.  For the most part <code>fansi</code> (currently) uses the internals of
<code>base::nchar(type='width')</code>, but there are exceptions and this may change in
the future.
</p>
<p>How a particular display format is encoded in <em>Control Sequences</em> is
not guaranteed to be stable across <code>fansi</code> versions.  Additionally, which
<em>Special Sequences</em> are re-encoded vs transcribed untouched may change.
In general we will strive to keep the rendered appearance stable.
</p>
<p>To maximize the odds of getting stable output set <code>normalize_state</code> to
<code>TRUE</code> and <code>type</code> to <code>"chars"</code> in functions that allow it, and
set <code>term.cap</code> to a specific set of capabilities.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+unhandled_ctl">unhandled_ctl</a></code> for detecting bad control sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("\033[44mhello", "\033[33mworld")
state_at_end(x)
state_at_end(x, carry=TRUE)
(close &lt;- close_state(state_at_end(x, carry=TRUE), normalize=TRUE))
writeLines(paste0(x, close, " no style"))
</code></pre>

<hr>
<h2 id='strip_ctl'>Strip Control Sequences</h2><span id='topic+strip_ctl'></span>

<h3>Description</h3>

<p>Removes <em>Control Sequences</em> from strings.  By default it will
strip all known <em>Control Sequences</em>, including CSI/OSC sequences, two
character sequences starting with ESC, and all C0 control characters,
including newlines.  You can fine tune this behavior with the <code>ctl</code>
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_ctl(x, ctl = "all", warn = getOption("fansi.warn", TRUE), strip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip_ctl_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="strip_ctl_+3A_ctl">ctl</code></td>
<td>
<p>character, any combination of the following values (see details):
</p>

<ul>
<li><p> &quot;nl&quot;: strip newlines.
</p>
</li>
<li><p> &quot;c0&quot;: strip all other &quot;C0&quot; control characters (i.e. x01-x1f, x7F),
except for newlines and the actual ESC character.
</p>
</li>
<li><p> &quot;sgr&quot;: strip ANSI CSI SGR sequences.
</p>
</li>
<li><p> &quot;csi&quot;: strip all non-SGR csi sequences.
</p>
</li>
<li><p> &quot;esc&quot;: strip all other escape sequences.
</p>
</li>
<li><p> &quot;all&quot;: all of the above, except when used in combination with any of the
above, in which case it means &quot;all but&quot; (see details).
</p>
</li></ul>
</td></tr>
<tr><td><code id="strip_ctl_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="strip_ctl_+3A_strip">strip</code></td>
<td>
<p>character, deprecated in favor of <code>ctl</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ctl</code> value contains the names of <strong>non-overlapping</strong> subsets of the
known <em>Control Sequences</em> (e.g. &quot;csi&quot; does not contain &quot;sgr&quot;, and &quot;c0&quot; does
not contain newlines).  The one exception is &quot;all&quot; which means strip every
known sequence.  If you combine &quot;all&quot; with any other options then everything
<strong>but</strong> those options will be stripped.
</p>


<h3>Value</h3>

<p>character vector of same length as x with ANSI escape sequences
stripped
</p>


<h3>Note</h3>

<p>Non-ASCII strings are converted to and returned in UTF-8 encoding.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+unhandled_ctl">unhandled_ctl</a></code> for detecting bad control sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- "hello\033k\033[45p world\n\033[31mgoodbye\a moon"
strip_ctl(string)
strip_ctl(string, c("nl", "c0", "sgr", "csi", "esc")) # equivalently
strip_ctl(string, "sgr")
strip_ctl(string, c("c0", "esc"))

## everything but C0 controls, we need to specify "nl"
## in addition to "c0" since "nl" is not part of "c0"
## as far as the `strip` argument is concerned
strip_ctl(string, c("all", "nl", "c0"))
</code></pre>

<hr>
<h2 id='strip_sgr'>Strip Control Sequences</h2><span id='topic+strip_sgr'></span>

<h3>Description</h3>

<p>This function is deprecated in favor of the <code><a href="#topic+strip_ctl">strip_ctl</a></code>.  It
strips CSI SGR and OSC hyperlink sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_sgr(x, warn = getOption("fansi.warn", TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip_sgr_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="strip_sgr_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of same length as x with ANSI escape sequences
stripped
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## convenience function, same as `strip_ctl(ctl=c('sgr', 'url'))`
string &lt;- "hello\033k\033[45p world\n\033[31mgoodbye\a moon"
strip_sgr(string)
</code></pre>

<hr>
<h2 id='strsplit_ctl'>Control Sequence Aware Version of strsplit</h2><span id='topic+strsplit_ctl'></span>

<h3>Description</h3>

<p>A drop-in replacement for <code><a href="base.html#topic+strsplit">base::strsplit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strsplit_ctl(
  x,
  split,
  fixed = FALSE,
  perl = FALSE,
  useBytes = FALSE,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strsplit_ctl_+3A_x">x</code></td>
<td>
<p>a character vector, or, unlike <code><a href="base.html#topic+strsplit">base::strsplit</a></code> an object that can
be coerced to character.</p>
</td></tr>
<tr><td><code id="strsplit_ctl_+3A_split">split</code></td>
<td>

<p>character vector (or object which can be coerced to such)
containing <a href="base.html#topic+regular+20expression">regular expression</a>(s) (unless <code>fixed = TRUE</code>)
to use for splitting.  If empty matches occur, in particular if
<code>split</code> has length 0, <code>x</code> is split into single characters.
If <code>split</code> has length greater than 1, it is re-cycled along
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="strsplit_ctl_+3A_fixed">fixed</code></td>
<td>

<p>logical.  If <code>TRUE</code> match <code>split</code> exactly, otherwise
use regular expressions.  Has priority over <code>perl</code>.
</p>
</td></tr>
<tr><td><code id="strsplit_ctl_+3A_perl">perl</code></td>
<td>
<p>logical.  Should Perl-compatible regexps be used?</p>
</td></tr>
<tr><td><code id="strsplit_ctl_+3A_usebytes">useBytes</code></td>
<td>
<p>logical.  If <code>TRUE</code> the matching is done
byte-by-byte rather than character-by-character, and inputs with
marked encodings are not converted.  This is forced (with a warning)
if any input is found which is marked as <code>"bytes"</code>
(see <code><a href="base.html#topic+Encoding">Encoding</a></code>).</p>
</td></tr>
<tr><td><code id="strsplit_ctl_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="strsplit_ctl_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="strsplit_ctl_+3A_ctl">ctl</code></td>
<td>
<p>character, which <em>Control Sequences</em> should be treated
specially.  Special treatment is context dependent, and may include
detecting them and/or computing their display/character width as zero.  For
the SGR subset of the ANSI CSI sequences, and OSC hyperlinks, <code>fansi</code>
will also parse, interpret, and reapply the sequences as needed.  You can
modify whether a <em>Control Sequence</em> is treated specially with the <code>ctl</code>
parameter.
</p>

<ul>
<li><p> &quot;nl&quot;: newlines.
</p>
</li>
<li><p> &quot;c0&quot;: all other &quot;C0&quot; control characters (i.e. 0x01-0x1f, 0x7F), except
for newlines and the actual ESC (0x1B) character.
</p>
</li>
<li><p> &quot;sgr&quot;: ANSI CSI SGR sequences.
</p>
</li>
<li><p> &quot;csi&quot;: all non-SGR ANSI CSI sequences.
</p>
</li>
<li><p> &quot;url&quot;: OSC hyperlinks
</p>
</li>
<li><p> &quot;osc&quot;: all non-OSC-hyperlink OSC sequences.
</p>
</li>
<li><p> &quot;esc&quot;: all other escape sequences.
</p>
</li>
<li><p> &quot;all&quot;: all of the above, except when used in combination with any of the
above, in which case it means &quot;all but&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="strsplit_ctl_+3A_normalize">normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
<tr><td><code id="strsplit_ctl_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
<tr><td><code id="strsplit_ctl_+3A_terminate">terminate</code></td>
<td>
<p>TRUE (default) or FALSE whether substrings should have
active state closed to avoid it bleeding into other strings they may be
prepended onto.  This does not stop state from carrying if <code>carry = TRUE</code>.
See the &quot;State Interactions&quot; section of <code><a href="#topic+fansi">?fansi</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works by computing the position of the split points after
removing <em>Control Sequences</em>, and uses those positions in conjunction with
<code><a href="#topic+substr_ctl">substr_ctl</a></code> to extract the pieces.  This concept is borrowed from
<code>crayon::col_strsplit</code>.  An important implication of this is that you cannot
split by <em>Control Sequences</em> that are being treated as <em>Control Sequences</em>.
You can however limit which control sequences are treated specially via the
<code>ctl</code> parameters (see examples).
</p>


<h3>Value</h3>

<p>Like <code><a href="base.html#topic+strsplit">base::strsplit</a></code>, with <em>Control Sequences</em> excluded.
</p>


<h3>Control and Special Sequences</h3>

<p><em>Control Sequences</em> are non-printing characters or sequences of characters.
<em>Special Sequences</em> are a subset of the <em>Control Sequences</em>, and include CSI
SGR sequences which can be used to change rendered appearance of text, and
OSC hyperlinks.  See <code><a href="#topic+fansi">fansi</a></code> for details.
</p>


<h3>Output Stability</h3>

<p>Several factors could affect the exact output produced by <code>fansi</code>
functions across versions of <code>fansi</code>, <code>R</code>, and/or across systems.
<strong>In general it is best not to rely on exact <code>fansi</code> output, e.g. by
embedding it in tests</strong>.
</p>
<p>Width and grapheme calculations depend on locale, Unicode database
version, and grapheme processing logic (which is still in development), among
other things.  For the most part <code>fansi</code> (currently) uses the internals of
<code>base::nchar(type='width')</code>, but there are exceptions and this may change in
the future.
</p>
<p>How a particular display format is encoded in <em>Control Sequences</em> is
not guaranteed to be stable across <code>fansi</code> versions.  Additionally, which
<em>Special Sequences</em> are re-encoded vs transcribed untouched may change.
In general we will strive to keep the rendered appearance stable.
</p>
<p>To maximize the odds of getting stable output set <code>normalize_state</code> to
<code>TRUE</code> and <code>type</code> to <code>"chars"</code> in functions that allow it, and
set <code>term.cap</code> to a specific set of capabilities.
</p>


<h3>Bidirectional Text</h3>

<p><code>fansi</code> is unaware of text directionality and operates as if all strings are
left to right (LTR).  Using <code>fansi</code> function with strings that contain mixed
direction scripts (i.e. both LTR and RTL) may produce undesirable results.
</p>


<h3>Note</h3>

<p>The split positions are computed after both <code>x</code> and <code>split</code> are
converted to UTF-8.
</p>
<p>Non-ASCII strings are converted to and returned in UTF-8 encoding.
Width calculations will not work properly in R &lt; 3.2.2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+normalize_state">normalize_state</a></code> for more details on what the <code>normalize</code> parameter does,
<code><a href="#topic+state_at_end">state_at_end</a></code> to compute active state at the end of strings,
<code><a href="#topic+close_state">close_state</a></code> to compute the sequence required to close active state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strsplit_ctl("\033[31mhello\033[42m world!", " ")

## Splitting by newlines does not work as they are _Control
## Sequences_, but we can use `ctl` to treat them as ordinary
strsplit_ctl("\033[31mhello\033[42m\nworld!", "\n")
strsplit_ctl("\033[31mhello\033[42m\nworld!", "\n", ctl=c("all", "nl"))
</code></pre>

<hr>
<h2 id='strsplit_sgr'>Check for Presence of Control Sequences</h2><span id='topic+strsplit_sgr'></span>

<h3>Description</h3>

<p>This function is deprecated in favor of the <code><a href="#topic+strsplit_ctl">strsplit_ctl</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strsplit_sgr(
  x,
  split,
  fixed = FALSE,
  perl = FALSE,
  useBytes = FALSE,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strsplit_sgr_+3A_x">x</code></td>
<td>
<p>a character vector, or, unlike <code><a href="base.html#topic+strsplit">base::strsplit</a></code> an object that can
be coerced to character.</p>
</td></tr>
<tr><td><code id="strsplit_sgr_+3A_split">split</code></td>
<td>

<p>character vector (or object which can be coerced to such)
containing <a href="base.html#topic+regular+20expression">regular expression</a>(s) (unless <code>fixed = TRUE</code>)
to use for splitting.  If empty matches occur, in particular if
<code>split</code> has length 0, <code>x</code> is split into single characters.
If <code>split</code> has length greater than 1, it is re-cycled along
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="strsplit_sgr_+3A_fixed">fixed</code></td>
<td>

<p>logical.  If <code>TRUE</code> match <code>split</code> exactly, otherwise
use regular expressions.  Has priority over <code>perl</code>.
</p>
</td></tr>
<tr><td><code id="strsplit_sgr_+3A_perl">perl</code></td>
<td>
<p>logical.  Should Perl-compatible regexps be used?</p>
</td></tr>
<tr><td><code id="strsplit_sgr_+3A_usebytes">useBytes</code></td>
<td>
<p>logical.  If <code>TRUE</code> the matching is done
byte-by-byte rather than character-by-character, and inputs with
marked encodings are not converted.  This is forced (with a warning)
if any input is found which is marked as <code>"bytes"</code>
(see <code><a href="base.html#topic+Encoding">Encoding</a></code>).</p>
</td></tr>
<tr><td><code id="strsplit_sgr_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="strsplit_sgr_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="strsplit_sgr_+3A_normalize">normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
<tr><td><code id="strsplit_sgr_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
<tr><td><code id="strsplit_sgr_+3A_terminate">terminate</code></td>
<td>
<p>TRUE (default) or FALSE whether substrings should have
active state closed to avoid it bleeding into other strings they may be
prepended onto.  This does not stop state from carrying if <code>carry = TRUE</code>.
See the &quot;State Interactions&quot; section of <code><a href="#topic+fansi">?fansi</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Like <code><a href="base.html#topic+strsplit">base::strsplit</a></code>, with <em>Control Sequences</em> excluded.
</p>

<hr>
<h2 id='strtrim_ctl'>Control Sequence Aware Version of strtrim</h2><span id='topic+strtrim_ctl'></span><span id='topic+strtrim2_ctl'></span>

<h3>Description</h3>

<p>A drop in replacement for <code><a href="base.html#topic+strtrim">base::strtrim</a></code>, with the difference that all
C0 control characters such as newlines, carriage returns, etc., are always
treated as zero width, whereas in base it may vary with platform / R version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strtrim_ctl(
  x,
  width,
  warn = getOption("fansi.warn", TRUE),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)

strtrim2_ctl(
  x,
  width,
  warn = getOption("fansi.warn", TRUE),
  tabs.as.spaces = getOption("fansi.tabs.as.spaces", FALSE),
  tab.stops = getOption("fansi.tab.stops", 8L),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strtrim_ctl_+3A_x">x</code></td>
<td>
<p>a character vector, or an object which can be coerced to a
character vector by <code><a href="base.html#topic+as.character">as.character</a></code>.</p>
</td></tr>
<tr><td><code id="strtrim_ctl_+3A_width">width</code></td>
<td>
<p>Positive integer values: recycled to the length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="strtrim_ctl_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="strtrim_ctl_+3A_ctl">ctl</code></td>
<td>
<p>character, which <em>Control Sequences</em> should be treated
specially.  Special treatment is context dependent, and may include
detecting them and/or computing their display/character width as zero.  For
the SGR subset of the ANSI CSI sequences, and OSC hyperlinks, <code>fansi</code>
will also parse, interpret, and reapply the sequences as needed.  You can
modify whether a <em>Control Sequence</em> is treated specially with the <code>ctl</code>
parameter.
</p>

<ul>
<li><p> &quot;nl&quot;: newlines.
</p>
</li>
<li><p> &quot;c0&quot;: all other &quot;C0&quot; control characters (i.e. 0x01-0x1f, 0x7F), except
for newlines and the actual ESC (0x1B) character.
</p>
</li>
<li><p> &quot;sgr&quot;: ANSI CSI SGR sequences.
</p>
</li>
<li><p> &quot;csi&quot;: all non-SGR ANSI CSI sequences.
</p>
</li>
<li><p> &quot;url&quot;: OSC hyperlinks
</p>
</li>
<li><p> &quot;osc&quot;: all non-OSC-hyperlink OSC sequences.
</p>
</li>
<li><p> &quot;esc&quot;: all other escape sequences.
</p>
</li>
<li><p> &quot;all&quot;: all of the above, except when used in combination with any of the
above, in which case it means &quot;all but&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="strtrim_ctl_+3A_normalize">normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
<tr><td><code id="strtrim_ctl_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
<tr><td><code id="strtrim_ctl_+3A_terminate">terminate</code></td>
<td>
<p>TRUE (default) or FALSE whether substrings should have
active state closed to avoid it bleeding into other strings they may be
prepended onto.  This does not stop state from carrying if <code>carry = TRUE</code>.
See the &quot;State Interactions&quot; section of <code><a href="#topic+fansi">?fansi</a></code> for details.</p>
</td></tr>
<tr><td><code id="strtrim_ctl_+3A_tabs.as.spaces">tabs.as.spaces</code></td>
<td>
<p>FALSE (default) or TRUE, whether to convert tabs to
spaces.  This can only be set to TRUE if <code>strip.spaces</code> is FALSE.</p>
</td></tr>
<tr><td><code id="strtrim_ctl_+3A_tab.stops">tab.stops</code></td>
<td>
<p>integer(1:n) indicating position of tab stops to use
when converting tabs to spaces.  If there are more tabs in a line than
defined tab stops the last tab stop is re-used.  For the purposes of
applying tab stops, each input line is considered a line and the character
count begins from the beginning of the input line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>strtrim2_ctl</code> adds the option of converting tabs to spaces before trimming.
This is the only difference between <code>strtrim_ctl</code> and <code>strtrim2_ctl</code>.
</p>


<h3>Value</h3>

<p>Like <code><a href="base.html#topic+strtrim">base::strtrim</a></code>, except that <em>Control Sequences</em> are treated
as zero width.
</p>


<h3>Note</h3>

<p>Non-ASCII strings are converted to and returned in UTF-8 encoding.
Width calculations will not work properly in R &lt; 3.2.2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+normalize_state">normalize_state</a></code> for more details on what the <code>normalize</code> parameter does,
<code><a href="#topic+state_at_end">state_at_end</a></code> to compute active state at the end of strings,
<code><a href="#topic+close_state">close_state</a></code> to compute the sequence required to close active state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strtrim_ctl("\033[42mHello world\033[m", 6)
</code></pre>

<hr>
<h2 id='strtrim_sgr'>Control Sequence Aware Version of strtrim</h2><span id='topic+strtrim_sgr'></span><span id='topic+strtrim2_sgr'></span>

<h3>Description</h3>

<p>These functions are deprecated in favor of the <code><a href="#topic+strtrim_ctl">strtrim_ctl</a></code> flavors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strtrim_sgr(
  x,
  width,
  warn = getOption("fansi.warn", TRUE),
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)

strtrim2_sgr(
  x,
  width,
  warn = getOption("fansi.warn", TRUE),
  tabs.as.spaces = getOption("fansi.tabs.as.spaces", FALSE),
  tab.stops = getOption("fansi.tab.stops", 8L),
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strtrim_sgr_+3A_x">x</code></td>
<td>
<p>a character vector, or an object which can be coerced to a
character vector by <code><a href="base.html#topic+as.character">as.character</a></code>.</p>
</td></tr>
<tr><td><code id="strtrim_sgr_+3A_width">width</code></td>
<td>
<p>Positive integer values: recycled to the length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="strtrim_sgr_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="strtrim_sgr_+3A_normalize">normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
<tr><td><code id="strtrim_sgr_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
<tr><td><code id="strtrim_sgr_+3A_terminate">terminate</code></td>
<td>
<p>TRUE (default) or FALSE whether substrings should have
active state closed to avoid it bleeding into other strings they may be
prepended onto.  This does not stop state from carrying if <code>carry = TRUE</code>.
See the &quot;State Interactions&quot; section of <code><a href="#topic+fansi">?fansi</a></code> for details.</p>
</td></tr>
<tr><td><code id="strtrim_sgr_+3A_tabs.as.spaces">tabs.as.spaces</code></td>
<td>
<p>FALSE (default) or TRUE, whether to convert tabs to
spaces.  This can only be set to TRUE if <code>strip.spaces</code> is FALSE.</p>
</td></tr>
<tr><td><code id="strtrim_sgr_+3A_tab.stops">tab.stops</code></td>
<td>
<p>integer(1:n) indicating position of tab stops to use
when converting tabs to spaces.  If there are more tabs in a line than
defined tab stops the last tab stop is re-used.  For the purposes of
applying tab stops, each input line is considered a line and the character
count begins from the beginning of the input line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Like <code><a href="base.html#topic+strtrim">base::strtrim</a></code>, except that <em>Control Sequences</em> are treated
as zero width.
</p>

<hr>
<h2 id='strwrap_ctl'>Control Sequence Aware Version of strwrap</h2><span id='topic+strwrap_ctl'></span><span id='topic+strwrap2_ctl'></span>

<h3>Description</h3>

<p>Wraps strings to a specified width accounting for <em>Control Sequences</em>.
<code>strwrap_ctl</code> is intended to emulate <code>strwrap</code> closely except with respect to
the <em>Control Sequences</em> (see details for other minor differences), while
<code>strwrap2_ctl</code> adds features and changes the processing of whitespace.
<code>strwrap_ctl</code> is faster than <code>strwrap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strwrap_ctl(
  x,
  width = 0.9 * getOption("width"),
  indent = 0,
  exdent = 0,
  prefix = "",
  simplify = TRUE,
  initial = prefix,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)

strwrap2_ctl(
  x,
  width = 0.9 * getOption("width"),
  indent = 0,
  exdent = 0,
  prefix = "",
  simplify = TRUE,
  initial = prefix,
  wrap.always = FALSE,
  pad.end = "",
  strip.spaces = !tabs.as.spaces,
  tabs.as.spaces = getOption("fansi.tabs.as.spaces", FALSE),
  tab.stops = getOption("fansi.tab.stops", 8L),
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strwrap_ctl_+3A_x">x</code></td>
<td>
<p>a character vector, or an object which can be converted to a
character vector by <code><a href="base.html#topic+as.character">as.character</a></code>.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_width">width</code></td>
<td>
<p>a positive integer giving the target column for wrapping
lines in the output.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_indent">indent</code></td>
<td>
<p>a non-negative integer giving the indentation of the
first line in a paragraph.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_exdent">exdent</code></td>
<td>
<p>a non-negative integer specifying the indentation of
subsequent lines in paragraphs.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_prefix">prefix</code>, <code id="strwrap_ctl_+3A_initial">initial</code></td>
<td>
<p>a character string to be used as prefix for
each line except the first, for which <code>initial</code> is used.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_simplify">simplify</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the result is a single
character vector of line text; otherwise, it is a list of the same
length as <code>x</code> the elements of which are character vectors of
line text obtained from the corresponding element of <code>x</code>.
(Hence, the result in the former case is obtained by unlisting that
of the latter.)</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_ctl">ctl</code></td>
<td>
<p>character, which <em>Control Sequences</em> should be treated
specially.  Special treatment is context dependent, and may include
detecting them and/or computing their display/character width as zero.  For
the SGR subset of the ANSI CSI sequences, and OSC hyperlinks, <code>fansi</code>
will also parse, interpret, and reapply the sequences as needed.  You can
modify whether a <em>Control Sequence</em> is treated specially with the <code>ctl</code>
parameter.
</p>

<ul>
<li><p> &quot;nl&quot;: newlines.
</p>
</li>
<li><p> &quot;c0&quot;: all other &quot;C0&quot; control characters (i.e. 0x01-0x1f, 0x7F), except
for newlines and the actual ESC (0x1B) character.
</p>
</li>
<li><p> &quot;sgr&quot;: ANSI CSI SGR sequences.
</p>
</li>
<li><p> &quot;csi&quot;: all non-SGR ANSI CSI sequences.
</p>
</li>
<li><p> &quot;url&quot;: OSC hyperlinks
</p>
</li>
<li><p> &quot;osc&quot;: all non-OSC-hyperlink OSC sequences.
</p>
</li>
<li><p> &quot;esc&quot;: all other escape sequences.
</p>
</li>
<li><p> &quot;all&quot;: all of the above, except when used in combination with any of the
above, in which case it means &quot;all but&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_normalize">normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_terminate">terminate</code></td>
<td>
<p>TRUE (default) or FALSE whether substrings should have
active state closed to avoid it bleeding into other strings they may be
prepended onto.  This does not stop state from carrying if <code>carry = TRUE</code>.
See the &quot;State Interactions&quot; section of <code><a href="#topic+fansi">?fansi</a></code> for details.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_wrap.always">wrap.always</code></td>
<td>
<p>TRUE or FALSE (default), whether to hard wrap at requested
width if no word breaks are detected within a line.  If set to TRUE then
<code>width</code> must be at least 2.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_pad.end">pad.end</code></td>
<td>
<p>character(1L), a single character to use as padding at the
end of each line until the line is <code>width</code> wide.  This must be a printable
ASCII character or an empty string (default).  If you set it to an empty
string the line remains unpadded.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_strip.spaces">strip.spaces</code></td>
<td>
<p>TRUE (default) or FALSE, if TRUE, extraneous white spaces
(spaces, newlines, tabs) are removed in the same way as <a href="base.html#topic+strwrap">base::strwrap</a>
does.  When FALSE, whitespaces are preserved, except for newlines as those
are implicit boundaries between output vector elements.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_tabs.as.spaces">tabs.as.spaces</code></td>
<td>
<p>FALSE (default) or TRUE, whether to convert tabs to
spaces.  This can only be set to TRUE if <code>strip.spaces</code> is FALSE.</p>
</td></tr>
<tr><td><code id="strwrap_ctl_+3A_tab.stops">tab.stops</code></td>
<td>
<p>integer(1:n) indicating position of tab stops to use
when converting tabs to spaces.  If there are more tabs in a line than
defined tab stops the last tab stop is re-used.  For the purposes of
applying tab stops, each input line is considered a line and the character
count begins from the beginning of the input line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>strwrap2_ctl</code> can convert tabs to spaces, pad strings up to <code>width</code>, and
hard-break words if single words are wider than <code>width</code>.
</p>
<p>Unlike <a href="base.html#topic+strwrap">base::strwrap</a>, both these functions will translate any non-ASCII
strings to UTF-8 and return them in UTF-8.  Additionally, invalid UTF-8
always causes errors, and <code>prefix</code> and <code>indent</code> must be scalar.
</p>
<p>When replacing tabs with spaces the tabs are computed relative to the
beginning of the input line, not the most recent wrap point.
Additionally,<code>indent</code>, <code>exdent</code>, <code>initial</code>, and <code>prefix</code> will be ignored when
computing tab positions.
</p>


<h3>Value</h3>

<p>A character vector, or list of character vectors if <code>simplify</code> is
false.
</p>


<h3>Control and Special Sequences</h3>

<p><em>Control Sequences</em> are non-printing characters or sequences of characters.
<em>Special Sequences</em> are a subset of the <em>Control Sequences</em>, and include CSI
SGR sequences which can be used to change rendered appearance of text, and
OSC hyperlinks.  See <code><a href="#topic+fansi">fansi</a></code> for details.
</p>


<h3>Graphemes</h3>

<p><code>fansi</code> approximates grapheme widths and counts by using heuristics for
grapheme breaks that work for most common graphemes, including emoji
combining sequences.  The heuristic is known to work incorrectly with
invalid combining sequences, prepending marks, and sequence interruptors.
<code>fansi</code> does not provide a full implementation of grapheme break detection to
avoid carrying a copy of the Unicode grapheme breaks table, and also because
the hope is that R will add the feature eventually itself.
</p>
<p>The <a href="https://cran.r-project.org/package=utf8"><code>utf8</code></a> package provides a
conforming grapheme parsing implementation.
</p>


<h3>Output Stability</h3>

<p>Several factors could affect the exact output produced by <code>fansi</code>
functions across versions of <code>fansi</code>, <code>R</code>, and/or across systems.
<strong>In general it is best not to rely on exact <code>fansi</code> output, e.g. by
embedding it in tests</strong>.
</p>
<p>Width and grapheme calculations depend on locale, Unicode database
version, and grapheme processing logic (which is still in development), among
other things.  For the most part <code>fansi</code> (currently) uses the internals of
<code>base::nchar(type='width')</code>, but there are exceptions and this may change in
the future.
</p>
<p>How a particular display format is encoded in <em>Control Sequences</em> is
not guaranteed to be stable across <code>fansi</code> versions.  Additionally, which
<em>Special Sequences</em> are re-encoded vs transcribed untouched may change.
In general we will strive to keep the rendered appearance stable.
</p>
<p>To maximize the odds of getting stable output set <code>normalize_state</code> to
<code>TRUE</code> and <code>type</code> to <code>"chars"</code> in functions that allow it, and
set <code>term.cap</code> to a specific set of capabilities.
</p>


<h3>Bidirectional Text</h3>

<p><code>fansi</code> is unaware of text directionality and operates as if all strings are
left to right (LTR).  Using <code>fansi</code> function with strings that contain mixed
direction scripts (i.e. both LTR and RTL) may produce undesirable results.
</p>


<h3>Note</h3>

<p>Non-ASCII strings are converted to and returned in UTF-8 encoding.
Width calculations will not work properly in R &lt; 3.2.2.
</p>
<p>For the <code style="white-space: pre;">&#8288;strwrap*&#8288;</code> functions the <code>carry</code> parameter affects whether
styles are carried across <em>input</em> vector elements.  Styles always carry
within a single wrapped vector element (e.g. if one of the input elements
gets wrapped into three lines, the styles will carry through those three
lines even if <code>carry=FALSE</code>, but not across input vector elements).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+normalize_state">normalize_state</a></code> for more details on what the <code>normalize</code> parameter does,
<code><a href="#topic+state_at_end">state_at_end</a></code> to compute active state at the end of strings,
<code><a href="#topic+close_state">close_state</a></code> to compute the sequence required to close active state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hello.1 &lt;- "hello \033[41mred\033[49m world"
hello.2 &lt;- "hello\t\033[41mred\033[49m\tworld"

strwrap_ctl(hello.1, 12)
strwrap_ctl(hello.2, 12)

## In default mode strwrap2_ctl is the same as strwrap_ctl
strwrap2_ctl(hello.2, 12)

## But you can leave whitespace unchanged, `warn`
## set to false as otherwise tabs causes warning
strwrap2_ctl(hello.2, 12, strip.spaces=FALSE, warn=FALSE)

## And convert tabs to spaces
strwrap2_ctl(hello.2, 12, tabs.as.spaces=TRUE)

## If your display has 8 wide tab stops the following two
## outputs should look the same
writeLines(strwrap2_ctl(hello.2, 80, tabs.as.spaces=TRUE))
writeLines(hello.2)

## tab stops are NOT auto-detected, but you may provide
## your own
strwrap2_ctl(hello.2, 12, tabs.as.spaces=TRUE, tab.stops=c(6, 12))

## You can also force padding at the end to equal width
writeLines(strwrap2_ctl("hello how are you today", 10, pad.end="."))

## And a more involved example where we read the
## NEWS file, color it line by line, wrap it to
## 25 width and display some of it in 3 columns
## (works best on displays that support 256 color
## SGR sequences)

NEWS &lt;- readLines(file.path(R.home('doc'), 'NEWS'))
NEWS.C &lt;- fansi_lines(NEWS, step=2)  # color each line
W &lt;- strwrap2_ctl(NEWS.C, 25, pad.end=" ", wrap.always=TRUE)
writeLines(c("", paste(W[1:20], W[100:120], W[200:220]), ""))
</code></pre>

<hr>
<h2 id='strwrap_sgr'>Control Sequence Aware Version of strwrap</h2><span id='topic+strwrap_sgr'></span><span id='topic+strwrap2_sgr'></span>

<h3>Description</h3>

<p>These functions are deprecated in favor of the <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> flavors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strwrap_sgr(
  x,
  width = 0.9 * getOption("width"),
  indent = 0,
  exdent = 0,
  prefix = "",
  simplify = TRUE,
  initial = prefix,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)

strwrap2_sgr(
  x,
  width = 0.9 * getOption("width"),
  indent = 0,
  exdent = 0,
  prefix = "",
  simplify = TRUE,
  initial = prefix,
  wrap.always = FALSE,
  pad.end = "",
  strip.spaces = !tabs.as.spaces,
  tabs.as.spaces = getOption("fansi.tabs.as.spaces", FALSE),
  tab.stops = getOption("fansi.tab.stops", 8L),
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strwrap_sgr_+3A_x">x</code></td>
<td>
<p>a character vector, or an object which can be converted to a
character vector by <code><a href="base.html#topic+as.character">as.character</a></code>.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_width">width</code></td>
<td>
<p>a positive integer giving the target column for wrapping
lines in the output.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_indent">indent</code></td>
<td>
<p>a non-negative integer giving the indentation of the
first line in a paragraph.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_exdent">exdent</code></td>
<td>
<p>a non-negative integer specifying the indentation of
subsequent lines in paragraphs.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_prefix">prefix</code>, <code id="strwrap_sgr_+3A_initial">initial</code></td>
<td>
<p>a character string to be used as prefix for
each line except the first, for which <code>initial</code> is used.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_simplify">simplify</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the result is a single
character vector of line text; otherwise, it is a list of the same
length as <code>x</code> the elements of which are character vectors of
line text obtained from the corresponding element of <code>x</code>.
(Hence, the result in the former case is obtained by unlisting that
of the latter.)</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_normalize">normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_terminate">terminate</code></td>
<td>
<p>TRUE (default) or FALSE whether substrings should have
active state closed to avoid it bleeding into other strings they may be
prepended onto.  This does not stop state from carrying if <code>carry = TRUE</code>.
See the &quot;State Interactions&quot; section of <code><a href="#topic+fansi">?fansi</a></code> for details.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_wrap.always">wrap.always</code></td>
<td>
<p>TRUE or FALSE (default), whether to hard wrap at requested
width if no word breaks are detected within a line.  If set to TRUE then
<code>width</code> must be at least 2.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_pad.end">pad.end</code></td>
<td>
<p>character(1L), a single character to use as padding at the
end of each line until the line is <code>width</code> wide.  This must be a printable
ASCII character or an empty string (default).  If you set it to an empty
string the line remains unpadded.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_strip.spaces">strip.spaces</code></td>
<td>
<p>TRUE (default) or FALSE, if TRUE, extraneous white spaces
(spaces, newlines, tabs) are removed in the same way as <a href="base.html#topic+strwrap">base::strwrap</a>
does.  When FALSE, whitespaces are preserved, except for newlines as those
are implicit boundaries between output vector elements.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_tabs.as.spaces">tabs.as.spaces</code></td>
<td>
<p>FALSE (default) or TRUE, whether to convert tabs to
spaces.  This can only be set to TRUE if <code>strip.spaces</code> is FALSE.</p>
</td></tr>
<tr><td><code id="strwrap_sgr_+3A_tab.stops">tab.stops</code></td>
<td>
<p>integer(1:n) indicating position of tab stops to use
when converting tabs to spaces.  If there are more tabs in a line than
defined tab stops the last tab stop is re-used.  For the purposes of
applying tab stops, each input line is considered a line and the character
count begins from the beginning of the input line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector, or list of character vectors if <code>simplify</code> is
false.
</p>

<hr>
<h2 id='substr_ctl'>Control Sequence Aware Version of substr</h2><span id='topic+substr_ctl'></span><span id='topic+substr2_ctl'></span><span id='topic+substr_ctl+3C-'></span><span id='topic+substr2_ctl+3C-'></span>

<h3>Description</h3>

<p><code>substr_ctl</code> is a drop-in replacement for <code>substr</code>.  Performance is
slightly slower than <code>substr</code>, and more so for <code>type = 'width'</code>.  Special
<em>Control Sequences</em> will be included in the substrings to reflect their format
when as it was when part of the source string.  <code>substr2_ctl</code> adds the
ability to extract substrings based on grapheme count or display width in
addition to the normal character width, as well as several other options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substr_ctl(
  x,
  start,
  stop,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)

substr2_ctl(
  x,
  start,
  stop,
  type = "chars",
  round = "start",
  tabs.as.spaces = getOption("fansi.tabs.as.spaces", FALSE),
  tab.stops = getOption("fansi.tab.stops", 8L),
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)

substr_ctl(
  x,
  start,
  stop,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
) &lt;- value

substr2_ctl(
  x,
  start,
  stop,
  type = "chars",
  round = "start",
  tabs.as.spaces = getOption("fansi.tabs.as.spaces", FALSE),
  tab.stops = getOption("fansi.tab.stops", 8L),
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substr_ctl_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_start">start</code></td>
<td>
<p>integer.  The first element to be extracted or replaced.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_stop">stop</code></td>
<td>
<p>integer.  The first element to be extracted or replaced.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_ctl">ctl</code></td>
<td>
<p>character, which <em>Control Sequences</em> should be treated
specially.  Special treatment is context dependent, and may include
detecting them and/or computing their display/character width as zero.  For
the SGR subset of the ANSI CSI sequences, and OSC hyperlinks, <code>fansi</code>
will also parse, interpret, and reapply the sequences as needed.  You can
modify whether a <em>Control Sequence</em> is treated specially with the <code>ctl</code>
parameter.
</p>

<ul>
<li><p> &quot;nl&quot;: newlines.
</p>
</li>
<li><p> &quot;c0&quot;: all other &quot;C0&quot; control characters (i.e. 0x01-0x1f, 0x7F), except
for newlines and the actual ESC (0x1B) character.
</p>
</li>
<li><p> &quot;sgr&quot;: ANSI CSI SGR sequences.
</p>
</li>
<li><p> &quot;csi&quot;: all non-SGR ANSI CSI sequences.
</p>
</li>
<li><p> &quot;url&quot;: OSC hyperlinks
</p>
</li>
<li><p> &quot;osc&quot;: all non-OSC-hyperlink OSC sequences.
</p>
</li>
<li><p> &quot;esc&quot;: all other escape sequences.
</p>
</li>
<li><p> &quot;all&quot;: all of the above, except when used in combination with any of the
above, in which case it means &quot;all but&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="substr_ctl_+3A_normalize">normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_terminate">terminate</code></td>
<td>
<p>TRUE (default) or FALSE whether substrings should have
active state closed to avoid it bleeding into other strings they may be
prepended onto.  This does not stop state from carrying if <code>carry = TRUE</code>.
See the &quot;State Interactions&quot; section of <code><a href="#topic+fansi">?fansi</a></code> for details.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_type">type</code></td>
<td>
<p>character(1L) partial matching
<code>c("chars", "width", "graphemes")</code>, although types other than &quot;chars&quot; only
work correctly with R &gt;= 3.2.2.  See <code><a href="base.html#topic+nchar">?nchar</a></code>.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_round">round</code></td>
<td>
<p>character(1L) partial matching
<code>c("start", "stop", "both", "neither")</code>, controls how to resolve
ambiguities when a <code>start</code> or <code>stop</code> value in &quot;width&quot; <code>type</code> mode falls
within a wide display character.  See details.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_tabs.as.spaces">tabs.as.spaces</code></td>
<td>
<p>FALSE (default) or TRUE, whether to convert tabs to
spaces (and supress tab related warnings).  This can only be set to TRUE if
<code>strip.spaces</code> is FALSE.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_tab.stops">tab.stops</code></td>
<td>
<p>integer(1:n) indicating position of tab stops to use
when converting tabs to spaces.  If there are more tabs in a line than
defined tab stops the last tab stop is re-used.  For the purposes of
applying tab stops, each input line is considered a line and the character
count begins from the beginning of the input line.</p>
</td></tr>
<tr><td><code id="substr_ctl_+3A_value">value</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the same length and with the same attributes as
x (after possible coercion and re-encoding to UTF-8).
</p>


<h3>Control and Special Sequences</h3>

<p><em>Control Sequences</em> are non-printing characters or sequences of characters.
<em>Special Sequences</em> are a subset of the <em>Control Sequences</em>, and include CSI
SGR sequences which can be used to change rendered appearance of text, and
OSC hyperlinks.  See <code><a href="#topic+fansi">fansi</a></code> for details.
</p>


<h3>Position Semantics</h3>

<p>When computing substrings, <em>Normal</em> (non-control) characters are considered
to occupy positions in strings, whereas <em>Control Sequences</em> occupy the
interstices between them.  The string:
</p>
<div class="sourceCode"><pre>"hello-\033[31mworld\033[m!"
</pre></div>
<p>is interpreted as:
</p>
<div class="sourceCode"><pre>                   1 1 1
 1 2 3 4 5 6 7 8 9 0 1 2
 h e l l o -|w o r l d|!
            ^         ^
            \033[31m  \033[m
</pre></div>
<p><code>start</code> and <code>stop</code> reference character positions so they never explicitly
select for the interstitial <em>Control Sequences</em>.  The latter are implicitly
selected if they appear in interstices after the first character and before
the last.  Additionally, because <em>Special Sequences</em> (CSI SGR and OSC
hyperlinks) affect all subsequent characters in a string, any active <em>Special
Sequence</em>, whether opened just before a character or much before, will be
reflected in the state <code>fansi</code> prepends to the beginning of each substring.
</p>
<p>It is possible to select <em>Control Sequences</em> at the end of a string by
specifying <code>stop</code> values past the end of the string, although for <em>Special
Sequences</em> this only produces visible results if <code>terminate</code> is set to
<code>FALSE</code>.  Similarly, it is possible to select <em>Control Sequences</em> preceding
the beginning of a string by specifying <code>start</code> values less than one,
although as noted earlier this is unnecessary for <em>Special Sequences</em> as
those are output by <code>fansi</code> before each substring.
</p>
<p>Because exact substrings on anything other than character count cannot be
guaranteed (e.g. as a result of multi-byte encodings, or double display-width
characters) <code>substr2_ctl</code> must make assumptions on how to resolve provided
<code>start</code>/<code>stop</code> values that are infeasible and does so via the <code>round</code>
parameter.
</p>
<p>If we use &quot;start&quot; as the <code>round</code> value, then any time the <code>start</code>
value corresponds to the middle of a multi-byte or a wide character, then
that character is included in the substring, while any similar partially
included character via the <code>stop</code> is left out.  The converse is true if we
use &quot;stop&quot; as the <code>round</code> value.  &quot;neither&quot; would cause all partial
characters to be dropped irrespective whether they correspond to <code>start</code> or
<code>stop</code>, and &quot;both&quot; could cause all of them to be included.  See examples.
</p>
<p>A number of <em>Normal</em> characters such as combining diacritic marks have
reported width of zero.  These are typically displayed overlaid on top of the
preceding glyph, as in the case of <code>"e\u301"</code> forming &quot;e&quot; with an acute
accent.  Unlike <em>Control Sequences</em>, which also have reported width of zero,
<code>fansi</code> groups zero-width <em>Normal</em> characters with the last preceding
non-zero width <em>Normal</em> character.  This is incorrect for some rare
zero-width <em>Normal</em> characters such as prepending marks (see &quot;Output
Stability&quot; and &quot;Graphemes&quot;).
</p>


<h3>Output Stability</h3>

<p>Several factors could affect the exact output produced by <code>fansi</code>
functions across versions of <code>fansi</code>, <code>R</code>, and/or across systems.
<strong>In general it is best not to rely on exact <code>fansi</code> output, e.g. by
embedding it in tests</strong>.
</p>
<p>Width and grapheme calculations depend on locale, Unicode database
version, and grapheme processing logic (which is still in development), among
other things.  For the most part <code>fansi</code> (currently) uses the internals of
<code>base::nchar(type='width')</code>, but there are exceptions and this may change in
the future.
</p>
<p>How a particular display format is encoded in <em>Control Sequences</em> is
not guaranteed to be stable across <code>fansi</code> versions.  Additionally, which
<em>Special Sequences</em> are re-encoded vs transcribed untouched may change.
In general we will strive to keep the rendered appearance stable.
</p>
<p>To maximize the odds of getting stable output set <code>normalize_state</code> to
<code>TRUE</code> and <code>type</code> to <code>"chars"</code> in functions that allow it, and
set <code>term.cap</code> to a specific set of capabilities.
</p>


<h3>Replacement Functions</h3>

<p>Semantics for replacement functions have the additional requirement that the
result appear as if it is the input modified in place between the positions
designated by <code>start</code> and <code>stop</code>.  <code>terminate</code> only affects the boundaries
between the original substring and the spliced one, <code>normalize</code> only affects
the same boundaries, and <code>tabs.as.spaces</code> only affects <code>value</code>, and <code>x</code> must
be ASCII only or marked &quot;UTF-8&quot;.
</p>
<p><code>terminate = FALSE</code> only makes sense in replacement mode if only one of <code>x</code>
or <code>value</code> contains <em>Control Sequences</em>.  <code>fansi</code> will not account for any
interactions of state in <code>x</code> and <code>value</code>.
</p>
<p>The <code>carry</code> parameter causes state to carry within the original string and
the replacement values independently, as if they were columns of text cut
from different pages and pasted together.  String values for <code>carry</code> are
disallowed in replacement mode as it is ambiguous which of <code>x</code> or <code>value</code>
they would modify (see examples).
</p>
<p>When in <code>type = 'width'</code> mode, it is only guaranteed that the result will be
no wider than the original <code>x</code>.  Narrower strings may result if a mixture
of narrow and wide graphemes cannot be replaced exactly with the same <code>width</code>
value, possibly because the provided <code>start</code> and <code>stop</code> values (or the
implicit ones generated for <code>value</code>) do not align with grapheme boundaries.
</p>


<h3>Graphemes</h3>

<p><code>fansi</code> approximates grapheme widths and counts by using heuristics for
grapheme breaks that work for most common graphemes, including emoji
combining sequences.  The heuristic is known to work incorrectly with
invalid combining sequences, prepending marks, and sequence interruptors.
<code>fansi</code> does not provide a full implementation of grapheme break detection to
avoid carrying a copy of the Unicode grapheme breaks table, and also because
the hope is that R will add the feature eventually itself.
</p>
<p>The <a href="https://cran.r-project.org/package=utf8"><code>utf8</code></a> package provides a
conforming grapheme parsing implementation.
</p>


<h3>Bidirectional Text</h3>

<p><code>fansi</code> is unaware of text directionality and operates as if all strings are
left to right (LTR).  Using <code>fansi</code> function with strings that contain mixed
direction scripts (i.e. both LTR and RTL) may produce undesirable results.
</p>


<h3>Note</h3>

<p>Non-ASCII strings are converted to and returned in UTF-8 encoding.
Width calculations will not work properly in R &lt; 3.2.2.
</p>
<p>If <code>stop</code> &lt; <code>start</code>, the return value is always an empty string.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+normalize_state">normalize_state</a></code> for more details on what the <code>normalize</code> parameter does,
<code><a href="#topic+state_at_end">state_at_end</a></code> to compute active state at the end of strings,
<code><a href="#topic+close_state">close_state</a></code> to compute the sequence required to close active state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>substr_ctl("\033[42mhello\033[m world", 1, 9)
substr_ctl("\033[42mhello\033[m world", 3, 9)

## Positions 2 and 4 are in the middle of the full width W (\uFF37) for
## the `start` and `stop` positions respectively. Use `round`
## to control result:
x &lt;- "\uFF37n\uFF37"
x
substr2_ctl(x, 2, 4, type='width', round='start')
substr2_ctl(x, 2, 4, type='width', round='stop')
substr2_ctl(x, 2, 4, type='width', round='neither')
substr2_ctl(x, 2, 4, type='width', round='both')

## We can specify which escapes are considered special:
substr_ctl("\033[31mhello\tworld", 1, 6, ctl='sgr', warn=FALSE)
substr_ctl("\033[31mhello\tworld", 1, 6, ctl=c('all', 'c0'), warn=FALSE)

## `carry` allows SGR to carry from one element to the next
substr_ctl(c("\033[33mhello", "world"), 1, 3)
substr_ctl(c("\033[33mhello", "world"), 1, 3, carry=TRUE)
substr_ctl(c("\033[33mhello", "world"), 1, 3, carry="\033[44m")

## We can omit the termination
bleed &lt;- substr_ctl(c("\033[41mhello", "world"), 1, 3, terminate=FALSE)
writeLines(bleed)      # Style will bleed out of string
end &lt;- "\033[0m\n"
writeLines(end)        # Stanch bleeding

## Trailing sequences omitted unless `stop` past end.
substr_ctl("ABC\033[42m", 1, 3, terminate=FALSE)
substr_ctl("ABC\033[42m", 1, 4, terminate=FALSE)

## Replacement functions
x0&lt;- x1 &lt;- x2 &lt;- x3 &lt;- c("\033[42mABC", "\033[34mDEF")
substr_ctl(x1, 2, 2) &lt;- "_"
substr_ctl(x2, 2, 2) &lt;- "\033[m_"
substr_ctl(x3, 2, 2) &lt;- "\033[45m_"
writeLines(c(x0, end, x1, end, x2, end, x3, end))

## With `carry = TRUE` strings look like original
x0&lt;- x1 &lt;- x2 &lt;- x3 &lt;- c("\033[42mABC", "\033[34mDEF")
substr_ctl(x0, 2, 2, carry=TRUE) &lt;- "_"
substr_ctl(x1, 2, 2, carry=TRUE) &lt;- "\033[m_"
substr_ctl(x2, 2, 2, carry=TRUE) &lt;- "\033[45m_"
writeLines(c(x0, end, x1, end, x2, end, x3, end))

## Work-around to specify carry strings in replacement mode
x &lt;- c("ABC", "DEF")
val &lt;- "#"
x2 &lt;- c("\033[42m", x)
val2 &lt;- c("\033[45m", rep_len(val, length(x)))
substr_ctl(x2, 2, 2, carry=TRUE) &lt;- val2
(x &lt;- x[-1])
</code></pre>

<hr>
<h2 id='substr_sgr'>SGR Control Sequence Aware Version of substr</h2><span id='topic+substr_sgr'></span><span id='topic+substr2_sgr'></span>

<h3>Description</h3>

<p>These functions are deprecated in favor of the <code><a href="#topic+substr_ctl">substr_ctl</a></code> flavors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substr_sgr(
  x,
  start,
  stop,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)

substr2_sgr(
  x,
  start,
  stop,
  type = "chars",
  round = "start",
  tabs.as.spaces = getOption("fansi.tabs.as.spaces", FALSE),
  tab.stops = getOption("fansi.tab.stops", 8L),
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE),
  terminate = getOption("fansi.terminate", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substr_sgr_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_start">start</code></td>
<td>
<p>integer.  The first element to be extracted or replaced.</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_stop">stop</code></td>
<td>
<p>integer.  The first element to be extracted or replaced.</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_normalize">normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_terminate">terminate</code></td>
<td>
<p>TRUE (default) or FALSE whether substrings should have
active state closed to avoid it bleeding into other strings they may be
prepended onto.  This does not stop state from carrying if <code>carry = TRUE</code>.
See the &quot;State Interactions&quot; section of <code><a href="#topic+fansi">?fansi</a></code> for details.</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_type">type</code></td>
<td>
<p>character(1L) partial matching
<code>c("chars", "width", "graphemes")</code>, although types other than &quot;chars&quot; only
work correctly with R &gt;= 3.2.2.  See <code><a href="base.html#topic+nchar">?nchar</a></code>.</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_round">round</code></td>
<td>
<p>character(1L) partial matching
<code>c("start", "stop", "both", "neither")</code>, controls how to resolve
ambiguities when a <code>start</code> or <code>stop</code> value in &quot;width&quot; <code>type</code> mode falls
within a wide display character.  See details.</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_tabs.as.spaces">tabs.as.spaces</code></td>
<td>
<p>FALSE (default) or TRUE, whether to convert tabs to
spaces (and supress tab related warnings).  This can only be set to TRUE if
<code>strip.spaces</code> is FALSE.</p>
</td></tr>
<tr><td><code id="substr_sgr_+3A_tab.stops">tab.stops</code></td>
<td>
<p>integer(1:n) indicating position of tab stops to use
when converting tabs to spaces.  If there are more tabs in a line than
defined tab stops the last tab stop is re-used.  For the purposes of
applying tab stops, each input line is considered a line and the character
count begins from the beginning of the input line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the same length and with the same attributes as
x (after possible coercion and re-encoding to UTF-8).
</p>

<hr>
<h2 id='tabs_as_spaces'>Replace Tabs With Spaces</h2><span id='topic+tabs_as_spaces'></span>

<h3>Description</h3>

<p>Finds horizontal tab characters (0x09) in a string and replaces them with the
spaces that produce the same horizontal offset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabs_as_spaces(
  x,
  tab.stops = getOption("fansi.tab.stops", 8L),
  warn = getOption("fansi.warn", TRUE),
  ctl = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabs_as_spaces_+3A_x">x</code></td>
<td>
<p>character vector or object coercible to character; any tabs therein
will be replaced.</p>
</td></tr>
<tr><td><code id="tabs_as_spaces_+3A_tab.stops">tab.stops</code></td>
<td>
<p>integer(1:n) indicating position of tab stops to use
when converting tabs to spaces.  If there are more tabs in a line than
defined tab stops the last tab stop is re-used.  For the purposes of
applying tab stops, each input line is considered a line and the character
count begins from the beginning of the input line.</p>
</td></tr>
<tr><td><code id="tabs_as_spaces_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="tabs_as_spaces_+3A_ctl">ctl</code></td>
<td>
<p>character, which <em>Control Sequences</em> should be treated
specially.  Special treatment is context dependent, and may include
detecting them and/or computing their display/character width as zero.  For
the SGR subset of the ANSI CSI sequences, and OSC hyperlinks, <code>fansi</code>
will also parse, interpret, and reapply the sequences as needed.  You can
modify whether a <em>Control Sequence</em> is treated specially with the <code>ctl</code>
parameter.
</p>

<ul>
<li><p> &quot;nl&quot;: newlines.
</p>
</li>
<li><p> &quot;c0&quot;: all other &quot;C0&quot; control characters (i.e. 0x01-0x1f, 0x7F), except
for newlines and the actual ESC (0x1B) character.
</p>
</li>
<li><p> &quot;sgr&quot;: ANSI CSI SGR sequences.
</p>
</li>
<li><p> &quot;csi&quot;: all non-SGR ANSI CSI sequences.
</p>
</li>
<li><p> &quot;url&quot;: OSC hyperlinks
</p>
</li>
<li><p> &quot;osc&quot;: all non-OSC-hyperlink OSC sequences.
</p>
</li>
<li><p> &quot;esc&quot;: all other escape sequences.
</p>
</li>
<li><p> &quot;all&quot;: all of the above, except when used in combination with any of the
above, in which case it means &quot;all but&quot;.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Since we do not know of a reliable cross platform means of detecting tab
stops you will need to provide them yourself if you are using anything
outside of the standard tab stop every 8 characters that is the default.
</p>


<h3>Value</h3>

<p>character, <code>x</code> with tabs replaced by spaces, with elements
possibly converted to UTF-8.
</p>


<h3>Note</h3>

<p>Non-ASCII strings are converted to and returned in UTF-8 encoding.  The
<code>ctl</code> parameter only affects which <em>Control Sequences</em> are considered zero
width.  Tabs will always be converted to spaces, irrespective of the <code>ctl</code>
setting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+unhandled_ctl">unhandled_ctl</a></code> for detecting bad control sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- '1\t12\t123\t1234\t12345678'
tabs_as_spaces(string)
writeLines(
  c(
    '-------|-------|-------|-------|-------|',
    tabs_as_spaces(string)
) )
writeLines(
  c(
    '-|--|--|--|--|--|--|--|--|--|--|',
    tabs_as_spaces(string, tab.stops=c(2, 3))
) )
writeLines(
  c(
    '-|--|-------|-------|-------|',
    tabs_as_spaces(string, tab.stops=c(2, 3, 8))
) )
</code></pre>

<hr>
<h2 id='term_cap_test'>Test Terminal Capabilities</h2><span id='topic+term_cap_test'></span>

<h3>Description</h3>

<p>Outputs ANSI CSI SGR formatted text to screen so that you may visually
inspect what color capabilities your terminal supports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_cap_test()
</code></pre>


<h3>Details</h3>

<p>The three tested terminal capabilities are:
</p>

<ul>
<li><p> &quot;bright&quot; for bright colors with SGR codes in 90-97 and 100-107
</p>
</li>
<li><p> &quot;256&quot; for colors defined by &quot;38;5;x&quot; and &quot;48;5;x&quot; where x is in 0-255
</p>
</li>
<li><p> &quot;truecolor&quot; for colors defined by &quot;38;2;x;y;z&quot; and &quot;48;x;y;x&quot; where x, y,
and z are in 0-255
</p>
</li></ul>

<p>Each of the color capabilities your terminal supports should be displayed
with a blue background and a red foreground.  For reference the corresponding
CSI SGR sequences are displayed as well.
</p>
<p>You should compare the screen output from this function to
<code>getOption('fansi.term.cap', dflt_term_cap)</code> to ensure that they are self
consistent.
</p>
<p>By default <code>fansi</code> assumes terminals support bright and 256 color
modes, and also tests for truecolor support via the $COLORTERM system
variable.
</p>
<p>Functions with the <code>term.cap</code> parameter like <code>substr_ctl</code> will warn if they
encounter 256 or true color SGR sequences and <code>term.cap</code> indicates they are
unsupported as such a terminal may misinterpret those sequences.  Bright
codes and OSC hyperlinks in terminals that do not support them will likely be
silently ignored, so <code>fansi</code> functions do not warn about those.
</p>


<h3>Value</h3>

<p>character the test vector, invisibly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dflt_term_cap">dflt_term_cap</a></code>, <code><a href="#topic+has_ctl">has_ctl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>term_cap_test()
</code></pre>

<hr>
<h2 id='to_html'>Convert Control Sequences to HTML Equivalents</h2><span id='topic+to_html'></span>

<h3>Description</h3>

<p>Interprets CSI SGR sequences and OSC hyperlinks to produce strings with
the state reproduced with SPAN elements, inline CSS styles, and A anchors.
Optionally for colors, the SPAN elements may be assigned classes instead of
inline styles, in which case it is the user's responsibility to provide a
style sheet.  Input that contains special HTML characters (&quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&amp;&quot;,
&quot;'&quot;, and &quot;\&quot;&quot;) likely should be escaped with <code><a href="#topic+html_esc">html_esc</a></code>, and <code>to_html</code> will
warn if it encounters the first two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_html(
  x,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  classes = FALSE,
  carry = getOption("fansi.carry", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_html_+3A_x">x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr><td><code id="to_html_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="to_html_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="to_html_+3A_classes">classes</code></td>
<td>
<p>FALSE (default), TRUE, or character vector of either 16,
32, or 512 class names.  Character strings may only contain ASCII
characters corresponding to letters, numbers, the hyphen, or the
underscore.  It is the user's responsibility to provide values that are
legal class names.
</p>

<ul>
<li><p> FALSE: All colors rendered as inline CSS styles.
</p>
</li>
<li><p> TRUE: Each of the 256 basic colors is mapped to a class in form
&quot;fansi-color-###&quot; (or &quot;fansi-bgcol-###&quot; for background colors)
where &quot;###&quot; is a zero padded three digit number in 0:255.  Basic colors
specified with SGR codes 30-37 (or 40-47) map to 000:007, and bright ones
specified with 90-97 (or 100-107) map to 008:015.  8 bit colors specified
with SGR codes 38;5;### or 48;5;### map directly based on the value of
&quot;###&quot;.  Implicitly, this maps the 8 bit colors in 0:7 to the basic
colors, and those in 8:15 to the bright ones even though these are not
exactly the same when using inline styles.  &quot;truecolor&quot;s specified with
38;2;#;#;# or 48;2;#;#;# do not map to classes and are rendered as inline
styles.
</p>
</li>
<li><p> character(16): The eight basic colors are mapped to the string values in
the vector, all others are rendered as inline CSS styles.  Basic colors
are mapped irrespective of whether they are encoded as the basic colors
or as 8-bit colors.  Sixteen elements are needed because there must be
eight classes for foreground colors, and eight classes for background
colors.  Classes should be ordered in ascending order of color number,
with foreground and background classes alternating starting with
foreground (see examples).
</p>
</li>
<li><p> character(32): Like character(16), except the basic and bright colors are
mapped.
</p>
</li>
<li><p> character(512): Like character(16), except the basic, bright, and all
other 8-bit colors are mapped.
</p>
</li></ul>
</td></tr>
<tr><td><code id="to_html_+3A_carry">carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="#topic+substr_ctl">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="#topic+fansi">?fansi</a></code> for details.  Except for <code><a href="#topic+strwrap_ctl">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only &quot;observable&quot; formats are translated.  These include colors,
background-colors, and basic styles (CSI SGR codes 1-6, 8, 9).  Style 7, the
&quot;inverse&quot; style, is implemented by explicitly switching foreground and
background colors, if there are any.  Styles 5-6 (blink) are rendered as
&quot;text-decoration&quot; but likely will do nothing in the browser.  Style 8
(conceal) sets the color to transparent.
</p>
<p>Parameters in OSC sequences are not copied over as they might have different
semantics in the OSC sequences than they would in HTML (e.g. the &quot;id&quot;
parameter is intended to be non-unique in OSC).
</p>
<p>Each element of the input vector is translated into a stand-alone valid HTML
string.  In particular, any open tags generated by <code>fansi</code> are closed at the
end of an element and re-opened on the subsequent element with the same
style.  This allows safe combination of HTML translated strings, for example
by <code><a href="base.html#topic+paste">paste</a></code>ing them together.  The trade-off is that there may be redundant
HTML produced.  To reduce redundancy you can first collapse the input vector
into one string, being mindful that very large strings may exceed maximum
string size when converted to HTML.
</p>
<p><code>fansi</code>-opened tags are closed and new ones open anytime the &quot;observable&quot;
state changes.  <code>to_html</code> never produces nested tags, even if at times
that might produce more compact output.  While it would be possible to
match a CSI/OSC encoded state with nested tags, it would increase the
complexity of the code substantially for little gain.
</p>


<h3>Value</h3>

<p>A character vector of the same length as <code>x</code> with all escape
sequences removed and any basic ANSI CSI SGR escape sequences applied via
SPAN HTML tags.
</p>


<h3>Note</h3>

<p>Non-ASCII strings are converted to and returned in UTF-8 encoding.
</p>
<p><code>to_html</code> always terminates as not doing so produces
invalid HTML.  If you wish for the last active SPAN to bleed into
subsequent text you may do so with e.g. <code>sub("&lt;/span&gt;(?:&lt;/a&gt;)?$", "", x)</code>
or similar.  Additionally, unlike other functions, the default is
<code>carry = TRUE</code> for compatibility with semantics of prior versions of
<code>fansi</code>.
</p>


<h3>See Also</h3>

<p>Other HTML functions: 
<code><a href="#topic+html_esc">html_esc</a>()</code>,
<code><a href="#topic+in_html">in_html</a>()</code>,
<code><a href="#topic+make_styles">make_styles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to_html("hello\033[31;42;1mworld\033[m")
to_html("hello\033[31;42;1mworld\033[m", classes=TRUE)

## Input contains HTML special chars
x &lt;- "&lt;hello \033[42m'there' \033[34m &amp;amp;\033[m \"moon\"!"
writeLines(x)
## Not run: 
in_html(
  c(
    to_html(html_esc(x)),  # Good
    to_html(x)             # Bad (warning)!
) )

## End(Not run)
## Generate some class names for basic colors
classes &lt;- expand.grid(
  "myclass",
  c("fg", "bg"),
  c("black", "red", "green", "yellow", "blue", "magenta", "cyan", "white")
)
classes  # order is important!
classes &lt;- do.call(paste, c(classes, sep="-"))
## We only provide 16 classes, so Only basic colors are
## mapped to classes; others styled inline.
to_html(
  "\033[94mhello\033[m \033[31;42;1mworld\033[m",
  classes=classes
)
## Create a whole web page with a style sheet for 256 colors and
## the colors shown in a table.
class.256 &lt;- do.call(paste, c(expand.grid(c("fg", "bg"), 0:255), sep="-"))
sgr.256 &lt;- sgr_256()     # A demo of all 256 colors
writeLines(sgr.256[1:8]) # SGR formatting

## Convert to HTML using classes instead of inline styles:
html.256 &lt;- to_html(sgr.256, classes=class.256)
writeLines(html.256[1])  # No inline colors

## Generate different style sheets.  See `?make_styles` for details.
default &lt;- make_styles(class.256)
mix &lt;- matrix(c(.6,.2,.2, .2,.6,.2, .2,.2,.6), 3)
desaturated &lt;- make_styles(class.256, mix)
writeLines(default[1:4])
writeLines(desaturated[1:4])

## Embed in HTML page and diplay; only CSS changing
## Not run: 
in_html(html.256)                  # no CSS
in_html(html.256, css=default)     # default CSS
in_html(html.256, css=desaturated) # desaturated CSS

## End(Not run)
</code></pre>

<hr>
<h2 id='trimws_ctl'>Control Sequence Aware Version of trimws</h2><span id='topic+trimws_ctl'></span>

<h3>Description</h3>

<p>Removes any whitespace before the first and/or after the last non-<em>Control
Sequence</em> character.  Unlike with the <code><a href="base.html#topic+trimws">base::trimws</a></code>, only the default
<code>whitespace</code> specification is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimws_ctl(
  x,
  which = c("both", "left", "right"),
  whitespace = "[ \t\r\n]",
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  ctl = "all",
  normalize = getOption("fansi.normalize", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimws_ctl_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="trimws_ctl_+3A_which">which</code></td>
<td>
<p>a character string specifying whether to remove both
leading and trailing whitespace (default), or only leading
(<code>"left"</code>) or trailing (<code>"right"</code>).  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="trimws_ctl_+3A_whitespace">whitespace</code></td>
<td>
<p>must be set to the default value, in the future it may
become possible to change this parameter.</p>
</td></tr>
<tr><td><code id="trimws_ctl_+3A_warn">warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="#topic+fansi">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="base.html#topic+validUTF8">validUTF8</a></code> for
that).</p>
</td></tr>
<tr><td><code id="trimws_ctl_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr><td><code id="trimws_ctl_+3A_ctl">ctl</code></td>
<td>
<p>character, which <em>Control Sequences</em> should be treated
specially.  Special treatment is context dependent, and may include
detecting them and/or computing their display/character width as zero.  For
the SGR subset of the ANSI CSI sequences, and OSC hyperlinks, <code>fansi</code>
will also parse, interpret, and reapply the sequences as needed.  You can
modify whether a <em>Control Sequence</em> is treated specially with the <code>ctl</code>
parameter.
</p>

<ul>
<li><p> &quot;nl&quot;: newlines.
</p>
</li>
<li><p> &quot;c0&quot;: all other &quot;C0&quot; control characters (i.e. 0x01-0x1f, 0x7F), except
for newlines and the actual ESC (0x1B) character.
</p>
</li>
<li><p> &quot;sgr&quot;: ANSI CSI SGR sequences.
</p>
</li>
<li><p> &quot;csi&quot;: all non-SGR ANSI CSI sequences.
</p>
</li>
<li><p> &quot;url&quot;: OSC hyperlinks
</p>
</li>
<li><p> &quot;osc&quot;: all non-OSC-hyperlink OSC sequences.
</p>
</li>
<li><p> &quot;esc&quot;: all other escape sequences.
</p>
</li>
<li><p> &quot;all&quot;: all of the above, except when used in combination with any of the
above, in which case it means &quot;all but&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="trimws_ctl_+3A_normalize">normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input with white space removed as described.
</p>


<h3>Control and Special Sequences</h3>

<p><em>Control Sequences</em> are non-printing characters or sequences of characters.
<em>Special Sequences</em> are a subset of the <em>Control Sequences</em>, and include CSI
SGR sequences which can be used to change rendered appearance of text, and
OSC hyperlinks.  See <code><a href="#topic+fansi">fansi</a></code> for details.
</p>


<h3>Output Stability</h3>

<p>Several factors could affect the exact output produced by <code>fansi</code>
functions across versions of <code>fansi</code>, <code>R</code>, and/or across systems.
<strong>In general it is best not to rely on exact <code>fansi</code> output, e.g. by
embedding it in tests</strong>.
</p>
<p>Width and grapheme calculations depend on locale, Unicode database
version, and grapheme processing logic (which is still in development), among
other things.  For the most part <code>fansi</code> (currently) uses the internals of
<code>base::nchar(type='width')</code>, but there are exceptions and this may change in
the future.
</p>
<p>How a particular display format is encoded in <em>Control Sequences</em> is
not guaranteed to be stable across <code>fansi</code> versions.  Additionally, which
<em>Special Sequences</em> are re-encoded vs transcribed untouched may change.
In general we will strive to keep the rendered appearance stable.
</p>
<p>To maximize the odds of getting stable output set <code>normalize_state</code> to
<code>TRUE</code> and <code>type</code> to <code>"chars"</code> in functions that allow it, and
set <code>term.cap</code> to a specific set of capabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trimws_ctl(" \033[31m\thello world\t\033[39m  ")
</code></pre>

<hr>
<h2 id='unhandled_ctl'>Identify Unhandled Control Sequences</h2><span id='topic+unhandled_ctl'></span>

<h3>Description</h3>

<p>Will return position and types of unhandled <em>Control Sequences</em> in a
character vector.  Unhandled sequences may cause <code>fansi</code> to interpret strings
in a way different to your display.  See <a href="#topic+fansi">fansi</a> for details.  Functions that
interpret <em>Special Sequences</em> (CSI SGR or OSC hyperlinks) might omit bad
<em>Special Sequences</em> or some of their components in output substrings,
particularly if they are leading or trailing.  Some functions are more
tolerant of bad inputs than others.  For example <code><a href="#topic+nchar_ctl">nchar_ctl</a></code> will not
report unsupported colors because it only cares about counts or widths.
<code>unhandled_ctl</code> will report all potentially problematic sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unhandled_ctl(x, term.cap = getOption("fansi.term.cap", dflt_term_cap()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unhandled_ctl_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="unhandled_ctl_+3A_term.cap">term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="#topic+term_cap_test">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To work around tabs present in input, you can use <code><a href="#topic+tabs_as_spaces">tabs_as_spaces</a></code> or the
<code>tabs.as.spaces</code> parameter on functions that have it, or the <code><a href="#topic+strip_ctl">strip_ctl</a></code>
function to remove the troublesome sequences.  Alternatively, you can use
<code>warn=FALSE</code> to suppress the warnings.
</p>
<p>This is a debugging function that is not optimized for speed and the precise
output of which might change with <code>fansi</code> versions.
</p>
<p>The return value is a data frame with five columns:
</p>

<ul>
<li><p> index: integer the index in <code>x</code> with the unhandled sequence
</p>
</li>
<li><p> start: integer the start position of the sequence (in characters)
</p>
</li>
<li><p> stop: integer the end of the sequence (in characters), but note that if
there are multiple ESC sequences abutting each other they will all be
treated as one, even if some of those sequences are valid.
</p>
</li>
<li><p> error: the reason why the sequence was not handled:
</p>

<ul>
<li><p> unknown-substring: SGR substring with a value that does not correspond
to a known SGR code or OSC hyperlink with unsupported parameters.
</p>
</li>
<li><p> invalid-substr: SGR contains uncommon characters in &quot;:&lt;=&gt;&quot;,
intermediate bytes, other invalid characters, or there is an invalid
subsequence (e.g. &quot;ESC[38;2m&quot; which should specify an RGB triplet
but does not).  OSCs contain invalid bytes, or OSC hyperlinks contain
otherwise valid OSC bytes in 0x08-0x0d.
</p>
</li>
<li><p> exceed-term-cap: contains color codes not supported by the terminal
(see <a href="#topic+term_cap_test">term_cap_test</a>).  Bright colors with color codes in the 90-97 and
100-107 range in terminals that do not support them are not considered
errors, whereas 256 or truecolor codes in terminals that do not support
them are.  This is because the latter are often misinterpreted by
terminals that do not support them, whereas the former are typically
silently ignored.
</p>
</li>
<li><p> CSI/OSC: a non-SGR CSI sequence, or non-hyperlink OSC sequence.
</p>
</li>
<li><p> CSI/OSC-bad-substr: a CSI or OSC sequence containing invalid
characters.
</p>
</li>
<li><p> malformed-CSI/OSC: a malformed CSI or OSC sequence, typically one that
never encounters its closing sequence before the end of a string.
</p>
</li>
<li><p> non-CSI/OSC: a non-CSI or non-OSC escape sequence, i.e. one where the
ESC is followed by something other than &quot;[&quot; or &quot;]&quot;.  Since we
assume all non-CSI sequences are only 2 characters long include the
ESC, this type of sequence is the most likely to cause problems as some
are not actually two characters long.
</p>
</li>
<li><p> malformed-ESC: a malformed two byte ESC sequence (i.e. one not ending
in 0x40-0x7e).
</p>
</li>
<li><p> C0: a &quot;C0&quot; control character (e.g. tab, bell, etc.).
</p>
</li>
<li><p> malformed-UTF8: illegal UTF8 encoding.
</p>
</li>
<li><p> non-ASCII: non-ASCII bytes in escape sequences.
</p>
</li></ul>

</li>
<li><p> translated: whether the string was translated to UTF-8, might be helpful in
odd cases were character offsets change depending on encoding.  You should
only worry about this if you cannot tie out the <code>start</code>/<code>stop</code> values to
the escape sequence shown.
</p>
</li>
<li><p> esc: character the unhandled escape sequence
</p>
</li></ul>



<h3>Value</h3>

<p>Data frame with as many rows as there are unhandled escape
sequences and columns containing useful information for debugging the
problem.  See details.
</p>


<h3>Note</h3>

<p>Non-ASCII strings are converted to UTF-8 encoding.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fansi">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="#topic+unhandled_ctl">unhandled_ctl</a></code> for detecting bad control sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- c(
  "\033[41mhello world\033[m", "foo\033[22&gt;m", "\033[999mbar",
  "baz \033[31#3m", "a\033[31k", "hello\033m world"
)
unhandled_ctl(string)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
