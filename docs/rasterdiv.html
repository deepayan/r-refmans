<!DOCTYPE html><html><head><title>Help for package rasterdiv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rasterdiv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.CRE_'><p>Cumulative Residual Entropy</p></a></li>
<li><a href='#.CumRes'><p>Calculate Cumulative Residual Probability</p></a></li>
<li><a href='#.Deltas'><p>Calculate Differences Among Values</p></a></li>
<li><a href='#.Prob'><p>Calculate Point Probability</p></a></li>
<li><a href='#.Reorder'><p>Additional supporting functions like '.Reorder', '.Cumsum', '.Rev'</p></a></li>
<li><a href='#BergerParker'><p>Berger-Parker's diversity index</p></a></li>
<li><a href='#BergerParkerP'><p>Calculate Berger-Parker Index on a Matrix</p></a></li>
<li><a href='#BergerParkerS'><p>Sequential Berger-Parker's diversity index</p></a></li>
<li><a href='#copNDVI'><p>Copernicus Long Term (1999-2017) NDVI Overview (5km)</p></a></li>
<li><a href='#CRE'><p>Cumulative Residual Entropy (CRE) Function</p></a></li>
<li><a href='#heliPlot'><p>Create a Helical Plot for Time Series Data</p></a></li>
<li><a href='#heliPrep'><p>Prepare Data for Helical Plotting</p></a></li>
<li><a href='#Hill'><p>Hill's index of diversity - Hill numbers (D)</p></a></li>
<li><a href='#HillP'><p>Parallelised Hill's diversity index</p></a></li>
<li><a href='#HillS'><p>Sequential Hill's diversity index</p></a></li>
<li><a href='#load_copNDVI'><p>Load Copernicus NDVI data</p></a></li>
<li><a href='#load_world'><p>Load Natural Earth world dataset</p></a></li>
<li><a href='#mpaRaoAreaS'><p>Area-Based Sequential Parametric Rao's index of quadratic entropy (Q)</p></a></li>
<li><a href='#mpaRaoP'><p>Multidimensional parallel Parametric Rao's index of quadratic entropy (Q)</p></a></li>
<li><a href='#mpaRaoS'><p>Multidimensional sequential Parametric Rao's index of quadratic entropy (Q)</p></a></li>
<li><a href='#ndviForestTS'><p>Simulated NDVI dataset</p></a></li>
<li><a href='#openCluster'><p>Open a Parallel Cluster</p></a></li>
<li><a href='#paRao'><p>Parametric Rao's index of quadratic entropy (Q)</p></a></li>
<li><a href='#paRaoAreaS'><p>Area-Based Sequential Parametric Rao's index of quadratic entropy (Q)</p></a></li>
<li><a href='#paRaoP'><p>Parallelized Parametric Rao's index of quadratic entropy (Q)</p></a></li>
<li><a href='#paRaoS'><p>Sequential Parametric Rao's index of quadratic entropy (Q)</p></a></li>
<li><a href='#Pielou'><p>Pielou's Evenness Index</p></a></li>
<li><a href='#PielouP'><p>Parallelised Pielou's diversity index</p></a></li>
<li><a href='#PielouS'><p>Sequential Pielou's diversity index</p></a></li>
<li><a href='#process_raster_result'><p>Process Raster Results</p></a></li>
<li><a href='#RaoAUC'><p>Accumulation function for parametric Rao's index of quadratic entropy (Q)</p></a></li>
<li><a href='#Renyi'><p>Renyi Diversity Index Calculation</p></a></li>
<li><a href='#RenyiP'><p>Parallel Computation of Renyi's Diversity Index</p></a></li>
<li><a href='#RenyiS'><p>Sequential Renyi's diversity index</p></a></li>
<li><a href='#Shannon'><p>Shannon's Evenness Index</p></a></li>
<li><a href='#ShannonP'><p>Calculate Shannon-Wiener Index on a Matrix</p></a></li>
<li><a href='#ShannonS'><p>Calculate Shannon-Wiener Index on a Matrix</p></a></li>
<li><a href='#validateInputs'><p>Validate Input Parameters for Diversity Index Calculation</p></a></li>
<li><a href='#world'><p>Natural Earth world dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Diversity Indices for Numerical Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matteo Marcantonio &lt;marcantoniomatteo@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods to calculate diversity indices on numerical matrices
    based on information theory, as described in Rocchini, Marcantonio and Ricotta (2017) &lt;<a href="https://doi.org/10.1016%2Fj.ecolind.2016.07.039">doi:10.1016/j.ecolind.2016.07.039</a>&gt;,
    and Rocchini et al. (2021) &lt;<a href="https://doi.org/10.1101%2F2021.01.23.427872">doi:10.1101/2021.01.23.427872</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, foreach, ggforce, ggplot2, methods, proxy,
progress, terra, viridis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, rasterVis, RColorBrewer, gridExtra, gstat,
latticeExtra, COVID19</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mattmar.github.io/rasterdiv/">https://mattmar.github.io/rasterdiv/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mattmar/rasterdiv/issues">https://github.com/mattmar/rasterdiv/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 14:12:34 UTC; matteo</td>
</tr>
<tr>
<td>Author:</td>
<td>Matteo Marcantonio [aut, cre],
  Martina Iannacito [aut, ctb],
  Elisa Marchetto [ctb],
  Elisa Thouverai [aut, ctb],
  Michele Torresani [aut, ctb],
  Daniele Da Re [aut],
  Clara Tattoni [aut],
  Giovanni Bacaro [aut],
  Saverio Vicario [aut, ctb],
  Carlo Ricotta [aut],
  Duccio Rocchini [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.CRE_'>Cumulative Residual Entropy</h2><span id='topic+.CRE_'></span>

<h3>Description</h3>

<p>This function calculates the Cumulative Residual Entropy (CRE) for a given set of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.CRE_(B, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".CRE__+3A_b">B</code></td>
<td>
<p>A numeric vector or matrix representing the values for which CRE is to be calculated.</p>
</td></tr>
<tr><td><code id=".CRE__+3A_base">base</code></td>
<td>
<p>The base of the logarithm used in the calculation. The default is the natural logarithm (e).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the CRE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- c(1, 2, 3, 4)
.CRE_(B)
</code></pre>

<hr>
<h2 id='.CumRes'>Calculate Cumulative Residual Probability</h2><span id='topic+.CumRes'></span>

<h3>Description</h3>

<p>This function computes the cumulative residual probability for a given set of probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.CumRes(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".CumRes_+3A_a">a</code></td>
<td>
<p>A numeric vector or matrix representing probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or matrix of cumulative residual probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- data.frame(V1= c(0.2, 0.3, 0.5), V2 =c(0.2, 0.3, 0.5))
.CumRes(a)
</code></pre>

<hr>
<h2 id='.Deltas'>Calculate Differences Among Values</h2><span id='topic+.Deltas'></span>

<h3>Description</h3>

<p>This function computes the differences among values of a table, used in probability calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.Deltas(P, first = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".Deltas_+3A_p">P</code></td>
<td>
<p>A numeric vector or matrix representing probabilities.</p>
</td></tr>
<tr><td><code id=".Deltas_+3A_first">first</code></td>
<td>
<p>The starting value for difference calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix of differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- c(0.2, 0.3, 0.5)
.Deltas(P)
</code></pre>

<hr>
<h2 id='.Prob'>Calculate Point Probability</h2><span id='topic+.Prob'></span>

<h3>Description</h3>

<p>This function computes the probability of each point in a given vector or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.Prob(C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".Prob_+3A_c">C</code></td>
<td>
<p>A numeric vector or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of probabilities corresponding to each point in 'C'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- c(1, 1, 2, 2, 3)
.Prob(C)
</code></pre>

<hr>
<h2 id='.Reorder'>Additional supporting functions like '.Reorder', '.Cumsum', '.Rev'</h2><span id='topic+.Reorder'></span>

<h3>Description</h3>

<p>These functions provide utility operations like reordering dimensions, 
computing cumulative sums, and reversing order along a specific dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.Reorder(a, ax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".Reorder_+3A_a">a</code></td>
<td>
<p>ax Additional parameters specific to each function.</p>
</td></tr>
<tr><td><code id=".Reorder_+3A_ax">ax</code></td>
<td>
<p>Additional parameters specific to each function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output varies depending on the function.
</p>

<hr>
<h2 id='BergerParker'>Berger-Parker's diversity index</h2><span id='topic+BergerParker'></span>

<h3>Description</h3>

<p>Computes Berger-Parker's diversity index on different classes of numeric matrices using a moving window algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BergerParker(
  x,
  window = 3,
  rasterOut = TRUE,
  np = 1,
  na.tolerance = 1,
  cluster.type = "SOCK",
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BergerParker_+3A_x">x</code></td>
<td>
<p>Input data may be a matrix, a Spatial Grid Data Frame, a SpatRaster, or a list of these objects. In the latter case, only the first element of the list will be considered.</p>
</td></tr>
<tr><td><code id="BergerParker_+3A_window">window</code></td>
<td>
<p>The side of the square moving window, it must be an odd numeric value greater than 1 to ensure that the target pixel is in the centre of the moving window. Default value is 3.</p>
</td></tr>
<tr><td><code id="BergerParker_+3A_rasterout">rasterOut</code></td>
<td>
<p>Boolean, if TRUE, output will be in SpatRaster format with <em>x</em> as a template.</p>
</td></tr>
<tr><td><code id="BergerParker_+3A_np">np</code></td>
<td>
<p>The number of processes (cores) which will be spawned. Default value is 1.</p>
</td></tr>
<tr><td><code id="BergerParker_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>A numeric value (0.0-1.0) which indicates the proportion of NA values that will be tolerated to calculate Berger-Parker's index in each moving window over <em>x</em>. If the relative proportion of NA's in a moving window is bigger than na.tolerance, then the value of the window will be set as NA, otherwise, Rao's index will be calculated considering the non-NA values. Default values are 1.0 (i.e., no tolerance for NA's).</p>
</td></tr>
<tr><td><code id="BergerParker_+3A_cluster.type">cluster.type</code></td>
<td>
<p>The type of cluster which will be created. The options are <code>"MPI"</code> (calls &quot;makeMPIcluster&quot;), <code>"FORK"</code>, and <code>"SOCK"</code> (call &quot;makeCluster&quot;). Default type is <code>"SOCK"</code>.</p>
</td></tr>
<tr><td><code id="BergerParker_+3A_debugging">debugging</code></td>
<td>
<p>A boolean variable set to FALSE by default. If TRUE, additional messages will be printed. For de-bugging only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Berger-Parker's index is the relative abundance of the most abundant category (i.e., unique numerical values in the considered numerical matrix). Berger-Parker's index equals the logarithm of the inverse Renyi's index of order infinity, <code class="reqn">log(1/{}^\infty H)</code> or the inverse of Hill's index of order infinity, <code class="reqn">1/{}^\infty D</code>.
</p>


<h3>Value</h3>

<p>A numerical matrix with dimensions as <code>dim(x)</code>.
</p>


<h3>Note</h3>

<p>Linux users need to install libopenmpi for MPI parallel computing. Linux Ubuntu users may try:
apt-get update; apt-get upgrade; apt-get install mpi; apt-get install libopenmpi-dev; apt-get install r-cran-rmpi
</p>
<p>Microsoft Windows users may need some additional work to use &quot;MPI&quot;, see:<br />
<a href="https://bioinfomagician.wordpress.com/2013/11/18/installing-rmpi-mpi-for-r-on-mac-and-windows/">https://bioinfomagician.wordpress.com/2013/11/18/installing-rmpi-mpi-for-r-on-mac-and-windows/</a>
</p>


<h3>Author(s)</h3>

<p>Marcantonio Matteo <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>, Martina Iannacito <a href="mailto:martina.iannacito@inria.fr">martina.iannacito@inria.fr</a>, Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>
</p>


<h3>References</h3>

<p>Berger, W.H., Parker, F.L. (1970). Diversity of planktonic foraminifera in deep-sea sediments&quot;. Science, 168: 1345-1347.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Minimal example; compute Renyi's index with alpha 1:5 
a &lt;- matrix(c(10,10,10,20,20,20,20,30,30),ncol=3,nrow=3)
berpar &lt;- BergerParker(x=a, window=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='BergerParkerP'>Calculate Berger-Parker Index on a Matrix</h2><span id='topic+BergerParkerP'></span>

<h3>Description</h3>

<p>This function computes Berger-Parker Index for each cell of a matrix, 
using a parallelized approach and considering a specified moving window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BergerParkerP(x, window = 1, na.tolerance = 1, debugging = FALSE, np = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BergerParkerP_+3A_x">x</code></td>
<td>
<p>A numeric matrix representing the data on which the index is to be calculated.</p>
</td></tr>
<tr><td><code id="BergerParkerP_+3A_window">window</code></td>
<td>
<p>The width of the moving window to consider for each cell. 
The actual window size will be '(2 * window + 1) x (2 * window + 1)'. Default is 1.</p>
</td></tr>
<tr><td><code id="BergerParkerP_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>The tolerance level for missing data within the moving window. 
A window will be processed only if the proportion of non-missing data is above this threshold. 
Value should be between 0 and 1. Default is 1.</p>
</td></tr>
<tr><td><code id="BergerParkerP_+3A_debugging">debugging</code></td>
<td>
<p>Boolean flag to enable or disable debugging messages. Default is FALSE.</p>
</td></tr>
<tr><td><code id="BergerParkerP_+3A_np">np</code></td>
<td>
<p>The number of processes (cores) which will be spawned. Default value is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimensions as 'x', where each cell contains the 
Berger-Parker Index calculated for the window around the cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- matrix(runif(100), nrow = 10)
bp_index &lt;- BergerParkerP(data, window = 1, np=2)

## End(Not run)

</code></pre>

<hr>
<h2 id='BergerParkerS'>Sequential Berger-Parker's diversity index</h2><span id='topic+BergerParkerS'></span>

<h3>Description</h3>

<p>This function calculates the Berger-Parker's diversity index for each cell in a matrix,
considering a specified moving window around each cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BergerParkerS(x, window = 1, na.tolerance = 1, debugging = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BergerParkerS_+3A_x">x</code></td>
<td>
<p>A numeric matrix representing the data on which the index is to be calculated.</p>
</td></tr>
<tr><td><code id="BergerParkerS_+3A_window">window</code></td>
<td>
<p>The width of the moving window to consider for each cell. The actual window size 
will be '(2 * window + 1) x (2 * window + 1)'. Default is 1.</p>
</td></tr>
<tr><td><code id="BergerParkerS_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>The tolerance level for missing data within the moving window. 
A window will be processed only if the proportion of non-missing data is above this threshold. 
Value should be between 0 and 1. Default is 1.</p>
</td></tr>
<tr><td><code id="BergerParkerS_+3A_debugging">debugging</code></td>
<td>
<p>Boolean flag to enable or disable debugging messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Berger-Parker's diversity index calculated sequentially over a raster matrix.
</p>


<h3>Value</h3>

<p>A matrix of the same dimensions as 'x', where each cell contains the 
Berger-Parker's diversity index calculated for the window around the cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(runif(100), nrow = 10)
bp_index &lt;- BergerParkerS(data, window = 1)

</code></pre>

<hr>
<h2 id='copNDVI'>Copernicus Long Term (1999-2017) NDVI Overview (5km)</h2><span id='topic+copNDVI'></span>

<h3>Description</h3>

<p>A <code>SpatRaster</code> (EPSG: 4326) of the global average NDVI value per pixel for the 21st of June over the period 1999-2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_copNDVI()
</code></pre>


<h3>Format</h3>

<p>A <code>SpatRaster</code> containing the following elements:
</p>

<dl>
<dt>NDVI</dt><dd><p>Normalised Difference Vegetation Index value (0-255) for each 5 km pixel. This index provides an indication of the presence of live green vegetation in the area.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset provides a long-term overview of the Normalised Difference Vegetation Index (NDVI) 
across the globe. Each pixel represents a 5 km area, with NDVI values ranging from 0 to 255.
</p>


<h3>Source</h3>

<p><a href="https://land.copernicus.eu/global/products/ndvi">https://land.copernicus.eu/global/products/ndvi</a>
</p>


<h3>References</h3>

<p><a href="https://land.copernicus.eu/global/products/ndvi">https://land.copernicus.eu/global/products/ndvi</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>copNDVI &lt;- readRDS(system.file("extdata", "copNDVI.rds", package = "rasterdiv"))
</code></pre>

<hr>
<h2 id='CRE'>Cumulative Residual Entropy (CRE) Function</h2><span id='topic+CRE'></span>

<h3>Description</h3>

<p>Computes the Cumulative Residual Entropy (CRE) for spatial raster data. This function 
can be used with either a single raster layer or a list of raster layers. It supports 
both classic and multidimensional methods for CRE computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CRE(
  x,
  window = 3,
  method = "classic",
  rasterOut = TRUE,
  rescale = FALSE,
  na.tolerance = 1,
  simplify = 2,
  np = 1,
  cluster.type = "SOCK",
  progBar = TRUE,
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CRE_+3A_x">x</code></td>
<td>
<p>A matrix, SpatRaster, or a list of SpatRaster objects.</p>
</td></tr>
<tr><td><code id="CRE_+3A_window">window</code></td>
<td>
<p>The size of the moving window, must be an odd integer.</p>
</td></tr>
<tr><td><code id="CRE_+3A_method">method</code></td>
<td>
<p>The method for CRE computation, either &quot;classic&quot; or &quot;multidimensional&quot;.</p>
</td></tr>
<tr><td><code id="CRE_+3A_rasterout">rasterOut</code></td>
<td>
<p>Logical, if TRUE, returns a SpatRaster, else returns a matrix.</p>
</td></tr>
<tr><td><code id="CRE_+3A_rescale">rescale</code></td>
<td>
<p>Logical, if TRUE, rescales the data before processing.</p>
</td></tr>
<tr><td><code id="CRE_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>A numeric value between 0 and 1, indicating the tolerance level for NA values.</p>
</td></tr>
<tr><td><code id="CRE_+3A_simplify">simplify</code></td>
<td>
<p>Integer, the number of decimal places for data rounding in case of float numbers.</p>
</td></tr>
<tr><td><code id="CRE_+3A_np">np</code></td>
<td>
<p>The number of parallel processes to use.</p>
</td></tr>
<tr><td><code id="CRE_+3A_cluster.type">cluster.type</code></td>
<td>
<p>The type of parallel cluster to use, options are &quot;SOCK&quot;, &quot;FORK&quot;, or &quot;MPI&quot;.</p>
</td></tr>
<tr><td><code id="CRE_+3A_progbar">progBar</code></td>
<td>
<p>logical. If TRUE a progress bar is shown.</p>
</td></tr>
<tr><td><code id="CRE_+3A_debugging">debugging</code></td>
<td>
<p>Logical, if TRUE, provides additional debugging information during execution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the 'rasterOut' parameter, this function returns either a SpatRaster or a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# For a matrix input:
result &lt;- CRE(matrix_data, window=3, method="classic")

# For a SpatRaster input:
result &lt;- CRE(raster_data, window=3, method="classic", rasterOut=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='heliPlot'>Create a Helical Plot for Time Series Data</h2><span id='topic+heliPlot'></span>

<h3>Description</h3>

<p>Creates a helical plot to visualize time series data, emphasizing both
the magnitude and rate of change over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heliPlot(
  data,
  group = NULL,
  facet = FALSE,
  xlabel = "Rate of Change",
  ylabel = "Values",
  arrow = TRUE,
  dateFont = 3,
  dateInterval = FALSE,
  sizeRange = c(1, 3),
  facetScales = "free",
  dateFormat = "%d %b %y",
  n = nrow(data),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heliPlot_+3A_data">data</code></td>
<td>
<p>A data frame containing the time series data with required columns: &quot;values_avg&quot;, &quot;change_rate&quot;, and &quot;date&quot;.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_group">group</code></td>
<td>
<p>(Optional) A string specifying the column name in 'data' to use for grouping data in the plot. If NULL, no grouping is applied.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_facet">facet</code></td>
<td>
<p>Logical indicating whether to facet the plot based on the 'group' variable. If TRUE and 'group' is NULL, an error is raised.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_xlabel">xlabel</code></td>
<td>
<p>Label for the x-axis, defaults to &quot;Rate of Change&quot;.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_ylabel">ylabel</code></td>
<td>
<p>Label for the y-axis, defaults to &quot;Values&quot;.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_arrow">arrow</code></td>
<td>
<p>Logical indicating whether to add an arrow to the end of each line, defaults to TRUE.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_datefont">dateFont</code></td>
<td>
<p>Numeric specifying the size of the date font, defaults to 3.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_dateinterval">dateInterval</code></td>
<td>
<p>Numeric specifying the interval at which date labels should be displayed. If FALSE, no date labels are shown.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_sizerange">sizeRange</code></td>
<td>
<p>Numeric vector of length 2 specifying the range of line widths.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_facetscales">facetScales</code></td>
<td>
<p>Character string indicating whether scales should be &quot;fixed&quot;, &quot;free_x&quot;, &quot;free_y&quot;, or &quot;free&quot;.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_dateformat">dateFormat</code></td>
<td>
<p>Format for the date labels, defaults to d-b-y.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_n">n</code></td>
<td>
<p>Numeric specifying the number of points to interpolate along the spline, defaults to the number of rows in 'data'.</p>
</td></tr>
<tr><td><code id="heliPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to 'ggplot2' layer functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'ggplot' object representing the helical plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assuming `dataPrep` is a data frame prepared with the required structure:

## Not run: 
heliPlot(dataPrep, group = "myGroup", arrow = TRUE, 
dateFont = 3, dateInterval = 30, sizeRange = c(1, 3))

## End(Not run)

</code></pre>

<hr>
<h2 id='heliPrep'>Prepare Data for Helical Plotting</h2><span id='topic+heliPrep'></span>

<h3>Description</h3>

<p>This function preprocesses a time series data for helical plotting by
applying a moving average and smoothing the values and their rate of change.
It also handles conversion of numeric dates to Date objects and ensures
proper alignment of the time series for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heliPrep(dates, values, filterWidth = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heliPrep_+3A_dates">dates</code></td>
<td>
<p>A vector of dates associated with the values; can be numeric or
Date objects. If numeric, they are treated as days since a given start date.</p>
</td></tr>
<tr><td><code id="heliPrep_+3A_values">values</code></td>
<td>
<p>A numeric vector of the time series values corresponding to the dates.</p>
</td></tr>
<tr><td><code id="heliPrep_+3A_filterwidth">filterWidth</code></td>
<td>
<p>The size of the moving window to calculate the moving average.
Defaults to 7</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame suitable for helical plotting, containing the original
dates, the smoothed values ('ch_avg'), the smoothed rate of change ('ch_rate'),
and the endpoints for plotting ('yend', 'xend').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Assume 'dates' and 'values' are available time series data
  prepared_data &lt;- heliPrep(dates, values)
  # Now 'prepared_data' can be used for helical plotting with 'heliPlot'

## End(Not run)

</code></pre>

<hr>
<h2 id='Hill'>Hill's index of diversity - Hill numbers (D)</h2><span id='topic+Hill'></span>

<h3>Description</h3>

<p>Computes Hill's index of diversity (Hill numbers) on different classes of numeric matrices using a moving window algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hill(
  x,
  window = 3,
  alpha = 1,
  base = exp(1),
  rasterOut = TRUE,
  np = 1,
  na.tolerance = 1,
  cluster.type = "SOCK",
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hill_+3A_x">x</code></td>
<td>
<p>Input data may be a matrix, a Spatial Grid Data Frame, a SpatRaster, or a list of these objects. In the latter case, only the first element of the list will be considered.</p>
</td></tr>
<tr><td><code id="Hill_+3A_window">window</code></td>
<td>
<p>The side of the square moving window. It must be an odd numeric value greater than 1 to ensure that the target pixel is in the centre of the moving window. Default value is 3.</p>
</td></tr>
<tr><td><code id="Hill_+3A_alpha">alpha</code></td>
<td>
<p>Order of the Hill number to compute the index. If <code>alpha</code> is a vector with length greater than 1, then the index will be calculated over <code>x</code> for each value in the sequence.</p>
</td></tr>
<tr><td><code id="Hill_+3A_base">base</code></td>
<td>
<p>The logarithm base for the calculation, default is natural logarithm.</p>
</td></tr>
<tr><td><code id="Hill_+3A_rasterout">rasterOut</code></td>
<td>
<p>Boolean; if TRUE, the output will be in SpatRaster format with <code>x</code> as the template.</p>
</td></tr>
<tr><td><code id="Hill_+3A_np">np</code></td>
<td>
<p>The number of processes (cores) which will be spawned. Default value is 1.</p>
</td></tr>
<tr><td><code id="Hill_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>A numeric value between 0.0 and 1.0, which indicates the proportion of NA values that will be tolerated to calculate Hill's index in each moving window over <code>x</code>. If the relative proportion of NA's in a moving window is bigger than na.tolerance, then the value of the window will be set as NA; otherwise, Hill's index will be calculated considering the non-NA values. Default value is 1.0 (i.e., full tolerance for NA's).</p>
</td></tr>
<tr><td><code id="Hill_+3A_cluster.type">cluster.type</code></td>
<td>
<p>The type of cluster which will be created. Options are &quot;MPI&quot; (calls &quot;makeMPIcluster&quot;), &quot;FORK,&quot; and &quot;SOCK&quot; (call &quot;makeCluster&quot;). Default type is &quot;SOCK&quot;.</p>
</td></tr>
<tr><td><code id="Hill_+3A_debugging">debugging</code></td>
<td>
<p>A boolean variable set to FALSE by default. If TRUE, additional messages will be printed for debugging purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hill numbers (<code class="reqn">{}^qD</code>) are calculated on numerical matrices as <code class="reqn">{}^qD = (\sum_{i=1}^{R} {p^q}_i)^{1/(1-q)}</code>, where <em>q</em> is the order of the Hill number, <em>R</em> is the total number of categories (i.e., unique numerical values in a numerical matrix), and <em>p</em> is the relative abundance of each category. When q=1, Shannon.R is called to calculate <code class="reqn">exp(H^1)</code> instead of the indefinite <code class="reqn">{}^1D</code>. If <code class="reqn">q &gt; 2*10^9</code>, BergerParker.R is called to calculate <code class="reqn">1/{{}^\infty D}</code>. Hill numbers of low order weight more rare categories, whereas Hill numbers of higher order weight more dominant categories.
</p>


<h3>Value</h3>

<p>A list of matrices of dimension <code>dim(x)</code> with length equal to the length of <code>alpha</code>.
</p>


<h3>Note</h3>

<p>Linux users need to install libopenmpi for MPI parallel computing. Linux Ubuntu users may try:
<code>apt-get update; apt-get upgrade; apt-get install mpi; apt-get install libopenmpi-dev; apt-get install r-cran-rmpi</code>
</p>
<p>Microsoft Windows users may need some additional work to use &quot;MPI&quot;. For more details, see:
<a href="https://bioinfomagician.wordpress.com/2013/11/18/installing-rmpi-mpi-for-r-on-mac-and-windows/">https://bioinfomagician.wordpress.com/2013/11/18/installing-rmpi-mpi-for-r-on-mac-and-windows/</a>
</p>


<h3>References</h3>

<p>Hill, M.O. (1973). Diversity and evenness: a unifying notation and its consequences. Ecology 54, 427-432.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BergerParker">BergerParker</a></code>, <code><a href="#topic+Shannon">Shannon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Minimal example; compute Hill's index with alpha 1:5 
a &lt;- matrix(c(10,10,10,20,20,20,20,30,30),ncol=3,nrow=3)
hill &lt;- Hill(x=a,window=3,alpha=1:5)

</code></pre>

<hr>
<h2 id='HillP'>Parallelised Hill's diversity index</h2><span id='topic+HillP'></span>

<h3>Description</h3>

<p>Parallelised computation of Hill's diversity index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HillP(rasterm, window, alpha, na.tolerance, debugging, np)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HillP_+3A_rasterm">rasterm</code></td>
<td>
<p>Input data.</p>
</td></tr>
<tr><td><code id="HillP_+3A_window">window</code></td>
<td>
<p>Half of the side of the square moving window.</p>
</td></tr>
<tr><td><code id="HillP_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value for the order of diversity in Hill's Index.</p>
</td></tr>
<tr><td><code id="HillP_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>A numeric value between 0.0 and 1.0, which indicates the proportion of NA values that will be tolerated to calculate the index in each moving window over <code>rasterm</code>. If the relative proportion of NA's in a moving window is bigger than na.tolerance, then the value of the window will be set as NA; otherwise, the index will be calculated considering the non-NA values. Default value is 0.0 (i.e., no tolerance for NA's).</p>
</td></tr>
<tr><td><code id="HillP_+3A_debugging">debugging</code></td>
<td>
<p>A boolean variable set to FALSE by default. If TRUE, additional messages will be printed for debugging purposes.</p>
</td></tr>
<tr><td><code id="HillP_+3A_np">np</code></td>
<td>
<p>Number of processes for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix or a list of matrices with the Hill index computed through a moving window of the given size.
</p>


<h3>Author(s)</h3>

<p>Marcantonio Matteo <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>, Martina Iannacito <a href="mailto:martina.iannacito@inria.fr">martina.iannacito@inria.fr</a>, Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hill">Hill</a></code>
</p>

<hr>
<h2 id='HillS'>Sequential Hill's diversity index</h2><span id='topic+HillS'></span>

<h3>Description</h3>

<p>Computes Hill's diversity index in a non-parallelized (sequential) manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HillS(x, window = 1, alpha = 1, na.tolerance = 1, debugging = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HillS_+3A_x">x</code></td>
<td>
<p>Input data.</p>
</td></tr>
<tr><td><code id="HillS_+3A_window">window</code></td>
<td>
<p>Half of the side of the square moving window.</p>
</td></tr>
<tr><td><code id="HillS_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value for the order of diversity in Hill's Index.</p>
</td></tr>
<tr><td><code id="HillS_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>A numeric value between 0.0 and 1.0, which indicates the proportion of NA values that will be tolerated to calculate Hill's index in each moving window over <code>x</code>. If the relative proportion of NA's in a moving window is greater than na.tolerance, then the value of the window will be set as NA; otherwise, the index will be calculated considering the non-NA values. Default value is 1.0 (i.e., full tolerance for NA's).</p>
</td></tr>
<tr><td><code id="HillS_+3A_debugging">debugging</code></td>
<td>
<p>A boolean variable set to FALSE by default. If TRUE, additional messages will be printed for debugging purposes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix or a list of matrices with the Hill index computed through a moving window of the given size.
</p>


<h3>Author(s)</h3>

<p>Marcantonio Matteo <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>, Martina Iannacito <a href="mailto:martina.iannacito@inria.fr">martina.iannacito@inria.fr</a>, Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hill">Hill</a></code>
</p>

<hr>
<h2 id='load_copNDVI'>Load Copernicus NDVI data</h2><span id='topic+load_copNDVI'></span>

<h3>Description</h3>

<p>This function loads and returns the Copernicus Long Term (1999-2017) NDVI Overview stored within the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_copNDVI()
</code></pre>


<h3>Value</h3>

<p>A 'SpatRaster' object representing the Copernicus NDVI data.
</p>

<hr>
<h2 id='load_world'>Load Natural Earth world dataset</h2><span id='topic+load_world'></span>

<h3>Description</h3>

<p>This function loads and returns the World Vector data stored within the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_world()
</code></pre>


<h3>Details</h3>

<p>SpatVector (EPSG: 4326) of the world dissolved on continents.
</p>


<h3>Value</h3>

<p>A 'SpatVector' object representing the World vector data.
</p>


<h3>Source</h3>

<p><code>https://www.naturalearthdata.com/</code>
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+vect">vect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
world_data &lt;- load_world_vector()
plot(world_data)

## End(Not run)

</code></pre>

<hr>
<h2 id='mpaRaoAreaS'>Area-Based Sequential Parametric Rao's index of quadratic entropy (Q)</h2><span id='topic+mpaRaoAreaS'></span>

<h3>Description</h3>

<p>Calculates an area-based sequential version of the parametric Rao's index of quadratic entropy (Q). 
This function is designed for situations where the diversity index needs to consider geographical 
areas and works with raster data representing the distribution of species or other measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpaRaoAreaS(rasterm, area, alpha, simplify, dist_m, rescale, lambda, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpaRaoAreaS_+3A_rasterm">rasterm</code></td>
<td>
<p>Raster; the input raster data representing variables across a geographic space.</p>
</td></tr>
<tr><td><code id="mpaRaoAreaS_+3A_area">area</code></td>
<td>
<p>Numeric; the input vector data representing the areas of interest.</p>
</td></tr>
<tr><td><code id="mpaRaoAreaS_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; alpha value for order of diversity in Hill's Index.</p>
</td></tr>
<tr><td><code id="mpaRaoAreaS_+3A_simplify">simplify</code></td>
<td>
<p>Numeric; the parameter that determines the rounding off of the calculations.</p>
</td></tr>
<tr><td><code id="mpaRaoAreaS_+3A_dist_m">dist_m</code></td>
<td>
<p>Character; type of distance metric used (e.g., &quot;euclidean&quot;, &quot;manhattan&quot;, etc.).</p>
</td></tr>
<tr><td><code id="mpaRaoAreaS_+3A_rescale">rescale</code></td>
<td>
<p>Logical; whether to scale and centre the values in each element of the raster data.</p>
</td></tr>
<tr><td><code id="mpaRaoAreaS_+3A_lambda">lambda</code></td>
<td>
<p>Numeric; lambda parameter for Minkowski distance calculation.</p>
</td></tr>
<tr><td><code id="mpaRaoAreaS_+3A_window">window</code></td>
<td>
<p>Numeric; defines the size of the moving window for the analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector similar to the input, with additional columns representing Rao's index values for 
each area.
</p>


<h3>Author(s)</h3>

<p>Matteo Marcantonio <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>,
Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>,
Michele Torresani <a href="mailto:michele.torresani@unibo.it">michele.torresani@unibo.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paRao">paRao</a></code> for a related function dealing with the parallel computation of Rao's index.
</p>

<hr>
<h2 id='mpaRaoP'>Multidimensional parallel Parametric Rao's index of quadratic entropy (Q)</h2><span id='topic+mpaRaoP'></span>

<h3>Description</h3>

<p>Multidimensional parametric Rao's index of quadratic entropy (Q).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpaRaoP(
  x,
  alpha,
  window,
  dist_m,
  na.tolerance,
  rescale,
  lambda,
  diag,
  debugging,
  isfloat,
  mfactor,
  np
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpaRaoP_+3A_x">x</code></td>
<td>
<p>input list.</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_alpha">alpha</code></td>
<td>
<p>alpha value for order of diversity in Hill's Index.</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_window">window</code></td>
<td>
<p>half of the side of the square moving window.</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_dist_m">dist_m</code></td>
<td>
<p>Type of distance used.</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>a numeric value <code class="reqn">(0.0-1.0)</code> which indicates the proportion
of NA values that will be tolerated to calculate Rao's index in each moving
window over <em>x</em>. If the relative proportion of NA's in a moving window is
bigger than na.tolerance, then the value of the window will be set as NA,
otherwise Rao's index will be calculated considering the non-NA values.
Default values is 0.0 (i.e., no tolerance for NA's).</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_rescale">rescale</code></td>
<td>
<p>Scale and centre values in each of the element of x.</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_lambda">lambda</code></td>
<td>
<p>Lambda value for Minkowski distance.</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_diag">diag</code></td>
<td>
<p>Boolean. Diagonal of the distance matrix.</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_debugging">debugging</code></td>
<td>
<p>a boolean variable set to FALSE by default. If TRUE, additional
messages will be printed. For de-bugging only.</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_isfloat">isfloat</code></td>
<td>
<p>Are the input data floats?</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_mfactor">mfactor</code></td>
<td>
<p>Multiplication factor in case of input data as float numbers.</p>
</td></tr>
<tr><td><code id="mpaRaoP_+3A_np">np</code></td>
<td>
<p>the number of processes (cores) which will be spawned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices of dimension <code>dim(x)</code> with length equal to the
length of <code>alpha</code>.
</p>


<h3>Author(s)</h3>

<p>Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>, Marcantonio Matteo
<a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paRao">paRao</a></code>
</p>

<hr>
<h2 id='mpaRaoS'>Multidimensional sequential Parametric Rao's index of quadratic entropy (Q)</h2><span id='topic+mpaRaoS'></span>

<h3>Description</h3>

<p>This function calculates the multidimensional parametric Rao's index of quadratic entropy (Q) using a 
sequential method. It is particularly useful in contexts where parallel computation is not feasible or desired.
The function applies a moving window approach to the provided raster data stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpaRaoS(
  x,
  alpha,
  window,
  dist_m,
  na.tolerance,
  rescale,
  lambda,
  diag,
  debugging,
  isfloat,
  mfactor,
  np
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpaRaoS_+3A_x">x</code></td>
<td>
<p>input list.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; alpha value for order of diversity in Hill's Index.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_window">window</code></td>
<td>
<p>Numeric; half of the side of the square moving window used for calculation.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_dist_m">dist_m</code></td>
<td>
<p>Character; type of distance used in the analysis.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>Numeric; a threshold between 0.0 and 1.0 indicating the allowable proportion of NA 
values within each moving window. If the proportion of NA values exceeds this, the window's value is set as 
NA; otherwise, the computation uses the non-NA values.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_rescale">rescale</code></td>
<td>
<p>Logical; if TRUE, scales and centres the values in each element of 'x'.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_lambda">lambda</code></td>
<td>
<p>Numeric; lambda value used for Minkowski distance calculation.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_diag">diag</code></td>
<td>
<p>Logical; if TRUE, includes the diagonal of the distance matrix in computations.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_debugging">debugging</code></td>
<td>
<p>Logical; if TRUE, additional diagnostic messages are output, useful for debugging. Default 
is FALSE.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_isfloat">isfloat</code></td>
<td>
<p>Logical; specifies if the input data are floats.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_mfactor">mfactor</code></td>
<td>
<p>Numeric; multiplication factor applied if input data are float numbers.</p>
</td></tr>
<tr><td><code id="mpaRaoS_+3A_np">np</code></td>
<td>
<p>Number of processes for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices, each representing a layer of the input RasterStack, containing calculated 
Rao's index values. The dimensions correspond to those of the input, and the list length is equal to the 
length of 'alpha'.
</p>


<h3>Author(s)</h3>

<p>Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>, 
Matteo Marcantonio <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paRao">paRao</a></code> for the parallelized version of the Rao's index computation.
</p>

<hr>
<h2 id='ndviForestTS'>Simulated NDVI dataset</h2><span id='topic+ndviForestTS'></span>

<h3>Description</h3>

<p>A <code>list</code> of 8-bit matrices.
</p>


<h3>Format</h3>

<p>A <code>list</code> containing matrices:
</p>

<dl>
<dt>ndviForestTS</dt><dd><p>List of matrixes of 9 cells simulating NDVI of a patch of forests over 3 years. Each matrix represents a day in the time series.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This list represents a time series of NDVI values of a patch of forest over 3 years. 
It is stored as a <code>list</code>, suitable for explaining how to make helical plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ndviForestTS &lt;- readRDS(system.file("extdata", "ndviForestTS.rds", package = "rasterdiv"))
</code></pre>

<hr>
<h2 id='openCluster'>Open a Parallel Cluster</h2><span id='topic+openCluster'></span>

<h3>Description</h3>

<p>Opens a parallel cluster for computation, registers it for parallel operations,
and ensures its closure on script exit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>openCluster(cluster.type = "SOCK", np = 2, progBar = TRUE, debugging = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="openCluster_+3A_cluster.type">cluster.type</code></td>
<td>
<p>A character string specifying the type of cluster.
Accepted values are &quot;SOCK&quot;, &quot;FORK&quot;, or &quot;MPI&quot;.</p>
</td></tr>
<tr><td><code id="openCluster_+3A_np">np</code></td>
<td>
<p>An integer specifying the number of processes to be used in the parallel cluster.</p>
</td></tr>
<tr><td><code id="openCluster_+3A_progbar">progBar</code></td>
<td>
<p>logical. If TRUE a progress bar is shown.</p>
</td></tr>
<tr><td><code id="openCluster_+3A_debugging">debugging</code></td>
<td>
<p>logical. For developer use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the parallel cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Open a SOCK cluster with 4 cores
  cls &lt;- openCluster("SOCK", 4)
  # Your parallel computation code here
  # The cluster will automatically close when the script exits

## End(Not run)

</code></pre>

<hr>
<h2 id='paRao'>Parametric Rao's index of quadratic entropy (Q)</h2><span id='topic+paRao'></span>

<h3>Description</h3>

<p>It computes the parametric version of Rao's index of quadratic entropy (Q) on different classes of numeric matrices using a moving window algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paRao(
  x,
  area = NULL,
  field = NULL,
  dist_m = "euclidean",
  window = 9,
  alpha = 1,
  method = "classic",
  rasterOut = TRUE,
  lambda = 0,
  na.tolerance = 1,
  rescale = FALSE,
  diag = TRUE,
  simplify = 0,
  np = 1,
  cluster.type = "SOCK",
  progBar = TRUE,
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paRao_+3A_x">x</code></td>
<td>
<p>Input data may be a matrix, a Spatial Grid Data Frame, a SpatRaster, or a list of these objects.</p>
</td></tr>
<tr><td><code id="paRao_+3A_area">area</code></td>
<td>
<p>Input vector area layer for area-based calculation.</p>
</td></tr>
<tr><td><code id="paRao_+3A_field">field</code></td>
<td>
<p>Column name of the vector area layer to use to calculate the index.</p>
</td></tr>
<tr><td><code id="paRao_+3A_dist_m">dist_m</code></td>
<td>
<p>Define the type of distance to be calculated between numerical categories. 'dist_m' can be a character string which defines the name of the distance to derive such as &quot;euclidean&quot;. The distance names allowed are the same as for <code>proxy::dist</code>. Alternatively, 'dist_m' can be a function which calculates a user-defined distance, (i.e., <code>function(x,y) {return(cos(y-x)-sin(y-x))}</code>) or a matrix of distances. If 'method=&quot;multidimension&quot;' then only &quot;euclidean&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;minkowski&quot; and &quot;mahalanobis&quot; can be used. Default value is &quot;euclidean&quot;. If 'dist_m' is a matrix, then the function will assume that the matrix contains the distances.</p>
</td></tr>
<tr><td><code id="paRao_+3A_window">window</code></td>
<td>
<p>The side of the square moving window, it must be a vector of odd numeric values greater than 1 to ensure that the target pixel is in the centre of the moving window. Default value is 3. &lsquo;window' can be a vector with length greater than 1, in this case, Rao&rsquo;s index will be calculated over 'x' for each value in the vector.</p>
</td></tr>
<tr><td><code id="paRao_+3A_alpha">alpha</code></td>
<td>
<p>Weight for the distance matrix. If &lsquo;alpha = 0', distances will be averaged with a geometric average, if 'alpha=1' with an arithmetic mean, if 'alpha = 2' with a quadratic mean, 'alpha = 3' with a cubic mean, and so on. if 'alpha' tends to infinite (i.e., higher than the maximum integer allowed in R) or 'alpha=Inf', then the maximum distance will be taken. 'alpha' can be a vector with length greater than 1, in this case, Rao&rsquo;s index will be calculated over 'x' for each value in the vector.</p>
</td></tr>
<tr><td><code id="paRao_+3A_method">method</code></td>
<td>
<p>Currently, there are two ways to calculate the parametric version of Rao's index. If &lsquo;method=&quot;classic&quot;', then the normal parametric Rao&rsquo;s index will be calculated on a single matrix. If &lsquo;method=&quot;multidimension&quot;' (experimental!), a list of matrices must be provided as input. In the latter case, the overall distance matrix will be calculated in a multi- or hyper-dimensional system by using the distance measure defined through the function argument 'dist_m'. Each pairwise distance is then multiplied by the inverse of the squared number of pixels in the considered moving window, and the Rao&rsquo;s Q is finally derived by applying a summation. Default value is '&quot;classic&quot;'.</p>
</td></tr>
<tr><td><code id="paRao_+3A_rasterout">rasterOut</code></td>
<td>
<p>Boolean, if TRUE the output will be a SpatRaster object with 'x' as a template.</p>
</td></tr>
<tr><td><code id="paRao_+3A_lambda">lambda</code></td>
<td>
<p>The value of the lambda of Minkowski's distance. Considered only if 'dist_m = &quot;minkowski&quot;' and 'method=&quot;multidimension&quot;'. Default value is 0.</p>
</td></tr>
<tr><td><code id="paRao_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>Numeric value (0.0-1.0) which indicates the proportion of NA values that will be tolerated to calculate Rao's index in each moving window over &lsquo;x'. If the relative proportion of NA&rsquo;s in a moving window is bigger than &lsquo;na.tolerance', then the value of the window will be set as NA, otherwise Rao&rsquo;s index will be calculated considering the non-NA values. Default value is 1.0.</p>
</td></tr>
<tr><td><code id="paRao_+3A_rescale">rescale</code></td>
<td>
<p>Boolean. Considered only if 'method=&quot;multidimension&quot;'. If TRUE, each element of 'x' is rescaled and centred.</p>
</td></tr>
<tr><td><code id="paRao_+3A_diag">diag</code></td>
<td>
<p>Boolean. If TRUE then the diagonal of the distance matrix is filled with 0's, otherwise with NA's. If &lsquo;diag=TRUE' and 'alpha=0', the output matrix will inexorably be 0&rsquo;s.</p>
</td></tr>
<tr><td><code id="paRao_+3A_simplify">simplify</code></td>
<td>
<p>Number of decimal places to be retained to calculate distances in Rao's index. Default 'simplify=0'.</p>
</td></tr>
<tr><td><code id="paRao_+3A_np">np</code></td>
<td>
<p>The number of processes (cores) which will be spawned. Default value is 2.</p>
</td></tr>
<tr><td><code id="paRao_+3A_cluster.type">cluster.type</code></td>
<td>
<p>The type of cluster which will be created. The options are '&quot;MPI&quot;' (which calls &quot;makeMPIcluster&quot;), '&quot;FORK&quot;', and '&quot;SOCK&quot;' (which call &quot;makeCluster&quot;). Default type is '&quot;SOCK&quot;'.</p>
</td></tr>
<tr><td><code id="paRao_+3A_progbar">progBar</code></td>
<td>
<p>logical. If TRUE a progress bar is shown.</p>
</td></tr>
<tr><td><code id="paRao_+3A_debugging">debugging</code></td>
<td>
<p>A boolean variable set to FALSE by default. If TRUE, additional messages will be printed. For debugging only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parametric Rao's Index (Q) is an extension of Rao's Index which considers a generalized mean between distances. The general formula for the parametric Rao's index is Q_a = </p>
<p style="text-align: center;"><code class="reqn">Q = \sum_{i, j} p_i p_j d_{ij}^{\alpha}</code>
</p>
<p>. Where &lsquo;N' is the number of numerical categories, 'i' and 'j' are pair of numerical categories in the same moving window, and 'alpha' is a weight given to distances. In the &quot;multidimension&quot; Rao&rsquo;s index, first the distances among categories are calculated considering more than one feature, and then the overall Rao's Q is derived by using these distances.
</p>


<h3>Value</h3>

<p>A list of matrices of dimension 'dim(x)' with length equal to the length of 'alpha'. If 'rasterOut=TRUE' and 'x' is a SpatRaster, then the output is a list of SpatRaster objects.
</p>


<h3>References</h3>

<p>Rao, C. R. (1982). Diversity and dissimilarity coefficients: A unified approach. Theoretical Population Biology, 21(1), 24-43.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# loading data
data(volcano)
r &lt;- terra::rast(volcano)

# we want to compute Rao's index on this data using a 3x3 window
res &lt;- paRao(x = r, window = 3, alpha = 2, method = "classic")
terra::plot(res[[1]][[1]])

## End(Not run)

</code></pre>

<hr>
<h2 id='paRaoAreaS'>Area-Based Sequential Parametric Rao's index of quadratic entropy (Q)</h2><span id='topic+paRaoAreaS'></span>

<h3>Description</h3>

<p>Area-Based Sequential Parametric Rao's index of quadratic entropy (Q).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paRaoAreaS(rasterm, area, alpha, simplify)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paRaoAreaS_+3A_rasterm">rasterm</code></td>
<td>
<p>input raster data.</p>
</td></tr>
<tr><td><code id="paRaoAreaS_+3A_area">area</code></td>
<td>
<p>input vector data.</p>
</td></tr>
<tr><td><code id="paRaoAreaS_+3A_alpha">alpha</code></td>
<td>
<p>alpha value for order of diversity in Hill's Index.</p>
</td></tr>
<tr><td><code id="paRaoAreaS_+3A_simplify">simplify</code></td>
<td>
<p>Rounding parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector as the input with Rao's index pasted additional columns.
</p>


<h3>Author(s)</h3>

<p>Marcantonio Matteo <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>, 
Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>, 
Michele Torresani <a href="mailto:michele.torresani@unibo.it">michele.torresani@unibo.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paRao">paRao</a></code>
</p>

<hr>
<h2 id='paRaoP'>Parallelized Parametric Rao's index of quadratic entropy (Q)</h2><span id='topic+paRaoP'></span>

<h3>Description</h3>

<p>This function computes the parametric Rao's index of quadratic entropy (Q), a measure of biodiversity 
that considers the evolutionary distances between species, utilizing parallel computing for enhanced 
performance. The computation is applied over a moving window across the input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paRaoP(
  x,
  alpha,
  window,
  dist_m,
  na.tolerance,
  diag,
  debugging,
  isfloat,
  mfactor,
  np
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paRaoP_+3A_x">x</code></td>
<td>
<p>Matrix or data frame; the input data over which the index calculation is performed.</p>
</td></tr>
<tr><td><code id="paRaoP_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; specifies the alpha value for the order of diversity in Hill's Index.</p>
</td></tr>
<tr><td><code id="paRaoP_+3A_window">window</code></td>
<td>
<p>Numeric; half of the side length of the square moving window used in the calculation.</p>
</td></tr>
<tr><td><code id="paRaoP_+3A_dist_m">dist_m</code></td>
<td>
<p>Character; specifies the type of distance metric used in calculations.</p>
</td></tr>
<tr><td><code id="paRaoP_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>Numeric; the threshold proportion of NA values allowed in the moving window. 
If exceeded, the calculation for that window is skipped. Values range from 0.0 (no tolerance) to 1.0.</p>
</td></tr>
<tr><td><code id="paRaoP_+3A_diag">diag</code></td>
<td>
<p>Logical; indicates whether the diagonal of the distance matrix should be included in the 
computation. Typically set to FALSE.</p>
</td></tr>
<tr><td><code id="paRaoP_+3A_debugging">debugging</code></td>
<td>
<p>Logical; set to FALSE by default. If TRUE, additional console messages will be 
displayed for debugging purposes.</p>
</td></tr>
<tr><td><code id="paRaoP_+3A_isfloat">isfloat</code></td>
<td>
<p>Logical; indicates whether the input data values are floating-point numbers.</p>
</td></tr>
<tr><td><code id="paRaoP_+3A_mfactor">mfactor</code></td>
<td>
<p>Integer; multiplication factor in case of input data as float numbers.</p>
</td></tr>
<tr><td><code id="paRaoP_+3A_np">np</code></td>
<td>
<p>Number of processes for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices corresponding to the computed Rao's index values. Each matrix in the list 
represents the calculations performed over the moving window, with dimensions equal to <code>dim(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>,
Matteo Marcantonio <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paRao">paRao</a></code> for the related non-parallelized function.
</p>

<hr>
<h2 id='paRaoS'>Sequential Parametric Rao's index of quadratic entropy (Q)</h2><span id='topic+paRaoS'></span>

<h3>Description</h3>

<p>Computes the sequential version of the parametric Rao's index of quadratic entropy (Q), 
a measure used in environmental and ecological studies to assess biodiversity by considering 
the evolutionary distance between species. The function performs calculations in a sequential 
manner over a moving window across the input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paRaoS(
  x,
  alpha,
  window,
  dist_m,
  na.tolerance,
  diag,
  debugging,
  isfloat,
  mfactor
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paRaoS_+3A_x">x</code></td>
<td>
<p>Matrix or data frame; the input data over which the index calculation is performed.</p>
</td></tr>
<tr><td><code id="paRaoS_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; specifies the alpha value for the order of diversity in Hill's Index.</p>
</td></tr>
<tr><td><code id="paRaoS_+3A_window">window</code></td>
<td>
<p>Numeric; half of the side length of the square moving window used in the calculation.</p>
</td></tr>
<tr><td><code id="paRaoS_+3A_dist_m">dist_m</code></td>
<td>
<p>Character; specifies the type of distance metric used in calculations.</p>
</td></tr>
<tr><td><code id="paRaoS_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>Numeric; the threshold proportion of NA values allowed in the moving window. 
If exceeded, the calculation for that window is skipped. Values range from 0.0 (no tolerance) to 1.0.</p>
</td></tr>
<tr><td><code id="paRaoS_+3A_diag">diag</code></td>
<td>
<p>Logical; indicates whether the diagonal of the distance matrix should be included in the 
computation. Typically set to FALSE.</p>
</td></tr>
<tr><td><code id="paRaoS_+3A_debugging">debugging</code></td>
<td>
<p>Logical; set to FALSE by default. If TRUE, additional console messages will be 
displayed for debugging purposes.</p>
</td></tr>
<tr><td><code id="paRaoS_+3A_isfloat">isfloat</code></td>
<td>
<p>Logical; indicates whether the input data values are floating-point numbers.</p>
</td></tr>
<tr><td><code id="paRaoS_+3A_mfactor">mfactor</code></td>
<td>
<p>Integer; indicates the decimal position to round.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices corresponding to the computed Rao's index values. Each matrix in the list 
represents the calculations performed over the moving window, with dimensions equal to <code>dim(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>,
Matteo Marcantonio <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paRao">paRao</a></code> for the related non-sequential function.
</p>

<hr>
<h2 id='Pielou'>Pielou's Evenness Index</h2><span id='topic+Pielou'></span>

<h3>Description</h3>

<p>Calculates Pielou's Evenness Index for a given raster object over a specified window size. The function can operate in either sequential or parallel mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pielou(
  x,
  window = 3,
  rasterOut = TRUE,
  np = 1,
  na.tolerance = 1,
  cluster.type = "SOCK",
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pielou_+3A_x">x</code></td>
<td>
<p>A raster object (matrix, SpatRaster, SpatialGridDataFrame, or a list containing one of these).</p>
</td></tr>
<tr><td><code id="Pielou_+3A_window">window</code></td>
<td>
<p>The size of the moving window to be used for the calculation. Must be an odd integer.</p>
</td></tr>
<tr><td><code id="Pielou_+3A_rasterout">rasterOut</code></td>
<td>
<p>Logical, if TRUE the output will be a raster object; if FALSE a matrix.</p>
</td></tr>
<tr><td><code id="Pielou_+3A_np">np</code></td>
<td>
<p>The number of processes to use in parallel mode. If np &gt; 1, parallel computation is enabled.</p>
</td></tr>
<tr><td><code id="Pielou_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>The tolerance level for NA values within the moving window, expressed as a proportion (0 to 1).</p>
</td></tr>
<tr><td><code id="Pielou_+3A_cluster.type">cluster.type</code></td>
<td>
<p>The type of cluster to use for parallel computation (e.g., &quot;SOCK&quot;, &quot;FORK&quot;).</p>
</td></tr>
<tr><td><code id="Pielou_+3A_debugging">debugging</code></td>
<td>
<p>Logical, if TRUE debugging information will be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a raster object or matrix containing the Pielou's Evenness Index values.
</p>

<hr>
<h2 id='PielouP'>Parallelised Pielou's diversity index</h2><span id='topic+PielouP'></span>

<h3>Description</h3>

<p>This function calculates Pielou's diversity index in a parallelized manner, 
allowing for improved performance on suitable hardware. The diversity index 
is computed using a moving window approach over the input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PielouP(x, window = 1, na.tolerance = 1, debugging = FALSE, np)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PielouP_+3A_x">x</code></td>
<td>
<p>Input raster data, representing the environmental variable(s) 
over which the diversity index should be calculated.</p>
</td></tr>
<tr><td><code id="PielouP_+3A_window">window</code></td>
<td>
<p>The size of the half-side of the square moving window used in the 
calculation. This determines the scale at which diversity is assessed.</p>
</td></tr>
<tr><td><code id="PielouP_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>A numeric value (between 0.0 and 1.0) indicating the 
proportion of NA values that are acceptable in each moving window over the 
raster data. If the proportion of NA values in a window exceeds this 
threshold, the resulting value for that window is set as NA. The default 
is 0.0, indicating no tolerance for NA values.</p>
</td></tr>
<tr><td><code id="PielouP_+3A_debugging">debugging</code></td>
<td>
<p>Boolean flag indicating whether additional console
output should be generated for debugging purposes. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="PielouP_+3A_np">np</code></td>
<td>
<p>The number of processes (cores) which will be spawned. Default value is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or list of matrices, depending on the input, containing 
the calculated Pielou diversity index values. Each cell in the output 
matrix represents the diversity index calculated from the corresponding 
moving window of the input data.
</p>


<h3>Author(s)</h3>

<p>Marcantonio Matteo <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>, 
Martina Iannacito <a href="mailto:martina.iannacito@inria.fr">martina.iannacito@inria.fr</a>, 
Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pielou">Pielou</a></code> for the non-parallelized version of the 
Pielou's diversity index calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Demonstration of function with hypothetical data
# Ensure you replace this with actual raster data
demo_raster &lt;- #... (your raster data here)
result &lt;- PielouP(x = demo_raster, win = 3, na.tolerance = 0.1, debugging = FALSE)
# proceed with analyzing 'result'

## End(Not run)
</code></pre>

<hr>
<h2 id='PielouS'>Sequential Pielou's diversity index</h2><span id='topic+PielouS'></span>

<h3>Description</h3>

<p>Computes Pielou's diversity index using a sequential method, particularly useful 
for handling large datasets that might not be efficiently processed in a 
standard, non-sequential manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PielouS(x, window = 1, na.tolerance = 1, debugging = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PielouS_+3A_x">x</code></td>
<td>
<p>Input raster data, representing the environmental variable(s) 
over which the diversity index should be calculated.</p>
</td></tr>
<tr><td><code id="PielouS_+3A_window">window</code></td>
<td>
<p>The size of the half-side of the square moving window used in the 
calculation. This determines the scale at which diversity is assessed.</p>
</td></tr>
<tr><td><code id="PielouS_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>A numeric value (between 0.0 and 1.0) indicating the 
proportion of NA values that are acceptable in each moving window over the 
raster data. If the proportion of NA values in a window exceeds this 
threshold, the resulting value for that window is set as NA. The default 
is 0.0, indicating no tolerance for NA values.</p>
</td></tr>
<tr><td><code id="PielouS_+3A_debugging">debugging</code></td>
<td>
<p>Boolean flag indicating whether additional console 
output should be generated for debugging purposes. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or list of matrices, depending on the input, containing 
the calculated Pielou diversity index values. Each cell in the output 
matrix represents the diversity index calculated from the corresponding 
moving window of the input data.
</p>


<h3>Author(s)</h3>

<p>Marcantonio Matteo <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>, 
Martina Iannacito <a href="mailto:martina.iannacito@inria.fr">martina.iannacito@inria.fr</a>, 
Duccio Rocchini <a href="mailto:duccio.rocchini@unibo.it">duccio.rocchini@unibo.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pielou">Pielou</a></code> for the standard computation of Pielou's 
diversity index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Demonstration of function with hypothetical data
# Ensure you replace this with actual raster data
demo_raster &lt;- #... (your raster data here)
result &lt;- PielouS(x = demo_raster, win = 3, na.tolerance = 0.1, debugging = FALSE)
# proceed with analyzing 'result'

## End(Not run)
</code></pre>

<hr>
<h2 id='process_raster_result'>Process Raster Results</h2><span id='topic+process_raster_result'></span>

<h3>Description</h3>

<p>This function processes the results of a list of calculations, packaging them into SpatRaster objects and naming them appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_raster_result(out, x, alpha, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_raster_result_+3A_out">out</code></td>
<td>
<p>A list containing the results of calculations that need to be transformed into SpatRaster objects. Each element in the list corresponds to a different calculation result.</p>
</td></tr>
<tr><td><code id="process_raster_result_+3A_x">x</code></td>
<td>
<p>A list of SpatRaster objects or a similar object used as a template for creating new SpatRaster objects. Specifically, 'x[[1]]' is used as the template.</p>
</td></tr>
<tr><td><code id="process_raster_result_+3A_alpha">alpha</code></td>
<td>
<p>Numeric or numeric vector indicating the weight(s) used in the distance calculations that generated 'out'. It is used to label the results appropriately.</p>
</td></tr>
<tr><td><code id="process_raster_result_+3A_window">window</code></td>
<td>
<p>Numeric or numeric vector indicating the size(s) of the moving window(s) used in the calculations that generated 'out'. It is used to label the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is designed to post-process the results of spatial calculations performed on raster data. The typical use case is to process results from a function that performs calculations on different 'windows' of the data, using varying 'alpha' parameters, and returns the results as a list. This function takes that list, converts each element to a SpatRaster (using the first SpatRaster in 'x' as a template), and assigns appropriate names to each based on the 'alpha' and 'window' parameters.
</p>


<h3>Value</h3>

<p>A list of SpatRaster objects corresponding to the different processed results. Each SpatRaster is named based on the 'alpha' and 'window' parameters used in the calculation. The naming convention is 'alpha.&lt;alpha value&gt;' for the inner lists and 'window.&lt;window size&gt;' for the outer list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Assume 'result_list' is obtained from a previous calculation, containing
# multiple results to be converted to SpatRaster objects.
# 'raster_template' is a list of SpatRaster objects used as templates.

processed_results &lt;- process_raster_result(out = result_list, 
                                           x = raster_template, 
                                           alpha = c(1, 2), 
                                           window = c(3, 5))

## End(Not run)

</code></pre>

<hr>
<h2 id='RaoAUC'>Accumulation function for parametric Rao's index of quadratic entropy (Q)</h2><span id='topic+RaoAUC'></span>

<h3>Description</h3>

<p>RaoAUC computes the accumulation function (integral or area under the curve) 
of the parametric version of Rao's index of quadratic entropy (Q) on different 
classes of numeric matrices using a moving window algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RaoAUC(
  alphas = 1:5,
  x,
  dist_m = "euclidean",
  window = 9,
  method = "classic",
  rasterAUC = TRUE,
  lambda = 0,
  na.tolerance = 1,
  rescale = FALSE,
  diag = TRUE,
  simplify = 0,
  np = 1,
  cluster.type = "SOCK",
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RaoAUC_+3A_alphas">alphas</code></td>
<td>
<p>A continuous vector of alphas in the form start:end over which integrated the parametric Rao's index. 
Default value is 1:5.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_x">x</code></td>
<td>
<p>Input data may be a matrix, a Spatial Grid Data Frame, a SpatRaster, or a list of these objects. 
In the latter case, if <code>method="classic"</code> only the first element of the list will be considered.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_dist_m">dist_m</code></td>
<td>
<p>Define the type of distance to be calculated between numerical categories. <code>dist_m</code> can be 
a character string which defines the name of the distance to derive such as &quot;euclidean&quot;. 
The distance names allowed are the same as for <code>proxy::dist</code>. Alternatively, <code>dist_m</code> can be 
a function which calculates a user-defined distance, (i.e., <code>function(x,y) {return(cos(y-x)-sin(y-x))}</code>) 
or a matrix of distances. If <code>method="multidimension"</code> then only &quot;euclidean&quot;, &quot;manhattan&quot;, 
&quot;canberra&quot;, &quot;minkowski&quot; and &quot;mahalanobis&quot; can be used. Default value is &quot;euclidean&quot;.
If <code>proxy::dist</code> is a matrix then the function will assume that this is the distance matrix, 
and therefore no distance will be derived.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_window">window</code></td>
<td>
<p>The side of the square moving window, it must be an odd numeric value greater than 1 to ensure that the target pixel is in the centre of the moving window. Default value is 3.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_method">method</code></td>
<td>
<p>Currently, there are two ways to calculate the parametric version of Rao's index. 
If <code>method="classic"</code>, then the normal parametric Rao's index will be calculated on a single matrix. 
If <code>method="multidimension"</code> (experimental!) a list of matrices must be provided as input. 
In the latter case, the overall distance matrix will be calculated in a multi- or hyper-dimensional system 
by using the distance measure defined through the function argument <code>dist_m</code>. 
Each pairwise distance is then multiplied by the inverse of the squared number of pixels in the considered 
moving window, and the Rao's Q is finally derived by applying a summation. Default value is <em>&quot;classic&quot;</em>.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_rasterauc">rasterAUC</code></td>
<td>
<p>Boolean, if TRUE the output will be a SpatRaster object with <em>x</em> as a raster template.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_lambda">lambda</code></td>
<td>
<p>The value of the lambda of Minkowski's distance. Considered only if <code>dist_m = "minkowski"</code> 
and <code>method="multidimension"</code>. Default value is 0.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>Numeric value <code class="reqn">(0.0-1.0)</code> which indicates the proportion of NA values that will be 
tolerated to calculate parametric Rao's index in each moving window over <em>x</em>. 
If the relative proportion of NA's in a moving window is bigger than na.tolerance, 
then the value of the window will be set as NA, otherwise Rao's index will be calculated 
considering the non-NA values. Default values are 1.0 (i.e., no tolerance for NA's). Default value is 1.0.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_rescale">rescale</code></td>
<td>
<p>Boolean. Considered only if <code>method="multidimension"</code>. If TRUE, each element of <code>x</code> 
is rescaled and centred.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_diag">diag</code></td>
<td>
<p>Boolean. If TRUE then the diagonal of the distance matrix is filled with 0's, otherwise with NA's. 
If <code>diag=TRUE</code> and <code>alpha=0</code>, the output matrix will inexorably be composed of 0's.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_simplify">simplify</code></td>
<td>
<p>Number of decimal places to be retained to calculate distances in Rao's index. Only if <em>x</em> is floats.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_np">np</code></td>
<td>
<p>The number of processes (cores) which will be spawned. Default value is 2.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_cluster.type">cluster.type</code></td>
<td>
<p>The type of cluster which will be created. The options are <em>&quot;MPI&quot;</em> (which calls &quot;makeMPIcluster&quot;), 
<em>&quot;FORK&quot;</em> (which calls &quot;makeForkCluster&quot;), and <em>&quot;SOCK&quot;</em> (which calls &quot;makeCluster&quot;). Default type is <em>&quot;SOCK&quot;</em>.</p>
</td></tr>
<tr><td><code id="RaoAUC_+3A_debugging">debugging</code></td>
<td>
<p>A boolean variable set to FALSE by default. If TRUE, additional messages will be printed. 
For debugging only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The accumulation function for the parametric Rao's Index (<code class="reqn">Q</code>) is calculated integrating numerically 
over a range of alphas. *RaoAUC* is therefore equal to <code class="reqn">(\int_{a}^{b} {1\over{N^4}}\cdot{d_{i,j}^{\alpha}})^{1\over{\alpha}} dx</code>. 
Where <em>N</em> is the number of pixels in a moving window, and <em>alpha</em> is a weight assigned to distances.
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>dim(x)</code>. If <code>rasterAUC=TRUE</code>, then the output is a SpatRaster with <em>x</em> as a template.
</p>


<h3>Author(s)</h3>

<p>Matteo Marcantonio <a href="mailto:marcantoniomatteo@gmail.com">marcantoniomatteo@gmail.com</a>
</p>


<h3>References</h3>

<p>Rocchini, D., M. Marcantonio, and C. Ricotta (2017). Measuring Rao’s Q diversity index from remote sensing: 
An open source solution. Ecological Indicators. 72: 234–238.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paRao">paRao</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Minimal example; RaoAUC with alphas ranging from 1 to 10
a &lt;- matrix(c(10,10,10,20,20,20,20,30,30), ncol=3, nrow=3)
out &lt;- RaoAUC(alphas=1:10, x=a, window=3, dist_m="euclidean", na.tolerance=1, rasterAUC=TRUE)

</code></pre>

<hr>
<h2 id='Renyi'>Renyi Diversity Index Calculation</h2><span id='topic+Renyi'></span>

<h3>Description</h3>

<p>Computes Renyi diversity index for a given raster object. This function allows
specifying window size, alpha values, and various other parameters for 
the calculation of the Renyi index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Renyi(
  x,
  window = 3,
  alpha = 1,
  base = exp(1),
  rasterOut = TRUE,
  np = 1,
  na.tolerance = 1,
  cluster.type = "SOCK",
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Renyi_+3A_x">x</code></td>
<td>
<p>A raster object which can be a matrix, SpatialGridDataFrame, SpatRaster, list, or RasterStack.</p>
</td></tr>
<tr><td><code id="Renyi_+3A_window">window</code></td>
<td>
<p>The size of the moving window; must be an odd integer.</p>
</td></tr>
<tr><td><code id="Renyi_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector of alpha values for the Renyi index.</p>
</td></tr>
<tr><td><code id="Renyi_+3A_base">base</code></td>
<td>
<p>The logarithm base for the calculation, default is natural logarithm.</p>
</td></tr>
<tr><td><code id="Renyi_+3A_rasterout">rasterOut</code></td>
<td>
<p>Logical; if TRUE, returns a SpatRaster object, otherwise returns a list.</p>
</td></tr>
<tr><td><code id="Renyi_+3A_np">np</code></td>
<td>
<p>Number of processes for parallel computation.</p>
</td></tr>
<tr><td><code id="Renyi_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>Tolerance level for NA values, must be within [0-1].</p>
</td></tr>
<tr><td><code id="Renyi_+3A_cluster.type">cluster.type</code></td>
<td>
<p>Type of cluster for parallel computation, either &quot;SOCK&quot; or &quot;MPI&quot;.</p>
</td></tr>
<tr><td><code id="Renyi_+3A_debugging">debugging</code></td>
<td>
<p>Logical; if TRUE, provides additional console output for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object or a list of calculated Renyi indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
result &lt;- Renyi(ndvi.8bit, window = 3, alpha = c(0, 1, 2))

## End(Not run)

</code></pre>

<hr>
<h2 id='RenyiP'>Parallel Computation of Renyi's Diversity Index</h2><span id='topic+RenyiP'></span>

<h3>Description</h3>

<p>This function computes Renyi's diversity index for each cell of a matrix, 
using a parallelized approach and considering a specified moving window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RenyiP(
  x,
  window = 1,
  alpha = 1,
  base = exp(1),
  na.tolerance = 1,
  debugging = FALSE,
  np = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RenyiP_+3A_x">x</code></td>
<td>
<p>A numeric matrix representing the data on which the index is to be calculated.</p>
</td></tr>
<tr><td><code id="RenyiP_+3A_window">window</code></td>
<td>
<p>The width of the moving window to consider for each cell. 
The actual window size will be '(2 * window + 1) x (2 * window + 1)'. Default is 1.</p>
</td></tr>
<tr><td><code id="RenyiP_+3A_alpha">alpha</code></td>
<td>
<p>The alpha parameter for Renyi's index, influencing sensitivity 
to species abundance. Default is 1.</p>
</td></tr>
<tr><td><code id="RenyiP_+3A_base">base</code></td>
<td>
<p>The base of the logarithm used in Renyi's formula. Default is 'exp(1)' 
(natural logarithm).</p>
</td></tr>
<tr><td><code id="RenyiP_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>The tolerance level for missing data within the moving window. 
A window will be processed only if the proportion of non-missing data is above this threshold. 
Value should be between 0 and 1. Default is 1.</p>
</td></tr>
<tr><td><code id="RenyiP_+3A_debugging">debugging</code></td>
<td>
<p>Boolean flag to enable or disable debugging messages. Default is FALSE.</p>
</td></tr>
<tr><td><code id="RenyiP_+3A_np">np</code></td>
<td>
<p>Number of processes for parallel computation.#'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimensions as 'x', where each cell contains the 
Renyi's diversity index calculated for the window around the cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(runif(100), nrow = 10)
renyi_index &lt;- RenyiP(data, window = 1, np = 1)

</code></pre>

<hr>
<h2 id='RenyiS'>Sequential Renyi's diversity index</h2><span id='topic+RenyiS'></span>

<h3>Description</h3>

<p>This function calculates the Renyi's diversity index index for each cell in a matrix,
considering a specified moving window around each cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RenyiS(
  x,
  window = 1,
  alpha = 1,
  base = exp(1),
  na.tolerance = 1,
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RenyiS_+3A_x">x</code></td>
<td>
<p>A numeric matrix representing the data on which the index is to be calculated.</p>
</td></tr>
<tr><td><code id="RenyiS_+3A_window">window</code></td>
<td>
<p>The width of the moving window to consider for each cell. The actual window size 
will be '(2 * window + 1) x (2 * window + 1)'. Default is 1.</p>
</td></tr>
<tr><td><code id="RenyiS_+3A_alpha">alpha</code></td>
<td>
<p>(Not used in this function, included for compatibility) The alpha parameter for 
diversity indices, default is 1.</p>
</td></tr>
<tr><td><code id="RenyiS_+3A_base">base</code></td>
<td>
<p>The base of the logarithm used in the Shannon formula, default is 'exp(1)' (natural logarithm).</p>
</td></tr>
<tr><td><code id="RenyiS_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>The tolerance level for missing data within the moving window. 
A window will be processed only if the proportion of non-missing data is above this threshold. 
Value should be between 0 and 1. Default is 1.</p>
</td></tr>
<tr><td><code id="RenyiS_+3A_debugging">debugging</code></td>
<td>
<p>Boolean flag to enable or disable debugging messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Berger-Parker's diversity index calculated sequentially over a raster matrix.
</p>


<h3>Value</h3>

<p>A matrix of the same dimensions as 'x', where each cell contains the 
Renyi's diversity index calculated for the window around the cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(runif(100), nrow = 10)
renyi_index &lt;- RenyiS(data, window = 1)

</code></pre>

<hr>
<h2 id='Shannon'>Shannon's Evenness Index</h2><span id='topic+Shannon'></span>

<h3>Description</h3>

<p>Calculates Shannon's Evenness Index for a given raster object over a specified window size. The function can operate in either sequential or parallel mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Shannon(
  x,
  window = 3,
  rasterOut = TRUE,
  np = 1,
  na.tolerance = 1,
  cluster.type = "SOCK",
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Shannon_+3A_x">x</code></td>
<td>
<p>A raster object (matrix, SpatRaster, SpatialGridDataFrame, or a list containing one of these).</p>
</td></tr>
<tr><td><code id="Shannon_+3A_window">window</code></td>
<td>
<p>The size of the moving window to be used for the calculation. Must be an odd integer.</p>
</td></tr>
<tr><td><code id="Shannon_+3A_rasterout">rasterOut</code></td>
<td>
<p>Logical, if TRUE the output will be a raster object; if FALSE a matrix.</p>
</td></tr>
<tr><td><code id="Shannon_+3A_np">np</code></td>
<td>
<p>The number of processes to use in parallel mode. If np &gt; 1, parallel computation is enabled.</p>
</td></tr>
<tr><td><code id="Shannon_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>The tolerance level for NA values within the moving window, expressed as a proportion (0 to 1).</p>
</td></tr>
<tr><td><code id="Shannon_+3A_cluster.type">cluster.type</code></td>
<td>
<p>The type of cluster to use for parallel computation (e.g., &quot;SOCK&quot;, &quot;FORK&quot;).</p>
</td></tr>
<tr><td><code id="Shannon_+3A_debugging">debugging</code></td>
<td>
<p>Logical, if TRUE debugging information will be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a raster object or matrix containing the Shannon's Evenness Index values.
</p>

<hr>
<h2 id='ShannonP'>Calculate Shannon-Wiener Index on a Matrix</h2><span id='topic+ShannonP'></span>

<h3>Description</h3>

<p>This function computes Shannon-Wiener Index for each cell of a matrix, 
using a parallelized approach and considering a specified moving window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShannonP(x, window = 1, na.tolerance = 1, debugging = FALSE, np = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShannonP_+3A_x">x</code></td>
<td>
<p>A numeric matrix representing the data on which the index is to abe calculated.</p>
</td></tr>
<tr><td><code id="ShannonP_+3A_window">window</code></td>
<td>
<p>The width of the moving window to consider for each cell. 
The actual window size will be '(2 * window + 1) x (2 * window + 1)'. Default is 1.</p>
</td></tr>
<tr><td><code id="ShannonP_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>The tolerance level for missing data within the moving window. 
A window will be processed only if the proportion of non-missing data is above this threshold. 
Value should be between 0 and 1. Default is 1.</p>
</td></tr>
<tr><td><code id="ShannonP_+3A_debugging">debugging</code></td>
<td>
<p>Boolean flag to enable or disable debugging messages. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ShannonP_+3A_np">np</code></td>
<td>
<p>Number of processes for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimensions as 'x', where each cell contains the 
Shannon-Wiener Index calculated for the window around the cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(runif(100), nrow = 10)
shannon_index &lt;- ShannonP(data, window = 1, np = 1 )

</code></pre>

<hr>
<h2 id='ShannonS'>Calculate Shannon-Wiener Index on a Matrix</h2><span id='topic+ShannonS'></span>

<h3>Description</h3>

<p>This function calculates the Shannon-Wiener Index for each cell in a matrix,
considering a specified moving window around each cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShannonS(x, window = 1, na.tolerance = 1, debugging = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShannonS_+3A_x">x</code></td>
<td>
<p>A numeric matrix representing the data on which the index is to be calculated.</p>
</td></tr>
<tr><td><code id="ShannonS_+3A_window">window</code></td>
<td>
<p>The width of the moving window to consider for each cell. The actual window size 
will be '(2 * window + 1) x (2 * window + 1)'. Default is 1.</p>
</td></tr>
<tr><td><code id="ShannonS_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>The tolerance level for missing data within the moving window. 
A window will be processed only if the proportion of non-missing data is above this threshold. 
Value should be between 0 and 1. Default is 1.</p>
</td></tr>
<tr><td><code id="ShannonS_+3A_debugging">debugging</code></td>
<td>
<p>Boolean flag to enable or disable debugging messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimensions as 'x', where each cell contains the 
Shannon-Wiener Index calculated for the window around the cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(runif(100), nrow = 10)
shannon_index &lt;- ShannonS(data, window = 1)

</code></pre>

<hr>
<h2 id='validateInputs'>Validate Input Parameters for Diversity Index Calculation</h2><span id='topic+validateInputs'></span>

<h3>Description</h3>

<p>Validates the input parameters for diversity index calculation functions. Checks for valid raster types, window sizes, alpha values, and NA tolerance levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateInputs(x, window, alpha = 1, na.tolerance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateInputs_+3A_x">x</code></td>
<td>
<p>Raster object to be validated.</p>
</td></tr>
<tr><td><code id="validateInputs_+3A_window">window</code></td>
<td>
<p>Size of the moving window for calculations.</p>
</td></tr>
<tr><td><code id="validateInputs_+3A_alpha">alpha</code></td>
<td>
<p>Diversity index parameter, default is 1.</p>
</td></tr>
<tr><td><code id="validateInputs_+3A_na.tolerance">na.tolerance</code></td>
<td>
<p>Proportion of acceptable NA values within the window (range: 0 to 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Throws an error if any input is invalid.
</p>

<hr>
<h2 id='world'>Natural Earth world dataset</h2><span id='topic+world'></span>

<h3>Description</h3>

<p>A <code>SpatVector</code> (EPSG: 4326) of the continents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_world()
</code></pre>


<h3>Format</h3>

<p>A <code>SpatVector</code> containing the following columns:
</p>

<dl>
<dt>world</dt><dd><p>SpatVector of the world dissolved on continents. Details about columns should be listed here if applicable.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset represents the world, with spatial information dissolved on continents.
It is stored as a <code>SpatVector</code>, suitable for various spatial operations and mapping.
</p>


<h3>Source</h3>

<p><a href="https://www.naturalearthdata.com/">https://www.naturalearthdata.com/</a>
</p>


<h3>References</h3>

<p><a href="https://www.naturalearthdata.com/">https://www.naturalearthdata.com/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>world &lt;- readRDS(system.file("extdata", "world.rds", package = "rasterdiv"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
