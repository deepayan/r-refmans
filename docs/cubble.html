<!DOCTYPE html><html><head><title>Help for package cubble</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cubble}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cubble-package'><p>cubble: A Vector Spatio-Temporal Data Structure for Data Analysis</p></a></li>
<li><a href='#[.spatial_cubble_df'><p>Accessors to a cubble object</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#arrange.temporal_cubble_df'><p><code>dplyr</code> methods</p></a></li>
<li><a href='#as_cubble'><p>Coerce foreign objects into a cubble object</p></a></li>
<li><a href='#check_key'><p>Check on key when create cubble from two components (spatial/temporal)</p></a></li>
<li><a href='#climate_aus'><p>Australia climate data</p></a></li>
<li><a href='#covid'><p>Daily COVID count data (in <code>tsibble</code>) and Victoria LGA (in <code>sf</code>)</p></a></li>
<li><a href='#cubble'><p>Create a cubble object</p></a></li>
<li><a href='#extract_var'><p>Functions to extract NetCDF dimension and variables</p></a></li>
<li><a href='#face_temporal'><p>Pivot a cubble object between the nested/long (spatial/temporal) form</p></a></li>
<li><a href='#fill_gaps.temporal_cubble_df'><p>Gap-filling on the temporal component of a cubble object</p></a></li>
<li><a href='#geom_glyph'><p>Create glyph map with ggplot2</p></a></li>
<li><a href='#is_cubble'><p>Predicate functions on the object class</p></a></li>
<li><a href='#key_vars.cubble_df'><p>Extract cubble attributes</p></a></li>
<li><a href='#make_spatial_sf'><p>Update the spatial cubble to include the sf class</p></a></li>
<li><a href='#make_temporal_tsibble'><p>Update the temporal cubble to include the tsibble class (<code>tbl_ts</code>)</p></a></li>
<li><a href='#match_sites'><p>Match stations in two cubbles by spatial distance/ temporal similarity</p></a></li>
<li><a href='#print.cubble_df'><p>Print methods</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#river'><p>Australia river data</p></a></li>
<li><a href='#stations'><p>Toy climate data</p></a></li>
<li><a href='#unfold'><p>Augment spatial component into the long (temporal) form</p></a></li>
<li><a href='#update_cubble'><p>Temporary update cubble if the sf class take precedent of cubble classes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Vector Spatio-Temporal Data Structure for Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A spatiotemperal data object in a relational data structure to separate the recording of time variant/ invariant variables.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, ggplot2, glue, lubridate, ncdf4, rlang, sf,
stringr, tibble, tidyr, tidyselect, tsibble, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, rmarkdown, knitr, testthat (&ge; 3.0.0), ozmaps,
GGally, ggrepel, ggforce, purrr, stars, units, leaflet, plotly,
crosstalk, concaveman, colorspace, vdiffr, sftime, patchwork</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/huizezhang-sherry/cubble">https://github.com/huizezhang-sherry/cubble</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/huizezhang-sherry/cubble/issues">https://github.com/huizezhang-sherry/cubble/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-30 01:18:30 UTC; hzha400</td>
</tr>
<tr>
<td>Author:</td>
<td>H. Sherry Zhang <a href="https://orcid.org/0000-0002-7122-1463"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Dianne Cook <a href="https://orcid.org/0000-0002-3813-7155"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Ursula Laa <a href="https://orcid.org/0000-0002-0249-6439"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Nicolas Langrené <a href="https://orcid.org/0000-0001-7601-4618"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Patricia Menéndez <a href="https://orcid.org/0000-0003-0701-6315"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>H. Sherry Zhang &lt;huize.zhang@monash.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-30 03:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cubble-package'>cubble: A Vector Spatio-Temporal Data Structure for Data Analysis</h2><span id='topic+cubble-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A spatiotemperal data object in a relational data structure to separate the recording of time variant/ invariant variables.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: H. Sherry Zhang <a href="mailto:huize.zhang@monash.edu">huize.zhang@monash.edu</a> (<a href="https://orcid.org/0000-0002-7122-1463">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Dianne Cook <a href="mailto:dicook@monash.edu">dicook@monash.edu</a> (<a href="https://orcid.org/0000-0002-3813-7155">ORCID</a>)
</p>
</li>
<li><p> Ursula Laa <a href="mailto:ursula.laa@boku.ac.at">ursula.laa@boku.ac.at</a> (<a href="https://orcid.org/0000-0002-0249-6439">ORCID</a>)
</p>
</li>
<li><p> Nicolas Langrené <a href="mailto:nicolas.langrene@csiro.au">nicolas.langrene@csiro.au</a> (<a href="https://orcid.org/0000-0001-7601-4618">ORCID</a>)
</p>
</li>
<li><p> Patricia Menéndez <a href="mailto:patricia.menendez@monash.edu">patricia.menendez@monash.edu</a> (<a href="https://orcid.org/0000-0003-0701-6315">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/huizezhang-sherry/cubble">https://github.com/huizezhang-sherry/cubble</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/huizezhang-sherry/cubble/issues">https://github.com/huizezhang-sherry/cubble/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.spatial_cubble_df'>Accessors to a cubble object</h2><span id='topic++5B.spatial_cubble_df'></span><span id='topic++5B.temporal_cubble_df'></span><span id='topic+names+3C-.spatial_cubble_df'></span><span id='topic+names+3C-.temporal_cubble_df'></span><span id='topic++5B+5B+3C-.cubble_df'></span>

<h3>Description</h3>

<p>Accessors to a cubble object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatial_cubble_df'
data[i, j, drop = FALSE]

## S3 method for class 'temporal_cubble_df'
data[i, j, drop = FALSE]

## S3 replacement method for class 'spatial_cubble_df'
names(x) &lt;- value

## S3 replacement method for class 'temporal_cubble_df'
names(x) &lt;- value

## S3 replacement method for class 'cubble_df'
x[[i]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.spatial_cubble_df_+3A_data">data</code></td>
<td>
<p>an object of class <code>spatial_cubble_df</code> or
<code>temporal_cubble_df</code></p>
</td></tr>
<tr><td><code id="+2B5B.spatial_cubble_df_+3A_i">i</code>, <code id="+2B5B.spatial_cubble_df_+3A_j">j</code></td>
<td>
<p>row and column selector</p>
</td></tr>
<tr><td><code id="+2B5B.spatial_cubble_df_+3A_drop">drop</code></td>
<td>
<p>logical.  If <code>TRUE</code> the result is coerced to the
lowest possible dimension.  The default is to drop if only one
column is left, but <b>not</b> to drop if only one row is left.</p>
</td></tr>
<tr><td><code id="+2B5B.spatial_cubble_df_+3A_x">x</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="+2B5B.spatial_cubble_df_+3A_value">value</code></td>
<td>
<p>A suitable replacement value: it will be repeated a whole
number of times if necessary and it may be coerced: see the
Coercion section.  If <code>NULL</code>, deletes the column if a single
column is selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For nested cubbles, <code>[</code> will return a cubble object if the <code>key</code>
variable, the<code>coords</code> variables, and the <code>ts</code> column all present.
If the cubble object is also an sf object, the sticky select behavior on
the sf column will preserve. For long cubbles, <code>[</code> will return a cubble
object if the <code>key</code> and <code>index</code> variable both present.
When a cubble can't be created and the data is not an sf class,
<code>[</code> will always return a tibble, even with single index selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>climate_mel[c(1:3, 7)] # a nested cubble
make_spatial_sf(climate_mel)[1:3] # an sf

long &lt;- climate_mel %&gt;% face_temporal()
long[1:3] # a long cubble

climate_mel[1:3] # tibble
long[2:5] # tibble
climate_mel[1] # still tibble
long[1] # and still tibble
</code></pre>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='arrange.temporal_cubble_df'><code>dplyr</code> methods</h2><span id='topic+arrange.temporal_cubble_df'></span><span id='topic+select.spatial_cubble_df'></span><span id='topic+select.temporal_cubble_df'></span><span id='topic+group_by.spatial_cubble_df'></span><span id='topic+group_by.temporal_cubble_df'></span><span id='topic+ungroup.spatial_cubble_df'></span><span id='topic+ungroup.temporal_cubble_df'></span><span id='topic+summarise.spatial_cubble_df'></span><span id='topic+summarise.temporal_cubble_df'></span><span id='topic+rename.spatial_cubble_df'></span><span id='topic+rename.temporal_cubble_df'></span><span id='topic+bind_rows.temporal_cubble_df'></span><span id='topic+bind_cols.spatial_cubble_df'></span><span id='topic+bind_cols.temporal_cubble_df'></span><span id='topic+rowwise.spatial_cubble_df'></span><span id='topic+rowwise.temporal_cubble_df'></span><span id='topic+dplyr_col_modify.cubble_df'></span><span id='topic+dplyr_row_slice.spatial_cubble_df'></span><span id='topic+dplyr_row_slice.temporal_cubble_df'></span><span id='topic+dplyr_reconstruct.spatial_cubble_df'></span><span id='topic+dplyr_reconstruct.temporal_cubble_df'></span><span id='topic+mutate.spatial_cubble_df'></span><span id='topic+filter.spatial_cubble_df'></span><span id='topic+arrange.spatial_cubble_df'></span>

<h3>Description</h3>

<p>Verbs supported for both nested and long cubble include:
<code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>,  <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>,
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>, <code><a href="dplyr.html#topic+group_by">dplyr::ungroup()</a></code>, <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code>,.
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code>, <code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>, <code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code>,
<code>dplyr::slice_*()</code>, <code>dplyr::*_join()</code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>,
<code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'temporal_cubble_df'
arrange(.data, ...)

## S3 method for class 'spatial_cubble_df'
select(.data, ...)

## S3 method for class 'temporal_cubble_df'
select(.data, ...)

## S3 method for class 'spatial_cubble_df'
group_by(.data, ..., .add, .drop)

## S3 method for class 'temporal_cubble_df'
group_by(.data, ..., .add, .drop)

## S3 method for class 'spatial_cubble_df'
ungroup(x, ...)

## S3 method for class 'temporal_cubble_df'
ungroup(x, ...)

## S3 method for class 'spatial_cubble_df'
summarise(.data, ..., .by = NULL, .groups = NULL)

## S3 method for class 'temporal_cubble_df'
summarise(.data, ..., .by = key_vars(.data), .groups = NULL)

## S3 method for class 'spatial_cubble_df'
rename(.data, ...)

## S3 method for class 'temporal_cubble_df'
rename(.data, ...)

bind_rows.temporal_cubble_df(..., .id = NULL)

bind_cols.spatial_cubble_df(..., .name_repair)

bind_cols.temporal_cubble_df(..., .name_repair)

## S3 method for class 'spatial_cubble_df'
rowwise(data, ...)

## S3 method for class 'temporal_cubble_df'
rowwise(data, ...)

## S3 method for class 'cubble_df'
dplyr_col_modify(data, cols)

## S3 method for class 'spatial_cubble_df'
dplyr_row_slice(data, i, ...)

## S3 method for class 'temporal_cubble_df'
dplyr_row_slice(data, i, ...)

## S3 method for class 'spatial_cubble_df'
dplyr_reconstruct(data, template)

## S3 method for class 'temporal_cubble_df'
dplyr_reconstruct(data, template)

## S3 method for class 'spatial_cubble_df'
mutate(.data, ...)

## S3 method for class 'spatial_cubble_df'
filter(.data, ...)

## S3 method for class 'spatial_cubble_df'
arrange(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange.temporal_cubble_df_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_.add">.add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_x">x</code></td>
<td>
<p>A <code><a href="dplyr.html#topic+tbl">tbl()</a></code></p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_.groups">.groups</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Grouping structure of the
result.
</p>

<ul>
<li><p> &quot;drop_last&quot;: dropping the last level of grouping. This was the
only supported option before version 1.0.0.
</p>
</li>
<li><p> &quot;drop&quot;: All levels of grouping are dropped.
</p>
</li>
<li><p> &quot;keep&quot;: Same grouping structure as <code>.data</code>.
</p>
</li>
<li><p> &quot;rowwise&quot;: Each row is its own group.
</p>
</li></ul>

<p>When <code>.groups</code> is not specified, it is chosen
based on the number of rows of the results:
</p>

<ul>
<li><p> If all the results have 1 row, you get &quot;drop_last&quot;.
</p>
</li>
<li><p> If the number of rows varies, you get &quot;keep&quot; (note that returning a
variable number of rows was deprecated in favor of <code><a href="dplyr.html#topic+reframe">reframe()</a></code>, which
also unconditionally drops all levels of grouping).
</p>
</li></ul>

<p>In addition, a message informs you of that choice, unless the result is ungrouped,
the option &quot;dplyr.summarise.inform&quot; is set to <code>FALSE</code>,
or when <code>summarise()</code> is called from a function in a package.</p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_.id">.id</code></td>
<td>
<p>The name of an optional identifier column. Provide a string to
create an output column that identifies each input. The column will use
names if available, otherwise it will use positions.</p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, or
<code>"check_unique"</code>. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for the meaning of these
options.</p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_data">data</code>, <code id="arrange.temporal_cubble_df_+3A_.data">.data</code></td>
<td>
<p>a cubble object of class <code>spatial_cubble_df</code> or
<code>temporal_cubble_df</code></p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_cols">cols</code></td>
<td>
<p>A named list used to modify columns. A <code>NULL</code> value should remove
an existing column.</p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_i">i</code></td>
<td>
<p>A numeric or logical vector that indexes the rows of <code>data</code>.</p>
</td></tr>
<tr><td><code id="arrange.temporal_cubble_df_+3A_template">template</code></td>
<td>
<p>Template data frame to use for restoring attributes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You may find not all the verbs have a <code>verb.spatial_cubble_df</code> or
<code>verb.temporal_cubble_df</code> implemented. These verbs call
the dplyr extending trios: <code>dplyr_row_slice</code>, <code>dplyr_col_modify</code>,
and <code>dplyr_reconstruct</code> under the hood.
See https://dplyr.tidyverse.org/reference/dplyr_extending.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
cb_nested &lt;- climate_mel
cb_long &lt;- face_temporal(climate_mel)

# filter - currently filter.spatial_cubble_df, dply_row_slice
cb_nested %&gt;% filter(elev &gt; 40)
cb_long %&gt;% filter(prcp &gt; 0)

# mutate - curerntly mutate.spatial_cubble_df, dply_col_modify
cb_nested %&gt;% mutate(elev2 = elev + 10)
cb_long %&gt;% mutate(prcp2 = prcp + 10)

# arrange - currently arrange.spatial_cubble_df, arrange.temporal_cubble_df
cb_nested %&gt;% arrange(wmo_id)
cb_long %&gt;% arrange(prcp)

# summarise - summarise.spatial_cubble_df,  summarise.temporal_cubble_df
cb_long %&gt;%
  group_by(first_5 = ifelse(lubridate::day(date) &lt;=5, 1, 2 )) %&gt;%
  summarise(tmax = mean(tmax))
cb_long %&gt;%
  mutate(first_5 = ifelse(lubridate::day(date) &lt;=5, 1, 2)) %&gt;%
  summarise(t = mean(tmax), .by = first_5)

# select -  select.spatial_cubble_df,  select.temporal_cubble_df
cb_nested %&gt;% select(name)
cb_nested %&gt;% select(-id, -name)
cb_long %&gt;% select(prcp)
cb_long %&gt;% select(-prcp, -date)

# rename - rename.spatial_cubble_df, rename.temporal_cubble_df
cb_nested %&gt;% rename(elev2 = elev)
cb_long %&gt;% rename(prcp2 = prcp)
# rename on key attributes
cb_nested %&gt;% rename(id2 = id)
cb_long %&gt;% rename(date2 = date)

# join - mutate_join - dplyr_reconstruct()
# join - filter_join - dplyr_row_slice()
df1 &lt;- cb_nested %&gt;% as_tibble() %&gt;% select(id, name) %&gt;% head(2)
nested &lt;- cb_nested %&gt;% select(-name)
nested %&gt;% left_join(df1, by = "id")
nested %&gt;% right_join(df1, by = "id")
nested %&gt;% inner_join(df1, by = "id")
nested %&gt;% full_join(df1, by = "id")
nested %&gt;% anti_join(df1, by = "id")

# bind_rows - dplyr_reconstruct, bind_rows.temporal_cubble_df
df1 &lt;- cb_nested %&gt;% head(1)
df2 &lt;- cb_nested %&gt;% tail(2)
bind_rows(df1, df2)
df1 &lt;- cb_long %&gt;% head(10)
df2 &lt;- cb_long %&gt;% tail(20)
bind_rows(df1, df2)

# relocate - dplyr_col_select, dplyr_col_select
cb_nested %&gt;% relocate(ts, .before = name)
cb_nested %&gt;% face_temporal() %&gt;% relocate(tmin)

# slice - all the slice_* uses dplyr::slice(), which uses dplyr_row_slice()
cb_nested %&gt;% slice_head(n = 2)
cb_nested %&gt;% slice_tail(n = 2)
cb_nested %&gt;% slice_max(elev)
cb_nested %&gt;% slice_min(elev)
cb_nested %&gt;% slice_sample(n = 2)

# rowwise - rowwise.spatial_cubble_df, rowwise.temporal_cuble_df
cb_nested %&gt;% rowwise()
cb_long %&gt;% rowwise()

# group_by &amp; ungroup -
(res &lt;- cb_nested %&gt;% mutate(group1 = c(1, 1, 2)) %&gt;% group_by(group1))
res %&gt;% ungroup()
(res2 &lt;- res %&gt;% face_temporal() %&gt;% unfold(group1) %&gt;% group_by(group1))
res2 %&gt;% ungroup()
res2 %&gt;% mutate(first_5 = ifelse(lubridate::day(date) &lt;= 5, 1, 6)) %&gt;%
  group_by(first_5) %&gt;%
  ungroup(group1)
</code></pre>

<hr>
<h2 id='as_cubble'>Coerce foreign objects into a cubble object</h2><span id='topic+as_cubble'></span><span id='topic+as_cubble.tbl_df'></span><span id='topic+as_cubble.sf'></span><span id='topic+as_cubble.ncdf4'></span><span id='topic+as_cubble.stars'></span><span id='topic+as_cubble.sftime'></span>

<h3>Description</h3>

<p>Coerce foreign objects into a cubble object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_cubble(data, key, index, coords, ...)

## S3 method for class 'tbl_df'
as_cubble(data, key, index, coords, ...)

## S3 method for class 'sf'
as_cubble(data, key, index, ...)

## S3 method for class 'ncdf4'
as_cubble(
  data,
  key,
  index,
  coords,
  vars,
  lat_range = NULL,
  long_range = NULL,
  ...
)

## S3 method for class 'stars'
as_cubble(data, key, index, coords, ...)

## S3 method for class 'sftime'
as_cubble(data, key, index, coords, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_cubble_+3A_data">data</code></td>
<td>
<p>an object to be converted into an cubble object. Currently
support objects of classes <code>tibble</code>, <code>ncdf4</code>, <code>stars</code>, and <code>sftime</code>.</p>
</td></tr>
<tr><td><code id="as_cubble_+3A_key">key</code></td>
<td>
<p>a character (symbol), the spatial identifier,
see <code><a href="#topic+make_cubble">make_cubble()</a></code></p>
</td></tr>
<tr><td><code id="as_cubble_+3A_index">index</code></td>
<td>
<p>a character (symbol), the temporal identifier,
see <code><a href="#topic+make_cubble">make_cubble()</a></code>.</p>
</td></tr>
<tr><td><code id="as_cubble_+3A_coords">coords</code></td>
<td>
<p>a vector of character (symbol) of length 2,
see <code><a href="#topic+make_cubble">make_cubble()</a></code>.</p>
</td></tr>
<tr><td><code id="as_cubble_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
<tr><td><code id="as_cubble_+3A_vars">vars</code></td>
<td>
<p>a vector of variables to read in (with quote),
used in <code>as_cubble.netcdf()</code>
to select the variable to read in.</p>
</td></tr>
<tr><td><code id="as_cubble_+3A_lat_range">lat_range</code>, <code id="as_cubble_+3A_long_range">long_range</code></td>
<td>
<p>in the syntax of <code>seq(FROM, TO, BY)</code>
to downsample
the data to read in <code>as_cubble.netcdf()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cubble object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>climate_flat %&gt;% as_cubble(key = id, index = date, coords = c(long, lat))

# only need `coords` if create from a tsibble
dt &lt;- climate_flat %&gt;%  tsibble::as_tsibble(key = id, index = date)
dt %&gt;%  as_cubble(coords = c(long, lat))

# netcdf
path &lt;- system.file("ncdf/era5-pressure.nc", package = "cubble")
raw &lt;- ncdf4::nc_open(path)
dt &lt;- as_cubble(raw)
# subset degree
dt &lt;- as_cubble(raw,vars = c("q", "z"),
                long_range = seq(113, 153, 3),
                lat_range = seq(-53, -12, 3))

## Not run: 
# stars - take a few seconds to run
tif &lt;- system.file("tif/L7_ETMs.tif", package = "stars")
x &lt;-  stars::read_stars(tif)
x %&gt;% as_cubble()

## End(Not run)

# don't have to supply coords if create from a sftime
dt &lt;- climate_flat %&gt;%
  sf::st_as_sf(coords = c("long", "lat"), crs = sf::st_crs("OGC:CRS84")) %&gt;%
  sftime::st_as_sftime()
dt %&gt;% as_cubble(key = id, index = date)
</code></pre>

<hr>
<h2 id='check_key'>Check on key when create cubble from two components (spatial/temporal)</h2><span id='topic+check_key'></span>

<h3>Description</h3>

<p>When creating a cubble from separate spatial and temporal component,
<code><a href="#topic+make_cubble">make_cubble()</a></code> will informed users about potential disagreement
of the key values in the two datasets (some sites appear in one table
but not the other). This function summarises the key values into those
match, potentially can be matched, and can't be matched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_key(spatial, temporal, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_key_+3A_spatial">spatial</code></td>
<td>
<p>a tibble object or an sf object, the spatial component
containing the <code>key</code> and <code>coords</code> variable (<code>coords</code> can be automatically
created from an <code>sf</code> object if not supplied).</p>
</td></tr>
<tr><td><code id="check_key_+3A_temporal">temporal</code></td>
<td>
<p>a tibble object or a tsibble object, the temporal component
containing the <code>key</code> and <code>index</code> variable.</p>
</td></tr>
<tr><td><code id="check_key_+3A_by">by</code></td>
<td>
<p>in the syntax of the <code>by</code> argument in <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>,
used in <code>make_cubble()</code> when the key variable has different names in the
<code>spatial</code> and <code>temporal</code> data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three elements: 1) paired: a tibble of paired ID from
spatial and temporal data, 2) potential_pairs: a tibble of pairs that could
potentially match from both datasets, 3) others: other key values that can't
be matched in a list: others$temporal and others$spatial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_key(stations, meteo)

# make_cubble() will prompt to use check_key if there are key mis-match:
make_cubble(spatial = lga, temporal = covid, by = c("lga_name_2018" = "lga"))
check_key(lga, covid, by = c("lga_name_2018" = "lga"))
</code></pre>

<hr>
<h2 id='climate_aus'>Australia climate data</h2><span id='topic+climate_aus'></span><span id='topic+historical_tmax'></span>

<h3>Description</h3>

<p><code>climate_aus</code>: daily measure on precipitation (<code>prcp</code>),
maximum temperature (<code>tmax</code>), and minimum temperature (<code>tmin</code>)
in 2020 for 639 stations. <code>historical_tmax</code>: daily maximum temperature
(<code>tmax</code>) for 75 stations in Victoria and New South Wales for two
periods: 1971-1975 and 2016-2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>climate_aus

historical_tmax
</code></pre>


<h3>Format</h3>

<p>An object of class <code>spatial_cubble_df</code> (inherits from <code>cubble_df</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 639 rows and 7 columns.
</p>
<p>An object of class <code>spatial_cubble_df</code> (inherits from <code>cubble_df</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 75 rows and 7 columns.
</p>


<h3>Details</h3>


<dl>
<dt>id</dt><dd><p>station ID, &quot;ASN000&quot; are international paddings, the next
two digits (digit 8-9) indicates the states the station is in:
Western Australia: 01-13, Northern Territory: 14-15, South Australia:
16-26, Queensland: 27-45, New South Wales: 46-75, Victoria: 76-90,
Tasmania: 91-99.
See http://www.bom.gov.au/climate/cdo/about/site-num.shtml</p>
</dd>
<dt>lat</dt><dd><p>latitude of the stations, in degree</p>
</dd>
<dt>long</dt><dd><p>longitude of the stations, in degree</p>
</dd>
<dt>elev</dt><dd><p>elevation of the stations</p>
</dd>
<dt>name</dt><dd><p>station name</p>
</dd>
<dt>wmo_id</dt><dd><p>the world meteorological organisation (WMO) station number</p>
</dd>
<dt>ts</dt><dd><p>For <code>climate_aus</code>: date, prcp, tmax, and tmin, for
<code>historical_tmax</code>: date and tmax</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>climate_aus %&gt;% face_temporal() %&gt;% face_spatial()
</code></pre>

<hr>
<h2 id='covid'>Daily COVID count data (in <code>tsibble</code>) and Victoria LGA (in <code>sf</code>)</h2><span id='topic+covid'></span><span id='topic+lga'></span>

<h3>Description</h3>

<p>Daily COVID count data (<code>covid</code>) from 2022-01-01 to 2020-03-23 in a
tsibble object (<code>date</code>, <code>lga</code>, <code>n</code>, and <code>avg_7day</code>).
Victoria Local Government Area (LGA) spatial geometry in an sf object
(<code>lga_name_2018</code> and <code>geometry</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covid

lga
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_ts</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 6806 rows and 4 columns.
</p>
<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 80 rows and 2 columns.
</p>


<h3>Details</h3>


<dl>
<dt>date</dt><dd><p>date object, from 2022-01-01 to 2020-03-23</p>
</dd>
<dt>lga</dt><dd><p>Victoria Local Government Area (LGA) in Australia</p>
</dd>
<dt>n</dt><dd><p>COVID-19 case count</p>
</dd>
<dt>avg_7day</dt><dd><p>rolling mean of <code>n</code> in a 7 day window.
Calculate with <code>mutate(avg_7day = slider::slide_dbl(n,
  mean, .before = 6))</code></p>
</dd>
<dt>lga_name_2018</dt><dd><p>LGA encoding by Australia Bureau of Statistics,
slightly differ from the encoding used by the Department of Health
in the <code>covid</code> data</p>
</dd>
<dt>geometry</dt><dd><p>multipolygon geometry of each LGA</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
library(dplyr)
# prompt msg on the key mismatch between the two datasets
make_cubble(lga, covid, by = c("lga_name_2018" = "lga"))
check_res &lt;- check_key(lga, covid, by = c("lga_name_2018" = "lga"))

# fix mismatch
lga2 &lt;- lga |&gt;
  rename(lga = lga_name_2018) |&gt;
  mutate(lga = ifelse(lga == "Kingston (C) (Vic.)", "Kingston (C)", lga),
         lga = ifelse(lga == "Latrobe (C) (Vic.)", "Latrobe (C)", lga)) |&gt;
  filter(!lga %in% check_res$others$spatial)
covid2 &lt;- covid |&gt; filter(!lga %in% check_res$others$temporal)

make_cubble(spatial = lga2, temporal = covid2)
</code></pre>

<hr>
<h2 id='cubble'>Create a cubble object</h2><span id='topic+cubble'></span><span id='topic+make_cubble'></span>

<h3>Description</h3>

<p>Create a cubble object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubble(..., key, index, coords)

make_cubble(spatial, temporal, by = NULL, key, index, coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubble_+3A_...">...</code></td>
<td>
<p>a set of name-value pairs to create a cubble, need to include the
<code>key</code>, <code>index</code>, and <code>coords</code> variables.</p>
</td></tr>
<tr><td><code id="cubble_+3A_key">key</code></td>
<td>
<p>a character (or symbol), the spatial identifier. See the Key
section in <code><a href="tsibble.html#topic+as-tsibble">tsibble::as_tsibble()</a></code></p>
</td></tr>
<tr><td><code id="cubble_+3A_index">index</code></td>
<td>
<p>a character (or symbol), the temporal identifier.
Currently support base R classes <code>Date</code>, <code>POSIXlt</code>,
<code>POSIXct</code> and tsibble's <code><a href="tsibble.html#topic+year-month">tsibble::yearmonth()</a></code>, <code><a href="tsibble.html#topic+year-week">tsibble::yearweek()</a></code>,
and <code><a href="tsibble.html#topic+year-quarter">tsibble::yearquarter()</a></code> class. See the Index section in
<code><a href="tsibble.html#topic+as-tsibble">tsibble::as_tsibble()</a></code></p>
</td></tr>
<tr><td><code id="cubble_+3A_coords">coords</code></td>
<td>
<p>a vector of character (or symbol) of length two, in the order of
longitude first and then latitude, the argument can be omitted if created
from an sf and its subclasses. In case the sf geometry column is not POINT,
coords will be the centroid coordinates.</p>
</td></tr>
<tr><td><code id="cubble_+3A_spatial">spatial</code></td>
<td>
<p>a tibble object or an sf object, the spatial component
containing the <code>key</code> and <code>coords</code> variable (<code>coords</code> can be automatically
created from an <code>sf</code> object if not supplied).</p>
</td></tr>
<tr><td><code id="cubble_+3A_temporal">temporal</code></td>
<td>
<p>a tibble object or a tsibble object, the temporal component
containing the <code>key</code> and <code>index</code> variable.</p>
</td></tr>
<tr><td><code id="cubble_+3A_by">by</code></td>
<td>
<p>in the syntax of the <code>by</code> argument in <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>,
used in <code>make_cubble()</code> when the key variable has different names in the
<code>spatial</code> and <code>temporal</code> data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cubble object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cubble(
  id = rep(c("perth", "melbourne", "sydney"), each = 3),
  date = rep(as.Date("2020-01-01") + 0:2, times = 3),
  long = rep(c(115.86, 144.96, 151.21), each = 3),
  lat = rep(c(-31.95, -37.81, -33.87), each = 3),
  value = rnorm(n = 9),
  key = id, index = date, coords = c(long, lat)
  )

# stations and climate are in-built data in cubble
make_cubble(spatial = stations, temporal = meteo,
            key = id, index = date, coords = c(long, lat))

</code></pre>

<hr>
<h2 id='extract_var'>Functions to extract NetCDF dimension and variables</h2><span id='topic+extract_var'></span><span id='topic+extract_longlat'></span><span id='topic+extract_time'></span>

<h3>Description</h3>

<p>Functions to extract NetCDF dimension and variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_var(data, vars = NULL)

extract_longlat(data)

extract_time(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_var_+3A_data">data</code></td>
<td>
<p>a NetCDF file read in from <code>ncdf4::nc_open()</code></p>
</td></tr>
<tr><td><code id="extract_var_+3A_vars">vars</code></td>
<td>
<p>variables to read, see the variables in your data with
<code>names(data$var)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>extracted netcdf4 components
</p>

<hr>
<h2 id='face_temporal'>Pivot a cubble object between the nested/long (spatial/temporal) form</h2><span id='topic+face_temporal'></span><span id='topic+face_temporal.temporal_cubble_df'></span><span id='topic+face_temporal.spatial_cubble_df'></span><span id='topic+face_spatial'></span><span id='topic+face_spatial.spatial_cubble_df'></span><span id='topic+face_spatial.temporal_cubble_df'></span>

<h3>Description</h3>

<p>While <code>face_temporal()</code> switches a cubble object into a long cubble,
suitable for temporal operations, <code>face_spatial()</code> turns a long cubble back
into a nest cubble for spatial operations. The two operations are exact
inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>face_temporal(data, col)

## S3 method for class 'temporal_cubble_df'
face_temporal(data, col)

## S3 method for class 'spatial_cubble_df'
face_temporal(data, col)

face_spatial(data)

## S3 method for class 'spatial_cubble_df'
face_spatial(data)

## S3 method for class 'temporal_cubble_df'
face_spatial(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="face_temporal_+3A_data">data</code></td>
<td>
<p>a cubble object</p>
</td></tr>
<tr><td><code id="face_temporal_+3A_col">col</code></td>
<td>
<p>a character (or a symbol), the list column to be expanded,
<code>col</code> is required to be specified if there are more than one list column
and the list column name is not <code>ts</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cubble object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cb_long &lt;- climate_mel %&gt;% face_temporal()
cb_back &lt;- cb_long %&gt;% face_spatial()
identical(climate_mel, cb_back)
</code></pre>

<hr>
<h2 id='fill_gaps.temporal_cubble_df'>Gap-filling on the temporal component of a cubble object</h2><span id='topic+fill_gaps.temporal_cubble_df'></span><span id='topic+scan_gaps.temporal_cubble_df'></span>

<h3>Description</h3>

<p>Gap-filling on the temporal component of a cubble object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'temporal_cubble_df'
fill_gaps(.data, ..., .full = FALSE, .start = NULL, .end = NULL)

## S3 method for class 'temporal_cubble_df'
scan_gaps(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_gaps.temporal_cubble_df_+3A_.data">.data</code></td>
<td>
<p>A tsibble.</p>
</td></tr>
<tr><td><code id="fill_gaps.temporal_cubble_df_+3A_...">...</code></td>
<td>
<p>A set of name-value pairs. The values provided will only replace
missing values that were marked as &quot;implicit&quot;, and will leave previously
existing <code>NA</code> untouched.
</p>

<ul>
<li><p> empty: filled with default <code>NA</code>.
</p>
</li>
<li><p> filled by values or functions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fill_gaps.temporal_cubble_df_+3A_.full">.full</code></td>
<td>

<ul>
<li> <p><code>FALSE</code> inserts <code>NA</code> for each keyed unit within its own period.
</p>
</li>
<li> <p><code>TRUE</code> fills <code>NA</code> over the entire time span of the data (a.k.a. fully balanced panel).
</p>
</li>
<li> <p><code>start()</code> pad <code>NA</code> to the same starting point (i.e. <code style="white-space: pre;">&#8288;min(&lt;index&gt;)&#8288;</code>) across units.
</p>
</li>
<li> <p><code>end()</code> pad <code>NA</code> to the same ending point (i.e. <code style="white-space: pre;">&#8288;max(&lt;index&gt;)&#8288;</code>) across units.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fill_gaps.temporal_cubble_df_+3A_.start">.start</code>, <code id="fill_gaps.temporal_cubble_df_+3A_.end">.end</code></td>
<td>
<p>Set custom starting/ending time that allows to expand the
existing time spans.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cubble object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsibble)
climate_aus %&gt;% face_temporal() %&gt;% fill_gaps()
climate_aus %&gt;% face_temporal() %&gt;% scan_gaps()
</code></pre>

<hr>
<h2 id='geom_glyph'>Create glyph map with ggplot2</h2><span id='topic+geom_glyph'></span><span id='topic+geom_glyph_line'></span><span id='topic+geom_glyph_box'></span>

<h3>Description</h3>

<p>Create glyph map with ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_glyph(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  x_major = NULL,
  x_minor = NULL,
  y_major = NULL,
  y_minor = NULL,
  x_scale = identity,
  y_scale = identity,
  polar = FALSE,
  width = ggplot2::rel(2.1),
  height = ggplot2::rel(1.8),
  global_rescale = TRUE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_glyph_line(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  x_major = NULL,
  x_minor = NULL,
  y_major = NULL,
  y_minor = NULL,
  polar = FALSE,
  width = ggplot2::rel(2.1),
  height = ggplot2::rel(2.1),
  show.legend = NA,
  inherit.aes = TRUE
)

geom_glyph_box(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  x_major = NULL,
  x_minor = NULL,
  y_major = NULL,
  y_minor = NULL,
  polar = FALSE,
  width = ggplot2::rel(2.1),
  height = ggplot2::rel(2.1),
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_glyph_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_x_major">x_major</code>, <code id="geom_glyph_+3A_x_minor">x_minor</code>, <code id="geom_glyph_+3A_y_major">y_major</code>, <code id="geom_glyph_+3A_y_minor">y_minor</code></td>
<td>
<p>The name of the variable (as a
string) for the major and minor x and y axes. Together, each unique
combination of <code>x_major</code> and <code>y_major</code> specifies a grid cell.</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_y_scale">y_scale</code>, <code id="geom_glyph_+3A_x_scale">x_scale</code></td>
<td>
<p>The scaling function to be applied to each set of
minor values within a grid cell. Defaults to <code><a href="base.html#topic+identity">identity</a></code> so
that no scaling is performed.</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_polar">polar</code></td>
<td>
<p>A logical of length 1, specifying whether the glyphs should
be drawn in polar coordinates.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_height">height</code>, <code id="geom_glyph_+3A_width">width</code></td>
<td>
<p>The height and width of each glyph. Defaults to 95% of
the <code><a href="ggplot2.html#topic+resolution">resolution</a></code> of the data. Specify the width
absolutely by supplying a numeric vector of length 1, or relative to the
resolution of the data by using <code><a href="ggplot2.html#topic+rel">rel</a></code>.</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_global_rescale">global_rescale</code></td>
<td>
<p>Whether rescale is performed globally or on each
individual glyph.</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_glyph_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print_p &lt;- GGally::print_if_interactive

library(ggplot2)
# basic glyph map with reference line and box---------------
p &lt;- ggplot(data = GGally::nasa,
       aes(x_major = long, x_minor = day,
           y_major = lat, y_minor = surftemp)) +
  geom_glyph_box() +
  geom_glyph_line() +
  geom_glyph() +
  theme_bw()
print_p(p)

# rescale on each individual glyph ---------------
p &lt;- ggplot(data = GGally::nasa,
       aes(x_major = long, x_minor = day,
           y_major = lat, y_minor = surftemp)) +
  geom_glyph(global_rescale = FALSE)
print_p(p)

# adjust width and height with relative &amp; absolute value ---------------
p &lt;- ggplot() +
  geom_glyph(data = GGally::nasa,
             aes(x_major = long, x_minor = day,
                 y_major = lat, y_minor = surftemp),
                 width = rel(0.8), height = 1) +
   theme_bw()
print_p(p)

# apply a re-scaling on Y and use polar coordinate
p &lt;-
  GGally::nasa %&gt;%
  ggplot(aes(x_major = long, x_minor = day,
             y_major = lat, y_minor = ozone)) +
    geom_glyph_box(fill=NA) +
    geom_glyph_line() +
    geom_glyph(y_scale = GGally::range01, polar = TRUE)
print_p(p)
</code></pre>

<hr>
<h2 id='is_cubble'>Predicate functions on the object class</h2><span id='topic+is_cubble'></span><span id='topic+is_cubble_spatial'></span><span id='topic+is_cubble_temporal'></span><span id='topic+is_sf'></span><span id='topic+is_tsibble'></span>

<h3>Description</h3>

<p>Predicate functions on the object class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_cubble(data)

is_cubble_spatial(data)

is_cubble_temporal(data)

is_sf(data)

is_tsibble(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_cubble_+3A_data">data</code></td>
<td>
<p>an object to test for the class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value of TRUE/FALSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_cubble(stations)
is_cubble(meteo)
is_cubble(climate_flat)
is_cubble(climate_mel)
is_cubble(climate_aus)
is_cubble_spatial(climate_aus)
is_cubble_temporal(climate_aus)
</code></pre>

<hr>
<h2 id='key_vars.cubble_df'>Extract cubble attributes</h2><span id='topic+key_vars.cubble_df'></span><span id='topic+key.cubble_df'></span><span id='topic+key_data.cubble_df'></span><span id='topic+coords'></span><span id='topic+spatial'></span><span id='topic+spatial.spatial_cubble_df'></span><span id='topic+spatial.temporal_cubble_df'></span><span id='topic+index'></span><span id='topic+index_var'></span>

<h3>Description</h3>

<p>Extract cubble attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cubble_df'
key_vars(x)

## S3 method for class 'cubble_df'
key(x)

## S3 method for class 'cubble_df'
key_data(.data)

coords(data)

spatial(data)

## S3 method for class 'spatial_cubble_df'
spatial(data)

## S3 method for class 'temporal_cubble_df'
spatial(data)

index(data)

index_var(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key_vars.cubble_df_+3A_x">x</code>, <code id="key_vars.cubble_df_+3A_.data">.data</code>, <code id="key_vars.cubble_df_+3A_data">data</code></td>
<td>
<p>a cubble object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsibble)
key(climate_mel)
key_vars(climate_mel)
key_data(climate_mel)
cubble::index(climate_mel)
cubble::index_var(climate_mel)
coords(climate_mel)
spatial(climate_mel)
</code></pre>

<hr>
<h2 id='make_spatial_sf'>Update the spatial cubble to include the sf class</h2><span id='topic+make_spatial_sf'></span>

<h3>Description</h3>

<p>add geometry list column to cubble_df object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_spatial_sf(x, sfc = NULL, crs, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_spatial_sf_+3A_x">x</code></td>
<td>
<p>object of class <code>spatial_cubble_df</code></p>
</td></tr>
<tr><td><code id="make_spatial_sf_+3A_sfc">sfc</code></td>
<td>
<p>object of class <code>sfc</code> (see package sf)</p>
</td></tr>
<tr><td><code id="make_spatial_sf_+3A_crs">crs</code></td>
<td>
<p>object of class <code>crs</code> (see package sf); if missing
'OGC:CRS84' is assumed (WGS84) and a message is emitted</p>
</td></tr>
<tr><td><code id="make_spatial_sf_+3A_silent">silent</code></td>
<td>
<p>logical; suppress message?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+make_temporal_tsibble">make_temporal_tsibble</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>climate_mel %&gt;% make_spatial_sf()
</code></pre>

<hr>
<h2 id='make_temporal_tsibble'>Update the temporal cubble to include the tsibble class (<code>tbl_ts</code>)</h2><span id='topic+make_temporal_tsibble'></span>

<h3>Description</h3>

<p>Update the temporal cubble to include the tsibble class (<code>tbl_ts</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_temporal_tsibble(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_temporal_tsibble_+3A_x">x</code></td>
<td>
<p>object of class <code>temporal_cubble_df</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>climate_mel %&gt;% face_temporal() %&gt;% make_temporal_tsibble()
</code></pre>

<hr>
<h2 id='match_sites'>Match stations in two cubbles by spatial distance/ temporal similarity</h2><span id='topic+match_sites'></span><span id='topic+match_spatial'></span><span id='topic+match_temporal'></span>

<h3>Description</h3>

<p>The spatial matching is calculated using <code><a href="sf.html#topic+geos_measures">sf::st_distance()</a></code> with different
distance (in meter or degree) available depending on the coordinate reference
system and parameter (<code>which</code> and <code>par</code>). The temporal matching is based on
a temporal matching function (<code>temporal_match_fn</code>) that can be customised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_sites(
  df1,
  df2,
  crs = sf::st_crs("OGC:CRS84"),
  which = NULL,
  par = 0,
  spatial_n_each = 1,
  spatial_n_group = 4,
  data_id,
  match_id,
  temporal_matching = TRUE,
  temporal_by,
  temporal_match_fn = match_peak,
  temporal_n_highest = 20,
  temporal_window = 5,
  ...
)

match_spatial(
  df1,
  df2,
  crs = sf::st_crs("OGC:CRS84"),
  which = NULL,
  par = 0,
  spatial_n_each = 1,
  spatial_n_group = 4,
  return_cubble = FALSE
)

match_temporal(
  data,
  data_id,
  match_id = NULL,
  temporal_by,
  return_cubble = FALSE,
  temporal_match_fn = match_peak,
  temporal_n_highest = 30,
  temporal_window = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_sites_+3A_df1">df1</code>, <code id="match_sites_+3A_df2">df2</code></td>
<td>
<p>the two cubble objects to match</p>
</td></tr>
<tr><td><code id="match_sites_+3A_crs">crs</code></td>
<td>
<p>a crs object from <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code></p>
</td></tr>
<tr><td><code id="match_sites_+3A_which">which</code></td>
<td>
<p>character; for Cartesian coordinates only: one of <code>Euclidean</code>, <code>Hausdorff</code> or <code>Frechet</code>; for geodetic coordinates, great circle distances are computed; see details</p>
</td></tr>
<tr><td><code id="match_sites_+3A_par">par</code></td>
<td>
<p>for <code>which</code> equal to <code>Hausdorff</code> or <code>Frechet</code>, optionally use a value between 0 and 1 to densify the geometry</p>
</td></tr>
<tr><td><code id="match_sites_+3A_spatial_n_each">spatial_n_each</code></td>
<td>
<p>integer, the number of matched &quot;station&quot; in <code>df2</code>
for each <code>df1</code> record</p>
</td></tr>
<tr><td><code id="match_sites_+3A_spatial_n_group">spatial_n_group</code></td>
<td>
<p>integer, the number of matched group (pair) return</p>
</td></tr>
<tr><td><code id="match_sites_+3A_data_id">data_id</code></td>
<td>
<p>a character (or symbol), the variable differentiates
<code>df1</code> and <code>df2</code></p>
</td></tr>
<tr><td><code id="match_sites_+3A_match_id">match_id</code></td>
<td>
<p>a character (or symbol), the variable differentiate
each group of match</p>
</td></tr>
<tr><td><code id="match_sites_+3A_temporal_matching">temporal_matching</code></td>
<td>
<p>logical, whether to match temporally</p>
</td></tr>
<tr><td><code id="match_sites_+3A_temporal_by">temporal_by</code></td>
<td>
<p>in the <code>by</code> syntax in <code>dplyr::*_join()</code>,
the variables to match temporally in <code>df1</code> and <code>df2</code>.</p>
</td></tr>
<tr><td><code id="match_sites_+3A_temporal_match_fn">temporal_match_fn</code></td>
<td>
<p>character, the function name on how two time
series should be matched</p>
</td></tr>
<tr><td><code id="match_sites_+3A_temporal_n_highest">temporal_n_highest</code></td>
<td>
<p>numeric, the number of highest peak used for
temporal matching in <code>match_peak</code></p>
</td></tr>
<tr><td><code id="match_sites_+3A_temporal_window">temporal_window</code></td>
<td>
<p>The temporal window allowed in <code>match_peak</code></p>
</td></tr>
<tr><td><code id="match_sites_+3A_...">...</code></td>
<td>
<p>parameters passing to temporal match</p>
</td></tr>
<tr><td><code id="match_sites_+3A_return_cubble">return_cubble</code></td>
<td>
<p>logical (default to false), whether to return the
cubble object or a matching summary table</p>
</td></tr>
<tr><td><code id="match_sites_+3A_data">data</code></td>
<td>
<p>the resulting cubble object from spatial matching (with
<code>return_cubble = TRUE</code> in spatial matching)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
climate_aus &lt;- mutate(climate_aus, type = "climate")
match_spatial(climate_aus, river)
# turn with different distance calculation:
match_spatial(climate_aus, river, which = "Hausdorff")
# tune the number of matches in each group
match_spatial(climate_aus, river, spatial_n_each = 5, spatial_n_group = 2)

a1 &lt;- match_spatial(climate_aus, river, return_cubble = TRUE) %&gt;% bind_rows()
match_temporal(a1, data_id = type, match_id = group,
               temporal_by = c("prcp" = "Water_course_level"))
</code></pre>

<hr>
<h2 id='print.cubble_df'>Print methods</h2><span id='topic+print.cubble_df'></span><span id='topic+tbl_sum.spatial_cubble_df'></span><span id='topic+tbl_sum.temporal_cubble_df'></span>

<h3>Description</h3>

<p>Print methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cubble_df'
print(x, width = NULL, ...)

## S3 method for class 'spatial_cubble_df'
tbl_sum(x)

## S3 method for class 'temporal_cubble_df'
tbl_sum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cubble_df_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object (conceptually); typically numeric.</p>
</td></tr>
<tr><td><code id="print.cubble_df_+3A_width">width</code></td>
<td>
<p><code>default</code> method: the <em>minimum</em> field width or
<code>NULL</code> or <code>0</code> for no restriction.
</p>
<p><code>AsIs</code> method: the <em>maximum</em> field width for non-character
objects.  <code>NULL</code> corresponds to the default <code>12</code>.
</p>
</td></tr>
<tr><td><code id="print.cubble_df_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>climate_mel # a nested/spatial cubble
face_temporal(climate_mel) # a long/temporal cubble
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
</dl>

<hr>
<h2 id='river'>Australia river data</h2><span id='topic+river'></span>

<h3>Description</h3>

<p>Australia river data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>river
</code></pre>


<h3>Format</h3>

<p>An object of class <code>spatial_cubble_df</code> (inherits from <code>cubble_df</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 71 rows and 6 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>river
</code></pre>

<hr>
<h2 id='stations'>Toy climate data</h2><span id='topic+stations'></span><span id='topic+stations_sf'></span><span id='topic+meteo'></span><span id='topic+meteo_ts'></span><span id='topic+climate_flat'></span><span id='topic+climate_mel'></span>

<h3>Description</h3>

<p>Daily measure (2020-01-01 to 2020-01-10) on precipitation (prcp),
maximum temperature (tmax), and minimum temperature (tmin)
for 3 melbourne airport stations. <code>stations</code> is the spatial component,
(<code>stations_sf</code> as an sf object), <code>meteo</code> has the temporal component
(<code>meteo_ts</code> as a tsibble object), <code>climate_flat</code> has both
in a single joined table, and <code>climate_mel</code> is the cubble object.
See <code>climate_aus</code> on the full dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stations

stations_sf

meteo

meteo_ts

climate_flat

climate_mel
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 3 rows and 6 columns.
</p>
<p>An object of class <code>sf</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 3 rows and 5 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 30 rows and 5 columns.
</p>
<p>An object of class <code>tbl_ts</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 30 rows and 5 columns.
</p>
<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 30 rows and 10 columns.
</p>
<p>An object of class <code>spatial_cubble_df</code> (inherits from <code>cubble_df</code>, <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 3 rows and 7 columns.
</p>


<h3>See Also</h3>

<p>climate_aus
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cb &lt;- make_cubble(
  spatial = stations, temporal = meteo,
  key = id, index = date, coords = c(long, lat)
)
identical(cb, climate_mel)
cb2 &lt;- climate_flat %&gt;%
  as_cubble(key = id, index = date, coords = c(long, lat))
identical(cb, climate_mel)
</code></pre>

<hr>
<h2 id='unfold'>Augment spatial component into the long (temporal) form</h2><span id='topic+unfold'></span><span id='topic+unfold.spatial_cubble_df'></span><span id='topic+unfold.temporal_cubble_df'></span>

<h3>Description</h3>

<p>Some spatio-temporal transformation, i.e. glyph maps, uses both spatial
and temporal variables. <code>unfold()</code> allows you to temporarily moves spatial
variables into the long form for these transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfold(data, ...)

## S3 method for class 'spatial_cubble_df'
unfold(data, ...)

## S3 method for class 'temporal_cubble_df'
unfold(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfold_+3A_data">data</code></td>
<td>
<p>a long cubble object</p>
</td></tr>
<tr><td><code id="unfold_+3A_...">...</code></td>
<td>
<p>spatial variables to move into the long form,
support tidyselect syntax</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cubble object in the long form
</p>


<h3>Examples</h3>

<pre><code class='language-R'>climate_mel %&gt;% face_temporal() %&gt;% unfold(long, lat)
climate_mel %&gt;% face_temporal() %&gt;% unfold(dplyr::starts_with("l"))
</code></pre>

<hr>
<h2 id='update_cubble'>Temporary update cubble if the sf class take precedent of cubble classes</h2><span id='topic+update_cubble'></span><span id='topic+update_cubble.spatial_cubble_df'></span><span id='topic+update_cubble.temporal_cubble_df'></span>

<h3>Description</h3>

<p>When the data is already a cubble object but need update on attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_cubble(data, key, index, coords, ...)

## S3 method for class 'spatial_cubble_df'
update_cubble(data, key = NULL, index = NULL, coords = NULL, ...)

## S3 method for class 'temporal_cubble_df'
update_cubble(
  data,
  key = NULL,
  index = NULL,
  coords = NULL,
  spatial = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_cubble_+3A_data">data</code>, <code id="update_cubble_+3A_key">key</code>, <code id="update_cubble_+3A_index">index</code>, <code id="update_cubble_+3A_coords">coords</code>, <code id="update_cubble_+3A_spatial">spatial</code>, <code id="update_cubble_+3A_...">...</code></td>
<td>
<p>skdflsjkd</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
