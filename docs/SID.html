<!DOCTYPE html><html><head><title>Help for package SID</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SID}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SID-package'>
<p>Structural Intervention Distance (SID) (package)</p></a></li>
<li><a href='#computePathMatrix'>
<p>auxiliary file for SID: computes a path matrix efficiently (can probably be made faster)</p></a></li>
<li><a href='#computePathMatrix2'>
<p>auxiliary file for SID: computes a path matrix efficiently (can probably be made faster)</p></a></li>
<li><a href='#hammingDist'>
<p>Hamming Distance</p></a></li>
<li><a href='#randomDAG'>
<p>outputs the adjacency matrix of a randomly generated directed acyclic graph (DAG).</p></a></li>
<li><a href='#structIntervDist'>
<p>Structural Intervention Distance (SID)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Structural Intervention Distance</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-03</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>pcalg, igraph, RBGL, Matrix, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>The code computes the structural intervention distance (SID) between a true directed acyclic graph (DAG) and an estimated DAG. Definition and details about the implementation can be found in J. Peters and P. BÃ¼hlmann: "Structural intervention distance (SID) for evaluating causal graphs", Neural Computation 27, pages 771-799, 2015  &lt;<a href="https://doi.org/10.1162%2FNECO_a_00708">doi:10.1162/NECO_a_00708</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fkgruber/SID_cran">https://github.com/fkgruber/SID_cran</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.freebsd.org/copyright/freebsd-license.html">FreeBSD</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-06 04:46:38 UTC; fred</td>
</tr>
<tr>
<td>Author:</td>
<td>Fred Gruber [cre],
  Jonas Peters [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fred Gruber &lt;fgruber@gmail.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-06 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SID-package'>
Structural Intervention Distance (SID) (package)
</h2><span id='topic+SID-package'></span>

<h3>Description</h3>

<p>The package allows to compute the structural intervention distance (SID) between two graphs. This (pre-)metric evaluates graphs from a causal inference point of view. The package also contains a function for computing the Hamming distance and to generate random DAGs. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SID</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-03-07</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> FreeBSD</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Computing the Structural Intervention Distance. The algorithm can be called with <code>structIntervDist</code>.
</p>


<h3>Author(s)</h3>

<p>Jonas Peters &lt;jonas.peters@tuebingen.mpg.de&gt;
</p>


<h3>References</h3>

<p>J. Peters, P. B\&quot;uhlmann: Structural intervention distance (SID) for evaluating causal 
graphs, Neural Computation 27, pages 771-799, 2015
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomDAG">randomDAG</a></code>
<code><a href="#topic+structIntervDist">structIntervDist</a></code>
<code><a href="#topic+hammingDist">hammingDist</a></code>
</p>

<hr>
<h2 id='computePathMatrix'>
auxiliary file for SID: computes a path matrix efficiently (can probably be made faster)
</h2><span id='topic+computePathMatrix'></span>

<h3>Description</h3>

<p>auxiliary file for SID: computes a path matrix efficiently (can probably be made faster)
This function takes an adjacency matrix G from a DAG and computes a path matrix for which entry(i,j) being one means that there is a directed path from i to j the diagonal will also be one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePathMatrix(G, spars=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computePathMatrix_+3A_g">G</code></td>
<td>

<p>graph.
</p>
</td></tr>
<tr><td><code id="computePathMatrix_+3A_spars">spars</code></td>
<td>

<p>boolean indicating whether G is a sparse matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pathMatrix
</p>


<h3>Author(s)</h3>

<p>Jonas Peters &lt;jonas.peters@tuebingen.mpg.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+structIntervDist">structIntervDist</a></code>
<code><a href="#topic+computePathMatrix2">computePathMatrix2</a></code>
</p>

<hr>
<h2 id='computePathMatrix2'>
auxiliary file for SID: computes a path matrix efficiently (can probably be made faster)
</h2><span id='topic+computePathMatrix2'></span>

<h3>Description</h3>

<p>auxiliary file for SID: computes a path matrix efficiently (can probably be made faster)
The only difference to the function computePathMatrix is that this function changes the graph by removing all edges that leave condSet. If condSet is empty, it just returns PathMatrix1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePathMatrix2(G,condSet,PathMatrix1, spars=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computePathMatrix2_+3A_g">G</code></td>
<td>

<p>graph.
</p>
</td></tr>
<tr><td><code id="computePathMatrix2_+3A_condset">condSet</code></td>
<td>

<p>set of variables
</p>
</td></tr>
<tr><td><code id="computePathMatrix2_+3A_pathmatrix1">PathMatrix1</code></td>
<td>

<p>PathMatrix1
</p>
</td></tr>
<tr><td><code id="computePathMatrix2_+3A_spars">spars</code></td>
<td>

<p>boolean indicating whether the matrices are sparse
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pathMatrix
</p>


<h3>Author(s)</h3>

<p>Jonas Peters &lt;jonas.peters@tuebingen.mpg.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+structIntervDist">structIntervDist</a></code>
<code><a href="#topic+computePathMatrix">computePathMatrix</a></code>
</p>

<hr>
<h2 id='hammingDist'>
Hamming Distance
</h2><span id='topic+hammingDist'></span>

<h3>Description</h3>

<p>Computes the Hamming distance between two graph objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hammingDist(G1, G2, allMistakesOne = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hammingDist_+3A_g1">G1</code></td>
<td>

<p>p x p adjacency matrix of the first graph. 
</p>
</td></tr>
<tr><td><code id="hammingDist_+3A_g2">G2</code></td>
<td>

<p>p x p adjacency matrix of the second graph.
</p>
</td></tr>
<tr><td><code id="hammingDist_+3A_allmistakesone">allMistakesOne</code></td>
<td>

<p>boolean variable (TRUE/FALSE) that indicates whether all mistakes should be counted as one. E.g., if it is set to FALSE the Hamming distance between X -&gt; Y and X &lt;- Y is two and one if it set to TRUE. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hamming distance between two graphs counts the number of edges, in which the graphs do not coincide. allMistakesOne determines whether a reversed edge counts as two or as one mistake. The Hamming distance is symmetric, that is hammingDist(G1,G2) = hammingDist(G2,G1). 
</p>


<h3>Value</h3>

<p>The method outputs the computed Hamming distance.
</p>


<h3>Author(s)</h3>

<p>Jonas Peters &lt;jonas.peters@tuebingen.mpg.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+structIntervDist">structIntervDist</a></code>
</p>

<hr>
<h2 id='randomDAG'>
outputs the adjacency matrix of a randomly generated directed acyclic graph (DAG). 
</h2><span id='topic+randomDAG'></span>

<h3>Description</h3>

<p>After simulating a random topological order first (the order can also be prespecified), the algorithm connects two nodes with the porbability
probConnect. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomDAG(p, probConnect, causalOrder = sample(p, p, replace = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomDAG_+3A_p">p</code></td>
<td>

<p>number of nodes.
</p>
</td></tr>
<tr><td><code id="randomDAG_+3A_probconnect">probConnect</code></td>
<td>

<p>probability of connecting two nodes, determines the sparsity of the graph. Choosing probConnect = 2/(p-1), for example, leads to an expected number of p nodes.
</p>
</td></tr>
<tr><td><code id="randomDAG_+3A_causalorder">causalOrder</code></td>
<td>

<p>OPTIONAL: causal or topological order of the nodes. If not provided, the topological order is chosen randomly.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p x p adjacency matrix that describes a directed acyclic graph (DAG) with p nodes. The entry (i,j) equals one if and only if there is an edge from i to j.
</p>


<h3>Author(s)</h3>

<p>Jonas Peters &lt;jonas.peters@tuebingen.mpg.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+structIntervDist">structIntervDist</a></code>
<code><a href="#topic+hammingDist">hammingDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>randomDAG(p = 5, probConnect = 0.6)
</code></pre>

<hr>
<h2 id='structIntervDist'>
Structural Intervention Distance (SID)
</h2><span id='topic+structIntervDist'></span>

<h3>Description</h3>

<p>computes the structural intervention distance (SID) between two graphs; it evaluates graphs from a causal inference point of view.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structIntervDist(trueGraph, estGraph, output = FALSE, spars = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structIntervDist_+3A_truegraph">trueGraph</code></td>
<td>

<p>p x p adjacecncy matrix; it must be a directed acyclic graph (DAG)
</p>
</td></tr>
<tr><td><code id="structIntervDist_+3A_estgraph">estGraph</code></td>
<td>

<p>again a p x p adjacecncy matrix; it can be either a DAG or a completed partially directed graph (CPDAG) that represents a Markov equivalence class.
</p>
</td></tr>
<tr><td><code id="structIntervDist_+3A_output">output</code></td>
<td>

<p>boolean (TRUE/FALSE) that indicates whether output shall be shown
</p>
</td></tr>
<tr><td><code id="structIntervDist_+3A_spars">spars</code></td>
<td>

<p>boolean (TRUE/FALSE) that indicates whether the input matrices trueGraph and estGraph are sparse. If matrices are indeed large and sparse this increases the speed of the algorithm.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The structural intervention distance (SID) considers each pair (i,j) and checks whether the parents of i in estGraph is a valid adjustment set in trueGraph for the causal effect from i to j. If it is, estimating the causal effect from i to j using parent adjustment in estGraph is a correct procedure, independently of the distribution. If it is not, the pair (i,j) contributes a mistake of one to the overall structural intervention distance. 
</p>
<p>The SID satisfies the properties of a pre-metric; we have SID(G,G) = 0 and 0 &lt;= SID(G1,G2) &lt;= p(p-1), where p is the number of nodes. The SID is not symmetric: in general, we have SID(G1, G2) != SID(G2,G1). Furthermore, the SID can be zero although the two graphs are not the same.
</p>
<p>If estGraph is a completed partially directed acyclic graph (CPDAG), that is it describes a Markov equivalence class, the SID outputs a lower and an upper bound of the SID, that correspond to the best and worst DAG in the equivalence class, respectively.
</p>


<h3>Value</h3>

<p>The main function is structIntervDist. It takes two DAGs (adjacency matrices) of the same dimension as input and provides a list with 
</p>
<table>
<tr><td><code>sid</code></td>
<td>
<p>the SID</p>
</td></tr>
<tr><td><code>sidUpperBound</code></td>
<td>
<p>relevant if estGraph is a CPDAG: it is the highest SID that can be achieved by a graph within the Markov equivalence class (&quot;worst DAG&quot;)</p>
</td></tr>
<tr><td><code>sidLowerBound</code></td>
<td>
<p>relevant if estGraph is a CPDAG: it is the lowest SID that can be achieved by a graph within the Markov equivalence class (&quot;best DAG&quot;)</p>
</td></tr>
<tr><td><code>incorrectMat</code></td>
<td>
<p>the matrix of incorrect interventional distributions; its sum equals $sid</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Peters &lt;jonas.peters@tuebingen.mpg.de&gt;
</p>


<h3>References</h3>

<p>J. Peters, P. B\&quot;uhlmann: Structural intervention distance (SID) for evaluating causal graphs, Neural Computation 27, pages 771-799, 2015
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hammingDist">hammingDist</a></code>
<code><a href="#topic+randomDAG">randomDAG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- rbind(c(0,1,1,1,1),
           c(0,0,1,1,1),
           c(0,0,0,0,0),
           c(0,0,0,0,0),
           c(0,0,0,0,0))

H1 &lt;- rbind(c(0,1,1,1,1),
            c(0,0,1,1,1),
            c(0,0,0,1,0),
            c(0,0,0,0,0),
            c(0,0,0,0,0))

H2 &lt;- rbind(c(0,0,1,1,1),
            c(1,0,1,1,1),
            c(0,0,0,0,0),
            c(0,0,0,0,0),
            c(0,0,0,0,0))

cat("true DAG G:\n")
show(G)
cat("\n")
cat("==============","\n")
cat("\n")
cat("estimated DAG H1:\n")
show(H1)
sid &lt;- structIntervDist(G,H1)
shd &lt;- hammingDist(G,H1)
cat("SHD between G and H1: ",shd,"\n")
cat("SID between G and H1: ",sid$sid,"\n")
#cat("The matrix of incorrect interventional distributions is: ","\n")
#show(sid$incorrectMat)
cat("\n")
cat("==============","\n")
cat("\n")
cat("estimated DAG H2:\n")
show(H2)
sid &lt;- structIntervDist(G,H2)
shd &lt;- hammingDist(G,H2)
cat("SHD between G and H2: ",shd,"\n")
cat("SID between G and H2: ",sid$sid,"\n")
cat("The matrix of incorrect interventional distributions is: ","\n")
show(sid$incorrectMat)

readline("The SID can also be applied to CPDAGs. Please press enter...")
cat("\n")
cat("==============","\n")
cat("\n")
cat("estimated CPDAG H1c:\n")
H1c &lt;- rbind(c(0,1,1,1,1),c(1,0,1,1,1),c(1,1,0,1,0),c(1,1,1,0,0),c(1,1,0,0,0)) 
show(H1c)
sid &lt;- structIntervDist(G,H1c)
cat("SID between G and H1: \n")
cat("lower bound: ",sid$sidLowerBound," upper bound: ", sid$sidUpperBound, "\n")
cat("\n")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
