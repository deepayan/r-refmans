<!DOCTYPE html><html><head><title>Help for package ggbiplot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggbiplot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crime'><p>U. S. Crimes</p></a></li>
<li><a href='#get_SVD'><p>Extract the SVD components from a PCA-like object</p></a></li>
<li><a href='#ggbiplot'><p>Biplot for Principal Components using ggplot2</p></a></li>
<li><a href='#ggscreeplot'><p>Screeplot for Principal Components</p></a></li>
<li><a href='#reflect'><p>Reflect Columns in a Principal Component-like Object</p></a></li>
<li><a href='#wine'><p>Wine dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Grammar of Graphics Implementation of Biplots</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-06</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'ggplot2' based implementation of biplots, giving a representation of a dataset in
    a two dimensional space accounting for the greatest variance, together with variable vectors
    showing how the data variables relate to this space. It provides a 
    replacement for stats::biplot(), but with many enhancements to control the analysis and
    graphical display. It implements 
    biplot and scree plot methods which can be used with the results of prcomp(), princomp(),
    FactoMineR::PCA(), ade4::dudi.pca() or MASS::lda() and can be customized using 'ggplot2' techniques.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>scales</td>
</tr>
<tr>
<td>Suggests:</td>
<td>corrplot, dplyr, MASS, broom, tidyr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/friendly/ggbiplot">https://github.com/friendly/ggbiplot</a>,
<a href="https://friendly.github.io/ggbiplot/">https://friendly.github.io/ggbiplot/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/friendly/ggbiplot/issues">https://github.com/friendly/ggbiplot/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 15:42:14 UTC; friendly</td>
</tr>
<tr>
<td>Author:</td>
<td>Vincent Q. Vu <a href="https://orcid.org/0000-0002-4689-0497"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Michael Friendly <a href="https://orcid.org/0000-0002-3237-0941"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Aghasi Tavadyan [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Friendly &lt;friendly@yorku.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 23:10:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='crime'>U. S. Crimes</h2><span id='topic+crime'></span>

<h3>Description</h3>

<p>This dataset gives rates of occurrence (per 100,000 people)
various serious crimes in each of the 50 U. S. states, 
originally from the United States Statistical Abstracts (1970). The data
were analyzed by John Hartigan (1975) in his book <em>Clustering Algorithms</em> and 
were later reanalyzed by Friendly (1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(crime)
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on the following 10 variables.
</p>

<dl>
<dt><code>state</code></dt><dd><p>state name, a character vector</p>
</dd>
<dt><code>murder</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rape</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>robbery</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>assault</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>burglary</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>larceny</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>auto</code></dt><dd><p>auto thefts, a numeric vector</p>
</dd>
<dt><code>st</code></dt><dd><p>state abbreviation, a character vector</p>
</dd>
<dt><code>region</code></dt><dd><p>region of the U.S., a factor with levels <code>Northeast</code> <code>South</code> <code>North Central</code> <code>West</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>The data are originally from the United States Statistical Abstracts (1970).
This dataset also appears in the SAS/Stat Sample library,
<em>Getting Started Example for PROC PRINCOMP</em>, 
<a href="https://support.sas.com/documentation/onlinedoc/stat/ex_code/131/princgs.html">https://support.sas.com/documentation/onlinedoc/stat/ex_code/131/princgs.html</a>, from which the
current copy was derived.
</p>


<h3>References</h3>

<p>Friendly, M. (1991). <em>SAS System for Statistical Graphics</em>. SAS Institute.
</p>
<p>Hartigan, J. A. (1975). <em>Clustering Algorithms</em>. John Wiley and Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crime)
library(ggplot2)
crime.pca &lt;- 
  crime |&gt; 
  dplyr::select(where(is.numeric)) |&gt;
  prcomp(scale. = TRUE)

ggbiplot(crime.pca,
     labels = crime$st ,
     circle = TRUE,
     varname.size = 4,
     varname.color = "red") +
 theme_minimal(base_size = 14) 
</code></pre>

<hr>
<h2 id='get_SVD'>Extract the SVD components from a PCA-like object</h2><span id='topic+get_SVD'></span>

<h3>Description</h3>

<p>Biplots are based on the Singular Value Decomposition, which for a data matrix is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{X} / \sqrt{n} = \mathbf{U} \mathbf{D} \mathbf{V}^T</code>
</p>

<p>but these are computed and returned in quite different
forms by various PCA-like methods. This function provides a common interface, returning
the components with standard names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_SVD(pcobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_SVD_+3A_pcobj">pcobj</code></td>
<td>
<p>an object returned by <code><a href="stats.html#topic+prcomp">prcomp</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code>, 
<code><a href="FactoMineR.html#topic+PCA">PCA</a></code>, <code><a href="ade4.html#topic+dudi.pca">dudi.pca</a></code>, or <code><a href="MASS.html#topic+lda">lda</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of four elements
</p>

<dl>
<dt>n</dt><dd><p>The sample size on which the analysis was based</p>
</dd>
<dt>U</dt><dd><p>Left singular vectors, giving observation scores</p>
</dd>
<dt>D</dt><dd><p>vector of singular values, the diagonal elements of the matrix <code class="reqn">\mathbf{D}</code>, which are also the square roots
of the eigenvalues of <code class="reqn">\mathbf{X} \mathbf{X}'</code></p>
</dd>
<dt>V</dt><dd><p>Right singular vectors, giving variable loadings</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(crime)
crime.pca &lt;- 
  crime |&gt; 
  dplyr::select(where(is.numeric)) |&gt;
  prcomp(scale. = TRUE)

crime.svd &lt;- get_SVD(crime.pca)
names(crime.svd)
crime.svd$D

</code></pre>

<hr>
<h2 id='ggbiplot'>Biplot for Principal Components using ggplot2</h2><span id='topic+ggbiplot'></span>

<h3>Description</h3>

<p>A biplot simultaneously displays information on the observations (as points)
and the variables (as vectors) in a multidimensional dataset. The 2D biplot
is typically based on the first two principal components of a dataset, giving a rank 2 approximation 
to the data. The “bi” in biplot refers to the fact that two sets of points (i.e., the rows and
columns of the data matrix) are visualized by scalar products, not the fact
that the display is usually two-dimensional.
</p>
<p>The biplot method for principal component analysis was originally defined by Gabriel (1971, 1981).
Gower &amp; Hand (1996) give a more complete treatment. Greenacre (2010) is a practical user-oriented guide to biplots.
Gower et al. (2011) is the most up to date
exposition of biplot methodology.
</p>
<p>This implementation handles the results of a principal components analysis using 
<code><a href="stats.html#topic+prcomp">prcomp</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code>, <code><a href="FactoMineR.html#topic+PCA">PCA</a></code> and <code><a href="ade4.html#topic+dudi.pca">dudi.pca</a></code>;
also handles a discriminant analysis using <code><a href="MASS.html#topic+lda">lda</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbiplot(
  pcobj,
  choices = 1:2,
  scale = 1,
  pc.biplot = TRUE,
  obs.scale = 1 - scale,
  var.scale = scale,
  var.factor = 1,
  groups = NULL,
  point.size = 1.5,
  ellipse = FALSE,
  ellipse.prob = 0.68,
  ellipse.linewidth = 1.3,
  ellipse.fill = TRUE,
  ellipse.alpha = 0.25,
  labels = NULL,
  labels.size = 3,
  alpha = 1,
  var.axes = TRUE,
  circle = FALSE,
  circle.prob = 0.68,
  varname.size = 3,
  varname.adjust = 1.25,
  varname.color = "black",
  varname.abbrev = FALSE,
  axis.title = "PC",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbiplot_+3A_pcobj">pcobj</code></td>
<td>
<p>an object returned by <code><a href="stats.html#topic+prcomp">prcomp</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code>, 
<code><a href="FactoMineR.html#topic+PCA">PCA</a></code>, <code><a href="ade4.html#topic+dudi.pca">dudi.pca</a></code>, or <code><a href="MASS.html#topic+lda">lda</a></code></p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_choices">choices</code></td>
<td>
<p>Which components to plot? An integer vector of length 2.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_scale">scale</code></td>
<td>
<p>Covariance biplot (<code>scale = 1</code>), form biplot (<code>scale = 0</code>). 
When <code>scale = 1</code> (the default), the inner product 
between the variables approximates the covariance and the distance between the points 
approximates the Mahalanobis distance.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_pc.biplot">pc.biplot</code></td>
<td>
<p>Logical, for compatibility with <code>biplot.princomp()</code>. If <code>TRUE</code>, use what Gabriel (1971) 
refers to as a &quot;principal component biplot&quot;, with <code class="reqn">\alpha = 1</code> and observations scaled 
up by <code class="reqn">sqrt(n)</code> and variables scaled down by <code class="reqn">sqrt(n)</code>. Then inner products between 
variables approximate covariances and distances between observations approximate 
Mahalanobis distance.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_obs.scale">obs.scale</code></td>
<td>
<p>Scale factor to apply to observations</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_var.scale">var.scale</code></td>
<td>
<p>Scale factor to apply to variables</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_var.factor">var.factor</code></td>
<td>
<p>Factor to be applied to variable vectors after scaling. This allows the variable vectors to be reflected
(<code>var.factor = -1</code>) or expanded in length (<code>var.factor &gt; 1</code>) for greater visibility.
<code><a href="#topic+reflect">reflect</a></code> provides a simpler way to reflect the variables.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_groups">groups</code></td>
<td>
<p>Optional factor variable indicating the groups that the observations belong to. 
If provided the points will be colored according to groups and this allows data ellipses also
to be drawn when <code>ellipse = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_point.size">point.size</code></td>
<td>
<p>Size of observation points.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_ellipse">ellipse</code></td>
<td>
<p>Logical; draw a normal data ellipse for each group?</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_ellipse.prob">ellipse.prob</code></td>
<td>
<p>Coverage size of the data ellipse in Normal probability</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_ellipse.linewidth">ellipse.linewidth</code></td>
<td>
<p>Thickness of the line outlining the ellipses</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_ellipse.fill">ellipse.fill</code></td>
<td>
<p>Logical; should the ellipses be filled?</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_ellipse.alpha">ellipse.alpha</code></td>
<td>
<p>Transparency value (0 - 1) for filled ellipses</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_labels">labels</code></td>
<td>
<p>Optional vector of labels for the observations. Often, this will be specified as the <code>row.names()</code>
of the dataset.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_labels.size">labels.size</code></td>
<td>
<p>Size of the text used for the point labels</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_alpha">alpha</code></td>
<td>
<p>Alpha transparency value for the points (0 = transparent, 1 = opaque)</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_var.axes">var.axes</code></td>
<td>
<p>logical; draw arrows for the variables?</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_circle">circle</code></td>
<td>
<p>draw a correlation circle? (only applies when prcomp was called with 
<code>scale = TRUE</code> and when <code>var.scale = 1</code>)</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_circle.prob">circle.prob</code></td>
<td>
<p>Size of the correlation circle</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_varname.size">varname.size</code></td>
<td>
<p>Size of the text for variable names</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_varname.adjust">varname.adjust</code></td>
<td>
<p>Adjustment factor the placement of the variable names, &gt;= 1 means farther from the arrow</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_varname.color">varname.color</code></td>
<td>
<p>Color for the variable vectors and names</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_varname.abbrev">varname.abbrev</code></td>
<td>
<p>logical; whether or not to abbreviate the variable names, using <code><a href="base.html#topic+abbreviate">abbreviate</a></code>.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_axis.title">axis.title</code></td>
<td>
<p>character; the prefix used as the axis labels. Default: <code>"PC"</code>.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_...">...</code></td>
<td>
<p>other arguments passed down</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The biplot is constructed by using the singular value decomposition (SVD) to obtain a low-rank 
approximation to the data matrix <code class="reqn">\mathbf{X}_{n \times p}</code> (centered, and optionally scaled to unit variances)
whose <code class="reqn">n</code> rows are the observations 
and whose <code class="reqn">p</code> columns are the variables. 
</p>
<p>Using the SVD, the matrix <code class="reqn">\mathbf{X}</code>, of rank <code class="reqn">r \le p</code>
can be expressed <em>exactly</em> as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{X} = \mathbf{U} \mathbf{\Lambda} \mathbf{V}'
                 = \Sigma_i^r \lambda_i \mathbf{u}_i \mathbf{v}_i' \; ,</code>
</p>

<p>where 
</p>

<ul>
<li> <p><code class="reqn">\mathbf{U}</code> is an <code class="reqn">n \times r</code> orthonormal matrix of observation scores; these are also the eigenvectors
of <code class="reqn">\mathbf{X} \mathbf{X}'</code>,
</p>
</li>
<li> <p><code class="reqn">\mathbf{\Lambda}</code> is an <code class="reqn">r \times r</code> diagonal matrix of singular values, 
<code class="reqn">\lambda_1 \ge \lambda_2 \ge \cdots \lambda_r</code> 


</p>
</li>
<li> <p><code class="reqn">\mathbf{V}</code> is an <code class="reqn">r \times p</code> orthonormal matrix of variable weights and also the eigenvectors
of <code class="reqn">\mathbf{X}' \mathbf{X}</code>.
</p>
</li></ul>

<p>Then, a rank 2 (or 3) PCA approximation <code class="reqn">\widehat{\mathbf{X}}</code> to the data matrix used in the biplot
can be obtained from the first 2 (or 3)
singular values <code class="reqn">\lambda_i</code>
and the corresponding <code class="reqn">\mathbf{u}_i, \mathbf{v}_i</code> as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{X} \approx \widehat{\mathbf{X}} = \lambda_1 \mathbf{u}_1 \mathbf{v}_1' + \lambda_2 \mathbf{u}_2 \mathbf{v}_2' \; .</code>
</p>

<p>The variance of <code class="reqn">\mathbf{X}</code> accounted for by each term is <code class="reqn">\lambda_i^2</code>.
</p>
<p>The biplot is then obtained by overlaying two scatterplots that share a common set of axes and have a between-set scalar 
product interpretation. Typically, the observations (rows of <code class="reqn">\mathbf{X}</code>) are represented as points
and the variables (columns of <code class="reqn">\mathbf{X}</code>) are represented as vectors from the origin.
</p>
<p>The <code>scale</code> factor, <code class="reqn">\alpha</code> allows the variances of the components to be apportioned between the
row points and column vectors, with different interpretations, by representing the approximation
<code class="reqn">\widehat{\mathbf{X}}</code> as the product of two matrices,
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\mathbf{X}} = (\mathbf{U} \mathbf{\Lambda}^\alpha) (\mathbf{\Lambda}^{1-\alpha} \mathbf{V}')</code>
</p>

<p>The choice <code class="reqn">\alpha = 1</code>, assigning the singular values totally to the left factor,
gives a distance interpretation to the row display and 
<code class="reqn">\alpha = 0</code> gives a distance interpretation to the column display.
<code class="reqn">\alpha = 1/2</code> gives a symmetrically scaled biplot.
</p>
<p>When the singular values are assigned totally to the left or to the right factor, the resultant 
coordinates are called <em>principal coordinates</em> and the sum of squared coordinates
on each dimension equal the corresponding singular value.
The other matrix, to which no part of the singular 
values is assigned, contains the so-called <em>standard coordinates</em> and have sum of squared
values equal to 1.0.
</p>


<h3>Value</h3>

<p>a ggplot2 plot object of class <code>c("gg", "ggplot")</code>
</p>


<h3>Author(s)</h3>

<p>Vincent Q. Vu.
</p>


<h3>References</h3>

<p>Gabriel, K. R. (1971). The biplot graphical display of matrices with application to principal component analysis. 
<em>Biometrika</em>, <b>58</b>, 453–467. <a href="https://doi.org/10.2307/2334381">doi:10.2307/2334381</a>.
</p>
<p>Gabriel, K. R. (1981). Biplot display of multivariate matrices for inspection of data and diagnosis. 
In V. Barnett (Ed.), <em>Interpreting Multivariate Data</em>. London: Wiley. 
</p>
<p>Greenacre, M. (2010). <em>Biplots in Practice</em>. BBVA Foundation, Bilbao, Spain. 
Available for free at <a href="https://www.fbbva.es/microsite/multivariate-statistics/">https://www.fbbva.es/microsite/multivariate-statistics/</a>.
</p>
<p>J.C. Gower and D. J. Hand (1996). <em>Biplots</em>. Chapman &amp; Hall.
</p>
<p>Gower, J. C., Lubbe, S. G., &amp; Roux, N. J. L. (2011). <em>Understanding Biplots</em>. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reflect">reflect</a></code>, <code><a href="#topic+ggscreeplot">ggscreeplot</a></code>;
<code><a href="stats.html#topic+biplot">biplot</a></code> for the original stats package version;
<code><a href="factoextra.html#topic+fviz_pca_biplot">fviz_pca_biplot</a></code> for the factoextra package version.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)
library(ggplot2)
wine.pca &lt;- prcomp(wine, scale. = TRUE)
ggbiplot(wine.pca, 
         obs.scale = 1, var.scale = 1, 
         varname.size = 4,
         groups = wine.class, 
         ellipse = TRUE, circle = TRUE)

data(iris)
iris.pca &lt;- prcomp (~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width,
                    data=iris,
                    scale. = TRUE)
ggbiplot(iris.pca, obs.scale = 1, var.scale = 1,
         groups = iris$Species, point.size=2,
         varname.size = 5, 
         varname.color = "black",
         varname.adjust = 1.2,
         ellipse = TRUE, 
         circle = TRUE) +
  labs(fill = "Species", color = "Species") +
  theme_minimal(base_size = 14) +
  theme(legend.direction = 'horizontal', legend.position = 'top')
</code></pre>

<hr>
<h2 id='ggscreeplot'>Screeplot for Principal Components</h2><span id='topic+ggscreeplot'></span>

<h3>Description</h3>

<p>Produces scree plots (Cattell, 1966) of the variance proportions explained by each dimension against dimension number from 
various PCA-like dimension reduction techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggscreeplot(
  pcobj,
  type = c("pev", "cev"),
  size = 4,
  shape = 19,
  color = "black",
  linetype = 1,
  linewidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggscreeplot_+3A_pcobj">pcobj</code></td>
<td>
<p>an object returned by <code><a href="stats.html#topic+prcomp">prcomp</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code>, 
<code><a href="FactoMineR.html#topic+PCA">PCA</a></code>, <code><a href="ade4.html#topic+dudi.pca">dudi.pca</a></code>, or <code><a href="MASS.html#topic+lda">lda</a></code></p>
</td></tr>
<tr><td><code id="ggscreeplot_+3A_type">type</code></td>
<td>
<p>the type of scree plot, one of <code>c('pev', 'cev')</code>.
<code>'pev'</code> plots the proportion of explained variance, i.e. the eigenvalues divided by the trace. 
<code>'cev'</code> plots the cumulative proportion of explained variance, i.e. the partial sum of the first k eigenvalues divided by the trace.</p>
</td></tr>
<tr><td><code id="ggscreeplot_+3A_size">size</code></td>
<td>
<p>point size</p>
</td></tr>
<tr><td><code id="ggscreeplot_+3A_shape">shape</code></td>
<td>
<p>shape of the points. Default: 19, a filled circle.</p>
</td></tr>
<tr><td><code id="ggscreeplot_+3A_color">color</code></td>
<td>
<p>color for points and line. Default: <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="ggscreeplot_+3A_linetype">linetype</code></td>
<td>
<p>type of line</p>
</td></tr>
<tr><td><code id="ggscreeplot_+3A_linewidth">linewidth</code></td>
<td>
<p>width of line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object with the aesthetics <code>x = PC, y = yvar</code>
</p>


<h3>References</h3>

<p>Cattell, R. B. (1966). The Scree Test For The Number Of Factors. <em>Multivariate Behavioral Research</em>, 1, 245–276.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)
wine.pca &lt;- prcomp(wine, scale. = TRUE)
ggscreeplot(wine.pca)

# show horizontal lines for 80, 90% of cumulative variance
ggscreeplot(wine.pca, type = "cev") +
  geom_hline(yintercept = c(0.8, 0.9), color = "blue") 

# Make a fancy screeplot, higlighting the scree starting at component 4
data(crime)
crime.pca &lt;- 
  crime |&gt; 
  dplyr::select(where(is.numeric)) |&gt;
  prcomp(scale. = TRUE)
  
(crime.eig &lt;- crime.pca |&gt; 
   broom::tidy(matrix = "eigenvalues"))

ggscreeplot(crime.pca) +
  stat_smooth(data = crime.eig |&gt; dplyr::filter(PC&gt;=4), 
              aes(x=PC, y=percent), method = "lm", 
              se = FALSE,
              fullrange = TRUE) 

</code></pre>

<hr>
<h2 id='reflect'>Reflect Columns in a Principal Component-like Object</h2><span id='topic+reflect'></span>

<h3>Description</h3>

<p>Principle component-like objects have variable loadings (the eigenvectors of the covariance/correlation matrix)
whose signs are arbitrary, in the sense that a given column can be 
reflected (multiplied by -1) without changing the fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reflect(pcobj, columns = 1:2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reflect_+3A_pcobj">pcobj</code></td>
<td>
<p>an object returned by <code><a href="stats.html#topic+prcomp">prcomp</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code>, 
<code><a href="FactoMineR.html#topic+PCA">PCA</a></code>, or <code><a href="MASS.html#topic+lda">lda</a></code></p>
</td></tr>
<tr><td><code id="reflect_+3A_columns">columns</code></td>
<td>
<p>a vector of indices of the columns to reflect</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows one to reflect any columns of the variable
loadings (and corresponding observation scores). Coordinates for quantitative
supplementary variables are also reflected if present.
This is often
useful for interpreting a biplot, for example when a component (often the first) has all negative signs.
</p>


<h3>Value</h3>

<p>The pca-like object with specified columns of the 
variable loadings and observation scores multiplied
by -1.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prcomp">prcomp</a></code>,  <code><a href="stats.html#topic+princomp">princomp</a></code>, 
<code><a href="FactoMineR.html#topic+PCA">PCA</a></code>, <code><a href="MASS.html#topic+lda">lda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crime)
crime.pca &lt;- 
  crime |&gt; 
  dplyr::select(where(is.numeric)) |&gt;
  prcomp(scale. = TRUE)
  
 biplot(crime.pca)
 
 crime.pca &lt;- reflect(crime.pca)  # reflect columns 1:2
 biplot(crime.pca)
</code></pre>

<hr>
<h2 id='wine'>Wine dataset</h2><span id='topic+wine'></span><span id='topic+wine.class'></span>

<h3>Description</h3>

<p>Results of a chemical analysis of wines grown in the same region in Italy,
derived from three different cultivars. The analysis determined the 
quantities of 13 chemical constituents found in each of the three types of wines. 
</p>
<p>The grape varieties (cultivars), 'barolo', 'barbera', and 'grignolino', are indicated in <code>wine.class</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wine)
</code></pre>


<h3>Format</h3>

<p>A <code>wine</code> data frame consisting of 178 observations (rows) and
13 columns and vector <code>wine.class</code> of factors indicating the cultivars.
The variables are:
</p>

<dl>
<dt><code>Alcohol</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MalicAcid</code></dt><dd><p>Malic acid, a numeric vector</p>
</dd>
<dt><code>Ash</code></dt><dd><p>Ash, a numeric vector</p>
</dd>
<dt><code>AlcAsh</code></dt><dd><p>Alcalinity of ash, a numeric vector</p>
</dd>
<dt><code>Mg</code></dt><dd><p>Magnesium, a numeric vector</p>
</dd>
<dt><code>Phenols</code></dt><dd><p>total phenols, a numeric vector</p>
</dd>
<dt><code>Flav</code></dt><dd><p>Flavanoids, a numeric vector</p>
</dd>
<dt><code>NonFlavPhenols</code></dt><dd><p>Nonflavanoid phenols, a numeric vector</p>
</dd>
<dt><code>Proa</code></dt><dd><p>Proanthocyanins, a numeric vector</p>
</dd>
<dt><code>Color</code></dt><dd><p>Color intensity, a numeric vector</p>
</dd>
<dt><code>Hue</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>OD</code></dt><dd><p>D280/OD315 of diluted wines, a numeric vector</p>
</dd>
<dt><code>Proline</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>UCI Machine Learning Repository (<a href="http://archive.ics.uci.edu/ml/datasets/Wine">http://archive.ics.uci.edu/ml/datasets/Wine</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)
table(wine.class)

wine.pca &lt;- prcomp(wine, scale. = TRUE)
ggscreeplot(wine.pca)                                               
ggbiplot(wine.pca, 
         obs.scale = 1, var.scale = 1, 
         groups = wine.class, ellipse = TRUE, circle = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
