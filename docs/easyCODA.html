<!DOCTYPE html><html lang="en"><head><title>Help for package easyCODA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {easyCODA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#easyCODA-package'>
<p>Compositional Data Analysis in Practice</p></a></li>
<li><a href='#ACLUST'>
<p>Amalgamation clustering of the parts of a compositional data matrix</p></a></li>
<li><a href='#ALR'>
<p>Additive logratios</p></a></li>
<li><a href='#BAR'>
<p>Compositional bar plot</p></a></li>
<li><a href='#CA'>
<p>Correspondence analysis</p></a></li>
<li><a href='#CIplot_biv'>
<p>Bivariate confidence and data ellipses</p></a></li>
<li><a href='#CLOSE'>
<p>Closure of rows of compositional data matrix</p></a></li>
<li><a href='#CLR'>
<p>Centred logratios</p></a></li>
<li><a href='#cups'><p>Dataset: RomanCups</p></a></li>
<li><a href='#DOT'>
<p>Dot plot</p></a></li>
<li><a href='#DUMMY'>
<p>Dummy variable (indicator) coding</p></a></li>
<li><a href='#FINDALR'>
<p>Find the best ALR transformation</p></a></li>
<li><a href='#fish'><p>Dataset: FishMorphology</p></a></li>
<li><a href='#ILR'>
<p>Isometric logratio</p></a></li>
<li><a href='#invALR'>
<p>Inverse of additive logratios</p></a></li>
<li><a href='#invCLR'>
<p>Inverse of centred logratios</p></a></li>
<li><a href='#invSLR'>
<p>Inverse of full set of amalgamation balances</p></a></li>
<li><a href='#LR'>
<p>All pairwise logratios</p></a></li>
<li><a href='#LR.VAR'>
<p>Total logratio variance</p></a></li>
<li><a href='#LRA'>
<p>Logratio analysis</p></a></li>
<li><a href='#PCA'>
<p>Principal component analysis</p></a></li>
<li><a href='#PLOT.CA'>
<p>Plot the results of a correspondence analysis</p></a></li>
<li><a href='#PLOT.LRA'>
<p>Plot the results of a logratio analysis</p></a></li>
<li><a href='#PLOT.PCA'>
<p>Plot the results of a principal component analysis</p></a></li>
<li><a href='#PLOT.RDA'>
<p>Plot the results of a redundancy analysis</p></a></li>
<li><a href='#PLR'>
<p>Pivot logratios</p></a></li>
<li><a href='#RDA'>
<p>Redundancy analysis</p></a></li>
<li><a href='#SLR'>
<p>Amalgamation (summed) logratio</p></a></li>
<li><a href='#STEP'>
<p>Stepwise selection of logratios</p></a></li>
<li><a href='#STEPR'>
<p>Stepwise selection of pairwise logratios for generalized linear modelling</p></a></li>
<li><a href='#time'><p>Dataset: TimeBudget</p></a></li>
<li><a href='#VAR'>
<p>Variance of a vector of observations, dividing by n rather than n-1</p></a></li>
<li><a href='#veg'><p>Dataset: Vegetables</p></a></li>
<li><a href='#WARD'>
<p>Ward clustering of a compositional data matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.40.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Compositional Data Analysis in Practice</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Greenacre [aut, cre]</td>
</tr>
<tr>
<td>Imports:</td>
<td>ca (&ge; 0.7), vegan (&ge; 2.3), ellipse (&ge; 0.4.1)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Greenacre &lt;michael.greenacre@upf.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Univariate and multivariate methods for compositional data 
    analysis, based on logratios. The package implements the approach in the
    book Compositional Data Analysis in Practice by Michael Greenacre (2018),
    where accent is given to simple pairwise logratios. Selection can be made
    of logratios that account for a maximum percentage of logratio variance.
    Various multivariate analyses of logratios are included in the package. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/michaelgreenacre/CODAinPractice/">https://github.com/michaelgreenacre/CODAinPractice/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-27 14:25:12 UTC; rforge</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>easycoda</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>53</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2024-08-27 14:20:20</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-27 15:00:05 UTC</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
</table>
<hr>
<h2 id='easyCODA-package'>
Compositional Data Analysis in Practice
</h2><span id='topic+easyCODA-package'></span>

<h3>Description</h3>

<p>Univariate and multivariate methods for compositional data 
    analysis, based on logratios. The package implements the approach in the
    book Compositional Data Analysis in Practice by Michael Greenacre (2018),
    where accent is given to simple pairwise logratios. Selection can be made
    of logratios that account for a maximum percentage of logratio variance.
    Various multivariate analyses of logratios are included in the package. 
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> easyCODA</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.40.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-08-25</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Compositional Data Analysis in Practice</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given = "Michael",
                    family = "Greenacre",
                    role = c("aut", "cre"),
                    email = "michael.greenacre@upf.edu")</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Michael Greenacre [aut, cre]</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> ca (&gt;= 0.7), vegan (&gt;= 2.3), ellipse (&gt;= 0.4.1)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Michael Greenacre &lt;michael.greenacre@upf.edu&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Univariate and multivariate methods for compositional data 
    analysis, based on logratios. The package implements the approach in the
    book Compositional Data Analysis in Practice by Michael Greenacre (2018),
    where accent is given to simple pairwise logratios. Selection can be made
    of logratios that account for a maximum percentage of logratio variance.
    Various multivariate analyses of logratios are included in the package. </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/michaelgreenacre/CODAinPractice/</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2024-08-25 20:08:18 UTC; u16368</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> R-Forge</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository/R-Forge/Project: </td><td style="text-align: left;"> easycoda</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository/R-Forge/Revision: </td><td style="text-align: left;"> 53</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository/R-Forge/DateTimeStamp: </td><td style="text-align: left;"> 2024-08-27 14:20:20</td>
</tr>
<tr>
 <td style="text-align: left;">
Date/Publication: </td><td style="text-align: left;"> 2024-08-27 14:20:20</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
ACLUST                  Amalgamation clustering of the parts of a
                        compositional data matrix
ALR                     Additive logratios
BAR                     Compositional bar plot
CA                      Correspondence analysis
CIplot_biv              Bivariate confidence and data ellipses
CLOSE                   Closure of rows of compositional data matrix
CLR                     Centred logratios
DOT                     Dot plot
DUMMY                   Dummy variable (indicator) coding
FINDALR                 Find the best ALR transformation
ILR                     Isometric logratio
LR                      All pairwise logratios
LR.VAR                  Total logratio variance
LRA                     Logratio analysis
PCA                     Principal component analysis
PLOT.CA                 Plot the results of a correspondence analysis
PLOT.LRA                Plot the results of a logratio analysis
PLOT.PCA                Plot the results of a principal component
                        analysis
PLOT.RDA                Plot the results of a redundancy analysis
PLR                     Pivot logratios
RDA                     Redundancy analysis
SLR                     Amalgamation (summed) logratio
STEP                    Stepwise selection of logratios
STEPR                   Stepwise selection of pairwise logratios for
                        generalized linear modelling
VAR                     Variance of a vector of observations, dividing
                        by n rather than n-1
WARD                    Ward clustering of a compositional data matrix
cups                    Dataset: RomanCups
easyCODA-package        Compositional Data Analysis in Practice
fish                    Dataset: FishMorphology
invALR                  Inverse of additive logratios
invCLR                  Inverse of centred logratios
invSLR                  Inverse of full set of amalgamation balances
time                    Dataset: TimeBudget
veg                     Dataset: Vegetables
</pre>


<h3>Author(s)</h3>

<p>Michael Greenacre [aut, cre]
</p>
<p>Maintainer: Michael Greenacre &lt;michael.greenacre@upf.edu&gt;
</p>


<h3>References</h3>

<p>Greenacre, Michael (2018) Compositional Data Analysis in Practice. Chapman &amp; Hall / CRC Press
</p>


<h3>See Also</h3>

<p><code><a href="ca.html#topic+ca">ca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Roman cups glass compositions
data("cups")
# unweighted logratio analysis
cups.ulra &lt;- LRA(cups, weight=FALSE)
PLOT.LRA(cups.ulra)
# weighted logratio analysis
cups.wlra &lt;- LRA(cups)
PLOT.LRA(cups.wlra)
</code></pre>

<hr>
<h2 id='ACLUST'>
Amalgamation clustering of the parts of a compositional data matrix
</h2><span id='topic+ACLUST'></span>

<h3>Description</h3>

<p>This function clusters the parts of a compositional data matrix, using amalgamation of the parts at each step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACLUST(data, weight = TRUE, close = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACLUST_+3A_data">data</code></td>
<td>

<p>Compositional data matrix, with the parts as columns
</p>
</td></tr>
<tr><td><code id="ACLUST_+3A_weight">weight</code></td>
<td>

<p><code>TRUE</code> (default) for weighting using part averages of closed compositions, <code>FALSE</code> for unweighted analysis, or a vector of user-defined column weights
</p>
</td></tr>
<tr><td><code id="ACLUST_+3A_close">close</code></td>
<td>

<p><code>TRUE</code> (default) will close the rows of <code>data</code> prior to clustering, <code>FALSE</code> leaves <code>data</code> as it is
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>ACLUST</code> performs amalgamation hierarchical clustering on the parts (columns) of a given compositional data matrix, as proposed by Greenacre (2019).
At each step of the clustering two clusters are amalgamated that give the least loss of explained logratio variance.
</p>


<h3>Value</h3>

<p>An object which describes the tree produced by the clustering process on the n objects. The object is a list with components:
</p>
<table role = "presentation">
<tr><td><code>merge</code></td>
<td>
<p>an n-1 by 2 matrix. Row i of <code>merge</code> describes the merging of clusters at step i of the clustering. If an element j in the row is negative, then observation -j was merged at this stage. If j is positive then the merge was with the cluster formed at the (earlier) stage j of the algorithm. Thus negative entries in <code>merge</code> indicate agglomerations of singletons, and positive entries indicate agglomerations of non-singletons.</p>
</td></tr>
<tr><td><code>height</code></td>
<td>
<p>a set of n-1 real values (non-decreasing for ultrametric trees). The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>a vector giving the permutation of the original observations suitable for plotting, in the sense that a cluster plot using this ordering and matrix merge will not have crossings of the branches</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>a vector of column labels, the column names of <code>data</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC. <br />
Greenacre, M. (2019), Amalgamations are valid in compositional data analysis,
can be used in agglomerative clustering, and their
logratios have an inverse transformation.
Applied Computing and Geosciences, open access.<br />
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+WARD">WARD</a></code>,<code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+LR.VAR">LR.VAR</a></code>,
<code><a href="#topic+CLOSE">CLOSE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cups)

# amalgamation clustering    (weighted parts)
cups.aclust &lt;- ACLUST(cups)
plot(cups.aclust)

# reproducing Figure 2(b) of Greenacre (2019) (unweighted parts))
# dataset Aar is in the compositions package
# aar is a subset of Aar
# code given here within the '\dontrun' environment since external package 'compositions' required
## Not run: 
  library(compositions)
  data(Aar)
  aar &lt;- Aar[,c(3:12)]
  aar.aclust &lt;- ACLUST(aar, weight=FALSE)
# the maximum height is the total variance
# convert to percents of variance NOT explained
  aar.aclust$height &lt;- 100 * aar.aclust$height / max(aar.aclust$height)
  plot(aar.aclust, main="Parts of Unexplained Variance", ylab="Variance (percent)")

## End(Not run)
</code></pre>

<hr>
<h2 id='ALR'>
Additive logratios
</h2><span id='topic+ALR'></span>

<h3>Description</h3>

<p>Computation of additive logratios (ALRs) with respect to a specified part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ALR(data, denom=ncol(data), weight=TRUE, stats=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ALR_+3A_data">data</code></td>
<td>

<p>A compositional data frame or matrix 
</p>
</td></tr>
<tr><td><code id="ALR_+3A_denom">denom</code></td>
<td>

<p>Number of part used in the denominator
</p>
</td></tr>
<tr><td><code id="ALR_+3A_weight">weight</code></td>
<td>

<p>Logical indicating if varying weights are returned(default:<code>TRUE</code>). If <code>FALSE</code>, unweighted (equal) weights are returned. Alternatively a set of positive weights can be specified.
</p>
</td></tr>
<tr><td><code id="ALR_+3A_stats">stats</code></td>
<td>

<p>Logical indicating if means, variances and total variance of the ALRs are returned (default:<code>FALSE</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>ALR</code> computes a set of additive logratios (ALRs) with respect to a specified part (by default, the last part). 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>LR</code></td>
<td>

<p>The additive logratios (ALRs)
</p>
</td></tr>
<tr><td><code>LR.wt</code></td>
<td>

<p>The weights assigned to the ALRs
</p>
</td></tr>
<tr><td><code>denom</code></td>
<td>

<p>The index of the denominator used in the computation of the ALRs 
</p>
</td></tr>
<tr><td><code>part.names</code></td>
<td>

<p>The part names in the data, i.e. column names 
</p>
</td></tr>
<tr><td><code>part.wt</code></td>
<td>

<p>The part weights 
</p>
</td></tr>
<tr><td><code>means</code></td>
<td>

<p>The means of the ALRs (only returned if <code>stats = TRUE</code>)
</p>
</td></tr>
<tr><td><code>vars</code></td>
<td>

<p>The variances of the ALRs (only returned if <code>stats = TRUE</code>)
</p>
</td></tr>
<tr><td><code>totvar</code></td>
<td>

<p>The total variance of the ALRs (only returned if <code>stats = TRUE</code>)
</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. (1986), The Statistical Analysis of Compositional Data, Chapman &amp; Hall. <br /> 
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+invALR">invALR</a></code>, <code><a href="#topic+LR">LR</a></code>, <code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+invCLR">invCLR</a></code>, <code><a href="#topic+LR.VAR">LR.VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veg)
ALR(veg, denom=2)
</code></pre>

<hr>
<h2 id='BAR'>
Compositional bar plot
</h2><span id='topic+BAR'></span>

<h3>Description</h3>

<p>Horizontal bar plot of compositional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BAR(data, cols=rainbow(ncol(data)), col.names=colnames(data),
    row.names=rownames(data), order.column=NA, eps=0.5, main="", ylab="",
    ylim=c(0,nrow(data)), xlim=c(0,100), cex=1, truncate=NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BAR_+3A_data">data</code></td>
<td>

<p>Compositional data matrix or data frame with compositions in rows, parts in columns
</p>
</td></tr>
<tr><td><code id="BAR_+3A_cols">cols</code></td>
<td>

<p>Colours of points for each part, default rainbow
</p>
</td></tr>
<tr><td><code id="BAR_+3A_col.names">col.names</code></td>
<td>

<p>Part names, if modified
</p>
</td></tr>
<tr><td><code id="BAR_+3A_row.names">row.names</code></td>
<td>

<p>Sample names, if modified
</p>
</td></tr>
<tr><td><code id="BAR_+3A_order.column">order.column</code></td>
<td>

<p>By default parts are taken in order of columns, but can be re-ordered using this option
</p>
</td></tr>
<tr><td><code id="BAR_+3A_eps">eps</code></td>
<td>

<p>Small space between bars, can be modified
</p>
</td></tr>
<tr><td><code id="BAR_+3A_main">main</code></td>
<td>

<p>Heading
</p>
</td></tr>
<tr><td><code id="BAR_+3A_ylab">ylab</code></td>
<td>

<p>Vertical axis label
</p>
</td></tr>
<tr><td><code id="BAR_+3A_ylim">ylim</code></td>
<td>

<p>Vertical axis limits (default is the number of rows in data)
</p>
</td></tr>
<tr><td><code id="BAR_+3A_xlim">xlim</code></td>
<td>

<p>Horizontal axis limits (default c(0,100))
</p>
</td></tr>
<tr><td><code id="BAR_+3A_cex">cex</code></td>
<td>

<p>Character size scaling factor for labels
</p>
</td></tr>
<tr><td><code id="BAR_+3A_truncate">truncate</code></td>
<td>

<p>Truncate part (column) names to this number of characters for legend
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>BAR</code> makes a BAR plot for specified groups of points, which can be in columns of a matrix or data frame. 
</p>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M. (2016), Data reporting and visualization in ecology, Polar Biology: 39, 2189-2205.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DOT">DOT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vegetables data set: order samples by carbohydrates 
data(veg)
BAR(veg, order.column=2)
data(time)
# TimeBudget data set: put domestic work in first column and order by it
BAR(time[,c(2,1,3,4,5,6)], order.column=1, main="Time Budget")
</code></pre>

<hr>
<h2 id='CA'>
Correspondence analysis
</h2><span id='topic+CA'></span>

<h3>Description</h3>

<p>Computation of correspondence analysis on a table of nonnegative data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CA(data, nd = 2, suprow = NA, supcol = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CA_+3A_data">data</code></td>
<td>

<p>A data frame or matrix of nonnegative data (no negative values)
</p>
</td></tr>
<tr><td><code id="CA_+3A_nd">nd</code></td>
<td>

<p>Number of dimensions for summary solution if not 2 (default)
</p>
</td></tr>
<tr><td><code id="CA_+3A_suprow">suprow</code></td>
<td>

<p>Indices of rows that are supplementary points
</p>
</td></tr>
<tr><td><code id="CA_+3A_supcol">supcol</code></td>
<td>

<p>Indices of columns that are supplementary points
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>CA</code> is a simple wrapper for the <code>ca</code> function in the <b>ca</b> package (Nenadic and Greenacre, 2007), for compatibility within the <b>easyCODA</b> package.
</p>
<p>Supplementary rows and columns can be declared (also known as passive points) &ndash; these do not contribute to the solution but are positioned on the solution axes.
</p>
<p>The function borrows the structure and functions of the <code>ca</code> package, which is required, and produces a <code>ca</code> object, and the same <code>print</code>, <code>summary</code> and <code>plot</code> methods can be used, as for a <code>ca</code> object.     
It additionally exports the principal coordinates of both the rows and columns, not presently found in the <code>ca</code> package.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sv</code></td>
<td>
<p>Singular values</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>Number of dimensions in solution results</p>
</td></tr>
<tr><td><code>rownames</code></td>
<td>
<p>Row names</p>
</td></tr>
<tr><td><code>rowmass</code></td>
<td>
<p>Row weights</p>
</td></tr>
<tr><td><code>rowdist</code></td>
<td>
<p>Row logratio distances to centroid</p>
</td></tr>
<tr><td><code>rowinertia</code></td>
<td>
<p>Row inertias</p>
</td></tr>
<tr><td><code>rowcoord</code></td>
<td>
<p>Row standard coordinates</p>
</td></tr>
<tr><td><code>rowpcoord</code></td>
<td>
<p>Row principal coordinates</p>
</td></tr>
<tr><td><code>rowsup</code></td>
<td>
<p>Indices of row supplementary points</p>
</td></tr>
<tr><td><code>colnames</code></td>
<td>
<p>Column names</p>
</td></tr>
<tr><td><code>colmass</code></td>
<td>
<p>Column weights</p>
</td></tr>
<tr><td><code>coldist</code></td>
<td>
<p>Column logratio distances to centroid</p>
</td></tr>
<tr><td><code>colinertia</code></td>
<td>
<p>Column inertias</p>
</td></tr>
<tr><td><code>colcoord</code></td>
<td>
<p>Column standard coordinates</p>
</td></tr>
<tr><td><code>colpcoord</code></td>
<td>
<p>Column principal coordinates</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>The compositional data table</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Nenadic, O. and Greenacre, M. (2007). Correspondence analysis in R, with two- and three-dimensional graphics: The ca package. <em>Journal of Statistical Software</em>, <b>20 (3)</b>, <a href="https://www.jstatsoft.org/v20/i03/">https://www.jstatsoft.org/v20/i03/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLOT.CA">PLOT.CA</a></code>, <code><a href="ca.html#topic+plot.ca">plot.ca</a></code>, <code><a href="ca.html#topic+summary.ca">summary.ca</a></code>, <code><a href="ca.html#topic+print.ca">print.ca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CA of the Roman cups data (symmetric map)
data("cups")
PLOT.CA(CA(cups))
</code></pre>

<hr>
<h2 id='CIplot_biv'>
Bivariate confidence and data ellipses
</h2><span id='topic+CIplot_biv'></span>

<h3>Description</h3>

<p>Draws confidence and data ellipses in bivariate scatterplots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIplot_biv(x, y, group, wt=rep(1/length(x),length(x)), 
           varnames=c("x","y"), groupnames=sort(unique(group)), 
           groupcols=rainbow(length(unique(group))), 
           shownames=TRUE, xlim=c(NA,NA), ylim=c(NA,NA), 
           lty=1, lwd=1, add=FALSE, alpha=0.95, ellipse=0, 
           shade=FALSE, alpha.f=0.2, frac=0.01, cex=1) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CIplot_biv_+3A_x">x</code></td>
<td>

<p>x-variable (horizontal) of scatterplot
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_y">y</code></td>
<td>

<p>y-variable (vertical) of scatterplot
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_group">group</code></td>
<td>

<p>Grouping variable
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_wt">wt</code></td>
<td>

<p>Set of weights on the cases (operates when ellipse=1)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_varnames">varnames</code></td>
<td>

<p>Vector of two labels for the axes (default is x and y)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_groupnames">groupnames</code></td>
<td>

<p>Vector of labels for the groups (default is 1, 2, etc...)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_groupcols">groupcols</code></td>
<td>

<p>Vector of colours for the groups
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_shownames">shownames</code></td>
<td>

<p>Whether to show group names at group centroids or not (default is <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_xlim">xlim</code></td>
<td>

<p>Possible new x-limits for plot
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_ylim">ylim</code></td>
<td>

<p>Possible new y-limits for plot
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_lty">lty</code></td>
<td>

<p>Line type for the ellipses (default is 1)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_lwd">lwd</code></td>
<td>

<p>Line width for the ellipses (default is 1)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_add">add</code></td>
<td>

<p>=<code>TRUE</code> if ellipses/intervals are added to existing plot (default is <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_alpha">alpha</code></td>
<td>

<p>Confidence level of ellipses (default is 0.95)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_ellipse">ellipse</code></td>
<td>

<p>Type of ellipse (see Details below; default is 0 for normal-based ellipses)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_shade">shade</code></td>
<td>

<p>=<code>TRUE</code> for ellipse shading (default=<code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_alpha.f">alpha.f</code></td>
<td>

<p>Shading fraction (default is 0.2)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_frac">frac</code></td>
<td>

<p>Proportional part defining the width of the bars at the edges of confidence intervals (for <code>ellipse=3</code> and <code>4</code>)
</p>
</td></tr>
<tr><td><code id="CIplot_biv_+3A_cex">cex</code></td>
<td>

<p>Character expansion factor for group names
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>CIplot_biv</code> makes various types of confidence and data ellipses, according to option <code>ellipse</code>. Set <code>ellipse&lt;0</code> for regular data-covering ellipses. Set <code>ellipse=0</code> (default) for normal-theory confidence ellipses. Set<code>ellipse=1</code> for bootstrap confidence ellipses. The option <code>ellipse=2</code> for the delta method is not implemented yet.  Set <code>ellipse=3</code> for normal-theory confidence error bars lined up with axes. Set <code>ellipse=4</code> for bootstrap confidence error bars along axes.  The package <code>ellipse</code> is required.
</p>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M. (2016), Data reporting and visualization in ecology, Polar Biology, 39:2189-2205.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DOT">DOT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some bivariate normal data in three groups with different means
# Means (1,0), (0,1) and (0,0)
means  &lt;- matrix(c(1,0,0,1,0,0), ncol=3)
data   &lt;- matrix(nrow=300, ncol=2)
groups &lt;- sample(rep(c(1,2,3), 100))
for(i in 1:300) data[i,] &lt;- rnorm(c(1,1), mean=means[,groups[i]])
# Plot confidence ellipses with shading
CIplot_biv(data[,1], data[,2], group=groups, shade=TRUE)
</code></pre>

<hr>
<h2 id='CLOSE'>
Closure of rows of compositional data matrix
</h2><span id='topic+CLOSE'></span>

<h3>Description</h3>

<p>This function closes (or normalizes) the rows of a compositional data matrix, resulting in rows summing to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CLOSE(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CLOSE_+3A_x">x</code></td>
<td>

<p>Compositional data matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compositional data carry relative information. It is sometimes required to close the data so that each row of observations sums to 1.
The function <code>CLOSE</code> performs the closure.
</p>


<h3>Value</h3>

<p>The closed compositional data matrix.
</p>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cups)
apply(cups, 2, sum)
cups &lt;- CLOSE(cups)
apply(cups, 2, sum)
</code></pre>

<hr>
<h2 id='CLR'>
Centred logratios
</h2><span id='topic+CLR'></span>

<h3>Description</h3>

<p>Computation of centred logratios (CLRs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CLR(data, weight=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CLR_+3A_data">data</code></td>
<td>

<p>A compositional data frame or matrix 
</p>
</td></tr>
<tr><td><code id="CLR_+3A_weight">weight</code></td>
<td>

<p>Logical indicating if varying weights are returned(default:<code>TRUE</code>). If <code>FALSE</code>, unweighted (equal) weights are returned. Alternatively a set of positive weights can be specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>CLR</code> computes the set of centred logratios (CLRs). 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>LR</code></td>
<td>

<p>The centred logratios (CLRs)
</p>
</td></tr>
<tr><td><code>LR.wt</code></td>
<td>

<p>The weights assigned to the CLRs
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. (1986), The Statistical Analysis of Compositional Data, Chapman &amp; Hall. <br />
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+invCLR">invCLR</a></code>, <code><a href="#topic+ALR">ALR</a></code>, <code><a href="#topic+invALR">invALR</a></code>, <code><a href="#topic+LR">LR</a></code>, <code><a href="#topic+LR.VAR">LR.VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veg)
CLR(veg)
</code></pre>

<hr>
<h2 id='cups'>Dataset: RomanCups</h2><span id='topic+cups'></span>

<h3>Description</h3>

<p>This data set consists of the compositions of 11 oxides in 47 Roman cups found at an archaeological site in eastern England. Compositions are expressed as percentages.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cups)</code></pre>


<h3>Format</h3>

<p>Data frame containing the 47 x 11 matrix.</p>


<h3>Source</h3>

<p>Baxter MJ, Beardah CC, Cool HEM and Jackson CM (2005) Compositional data analysis of some alkaline glasses. Mathematical Geology 37: 183-196.</p>

<hr>
<h2 id='DOT'>
Dot plot
</h2><span id='topic+DOT'></span>

<h3>Description</h3>

<p>Simple dot plot of original data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DOT(data, cols=NA, names=NA, groups=NA, pch=NA, horizon=FALSE, jitter=1, 
     xscale=NA, xscalefac=1, yaxis=TRUE, shownames=TRUE, main="", ylab="", 
     xlim=c(NA,NA), ylim=c(NA, NA), cex=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DOT_+3A_data">data</code></td>
<td>

<p>Matrix or data frame with data groups in columns; alternatively, a single vector but then groups (if any) have to specified with the <code>groups</code> option 
</p>
</td></tr>
<tr><td><code id="DOT_+3A_cols">cols</code></td>
<td>

<p>Colours of points for each sample, default rainbow
</p>
</td></tr>
<tr><td><code id="DOT_+3A_names">names</code></td>
<td>

<p>Labels for variables, by default the column names of data, or group names
</p>
</td></tr>
<tr><td><code id="DOT_+3A_groups">groups</code></td>
<td>

<p>Group codes to split the data vector into separate plots
</p>
</td></tr>
<tr><td><code id="DOT_+3A_pch">pch</code></td>
<td>

<p>Point character
</p>
</td></tr>
<tr><td><code id="DOT_+3A_horizon">horizon</code></td>
<td>

<p><code>TRUE</code> if horizontal gray dashed lines required at &quot;nice&quot; y-values (default FALSE, not implemented yet)
</p>
</td></tr>
<tr><td><code id="DOT_+3A_jitter">jitter</code></td>
<td>

<p>1 by default, increase or decrease slightly for more jitter
</p>
</td></tr>
<tr><td><code id="DOT_+3A_xscale">xscale</code></td>
<td>

<p>User-supplied positions of points on horizontal axis
</p>
</td></tr>
<tr><td><code id="DOT_+3A_xscalefac">xscalefac</code></td>
<td>

<p>1 by default, rescale the positions on horizontal axis
</p>
</td></tr>
<tr><td><code id="DOT_+3A_yaxis">yaxis</code></td>
<td>

<p>TRUE by default, FALSE to suppress and optionally add afterwards
</p>
</td></tr>
<tr><td><code id="DOT_+3A_shownames">shownames</code></td>
<td>

<p><code>TRUE</code> by default; <code>FALSE</code> to not show group names and add them externally
</p>
</td></tr>
<tr><td><code id="DOT_+3A_main">main</code></td>
<td>

<p>Heading
</p>
</td></tr>
<tr><td><code id="DOT_+3A_ylab">ylab</code></td>
<td>

<p>Vertical axis label
</p>
</td></tr>
<tr><td><code id="DOT_+3A_xlim">xlim</code></td>
<td>

<p>Horizontal axis limits 
</p>
</td></tr>
<tr><td><code id="DOT_+3A_ylim">ylim</code></td>
<td>

<p>Vertical axis limits 
</p>
</td></tr>
<tr><td><code id="DOT_+3A_cex">cex</code></td>
<td>

<p>Character size adjustment for labels
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>DOT</code> makes a dot plot for specified groups of points, which can be in columns of a matrix or data frame, or in a single vector with group codes specified separately. 
</p>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M. (2016), Data reporting and visualization in ecology, Polar Biology, 39:2189-2205.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BAR">BAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Dot plot of columns of Vegetables data set
data(veg)
DOT(veg)
# Dot plot of domestic work column of TimeBudget data set, split by sex
data(time)
DOT(time[,2], groups=substr(rownames(time),3,3), cols=c("blue","red"), ylim=c(0,20), 
    jitter=2, main="Percentage of Domestic Work")
</code></pre>

<hr>
<h2 id='DUMMY'>
Dummy variable (indicator) coding
</h2><span id='topic+DUMMY'></span>

<h3>Description</h3>

<p>Convert categorical variable to dummy (0/1) coding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DUMMY(x, catnames=NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DUMMY_+3A_x">x</code></td>
<td>

<p>Variable (vector) of categorical data to be coded
</p>
</td></tr>
<tr><td><code id="DUMMY_+3A_catnames">catnames</code></td>
<td>

<p>Category names
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>DUMMY</code> takes a categorical variable and converts it to a set of dummy variables (zeros and ones), where the ones indicate the corresponding category. There are as many columns in the result as there are unique categories in the input vector. 
</p>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Indicator (dummy) coding of sex in FishMorphology data set
data(fish)
sex   &lt;- fish[,1]
sex.Z &lt;- DUMMY(sex, catnames=c("F","M")) 
</code></pre>

<hr>
<h2 id='FINDALR'>
Find the best ALR transformation
</h2><span id='topic+FINDALR'></span>

<h3>Description</h3>

<p>Searching over every possible reference part for choosing an optimal ALR transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FINDALR(data, weight=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FINDALR_+3A_data">data</code></td>
<td>

<p>Compositional data matrix, with the parts as columns
</p>
</td></tr>
<tr><td><code id="FINDALR_+3A_weight">weight</code></td>
<td>

<p>FALSE (default) for equally weighted parts, TRUE when weights are in data list object, or a vector of user-defined part weights
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>FINDALR</code> considers every possible set of additive logratio (ALR) transformations, by trying each of the references. For each set the closeness to isometry is measured by the Procrustes correlation. In addition, the variance of the log-transformed reference is also computed. The reference with highest Procrustes correlation and the reference with the lowest variance of its log-transform are identified. The number of ALRs computed is equal to 1 less than the number of rows or columns, whichever is the smallest.
</p>


<h3>Value</h3>

<p>An object which describes the tree produced by the clustering process on the n objects. The object is a list with components:
</p>
<table role = "presentation">
<tr><td><code>totvar</code></td>
<td>
<p>Total logratio variance</p>
</td></tr>
<tr><td><code>procrust.cor</code></td>
<td>
<p>The Procrustes correlations of the ALRs using each reference</p>
</td></tr>
<tr><td><code>procrust.max</code></td>
<td>
<p>The value of the highest Procrustes correlation</p>
</td></tr>
<tr><td><code>procrust.ref</code></td>
<td>
<p>The reference corresponding to the highest correlation</p>
</td></tr>
<tr><td><code>var.log</code></td>
<td>
<p>Variances of the log-transformed references</p>
</td></tr>
<tr><td><code>var.min</code></td>
<td>
<p>The value of the lowest variance</p>
</td></tr>
<tr><td><code>var.ref</code></td>
<td>
<p>The reference corresponding to the lowest variance</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M., Martinez-Alvaro, M. and Blasco, A. (2021), Compositional data analysis of microbiome and any-omics datasets: a validation of the additive logratio transformation, Frontiers in Microbiology 12: 2625 <br />
Gower, J. and Dijksterhuis, G.B. (2004), Procrustes Problems. Oxford University Press   <br />
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ALR">ALR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the fish morphometric data, first close (normalize) 
# then loop over the 26 possible references
data(fish)
FINDALR(CLOSE(fish[,4:29]))
# Note that for the default option weight=FALSE closing the data is not necessary
</code></pre>

<hr>
<h2 id='fish'>Dataset: FishMorphology</h2><span id='topic+fish'></span>

<h3>Description</h3>

<p>This data set consists of the sex, habitat, mass and then 26 morphometric measurements on 75 fish (Arctic charr)</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fish)</code></pre>


<h3>Format</h3>

<p>Data frame containing the 75 x 29 matrix. Column 1 contains sex (1=female, 2=male). Column 2 contains habitat (1=litoral, 2=pelagic). Column 3 contains the mass in grams. Columns 4 to 29 contain the 26 morphometric measurements.</p>


<h3>Source</h3>

<p>Greenacre, M and Primicerio, R (2010) Multivariate Analysis of Ecological Data. BBVA Foundation, Bilbao. Free download at www.multivariatestatistics.org</p>

<hr>
<h2 id='ILR'>
Isometric logratio
</h2><span id='topic+ILR'></span>

<h3>Description</h3>

<p>Computation of a single isometric logratio (ILR)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ILR(data, numer=NA, denom=NA, weight=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ILR_+3A_data">data</code></td>
<td>

<p>A compositional data frame or matrix 
</p>
</td></tr>
<tr><td><code id="ILR_+3A_numer">numer</code></td>
<td>

<p>Vector of parts in the numerator
</p>
</td></tr>
<tr><td><code id="ILR_+3A_denom">denom</code></td>
<td>

<p>Vector of parts in the denominator
</p>
</td></tr>
<tr><td><code id="ILR_+3A_weight">weight</code></td>
<td>

<p>Logical indicating if a varying weight is returned (default:<code>TRUE</code>). If <code>FALSE</code>, a weight based on equally-weighted parts is returned. Alternatively a positive weight can be specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>ILR</code> computes a single isometric logratio based on the specified numerator and denominator parts that define the two geometric means in the ratio. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>LR</code></td>
<td>

<p>The isometric logratio (ILR)
</p>
</td></tr>
<tr><td><code>LR.wt</code></td>
<td>

<p>The weight assigned to the ILR
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. (1986), The Statistical Analysis of Compositional Data, Chapman &amp; Hall.  <br />
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SLR">SLR</a></code>, <code><a href="#topic+ALR">ALR</a></code>, <code><a href="#topic+PLR">PLR</a></code>, <code><a href="#topic+LR">LR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veg)
ILR(veg, numer=1, denom=2:3)
</code></pre>

<hr>
<h2 id='invALR'>
Inverse of additive logratios
</h2><span id='topic+invALR'></span>

<h3>Description</h3>

<p>Given additive logratios (ALRs) with respect to a specified part, compute the inverse (i.e. original parts)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invALR(ALRmatrix, part.names=paste("part",1:(ncol(ALRmatrix)+1),sep=""), denom=NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invALR_+3A_alrmatrix">ALRmatrix</code></td>
<td>

<p>A matrix of additive logratios (ALRs) with respect to a specified part)
</p>
</td></tr>
<tr><td><code id="invALR_+3A_part.names">part.names</code></td>
<td>

<p>Part names in the reconstructed compositional data matrix
</p>
</td></tr>
<tr><td><code id="invALR_+3A_denom">denom</code></td>
<td>

<p>The index of the denominator used in the computation of the ALRs (default: last part))
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>invALR</code> computes the original parts, given the additive logratios (ALRs)
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>parts</code></td>
<td>

<p>The reconstructed parts (they add up to 1)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. (1986), The Statistical Analysis of Compositional Data, Chapman &amp; Hall. <br />
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ALR">ALR</a></code>, <code><a href="#topic+LR">LR</a></code>, <code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+invCLR">invCLR</a></code>, <code><a href="#topic+LR.VAR">LR.VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veg)
# compute additive logratios with respect to second part
veg.ALR &lt;- ALR(veg, denom=2)$LR
# recover original parts (to get same order, specify the denominator used originally)
invALR(veg.ALR, denom=2)
</code></pre>

<hr>
<h2 id='invCLR'>
Inverse of centred logratios
</h2><span id='topic+invCLR'></span>

<h3>Description</h3>

<p>Given centred logratios (CLRs), compute the inverse (i.e. recover the original parts)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invCLR(CLRmatrix, part.names=colnames(CLRmatrix))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invCLR_+3A_clrmatrix">CLRmatrix</code></td>
<td>

<p>A matrix of centred logratios
</p>
</td></tr>
<tr><td><code id="invCLR_+3A_part.names">part.names</code></td>
<td>

<p>Part names in the reconstructed compositional data matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>invCLR</code> computes the original parts, given the centred logratios (CLRs)
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>parts</code></td>
<td>

<p>The reconstructed parts (they add up to 1)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. (1986), The Statistical Analysis of Compositional Data, Chapman &amp; Hall.   <br />
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+ALR">ALR</a></code>, <code><a href="#topic+invALR">invALR</a></code>, <code><a href="#topic+LR.VAR">LR.VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veg)
# compute centred logratios
veg.CLR &lt;- CLR(veg)$LR
# invert back to original parts (parts closed to sum to 1)
invALR(veg.CLR)
</code></pre>

<hr>
<h2 id='invSLR'>
Inverse of full set of amalgamation balances
</h2><span id='topic+invSLR'></span>

<h3>Description</h3>

<p>Given a full set of amalgamation (or summation) balances (SLRs), compute the inverse (i.e. recover the original parts)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invSLR(SLRmatrix, part.names=NA, ratio.names=colnames(SLRmatrix))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invSLR_+3A_slrmatrix">SLRmatrix</code></td>
<td>

<p>A matrix of amalgamation logratios, one less column than the number of parts
</p>
</td></tr>
<tr><td><code id="invSLR_+3A_part.names">part.names</code></td>
<td>

<p>Part names in the reconstructed compositional data matrix
</p>
</td></tr>
<tr><td><code id="invSLR_+3A_ratio.names">ratio.names</code></td>
<td>

<p>Definition of the amalgamation logratios
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>invSLR</code> computes the original parts, given the amalgamation logratios (CLRs).
The amalgamation logratios are specified in <code>ratio.names</code> in the format <code>num/den</code> where <code>num</code> and <code>den</code> are the numerator and denominator amalgamations respectively. 
An amalgamation is specified as <code>"p1&amp;p2&amp;..."</code>, where <code>p1</code>, <code>p2</code>, etc. are the parts summed in the amalgamation.
For example, an SLR of the ratio MnO/(CaO+P2O5) would be names as <code>"MnO/CaO&amp;P2O5"</code>. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>parts</code></td>
<td>

<p>The reconstructed parts (they add up to 1)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. (1986), The Statistical Analysis of Compositional Data, Chapman &amp; Hall.   <br />
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+ALR">ALR</a></code>, <code><a href="#topic+invALR">invALR</a></code>, <code><a href="#topic+LR.VAR">LR.VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veg)
# compute centred logratios
veg.CLR &lt;- CLR(veg)$LR
# invert back to original parts (parts closed to sum to 1)
invALR(veg.CLR)
</code></pre>

<hr>
<h2 id='LR'>
All pairwise logratios
</h2><span id='topic+LR'></span>

<h3>Description</h3>

<p>Computation of all pairwise logratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR(data, ordering=1:ncol(data), weight=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LR_+3A_data">data</code></td>
<td>

<p>A compositional data frame or matrix 
</p>
</td></tr>
<tr><td><code id="LR_+3A_ordering">ordering</code></td>
<td>

<p>A permutation of the columns (default: the original ordering) 
</p>
</td></tr>
<tr><td><code id="LR_+3A_weight">weight</code></td>
<td>

<p>Logical indicating if varying weights are returned (default:<code>TRUE</code>). If <code>FALSE</code>, unweighted (equal) weights are returned. Alternatively a set of positive weights can be specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>LR</code> computes the complete set of pairwise logratios, in the order [1,2], [1,3], [2,3], [1,4], [2,4], [3,4], etc. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>LR</code></td>
<td>

<p>The pairwise logratios as columns of a data matrix
</p>
</td></tr>
<tr><td><code>LR.wt</code></td>
<td>

<p>The weights assigned to the respective logratios
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. (1986), The Statistical Analysis of Compositional Data, Chapman &amp; Hall. <br /> 
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ALR">ALR</a></code>, <code><a href="#topic+invALR">invALR</a></code>, <code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+invCLR">invCLR</a></code>, <code><a href="#topic+LR.VAR">LR.VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veg)
LR(veg)
</code></pre>

<hr>
<h2 id='LR.VAR'>
Total logratio variance
</h2><span id='topic+LR.VAR'></span>

<h3>Description</h3>

<p>Computation of total (weighted)logratio variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR.VAR(LRdata, row.wt = NA, weight=TRUE, vars=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LR.VAR_+3A_lrdata">LRdata</code></td>
<td>

<p>Matrix of logratios, either a vector or preferably the logratio object resulting from one of the functions ALR, CLR, PLR or LR
</p>
</td></tr>
<tr><td><code id="LR.VAR_+3A_row.wt">row.wt</code></td>
<td>

<p>Optional set of row weights (default: equal weights)
</p>
</td></tr>
<tr><td><code id="LR.VAR_+3A_weight">weight</code></td>
<td>

<p>Logical indicating if varying weights are returned(default:<code>TRUE</code>). If <code>FALSE</code>, unweighted (equal) weights are returned. Alternatively a set of positive weights can be specified.
</p>
</td></tr>
<tr><td><code id="LR.VAR_+3A_vars">vars</code></td>
<td>

<p>If <code>TRUE</code>, output individual variances as well (default <code>FALSE</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>LR.VAR</code> computes the sum of the logratio variances provided as input, using the weights in the logratio data object. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>LRtotvar</code></td>
<td>

<p>The total logratio variance
</p>
</td></tr>
<tr><td><code>LRvars</code></td>
<td>

<p>(optional, if vars=TRUE, the individual logratio variances composing the total)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. (1986), The Statistical Analysis of Compositional Data, Chapman &amp; Hall.  <br />
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LR">LR</a></code>, <code><a href="#topic+ALR">ALR</a></code>, <code><a href="#topic+invALR">invALR</a></code>, <code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+invCLR">invCLR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cups)
# These give identical total logratio variances (weighted, by default)
LR.VAR(CLR(cups))
LR.VAR(LR(cups))
# Summing over all sets of ALRs gives twice the variance
totvar &lt;- 0
for(j in 1:ncol(cups)) totvar &lt;- totvar + LR.VAR(ALR(cups, denom=j))
totvar/2
</code></pre>

<hr>
<h2 id='LRA'>
Logratio analysis
</h2><span id='topic+LRA'></span>

<h3>Description</h3>

<p>Computation of weighted or unweighted logratio analysis of a samples-by-parts compositional data table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRA(data, nd = 2, weight = TRUE, suprow = NA, row.wt = NA, amalg = NA, supamalg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LRA_+3A_data">data</code></td>
<td>

<p>A data frame or matrix of compositional data, with no zero values
</p>
</td></tr>
<tr><td><code id="LRA_+3A_nd">nd</code></td>
<td>

<p>Number of dimensions for summary solution if not 2 (default)
</p>
</td></tr>
<tr><td><code id="LRA_+3A_weight">weight</code></td>
<td>

<p>TRUE (default) for part weighting, FALSE for unweighted analysis, or a vector of user-defined part weights
</p>
</td></tr>
<tr><td><code id="LRA_+3A_suprow">suprow</code></td>
<td>

<p>Indices of rows that are supplementary points
</p>
</td></tr>
<tr><td><code id="LRA_+3A_row.wt">row.wt</code></td>
<td>

<p>Optional user-defined set of positive weights for the rows (samples) (default: equal weights)
</p>
</td></tr>
<tr><td><code id="LRA_+3A_amalg">amalg</code></td>
<td>

<p>Optional list of amalgamated parts 
</p>
</td></tr>
<tr><td><code id="LRA_+3A_supamalg">supamalg</code></td>
<td>

<p>FALSE (default) when amalgamations are active and their subparts supplementary, TRUE when amalgamations are supplementary and their parts active  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>LRA</code> computes a log-ratio analysis of a table of compositional data based on the singular value decomposition. 
By default the weighted log-ratio analysis is computed (Greenacre &amp; Lewi 2009). 
For the unweighted logratio analysis (Aitchison &amp; Greenacre 2002), specify the option <code>weight=FALSE</code>. 
</p>
<p>User-specified weights can be supplied, for the rows and/or the columns.
Usually row weights are not specified, and are equal unless intentional weighting of the samples is desired.
Default column weights (if <code>weight = TRUE</code>) are the part means of the true compositional table, thus summing to 1.
User-specified part weights can be provided using the same <code>weight</code> option. 
</p>
<p>Supplementary rows can be declared (also known as passive points) &ndash; these do not contribute to the solution but are positioned on the solution axes.
</p>
<p>Amalgamations can be defined and can either replace their constituent parts (default) or be declared supplementary using the <code>supamalg</code> option: <code>supamalg = FALSE</code> (default), <code>= TRUE</code> if all declared amalgamations are supplementary.
</p>
<p>The function borrows the structure and functions of the <code>ca</code> package, which is required, and produces a <code>ca</code> object, and the same <code>print</code>, <code>summary</code> and <code>plot</code> methods can be used, as for a <code>ca</code> object.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sv</code></td>
<td>
<p>Singular values</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>Number of dimensions in solution results</p>
</td></tr>
<tr><td><code>rownames</code></td>
<td>
<p>Row names</p>
</td></tr>
<tr><td><code>rowmass</code></td>
<td>
<p>Row weights</p>
</td></tr>
<tr><td><code>rowdist</code></td>
<td>
<p>Row logratio distances to centroid</p>
</td></tr>
<tr><td><code>rowinertia</code></td>
<td>
<p>Row inertias</p>
</td></tr>
<tr><td><code>rowcoord</code></td>
<td>
<p>Row standard coordinates</p>
</td></tr>
<tr><td><code>rowpcoord</code></td>
<td>
<p>Row principal coordinates</p>
</td></tr>
<tr><td><code>rowsup</code></td>
<td>
<p>Indices of row supplementary points</p>
</td></tr>
<tr><td><code>colnames</code></td>
<td>
<p>Column names</p>
</td></tr>
<tr><td><code>colmass</code></td>
<td>
<p>Column weights</p>
</td></tr>
<tr><td><code>coldist</code></td>
<td>
<p>Column logratio distances to centroid</p>
</td></tr>
<tr><td><code>colinertia</code></td>
<td>
<p>Column inertias</p>
</td></tr>
<tr><td><code>colcoord</code></td>
<td>
<p>Column standard coordinates</p>
</td></tr>
<tr><td><code>colpcoord</code></td>
<td>
<p>Column principal coordinates</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>The compositional data table</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. and Greenacre, M. (2002), Biplots of compositional data, Applied Statistics 51, 375-392.<br />
Greenacre, M. and Lewi, P.J. (2009), Distributional equivalence and subcompositional coherence in the analysis of compositional data, contingency tables and ratio scale measurements. Journal of Classification 26, 29-54.
Greenacre, M. (2020), Amalgamations are valid in compositional data analysis, can be used in agglomerative clustering, and their logratios have an inverse transformation. Applied Computing and Geosciences 5, 100017.
</p>


<h3>See Also</h3>

<p><code><a href="ca.html#topic+plot.ca">plot.ca</a></code>, <code><a href="ca.html#topic+summary.ca">summary.ca</a></code>, <code><a href="ca.html#topic+print.ca">print.ca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (weighted) LRA of the RomanCups data set, showing default symmetric map
data("cups")
PLOT.LRA(LRA(cups))
# (unweighted) LRA of the RomanCups data set, showing default symmetric map
# the solution is completely different
PLOT.LRA(LRA(cups, weight=FALSE))
</code></pre>

<hr>
<h2 id='PCA'>
Principal component analysis
</h2><span id='topic+PCA'></span>

<h3>Description</h3>

<p>Computation of weighted or unweighted principal component analysis of a matrix of interval-scale data (e.g. a matrix of logratios).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCA(data, nd = 2, weight = TRUE, row.wt = NA, suprow = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCA_+3A_data">data</code></td>
<td>

<p>A data frame or matrix of interval-scale data, or logratio object from functions <code>ALR</code>, <code>CLR</code> or <code>LR</code>
</p>
</td></tr>
<tr><td><code id="PCA_+3A_nd">nd</code></td>
<td>

<p>Number of dimensions for summary solution if not 2 (default)
</p>
</td></tr>
<tr><td><code id="PCA_+3A_weight">weight</code></td>
<td>

<p>TRUE (default) for column weighting, FALSE for unweighted analysis, or a vector of user-defined column weights
</p>
</td></tr>
<tr><td><code id="PCA_+3A_row.wt">row.wt</code></td>
<td>

<p>Optional user-defined set of positive weights for the rows (samples) (default: equal weights)
</p>
</td></tr>
<tr><td><code id="PCA_+3A_suprow">suprow</code></td>
<td>

<p>Indices of rows that are supplementary points (NOTE: this option is not implemented in this version)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>PCA</code> computes an unstandardized principal component analysis, based on the singular value decomposition, of a matrix of interval-scale data, usually a matrix of logratios in the context of this package (but it can be used for general data as well). 
For general usage the unweighted option <code>weight = FALSE</code> might be preferred, but the default is weighted in the present context of compositional data.
</p>
<p>User-specified weights can be supplied, for the rows and/or the columns.
Usually row weights are not specified, and are equal unless intentional weighting of the samples is desired.
User-specified part weights can be provided using the <code>weight</code> option. 
</p>
<p>Supplementary rows and columns can be declared (also known as passive points) &ndash; these do not contribute to the solution but are positioned on the solution axes. Notice that this optyion is not implemented in the present version, but will appear in the next one.
</p>
<p>The function borrows the structure and functions of the <code>ca</code> package, which is required, and produces a <code>ca</code> object, and the same <code>print</code>, <code>summary</code> and <code>plot</code> methods can be used, as for a <code>ca</code> object.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sv</code></td>
<td>
<p>Singular values</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>Dimenson of the solution</p>
</td></tr>
<tr><td><code>rownames</code></td>
<td>
<p>Row names</p>
</td></tr>
<tr><td><code>rowmass</code></td>
<td>
<p>Row weights</p>
</td></tr>
<tr><td><code>rowdist</code></td>
<td>
<p>Row logratio distances to centroid</p>
</td></tr>
<tr><td><code>rowinertia</code></td>
<td>
<p>Row variances</p>
</td></tr>
<tr><td><code>rowcoord</code></td>
<td>
<p>Row standard coordinates</p>
</td></tr>
<tr><td><code>rowpcoord</code></td>
<td>
<p>Row principal coordinates</p>
</td></tr>
<tr><td><code>rowsup</code></td>
<td>
<p>Indices of row supplementary points</p>
</td></tr>
<tr><td><code>colnames</code></td>
<td>
<p>Column names</p>
</td></tr>
<tr><td><code>colmass</code></td>
<td>
<p>Column weights</p>
</td></tr>
<tr><td><code>coldist</code></td>
<td>
<p>Column logratio distances to centroid</p>
</td></tr>
<tr><td><code>colinertia</code></td>
<td>
<p>Column variances</p>
</td></tr>
<tr><td><code>colcoord</code></td>
<td>
<p>Column standard coordinates</p>
</td></tr>
<tr><td><code>colpcoord</code></td>
<td>
<p>Column principal coordinates</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>The data table</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. and Greenacre, M. (2002), Biplots of compositional data, Applied Statistics 51, 375-392.<br />
Greenacre, M. (2010), Biplots in Practice, BBVA Foundation, Bilbao. Free download from www.multivariatestatistics.org
</p>


<h3>See Also</h3>

<p><code>PLOT.PCA</code>, <code><a href="ca.html#topic+plot.ca">plot.ca</a></code>, <code><a href="ca.html#topic+summary.ca">summary.ca</a></code>, <code><a href="ca.html#topic+print.ca">print.ca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute logratios of Vegetables data set
data("veg")
veg.LR &lt;- LR(veg)
# unweighted PCA biplot of the results
veg.pca &lt;- PCA(veg.LR$LR, weight=FALSE)
PLOT.PCA(veg.pca, map="asymmetric")
</code></pre>

<hr>
<h2 id='PLOT.CA'>
Plot the results of a correspondence analysis
</h2><span id='topic+PLOT.CA'></span>

<h3>Description</h3>

<p>Various maps and biplots of the results of a correspondence analysis using function <code>CA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLOT.CA(obj, map="symmetric", rescale=1, dim=c(1,2), axes.inv = c(1,1), main="",
        cols=c("blue","red"), colarrows = "pink", cexs=c(0.8,0.8), fonts=c(2,4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PLOT.CA_+3A_obj">obj</code></td>
<td>

<p>A CA object created using function <code>CA</code>
</p>
</td></tr>
<tr><td><code id="PLOT.CA_+3A_map">map</code></td>
<td>

<p>Choice of scaling of rows and columns: <code>"symmetric"</code> (default), <code>"asymmetric"</code> or <code>"contribution"</code>
</p>
</td></tr>
<tr><td><code id="PLOT.CA_+3A_rescale">rescale</code></td>
<td>

<p>A rescaling factor applied to column coordinates (default is 1 for no rescaling)
</p>
</td></tr>
<tr><td><code id="PLOT.CA_+3A_dim">dim</code></td>
<td>

<p>Dimensions selected for horizontal and vertical axes of the plot (default is c(1,2)) 
</p>
</td></tr>
<tr><td><code id="PLOT.CA_+3A_main">main</code></td>
<td>

<p>Title for plot
</p>
</td></tr>
<tr><td><code id="PLOT.CA_+3A_axes.inv">axes.inv</code></td>
<td>

<p>Option for reversing directions of horizontal and vertical axes (default is c(1,1) for no reversing, change one or both to -1 for reversing)
</p>
</td></tr>
<tr><td><code id="PLOT.CA_+3A_cols">cols</code></td>
<td>

<p>Colours for row and column labels (default is c(&quot;blue&quot;,&quot;red&quot;))
</p>
</td></tr>
<tr><td><code id="PLOT.CA_+3A_colarrows">colarrows</code></td>
<td>

<p>Colour for arrows in asymmetric and contribution biplots (default is &quot;pink&quot;)
</p>
</td></tr>
<tr><td><code id="PLOT.CA_+3A_cexs">cexs</code></td>
<td>

<p>Character expansion factors for row and column labels (default is c(0.8,0.8))
</p>
</td></tr>
<tr><td><code id="PLOT.CA_+3A_fonts">fonts</code></td>
<td>

<p>Fonts for row and column labels (default is c(2,4))
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>PLOT.CA</code> makes a scatterplot of the results of a correspondence analysis (computed using function <code>CA</code>), with various options for scaling the results and changing the direction of the axes.  By default, dimensions 1 and 2 are plotted on the horizontal and vertical axes, and it is assumed that row points refer to samples and columns to variables.
</p>
<p>By default, the symmetric scaling is used, where both rows and columns are in principal coordinates and have the same amount of weighted variance (i.e. inertia) along the two dimensions. The other options are biplots: the asymmetric option, when columns are in standard coordinates, and the contribution option, when columns are in contribution coordinates.  In cases where the row and column displays occupy widely different extents, the column coordinates can be rescaled using the <code>rescale</code> option. 
</p>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M. (2013), Contribution biplots, Journal of Computational and Graphical Statistics, 22, 107-122.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CA">CA</a></code>, <code><a href="ca.html#topic+plot.ca">plot.ca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("cups")
cups.ca &lt;- CA(cups)
PLOT.CA(cups.ca, map="contribution", rescale=0.2)	
# Compare the above plot with that of a weighted LRA -- practically the same
cups.lra &lt;- LRA(cups)
PLOT.LRA(cups.lra, map="contribution", rescale=0.2)
</code></pre>

<hr>
<h2 id='PLOT.LRA'>
Plot the results of a logratio analysis
</h2><span id='topic+PLOT.LRA'></span>

<h3>Description</h3>

<p>Various maps and biplots of the results of a logratio analysis using function <code>LRA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLOT.LRA(obj, map="symmetric", rescale=1, dim=c(1,2), axes.inv = c(1,1), main="",
         cols=c("blue","red"), colarrows = "pink", cexs=c(0.8,0.8), fonts=c(2,4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PLOT.LRA_+3A_obj">obj</code></td>
<td>

<p>An LRA object created using function <code>LRA</code>
</p>
</td></tr>
<tr><td><code id="PLOT.LRA_+3A_map">map</code></td>
<td>

<p>Choice of scaling of rows and columns: <code>"symmetric"</code> (default), <code>"asymmetric"</code> or <code>"contribution"</code>
</p>
</td></tr>
<tr><td><code id="PLOT.LRA_+3A_rescale">rescale</code></td>
<td>

<p>A rescaling factor applied to column coordinates (default is 1 for no rescaling)
</p>
</td></tr>
<tr><td><code id="PLOT.LRA_+3A_dim">dim</code></td>
<td>

<p>Dimensions selected for horizontal and vertical axes of the plot (default is c(1,2)) 
</p>
</td></tr>
<tr><td><code id="PLOT.LRA_+3A_axes.inv">axes.inv</code></td>
<td>

<p>Option for reversing directions of horizontal and vertical axes (default is c(1,1) for no reversing, change one or both to -1 for reversing)
</p>
</td></tr>
<tr><td><code id="PLOT.LRA_+3A_main">main</code></td>
<td>

<p>Title for plot
</p>
</td></tr>
<tr><td><code id="PLOT.LRA_+3A_cols">cols</code></td>
<td>

<p>Colours for row and column labels (default is c(&quot;blue&quot;,&quot;red&quot;))
</p>
</td></tr>
<tr><td><code id="PLOT.LRA_+3A_colarrows">colarrows</code></td>
<td>

<p>Colour for arrows in asymmetric and contribution biplots (default is &quot;pink&quot;)
</p>
</td></tr>
<tr><td><code id="PLOT.LRA_+3A_cexs">cexs</code></td>
<td>

<p>Character expansion factors for row and column labels (default is c(0.8,0.8))
</p>
</td></tr>
<tr><td><code id="PLOT.LRA_+3A_fonts">fonts</code></td>
<td>

<p>Fonts for row and column labels (default is c(2,4))
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>PLOT.LRA</code> makes a scatterplot of the results of a logratio analysis (computed using function <code>LRA</code>), with various options for scaling the results and changing the direction of the axes.  By default, dimensions 1 and 2 are plotted on the horizontal and vertical axes, and it is assumed that row points refer to samples and columns to compositional parts.
</p>
<p>By default, the symmetric scaling is used, where both rows and columns are in principal coordinates and have the same amount of weighted variance along the two dimensions. The other options are the asymmetric option, when columns are in standard coordinates, and the contribution option, when columns are in contribution coordinates.  In cases where the row and column displays occupy widely different extents, the column coordinates can be rescaled using the <code>rescale</code> option. 
</p>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M. (2013), Contribution biplots, Journal of Computational and Graphical Statistics, 22, 107-122.
</p>


<h3>See Also</h3>

<p><code><a href="ca.html#topic+plot.ca">plot.ca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># perform LRA on the vegetable compositions (unweighted form)
data("veg")
veg.lra &lt;- LRA(veg, weight=FALSE)
PLOT.LRA(veg.lra)
# perform LRA on the Roman cups data set and plot the results (weighted form)
data("cups")
cups.lra &lt;- LRA(cups)
PLOT.LRA(cups.lra, map="contribution", rescale=0.2)	
</code></pre>

<hr>
<h2 id='PLOT.PCA'>
Plot the results of a principal component analysis
</h2><span id='topic+PLOT.PCA'></span>

<h3>Description</h3>

<p>Various maps and biplots of the results of a principal component analysis using function <code>PCA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLOT.PCA(obj, map="symmetric", rescale=1, dim=c(1,2), axes.inv = c(1,1),
         main="", cols=c("blue","red"), colarrows = "pink", cexs=c(0.8,0.8),
         fonts=c(2,4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PLOT.PCA_+3A_obj">obj</code></td>
<td>

<p>An LRA object created using function <code>LRA</code>
</p>
</td></tr>
<tr><td><code id="PLOT.PCA_+3A_map">map</code></td>
<td>

<p>Choice of scaling of rows and columns: <code>"symmetric"</code> (default), <code>"asymmetric"</code> or <code>"contribution"</code>
</p>
</td></tr>
<tr><td><code id="PLOT.PCA_+3A_rescale">rescale</code></td>
<td>

<p>A rescaling factor applied to column coordinates (default is 1 for no rescaling)
</p>
</td></tr>
<tr><td><code id="PLOT.PCA_+3A_dim">dim</code></td>
<td>

<p>Dimensions selected for horizontal and vertical axes of the plot (default is c(1,2)) 
</p>
</td></tr>
<tr><td><code id="PLOT.PCA_+3A_axes.inv">axes.inv</code></td>
<td>

<p>Option for reversing directions of horizontal and vertical axes (default is c(1,1) for no reversing, change one or both to -1 for reversing)
</p>
</td></tr>
<tr><td><code id="PLOT.PCA_+3A_main">main</code></td>
<td>

<p>Title for plot
</p>
</td></tr>
<tr><td><code id="PLOT.PCA_+3A_cols">cols</code></td>
<td>

<p>Colours for row and column labels (default is c(&quot;blue&quot;,&quot;red&quot;))
</p>
</td></tr>
<tr><td><code id="PLOT.PCA_+3A_colarrows">colarrows</code></td>
<td>

<p>Colour for arrows in asymmetric and contribution biplots (default is &quot;pink&quot;)
</p>
</td></tr>
<tr><td><code id="PLOT.PCA_+3A_cexs">cexs</code></td>
<td>

<p>Character expansion factors for row and column labels (default is c(0.8,0.8))
</p>
</td></tr>
<tr><td><code id="PLOT.PCA_+3A_fonts">fonts</code></td>
<td>

<p>Fonts for row and column labels (default is c(2,4))
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>PLOT.PCA</code> makes a scatterplot of the results of a logratio analysis (computed using function <code>PCA</code>), with various options for scaling the results and changing the direction of the axes.  By default, dimensions 1 and 2 are plotted on the horizontal and vertical axes, and it is assumed that row points refer to samples and columns to variables.
</p>
<p>By default, the symmetric scaling is used, where both rows and columns are in principal coordinates and have the same amount of weighted variance along the two dimensions. The other options are biplots: the asymmetric option, when columns are in standard coordinates, and the contribution option, when columns are in contribution coordinates.  In cases where the row and column displays occupy widely different extents, the column coordinates can be rescaled using the <code>rescale</code> option. 
</p>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M. (2013), Contribution biplots, Journal of Computational and Graphical Statistics, 22, 107-122.
</p>


<h3>See Also</h3>

<p><code><a href="ca.html#topic+plot.ca">plot.ca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># perform weighted PCA on the ALRs of the Roman cups data set
# where the first oxide silica is chosen as the denominator
data("cups")
cups.alr &lt;- ALR(cups, denom=1)
cups.pca &lt;- PCA(cups.alr)
PLOT.PCA(cups.pca, map="contribution", rescale=0.2, axes.inv=c(1,-1))	
</code></pre>

<hr>
<h2 id='PLOT.RDA'>
Plot the results of a redundancy analysis
</h2><span id='topic+PLOT.RDA'></span>

<h3>Description</h3>

<p>Various maps and biplots/triplots of the results of a redundancy analysis using function <code>RDA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLOT.RDA(obj, map="symmetric", indcat=NA, rescale=1, dim=c(1,2), axes.inv=c(1,1),
         main="", rowstyle=1, cols=c("blue","red","forestgreen"),
         colarrows=c("pink","lightgreen"), colrows=NA, pchrows=NA, colcats=NA,
         cexs=c(0.8,0.8,0.8), fonts=c(2,4,4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PLOT.RDA_+3A_obj">obj</code></td>
<td>

<p>An RDA object created using function <code>RDA</code>
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_map">map</code></td>
<td>

<p>Choice of scaling of rows and columns: <code>"symmetric"</code> (default), <code>"asymmetric"</code> or <code>"contribution"</code>
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_indcat">indcat</code></td>
<td>

<p>A vector indicating which of the covariates are dummy (or fuzzy) variables
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_rescale">rescale</code></td>
<td>

<p>A rescaling factor applied to column coordinates(default is 1 for no rescaling). If rescale is a vector with two values, the first applies to the column coordinates and the second to the covariate coordinates.
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_dim">dim</code></td>
<td>

<p>Dimensions selected for horizontal and vertical axes of the plot (default is c(1,2)) 
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_axes.inv">axes.inv</code></td>
<td>

<p>Option for reversing directions of horizontal and vertical axes (default is c(1,1) for no reversing, change one or both to -1 for reversing)
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_main">main</code></td>
<td>

<p>Title for plot
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_rowstyle">rowstyle</code></td>
<td>

<p>Scaling option for row coordinates, either 1 (SVD coordinates, default) or 2 (as supplementary points)
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_cols">cols</code></td>
<td>

<p>Colours for row and column  and covariate labels (default is c(&quot;blue&quot;,&quot;red&quot;,&quot;forestgreen&quot;))
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_colarrows">colarrows</code></td>
<td>

<p>Colour for arrows in asymmetric or contribution biplots, for columns and covariates (default is c(&quot;pink&quot;,&quot;lightgreen&quot;))
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_colrows">colrows</code></td>
<td>

<p>Optional vector of colours for rows
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_pchrows">pchrows</code></td>
<td>

<p>Optional vector of point symbols for rows
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_colcats">colcats</code></td>
<td>

<p>Optional vector of colours for covariate categories (dummy variables)
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_cexs">cexs</code></td>
<td>

<p>Vector of character expansion factors for row and column and covariate labels (default is c(0.8,0.8,0.8))
</p>
</td></tr>
<tr><td><code id="PLOT.RDA_+3A_fonts">fonts</code></td>
<td>

<p>Vector of font styles for row and column and covariate labels (default is c(2,4,4))
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>PLOT.RDA</code> makes a scatterplot of the results of a redundancy analysis (computed using function <code>RDA</code>), with various options for scaling the results and changing the direction of the axes.  By default, dimensions 1 and 2 are plotted on the horizontal and vertical axes, and it is assumed that row points refer to samples and columns to compositional parts.   Covariates are plotted according to their regression coefficients with the RDA dimensions, and if they contain dummy (or fuzzy) variables these are indicated by the option indcat, and hence plotted as centroids not arrows.
</p>
<p>By default, the symmetric scaling is used, where both rows and columns are in principal coordinates and have the same amount of weighted variance along the two dimensions. The other options are the asymmetric option, when columns are in standard coordinates, and the contribution option, when columns are in contribution coordinates.  In cases where the row and column displays as well as the covariate positions occupy widely different extents, the column and covariate coordinates can be rescaled using the <code>rescale</code> option. 
</p>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDA">RDA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see the use of PLOT.RDA in the example of the RDA function
</code></pre>

<hr>
<h2 id='PLR'>
Pivot logratios
</h2><span id='topic+PLR'></span>

<h3>Description</h3>

<p>Computation of the set of pivot logratios(PLRs) based on the specified ordering of parts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLR(data, ordering=1:ncol(data), weight=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PLR_+3A_data">data</code></td>
<td>

<p>A compositional data frame or matrix 
</p>
</td></tr>
<tr><td><code id="PLR_+3A_ordering">ordering</code></td>
<td>

<p>The ordering of the parts to be used in the PLRs (by default, the original ordering of the columns)
</p>
</td></tr>
<tr><td><code id="PLR_+3A_weight">weight</code></td>
<td>

<p>Logical indicating if varying weights are returned (default:<code>TRUE</code>). If <code>FALSE</code>, weights based on equally-weighted parts are returned. Alternatively a set of positive weights can be specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>PLR</code> computes the set of pivot logratios according to the ordering of the parts. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>LR</code></td>
<td>

<p>The pivot logratios (PLRs)
</p>
</td></tr>
<tr><td><code>LR.wt</code></td>
<td>

<p>The weights assigned to the PLRs
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Hron K., Filzmoser P., de Caritat P., Fiserova E., Gardlo A. (2017). Weighted pivot coordinates for copositional data and their application to geochemical mapping. Mathematical Geosciences 49, 777-796.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ILR">ILR</a></code>, <code><a href="#topic+SLR">SLR</a></code>, <code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+ALR">ALR</a></code>, <code><a href="#topic+LR">LR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veg)
PLR(veg, ordering=c(1,3,2))
</code></pre>

<hr>
<h2 id='RDA'>
Redundancy analysis
</h2><span id='topic+RDA'></span>

<h3>Description</h3>

<p>Computation of weighted or unweighted redundancy analysis of a samples-by-parts compositional data table, given a set of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDA(data, cov=NA, nd = NA, weight = TRUE, suprow = NA, row.wt = NA) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDA_+3A_data">data</code></td>
<td>

<p>A data frame or matrix of interval-scale data, e.g. logratios (which are preferably in a list object with weights)
</p>
</td></tr>
<tr><td><code id="RDA_+3A_cov">cov</code></td>
<td>

<p>List of covariates for constraining solution
</p>
</td></tr>
<tr><td><code id="RDA_+3A_nd">nd</code></td>
<td>

<p>Number of dimensions for summary output, by default the number of constraining dimensions
</p>
</td></tr>
<tr><td><code id="RDA_+3A_weight">weight</code></td>
<td>

<p>TRUE (default) when weights are in data list object, FALSE for unweighted analysis, or a vector of user-defined part weights
</p>
</td></tr>
<tr><td><code id="RDA_+3A_suprow">suprow</code></td>
<td>

<p>Indices of rows that are supplementary (passive) points  (NOTE: this option is not implemented in this version)
</p>
</td></tr>
<tr><td><code id="RDA_+3A_row.wt">row.wt</code></td>
<td>

<p>Optional user-defined set of positive weights for the rows (samples) (default: equal weights)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>RDA</code> computes a redundancy analysis of a matrix of interval-scaled data, constrained by a matrix of covariates, using the singular value decomposition. 
By default weights are assumed in the data list object. 
For the unweighted logratio analysis, specify the option <code>weight=FALSE</code>. 
If <code>weight = TRUE</code> (the default) it is assumed that the weights are included in the data object, which comes from one of the logratio functions.
User-specified part weights can be provided using the same <code>weight</code> option. 
</p>
<p>Usually row weights are not specified, they are equal unless intentional weighting of the samples is desired.
Supplementary rows can be declared (also known as passive points) &ndash; these do not contribute to the solution but are positioned on the solution axes.
This option will be available in the next release of the package.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sv</code></td>
<td>
<p>Singular values</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>Number of dimensions in the solution output</p>
</td></tr>
<tr><td><code>rownames</code></td>
<td>
<p>Row names</p>
</td></tr>
<tr><td><code>rowmass</code></td>
<td>
<p>Row weights</p>
</td></tr>
<tr><td><code>rowdist</code></td>
<td>
<p>Row distances to centroid</p>
</td></tr>
<tr><td><code>rowinertia</code></td>
<td>
<p>Row variances</p>
</td></tr>
<tr><td><code>rowcoord</code></td>
<td>
<p>Row standard coordinates</p>
</td></tr>
<tr><td><code>rowpcoord</code></td>
<td>
<p>Row principal coordinates</p>
</td></tr>
<tr><td><code>rowsup</code></td>
<td>
<p>Indices of row supplementary points</p>
</td></tr>
<tr><td><code>colnames</code></td>
<td>
<p>Column names</p>
</td></tr>
<tr><td><code>colmass</code></td>
<td>
<p>Column weights</p>
</td></tr>
<tr><td><code>coldist</code></td>
<td>
<p>Column logratio distances to centroid</p>
</td></tr>
<tr><td><code>colinertia</code></td>
<td>
<p>Column variances</p>
</td></tr>
<tr><td><code>colcoord</code></td>
<td>
<p>Column standard coordinates</p>
</td></tr>
<tr><td><code>colpcoord</code></td>
<td>
<p>Column principal coordinates</p>
</td></tr>
<tr><td><code>covcoord</code></td>
<td>
<p>Regression coordinates of constraining variables</p>
</td></tr>
<tr><td><code>covnames</code></td>
<td>
<p>Names of constraining variables</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>The data table (usually logratios in this package)</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The table of covariates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Van den Wollenbergh, A. (1977), Redundancy analysis. An alternative to canonical correlation analysis, Psychometrika 42, 207-219.<br />
Greenacre, M. (2013), Contribution biplots, Journal of Computational and Graphical Statistics 22, 107-122.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLOT.RDA">PLOT.RDA</a></code>, <code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+LR">LR</a></code>, <code><a href="#topic+DUMMY">DUMMY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data frame fish has sex, habitat and mass in first columns, 
# then morphometric data in remaining columns
data("fish")
sex     &lt;- fish[,1]
habitat &lt;- fish[,2]
mass    &lt;- fish[,3]
fishm   &lt;- as.matrix(fish[,4:29])
# Convert to compositional data matrix
fishm   &lt;- CLOSE(fishm)
# Compute logarithm of mass and interaction of sex (F/M) and habitat (L/P) categories
logmass &lt;- log(mass)
sexhab  &lt;- 2*(sex-1)+habitat
sexhab.names &lt;- c("FL","FP","ML","MP")
rownames(fishm) &lt;- sexhab.names[sexhab]
# Create dummy variables for sexhab and create matrix of covariates
sexhab.Z &lt;- DUMMY(sexhab, catnames=sexhab.names)
vars     &lt;- cbind(logmass, sexhab.Z)
# Perform RDA on centred logratios
require(ca)
fish.rda &lt;- RDA(CLR(fishm), cov=vars)
# Plot results 
# (for more options see Appendix of Compositional Data Analysis in Practice)
PLOT.RDA(fish.rda, map="contribution", rescale=0.05, indcat=2:5, 
         colrows=rainbow(4, start=0.1, end=0.8)[sexhab], cexs=c(0.8,0.8,1))
</code></pre>

<hr>
<h2 id='SLR'>
Amalgamation (summed) logratio
</h2><span id='topic+SLR'></span>

<h3>Description</h3>

<p>Computation of a single amalgamation (summed) logratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SLR(data, numer=NA, denom=NA, weight=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SLR_+3A_data">data</code></td>
<td>

<p>A compositional data frame or matrix 
</p>
</td></tr>
<tr><td><code id="SLR_+3A_numer">numer</code></td>
<td>

<p>Vector of parts in the numerator
</p>
</td></tr>
<tr><td><code id="SLR_+3A_denom">denom</code></td>
<td>

<p>Vector of parts in the denominator
</p>
</td></tr>
<tr><td><code id="SLR_+3A_weight">weight</code></td>
<td>

<p>Logical indicating if a varying weight is returned (default:<code>TRUE</code>). If <code>FALSE</code>, a weight based on equally-weighted parts is returned. Alternatively a positive weight can be specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>SLR</code> computes a single amalgamation logratio based on the specified numerator and denominator parts that define the two summations in the ratio. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>LR</code></td>
<td>

<p>The amalgamation (summed)) logratio (SLR)
</p>
</td></tr>
<tr><td><code>LR.wt</code></td>
<td>

<p>The weight assigned to the SLR
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Aitchison, J. (1986), The Statistical Analysis of Compositional Data, Chapman &amp; Hall. <br />
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ILR">ILR</a></code>, <code><a href="#topic+ALR">ALR</a></code>, <code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+PLR">PLR</a></code>, <code><a href="#topic+LR">LR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veg)
SLR(veg, numer=1, denom=2:3)
</code></pre>

<hr>
<h2 id='STEP'>
Stepwise selection of logratios
</h2><span id='topic+STEP'></span>

<h3>Description</h3>

<p>Stepwise selection of pairwise logratios that explain maximum variance in a target matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STEP(data, datatarget=data, previous=NA, previous.wt=NA, weight=TRUE, 
     random=FALSE, nsteps=min(ncol(data), ncol(datatarget))-1, top=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STEP_+3A_data">data</code></td>
<td>

<p>A data frame or matrix of compositional data on which pairwise logratios are computed
</p>
</td></tr>
<tr><td><code id="STEP_+3A_datatarget">datatarget</code></td>
<td>

<p>A matrix of interval-scale data, with as many rows as <code>data</code>, which serves as the target matrix whose variance is to be explained (by default it is the same matrix as data, in which case total logratio variance is to be explained)
</p>
</td></tr>
<tr><td><code id="STEP_+3A_previous">previous</code></td>
<td>

<p>A vector or matrix of variables to be forced in before logratios are sought
</p>
</td></tr>
<tr><td><code id="STEP_+3A_previous.wt">previous.wt</code></td>
<td>

<p>Possible weights of the variable(s) forced in before logratios are sought (if not specified, weights of 1 are assumed)
</p>
</td></tr>
<tr><td><code id="STEP_+3A_weight">weight</code></td>
<td>

<p><code>TRUE</code> (default) when weights are in data list object, <code>FALSE</code> for unweighted analysis, or a vector of user-defined part weights
</p>
</td></tr>
<tr><td><code id="STEP_+3A_random">random</code></td>
<td>

<p><code>TRUE</code> if a random selection is made of tied logratios; <code>FALSE</code> (default) if logratio that maximizes Procrustes correlation is chosen  
</p>
</td></tr>
<tr><td><code id="STEP_+3A_nsteps">nsteps</code></td>
<td>

<p>Number of steps to take (by default, one less than the number of columns of data and of datatarget, whichever is smaller)
</p>
</td></tr>
<tr><td><code id="STEP_+3A_top">top</code></td>
<td>

<p>Number of top variance-explaining logratios returned after last step (by default, 1, i.e. the best) 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>STEP</code> sequentially computes the logratios in a data matrix (usually compositional) that best explain the variance in a second matrix, called the target matrix.  By default, the target matrix is the same matrix, in which case the logratios that best explain the logratio variance in the same matrix are computed.
In this case, weights for the data matrix are assumed by default, proportional to part means of the compositional data matrix.
For the unweighted logratio variance, specify the option <code>weight=FALSE</code>. 
User-specified weights on the columns of the data matrix (usually compositional parts) can be provided using the same <code>weight</code> option. 
</p>
<p>If the target matrix is a different matrix, it is the logratio variance of that matrix that is to be explained.
An option for the target matrix to be any response matrix will be in the next release.
</p>
<p>If <code>nsteps &gt; 1</code> and <code>top=1</code> the results are in the form of an optimal set of logratios that sequentially add maximum explained variance at each step.  
If <code>top&gt;1</code> then at the last step the ordered list of top variance-explaining logratios is returned, which allows users to make an alternative choice of the logratio based on substantive knowledge. Hence, if <code>nsteps=1</code> and <code>top=10</code>, for example, the procedure will move only one step, but list the top 10 logratios for that step.  If <code>top=1</code> then all results with extension <code>.top</code> related to the top ratios are omitted because they are already given.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>names</code></td>
<td>
<p>Names of maximizing ratios in stepwise process</p>
</td></tr>
<tr><td><code>ratios</code></td>
<td>
<p>Indices of ratios</p>
</td></tr>
<tr><td><code>logratios</code></td>
<td>
<p>Matrix of logratios</p>
</td></tr>
<tr><td><code>R2max</code></td>
<td>
<p>Sequence of maximum cumulative explained variances</p>
</td></tr>
<tr><td><code>pro.cor</code></td>
<td>
<p>Corresponding sequence of Procrustes correlations</p>
</td></tr>
<tr><td><code>names.top</code></td>
<td>
<p>Names of &quot;top&quot; ratios at last step</p>
</td></tr>
<tr><td><code>ratios.top</code></td>
<td>
<p>Indices of &quot;top&quot; ratios</p>
</td></tr>
<tr><td><code>logratios.top</code></td>
<td>
<p>Matrix of &quot;top&quot; logratios</p>
</td></tr>
<tr><td><code>R2.top</code></td>
<td>
<p>Sequence of &quot;top&quot; cumulative explained variances (in descending order)</p>
</td></tr>
<tr><td><code>pro.cor.top</code></td>
<td>
<p>Corresponding sequence of &quot;top&quot; Procrustes correlations</p>
</td></tr>
<tr><td><code>totvar</code></td>
<td>
<p>Total logratio variance of target matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Van den Wollenbergh, A. (1977), Redundancy analysis. An alternative to canonical correlation analysis, Psychometrika 42, 207-219.<br />
Greenacre, M. (2018), Variable selection in compositional data analysis using pairwise logratios, Mathematical Geosciences, DOI: 10.1007/s11004-018-9754-x. <br />
Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLOT.RDA">PLOT.RDA</a></code>, <code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+LR">LR</a></code>, <code><a href="#topic+ALR">ALR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stepwise selection of ratios for RomanCups data set
data(cups)
# Set seed to obtain same results as in Appendix C of Greenacre (2018)
set.seed(2872)
STEP(cups, random=TRUE)
# Select best ratio, but output "top 5"
STEP(cups, nsteps=1, top=5)
</code></pre>

<hr>
<h2 id='STEPR'>
Stepwise selection of pairwise logratios for generalized linear modelling
</h2><span id='topic+STEPR'></span>

<h3>Description</h3>

<p>Three different algorithms for selecting pairwise logratios that best explain/predict a response variable, which could be continuous, binary or count
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STEPR(data, y, method = NA, family = "gaussian", nsteps = ncol(data)-1, 
      top = 1, previous = NA, criterion = "Bonferroni", alpha = 0.05, 
      previousparts=NA, denom=NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STEPR_+3A_data">data</code></td>
<td>

<p>A data frame or matrix of compositional data on which the pairwise logratios will be constructed and selected
</p>
</td></tr>
<tr><td><code id="STEPR_+3A_y">y</code></td>
<td>

<p>The response variable: a numeric variable for regression (default)), a binary factor for logistic regression or a numeric count for Poisson regression
</p>
</td></tr>
<tr><td><code id="STEPR_+3A_method">method</code></td>
<td>

<p>The selection method: 1 (unrestricted selection of logratios), 2 (restricted to non-overlapping parts), 3 (additive logratios)
</p>
</td></tr>
<tr><td><code id="STEPR_+3A_family">family</code></td>
<td>

<p>The distribution used in the generalized linear model family: &quot;gaussian&quot; (default, for multiple regression), &quot;binomial&quot; (for logistic regression of binary response), or &quot;poisson&quot; (for Poisson regression)
</p>
</td></tr>
<tr><td><code id="STEPR_+3A_nsteps">nsteps</code></td>
<td>

<p>The maximum number of steps taken, by default one less than the number of parts
</p>
</td></tr>
<tr><td><code id="STEPR_+3A_top">top</code></td>
<td>

<p>When one step is taken (nsteps=1), the ordered list of top logratios with the highest improvements in the likelihood function, for selection based on domain knowledge 
</p>
</td></tr>
<tr><td><code id="STEPR_+3A_previous">previous</code></td>
<td>
	
<p>For specifying variable(s) to be included before stepwise selection takes place; these can be non-compositional variables and/or specific pairwise logratios computed in previous runs of STEPR or by hand; the matrix (or vector for a single variable) of values must be supplied
</p>
</td></tr>
<tr><td><code id="STEPR_+3A_criterion">criterion</code></td>
<td>

<p>Criterion for stopping the stepwise selection: &quot;Bonferroni&quot; (default), &quot;AIC&quot;, &quot;BIC&quot;, or NA for no stopping until maximum specified or permissible logratios entered
</p>
</td></tr>
<tr><td><code id="STEPR_+3A_alpha">alpha</code></td>
<td>
	
<p>Overall significance level (default is 0.05)
</p>
</td></tr>
<tr><td><code id="STEPR_+3A_previousparts">previousparts</code></td>
<td>

<p>(For method 2) The sequence numbers of the logratios, if any, forced in using the previous option
</p>
</td></tr>
<tr><td><code id="STEPR_+3A_denom">denom</code></td>
<td>

<p>(For method 3) The sequence number of the part used in denominator; for use when additive logratios are forced in using previous option or to select a set of additive logratios with specific reference from the start
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>STEPR</code> performs stepwise selection of pairwise logratios with the objective of explaining/predicting a response variable, in the framework of generalized linear modelling where the response can be numeric continuous (regression analysis), or a binary factor (logistic regression), or a numeric count (Poisson regression). The corresponding family option has to be indicated if the regression is logistic or Poisson. The different method options for the stepwise selection are <code>method = 1</code> (unrestricted selection of logratios, any logratios can be selected irrespective of the previous ones), <code>method = 2</code> (restricted to non-overlapping parts, each part participates at most in one logratio, so that parts in previously selected logratios are excluded in subsequent steps; logratio effects can be interpreted as under orthogonality), <code>method = 3</code> (additive logratios, only logratios with the same denominator as the first selected logratio are c onsidered; the result is an additive logratio transformation on a subcomposition) Three alternative stopping criteria can be specified, otherwise the procedure executes as many steps as the value of nsteps. These are (in increasing strictness), &quot;AIC&quot;, &quot;BIC&quot; and &quot;Bonferroni&quot; (the default).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>rationames</code></td>
<td>
<p>Names of the selected logratios</p>
</td></tr>
<tr><td><code>ratios</code></td>
<td>
<p>The sequence numbers of the selected parts in each ratio</p>
</td></tr>
<tr><td><code>logratios</code></td>
<td>
<p>Matrix of selected logratios</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The -2*log-likelihood sequence for the steps</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance sequence for the steps</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>The AIC sequence for the steps</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>The BIC sequence for the steps</p>
</td></tr>
<tr><td><code>Bonferroni</code></td>
<td>
<p>The Bonferroni sequence for the steps</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>The null deviance for the regression</p>
</td></tr>
</table>
<p>(Notice that for <code>logLik</code>, <code>AIC</code>, <code>BIC</code> and <code>Bonferroni</code>, the values for one more step are given, so that the stopping point can be confirmed.)  <br />
</p>
<p>And the following if <code>top &gt; 1</code>: <br />
</p>
<table role = "presentation">
<tr><td><code>ratios.top</code></td>
<td>
<p>The top ratios and the sequence numbers of their parts</p>
</td></tr>
<tr><td><code>logratios.top</code></td>
<td>
<p>The matrix of top logratios</p>
</td></tr>
<tr><td><code>logLik.top</code></td>
<td>
<p>The set of top -2*log-likelihoods</p>
</td></tr>
<tr><td><code>deviance.top</code></td>
<td>
<p>The set of top deviances</p>
</td></tr>
<tr><td><code>AIC.top</code></td>
<td>
<p>The set of top AICs</p>
</td></tr>
<tr><td><code>BIC.top</code></td>
<td>
<p>The set of top BICs</p>
</td></tr>
<tr><td><code>Bonferroni.top</code></td>
<td>
<p>The set of top Bonferronis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Coenders, G. and Greenacre, M. (2021), Three approaches to supervised learning for compositional data with pairwise logratios. aRxiv preprint. URL:https://arxiv.org/abs/2111.08953 <br />
Coenders, G. and Pawlowsky-Glahn, V. (2020), On interpretations of tests and effect sizes in regression models with a compositional predictor. SORT, 44:201-220 <br />
Greenacre, M. (2021), Compositional data analysis, Annual Review of Statistics and its Application, 8: 271-299
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ALR">ALR</a></code>, <code><a href="#topic+STEP">STEP</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For the fish morphometric data, first close (normalize, although not necessary) 
# then loop over the 26*25/2 = 325 possible logratios stepwise
data(fish)
habitat &lt;- fish[,2]
morph &lt;- CLOSE(fish[,4:29])
# predict habitat binary classification from morphometric ratios
fish.step1 &lt;- STEPR(morph, as.factor(habitat), method=1, family="binomial")
# [1] "Criterion increases when 3-th ratio enters"
fish.step1$names
# [1] "Bac/Hg" "Hw/Jl"
# perform logistic regression with selected logratios
fish.glm   &lt;- glm(as.factor(habitat) ~ fish.step1$logratios, family="binomial")
summary(fish.glm)
fish.pred1  &lt;- predict(fish.glm)
table(fish.pred1&gt;0.5, habitat)
#     habitat
#        1  2
# FALSE 56 11
# TRUE   3  5
# (Thus 61/75 correct predictions)
#
# force the sex variable in at the first step before selecting logratios
# and using more strict Bonferroni default
sex &lt;- as.factor(fish[,1]) 
fish.step2 &lt;- STEPR(morph, as.factor(habitat), method=1, previous=sex, family="binomial")
# [1] "Criterion increases when 3-th ratio enters"
fish.step2$names
# [1] "Bac/Hg" "Hw/Jl"
# perform logistic regression with sex and selected logratios
fish.glm   &lt;- glm(as.factor(habitat) ~ sex + fish.step2$logratios, family="binomial")
summary(fish.glm)
# (sex not significant)
#
# check the top 10 ratios at Step 1 to allow domain knowledge to operate
fish.step3 &lt;- STEPR(morph, as.factor(habitat), method=1, nsteps=1, top=10, family="binomial")
cbind(fish.step3$ratios.top, fish.step3$BIC.top)
#        row col         
# Bac/Hg   8  19 67.93744
# Bp/Hg    7  19 69.87134
# Jl/Hg    6  19 70.31554
# Jw/Bp    5   7 71.53671
# Jw/Jl    5   6 71.57122
# Jw/Bac   5   8 71.69294
# Fc/Hg   10  19 72.38560
# Hw/Bac   1   8 73.25325
# Jw/Fc    5  10 73.48882
# Hw/Bp    1   7 73.55621
# Suppose 5th in list, Jw/Jl (Jaw width/Jaw length), preferred at the first step
fish.step4 &lt;- STEPR(morph, as.factor(habitat), method=1, 
                    previous=fish.step3$logratios.top[,5], family="binomial")
# [1] "Criterion increases when 2-th ratio enters"
fish.step4$names
# [1] "Bac/Hg"
# So after Jw/Jl forced in only Bac/Hg enters, the best one originally
</code></pre>

<hr>
<h2 id='time'>Dataset: TimeBudget</h2><span id='topic+time'></span>

<h3>Description</h3>

<p>This data set consists of the average percentage breakdown of time use into six categories, for 16 countries, split by males and females.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(time)</code></pre>


<h3>Format</h3>

<p>Data matrix containing the 32 x 6 matrix. Row samples are labelled by the two-character country code and m (male) or f (female).</p>


<h3>Source</h3>

<p>Greenacre M., Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC, 2018.</p>

<hr>
<h2 id='VAR'>
Variance of a vector of observations, dividing by n rather than n-1
</h2><span id='topic+VAR'></span>

<h3>Description</h3>

<p>This function computes the usual variance but divides by n, not by n-1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAR(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VAR_+3A_x">x</code></td>
<td>

<p>Vector of values for which variance is computed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To think of each of n observations weighted by 1/n this function <code>VAR</code> computes squared deviations from the mean and averages them.
Thus, the sum of squared deviations is divided by n rather than by n-1, as for the unbiased estimate of the variance.
</p>


<h3>Value</h3>

<p>The value of the variance.
</p>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC. <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LR.VAR">LR.VAR</a></code>, <code><a href="#topic+CLOSE">CLOSE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cups)
cups &lt;- CLOSE(cups)

# variances using base R function var
apply(cups, 2, var)

# variances using easyCODA function VAR
apply(cups, 2, VAR)
</code></pre>

<hr>
<h2 id='veg'>Dataset: Vegetables</h2><span id='topic+veg'></span>

<h3>Description</h3>

<p>This data set consists of the protein, carbohydrate and fat compositions of 10 different vegetables. Compositions are expressed as percentages.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(veg)</code></pre>


<h3>Format</h3>

<p>Data frame containing the 10 x 3 matrix.</p>


<h3>Source</h3>

<p>US Department of Agriculture, https://ndb.nal.usda.gov/ndb/nutrients/index</p>

<hr>
<h2 id='WARD'>
Ward clustering of a compositional data matrix
</h2><span id='topic+WARD'></span>

<h3>Description</h3>

<p>This function clusters the rows (or the columns, if the matrix is transformed) of a compositional data matrix, using weighted Ward clustering of the logratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WARD(LRdata, weight=TRUE, row.wt=NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WARD_+3A_lrdata">LRdata</code></td>
<td>

<p>Matrix of logratios, either a vector or preferably the logratio object resulting from one of the functions ALR, CLR, PLR or LR  (usually CLRs will be used))
</p>
</td></tr>
<tr><td><code id="WARD_+3A_weight">weight</code></td>
<td>

<p><code>TRUE</code> (default) for weighted analysis (in which case weights are in the logratio object), <code>FALSE</code> for unweighted analysis, or a vector of user-defined column weights
</p>
</td></tr>
<tr><td><code id="WARD_+3A_row.wt">row.wt</code></td>
<td>

<p>Optional set of row weights (default is equal weights when <code>row.wt=NA</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>WARD</code> performs a weighted WARD hierarchical clustering on the rows of an input set of logratios, usually CLR-transformed.
(This would be equivalent to performing the clustering on all pairwise logratios).
If the columns of the logratio matrix are unweighted, specify the option <code>weight=FALSE</code>: they will then get equal weights.
The default <code>weight=TRUE</code> option implies that column weights are provided, either in the input list object LRdata, as <code>LRdata$LR.wt</code>, or as
a vector of user-specified weights using the same <code>weight</code> option.
</p>


<h3>Value</h3>

<p>An object which describes the tree produced by the clustering process on the n objects. The object is a list with components:
</p>
<table role = "presentation">
<tr><td><code>merge</code></td>
<td>
<p>an n-1 by 2 matrix. Row i of <code>merge</code> describes the merging of clusters at step i of the clustering. If an element j in the row is negative, then observation -j was merged at this stage. If j is positive then the merge was with the cluster formed at the (earlier) stage j of the algorithm. Thus negative entries in <code>merge</code> indicate agglomerations of singletons, and positive entries indicate agglomerations of non-singletons.</p>
</td></tr>
<tr><td><code>height</code></td>
<td>
<p>a set of n-1 real values (non-decreasing for ultrametric trees). The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>a vector giving the permutation of the original observations suitable for plotting, in the sense that a cluster plot using this ordering and matrix merge will not have crossings of the branches</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Greenacre
</p>


<h3>References</h3>

<p>Greenacre, M. (2018), Compositional Data Analysis in Practice, Chapman &amp; Hall / CRC. <br />
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+CLR">CLR</a></code>, <code><a href="#topic+LR.VAR">LR.VAR</a></code>, <code><a href="#topic+CLOSE">CLOSE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># clustering steps for unweighted and weighted logratios
# for both row- and column-clustering
data(cups)
cups &lt;- CLOSE(cups)

# unweighted logratios: clustering samples
cups.uclr  &lt;- CLR(cups, weight=FALSE)
cups.uward &lt;- WARD(cups.uclr, weight=FALSE)   # weight=FALSE not needed here,
                                              # as equal weights are in object
plot(cups.uward)
# add up the heights of the nodes
sum(cups.uward$height)
# [1] 0.02100676
# check against the total logratio variance
LR.VAR(cups.uclr, weight=FALSE)
# [1] 0.02100676

# unweighted logratios: clustering parts
tcups &lt;- t(cups)
tcups.uclr  &lt;- CLR(tcups, weight=FALSE)
tcups.uward &lt;- WARD(tcups.uclr, weight=FALSE)  # weight=FALSE not needed here,
                                               # as equal weights are in object
plot(tcups.uward, labels=colnames(cups))
sum(tcups.uward$height)
# [1] 0.02100676
LR.VAR(tcups.uclr, weight=FALSE)
# [1] 0.02100676

# weighted logratios: clustering samples
cups.clr &lt;- CLR(cups)
cups.ward &lt;- WARD(cups.clr)
plot(cups.ward)
sum(cups.ward$height)
# [1] 0.002339335
LR.VAR(cups.clr)
# [1] 0.002339335

# weighted logratios: clustering parts
# weight=FALSE is needed here, since we want equal weights
# for the samples (columns of tcups)
tcups.clr  &lt;- CLR(tcups, weight=FALSE)
tcups.ward &lt;- WARD(tcups.clr, row.wt=colMeans(cups))
plot(tcups.ward, labels=colnames(cups))
   sum(tcups.ward$height)
# [1] 0.002339335
LR.VAR(tcups.clr, row.wt=colMeans(cups))
# [1] 0.002339335
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
