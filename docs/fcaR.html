<!DOCTYPE html><html lang="en"><head><title>Help for package fcaR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fcaR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fcaR-package'><p>fcaR: Tools for Formal Concept Analysis</p></a></li>
<li><a href='#+25-+25'><p>Difference in Sets</p></a></li>
<li><a href='#+25+26amp+3B+25'><p>Intersection (Logical AND) of Fuzzy Sets</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#+25+26lt+3B+3D+25'><p>Partial Order in Sets and Concepts</p></a></li>
<li><a href='#+25+3D+3D+25'><p>Equality in Sets and Concepts</p></a></li>
<li><a href='#+25~+25'><p>Equivalence of sets of implications</p></a></li>
<li><a href='#+25entails+25'><p>Entailment between implication sets</p></a></li>
<li><a href='#+25holds_in+25'><p>Implications that hold in a Formal Context</p></a></li>
<li><a href='#+25or+25'><p>Union (Logical OR) of Fuzzy Sets</p></a></li>
<li><a href='#+25respects+25'><p>Check if Set or FormalContext respects an ImplicationSet</p></a></li>
<li><a href='#as_Set'><p>Convert Named Vector to Set</p></a></li>
<li><a href='#as_vector'><p>Convert Set to vector</p></a></li>
<li><a href='#cobre32'><p>Data for Differential Diagnosis for Schizophrenia</p></a></li>
<li><a href='#cobre61'><p>Data for Differential Diagnosis for Schizophrenia</p></a></li>
<li><a href='#Concept'><p>R6 class for a fuzzy concept with sparse internal representation</p></a></li>
<li><a href='#ConceptLattice'><p>R6 class for a concept lattice</p></a></li>
<li><a href='#ConceptSet'><p>R6 class for a set of concepts</p></a></li>
<li><a href='#equivalencesRegistry'><p>Equivalence Rules Registry</p></a></li>
<li><a href='#fcaR_options'><p>Set or get options for fcaR</p></a></li>
<li><a href='#FormalContext'><p>R6 class for a formal context</p></a></li>
<li><a href='#ImplicationSet'><p>R6 Class for Set of implications</p></a></li>
<li><a href='#parse_implication'><p>Parses a string into an implication</p></a></li>
<li><a href='#parse_implications'><p>Parses several implications given as a string</p></a></li>
<li><a href='#planets'><p>Planets data</p></a></li>
<li><a href='#scalingRegistry'><p>Scaling Registry</p></a></li>
<li><a href='#Set'><p>R6 class for a fuzzy set with sparse internal representation</p></a></li>
<li><a href='#vegas'><p>Data for Tourist Destination in Las Vegas</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Formal Concept Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Domingo Lopez Rodriguez &lt;dominlopez@uma.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools to perform fuzzy formal concept
    analysis, presented in Wille (1982) &lt;<a href="https://doi.org/10.1007%2F978-3-642-01815-2_23">doi:10.1007/978-3-642-01815-2_23</a>&gt;
    and in Ganter and Obiedkov (2016) &lt;<a href="https://doi.org/10.1007%2F978-3-662-49291-8">doi:10.1007/978-3-662-49291-8</a>&gt;.  It
    provides functions to load and save a formal context, extract its
    concept lattice and implications.  In addition, one can use the
    implications to compute semantic closures of fuzzy sets and, thus,
    build recommendation systems.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Malaga-FCA-group/fcaR">https://github.com/Malaga-FCA-group/fcaR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Malaga-FCA-group/fcaR/issues">https://github.com/Malaga-FCA-group/fcaR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, forcats, fractional, ggplot2, glue, grDevices, Matrix,
methods, POSetR, R6, rlang, Rcpp, registry, settings, stringr,
tibble, tidyr, tikzDevice, magrittr, purrr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>arules, covr, hasseDiagram, knitr, markdown, rmarkdown,
testthat (&ge; 2.1.0), tictoc, tinytex, parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 10:56:08 UTC; domingo</td>
</tr>
<tr>
<td>Author:</td>
<td>Domingo Lopez Rodriguez
    <a href="https://orcid.org/0000-0002-0172-1585"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Angel Mora [aut],
  Jesus Dominguez [aut],
  Ana Villalon [aut],
  Ian Johnson [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fcaR-package'>fcaR: Tools for Formal Concept Analysis</h2><span id='topic+fcaR'></span><span id='topic+fcaR-package'></span>

<h3>Description</h3>

<p>The aim of this package is to provide tools to perform  fuzzy formal concept analysis (FCA) from within R.
It provides functions to load and save a Formal Context, extract its concept lattice and implications.
In addition, one can use the implications to compute semantic closures of fuzzy sets and, thus, build recommendation systems.
</p>


<h3>Details</h3>

<p>The fcaR package provides data structures which allow the user to work seamlessly with formal contexts and sets of implications. More explicitly, three main classes are implemented, using the <code>R6</code> object-oriented-programming paradigm in R:
</p>

<ul>
<li> <p><code>FormalContext</code> encapsulates the definition of a formal context <code class="reqn">(G, M, I)</code>, being <code class="reqn">G</code> the set of objects, <code class="reqn">M</code> the set of attributes and <code class="reqn">I</code> the (fuzzy) relationship matrix, and provides methods to operate on the context using FCA tools.
</p>
</li>
<li> <p><code>ImplicationSet</code> represents a set of implications over a specific formal context.
</p>
</li>
<li> <p><code>ConceptLattice</code> represents the set of concepts and their relationships, including methods to operate on the lattice.
</p>
</li></ul>

<p>Two additional helper classes are implemented:
</p>

<ul>
<li> <p><code>Set</code> is a class solely used for visualization purposes, since it encapsulates in sparse format a (fuzzy) set.
</p>
</li>
<li> <p><code>Concept</code> encapsulates internally both extent and intent of a formal concept as <code>Set</code>.
Since fcaR is an extension of the data model in the arules package, most of the methods and classes implemented interoperates with the main <code>S4</code> classes in arules (<code>transactions</code> and <code>rules</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Domingo Lopez Rodriguez <a href="mailto:dominlopez@uma.es">dominlopez@uma.es</a> (<a href="https://orcid.org/0000-0002-0172-1585">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Angel Mora <a href="mailto:amorabonilla@gmail.com">amorabonilla@gmail.com</a>
</p>
</li>
<li><p> Jesus Dominguez
</p>
</li>
<li><p> Ana Villalon
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Ian Johnson [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Guigues J, Duquenne V (1986). “Familles minimales d'implications informatives résultant d'un tableau de données binaires.” <em>Mathématiques et Sciences humaines</em>, <em>95</em>, 5-18.
</p>
<p>Ganter B, Wille R (1999). <em>Formal concept analysis : mathematical foundations</em>. Springer. ISBN 3540627715.
</p>
<p>Cordero P, Enciso M, Mora Á, Pérez de Guzman I (2002). “SLFD Logic: Elimination of Data Redundancy in Knowledge Representation.” <em>Advances in Artificial Intelligence -   IBERAMIA 2002</em>, <em>2527</em>, 141-150. doi:   10.1007/3-540-36131-6_15 (URL: http://doi.org/10.1007/3-540-36131-6_15).
</p>
<p>Belohlavek R (2002). “Algorithms for fuzzy concept lattices.” In <em>Proc. Fourth Int. Conf. on Recent Advances in Soft Computing</em>. Nottingham, United Kingdom, 200-205.
</p>
<p>Hahsler M, Grun B, Hornik K (2005). “arules - a computational environment for mining association rules and frequent item sets.” <em>J Stat Softw</em>, <em>14</em>, 1-25.
</p>
<p>Mora A, Cordero P, Enciso M, Fortes I, Aguilera G (2012). “Closure via functional dependence simplification.” <em>International Journal of Computer Mathematics</em>, <em>89</em>(4), 510-526.
Belohlavek R, Cordero P, Enciso M, Mora Á, Vychodil V (2016). “Automated prover for attribute dependencies in data with grades.” <em>International Journal of Approximate Reasoning</em>, <em>70</em>, 51-67.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Malaga-FCA-group/fcaR">https://github.com/Malaga-FCA-group/fcaR</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Malaga-FCA-group/fcaR/issues">https://github.com/Malaga-FCA-group/fcaR/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Build a formal context
fc_planets &lt;- FormalContext$new(planets)

# Find its concepts and implications
fc_planets$find_implications()

# Print the extracted implications
fc_planets$implications

</code></pre>

<hr>
<h2 id='+25-+25'>Difference in Sets</h2><span id='topic++25-+25'></span>

<h3>Description</h3>

<p>Difference in Sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S1 %-% S2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25-+2B25_+3A_s1">S1</code></td>
<td>
<p>A <code>Set</code></p>
</td></tr>
<tr><td><code id="+2B25-+2B25_+3A_s2">S2</code></td>
<td>
<p>A <code>Set</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>S1</code> and <code>S2</code> must be Sets.
</p>


<h3>Value</h3>

<p>Returns the difference <code>S1 - S2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build two sparse sets
S &lt;- Set$new(attributes = c("A", "B", "C"))
S$assign(A = 1, B = 1)
T &lt;- Set$new(attributes = c("A", "B", "C"))
T$assign(A = 1)

# Difference
S %-% T

</code></pre>

<hr>
<h2 id='+25+26amp+3B+25'>Intersection (Logical AND) of Fuzzy Sets</h2><span id='topic++25+26+25'></span>

<h3>Description</h3>

<p>Intersection (Logical AND) of Fuzzy Sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S1 %&amp;% S2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26amp+2B3B+2B25_+3A_s1">S1</code></td>
<td>
<p>A <code>Set</code></p>
</td></tr>
<tr><td><code id="+2B25+2B26amp+2B3B+2B25_+3A_s2">S2</code></td>
<td>
<p>A <code>Set</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>S1</code> and <code>S2</code> must be Sets.
</p>


<h3>Value</h3>

<p>Returns the intersection of <code>S1</code> and <code>S2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build two sparse sets
S &lt;- Set$new(attributes = c("A", "B", "C"))
S$assign(A = 1, B = 1)
T &lt;- Set$new(attributes = c("A", "B", "C"))
T$assign(A = 1, C = 1)

# Intersection
S %&amp;% T

</code></pre>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='+25+26lt+3B+3D+25'>Partial Order in Sets and Concepts</h2><span id='topic++25+3C+3D+25'></span>

<h3>Description</h3>

<p>Partial Order in Sets and Concepts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C1 %&lt;=% C2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26lt+2B3B+2B3D+2B25_+3A_c1">C1</code></td>
<td>
<p>A <code>Set</code> or <code>Concept</code></p>
</td></tr>
<tr><td><code id="+2B25+2B26lt+2B3B+2B3D+2B25_+3A_c2">C2</code></td>
<td>
<p>A <code>Set</code> or <code>Concept</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>C1</code> and <code>C2</code> must be of the same class.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if concept <code>C1</code> is subconcept of <code>C2</code> or if set <code>C1</code> is subset of <code>C2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build two sparse sets
S &lt;- Set$new(attributes = c("A", "B", "C"))
S$assign(A = 1)
T &lt;- Set$new(attributes = c("A", "B", "C"))
T$assign(A = 1, B = 1)

# Test whether S is subset of T
S %&lt;=% T

</code></pre>

<hr>
<h2 id='+25+3D+3D+25'>Equality in Sets and Concepts</h2><span id='topic++25+3D+3D+25'></span>

<h3>Description</h3>

<p>Equality in Sets and Concepts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C1 %==% C2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B3D+2B3D+2B25_+3A_c1">C1</code></td>
<td>
<p>A <code>Set</code> or <code>Concept</code></p>
</td></tr>
<tr><td><code id="+2B25+2B3D+2B3D+2B25_+3A_c2">C2</code></td>
<td>
<p>A <code>Set</code> or <code>Concept</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>C1</code> and <code>C2</code> must be of the same class.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>C1</code> is equal to <code>C2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build two sparse sets
S &lt;- Set$new(attributes = c("A", "B", "C"))
S$assign(A = 1)
T &lt;- Set$new(attributes = c("A", "B", "C"))
T$assign(A = 1)

# Test whether S and T are equal
S %==% T

</code></pre>

<hr>
<h2 id='+25~+25'>Equivalence of sets of implications</h2><span id='topic++25~+25'></span>

<h3>Description</h3>

<p>Equivalence of sets of implications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imps %~% imps2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25~+2B25_+3A_imps">imps</code></td>
<td>
<p>A <code>ImplicationSet</code>.</p>
</td></tr>
<tr><td><code id="+2B25~+2B25_+3A_imps2">imps2</code></td>
<td>
<p>Another <code>ImplicationSet</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> of and only if <code>imps</code> and <code>imps2</code>
are equivalent, that is, if every implication in <code>imps</code>
follows from <code>imps2</code> and viceversa.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fc &lt;- FormalContext$new(planets)
fc$find_implications()
imps &lt;- fc$implications$clone()
imps2 &lt;- imps$clone()
imps2$apply_rules(c("simp", "rsimp"))
imps %~% imps2
imps %~% imps2[1:9]
</code></pre>

<hr>
<h2 id='+25entails+25'>Entailment between implication sets</h2><span id='topic++25entails+25'></span>

<h3>Description</h3>

<p>Entailment between implication sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imps %entails% imps2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25entails+2B25_+3A_imps">imps</code></td>
<td>
<p>(<code>ImplicationSet</code>) A set of implications.</p>
</td></tr>
<tr><td><code id="+2B25entails+2B25_+3A_imps2">imps2</code></td>
<td>
<p>(<code>ImplicationSet</code>) A set of implications which
is tested to check if it follows semantically from <code>imps</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, where element k is <code>TRUE</code> if the
k-th implication in <code>imps2</code> follows from <code>imps</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fc &lt;- FormalContext$new(planets)
fc$find_implications()
imps &lt;- fc$implications[1:4]$clone()
imps2 &lt;- fc$implications[3:6]$clone()
imps %entails% imps2
</code></pre>

<hr>
<h2 id='+25holds_in+25'>Implications that hold in a Formal Context</h2><span id='topic++25holds_in+25'></span>

<h3>Description</h3>

<p>Implications that hold in a Formal Context
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imps %holds_in% fc
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25holds_in+2B25_+3A_imps">imps</code></td>
<td>
<p>(<code>ImplicationSet</code>) The set of implications to test if hold in the formal context.</p>
</td></tr>
<tr><td><code id="+2B25holds_in+2B25_+3A_fc">fc</code></td>
<td>
<p>(<code>FormalContext</code>) A formal context where to test if the implications hold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, indicating if each implication holds in the formal context.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fc &lt;- FormalContext$new(planets)
fc$find_implications()
imps &lt;- fc$implications$clone()
imps %holds_in% fc

</code></pre>

<hr>
<h2 id='+25or+25'>Union (Logical OR) of Fuzzy Sets</h2><span id='topic++25or+25'></span><span id='topic++25+7C+25'></span>

<h3>Description</h3>

<p>Union (Logical OR) of Fuzzy Sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S1 %|% S2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25or+2B25_+3A_s1">S1</code></td>
<td>
<p>A <code>Set</code></p>
</td></tr>
<tr><td><code id="+2B25or+2B25_+3A_s2">S2</code></td>
<td>
<p>A <code>Set</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>S1</code> and <code>S2</code> must be Sets.
</p>


<h3>Value</h3>

<p>Returns the union of <code>S1</code> and <code>S2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build two sparse sets
S &lt;- Set$new(attributes = c("A", "B", "C"))
S$assign(A = 1, B = 1)
T &lt;- Set$new(attributes = c("A", "B", "C"))
T$assign(C = 1)

# Union
S %|% T

</code></pre>

<hr>
<h2 id='+25respects+25'>Check if Set or FormalContext respects an ImplicationSet</h2><span id='topic++25respects+25'></span>

<h3>Description</h3>

<p>Check if Set or FormalContext respects an ImplicationSet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set %respects% imps
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25respects+2B25_+3A_set">set</code></td>
<td>
<p>(list of <code>Set</code>s, or a <code>FormalContext</code>) The sets of attributes to check whether they respect the <code>ImplicationSet</code>.</p>
</td></tr>
<tr><td><code id="+2B25respects+2B25_+3A_imps">imps</code></td>
<td>
<p>(<code>ImplicationSet</code>) The set of implications to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical matrix with as many rows as <code>Set</code>s and as many columns as implications in the <code>ImplicationSet</code>. A <code>TRUE</code> in element (i, j) of the result means that the i-th <code>Set</code> respects the j-th implication of the <code>ImplicationSet</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fc &lt;- FormalContext$new(planets)
fc$find_implications()
imps &lt;- fc$implications$clone()
fc %respects% imps
</code></pre>

<hr>
<h2 id='as_Set'>Convert Named Vector to Set</h2><span id='topic+as_Set'></span>

<h3>Description</h3>

<p>Convert Named Vector to Set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_Set(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_Set_+3A_a">A</code></td>
<td>
<p>A named vector or matrix to build a new <code>Set</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Set</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- c(a = 0.1, b = 0.2, p = 0.3, q = 0)
as_Set(A)

</code></pre>

<hr>
<h2 id='as_vector'>Convert Set to vector</h2><span id='topic+as_vector'></span>

<h3>Description</h3>

<p>Convert Set to vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_vector(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_vector_+3A_v">v</code></td>
<td>
<p>A <code>Set</code> to convert to vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- c(a = 0.1, b = 0.2, p = 0.3, q = 0)
v &lt;- as_Set(A)
A2 &lt;- as_vector(v)
all(A == A2)

</code></pre>

<hr>
<h2 id='cobre32'>Data for Differential Diagnosis for Schizophrenia</h2><span id='topic+cobre32'></span>

<h3>Description</h3>

<p>A subset of the COBRE dataset has been retrieved, by querying SchizConnect for 105 patients with neurological and clinical symptoms, collecting also their corresponding diagnosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cobre32
</code></pre>


<h3>Format</h3>

<p>A matrix with 105 rows and 32 columns. Column names are related to different scales for depression and Schizophrenia:
</p>

<dl>
<dt>COSAS_n</dt><dd><p>The <em>Simpson-Angus Scale</em>, 7 items to evaluate Parkinsonism-like alterations, related to schizophrenia, in an individual.</p>
</dd>
<dt>FICAL_n</dt><dd><p>The <em>Calgary Depression Scale for Schizophrenia</em>, 9 items (attributes) assessing the level of depression in schizophrenia, differentiating between positive and negative aspects of the disease.</p>
</dd>
<dt>SCIDII_n</dt><dd><p>The <em>Structured Clinical Interview for DSM-III-R Personality Disorders</em>, with 14 variables related to the presence of signs affecting personality.</p>
</dd>
<dt>dx_ss</dt><dd><p>if <code>TRUE</code>, the diagnosis is strict schizophrenia.</p>
</dd>
<dt>dx_other</dt><dd><p>it <code>TRUE</code>, the diagnosis is other than schizophrenia, including schizoaffective, bipolar disorder and major depression.</p>
</dd>
</dl>

<p>In summary, the dataset consists in the previous 30 attributes related to signs or symptoms, and 2 attributes related to diagnosis (these diagnoses are mutually exclusive, thus only one of them is assigned to each patient). This makes a dataset with 105 objects (patients) and 32 attributes to explore. The symptom attributes are multi-valued.
</p>
<p>Thus, according to the specific scales used, all attributes are fuzzy and graded. For a given attribute (symptom), the available grades range from <em>absent</em> to <em>extreme</em>, with <em>minimal</em>, <em>mild</em>, <em>moderate</em>, <em>moderate severe</em> and <em>severe</em> in between.
</p>
<p>These fuzzy attributes are mapped to values in the interval [0, 1].
</p>


<h3>Source</h3>

<p>Aine, C. J., Bockholt, H. J., Bustillo, J. R., Cañive, J. M., Caprihan, A., Gasparovic, C., ... &amp; Liu, J. (2017). Multimodal neuroimaging in schizophrenia: description and dissemination. Neuroinformatics, 15(4), 343-364.
<a href="https://pubmed.ncbi.nlm.nih.gov/26142271/">https://pubmed.ncbi.nlm.nih.gov/26142271/</a>
</p>

<hr>
<h2 id='cobre61'>Data for Differential Diagnosis for Schizophrenia</h2><span id='topic+cobre61'></span>

<h3>Description</h3>

<p>A subset of the COBRE dataset has been retrieved, by querying SchizConnect for 105 patients with neurological and clinical symptoms, collecting also their corresponding diagnosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cobre61
</code></pre>


<h3>Format</h3>

<p>A matrix with 105 rows and 61 columns. Column names are related to different scales for depression and Schizophrenia:
</p>

<dl>
<dt>COSAS_n</dt><dd><p>The <em>Simpson-Angus Scale</em>, 7 items to evaluate Parkinsonism-like alterations, related to schizophrenia, in an individual.</p>
</dd>
<dt>FIPAN_n</dt><dd><p>The <em>Positive and Negative Syndrome Scale</em>, a set of 29 attributes measuring different aspects and symptoms in schizophrenia.</p>
</dd>
<dt>FICAL_n</dt><dd><p> The <em>Calgary Depression Scale for Schizophrenia</em>, 9 items (attributes) assessing the level of depression in schizophrenia, differentiating between positive and negative aspects of the disease.</p>
</dd>
<dt>SCIDII_n</dt><dd><p>The <em>Structured Clinical Interview for DSM-III-R Personality Disorders</em>, with 14 variables related to the presence of signs affecting personality.</p>
</dd>
<dt>dx_ss</dt><dd><p>if <code>TRUE</code>, the diagnosis is strict schizophrenia.</p>
</dd>
<dt>dx_other</dt><dd><p>it <code>TRUE</code>, the diagnosis is other than schizophrenia, including schizoaffective, bipolar disorder and major depression.</p>
</dd>
</dl>

<p>In summary, the dataset consists in the previous 59 attributes related to signs or symptoms, and 2 attributes related to diagnosis (these diagnoses are mutually exclusive, thus only one of them is assigned to each patient). This makes a dataset with 105 objects (patients) and 61 attributes to explore. The symptom attributes are multi-valued.
</p>
<p>Thus, according to the specific scales used, all attributes are fuzzy and graded. For a given attribute (symptom), the available grades range from <em>absent</em> to <em>extreme</em>, with <em>minimal</em>, <em>mild</em>, <em>moderate</em>, <em>moderate severe</em> and <em>severe</em> in between.
</p>
<p>These fuzzy attributes are mapped to values in the interval [0, 1].
</p>


<h3>Source</h3>

<p>Aine, C. J., Bockholt, H. J., Bustillo, J. R., Cañive, J. M., Caprihan, A., Gasparovic, C., ... &amp; Liu, J. (2017). Multimodal neuroimaging in schizophrenia: description and dissemination. Neuroinformatics, 15(4), 343-364.
<a href="https://pubmed.ncbi.nlm.nih.gov/26142271/">https://pubmed.ncbi.nlm.nih.gov/26142271/</a>
</p>

<hr>
<h2 id='Concept'>R6 class for a fuzzy concept with sparse internal representation</h2><span id='topic+Concept'></span>

<h3>Description</h3>

<p>This class implements the data structure and methods for fuzzy concepts.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Concept-new"><code>Concept$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Concept-get_extent"><code>Concept$get_extent()</code></a>
</p>
</li>
<li> <p><a href="#method-Concept-get_intent"><code>Concept$get_intent()</code></a>
</p>
</li>
<li> <p><a href="#method-Concept-print"><code>Concept$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Concept-to_latex"><code>Concept$to_latex()</code></a>
</p>
</li>
<li> <p><a href="#method-Concept-clone"><code>Concept$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Concept-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creator for objects of class <code>Concept</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Concept$new(extent, intent)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>extent</code></dt><dd><p>(<code>Set</code>) The extent of the concept.</p>
</dd>
<dt><code>intent</code></dt><dd><p>(<code>Set</code>) The intent of the concept.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code>Concept</code>.
</p>


<hr>
<a id="method-Concept-get_extent"></a>



<h4>Method <code>get_extent()</code></h4>

<p>Internal <code>Set</code> for the extent
</p>


<h5>Usage</h5>

<div class="r"><pre>Concept$get_extent()</pre></div>



<h5>Returns</h5>

<p>The <code>Set</code> representation of the extent.
</p>


<hr>
<a id="method-Concept-get_intent"></a>



<h4>Method <code>get_intent()</code></h4>

<p>Internal <code>Set</code> for the intent
</p>


<h5>Usage</h5>

<div class="r"><pre>Concept$get_intent()</pre></div>



<h5>Returns</h5>

<p>The <code>Set</code> representation of the intent.
</p>


<hr>
<a id="method-Concept-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints the concept to console
</p>


<h5>Usage</h5>

<div class="r"><pre>Concept$print()</pre></div>



<h5>Returns</h5>

<p>A string with the elements of the set and their grades between brackets .
</p>


<hr>
<a id="method-Concept-to_latex"></a>



<h4>Method <code>to_latex()</code></h4>

<p>Write the concept in LaTeX format
</p>


<h5>Usage</h5>

<div class="r"><pre>Concept$to_latex(print = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>print</code></dt><dd><p>(logical) Print to output?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The fuzzy concept in LaTeX.
</p>


<hr>
<a id="method-Concept-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Concept$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Build a formal context and find its concepts
fc_planets &lt;- FormalContext$new(planets)
fc_planets$find_concepts()

# Print the first three concepts
fc_planets$concepts[1:3]

# Select the first concept:
C &lt;- fc_planets$concepts$sub(1)

# Get its extent and intent
C$get_extent()
C$get_intent()

</code></pre>

<hr>
<h2 id='ConceptLattice'>R6 class for a concept lattice</h2><span id='topic+ConceptLattice'></span>

<h3>Description</h3>

<p>This class implements the data structure and methods for concept lattices.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ConceptSet">fcaR::ConceptSet</a></code> -&gt; <code>ConceptLattice</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ConceptLattice-new"><code>ConceptLattice$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-plot"><code>ConceptLattice$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-sublattice"><code>ConceptLattice$sublattice()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-top"><code>ConceptLattice$top()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-bottom"><code>ConceptLattice$bottom()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-join_irreducibles"><code>ConceptLattice$join_irreducibles()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-meet_irreducibles"><code>ConceptLattice$meet_irreducibles()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-decompose"><code>ConceptLattice$decompose()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-supremum"><code>ConceptLattice$supremum()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-infimum"><code>ConceptLattice$infimum()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-subconcepts"><code>ConceptLattice$subconcepts()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-superconcepts"><code>ConceptLattice$superconcepts()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-lower_neighbours"><code>ConceptLattice$lower_neighbours()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-upper_neighbours"><code>ConceptLattice$upper_neighbours()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptLattice-clone"><code>ConceptLattice$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="fcaR" data-topic="ConceptSet" data-id="["><a href='../../fcaR/html/ConceptSet.html#method-ConceptSet-bracket'><code>fcaR::ConceptSet$[()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fcaR" data-topic="ConceptSet" data-id="extents"><a href='../../fcaR/html/ConceptSet.html#method-ConceptSet-extents'><code>fcaR::ConceptSet$extents()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fcaR" data-topic="ConceptSet" data-id="intents"><a href='../../fcaR/html/ConceptSet.html#method-ConceptSet-intents'><code>fcaR::ConceptSet$intents()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fcaR" data-topic="ConceptSet" data-id="is_empty"><a href='../../fcaR/html/ConceptSet.html#method-ConceptSet-is_empty'><code>fcaR::ConceptSet$is_empty()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fcaR" data-topic="ConceptSet" data-id="print"><a href='../../fcaR/html/ConceptSet.html#method-ConceptSet-print'><code>fcaR::ConceptSet$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fcaR" data-topic="ConceptSet" data-id="size"><a href='../../fcaR/html/ConceptSet.html#method-ConceptSet-size'><code>fcaR::ConceptSet$size()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fcaR" data-topic="ConceptSet" data-id="sub"><a href='../../fcaR/html/ConceptSet.html#method-ConceptSet-sub'><code>fcaR::ConceptSet$sub()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fcaR" data-topic="ConceptSet" data-id="support"><a href='../../fcaR/html/ConceptSet.html#method-ConceptSet-support'><code>fcaR::ConceptSet$support()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fcaR" data-topic="ConceptSet" data-id="to_latex"><a href='../../fcaR/html/ConceptSet.html#method-ConceptSet-to_latex'><code>fcaR::ConceptSet$to_latex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="fcaR" data-topic="ConceptSet" data-id="to_list"><a href='../../fcaR/html/ConceptSet.html#method-ConceptSet-to_list'><code>fcaR::ConceptSet$to_list()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ConceptLattice-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>ConceptLattice</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$new(extents, intents, objects, attributes, I = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>extents</code></dt><dd><p>(<code>dgCMatrix</code>) The extents of all concepts</p>
</dd>
<dt><code>intents</code></dt><dd><p>(<code>dgCMatrix</code>) The intents of all concepts</p>
</dd>
<dt><code>objects</code></dt><dd><p>(character vector) Names of the objects in the formal context</p>
</dd>
<dt><code>attributes</code></dt><dd><p>(character vector) Names of the attributes in the formal context</p>
</dd>
<dt><code>I</code></dt><dd><p>(<code>dgCMatrix</code>) The matrix of the formal context</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>ConceptLattice</code> object.
</p>


<hr>
<a id="method-ConceptLattice-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot the concept lattice
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$plot(object_names = TRUE, to_latex = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>object_names</code></dt><dd><p>(logical) If <code>TRUE</code>, plot object names, otherwise omit them from the diagram.</p>
</dd>
<dt><code>to_latex</code></dt><dd><p>(logical) If <code>TRUE</code>, export the plot as a <code>tikzpicture</code> environment that can be included in a <code>LaTeX</code> file.</p>
</dd>
<dt><code>...</code></dt><dd><p>Other parameters to be passed to the <code>tikzDevice</code> that renders the lattice in <code>LaTeX</code>, or for the figure caption. See <code>Details</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Particular parameters that control the size of the <code>tikz</code> output are: <code>width</code>, <code>height</code> (both in inches), and <code>pointsize</code> (in points), that should be set to the font size used in the <code>documentclass</code> header in the <code>LaTeX</code> file where the code is to be inserted.
</p>
<p>If a <code>caption</code> is provided, the whole <code>tikz</code> picture will be wrapped by a <code>figure</code> environment and the caption set.
</p>



<h5>Returns</h5>

<p>If <code>to_latex</code> is <code>FALSE</code>, it returns nothing, just plots the graph of the concept lattice. Otherwise, this function returns the <code>LaTeX</code> code to reproduce the concept lattice.
</p>


<hr>
<a id="method-ConceptLattice-sublattice"></a>



<h4>Method <code>sublattice()</code></h4>

<p>Sublattice
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$sublattice(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>See Details.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>As argument, one can provide both integer indices or <code>Concepts</code>, separated by commas. The corresponding concepts are used to generate a sublattice.
</p>



<h5>Returns</h5>

<p>The generated sublattice as a new <code>ConceptLattice</code> object.
</p>


<hr>
<a id="method-ConceptLattice-top"></a>



<h4>Method <code>top()</code></h4>

<p>Top of a Lattice
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$top()</pre></div>



<h5>Returns</h5>

<p>The top of the Concept Lattice
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>fc &lt;- FormalContext$new(planets)
fc$find_concepts()
fc$concepts$top()

</pre>
</div>


<hr>
<a id="method-ConceptLattice-bottom"></a>



<h4>Method <code>bottom()</code></h4>

<p>Bottom of a Lattice
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$bottom()</pre></div>



<h5>Returns</h5>

<p>The bottom of the Concept Lattice
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>fc &lt;- FormalContext$new(planets)
fc$find_concepts()
fc$concepts$bottom()

</pre>
</div>


<hr>
<a id="method-ConceptLattice-join_irreducibles"></a>



<h4>Method <code>join_irreducibles()</code></h4>

<p>Join-irreducible Elements
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$join_irreducibles()</pre></div>



<h5>Returns</h5>

<p>The join-irreducible elements in the concept lattice.
</p>


<hr>
<a id="method-ConceptLattice-meet_irreducibles"></a>



<h4>Method <code>meet_irreducibles()</code></h4>

<p>Meet-irreducible Elements
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$meet_irreducibles()</pre></div>



<h5>Returns</h5>

<p>The meet-irreducible elements in the concept lattice.
</p>


<hr>
<a id="method-ConceptLattice-decompose"></a>



<h4>Method <code>decompose()</code></h4>

<p>Decompose a concept as the supremum of meet-irreducible concepts
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$decompose(C)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>C</code></dt><dd><p>A list of <code>Concept</code>s</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list, each field is the set of meet-irreducible elements whose supremum is the corresponding element in <code>C</code>.
</p>


<hr>
<a id="method-ConceptLattice-supremum"></a>



<h4>Method <code>supremum()</code></h4>

<p>Supremum of Concepts
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$supremum(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>See Details.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>As argument, one can provide both integer indices or <code>Concepts</code>, separated by commas. The corresponding concepts are used to compute their supremum in the lattice.
</p>



<h5>Returns</h5>

<p>The supremum of the list of concepts.
</p>


<hr>
<a id="method-ConceptLattice-infimum"></a>



<h4>Method <code>infimum()</code></h4>

<p>Infimum of Concepts
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$infimum(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>See Details.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>As argument, one can provide both integer indices or <code>Concepts</code>, separated by commas. The corresponding concepts are used to compute their infimum in the lattice.
</p>



<h5>Returns</h5>

<p>The infimum of the list of concepts.
</p>


<hr>
<a id="method-ConceptLattice-subconcepts"></a>



<h4>Method <code>subconcepts()</code></h4>

<p>Subconcepts of a Concept
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$subconcepts(C)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>C</code></dt><dd><p>(numeric or <code>SparseConcept</code>) The concept to which determine all its subconcepts.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the subconcepts.
</p>


<hr>
<a id="method-ConceptLattice-superconcepts"></a>



<h4>Method <code>superconcepts()</code></h4>

<p>Superconcepts of a Concept
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$superconcepts(C)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>C</code></dt><dd><p>(numeric or <code>SparseConcept</code>) The concept to which determine all its superconcepts.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the superconcepts.
</p>


<hr>
<a id="method-ConceptLattice-lower_neighbours"></a>



<h4>Method <code>lower_neighbours()</code></h4>

<p>Lower Neighbours of a Concept
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$lower_neighbours(C)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>C</code></dt><dd><p>(<code>SparseConcept</code>) The concept to which find its lower neighbours</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the lower neighbours of <code>C</code>.
</p>


<hr>
<a id="method-ConceptLattice-upper_neighbours"></a>



<h4>Method <code>upper_neighbours()</code></h4>

<p>Upper Neighbours of a Concept
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$upper_neighbours(C)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>C</code></dt><dd><p>(<code>SparseConcept</code>) The concept to which find its upper neighbours</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the upper neighbours of <code>C</code>.
</p>


<hr>
<a id="method-ConceptLattice-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptLattice$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Build a formal context
fc_planets &lt;- FormalContext$new(planets)

# Find the concepts
fc_planets$find_concepts()

# Find join- and meet- irreducible elements
fc_planets$concepts$join_irreducibles()
fc_planets$concepts$meet_irreducibles()

# Get concept support
fc_planets$concepts$support()


## ------------------------------------------------
## Method `ConceptLattice$top`
## ------------------------------------------------

fc &lt;- FormalContext$new(planets)
fc$find_concepts()
fc$concepts$top()


## ------------------------------------------------
## Method `ConceptLattice$bottom`
## ------------------------------------------------

fc &lt;- FormalContext$new(planets)
fc$find_concepts()
fc$concepts$bottom()

</code></pre>

<hr>
<h2 id='ConceptSet'>R6 class for a set of concepts</h2><span id='topic+ConceptSet'></span>

<h3>Description</h3>

<p>This class implements the data structure and methods for concept sets.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ConceptSet-new"><code>ConceptSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-size"><code>ConceptSet$size()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-is_empty"><code>ConceptSet$is_empty()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-extents"><code>ConceptSet$extents()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-intents"><code>ConceptSet$intents()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-print"><code>ConceptSet$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-to_latex"><code>ConceptSet$to_latex()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-to_list"><code>ConceptSet$to_list()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-bracket"><code>ConceptSet$[()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-sub"><code>ConceptSet$sub()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-support"><code>ConceptSet$support()</code></a>
</p>
</li>
<li> <p><a href="#method-ConceptSet-clone"><code>ConceptSet$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ConceptSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>ConceptLattice</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$new(extents, intents, objects, attributes, I = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>extents</code></dt><dd><p>(<code>dgCMatrix</code>) The extents of all concepts</p>
</dd>
<dt><code>intents</code></dt><dd><p>(<code>dgCMatrix</code>) The intents of all concepts</p>
</dd>
<dt><code>objects</code></dt><dd><p>(character vector) Names of the objects in the formal context</p>
</dd>
<dt><code>attributes</code></dt><dd><p>(character vector) Names of the attributes in the formal context</p>
</dd>
<dt><code>I</code></dt><dd><p>(<code>dgCMatrix</code>) The matrix of the formal context</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>ConceptLattice</code> object.
</p>


<hr>
<a id="method-ConceptSet-size"></a>



<h4>Method <code>size()</code></h4>

<p>Size of the Lattice
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$size()</pre></div>



<h5>Returns</h5>

<p>The number of concepts in the lattice.
</p>


<hr>
<a id="method-ConceptSet-is_empty"></a>



<h4>Method <code>is_empty()</code></h4>

<p>Is the lattice empty?
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$is_empty()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if the lattice has no concepts.
</p>


<hr>
<a id="method-ConceptSet-extents"></a>



<h4>Method <code>extents()</code></h4>

<p>Concept Extents
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$extents()</pre></div>



<h5>Returns</h5>

<p>The extents of all concepts, as a <code>dgCMatrix</code>.
</p>


<hr>
<a id="method-ConceptSet-intents"></a>



<h4>Method <code>intents()</code></h4>

<p>Concept Intents
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$intents()</pre></div>



<h5>Returns</h5>

<p>The intents of all concepts, as a <code>dgCMatrix</code>.
</p>


<hr>
<a id="method-ConceptSet-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the Concept Set
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$print()</pre></div>



<h5>Returns</h5>

<p>Nothing, just prints the concepts
</p>


<hr>
<a id="method-ConceptSet-to_latex"></a>



<h4>Method <code>to_latex()</code></h4>

<p>Write in LaTeX
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$to_latex(print = TRUE, ncols = 1, numbered = TRUE, align = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>print</code></dt><dd><p>(logical) Print to output?</p>
</dd>
<dt><code>ncols</code></dt><dd><p>(integer) Number of columns of the output.</p>
</dd>
<dt><code>numbered</code></dt><dd><p>(logical) Number the concepts?</p>
</dd>
<dt><code>align</code></dt><dd><p>(logical) Align objects and attributes independently?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The <code>LaTeX</code> code to list all concepts.
</p>


<hr>
<a id="method-ConceptSet-to_list"></a>



<h4>Method <code>to_list()</code></h4>

<p>Returns a list with all the concepts
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$to_list()</pre></div>



<h5>Returns</h5>

<p>A list of concepts.
</p>


<hr>
<a id="method-ConceptSet-bracket"></a>



<h4>Method <code>[()</code></h4>

<p>Subsets a ConceptSet
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$[(indices)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>indices</code></dt><dd><p>(numeric or logical vector) The indices of the concepts to return as a list of Concepts. It can be a vector of logicals where <code>TRUE</code> elements are to be retained.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Another ConceptSet.
</p>


<hr>
<a id="method-ConceptSet-sub"></a>



<h4>Method <code>sub()</code></h4>

<p>Individual Concepts
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$sub(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>(numeric) The index of the concept to return.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The Concept.
</p>


<hr>
<a id="method-ConceptSet-support"></a>



<h4>Method <code>support()</code></h4>

<p>Get support of each concept
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$support()</pre></div>



<h5>Returns</h5>

<p>A vector with the support of each concept.
</p>


<hr>
<a id="method-ConceptSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConceptSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Build a formal context
fc_planets &lt;- FormalContext$new(planets)

# Find the concepts
fc_planets$find_concepts()

# Find join- and meet- irreducible elements
fc_planets$concepts$join_irreducibles()
fc_planets$concepts$meet_irreducibles()


</code></pre>

<hr>
<h2 id='equivalencesRegistry'>Equivalence Rules Registry</h2><span id='topic+equivalencesRegistry'></span>

<h3>Description</h3>

<p>Equivalence Rules Registry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalencesRegistry
</code></pre>


<h3>Format</h3>

<p>An object of class <code>equivalence_registry</code> (inherits from <code>registry</code>) of length 6.
</p>


<h3>Details</h3>

<p>This is a registry that stores the equivalence rules that can be
applied using the <code>apply_rules()</code> method in an
<code>ImplicationSet</code>.
</p>
<p>One can obtain the list of available equivalence operators by:
<code>equivalencesRegistry$get_entry_names()</code>
</p>

<hr>
<h2 id='fcaR_options'>Set or get options for fcaR</h2><span id='topic+fcaR_options'></span>

<h3>Description</h3>

<p>Set or get options for fcaR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcaR_options(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcaR_options_+3A_...">...</code></td>
<td>
<p>Option names to retrieve option values or <code>[key]=[value]</code> pairs to set options.</p>
</td></tr>
</table>


<h3>Supported options</h3>

<p>The following options are supported
</p>

<dl>
<dt><code>decimal_places</code></dt><dd><p>(<code>numeric</code>;2) The number of decimal places to show when printing or exporting to LaTeX sets, implications, concepts, etc.</p>
</dd>
<dt><code>latex_size</code></dt><dd><p>(<code>character</code>;&quot;normalsize&quot;) Size to use when exporting to LaTeX.</p>
</dd>
<dt><code>reduced\_lattice</code></dt><dd><p>(<code>logical</code>;TRUE) Plot the reduced concept lattice?</p>
</dd>
</dl>


<hr>
<h2 id='FormalContext'>R6 class for a formal context</h2><span id='topic+FormalContext'></span>

<h3>Description</h3>

<p>This class implements the data structure and methods for formal contexts.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>I</code></dt><dd><p>The table of the formal context as a matrix.</p>
</dd>
<dt><code>attributes</code></dt><dd><p>The attributes of the formal context.</p>
</dd>
<dt><code>objects</code></dt><dd><p>The objects of the formal context.</p>
</dd>
<dt><code>grades_set</code></dt><dd><p>The set of degrees (in [0, 1]) the whole set of attributes can take.</p>
</dd>
<dt><code>expanded_grades_set</code></dt><dd><p>The set of degrees (in [0, 1]) each attribute can take.</p>
</dd>
<dt><code>concepts</code></dt><dd><p>The concept lattice associated to the formal context as a <code><a href="#topic+ConceptLattice">ConceptLattice</a></code>.</p>
</dd>
<dt><code>implications</code></dt><dd><p>A set of implications on the formal context as an <code><a href="#topic+ImplicationSet">ImplicationSet</a></code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FormalContext-new"><code>FormalContext$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-is_empty"><code>FormalContext$is_empty()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-scale"><code>FormalContext$scale()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-get_scales"><code>FormalContext$get_scales()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-background_knowledge"><code>FormalContext$background_knowledge()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-dual"><code>FormalContext$dual()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-intent"><code>FormalContext$intent()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-uparrow"><code>FormalContext$uparrow()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-extent"><code>FormalContext$extent()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-downarrow"><code>FormalContext$downarrow()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-closure"><code>FormalContext$closure()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-obj_concept"><code>FormalContext$obj_concept()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-att_concept"><code>FormalContext$att_concept()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-is_concept"><code>FormalContext$is_concept()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-is_closed"><code>FormalContext$is_closed()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-clarify"><code>FormalContext$clarify()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-reduce"><code>FormalContext$reduce()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-standardize"><code>FormalContext$standardize()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-find_concepts"><code>FormalContext$find_concepts()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-find_implications"><code>FormalContext$find_implications()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-to_transactions"><code>FormalContext$to_transactions()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-save"><code>FormalContext$save()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-load"><code>FormalContext$load()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-dim"><code>FormalContext$dim()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-print"><code>FormalContext$print()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-to_latex"><code>FormalContext$to_latex()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-incidence"><code>FormalContext$incidence()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-subcontext"><code>FormalContext$subcontext()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-bracket"><code>FormalContext$[()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-plot"><code>FormalContext$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-use_logic"><code>FormalContext$use_logic()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-get_logic"><code>FormalContext$get_logic()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-use_connection"><code>FormalContext$use_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-get_connection"><code>FormalContext$get_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-FormalContext-clone"><code>FormalContext$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FormalContext-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creator for the Formal Context class
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$new(I, filename, remove_const = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>I</code></dt><dd><p>(numeric matrix) The table of the formal context.</p>
</dd>
<dt><code>filename</code></dt><dd><p>(character) Path of a file to import.</p>
</dd>
<dt><code>remove_const</code></dt><dd><p>(logical) If <code>TRUE</code>, remove constant columns. The default is <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Columns of <code>I</code> should be named, since they are the names of the attributes of the formal context.
</p>
<p>If no <code>I</code> is used, the resulting <code>FormalContext</code> will be empty and not usable unless for loading a previously saved one. In this case, one can provide a <code>filename</code> to import. Only RDS, CSV and CXT files are currently supported.
</p>



<h5>Returns</h5>

<p>An object of the <code>FormalContext</code> class.
</p>


<hr>
<a id="method-FormalContext-is_empty"></a>



<h4>Method <code>is_empty()</code></h4>

<p>Check if the <code>FormalContext</code> is empty
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$is_empty()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if the <code>FormalContext</code> is empty, that is, has not been provided with a matrix, and <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-FormalContext-scale"></a>



<h4>Method <code>scale()</code></h4>

<p>Scale the context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$scale(attributes, type, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>attributes</code></dt><dd><p>The attributes to scale</p>
</dd>
<dt><code>type</code></dt><dd><p>Type of scaling.</p>
</dd>
<dt><code>...</code></dt><dd></dd>
</dl>

</div>



<h5>Details</h5>

<p>The types of scaling are implemented in a registry,
so that <code>scalingRegistry$get_entries()</code> returns
all types.
</p>
<p>In the dots argument, the user can supply the value for <code>bg</code> (logical), which, if set to <code>TRUE</code>, indicates to compute background knowledge as implications on the scales; if <code>FALSE</code>, no implications will be computed on the scales.
</p>



<h5>Returns</h5>

<p>The scaled formal context
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>filename &lt;- system.file("contexts", "aromatic.csv", package = "fcaR")
fc &lt;- FormalContext$new(filename)
fc$scale("nitro", "ordinal", comparison = `&gt;=`, values = 1:3)
fc$scale("OS", "nominal", c("O", "S"))
fc$scale(attributes = "ring", type = "nominal")
</pre>
</div>


<hr>
<a id="method-FormalContext-get_scales"></a>



<h4>Method <code>get_scales()</code></h4>

<p>Scales applied to the formal context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$get_scales(attributes = names(private$scales))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>attributes</code></dt><dd><p>(character) Name of the attributes for which scales
(if applied) are returned.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The scales that have been applied to the specified attributes
of the formal context. If no <code>attributes</code> are passed,
then all applied scales are returned.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>filename &lt;- system.file("contexts", "aromatic.csv", package = "fcaR")
fc &lt;- FormalContext$new(filename)
fc$scale("nitro", "ordinal", comparison = `&gt;=`, values = 1:3)
fc$scale("OS", "nominal", c("O", "S"))
fc$scale(attributes = "ring", type = "nominal")
fc$get_scales()
</pre>
</div>


<hr>
<a id="method-FormalContext-background_knowledge"></a>



<h4>Method <code>background_knowledge()</code></h4>

<p>Background knowledge of a scaled formal context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$background_knowledge()</pre></div>



<h5>Returns</h5>

<p>An <code>ImplicationSet</code> with the implications
extracted from the application of scales.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>filename &lt;- system.file("contexts", "aromatic.csv", package = "fcaR")
fc &lt;- FormalContext$new(filename)
fc$scale("nitro", "ordinal", comparison = `&gt;=`, values = 1:3)
fc$scale("OS", "nominal", c("O", "S"))
fc$scale(attributes = "ring", type = "nominal")
fc$background_knowledge()
</pre>
</div>


<hr>
<a id="method-FormalContext-dual"></a>



<h4>Method <code>dual()</code></h4>

<p>Get the dual formal context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$dual()</pre></div>



<h5>Returns</h5>

<p>A <code>FormalContext</code> where objects and attributes have interchanged their roles.
</p>


<hr>
<a id="method-FormalContext-intent"></a>



<h4>Method <code>intent()</code></h4>

<p>Get the intent of a fuzzy set of objects
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$intent(S)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt><dd><p>(<code>Set</code>) The set of objects to compute the intent for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Set</code> with the intent.
</p>


<hr>
<a id="method-FormalContext-uparrow"></a>



<h4>Method <code>uparrow()</code></h4>

<p>Get the intent of a fuzzy set of objects
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$uparrow(S)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt><dd><p>(<code>Set</code>) The set of objects to compute the intent for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Set</code> with the intent.
</p>


<hr>
<a id="method-FormalContext-extent"></a>



<h4>Method <code>extent()</code></h4>

<p>Get the extent of a fuzzy set of attributes
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$extent(S)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt><dd><p>(<code>Set</code>) The set of attributes to compute the extent for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Set</code> with the intent.
</p>


<hr>
<a id="method-FormalContext-downarrow"></a>



<h4>Method <code>downarrow()</code></h4>

<p>Get the extent of a fuzzy set of attributes
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$downarrow(S)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt><dd><p>(<code>Set</code>) The set of attributes to compute the extent for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Set</code> with the intent.
</p>


<hr>
<a id="method-FormalContext-closure"></a>



<h4>Method <code>closure()</code></h4>

<p>Get the closure of a fuzzy set of attributes
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$closure(S)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt><dd><p>(<code>Set</code>) The set of attributes to compute the closure for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Set</code> with the closure.
</p>


<hr>
<a id="method-FormalContext-obj_concept"></a>



<h4>Method <code>obj_concept()</code></h4>

<p>Object Concept
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$obj_concept(object)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>object</code></dt><dd><p>(character) Name of the object to compute its associated concept</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The object concept associated to the object given.
</p>


<hr>
<a id="method-FormalContext-att_concept"></a>



<h4>Method <code>att_concept()</code></h4>

<p>Attribute Concept
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$att_concept(attribute)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>attribute</code></dt><dd><p>(character) Name of the attribute to compute its associated concept</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The attribute concept associated to the attribute given.
</p>


<hr>
<a id="method-FormalContext-is_concept"></a>



<h4>Method <code>is_concept()</code></h4>

<p>Is a Concept?
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$is_concept(C)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>C</code></dt><dd><p>A <code>Concept</code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> if <code>C</code> is a concept.
</p>


<hr>
<a id="method-FormalContext-is_closed"></a>



<h4>Method <code>is_closed()</code></h4>

<p>Testing closure of attribute sets
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$is_closed(S)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt><dd><p>A <code>Set</code> of attributes</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> if the set <code>S</code> is closed in this formal context.
</p>


<hr>
<a id="method-FormalContext-clarify"></a>



<h4>Method <code>clarify()</code></h4>

<p>Clarify a formal context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$clarify(copy = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>copy</code></dt><dd><p>(logical) If <code>TRUE</code>, a new <code>FormalContext</code> object is created with the clarified context, otherwise the current one is overwritten.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The clarified <code>FormalContext</code>.
</p>


<hr>
<a id="method-FormalContext-reduce"></a>



<h4>Method <code>reduce()</code></h4>

<p>Reduce a formal context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$reduce(copy = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>copy</code></dt><dd><p>(logical) If <code>TRUE</code>, a new <code>FormalContext</code> object is created with the clarified and reduced context, otherwise the current one is overwritten.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The clarified and reduced <code>FormalContext</code>.
</p>


<hr>
<a id="method-FormalContext-standardize"></a>



<h4>Method <code>standardize()</code></h4>

<p>Build the Standard Context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$standardize()</pre></div>



<h5>Details</h5>

<p>All concepts must be previously computed.
</p>



<h5>Returns</h5>

<p>The standard context using the join- and meet- irreducible elements.
</p>


<hr>
<a id="method-FormalContext-find_concepts"></a>



<h4>Method <code>find_concepts()</code></h4>

<p>Use Ganter Algorithm to compute concepts
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$find_concepts(verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>(logical) TRUE will provide a verbose output.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with all the concepts in the formal context.
</p>


<hr>
<a id="method-FormalContext-find_implications"></a>



<h4>Method <code>find_implications()</code></h4>

<p>Use modified Ganter algorithm to compute both concepts and implications
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$find_implications(save_concepts = TRUE, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>save_concepts</code></dt><dd><p>(logical) <code>TRUE</code> will also compute and save the concept lattice. <code>FALSE</code> is usually faster, since it only computes implications.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>(logical) <code>TRUE</code> will provide a verbose output.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing, just updates the internal fields <code>concepts</code> and <code>implications</code>.
</p>


<hr>
<a id="method-FormalContext-to_transactions"></a>



<h4>Method <code>to_transactions()</code></h4>

<p>Convert the formal context to object of class <code>transactions</code> from the <code>arules</code> package
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$to_transactions()</pre></div>



<h5>Returns</h5>

<p>A <code>transactions</code> object.
</p>


<hr>
<a id="method-FormalContext-save"></a>



<h4>Method <code>save()</code></h4>

<p>Save a <code>FormalContext</code> to RDS or CXT format
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$save(filename = tempfile(fileext = ".rds"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>(character) Path of the  file where to store the <code>FormalContext</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The format is inferred from the extension of the filename.
</p>



<h5>Returns</h5>

<p>Invisibly the current <code>FormalContext</code>.
</p>


<hr>
<a id="method-FormalContext-load"></a>



<h4>Method <code>load()</code></h4>

<p>Load a <code>FormalContext</code> from a file
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$load(filename)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>(character) Path of the file to load the <code>FormalContext</code> from.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Currently, only RDS, CSV and CXT files are supported.
</p>



<h5>Returns</h5>

<p>The loaded <code>FormalContext</code>.
</p>


<hr>
<a id="method-FormalContext-dim"></a>



<h4>Method <code>dim()</code></h4>

<p>Dimensions of the formal context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$dim()</pre></div>



<h5>Returns</h5>

<p>A vector with (number of objects, number of attributes).
</p>


<hr>
<a id="method-FormalContext-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints the formal context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$print()</pre></div>



<h5>Returns</h5>

<p>Prints information regarding the formal context.
</p>


<hr>
<a id="method-FormalContext-to_latex"></a>



<h4>Method <code>to_latex()</code></h4>

<p>Write the context in LaTeX format
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$to_latex(table = TRUE, label = "", caption = "")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>table</code></dt><dd><p>(logical) If <code>TRUE</code>, surrounds everything between <code>\begin{table}</code> and <code>\end{table}</code>.</p>
</dd>
<dt><code>label</code></dt><dd><p>(character) The label for the table environment.</p>
</dd>
<dt><code>caption</code></dt><dd><p>(character) The caption of the table.</p>
</dd>
<dt><code>fraction</code></dt><dd><p>(character) If <code>none</code>, no fractions are produced. Otherwise, if it is <code>frac</code>, <code>dfrac</code> or <code>sfrac</code>, decimal numbers are represented as fractions with the corresponding LaTeX typesetting.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A table environment in LaTeX.
</p>


<hr>
<a id="method-FormalContext-incidence"></a>



<h4>Method <code>incidence()</code></h4>

<p>Incidence matrix of the formal context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$incidence()</pre></div>



<h5>Returns</h5>

<p>The incidence matrix of the formal context
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>fc &lt;- FormalContext$new(planets)
fc$incidence()
</pre>
</div>


<hr>
<a id="method-FormalContext-subcontext"></a>



<h4>Method <code>subcontext()</code></h4>

<p>Subcontext of the formal context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$subcontext(objects, attributes)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>objects</code></dt><dd><p>(character array) Name of the objects to
keep.</p>
</dd>
<dt><code>attributes</code></dt><dd><p>(character array) Names of the attributes
to keep.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A warning will be issued if any of the names is not present
in the list of objects or attributes of the formal context.
</p>
<p>If <code>objects</code> or <code>attributes</code> is empty, then it is
assumed to represent the whole set of objects or attributes
of the original formal context.
</p>



<h5>Returns</h5>

<p>Another <code>FormalContext</code> that is a subcontext
of the original one, with only the objects and attributes
selected.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>fc &lt;- FormalContext$new(planets)
fc$subcontext(attributes = c("moon", "no_moon"))
</pre>
</div>


<hr>
<a id="method-FormalContext-bracket"></a>



<h4>Method <code>[()</code></h4>

<p>Subcontext of the formal context
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$[(objects, attributes)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>objects</code></dt><dd><p>(character array) Name of the objects to
keep.</p>
</dd>
<dt><code>attributes</code></dt><dd><p>(character array) Names of the attributes
to keep.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>A warning will be issued if any of the names is not present
in the list of objects or attributes of the formal context.
</p>
<p>If <code>objects</code> or <code>attributes</code> is empty, then it is
assumed to represent the whole set of objects or attributes
of the original formal context.
</p>



<h5>Returns</h5>

<p>Another <code>FormalContext</code> that is a subcontext
of the original one, with only the objects and attributes
selected.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>fc &lt;- FormalContext$new(planets)
fc[, c("moon", "no_moon")]
</pre>
</div>


<hr>
<a id="method-FormalContext-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot the formal context table
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$plot(to_latex = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>to_latex</code></dt><dd><p>(logical) If <code>TRUE</code>, export the plot as a <code>tikzpicture</code> environment that can be included in a <code>LaTeX</code> file.</p>
</dd>
<dt><code>...</code></dt><dd><p>Other parameters to be passed to the <code>tikzDevice</code> that renders the lattice in <code>LaTeX</code>, or for the figure caption. See <code>Details</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Particular parameters that control the size of the <code>tikz</code> output are: <code>width</code>, <code>height</code> (both in inches), and <code>pointsize</code> (in points), that should be set to the font size used in the <code>documentclass</code> header in the <code>LaTeX</code> file where the code is to be inserted.
</p>
<p>If a <code>caption</code> is provided, the whole <code>tikz</code> picture will be wrapped by a <code>figure</code> environment and the caption set.
</p>



<h5>Returns</h5>

<p>If <code>to_latex</code> is <code>FALSE</code>, it returns nothing, just plots the graph of the formal context. Otherwise, this function returns the <code>LaTeX</code> code to reproduce the formal context plot.
</p>


<hr>
<a id="method-FormalContext-use_logic"></a>



<h4>Method <code>use_logic()</code></h4>

<p>Sets the logic to use
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$use_logic(name = available_logics())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the logic to use. To see the available names, run <code>available_logics()</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FormalContext-get_logic"></a>



<h4>Method <code>get_logic()</code></h4>

<p>Gets the logic used
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$get_logic()</pre></div>



<h5>Returns</h5>

<p>A string with the name of the logic.
</p>


<hr>
<a id="method-FormalContext-use_connection"></a>



<h4>Method <code>use_connection()</code></h4>

<p>Sets the name of the Galois connection to use
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$use_connection(connection)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>connection</code></dt><dd><p>The name of the Galois connection. Available connections are &quot;standard&quot; (antitone), &quot;benevolent1&quot; and &quot;benevolent2&quot; (isotone)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FormalContext-get_connection"></a>



<h4>Method <code>get_connection()</code></h4>

<p>Gets the name of the Galois connection
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$get_connection()</pre></div>



<h5>Returns</h5>

<p>A string with the name of the Galois connection
</p>


<hr>
<a id="method-FormalContext-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FormalContext$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Guigues J, Duquenne V (1986). “Familles minimales d'implications informatives résultant d'un tableau de données binaires.” <em>Mathématiques et Sciences humaines</em>, <em>95</em>, 5-18.
</p>
<p>Ganter B, Wille R (1999). <em>Formal concept analysis : mathematical foundations</em>. Springer. ISBN 3540627715.
</p>
<p>Belohlavek R (2002). “Algorithms for fuzzy concept lattices.” In <em>Proc. Fourth Int. Conf. on Recent Advances in Soft Computing</em>. Nottingham, United Kingdom, 200-205.
</p>
<p>Hahsler M, Grun B, Hornik K (2005). “arules - a computational environment for mining association rules and frequent item sets.” <em>J Stat Softw</em>, <em>14</em>, 1-25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build and print the formal context
fc_planets &lt;- FormalContext$new(planets)
print(fc_planets)

# Define a set of attributes
S &lt;- Set$new(attributes = fc_planets$attributes)
S$assign(moon = 1, large = 1)

# Compute the closure of S
Sc &lt;- fc_planets$closure(S)
# Is Sc a closed set?
fc_planets$is_closed(Sc)

# Clarify and reduce the formal context
fc2 &lt;- fc_planets$reduce(TRUE)

# Find implications
fc_planets$find_implications()

# Read a formal context from CSV
filename &lt;- system.file("contexts", "airlines.csv", package = "fcaR")
fc &lt;- FormalContext$new(filename)

# Read a formal context from a CXT file
filename &lt;- system.file("contexts", "lives_in_water.cxt", package = "fcaR")
fc &lt;- FormalContext$new(filename)


## ------------------------------------------------
## Method `FormalContext$scale`
## ------------------------------------------------

filename &lt;- system.file("contexts", "aromatic.csv", package = "fcaR")
fc &lt;- FormalContext$new(filename)
fc$scale("nitro", "ordinal", comparison = `&gt;=`, values = 1:3)
fc$scale("OS", "nominal", c("O", "S"))
fc$scale(attributes = "ring", type = "nominal")

## ------------------------------------------------
## Method `FormalContext$get_scales`
## ------------------------------------------------

filename &lt;- system.file("contexts", "aromatic.csv", package = "fcaR")
fc &lt;- FormalContext$new(filename)
fc$scale("nitro", "ordinal", comparison = `&gt;=`, values = 1:3)
fc$scale("OS", "nominal", c("O", "S"))
fc$scale(attributes = "ring", type = "nominal")
fc$get_scales()

## ------------------------------------------------
## Method `FormalContext$background_knowledge`
## ------------------------------------------------

filename &lt;- system.file("contexts", "aromatic.csv", package = "fcaR")
fc &lt;- FormalContext$new(filename)
fc$scale("nitro", "ordinal", comparison = `&gt;=`, values = 1:3)
fc$scale("OS", "nominal", c("O", "S"))
fc$scale(attributes = "ring", type = "nominal")
fc$background_knowledge()

## ------------------------------------------------
## Method `FormalContext$incidence`
## ------------------------------------------------

fc &lt;- FormalContext$new(planets)
fc$incidence()

## ------------------------------------------------
## Method `FormalContext$subcontext`
## ------------------------------------------------

fc &lt;- FormalContext$new(planets)
fc$subcontext(attributes = c("moon", "no_moon"))

## ------------------------------------------------
## Method `FormalContext$[`
## ------------------------------------------------

fc &lt;- FormalContext$new(planets)
fc[, c("moon", "no_moon")]
</code></pre>

<hr>
<h2 id='ImplicationSet'>R6 Class for Set of implications</h2><span id='topic+ImplicationSet'></span>

<h3>Description</h3>

<p>This class implements the structure needed to store implications and the methods associated.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ImplicationSet-new"><code>ImplicationSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-get_attributes"><code>ImplicationSet$get_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-bracket"><code>ImplicationSet$[()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-to_arules"><code>ImplicationSet$to_arules()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-add"><code>ImplicationSet$add()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-cardinality"><code>ImplicationSet$cardinality()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-is_empty"><code>ImplicationSet$is_empty()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-size"><code>ImplicationSet$size()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-closure"><code>ImplicationSet$closure()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-recommend"><code>ImplicationSet$recommend()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-apply_rules"><code>ImplicationSet$apply_rules()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-to_basis"><code>ImplicationSet$to_basis()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-print"><code>ImplicationSet$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-to_latex"><code>ImplicationSet$to_latex()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-get_LHS_matrix"><code>ImplicationSet$get_LHS_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-get_RHS_matrix"><code>ImplicationSet$get_RHS_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-filter"><code>ImplicationSet$filter()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-support"><code>ImplicationSet$support()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-clone"><code>ImplicationSet$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ImplicationSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize with an optional name
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$new(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>See Details.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Creates and initialize a new <code>ImplicationSet</code> object. It can be done in two ways:
<code>initialize(name, attributes, lhs, rhs)</code>
or <code>initialize(rules)</code>
</p>
<p>In the first way, the only mandatory argument is <code>attributes</code>, (character vector) which is a vector of names of the attributes on which we define the implications. Optional arguments are: <code>name</code> (character string), name of the implication set, <code>lhs</code> (a <code>dgCMatrix</code>), initial LHS of the implications stored and the analogous <code>rhs</code>.
</p>
<p>The other way is used to initialize the <code>ImplicationSet</code> object from a <code>rules</code> object from package <code>arules</code>.
</p>



<h5>Returns</h5>

<p>A new <code>ImplicationSet</code> object.
</p>


<hr>
<a id="method-ImplicationSet-get_attributes"></a>



<h4>Method <code>get_attributes()</code></h4>

<p>Get the names of the attributes
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$get_attributes()</pre></div>



<h5>Returns</h5>

<p>A character vector with the names of the attributes used in the implications.
</p>


<hr>
<a id="method-ImplicationSet-bracket"></a>



<h4>Method <code>[()</code></h4>

<p>Get a subset of the implication set
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$[(idx)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>idx</code></dt><dd><p>(integer or logical vector) Indices of the implications to extract or remove. If logical vector, only <code>TRUE</code> elements are retained and the rest discarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>ImplicationSet</code> with only the rules given by the <code>idx</code> indices (if all <code>idx &gt; 0</code> and all but <code>idx</code> if all <code>idx &lt; 0</code>.
</p>


<hr>
<a id="method-ImplicationSet-to_arules"></a>



<h4>Method <code>to_arules()</code></h4>

<p>Convert to arules format
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$to_arules(quality = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>quality</code></dt><dd><p>(logical) Compute the interest measures for each rule?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>rules</code> object as used by package <code>arules</code>.
</p>


<hr>
<a id="method-ImplicationSet-add"></a>



<h4>Method <code>add()</code></h4>

<p>Add a precomputed implication set
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$add(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>An <code>ImplicationSet</code> object, a <code>rules</code> object, or a pair <code>lhs</code>, <code>rhs</code> of <code>Set</code> objects or <code>dgCMatrix</code>. The implications to add to this formal context.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Nothing, just updates the internal <code>implications</code> field.
</p>


<hr>
<a id="method-ImplicationSet-cardinality"></a>



<h4>Method <code>cardinality()</code></h4>

<p>Cardinality: Number of implications in the set
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$cardinality()</pre></div>



<h5>Returns</h5>

<p>The cardinality of the implication set.
</p>


<hr>
<a id="method-ImplicationSet-is_empty"></a>



<h4>Method <code>is_empty()</code></h4>

<p>Empty set
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$is_empty()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if the set of implications is empty, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-ImplicationSet-size"></a>



<h4>Method <code>size()</code></h4>

<p>Size: number of attributes in each of LHS and RHS
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$size()</pre></div>



<h5>Returns</h5>

<p>A vector with two components: the number of attributes present in each of the LHS and RHS of each implication in the set.
</p>


<hr>
<a id="method-ImplicationSet-closure"></a>



<h4>Method <code>closure()</code></h4>

<p>Compute the semantic closure of a fuzzy set with respect to the implication set
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$closure(S, reduce = FALSE, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt><dd><p>(a <code>Set</code> object)  Fuzzy set to compute its closure. Use class <code>Set</code> to build it.</p>
</dd>
<dt><code>reduce</code></dt><dd><p>(logical) Reduce the implications using simplification logic?</p>
</dd>
<dt><code>verbose</code></dt><dd><p>(logical) Show verbose output?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If <code>reduce == FALSE</code>, the output is a fuzzy set corresponding to the closure of <code>S</code>. If <code>reduce == TRUE</code>, a list with two components: <code>closure</code>, with the closure as above, and <code>implications</code>, the reduced set of implications.
</p>


<hr>
<a id="method-ImplicationSet-recommend"></a>



<h4>Method <code>recommend()</code></h4>

<p>Generate a recommendation for a subset of the attributes
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$recommend(S, attribute_filter)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt><dd><p>(a vector) Vector with the grades of each attribute (a fuzzy set).</p>
</dd>
<dt><code>attribute_filter</code></dt><dd><p>(character vector) Names of the attributes to get recommendation for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A fuzzy set describing the values of the attributes in <code>attribute_filter</code> within the closure of <code>S</code>.
</p>


<hr>
<a id="method-ImplicationSet-apply_rules"></a>



<h4>Method <code>apply_rules()</code></h4>

<p>Apply rules to remove redundancies
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$apply_rules(
  rules = c("composition", "generalization"),
  batch_size = 25000L,
  parallelize = FALSE,
  reorder = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rules</code></dt><dd><p>(character vector) Names of the rules to use. See <code>details</code>.</p>
</dd>
<dt><code>batch_size</code></dt><dd><p>(integer) If the number of rules is large, apply the rules by batches of this size.</p>
</dd>
<dt><code>parallelize</code></dt><dd><p>(logical) If possible, should we parallelize the computation among different batches?</p>
</dd>
<dt><code>reorder</code></dt><dd><p>(logical) Should the rules be randomly reordered previous to the computation?</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Currently, the implemented rules are <code>"generalization"</code>, <code>"simplification"</code>, <code>"reduction"</code> and <code>"composition"</code>.
</p>



<h5>Returns</h5>

<p>Nothing, just updates the internal matrices for LHS and RHS.
</p>


<hr>
<a id="method-ImplicationSet-to_basis"></a>



<h4>Method <code>to_basis()</code></h4>

<p>Convert Implications to Canonical Basis
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$to_basis()</pre></div>



<h5>Returns</h5>

<p>The canonical basis of implications obtained from the current <code>ImplicationSet</code>
</p>


<hr>
<a id="method-ImplicationSet-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print all implications to text
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$print()</pre></div>



<h5>Returns</h5>

<p>A string with all the implications in the set.
</p>


<hr>
<a id="method-ImplicationSet-to_latex"></a>



<h4>Method <code>to_latex()</code></h4>

<p>Export to LaTeX
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$to_latex(
  print = TRUE,
  ncols = 1,
  numbered = TRUE,
  numbers = seq(self$cardinality())
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>print</code></dt><dd><p>(logical) Print to output?</p>
</dd>
<dt><code>ncols</code></dt><dd><p>(integer) Number of columns for the output.</p>
</dd>
<dt><code>numbered</code></dt><dd><p>(logical) If <code>TRUE</code> (default), implications will be numbered in the output.</p>
</dd>
<dt><code>numbers</code></dt><dd><p>(vector) If <code>numbered</code>, use these elements to enumerate the implications. The default is to enumerate 1, 2, ..., but can be changed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A string in LaTeX format that prints nicely all the implications.
</p>


<hr>
<a id="method-ImplicationSet-get_LHS_matrix"></a>



<h4>Method <code>get_LHS_matrix()</code></h4>

<p>Get internal LHS matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$get_LHS_matrix()</pre></div>



<h5>Returns</h5>

<p>A sparse matrix representing the LHS of the implications in the set.
</p>


<hr>
<a id="method-ImplicationSet-get_RHS_matrix"></a>



<h4>Method <code>get_RHS_matrix()</code></h4>

<p>Get internal RHS matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$get_RHS_matrix()</pre></div>



<h5>Returns</h5>

<p>A sparse matrix representing the RHS of the implications in the set.
</p>


<hr>
<a id="method-ImplicationSet-filter"></a>



<h4>Method <code>filter()</code></h4>

<p>Filter implications by attributes in LHS and RHS
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$filter(
  lhs = NULL,
  not_lhs = NULL,
  rhs = NULL,
  not_rhs = NULL,
  drop = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lhs</code></dt><dd><p>(character vector) Names of the attributes to filter the LHS by. If <code>NULL</code>, no filtering is done on the LHS.</p>
</dd>
<dt><code>not_lhs</code></dt><dd><p>(character vector) Names of the attributes to not include in the LHS. If <code>NULL</code> (the default), it is not considered at all.</p>
</dd>
<dt><code>rhs</code></dt><dd><p>(character vector) Names of the attributes to filter the RHS by. If <code>NULL</code>, no filtering is done on the RHS.</p>
</dd>
<dt><code>not_rhs</code></dt><dd><p>(character vector) Names of the attributes to not include in the RHS. If <code>NULL</code> (the default), it is not considered at all.</p>
</dd>
<dt><code>drop</code></dt><dd><p>(logical) Remove the rest of attributes in RHS?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An <code>ImplicationSet</code> that is a subset of the current set, only with those rules which has the attributes in <code>lhs</code> and <code>rhs</code> in their LHS and RHS, respectively.
</p>


<hr>
<a id="method-ImplicationSet-support"></a>



<h4>Method <code>support()</code></h4>

<p>Compute support of each implication
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$support()</pre></div>



<h5>Returns</h5>

<p>A vector with the support of each implication
</p>


<hr>
<a id="method-ImplicationSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Ganter B, Obiedkov S (2016). Conceptual Exploration. Springer. https://doi.org/10.1007/978-3-662-49291-8
</p>
<p>Hahsler M, Grun B, Hornik K (2005). “arules - a computational environment for mining association rules and frequent item sets.” <em>J Stat Softw</em>, <em>14</em>, 1-25.
</p>
<p>Belohlavek R, Cordero P, Enciso M, Mora Á, Vychodil V (2016). “Automated prover for attribute dependencies in data with grades.” <em>International Journal of Approximate Reasoning</em>, <em>70</em>, 51-67.
</p>
<p>Mora A, Cordero P, Enciso M, Fortes I, Aguilera G (2012). “Closure via functional dependence simplification.” <em>International Journal of Computer Mathematics</em>, <em>89</em>(4), 510-526.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build a formal context
fc_planets &lt;- FormalContext$new(planets)

# Find its implication basis
fc_planets$find_implications()

# Print implications
fc_planets$implications

# Cardinality and mean size in the ruleset
fc_planets$implications$cardinality()
sizes &lt;- fc_planets$implications$size()
colMeans(sizes)

# Simplify the implication set
fc_planets$implications$apply_rules("simplification")

</code></pre>

<hr>
<h2 id='parse_implication'>Parses a string into an implication</h2><span id='topic+parse_implication'></span>

<h3>Description</h3>

<p>Parses a string into an implication
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_implication(string, attributes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_implication_+3A_string">string</code></td>
<td>
<p>(character) The string to be parsed</p>
</td></tr>
<tr><td><code id="parse_implication_+3A_attributes">attributes</code></td>
<td>
<p>(character vector) The attributes' names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two vectors as sparse matrices representing the LHS and RHS of the implication
</p>

<hr>
<h2 id='parse_implications'>Parses several implications given as a string</h2><span id='topic+parse_implications'></span>

<h3>Description</h3>

<p>Parses several implications given as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_implications(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_implications_+3A_input">input</code></td>
<td>
<p>(character) The string with the implications or a file containing the implications</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format for the input file is:
</p>

<ul>
<li><p> Every implication in its own line or separated by semicolon (;)
</p>
</li>
<li><p> Attributes are separated by commas (,)
</p>
</li>
<li><p> The LHS and RHS of each implication are separated by an arrow (-&gt;)
</p>
</li></ul>



<h3>Value</h3>

<p>An ImplicationSet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- system.file("implications", "ex_implications", package = "fcaR")
imps &lt;- parse_implications(input)

</code></pre>

<hr>
<h2 id='planets'>Planets data</h2><span id='topic+planets'></span>

<h3>Description</h3>

<p>This dataset records some properties of the planets in our solar system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planets
</code></pre>


<h3>Format</h3>

<p>A matrix with 9 rows (the planets) and 7 columns, representing additional features of the planets:
</p>

<dl>
<dt>small</dt><dd><p>1 if the planet is small, 0 otherwise.</p>
</dd>
<dt>medium</dt><dd><p>1 if the planet is medium-sized, 0 otherwise.</p>
</dd>
<dt>large</dt><dd><p>1 if the planet is large, 0 otherwise.</p>
</dd>
<dt>near</dt><dd><p>1 if the planet belongs in the inner solar system, 0 otherwise.</p>
</dd>
<dt>far</dt><dd><p>1 if the planet belongs in the outer solar system, 0 otherwise.</p>
</dd>
<dt>moon</dt><dd><p>1 if the planet has a natural moon, 0 otherwise.</p>
</dd>
<dt>no_moon</dt><dd><p>1 if the planet has no moon, 0 otherwise.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wille R (1982). “Restructuring Lattice Theory: An Approach Based on Hierarchies of Concepts.” In Ordered Sets, pp. 445–470. Springer.
</p>

<hr>
<h2 id='scalingRegistry'>Scaling Registry</h2><span id='topic+scalingRegistry'></span>

<h3>Description</h3>

<p>Scaling Registry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalingRegistry
</code></pre>


<h3>Format</h3>

<p>An object of class <code>scaling_registry</code> (inherits from <code>registry</code>) of length 6.
</p>


<h3>Details</h3>

<p>This is a registry that stores the implemented scales that can be
applied using the <code>scale()</code> method in an
<code>FormalContext</code>.
</p>
<p>One can obtain the list of available equivalence operators by:
<code>scalingRegistry$get_entry_names()</code>
</p>

<hr>
<h2 id='Set'>R6 class for a fuzzy set with sparse internal representation</h2><span id='topic+Set'></span>

<h3>Description</h3>

<p>This class implements the data structure and methods for fuzzy sets.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Set-new"><code>Set$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Set-assign"><code>Set$assign()</code></a>
</p>
</li>
<li> <p><a href="#method-Set-bracket"><code>Set$[()</code></a>
</p>
</li>
<li> <p><a href="#method-Set-cardinal"><code>Set$cardinal()</code></a>
</p>
</li>
<li> <p><a href="#method-Set-get_vector"><code>Set$get_vector()</code></a>
</p>
</li>
<li> <p><a href="#method-Set-get_attributes"><code>Set$get_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-Set-length"><code>Set$length()</code></a>
</p>
</li>
<li> <p><a href="#method-Set-print"><code>Set$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Set-to_latex"><code>Set$to_latex()</code></a>
</p>
</li>
<li> <p><a href="#method-Set-clone"><code>Set$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Set-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creator for objects of class <code>Set</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Set$new(attributes, M = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>attributes</code></dt><dd><p>(character vector) Names of the attributes that will be available in the fuzzy set.</p>
</dd>
<dt><code>M</code></dt><dd><p>(numeric vector or column <code>Matrix</code>) Values (grades) to be assigned to the attributes.</p>
</dd>
<dt><code>...</code></dt><dd><p><code>key</code> = <code>value</code> pairs, where the value <code>value</code> is assigned to the <code>key</code> attribute name.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If <code>M</code> is omitted and no pair <code>key</code> = <code>value</code>, the fuzzy set is the empty set. Later, one can use the <code>assign</code> method to assign grades to any of its attributes.
</p>



<h5>Returns</h5>

<p>An object of class <code>Set</code>.
</p>


<hr>
<a id="method-Set-assign"></a>



<h4>Method <code>assign()</code></h4>

<p>Assign grades to attributes in the set
</p>


<h5>Usage</h5>

<div class="r"><pre>Set$assign(attributes = c(), values = c(), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>attributes</code></dt><dd><p>(character vector) Names of the attributes to assign a grade to.</p>
</dd>
<dt><code>values</code></dt><dd><p>(numeric vector) Grades to be assigned to the previous <code>attributes</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p><code>key</code> = <code>value</code> pairs, where the value <code>value</code> is assigned to the <code>key</code> attribute name.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>One can use both of:
<code>S$assign(A = 1, B = 0.3)</code>
<code>S$assign(attributes = c(A, B), values = c(1, 0.3))</code>.
</p>


<hr>
<a id="method-Set-bracket"></a>



<h4>Method <code>[()</code></h4>

<p>Get elements by index
</p>


<h5>Usage</h5>

<div class="r"><pre>Set$[(indices)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>indices</code></dt><dd><p>(numeric, logical or character vector) The indices of the elements to return. It can be a vector of logicals where <code>TRUE</code> elements are to be retained.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Set</code> but with only the required elements.
</p>


<hr>
<a id="method-Set-cardinal"></a>



<h4>Method <code>cardinal()</code></h4>

<p>Cardinal of the Set
</p>


<h5>Usage</h5>

<div class="r"><pre>Set$cardinal()</pre></div>



<h5>Returns</h5>

<p>the cardinal of the <code>Set</code>, counted
as the sum of the degrees of each element.
</p>


<hr>
<a id="method-Set-get_vector"></a>



<h4>Method <code>get_vector()</code></h4>

<p>Internal <code>Matrix</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Set$get_vector()</pre></div>



<h5>Returns</h5>

<p>The internal sparse <code>Matrix</code> representation of the set.
</p>


<hr>
<a id="method-Set-get_attributes"></a>



<h4>Method <code>get_attributes()</code></h4>

<p>Attributes defined for the set
</p>


<h5>Usage</h5>

<div class="r"><pre>Set$get_attributes()</pre></div>



<h5>Returns</h5>

<p>A character vector with the names of the attributes.
</p>


<hr>
<a id="method-Set-length"></a>



<h4>Method <code>length()</code></h4>

<p>Number of attributes
</p>


<h5>Usage</h5>

<div class="r"><pre>Set$length()</pre></div>



<h5>Returns</h5>

<p>The number of attributes that are defined for this fuzzy set.
</p>


<hr>
<a id="method-Set-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints the set to console
</p>


<h5>Usage</h5>

<div class="r"><pre>Set$print(eol = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>eol</code></dt><dd><p>(logical) If <code>TRUE</code>, adds an end of line to the output.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A string with the elements of the set and their grades between brackets .
</p>


<hr>
<a id="method-Set-to_latex"></a>



<h4>Method <code>to_latex()</code></h4>

<p>Write the set in LaTeX format
</p>


<h5>Usage</h5>

<div class="r"><pre>Set$to_latex(print = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>print</code></dt><dd><p>(logical) Print to output?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The fuzzy set in LaTeX.
</p>


<hr>
<a id="method-Set-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Set$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- Set$new(attributes = c("A", "B", "C"))
S$assign(A = 1)
print(S)
S$to_latex()

S &lt;- Set$new(c("A", "B", "C"), C = 1, B = 0.5)
S

</code></pre>

<hr>
<h2 id='vegas'>Data for Tourist Destination in Las Vegas</h2><span id='topic+vegas'></span>

<h3>Description</h3>

<p>The dataset <code>vegas</code> is the binary translation of the Las Vegas Strip dataset (@moro2017stripping), which records more than 500 TripAdvisor reviews of hotels in Las Vegas Strip. The uninformative attributes (such as the user continent or the weekday of the review) are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegas
</code></pre>


<h3>Format</h3>

<p>A matrix with 504 rows and 25 binary columns. Column names are related to different features of the hotels:
</p>

<dl>
<dt>Period of Stay</dt><dd><p>4 categories are present in the original data, which produces as many binary variables: <code>Period of stay=Dec-Feb</code>, <code>Period of stay=Mar-May</code>, <code>Period of stay=Jun-Aug</code> and <code>Period of stay=Sep-Nov</code>.</p>
</dd>
<dt>Traveler type</dt><dd><p>Five binary categories are created from the original data: <code>Traveler type=Business</code>, <code>Traveler type=Couples</code>, <code>Traveler type=Families</code>, <code>Traveler type=Friends</code> and <code>Traveler type=Solo</code>.</p>
</dd>
<dt>Pool, Gym, Tennis court, Spa, Casino, Free internet</dt><dd><p>Binary variables for the services offered by each destination hotel</p>
</dd>
<dt>Stars</dt><dd><p>Five binary variables are created, according to the number of stars of the hotel, <code>Stars=3</code>, <code>Stars=3.5</code>, <code>Stars=4</code>, <code>Stars=4.5</code> and <code>Stars=5</code>.</p>
</dd>
<dt>Score</dt><dd><p>The score assigned in the review, from <code>Score=1</code> to <code>Score=5</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Moro, S., Rita, P., &amp; Coelho, J. (2017). Stripping customers' feedback on hotels through data mining: The case of Las Vegas Strip. Tourism Management Perspectives, 23, 41-52.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
