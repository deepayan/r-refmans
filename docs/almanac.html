<!DOCTYPE html><html lang="en"><head><title>Help for package almanac</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {almanac}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#almanac-package'><p>almanac: Tools for Working with Recurrence Rules</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#adjustments'><p>Date adjustments</p></a></li>
<li><a href='#alma_events'><p>Get all events</p></a></li>
<li><a href='#alma_in'><p>Check if dates are in an event set</p></a></li>
<li><a href='#alma_next'><p>Generate the next or previous event</p></a></li>
<li><a href='#alma_search'><p>Search for events</p></a></li>
<li><a href='#alma_seq'><p>Generate date sequences</p></a></li>
<li><a href='#alma_step'><p>Step relative to an rschedule</p></a></li>
<li><a href='#almanac-defaults'><p>Default values in almanac</p></a></li>
<li><a href='#almanac-vctrs-compat'><p>vctrs compatibility functions</p></a></li>
<li><a href='#cal_events'><p>Calendar events</p></a></li>
<li><a href='#cal_match'><p>Calendar matching</p></a></li>
<li><a href='#cal_names'><p>Calendar names</p></a></li>
<li><a href='#cal_us_federal'><p>US federal calendar</p></a></li>
<li><a href='#calendar-add-remove'><p>Calendar additions and removals</p></a></li>
<li><a href='#calendar-locations'><p>Calendar locations</p></a></li>
<li><a href='#deprecated-recur'><p>Deprecated recurrence helpers</p></a></li>
<li><a href='#holiday-utilities'><p>Holiday utility functions</p></a></li>
<li><a href='#holidays'><p>Holidays</p></a></li>
<li><a href='#new_rschedule'><p>Create a new rschedule</p></a></li>
<li><a href='#radjusted'><p>Create an adjusted rschedule</p></a></li>
<li><a href='#rcalendar'><p>Create a recurring calendar</p></a></li>
<li><a href='#rcustom'><p>Create a custom rschedule</p></a></li>
<li><a href='#recur_for_count'><p>Control the number of times to recur</p></a></li>
<li><a href='#recur_on_day_of_month'><p>Recur on a day of the month</p></a></li>
<li><a href='#recur_on_day_of_week'><p>Recur on a day of the week</p></a></li>
<li><a href='#recur_on_day_of_year'><p>Recur on a day of the year</p></a></li>
<li><a href='#recur_on_easter'><p>Recur on easter</p></a></li>
<li><a href='#recur_on_interval'><p>Recur on an interval</p></a></li>
<li><a href='#recur_on_month_of_year'><p>Recur on a month of the year</p></a></li>
<li><a href='#recur_on_position'><p>Recur on a position within a frequency</p></a></li>
<li><a href='#recur_on_week_of_year'><p>Recur on a week of the year</p></a></li>
<li><a href='#recur_with_week_start'><p>Control the start of the week</p></a></li>
<li><a href='#rholiday'><p>Create a recurring holiday</p></a></li>
<li><a href='#roffset'><p>Create an offset rschedule</p></a></li>
<li><a href='#rrule'><p>Create a recurrence rule</p></a></li>
<li><a href='#rset'><p>Create a new set-based recurrence schedule</p></a></li>
<li><a href='#rset-add'><p>Deprecated rset helpers</p></a></li>
<li><a href='#stepper'><p>Create a new stepper</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Working with Recurrence Rules</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for defining recurrence rules and recurrence
    sets. Recurrence rules are a programmatic way to define a recurring
    event, like the first Monday of December. Multiple recurrence rules
    can be combined into larger recurrence sets. A full holiday and
    calendar interface is also provided that can generate holidays within
    a particular year, can detect if a date is a holiday, can respect
    holiday observance rules, and allows for custom holidays.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DavisVaughan/almanac">https://github.com/DavisVaughan/almanac</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DavisVaughan/almanac/issues">https://github.com/DavisVaughan/almanac/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.6.1), glue (&ge; 1.6.2), lifecycle (&ge; 1.0.3),
lubridate (&ge; 1.9.2), magrittr (&ge; 2.0.3), R6 (&ge; 2.5.1), rlang
(&ge; 1.1.0), V8 (&ge; 4.2.2), vctrs (&ge; 0.6.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, slider (&ge; 0.3.0), testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-13 14:06:52 UTC; davis</td>
</tr>
<tr>
<td>Author:</td>
<td>Davis Vaughan [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Davis Vaughan &lt;davis@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-13 22:30:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='almanac-package'>almanac: Tools for Working with Recurrence Rules</h2><span id='topic+almanac'></span><span id='topic+almanac-package'></span>

<h3>Description</h3>

<p>Provides tools for defining recurrence rules and recurrence sets. Recurrence rules are a programmatic way to define a recurring event, like the first Monday of December. Multiple recurrence rules can be combined into larger recurrence sets. A full holiday and calendar interface is also provided that can generate holidays within a particular year, can detect if a date is a holiday, can respect holiday observance rules, and allows for custom holidays.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DavisVaughan/almanac">https://github.com/DavisVaughan/almanac</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DavisVaughan/almanac/issues">https://github.com/DavisVaughan/almanac/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='adjustments'>Date adjustments</h2><span id='topic+adjustments'></span><span id='topic+adj_following'></span><span id='topic+adj_preceding'></span><span id='topic+adj_modified_following'></span><span id='topic+adj_modified_preceding'></span><span id='topic+adj_nearest'></span><span id='topic+adj_none'></span>

<h3>Description</h3>

<p>This family of <code style="white-space: pre;">&#8288;adj_*()&#8288;</code> functions encode business logic for common
date adjustments. If <code>x</code> falls on an event date, it is adjusted according to
the function's adjustment rule. Otherwise it is left untouched.
</p>

<ul>
<li> <p><code>adj_following()</code>
</p>
<p>Choose the first non-event date after <code>x</code>.
</p>
</li>
<li> <p><code>adj_preceding()</code>
</p>
<p>Choose the first non-event date before <code>x</code>.
</p>
</li>
<li> <p><code>adj_modified_following()</code>
</p>
<p>Choose the first non-event date after <code>x</code>, unless it falls in a
different month, in which case the first non-event date before <code>x</code> is
chosen instead.
</p>
</li>
<li> <p><code>adj_modified_preceding()</code>
</p>
<p>Choose the first non-event date before <code>x</code>, unless it falls in a
different month, in which case the first non-event date after <code>x</code> is
chosen instead.
</p>
</li>
<li> <p><code>adj_nearest()</code>
</p>
<p>Choose the nearest non-event date to <code>x</code>. If the closest preceding and
following non-event dates are equally far away, the following non-event
date is chosen.
</p>
</li>
<li> <p><code>adj_none()</code>
</p>
<p>Performs no adjustment and returns <code>x</code> unchanged.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>adj_following(x, rschedule)

adj_preceding(x, rschedule)

adj_modified_following(x, rschedule)

adj_modified_preceding(x, rschedule)

adj_nearest(x, rschedule)

adj_none(x, rschedule)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjustments_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date]&#8288;</code>
</p>
<p>A vector of dates.</p>
</td></tr>
<tr><td><code id="adjustments_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule, such as an rrule, runion, rintersect, or rsetdiff.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjusted vector of Dates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A Saturday
x &lt;- as.Date("1970-01-03")

on_weekends &lt;- weekly() %&gt;% recur_on_weekends()

# Adjust forward to Monday
adj_following(x, on_weekends)

# Adjust backwards to Friday
adj_preceding(x, on_weekends)

# Adjust to nearest non-event date
adj_nearest(x, on_weekends)
adj_nearest(x + 1, on_weekends)

# Sundays, one of which is at the end of the month
sundays &lt;- as.Date(c("2020-05-24", "2020-05-31"))

# Adjust forward, unless that takes us into a new month, in which case we
# adjust backwards.
adj_modified_following(sundays, on_weekends)

# Saturdays, one of which is at the beginning of the month
saturdays &lt;- as.Date(c("2020-08-01", "2020-08-08"))

# Adjust backwards, unless that takes us into a new month, in which
# case we adjust forwards
adj_modified_preceding(saturdays, on_weekends)
</code></pre>

<hr>
<h2 id='alma_events'>Get all events</h2><span id='topic+alma_events'></span>

<h3>Description</h3>

<p><code>alma_events()</code> retrieves all of the events in the rschedule's
event set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alma_events(rschedule, ..., year = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alma_events_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule, such as an rrule, runion, rintersect, or rsetdiff.</p>
</td></tr>
<tr><td><code id="alma_events_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="alma_events_+3A_year">year</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[NULL / integer]&#8288;</code>
</p>
<p>An optional integer vector of years to limit the returned events to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Date vector of events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rrule &lt;- daily(since = "1970-01-01", until = "1970-01-05")

alma_events(rrule)

on_christmas &lt;- yearly() %&gt;%
  recur_on_month_of_year("Dec") %&gt;%
  recur_on_day_of_month(25)

alma_events(on_christmas, year = c(2020, 2022))
</code></pre>

<hr>
<h2 id='alma_in'>Check if dates are in an event set</h2><span id='topic+alma_in'></span>

<h3>Description</h3>

<p><code>alma_in()</code> checks if <code>x</code> is in the event set of dates defined by the
rschedule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alma_in(x, rschedule)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alma_in_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date]&#8288;</code>
</p>
<p>A vector of dates.</p>
</td></tr>
<tr><td><code id="alma_in_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule, such as an rrule, runion, rintersect, or rsetdiff.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same size as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rrule &lt;- weekly() %&gt;%
  recur_on_day_of_week("Thursday")

# A Thursday and Friday
x &lt;- as.Date("1970-01-01") + 0:1

alma_in(x, rrule)

# Every month, on the 2nd day of the month
rrule2 &lt;- monthly() %&gt;%
  recur_on_day_of_month(2)

# Make a larger set of multiple rules
rb &lt;- runion(rrule, rrule2)

alma_in(x, rb)
</code></pre>

<hr>
<h2 id='alma_next'>Generate the next or previous event</h2><span id='topic+alma_next'></span><span id='topic+alma_previous'></span>

<h3>Description</h3>


<ul>
<li> <p><code>alma_next()</code> generates the next event after <code>x</code>.
</p>
</li>
<li> <p><code>alma_previous()</code> generates the previous event before <code>x</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>alma_next(x, rschedule, inclusive = FALSE)

alma_previous(x, rschedule, inclusive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alma_next_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date]&#8288;</code>
</p>
<p>A vector of dates.</p>
</td></tr>
<tr><td><code id="alma_next_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule, such as an rrule, runion, rintersect, or rsetdiff.</p>
</td></tr>
<tr><td><code id="alma_next_+3A_inclusive">inclusive</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>If <code>x</code> is an event, should it be considered the next or previous event?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Date vector the same size as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>on_12th &lt;- monthly() %&gt;% recur_on_day_of_month(12)
on_monday &lt;- weekly() %&gt;% recur_on_day_of_week("Monday")

# On the 12th of the month, or on Mondays
rb &lt;- runion(on_12th, on_monday)

alma_next(c("2019-01-01", "2019-01-11"), rb)
alma_previous(c("2019-01-01", "2019-01-11"), rb)
</code></pre>

<hr>
<h2 id='alma_search'>Search for events</h2><span id='topic+alma_search'></span>

<h3>Description</h3>

<p><code>alma_search()</code> retrieves all events between <code>from</code> and <code>to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alma_search(from, to, rschedule, inclusive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alma_search_+3A_from">from</code>, <code id="alma_search_+3A_to">to</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1)]&#8288;</code>
</p>
<p>Dates defining the range to look for events.</p>
</td></tr>
<tr><td><code id="alma_search_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule, such as an rrule, runion, rintersect, or rsetdiff.</p>
</td></tr>
<tr><td><code id="alma_search_+3A_inclusive">inclusive</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>If <code>from</code> or <code>to</code> are events, should they be included?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Date vector of all events between <code>from</code> and <code>to</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>on_12th &lt;- monthly() %&gt;% recur_on_day_of_month(12)
on_monday &lt;- weekly() %&gt;% recur_on_day_of_week("Monday")

# On the 12th of the month, or on Mondays
rb &lt;- runion(on_12th, on_monday)

alma_search("2019-01-01", "2019-01-31", rb)
</code></pre>

<hr>
<h2 id='alma_seq'>Generate date sequences</h2><span id='topic+alma_seq'></span>

<h3>Description</h3>

<p><code>alma_seq()</code> generates a sequence of all dates between <code>from</code> and <code>to</code>,
skipping any events defined by the <code>rschedule</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alma_seq(from, to, rschedule, inclusive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alma_seq_+3A_from">from</code>, <code id="alma_seq_+3A_to">to</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1)]&#8288;</code>
</p>
<p>Dates defining the range to look for events.</p>
</td></tr>
<tr><td><code id="alma_seq_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule, such as an rrule, runion, rintersect, or rsetdiff.</p>
</td></tr>
<tr><td><code id="alma_seq_+3A_inclusive">inclusive</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>If <code>from</code> or <code>to</code> are events in the <code>rschedule</code>, should they be removed
from the sequence?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of dates in the range of <code style="white-space: pre;">&#8288;[from, to]&#8288;</code>, with all events in the
<code>rschedule</code> removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>on_weekends &lt;- weekly() %&gt;% recur_on_weekends()

# Generate a sequence of all non-weekend dates in Jan-2000
alma_seq("2000-01-01", "2000-01-31", on_weekends)
</code></pre>

<hr>
<h2 id='alma_step'>Step relative to an rschedule</h2><span id='topic+alma_step'></span>

<h3>Description</h3>

<p><code>alma_step()</code> is useful for shifting dates by &quot;n business days&quot;.
</p>
<p><code>alma_step()</code> steps over a sequence of dates 1 day at a time, for <code>n</code> days.
After each step, an adjustment is applied to shift to the next non-event
date.
</p>

<ul>
<li><p> If <code>n</code> is positive, <code><a href="#topic+adj_following">adj_following()</a></code> is called.
</p>
</li>
<li><p> If <code>n</code> is negative, <code><a href="#topic+adj_preceding">adj_preceding()</a></code> is called.
</p>
</li>
<li><p> If <code>n</code> is zero, it was arbitrarily decided to call <code><a href="#topic+adj_following">adj_following()</a></code> to
roll to the next available non-event date.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>alma_step(x, n, rschedule)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alma_step_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date]&#8288;</code>
</p>
<p>A vector of dates.</p>
</td></tr>
<tr><td><code id="alma_step_+3A_n">n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>The number of days to step. Can be negative to step backwards.</p>
</td></tr>
<tr><td><code id="alma_step_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule, such as an rrule, runion, rintersect, or rsetdiff.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imagine you are on a Friday and want to shift forward 2 days using an
rrule that marks weekends as events. <code>alma_step()</code> works like this:
</p>

<ul>
<li><p> Step forward 1 day to Saturday.
</p>
</li>
<li><p> Apply an adjustment of <code><a href="#topic+adj_following">adj_following()</a></code>, which rolls forward to Monday.
</p>
</li>
<li><p> Step forward 1 day to Tuesday.
</p>
</li>
<li><p> Apply an adjustment of <code><a href="#topic+adj_following">adj_following()</a></code>, but no adjustment is required.
</p>
</li></ul>

<p>This lends itself naturally to business logic. Two business days from Friday
is Tuesday.
</p>


<h3>Value</h3>

<p>A Date vector the same size as <code>x</code> shifted by <code>n</code> steps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a rrule for weekends
on_weekends &lt;- weekly() %&gt;%
  recur_on_weekends()

# "Step forward by 2 business days"
# 2019-09-13 is a Friday.
# Here we:
# - Step 1 day to Saturday
# - Adjust to Monday
# - Step 1 day to Tuesday
alma_step("2019-09-13", 2, on_weekends)

# If Monday, 2019-09-16, was a recurring holiday, we could create
# a custom runion and step over that too.
on_09_16 &lt;- yearly() %&gt;%
  recur_on_month_of_year(9) %&gt;%
  recur_on_day_of_month(16)

rb &lt;- runion(on_09_16, on_weekends)

alma_step("2019-09-13", 2, rb)
</code></pre>

<hr>
<h2 id='almanac-defaults'>Default values in almanac</h2><span id='topic+almanac-defaults'></span><span id='topic+almanac_since'></span><span id='topic+almanac_until'></span>

<h3>Description</h3>


<ul>
<li> <p><code>almanac_since()</code> represents the default <code>since</code> date used in almanac. It
defaults to <code>1900-01-01</code>, a Monday.
</p>
</li>
<li> <p><code>almanac_until()</code> represents the default <code>until</code> date used in almanac. It
defaults to <code>2100-01-01</code>, a Friday.
</p>
</li></ul>

<p>The choice of <code>since</code> and <code>until</code> are somewhat arbitrary, but should generate
a useful event set range for most rschedules. If you need to adjust the
defaults, then you should supply the <code>since</code> and <code>until</code> arguments directly
to the rrule generators, like <code><a href="#topic+yearly">yearly()</a></code> and <code><a href="#topic+weekly">weekly()</a></code>.
</p>
<p>The <code>since</code> default is particularly important for weekly recurrence rules,
where the <code>since</code> date represents the anchor point to begin counting from.
See <code><a href="#topic+recur_on_day_of_week">recur_on_day_of_week()</a></code> for examples of how to adjust this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>almanac_since()

almanac_until()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>almanac_since()
almanac_until()
</code></pre>

<hr>
<h2 id='almanac-vctrs-compat'>vctrs compatibility functions</h2><span id='topic+almanac-vctrs-compat'></span><span id='topic+vec_arith.almanac_stepper'></span><span id='topic+vec_ptype2.almanac_stepper.almanac_stepper'></span><span id='topic+vec_cast.almanac_stepper.almanac_stepper'></span>

<h3>Description</h3>

<p>These functions are the extensions that allow stepper objects to
work with vctrs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'almanac_stepper'
vec_arith(op, x, y, ...)

## S3 method for class 'almanac_stepper.almanac_stepper'
vec_ptype2(x, y, ..., x_arg = "", y_arg = "")

## S3 method for class 'almanac_stepper.almanac_stepper'
vec_cast(x, to, ..., x_arg = "", to_arg = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="almanac-vctrs-compat_+3A_op">op</code></td>
<td>
<p>An arithmetic operator as a string.</p>
</td></tr>
<tr><td><code id="almanac-vctrs-compat_+3A_x">x</code>, <code id="almanac-vctrs-compat_+3A_y">y</code>, <code id="almanac-vctrs-compat_+3A_to">to</code></td>
<td>
<p>Objects.</p>
</td></tr>
<tr><td><code id="almanac-vctrs-compat_+3A_...">...</code></td>
<td>
<p>Used to pass along error message information.</p>
</td></tr>
<tr><td><code id="almanac-vctrs-compat_+3A_x_arg">x_arg</code>, <code id="almanac-vctrs-compat_+3A_y_arg">y_arg</code>, <code id="almanac-vctrs-compat_+3A_to_arg">to_arg</code></td>
<td>
<p>Used to pass along error message information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See the corresponding vctrs function for the exact return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vctrs)
vec_arith("+", as.Date("2019-01-04"), workdays(1))
</code></pre>

<hr>
<h2 id='cal_events'>Calendar events</h2><span id='topic+cal_events'></span>

<h3>Description</h3>

<p><code>cal_events()</code> returns a data frame of holiday name / event date pairs for
a calendar. It is similar to <code><a href="#topic+alma_events">alma_events()</a></code>, but returns information about
the name of the holiday and has specialized behavior related to observed
dates when filtering by <code>year</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_events(x, ..., year = NULL, observed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_events_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rcalendar]&#8288;</code>
</p>
<p>An rcalendar.</p>
</td></tr>
<tr><td><code id="cal_events_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="cal_events_+3A_year">year</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>An integer vector of years to filter for.</p>
</td></tr>
<tr><td><code id="cal_events_+3A_observed">observed</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[FALSE / TRUE]&#8288;</code>
</p>
<p>When filtering for specific <code>year</code>s, should the <em>observed</em> date of the
holiday be used for filtering purposes? If <code>FALSE</code>, the <em>actual</em> date of
the holiday will be used, i.e. the date before any observance adjustments
created by <code><a href="#topic+hol_observe">hol_observe()</a></code> have been applied, which is typically desired
when filtering for a year's worth of holidays. See the examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two column data frame:
</p>

<ul>
<li> <p><code>name</code> is a character vector of holiday names.
</p>
</li>
<li> <p><code>date</code> is a Date vector of holiday event dates.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>on_weekends &lt;- weekly() %&gt;%
  recur_on_weekends()

# New Year's Day, observed on the nearest weekday if it falls on a weekend
on_new_years &lt;- hol_new_years_day() %&gt;%
  hol_observe(on_weekends, adj_nearest)

# Christmas, observed on the nearest weekday if it falls on a weekend
on_christmas &lt;- hol_christmas() %&gt;%
  hol_observe(on_weekends, adj_nearest)

cal &lt;- rcalendar(on_new_years, on_christmas)
cal

# In 2010, Christmas fell on a Saturday and was adjusted backwards
cal_events(cal, year = 2010)

# In 2011, New Year's fell on a Saturday and was adjusted backwards.
# Note that the returned date is in 2010, even though we requested holidays
# for 2011, because most people would consider the actual New Year's date of
# 2011-01-01 part of the 2011 set of holidays, even though it was observed in
# 2010.
cal_events(cal, year = 2011)

# If you want to filter by the observed date, set `observed = TRUE`, which
# will move the New Year's Day that was observed in 2010 to the 2010 result
cal_events(cal, year = 2010, observed = TRUE)
cal_events(cal, year = 2011, observed = TRUE)
</code></pre>

<hr>
<h2 id='cal_match'>Calendar matching</h2><span id='topic+cal_match'></span>

<h3>Description</h3>

<p><code>cal_match()</code> matches a date in <code>x</code> to a holiday in <code>rcalendar</code> and returns
the corresponding holiday name, or <code>NA</code> if it doesn't exist in the calendar.
</p>
<p>If a date corresponds to multiple holidays, the holiday that was added to the
calendar first is returned.
</p>
<p>This function is intended to be similar to <code><a href="base.html#topic+match">base::match()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_match(x, rcalendar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_match_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date]&#8288;</code>
</p>
<p>A date vector to match.</p>
</td></tr>
<tr><td><code id="cal_match_+3A_rcalendar">rcalendar</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rcalendar]&#8288;</code>
</p>
<p>A calendar to look for holiday matches in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same size as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cal &lt;- rcalendar(
  hol_christmas(),
  hol_halloween(),
  hol_new_years_day(),
  hol_us_presidents_day()
)

x &lt;- as.Date(c(
  "2019-01-02",
  "2019-12-25",
  "2018-02-19",
  "2018-02-20",
  "2020-10-31"
))

cal_match(x, cal)
</code></pre>

<hr>
<h2 id='cal_names'>Calendar names</h2><span id='topic+cal_names'></span>

<h3>Description</h3>

<p><code>cal_names()</code> returns the names of the holidays in a calendar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_names_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rcalendar]&#8288;</code>
</p>
<p>An rcalendar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of holiday names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rcalendar(hol_christmas(), hol_new_years_day())
cal_names(x)
</code></pre>

<hr>
<h2 id='cal_us_federal'>US federal calendar</h2><span id='topic+cal_us_federal'></span>

<h3>Description</h3>

<p><code>cal_us_federal()</code> is an example calendar that represents the federal
holidays in the United States. It makes no attempt to be historically
accurate, but instead represents the <em>currently</em> recognized federal holidays.
The calendar represents the <em>observed</em> dates of each holiday, rather than the
actual dates of each holiday (i.e. if a holiday falls on a Saturday, it is
federally observed on the preceding Friday).
</p>
<p>Refer to the source code of <code>cal_us_federal()</code> to get a feel for how to
build your own personal calendar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_us_federal(since = NULL, until = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cal_us_federal_+3A_since">since</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1)]&#8288;</code>
</p>
<p>A lower bound on the event set to generate.
</p>
<p>Defaults to <code><a href="#topic+almanac_since">almanac_since()</a></code> if not set.</p>
</td></tr>
<tr><td><code id="cal_us_federal_+3A_until">until</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1)]&#8288;</code>
</p>
<p>An upper bound on the event set to generate.
</p>
<p>Defaults to <code><a href="#topic+almanac_until">almanac_until()</a></code> if not set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rcalendar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cal &lt;- cal_us_federal()

# All 2023 holidays
cal_events(cal, year = 2023)

# Notice that for 2028, `cal_events()` knows that you probably want to
# treat New Year's Day as a 2028 holiday even though it will observed in
# 2027 (because it will be a Saturday and will be rolled back to being
# observed on Friday)
cal_events(cal, year = 2028)

# Were any of these dates on a holiday?
x &lt;- as.Date(c(
  "2023-11-10",
  "2023-10-05",
  "2023-06-19",
  "2023-05-29",
  "2023-05-28"
))

alma_in(x, cal)

# Which one?
cal_match(x, cal)
</code></pre>

<hr>
<h2 id='calendar-add-remove'>Calendar additions and removals</h2><span id='topic+calendar-add-remove'></span><span id='topic+cal_add'></span><span id='topic+cal_remove'></span>

<h3>Description</h3>


<ul>
<li> <p><code>cal_add()</code> adds an rholiday to an rcalendar.
</p>
</li>
<li> <p><code>cal_remove()</code> removes an rholiday from an rcalendar by name, either by
specifying a character name or an rholiday object with the same name.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cal_add(x, rholiday)

cal_remove(x, what)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calendar-add-remove_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rcalendar]&#8288;</code>
</p>
<p>An rcalendar.</p>
</td></tr>
<tr><td><code id="calendar-add-remove_+3A_rholiday">rholiday</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rholiday]&#8288;</code>
</p>
<p>An rholiday to add to the rcalendar.</p>
</td></tr>
<tr><td><code id="calendar-add-remove_+3A_what">what</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1) / rholiday]&#8288;</code>
</p>
<p>The name of a holiday to remove from the rcalendar, or an rholiday object
with the corresponding name that you'd like to remove.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new rcalendar with the holiday added or removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cal &lt;- rcalendar(
  hol_christmas(),
  hol_halloween(),
  hol_new_years_day(),
  hol_us_presidents_day()
)

# Can't forget Easter!
cal %&gt;%
  cal_add(hol_easter())

# Didn't actually need Halloween
cal %&gt;%
  cal_remove(hol_halloween())

# Can remove by name or by object
cal %&gt;%
  cal_remove("Halloween")
</code></pre>

<hr>
<h2 id='calendar-locations'>Calendar locations</h2><span id='topic+calendar-locations'></span><span id='topic+cal_next'></span><span id='topic+cal_previous'></span>

<h3>Description</h3>


<ul>
<li> <p><code>cal_next()</code> generates the next holiday after <code>x</code>.
</p>
</li>
<li> <p><code>cal_previous()</code> generates the previous holiday before <code>x</code>.
</p>
</li></ul>

<p>If no holiday exists before/after <code>x</code>, a missing row is generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_next(x, rcalendar, ..., inclusive = FALSE)

cal_previous(x, rcalendar, ..., inclusive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calendar-locations_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date]&#8288;</code>
</p>
<p>A vector of dates.</p>
</td></tr>
<tr><td><code id="calendar-locations_+3A_rcalendar">rcalendar</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rcalendar]&#8288;</code>
</p>
<p>An rcalendar.</p>
</td></tr>
<tr><td><code id="calendar-locations_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="calendar-locations_+3A_inclusive">inclusive</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code>
</p>
<p>If <code>x</code> is an event, should it be considered the next or previous event?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two column data frame, like <code>cal_events()</code>, which is the same size as <code>x</code>
and contains either the next or previous holiday relative to <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.Date(c("2023-04-11", "2023-08-10", "2021-05-06"))
cal &lt;- cal_us_federal()

cal_next(x, cal)
cal_previous(x, cal)
</code></pre>

<hr>
<h2 id='deprecated-recur'>Deprecated recurrence helpers</h2><span id='topic+deprecated-recur'></span><span id='topic+recur_on_mday'></span><span id='topic+recur_on_wday'></span><span id='topic+recur_on_yday'></span><span id='topic+recur_on_yweek'></span><span id='topic+recur_on_ymonth'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>

<ul>
<li> <p><code>recur_on_mday()</code> is deprecated as of almanac 1.0.0 in favor of
<code><a href="#topic+recur_on_day_of_month">recur_on_day_of_month()</a></code>.
</p>
</li>
<li> <p><code>recur_on_wday()</code> is deprecated as of almanac 1.0.0 in favor of
<code><a href="#topic+recur_on_day_of_week">recur_on_day_of_week()</a></code>.
</p>
</li>
<li> <p><code>recur_on_yday()</code> is deprecated as of almanac 1.0.0 in favor of
<code><a href="#topic+recur_on_day_of_year">recur_on_day_of_year()</a></code>.
</p>
</li>
<li> <p><code>recur_on_yweek()</code> is deprecated as of almanac 1.0.0 in favor of
<code><a href="#topic+recur_on_week_of_year">recur_on_week_of_year()</a></code>.
</p>
</li>
<li> <p><code>recur_on_ymonth()</code> is deprecated as of almanac 1.0.0 in favor of
<code><a href="#topic+recur_on_month_of_year">recur_on_month_of_year()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>recur_on_mday(x, mday)

recur_on_wday(x, wday, nth = NULL)

recur_on_yday(x, yday)

recur_on_yweek(x, yweek)

recur_on_ymonth(x, ymonth)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deprecated-recur_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="deprecated-recur_+3A_mday">mday</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>The days of the month on which to recur. Negative values are allowed,
which specify <code>n</code> days from the end of the month.</p>
</td></tr>
<tr><td><code id="deprecated-recur_+3A_wday">wday</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer / character]&#8288;</code>
</p>
<p>Days of the week to recur on. Integer values must be from <code>1</code> to <code>7</code>, with
<code>1 = Monday</code> and <code>7 = Sunday</code>. This is also allowed to be a full weekday
string like <code>"Tuesday"</code>, or an abbreviation like <code>"Tues"</code>.</p>
</td></tr>
<tr><td><code id="deprecated-recur_+3A_nth">nth</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer / NULL]&#8288;</code>
</p>
<p>Limit to the n-th occurrence of the <code>day</code> in the base frequency. For
example, in a monthly frequency, using <code>nth = -1</code> would limit to the
last <code>day</code> in the month. The default of <code>NULL</code> chooses all occurrences.</p>
</td></tr>
<tr><td><code id="deprecated-recur_+3A_yweek">yweek</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>Weeks of the year to recur on. Integer values must be between
<code style="white-space: pre;">&#8288;[1, 53]&#8288;</code> or <code style="white-space: pre;">&#8288;[-53, -1]&#8288;</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='holiday-utilities'>Holiday utility functions</h2><span id='topic+holiday-utilities'></span><span id='topic+hol_observe'></span><span id='topic+hol_offset'></span><span id='topic+hol_rename'></span>

<h3>Description</h3>

<p>These three functions allow you to tweak existing holidays created by
<code><a href="#topic+rholiday">rholiday()</a></code> so that they more properly align with business calendars. The
resulting holidays can then be added into an <code><a href="#topic+rcalendar">rcalendar()</a></code>.
</p>

<ul>
<li> <p><code>hol_observe()</code> adjusts a holiday based on when it is actually observed.
For example, many holidays that occur on a Saturday are actually observed
on the preceding Friday or following Monday.
</p>
</li>
<li> <p><code>hol_offset()</code> creates a new holiday by <em>offsetting</em> it from an existing
one. For example, Boxing Day is the day after Christmas, and the observance
of Boxing Day may be dependent on the observance of Christmas (i.e. if
Christmas is Sunday, it may be observed on Monday, so Boxing Day would be
observed on Tuesday).
</p>
</li>
<li> <p><code>hol_rename()</code> renames an existing holiday. This is typically useful after
a call to <code>hol_offset()</code>, since it doesn't rename the holiday but you may
want to give it a different name.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>hol_observe(x, adjust_on, adjustment)

hol_offset(x, by)

hol_rename(x, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="holiday-utilities_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rholiday]&#8288;</code>
</p>
<p>An rholiday.</p>
</td></tr>
<tr><td><code id="holiday-utilities_+3A_adjust_on">adjust_on</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule that determines when the <code>adjustment</code> is to be applied.</p>
</td></tr>
<tr><td><code id="holiday-utilities_+3A_adjustment">adjustment</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function]&#8288;</code>
</p>
<p>An adjustment function to apply to problematic dates. Typically one
of the pre-existing adjustment functions, like <code><a href="#topic+adj_nearest">adj_nearest()</a></code>.
</p>
<p>A custom adjustment function must have two arguments <code>x</code> and <code>rschedule</code>.
<code>x</code> is the complete vector of dates that possibly need adjustment.
<code>rschedule</code> is the rschedule who's event set determines when an
adjustment needs to be applied. The function should adjust <code>x</code> as required
and return the adjusted Date vector.</p>
</td></tr>
<tr><td><code id="holiday-utilities_+3A_by">by</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]&#8288;</code>
</p>
<p>A single integer to offset by.</p>
</td></tr>
<tr><td><code id="holiday-utilities_+3A_name">name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>A new name for the holiday.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
on_weekends &lt;- weekly() %&gt;%
  recur_on_weekends()

# Christmas, adjusted to nearest Friday or Monday if it falls on a weekend
on_christmas &lt;- hol_christmas() %&gt;%
  hol_observe(on_weekends, adj_nearest)

# Boxing Day is the day after Christmas.
# If observed Christmas is a Friday, then observed Boxing Day should be Monday.
# If observed Christmas is a Monday, then observed Boxing Day should be Tuesday.
on_boxing_day &lt;- on_christmas %&gt;%
  hol_offset(1) %&gt;%
  hol_observe(on_weekends, adj_following) %&gt;%
  hol_rename("Boxing Day")

christmas_dates &lt;- alma_events(on_christmas, year = 2010:2015)
boxing_day_dates &lt;- alma_events(on_boxing_day, year = 2010:2015)

data.frame(
  christmas = christmas_dates,
  boxing_day = boxing_day_dates,
  christmas_weekday = lubridate::wday(christmas_dates, label = TRUE),
  boxing_day_weekday = lubridate::wday(boxing_day_dates, label = TRUE)
)
</code></pre>

<hr>
<h2 id='holidays'>Holidays</h2><span id='topic+holidays'></span><span id='topic+hol_christmas'></span><span id='topic+hol_christmas_eve'></span><span id='topic+hol_easter'></span><span id='topic+hol_good_friday'></span><span id='topic+hol_halloween'></span><span id='topic+hol_new_years_day'></span><span id='topic+hol_new_years_eve'></span><span id='topic+hol_st_patricks_day'></span><span id='topic+hol_valentines_day'></span><span id='topic+hol_us_election_day'></span><span id='topic+hol_us_fathers_day'></span><span id='topic+hol_us_independence_day'></span><span id='topic+hol_us_indigenous_peoples_day'></span><span id='topic+hol_us_juneteenth'></span><span id='topic+hol_us_labor_day'></span><span id='topic+hol_us_martin_luther_king_junior_day'></span><span id='topic+hol_us_memorial_day'></span><span id='topic+hol_us_mothers_day'></span><span id='topic+hol_us_presidents_day'></span><span id='topic+hol_us_thanksgiving'></span><span id='topic+hol_us_veterans_day'></span>

<h3>Description</h3>

<p>This page lists a number of pre-created holidays that can be added to a
calendar created with <code><a href="#topic+rcalendar">rcalendar()</a></code>. This list makes no attempt to be
comprehensive. If you need to create your own holiday, you can do so with
<code><a href="#topic+rholiday">rholiday()</a></code>.
</p>
<p>It also makes no attempt to be historically accurate, i.e. Juneteenth was
created in 2021, but <code>hol_us_juneteenth()</code> will generate event dates before
that. Because <code><a href="#topic+rholiday">rholiday()</a></code> takes an arbitrary rschedule object, you can
always create an rschedule that is historically accurate and use that
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hol_christmas(since = NULL, until = NULL)

hol_christmas_eve(since = NULL, until = NULL)

hol_easter(since = NULL, until = NULL)

hol_good_friday(since = NULL, until = NULL)

hol_halloween(since = NULL, until = NULL)

hol_new_years_day(since = NULL, until = NULL)

hol_new_years_eve(since = NULL, until = NULL)

hol_st_patricks_day(since = NULL, until = NULL)

hol_valentines_day(since = NULL, until = NULL)

hol_us_election_day(since = NULL, until = NULL)

hol_us_fathers_day(since = NULL, until = NULL)

hol_us_independence_day(since = NULL, until = NULL)

hol_us_indigenous_peoples_day(since = NULL, until = NULL)

hol_us_juneteenth(since = NULL, until = NULL)

hol_us_labor_day(since = NULL, until = NULL)

hol_us_martin_luther_king_junior_day(since = NULL, until = NULL)

hol_us_memorial_day(since = NULL, until = NULL)

hol_us_mothers_day(since = NULL, until = NULL)

hol_us_presidents_day(since = NULL, until = NULL)

hol_us_thanksgiving(since = NULL, until = NULL)

hol_us_veterans_day(since = NULL, until = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="holidays_+3A_since">since</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1)]&#8288;</code>
</p>
<p>A lower bound on the event set to generate.
</p>
<p>Defaults to <code><a href="#topic+almanac_since">almanac_since()</a></code> if not set.</p>
</td></tr>
<tr><td><code id="holidays_+3A_until">until</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1)]&#8288;</code>
</p>
<p>An upper bound on the event set to generate.
</p>
<p>Defaults to <code><a href="#topic+almanac_until">almanac_until()</a></code> if not set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <em>relative</em> holidays, such as New Year's Eve, which is 1 day before
New Year's Day, aren't pre-created in a way that allows you to define
observance rules for them that depend on the observance rules of the holiday
they are relative to. If you need to do this, you should start with the base
holiday, here <code><a href="#topic+hol_new_years_day">hol_new_years_day()</a></code>, and use <code><a href="#topic+hol_observe">hol_observe()</a></code> and
<code><a href="#topic+hol_offset">hol_offset()</a></code> on that to generate a New Year's Eve holiday that matches
your required observance rules. See the examples of <code><a href="#topic+hol_offset">hol_offset()</a></code> for more
information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>on_christmas &lt;- hol_christmas()
on_christmas

# These are like any other rschedule object
alma_events(on_christmas, year = 2020:2025)

# But they can also be added into an rcalendar
cal &lt;- rcalendar(
  on_christmas,
  hol_halloween(),
  hol_new_years_day(),
  hol_us_presidents_day()
)
cal

# Which gives you access to a number of `cal_*()` functions
cal_events(cal, year = 2020:2022)
</code></pre>

<hr>
<h2 id='new_rschedule'>Create a new rschedule</h2><span id='topic+new_rschedule'></span><span id='topic+rschedule_events'></span>

<h3>Description</h3>

<p><code>new_rschedule()</code> is a developer focused tool that is not required for
normal usage of almanac. It is only exported to allow other packages
to construct new rschedule objects that work with almanac functions
prefixed with <code style="white-space: pre;">&#8288;alma_*()&#8288;</code>, like <code><a href="#topic+alma_in">alma_in()</a></code>.
</p>
<p><code>rschedule_events()</code> is a generic function that rschedule subclasses must
provide a method for. <code>rschedule_events()</code> should return a Date vector
containing the complete ordered set of events in the event set of
that rschedule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_rschedule(..., class)

rschedule_events(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_rschedule_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[named fields]&#8288;</code>
</p>
<p>Named data fields.</p>
</td></tr>
<tr><td><code id="new_rschedule_+3A_class">class</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code>
</p>
<p>A required subclass.</p>
</td></tr>
<tr><td><code id="new_rschedule_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule subclass]&#8288;</code>
</p>
<p>An object that subclasses rschedule.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An rschedule is an abstract class that rrule and rset both inherit from.
The sole functionality of rschedule classes is to provide a method for
<code>rschedule_events()</code>.
</p>


<h3>Value</h3>

<p>For <code>new_rschedule()</code>, a new rschedule subclass.
</p>
<p>For <code>rschedule_events()</code>, a Date vector of events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>events &lt;- as.Date("1970-01-01")

static &lt;- new_rschedule(
  events = events,
  class = "static_rschedule"
)

# You have to register an `rschedule_events()` method first!
try(alma_events(static))
</code></pre>

<hr>
<h2 id='radjusted'>Create an adjusted rschedule</h2><span id='topic+radjusted'></span>

<h3>Description</h3>

<p><code>radjusted()</code> creates a new adjusted rschedule on top of an existing one. The
new rschedule contains the same event dates as the existing rschedule,
except when they intersect with the dates in the event set of the
rschedule, <code>adjust_on</code>. In those cases, an <code>adjustment</code> is applied to the
problematic dates to shift them to valid event dates.
</p>
<p>This is most useful when creating corporate holiday rschedules. For example,
Christmas always falls on December 25th, but if it falls on a Saturday,
your company might observe Christmas on the previous Friday. If it falls
on a Sunday, you might observe it on the following Monday. In this case,
you could construct an rschedule for a recurring event of December 25th,
and a second rschedule for weekends. When Christmas falls on a weekend,
you would apply an adjustment of <code><a href="#topic+adj_nearest">adj_nearest()</a></code> to get the observance date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radjusted(rschedule, adjust_on, adjustment)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="radjusted_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule, such as an rrule, runion, rintersect, or rsetdiff.</p>
</td></tr>
<tr><td><code id="radjusted_+3A_adjust_on">adjust_on</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule that determines when the <code>adjustment</code> is to be applied.</p>
</td></tr>
<tr><td><code id="radjusted_+3A_adjustment">adjustment</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function]&#8288;</code>
</p>
<p>An adjustment function to apply to problematic dates. Typically one
of the pre-existing adjustment functions, like <code><a href="#topic+adj_nearest">adj_nearest()</a></code>.
</p>
<p>A custom adjustment function must have two arguments <code>x</code> and <code>rschedule</code>.
<code>x</code> is the complete vector of dates that possibly need adjustment.
<code>rschedule</code> is the rschedule who's event set determines when an
adjustment needs to be applied. The function should adjust <code>x</code> as required
and return the adjusted Date vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjusted rschedule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>since &lt;- "2000-01-01"
until &lt;- "2010-01-01"

on_christmas &lt;- yearly(since = since, until = until) %&gt;%
  recur_on_month_of_year("Dec") %&gt;%
  recur_on_day_of_month(25)

# All Christmas dates, with no adjustments
alma_events(on_christmas)

on_weekends &lt;- weekly(since = since, until = until) %&gt;%
  recur_on_weekends()

# Now all Christmas dates that fell on a weekend are
# adjusted either forwards or backwards, depending on which
# non-event date was closer
on_adj_christmas &lt;- radjusted(on_christmas, on_weekends, adj_nearest)

alma_events(on_adj_christmas)
</code></pre>

<hr>
<h2 id='rcalendar'>Create a recurring calendar</h2><span id='topic+rcalendar'></span>

<h3>Description</h3>

<p><code>rcalendar()</code> creates a calendar filled with holidays created from one of the
existing <code style="white-space: pre;">&#8288;hol_*()&#8288;</code> holidays (such as <code><a href="#topic+hol_christmas">hol_christmas()</a></code>) or from a manually
generated holiday created using <code><a href="#topic+rholiday">rholiday()</a></code>. That calendar can then be used
as an rschedule with any other <code style="white-space: pre;">&#8288;alma_*()&#8288;</code> function (like <code><a href="#topic+alma_in">alma_in()</a></code>), or
with one of the specialized calendar functions, like <code><a href="#topic+cal_match">cal_match()</a></code> or
<code><a href="#topic+cal_events">cal_events()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcalendar(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcalendar_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rholidays]&#8288;</code>
</p>
<p>One or more holidays created from <code><a href="#topic+rholiday">rholiday()</a></code> or <code style="white-space: pre;">&#8288;hol_*()&#8288;</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>on_earth_day &lt;- yearly() %&gt;%
  recur_on_month_of_year("April") %&gt;%
  recur_on_day_of_month(22) %&gt;%
  rholiday("Earth Day")

cal &lt;- rcalendar(
  hol_christmas(),
  on_earth_day,
  hol_us_independence_day()
)

cal

cal_events(cal, year = 2020:2022)

# Lookup holiday name based on date, if it exists
cal_match(c("2021-12-25", "2021-12-26"), cal)

# Find next holiday
alma_next("2021-12-26", cal)
</code></pre>

<hr>
<h2 id='rcustom'>Create a custom rschedule</h2><span id='topic+rcustom'></span>

<h3>Description</h3>

<p><code>rcustom()</code> creates an rschedule from manually defined event dates. This can
be useful when combined with <code><a href="#topic+runion">runion()</a></code> and <code><a href="#topic+rsetdiff">rsetdiff()</a></code> if you have a set of
fixed event dates to forcibly include or exclude from an rschedule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcustom(events)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcustom_+3A_events">events</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date]&#8288;</code>
</p>
<p>A vector of event dates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A custom rschedule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>include &lt;- rcustom("2019-07-05")
exclude &lt;- rcustom("2019-07-04")

independence_day &lt;- yearly() %&gt;%
  recur_on_month_of_year("July") %&gt;%
  recur_on_day_of_month(4)

# Remove forcibly excluded day
independence_day &lt;- rsetdiff(independence_day, exclude)

# Add forcibly included day
independence_day &lt;- runion(independence_day, include)

alma_search("2018-01-01", "2020-12-31", independence_day)
</code></pre>

<hr>
<h2 id='recur_for_count'>Control the number of times to recur</h2><span id='topic+recur_for_count'></span>

<h3>Description</h3>

<p><code>recur_for_count()</code> controls the total number of events in the recurrence
set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_for_count(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recur_for_count_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="recur_for_count_+3A_n">n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[positive integer(1)]&#8288;</code>
</p>
<p>The number of times to recur for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remember that the number of times the occurrence has occurred is counted
from the <code>since</code> date and is limited by the <code>until</code> date! Adjust them as
necessary to get your desired results.
</p>


<h3>Value</h3>

<p>An updated rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the default `since` date
daily_since_epoch_for_5 &lt;- daily() %&gt;% recur_for_count(5)

alma_search("1969-12-31", "1970-01-25", daily_since_epoch_for_5)

# Changing the `since` date
daily_since_2019_for_5 &lt;- daily(since = "2019-01-01") %&gt;% recur_for_count(5)

alma_search("2018-12-31", "2019-01-25", daily_since_2019_for_5)

# In the case of "impossible" dates, such as 2019-02-31 and 2019-04-31 in the
# example below, they are not added to the total count. Only true event
# dates are counted.
on_31_for_5 &lt;- monthly(since = "2019-01-01") %&gt;%
  recur_on_day_of_month(31) %&gt;%
  recur_for_count(5)

alma_search("2019-01-01", "2020-01-01", on_31_for_5)
</code></pre>

<hr>
<h2 id='recur_on_day_of_month'>Recur on a day of the month</h2><span id='topic+recur_on_day_of_month'></span>

<h3>Description</h3>

<p><code>recur_on_day_of_month()</code> recurs on a specific day of the month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_on_day_of_month(x, day)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recur_on_day_of_month_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="recur_on_day_of_month_+3A_day">day</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>The days of the month on which to recur. Negative values are allowed,
which specify <code>n</code> days from the end of the month.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the day of the month doesn't exist for that particular month, then it
is ignored. For example, if <code>recur_on_day_of_month(30)</code> is set, then it will
never generate an event in February.
</p>


<h3>Value</h3>

<p>An updated rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># When used with a yearly or monthly frequency, `recur_on_day_of_month()`
# expands the number of days in the event set.
on_yearly &lt;- yearly()
on_yearly_day_of_month_1_to_2 &lt;- on_yearly %&gt;% recur_on_day_of_month(1:2)

start &lt;- "1999-01-01"
end &lt;- "2000-06-30"

alma_search(start, end, on_yearly)
alma_search(start, end, on_yearly_day_of_month_1_to_2)

# When used with a daily frequency, `recur_on_day_of_month()` limits the
# number of days in the event set.
on_daily &lt;- daily()
on_daily_day_of_month_1_to_2 &lt;- on_daily %&gt;% recur_on_day_of_month(1:2)

length(alma_search(start, end, on_daily))
length(alma_search(start, end, on_daily_day_of_month_1_to_2))

# Using a negative value is a powerful way to look back from the end of the
# month. This is particularly useful because months don't have the same
# number of days.
on_last_of_month &lt;- monthly() %&gt;% recur_on_day_of_month(-1)

alma_search(start, end, on_last_of_month)

# If you want particular days of the week at the end of the month, you
# could use something like this, which checks if the end of the month
# is also a Friday.
on_last_of_month_that_is_also_friday &lt;- on_last_of_month %&gt;% recur_on_day_of_week("Friday")
alma_search(start, end, on_last_of_month_that_is_also_friday)

# But you probably wanted this, which takes the last friday of the month,
# on whatever day that lands on
on_last_friday_of_month &lt;- monthly() %&gt;% recur_on_day_of_week("Friday", nth = -1)
alma_search(start, end, on_last_friday_of_month)
</code></pre>

<hr>
<h2 id='recur_on_day_of_week'>Recur on a day of the week</h2><span id='topic+recur_on_day_of_week'></span><span id='topic+recur_on_weekdays'></span><span id='topic+recur_on_weekends'></span>

<h3>Description</h3>


<ul>
<li> <p><code>recur_on_day_of_week()</code> recurs on a specific day of the week.
</p>
</li>
<li> <p><code>recur_on_weekends()</code> and <code>recur_on_weekdays()</code> are helpers for
recurring on weekends and weekdays.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>recur_on_day_of_week(x, day, ..., nth = NULL)

recur_on_weekdays(x)

recur_on_weekends(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recur_on_day_of_week_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="recur_on_day_of_week_+3A_day">day</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer / character]&#8288;</code>
</p>
<p>Days of the week to recur on. Integer values must be from <code>1</code> to <code>7</code>, with
<code>1 = Monday</code> and <code>7 = Sunday</code>. This is also allowed to be a full weekday
string like <code>"Tuesday"</code>, or an abbreviation like <code>"Tues"</code>.</p>
</td></tr>
<tr><td><code id="recur_on_day_of_week_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="recur_on_day_of_week_+3A_nth">nth</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer / NULL]&#8288;</code>
</p>
<p>Limit to the n-th occurrence of the <code>day</code> in the base frequency. For
example, in a monthly frequency, using <code>nth = -1</code> would limit to the
last <code>day</code> in the month. The default of <code>NULL</code> chooses all occurrences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple week day values are allowed, and <code>nth</code> will be applied to
all of them. If you want to apply different <code>nth</code> values to different
days of the week, call <code>recur_on_day_of_week()</code> twice with different <code>day</code>
values.
</p>
<p>It is particularly important to pay attention to the <code>since</code> date when using
weekly rules. The day of the week to use comes from the <code>since</code> date, which,
by default, is a Monday (<code>1900-01-01</code>). See <code><a href="#topic+almanac_since">almanac_since()</a></code> for more
information.
</p>


<h3>Value</h3>

<p>An updated rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using default `since` (1900-01-01, a Monday)
on_weekly_mondays &lt;- weekly()

start &lt;- "1999-01-01" # &lt;- a Friday
end &lt;- "1999-03-01"

# This finds the first Monday, and then continues from there
alma_search(start, end, on_weekly_mondays)

# We start counting from a Friday here
on_weekly_fridays &lt;- weekly(since = start)
alma_search(start, end, on_weekly_fridays)

# Alternatively, we could use `recur_on_day_of_week()` and force a recurrence
# rule on Friday
on_forced_friday &lt;- on_weekly_mondays %&gt;% recur_on_day_of_week("Friday")
alma_search(start, end, on_forced_friday)

# At monthly frequencies, you can use n-th values to look for particular
# week day events
on_first_friday_in_month &lt;- monthly() %&gt;% recur_on_day_of_week("Fri", nth = 1)
alma_search(start, end, on_first_friday_in_month)

# Negative values let you look from the back
on_last_friday_in_month &lt;- monthly() %&gt;% recur_on_day_of_week("Fri", nth = -1)
alma_search(start, end, on_last_friday_in_month)

# At yearly frequencies, this looks for the first sunday of the year
on_first_sunday_in_year &lt;- yearly() %&gt;% recur_on_day_of_week("Sunday", nth = 1)
alma_search(start, end, on_first_sunday_in_year)

# Last week day of the month
last_weekday_of_month &lt;- monthly() %&gt;%
  # Last occurrence of each weekday in the month
  recur_on_day_of_week(c("Mon", "Tue", "Wed", "Thu", "Fri"), nth = -1) %&gt;%
  # Now choose the last one of those in each month
  recur_on_position(-1)

alma_search(start, end, last_weekday_of_month)

</code></pre>

<hr>
<h2 id='recur_on_day_of_year'>Recur on a day of the year</h2><span id='topic+recur_on_day_of_year'></span>

<h3>Description</h3>

<p><code>recur_on_day_of_year()</code> recurs on a specific day of the year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_on_day_of_year(x, day)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recur_on_day_of_year_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="recur_on_day_of_year_+3A_day">day</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>Days of the year to recur on. Values must be from <code style="white-space: pre;">&#8288;[-366, -1]&#8288;</code> and
<code style="white-space: pre;">&#8288;[1, 366]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate, warn.conflicts = FALSE)

on_5th_day_of_year &lt;- yearly() %&gt;% recur_on_day_of_year(5)

alma_search("1999-01-01", "2000-12-31", on_5th_day_of_year)

# Notice that if you use a `since` date that has a day of the year
# after the specified one, it rolls to the next year
on_5th_day_of_year2 &lt;- yearly(since = "1999-01-06") %&gt;% recur_on_day_of_year(5)
alma_search("1999-01-01", "2000-12-31", on_5th_day_of_year2)

# Negative values select from the back, which is useful in leap years
leap_year(as.Date("2000-01-01"))

last_day_of_year &lt;- yearly() %&gt;% recur_on_day_of_year(-1)
last_day_of_year_bad &lt;- yearly() %&gt;% recur_on_day_of_year(365)

alma_search("1999-01-01", "2000-12-31", last_day_of_year)
alma_search("1999-01-01", "2000-12-31", last_day_of_year_bad)

</code></pre>

<hr>
<h2 id='recur_on_easter'>Recur on easter</h2><span id='topic+recur_on_easter'></span>

<h3>Description</h3>

<p><code>recur_on_easter()</code> is a special helper to recur on Easter. Easter is
particularly difficult to construct a recurrence rule for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_on_easter(x, offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recur_on_easter_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="recur_on_easter_+3A_offset">offset</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code style="white-space: pre;">&#8288;[integer(1)]&#8288;</code>
</p>
<p>Deprecated in favor of using <code><a href="#topic+roffset">roffset()</a></code> directly.
</p>
<p>An offset in terms of a number of days on either side of Easter to recur
on. This offset must still fall within the same year, otherwise the date
will be silently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>on_easter &lt;- yearly() %&gt;% recur_on_easter()

# Rather than:
if (FALSE) {
on_easter_monday &lt;- yearly() %&gt;% recur_on_easter(1)
}

# Please use:
on_easter_monday &lt;- roffset(on_easter, 1)

alma_search("1999-01-01", "2001-01-01", on_easter)

both &lt;- runion(on_easter, on_easter_monday)

alma_search("1999-01-01", "2001-01-01", both)
</code></pre>

<hr>
<h2 id='recur_on_interval'>Recur on an interval</h2><span id='topic+recur_on_interval'></span>

<h3>Description</h3>

<p><code>recur_on_interval()</code> adjusts the interval of the base frequency of the
recurrence rule. For example, a <code><a href="#topic+monthly">monthly()</a></code> rule with an interval of 2 would
become &quot;every other month&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_on_interval(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recur_on_interval_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="recur_on_interval_+3A_n">n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[positive integer(1)]&#8288;</code>
</p>
<p>The interval on which to recur.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The default interval is 1
on_monthly &lt;- monthly(since = "1999-01-01")

alma_search("1999-01-01", "1999-06-01", on_monthly)

# Adjust to every other month
on_every_other_month &lt;- on_monthly %&gt;% recur_on_interval(2)

alma_search("1999-01-01", "1999-06-01", on_every_other_month)

# Note that the frequency is limited to "every other month", but you
# can still have multiple events inside a single month
on_every_other_month_on_day_25_or_26 &lt;- on_every_other_month %&gt;%
  recur_on_day_of_month(25:26)

alma_search("1999-01-01", "1999-06-01", on_every_other_month_on_day_25_or_26)

</code></pre>

<hr>
<h2 id='recur_on_month_of_year'>Recur on a month of the year</h2><span id='topic+recur_on_month_of_year'></span>

<h3>Description</h3>

<p><code>recur_on_month_of_year()</code> recurs on a specific month of the year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_on_month_of_year(x, month)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recur_on_month_of_year_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="recur_on_month_of_year_+3A_month">month</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer / character]&#8288;</code>
</p>
<p>Months of the year to mark as events. Integer values must be between
<code style="white-space: pre;">&#8288;[1, 12]&#8288;</code>. This can also be a full month string like <code>"November"</code>, or an
abbreviation like <code>"Nov"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a big difference between adding this rule to a `yearly()`
# or `monthly()` frequency, and a `daily()` frequency.

# Limit from every day to every day in February
on_feb_daily &lt;- daily() %&gt;% recur_on_month_of_year("Feb")

# Limit from 1 day per month to 1 day in February
on_feb_monthly &lt;- monthly() %&gt;% recur_on_month_of_year("Feb")

start &lt;- "1999-01-01"
end &lt;- "2001-01-01"

alma_search(start, end, on_feb_daily)

alma_search(start, end, on_feb_monthly)
</code></pre>

<hr>
<h2 id='recur_on_position'>Recur on a position within a frequency</h2><span id='topic+recur_on_position'></span>

<h3>Description</h3>

<p><code>recur_on_position()</code> let's you have fine tuned control over which element
of the set to select <em>within</em> the base frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_on_position(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recur_on_position_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="recur_on_position_+3A_n">n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>The positions to select within an intrafrequency set. Negative numbers
select from the end of the set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate, warn.conflicts = FALSE)

start &lt;- "1999-01-01"
end &lt;- "1999-05-01"

# You might want the last day of the month that is either a
# Sunday or a Monday, but you don't want to return both.
# This would return both:
on_last_monday_and_sunday &lt;- monthly() %&gt;%
  recur_on_day_of_week(c("Monday", "Sunday"), nth = -1)

alma_search(start, end, on_last_monday_and_sunday)

# To return just the last one, you would select the last value in
# the set, which is computed on a per month basis
on_very_last_monday_or_sunday &lt;- on_last_monday_and_sunday %&gt;%
  recur_on_position(-1)

alma_search(start, end, on_very_last_monday_or_sunday)

wday(alma_search(start, end, on_very_last_monday_or_sunday), label = TRUE)

</code></pre>

<hr>
<h2 id='recur_on_week_of_year'>Recur on a week of the year</h2><span id='topic+recur_on_week_of_year'></span>

<h3>Description</h3>

<p><code>recur_on_week_of_year()</code> recurs on a specific week of the year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_on_week_of_year(x, week)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recur_on_week_of_year_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="recur_on_week_of_year_+3A_week">week</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>Weeks of the year to recur on. Integer values must be between
<code style="white-space: pre;">&#8288;[1, 53]&#8288;</code> or <code style="white-space: pre;">&#8288;[-53, -1]&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weekly rules are implemented according to the ISO-8601 standard. This
requires that the first week of a year is the first one containing at least
4 days of the new year. Additionally, the week will start on the week day
specified by <code><a href="#topic+recur_with_week_start">recur_with_week_start()</a></code>, which defaults to Monday.
</p>


<h3>Value</h3>

<p>An updated rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Weekly rules are a bit tricky because they are implemented to comply
# with ISO-8601 standards, which require that the first week of the year
# is when there are at least 4 days in that year, and the week starts on
# the week day specified by `recur_with_week_start()` (Monday by default).
on_first_week &lt;- yearly() %&gt;% recur_on_week_of_year(1)

# In 2017:
# - Look at dates 1-4
# - 2017-01-02 is a Monday, so start the first week here
alma_search("2017-01-01", "2017-01-25", on_first_week)

# In 2015:
# - Look at dates 1-4
# - None of these are Monday, so the start of the week is
#   in the previous year
# - Look at 2014 and find the last Monday, 2014-12-29. This is the start of
#   the first week in 2015.
alma_search("2014-12-25", "2015-01-25", on_first_week)

# Say we want the start of the week to be Sunday instead of Monday!

# In 2015:
# - Look at dates 1-4
# - 2015-01-04 is a Sunday, so start the first week here
on_first_week_sun &lt;- yearly() %&gt;%
  recur_on_week_of_year(1) %&gt;%
  recur_with_week_start("Sunday")

alma_search("2014-12-25", "2015-01-25", on_first_week_sun)
</code></pre>

<hr>
<h2 id='recur_with_week_start'>Control the start of the week</h2><span id='topic+recur_with_week_start'></span>

<h3>Description</h3>

<p><code>recur_with_week_start()</code> controls the week day that represents the start of
the week. This is important for rules that use <code><a href="#topic+recur_on_week_of_year">recur_on_week_of_year()</a></code>.
</p>
<p><em>The default day of the week to start on is Monday.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recur_with_week_start(x, day)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recur_with_week_start_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rrule]&#8288;</code>
</p>
<p>A recurrence rule.</p>
</td></tr>
<tr><td><code id="recur_with_week_start_+3A_day">day</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / character(1)]&#8288;</code>
</p>
<p>Day of the week to start the week on. Must be an integer value in
<code style="white-space: pre;">&#8288;[1, 7]&#8288;</code>, with <code>1 = Monday</code> and <code>7 = Sunday</code>. This is also allowed to be
a full weekday string like <code>"Tuesday"</code>, or an abbreviation like <code>"Tues"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Weekly rules are a bit tricky because they are implemented to comply
# with ISO-8601 standards, which require that the first week of the year
# is when there are at least 4 days in that year, and the week starts on
# the week day specified by `recur_with_week_start()` (Monday by default).
on_first_week &lt;- yearly() %&gt;% recur_on_week_of_year(1)

# In 2017:
# - Look at dates 1-4
# - 2017-01-02 is a Monday, so start the first week here
alma_search("2017-01-01", "2017-01-25", on_first_week)

# In 2015:
# - Look at dates 1-4
# - None of these are Monday, so the start of the week is
#   in the previous year
# - Look at 2014 and find the last Monday, 2014-12-29. This is the start of
#   the first week in 2015.
alma_search("2014-12-25", "2015-01-25", on_first_week)

# Say we want the start of the week to be Sunday instead of Monday!

# In 2015:
# - Look at dates 1-4
# - 2015-01-04 is a Sunday, so start the first week here
on_first_week_sun &lt;- yearly() %&gt;%
  recur_on_week_of_year(1) %&gt;%
  recur_with_week_start("Sunday")

alma_search("2014-12-25", "2015-01-25", on_first_week_sun)
</code></pre>

<hr>
<h2 id='rholiday'>Create a recurring holiday</h2><span id='topic+rholiday'></span>

<h3>Description</h3>

<p><code>rholiday()</code> is used to create custom holidays. It wraps up a holiday <code>name</code>
and its corresponding <code>rschedule</code> into a holiday object with special
properties.
</p>
<p>Holiday objects can be tweaked with <code><a href="#topic+hol_rename">hol_rename()</a></code>, <code><a href="#topic+hol_observe">hol_observe()</a></code>, and
<code><a href="#topic+hol_offset">hol_offset()</a></code>, and they can be added to a calendar with <code><a href="#topic+rcalendar">rcalendar()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rholiday(rschedule, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rholiday_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>The recurrence schedule that determines when the holiday occurs.</p>
</td></tr>
<tr><td><code id="rholiday_+3A_name">name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>The name of the holiday. This serves as a unique identifier when adding
multiple holidays to an <code><a href="#topic+rcalendar">rcalendar()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>on_christmas &lt;- yearly() %&gt;%
  recur_on_month_of_year("Dec") %&gt;%
  recur_on_day_of_month(25)

# Bundle a holiday name with its recurrence schedule to create a holiday
rholiday(on_christmas, "Christmas")

# This is how the built in holiday objects are created
hol_christmas()
</code></pre>

<hr>
<h2 id='roffset'>Create an offset rschedule</h2><span id='topic+roffset'></span>

<h3>Description</h3>

<p><code>roffset()</code> creates a new rschedule with events that are <em>offset</em> from an
existing rschedule by a certain amount. This can be useful when generating
relative events like &quot;the day after Christmas.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roffset(rschedule, by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roffset_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule to offset.</p>
</td></tr>
<tr><td><code id="roffset_+3A_by">by</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]&#8288;</code>
</p>
<p>A single integer to offset by.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An offset rschedule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>on_christmas &lt;- yearly() %&gt;%
  recur_on_month_of_year("Dec") %&gt;%
  recur_on_day_of_month(25)

on_day_after_christmas &lt;- roffset(on_christmas, by = 1)

alma_search("2018-01-01", "2023-01-01", on_day_after_christmas)

# Now what if you want the observed holiday representing the day after
# Christmas?
on_weekends &lt;- weekly() %&gt;% recur_on_weekends()

# Adjust Christmas to the nearest weekday
on_christmas &lt;- radjusted(on_christmas, on_weekends, adj_nearest)

# Offset by 1 and then adjust that to the following weekday.
# We never adjust backwards because that can coincide with the observed day
# for Christmas.
on_day_after_christmas &lt;- on_christmas %&gt;%
  roffset(by = 1) %&gt;%
  radjusted(on_weekends, adj_following)

# Note that:
# - A Christmas on Friday the 24th resulted in a day after Christmas of
#   Monday the 27th
# - A Christmas on Monday the 26th resulted in a day after Christmas of
#   Tuesday the 27th
christmas &lt;- alma_search("2018-01-01", "2023-01-01", on_christmas)
day_after_christmas &lt;- alma_search("2018-01-01", "2023-01-01", on_day_after_christmas)

lubridate::wday(christmas, label = TRUE)
lubridate::wday(day_after_christmas, label = TRUE)
</code></pre>

<hr>
<h2 id='rrule'>Create a recurrence rule</h2><span id='topic+rrule'></span><span id='topic+daily'></span><span id='topic+weekly'></span><span id='topic+monthly'></span><span id='topic+yearly'></span>

<h3>Description</h3>

<p>These functions allow you to create a recurrence rule with a specified
frequency. They are the base elements for all recurrence rules. To add
to them, use one of the <code style="white-space: pre;">&#8288;recur_*()&#8288;</code> functions.
</p>

<ul>
<li> <p><code>daily()</code> Recur on a daily frequency.
</p>
</li>
<li> <p><code>weekly()</code> Recur on a weekly frequency.
</p>
</li>
<li> <p><code>monthly()</code> Recur on a monthly frequency.
</p>
</li>
<li> <p><code>yearly()</code> Recur on a yearly frequency.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>daily(since = NULL, until = NULL)

weekly(since = NULL, until = NULL)

monthly(since = NULL, until = NULL)

yearly(since = NULL, until = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rrule_+3A_since">since</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1)]&#8288;</code>
</p>
<p>The lower bound on the event set. Depending on the final
recurrence rule, pieces of information from this anchor date might be used
to generate a complete recurrence rule.</p>
</td></tr>
<tr><td><code id="rrule_+3A_until">until</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1)]&#8288;</code>
</p>
<p>The upper bound on the event set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>since == "1900-01-01"</code> and <code>until == "2100-01-01"</code>, which should
capture most use cases well while still being performant. You may need to
adjust these dates if you want events outside this range. See
<code><a href="#topic+almanac_since">almanac_since()</a></code> and <code><a href="#topic+almanac_until">almanac_until()</a></code> for more information.
</p>
<p>In terms of speed, it is generally more efficient if you adjust the <code>since</code>
and <code>until</code> date to be closer to the first date in the sequence of dates
that you are working with. For example, if you are working with dates in the
range of 2019 and forward, adjust the <code>since</code> date to be <code>2019-01-01</code> for a
significant speed boost.
</p>
<p>As the anchor date, events are often calculated <em>relative to</em> this
date. As an example, a rule of &quot;on Monday, every other week&quot; would use
the <code>since</code> date to find the first Monday to start the recurrence from.
</p>
<p>There is no <code>quarterly()</code> recurrence frequency, but this can be accomplished
with <code>monthly() %&gt;% recur_on_interval(3)</code>. The month to start the quarterly
interval from will be pulled from the <code>since</code> date inside <code>monthly()</code>. The
default will use a quarterly rule starting in January since the default
<code>since</code> date is <code>1900-01-01</code>. See the examples.
</p>


<h3>Value</h3>

<p>A new empty rrule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rrule &lt;- monthly() %&gt;% recur_on_day_of_month(25)

alma_search("1970-01-01", "1971-01-01", rrule)

# Notice that dates before 1900-01-01 are never generated with the defaults!
alma_search("1899-01-01", "1901-01-01", rrule)

# Adjust the `since` date to get access to these dates
rrule_pre_1900 &lt;- monthly(since = "1850-01-01") %&gt;% recur_on_day_of_month(25)
alma_search("1899-01-01", "1901-01-01", rrule_pre_1900)

# A quarterly recurrence rule can be built from
# `monthly()` and `recur_on_interval()`
on_first_of_the_quarter &lt;- monthly() %&gt;%
  recur_on_interval(3) %&gt;%
  recur_on_day_of_month(1)

alma_search("1999-01-01", "2000-04-01", on_first_of_the_quarter)

# Alter the starting quarter by altering the `since` date
on_first_of_the_quarter_starting_in_feb &lt;- monthly(since = "1998-02-01") %&gt;%
  recur_on_interval(3) %&gt;%
  recur_on_day_of_month(1)

alma_search(
  "1999-01-01",
  "2000-04-01",
  on_first_of_the_quarter_starting_in_feb
)

</code></pre>

<hr>
<h2 id='rset'>Create a new set-based recurrence schedule</h2><span id='topic+rset'></span><span id='topic+runion'></span><span id='topic+rintersect'></span><span id='topic+rsetdiff'></span>

<h3>Description</h3>

<p>Often, a single rrule will be sufficient. However, more complex
recurrence objects can be constructed by combining multiple rschedules into
a <em>recurrence set</em>.
</p>
<p>There are three types of recurrence sets provided in almanac, each of
which construct their event sets by performing a set operation on the
underlying events of the rschedules in the set.
</p>

<ul>
<li> <p><code>runion()</code> takes the union.
</p>
</li>
<li> <p><code>rintersect()</code> takes the intersection.
</p>
</li>
<li> <p><code>rsetdiff()</code> takes the set difference.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>runion(...)

rintersect(...)

rsetdiff(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rset_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedules]&#8288;</code>
</p>
<p>rschedule objects to add to the set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>rsetdiff()</code>, the event set is created &quot;from left to right&quot; and depends
on the order that the rschedules were added to the set.
</p>


<h3>Value</h3>

<p>A runion, rintersect, or rsetdiff.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>since &lt;- "2019-04-01"
until &lt;- "2019-05-31"

on_weekends &lt;- weekly(since = since, until = until) %&gt;%
  recur_on_weekends()

on_25th &lt;- monthly(since = since, until = until) %&gt;%
  recur_on_day_of_month(25)

# On weekends OR the 25th of the month
ru &lt;- runion(on_weekends, on_25th)
alma_events(ru)

# On weekends AND the 25th of the month
ri &lt;- rintersect(on_weekends, on_25th)
alma_events(ri)

# On weekends AND NOT the 25th of the month
rsd1 &lt;- rsetdiff(on_weekends, on_25th)
alma_events(rsd1)

# On the 25th of the month AND NOT the weekend
rsd2 &lt;- rsetdiff(on_25th, on_weekends)
alma_events(rsd2)
</code></pre>

<hr>
<h2 id='rset-add'>Deprecated rset helpers</h2><span id='topic+rset-add'></span><span id='topic+add_rschedule'></span><span id='topic+add_rdates'></span><span id='topic+add_exdates'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>

<ul>
<li> <p><code>add_rschedule()</code> is deprecated in favor of using the <code>...</code> arguments of
<code><a href="#topic+runion">runion()</a></code>, <code><a href="#topic+rintersect">rintersect()</a></code>, and <code><a href="#topic+rsetdiff">rsetdiff()</a></code> directly.
</p>
</li>
<li> <p><code>add_rdates()</code> is deprecated in favor of using <code><a href="#topic+runion">runion()</a></code> in combination
with a custom <code><a href="#topic+rcustom">rcustom()</a></code> rschedule holding the required dates.
</p>
</li>
<li> <p><code>add_exdates()</code> is deprecated in favor of using <code><a href="#topic+rsetdiff">rsetdiff()</a></code> in combination
with a custom <code><a href="#topic+rcustom">rcustom()</a></code> rschedule holding the excluded dates.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>add_rschedule(x, rschedule)

add_rdates(x, rdates)

add_exdates(x, exdates)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rset-add_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rset]&#8288;</code>
</p>
<p>An rset to add to.</p>
</td></tr>
<tr><td><code id="rset-add_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule, such as an rrule, runion, rintersect, or rsetdiff.</p>
</td></tr>
<tr><td><code id="rset-add_+3A_rdates">rdates</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date]&#8288;</code>
</p>
<p>Dates to forcibly include in the rset.</p>
</td></tr>
<tr><td><code id="rset-add_+3A_exdates">exdates</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date]&#8288;</code>
</p>
<p>Dates to forcibly exclude from the rset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated rset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>on_thanksgiving &lt;- yearly() %&gt;%
  recur_on_day_of_week("Thurs", nth = 4) %&gt;%
  recur_on_month_of_year("Nov")

on_christmas &lt;- yearly() %&gt;%
  recur_on_day_of_month(25) %&gt;%
  recur_on_month_of_year("Dec")

on_labor_day &lt;- monthly() %&gt;%
  recur_on_month_of_year("Sep") %&gt;%
  recur_on_day_of_week("Mon", nth = 1)

# Rather than:
if (FALSE) {
rb &lt;- runion() %&gt;%
  add_rschedule(on_thanksgiving) %&gt;%
  add_rschedule(on_christmas) %&gt;%
  add_rschedule(on_labor_day)
}

# Use the `...` of the `runion()` helper directly:
rb &lt;- runion(on_thanksgiving, on_christmas, on_labor_day)

# Thanksgiving, Christmas, or Labor Day
alma_search("2019-01-01", "2021-01-01", rb)

# Except Labor Day in 2019
# Rather than:
if (FALSE) {
rb2 &lt;- add_exdates(rb, "2019-09-02")
}

# We recommend:
rb2 &lt;- rsetdiff(rb, rcustom("2019-09-02"))

alma_search("2019-01-01", "2021-01-01", rb2)
</code></pre>

<hr>
<h2 id='stepper'>Create a new stepper</h2><span id='topic+stepper'></span><span id='topic++25s+2B+25'></span><span id='topic++25s-+25'></span><span id='topic+workdays'></span>

<h3>Description</h3>


<ul>
<li> <p><code>stepper()</code> returns a function that can be used to add or subtract a
number of days from a Date, &quot;stepping&quot; over events specified by an
rschedule. You supply it the rschedule to step relative to, and then
call the returned function with the number of days to step by.
</p>
</li>
<li> <p><code>workdays()</code> is a convenient stepper for stepping over the weekend.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;%s+%&#8288;</code> steps forwards.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;%s-%&#8288;</code> steps backwards.
</p>
</li></ul>

<p>You <em>must</em> use <code style="white-space: pre;">&#8288;%s+&#8288;</code> and <code style="white-space: pre;">&#8288;%s-%&#8288;</code> to control the stepping. <code>+</code> and <code>-</code> will
not work due to limitations in R's S3 dispatch system. Alternatively, you
can call <code><a href="vctrs.html#topic+vec_arith">vctrs::vec_arith()</a></code> directly, which powers <code style="white-space: pre;">&#8288;%s+%&#8288;</code> with a correct
double dispatch implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepper(rschedule)

x %s+% y

x %s-% y

workdays(n, since = NULL, until = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepper_+3A_rschedule">rschedule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[rschedule]&#8288;</code>
</p>
<p>An rschedule, such as an rrule, runion, rintersect, or rsetdiff.</p>
</td></tr>
<tr><td><code id="stepper_+3A_x">x</code>, <code id="stepper_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[objects]&#8288;</code>
</p>
<p>Objects to perform step arithmetic on. Typically Dates or steppers.</p>
</td></tr>
<tr><td><code id="stepper_+3A_n">n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>The number of days to step. Can be negative to step backwards.</p>
</td></tr>
<tr><td><code id="stepper_+3A_since">since</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1)]&#8288;</code>
</p>
<p>The lower bound on the event set. Depending on the final
recurrence rule, pieces of information from this anchor date might be used
to generate a complete recurrence rule.</p>
</td></tr>
<tr><td><code id="stepper_+3A_until">until</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Date(1)]&#8288;</code>
</p>
<p>The upper bound on the event set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, a stepper is just powered by <code><a href="#topic+alma_step">alma_step()</a></code>, so feel free to
use that directly.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>stepper()</code> returns a function of 1 argument, <code>n</code>, that can be used to
step by <code>n</code> days, relative to the rschedule.
</p>
</li>
<li> <p><code>workdays()</code> return a new stepper object.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;%s+%&#8288;</code> and <code style="white-space: pre;">&#8288;%s-%&#8288;</code> return a new shifted Date vector.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># A Thursday and Friday
x &lt;- as.Date(c("1970-01-01", "1970-01-02"))

# Thursday is stepped forward 1 working day to Friday,
# and then 1 more working day to Monday.
# Friday is stepped forward 1 working day to Monday,
# and then 1 more working day to Tuesday
x %s+% workdays(2)

# ---------------------------------------------------------------------------

on_weekends &lt;- weekly() %&gt;%
  recur_on_weekends()

on_christmas &lt;- yearly() %&gt;%
  recur_on_day_of_month(25) %&gt;%
  recur_on_month_of_year("Dec")

rb &lt;- runion(on_weekends, on_christmas)

workday &lt;- stepper(rb)

# Friday before Christmas, which was on a Monday
friday_before_christmas &lt;- as.Date("2000-12-22")

# Steps over the weekend and Christmas to the following Tuesday
friday_before_christmas %s+% workday(1)

# ---------------------------------------------------------------------------

# Christmas in 2005 was on a Sunday, but your company probably "observed"
# it on Monday. So when you are on the Friday before Christmas in 2005,
# stepping forward 1 working day should go to Tuesday.

# We'll adjust the previous rule for Christmas to roll to the nearest
# non-weekend day, if it happened to fall on a weekend.
on_observed_christmas &lt;- radjusted(
  on_christmas,
  adjust_on = on_weekends,
  adjustment = adj_nearest
)

# Note that the "observed" date for Christmas is the 26th
alma_search("2005-01-01", "2006-01-01", on_observed_christmas)

rb2 &lt;- runion(on_weekends, on_observed_christmas)

workday2 &lt;- stepper(rb2)

friday_before_christmas_2005 &lt;- as.Date("2005-12-23")

# Steps over the weekend and the observed Christmas date
# of 2005-12-26 to Tuesday the 27th.
friday_before_christmas_2005 %s+% workday2(1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
