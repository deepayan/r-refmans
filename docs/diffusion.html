<!DOCTYPE html><html><head><title>Help for package diffusion</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {diffusion}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#difcurve'><p>Calculates the values for various diffusion curves, given some parameters.</p></a></li>
<li><a href='#diffusion'><p>Fit various diffusion curves.</p></a></li>
<li><a href='#is.diffusion'><p>Diffusion class checkers</p></a></li>
<li><a href='#Nortonbass'><p>Norton-Bass model</p></a></li>
<li><a href='#Nortonbass_error'><p>Fits Norton Bass curve and estimated RMSE</p></a></li>
<li><a href='#Nortonbass_startvalgen'><p>Fits Norton Bass curve and estimated RMSE</p></a></li>
<li><a href='#plot.diffusion'><p>Plot a fitted diffusion curve.</p></a></li>
<li><a href='#plot.seqdiffusion'><p>Plot sequentially fitted diffusion curves.</p></a></li>
<li><a href='#predict.diffusion'><p>Predict future periods of a fitted diffusion curve.</p></a></li>
<li><a href='#print.diffusion'><p>Print a fitted diffusion curve.</p></a></li>
<li><a href='#print.seqdiffusion'><p>Print sequentially fitted diffusion curves.</p></a></li>
<li><a href='#seqdiffusion'><p>Enables fitting various sequential diffusion curves.</p></a></li>
<li><a href='#tsAc'><p>Time series: Assassins Creeds</p></a></li>
<li><a href='#tsCarstock'><p>Time series: Stock of cars</p></a></li>
<li><a href='#tsChicken'><p>Time series: Chicken weight</p></a></li>
<li><a href='#tsCovid'><p>Time series: COVID-19 confirmed cases US</p></a></li>
<li><a href='#tsIbm'><p>Time series: Sales of IBM Computers</p></a></li>
<li><a href='#tsMetal'><p>Time series: U.S. Merchant Marine conversion to metal</p></a></li>
<li><a href='#tsSafari'><p>Time series: Safari Browser market share</p></a></li>
<li><a href='#tsWindows'><p>Time series: Windows OS Platform Statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecast the Diffusion of New Products</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mamut86/diffusion">https://github.com/mamut86/diffusion</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mamut86/diffusion/issues">https://github.com/mamut86/diffusion/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Various diffusion models to forecast new product growth. Currently
    the package contains Bass, Gompertz, Gamma/Shifted Gompertz and Weibull curves. See
    Meade and Islam (2006) &lt;<a href="https://doi.org/10.1016%2Fj.ijforecast.2006.01.005">doi:10.1016/j.ijforecast.2006.01.005</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>nloptr, systemfit, optimx</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-16 16:58:53 UTC; SchaerO</td>
</tr>
<tr>
<td>Author:</td>
<td>Oliver Schaer [aut, cre] (Assistant Professor, LeBow College of
    Business, Drexel University, USA),
  Nikolaos Kourentzes [aut] (Professor of Predictive Analytics, School of
    Informatics, Skoevde University, Sweden),
  Ivan Svetunkov [aut] (Lecturer at Centre for Marketing Analytics and
    Forecasting, Lancaster University, UK)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Oliver Schaer &lt;info@oliverschaer.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-16 20:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='difcurve'>Calculates the values for various diffusion curves, given some parameters.</h2><span id='topic+difcurve'></span>

<h3>Description</h3>

<p>This function calculates the values of diffusion curves that can be of <code>"bass"</code>, 
<code>"gompertz"</code>, <code>"gsgompertz"</code> or <code>"weibull"</code> type, given some parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difcurve(
  n,
  w = c(0.01, 0.1, 10),
  type = c("bass", "gompertz", "gsgompertz", "weibull"),
  curve = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difcurve_+3A_n">n</code></td>
<td>
<p>number of periods to calculate values for.</p>
</td></tr>
<tr><td><code id="difcurve_+3A_w">w</code></td>
<td>
<p>vector of curve parameters (see note). If argument curve is used, this is ignored.</p>
</td></tr>
<tr><td><code id="difcurve_+3A_type">type</code></td>
<td>
<p>diffusion curve to use. This can be &quot;bass&quot;, &quot;gompertz&quot; and &quot;gsgompertz&quot;. If argument curve is used, this is ignored.</p>
</td></tr>
<tr><td><code id="difcurve_+3A_curve">curve</code></td>
<td>
<p>if provided <code>w</code> and <code>type</code> are taken from an object of class <code>diffusion</code>, the output of <code><a href="#topic+diffusion">diffusion</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of values with each row being a period.
</p>


<h3>Note</h3>

<p><code>w</code> needs to be provided for the Bass curve in the order of
<code>("m", "p", "q")</code>, where &quot;p&quot; is the coefficient of innovation, &quot;q&quot; is the
coefficient of imitation and &quot;m&quot; is the market size coefficient.
</p>
<p>For the Gompertz curve, vector <code>w</code> needs to be in the form of
<code>("m", "a", "b")</code>. Where &quot;a&quot; is the x-axis displacement coefficient, &quot;b&quot;
determines the growth rate and &quot;m&quot; sets, similarly to Bass model, the
market potential (saturation point).
</p>
<p>For the Shifted-Gompertz curve, vector <code>w</code> needs to be in the form of 
<code>("m", "a", "b", "c")</code>. Where &quot;a&quot; is the x-axis displacement
coefficient, &quot;b&quot; determines the growth rate, &quot;c&quot; is the shifting parameter
and &quot;m&quot; sets, similarly to Bass model, the market potential (saturation
point).
</p>
<p>For the Weibull curve, vector <code>w</code> needs to be in the form of
<code>("m", "a", "b")</code>. Where &quot;a&quot; is the scale parameter, &quot;b&quot; determines the
shape. Together, &quot;a&quot; and &quot;b&quot; determine the stepness of the curve. The &quot;m&quot;
parameter sets the market potential (saturation point).
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>,
</p>
<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffusion">diffusion</a></code> for fitting a diffusion curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  difcurve(w=c(0.01,0.1,10),20)
  
</code></pre>

<hr>
<h2 id='diffusion'>Fit various diffusion curves.</h2><span id='topic+diffusion'></span>

<h3>Description</h3>

<p>This function fits diffusion curves that can be of <code>"bass"</code>, 
<code>"gompertz"</code>, <code>"gsgompertz"</code> (Gamma/Shifted Gompertz curve) or <code>"Weibull"</code> type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffusion(
  y,
  w = NULL,
  cleanlead = c(TRUE, FALSE),
  loss = 2,
  cumulative = c(TRUE, FALSE),
  verbose = c(FALSE, TRUE),
  type = c("bass", "gompertz", "gsgompertz", "weibull"),
  method = c("L-BFGS-B", "Nelder-Mead", "BFGS", "hjkb", "Rcgmin", "bobyqa"),
  maxiter = 500,
  opttol = 1e-06,
  multisol = c(FALSE, TRUE),
  initpar = c("linearize", "preset"),
  mscal = c(TRUE, FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffusion_+3A_y">y</code></td>
<td>
<p>vector with adoption per period</p>
</td></tr>
<tr><td><code id="diffusion_+3A_w">w</code></td>
<td>
<p>vector of curve parameters (see note). Parameters set to NA will be
optimized. If <code>w = NULL</code> (default) all paramters are optimized.</p>
</td></tr>
<tr><td><code id="diffusion_+3A_cleanlead">cleanlead</code></td>
<td>
<p>removes leading zeros for fitting purposes (default == TRUE)</p>
</td></tr>
<tr><td><code id="diffusion_+3A_loss">loss</code></td>
<td>
<p>the l-norm (1 is absolute errors, 2 is squared errors).</p>
</td></tr>
<tr><td><code id="diffusion_+3A_cumulative">cumulative</code></td>
<td>
<p>If TRUE optimisation is done on cumulative adoption.</p>
</td></tr>
<tr><td><code id="diffusion_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE console output is provided during estimation (default == FALSE)</p>
</td></tr>
<tr><td><code id="diffusion_+3A_type">type</code></td>
<td>
<p>diffusion curve to use. This can be &quot;bass&quot;, &quot;gompertz&quot; and &quot;gsgompertz&quot;</p>
</td></tr>
<tr><td><code id="diffusion_+3A_method">method</code></td>
<td>
<p>optimization method to use. These can be <code>"Nelder-Meade"</code>,
<code>"L-BFGS-B"</code>, <code>"BFGS"</code>, <code>"hjkb"</code>, <code>"Rcgmin"</code>,
<code>"bobyqa"</code>. Typically, good performance is achieved with
<code>"Nelder-Meade"</code> and <code>"L-BFGS-B"</code>. <code>"hjkb"</code> and
<code>"Rcgmin"</code> might be an alternative for complex shapes but have
substantially higher computational costs. For further details on
optimization algorithms we refer to the optimx package documentation</p>
</td></tr>
<tr><td><code id="diffusion_+3A_maxiter">maxiter</code></td>
<td>
<p>number of iterations the optimiser takes (default == <code>5000</code>)</p>
</td></tr>
<tr><td><code id="diffusion_+3A_opttol">opttol</code></td>
<td>
<p>Tolerance for convergence (default == 1.e-06)</p>
</td></tr>
<tr><td><code id="diffusion_+3A_multisol">multisol</code></td>
<td>
<p>when <code>"TRUE"</code> multiple optmisation solutions from
different initialisations of the market parameter are used (default ==
<code>"FALSE"</code>)</p>
</td></tr>
<tr><td><code id="diffusion_+3A_initpar">initpar</code></td>
<td>
<p>vector of initalisation parameters. If set to <code>preset</code> a
predfined set of internal initalisation parameters is used while
<code>"linearize"</code> uses linearized initalisation methods (default == <code>"linearize"</code>.</p>
</td></tr>
<tr><td><code id="diffusion_+3A_mscal">mscal</code></td>
<td>
<p>scales market potential at initalisation with the maximum of the
observed market potential for better optimization results (default == <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="diffusion_+3A_...">...</code></td>
<td>
<p>accepts <code>pvalreps</code>, bootstrap repetitions to estimate
(marginal) p-values; <code>eliminate</code>, if TRUE eliminates insignificant
parameters from the estimation (forces <code>pvalreps = 1000</code> if left to 0)
<code>sig</code>, significance level used to eliminate parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>diffusion</code>, which contains:
</p>

<ul>
<li> <p><code>type</code> diffusion curve type used
</p>
</li>
<li> <p><code>call</code> calls function fitted
</p>
</li>
<li> <p><code>w</code> named vector of fitted parameters
</p>
</li>
<li> <p><code>y</code> actuals
</p>
</li>
<li> <p><code>fit</code> fitted values of model
</p>
</li>
<li> <p><code>frc</code> forecasts for future periods. This is <code>NULL</code> until <code><a href="#topic+predict.diffusion">predict.diffusion</a></code> is called.
</p>
</li>
<li> <p><code>mse</code> insample Mean Squared Error
</p>
</li>
<li> <p><code>prew</code> the <code>w</code> of the previous generation
</p>
</li>
<li> <p><code>pval</code> p-values for <code>w</code>
</p>
</li>
<li> <p><code>init</code> the initial values that have been used for the optimizer
</p>
</li></ul>



<h3>Bass curve</h3>

<p>The optimization of the Bass curve is initialized by the linear
approximation suggested in Bass (1969).
</p>


<h3>Gompertz curve</h3>

<p>The initialization of the Gompertz curve uses the
approach suggested by Jukic et al. (2004), but is adapted to allow for the
non-exponential version of the Gompertz curve. This makes the market potential
parameter equivalent to the Bass curves and the market potential from
Bass curve is used for initialization.
</p>


<h3>Gamma/Shifted Gompertz</h3>

<p>The curve is initialized by assuming the shift operator to be 1 and 
becomes equivalent to the Bass curve, as shown in Bemmaor (1994). A Bass
curve is therefore used as an estimator for the remaining initial parameters.
</p>


<h3>Weibull</h3>

<p>The initialization is obtained through by a linear approximation
median-ranked OLS described in Sharif and Islam 1980.
</p>


<h3>Note</h3>

<p>vector <code>w</code> needs to be provided for the Bass curve in the order of
<code>"m", "p", "q"</code>, where &quot;p&quot; is the coefficient of innovation, &quot;q&quot; is the
coefficient of imitation and &quot;m&quot; is the market size coefficient.
</p>
<p>For the Gompertz curve, vector <code>w</code> needs to be in the form of
<code>("m", "a", "b")</code>. Where &quot;a&quot; is the x-axis displacement coefficient, &quot;b&quot;
determines the growth rate and &quot;m&quot; sets, similarly to the Bass curve, the
market potential (saturation point).
</p>
<p>For the Shifted-Gompertz curve, vector <code>w</code> needs to be in the form of 
<code>("m", "a", "b", "c")</code>. Where &quot;a&quot; is the x-axis displacement
coefficient, &quot;b&quot; determines the growth rate, &quot;c&quot; is the shifting parameter
and &quot;m&quot; sets, similarly to the Bass curve, the market potential (saturation
point).
</p>
<p>For the Weibull curve, vector <code>w</code> needs to be in the form of
<code>("m", "a", "b")</code>. Where &quot;a&quot; is the scale parameter, &quot;b&quot; determines the
shape. Together, &quot;a&quot; and &quot;b&quot; determine the steepness of the curve. The &quot;m&quot;
parameter sets the market potential (saturation point).
</p>
<p>Parameters are estimated by 
minimising the Mean Squared Error with a subplex algorithm from the optimx package. 
Optionally p-values of the coefficients can be determined via
bootstraping. Furthermore, the bootstrapping allows removing insignificant
parameters from the optimization process.
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>,
</p>
<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>
</p>


<h3>References</h3>


<ul>
<li><p>For an introduction to diffusion curves see Ord K., Fildes R., Kourentzes N. (2017) <a href="https://wessexlearning.com/products/principles-of-business-forecasting-2nd-ed">Principles of Business Forecasting 2e</a>. <em>Wessex Press Publishing Co.</em>, Chapter 12.
</p>
</li>
<li><p>Bass, F.M., 1969. A new product growth for model consumer durables. Management Science 15(5), 215-227.
</p>
</li>
<li><p>Bemmaor, A. 1994. Modeling the Diffusion of New Durable Goods: Word-of-Mouth Effect versus Consumer Heterogeneity. In G. Laurent, G.L. Lilien and B. Pras (Eds.). Research Traditions in Marketing. Boston: Kluwer, pp. 201-223.
</p>
</li>
<li><p>Jukic, D., Kralik, G. and Scitovski, R., 2004. Least-squares fitting Gompertz curve. Journal of Computational and Applied Mathematics, 169, 359-375.
</p>
</li>
<li><p>Sharif, N.M. and Islam, M.N. 1980. The Weibull Distribution as a General Model for Forecasting Technological Change. Technological Forecasting and Social Change, 18, 247-256.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+predict.diffusion">predict.diffusion</a></code>, <code><a href="#topic+plot.diffusion">plot.diffusion</a></code> and <code><a href="#topic+print.diffusion">print.diffusion</a></code>.
</p>
<p><code><a href="#topic+seqdiffusion">seqdiffusion</a></code> for sequential diffusion model fitting
across product generations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fitbass &lt;- diffusion(diff(tsChicken[, 2]), type = "bass")
 fitgomp &lt;- diffusion(diff(tsChicken[, 2]), type = "gompertz")
 fitgsg &lt;- diffusion(diff(tsChicken[, 2]), type = "gsgompertz")
 fitgwb &lt;- diffusion(diff(tsChicken[, 2]), type = "weibull")
 
 # Produce some plots
 plot(fitbass)
 plot(fitgomp)
 plot(fitgsg)
 plot(fitgwb)

</code></pre>

<hr>
<h2 id='is.diffusion'>Diffusion class checkers</h2><span id='topic+is.diffusion'></span><span id='topic+is.bass'></span>

<h3>Description</h3>

<p>Functions to check if an object is of the specified class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.diffusion(x)

is.bass(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.diffusion_+3A_x">x</code></td>
<td>
<p>The object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of functions includes:
</p>

<ul>
<li> <p><code>is.diffusion()</code> tests if the object was produced by a diffusion() function.
</p>
</li>
<li> <p><code>is.bass()</code> checks if the forecast was produced by the bass() function.
</p>
</li></ul>



<h3>Value</h3>

<p><code>TRUE</code> if this is the specified class and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>,
</p>
<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>
</p>

<hr>
<h2 id='Nortonbass'>Norton-Bass model</h2><span id='topic+Nortonbass'></span>

<h3>Description</h3>

<p><code>Nortonbass</code> fits a generational Bass model proposed by Norton and Bass 
(1987). Each subsequent generation influences the sales of the previous 
generation. The set of equation is estimated simulataneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nortonbass(
  x,
  startval.met = c("2ST", "BB", "iBM"),
  estim.met = c("BOBYQA", "OLS", "SUR", "2SLS", "3SLS"),
  gstart = NULL,
  startval = NULL,
  flexpq = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nortonbass_+3A_x">x</code></td>
<td>
<p>matrix or dataframe containing demand for each generation in 
non-cumulative form.</p>
</td></tr>
<tr><td><code id="Nortonbass_+3A_startval.met">startval.met</code></td>
<td>
<p>Different methods of obtaining starting values. 
</p>
 <dl>
<dt><code>"2ST"</code></dt><dd><p>Two stage approach taking <code>"BB"</code> method
first and then re-estimate if <code>flexpq == T</code> (default)</p>
</dd> 
<dt><code>"BB"</code></dt><dd><p>Bass and Bass (2004) method which sets
<code class="reqn">p_{1,\dots,j} = 0.003, q_{1,\dots,j} = 0.05</code>
and <code class="reqn">m_j</code> is the maximum observed value for generation <code class="reqn">j</code></p>
</dd> 
<dt><code>"iBM"</code></dt><dd><p>Fits individual Bass models and uses this as
estimators. In case <code>flexpq == F</code> the median of p and q is used </p>
</dd></dl>
</td></tr>
<tr><td><code id="Nortonbass_+3A_estim.met">estim.met</code></td>
<td>
<p>Estimation method, <code>"BOBYQA"</code> see
<code><a href="systemfit.html#topic+nlsystemfit">nlsystemfit</a></code> (<code>BOBYQA</code> default)</p>
</td></tr>
<tr><td><code id="Nortonbass_+3A_gstart">gstart</code></td>
<td>
<p>optional vector with starting points of generations#'</p>
</td></tr>
<tr><td><code id="Nortonbass_+3A_startval">startval</code></td>
<td>
<p>an optional Vector with starting for manual estimation</p>
</td></tr>
<tr><td><code id="Nortonbass_+3A_flexpq">flexpq</code></td>
<td>
<p>If <code>TRUE</code>, generations will have independent p and q 
values as suggested by Islam and Maed (1997). Note that model might
not converge.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For starting values the Vector values need to be named in the case 
<code>flexpq == T</code> 
<code class="reqn">p_1,\dots,p_j,q_1,\dots,q_j,m_1,\dots,m_j</code>.
In the case of <code>flexpq == F</code> <code class="reqn">p_1, q_1, m_1,\dots, m_j</code>.
</p>
<p>If <code>gstart</code> is not provided, the generation starting points will be 
detected automatically selecting the first value that is non-zero.
</p>


<h3>Value</h3>

<p><code>coef</code>: coefficients for p, q and m
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>
</p>


<h3>References</h3>

<p>Norton, J.A. and Bass, F.M., 1987. A Diffusion Theory Model of 
Adoption and Substitution for Successive Generations of High-Technology 
Products.
</p>
<p>Islam, T. and Meade, N., 1997. The Diffusion of Successive 
Generations of a Technology: A More General Model. Technological 
Forecasting and Social Change, 56, 49-60.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
   fitNB1 &lt;- Nortonbass(tsIbm, startval.met = "2ST", estim.met = "OLS",
                        startval = NULL, flexpq = F, gstart = NULL)
   fitNB2 &lt;- Nortonbass(tsIbm, startval.met = "2ST", estim.met = "SUR",
                        startval = NULL, flexpq = F, gstart = NULL)
   # using BOBYQA algorithm
   fitNB3 &lt;- Nortonbass(tsIbm, startval.met = "2ST", estim.met = "BOBYQA",
                        startval = NULL, flexpq = F, gstart = NULL)
   # Create some plots
   plot(tsibm[, 1],type = "l", ylim=c(0,35000))
   lines(tsibm[, 2],col ="blue")
   lines(tsibm[, 3],col ="green")
   lines(tsibm[, 4],col ="pink")
   lines(fitNB1$fit$fitted[[1]], col = "black", lty = 2)
   lines(fitNB1$fit$fitted[[2]], col = "blue", lty = 2)
   lines(fitNB1$fit$fitted[[3]], col = "green", lty = 2)
   lines(fitNB1$fit$fitted[[4]], col = "pink", lty = 2)
   lines(fitNB2$fit$fitted[[1]], col = "black", lty = 3)
   lines(fitNB2$fit$fitted[[2]], col = "blue", lty = 3)
   lines(fitNB2$fit$fitted[[3]], col = "green", lty = 3)
   lines(fitNB2$fit$fitted[[4]], col = "pink", lty = 3)
   lines(fitNB3$fit$fitted[[1]], col = "black", lty = 4)
   lines(fitNB3$fit$fitted[[2]], col = "blue", lty = 4)
   lines(fitNB3$fit$fitted[[3]], col = "green", lty = 4)
   lines(fitNB3$fit$fitted[[4]], col = "pink", lty = 4)
   # read out RMSE
   fitNB1$fit$RMSE[[1]]
   fitNB1$fit$RMSE[[2]]
   fitNB1$fit$RMSE[[3]]
   fitNB1$fit$RMSE[[4]]
   fitNB2$fit$RMSE[[1]]
   fitNB2$fit$RMSE[[2]]
   fitNB2$fit$RMSE[[3]]
   fitNB2$fit$RMSE[[4]]
   fitNB3$fit$RMSE[[1]]
   fitNB3$fit$RMSE[[2]]
   fitNB3$fit$RMSE[[3]]
   fitNB3$fit$RMSE[[4]]
 
## End(Not run)
 
  
</code></pre>

<hr>
<h2 id='Nortonbass_error'>Fits Norton Bass curve and estimated RMSE</h2><span id='topic+Nortonbass_error'></span>

<h3>Description</h3>

<p>Fits Norton Bass curve and estimated RMSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nortonbass_error(x, param, gstart = NULL, flexpq = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nortonbass_error_+3A_x">x</code></td>
<td>
<p>matrix with generations</p>
</td></tr>
<tr><td><code id="Nortonbass_error_+3A_param">param</code></td>
<td>
<p>the parameters for curve to estimated</p>
</td></tr>
<tr><td><code id="Nortonbass_error_+3A_gstart">gstart</code></td>
<td>
<p>optional vector of starting points for the generations</p>
</td></tr>
<tr><td><code id="Nortonbass_error_+3A_flexpq">flexpq</code></td>
<td>
<p>flexible p and q</p>
</td></tr>
</table>


<h3>Value</h3>

<p>yhat, the predicted values
</p>
<p>actuals, the actual values
</p>
<p>RMSE, the root mean squared error for each generation
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>
</p>

<hr>
<h2 id='Nortonbass_startvalgen'>Fits Norton Bass curve and estimated RMSE</h2><span id='topic+Nortonbass_startvalgen'></span>

<h3>Description</h3>

<p>Fits Norton Bass curve and estimated RMSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nortonbass_startvalgen(x, gstart, flexpq, startval.met)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nortonbass_startvalgen_+3A_x">x</code></td>
<td>
<p>matrix with generations</p>
</td></tr>
<tr><td><code id="Nortonbass_startvalgen_+3A_gstart">gstart</code></td>
<td>
<p>optional vector of starting points for the generations</p>
</td></tr>
<tr><td><code id="Nortonbass_startvalgen_+3A_flexpq">flexpq</code></td>
<td>
<p>For <code>startvalgen="BB"</code>. Allows parameters p and q to be flexible if set <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Nortonbass_startvalgen_+3A_startval.met">startval.met</code></td>
<td>
<p><code>"iBM"</code> fits individual Bass model to each generation;
<code>"BB"</code> uses the approach described in Bass and Bass (2004).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>starting values for all parameters
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>
</p>

<hr>
<h2 id='plot.diffusion'>Plot a fitted diffusion curve.</h2><span id='topic+plot.diffusion'></span>

<h3>Description</h3>

<p>Produces a plot of a fitted diffusion curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffusion'
plot(x, cumulative = c(FALSE, TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.diffusion_+3A_x">x</code></td>
<td>
<p><code>diffusion</code> object, produced using <code><a href="#topic+diffusion">diffusion</a></code>.</p>
</td></tr>
<tr><td><code id="plot.diffusion_+3A_cumulative">cumulative</code></td>
<td>
<p>If TRUE plot cumulative adoption.</p>
</td></tr>
<tr><td><code id="plot.diffusion_+3A_...">...</code></td>
<td>
<p>Unused argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Function produces a plot.
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>,
</p>
<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffusion">diffusion</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- diffusion(tsChicken[, 2])
 plot(fit)

</code></pre>

<hr>
<h2 id='plot.seqdiffusion'>Plot sequentially fitted diffusion curves.</h2><span id='topic+plot.seqdiffusion'></span>

<h3>Description</h3>

<p>Produces a plot of sequentially fitted diffusion curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqdiffusion'
plot(x, cumulative = c(FALSE, TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.seqdiffusion_+3A_x">x</code></td>
<td>
<p><code>seqdiffusion</code> object, produced using <code><a href="#topic+seqdiffusion">seqdiffusion</a></code>.</p>
</td></tr>
<tr><td><code id="plot.seqdiffusion_+3A_cumulative">cumulative</code></td>
<td>
<p>If TRUE plot cumulative adoption.</p>
</td></tr>
<tr><td><code id="plot.seqdiffusion_+3A_...">...</code></td>
<td>
<p>Unused argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Function produces a plot.
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>,
</p>
<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdiffusion">seqdiffusion</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- seqdiffusion(tsIbm)
 plot(fit)

</code></pre>

<hr>
<h2 id='predict.diffusion'>Predict future periods of a fitted diffusion curve.</h2><span id='topic+predict.diffusion'></span>

<h3>Description</h3>

<p>Calculates the values for h future periods of a fitted diffusion curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffusion'
predict(object, h = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.diffusion_+3A_object">object</code></td>
<td>
<p><code>diffusion</code> object, produced using <code><a href="#topic+diffusion">diffusion</a></code>.</p>
</td></tr>
<tr><td><code id="predict.diffusion_+3A_h">h</code></td>
<td>
<p>Forecast horizon.</p>
</td></tr>
<tr><td><code id="predict.diffusion_+3A_...">...</code></td>
<td>
<p>Unused argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>diffusion</code>, which contains:
</p>

<ul>
<li> <p><code>type</code> diffusion curve type used
</p>
</li>
<li> <p><code>call</code> calls function fitted
</p>
</li>
<li> <p><code>w</code> named vector of fitted parameters
</p>
</li>
<li> <p><code>y</code> actuals
</p>
</li>
<li> <p><code>fit</code> fitted values of model
</p>
</li>
<li> <p><code>frc</code> forecasts for future periods.
</p>
</li>
<li> <p><code>mse</code> insample Mean Squared Error
</p>
</li>
<li> <p><code>prew</code> the <code>w</code> of the previous generation
</p>
</li>
<li> <p><code>pval</code> p-values for <code>w</code>
</p>
</li></ul>



<h3>Note</h3>

<p>This function populates the matrix frc of the <code>diffusion</code> object used as input.
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>,
</p>
<p>Nikoloas Kourentzes, <a href="mailto:nikoloas@kourentzes.com">nikoloas@kourentzes.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffusion">diffusion</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- diffusion(tsChicken[, 2])
 fit &lt;- predict(fit, 20)
 plot(fit)

</code></pre>

<hr>
<h2 id='print.diffusion'>Print a fitted diffusion curve.</h2><span id='topic+print.diffusion'></span>

<h3>Description</h3>

<p>Outputs the result of a fitted diffusion curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffusion'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.diffusion_+3A_x">x</code></td>
<td>
<p><code>diffusion</code> object, produced using <code><a href="#topic+diffusion">diffusion</a></code>.</p>
</td></tr>
<tr><td><code id="print.diffusion_+3A_...">...</code></td>
<td>
<p>Unused argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Console output only.
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>,
</p>
<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffusion">diffusion</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- diffusion(tsChicken[, 2])
 print(fit)

</code></pre>

<hr>
<h2 id='print.seqdiffusion'>Print sequentially fitted diffusion curves.</h2><span id='topic+print.seqdiffusion'></span>

<h3>Description</h3>

<p>Outputs the result of sequentially fitted diffusion curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqdiffusion'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.seqdiffusion_+3A_x">x</code></td>
<td>
<p><code>seqdiffusion</code> object, produced using <code><a href="#topic+seqdiffusion">seqdiffusion</a></code>.</p>
</td></tr>
<tr><td><code id="print.seqdiffusion_+3A_...">...</code></td>
<td>
<p>Unused argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Console output only.
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>,
</p>
<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqdiffusion">seqdiffusion</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- seqdiffusion(tsIbm)
 print(fit)

</code></pre>

<hr>
<h2 id='seqdiffusion'>Enables fitting various sequential diffusion curves.</h2><span id='topic+seqdiffusion'></span>

<h3>Description</h3>

<p>This function fits diffusion curves of the type <code>"bass"</code>,
<code>"gompertz"</code>, <code>gsgompertz</code> or <code>weibull</code> across generations.
Parameters are estimated for each generation individually by minimizing the
Mean Squared Error with subplex algorithms from the optimx package.
Optionally p-values of the coefficients can be determined via bootstraping.
Furthermore, the bootstrapping allows removing insignificant parameters from
the optimisation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqdiffusion(
  y,
  w = NULL,
  cleanlead = c(TRUE, FALSE),
  loss = 2,
  cumulative = c(TRUE, FALSE),
  pvalreps = 0,
  eliminate = c(FALSE, TRUE),
  sig = 0.05,
  verbose = c(FALSE, TRUE),
  type = c("bass", "gompertz", "gsgompertz", "weibull"),
  method = c("L-BFGS-B", "Nelder-Mead", "BFGS", "hjkb", "Rcgmin", "bobyqa"),
  maxiter = 500,
  opttol = 1e-06,
  multisol = c(FALSE, TRUE),
  initpar = c("linearize", "preset"),
  mscal = c(TRUE, FALSE),
  bootloss = c("smthempir", "empir", "se"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqdiffusion_+3A_y">y</code></td>
<td>
<p>matrix containing in each column the adoption per period for generation k</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_w">w</code></td>
<td>
<p>matrix containing in each column the curve parameters for generation k (see note). Parameters set to NA will be
optimised. If <code>w = NULL</code> (default) all parameters are optimized.</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_cleanlead">cleanlead</code></td>
<td>
<p>removes leading zeros for fitting purposes (default == T)</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_loss">loss</code></td>
<td>
<p>the l-norm (1 is absolute errors, 2 is squared errors)</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_cumulative">cumulative</code></td>
<td>
<p>If TRUE optimization is done on cumulative adoption.</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_pvalreps">pvalreps</code></td>
<td>
<p>bootstrap repetitions to estimate (marginal) p-values</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_eliminate">eliminate</code></td>
<td>
<p>if TRUE eliminates insignificant parameters from the
estimation. Forces <code>pvalreps = 1000</code> if left to 0.</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_sig">sig</code></td>
<td>
<p>significance level used to eliminate parameters</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE console output is provided during estimation (default
== F)</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_type">type</code></td>
<td>
<p>of diffusion curve to use. This can be &quot;bass&quot;, &quot;gompertz&quot;,
&quot;gsgompertz&quot; and &quot;weibull&quot;</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_method">method</code></td>
<td>
<p>optimization method to use. This can be &quot;nm&quot; for Nelder-Meade or
&quot;hj&quot; for Hooke-Jeeves. #' @param maxiter number of iterations the optimiser
takes (default == <code>10000</code> for &quot;nm&quot; and <code>Inf</code> for &quot;hj&quot;)</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_opttol">opttol</code></td>
<td>
<p>Tolerance for convergence (default == 1.e-06)</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_multisol">multisol</code></td>
<td>
<p>when <code>"TRUE"</code> multiple optmisation solutions from different initialisations of the market parameter are used (default == <code>"FALSE"</code>)</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_initpar">initpar</code></td>
<td>
<p>vector of initalisation parameters. If set to <code>preset</code> a predfined set of internal initalisation parameters is used while <code>"linearize"</code> uses linearised initalisation methods (default == <code>"linearize"</code>.</p>
</td></tr>
<tr><td><code id="seqdiffusion_+3A_mscal">mscal</code></td>
<td>
<p>scales market potential at initalisation with the maximum of the observed market potential for better optimization results (default == <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>seqdiffusion</code>, which contains:
</p>

<ul>
<li> <p><code>type</code> diffusion model type used
</p>
</li>
<li> <p><code>diffusion</code> returns model specification for each generation (see
<code><a href="#topic+diffusion">diffusion</a></code> for details)
</p>
</li>
<li> <p><code>call</code> calls function fitted
</p>
</li>
<li> <p><code>w</code> named matrix of fitted parameters for each generation
</p>
</li>
<li> <p><code>y</code> matrix of actuals
</p>
</li>
<li> <p><code>mse</code> insample Mean Squared Error for each generation
</p>
</li>
<li> <p><code>pval</code> all p-values for <code>w</code> at each generation
</p>
</li></ul>



<h3>Bass curve</h3>

<p>The optimization of the Bass curve is initialized by the linear
approximation suggested in Bass (1969).
</p>


<h3>Gompertz curve</h3>

<p>The initialization of the Gompertz curve uses the
approach suggested by Jukic et al. (2004), but is adapted to allow for the
non-exponential version of the Gompertz curve. This makes the market potential
parameter equivalent to the Bass curves and the market potential from
Bass curve is used for initialization.
</p>


<h3>Gamma/Shifted Gompertz</h3>

<p>The curve is initialized by assuming the shift operator to be 1 and 
becomes equivalent to the Bass curve, as shown in Bemmaor (1994). A Bass
curve is therefore used as an estimator for the remaining initial parameters.
</p>


<h3>Weibull</h3>

<p>The initialization is obtained through by a linear approximation
median-ranked OLS described in Sharif and Islam 1980.
</p>


<h3>Author(s)</h3>

<p>Oliver Schaer, <a href="mailto:info@oliverschaer.ch">info@oliverschaer.ch</a>,
</p>
<p>Nikolaos Kourentzes, <a href="mailto:nikolaos@kourentzes.com">nikolaos@kourentzes.com</a>
</p>


<h3>References</h3>


<ul>
<li><p>For an introduction to diffusion curves see Ord K., Fildes R., Kourentzes N. (2017) <a href="https://wessexlearning.com/products/principles-of-business-forecasting-2nd-ed">Principles of Business Forecasting 2e</a>. <em>Wessex Press Publishing Co.</em>, Chapter 12.
</p>
</li>
<li><p>Bass, F.M., 1969. A new product growth for model consumer durables. Management Science 15(5), 215-227.
</p>
</li>
<li><p>Bemmaor, A. 1994. Modeling the Diffusion of New Durable Goods: Word-of-Mouth Effect versus Consumer Heterogeneity. In G. Laurent, G.L. Lilien and B. Pras (Eds.). Research Traditions in Marketing. Boston: Kluwer, pp. 201-223.
</p>
</li>
<li><p>Jukic, D., Kralik, G. and Scitovski, R., 2004. Least-squares fitting Gompertz curve. Journal of Computational and Applied Mathematics, 169, 359-375.
</p>
</li>
<li><p>Sharif, N.M. and Islam, M.N. 1980. The Weibull Distribution as a General Model for Forecasting Technological Change. Technological Forecasting and Social Change, 18, 247-256.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot.seqdiffusion">plot.seqdiffusion</a></code> and <code><a href="#topic+print.seqdiffusion">print.seqdiffusion</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- seqdiffusion(tsIbm)
  plot(fit)

</code></pre>

<hr>
<h2 id='tsAc'>Time series: Assassins Creeds</h2><span id='topic+tsAc'></span>

<h3>Description</h3>

<p>A dataset containing the weekly sales of Assassins Creeds game.
</p>


<h3>Format</h3>

<p>A matrix with 380 observations and 8 variables
</p>

<dl>
<dt>ac1</dt><dd><p>Assassins Creed 1</p>
</dd>
<dt>ac2</dt><dd><p>Assassins Creed 2</p>
</dd>
<dt>ac3</dt><dd><p>Assassins Creed 3</p>
</dd>
<dt>ac4</dt><dd><p>Assassins Creed 4</p>
</dd>
<dt>ac5</dt><dd><p>Assassins Creed 5</p>
</dd>
<dt>ac6</dt><dd><p>Assassins Creed 6</p>
</dd>
<dt>ac7</dt><dd><p>Assassins Creed 7</p>
</dd>
<dt>ac8</dt><dd><p>Assassins Creed 8</p>
</dd>
</dl>



<h3>References</h3>

<p>VGChartz
</p>

<hr>
<h2 id='tsCarstock'>Time series: Stock of cars</h2><span id='topic+tsCarstock'></span>

<h3>Description</h3>

<p>A dataset containing the yearly stock of cars in the Netherlands (1965-1989).
</p>


<h3>Format</h3>

<p>A data frame with 25 observations and 3 variables
</p>

<dl>
<dt>year</dt><dd><p>Year</p>
</dd>
<dt>raw</dt><dd><p>Raw stock numbers</p>
</dd>
<dt>smoothed</dt><dd><p>Smoothed stock numbers as described by Franses (1994)</p>
</dd>
</dl>



<h3>References</h3>

<p>Franses, P.H. 1994. Fitting a Gompertz curve. Journal of
Operational Research Society, 45, 109-113.
</p>

<hr>
<h2 id='tsChicken'>Time series: Chicken weight</h2><span id='topic+tsChicken'></span>

<h3>Description</h3>

<p>A dataset containing the average weekly female chicken weight.
</p>


<h3>Format</h3>

<p>A data frame with 13 observations and 2 variables
</p>

<dl>
<dt>time</dt><dd><p>Weeks since birth</p>
</dd>
<dt>weight</dt><dd><p>Weight of the female chicken in Kg</p>
</dd>
</dl>



<h3>References</h3>

<p>Jukic, D., Kralik, G. and Scitovski, R. 2004. Least-square
fitting Gompertz curve. Journal of Computational and Applied Mathematics,
169, 359-375.
</p>

<hr>
<h2 id='tsCovid'>Time series: COVID-19 confirmed cases US</h2><span id='topic+tsCovid'></span>

<h3>Description</h3>

<p>A dataset containing the number of confirmed COVID-19 cases in the US.
</p>


<h3>Format</h3>

<p>A ts object with 107 days of observations
</p>

<dl>
<dt>tsCovid</dt><dd><p>Daily confirmed COVDID-19 cases</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/CSSEGISandData/COVID-19">https://github.com/CSSEGISandData/COVID-19</a>
</p>


<h3>References</h3>

<p>COVID-19 Data Repository by the Center for Systems Science and Engineering (CSSE) at Johns Hopkins University
</p>

<hr>
<h2 id='tsIbm'>Time series: Sales of IBM Computers</h2><span id='topic+tsIbm'></span>

<h3>Description</h3>

<p>A dataset containing the first four generations of yearly IBM general-purpose
computers installations in the USA.
</p>


<h3>Format</h3>

<p>A data frame with 24 observations and 4 variables </p>

<dl>
<dt>SIU1</dt><dd><p>1st generation</p>
</dd>
<dt>SIU2</dt><dd><p>2nd generation (starts 6 years after first generation)</p>
</dd>
<dt>SIU3</dt><dd><p>3rd generation (starts 11 years after first generation)</p>
</dd>
<dt>SIU4</dt><dd><p>4th generation (starts 16 years after first generation)</p>
</dd></dl>



<h3>Source</h3>

<p><a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=8bbf197bc39a27ccf44cfd5ed22b5db3da0c7bb2">https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=8bbf197bc39a27ccf44cfd5ed22b5db3da0c7bb2</a>
</p>


<h3>References</h3>

<p>Bass, P.I. and Bass, F.M. 2004. IT Waves: Two Completed
Generational Diffusion Models. Working Paper Basseconomics, 1-33.
</p>

<hr>
<h2 id='tsMetal'>Time series: U.S. Merchant Marine conversion to metal</h2><span id='topic+tsMetal'></span>

<h3>Description</h3>

<p>A dataset with conversion of U.S. Merchant Marine from wood to metal.
</p>


<h3>Format</h3>

<p>A data frame with 17 observations and 2 variables
</p>

<dl>
<dt>year</dt><dd><p>Year</p>
</dd>
<dt>substitution</dt><dd><p>Conversion to metal</p>
</dd>
</dl>



<h3>References</h3>

<p>Martino, J.P. 1993. Technological Forecasting for Decision
Making. 3rd edition. New York: McGraw-Hill.
</p>

<hr>
<h2 id='tsSafari'>Time series: Safari Browser market share</h2><span id='topic+tsSafari'></span>

<h3>Description</h3>

<p>A dataset containing the monthly market share of Safari browser generations
from Safari 4.0 to Safari 10.
</p>


<h3>Format</h3>

<p>A data frame with 98 observations and 13 variables </p>
 
<dl>
<dt>Date</dt><dd><p>Log file date</p>
</dd>
<dt>Safari10.0</dt><dd><p>Usage of Windows 10</p>
</dd> 
<dt>Safari9.1</dt><dd><p>Market share of Safari browser v 10.0</p>
</dd>
<dt>Safari9.0</dt><dd><p>Market share of Safari browser v 9.1</p>
</dd> 
<dt>Safari8.0</dt><dd><p>Market share of Safari browser v 9.0</p>
</dd>
<dt>Safari7.1</dt><dd><p>Market share of Safari browser v 8.0</p>
</dd> 
<dt>Safari7.0</dt><dd><p>Market share of Safari browser v 7.1</p>
</dd>
<dt>Safari6.1</dt><dd><p>Market share of Safari browser v 6.1</p>
</dd> 
<dt>Safari6.0</dt><dd><p>Market share of Safari browser v 6.0</p>
</dd>
<dt>Safari5.1</dt><dd><p>Market share of Safari browser v 5.1</p>
</dd>
<dt>Safari5.0</dt><dd><p>Market share of Safari browser v 5.0</p>
</dd>
<dt>Safari4.1</dt><dd><p>Market share of Safari browser v 4.1</p>
</dd>
<dt>Safari4.0</dt><dd><p>Market share of Safari browser v 4.0</p>
</dd></dl>



<h3>Source</h3>

<p><a href="https://gs.statcounter.com/browser-version-market-share">https://gs.statcounter.com/browser-version-market-share</a>
</p>

<hr>
<h2 id='tsWindows'>Time series: Windows OS Platform Statistics</h2><span id='topic+tsWindows'></span>

<h3>Description</h3>

<p>A dataset containing the 3WSchools monthly log files of Windows operating 
system usage from March 2003 until February 2017.
</p>


<h3>Format</h3>

<p>A data frame with 168 observations and 9 variables </p>
 
<dl>
<dt>Date</dt><dd><p>Log file date</p>
</dd> <dt>Win10</dt><dd><p>Usage of Windows 10</p>
</dd> 
<dt>Win8</dt><dd><p>Usage of Windows 8</p>
</dd> <dt>Win7</dt><dd><p>Usage of Windows 7</p>
</dd> 
<dt>Vista</dt><dd><p>Usage of Windows Vista</p>
</dd> <dt>WinXP</dt><dd><p>Usage of Windows XP</p>
</dd> 
<dt>Win2000</dt><dd><p>Usage of Windows 2000</p>
</dd> <dt>Win98</dt><dd><p>Usage of Windows 98</p>
</dd> 
<dt>Win95</dt><dd><p>Usage of Windows 95</p>
</dd></dl>



<h3>Note</h3>

<p>From March 2003 until January 2008 log file is only available
bi-monthly. To retain monthly consistency, values have been linearly
interpolated
</p>


<h3>Source</h3>

<p><a href="https://www.w3schools.com/browsers/browsers_os.asp">https://www.w3schools.com/browsers/browsers_os.asp</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
