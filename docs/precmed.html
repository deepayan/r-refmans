<!DOCTYPE html><html><head><title>Help for package precmed</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {precmed}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abc'><p>Compute the area between curves from the <code>"precmed"</code> object</p></a></li>
<li><a href='#abc.precmed'><p>Compute the area between curves from the <code>"precmed"</code> object</p></a></li>
<li><a href='#arg.checks'><p>Check arguments</p>
Catered to all types of outcome
Apply at the beginning of <code>pmcount()</code>, <code>cvcount()</code>, <code>drcount.inference()</code>, <code>catefitsurv()</code>, <code>catecvsurv()</code>, and <code>drsurv.inference()</code></a></li>
<li><a href='#arg.checks.common'><p>Check arguments that are common to all types of outcome</p>
USed inside <code>arg.checks()</code></a></li>
<li><a href='#atefit'><p>Doubly robust estimator of and inference for the average treatment effect for count, survival and continuous data</p></a></li>
<li><a href='#atefitcount'><p>Doubly robust estimator of and inference for the average treatment effect</p>
for count data</a></li>
<li><a href='#atefitmean'><p>Doubly robust estimator of and inference for the average treatment effect for</p>
continuous data</a></li>
<li><a href='#atefitsurv'><p>Doubly robust estimator of and inference for the average treatment effect for survival data</p></a></li>
<li><a href='#balance.split'><p>Split the given dataset into balanced training and validation sets</p>
(within a pre-specified tolerance)
Balanced means 1) The ratio of treated and controls is maintained in the training and validation sets
2) The covariate distributions are balanced between the training and validation sets</a></li>
<li><a href='#balancemean.split'><p>Split the given dataset into balanced training and validation sets (within a pre-specified tolerance)</p>
Balanced means 1) The ratio of treated and controls is maintained in the training and validation sets
2) The covariate distributions are balanced between the training and validation sets</a></li>
<li><a href='#balancesurv.split'><p>Split the given time-to-event dataset into balanced training and validation sets (within a pre-specified tolerance)</p>
Balanced means 1) The ratio of treated and controls is maintained in the training and validation sets
2) The covariate distributions are balanced between the training and validation sets</a></li>
<li><a href='#boxplot.precmed'><p>A set of box plots of estimated ATEs from the <code>"precmed"</code> object</p></a></li>
<li><a href='#catecv'><p>Cross-validation of the conditional average treatment effect (CATE) score for count, survival or continuous outcomes</p></a></li>
<li><a href='#catecvcount'><p>Cross-validation of the conditional average treatment effect (CATE) score</p>
for count outcomes</a></li>
<li><a href='#catecvmean'><p>Cross-validation of the conditional average treatment effect (CATE) score for continuous outcomes</p></a></li>
<li><a href='#catecvsurv'><p>Cross-validation of the conditional average treatment effect (CATE) score for survival outcomes</p></a></li>
<li><a href='#catefit'><p>Estimation of the conditional average treatment effect (CATE) score for count, survival and continuous data</p></a></li>
<li><a href='#catefitcount'><p>Estimation of the conditional average treatment effect (CATE) score for count data</p></a></li>
<li><a href='#catefitmean'><p>Estimation of the conditional average treatment effect (CATE) score for continuous data</p></a></li>
<li><a href='#catefitsurv'><p>Estimation of the conditional average treatment effect (CATE) score for survival data</p></a></li>
<li><a href='#countExample'><p>Simulated data with count outcome</p></a></li>
<li><a href='#cox.rmst'><p>Estimate restricted mean survival time (RMST) based on Cox regression model</p></a></li>
<li><a href='#data.preproc'><p>Data preprocessing</p>
Apply at the beginning of <code>pmcount()</code> and <code>cvcount()</code>, after <code>arg.checks()</code></a></li>
<li><a href='#data.preproc.mean'><p>Data preprocessing</p>
Apply at the beginning of <code>catefitmean()</code> and <code>catecvmean()</code>, after <code>arg.checks()</code></a></li>
<li><a href='#data.preproc.surv'><p>Data preprocessing</p>
Apply at the beginning of <code>catefitcount()</code>, <code>catecvcount()</code>, <code>catefitsurv()</code>, and <code>catecvsurv()</code>, after <code>arg.checks()</code></a></li>
<li><a href='#drcount'><p>Doubly robust estimator of the average treatment effect for count data</p></a></li>
<li><a href='#drmean'><p>Doubly robust estimator of the average treatment effect for continuous data</p></a></li>
<li><a href='#drsurv'><p>Doubly robust estimator of the average treatment effect with Cox model for survival data</p></a></li>
<li><a href='#estcount.bilevel.subgroups'><p>Estimate the Average Treatment Effect of the log risk ratio in multiple</p>
bi-level subgroups defined by the proportions</a></li>
<li><a href='#estcount.multilevel.subgroup'><p>Estimate the ATE of the log RR ratio in one multilevel subgroup defined by the proportions</p></a></li>
<li><a href='#estmean.bilevel.subgroups'><p>Estimate the ATE of the mean difference in multiple bi-level subgroups</p>
defined by the proportions</a></li>
<li><a href='#estmean.multilevel.subgroup'><p>Estimate the ATE of the mean difference in one multilevel subgroup defined by the proportions</p></a></li>
<li><a href='#estsurv.bilevel.subgroups'><p>Estimate the ATE of the RMTL ratio and unadjusted hazard ratio in multiple bi-level subgroups defined by the proportions</p></a></li>
<li><a href='#estsurv.multilevel.subgroups'><p>Estimate the ATE of the RMTL ratio and unadjusted hazard ratio in one multilevel subgroup defined by the proportions</p></a></li>
<li><a href='#glm.ps'><p>Propensity score estimation with LASSO</p></a></li>
<li><a href='#glm.simplereg.ps'><p>Propensity score estimation with a linear model</p></a></li>
<li><a href='#intxcount'><p>Estimate the CATE model using specified scoring methods</p></a></li>
<li><a href='#intxmean'><p>Estimate the CATE model using specified scoring methods</p></a></li>
<li><a href='#intxsurv'><p>Estimate the CATE model using specified scoring methods for survival outcomes</p></a></li>
<li><a href='#ipcw.surv'><p>Probability of being censored</p></a></li>
<li><a href='#meanCatch'><p>Catch errors and warnings when estimating the ATEs in the nested subgroup for continuous data</p></a></li>
<li><a href='#meanExample'><p>Simulated data with a continuous outcome</p></a></li>
<li><a href='#onearmglmcount.dr'><p>Doubly robust estimators of the coefficients in the two regression</p></a></li>
<li><a href='#onearmglmmean.dr'><p>Doubly robust estimators of the coefficients in the two regression</p></a></li>
<li><a href='#onearmsurv.dr'><p>Doubly robust estimators of the coefficients in the two regression</p></a></li>
<li><a href='#plot.atefit'><p>Histogram of bootstrap estimates</p></a></li>
<li><a href='#plot.precmed'><p>Two side-by-side line plots of validation curves from the <code>"precmed"</code> object</p></a></li>
<li><a href='#print.atefit'><p>Print function for atefit</p></a></li>
<li><a href='#print.catefit'><p>Print function for atefit</p></a></li>
<li><a href='#scorecount'><p>Calculate the log CATE score given the baseline covariates and follow-up time for specified scoring method methods</p></a></li>
<li><a href='#scoremean'><p>Calculate the CATE score given the baseline covariates for specified scoring method methods</p></a></li>
<li><a href='#scoresurv'><p>Calculate the log CATE score given the baseline covariates and follow-up time for specified scoring method methods for survival outcomes</p></a></li>
<li><a href='#survCatch'><p>Catch errors and warnings when estimating the ATEs in the nested subgroup</p></a></li>
<li><a href='#survivalExample'><p>Simulated data with survival outcome</p></a></li>
<li><a href='#twoarmglmcount.dr'><p>Doubly robust estimators of the coefficients in the contrast regression</p>
as well as their covariance matrix and convergence information</a></li>
<li><a href='#twoarmglmmean.dr'><p>Doubly robust estimators of the coefficients in the contrast regression</p>
as well as their covariance matrix</a></li>
<li><a href='#twoarmsurv.dr'><p>Doubly robust estimators of the coefficients in the contrast regression</p>
as well as their covariance matrix and convergence information</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Precision Medicine</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A doubly robust precision medicine approach to fit, cross-validate and visualize prediction models for the conditional average treatment effect (CATE). It implements doubly robust estimation and semiparametric modeling approach of treatment-covariate interactions as proposed by Yadlowsky et al. (2020) &lt;<a href="https://doi.org/10.1080%2F01621459.2020.1772080">doi:10.1080/01621459.2020.1772080</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, gbm, gam, ggplot2, glmnet, graphics, MASS, MESS, mgcv,
rlang, stringr, tidyr, survival, randomForestSRC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-11 13:11:14 UTC; Thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Lu Tian <a href="https://orcid.org/0000-0002-5893-0169"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Xiaotong Jiang <a href="https://orcid.org/0000-0003-3698-4526"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Gabrielle Simoneau
    <a href="https://orcid.org/0000-0001-9310-6274"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Biogen MA Inc. [cph],
  Thomas Debray <a href="https://orcid.org/0000-0002-1790-2719"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cre],
  Stan Wijn [ctb],
  Joana Caldas [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Debray &lt;tdebray@fromdatatowisdom.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-12 14:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='abc'>Compute the area between curves from the <code>"precmed"</code> object</h2><span id='topic+abc'></span>

<h3>Description</h3>

<p>Compute the area between curves (ABC) for each scoring method in the <code>"precmed"</code> object.
This should be run only after results of <code><a href="#topic+catecv">catecv</a>()</code> have been obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abc_+3A_x">x</code></td>
<td>
<p>An object of class <code>"precmed"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ABC is the area between a validation curve and the overall ATE in the validation set.
It is calculated for each scoring method separately. Higher ABC values are preferable as they
indicate that more treatment effect heterogeneity is captured by the scoring method.
Negative values of ABC are possible if segments of the validation curve cross the overall ATE line.
The ABC is calculated with the <code><a href="MESS.html#topic+auc">auc</a>()</code> in the <code>MESS</code> package with a natural
cubic spline interpolation. The calculation of the ABC is always based on validation curves based on
100 proportions equally spaced from <code>min(prop.cutoff)</code> to <code>max(prop.cutoff)</code>.
</p>
<p>The ABC is a metric to help users select the best scoring method in terms of capturing treatment
effect heterogeneity in the data. It should be used in complement to the visual inspection of
the validation curves in the validation set in <code><a href="base.html#topic+plot">plot</a>()</code>.
</p>


<h3>Value</h3>

<p>Returns a matrix of numeric values with number of columns equal to the number cross-validation
iteration and number of rows equal to the number of scoring methods in <code>x</code>.
</p>


<h3>References</h3>

<p>Zhao, L., Tian, L., Cai, T., Claggett, B., &amp; Wei, L. J. (2013).
<em>Effectively selecting a target population for a future comparative study.
Journal of the American Statistical Association, 108(502), 527-539.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+catecv">catecv</a>()</code> function and <code><a href="base.html#topic+plot">plot</a>()</code>, <code><a href="graphics.html#topic+boxplot">boxplot</a>()</code> methods for
<code>"precmed"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Count outcome
cv_count &lt;- catecv(response = "count",
                   data = countExample,
                   score.method = "poisson",
                   cate.model = y ~ age + female + previous_treatment +
                                previous_cost + previous_number_relapses +
                                offset(log(years)),
                   ps.model = trt ~ age + previous_treatment,
                   higher.y = FALSE, cv.n = 5, verbose = 1)

# ABC of the validation curves for each method and each CV iteration
abc(cv_count)

# Survival outcome
library(survival)
cv_surv &lt;- catecv(response = "survival",
                  data = survivalExample,
                  score.method = c("poisson", "randomForest"),
                  cate.model = Surv(y, d) ~ age + female + previous_cost +
                               previous_number_relapses,
                  ps.model = trt ~ age + previous_treatment,
                  higher.y = FALSE,
                  cv.n = 5)

# ABC of the validation curves for each method and each CV iteration
abc(cv_surv)



</code></pre>

<hr>
<h2 id='abc.precmed'>Compute the area between curves from the <code>"precmed"</code> object</h2><span id='topic+abc.precmed'></span>

<h3>Description</h3>

<p>Compute the area between curves (ABC) for each scoring method in the <code>"precmed"</code> object.
This should be run only after results of <code><a href="#topic+catecv">catecv</a>()</code> have been obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'precmed'
abc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abc.precmed_+3A_x">x</code></td>
<td>
<p>An object of class <code>"precmed"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ABC is the area between a validation curve and the overall ATE in the validation set.
It is calculated for each scoring method separately. Higher ABC values are preferable as they
indicate that more treatment effect heterogeneity is captured by the scoring method.
Negative values of ABC are possible if segments of the validation curve cross the overall ATE line.
The ABC is calculated with the <code><a href="MESS.html#topic+auc">auc</a>()</code> in the <code>MESS</code> package with a natural
cubic spline interpolation. The calculation of the ABC is always based on validation curves based on
100 proportions equally spaced from <code>min(prop.cutoff)</code> to <code>max(prop.cutoff)</code>.
</p>
<p>The ABC is a metric to help users select the best scoring method in terms of capturing treatment
effect heterogeneity in the data. It should be used in complement to the visual inspection of
the validation curves in the validation set in <code><a href="base.html#topic+plot">plot</a>()</code>.
</p>


<h3>Value</h3>

<p>Returns a matrix of numeric values with number of columns equal to the number cross-validation
iteration and number of rows equal to the number of scoring methods in <code>x</code>.
</p>


<h3>References</h3>

<p>Zhao, L., Tian, L., Cai, T., Claggett, B., &amp; Wei, L. J. (2013).
<em>Effectively selecting a target population for a future comparative study.
Journal of the American Statistical Association, 108(502), 527-539.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+catecv">catecv</a>()</code> function and <code><a href="base.html#topic+plot">plot</a>()</code>, <code><a href="graphics.html#topic+boxplot">boxplot</a>()</code> methods for
<code>"precmed"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Count outcome
cv_count &lt;- catecv(response = "count",
                   data = countExample,
                   score.method = "poisson",
                   cate.model = y ~ age + female + previous_treatment +
                                previous_cost + previous_number_relapses +
                                offset(log(years)),
                   ps.model = trt ~ age + previous_treatment,
                   higher.y = FALSE, cv.n = 5, verbose = 1)

# ABC of the validation curves for each method and each CV iteration
abc(cv_count)

# Survival outcome
library(survival)
cv_surv &lt;- catecv(response = "survival",
                  data = survivalExample,
                  score.method = c("poisson", "randomForest"),
                  cate.model = Surv(y, d) ~ age + female + previous_cost +
                               previous_number_relapses,
                  ps.model = trt ~ age + previous_treatment,
                  higher.y = FALSE,
                  cv.n = 5)

# ABC of the validation curves for each method and each CV iteration
abc(cv_surv)



</code></pre>

<hr>
<h2 id='arg.checks'>Check arguments
Catered to all types of outcome
Apply at the beginning of <code>pmcount()</code>, <code>cvcount()</code>, <code>drcount.inference()</code>, <code>catefitsurv()</code>, <code>catecvsurv()</code>, and <code>drsurv.inference()</code></h2><span id='topic+arg.checks'></span>

<h3>Description</h3>

<p>Check arguments
Catered to all types of outcome
Apply at the beginning of <code>pmcount()</code>, <code>cvcount()</code>, <code>drcount.inference()</code>, <code>catefitsurv()</code>, <code>catecvsurv()</code>, and <code>drsurv.inference()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arg.checks(
  fun,
  response,
  data,
  followup.time = NULL,
  tau0 = NULL,
  surv.min = NULL,
  ipcw.method = NULL,
  ps.method,
  minPS,
  maxPS,
  higher.y = NULL,
  score.method = NULL,
  abc = NULL,
  prop.cutoff = NULL,
  prop.multi = NULL,
  train.prop = NULL,
  cv.n = NULL,
  error.max = NULL,
  max.iter = NULL,
  initial.predictor.method = NULL,
  tree.depth = NULL,
  n.trees.rf = NULL,
  n.trees.boosting = NULL,
  B = NULL,
  Kfold = NULL,
  plot.gbmperf = NULL,
  error.maxNR = NULL,
  max.iterNR = NULL,
  tune = NULL,
  n.boot = NULL,
  plot.boot = NULL,
  interactions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arg.checks_+3A_fun">fun</code></td>
<td>
<p>A function for which argument check is needed; &quot;catefit&quot; for <code>catefitcount()</code> and <code>catefitsurv()</code>, &quot;crossv&quot; for <code>catecvcount()</code> and <code>catecvsurv()</code>,
and &quot;drinf&quot; for <code>drcount.inference()</code> and <code>drsurv.inference()</code>. No default.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_response">response</code></td>
<td>
<p>The type of response. Always 'survival' for this function.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome and propensity score models;
a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_followup.time">followup.time</code></td>
<td>
<p>Follow-up time, interpreted as the potential censoring time. If the potential censoring time is known,
followup.time is the name of a corresponding column in the data. Otherwise, set <code>followup.time == NULL</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for probability of being censored (positive and very close to 0).</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>The censoring model. Allowed values are: <code>'breslow'</code> (Cox regression with Breslow estimator of the baseline survivor function),
<code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>, <code>'aft (lognormal)'</code> or <code>'aft (loglogistic)'</code>. Default is <code>'breslow'</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or lower (<code>FALSE</code>)
values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'poisson'</code>, <code>'twoReg'</code>, <code>'contrastReg'</code>,
<code>'negBin'</code>. Default specifies all 5 methods.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_abc">abc</code></td>
<td>
<p>A logical value indicating whether the area between curves (ABC) should be calculated
at each cross-validation iterations, for each <code>score.method</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated log CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_prop.multi">prop.multi</code></td>
<td>
<p>A vector of numerical values (in [0, 1]) specifying percentiles of the
estimated log CATE scores to define mutually exclusive subgroups.
It should start with 0, end with 1, and be of <code>length(prop.multi) &gt; 2</code>.
Each element represents the cutoff to separate the observations into
<code>length(prop.multi) - 1</code> mutually exclusive subgroups.
Default is <code>c(0, 1/3, 2/3, 1)</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_train.prop">train.prop</code></td>
<td>
<p>A numerical value (in (0, 1)) indicating the proportion of total data used
for training. Default is <code>3/4</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_cv.n">cv.n</code></td>
<td>
<p>A positive integer value indicating the number of cross-validation iterations.
Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_error.max">error.max</code></td>
<td>
<p>A numerical value &gt; 0 indicating the tolerance (maximum value of error)
for the largest standardized absolute difference in the covariate distributions or in the
doubly robust estimated rate ratios between the training and validation sets. This is used
to define a balanced training-validation splitting. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_max.iter">max.iter</code></td>
<td>
<p>A positive integer value indicating the maximum number of iterations when
searching for a balanced training-validation split. Default is <code>5,000</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates in <code>cate.model</code>
in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Allowed values include
one of <code>'randomForest'</code>, <code>'boosting'</code> and <code>'logistic'</code> (fastest). Default is <code>'randomForest'</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_n.trees.rf">n.trees.rf</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in random forest.
Used if <code>score.method = 'ranfomForest'</code> or
if <code>initial.predictor.method = 'randomForest'</code> with
<code>score.method = 'twoReg'</code> or <code>'contrastReg'</code>. Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with
<code>score.method = 'twoReg'</code> or <code>'contrastReg'</code>. Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds (parts) used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>6</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_n.boot">n.boot</code></td>
<td>
<p>A numeric value indicating the number of bootstrap samples used. This is only relevant
if <code>inference = TRUE</code>. Default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_plot.boot">plot.boot</code></td>
<td>
<p>A logic value indicating whether histograms of the bootstrapped log(rate ratio) should
be produced at every <code>n.boot/10</code>-th iteration and whether the final histogram should be outputted.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="arg.checks_+3A_interactions">interactions</code></td>
<td>
<p>A logical value indicating whether the outcome model should assume interactions
between <code>x</code> and <code>trt</code>. If <code>TRUE</code>, interactions will be assumed only if at least 10 patients
received each treatment option. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Will stop if arguments are incorrect.
</p>

<hr>
<h2 id='arg.checks.common'>Check arguments that are common to all types of outcome
USed inside <code>arg.checks()</code></h2><span id='topic+arg.checks.common'></span>

<h3>Description</h3>

<p>Check arguments that are common to all types of outcome
USed inside <code>arg.checks()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arg.checks.common(
  fun,
  ps.method,
  minPS,
  maxPS,
  higher.y = NULL,
  abc = NULL,
  prop.cutoff = NULL,
  prop.multi = NULL,
  B = NULL,
  Kfold = NULL,
  plot.gbmperf = NULL,
  tree.depth = NULL,
  n.trees.boosting = NULL,
  error.maxNR = NULL,
  max.iterNR = NULL,
  tune = NULL,
  train.prop = NULL,
  cv.n = NULL,
  error.max = NULL,
  max.iter = NULL,
  n.boot = NULL,
  plot.boot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arg.checks.common_+3A_fun">fun</code></td>
<td>
<p>A function for which argument check is needed; &quot;pm&quot; for <code>pmcount()</code>, &quot;cv&quot; for <code>cvcount()</code>,
and &quot;drinf&quot; for <code>drcount.inference()</code>. No default.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or lower (<code>FALSE</code>)
values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_abc">abc</code></td>
<td>
<p>A logical value indicating whether the area between curves (ABC) should be calculated
at each cross-validation iterations, for each <code>score.method</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated log CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_prop.multi">prop.multi</code></td>
<td>
<p>A vector of numerical values (in [0, 1]) specifying percentiles of the
estimated log CATE scores to define mutually exclusive subgroups.
It should start with 0, end with 1, and be of <code>length(prop.multi) &gt; 2</code>.
Each element represents the cutoff to separate the observations into
<code>length(prop.multi) - 1</code> mutually exclusive subgroups.
Default is <code>c(0, 1/3, 2/3, 1)</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds (parts) used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>6</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_train.prop">train.prop</code></td>
<td>
<p>A numerical value (in (0, 1)) indicating the proportion of total data used
for training. Default is <code>3/4</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_cv.n">cv.n</code></td>
<td>
<p>A positive integer value indicating the number of cross-validation iterations.
Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_error.max">error.max</code></td>
<td>
<p>A numerical value &gt; 0 indicating the tolerance (maximum value of error)
for the largest standardized absolute difference in the covariate distributions or in the
doubly robust estimated rate ratios between the training and validation sets. This is used
to define a balanced training-validation splitting. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_max.iter">max.iter</code></td>
<td>
<p>A positive integer value indicating the maximum number of iterations when
searching for a balanced training-validation split. Default is <code>5,000</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_n.boot">n.boot</code></td>
<td>
<p>A numeric value indicating the number of bootstrap samples used. This is only relevant
if <code>inference = TRUE</code>. Default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="arg.checks.common_+3A_plot.boot">plot.boot</code></td>
<td>
<p>A logic value indicating whether histograms of the bootstrapped log(rate ratio) should
be produced at every <code>n.boot/10</code>-th iteration and whether the final histogram should be outputted.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Will stop if arguments are incorrect.
</p>

<hr>
<h2 id='atefit'>Doubly robust estimator of and inference for the average treatment effect for count, survival and continuous data</h2><span id='topic+atefit'></span>

<h3>Description</h3>

<p>Doubly robust estimator of the average treatment effect between two treatments, which is the rate ratio
for count outcomes, the restricted mean time lost ratio for survival outcomes and the mean difference for continuous outcome. Bootstrap is used for
inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atefit(
  response,
  data,
  cate.model,
  ps.model,
  ps.method = "glm",
  ipcw.model = NULL,
  ipcw.method = "breslow",
  minPS = 0.01,
  maxPS = 0.99,
  followup.time = NULL,
  tau0 = NULL,
  surv.min = 0.025,
  interactions = TRUE,
  n.boot = 500,
  seed = NULL,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atefit_+3A_response">response</code></td>
<td>
<p>A string describing the type of outcome in the data. Allowed values include
&quot;count&quot; (see <code><a href="#topic+catecvcount">catecvcount</a>()</code>), &quot;survival&quot; (see
<code><a href="#topic+catecvsurv">catecvsurv</a>()</code>) and &quot;continuous&quot; (see <code><a href="#topic+catecvmean">catecvmean</a>()</code>).</p>
</td></tr>
<tr><td><code id="atefit_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome, propensity score, and inverse
probability of censoring models (if specified); a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="atefit_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side. For survival outcomes,
a <code>Surv</code> object must be used to describe the outcome.</p>
</td></tr>
<tr><td><code id="atefit_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score (PS) model to be fitted. The treatment must
appear on the left-hand side. The treatment must be a numeric vector coded as 0/1.
If data are from a randomized controlled trial, specify <code>ps.model = ~1</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="atefit_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="atefit_+3A_ipcw.model">ipcw.model</code></td>
<td>
<p>A formula describing the inverse probability of censoring weighting (IPCW)
model to be fitted. The left-hand side must be empty. Only applies for survival outcomes.
Default is <code>NULL</code>, which corresponds to specifying the IPCW with the same covariates
as the outcome model <code>cate.model</code>, plus the treatment.</p>
</td></tr>
<tr><td><code id="atefit_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>A character value for the censoring model. Only applies for survival
outcomes. Allowed values are: <code>'breslow'</code> (Cox regression with Breslow estimator of t
he baseline survivor function), <code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>,
<code>'aft (lognormal)'</code> or <code>'aft (loglogistic)'</code> (accelerated failure time model
with different distributions for y variable). Default is <code>'breslow'</code>.</p>
</td></tr>
<tr><td><code id="atefit_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="atefit_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="atefit_+3A_followup.time">followup.time</code></td>
<td>
<p>A column name in <code>data</code> specifying the maximum follow-up time,
interpreted as the potential censoring time. Only applies for survival outcomes.
Default is <code>NULL</code>, which corresponds to unknown potential censoring time.</p>
</td></tr>
<tr><td><code id="atefit_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost. Only applies for
survival outcomes. Default is <code>NULL</code>, which corresponds to setting the truncation time as the
maximum survival time in the data.</p>
</td></tr>
<tr><td><code id="atefit_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for the probability of being censored.
It must be a positive value and should be chosen close to 0. Only applies for survival
outcomes. Default is <code>0.025</code>.</p>
</td></tr>
<tr><td><code id="atefit_+3A_interactions">interactions</code></td>
<td>
<p>A logical value indicating whether the outcome model should assume interactions
between <code>x</code> and <code>trt</code>. Applies only to count outcomes. If <code>TRUE</code>, interactions will
be assumed only if at least 10 patients received each treatment option. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="atefit_+3A_n.boot">n.boot</code></td>
<td>
<p>A numeric value indicating the number of bootstrap samples used. Default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="atefit_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for reproducibility.
Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="atefit_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating whether intermediate progress messages and histograms should
be printed. <code>1</code> indicates messages are printed and <code>0</code> otherwise. Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For count response, see details in <code><a href="#topic+atefitcount">atefitcount</a>()</code>.
For survival response, see details in <code><a href="#topic+atefitsurv">atefitsurv</a>()</code>.
</p>


<h3>Value</h3>

<p>For count response, see description of outputs in <code><a href="#topic+atefitcount">atefitcount</a>()</code>.
For survival response, see description of outputs in <code><a href="#topic+atefitsurv">atefitsurv</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Count outcome
output &lt;- atefit(response = "count",
                 data = countExample,
                 cate.model = y ~ age + female + previous_treatment +
                              previous_cost + previous_number_relapses +
                              offset(log(years)),
                 ps.model = trt ~ age + previous_treatment,
                 n.boot = 50,
                 seed = 999)
output
plot(output)



# Survival outcome
tau0 &lt;- with(survivalExample,
                 min(quantile(y[trt == "drug1"], 0.95), quantile(y[trt == "drug0"], 0.95)))

output2 &lt;- atefit(response = "survival",
                  data = survivalExample,
                  cate.model = survival::Surv(y, d) ~ age + female +
                        previous_cost + previous_number_relapses,
                        ps.model = trt ~ age + previous_treatment,
                  tau0 = tau0,
                  seed = 999)
output2
plot(output2)


</code></pre>

<hr>
<h2 id='atefitcount'>Doubly robust estimator of and inference for the average treatment effect
for count data</h2><span id='topic+atefitcount'></span>

<h3>Description</h3>

<p>Doubly robust estimator of the average treatment effect between two
treatments, which is the rate ratio for count outcomes. Bootstrap is used for
inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atefitcount(
  data,
  cate.model,
  ps.model,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99,
  interactions = TRUE,
  n.boot = 500,
  seed = NULL,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atefitcount_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome, propensity
score, and inverse probability of censoring models (if specified); a data
frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="atefitcount_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="atefitcount_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score (PS) model to be
fitted. The treatment must appear on the left-hand side. The treatment must
be a numeric vector coded as 0 or 1. If data are from a randomized controlled
trial, specify <code>ps.model = ~1</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="atefitcount_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity
score. Allowed values include one of: <code>'glm'</code> for logistic regression
with main effects only (default), or <code>'lasso'</code> for a logistic regression
with main effects and LASSO penalization on two-way interactions (added to
the model if interactions are not specified in <code>ps.model</code>). Relevant
only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="atefitcount_+3A_minps">minPS</code></td>
<td>
<p>A numerical value between 0 and 1 below which estimated
propensity scores should be truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="atefitcount_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value between 0 and 1 above which estimated
propensity scores should be truncated. Must be strictly greater than
<code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="atefitcount_+3A_interactions">interactions</code></td>
<td>
<p>A logical value indicating whether the outcome model
should assume treatment-covariate interaction by <code>x</code>. If <code>TRUE</code>,
interactions will be assumed only if at least 10 patients received each
treatment option. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="atefitcount_+3A_n.boot">n.boot</code></td>
<td>
<p>A numeric value indicating the number of bootstrap samples
used. Default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="atefitcount_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for
reproducibility. Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="atefitcount_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating whether intermediate progress
messages should be printed. <code>1</code> indicates messages are printed and
<code>0</code> otherwise. Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This helper function estimates the average treatment effect (ATE)
between two treatment groups in a given dataset. The ATE is estimated with a
doubly robust estimator that accounts for imbalances in covariate
distributions between the two treatment groups with inverse probability
treatment weighting. For count outcomes, the estimated ATE is the estimated
rate ratio between treatment 1 versus treatment 0.
</p>


<h3>Value</h3>

<p>Return an item of the class <code>atefit</code> with the following
elements:
</p>

<ul>
<li><p><code>log.rate.ratio</code>:  A vector of numeric values of the estimated
ATE (expressed as a log rate ratio of <code>trt=1</code> over <code>trt=0</code>),
the bootstrap standard error, the lower and upper limits of 95% confidence
interval, and the p-value.
</p>
</li>
<li><p><code>rate0</code>:  A numeric value of the estimated rate in the group
<code>trt=0</code>.
</p>
</li>
<li><p><code>rate1</code>:  A numeric value of the estimated rate in the group
<code>trt=1</code>.
</p>
</li>
<li><p><code>trt.boot</code>:  Estimated log rate ratios in each bootstrap
sample.
</p>
</li>
<li><p><code>warning</code>:  A warning message produced if the treatment
variable was not coded as 0 or 1. The key to map the original coding of the
variable to a 0-1 coding is displayed in the warning to facilitate the
interpretation of the remaining of the output.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>output &lt;- atefitcount(data = countExample,
                      cate.model = y ~ age + female + previous_treatment +
                                   previous_cost + previous_number_relapses +
                                   offset(log(years)),
                      ps.model = trt ~ age + previous_treatment,
                      verbose = 1, n.boot = 50, seed = 999)
output
plot(output)
</code></pre>

<hr>
<h2 id='atefitmean'>Doubly robust estimator of and inference for the average treatment effect for
continuous data</h2><span id='topic+atefitmean'></span>

<h3>Description</h3>

<p>Doubly robust estimator of the average treatment effect between two
treatments, which is the rate ratio of treatment 1 over treatment 0 for
count outcomes. Bootstrap is used for inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atefitmean(
  data,
  cate.model,
  ps.model,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99,
  interactions = TRUE,
  n.boot = 500,
  plot.boot = FALSE,
  seed = NULL,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atefitmean_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome and
propensity score models; a data frame with <code>n</code> rows (1 row per
observation).</p>
</td></tr>
<tr><td><code id="atefitmean_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="atefitmean_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score model to be fitted.
The treatment must appear on the left-hand side. The treatment must be a
numeric vector coded as 0/1. If data are from a RCT, specify <code>ps.model</code>
as an intercept-only model.</p>
</td></tr>
<tr><td><code id="atefitmean_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity
score. Allowed values include one of: <code>'glm'</code> for logistic regression
with main effects only (default), or <code>'lasso'</code> for a logistic regression
with main effects and LASSO penalization on two-way interactions (added to
the model if interactions are not specified in <code>ps.model</code>). Relevant
only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="atefitmean_+3A_minps">minPS</code></td>
<td>
<p>A numerical value between 0 and 1 below which estimated
propensity scores should be truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="atefitmean_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value between 0 and 1 above which estimated
propensity scores should be truncated. Must be strictly greater than
<code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="atefitmean_+3A_interactions">interactions</code></td>
<td>
<p>A logical value indicating whether the outcome model
should be fitted separately by treatment arm with the variables in
<code>cate.model</code>, which is equivalent to assuming treatment-covariate
interaction by all of the variables in <code>cate.model</code>. If <code>TRUE</code>, the
outcome model will be fitted separately by treatment arms only if at least
10 patients received each treatment option. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="atefitmean_+3A_n.boot">n.boot</code></td>
<td>
<p>A numeric value indicating the number of bootstrap samples
used. Default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="atefitmean_+3A_plot.boot">plot.boot</code></td>
<td>
<p>A logical value indicating whether histograms of the
bootstrapped treatment effect estimates should be produced at every
<code>n.boot/10</code>-th iteration and whether the final histogram should be
outputted. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="atefitmean_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for
reproducibility. Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="atefitmean_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating whether intermediate progress
messages and histograms should be printed. <code>1</code> indicates messages are
printed and <code>0</code> otherwise. Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This helper function estimates the average treatment effect (ATE) between two
treatment groups in a given dataset specified by <code>y, trt, x.cate, x.ps, time</code>. The ATE is
estimated with a doubly robust estimator that accounts for imbalances in covariate distributions
between the two treatment groups with inverse probability treatment weighting.
For count outcomes, the estimated ATE is the estimated
rate ratio between treatment 1 versus treatment 0. Both original and log-transformed ATEs are
returned, as well as the rate in either treatment group.
If <code>inference = TRUE</code>, the variability of the estimated rate ratio is also calculated
using bootstrap. Additional variability outputs include standard error of the log rate ratio,
95% confidence interval of the rate ratio, p-value, and a histogram of the log rate ratio.
</p>


<h3>Value</h3>

<p>Return a list of 8 elements:
</p>

<ul>
<li><p><code>log.rate.ratio</code>:  A numeric value of the estimated log rate ratio.
</p>
</li>
<li><p><code>se.boot.log.rate.ratio</code>:  A numeric value of the bootstrap standard error of log rate ratio.
</p>
</li>
<li><p><code>rate.ratio</code>:  A numeric value of the estimated rate ratio.
</p>
</li>
<li><p><code>rate.ratio0</code>:  A numeric value of the estimated rate in the group trt=0.
</p>
</li>
<li><p><code>rate.ratio1</code>:  A numeric value of the estimated rate in the group trt=1.
</p>
</li>
<li><p><code>rate.ratio.CIl</code>:  A numeric value of the lower limit 95% bootstrap confidence interval
for estimated rate ratio.
</p>
</li>
<li><p><code>rate.ratio.CIu</code>:  A numeric value of the upper limit 95% bootstrap confidence interval
for estimated rate ratio.
</p>
</li>
<li><p><code>pvalue</code>:  A numeric value of the p-value derived from the bootstrapped values
based on a Chi-squared distribution.
</p>
</li>
<li><p><code>warning</code>:  A warning message produced if the treatment variable was not coded as 0/1. The key
to map the original coding of the variable to a 0/1 key is displayed in the warning to facilitate the
interpretation of the remaining of the output.
</p>
</li>
<li><p><code>plot</code>:  If <code>plot.boot</code> is <code>TRUE</code>, a histogram displaying the distribution of the bootstrapped log rate ratios.
The red vertical reference line in the histogram represents the estimated log rate ratio.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># This module is not implemented yet!

</code></pre>

<hr>
<h2 id='atefitsurv'>Doubly robust estimator of and inference for the average treatment effect for survival data</h2><span id='topic+atefitsurv'></span>

<h3>Description</h3>

<p>Doubly robust estimator of the average treatment effect between two treatments, which is the
restricted mean time lost ratio for survival outcomes. Bootstrap is used for inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atefitsurv(
  data,
  cate.model,
  ps.model,
  ps.method = "glm",
  ipcw.model = NULL,
  ipcw.method = "breslow",
  minPS = 0.01,
  maxPS = 0.99,
  followup.time = NULL,
  tau0 = NULL,
  surv.min = 0.025,
  n.boot = 500,
  seed = NULL,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atefitsurv_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome, propensity score, and inverse
probability of censoring models (if specified); a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side. For survival outcomes, a <code>Surv</code> object
must be used to describe the outcome.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score (PS) model to be fitted. The treatment must
appear on the left-hand side. The treatment must be a numeric vector coded as 0/1.
If data are from a randomized controlled trial, specify <code>ps.model = ~1</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_ipcw.model">ipcw.model</code></td>
<td>
<p>A formula describing the inverse probability of censoring weighting (IPCW)
model to be fitted. The left-hand side must be empty. Only applies for survival outcomes.
Default is <code>NULL</code>, which corresponds to specifying the IPCW with the same covariates
as the outcome model <code>cate.model</code>, plus the treatment.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>A character value for the censoring model. Only applies for survival
outcomes. Allowed values are: <code>'breslow'</code> (Cox regression with Breslow estimator of t
he baseline survivor function), <code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>,
<code>'aft (lognormal)'</code> or <code>'aft (loglogistic)'</code> (accelerated failure time model
with different distributions for y variable). Default is <code>'breslow'</code>.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_followup.time">followup.time</code></td>
<td>
<p>A column name in <code>data</code> specifying the maximum follow-up time,
interpreted as the potential censoring time. Only applies for survival outcomes.
Default is <code>NULL</code>, which corresponds to unknown potential censoring time.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost. Only applies for
survival outcomes. Default is <code>NULL</code>, which corresponds to setting the truncation time as the
maximum survival time in the data.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for the probability of being censored.
It must be a positive value and should be chosen close to 0. Only applies for survival
outcomes. Default is <code>0.025</code>.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_n.boot">n.boot</code></td>
<td>
<p>A numeric value indicating the number of bootstrap samples used. Default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for reproducibility.
Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="atefitsurv_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating whether intermediate progress messages should
be printed. <code>1</code> indicates messages are printed and <code>0</code> otherwise. Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This helper function estimates the average treatment effect (ATE) for survival data between two
treatment groups in a given dataset. The ATE is estimated with a doubly robust estimator that accounts for
imbalances in covariate distributions between the two treatment groups with inverse probability treatment and
censoring weighting. For survival outcomes, the estimated ATE is the estimated by RMTL ratio between treatment
1 versus treatment 0. The log-transformed ATEs and log-transformed adjusted hazard ratios are returned, as well
as the estimated RMST in either treatment group. The variability of the estimated RMTL ratio is calculated
using bootstrap. Additional outputs include standard error of the log RMTL ratio, 95% confidence interval,
p-value, and a histogram of the bootstrap estimates.
</p>


<h3>Value</h3>

<p>Return an object of class <code>atefit</code> with 6 elements:
</p>

<ul>
<li><p><code>rmst1</code>:  A vector of numeric values of the estimated RMST, bootstrap standard error,
lower and upper limits of 95% confidence interval, and the p-value in the group <code>trt=1</code>.
</p>
</li>
<li><p><code>rmst0</code>:  A vector of numeric values of the estimated RMST, bootstrap standard error,
lower and upper limits of 95% confidence interval, and the p-value in the group <code>trt=0</code>.
</p>
</li>
<li><p><code>log.rmtl.ratio</code>:  A vector of numeric values of the estimated log RMTL ratio of
<code>trt=1</code> over <code>trt=0</code>, bootstrap standard error, lower and upper limits of 95% confidence
interval, and the p-value.
</p>
</li>
<li><p><code>log.hazard.ratio</code>:  A vector of numeric values of the estimated adjusted log hazard ratio
of <code>trt=1</code> over <code>trt=0</code>, bootstrap standard error, lower and upper limits of 95% confidence
interval, and the p-value.
</p>
</li>
<li><p><code>trt.boot</code>:  Estimates of <code>rmst1</code>, <code>rmst0</code>,
<code>log.rmtl.ratio</code> and <code>log.hazard.ratio</code> in each bootstrap sample.
</p>
</li>
<li><p><code>warning</code>:  A warning message produced if the treatment variable was not coded as 0/1.
The key to map the original coding of the variable to a 0/1 key is displayed in the warning to facilitate
the interpretation of the remaining of the output.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
tau0 &lt;- with(survivalExample,
             min(quantile(y[trt == "drug1"], 0.95), quantile(y[trt == "drug0"], 0.95)))

output &lt;- atefitsurv(data = survivalExample,
                     cate.model = Surv(y, d) ~ age + female +
                                  previous_cost + previous_number_relapses,
                     ps.model = trt ~ age + previous_treatment,
                     tau0 = tau0,
                     n.boot = 50,
                     seed = 999,
                     verbose = 1)
output
plot(output)


</code></pre>

<hr>
<h2 id='balance.split'>Split the given dataset into balanced training and validation sets
(within a pre-specified tolerance)
Balanced means 1) The ratio of treated and controls is maintained in the training and validation sets
2) The covariate distributions are balanced between the training and validation sets</h2><span id='topic+balance.split'></span>

<h3>Description</h3>

<p>Split the given dataset into balanced training and validation sets
(within a pre-specified tolerance)
Balanced means 1) The ratio of treated and controls is maintained in the training and validation sets
2) The covariate distributions are balanced between the training and validation sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance.split(
  y,
  trt,
  x.cate,
  x.ps,
  time,
  minPS = 0.01,
  maxPS = 0.99,
  train.prop = 3/4,
  error.max = 0.1,
  max.iter = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance.split_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code> (observations)</p>
</td></tr>
<tr><td><code id="balance.split_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="balance.split_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code>
(covariates in the outcome model)</p>
</td></tr>
<tr><td><code id="balance.split_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept);
dimension <code>n</code> by <code>p.ps + 1</code> (covariates in the propensity score model plus intercept)</p>
</td></tr>
<tr><td><code id="balance.split_+3A_time">time</code></td>
<td>
<p>Log-transformed person-years of follow-up; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="balance.split_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="balance.split_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="balance.split_+3A_train.prop">train.prop</code></td>
<td>
<p>A numerical value (in (0, 1)) indicating the proportion of total data used
for training. Default is <code>3/4</code>.</p>
</td></tr>
<tr><td><code id="balance.split_+3A_error.max">error.max</code></td>
<td>
<p>A numerical value &gt; 0 indicating the tolerance (maximum value of error)
for the largest standardized absolute difference in the covariate distributions or in the
doubly robust estimated rate ratios between the training and validation sets. This is used
to define a balanced training-validation splitting. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="balance.split_+3A_max.iter">max.iter</code></td>
<td>
<p>A positive integer value indicating the maximum number of iterations when
searching for a balanced training-validation split. Default is <code>5,000</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 10 objects, 5 training and 5 validation of y, trt, x.cate, x.ps, time:
y.train          - observed outcome in the training set; vector of size <code>m</code> (observations in the training set)
trt.train        - treatment received in the training set; vector of size <code>m</code> coded as 0/1
x.cate.train     - baseline covariates for the outcome model in the training set; matrix of dimension <code>m</code> by <code>p.cate</code>
x.ps.train       - baseline covariates (plus intercept) for the propensity score model in the training set; matrix of dimension <code>m</code> by <code>p.ps + 1</code>
time.train       - log-transformed person-years of follow-up in the training set; vector of size <code>m</code>
y.valid          - observed outcome in the validation set; vector of size <code>n-m</code>
trt.valid        - treatment received in the validation set; vector of size <code>n-m</code> coded as 0/1
x.cate.valid     - baseline covariates for the outcome model in the validation set; matrix of dimension <code>n-m</code> by <code>p.cate</code>
x.ps.valid       - baseline covariates (plus intercept) for the propensity score model in the validation set; matrix of dimension <code>n-m</code> by <code>p.ps + 1</code>
time.valid       - log-transformed person-years of follow-up in the validation set; vector of size <code>n-m</code>
</p>

<hr>
<h2 id='balancemean.split'>Split the given dataset into balanced training and validation sets (within a pre-specified tolerance)
Balanced means 1) The ratio of treated and controls is maintained in the training and validation sets
2) The covariate distributions are balanced between the training and validation sets</h2><span id='topic+balancemean.split'></span>

<h3>Description</h3>

<p>Split the given dataset into balanced training and validation sets (within a pre-specified tolerance)
Balanced means 1) The ratio of treated and controls is maintained in the training and validation sets
2) The covariate distributions are balanced between the training and validation sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balancemean.split(
  y,
  trt,
  x.cate,
  x.ps,
  minPS = 0.01,
  maxPS = 0.99,
  train.prop = 3/4,
  error.max = 0.1,
  max.iter = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balancemean.split_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code> (observations)</p>
</td></tr>
<tr><td><code id="balancemean.split_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="balancemean.split_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code>
(covariates in the outcome model)</p>
</td></tr>
<tr><td><code id="balancemean.split_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept);
dimension <code>n</code> by <code>p.ps + 1</code> (covariates in the propensity score model plus intercept)</p>
</td></tr>
<tr><td><code id="balancemean.split_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="balancemean.split_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="balancemean.split_+3A_train.prop">train.prop</code></td>
<td>
<p>A numerical value (in (0, 1)) indicating the proportion of total data used
for training. Default is <code>3/4</code>.</p>
</td></tr>
<tr><td><code id="balancemean.split_+3A_error.max">error.max</code></td>
<td>
<p>A numerical value &gt; 0 indicating the tolerance (maximum value of error)
for the largest standardized absolute difference in the covariate distributions or in the
doubly robust estimated rate ratios between the training and validation sets. This is used
to define a balanced training-validation splitting. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="balancemean.split_+3A_max.iter">max.iter</code></td>
<td>
<p>A positive integer value indicating the maximum number of iterations when
searching for a balanced training-validation split. Default is <code>5,000</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 10 objects, 5 training and 5 validation of y, trt, x.cate, x.ps, time:
y.train          - observed outcome in the training set; vector of size <code>m</code> (observations in the training set)
trt.train        - treatment received in the training set; vector of size <code>m</code> coded as 0/1
x.cate.train     - baseline covariates for the outcome model in the training set; matrix of dimension <code>m</code> by <code>p.cate</code>
x.ps.train       - baseline covariates (plus intercept) for the propensity score model in the training set; matrix of dimension <code>m</code> by <code>p.ps + 1</code>
y.valid          - observed outcome in the validation set; vector of size <code>n-m</code>
trt.valid        - treatment received in the validation set; vector of size <code>n-m</code> coded as 0/1
x.cate.valid     - baseline covariates for the outcome model in the validation set; matrix of dimension <code>n-m</code> by <code>p.cate</code>
x.ps.valid       - baseline covariates (plus intercept) for the propensity score model in the validation set; matrix of dimension <code>n-m</code> by <code>p.ps + 1</code>
bestid.valid     - id for the validation set by the best split; vector of size <code>n-m</code>
</p>

<hr>
<h2 id='balancesurv.split'>Split the given time-to-event dataset into balanced training and validation sets (within a pre-specified tolerance)
Balanced means 1) The ratio of treated and controls is maintained in the training and validation sets
2) The covariate distributions are balanced between the training and validation sets</h2><span id='topic+balancesurv.split'></span>

<h3>Description</h3>

<p>Split the given time-to-event dataset into balanced training and validation sets (within a pre-specified tolerance)
Balanced means 1) The ratio of treated and controls is maintained in the training and validation sets
2) The covariate distributions are balanced between the training and validation sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balancesurv.split(
  y,
  d,
  trt,
  x.cate,
  x.ps,
  x.ipcw,
  yf = NULL,
  train.prop = 3/4,
  error.max = 0.1,
  max.iter = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balancesurv.split_+3A_y">y</code></td>
<td>
<p>Observed survival or censoring time; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="balancesurv.split_+3A_d">d</code></td>
<td>
<p>The event indicator, normally <code>1 = event, 0 = censored</code>; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="balancesurv.split_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> with treatment coded as 0/1.</p>
</td></tr>
<tr><td><code id="balancesurv.split_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates specified in the outcome model; dimension <code>n</code> by <code>p.cate</code>.</p>
</td></tr>
<tr><td><code id="balancesurv.split_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates specified in the propensity score model; dimension <code>n</code> by <code>p.ps</code>.</p>
</td></tr>
<tr><td><code id="balancesurv.split_+3A_x.ipcw">x.ipcw</code></td>
<td>
<p>Matrix of <code>p.ipw</code> baseline covariate specified in inverse probability of censoring weighting; dimension <code>n</code> by <code>p.ipw</code>.</p>
</td></tr>
<tr><td><code id="balancesurv.split_+3A_yf">yf</code></td>
<td>
<p>Follow-up time, interpreted as the potential censoring time; vector of size <code>n</code> if the potential censoring time is known.
If unknown, set <code>yf == NULL</code> and <code>yf</code> will be taken as <code>y</code> in the function.</p>
</td></tr>
<tr><td><code id="balancesurv.split_+3A_train.prop">train.prop</code></td>
<td>
<p>A numerical value (in (0, 1)) indicating the proportion of total data used
for training. Default is <code>3/4</code>.</p>
</td></tr>
<tr><td><code id="balancesurv.split_+3A_error.max">error.max</code></td>
<td>
<p>A numerical value &gt; 0 indicating the tolerance (maximum value of error)
for the largest standardized absolute difference in the covariate distributions or in the
doubly robust estimated rate ratios between the training and validation sets. This is used
to define a balanced training-validation splitting. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="balancesurv.split_+3A_max.iter">max.iter</code></td>
<td>
<p>A positive integer value indicating the maximum number of iterations when
searching for a balanced training-validation split. Default is <code>5,000</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 14 objects, 7training and 7 validation of y, trt, x.cate, x.ps, x.ipcw, time, yf:
y.train          - observed survival or censoring time in the training set; vector of size <code>m</code> (observations in the training set)
d.train          - event indicator in the training set; vector of size <code>m</code> coded as 0/1
trt.train        - treatment received in the training set; vector of size <code>m</code> coded as 0/1
x.cate.train     - baseline covariates for the outcome model in the training set; matrix of dimension <code>m</code> by <code>p.cate</code>
x.ps.train       - baseline covariates (plus intercept) for the propensity score model in the training set; matrix of dimension <code>m</code> by <code>p.ps + 1</code>
x.ipcw.train      - baseline covariates for inverse probability of censoring in the training set; matrix of dimension <code>m</code> by <code>p.ipw</code>
yf.train         - follow-up time in the training set; if known, vector of size <code>m</code>; if unknown, <code>yf == NULL</code>
y.valid          - observed survival or censoring time in the validation set; vector of size <code>n-m</code>
d.valid          - event indicator in the validation set; vector of size <code>n-m</code> coded as 0/1
trt.valid        - treatment received in the validation set; vector of size <code>n-m</code> coded as 0/1
x.cate.valid     - baseline covariates for the outcome model in the validation set; matrix of dimension <code>n-m</code> by <code>p.cate</code>
x.ps.valid       - baseline covariates (plus intercept) for the propensity score model in the validation set; matrix of dimension <code>n-m</code> by <code>p.ps + 1</code>
x.ipcw.valid      - baseline covariates for inverse probability of censoring in the validation set; matrix of dimension <code>n-m</code> by <code>p.ipw</code>
yf.valid         - follow-up time in the training set; if known, vector of size <code>n-m</code>; if unknown, <code>yf == NULL</code>
</p>

<hr>
<h2 id='boxplot.precmed'>A set of box plots of estimated ATEs from the <code>"precmed"</code> object</h2><span id='topic+boxplot.precmed'></span>

<h3>Description</h3>

<p>Provides box plots which depict distributions of estimated ATEs for each multi-category subgroup in
the validation set across all cross-validation iterations. The subgroups are mutually exclusive and
are categorized by the CATE score percentiles (<code>prop.multi</code> specified in <code><a href="#topic+catecv">catecv</a>()</code> or
<code><a href="#topic+catecvmean">catecvmean</a>()</code>). Box plots of mutually exclusive subgroups are constructed separately by scoring
method specified in <code><a href="#topic+catecv">catecv</a>()</code>. This should be run only after results of <code><a href="#topic+catecv">catecv</a>()</code> or
<code><a href="#topic+catecvmean">catecvmean</a>()</code>) have been obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'precmed'
boxplot(
  x,
  ylab = NULL,
  plot.hr = FALSE,
  title = waiver(),
  theme = theme_classic(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot.precmed_+3A_x">x</code></td>
<td>
<p>An object of class <code>"precmed"</code>.</p>
</td></tr>
<tr><td><code id="boxplot.precmed_+3A_ylab">ylab</code></td>
<td>
<p>A character value for the y-axis label to describe what the ATE is. Default is <code>NULL</code>,
which creates a default y-axis label based on available data.</p>
</td></tr>
<tr><td><code id="boxplot.precmed_+3A_plot.hr">plot.hr</code></td>
<td>
<p>A logical value indicating whether the hazard ratios should be plotted in the
validation curves (<code>TRUE</code>). Otherwise, the restricted mean time lost is plotted (<code>FALSE</code>).
This argument is only applicable to survival outcomes. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="boxplot.precmed_+3A_title">title</code></td>
<td>
<p>The text for the title</p>
</td></tr>
<tr><td><code id="boxplot.precmed_+3A_theme">theme</code></td>
<td>
<p>Defaults to <code>theme_classic()</code>. Other options include <code>theme_grey()</code>, <code>theme_bw()</code>, <code>theme_light()</code>, <code>theme_dark()</code>, and <code>theme_void()</code></p>
</td></tr>
<tr><td><code id="boxplot.precmed_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a>()</code> takes in outputs from <code><a href="#topic+catecv">catecv</a>()</code> and generates
the box plots of estimated ATEs for multi-category subgroups of the validation set.
The box plots together with the overall ATE reference line can help compare the scoring methods'
ability to distinguish subgroups of patients with different treatment effects.
</p>
<p>For a given scoring method, box plots showing increasing or decreasing trends across the
multi-category subgroups indicate presence of treatment effect heterogeneity
(and the ability of the scoring method to capture it). On the contrary, box plots which
are relatively aligned across the multi-category subgroups indicate absence of treatment
effect heterogeneity (or the inability of the scoring method to capture it).
</p>


<h3>Value</h3>

<p>Returns sets of box plots, one set for each scoring method, over each of the multi-category
subgroups. A gray horizontal dashed line of the overall ATE is included as a reference.
</p>


<h3>References</h3>

<p>Yadlowsky, S., Pellegrini, F., Lionetto, F., Braune, S., &amp; Tian, L. (2020).
<em>Estimation and validation of ratio-based conditional average treatment effects using
observational data. Journal of the American Statistical Association, 1-18.</em>
<a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080">https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a></code> and <code><a href="#topic+abc">abc</a>()</code> for <code>"precmed"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Count outcome
eval_1 &lt;- catecv(response = "count",
                 data = countExample,
                 score.method = "poisson",
                 cate.model = y ~ age + female + previous_treatment +
                                  previous_cost + previous_number_relapses +
                                  offset(log(years)),
                 ps.model = trt ~ age + previous_treatment,
                 higher.y = FALSE,
                 cv.n = 5)

boxplot(eval_1, ylab = "Rate ratio of drug1 vs drug0 in each subgroup")

# Survival outcome
library(survival)
tau0 &lt;- with(survivalExample,
             min(quantile(y[trt == "drug1"], 0.95), quantile(y[trt == "drug0"], 0.95)))
eval_2 &lt;- catecv(response = "survival",
                 data = survivalExample,
                 score.method = c("poisson", "randomForest"),
                 cate.model = Surv(y, d) ~ age + female + previous_cost +
                                           previous_number_relapses,
                 ps.model = trt ~ age + previous_treatment,
                 initial.predictor.method = "randomForest",
                 ipcw.model = ~ age + previous_cost + previous_treatment,
                 tau0 = tau0,
                 higher.y = TRUE,
                 cv.n = 5,
                 seed = 999)

boxplot(eval_2, ylab = "RMTL ratio of drug1 vs drug0 in each subgroup")


</code></pre>

<hr>
<h2 id='catecv'>Cross-validation of the conditional average treatment effect (CATE) score for count, survival or continuous outcomes</h2><span id='topic+catecv'></span>

<h3>Description</h3>

<p>Provides (doubly robust) estimation of the average treatment effect (ATE) for count, survival or continuous
outcomes in nested and mutually exclusive subgroups of patients defined by an estimated conditional
average treatment effect (CATE) score via cross-validation (CV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catecv(
  response,
  data,
  score.method,
  cate.model,
  ps.model,
  ps.method = "glm",
  init.model = NULL,
  initial.predictor.method = NULL,
  ipcw.model = NULL,
  ipcw.method = "breslow",
  minPS = 0.01,
  maxPS = 0.99,
  followup.time = NULL,
  tau0 = NULL,
  higher.y = TRUE,
  prop.cutoff = seq(0.5, 1, length = 6),
  prop.multi = c(0, 1/3, 2/3, 1),
  abc = TRUE,
  train.prop = 3/4,
  cv.n = 10,
  error.max = 0.1,
  max.iter = 5000,
  surv.min = 0.025,
  xvar.smooth.score = NULL,
  xvar.smooth.init = NULL,
  tree.depth = 2,
  n.trees.rf = 1000,
  n.trees.boosting = 200,
  B = 3,
  Kfold = 5,
  error.maxNR = 0.001,
  max.iterNR = 150,
  tune = c(0.5, 2),
  seed = NULL,
  plot.gbmperf = TRUE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catecv_+3A_response">response</code></td>
<td>
<p>A string describing the type of outcome in the data.
Allowed values include &quot;count&quot; (see <code><a href="#topic+catecvcount">catecvcount</a>()</code>), &quot;survival&quot;
(see <code><a href="#topic+catecvsurv">catecvsurv</a>()</code>) and &quot;continuous&quot; (see
<code><a href="#topic+catecvmean">catecvmean</a>()</code>) .</p>
</td></tr>
<tr><td><code id="catecv_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome, propensity score, and inverse
probability of censoring models (if specified); a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="catecv_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'twoReg'</code>, <code>'contrastReg'</code>, <code>'poisson'</code> (count and survival outcomes only),
<code>'randomForest'</code> (survival, continuous outcomes only), <code>negBin</code> (count outcomes only), <code>'gam'</code> (continuous outcomes only),
<code>'gaussian'</code> (continuous outcomes only).</p>
</td></tr>
<tr><td><code id="catecv_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side. For survival outcomes, a
<code>Surv</code> object must be used to describe the outcome.</p>
</td></tr>
<tr><td><code id="catecv_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score (PS) model to be fitted. The treatment must
appear on the left-hand side. The treatment must be a numeric vector coded as 0/1.
If data are from a randomized controlled trial, specify <code>ps.model = ~1</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="catecv_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="catecv_+3A_init.model">init.model</code></td>
<td>
<p>A formula describing the initial predictor model. The outcome must appear on the left-hand side.
It must be specified when <code>score.method = contrastReg</code> or <code>twoReg</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates specified in <code>cate.model</code>. Only applies
when <code>score.method</code> includes <code>'twoReg'</code> or <code>'contrastReg'</code>. Allowed values include one of
<code>'randomForest'</code> (survival outcomes only), <code>'boosting'</code>, <code>'logistic'</code>
(survival outcomes only, fast), <code>'poisson'</code> (count outcomes only, fast), <code>'gaussian'</code> (continuous outcomes only) and
<code>'gam'</code> (count and continuous outcomes only). Default is <code>NULL</code>, which assigns <code>'boosting'</code>
for count outcomes and <code>'randomForest'</code> for survival outcomes.</p>
</td></tr>
<tr><td><code id="catecv_+3A_ipcw.model">ipcw.model</code></td>
<td>
<p>A formula describing the inverse probability of censoring weighting (IPCW)
model to be fitted. The left-hand side must be empty. Only applies for survival outcomes.
Default is <code>NULL</code>, which corresponds to specifying the IPCW with the same covariates
as the outcome model <code>cate.model</code>, plus the treatment.</p>
</td></tr>
<tr><td><code id="catecv_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>A character value for the censoring model. Only applies for survival
outcomes. Allowed values are: <code>'breslow'</code> (Cox regression with Breslow estimator of t
he baseline survivor function), <code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>,
<code>'aft (lognormal)'</code> or <code>'aft (loglogistic)'</code> (accelerated failure time model
with different distributions for y variable). Default is <code>'breslow'</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_followup.time">followup.time</code></td>
<td>
<p>A column name in <code>data</code> specifying the maximum follow-up time,
interpreted as the potential censoring time. Only applies for survival outcomes.
Default is <code>NULL</code>, which corresponds to unknown potential censoring time.</p>
</td></tr>
<tr><td><code id="catecv_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost. Only applies for
survival outcomes. Default is <code>NULL</code>, which corresponds to setting the truncation time as the
maximum survival time in the data.</p>
</td></tr>
<tr><td><code id="catecv_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or
lower (<code>FALSE</code>) values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated log CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_prop.multi">prop.multi</code></td>
<td>
<p>A vector of numerical values (in [0, 1]) specifying percentiles of the
estimated log CATE scores to define mutually exclusive subgroups.
It should start with 0, end with 1, and be of <code>length(prop.multi) &gt; 2</code>.
Each element represents the cutoff to separate the observations into
<code>length(prop.multi) - 1</code> mutually exclusive subgroups.
Default is <code>c(0, 1/3, 2/3, 1)</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_abc">abc</code></td>
<td>
<p>A logical value indicating whether the area between curves (ABC) should be calculated
at each cross-validation iterations, for each <code>score.method</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_train.prop">train.prop</code></td>
<td>
<p>A numerical value (in (0, 1)) indicating the proportion of total data used
for training. Default is <code>3/4</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_cv.n">cv.n</code></td>
<td>
<p>A positive integer value indicating the number of cross-validation iterations.
Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_error.max">error.max</code></td>
<td>
<p>A numerical value &gt; 0 indicating the tolerance (maximum value of error)
for the largest standardized absolute difference in the covariate distributions or in the
doubly robust estimated rate ratios between the training and validation sets. This is used
to define a balanced training-validation splitting. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_max.iter">max.iter</code></td>
<td>
<p>A positive integer value indicating the maximum number of iterations when
searching for a balanced training-validation split. Default is <code>5,000</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for the probability of being censored.
It must be a positive value and should be chosen close to 0. Only applies for survival
outcomes. Default is <code>0.025</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_xvar.smooth.score">xvar.smooth.score</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>score.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>cate.model</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_xvar.smooth.init">xvar.smooth.init</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>initial.predictor.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>init.model</code>.
Default is <code>NULL</code>, which uses all variables in <code>init.model</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="catecv_+3A_n.trees.rf">n.trees.rf</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in random forest.
Used if <code>score.method = 'ranfomForest'</code> or if <code>initial.predictor.method = 'randomForest'</code>
with <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code>. Only applies for survival outcomes.
Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for reproducibility.
Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="catecv_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecv_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating what kind of intermediate progress messages should
be printed. <code>0</code> means no outputs. <code>1</code> means only progress bar and run time.
<code>2</code> means progress bar, run time, and all errors and warnings. Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For count response, see details in <code><a href="#topic+catecvcount">catecvcount</a>()</code>.
For survival response, see details in <code><a href="#topic+catecvsurv">catecvsurv</a>()</code>.
For continuous response, see details in <code><a href="#topic+catecvmean">catecvmean</a>()</code>.
</p>


<h3>Value</h3>

<p>For count response, see description of outputs in <code><a href="#topic+catecvcount">catecvcount</a>()</code>.
For survival response, see description of outputs in <code><a href="#topic+catecvsurv">catecvsurv</a>()</code>.
For continuous response, see description of outputs in <code><a href="#topic+catecvmean">catecvmean</a>()</code>.
</p>


<h3>References</h3>

<p>Yadlowsky, S., Pellegrini, F., Lionetto, F., Braune, S., &amp; Tian, L. (2020).
<em>Estimation and validation of ratio-based conditional average treatment effects using
observational data. Journal of the American Statistical Association, 1-18.</em>
<a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080">https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+catefit">catefit</a>()</code> function and <code><a href="graphics.html#topic+boxplot">boxplot</a>()</code>, <code><a href="#topic+abc">abc</a></code> methods for
<code>"precmed"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cate_1 &lt;- catecv(response = "count",
                 data = countExample,
                 score.method = "poisson",
                 cate.model = y ~ age + female + previous_treatment +
                              previous_cost + previous_number_relapses +
                              offset(log(years)),
                 ps.model = trt ~ age + previous_treatment,
                 higher.y = FALSE, cv.n = 5, seed = 999, verbose = 1)

plot(cate_1, ylab = "RMTL ratio of drug1 vs drug0 in each subgroup")
boxplot(cate_1, ylab = "RMTL ratio of drug1 vs drug0 in each subgroup")
abc(cate_1)

# Survival outcome
library(survival)
tau0 &lt;- with(survivalExample,
             min(quantile(y[trt == "drug1"], 0.95), quantile(y[trt == "drug0"], 0.95)))

cate_2 &lt;- catecv(response = "survival",
                 data = survivalExample,
                 score.method = c("poisson", "randomForest"),
                 cate.model = Surv(y, d) ~ age + female + previous_cost +
                              previous_number_relapses,
                 ps.model = trt ~ age + previous_treatment,
                 initial.predictor.method = "randomForest",
                 ipcw.model = ~ age + previous_cost + previous_treatment,
                 tau0 = tau0,
                 higher.y = TRUE,
                 surv.min = 0.025,
                 cv.n = 5,
                 seed = 999)

plot(cate_2, ylab = "RMTL ratio of drug1 vs drug0 in each subgroup")
boxplot(cate_2, ylab = "RMTL ratio of drug1 vs drug0 in each subgroup")
abc(cate_2)




</code></pre>

<hr>
<h2 id='catecvcount'>Cross-validation of the conditional average treatment effect (CATE) score
for count outcomes</h2><span id='topic+catecvcount'></span>

<h3>Description</h3>

<p>Provides doubly robust estimation of the average treatment effect (ATE) in
nested and mutually exclusive subgroups of patients defined by an estimated
conditional average treatment effect (CATE) score via cross-validation (CV).
The CATE score can be estimated with up to 5 methods among the following:
Poisson regression, boosting, two regressions, contrast regression, and
negative binomial (see <code>score.method</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catecvcount(
  data,
  score.method,
  cate.model,
  ps.model,
  ps.method = "glm",
  initial.predictor.method = "boosting",
  minPS = 0.01,
  maxPS = 0.99,
  higher.y = TRUE,
  prop.cutoff = seq(0.5, 1, length = 6),
  prop.multi = c(0, 1/3, 2/3, 1),
  abc = TRUE,
  train.prop = 3/4,
  cv.n = 10,
  error.max = 0.1,
  max.iter = 5000,
  xvar.smooth = NULL,
  tree.depth = 2,
  n.trees.boosting = 200,
  B = 3,
  Kfold = 5,
  error.maxNR = 0.001,
  max.iterNR = 150,
  tune = c(0.5, 2),
  seed = NULL,
  plot.gbmperf = TRUE,
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catecvcount_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome and
propensity score model; a data frame with <code>n</code> rows (1 row per
observation).</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE
score. Allowed values are: <code>'boosting'</code>, <code>'poisson'</code>,
<code>'twoReg'</code>, <code>'contrastReg'</code>, and <code>'negBin'</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score model to be fitted.
The treatment must appear on the left-hand side. The treatment must be a
numeric vector coded as 0 or 1. If data are from a randomized trial, specify
<code>ps.model</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity
score. Allowed values include one of: <code>'glm'</code> for logistic regression
with main effects only (default), or <code>'lasso'</code> for a logistic regression
with main effects and LASSO penalization on two-way interactions (added to
the model if interactions are not specified in <code>ps.model</code>). Relevant
only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get
initial outcome predictions conditional on the covariates in
<code>cate.model</code>. Only applies when <code>score.method</code> includes
<code>'twoReg'</code> or <code>'contrastReg'</code>. Allowed values include one of
<code>'poisson'</code> (fastest), <code>'boosting'</code> and <code>'gam'</code>. Default is
<code>'boosting'</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_minps">minPS</code></td>
<td>
<p>A numerical value between 0 and 1 below which estimated
propensity scores should be truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value between 0 and 1 above which estimated
propensity scores should be truncated. Must be strictly greater than
<code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or
lower (<code>FALSE</code>) values of the outcome are more desirable. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values between 0 and 1 specifying
percentiles of the estimated log CATE scores to define nested subgroups. Each
element represents the cutoff to separate observations in nested subgroups
(below vs above cutoff). The length of <code>prop.cutoff</code> is the number of
nested subgroups. An equally-spaced sequence of proportions ending with 1 is
recommended. Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_prop.multi">prop.multi</code></td>
<td>
<p>A vector of numerical values between 0 and 1 specifying
percentiles of the estimated log CATE scores to define mutually exclusive
subgroups. It should start with 0, end with 1, and be of
<code>length(prop.multi) &gt; 2</code>. Each element represents the cutoff to separate
the observations into <code>length(prop.multi) - 1</code> mutually exclusive
subgroups. Default is <code>c(0, 1/3, 2/3, 1)</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_abc">abc</code></td>
<td>
<p>A logical value indicating whether the area between curves (ABC)
should be calculated at each cross-validation iterations, for each
<code>score.method</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_train.prop">train.prop</code></td>
<td>
<p>A numerical value between 0 and 1 indicating the proportion
of total data used for training. Default is <code>3/4</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_cv.n">cv.n</code></td>
<td>
<p>A positive integer value indicating the number of
cross-validation iterations. Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_error.max">error.max</code></td>
<td>
<p>A numerical value &gt; 0 indicating the tolerance (maximum
value of error) for the largest standardized absolute difference in the
covariate distributions or in the doubly robust estimated rate ratios between
the training and validation sets. This is used to define a balanced
training-validation splitting. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_max.iter">max.iter</code></td>
<td>
<p>A positive integer value indicating the maximum number of
iterations when searching for a balanced training-validation split. Default
is <code>5,000</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_xvar.smooth">xvar.smooth</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>initial.predictor.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>cate.model</code>.
Default is <code>NULL</code>, which uses all variables in <code>cate.model</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for reproducibility.
Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating what kind of intermediate progress messages should
be printed. <code>0</code> means no outputs. <code>1</code> means only progress bar and run time.
<code>2</code> means progress bar, run time, and all errors and warnings. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="catecvcount_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>gbm()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CATE score represents an individual-level treatment effect expressed as a
rate ratio for count outcomes. It can be estimated with boosting, Poisson regression,
negative binomial regression, and the doubly robust estimator two regressions (Yadlowsky,
2020) applied separately by treatment group or with the other doubly robust estimator
contrast regression (Yadlowsky, 2020) applied to the entire data set.
</p>
<p>Internal CV is applied to reduce optimism in choosing the CATE estimation method that
captures the most treatment effect heterogeneity. The CV is applied by repeating the
following steps <code>cv.n</code> times:
</p>

<ol>
<li><p> Split the data into a training and validation set according to <code>train.prop</code>.
The training and validation sets must be balanced with respect to covariate distributions
and doubly robust rate ratio estimates (see <code>error.max</code>).
</p>
</li>
<li><p> Estimate the CATE score in the training set with the specified scoring method.
</p>
</li>
<li><p> Predict the CATE score in the validation set using the scoring model fitted from
the training set.
</p>
</li>
<li><p> Build nested subgroups of treatment responders in the training and validation sets,
separately, and estimate the ATE within each nested subgroup. For each element i of
<code>prop.cutoff</code> (e.g., <code>prop.cutoff[i]</code> = 0.6), take the following steps:
</p>

<ol>
<li><p> Identify high responders as observations with the 60%
(i.e., <code>prop.cutoff[i]</code>x100%) highest (if <code>higher.y = TRUE</code>) or
lowest (if <code>higher.y = FALSE</code>) estimated CATE scores.
</p>
</li>
<li><p> Estimate the ATE in the subgroup of high responders using a doubly robust estimator.
</p>
</li>
<li><p> Conversely, identify low responders as observations with the 40%
(i.e., 1 - <code>prop.cutoff[i]</code>x100%) lowest (if <code>higher.y</code> = TRUE) or
highest (if <code>higher.y</code> = FALSE) estimated CATE scores.
</p>
</li>
<li><p> Estimate the ATE in the subgroup of low responders using a doubly robust estimator.
</p>
</li></ol>

</li>
<li><p> If <code>abc</code> = TRUE, calculate the area between the ATE and the series of ATEs in
nested subgroups of high responders in the validation set.
</p>
</li>
<li><p> Build mutually exclusive subgroups of treatment responders in the training and
validation sets, separately, and estimate the ATE within each subgroup. Mutually exclusive
subgroups are built by splitting the estimated CATE scores according to <code>prop.multi</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a list containing the following components saved as a <code>"precmed"</code> object:
</p>

<ul>
<li><p><code>ate.poisson</code>: A list of results output if <code>score.method</code> includes
<code>'poisson'</code>:
</p>

<ul>
<li><p><code>ate.est.train.high.cv</code>: A matrix of numerical values with
<code>length(prop.cutoff)</code> rows and <code>cv.n</code> columns.
The ith row/jth column cell contains the estimated ATE in the nested subgroup of high responders
defined by CATE score above (if <code>higher.y = TRUE</code>) or below (if <code>higher.y = FALSE</code>) the
<code>prop.cutoff[i]</code>x100% percentile of the estimated CATE score in the training set in the jth
cross-validation iteration.
</p>
</li>
<li><p><code>ate.est.train.low.cv</code>: A matrix of numerical values with
<code>length(prop.cutoff) - 1</code> rows and <code>cv.n</code> columns.
The ith row/jth column cell contains the estimated ATE in the nested subgroup of low responders
defined by CATE score below (if <code>higher.y = TRUE</code>) or above (if <code>higher.y = FALSE</code>) the
<code>prop.cutoff[i]</code>x100% percentile of the estimated CATE score in the training set in the jth
cross-validation iteration.
</p>
</li>
<li><p><code>ate.est.valid.high.cv</code>: Same as <code>ate.est.train.high.cv</code>,
but in the validation set.
</p>
</li>
<li><p><code>ate.est.valid.low.cv</code>: Same as <code>ate.est.train.low.cv</code>,
but in the validation set.
</p>
</li>
<li><p><code>ate.est.train.group.cv</code>: A matrix of numerical values with
<code>length(prop.multi) - 1</code> rows and <code>cv.n</code> columns.
The jth column contains the estimated ATE in <code>length(prop.multi) - 1</code>
mutually exclusive subgroups defined by <code>prop.multi</code> in the training set in jth
cross-validation iteration.
</p>
</li>
<li><p><code>ate.est.valid.group.cv</code>: Same as <code>ate.est.train.group.cv</code>, but in the
validation set.
</p>
</li>
<li><p><code>abc.valid</code>: A vector of numerical values of length <code>cv.n</code>.
The ith element returns the ABC of the validation curve in the ith cross-validation
iteration. Only returned if <code>abc = TRUE</code>.
</p>
</li></ul>

</li>
<li><p><code>ate.boosting</code>: A list of results similar to <code>ate.poisson</code> output
if <code>score.method</code> includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>ate.twoReg</code>: A list of results similar to <code>ate.poisson</code> output
if <code>score.method</code> includes <code>'twoReg'</code>.
</p>
</li>
<li><p><code>ate.contrastReg</code>: A list of results similar to <code>ate.poisson</code> output
if <code>score.method</code> includes <code>'contrastReg'</code>.
This method has an additional element in the list of results:
</p>

<ul>
<li><p><code>converge.contrastReg.cv</code>: A vector of logical value of length <code>cv.n</code>.
The ith element indicates whether the algorithm converged in the ith cross-validation
iteration.
</p>
</li></ul>

</li>
<li><p><code>ate.negBin</code>: A list of results similar to <code>ate.poisson</code> output
if <code>score.method</code> includes <code>'negBin'</code>.
</p>
</li>
<li><p><code>props</code>: A list of 3 elements:
</p>

<ul>
<li><p><code>prop.onlyhigh</code>: The original argument <code>prop.cutoff</code>,
reformatted as necessary.
</p>
</li>
<li><p><code>prop.bi</code>: The original argument <code>prop.cutoff</code>,
similar to <code>prop.onlyhigh</code> but reformatted to exclude 1.
</p>
</li>
<li><p><code>prop.multi</code>: The original argument <code>prop.multi</code>,
reformatted as necessary to include 0 and 1.
</p>
</li></ul>

</li>
<li><p><code>overall.ate.valid</code>: A vector of numerical values of length <code>cv.n</code>.
The ith element contains the ATE in the validation set of the ith cross-validation
iteration, estimated with the doubly robust estimator.
</p>
</li>
<li><p><code>overall.ate.train</code>: A vector of numerical values of length <code>cv.n</code>.
The ith element contains the ATE in the training set of the ith cross-validation
iteration, estimated with the doubly robust estimator.
</p>
</li>
<li><p><code>fgam</code>: The formula used in GAM if <code>initial.predictor.method = 'gam'</code>.
</p>
</li>
<li><p><code>higher.y</code>: The original <code>higher.y</code> argument.
</p>
</li>
<li><p><code>abc</code>: The original <code>abc</code> argument.
</p>
</li>
<li><p><code>cv.n</code>: The original <code>cv.n</code> argument.
</p>
</li>
<li><p><code>response</code>: The type of response. Always 'count' for this function.
</p>
</li>
<li><p><code>formulas</code>:A list of 3 elements: (1) <code>cate.model</code> argument,
(2) <code>ps.model</code> argument and (3) original labels of the left-hand side variable in
<code>ps.model</code> (treatment) if it was not 0/1.
</p>
</li></ul>



<h3>References</h3>

<p>Yadlowsky, S., Pellegrini, F., Lionetto, F., Braune, S., &amp; Tian, L. (2020).
<em>Estimation and validation of ratio-based conditional average treatment
effects using observational data. Journal of the American Statistical
Association, 1-18.</em>
<a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080">https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.precmed">plot.precmed</a>()</code>, <code><a href="#topic+boxplot.precmed">boxplot.precmed</a>()</code>,
<code><a href="#topic+abc">abc</a>()</code> methods for <code>"precmed"</code> objects,
and <code><a href="#topic+catefitcount">catefitcount</a>()</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
catecv &lt;- catecvcount(data = countExample,
                      score.method = "poisson",
                      cate.model = y ~ age + female + previous_treatment +
                                   previous_cost + previous_number_relapses +
                                   offset(log(years)),
                      ps.model = trt ~ age + previous_treatment,
                      higher.y = FALSE,
                      cv.n = 5,
                      seed = 999,
                      plot.gbmperf = FALSE,
                      verbose = 1)

plot(catecv, ylab = "Rate ratio of drug1 vs drug0 in each subgroup")
boxplot(catecv, ylab = "Rate ratio of drug1 vs drug0 in each subgroup")
abc(catecv)

</code></pre>

<hr>
<h2 id='catecvmean'>Cross-validation of the conditional average treatment effect (CATE) score for continuous outcomes</h2><span id='topic+catecvmean'></span>

<h3>Description</h3>

<p>Provides doubly robust estimation of the average treatment effect (ATE) in nested and
mutually exclusive subgroups of patients defined by an estimated conditional average
treatment effect (CATE) score via cross-validation (CV). The CATE score can be estimated
with up to 6 methods among the following: Linear regression, boosting, two regressions,
contrast regression, random forest and generalized additive model (see <code>score.method</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catecvmean(
  data,
  score.method,
  cate.model,
  ps.model,
  ps.method = "glm",
  init.model = NULL,
  initial.predictor.method = "boosting",
  minPS = 0.01,
  maxPS = 0.99,
  higher.y = TRUE,
  prop.cutoff = seq(0.5, 1, length = 6),
  prop.multi = c(0, 1/3, 2/3, 1),
  abc = TRUE,
  train.prop = 3/4,
  cv.n = 10,
  error.max = 0.1,
  max.iter = 5000,
  xvar.smooth.score = NULL,
  xvar.smooth.init = NULL,
  tree.depth = 2,
  n.trees.rf = 1000,
  n.trees.boosting = 200,
  B = 3,
  Kfold = 6,
  plot.gbmperf = TRUE,
  error.maxNR = 0.001,
  tune = c(0.5, 2),
  seed = NULL,
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catecvmean_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome and propensity score models;
a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'gaussian'</code>, <code>'twoReg'</code>, <code>'contrastReg'</code>,
<code>'randomForest'</code>, <code>'gam'</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score model to be fitted.
The treatment must appear on the left-hand side. The treatment must be a numeric vector
coded as 0/1. If data are from a RCT, specify <code>ps.model</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_init.model">init.model</code></td>
<td>
<p>A formula describing the initial predictor model. The outcome must appear on the left-hand side.
It must be specified when <code>score.method = contrastReg</code> or <code>twoReg</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates in <code>cate.model</code>
in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Allowed values include
one of <code>'poisson'</code> (fastest), <code>'boosting'</code> and <code>'gam'</code>.
Default is <code>'boosting'</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or lower (<code>FALSE</code>)
values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_prop.multi">prop.multi</code></td>
<td>
<p>A vector of numerical values (in [0, 1]) specifying percentiles of the
estimated CATE scores to define mutually exclusive subgroups.
It should start with 0, end with 1, and be of <code>length(prop.multi) &gt; 2</code>.
Each element represents the cutoff to separate the observations into
<code>length(prop.multi) - 1</code> mutually exclusive subgroups.
Default is <code>c(0, 1/3, 2/3, 1)</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_abc">abc</code></td>
<td>
<p>A logical value indicating whether the area between curves (ABC) should be calculated
at each cross-validation iterations, for each <code>score.method</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_train.prop">train.prop</code></td>
<td>
<p>A numerical value (in (0, 1)) indicating the proportion of total data used
for training. Default is <code>3/4</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_cv.n">cv.n</code></td>
<td>
<p>A positive integer value indicating the number of cross-validation iterations.
Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_error.max">error.max</code></td>
<td>
<p>A numerical value &gt; 0 indicating the tolerance (maximum value of error)
for the largest standardized absolute difference in the covariate distributions or in the
doubly robust estimated rate ratios between the training and validation sets. This is used
to define a balanced training-validation splitting. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_max.iter">max.iter</code></td>
<td>
<p>A positive integer value indicating the maximum number of iterations when
searching for a balanced training-validation split. Default is <code>5,000</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_xvar.smooth.score">xvar.smooth.score</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>score.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>cate.model</code>.
Default is <code>NULL</code>, which uses all variables in <code>cate.model</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_xvar.smooth.init">xvar.smooth.init</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>initial.predictor.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>init.model</code>.
Default is <code>NULL</code>, which uses all variables in <code>init.model</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_n.trees.rf">n.trees.rf</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in random forest.
Used if <code>score.method = 'ranfomForest'</code> or if <code>initial.predictor.method = 'randomForest'</code>
with <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code>. Only applies for survival outcomes.
Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds (parts) used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>6</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for reproducibility.
Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating what kind of intermediate progress messages should
be printed. <code>0</code> means no outputs. <code>1</code> means only progress bar and run time.
<code>2</code> means progress bar, run time, and all errors and warnings. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="catecvmean_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>gbm()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CATE score represents an individual-level treatment effect for continuous data,
estimated with boosting, linear regression, random forest, generalized additive model and the doubly
robust estimator (two regressions, Yadlowsky, 2020) applied separately by treatment group
or with the other doubly robust estimators (contrast regression, Yadlowsky, 2020) applied
to the entire data set.
</p>
<p>Internal CV is applied to reduce optimism in choosing the CATE estimation method that
captures the most treatment effect heterogeneity. The CV is applied by repeating the
following steps <code>cv.n</code> times:
</p>

<ol>
<li><p> Split the data into a training and validation set according to <code>train.prop</code>.
The training and validation sets must be balanced with respect to covariate distributions
and doubly robust rate ratio estimates (see <code>error.max</code>).
</p>
</li>
<li><p> Estimate the CATE score in the training set with the specified scoring method.
</p>
</li>
<li><p> Predict the CATE score in the validation set using the scoring model fitted from
the training set.
</p>
</li>
<li><p> Build nested subgroups of treatment responders in the training and validation sets,
separately, and estimate the ATE within each nested subgroup. For each element i of
<code>prop.cutoff</code> (e.g., <code>prop.cutoff[i]</code> = 0.6), take the following steps:
</p>

<ol>
<li><p> Identify high responders as observations with the 60%
(i.e., <code>prop.cutoff[i]</code>x100%) highest (if <code>higher.y = TRUE</code>) or
lowest (if <code>higher.y = FALSE</code>) estimated CATE scores.
</p>
</li>
<li><p> Estimate the ATE in the subgroup of high responders using a doubly robust estimator.
</p>
</li>
<li><p> Conversely, identify low responders as observations with the 40%
(i.e., 1 - <code>prop.cutoff[i]</code>x100%) lowest (if <code>higher.y</code> = TRUE) or
highest (if <code>higher.y</code> = FALSE) estimated CATE scores.
</p>
</li>
<li><p> Estimate the ATE in the subgroup of low responders using a doubly robust estimator.
</p>
</li></ol>

</li>
<li><p> Build mutually exclusive subgroups of treatment responders in the training and
validation sets, separately, and estimate the ATE within each subgroup. Mutually exclusive
subgroups are built by splitting the estimated CATE scores according to <code>prop.multi</code>.
</p>
</li>
<li><p> If <code>abc</code> = TRUE, calculate the area between the ATE and the series of ATEs in
nested subgroups of high responders in the validation set.
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a list containing the following components saved as a <code>"precmed"</code> object:
</p>

<ul>
<li><p><code>ate.gaussian</code>: A list of results output if <code>score.method</code> includes
<code>'gaussian'</code>:
</p>

<ul>
<li><p><code>ate.est.train.high.cv</code>: A matrix of numerical values with
<code>length(prop.cutoff)</code> rows and <code>cv.n</code> columns.
The ith column/jth row cell contains the estimated ATE in the nested subgroup of high responders
defined by CATE score above (if <code>higher.y = TRUE</code>) or below (if <code>higher.y = FALSE</code>) the
<code>prop.cutoff[j]</code>x100% percentile of the estimated CATE score in the training set in the ith
cross-validation iteration.
</p>
</li>
<li><p><code>ate.est.train.low.cv</code>: A matrix of numerical values with
<code>length(prop.cutoff) - 1</code> rows and <code>cv.n</code> columns.
The ith column/jth row cell contains the estimated ATE in the nested subgroup of low responders
defined by CATE score below (if <code>higher.y = TRUE</code>) or above (if <code>higher.y = FALSE</code>) the
<code>prop.cutoff[j]</code>x100% percentile of the estimated CATE score in the training set in the ith
cross-validation iteration.
</p>
</li>
<li><p><code>ate.est.valid.high.cv</code>: Same as <code>ate.est.train.high.cv</code>,
but in the validation set.
</p>
</li>
<li><p><code>ate.est.valid.low.cv</code>: Same as <code>ate.est.train.low.cv</code>,
but in the validation set.
</p>
</li>
<li><p><code>ate.est.train.group.cv</code>: A matrix of numerical values with
<code>length(prop.multi) - 1</code> rows and <code>cv.n</code> columns.
The ith column contains the estimated ATE in <code>length(prop.multi) - 1</code>
mutually exclusive subgroups defined by <code>prop.multi</code> in the training set in ith
cross-validation iteration.
</p>
</li>
<li><p><code>ate.est.valid.group.cv</code>: Same as <code>ate.est.train.group.cv</code>, but in the
validation set.
</p>
</li>
<li><p><code>abc.valid</code>: A vector of numerical values of length <code>cv.n</code>,
The ith element returns the ABC of the validation curve in the ith cross-validation
iteration. Only returned if <code>abc = TRUE</code>.
</p>
</li></ul>

</li>
<li><p><code>ate.boosting</code>: A list of results similar to <code>ate.gaussian</code> output
if <code>score.method</code> includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>ate.twoReg</code>: A list of results similar to <code>ate.gaussian</code> output
if <code>score.method</code> includes <code>'twoReg'</code>.
</p>
</li>
<li><p><code>ate.contrastReg</code>: A list of results similar to <code>ate.gaussian</code> output
if <code>score.method</code> includes <code>'contrastReg'</code>.
</p>
</li>
<li><p><code>ate.randomForest</code>: A list of results similar to <code>ate.gaussian</code> output
if <code>score.method</code> includes <code>'randomForest'</code>.
</p>
</li>
<li><p><code>ate.gam</code>: A list of results similar to <code>ate.gaussian</code> output
if <code>score.method</code> includes <code>'gam'</code>.
</p>
</li>
<li><p><code>props</code>: A list of 3 elements:
</p>

<ul>
<li><p><code>prop.onlyhigh</code>: The original argument <code>prop.cutoff</code>,
reformatted as necessary.
</p>
</li>
<li><p><code>prop.bi</code>: The original argument <code>prop.cutoff</code>,
similar to <code>prop.onlyhigh</code> but reformatted to exclude 1.
</p>
</li>
<li><p><code>prop.multi</code>: The original argument <code>prop.multi</code>,
reformatted as necessary.
</p>
</li></ul>

</li>
<li><p><code>overall.ate.train</code>: A vector of numerical values of length <code>cv.n</code>.
The ith element contains the ATE in the training set of the ith cross-validation
iteration, estimated with the doubly robust estimator.
</p>
</li>
<li><p><code>overall.ate.valid</code>: A vector of numerical values of length <code>cv.n</code>.
The ith element contains the ATE in the validation set of the ith cross-validation
iteration, estimated with the doubly robust estimator.
</p>
</li>
<li><p><code>higher.y</code>: The original <code>higher.y</code> argument.
</p>
</li>
<li><p><code>abc</code>: The original <code>abc</code> argument.
</p>
</li>
<li><p><code>cv.n</code>: The original <code>cv.n</code> argument.
</p>
</li>
<li><p><code>response</code>: The type of response. Always 'continuous' for this function.
</p>
</li>
<li><p><code>formulas</code>:A list of 3 elements: (1) <code>cate.model</code> argument,
(2) <code>ps.model</code> argument and (3) original labels of the left-hand side variable in
<code>ps.model</code> (treatment) if it was not 0/1.
</p>
</li></ul>



<h3>References</h3>

<p>Yadlowsky, S., Pellegrini, F., Lionetto, F., Braune, S., &amp; Tian, L. (2020).
<em>Estimation and validation of ratio-based conditional average treatment effects using
observational data. Journal of the American Statistical Association, 1-18.</em>
<a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080">https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.precmed">plot.precmed</a>()</code>, <code><a href="#topic+boxplot.precmed">boxplot.precmed</a>()</code>, <code><a href="#topic+abc">abc</a>()</code> methods for <code>"precmed"</code> objects,
and <code><a href="#topic+catefitmean">catefitmean</a>()</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not implemented yet!

</code></pre>

<hr>
<h2 id='catecvsurv'>Cross-validation of the conditional average treatment effect (CATE) score for survival outcomes</h2><span id='topic+catecvsurv'></span>

<h3>Description</h3>

<p>Provides doubly robust estimation of the average treatment effect (ATE) by the
RMTL (restricted mean time lost) ratio in nested and mutually exclusive subgroups of patients
defined by an estimated conditional average treatment effect (CATE) score via
cross-validation (CV). The CATE score can be estimated with up to 5 methods among the following:
Random forest, boosting, poisson regression, two regressions, and contrast regression
(see <code>score.method</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catecvsurv(
  data,
  score.method,
  cate.model,
  ps.model,
  ps.method = "glm",
  initial.predictor.method = "randomForest",
  ipcw.model = NULL,
  ipcw.method = "breslow",
  minPS = 0.01,
  maxPS = 0.99,
  followup.time = NULL,
  tau0 = NULL,
  higher.y = TRUE,
  prop.cutoff = seq(0.5, 1, length = 6),
  prop.multi = c(0, 1/3, 2/3, 1),
  abc = TRUE,
  train.prop = 3/4,
  cv.n = 10,
  error.max = 0.1,
  max.iter = 5000,
  surv.min = 0.025,
  tree.depth = 2,
  n.trees.rf = 1000,
  n.trees.boosting = 200,
  B = 3,
  Kfold = 5,
  error.maxNR = 0.001,
  max.iterNR = 150,
  tune = c(0.5, 2),
  seed = NULL,
  plot.gbmperf = TRUE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catecvsurv_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome, propensity score, and inverse
probability of censoring models (if specified); a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'randomForest'</code>, <code>'boosting'</code>, <code>'poisson'</code>, <code>'twoReg'</code>, and
<code>'contrastReg'</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_cate.model">cate.model</code></td>
<td>
<p>A standard <code>Surv</code> formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score (PS) model to be fitted. The treatment must
appear on the left-hand side. The treatment must be a numeric vector coded as 0/1.
If data are from a randomized controlled trial, specify <code>ps.model = ~1</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates specified in <code>cate.model</code>. Only applies
when <code>score.method</code> includes <code>'twoReg'</code> or <code>'contrastReg'</code>. Allowed values include
one of <code>'randomForest'</code>, <code>'boosting'</code> and <code>'logistic'</code> (fastest).
Default is <code>'randomForest'</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_ipcw.model">ipcw.model</code></td>
<td>
<p>A formula describing the inverse probability of censoring weighting (IPCW)
model to be fitted. The left-hand side must be empty. Default is <code>ipcw.model = NULL</code>,
which corresponds to specifying the IPCW model with the same covariates as the outcome model
<code>cate.model</code> plus the treatment.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>A character value for the censoring model. Allowed values are:
<code>'breslow'</code> (Cox regression with Breslow estimator of the baseline survivor function),
<code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>, <code>'aft (lognormal)'</code>
or <code>'aft (loglogistic)'</code> (accelerated failure time model with different distributions for
y variable). Default is <code>'breslow'</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_followup.time">followup.time</code></td>
<td>
<p>A column name in <code>data</code> specifying the maximum follow-up time,
interpreted as the potential censoring time. Default is <code>followup.time = NULL</code>,
which corresponds to unknown potential censoring time.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost. Default is <code>NULL</code>,
which corresponds to setting the truncation time as the maximum survival time in the data.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or
lower (<code>FALSE</code>) values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated log CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_prop.multi">prop.multi</code></td>
<td>
<p>A vector of numerical values (in [0, 1]) specifying percentiles of the
estimated log CATE scores to define mutually exclusive subgroups.
It should start with 0, end with 1, and be of <code>length(prop.multi) &gt; 2</code>.
Each element represents the cutoff to separate the observations into
<code>length(prop.multi) - 1</code> mutually exclusive subgroups.
Default is <code>c(0, 1/3, 2/3, 1)</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_abc">abc</code></td>
<td>
<p>A logical value indicating whether the area between curves (ABC) should be calculated
at each cross-validation iterations, for each <code>score.method</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_train.prop">train.prop</code></td>
<td>
<p>A numerical value (in (0, 1)) indicating the proportion of total data used
for training. Default is <code>3/4</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_cv.n">cv.n</code></td>
<td>
<p>A positive integer value indicating the number of cross-validation iterations.
Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_error.max">error.max</code></td>
<td>
<p>A numerical value &gt; 0 indicating the tolerance (maximum value of error)
for the largest standardized absolute difference in the covariate distributions or in the
doubly robust estimated rate ratios between the training and validation sets. This is used
to define a balanced training-validation splitting. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_max.iter">max.iter</code></td>
<td>
<p>A positive integer value indicating the maximum number of iterations when
searching for a balanced training-validation split. Default is <code>5,000</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for the probability of being censored.
It must be a positive value and should be chosen close to 0. Default is <code>0.025</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_n.trees.rf">n.trees.rf</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in random forest.
Used if <code>score.method = 'ranfomForest'</code> or if <code>initial.predictor.method = 'randomForest'</code>
with <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code>. Only applies for survival outcomes.
Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for reproducibility.
Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catecvsurv_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating what kind of intermediate progress messages should
be printed. <code>0</code> means no outputs. <code>1</code> means only progress bar and run time.
<code>2</code> means progress bar, run time, and all errors and warnings. Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CATE score represents an individual-level treatment effect expressed as the
restricted mean survival time (RMTL) ratio) for survival outcomes. It can be estimated with boosting,
Poisson regression, random forest, and the doubly robust estimator two regressions (Yadlowsky, 2020)
applied separately by treatment group or with the other doubly robust estimator contrast regression
(Yadlowsky, 2020) applied to the entire data set.
</p>
<p>Internal CV is applied to reduce optimism in choosing the CATE estimation method that
captures the most treatment effect heterogeneity. The CV is applied by repeating the
following steps <code>cv.n</code> times:
</p>

<ol>
<li><p> Split the data into a training and validation set according to <code>train.prop</code>.
The training and validation sets must be balanced with respect to covariate distributions
and doubly robust RMTL ratio estimates (see <code>error.max</code>).
</p>
</li>
<li><p> Estimate the CATE score in the training set with the specified scoring method.
</p>
</li>
<li><p> Predict the CATE score in the validation set using the scoring model fitted from
the training set.
</p>
</li>
<li><p> Build nested subgroups of treatment responders in the training and validation sets,
separately, and estimate the ATE within each nested subgroup. For each element i of
<code>prop.cutoff</code> (e.g., <code>prop.cutoff[i]</code> = 0.6), take the following steps:
</p>

<ol>
<li><p> Identify high responders as observations with the 60%
(i.e., <code>prop.cutoff[i]</code>x100%) highest (if <code>higher.y = FALSE</code>) or
lowest (if <code>higher.y = TRUE</code>) estimated CATE scores.
</p>
</li>
<li><p> Estimate the ATE in the subgroup of high responders using a doubly robust estimator.
</p>
</li>
<li><p> Conversely, identify low responders as observations with the 40%
(i.e., 1 - <code>prop.cutoff[i]</code>x100%) lowest (if <code>higher.y</code> = FALSE) or
highest (if <code>higher.y</code> = TRUE) estimated CATE scores.
</p>
</li>
<li><p> Estimate the ATE in the subgroup of low responders using a doubly robust estimator.
</p>
</li></ol>

</li>
<li><p> If <code>abc</code> = TRUE, calculate the area between the ATE and the series of ATEs in
nested subgroups of high responders in the validation set.
</p>
</li>
<li><p> Build mutually exclusive subgroups of treatment responders in the training and
validation sets, separately, and estimate the ATE within each subgroup. Mutually exclusive
subgroups are built by splitting the estimated CATE scores according to <code>prop.multi</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a list containing the following components saved as a <code>"precmed"</code> object:
</p>

<ul>
<li><p><code>ate.randomForest</code>: A list of ATE output measured by the RMTL ratio if
<code>score.method</code> includes <code>'randomForest'</code>:
</p>

<ul>
<li><p><code>ate.est.train.high.cv</code>: A matrix of numerical values with
<code>length(prop.cutoff)</code> rows and <code>cv.n</code> columns.
The ith column/jth row cell contains the estimated ATE in the nested subgroup of high responders
defined by CATE score above (if <code>higher.y = FALSE</code>) or below (if <code>higher.y = TRUE</code>) the
<code>prop.cutoff[j]</code>x100% percentile of the estimated CATE score in the training set in the ith
cross-validation iteration.
</p>
</li>
<li><p><code>ate.est.train.low.cv</code>: A matrix of numerical values with
<code>length(prop.cutoff) - 1</code> rows and <code>cv.n</code> columns.
TThe ith column/jth row cell contains the estimated ATE in the nested subgroup of low responders
defined by CATE score below (if <code>higher.y = FALSE</code>) or above (if <code>higher.y = TRUE</code>) the
<code>prop.cutoff[j]</code>x100% percentile of the estimated CATE score in the training set in the ith
cross-validation iteration.
</p>
</li>
<li><p><code>ate.est.valid.high.cv</code>: Same as <code>ate.est.train.high.cv</code>,
but in the validation set.
</p>
</li>
<li><p><code>ate.est.valid.low.cv</code>: Same as <code>ate.est.train.low.cv</code>,
but in the validation set.
</p>
</li>
<li><p><code>ate.est.train.group.cv</code>: A matrix of numerical values with
<code>length(prop.multi) - 1</code> rows and <code>cv.n</code> columns.
The ith column contains the estimated ATE in <code>length(prop.multi) - 1</code>
mutually exclusive subgroups defined by <code>prop.multi</code> in the training set in ith
cross-validation iteration.
</p>
</li>
<li><p><code>ate.est.valid.group.cv</code>: Same as <code>ate.est.train.group.cv</code>, but in the
validation set.
</p>
</li>
<li><p><code>abc.valid</code>: A vector of numerical values of length <code>cv.n</code>,
The ith element returns the ABC of the validation curve in the ith cross-validation
iteration. Only returned if <code>abc = TRUE</code>.
</p>
</li></ul>

</li>
<li><p><code>ate.boosting</code>: A list of results similar to <code>ate.randomForest</code> output
if <code>score.method</code> includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>ate.poisson</code>: A list of results similar to <code>ate.randomForest</code> output
if <code>score.method</code> includes <code>'poisson'</code>.
</p>
</li>
<li><p><code>ate.twoReg</code>: A list of results similar to <code>ate.randomForest</code> output
if <code>score.method</code> includes <code>'twoReg'</code>.
</p>
</li>
<li><p><code>ate.contrastReg</code>: A list of results similar to <code>ate.randomForest</code> output
if <code>score.method</code> includes <code>'contrastReg'</code>.
This method has an additional element in the list of results:
</p>

<ul>
<li><p><code>converge.contrastReg.cv</code>: A vector of logical value of length <code>cv.n</code>.
The ith element indicates whether the algorithm converged in the ith cross-validation
iteration.
</p>
</li></ul>

</li>
<li><p><code>hr.randomForest</code>: A list of adjusted hazard ratio if <code>score.method</code> includes
<code>'randomForest'</code>:
</p>

<ul>
<li><p><code>hr.est.train.high.cv</code>: A matrix of numerical values with
<code>length(prop.cutoff)</code> rows and <code>cv.n</code> columns.
The ith column/jth row cell contains the estimated HR in the nested subgroup of high responders
defined by CATE score above (if <code>higher.y = FALSE</code>) or below (if <code>higher.y = TRUE</code>) the
<code>prop.cutoff[j]</code>x100% percentile of the estimated CATE score in the training set in the ith
cross-validation iteration.
</p>
</li>
<li><p><code>hr.est.train.low.cv</code>: A matrix of numerical values with
<code>length(prop.cutoff) - 1</code> rows and <code>cv.n</code> columns.
TThe ith column/jth row cell contains the estimated HR in the nested subgroup of low responders
defined by CATE score below (if <code>higher.y = FALSE</code>) or above (if <code>higher.y = TRUE</code>) the
<code>prop.cutoff[j]</code>x100% percentile of the estimated CATE score in the training set in the ith
cross-validation iteration.
</p>
</li>
<li><p><code>hr.est.valid.high.cv</code>: Same as <code>hr.est.train.high.cv</code>,
but in the validation set.
</p>
</li>
<li><p><code>hr.est.valid.low.cv</code>: Same as <code>hr.est.train.low.cv</code>,
but in the validation set.
</p>
</li>
<li><p><code>hr.est.train.group.cv</code>: A matrix of numerical values with
<code>length(prop.multi) - 1</code> rows and <code>cv.n</code> columns.
The ith column contains the estimated HR in <code>length(prop.multi) - 1</code>
mutually exclusive subgroups defined by <code>prop.multi</code> in the training set in ith
cross-validation iteration.
</p>
</li>
<li><p><code>hr.est.valid.group.cv</code>: Same as <code>hr.est.train.group.cv</code>, but in the
validation set.
</p>
</li></ul>

</li>
<li><p><code>hr.boosting</code>: A list of results similar to <code>hr.randomForest</code> output
if <code>score.method</code> includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>hr.poisson</code>: A list of results similar to <code>hr.randomForest</code> output
if <code>score.method</code> includes <code>'poisson'</code>.
</p>
</li>
<li><p><code>hr.twoReg</code>: A list of results similar to <code>hr.randomForest</code> output
if <code>score.method</code> includes <code>'twoReg'</code>.
</p>
</li>
<li><p><code>hr.contrastReg</code>: A list of results similar to <code>hr.randomForest</code> output
if <code>score.method</code> includes <code>'contrastReg'</code>.
</p>
<p><code>props</code>: A list of 3 elements:
</p>

<ul>
<li><p><code>prop.onlyhigh</code>: The original argument <code>prop.cutoff</code>,
reformatted as necessary.
</p>
</li>
<li><p><code>prop.bi</code>: The original argument <code>prop.cutoff</code>,
similar to <code>prop.onlyhigh</code> but reformatted to exclude 1.
</p>
</li>
<li><p><code>prop.multi</code>: The original argument <code>prop.multi</code>,
reformatted as necessary to include 0 and 1.
</p>
</li></ul>

<p><code>overall.ate.train</code>: A vector of numerical values of length <code>cv.n</code>.
The ith element contains the ATE (RMTL ratio) in the training set of the ith cross-validation
iteration, estimated with the doubly robust estimator.
</p>
<p><code>overall.hr.train</code>: A vector of numerical values of length <code>cv.n</code>.
The ith element contains the ATE (HR) in the training set of the ith cross-validation
iteration.
</p>
<p><code>overall.ate.valid</code>: A vector of numerical values of length <code>cv.n</code>.
The ith element contains the ATE (RMTL ratio) in the validation set of the ith cross-validation
iteration, estimated with the doubly robust estimator.
</p>
<p><code>overall.hr.valid</code>: A vector of numerical values of length <code>cv.n</code>.
The ith element contains the ATE (HR) in the validation set of the ith cross-validation
iteration.
</p>
<p><code>errors/warnings</code>: A nested list of errors and warnings that were wrapped during the
calculation of ATE. Errors and warnings are organized by <code>score.method</code> and
position in the CV flow.
</p>
<p><code>higher.y</code>: The original <code>higher.y</code> argument.
</p>
<p><code>abc</code>: The original <code>abc</code> argument.
</p>
<p><code>cv.n</code>: The original <code>cv.n</code> argument.
</p>
<p><code>response</code>: The type of response. Always 'survival' for this function.
</p>
<p><code>formulas</code>:A list of 3 elements: (1) <code>cate.model</code> argument,
(2) <code>ps.model</code> argument and (3) original labels of the left-hand side variable in
<code>ps.model</code> (treatment) if it was not 0/1.

</p>
</li></ul>



<h3>References</h3>

<p>Yadlowsky, S., Pellegrini, F., Lionetto, F., Braune, S., &amp; Tian, L. (2020).
<em>Estimation and validation of ratio-based conditional average treatment effects using
observational data. Journal of the American Statistical Association, 1-18.</em>
<a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080">https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+catefitsurv">catefitsurv</a>()</code> function and <code><a href="graphics.html#topic+boxplot">boxplot</a>()</code>, <code><a href="#topic+abc">abc</a></code> methods for
<code>"precmed"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)

tau0 &lt;- with(survivalExample,
             min(quantile(y[trt == "drug1"], 0.95), quantile(y[trt == "drug0"], 0.95)))

catecv &lt;- catecvsurv(data = survivalExample,
                     score.method = "poisson",
                     cate.model = Surv(y, d) ~ age + female + previous_cost +
                                               previous_number_relapses,
                     ps.model = trt ~ age + previous_treatment,
                     initial.predictor.method = "logistic",
                     ipcw.model = ~ age + previous_cost + previous_treatment,
                     tau0 = tau0,
                     higher.y = TRUE,
                     cv.n = 5, seed = 999, verbose = 1)

# Try:
plot(catecv, ylab = "RMTL ratio of drug1 vs drug0 in each subgroup")
boxplot(catecv, ylab = "RMTL ratio of drug1 vs drug0 in each subgroup")
abc(catecv)

</code></pre>

<hr>
<h2 id='catefit'>Estimation of the conditional average treatment effect (CATE) score for count, survival and continuous data</h2><span id='topic+catefit'></span>

<h3>Description</h3>

<p>Provides singly robust and doubly robust estimation of CATE score for count, survival and continuous data with
up the following scoring methods among the following: Random forest (survival, continuous only), boosting,
poisson regression (count, survival only), two regressions, contrast regression, negative binomial regression (count only),
linear regression (continuous only), and generalized additive model (continuous only).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catefit(
  response,
  data,
  score.method,
  cate.model,
  ps.model,
  ps.method = "glm",
  init.model = NULL,
  initial.predictor.method = NULL,
  ipcw.model = NULL,
  ipcw.method = "breslow",
  minPS = 0.01,
  maxPS = 0.99,
  followup.time = NULL,
  tau0 = NULL,
  higher.y = TRUE,
  prop.cutoff = seq(0.5, 1, length = 6),
  surv.min = 0.025,
  xvar.smooth.score = NULL,
  xvar.smooth.init = NULL,
  tree.depth = 2,
  n.trees.rf = 1000,
  n.trees.boosting = 200,
  B = 3,
  Kfold = 5,
  error.maxNR = 0.001,
  max.iterNR = 150,
  tune = c(0.5, 2),
  seed = NULL,
  plot.gbmperf = TRUE,
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catefit_+3A_response">response</code></td>
<td>
<p>A string describing the type of outcome in the data. Allowed values include
&quot;count&quot; (see <code><a href="#topic+catecvcount">catecvcount</a>()</code>), &quot;survival&quot; (see <code><a href="#topic+catecvsurv">catecvsurv</a>()</code>) and &quot;continuous&quot; (see <code><a href="#topic+catecvmean">catecvmean</a>()</code>).</p>
</td></tr>
<tr><td><code id="catefit_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome, propensity score, and inverse
probability of censoring models (if specified); a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="catefit_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'twoReg'</code>, <code>'contrastReg'</code>, <code>'poisson'</code> (count and survival outcomes only),
<code>'randomForest'</code> (survival, continuous outcomes only), <code>negBin</code> (count outcomes only), <code>'gam'</code> (continuous outcomes only),
<code>'gaussian'</code> (continuous outcomes only).</p>
</td></tr>
<tr><td><code id="catefit_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side. For survival outcomes, a <code>Surv</code> object
must be used to describe the outcome.</p>
</td></tr>
<tr><td><code id="catefit_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score (PS) model to be fitted. The treatment must
appear on the left-hand side. The treatment must be a numeric vector coded as 0/1.
If data are from a randomized controlled trial, specify <code>ps.model = ~1</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="catefit_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="catefit_+3A_init.model">init.model</code></td>
<td>
<p>A formula describing the initial predictor model. The outcome must appear on the left-hand side.
It must be specified when <code>score.method = contrastReg</code> or <code>twoReg</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates specified in <code>cate.model</code>. Only applies
when <code>score.method</code> includes <code>'twoReg'</code> or <code>'contrastReg'</code>.Allowed values include one of
<code>'randomForest'</code> (survival outcomes only), <code>'boosting'</code>, <code>'logistic'</code>
(survival outcomes only, fast), <code>'poisson'</code> (count outcomes only, fast), <code>'gaussian'</code> (continuous outcomes only) and
<code>'gam'</code> (count and continuous outcomes only). Default is <code>NULL</code>, which assigns <code>'boosting'</code>
for count outcomes and <code>'randomForest'</code> for survival outcomes.</p>
</td></tr>
<tr><td><code id="catefit_+3A_ipcw.model">ipcw.model</code></td>
<td>
<p>A formula describing the inverse probability of censoring weighting (IPCW)
model to be fitted. The left-hand side must be empty. Only applies for survival outcomes.
Default is <code>NULL</code>, which corresponds to specifying the IPCW with the same covariates
as the outcome model <code>cate.model</code>, plus the treatment.</p>
</td></tr>
<tr><td><code id="catefit_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>A character value for the censoring model. Only applies for survival
outcomes. Allowed values are: <code>'breslow'</code> (Cox regression with Breslow estimator of t
he baseline survivor function), <code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>,
<code>'aft (lognormal)'</code> or <code>'aft (loglogistic)'</code> (accelerated failure time model
with different distributions for y variable). Default is <code>'breslow'</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_followup.time">followup.time</code></td>
<td>
<p>A column name in <code>data</code> specifying the maximum follow-up time,
interpreted as the potential censoring time. Only applies for survival outcomes.
Default is <code>NULL</code>, which corresponds to unknown potential censoring time.</p>
</td></tr>
<tr><td><code id="catefit_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost. Only applies for
survival outcomes. Default is <code>NULL</code>, which corresponds to setting the truncation time as the
maximum survival time in the data.</p>
</td></tr>
<tr><td><code id="catefit_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or
lower (<code>FALSE</code>) values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated log CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for the probability of being censored.
It must be a positive value and should be chosen close to 0. Only applies for survival
outcomes. Default is <code>0.025</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_xvar.smooth.score">xvar.smooth.score</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>score.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>cate.model</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_xvar.smooth.init">xvar.smooth.init</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>initial.predictor.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>init.model</code>.
Default is <code>NULL</code>, which uses all variables in <code>init.model</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="catefit_+3A_n.trees.rf">n.trees.rf</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in random forest.
Used if <code>score.method = 'ranfomForest'</code> or if <code>initial.predictor.method = 'randomForest'</code>
with <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code>. Only applies for survival outcomes.
Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for reproducibility.
Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="catefit_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating whether intermediate progress messages and histograms should
be printed. <code>1</code> indicates messages are printed and <code>0</code> otherwise. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="catefit_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>gbm()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For count response, see details in <code><a href="#topic+catefitcount">catefitcount</a>()</code>.
For survival response, see details in <code><a href="#topic+catefitsurv">catefitsurv</a>()</code>.
</p>


<h3>Value</h3>

<p>For count response, see description of outputs in <code><a href="#topic+catefitcount">catefitcount</a>()</code>.
For survival response, see description of outputs in <code><a href="#topic+catefitsurv">catefitsurv</a>()</code>.
</p>


<h3>References</h3>

<p>Yadlowsky, S., Pellegrini, F., Lionetto, F., Braune, S., &amp; Tian, L. (2020).
<em>Estimation and validation of ratio-based conditional average treatment effects using
observational data. Journal of the American Statistical Association, 1-18.</em>
<a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080">https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+catecv">catecv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Count outcome
fit_1 &lt;- catefit(response = "count",
                 data = countExample,
                 score.method = "poisson",
                 cate.model = y ~ age + female + previous_treatment +
                                  previous_cost + previous_number_relapses +
                                  offset(log(years)),
                 ps.model = trt ~ age + previous_treatment,
                 higher.y = TRUE,
                 seed = 999)

coef(fit_1)


# Survival outcome
library(survival)
tau0 &lt;- with(survivalExample,
                 min(quantile(y[trt == "drug1"], 0.95), quantile(y[trt == "drug0"], 0.95)))

fit_2 &lt;- catefit(response = "survival",
                 data = survivalExample,
                 score.method = c("poisson", "boosting", "randomForest"),
                 cate.model = Surv(y, d) ~ age + female + previous_cost +
                                           previous_number_relapses,
                 ps.model = trt ~ age + previous_treatment,
                 initial.predictor.method = "logistic",
                 ipcw.model = ~ age + previous_cost + previous_treatment,
                 tau0 = tau0, higher.y = TRUE, seed = 999, n.cores = 1)

coef(fit_2)


</code></pre>

<hr>
<h2 id='catefitcount'>Estimation of the conditional average treatment effect (CATE) score for count data</h2><span id='topic+catefitcount'></span>

<h3>Description</h3>

<p>Provides singly robust and doubly robust estimation of CATE score with up to 5 scoring methods
among the following: Poisson regression, boosting, two regressions, contrast regression, and
negative binomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catefitcount(
  data,
  score.method,
  cate.model,
  ps.model,
  ps.method = "glm",
  initial.predictor.method = "boosting",
  minPS = 0.01,
  maxPS = 0.99,
  higher.y = TRUE,
  prop.cutoff = seq(0.5, 1, length = 6),
  xvar.smooth = NULL,
  tree.depth = 2,
  n.trees.boosting = 200,
  B = 3,
  Kfold = 5,
  error.maxNR = 0.001,
  max.iterNR = 150,
  tune = c(0.5, 2),
  seed = NULL,
  plot.gbmperf = FALSE,
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catefitcount_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome and propensity score model; a data frame with <code>n</code> rows
(1 row per observation).</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'poisson'</code>, <code>'twoReg'</code>, <code>'contrastReg'</code>,
and <code>'negBin'</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score model to be fitted.
The treatment must appear on the left-hand side. The treatment must be a numeric vector
coded as 0/1. If data are from a randomized trial, specify <code>ps.model</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates in <code>cate.model</code>. Only applies
when <code>score.method</code> includes <code>'twoReg'</code> or <code>'contrastReg'</code>. Allowed values
include one of <code>'poisson'</code> (fastest), <code>'boosting'</code> and <code>'gam'</code>.
Default is <code>'boosting'</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or
lower (<code>FALSE</code>) values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated log CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_xvar.smooth">xvar.smooth</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>initial.predictor.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>cate.model</code>.
Default is <code>NULL</code>, which uses all variables in <code>cate.model</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for reproducibility.
Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating what kind of intermediate progress messages should
be printed. <code>0</code> means no outputs. <code>1</code> means only progress and run time.
<code>2</code> means progress, run time, and all errors and warnings. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="catefitcount_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>gbm()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CATE score represents an individual-level treatment effect, estimated with
either Poisson regression, boosting or negative binomial regression applied separately by
treatment group or with two doubly robust estimators, two regressions and contrast regression
(Yadlowsky, 2020) applied to the entire dataset.
</p>
<p><code><a href="#topic+catefitcount">catefitcount</a>()</code> provides the coefficients of the CATE score for each scoring method requested
through <code>score.method</code>. Currently, contrast regression is the only method which allows
for inference of the CATE coefficients by providing standard errors of the coefficients.
The coefficients can be used to learn the effect size of each variable and predict the
CATE score for a new observation.
</p>
<p><code><a href="#topic+catefitcount">catefitcount</a>()</code> also provides the predicted CATE score of each observation in the data set,
for each scoring method. The predictions allow ranking the observations from potentially
high responders to the treatment to potentially low or standard responders.
</p>
<p>The estimated ATE among nested subgroups of high responders are also provided by scoring method.
Note that the ATEs in <code><a href="#topic+catefitcount">catefitcount</a>()</code> are derived based on the CATE score which is estimated
using the same data sample. Therefore, overfitting may be an issue. <code><a href="#topic+catecvcount">catecvcount</a>()</code> is more
suitable to inspect the estimated ATEs across scoring methods as it implements internal cross
validation to reduce optimism.
</p>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>

<ul>
<li><p><code>ate.poisson</code>: A vector of numerical values of length <code>prop.cutoff</code>
containing the estimated ATE in nested subgroups (defined by <code>prop.cutoff</code>)
constructed based on the estimated CATE scores with poisson regression.
Only provided if <code>score.method</code> includes <code>'poisson'</code>.
</p>
</li>
<li><p><code>ate.boosting</code>: Same as <code>ate.poisson</code>, but with the nested subgroups based
the estimated CATE scores with boosting. Only provided if <code>score.method</code>
includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>ate.twoReg</code>: Same as <code>ate.poisson</code>, but with the nested subgroups based
the estimated CATE scores with two regressions.
Only provided if <code>score.method</code> includes <code>'twoReg'</code>.
</p>
</li>
<li><p><code>ate.contrastReg</code>: Same as <code>ate.poisson</code>, but with the nested subgroups based
the estimated CATE scores with contrast regression.
Only provided if <code>score.method</code> includes <code>'contrastReg'</code>.
</p>
</li>
<li><p><code>ate.negBin</code>: Same as <code>ate.poisson</code>, but with the nested subgroups based
the estimated CATE scores with negative binomial regression.
Only provided if <code>score.method</code> includes <code>'negBin'</code>.
</p>
</li>
<li><p><code>score.poisson</code>: A vector of numerical values of length n
(number of observations in <code>data</code>) containing the estimated log-CATE scores
according to the Poisson regression. Only provided if <code>score.method</code>
includes <code>'poisson'</code>.
</p>
</li>
<li><p><code>score.boosting</code>: Same as <code>score.poisson</code>, but with estimated log-CATE score
according to boosting. Only provided if <code>score.method</code> includes
<code>'boosting'</code>.
</p>
</li>
<li><p><code>score.twoReg</code>: Same as <code>score.poisson</code>, but with estimated log-CATE score
according to two regressions. Only provided if <code>score.method</code> includes
<code>'twoReg'</code>.
</p>
</li>
<li><p><code>score.contrastReg</code>: Same as <code>score.poisson</code>, but with estimated log-CATE score
according to contrast regression. Only provided if <code>score.method</code> includes
<code>'contrastReg'</code>.
</p>
</li>
<li><p><code>score.negBin</code>: Same as <code>score.poisson</code>, but with estimated log-CATE score
according to negative binomial regression. Only provided if <code>score.method</code>
includes <code>'negBin'</code>.
</p>
</li>
<li><p><code>fit</code>: Additional details on model fitting if <code>score.method</code>
includes 'boosting' or 'contrastReg':
</p>

<ul>
<li><p><code>result.boosting</code>: Details on the boosting model fitted to observations
with treatment = 0 <code>($fit0.boosting)</code> and to observations with treatment = 1 <code>($fit1.boosting)</code>.
Only provided if <code>score.method</code> includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>result.contrastReg$sigma.contrastReg</code>: Variance-covariance matrix of
the estimated log-CATE coefficients in contrast regression.
Only provided if <code>score.method</code> includes <code>'contrastReg'</code>.
</p>
</li></ul>

</li>
<li><p><code>coefficients</code>: A data frame with the coefficients of the estimated log-CATE
score by <code>score.method</code>. The data frame has number of rows equal to the number of
covariates in <code>cate.model</code> and number of columns equal to <code>length(score.method)</code>.
If <code>score.method</code> includes <code>'contrastReg'</code>, the data frame has an additional
column containing the standard errors of the coefficients estimated with contrast regression.
<code>'boosting'</code> does not have coefficient results because tree-based methods typically do not
express the log-CATE as a linear combination of coefficients and covariates.
</p>
</li></ul>



<h3>References</h3>

<p>Yadlowsky, S., Pellegrini, F., Lionetto, F., Braune, S., &amp; Tian, L. (2020).
<em>Estimation and validation of ratio-based conditional average treatment effects using
observational data. Journal of the American Statistical Association, 1-18.</em>
<a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080">https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+catecvcount">catecvcount</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- catefitcount(data = countExample,
                    score.method = "poisson",
                    cate.model = y ~ age + female + previous_treatment +
                                 previous_cost + previous_number_relapses +
                                 offset(log(years)),
                    ps.model = trt ~ age + previous_treatment,
                    higher.y = FALSE,
                    seed = 999, verbose = 1)
</code></pre>

<hr>
<h2 id='catefitmean'>Estimation of the conditional average treatment effect (CATE) score for continuous data</h2><span id='topic+catefitmean'></span>

<h3>Description</h3>

<p>Provides singly robust and doubly robust estimation of CATE score with up to 6 scoring methods
among the following: Linear regression, boosting, two regressions, contrast regression, random forest and
generalized additive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catefitmean(
  data,
  score.method,
  cate.model,
  ps.model,
  ps.method = "glm",
  init.model = NULL,
  initial.predictor.method = "boosting",
  minPS = 0.01,
  maxPS = 0.99,
  higher.y = TRUE,
  prop.cutoff = seq(0.5, 1, length = 6),
  xvar.smooth.score = NULL,
  xvar.smooth.init = NULL,
  tree.depth = 2,
  n.trees.rf = 1000,
  n.trees.boosting = 200,
  B = 3,
  Kfold = 6,
  plot.gbmperf = FALSE,
  error.maxNR = 0.001,
  tune = c(0.5, 2),
  seed = NULL,
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catefitmean_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome and propensity score models;
a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'gaussian'</code>, <code>'twoReg'</code>,
<code>'contrastReg'</code>, <code>'randomForest'</code>, <code>'gam'</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score model to be fitted.
The treatment must appear on the left-hand side.
The treatment must be a numeric vector coded as 0/1.
If data are from a RCT, specify <code>ps.model</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of: <code>'glm'</code> for logistic regression with main effects only
(default), or <code>'lasso'</code> for a logistic regression with main effects and LASSO penalization
on two-way interactions (added to the model if not specified in <code>ps.model</code>).</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_init.model">init.model</code></td>
<td>
<p>A formula describing the initial predictor model. The outcome must appear on the left-hand side.
It must be specified when <code>score.method = contrastReg</code> or <code>twoReg</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial outcome
predictions conditional on the covariates in <code>init.model</code> in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Allowed values include one of
<code>'gaussian'</code> (fastest), <code>'boosting'</code> and <code>'gam'</code>.
Default is <code>'boosting'</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or
lower (<code>FALSE</code>) values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of
the estimated log CATE scores to define nested subgroups. Each element represents the
cutoff to separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_xvar.smooth.score">xvar.smooth.score</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as the
smooth terms if <code>score.method = 'gam'</code>. The variables must be selected from
the variables listed in <code>cate.model</code>. Default is <code>NULL</code>, which uses all variables
in <code>cate.model</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_xvar.smooth.init">xvar.smooth.init</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as the
smooth terms if <code>initial.predictor.method = 'gam'</code>. The variables must be selected from
the variables listed in <code>init.model</code>. Default is <code>NULL</code>, which uses all variables
in <code>init.model</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_n.trees.rf">n.trees.rf</code></td>
<td>
<p>A positive integer specifying the number of trees. Used only if
<code>score.method = 'randomForest'</code>. Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds (parts) used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>6</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures
in boosting. Used only if <code>score.method = 'boosting'</code> or if
<code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for reproducibility.
Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating what kind of intermediate progress messages should
be printed. <code>0</code> means no outputs. <code>1</code> means only progress and run time.
<code>2</code> means progress, run time, and all errors and warnings. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="catefitmean_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>gbm()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CATE score represents an individual-level treatment effect, estimated with
either linear regression, boosting, random forest and generalized additive model applied separately by
treatment group or with two doubly robust estimators, two regressions and contrast regression
(Yadlowsky, 2020) applied to the entire dataset.
</p>
<p><code><a href="#topic+catefitmean">catefitmean</a>()</code> provides the coefficients of the CATE score for each scoring method requested
through <code>score.method</code>. Currently, contrast regression is the only method which allows
for inference of the CATE coefficients by providing standard errors of the coefficients.
The coefficients can be used to learn the effect size of each variable and predict the
CATE score for a new observation.
</p>
<p><code><a href="#topic+catefitmean">catefitmean</a>()</code> also provides the predicted CATE score of each observation in the data set,
for each scoring method. The predictions allow ranking the observations from potentially
high responders to the treatment to potentially low or standard responders.
</p>
<p>The estimated ATE among nested subgroups of high responders are also provided by scoring method.
Note that the ATEs in <code><a href="#topic+catefitmean">catefitmean</a>()</code> are derived based on the CATE score which is estimated
using the same data sample. Therefore, overfitting may be an issue. <code><a href="#topic+catefitmean">catefitmean</a>()</code> is more
suitable to inspect the estimated ATEs across scoring methods as it implements internal cross
validation to reduce optimism.
</p>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>

<ul>
<li><p><code>ate.gaussian</code>: A vector of numerical values of length <code>prop.cutoff</code>
containing the estimated ATE in nested subgroups (defined by <code>prop.cutoff</code>)
constructed based on the estimated CATE scores with Poisson regression.
Only provided if <code>score.method</code> includes <code>'gaussian'</code>.
</p>
</li>
<li><p><code>ate.boosting</code>: Same as <code>ate.gaussian</code>, but with the nested subgroups based
the estimated CATE scores with boosting. Only provided if <code>score.method</code>
includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>ate.twoReg</code>: Same as <code>ate.gaussian</code>, but with the nested subgroups based
the estimated CATE scores with two regressions.
Only provided if <code>score.method</code> includes <code>'twoReg'</code>.
</p>
</li>
<li><p><code>ate.contrastReg</code>: Same as <code>ate.gaussian</code>, but with the nested subgroups based
the estimated CATE scores with contrast regression.
Only provided if <code>score.method</code> includes <code>'contrastReg'</code>.
</p>
</li>
<li><p><code>ate.randomForest</code>: Same as <code>ate.gaussian</code>, but with the nested subgroups based
the estimated CATE scores with random forest.
Only provided if <code>score.method</code> includes <code>'gam'</code>.
</p>
</li>
<li><p><code>ate.gam</code>: Same as <code>ate.gaussian</code>, but with the nested subgroups based
the estimated CATE scores with generalized additive model.
Only provided if <code>score.method</code> includes <code>'gam'</code>.
</p>
</li>
<li><p><code>score.gaussian</code>: A vector of numerical values of length n
(number of observations in <code>data</code>) containing the estimated CATE scores
according to the linear regression. Only provided if <code>score.method</code>
includes <code>'gaussian'</code>.
</p>
</li>
<li><p><code>score.boosting</code>: Same as <code>score.gaussian</code>, but with estimated CATE score
according to boosting. Only provided if <code>score.method</code> includes
<code>'boosting'</code>.
</p>
</li>
<li><p><code>score.twoReg</code>: Same as <code>score.gaussian</code>, but with estimated CATE score
according to two regressions. Only provided if <code>score.method</code> includes
<code>'twoReg'</code>.
</p>
</li>
<li><p><code>score.contrastReg</code>: Same as <code>score.gaussian</code>, but with estimated CATE score
according to contrast regression. Only provided if <code>score.method</code> includes
<code>'contrastReg'</code>.
</p>
</li>
<li><p><code>score.randomForest</code>: Same as <code>score.gaussian</code>, but with estimated CATE score
according to random forest. Only provided if <code>score.method</code>
includes <code>'randomForest'</code>.
</p>
</li>
<li><p><code>score.gam</code>: Same as <code>score.gaussian</code>, but with estimated CATE score
according to generalized additive model. Only provided if <code>score.method</code>
includes <code>'gam'</code>.
</p>
</li>
<li><p><code>fit</code>: Additional details on model fitting if <code>score.method</code>
includes 'boosting' or 'contrastReg':
</p>

<ul>
<li><p><code>result.boosting</code>: Details on the boosting model fitted to observations
with treatment = 0 <code>($fit0.boosting)</code> and to observations with treatment = 1 <code>($fit1.boosting)</code>.
Only provided if <code>score.method</code> includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>result.randomForest</code>: Details on the boosting model fitted to observations
with treatment = 0 <code>($fit0.randomForest)</code> and to observations with treatment = 1 <code>($fit1.randomForest)</code>.
Only provided if <code>score.method</code> includes <code>'randomForest'</code>.
</p>
</li>
<li><p><code>result.gam</code>: Details on the boosting model fitted to observations
with treatment = 0 <code>($fit0.gam)</code> and to observations with treatment = 1 <code>($fit1.gam)</code>.
Only provided if <code>score.method</code> includes <code>'gam'</code>.
</p>
</li>
<li><p><code>result.contrastReg$sigma.contrastReg</code>: Variance-covariance matrix of
the estimated CATE coefficients in contrast regression.
Only provided if <code>score.method</code> includes <code>'contrastReg'</code>.
</p>
</li></ul>

</li>
<li><p><code>coefficients</code>: A data frame with the coefficients of the estimated CATE
score by <code>score.method</code>. The data frame has number of rows equal to the number of
covariates in <code>cate.model</code> and number of columns equal to <code>length(score.method)</code>.
If <code>score.method</code> includes <code>'contrastReg'</code>, the data frame has an additional
column containing the standard errors of the coefficients estimated with contrast regression.
<code>'boosting'</code>, <code>'randomForest'</code>, <code>'gam'</code> do not have coefficient results because these methods do not
express the CATE as a linear combination of coefficients and covariates.
</p>
</li></ul>



<h3>References</h3>

<p>Yadlowsky, S., Pellegrini, F., Lionetto, F., Braune, S., &amp; Tian, L. (2020).
<em>Estimation and validation of ratio-based conditional average treatment effects using
observational data. Journal of the American Statistical Association, 1-18.</em>
<a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080">https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+catecvmean">catecvmean</a>()</code> function
</p>

<hr>
<h2 id='catefitsurv'>Estimation of the conditional average treatment effect (CATE) score for survival data</h2><span id='topic+catefitsurv'></span>

<h3>Description</h3>

<p>Provides singly robust and doubly robust estimation of CATE score for survival data with
up to 5 scoring methods among the following: Random forest, boosting, poisson regression,
two regressions, and contrast regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catefitsurv(
  data,
  score.method,
  cate.model,
  ps.model,
  ps.method = "glm",
  initial.predictor.method = "randomForest",
  ipcw.model = NULL,
  ipcw.method = "breslow",
  minPS = 0.01,
  maxPS = 0.99,
  followup.time = NULL,
  tau0 = NULL,
  higher.y = TRUE,
  prop.cutoff = seq(0.5, 1, length = 6),
  surv.min = 0.025,
  tree.depth = 2,
  n.trees.rf = 1000,
  n.trees.boosting = 200,
  B = 3,
  Kfold = 5,
  plot.gbmperf = TRUE,
  error.maxNR = 0.001,
  max.iterNR = 100,
  tune = c(0.5, 2),
  seed = NULL,
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catefitsurv_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome, propensity score, and inverse
probability of censoring models (if specified); a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'randomForest'</code>, <code>'boosting'</code>, <code>'poisson'</code>, <code>'twoReg'</code>, and
<code>'contrastReg'</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_cate.model">cate.model</code></td>
<td>
<p>A standard <code>Surv</code> formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score (PS) model to be fitted. The treatment must
appear on the left-hand side. The treatment must be a numeric vector coded as 0/1.
If data are from a randomized controlled trial, specify <code>ps.model = ~1</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates specified in <code>cate.model</code>. Only applies
when <code>score.method</code> includes <code>'twoReg'</code> or <code>'contrastReg'</code>. Allowed values include
one of <code>'randomForest'</code>, <code>'boosting'</code> and <code>'logistic'</code> (fastest).
Default is <code>'randomForest'</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_ipcw.model">ipcw.model</code></td>
<td>
<p>A formula describing the inverse probability of censoring weighting (IPCW)
model to be fitted. The left-hand side must be empty. Default is <code>ipcw.model = NULL</code>,
which corresponds to specifying the IPCW model with the same covariates as the outcome model
<code>cate.model</code> plus the treatment.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>A character value for the censoring model. Allowed values are:
<code>'breslow'</code> (Cox regression with Breslow estimator of the baseline survivor function),
<code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>, <code>'aft (lognormal)'</code>
or <code>'aft (loglogistic)'</code> (accelerated failure time model with different distributions for
y variable). Default is <code>'breslow'</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_followup.time">followup.time</code></td>
<td>
<p>A column name in <code>data</code> specifying the maximum follow-up time,
interpreted as the potential censoring time. Default is <code>followup.time = NULL</code>,
which corresponds to unknown potential censoring time.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost. Default is <code>NULL</code>,
which corresponds to setting the truncation time as the maximum survival time in the data.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or
lower (<code>FALSE</code>) values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated log CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for the probability of being censored.
It must be a positive value and should be chosen close to 0. Default is <code>0.025</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_n.trees.rf">n.trees.rf</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in random forest.
Used if <code>score.method = 'ranfomForest'</code> or if <code>initial.predictor.method = 'randomForest'</code>
with <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code>. Only applies for survival outcomes.
Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with <code>score.method = 'twoReg'</code> or
<code>'contrastReg'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_seed">seed</code></td>
<td>
<p>An optional integer specifying an initial randomization seed for reproducibility.
Default is <code>NULL</code>, corresponding to no seed.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_verbose">verbose</code></td>
<td>
<p>An integer value indicating what kind of intermediate progress messages should
be printed. <code>0</code> means no outputs. <code>1</code> means only progress and run time.
<code>2</code> means progress, run time, and all errors and warnings. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="catefitsurv_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>gbm()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CATE score represents an individual-level treatment effect for survival data,
estimated with random forest, boosting, Poisson regression, and the doubly
robust estimator (two regressions, Yadlowsky, 2020) applied separately by treatment group
or with the other doubly robust estimators (contrast regression, Yadlowsky, 2020) applied
to the entire data set.
</p>
<p><code><a href="#topic+catefitsurv">catefitsurv</a>()</code> provides the coefficients of the CATE score for each scoring method requested
through <code>score.method</code>. Currently, contrast regression is the only method which allows
for inference of the CATE coefficients by providing standard errors of the coefficients.
The coefficients can be used to learn the effect size of each variable and predict the
CATE score for a new observation.
</p>
<p><code><a href="#topic+catefitsurv">catefitsurv</a>()</code> also provides the predicted CATE score of each observation in the data set,
for each scoring method. The predictions allow ranking the observations from potentially
high responders to the treatment to potentially low or standard responders.
</p>
<p>The estimated ATE among nested subgroups of high responders are also provided by scoring method.
Note that the ATEs in <code><a href="#topic+catefitsurv">catefitsurv</a>()</code> are derived based on the CATE score which is estimated
using the same data sample. Therefore, overfitting may be an issue. <code><a href="#topic+catecvsurv">catecvsurv</a>()</code> is more
suitable to inspect the estimated ATEs across scoring methods as it implements internal cross
validation to reduce optimism.
</p>


<h3>Value</h3>

<p>Returns an object of the class <code>catefit</code> containing the following components:
</p>

<ul>
<li><p><code>ate.randomForest</code>: A vector of numerical values of length <code>prop.cutoff</code>
containing the estimated ATE by the RMTL ratio in nested subgroups (defined by <code>prop.cutoff</code>)
constructed based on the estimated CATE scores with random forest method.
Only provided if <code>score.method</code> includes <code>'randomForest'</code>.
</p>
</li>
<li><p><code>ate.boosting</code>: Same as <code>ate.randomForest</code>, but with the nested subgroups based
the estimated CATE scores with boosting. Only provided if <code>score.method</code>
includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>ate.poisson</code>: Same as <code>ate.randomForest</code>, but with the nested subgroups based
the estimated CATE scores with poisson regression.
Only provided if <code>score.method</code> includes <code>'poisson'</code>.
</p>
</li>
<li><p><code>ate.twoReg</code>: Same as <code>ate.randomForest</code>, but with the nested subgroups based
the estimated CATE scores with two regressions.
Only provided if <code>score.method</code> includes <code>'twoReg'</code>.
</p>
</li>
<li><p><code>ate.contrastReg</code>: Same as <code>ate.randomForest</code>, but with the nested subgroups based
the estimated CATE scores with contrast regression.
Only provided if <code>score.method</code> includes <code>'contrastReg'</code>.
</p>
</li>
<li><p><code>hr.randomForest</code>: A vector of numerical values of length <code>prop.cutoff</code>
containing the adjusted hazard ratio in nested subgroups (defined by <code>prop.cutoff</code>)
constructed based on the estimated CATE scores with random forest method.
Only provided if <code>score.method</code> includes <code>'randomForest'</code>.
</p>
</li>
<li><p><code>hr.boosting</code>: Same as <code>hr.randomForest</code>, but with the nested subgroups based
the estimated CATE scores with boosting. Only provided if <code>score.method</code>
includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>hr.poisson</code>: Same as <code>hr.randomForest</code>, but with the nested subgroups based
the estimated CATE scores with poisson regression.
Only provided if <code>score.method</code> includes <code>'poisson'</code>.
</p>
</li>
<li><p><code>hr.twoReg</code>: Same as <code>hr.randomForest</code>, but with the nested subgroups based
the estimated CATE scores with two regressions.
Only provided if <code>score.method</code> includes <code>'twoReg'</code>.
</p>
</li>
<li><p><code>hr.contrastReg</code>: Same as <code>hr.randomForest</code>, but with the nested subgroups based
the estimated CATE scores with contrast regression.
Only provided if <code>score.method</code> includes <code>'contrastReg'</code>.
</p>
</li>
<li><p><code>score.randomForest</code>: A vector of numerical values of length n
(number of observations in <code>data</code>) containing the estimated log-CATE scores
according to random forest. Only provided if <code>score.method</code>
includes <code>'randomForest'</code>.
</p>
</li>
<li><p><code>score.boosting</code>: Same as <code>score.randomForest</code>, but with estimated log-CATE score
according to boosting. Only provided if <code>score.method</code> includes
<code>'boosting'</code>.
</p>
</li>
<li><p><code>score.poisson</code>: Same as <code>score.randomForest</code>, but with estimated log-CATE score
according to the Poisson regression. Only provided if <code>score.method</code>
includes <code>'poisson'</code>.
</p>
</li>
<li><p><code>score.twoReg</code>: Same as <code>score.randomForest</code>, but with estimated log-CATE score
according to two regressions. Only provided if <code>score.method</code> includes
<code>'twoReg'</code>.
</p>
</li>
<li><p><code>score.contrastReg</code>: Same as <code>score.randomForest</code>, but with estimated log-CATE score
according to contrast regression. Only provided if <code>score.method</code> includes
<code>'contrastReg'</code>.
</p>
</li>
<li><p><code>fit</code>: Additional details on model fitting if <code>score.method</code>
includes 'randomForest', 'boosting' or 'contrastReg':
</p>

<ul>
<li><p><code>result.randomForest</code>: Details on the random forest model fitted to observations
with treatment = 0 <code>($fit0.rf)</code> and to observations with treatment = 1 <code>($fit1.rf)</code>.
Only provided if <code>score.method</code> includes <code>'randomForest'</code>.
</p>
</li>
<li><p><code>result.boosting</code>: Details on the boosting model fitted to observations
with treatment = 0, <code>($fit0.boosting)</code> and <code>($fit0.gam)</code> and to observations with treatment = 1,
<code>($fit1.boosting)</code> and <code>($fit1.gam)</code>.
Only provided if <code>score.method</code> includes <code>'boosting'</code>.
</p>
</li>
<li><p><code>result.contrastReg$converge.contrastReg</code>: Whether the contrast regression algorithm converged
or not. Only provided if <code>score.method</code> includes <code>'contrastReg'</code>.
</p>
</li></ul>

</li>
<li><p><code>coefficients</code>: A data frame with the coefficients of the estimated log-CATE
score by <code>score.method</code>. The data frame has number of rows equal to the number of
covariates in <code>cate.model</code> and number of columns equal to <code>length(score.method)</code>.
If <code>score.method</code> includes <code>'contrastReg'</code>, the data frame has an additional
column containing the standard errors of the coefficients estimated with contrast regression.
<code>'randomForest'</code> and <code>'boosting'</code> do not have coefficient results because
tree-based methods typically do not express the log-CATE as a linear combination of coefficients
and covariates.
</p>
</li>
<li><p><code>errors/warnings</code>: A nested list of errors and warnings that were wrapped during the
calculation of ATE. Errors and warnings are organized by <code>score.method</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Yadlowsky, S., Pellegrini, F., Lionetto, F., Braune, S., &amp; Tian, L. (2020).
<em>Estimation and validation of ratio-based conditional average treatment effects using
observational data. Journal of the American Statistical Association, 1-18.</em>
<a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080">https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+catecvsurv">catecvsurv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)

tau0 &lt;- with(survivalExample, min(quantile(y[trt == "drug1"], 0.95),
                               quantile(y[trt == "drug0"], 0.95)))

fit &lt;- catefitsurv(data = survivalExample,
                   score.method = "randomForest",
                   cate.model = Surv(y, d) ~ age + female + previous_cost +
                                             previous_number_relapses,
                   ps.model = trt ~ age + previous_treatment,
                   ipcw.model = ~ age + previous_cost + previous_treatment,
                   tau0 = tau0,
                   seed = 999)

coef(fit)


</code></pre>

<hr>
<h2 id='countExample'>Simulated data with count outcome</h2><span id='topic+countExample'></span>

<h3>Description</h3>

<p>A dataset containing a count outcome, a length of follow-up and 6 baseline covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(countExample)
</code></pre>


<h3>Format</h3>

<p>A dataframe with 4000 rows (patients) and 9 variables:
</p>

<dl>
<dt>age</dt><dd><p>age at baseline, centered to 48 years old, in years</p>
</dd>
<dt>female</dt><dd><p>sex, 0 for male, 1 for female</p>
</dd>
<dt>previous_treatment</dt><dd><p>previous treatment, &quot;drugA&quot;, &quot;drugB&quot;, or &quot;drugC&quot;</p>
</dd>
<dt>previous_cost</dt><dd><p>previous medical cost, in US dollars</p>
</dd>
<dt>previous_number_symptoms</dt><dd><p>previous number of symptoms, &quot;0&quot;, &quot;1&quot;, or &quot;&gt;=2&quot;</p>
</dd>
<dt>previous_number_relapses</dt><dd><p>previous number of relapses</p>
</dd>
<dt>trt</dt><dd><p>current treatment, &quot;drug0&quot; or &quot;drug1&quot;</p>
</dd>
<dt>y</dt><dd><p>count oucome, current number of relapses</p>
</dd>
<dt>years</dt><dd><p>length of follow-up, in years</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(countExample)
str(countExample)
rate &lt;- countExample$y / countExample$years
</code></pre>

<hr>
<h2 id='cox.rmst'>Estimate restricted mean survival time (RMST) based on Cox regression model</h2><span id='topic+cox.rmst'></span>

<h3>Description</h3>

<p>Estimate restricted mean survival time (RMST) based on Cox regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox.rmst(y, d, x.cate, xnew, tau0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox.rmst_+3A_y">y</code></td>
<td>
<p>Observed survival or censoring time; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="cox.rmst_+3A_d">d</code></td>
<td>
<p>The event indicator, normally <code>1 = event, 0 = censored</code>; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="cox.rmst_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates specified in the outcome model; dimension <code>n</code> by <code>p.cate</code>.</p>
</td></tr>
<tr><td><code id="cox.rmst_+3A_xnew">xnew</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates for which we want an estimate of the RMST; dimension <code>m</code> (observations in the new data set) by <code>p.cate</code></p>
</td></tr>
<tr><td><code id="cox.rmst_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated RMST for new subjects with covariates <code>xnew</code>; vector of size <code>m</code>.
</p>

<hr>
<h2 id='data.preproc'>Data preprocessing
Apply at the beginning of <code>pmcount()</code> and <code>cvcount()</code>, after <code>arg.checks()</code></h2><span id='topic+data.preproc'></span>

<h3>Description</h3>

<p>Data preprocessing
Apply at the beginning of <code>pmcount()</code> and <code>cvcount()</code>, after <code>arg.checks()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.preproc(
  fun,
  cate.model,
  ps.model,
  data,
  prop.cutoff = NULL,
  prop.multi = NULL,
  ps.method,
  initial.predictor.method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.preproc_+3A_fun">fun</code></td>
<td>
<p>A function for which argument check is needed; &quot;pm&quot; for <code>pmcount()</code>, &quot;cv&quot; for <code>cvcount()</code>,
and &quot;drinf&quot; for <code>drcount.inference()</code>. No default.</p>
</td></tr>
<tr><td><code id="data.preproc_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="data.preproc_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score model to be fitted.
The treatment must appear on the left-hand side. The treatment must be a numeric vector
coded as 0/1. If data are from a RCT, specify <code>ps.model</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="data.preproc_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome and propensity score models;
a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="data.preproc_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated log CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="data.preproc_+3A_prop.multi">prop.multi</code></td>
<td>
<p>A vector of numerical values (in [0, 1]) specifying percentiles of the
estimated log CATE scores to define mutually exclusive subgroups.
It should start with 0, end with 1, and be of <code>length(prop.multi) &gt; 2</code>.
Each element represents the cutoff to separate the observations into
<code>length(prop.multi) - 1</code> mutually exclusive subgroups.
Default is <code>c(0, 1/3, 2/3, 1)</code>.</p>
</td></tr>
<tr><td><code id="data.preproc_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="data.preproc_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates. Only applies when <code>score.method</code>
includes <code>'twoReg'</code> or <code>'contrastReg'</code>. Allowed values include one of
<code>'boosting'</code>, <code>'poisson'</code> (fast), and <code>'gam'</code>. Default is <code>NULL</code>, which assigns
<code>'boosting'</code> for count outcomes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 6 elements:
- y: outcome; vector of length <code>n</code> (observations)
- trt: binary treatment; vector of length <code>n</code>
- x.ps: matrix of <code>p.ps</code> baseline covariates (plus intercept); dimension <code>n</code> by <code>p.ps + 1</code>
- x.cate: matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code>
- time: offset; vector of length <code>n</code>
- if <code>fun = "pm"</code>:
- prop: formatted <code>prop.cutoff</code>
- if <code>fun = "cv"</code>
- prop.onlyhigh: formatted <code>prop.cutoff</code> with 0 removed if applicable
- prop.bi; formatted <code>prop.cutoff</code> with 0 and 1 removed if applicable
- prop.multi: formatted <code>prop.multi</code>, starting with 0 and ending with 1
</p>

<hr>
<h2 id='data.preproc.mean'>Data preprocessing
Apply at the beginning of <code>catefitmean()</code> and <code>catecvmean()</code>, after <code>arg.checks()</code></h2><span id='topic+data.preproc.mean'></span>

<h3>Description</h3>

<p>Data preprocessing
Apply at the beginning of <code>catefitmean()</code> and <code>catecvmean()</code>, after <code>arg.checks()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.preproc.mean(
  fun,
  cate.model,
  init.model,
  ps.model,
  data,
  prop.cutoff = NULL,
  prop.multi = NULL,
  ps.method,
  score.method = NULL,
  initial.predictor.method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.preproc.mean_+3A_fun">fun</code></td>
<td>
<p>A function for which argument check is needed; &quot;pm&quot; for <code>catefitmean()</code>, &quot;cv&quot; for <code>catecvmean()</code>,
and &quot;drinf&quot; for <code>drmean.inference()</code>. No default.</p>
</td></tr>
<tr><td><code id="data.preproc.mean_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="data.preproc.mean_+3A_init.model">init.model</code></td>
<td>
<p>A formula describing the initial predictor model. The outcome must appear on the left-hand side.
It must be specified when <code>score.method = contrastReg</code> or <code>twoReg</code>.</p>
</td></tr>
<tr><td><code id="data.preproc.mean_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score model to be fitted.
The treatment must appear on the left-hand side. The treatment must be a numeric vector
coded as 0/1. If data are from a RCT, specify <code>ps.model</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="data.preproc.mean_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome and propensity score models;
a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="data.preproc.mean_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated log CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="data.preproc.mean_+3A_prop.multi">prop.multi</code></td>
<td>
<p>A vector of numerical values (in [0, 1]) specifying percentiles of the
estimated log CATE scores to define mutually exclusive subgroups.
It should start with 0, end with 1, and be of <code>length(prop.multi) &gt; 2</code>.
Each element represents the cutoff to separate the observations into
<code>length(prop.multi) - 1</code> mutually exclusive subgroups.
Default is <code>c(0, 1/3, 2/3, 1)</code>.</p>
</td></tr>
<tr><td><code id="data.preproc.mean_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="data.preproc.mean_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'gaussian'</code>, <code>'twoReg'</code>, <code>'contrastReg'</code>,
<code>'randomForest'</code>, <code>'gam'</code>.</p>
</td></tr>
<tr><td><code id="data.preproc.mean_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates. Only applies when <code>score.method</code>
includes <code>'twoReg'</code> or <code>'contrastReg'</code>. Allowed values include one of
<code>'boosting'</code>, <code>'poisson'</code> (fast), and <code>'gam'</code>. Default is <code>NULL</code>, which assigns
<code>'boosting'</code> for count outcomes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 6 elements:
- y: outcome; vector of length <code>n</code> (observations)
- trt: binary treatment; vector of length <code>n</code>
- x.ps: matrix of <code>p.ps</code> baseline covariates (plus intercept); dimension <code>n</code> by <code>p.ps + 1</code>
- x.cate: matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code>
- x.init: matrix of <code>p.init</code> baseline covariates; dimension <code>n</code> by <code>p.init</code>
- if <code>fun = "pm"</code>:
- prop: formatted <code>prop.cutoff</code>
- if <code>fun = "cv"</code>
- prop.onlyhigh: formatted <code>prop.cutoff</code> with 0 removed if applicable
- prop.bi; formatted <code>prop.cutoff</code> with 0 and 1 removed if applicable
- prop.multi: formatted <code>prop.multi</code>, starting with 0 and ending with 1
</p>

<hr>
<h2 id='data.preproc.surv'>Data preprocessing
Apply at the beginning of <code>catefitcount()</code>, <code>catecvcount()</code>, <code>catefitsurv()</code>, and <code>catecvsurv()</code>, after <code>arg.checks()</code></h2><span id='topic+data.preproc.surv'></span>

<h3>Description</h3>

<p>Data preprocessing
Apply at the beginning of <code>catefitcount()</code>, <code>catecvcount()</code>, <code>catefitsurv()</code>, and <code>catecvsurv()</code>, after <code>arg.checks()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.preproc.surv(
  fun,
  cate.model,
  ps.model,
  ipcw.model = NULL,
  tau0 = NULL,
  data,
  prop.cutoff = NULL,
  prop.multi = NULL,
  ps.method,
  initial.predictor.method = NULL,
  response = "count"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.preproc.surv_+3A_fun">fun</code></td>
<td>
<p>A function for which argument check is needed; &quot;catefit&quot; for <code>catefitcount()</code> and <code>catefitsurv()</code>,
&quot;crossv&quot; for <code>catecvcount()</code> and <code>catecvsurv()</code>,
and &quot;drinf&quot; for <code>drcount.inference()</code> and <code>drsurv.inference()</code>. No default.</p>
</td></tr>
<tr><td><code id="data.preproc.surv_+3A_cate.model">cate.model</code></td>
<td>
<p>A formula describing the outcome model to be fitted.
The outcome must appear on the left-hand side.</p>
</td></tr>
<tr><td><code id="data.preproc.surv_+3A_ps.model">ps.model</code></td>
<td>
<p>A formula describing the propensity score model to be fitted.
The treatment must appear on the left-hand side. The treatment must be a numeric vector
coded as 0/1. If data are from a RCT, specify <code>ps.model</code> as an intercept-only model.</p>
</td></tr>
<tr><td><code id="data.preproc.surv_+3A_ipcw.model">ipcw.model</code></td>
<td>
<p>A formula describing inverse probability of censoring weighting(IPCW) model to be fitted.
If covariates are the same as outcome model, set <code>ipcw.model = NULL</code>.
Otherwise, the left-hand side must be empty and the right-hand side is a covariates model.</p>
</td></tr>
<tr><td><code id="data.preproc.surv_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost. Default is <code>NULL</code>,
which corresponds to setting the truncation time as the maximum survival time in the data</p>
</td></tr>
<tr><td><code id="data.preproc.surv_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the outcome, propensity score, and IPCW models;
a data frame with <code>n</code> rows (1 row per observation).</p>
</td></tr>
<tr><td><code id="data.preproc.surv_+3A_prop.cutoff">prop.cutoff</code></td>
<td>
<p>A vector of numerical values (in (0, 1]) specifying percentiles of the
estimated log CATE scores to define nested subgroups. Each element represents the cutoff to
separate observations in nested subgroups (below vs above cutoff).
The length of <code>prop.cutoff</code> is the number of nested subgroups.
An equally-spaced sequence of proportions ending with 1 is recommended.
Default is <code>seq(0.5, 1, length = 6)</code>.</p>
</td></tr>
<tr><td><code id="data.preproc.surv_+3A_prop.multi">prop.multi</code></td>
<td>
<p>A vector of numerical values (in [0, 1]) specifying percentiles of the
estimated log CATE scores to define mutually exclusive subgroups.
It should start with 0, end with 1, and be of <code>length(prop.multi) &gt; 2</code>.
Each element represents the cutoff to separate the observations into
<code>length(prop.multi) - 1</code> mutually exclusive subgroups.
Default is <code>c(0, 1/3, 2/3, 1)</code>.</p>
</td></tr>
<tr><td><code id="data.preproc.surv_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="data.preproc.surv_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates. Only applies when <code>score.method</code>
includes <code>'twoReg'</code> or <code>'contrastReg'</code>. Allowed values include one of
<code>'randomForest'</code> (survival outcomes only), <code>'boosting'</code>, <code>'logistic'</code>
(survival outcomes only, fast), <code>'poisson'</code> (count outcomes only, fast), and
<code>'gam'</code> (count outcomes only). Default is <code>NULL</code>, which assigns <code>'boosting'</code>
for count outcomes and <code>'randomForest'</code> for survival outcomes.</p>
</td></tr>
<tr><td><code id="data.preproc.surv_+3A_response">response</code></td>
<td>
<p>The type of response variables; <code>count</code> (default) or <code>survival</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of elements:
- y: outcome; vector of length <code>n</code> (observations)
- d : the event indicator; vector of length <code>n</code>; only if <code>respone = "survival"</code>
- trt: binary treatment; vector of length <code>n</code>
- x.ps: matrix of <code>p.ps</code> baseline covariates specified in the propensity score model (plus intercept); dimension <code>n</code> by <code>p.ps + 1</code>
- x.cate: matrix of <code>p.cate</code> baseline covariates specified in the outcome model; dimension <code>n</code> by <code>p.cate</code>
- x.ipcw: matrix of <code>p.ipw</code> baseline covarites specified in inverse probability of censoring weighting model; dimension <code>n</code> by <code>p.ipw</code>
- time: offset; vector of length <code>n</code>; only if <code>response = "count"</code>
- if <code>fun = "catefit"</code>:
- prop: formatted <code>prop.cutoff</code>
- prop.no1: formatted <code>prop.cutoff</code> with 1 removed if applicable; otherwise prop.no1 is the same as prop
- if <code>fun = "crossv"</code>
- prop.onlyhigh: formatted <code>prop.cutoff</code> with 0 removed if applicable
- prop.bi; formatted <code>prop.cutoff</code> with 0 and 1 removed if applicable
- prop.multi: formatted <code>prop.multi</code>, starting with 0 and ending with 1
</p>

<hr>
<h2 id='drcount'>Doubly robust estimator of the average treatment effect for count data</h2><span id='topic+drcount'></span>

<h3>Description</h3>

<p>Doubly robust estimator of the average treatment effect between two
treatments, which is the rate ratio of treatment 1 over treatment 0 for
count outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drcount(
  y,
  trt,
  x.cate,
  x.ps,
  time,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99,
  interactions = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drcount_+3A_y">y</code></td>
<td>
<p>A numeric vector of size <code>n</code> with each element representing
the observed count outcome for each subject.</p>
</td></tr>
<tr><td><code id="drcount_+3A_trt">trt</code></td>
<td>
<p>A numeric vector (in 0, 1) of size <code>n</code> with each element
representing the treatment received for each subject.</p>
</td></tr>
<tr><td><code id="drcount_+3A_x.cate">x.cate</code></td>
<td>
<p>A numeric matrix of dimension <code>n</code> by <code>p.cate</code> with
each column representing each baseline covariate specified in the outcome
model for all subjects.</p>
</td></tr>
<tr><td><code id="drcount_+3A_x.ps">x.ps</code></td>
<td>
<p>A numeric matrix of dimension <code>n</code> by <code>p.ps + 1</code> with
a leading column of 1 as the intercept and each remaining column
representing each baseline covariate specified in the propensity score model
for all subjects.</p>
</td></tr>
<tr><td><code id="drcount_+3A_time">time</code></td>
<td>
<p>A numeric vector of size <code>n</code> with each element representing
the log-transformed person-years of follow-up for each subject.</p>
</td></tr>
<tr><td><code id="drcount_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity
score. Allowed values include one of: <code>'glm'</code> for logistic regression
with main effects only (default), or <code>'lasso'</code> for a logistic regression
with main effects and LASSO penalization on two-way interactions (added to
the model if interactions are not specified in <code>ps.model</code>). Relevant
only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="drcount_+3A_minps">minPS</code></td>
<td>
<p>A numerical value between 0 and 1 below which estimated
propensity scores should be truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="drcount_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value between 0 and 1 above which estimated
propensity scores should be truncated. Must be strictly greater than
<code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="drcount_+3A_interactions">interactions</code></td>
<td>
<p>A logical value indicating whether the outcome model
should allow for treatment-covariate interaction by <code>x</code>. If <code>TRUE</code>,
interactions will be assumed only if at least 10 patients received each
treatment option. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list of 4 elements:
</p>

<ul>
<li><p><code>log.rate.ratio</code>:  A numeric value of the estimated log rate ratio.
</p>
</li>
<li><p><code>rate0</code>:  A numeric value of the estimated rate in the group trt=0.
</p>
</li>
<li><p><code>rate1</code>:  A numeric value of the estimated rate in the group trt=1.
</p>
</li></ul>


<hr>
<h2 id='drmean'>Doubly robust estimator of the average treatment effect for continuous data</h2><span id='topic+drmean'></span>

<h3>Description</h3>

<p>Doubly robust estimator of the average treatment effect between two
treatments, which is the mean difference of treatment 1 over treatment 0 for
continuous outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drmean(
  y,
  trt,
  x.cate,
  x.ps,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99,
  interactions = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drmean_+3A_y">y</code></td>
<td>
<p>A numeric vector of size <code>n</code> with each element representing
the observed continuous outcome for each subject.</p>
</td></tr>
<tr><td><code id="drmean_+3A_trt">trt</code></td>
<td>
<p>A numeric vector (in 0, 1) of size <code>n</code> with each element
representing the treatment received for each subject.</p>
</td></tr>
<tr><td><code id="drmean_+3A_x.cate">x.cate</code></td>
<td>
<p>A numeric matrix of dimension <code>n</code> by <code>p.cate</code> with
each column representing each baseline covariate specified in the outcome
model for all subjects.</p>
</td></tr>
<tr><td><code id="drmean_+3A_x.ps">x.ps</code></td>
<td>
<p>A numeric matrix of dimension <code>n</code> by <code>p.ps + 1</code> with
a leading column of 1 as the intercept and each remaining column representing
each baseline covariate specified in the propensity score model for all
subjects</p>
</td></tr>
<tr><td><code id="drmean_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity
score. Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO
penalization on two-way interactions (added to the model if interactions are
not specified in <code>ps.model</code>). Relevant only when <code>ps.model</code> has
more than one variable.</p>
</td></tr>
<tr><td><code id="drmean_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity
scores should be truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="drmean_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity
scores should be truncated. Must be strictly greater than <code>minPS</code>.
Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="drmean_+3A_interactions">interactions</code></td>
<td>
<p>A logical value indicating whether the outcome model
should assume interactions between <code>x</code> and <code>trt</code>. If <code>TRUE</code>,
interactions will be assumed only if at least 10 patients received each
treatment option. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list of 4 elements:
</p>

<ul>
<li><p><code>mean.diff</code>:  A numeric value of the estimated mean difference.
</p>
</li>
<li><p><code>mean.diff0</code>:  A numeric value of the estimated mean difference
in treatment group 0.
</p>
</li>
<li><p><code>mean.diff1</code>:  A numeric value of the estimated mean difference
in treatment group 1.
</p>
</li></ul>


<hr>
<h2 id='drsurv'>Doubly robust estimator of the average treatment effect with Cox model for survival data</h2><span id='topic+drsurv'></span>

<h3>Description</h3>

<p>Doubly robust estimator of the average treatment effect between two treatments, which is the restricted mean time lost (RMTL) ratio
of treatment 1 over treatment 0 for survival outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drsurv(
  y,
  d,
  x.cate,
  x.ps,
  x.ipcw,
  trt,
  yf = NULL,
  tau0,
  surv.min = 0.025,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99,
  ipcw.method = "breslow"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drsurv_+3A_y">y</code></td>
<td>
<p>Observed survival or censoring time; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_d">d</code></td>
<td>
<p>The event indicator, normally <code>1 = event, 0 = censored</code>; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates specified in the outcome model; dimension <code>n</code> by <code>p.cate</code>.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates specified in the propensity score model; dimension <code>n</code> by <code>p.ps</code>.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_x.ipcw">x.ipcw</code></td>
<td>
<p>Matrix of <code>p.ipw</code> baseline covariate specified in inverse probability of censoring weighting; dimension <code>n</code> by <code>p.ipw</code>.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> with treatment coded as 0/1.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_yf">yf</code></td>
<td>
<p>Follow-up time, interpreted as the potential censoring time; vector of size <code>n</code> if the potential censoring time is known.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for probability of being censored (positive and very close to 0).</p>
</td></tr>
<tr><td><code id="drsurv_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score. Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="drsurv_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>The censoring model. Allowed values are: <code>'breslow'</code> (Cox regression with Breslow estimator of the baseline survivor function),
<code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>, <code>'aft (lognormal)'</code> or <code>'aft (loglogistic)'</code>. Default is <code>'breslow'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list of 4 elements:
</p>

<ul>
<li><p><code>rmst1</code>:  A numeric value of the estimated restricted mean survival time n the group <code>trt = 1</code>.
</p>
</li>
<li><p><code>rmst0</code>:  A numeric value of the estimated restricted mean survival time n the group <code>trt = 0</code>.
</p>
</li>
<li><p><code>log.rmtl.ratio</code>:  A numeric value of the estimated log rmtl ratio.
</p>
</li>
<li><p><code>log.hazard.ratio</code>:  A numeric value of the estimated log hazard ratio.
</p>
</li></ul>


<hr>
<h2 id='estcount.bilevel.subgroups'>Estimate the Average Treatment Effect of the log risk ratio in multiple
bi-level subgroups defined by the proportions</h2><span id='topic+estcount.bilevel.subgroups'></span>

<h3>Description</h3>

<p>If only care about the higher subgroup (above cutoff), only need trt.est.high so set <code>onlyhigh</code> to be TRUE
Scores are adjusted to the opposite sign if <code>higher.y</code> == FALSE; scores stay the same if <code>higher.y</code> == TRUE;
this is because estcount.bilevel.subgroups() always takes the subgroup of the top highest adjusted scores,
and higher adjusted scores should always represent high responders of trt=1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estcount.bilevel.subgroups(
  y,
  x.cate,
  x.ps,
  time,
  trt,
  score,
  higher.y,
  prop,
  onlyhigh,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estcount.bilevel.subgroups_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code> (observations)</p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code> (covariates in the outcome model)</p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept);
dimension <code>n</code> by <code>p.ps + 1</code> (covariates in the propensity score model plus intercept)</p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_time">time</code></td>
<td>
<p>Log-transformed person-years of follow-up; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> units with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_score">score</code></td>
<td>
<p>Estimated log CATE scores for all <code>n</code> observations from one of the four methods
(boosting, naive Poisson, two regressions, contrast regression); vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or lower (<code>FALSE</code>)
values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_prop">prop</code></td>
<td>
<p>Proportions corresponding to percentiles in the estimated log CATE scores that define subgroups to calculate ATE for;
vector of floats in (0,1] (if onlyhigh=T) or in (0,1) (if onlyhigh=F):
Each element of <code>prop</code> represents the high/low cutoff in each bi-level subgroup and the length of <code>prop</code>
is number of bi-level subgroups</p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_onlyhigh">onlyhigh</code></td>
<td>
<p>Indicator of returning only the ATEs in the higher-than-cutoff category of the bi-level subgroups; boolean</p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score. Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="estcount.bilevel.subgroups_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ate.est.high: estimated ATEs in the multiple bi-level subgroups that are in the higher-than-cutoff category;
vector of size equal to the length of prop; always returned
ate.est.low: estimated ATEs in the multiple bi-level subgroups that are in the lower-than-cutoff category;
vector of size equal to the length of prop; returned only when <code>onlyhigh</code> == TRUE
</p>

<hr>
<h2 id='estcount.multilevel.subgroup'>Estimate the ATE of the log RR ratio in one multilevel subgroup defined by the proportions</h2><span id='topic+estcount.multilevel.subgroup'></span>

<h3>Description</h3>

<p>Scores are adjusted to the opposite sign if <code>higher.y</code> == FALSE; scores stay the same if <code>higher.y</code> == TRUE;
this is because subgroups defined in estcount.multilevel.subgroup() start from the lowest to the highest adjusted scores,
and higher adjusted scores should always represent high responders of trt=1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estcount.multilevel.subgroup(
  y,
  x.cate,
  x.ps,
  time,
  trt,
  score,
  higher.y,
  prop,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estcount.multilevel.subgroup_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code> (observations)</p>
</td></tr>
<tr><td><code id="estcount.multilevel.subgroup_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code> (covariates in the outcome model)</p>
</td></tr>
<tr><td><code id="estcount.multilevel.subgroup_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept);
dimension <code>n</code> by <code>p.ps + 1</code> (covariates in the propensity score model plus intercept)</p>
</td></tr>
<tr><td><code id="estcount.multilevel.subgroup_+3A_time">time</code></td>
<td>
<p>Log-transformed person-years of follow-up; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="estcount.multilevel.subgroup_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> units with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="estcount.multilevel.subgroup_+3A_score">score</code></td>
<td>
<p>Estimated log CATE scores for all <code>n</code> observations from one of the four methods
(boosting, naive Poisson, two regressions, contrast regression); vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="estcount.multilevel.subgroup_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or lower (<code>FALSE</code>)
values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estcount.multilevel.subgroup_+3A_prop">prop</code></td>
<td>
<p>Proportions corresponding to percentiles in the estimated log CATE scores that define subgroups to calculate ATE for;
vector of floats in [0,1] always starting with 0 and ending with 1:
Each element of <code>prop</code> represents inclusive cutoffs in the multilevel subgroup and the length of <code>prop</code>
is number of categories in the multilevel subgroup</p>
</td></tr>
<tr><td><code id="estcount.multilevel.subgroup_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score. Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="estcount.multilevel.subgroup_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="estcount.multilevel.subgroup_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated ATEs of all categories in the one multilevel subgroup; vector of size equal to the length of categories in the multilevel subgroup
</p>

<hr>
<h2 id='estmean.bilevel.subgroups'>Estimate the ATE of the mean difference in multiple bi-level subgroups
defined by the proportions</h2><span id='topic+estmean.bilevel.subgroups'></span>

<h3>Description</h3>

<p>If only care about the higher subgroup (above cutoff), only need
trt.est.high so set <code>onlyhigh</code> to be TRUE. Scores are adjusted to the
opposite sign if <code>higher.y</code> == FALSE; scores stay the same if
<code>higher.y</code> == TRUE. This is because <code>estcount.bilevel.subgroups</code>()
always takes the subgroup of the top highest adjusted scores,and higher
adjusted scores should always represent high responders in treatment group 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estmean.bilevel.subgroups(
  y,
  x.cate,
  x.ps,
  trt,
  score,
  higher.y,
  prop,
  onlyhigh,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estmean.bilevel.subgroups_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code> (observations)</p>
</td></tr>
<tr><td><code id="estmean.bilevel.subgroups_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code> (covariates in the outcome model)</p>
</td></tr>
<tr><td><code id="estmean.bilevel.subgroups_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept);
dimension <code>n</code> by <code>p.ps + 1</code> (covariates in the propensity score model plus intercept)</p>
</td></tr>
<tr><td><code id="estmean.bilevel.subgroups_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> units with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="estmean.bilevel.subgroups_+3A_score">score</code></td>
<td>
<p>Estimated CATE scores for all <code>n</code> observations from one of the six methods
(boosting, linear regression, two regressions, contrast regression, random forest, generalized additive model); vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="estmean.bilevel.subgroups_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or lower (<code>FALSE</code>)
values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estmean.bilevel.subgroups_+3A_prop">prop</code></td>
<td>
<p>Proportions corresponding to percentiles in the estimated CATE scores that define subgroups to calculate ATE for;
vector of floats in (0,1] (if onlyhigh=T) or in (0,1) (if onlyhigh=F):
Each element of <code>prop</code> represents the high/low cutoff in each bi-level subgroup and the length of <code>prop</code>
is number of bi-level subgroups</p>
</td></tr>
<tr><td><code id="estmean.bilevel.subgroups_+3A_onlyhigh">onlyhigh</code></td>
<td>
<p>Indicator of returning only the ATEs in the higher-than-cutoff category of the bi-level subgroups; boolean</p>
</td></tr>
<tr><td><code id="estmean.bilevel.subgroups_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score. Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="estmean.bilevel.subgroups_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="estmean.bilevel.subgroups_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ate.est.high: estimated ATEs in the multiple bi-level subgroups that are in the higher-than-cutoff category;
vector of size equal to the length of prop; always returned
ate.est.low: estimated ATEs in the multiple bi-level subgroups that are in the lower-than-cutoff category;
vector of size equal to the length of prop; returned only when <code>onlyhigh</code> == TRUE
</p>

<hr>
<h2 id='estmean.multilevel.subgroup'>Estimate the ATE of the mean difference in one multilevel subgroup defined by the proportions</h2><span id='topic+estmean.multilevel.subgroup'></span>

<h3>Description</h3>

<p>Scores are adjusted to the opposite sign if <code>higher.y</code> == FALSE; scores stay the same if <code>higher.y</code> == TRUE;
this is because subgroups defined in estmean.multilevel.subgroup() start from the lowest to the highest adjusted scores,
and higher adjusted scores should always represent high responders of trt=1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estmean.multilevel.subgroup(
  y,
  x.cate,
  x.ps,
  trt,
  score,
  higher.y,
  prop,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estmean.multilevel.subgroup_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code> (observations)</p>
</td></tr>
<tr><td><code id="estmean.multilevel.subgroup_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code> (covariates in the outcome model)</p>
</td></tr>
<tr><td><code id="estmean.multilevel.subgroup_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept);
dimension <code>n</code> by <code>p.ps + 1</code> (covariates in the propensity score model plus intercept)</p>
</td></tr>
<tr><td><code id="estmean.multilevel.subgroup_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> units with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="estmean.multilevel.subgroup_+3A_score">score</code></td>
<td>
<p>Estimated CATE scores for all <code>n</code> observations from one of the six methods
(boosting, linear regression, two regressions, contrast regression, random forest, generalized additive model); vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="estmean.multilevel.subgroup_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or lower (<code>FALSE</code>)
values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estmean.multilevel.subgroup_+3A_prop">prop</code></td>
<td>
<p>Proportions corresponding to percentiles in the estimated CATE scores that define subgroups to calculate ATE for;
vector of floats in [0,1] always starting with 0 and ending with 1:
Each element of <code>prop</code> represents inclusive cutoffs in the multilevel subgroup and the length of <code>prop</code>
is number of categories in the multilevel subgroup</p>
</td></tr>
<tr><td><code id="estmean.multilevel.subgroup_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score. Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="estmean.multilevel.subgroup_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="estmean.multilevel.subgroup_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimated ATEs of all categories in the one multilevel subgroup; vector of size equal to the length of categories in the multilevel subgroup
</p>

<hr>
<h2 id='estsurv.bilevel.subgroups'>Estimate the ATE of the RMTL ratio and unadjusted hazard ratio in multiple bi-level subgroups defined by the proportions</h2><span id='topic+estsurv.bilevel.subgroups'></span>

<h3>Description</h3>

<p>If only care about the higher subgroup (above cutoff), only need ate.rmtl.high and hr.high so set &quot;onlyhigh&quot; to be TRUE
Scores are adjusted to the opposite sign if <code>higher.y</code> == FALSE; scores stay the same if <code>higher.y</code> == FALSE;
this is because estsurv() function always takes the subgroup of the top highest adjusted scores,
and higher adjusted scores should always represent high responders of trt=1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estsurv.bilevel.subgroups(
  y,
  d,
  x.cate,
  x.ps,
  x.ipcw,
  trt,
  yf,
  tau0 = tau0,
  score,
  higher.y,
  prop,
  onlyhigh,
  surv.min = 0.025,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99,
  ipcw.method = "breslow"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_y">y</code></td>
<td>
<p>Observed survival or censoring time; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_d">d</code></td>
<td>
<p>The event indicator, normally <code>1 = event, 0 = censored</code>; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates specified in the outcome model; dimension <code>n</code> by <code>p.cate</code>.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates specified in the propensity score model; dimension <code>n</code> by <code>p.ps</code>.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_x.ipcw">x.ipcw</code></td>
<td>
<p>Matrix of <code>p.ipw</code> baseline covariate specified in inverse probability of censoring weighting; dimension <code>n</code> by <code>p.ipw</code>.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> with treatment coded as 0/1.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_yf">yf</code></td>
<td>
<p>Follow-up time, interpreted as the potential censoring time; vector of size <code>n</code> if the potential censoring time is known.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_score">score</code></td>
<td>
<p>Estimated log CATE scores for all <code>n</code> observations from one of the five methods
(random forest, boosting, naive Poisson, two regressions, contrast regression); vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or lower (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_prop">prop</code></td>
<td>
<p>Proportions corresponding to percentiles in the estimated log CATE scores that define subgroups to calculate ATE for;
vector of floats in (0,1] (if <code>onlyhigh=TRUE</code>) or in (0,1) (if <code>onlyhigh=FALSE</code>):
Each element of <code>prop</code> represents the high/low cutoff in each bi-level subgroup and the length of <code>prop</code>
is number of bi-level subgroups</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_onlyhigh">onlyhigh</code></td>
<td>
<p>Indicator of returning only the ATEs in the higher-than-cutoff category of the bi-level subgroups; boolean.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for probability of being censored (positive and very close to 0).</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score. Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="estsurv.bilevel.subgroups_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>The censoring model. Allowed values are: <code>'breslow'</code> (Cox regression with Breslow estimator of the baseline survivor function),
<code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>, <code>'aft (lognormal)'</code> or <code>'aft (loglogistic)'</code>. Default is <code>'breslow'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ate.rmtl.high: estimated ATEs (ratio of RMTL) in the multiple bi-level subgroups that are in the higher-than-cutoff category;
vector of size equal to the length of prop; always returned.
ate.rmtl.low: estimated ATEs (ratio of RMTL) in the multiple bi-level subgroups that are in the lower-than-cutoff category;
vector of size equal to the length of prop; returned only when <code>onlyhigh = TRUE</code>.
hr.high: unadjusted hazard ratio in the multiple bi-level subgroups that are in the higher-than-cutoff category;
vector of size equal to the length of prop; always returned.
hr.low: unadjusted hazard ratio in the multiple bi-level subgroups that are in the lower-than-cutoff category;
vector of size equal to the length of prop; returned only when <code>onlyhigh = TRUE</code>
</p>

<hr>
<h2 id='estsurv.multilevel.subgroups'>Estimate the ATE of the RMTL ratio and unadjusted hazard ratio in one multilevel subgroup defined by the proportions</h2><span id='topic+estsurv.multilevel.subgroups'></span>

<h3>Description</h3>

<p>Scores are adjusted to the opposite sign if <code>higher.y</code> == FALSE; scores stay the same if <code>higher.y</code> == FALSE;
this is because estsurv function for multilevel subgroups start from the lowest to the highest adjusted scores,
and higher adjusted scores should always represent high responders of trt=1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estsurv.multilevel.subgroups(
  y,
  d,
  x.cate,
  x.ps,
  x.ipcw,
  trt,
  yf,
  tau0 = tau0,
  score,
  higher.y,
  prop,
  surv.min = 0.025,
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99,
  ipcw.method = "breslow"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_y">y</code></td>
<td>
<p>Observed survival or censoring time; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_d">d</code></td>
<td>
<p>The event indicator, normally <code>1 = event, 0 = censored</code>; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates specified in the outcome model; dimension <code>n</code> by <code>p.cate</code>.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates specified in the propensity score model; dimension <code>n</code> by <code>p.ps</code>.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_x.ipcw">x.ipcw</code></td>
<td>
<p>Matrix of <code>p.ipw</code> baseline covariate specified in inverse probability of censoring weighting; dimension <code>n</code> by <code>p.ipw</code>.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> with treatment coded as 0/1.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_yf">yf</code></td>
<td>
<p>Follow-up time, interpreted as the potential censoring time; vector of size <code>n</code> if the potential censoring time is known.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_score">score</code></td>
<td>
<p>Estimated log CATE scores for all <code>n</code> observations from one of the five methods
(random forest, boosting, naive Poisson, two regressions, contrast regression); vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_higher.y">higher.y</code></td>
<td>
<p>A logical value indicating whether higher (<code>TRUE</code>) or
lower (<code>FALSE</code>) values of the outcome are more desirable. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_prop">prop</code></td>
<td>
<p>Proportions corresponding to percentiles in the estimated log CATE scores that define subgroups to calculate ATE for;
vector of floats in [0,1] always starting with 0 and ending with 1:
Each element of <code>prop</code> represents inclusive cutoffs in the multilevel subgroup and the length of <code>prop</code>
is number of categories in the multilevel subgroup</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for probability of being censored (positive and very close to 0).</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score. Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="estsurv.multilevel.subgroups_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>The censoring model. Allowed values are: <code>'breslow'</code> (Cox regression with Breslow estimator of the baseline survivor function),
<code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>, <code>'aft (lognormal)'</code> or <code>'aft (loglogistic)'</code>. Default is <code>'breslow'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ate.rmtl: estimated ATEs (ratio of RMTL) of all categories in the one multilevel subgroup;
vector of size equal to the length of categories in the multilevel subgroup.
ate.hr: unadjusted hazard ratio of all categories in the one multilevel subgroup;
vector of size equal to the length of categories in the multilevel subgroup.
</p>

<hr>
<h2 id='glm.ps'>Propensity score estimation with LASSO</h2><span id='topic+glm.ps'></span>

<h3>Description</h3>

<p>Propensity score based on a multivariate logistic regression with LASSO penalization on the two-way interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.ps(trt, x.ps, xnew = NULL, minPS = 0.01, maxPS = 0.99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.ps_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> (observations) with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="glm.ps_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept);
dimension <code>n</code> by <code>p.ps + 1</code> (covariates in the propensity score model plus intercept)</p>
</td></tr>
<tr><td><code id="glm.ps_+3A_xnew">xnew</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept)
for which we want propensity scores predictions; dimension <code>m</code> (observations in the new data set) by <code>p.ps + 1</code></p>
</td></tr>
<tr><td><code id="glm.ps_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="glm.ps_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The trimmed propensity score for each unit; vector of size <code>n</code> (if <code>xnew</code> is NULL) or <code>m</code>
</p>

<hr>
<h2 id='glm.simplereg.ps'>Propensity score estimation with a linear model</h2><span id='topic+glm.simplereg.ps'></span>

<h3>Description</h3>

<p>Propensity score based on a multivariate logistic regression with main effects only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.simplereg.ps(trt, x.ps, xnew = NULL, minPS = 0.01, maxPS = 0.99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.simplereg.ps_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> (observations) with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="glm.simplereg.ps_+3A_x.ps">x.ps</code></td>
<td>
<p>A matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept);
dimension <code>n</code> by <code>p.ps + 1</code> (covariates in the propensity score model plus intercept)</p>
</td></tr>
<tr><td><code id="glm.simplereg.ps_+3A_xnew">xnew</code></td>
<td>
<p>A matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept)
for which we want PS predictions; dimension <code>m</code> (observations in the new data set) by <code>p.ps + 1</code></p>
</td></tr>
<tr><td><code id="glm.simplereg.ps_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="glm.simplereg.ps_+3A_maxps">maxPS</code></td>
<td>
<p>A numerical value (in (0, 1]) above which estimated propensity scores should be
truncated. Must be strictly greater than <code>minPS</code>. Default is <code>0.99</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated propensity score for each unit; vector of size <code>n</code> (if <code>xnew</code> is NULL) or <code>m</code>
</p>

<hr>
<h2 id='intxcount'>Estimate the CATE model using specified scoring methods</h2><span id='topic+intxcount'></span>

<h3>Description</h3>

<p>Coefficients of the CATE estimated with boosting, naive Poisson, two regression, contrast regression, negative binomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intxcount(
  y,
  trt,
  x.cate,
  x.ps,
  time,
  score.method = c("boosting", "poisson", "twoReg", "contrastReg", "negBin"),
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99,
  initial.predictor.method = "boosting",
  xvar.smooth = NULL,
  tree.depth = 2,
  n.trees.boosting = 200,
  B = 3,
  Kfold = 6,
  plot.gbmperf = TRUE,
  error.maxNR = 0.001,
  max.iterNR = 150,
  tune = c(0.5, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intxcount_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code> (observations)</p>
</td></tr>
<tr><td><code id="intxcount_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> units with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="intxcount_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code> (covariates in the outcome model)</p>
</td></tr>
<tr><td><code id="intxcount_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept);
dimension <code>n</code> by <code>p.ps + 1</code> (covariates in the propensity score model plus intercept)</p>
</td></tr>
<tr><td><code id="intxcount_+3A_time">time</code></td>
<td>
<p>Log-transformed person-years of follow-up; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="intxcount_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'poisson'</code>, <code>'twoReg'</code>, <code>'contrastReg'</code>,
<code>'negBin'</code>. Default specifies all 5 methods.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_maxps">maxPS</code></td>
<td>
<p>A number above which estimated propensity scores should be trimmed; scalar</p>
</td></tr>
<tr><td><code id="intxcount_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates in <code>cate.model</code>
in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Allowed values include
one of <code>'poisson'</code> (fastest), <code>'boosting'</code> (default) and <code>'gam'</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_xvar.smooth">xvar.smooth</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>initial.predictor.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>cate.model</code>.
Default is <code>NULL</code>, which uses all variables in <code>cate.model</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds (parts) used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>6</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="intxcount_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>gbm()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on what score.method is, the outputs is a combination of the following:
result.boosting: Results of boosting fit and best iteration, for trt = 0 and trt = 1 separately
result.poisson: Naive Poisson estimator (beta1 - beta0); vector of length <code>p.cate</code> + 1
result.twoReg: Two regression estimator (beta1 - beta0); vector of length <code>p.cate</code> + 1
result.contrastReg: A list of the contrast regression results with 3 elements:
$delta.contrastReg: Contrast regression DR estimator; vector of length <code>p.cate</code> + 1
$sigma.contrastReg: Variance covariance matrix for delta.contrastReg; matrix of size <code>p.cate</code> + 1 by <code>p.cate</code> + 1
$converge.contrastReg: Indicator that the Newton Raphson algorithm converged for <code>delta_0</code>; boolean
result.negBin: Negative binomial estimator (beta1 - beta0); vector of length <code>p.cate</code> + 1
best.iter: Largest best iterations for boosting (if used)
fgam: Formula applied in GAM (if used)
</p>

<hr>
<h2 id='intxmean'>Estimate the CATE model using specified scoring methods</h2><span id='topic+intxmean'></span>

<h3>Description</h3>

<p>Coefficients of the CATE estimated with boosting, linear regression, two regression, contrast regression, random forest, generalized additive model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intxmean(
  y,
  trt,
  x.cate,
  x.init,
  x.ps,
  score.method = c("boosting", "gaussian", "twoReg", "contrastReg", "gam",
    "randomForest"),
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99,
  initial.predictor.method = "boosting",
  xvar.smooth.init,
  xvar.smooth.score,
  tree.depth = 2,
  n.trees.rf = 1000,
  n.trees.boosting = 200,
  B = 1,
  Kfold = 2,
  plot.gbmperf = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intxmean_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code> (observations)</p>
</td></tr>
<tr><td><code id="intxmean_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> units with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="intxmean_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code> (covariates in the outcome model)</p>
</td></tr>
<tr><td><code id="intxmean_+3A_x.init">x.init</code></td>
<td>
<p>Matrix of <code>p.init</code> baseline covariates; dimension <code>n</code> by <code>p.init</code>
It must be specified when <code>score.method = contrastReg</code> or <code>twoReg</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates (plus a leading column of 1 for the intercept);
dimension <code>n</code> by <code>p.ps + 1</code> (covariates in the propensity score model plus intercept)</p>
</td></tr>
<tr><td><code id="intxmean_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'gaussian'</code>, <code>'twoReg'</code>, <code>'contrastReg'</code>,
<code>'randomForest'</code>, <code>'gam'</code>. Default specifies all 6 methods.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_ps.method">ps.method</code></td>
<td>
<p>A character value for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_maxps">maxPS</code></td>
<td>
<p>A number above which estimated propensity scores should be trimmed; scalar</p>
</td></tr>
<tr><td><code id="intxmean_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates in <code>cate.model</code>
in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Allowed values include
one of <code>'gaussian'</code> (fastest), <code>'boosting'</code> (default) and <code>'gam'</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_xvar.smooth.init">xvar.smooth.init</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>initial.predictor.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>init.model</code>.
Default is <code>NULL</code>, which uses all variables in <code>init.model</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_xvar.smooth.score">xvar.smooth.score</code></td>
<td>
<p>A vector of characters indicating the name of the variables used as
the smooth terms if <code>score.method = 'gam'</code>. The variables must be selected
from the variables listed in <code>cate.model</code>.
Default is <code>NULL</code>, which uses all variables in <code>cate.model</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_n.trees.rf">n.trees.rf</code></td>
<td>
<p>A positive integer specifying the number of trees. Used only if
<code>score.method = 'randomForest'</code>. Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds (parts) used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>6</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="intxmean_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>gbm()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on what score.method is, the outputs is a combination of the following:
result.boosting: Results of boosting fit and best iteration, for trt = 0 and trt = 1 separately
result.gaussian: Linear regression estimator (beta1 - beta0); vector of length <code>p.cate</code> + 1
result.twoReg: Two regression estimator (beta1 - beta0); vector of length <code>p.cate</code> + 1
result.contrastReg: A list of the contrast regression results with 3 elements:
$delta.contrastReg: Contrast regression DR estimator; vector of length <code>p.cate</code> + 1
$sigma.contrastReg: Variance covariance matrix for delta.contrastReg; matrix of size <code>p.cate</code> + 1 by <code>p.cate</code> + 1
result.randomForest: Results of random forest fit and best iteration, for trt = 0 and trt = 1 separately
result.gam: Results of generalized additive model fit and best iteration, for trt = 0 and trt = 1 separately
best.iter: Largest best iterations for boosting (if used)
fgam: Formula applied in GAM when <code>initial.predictor.method = 'gam'</code>
warn.fit: Warnings occurred when fitting <code>score.method</code>
err.fit:: Errors occurred when fitting <code>score.method</code>
</p>

<hr>
<h2 id='intxsurv'>Estimate the CATE model using specified scoring methods for survival outcomes</h2><span id='topic+intxsurv'></span>

<h3>Description</h3>

<p>Coefficients of the CATE estimated with random forest, boosting, naive Poisson, two regression, and contrast regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intxsurv(
  y,
  d,
  trt,
  x.cate,
  x.ps,
  x.ipcw,
  yf = NULL,
  tau0,
  surv.min = 0.025,
  score.method = c("randomForest", "boosting", "poisson", "twoReg", "contrastReg"),
  ps.method = "glm",
  minPS = 0.01,
  maxPS = 0.99,
  ipcw.method = "breslow",
  initial.predictor.method = "randomForest",
  tree.depth = 3,
  n.trees.rf = 1000,
  n.trees.boosting = 150,
  B = 3,
  Kfold = 5,
  plot.gbmperf = TRUE,
  error.maxNR = 0.001,
  max.iterNR = 100,
  tune = c(0.5, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intxsurv_+3A_y">y</code></td>
<td>
<p>Observed survival or censoring time; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_d">d</code></td>
<td>
<p>The event indicator, normally <code>1 = event, 0 = censored</code>; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> with treatment coded as 0/1.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates specified in the outcome model; dimension <code>n</code> by <code>p.cate</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_x.ps">x.ps</code></td>
<td>
<p>Matrix of <code>p.ps</code> baseline covariates specified in the propensity score model; dimension <code>n</code> by <code>p.ps</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_x.ipcw">x.ipcw</code></td>
<td>
<p>Matrix of <code>p.ipw</code> baseline covariate specified in inverse probability of censoring weighting; dimension <code>n</code> by <code>p.ipw</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_yf">yf</code></td>
<td>
<p>Follow-up time, interpreted as the potential censoring time; vector of size <code>n</code> if the potential censoring time is known.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for probability of being censored (positive and very close to 0).</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are:  <code>'randomForest'</code>, <code>'boosting'</code>, <code>'poisson'</code>, <code>'twoReg'</code>,
<code>'contrastReg'</code>. Default specifies all 5 methods.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_ps.method">ps.method</code></td>
<td>
<p>A character vector for the method to estimate the propensity score.
Allowed values include one of:
<code>'glm'</code> for logistic regression with main effects only (default), or
<code>'lasso'</code> for a logistic regression with main effects and LASSO penalization on
two-way interactions (added to the model if interactions are not specified in <code>ps.model</code>).
Relevant only when <code>ps.model</code> has more than one variable.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_minps">minPS</code></td>
<td>
<p>A numerical value (in [0, 1]) below which estimated propensity scores should be
truncated. Default is <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_maxps">maxPS</code></td>
<td>
<p>A number above which estimated propensity scores should be trimmed; scalar</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>The censoring model. Allowed values are: <code>'breslow'</code> (Cox regression with Breslow estimator of the baseline survivor function),
<code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>, <code>'aft (lognormal)'</code> or <code>'aft (loglogistic)'</code>. Default is <code>'breslow'</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_initial.predictor.method">initial.predictor.method</code></td>
<td>
<p>A character vector for the method used to get initial
outcome predictions conditional on the covariates in <code>cate.model</code>
in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Allowed values include
one of <code>'randomForest'</code>, <code>'boosting'</code> and <code>'logistic'</code> (fastest). Default is <code>'randomForest'</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_tree.depth">tree.depth</code></td>
<td>
<p>A positive integer specifying the depth of individual trees in boosting
(usually 2-3). Used only if <code>score.method = 'boosting'</code> or
if <code>score.method = 'twoReg'</code> or <code>'contrastReg'</code> and
<code>initial.predictor.method = 'boosting'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_n.trees.rf">n.trees.rf</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in random forest.
Used if <code>score.method = 'ranfomForest'</code> or
if <code>initial.predictor.method = 'randomForest'</code> with
<code>score.method = 'twoReg'</code> or <code>'contrastReg'</code>. Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_n.trees.boosting">n.trees.boosting</code></td>
<td>
<p>A positive integer specifying the maximum number of trees in boosting
(usually 100-1000). Used if <code>score.method = 'boosting'</code> or
if <code>initial.predictor.method = 'boosting'</code> with
<code>score.method = 'twoReg'</code> or <code>'contrastReg'</code>. Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_b">B</code></td>
<td>
<p>A positive integer specifying the number of time cross-fitting is repeated in
<code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_kfold">Kfold</code></td>
<td>
<p>A positive integer specifying the number of folds (parts) used in cross-fitting
to partition the data in <code>score.method = 'twoReg'</code> and <code>'contrastReg'</code>.
Default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_plot.gbmperf">plot.gbmperf</code></td>
<td>
<p>A logical value indicating whether to plot the performance measures in
boosting. Used only if <code>score.method = 'boosting'</code> or if <code>score.method = 'twoReg'</code>
or <code>'contrastReg'</code> and <code>initial.predictor.method = 'boosting'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
<tr><td><code id="intxsurv_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>gbm()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on what score.method is, the outputs is a combination of the following:
result.randomForest: Results of random forest fit, for trt = 0 and trt = 1 separately
result.boosting: Results of boosting fit, for trt = 0 and trt = 1 separately
result.poisson: Naive Poisson estimator (beta1 - beta0); vector of length <code>p.cate</code> + 1
result.twoReg: Two regression estimator (beta1 - beta0); vector of length <code>p.cate</code> + 1
result.contrastReg: A list of the contrast regression results with 2 elements:
$delta.contrastReg: Contrast regression DR estimator; vector of length <code>p.cate</code> + 1
$converge.contrastReg: Indicator that the Newton Raphson algorithm converged for <code>delta_0</code>; boolean
</p>

<hr>
<h2 id='ipcw.surv'>Probability of being censored</h2><span id='topic+ipcw.surv'></span>

<h3>Description</h3>

<p>Probability of being censored which is used to correct the effect of right censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipcw.surv(
  y,
  d,
  x.ipcw,
  yf = NULL,
  ipcw.method = "breslow",
  tau0,
  surv.min = 0.025
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipcw.surv_+3A_y">y</code></td>
<td>
<p>Observed survival or censoring time; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="ipcw.surv_+3A_d">d</code></td>
<td>
<p>The event indicator, normally <code>1 = event, 0 = censored</code>; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="ipcw.surv_+3A_x.ipcw">x.ipcw</code></td>
<td>
<p>Matrix of <code>p.ipw</code> baseline covariate specified in inverse probability of censoring weighting; dimension <code>n</code> by <code>p.ipw</code>.</p>
</td></tr>
<tr><td><code id="ipcw.surv_+3A_yf">yf</code></td>
<td>
<p>Follow-up time, interpreted as the potential censoring time; vector of size <code>n</code> if the potential censoring time is known.
If unknown, set <code>yf == NULL</code> and <code>yf</code> will be taken as <code>y</code> in the function.</p>
</td></tr>
<tr><td><code id="ipcw.surv_+3A_ipcw.method">ipcw.method</code></td>
<td>
<p>The censoring model. Allowed values are: <code>'breslow'</code> (Cox regression with Breslow estimator of the baseline survivor function),
<code>'aft (exponential)'</code>, <code>'aft (weibull)'</code>, <code>'aft (lognormal)'</code> or <code>'aft (loglogistic)'</code>. Default is <code>'breslow'</code>.</p>
</td></tr>
<tr><td><code id="ipcw.surv_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost.</p>
</td></tr>
<tr><td><code id="ipcw.surv_+3A_surv.min">surv.min</code></td>
<td>
<p>Lower truncation limit for probability of being censored (positive and very close to 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>n</code> with the estimated probabilities <code>Pr(C &gt; min(y, tau0) | x.ipcw)</code>
</p>

<hr>
<h2 id='meanCatch'>Catch errors and warnings when estimating the ATEs in the nested subgroup for continuous data</h2><span id='topic+meanCatch'></span>

<h3>Description</h3>

<p>Storing the errors and warnings that occurred when estimating the ATEs in the nested subgroups.
If there are no errors and no warnings, the estimated mean difference is provided.
If there are warnings but no errors, the estimated mean difference is provided with a warning attribute set.
If there are errors, the NA values are returned for mean difference. A error attribute set is also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanCatch(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanCatch_+3A_fun">fun</code></td>
<td>
<p>The drsurv function...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>

<hr>
<h2 id='meanExample'>Simulated data with a continuous outcome</h2><span id='topic+meanExample'></span>

<h3>Description</h3>

<p>A dataset containing a continuous outcome and 6 baseline covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meanExample)
</code></pre>


<h3>Format</h3>

<p>A dataframe with 4000 rows (patients) and 9 variables:
</p>

<dl>
<dt>age</dt><dd><p>age at baseline, centered to 48 years old, in years</p>
</dd>
<dt>female</dt><dd><p>sex, 0 for male, 1 for female</p>
</dd>
<dt>previous_treatment</dt><dd><p>previous treatment, &quot;drugA&quot;, &quot;drugB&quot;, or &quot;drugC&quot;</p>
</dd>
<dt>previous_cost</dt><dd><p>previous medical cost, in US dollars</p>
</dd>
<dt>previous_number_symptoms</dt><dd><p>previous number of symptoms, &quot;0&quot;, &quot;1&quot;, or &quot;&gt;=2&quot;</p>
</dd>
<dt>previous_number_relapses</dt><dd><p>previous number of relapses</p>
</dd>
<dt>trt</dt><dd><p>current treatment, &quot;drug0&quot; or &quot;drug1&quot;</p>
</dd>
<dt>y</dt><dd><p>count oucome, current number of relapses</p>
</dd></dl>
<p>#'

</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meanExample)
str(meanExample)
</code></pre>

<hr>
<h2 id='onearmglmcount.dr'>Doubly robust estimators of the coefficients in the two regression</h2><span id='topic+onearmglmcount.dr'></span>

<h3>Description</h3>

<p>Doubly robust estimators of the coefficients in the two regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onearmglmcount.dr(y, x.cate, time, trt, ps, f.predictor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="onearmglmcount.dr_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="onearmglmcount.dr_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p</code> baseline covariates; dimension <code>n</code> by <code>p</code></p>
</td></tr>
<tr><td><code id="onearmglmcount.dr_+3A_time">time</code></td>
<td>
<p>Log-transformed person-years of follow-up; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="onearmglmcount.dr_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> units with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="onearmglmcount.dr_+3A_ps">ps</code></td>
<td>
<p>Estimated propensity scores for all observations; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="onearmglmcount.dr_+3A_f.predictor">f.predictor</code></td>
<td>
<p>Initial prediction of the outcome (expected number of relapses for one unit of exposure time) conditioned
on the covariates <code>x</code> for one treatment group <code>r</code>; <code>mu_r(x)</code>, step 1 in the two regression; vector of size <code>n</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doubly robust estimators of the regression coefficients <code>beta_r</code> in the doubly robust estimating equation
where <code>r = 0, 1</code> is treatment received; vector of size <code>p</code> + 1 (intercept included)
</p>

<hr>
<h2 id='onearmglmmean.dr'>Doubly robust estimators of the coefficients in the two regression</h2><span id='topic+onearmglmmean.dr'></span>

<h3>Description</h3>

<p>Doubly robust estimators of the coefficients in the two regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onearmglmmean.dr(y, x.cate, trt, ps, f.predictor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="onearmglmmean.dr_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="onearmglmmean.dr_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p</code> baseline covariates; dimension <code>n</code> by <code>p</code></p>
</td></tr>
<tr><td><code id="onearmglmmean.dr_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> units with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="onearmglmmean.dr_+3A_ps">ps</code></td>
<td>
<p>Estimated propensity scores for all observations; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="onearmglmmean.dr_+3A_f.predictor">f.predictor</code></td>
<td>
<p>Initial prediction of the outcome (expected number of relapses for one unit of exposure time) conditioned
on the covariates <code>x</code> for one treatment group <code>r</code>; <code>mu_r(x)</code>, step 1 in the two regression; vector of size <code>n</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doubly robust estimators of the regression coefficients <code>beta_r</code> in the doubly robust estimating equation
where <code>r = 0, 1</code> is treatment received; vector of size <code>p</code> + 1 (intercept included)
</p>

<hr>
<h2 id='onearmsurv.dr'>Doubly robust estimators of the coefficients in the two regression</h2><span id='topic+onearmsurv.dr'></span>

<h3>Description</h3>

<p>Doubly robust estimators of the coefficients in the two regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onearmsurv.dr(ynew, dnew, trt, x.cate, tau0, weightsurv, ps, f.predictor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="onearmsurv.dr_+3A_ynew">ynew</code></td>
<td>
<p>Truncated survival or censoring time; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="onearmsurv.dr_+3A_dnew">dnew</code></td>
<td>
<p>The event indicator after truncation, <code>1 = event or censored after truncation, 0 = censored before truncation</code>;
vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="onearmsurv.dr_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> with treatment coded as 0/1.</p>
</td></tr>
<tr><td><code id="onearmsurv.dr_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates specified in the outcome model; dimension <code>n</code> by <code>p.cate</code>.</p>
</td></tr>
<tr><td><code id="onearmsurv.dr_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost.</p>
</td></tr>
<tr><td><code id="onearmsurv.dr_+3A_weightsurv">weightsurv</code></td>
<td>
<p>Estimated inverse probability of censoring weights with truncation for all observations; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="onearmsurv.dr_+3A_ps">ps</code></td>
<td>
<p>Estimated propensity scores for all observations; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="onearmsurv.dr_+3A_f.predictor">f.predictor</code></td>
<td>
<p>Initial prediction of the outcome (restricted mean time loss) conditioned on the covariates <code>x.cate</code> for one treatment group <code>r</code>;
<code>mu_r(x.cate)</code>, step 1 in the two regression; vector of size <code>n</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doubly robust estimators of the two regression coefficients <code>beta_r</code> where <code>r = 0, 1</code> is treatment received; vector of size <code>p.cate</code> + 1 (intercept included)
</p>

<hr>
<h2 id='plot.atefit'>Histogram of bootstrap estimates</h2><span id='topic+plot.atefit'></span>

<h3>Description</h3>

<p>Histogram of bootstrap estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'atefit'
plot(x, bins, alpha = 0.7, title = waiver(), theme = theme_classic(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.atefit_+3A_x">x</code></td>
<td>
<p>An object of class <code>"atefit"</code>.</p>
</td></tr>
<tr><td><code id="plot.atefit_+3A_bins">bins</code></td>
<td>
<p>Number of bins</p>
</td></tr>
<tr><td><code id="plot.atefit_+3A_alpha">alpha</code></td>
<td>
<p>Opacity</p>
</td></tr>
<tr><td><code id="plot.atefit_+3A_title">title</code></td>
<td>
<p>The text for the title</p>
</td></tr>
<tr><td><code id="plot.atefit_+3A_theme">theme</code></td>
<td>
<p>Defaults to <code>theme_classic()</code>. Other options include <code>theme_grey()</code>, <code>theme_bw()</code>, <code>theme_light()</code>, <code>theme_dark()</code>, and <code>theme_void()</code></p>
</td></tr>
<tr><td><code id="plot.atefit_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a histogram displaying the distribution of the bootstrap estimates.
The red vertical reference line represents the final estimate.
</p>


<h3>Value</h3>

<p>A plot of the class <code>ggplot</code>, displaying the estimated ATE across
the bootstrap samples
</p>


<h3>Author(s)</h3>

<p>Thomas Debray
</p>

<hr>
<h2 id='plot.precmed'>Two side-by-side line plots of validation curves from the <code>"precmed"</code> object</h2><span id='topic+plot.precmed'></span>

<h3>Description</h3>

<p>Provides validation curves in two side-by-side plots, visualizing the estimated ATEs in a series
of nested subgroups in the training set and validation set separately, where each line represents
one scoring method specified in <code><a href="#topic+catecv">catecv</a>()</code> or <code><a href="#topic+catecvmean">catecvmean</a>()</code>. This should be run
only after results of <code><a href="#topic+catecv">catecv</a>()</code> or <code><a href="#topic+catecvmean">catecvmean</a>()</code> have been obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'precmed'
plot(
  x,
  cv.i = NULL,
  combine = "mean",
  show.abc = TRUE,
  valid.only = FALSE,
  plot.hr = FALSE,
  ylab = NULL,
  legend.position = "bottom",
  xlim = NULL,
  title = waiver(),
  theme = theme_classic(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.precmed_+3A_x">x</code></td>
<td>
<p>An object of class <code>"precmed"</code>.</p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_cv.i">cv.i</code></td>
<td>
<p>A positive integer indicating the index of the CV iteration results to be plotted.
Allowed values are: a positive integer <code class="reqn">&lt;=</code> <code>cv.n</code> in <code><a href="#topic+catecv">catecv</a>()</code> or
<code>NULL</code>. If <code>cv.i = NULL</code>, the results across all CV iterations are combined according
to <code>combine</code> and then plotted. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_combine">combine</code></td>
<td>
<p>A character value indicating how to combine the estimated ATEs across all CV
iterations into a validation curve for each nested subgroup, separately for the training and
validation results. Allowed values are: <code>'mean'</code> or <code>'median'</code>. Used only if
<code>cv.i = NULL</code>. Default is <code>'mean'</code>.</p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_show.abc">show.abc</code></td>
<td>
<p>A logical value indicating whether to show the ABC statistics in the validation set. Used
only if <code>x$abc = TRUE</code> and <code>xlim</code> is not limited to a smaller range (i.e., <code>xlim = NULL</code> or
equal to the entire <code>x$prop.onlyhigh</code> range). If <code>cv.i</code> is NULL, ABC statistics will be based
on the combined CV iterations. If <code>cv.i</code> is an integer, ABC statistics will be based solely on that
CV iteration. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_valid.only">valid.only</code></td>
<td>
<p>A logical value indicating whether only the validation curves in the validation set
should be plotted (<code>TRUE</code>). Otherwise, the validation curves in both the training and validation
sets are plotted side-by-side (<code>FALSE</code>). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_plot.hr">plot.hr</code></td>
<td>
<p>A logical value indicating whether the hazard ratios should be plotted in the
validation curves (<code>TRUE</code>). Otherwise, the restricted mean time lost is plotted (<code>FALSE</code>).
This argument is only applicable to survival outcomes. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_ylab">ylab</code></td>
<td>
<p>A character value for the y-axis label to describe what the ATE is. Default is <code>NULL</code>,
which creates a default y-axis label based on available data.</p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_legend.position">legend.position</code></td>
<td>
<p>A character value for the legend position argument to be passed to <code>ggplot</code>
object. Default is <code>'bottom'</code>.</p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_xlim">xlim</code></td>
<td>
<p>A numeric value for the range of the x-axis. Default is <code>NULL</code>, which means there is no
range specified.</p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_title">title</code></td>
<td>
<p>The text for the title</p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_theme">theme</code></td>
<td>
<p>Defaults to <code>theme_classic()</code>. Other options include <code>theme_grey()</code>, <code>theme_bw()</code>, <code>theme_light()</code>, <code>theme_dark()</code>, and <code>theme_void()</code></p>
</td></tr>
<tr><td><code id="plot.precmed_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="base.html#topic+plot">plot</a>()</code> takes in outputs from <code><a href="#topic+catecv">catecv</a>()</code> and generates two plots
of validation curves side-by-side, one for the training set and one for validation set.
Separate validation curves are produced for each scoring method specified via <code>score.method</code>
in <code><a href="#topic+catecv">catecv</a>()</code> or <code><a href="#topic+catecvmean">catecvmean</a>()</code>.
</p>
<p>The validation curves (and ABC statistics, if applicable) can help compare the performance of
different scoring methods in terms of discerning potential treatment heterogeneity in subgroups
with internal validation. Steeper validation curves in the validation set suggest presence of
treatment effect heterogeneity (and the ability of the scoring methods to capture it) while flat
validation curves indicate absence of treatment effect heterogeneity (or inability of the scoring method
to capture it).
</p>


<h3>Value</h3>

<p>Returns two side-by-side line plots, one of which shows the validation curves of the training
sets and the other the validation curves in the validation sets. A gray horizontal dashed line of
overall ATE is included as a reference. ABC statistics will be added to the legend if
<code>show.abc = TRUE</code>.
</p>


<h3>References</h3>

<p>Yadlowsky, S., Pellegrini, F., Lionetto, F., Braune, S., &amp; Tian, L. (2020).
<em>Estimation and validation of ratio-based conditional average treatment effects using
observational data. Journal of the American Statistical Association, 1-18.</em>
<a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080">https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1772080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abc">abc</a>()</code> and <code><a href="graphics.html#topic+boxplot">boxplot</a>()</code> for <code>"precmed"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Count outcome
eval_1 &lt;- catecv(response = "count",
                 data = countExample,
                 score.method = "poisson",
                 cate.model = y ~ age + female + previous_treatment +
                                  previous_cost + previous_number_relapses + offset(log(years)),
                 ps.model = trt ~ age + previous_treatment,
                 higher.y = FALSE,
                 cv.n = 5)

# default setting
plot(eval_1)

# turn off ABC annotation
plot(eval_1, show.abc = FALSE)

# use a different theme
plot(eval_1, theme = ggplot2::theme_bw())

# plot the validation curves from the 2nd CV iteration instead of the mean
# of all validation curves
plot(eval_1, cv.i = 2)

# median of the validation curves
plot(eval_1, combine = "median")

# plot validation curves in validation set only
plot(eval_1, valid.only = TRUE)

# Survival outcome
library(survival)
tau0 &lt;- with(survivalExample,
             min(quantile(y[trt == "drug1"], 0.95), quantile(y[trt == "drug0"], 0.95)))
eval_2 &lt;- catecv(response = "survival",
                 data = survivalExample,
                 score.method = c("poisson", "randomForest"),
                 cate.model = Surv(y, d) ~ age + female + previous_cost +
                                           previous_number_relapses,
                 ps.model = trt ~ age + previous_treatment,
                 initial.predictor.method = "randomForest",
                 ipcw.model = ~ age + previous_cost + previous_treatment,
                 tau0 = tau0,
                 cv.n = 5,
                 seed = 999)


# default setting, plot RMTL ratios in both training and validation sets
plot(eval_2)

# plot hazard ratio
plot(eval_2, plot.hr = TRUE)



</code></pre>

<hr>
<h2 id='print.atefit'>Print function for atefit</h2><span id='topic+print.atefit'></span>

<h3>Description</h3>

<p>Print function for atefit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'atefit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.atefit_+3A_x">x</code></td>
<td>
<p>An object of class <code>"atefit"</code>.</p>
</td></tr>
<tr><td><code id="print.atefit_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Display the estimated treatment effects for survival outcomes (log
restricted mean time lost ratio and log hazard ratio) and count outcomes
(the log rate ratio).
</p>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Thomas Debray
</p>

<hr>
<h2 id='print.catefit'>Print function for atefit</h2><span id='topic+print.catefit'></span>

<h3>Description</h3>

<p>Print function for atefit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'catefit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.catefit_+3A_x">x</code></td>
<td>
<p>An object of class <code>"catefit"</code>.</p>
</td></tr>
<tr><td><code id="print.catefit_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Display the estimated treatment effects for survival outcomes (log
restricted mean time lost ratio and log hazard ratio) and count outcomes
(the log rate ratio).
</p>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Thomas Debray
</p>

<hr>
<h2 id='scorecount'>Calculate the log CATE score given the baseline covariates and follow-up time for specified scoring method methods</h2><span id='topic+scorecount'></span>

<h3>Description</h3>

<p>Based on intxcount results of the CATE coefficients estimated with boosting, naive Poisson, two regression, contrast regression, negative binomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scorecount(
  fit,
  x.cate,
  time,
  score.method = c("boosting", "poisson", "twoReg", "contrastReg", "negBin")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scorecount_+3A_fit">fit</code></td>
<td>
<p>List of objects generated from intxcount: outputs of boosting, naive Poisson, two regression, contrast regression, negative binomial</p>
</td></tr>
<tr><td><code id="scorecount_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> (observations) by <code>p.cate</code> (covariates in the outcome model)</p>
</td></tr>
<tr><td><code id="scorecount_+3A_time">time</code></td>
<td>
<p>Log-transformed person-years of follow-up; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="scorecount_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'poisson'</code>, <code>'twoReg'</code>, <code>'contrastReg'</code>,
<code>'negBin'</code>. Default specifies all 5 methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>score.boosting: Estimated log CATE score for all <code>n</code> observations with the boosting method; vector of size <code>n</code>
score.poisson: Estimated log CATE score for all <code>n</code> observations with the naive Poisson method; vector of size <code>n</code>
score.twoReg: Estimated log CATE score for all <code>n</code> observations with the two regression method; vector of size <code>n</code>
score.contrastReg: Estimated log CATE score for all <code>n</code> observations with the contrast regression method; vector of size <code>n</code>
score.negBin: Estimated log CATE score for all <code>n</code> observations with the naive Poisson method; vector of size <code>n</code>
score = NA if the corresponding method is not called
</p>

<hr>
<h2 id='scoremean'>Calculate the CATE score given the baseline covariates for specified scoring method methods</h2><span id='topic+scoremean'></span>

<h3>Description</h3>

<p>Based on intxmean results of the CATE coefficients estimated with boosting, linear regression, two regression, contrast regression, random forest, generalized additive model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoremean(
  fit,
  x.cate,
  score.method = c("boosting", "gaussian", "twoReg", "contrastReg", "randomForest",
    "gam")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoremean_+3A_fit">fit</code></td>
<td>
<p>List of objects generated from intxmean: outputs of boosting, linear regression, two regression, contrast regression, random forest, generalized additive model</p>
</td></tr>
<tr><td><code id="scoremean_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> (observations) by <code>p.cate</code> (covariates in the outcome model)</p>
</td></tr>
<tr><td><code id="scoremean_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'boosting'</code>, <code>'gaussian'</code>, <code>'twoReg'</code>, <code>'contrastReg'</code>, <code>'randomForest'</code>, <code>'gam'</code>.
Default specifies all 6 methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>score.boosting: Estimated CATE score for all <code>n</code> observations with the boosting method; vector of size <code>n</code>
score.gaussian: Estimated CATE score for all <code>n</code> observations with the linear regression method; vector of size <code>n</code>
score.twoReg: Estimated CATE score for all <code>n</code> observations with the two regression method; vector of size <code>n</code>
score.contrastReg: Estimated CATE score for all <code>n</code> observations with the contrast regression method; vector of size <code>n</code>
score.randomForest: Estimated CATE score for all <code>n</code> observations with the random forest method; vector of size <code>n</code>
score.gam: Estimated CATE score for all <code>n</code> observations with the generalized additive model; vector of size <code>n</code>
score = NA if the corresponding method is not called
</p>

<hr>
<h2 id='scoresurv'>Calculate the log CATE score given the baseline covariates and follow-up time for specified scoring method methods for survival outcomes</h2><span id='topic+scoresurv'></span>

<h3>Description</h3>

<p>Based on intxsurv results of the CATE coefficients estimated with random forest, boosting, naive Poisson, two regression, contrast regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoresurv(
  fit,
  x.cate,
  tau0,
  score.method = c("randomForest", "boosting", "poisson", "twoReg", "contrastReg")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoresurv_+3A_fit">fit</code></td>
<td>
<p>List of objects generated from intxsurv: outputs of random forest, boosting, naive Poisson, two regression, contrast regression</p>
</td></tr>
<tr><td><code id="scoresurv_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates specified in the outcome model; dimension <code>n</code> by <code>p.cate</code>.</p>
</td></tr>
<tr><td><code id="scoresurv_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost.</p>
</td></tr>
<tr><td><code id="scoresurv_+3A_score.method">score.method</code></td>
<td>
<p>A vector of one or multiple methods to estimate the CATE score.
Allowed values are: <code>'randomForest'</code>, <code>'boosting'</code>, <code>'poisson'</code>, <code>'twoReg'</code>,
<code>'contrastReg'</code>. Default specifies all 5 methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>score.randomForest: Estimated log CATE score for all <code>n</code> observations with the random forest method; vector of size <code>n</code>
score.boosting: Estimated log CATE score for all <code>n</code> observations with the boosting method; vector of size <code>n</code>
score.poisson: Estimated log CATE score for all <code>n</code> observations with the naive Poisson method; vector of size <code>n</code>
score.twoReg: Estimated log CATE score for all <code>n</code> observations with the two regression method; vector of size <code>n</code>
score.contrastReg: Estimated log CATE score for all <code>n</code> observations with the contrast regression method; vector of size <code>n</code>
score = NA if the corresponding method is not called
</p>

<hr>
<h2 id='survCatch'>Catch errors and warnings when estimating the ATEs in the nested subgroup</h2><span id='topic+survCatch'></span>

<h3>Description</h3>

<p>Storing the errors and warnings that occurred when estimating the ATEs in the nested subgroups.
If there are no errors and no warnings, the estimated log.rmtl.ratio and log.hazard.ratio are provided.
If there are warnings but no errors, the estimated log.rmtl.ratio and log.hazard.ratio are provided with a warning attribute set.
If there are errors, the NA values are returned for log.rmtl.ratio and log.hazard.ratio. A error attribute set is also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survCatch(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survCatch_+3A_fun">fun</code></td>
<td>
<p>The drsurv function...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>

<hr>
<h2 id='survivalExample'>Simulated data with survival outcome</h2><span id='topic+survivalExample'></span>

<h3>Description</h3>

<p>A dataset containing a time-to-event outcome, an event indicator, treatment group, and 6 baseline covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(survivalExample)
</code></pre>


<h3>Format</h3>

<p>A dataframe with 4000 rows (patients) and 9 variables:
</p>

<dl>
<dt>age</dt><dd><p>age at baseline, centered to 48 years old, in years</p>
</dd>
<dt>female</dt><dd><p>sex, 0 for male, 1 for female</p>
</dd>
<dt>previous_treatment</dt><dd><p>previous treatment, &quot;drugA&quot;, &quot;drugB&quot;, or &quot;drugC&quot;</p>
</dd>
<dt>previous_cost</dt><dd><p>previous medical cost, in US dollars</p>
</dd>
<dt>previous_number_symptoms</dt><dd><p>previous number of symptoms, &quot;0&quot;, &quot;1&quot;, or &quot;&gt;=2&quot;</p>
</dd>
<dt>previous_number_relapses</dt><dd><p>previous number of relapses</p>
</dd>
<dt>trt</dt><dd><p>current treatment, &quot;drug0&quot; or &quot;drug1&quot;</p>
</dd>
<dt>y</dt><dd><p>time to first relapse or censoring</p>
</dd>
<dt>d</dt><dd><p>event indicator, 1: relapse, 0: censored</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(survivalExample)
str(survivalExample)
</code></pre>

<hr>
<h2 id='twoarmglmcount.dr'>Doubly robust estimators of the coefficients in the contrast regression
as well as their covariance matrix and convergence information</h2><span id='topic+twoarmglmcount.dr'></span>

<h3>Description</h3>

<p>Newton-Raphson algorithm is used to solve the estimating equation <code>bar S_n (delta) = 0</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoarmglmcount.dr(
  y,
  x.cate,
  time,
  trt,
  ps,
  f1.predictor,
  f0.predictor,
  error.maxNR = 0.001,
  max.iterNR = 150,
  tune = c(0.5, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoarmglmcount.dr_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmglmcount.dr_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code></p>
</td></tr>
<tr><td><code id="twoarmglmcount.dr_+3A_time">time</code></td>
<td>
<p>Log-transformed person-years of follow-up; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmglmcount.dr_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> units with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="twoarmglmcount.dr_+3A_ps">ps</code></td>
<td>
<p>Estimated propensity scores for all observations; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmglmcount.dr_+3A_f1.predictor">f1.predictor</code></td>
<td>
<p>Initial predictions of the outcome (expected number of relapses for one unit of exposure time)
conditioned on the covariates <code>x</code> for treatment group trt = 1; <code>mu_1(x)</code>, step 1 in the two regression; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmglmcount.dr_+3A_f0.predictor">f0.predictor</code></td>
<td>
<p>Initial predictions of the outcome (expected number of relapses for one unit of exposure time)
conditioned on the covariates <code>x</code> for treatment group trt = 0; <code>mu_0(x)</code>, step 1 in the two regression; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmglmcount.dr_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="twoarmglmcount.dr_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>150</code>.</p>
</td></tr>
<tr><td><code id="twoarmglmcount.dr_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coef: Doubly robust estimators of the regression coefficients <code>delta_0</code>; vector of size <code>p</code> + 1 (intercept included)
vcov: Variance-covariance matrix of the estimated coefficient <code>delta_0</code>; matrix of size <code>p</code> + 1 by <code>p</code> + 1
converge: Indicator that the Newton Raphson algorithm converged for <code>delta_0</code>; boolean
</p>

<hr>
<h2 id='twoarmglmmean.dr'>Doubly robust estimators of the coefficients in the contrast regression
as well as their covariance matrix</h2><span id='topic+twoarmglmmean.dr'></span>

<h3>Description</h3>

<p>Solving the estimating equation <code>bar S_n (delta) = 0</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoarmglmmean.dr(y, x.cate, trt, ps, f1.predictor, f0.predictor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoarmglmmean.dr_+3A_y">y</code></td>
<td>
<p>Observed outcome; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmglmmean.dr_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates; dimension <code>n</code> by <code>p.cate</code></p>
</td></tr>
<tr><td><code id="twoarmglmmean.dr_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> units with treatment coded as 0/1</p>
</td></tr>
<tr><td><code id="twoarmglmmean.dr_+3A_ps">ps</code></td>
<td>
<p>Estimated propensity scores for all observations; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmglmmean.dr_+3A_f1.predictor">f1.predictor</code></td>
<td>
<p>Initial predictions of the outcome (expected number of relapses for one unit of exposure time)
conditioned on the covariates <code>x</code> for treatment group trt = 1; <code>mu_1(x)</code>, step 1 in the two regression; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmglmmean.dr_+3A_f0.predictor">f0.predictor</code></td>
<td>
<p>Initial predictions of the outcome (expected number of relapses for one unit of exposure time)
conditioned on the covariates <code>x</code> for treatment group trt = 0; <code>mu_0(x)</code>, step 1 in the two regression; vector of size <code>n</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>coef: Doubly robust estimators of the regression coefficients <code>delta_0</code>; vector of size <code>p</code> + 1 (intercept included)
vcov: Variance-covariance matrix of the estimated coefficient <code>delta_0</code>; matrix of size <code>p</code> + 1 by <code>p</code> + 1
</p>

<hr>
<h2 id='twoarmsurv.dr'>Doubly robust estimators of the coefficients in the contrast regression
as well as their covariance matrix and convergence information</h2><span id='topic+twoarmsurv.dr'></span>

<h3>Description</h3>

<p>Newton-Raphson algorithm is used to solve the estimating equation <code>bar S_n (delta) = 0</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoarmsurv.dr(
  ynew,
  dnew,
  trt,
  x.cate,
  tau0,
  weightsurv,
  ps,
  f1.predictor,
  f0.predictor,
  error.maxNR = 0.001,
  max.iterNR = 100,
  tune = c(0.5, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoarmsurv.dr_+3A_ynew">ynew</code></td>
<td>
<p>Truncated survival time; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_dnew">dnew</code></td>
<td>
<p>Event indicator after truncation; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_trt">trt</code></td>
<td>
<p>Treatment received; vector of size <code>n</code> with treatment coded as 0/1.</p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_x.cate">x.cate</code></td>
<td>
<p>Matrix of <code>p.cate</code> baseline covariates specified in the outcome model; dimension <code>n</code> by <code>p.cate</code>.</p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_tau0">tau0</code></td>
<td>
<p>The truncation time for defining restricted mean time lost.</p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_weightsurv">weightsurv</code></td>
<td>
<p>Estimated inverse probability of censoring weights with truncation for all observations; vector of size <code>n</code>.</p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_ps">ps</code></td>
<td>
<p>Estimated propensity scores for all observations; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_f1.predictor">f1.predictor</code></td>
<td>
<p>Initial predictions of the outcome (restricted mean time loss) conditioned on the covariates <code>x.cate</code> for treatment group trt = 1;
<code>mu_1(x.cate)</code>, step 1 in the two regression; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_f0.predictor">f0.predictor</code></td>
<td>
<p>Initial predictions of the outcome (restricted mean time loss) conditioned on the covariates <code>x.cate</code> for treatment group trt = 0;
<code>mu_0(x.cate)</code>, step 1 in the two regression; vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_error.maxnr">error.maxNR</code></td>
<td>
<p>A numerical value &gt; 0 indicating the minimum value of the mean absolute
error in Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_max.iternr">max.iterNR</code></td>
<td>
<p>A positive integer indicating the maximum number of iterations in the
Newton Raphson algorithm. Used only if <code>score.method = 'contrastReg'</code>.
Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="twoarmsurv.dr_+3A_tune">tune</code></td>
<td>
<p>A vector of 2 numerical values &gt; 0 specifying tuning parameters for the
Newton Raphson algorithm. <code>tune[1]</code> is the step size, <code>tune[2]</code> specifies a
quantity to be added to diagonal of the slope matrix to prevent singularity.
Used only if <code>score.method = 'contrastReg'</code>. Default is <code>c(0.5, 2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coef: Doubly robust estimators of the contrast regression coefficients <code>delta_0</code>; vector of size <code>p.cate</code> + 1 (intercept included)
converge: Indicator that the Newton Raphson algorithm converged for <code>delta_0</code>; boolean
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
