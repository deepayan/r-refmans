<!DOCTYPE html><html><head><title>Help for package iotools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iotools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.default.formatter'>
<p>Default formatter, coorisponding to the as.output functions</p></a></li>
<li><a href='#as.output'>
<p>Character Output</p></a></li>
<li><a href='#chunk'>
<p>Functions for very fast chunk-wise processing</p></a></li>
<li><a href='#chunk.apply'>
<p>Process input by applying a function to each chunk</p></a></li>
<li><a href='#chunk.map'>
<p>Map a function over a file by chunks</p></a></li>
<li><a href='#ctapply'>
<p>Fast tapply() replacement functions</p></a></li>
<li><a href='#dstrfw'>
<p>Split fixed width input into a dataframe</p></a></li>
<li><a href='#dstrsplit'>
<p>Split binary or character input into a dataframe</p></a></li>
<li><a href='#fdrbind'>
<p>Fast row-binding of lists and data frames</p></a></li>
<li><a href='#idstrsplit'>
<p>Create an iterator for splitting binary or character input into a dataframe</p></a></li>
<li><a href='#imstrsplit'>
<p>Create an iterator for splitting binary or character input into a matrix</p></a></li>
<li><a href='#input.file'>
<p>Load a file on the disk</p></a></li>
<li><a href='#line.merge'>
<p>Merge multiple sources</p></a></li>
<li><a href='#mstrsplit'>
<p>Split binary or character input into a matrix</p></a></li>
<li><a href='#output.file'>
<p>Write an R object to a file as a character string</p></a></li>
<li><a href='#read.csv.raw'>
<p>Fast data frame input</p></a></li>
<li><a href='#readAsRaw'>
<p>Read binary data in as raw</p></a></li>
<li><a href='#which.min.key'>
<p>Determine the next key in bytewise order</p></a></li>
<li><a href='#write.csv.raw'>
<p>Fast data output to disk</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3-5</td>
</tr>
<tr>
<td>Title:</td>
<td>I/O Tools for Streaming</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Urbanek &lt;Simon.Urbanek@r-project.org&gt;, Taylor Arnold &lt;taylor.arnold@acm.org&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Urbanek &lt;Simon.Urbanek@r-project.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.9.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Basic I/O tools for streaming and data parsing.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rforge.net/iotools">https://www.rforge.net/iotools</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 21:57:27 UTC; rforge</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-02 11:04:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='.default.formatter'>
Default formatter, coorisponding to the as.output functions
</h2><span id='topic+.default.formatter'></span>

<h3>Description</h3>

<p>This function provides the default formatter for the
iotools package; it assumes that the key is
seperated from the rest of the row by a tab character,
and the elements of the row are seperated by the pipe
(&quot;|&quot;) character. Vector and matrix objects returned from
the output via <code><a href="#topic+as.output">as.output</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.default.formatter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".default.formatter_+3A_x">x</code></td>
<td>
<p>character vector (each element is treated as a row) or a raw
vector (LF characters <code>'\n'</code> separate rows) to split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a character matrix with a row for each element in the input, or
a character vector with an element for each element in the input. The
latter occurs when only one column (not counting the key) is detected
in the input. The keys are stored as rownames or names, respectively.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mstrsplit">mstrsplit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  c &lt;- c("A\tB|C|D", "A\tB|B|B", "B\tA|C|E")
  .default.formatter(c)
  
  c &lt;- c("A\tD", "A\tB", "B\tA")
  .default.formatter(c)
</code></pre>

<hr>
<h2 id='as.output'>
Character Output
</h2><span id='topic+as.output'></span><span id='topic+as.output.default'></span><span id='topic+as.output.data.frame'></span><span id='topic+as.output.list'></span><span id='topic+as.output.matrix'></span><span id='topic+as.output.table'></span><span id='topic+as.output.raw'></span><span id='topic+iotools.stdout'></span><span id='topic+iotools.stderr'></span><span id='topic+iotools.fd'></span>

<h3>Description</h3>

<p>Create objects of class <code>output</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.output(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.output_+3A_x">x</code></td>
<td>
<p>object to be converted to an instance of <code>output</code>.</p>
</td></tr>
<tr><td><code id="as.output_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to implementing methods
of <code>as.output</code>. Most methods support the following arguments:
<code>sep</code> string, column/value separator, <code>nsep</code> string, key
separator, <code>keys</code> either a logical (if <code>FALSE</code> names/row
names are suppressed) or a character vector with overriding
keys. The default for <code>keys</code> typically varies by class or is
auto-detected (e.g., named vectors user names as keys,
<code>data.frames</code> use row names if they are non-automatic
etc.). All methods also support <code>con</code> argument which pushes
the output into a connection instead of generating an output object
- so <code>as.output(x, con=...)</code> is thus not a coersion but used
only for its side-effect.
Note that <code>con</code> also supports special values
<code>iotools.stdout</code>, <code>iotools.stderr</code> and
<code>iotools.fd(fd)</code> which write directly into the corresponding
streams instead of using theconnection API.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.output</code> is generic, and methods can be written to support
new classes. The output is meant to be a raw vector suitable for
writing to the disk or sending over a connection.
</p>


<h3>Value</h3>

<p>if <code>con</code> is set to a connection then the result is <code>NULL</code>
and the method is used for its side-effect, otherwise the result is a
raw vector.
</p>
<p>Side note: we cannot create a formal type of <code>output</code>, because
<code>writeBin</code> does <code>is.vector()</code> check which doesn't dispatch
and prevents anything with a class to be written.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m = matrix(sample(letters), ncol=2)
  as.output(m)

  df = data.frame(a = sample(letters), b = runif(26), c = sample(state.abb,26))
  str(as.output(df))

  as.output(df, con=iotools.stdout)
</code></pre>

<hr>
<h2 id='chunk'>
Functions for very fast chunk-wise processing
</h2><span id='topic+chunk'></span><span id='topic+chunk.reader'></span><span id='topic+read.chunk'></span>

<h3>Description</h3>

<p><code>chunk.reader</code> creates a reader that will read from a binary
connection in chunks while preserving integrity of lines.
</p>
<p><code>read.chunk</code> reads the next chunk using the specified reader.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk.reader(source, max.line = 65536L, sep = NULL)
read.chunk(reader, max.size = 33554432L, timeout = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk_+3A_source">source</code></td>
<td>
<p>binary connection or character (which is interpreted as
file name) specifying the source</p>
</td></tr>
<tr><td><code id="chunk_+3A_max.line">max.line</code></td>
<td>
<p>maximum length of one line (in byets) - determines the
size of the read buffer, default is 64kb</p>
</td></tr>
<tr><td><code id="chunk_+3A_sep">sep</code></td>
<td>
<p>optional string: key separator if key-aware chunking is to
be used</p>
</td></tr>
</table>
<p>character is considered a key and subsequent records holding the
same key are guaranteed to be 
</p>
<table>
<tr><td><code id="chunk_+3A_reader">reader</code></td>
<td>
<p>reader object as returned by <code>chunk.reader</code></p>
</td></tr>
<tr><td><code id="chunk_+3A_max.size">max.size</code></td>
<td>
<p>maximum size of the chunk (in bytes), default is 32Mb</p>
</td></tr>
<tr><td><code id="chunk_+3A_timeout">timeout</code></td>
<td>
<p>numeric, timeout (in seconds) for reads if
<code>source</code> is a raw file descriptor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chunk.reader</code> is essentially a filter that converts binary
connection into chunks that can be subsequently parsed into data while
preserving the integrity of input lines. <code>read.chunk</code> is used to
read the actual chunks. The implementation is very thin to prevert
copying of large vectors for best efficiency.
</p>
<p>If <code>sep</code> is set to a string, it is treated as a single-character
separator character. If specified, prefix in the input up to the
specified character is treated as a key and subsequent lines with the
same key are guaranteed to be processed in the same chunk. Note that
this implies that the chunk size is practically unlimited, since this
may force accumulation of multiple chunks to satisfy this condition.
Obviously, this increases the processing and memory overhead.
</p>
<p>In addition to connections <code>chunk.reader</code> supports raw file
descriptors (integers of the class <code>"fileDescriptor"</code>). In that
case the reads are preformed directly by <code>chunk.reader</code> and
<code>timeout</code> can be used to perform non-blocking or timed
reads (unix only, not supported on Windows).
</p>


<h3>Value</h3>

<p><code>chunk.reader</code> returns an object that can be used by
<code>read.chunk</code>. If <code>source</code> is a string, it is equivalent to
calling <code>chunk.reader(file(source, "rb"), ...)</code>.
</p>
<p><code>read.chunk</code> returns a raw vector holding the next chunk or
<code>NULL</code> if timeout was reached. It is deliberate that
<code>read.chunk</code> does NOT return a character vector since that
would reasult in a high performance penalty. Please use the
appropriate parser to convert the chunk into data, see
<code><a href="#topic+mstrsplit">mstrsplit</a></code>.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>

<hr>
<h2 id='chunk.apply'>
Process input by applying a function to each chunk
</h2><span id='topic+chunk.apply'></span><span id='topic+chunk.tapply'></span>

<h3>Description</h3>

<p><code>chunk.apply</code> processes input in chunks and applies <code>FUN</code>
to each chunk, collecting the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk.apply(input, FUN, ..., CH.MERGE = rbind, CH.MAX.SIZE = 33554432,
            CH.PARALLEL=1L, CH.SEQUENTIAL=TRUE, CH.BINARY=FALSE,
            CH.INITIAL=NULL)

chunk.tapply(input, FUN, ..., sep = "\t", CH.MERGE = rbind, CH.MAX.SIZE = 33554432)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk.apply_+3A_input">input</code></td>
<td>
<p>Either a chunk reader or a file name or connection that
will be used to create a chunk reader</p>
</td></tr>
<tr><td><code id="chunk.apply_+3A_fun">FUN</code></td>
<td>
<p>Function to apply to each chunk</p>
</td></tr>
<tr><td><code id="chunk.apply_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>FUN</code></p>
</td></tr>
<tr><td><code id="chunk.apply_+3A_sep">sep</code></td>
<td>
<p>for <code>tapply</code>, gives separator for the key over which
to apply. Each line is split at the first separator, and the value
is treated as the key over which to apply the function.</p>
</td></tr>
<tr><td><code id="chunk.apply_+3A_ch.merge">CH.MERGE</code></td>
<td>
<p>Function to call to merge results from all
chunks. Common values are <code>list</code> to get <code>lapply</code>-like
behavior, <code>rbind</code> for table-like output or <code>c</code> for a long
vector.</p>
</td></tr>
<tr><td><code id="chunk.apply_+3A_ch.max.size">CH.MAX.SIZE</code></td>
<td>
<p>maximal size of each chunk in bytes</p>
</td></tr>
<tr><td><code id="chunk.apply_+3A_ch.parallel">CH.PARALLEL</code></td>
<td>
<p>the number of parallel processes to use in the
calculation (unix only).</p>
</td></tr>
<tr><td><code id="chunk.apply_+3A_ch.sequential">CH.SEQUENTIAL</code></td>
<td>
<p>logical, only relevant for parallel
processing. If <code>TRUE</code> then the chunks are guaranteed to be
processed in sequential order. If <code>FALSE</code> then the chunks may
be processed in any order to gain better performance.</p>
</td></tr>
<tr><td><code id="chunk.apply_+3A_ch.binary">CH.BINARY</code></td>
<td>
<p>logical, if <code>TRUE</code> then <code>CH.MERGE</code> is a
binary function used to update the result object for each chunk,
effectively acting like the <code>Reduce</code> function. If <code>FALSE</code>
then the results from all chunks are accumulated first and then
<code>CH.MERGE</code> is called with all chunks as arguments. See below
for performance considerations.</p>
</td></tr>
<tr><td><code id="chunk.apply_+3A_ch.initial">CH.INITIAL</code></td>
<td>
<p>Function which will be applied to the first chunk if
<code>CH.BINARY=TRUE</code>. If <code>NULL</code> then <code>CH.MERGE(NULL,
      chunk)</code> is called instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to the fact that chunk-wise processing is typically used when the
input data is too large to fit in memory, there are additional
considerations depending on whether the results after applying
<code>FUN</code> are itself large or not. If they are not, then the apporach
of accumulating them and then applying <code>CH.MERGE</code> on all results
at once is typically the most efficient and it is what
<code>CH.BINARY=FALSE</code> will do.
</p>
<p>However, in some situations where the result are resonably big or
the number of chunks is very high, it may be more efficient to update
a sort of state based on each arriving chunk instead of collecting all
results. This can be achieved by setting <code>CH.BINARY=TRUE</code> in which
case the process is equivalent to:
</p>
<pre>res &lt;- CH.INITIAL(FUN(chunk1))
res &lt;- CH.MERGE(res, FUN(chunk2))
res &lt;- CH.MERGE(res, FUN(chunk3))
...
res</pre>
<p>If <code>CH.INITITAL</code> is <code>NULL</code> then the first line is
<code>res &lt;- CH.MERGE(NULL, FUN(chunk1))</code>.
</p>
<p>The parameter <code>CH.SEQUENTIAL</code> is only used if parallel
processing is requested. It allows the system to process chunks out of
order for performace reasons. If it is <code>TRUE</code> then the order of
the chunks is respected, but merging can only proceed if the result of
the next chunk is avaiable. With <code>CH.SEQUENTIAL=FALSE</code> the workers
will continue processing further chunks as they become avaiable, not
waiting for the results of the preceding calls. This is more
efficient, but the order of the chunks in the result is not
deterministic.
</p>
<p>Note that if parallel processing is required then all calls to
<code>FUN</code> should be considered independent. However, <code>CH.MERGE</code>
is always run in the current session and thus is allowed to have
side-effects.
</p>


<h3>Value</h3>

<p>The result of calling <code>CH.MERGE</code> on all chunk results as
arguments (<code>CH.BINARY=FALSE</code>) or result of the last call to
binary <code>CH.MERGE</code>.
</p>


<h3>Note</h3>

<p>The input to <code>FUN</code> is the raw chunk, so typically it is
advisable to use <code><a href="#topic+mstrsplit">mstrsplit</a></code> or similar function as the
first step in <code>FUN</code>.
</p>


<h3>Note</h3>

<p>The support for <code>CH.PARALLEL</code> is considered experimental and may
change in the future.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## compute quantiles of the first variable for each chunk
## of at most 10kB size
chunk.apply("input.file.txt",
            function(o) {
              m = mstrsplit(o, type='numeric')
              quantile(m[,1], c(0.25, 0.5, 0.75))
            }, CH.MAX.SIZE=1e5)

## End(Not run)
</code></pre>

<hr>
<h2 id='chunk.map'>
Map a function over a file by chunks
</h2><span id='topic+chunk.map'></span>

<h3>Description</h3>

<p>A wrapper around the core iotools functions to easily
apply a function over chunks of a large file. Results can
be either written to a file or returned as an internal list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk.map(input, output = NULL, formatter = .default.formatter,
          FUN, key.sep = NULL, max.line = 65536L,
          max.size = 33554432L, output.sep = ",", output.nsep = "\t",
          output.keys = FALSE, skip = 0L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk.map_+3A_input">input</code></td>
<td>
<p>an input connection or character vector describing a local file.</p>
</td></tr>
<tr><td><code id="chunk.map_+3A_output">output</code></td>
<td>
<p>an optional output connection or character vector describing a local file.
If <code>NULL</code>, the results are returned internally as a list.</p>
</td></tr>
<tr><td><code id="chunk.map_+3A_formatter">formatter</code></td>
<td>
<p>a function that takes raw input and produces the input given to <code>FUN</code></p>
</td></tr>
<tr><td><code id="chunk.map_+3A_fun">FUN</code></td>
<td>
<p>a user provided function to map over the chunks. The result of FUN is either
wrapper in a list item, when <code>output</code> is <code>NULL</code>, or written to the output file
using <code><a href="#topic+as.output">as.output</a></code></p>
</td></tr>
<tr><td><code id="chunk.map_+3A_key.sep">key.sep</code></td>
<td>
<p>optional key separator given to <code><a href="#topic+chunk.reader">chunk.reader</a></code></p>
</td></tr>
<tr><td><code id="chunk.map_+3A_max.line">max.line</code></td>
<td>
<p>maximum number of lines given to <code><a href="#topic+chunk.reader">chunk.reader</a></code></p>
</td></tr>
<tr><td><code id="chunk.map_+3A_max.size">max.size</code></td>
<td>
<p>maximum size of a block as given to <code><a href="#topic+read.chunk">read.chunk</a></code></p>
</td></tr>
<tr><td><code id="chunk.map_+3A_output.sep">output.sep</code></td>
<td>
<p>single character giving the field separator in the output.</p>
</td></tr>
<tr><td><code id="chunk.map_+3A_output.nsep">output.nsep</code></td>
<td>
<p>single character giving the key separator in the output.</p>
</td></tr>
<tr><td><code id="chunk.map_+3A_output.keys">output.keys</code></td>
<td>
<p>logical. Whether as.output should interpret row names as keys.</p>
</td></tr>
<tr><td><code id="chunk.map_+3A_skip">skip</code></td>
<td>
<p>integer giving the number of lines to strip off the input before reading. Useful
when the input contains a row a column headers</p>
</td></tr>
<tr><td><code id="chunk.map_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results when <code>output</code> is <code>NULL</code>; otherwise no output is returned.
</p>


<h3>Author(s)</h3>

<p>Taylor Arnold
</p>

<hr>
<h2 id='ctapply'>
Fast tapply() replacement functions
</h2><span id='topic+ctapply'></span>

<h3>Description</h3>

<p><code>ctapply</code> is a fast replacement of <code>tapply</code> that assumes
contiguous input, i.e. unique values in the index are never speparated
by any other values. This avoids an expensive <code>split</code> step since
both value and the index chungs can be created on the fly. It also
cuts a few corners to allow very efficient copying of values. This
makes it many orders of magnitude faster than the classical
<code>lapply(split(), ...)</code> implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctapply(X, INDEX, FUN, ..., MERGE=c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctapply_+3A_x">X</code></td>
<td>
<p>an atomic object, typically a vector</p>
</td></tr>
<tr><td><code id="ctapply_+3A_index">INDEX</code></td>
<td>
<p>numeric or character vector of the same length as <code>X</code></p>
</td></tr>
<tr><td><code id="ctapply_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied</p>
</td></tr>
<tr><td><code id="ctapply_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>FUN</code>. They are passed as-is,
i.e., without replication or recycling</p>
</td></tr>
<tr><td><code id="ctapply_+3A_merge">MERGE</code></td>
<td>
<p>function to merge the resulting vector or <code>NULL</code> if
the arguments to such a functiona re to be returned instead</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>ctapply</code> supports either integer, real or character
vectors as indices (note that factors are integer vectors and thus
supported, but you do not need to convert character vectors). Unlike
<code>tapply</code> it does not take a list of factors - if you want to use
a cross-product of factors, create the product first, e.g. using
<code>paste(i1, i2, i3, sep='\01')</code> or multiplication - whetever
method is convenient for the input types.
</p>
<p><code>ctapply</code> requires the <code>INDEX</code> to contiguous. One (slow) way
to achieve that is to use <code><a href="base.html#topic+sort">sort</a></code> or <code><a href="base.html#topic+order">order</a></code>.
</p>
<p><code>ctapply</code> also supports <code>X</code> to be a matrix in which case it
is split row-wise based on <code>INDEX</code>. The number of rows must match
the length of <code>INDEX</code>. Note that the indexed matrices behave as
if <code>drop=FALSE</code> was used and curretnly <code>dimnames</code> are only
honored if rownames are present.
</p>


<h3>Note</h3>

<p>This function has been moved to the <code>fastmatch</code> package!
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tapply">tapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i = rnorm(4e6)
names(i) = as.integer(rnorm(1e6))
i = i[order(names(i))]
system.time(tapply(i, names(i), sum))
system.time(ctapply(i, names(i), sum))

## ctapply() also works on matrices (unlike tapply)
m=matrix(c("A","A","B","B","B","C","A","B","C","D","E","F","","X","X","Y","Y","Z"),,3)
ctapply(m, m[,1], identity, MERGE=list)
ctapply(m, m[,1], identity, MERGE=rbind)
m2=m[,-1]
rownames(m2)=m[,1]
colnames(m2) = c("V1","V2")
ctapply(m2, rownames(m2), identity, MERGE=list)
ctapply(m2, rownames(m2), identity, MERGE=rbind)
</code></pre>

<hr>
<h2 id='dstrfw'>
Split fixed width input into a dataframe
</h2><span id='topic+dstrfw'></span>

<h3>Description</h3>

<p><code>dstrfw</code> takes raw or character vector and splits it
into a dataframe according to a vector of fixed widths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dstrfw(x, col_types, widths, nsep = NA, strict=TRUE, skip=0L, nrows=-1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dstrfw_+3A_x">x</code></td>
<td>
<p>character vector (each element is treated as a row) or a
raw vector (newlines separate rows)</p>
</td></tr>
<tr><td><code id="dstrfw_+3A_col_types">col_types</code></td>
<td>
<p>required character vector or a list. A vector of
classes to be assumed for the output dataframe. If it is a list,
<code>class(x)[1]</code> will be used to determine the class of the
contained element. It will not be recycled, and must
be at least as long as the longest row if <code>strict</code> is <code>TRUE</code>.
</p>
<p>Possible values are <code>"NULL"</code> (when the column is skipped) one of
the six atomic vector types (<code>'character'</code>, <code>'numeric'</code>,
<code>'logical'</code>, <code>'integer'</code>,  <code>'complex'</code>, <code>'raw'</code>)
or <code>POSIXct</code>.
'POSIXct' will parse date format in the form &quot;YYYY-MM-DD hh:mm:ss.sss&quot;
assuming GMT time zone. The separators between digits can be any
non-digit characters and only the date part is mandatory. See also
<code>fasttime::asPOSIXct</code> for details.
</p>
</td></tr>
<tr><td><code id="dstrfw_+3A_widths">widths</code></td>
<td>
<p>a vector of widths of the columns. Must be the same length
as <code>col_types</code>.</p>
</td></tr>
<tr><td><code id="dstrfw_+3A_nsep">nsep</code></td>
<td>
<p>index name separator (single character) or <code>NA</code> if no
index names are included</p>
</td></tr>
<tr><td><code id="dstrfw_+3A_strict">strict</code></td>
<td>
<p>logical, if <code>FALSE</code> then <code>dstrsplit</code> will not
fail on parsing errors, otherwise input not matching the format
(e.g. more columns than expected) will cause an error.</p>
</td></tr>
<tr><td><code id="dstrfw_+3A_skip">skip</code></td>
<td>
<p>integer: the number of lines of the data file to skip before
beginning to read data.</p>
</td></tr>
<tr><td><code id="dstrfw_+3A_nrows">nrows</code></td>
<td>
<p>integer: the maximum number of rows to read in.  Negative and
other invalid values are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nsep</code> is specified, the output of <code>dstrsplit</code> contains
an extra column called 'rowindex' containing the row index. This is
used instead of the rownames to allow for duplicated indicies (which
are checked for and not allowed in a dataframe, unlike the case with
a matrix).
</p>


<h3>Value</h3>

<p>If <code>nsep</code> is specified then all characters up to (but excluding)
the occurrence of <code>nsep</code> are treated as the index name. The
remaining characters are split using the <code>widths</code> vector into
fields (columns). <code>dstrfw</code> will fail with an error if any
line does not contain enough characters to fill all expected columns,
unless <code>strict</code> is <code>FALSE</code>. Excessive columns are ignored
in that case. Lines may contain fewer columns (but not partial ones
unless <code>strict</code> is <code>FALSE</code>) in which case they are set to
<code>NA</code>.
</p>
<p><code>dstrfw</code> returns a data.frame with as many rows as
they are lines in the input and as many columns as there are
non-NA values in <code>col_types</code>, plus an additional column if
<code>nsep</code> is specified. The colnames (other than the row index)
are set to 'V' concatenated with the column number unless
<code>col_types</code> is a named vector in which case the names are
inherited.
</p>


<h3>Author(s)</h3>

<p>Taylor Arnold and Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input = c("bear\t22.7horse+3", "pear\t 3.4mouse-3", "dogs\t14.8prime-8")
z = dstrfw(x = input, col_types = c("numeric", "character", "integer"),
      width=c(4L,5L,2L), nsep="\t")
z

# Now without row names (treat seperator as a 1 char width column with type NULL)
z = dstrfw(x = input,
    col_types = c("character", "NULL", "numeric", "character", "integer"),
    width=c(4L,1L,4L,5L,2L))
z
</code></pre>

<hr>
<h2 id='dstrsplit'>
Split binary or character input into a dataframe
</h2><span id='topic+dstrsplit'></span><span id='topic+rowindex'></span>

<h3>Description</h3>

<p><code>dstrsplit</code> takes raw or character vector and splits it
into a dataframe according to the separators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dstrsplit(x, col_types, sep="|", nsep=NA, strict=TRUE, skip=0L, nrows=-1L,
          quote="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dstrsplit_+3A_x">x</code></td>
<td>
<p>character vector (each element is treated as a row) or a
raw vector (newlines separate rows)</p>
</td></tr>
<tr><td><code id="dstrsplit_+3A_col_types">col_types</code></td>
<td>
<p>required character vector or a list. A vector of
classes to be assumed for the output dataframe. If it is a list,
<code>class(x)[1]</code> will be used to determine the class of the
contained element. It will not be recycled, and must
be at least as long as the longest row if <code>strict</code> is <code>TRUE</code>.
</p>
<p>Possible values are <code>"NULL"</code> (when the column is skipped) one of
the six atomic vector types (<code>'character'</code>, <code>'numeric'</code>,
<code>'logical'</code>, <code>'integer'</code>,  <code>'complex'</code>, <code>'raw'</code>)
or <code>POSIXct</code>.
'POSIXct' will parse date format in the form &quot;YYYY-MM-DD hh:mm:ss.sss&quot;
assuming GMT time zone. The separators between digits can be any
non-digit characters and only the date part is mandatory. See also
<code>fasttime::asPOSIXct</code> for details.
</p>
</td></tr>
<tr><td><code id="dstrsplit_+3A_sep">sep</code></td>
<td>
<p>single character: field (column) separator. Set to <code>NA</code>
for no seperator; in other words, a single column.</p>
</td></tr>
<tr><td><code id="dstrsplit_+3A_nsep">nsep</code></td>
<td>
<p>index name separator (single character) or <code>NA</code> if no
index names are included</p>
</td></tr>
<tr><td><code id="dstrsplit_+3A_strict">strict</code></td>
<td>
<p>logical, if <code>FALSE</code> then <code>dstrsplit</code> will not
fail on parsing errors, otherwise input not matching the format
(e.g. more columns than expected) will cause an error.</p>
</td></tr>
<tr><td><code id="dstrsplit_+3A_skip">skip</code></td>
<td>
<p>integer: the number of lines of the data file to skip before
beginning to read data.</p>
</td></tr>
<tr><td><code id="dstrsplit_+3A_nrows">nrows</code></td>
<td>
<p>integer: the maximum number of rows to read in.  Negative and
other invalid values are ignored.</p>
</td></tr>
<tr><td><code id="dstrsplit_+3A_quote">quote</code></td>
<td>
<p>the set of quoting characters as a length 1 vector. To disable
quoting altogether, use <code>quote = ""</code> (the default). Quoting
is only considered for columns read as character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nsep</code> is specified then all characters up to (but excluding)
the occurrence of <code>nsep</code> are treated as the index name. The
remaining characters are split using the <code>sep</code> character into
fields (columns). <code>dstrsplit</code> will fail with an error if any
line contains more columns then expected unless <code>strict</code> is
<code>FALSE</code>. Excessive columns are ignored in that case. Lines may
contain fewer columns in which case they are set to <code>NA</code>.
</p>
<p>Note that it is legal to use the same separator for <code>sep</code> and
<code>nsep</code> in which case the first field is treated as a row name and
subsequent fields as data columns.
</p>
<p>If <code>nsep</code> is specified, the output of <code>dstrsplit</code> contains
an extra column called 'rowindex' containing the row index. This is
used instead of the rownames to allow for duplicated indicies (which
are checked for and not allowed in a dataframe, unlike the case with
a matrix).
</p>


<h3>Value</h3>

<p><code>dstrsplit</code> returns a data.frame with as many rows as
they are lines in the input and as many columns as there are
non-NULL values in <code>col_types</code>, plus an additional column if
<code>nsep</code> is specified. The colnames (other than the row index)
are set to 'V' concatenated with the column number unless
<code>col_types</code> is a named vector in which case the names are
inherited.
</p>


<h3>Author(s)</h3>

<p>Taylor Arnold and Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input = c("apple\t2|2.7|horse|0d|1|2015-02-05 20:22:57",
          "pear\t7|3e3|bear|e4|1+3i|2015-02-05",
          "pear\te|1.8|bat|77|4.2i|2001-02-05")
z = dstrsplit(x = input,
      col_types = c("integer", "numeric", "character","raw","complex","POSIXct"),
      sep="|", nsep="\t")
lapply(z,class)
z

# Ignoring the third column:
z = dstrsplit(x = input,
      col_types = c("integer", "numeric", "character","raw","complex","POSIXct"),
      sep="|", nsep="\t")
z
</code></pre>

<hr>
<h2 id='fdrbind'>
Fast row-binding of lists and data frames
</h2><span id='topic+fdrbind'></span>

<h3>Description</h3>

<p><code>fdrbind</code> lakes a list of data frames or lists and merges them
together by rows very much like <code>rbind</code> does for its
arguments. But unlike <code>rbind</code> it specializes on data frames and
lists of columns only and performs the merge entriley at C leve which
allows it to be much faster than <code>rbind</code> at the cost of
generality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdrbind(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdrbind_+3A_list">list</code></td>
<td>
<p>lists of parts that can be either data frames or lists</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All parts are expected to have the same number of columns in the
same order. No column name matching is performed, they are merged by
position. Also the same column in each part has to be of the same
type, no coersion is performed at this point. The first part
determines the column names, if any. If the parts contain data
frames, their rownames are ignored, only the contents are merged.
Attributes are not copied, which is intentional. Probaby the most
common implocation is that ff you use factors, they must have all
the same levels, otherwise you have to convert factor columns to
strings first.
</p>


<h3>Value</h3>

<p>The merged data frame.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rbind">rbind</a></code>
</p>

<hr>
<h2 id='idstrsplit'>
Create an iterator for splitting binary or character input into a dataframe
</h2><span id='topic+idstrsplit'></span>

<h3>Description</h3>

<p><code>idstrsplit</code> takes a binary connection or character vector (which is 
interpreted as a file name) and splits it into a series of dataframes 
according to the separator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idstrsplit(x, col_types, sep="|", nsep=NA, strict=TRUE, 
           max.line = 65536L, max.size = 33554432L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idstrsplit_+3A_x">x</code></td>
<td>
<p>character vector (each element is treated as a row) or a
raw vector (newlines separate rows)</p>
</td></tr>
<tr><td><code id="idstrsplit_+3A_col_types">col_types</code></td>
<td>
<p>required character vector or a list. A vector of
classes to be assumed for the output dataframe. If it is a list,
<code>class(x)[1]</code> will be used to determine the class of the
contained element. It will not be recycled, and must
be at least as long as the longest row if <code>strict</code> is <code>TRUE</code>.
</p>
<p>Possible values are <code>"NULL"</code> (when the column is skipped) one of
the six atomic vector types (<code>'character'</code>, <code>'numeric'</code>,
<code>'logical'</code>, <code>'integer'</code>,  <code>'complex'</code>, <code>'raw'</code>)
or <code>POSIXct</code>.
'POSIXct' will parse date format in the form &quot;YYYY-MM-DD hh:mm:ss.sss&quot;
assuming GMT time zone. The separators between digits can be any
non-digit characters and only the date part is mandatory. See also
<code>fasttime::asPOSIXct</code> for details.
</p>
</td></tr>
<tr><td><code id="idstrsplit_+3A_sep">sep</code></td>
<td>
<p>single character: field (column) separator. Set to <code>NA</code>
for no seperator; in other words, a single column.</p>
</td></tr>
<tr><td><code id="idstrsplit_+3A_nsep">nsep</code></td>
<td>
<p>index name separator (single character) or <code>NA</code> if no
index names are included</p>
</td></tr>
<tr><td><code id="idstrsplit_+3A_strict">strict</code></td>
<td>
<p>logical, if <code>FALSE</code> then <code>dstrsplit</code> will not
fail on parsing errors, otherwise input not matching the format
(e.g. more columns than expected) will cause an error.</p>
</td></tr>
<tr><td><code id="idstrsplit_+3A_max.line">max.line</code></td>
<td>
<p>maximum length of one line (in byets) - determines the
size of the read buffer, default is 64kb</p>
</td></tr>
<tr><td><code id="idstrsplit_+3A_max.size">max.size</code></td>
<td>
<p>maximum size of the chunk (in bytes), default is 32Mb</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nsep</code> is specified then all characters up to (but excluding)
the occurrence of <code>nsep</code> are treated as the index name. The
remaining characters are split using the <code>sep</code> character into
fields (columns). <code>dstrsplit</code> will fail with an error if any
line contains more columns then expected unless <code>strict</code> is
<code>FALSE</code>. Excessive columns are ignored in that case. Lines may
contain fewer columns in which case they are set to <code>NA</code>.
</p>
<p>Note that it is legal to use the same separator for <code>sep</code> and
<code>nsep</code> in which case the first field is treated as a row name and
subsequent fields as data columns.
</p>
<p>If <code>nsep</code> is specified, the output of <code>dstrsplit</code> contains
an extra column called 'rowindex' containing the row index. This is
used instead of the rownames to allow for duplicated indicies (which
are checked for and not allowed in a dataframe, unlike the case with
a matrix).
</p>


<h3>Value</h3>

<p><code>idstrsplit</code> returns an iterator (closure). When <code>nextElem</code> is
called on the iterator a data.frame is returned with as many rows as
they are lines in the input and as many columns as there are
non-NULL values in <code>col_types</code>, plus an additional column if
<code>nsep</code> is specified. The colnames (other than the row index)
are set to 'V' concatenated with the column number unless
<code>col_types</code> is a named vector in which case the names are
inherited.
</p>


<h3>Author(s)</h3>

<p>Michael Kane
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_names &lt;- names(iris)
write.csv(iris, file="iris.csv", row.names=FALSE)
it &lt;- idstrsplit("iris.csv", col_types=c(rep("numeric", 4), "character"), 
                 sep=",")
# Get the elements
iris_read &lt;- it$nextElem()[-1,]
# or with the iterators package
# nextElem(it)
names(iris_read) &lt;- col_names
print(head(iris_read))

## remove iterator, connections and files
rm("it")
gc(FALSE)
unlink("iris.csv")
</code></pre>

<hr>
<h2 id='imstrsplit'>
Create an iterator for splitting binary or character input into a matrix
</h2><span id='topic+imstrsplit'></span>

<h3>Description</h3>

<p><code>imstrsplit</code> takes a binary connection or character vector (which is 
interpreted as a file name) and splits it into a character matrix 
according to the separator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imstrsplit(x, sep="|", nsep=NA, strict=TRUE, ncol = NA,
          type=c("character", "numeric", "logical", "integer",  "complex", 
                 "raw"), max.line = 65536L, max.size = 33554432L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imstrsplit_+3A_x">x</code></td>
<td>
<p>character vector (each element is treated as a row) or a raw
vector (LF characters <code>'\n'</code> separate rows) to split</p>
</td></tr>
<tr><td><code id="imstrsplit_+3A_sep">sep</code></td>
<td>
<p>single character: field (column) separator. Set to <code>NA</code>
for no seperator; in other words, a single column.</p>
</td></tr>
<tr><td><code id="imstrsplit_+3A_nsep">nsep</code></td>
<td>
<p>row name separator (single character) or <code>NA</code> if no
row names are included</p>
</td></tr>
<tr><td><code id="imstrsplit_+3A_strict">strict</code></td>
<td>
<p>logical, if <code>FALSE</code> then <code>mstrsplit</code> will not
fail on parsing errors, otherwise input not matching the format
(e.g. more columns than expected) will cause an error.</p>
</td></tr>
<tr><td><code id="imstrsplit_+3A_ncol">ncol</code></td>
<td>
<p>number of columns to expect. If <code>NA</code> then the number
of columns is guessed from the first line.</p>
</td></tr>
<tr><td><code id="imstrsplit_+3A_type">type</code></td>
<td>
<p>a character string representing one of the 6 atomic types:
<code>'character'</code>, <code>'numeric'</code>, <code>'logical'</code>, <code>'integer'</code>,
<code>'complex'</code>, or <code>'raw'</code>. The output matrix will use this as its
storage mode and the input will be parsed directly into this format
without using intermediate strings.</p>
</td></tr>
<tr><td><code id="imstrsplit_+3A_max.line">max.line</code></td>
<td>
<p>maximum length of one line (in byets) - determines the
size of the read buffer, default is 64kb</p>
</td></tr>
<tr><td><code id="imstrsplit_+3A_max.size">max.size</code></td>
<td>
<p>maximum size of the chunk (in bytes), default is 32Mb</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input is a raw vector, then it is interpreted as ASCII/UTF-8 content
with LF (<code>'\n'</code>) characters separating lines. If the input is a
character vector then each element is treated as a line.
</p>
<p>If <code>nsep</code> is specified then all characters up to (but excluding)
the occurrence of <code>nsep</code> are treated as the row name. The
remaining characters are split using the <code>sep</code> character into
fields (columns). If <code>ncol</code> is <code>NA</code> then the first line of
the input determines the number of columns. <code>mstrsplit</code> will fail
with an error if any line contains more columns then expected unless
<code>strict</code> is <code>FALSE</code>. Excessive columns are ignored in that
case. Lines may contain fewer columns in which case they are set to
<code>NA</code>.
</p>
<p>The processing is geared towards efficiency - no string re-coding is
performed and raw input vector is processed directly, avoiding the
creation of intermediate string representations.
</p>
<p>Note that it is legal to use the same separator for <code>sep</code> and
<code>nsep</code> in which case the first field is treated as a row name and
subsequent fields as data columns.
</p>


<h3>Value</h3>

<p>A matrix with as many rows as they are lines in the input and
as many columns as there are fields in the first line. The
storage mode of the matrix will be determined by the input to
<code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Kane
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  mm &lt;- model.matrix(~., iris)
  f &lt;- file("iris_mm.io", "wb")
  writeBin(as.output(mm), f)
  close(f)
  it &lt;- imstrsplit("iris_mm.io", type="numeric", nsep="\t")
  iris_mm &lt;- it$nextElem()
  print(head(iris_mm))

  ## remove iterator, connections and files
  rm("it")
  gc(FALSE)
  unlink("iris_mm.io")
</code></pre>

<hr>
<h2 id='input.file'>
Load a file on the disk
</h2><span id='topic+input.file'></span>

<h3>Description</h3>

<p><code>input.file</code> efficently reads a file on the disk into R using
a formatter function. The function may be <code>mstrsplit</code>,
<code>dstrsplit</code>, <code>dstrfw</code>, but can also be a user-defined
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>input.file(file_name, formatter = mstrsplit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="input.file_+3A_file_name">file_name</code></td>
<td>
<p>the input filename as a character string</p>
</td></tr>
<tr><td><code id="input.file_+3A_formatter">formatter</code></td>
<td>
<p>a function for formatting the input. <code>mstrsplit</code>
is used by default.</p>
</td></tr>
<tr><td><code id="input.file_+3A_...">...</code></td>
<td>
<p>other arguments passed to the formatter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the return type of the formatter function; by default a character matrix.
</p>


<h3>Author(s)</h3>

<p>Taylor Arnold and Simon Urbanek
</p>

<hr>
<h2 id='line.merge'>
Merge multiple sources
</h2><span id='topic+line.merge'></span>

<h3>Description</h3>

<p>Read lines for a collection of sources and merges the results to a single output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line.merge(sources, target, sep = "|", close = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line.merge_+3A_sources">sources</code></td>
<td>
<p>A list or vector of connections which need to be merged</p>
</td></tr>
<tr><td><code id="line.merge_+3A_target">target</code></td>
<td>
<p>A connection object or a character string giving the output
of the merge. If a character string a new file connection will be created
with the supplied file name.</p>
</td></tr>
<tr><td><code id="line.merge_+3A_sep">sep</code></td>
<td>
<p>string specifying the key delimiter. Only the first character
is used. Can be <code>""</code> if the entire string is to be treated as
a key.</p>
</td></tr>
<tr><td><code id="line.merge_+3A_close">close</code></td>
<td>
<p>logical. Should the input to sources be closed by the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No explicit value is returned. The function is used purely for its side effects
on the sources and target.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>

<hr>
<h2 id='mstrsplit'>
Split binary or character input into a matrix
</h2><span id='topic+mstrsplit'></span>

<h3>Description</h3>

<p><code>mstrsplit</code> takes either raw or character vector and splits it
into a character matrix according to the separators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstrsplit(x, sep="|", nsep=NA, strict=TRUE, ncol = NA,
          type=c("character", "numeric", "logical", "integer",  "complex", "raw"),
          skip=0L, nrows=-1L, quote="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstrsplit_+3A_x">x</code></td>
<td>
<p>character vector (each element is treated as a row) or a raw
vector (LF characters <code>'\n'</code> separate rows) to split</p>
</td></tr>
<tr><td><code id="mstrsplit_+3A_sep">sep</code></td>
<td>
<p>single character: field (column) separator. Set to <code>NA</code>
for no seperator; in other words, a single column.</p>
</td></tr>
<tr><td><code id="mstrsplit_+3A_nsep">nsep</code></td>
<td>
<p>row name separator (single character) or <code>NA</code> if no
row names are included</p>
</td></tr>
<tr><td><code id="mstrsplit_+3A_strict">strict</code></td>
<td>
<p>logical, if <code>FALSE</code> then <code>mstrsplit</code> will not
fail on parsing errors, otherwise input not matching the format
(e.g. more columns than expected) will cause an error.</p>
</td></tr>
<tr><td><code id="mstrsplit_+3A_ncol">ncol</code></td>
<td>
<p>number of columns to expect. If <code>NA</code> then the number
of columns is guessed from the first line.</p>
</td></tr>
<tr><td><code id="mstrsplit_+3A_type">type</code></td>
<td>
<p>a character string representing one of the 6 atomic types:
<code>'character'</code>, <code>'numeric'</code>, <code>'logical'</code>, <code>'integer'</code>,
<code>'complex'</code>, or <code>'raw'</code>. The output matrix will use this as its
storage mode and the input will be parsed directly into this format
without using intermediate strings.</p>
</td></tr>
<tr><td><code id="mstrsplit_+3A_skip">skip</code></td>
<td>
<p>integer: the number of lines of the data file to skip before
parsing records.</p>
</td></tr>
<tr><td><code id="mstrsplit_+3A_nrows">nrows</code></td>
<td>
<p>integer: the maximum number of rows to read in.  Negative and
other invalid values are ignored, and indiate that the entire input
should be processed.</p>
</td></tr>
<tr><td><code id="mstrsplit_+3A_quote">quote</code></td>
<td>
<p>the set of quoting characters as a length 1 vector. To disable
quoting altogether, use <code>quote = ""</code> (the default). Quoting
is only considered for columns read as character.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input is a raw vector, then it is interpreted as ASCII/UTF-8 content
with LF (<code>'\n'</code>) characters separating lines. If the input is a
character vector then each element is treated as a line.
</p>
<p>If <code>nsep</code> is specified then all characters up to (but excluding)
the occurrence of <code>nsep</code> are treated as the row name. The
remaining characters are split using the <code>sep</code> character into
fields (columns). If <code>ncol</code> is <code>NA</code> then the first line of
the input determines the number of columns. <code>mstrsplit</code> will fail
with an error if any line contains more columns then expected unless
<code>strict</code> is <code>FALSE</code>. Excessive columns are ignored in that
case. Lines may contain fewer columns in which case they are set to
<code>NA</code>.
</p>
<p>The processing is geared towards efficiency - no string re-coding is
performed and raw input vector is processed directly, avoiding the
creation of intermediate string representations.
</p>
<p>Note that it is legal to use the same separator for <code>sep</code> and
<code>nsep</code> in which case the first field is treated as a row name and
subsequent fields as data columns.
</p>


<h3>Value</h3>

<p>A matrix with as many rows as they are lines in the input and
as many columns as there are fields in the first line. The
storage mode of the matrix will be determined by the input to
<code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  c &lt;- c("A\tB|C|D", "A\tB|B|B", "B\tA|C|E")
  m &lt;- mstrsplit(gsub("\t","|",c))
  dim(m)
  m
  m &lt;- mstrsplit(c,, "\t")
  rownames(m)
  m

  ## use raw vectors instead
  r &lt;- charToRaw(paste(c, collapse="\n"))
  mstrsplit(r)
  mstrsplit(r, nsep="\t")
</code></pre>

<hr>
<h2 id='output.file'>
Write an R object to a file as a character string
</h2><span id='topic+output.file'></span>

<h3>Description</h3>

<p>Writes any R object to a file or connection using an output
formatter. Useful for pairing with the <code>input.file</code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  output.file(x, file, formatter.output = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output.file_+3A_x">x</code></td>
<td>
<p>R object to write to the file</p>
</td></tr>
<tr><td><code id="output.file_+3A_file">file</code></td>
<td>
<p>the input filename as a character string or a connection object
open for writting.</p>
</td></tr>
<tr><td><code id="output.file_+3A_formatter.output">formatter.output</code></td>
<td>
<p>a function for formatting the output. Using null
will attempt to find the appropriate method given the class of the input
<code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns the input to <code>file</code>.
</p>


<h3>Author(s)</h3>

<p>Taylor Arnold and Simon Urbanek
</p>

<hr>
<h2 id='read.csv.raw'>
Fast data frame input
</h2><span id='topic+read.csv.raw'></span><span id='topic+read.delim.raw'></span>

<h3>Description</h3>

<p>A fast replacement of <code>read.csv</code> and <code>read.delim</code> which
pre-loads the data as a raw vector and parses without constructing
intermediate strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.csv.raw(file, header=TRUE, sep=",", skip=0L, fileEncoding="",
              colClasses, nrows = -1L, nsep = NA, strict=TRUE,
              nrowsClasses = 25L, quote="'\"")

read.delim.raw(file, header=TRUE, sep="\t", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.csv.raw_+3A_file">file</code></td>
<td>
<p>A connection object or a character string naming a file
from which to read data.</p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_header">header</code></td>
<td>
<p>logical. Does a header row exist for the data.</p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_sep">sep</code></td>
<td>
<p>single character: field (column) separator.</p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_skip">skip</code></td>
<td>
<p>integer. Number of lines to skip in the input, no including
the header.</p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>The name of the encoding to be assumed. Only used when
<code>con</code> is a character string naming a file.</p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_colclasses">colClasses</code></td>
<td>
<p>an optional character vector indicating the column
types. A vector of classes to be assumed for the output dataframe.
If it is a list, <code>class(x)[1]</code> will be used to determine the class
of the contained element. It will not be recycled, and must
be at least as long as the longest row if <code>strict</code> is <code>TRUE</code>.
</p>
<p>Possible values are <code>"NULL"</code> (when the column is skipped) one of
the six atomic vector types (<code>'character'</code>, <code>'numeric'</code>,
<code>'logical'</code>, <code>'integer'</code>,  <code>'complex'</code>, <code>'raw'</code>)
or <code>POSIXct</code>.
'POSIXct' will parse date format in the form &quot;YYYY-MM-DD hh:mm:ss.sss&quot;
assuming GMT time zone. The separators between digits can be any
non-digit characters and only the date part is mandatory. See also
<code>fasttime::asPOSIXct</code> for details.
</p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_nrows">nrows</code></td>
<td>
<p>integer: the maximum number of rows to read in.  Negative and
other invalid values are ignored.</p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_nsep">nsep</code></td>
<td>
<p>index name separator (single character) or <code>NA</code> if no
index names are included</p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_strict">strict</code></td>
<td>
<p>logical, if <code>FALSE</code> then <code>dstrsplit</code> will not
fail on parsing errors, otherwise input not matching the format
(e.g. more columns than expected) will cause an error.</p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_nrowsclasses">nrowsClasses</code></td>
<td>
<p>integer. Maximum number of rows of data to read to learn column
types. Not used when <code>col_types</code> is supplied. </p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_quote">quote</code></td>
<td>
<p>the set of quoting characters as a length 1 vector. To disable
quoting altogether, use <code>quote = ""</code>. Quoting
is only considered for columns read as character.</p>
</td></tr>
<tr><td><code id="read.csv.raw_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code>read.csv.raw</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+dstrsplit">dstrsplit</a></code> for the details of <code>nsep</code>, <code>sep</code>,
and <code>strict</code>.
</p>


<h3>Value</h3>

<p>A data frame containing a representation of the data in the file.
</p>


<h3>Author(s)</h3>

<p>Taylor Arnold and Simon Urbanek
</p>

<hr>
<h2 id='readAsRaw'>
Read binary data in as raw
</h2><span id='topic+readAsRaw'></span>

<h3>Description</h3>

<p><code>readAsRaw</code> takes a connection or file name and reads it into
a raw type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAsRaw(con, n, nmax, fileEncoding="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readAsRaw_+3A_con">con</code></td>
<td>
<p>A connection object or a character string naming a file
from which to save the output.</p>
</td></tr>
<tr><td><code id="readAsRaw_+3A_n">n</code></td>
<td>
<p>Expected number of bytes to read. Set to <code>65536L</code> by
default when <code>con</code> is a connection, and set to the file size
by default when <code>con</code> is a character string.</p>
</td></tr>
<tr><td><code id="readAsRaw_+3A_nmax">nmax</code></td>
<td>
<p>Maximum number of bytes to read; missing of <code>Inf</code>
to read in the entire connection.</p>
</td></tr>
<tr><td><code id="readAsRaw_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>When <code>con</code> is a connection, the file encoding
to use to open the connection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>readAsRaw</code> returns a <code>raw</code> type which can then be consumed
by functions like <code>mstrsplit</code> and <code>dstrsplit</code>.
</p>


<h3>Author(s)</h3>

<p>Taylor Arnold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  mm &lt;- model.matrix(~., iris)
  f &lt;- file("iris_mm.io", "wb")
  writeBin(as.output(mm), f)
  close(f)
  m &lt;- mstrsplit(readAsRaw("iris_mm.io"), type="numeric", nsep="\t")
  head(mm)
  head(m)
  unlink("iris_mm.io")
</code></pre>

<hr>
<h2 id='which.min.key'>
Determine the next key in bytewise order
</h2><span id='topic+which.min.key'></span>

<h3>Description</h3>

<p><code>which.min.key</code> takes either a character vector or a list of
strings and returns the location of the element that is
lexicographically (using bytewise comparison) the first. In a sense
it is <code>which.min</code> for strings. In addition, it supports prefix
comparisons using a key delimiter (see below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.min.key(keys, sep = "|")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.min.key_+3A_keys">keys</code></td>
<td>
<p>character vector or a list of strings to use as input</p>
</td></tr>
<tr><td><code id="which.min.key_+3A_sep">sep</code></td>
<td>
<p>string specifying the key delimiter. Only the first
character is used. Can be <code>""</code> if the entire string is to be
treated as a key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>which.min.key</code> considers the prefix of each element in
<code>keys</code> up to the delimiter specified by <code>sep</code>. It returns
the index of the element which is lexicographically first among all
the elements, using bytewise comparison (i.e. the locale is not used
and multi-byte characters are not considered as one character).
</p>
<p>If <code>keys</code> is a character vector then <code>NA</code> elements are
treated as non-existent and will never be picked.
</p>
<p>If <code>keys</code> is a list then only string elements of length &gt; 0 are
eligible and <code>NA</code>s are not treated specially (hence they will
be sorted in just like the <code>"NA"</code> string).
</p>


<h3>Value</h3>

<p>scalar integer denoting the index of the lexicographically first
element. In case of a tie the lowest index is returned. If there are
no eligible elements in <code>keys</code> then a zero-length integer vector
is returned.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which.min">which.min</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>which.min.key(c("g","a","b",NA,"z","a"))
which.min.key(c("g","a|z","b",NA,"z|0","a"))
which.min.key(c("g","a|z","b",NA,"z|0","a"), "")
which.min.key(list("X",1,NULL,"F","Z"))
which.min.key(as.character(c(NA, NA)))
which.min.key(NA_character_)
which.min.key(list())
</code></pre>

<hr>
<h2 id='write.csv.raw'>
Fast data output to disk
</h2><span id='topic+write.csv.raw'></span><span id='topic+write.table.raw'></span>

<h3>Description</h3>

<p>A fast replacement of <code>write.csv</code> and <code>write.table</code> which
saves the data as a raw vector rather than a character one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.csv.raw(x, file = "", append = FALSE, sep = ",", nsep="\t",
              col.names = !is.null(colnames(x)), fileEncoding = "")

write.table.raw(x, file = "", sep = " ", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.csv.raw_+3A_x">x</code></td>
<td>
<p>object which is to be saved.</p>
</td></tr>
<tr><td><code id="write.csv.raw_+3A_file">file</code></td>
<td>
<p>A connection object or a character string naming a file
from which to save the output.</p>
</td></tr>
<tr><td><code id="write.csv.raw_+3A_append">append</code></td>
<td>
<p>logical. Only used when file is a character string.</p>
</td></tr>
<tr><td><code id="write.csv.raw_+3A_sep">sep</code></td>
<td>
<p>field (column) separator.</p>
</td></tr>
<tr><td><code id="write.csv.raw_+3A_nsep">nsep</code></td>
<td>
<p>index name separator (single character) or <code>NA</code> if no
index names are included</p>
</td></tr>
<tr><td><code id="write.csv.raw_+3A_col.names">col.names</code></td>
<td>
<p>logical. Should a raw of column names be writen.</p>
</td></tr>
<tr><td><code id="write.csv.raw_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>character string: if non-empty declares the encoding to
be used on a file.</p>
</td></tr>
<tr><td><code id="write.csv.raw_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code>write.table.raw</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+as.output">as.output</a></code> for the details of how various data types are
converted to raw vectors (or character vectors when raw is not available).
</p>


<h3>Author(s)</h3>

<p>Taylor Arnold and Simon Urbanek
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
