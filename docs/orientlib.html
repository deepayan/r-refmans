<!DOCTYPE html><html><head><title>Help for package orientlib</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {orientlib}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boat3d'><p> Draw boat glyphs for orientation data</p></a></li>
<li><a href='#coerce-methods'><p> Methods for Function coerce in Package &lsquo;orientlib&rsquo;</p></a></li>
<li><a href='#eulerzxz'><p> Create an orientation using Euler angles</p></a></li>
<li><a href='#eulerzyx'><p> Create an orientation using Euler angles</p></a></li>
<li><a href='#index-methods'><p> Methods for indexing orientations</p></a></li>
<li><a href='#length-methods'><p> Length of orientation object</p></a></li>
<li><a href='#matrix-classes'><p>Matrix orientation classes</p></a></li>
<li><a href='#matrix-methods'><p> Methods for matrix operations in &lsquo;orientlib&rsquo;</p></a></li>
<li><a href='#mean-methods'><p>Methods for calculating the mean</p></a></li>
<li><a href='#nearest'><p> Find nearest SO(3) or orthogonal matrix.</p></a></li>
<li><a href='#orientation-class'><p>Class &quot;orientation&quot;</p></a></li>
<li><a href='#orientlib'><p> Orientation Library</p></a></li>
<li><a href='#orientlm'><p> Linear models for orientation data</p></a></li>
<li><a href='#quaternion'><p> Create an orientation using quaternions</p></a></li>
<li><a href='#rotation.distance'><p> Rotation angle or distance</p></a></li>
<li><a href='#rotmatrix'><p> Create an orientation using Euler angles</p></a></li>
<li><a href='#rotvector'><p> Create an orientation using vectorized 3x3 matrices</p></a></li>
<li><a href='#skewmatrix'><p> Create an orientation using the entries in a skew-symmetric matrix representation</p></a></li>
<li><a href='#skewvector'><p> Create an orientation using the entries in a skew-symmetric matrix representation</p></a></li>
<li><a href='#vector-classes'><p>Orientation classes</p></a></li>
<li><a href='#weighted.mean-methods'><p> Weighted mean method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Support for Orientation Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Duncan Murdoch</td>
</tr>
<tr>
<td>Description:</td>
<td>Representations, conversions and display of orientation SO(3) data.
 See the orientlib help topic for details.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Duncan Murdoch &lt;murdoch.duncan@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.13.0), methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, scatterplot3d</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dmurdoch/orientlib">https://github.com/dmurdoch/orientlib</a>,
<a href="https://dmurdoch.github.io/orientlib/">https://dmurdoch.github.io/orientlib/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dmurdoch/orientlib/issues">https://github.com/dmurdoch/orientlib/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-10 16:09:06 UTC; murdoch</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-10 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='boat3d'> Draw boat glyphs for orientation data </h2><span id='topic+boat3d'></span>

<h3>Description</h3>

<p>Draws a stylized sailboat to represent an orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boat3d(orientation, x = 1:length(orientation), y = 0, 
       z = 0, scale = 0.25, col = 'red', add = FALSE, box = FALSE, axes = TRUE,
       graphics = c('rgl', 'scatterplot3d'), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boat3d_+3A_orientation">orientation</code></td>
<td>
<p> An <code><a href="#topic+orientation">orientation</a></code> object to be shown. </p>
</td></tr>
<tr><td><code id="boat3d_+3A_x">x</code>, <code id="boat3d_+3A_y">y</code>, <code id="boat3d_+3A_z">z</code></td>
<td>
<p> Coordinates where boats should be shown. </p>
</td></tr>
<tr><td><code id="boat3d_+3A_scale">scale</code></td>
<td>
<p> Size of boats </p>
</td></tr>
<tr><td><code id="boat3d_+3A_col">col</code></td>
<td>
<p> Colour of boats </p>
</td></tr>
<tr><td><code id="boat3d_+3A_add">add</code></td>
<td>
<p> Context in which to continue drawing, or <code>FALSE</code> to clear first.  </p>
</td></tr>
<tr><td><code id="boat3d_+3A_box">box</code></td>
<td>
<p> Whether to draw a box around the plot </p>
</td></tr>
<tr><td><code id="boat3d_+3A_axes">axes</code></td>
<td>
<p> Whether to draw axes </p>
</td></tr>
<tr><td><code id="boat3d_+3A_graphics">graphics</code></td>
<td>
<p> Which graphics package to use </p>
</td></tr>
<tr><td><code id="boat3d_+3A_...">...</code></td>
<td>
<p> Additional graphics parameters; see Details below </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the identity orientation, the sailboats will be shown upright.
Other orientations are shown as rotations of this glyph.
</p>
<p>The (x,y,z) coordinate appears in the middle of the sail, at the
top of the gunwales of the boat.
</p>
<p>If the <code><a href="rgl.html#topic+rgl-package">rgl</a></code> package is 
installed, it will be used to draw solid faces on the boats which can be moved by the
user.  If not, but the <code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code> package is
installed, it will be used to draw fixed wireframe boats.  This
search order can be changed by modifying the <code>graphics</code> parameter.
</p>
<p>Additional graphics parameters may be passed.  If <code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code> is used, these
are passed to the <code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code> function (and ignored
when adding to an existing plot).  Extra parameters are not passed to
<code><a href="rgl.html#topic+rgl-package">rgl</a></code>.
</p>
<p>To add to a <code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code> plot, you must pass the 
return value from the initial plot as the value of <code>add</code>.  See
the <code><a href="#topic+orientlm">orientlm</a></code> function for an example.
</p>


<h3>Value</h3>

<p>A current
plot number for <code><a href="rgl.html#topic+rgl-package">rgl</a></code>, or a <code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code> 
drawing context.  In any case, an attribute named <code>graphics</code> is added
to indicate the drawing device type.
</p>


<h3>Note</h3>

<p> Requires the <code><a href="rgl.html#topic+rgl-package">rgl</a></code> or 
<code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code> package. </p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- eulerzyx(psi=c(0,pi/4,0,0), theta=c(0,0,pi/4,0), phi=c(0,0,0,pi/4))

# Need a 3D renderer; assume scatterplot3d, but others could be used

s &lt;- boat3d(x, 0:3, axes = FALSE, graphics = 'scatterplot3d')
text(s$xyz.convert(0:3, rep(-0.5,4), rep(-0.5,4)), 
     label = c('Id','z','y','x'))
         
## Not run: 

# if the rgl package is installed, this code will work

boat3d(x, 0:3, axes = FALSE, graphics = 'rgl')
rgl::bbox3d(xat=0:3,xlab=c('Id','z','y','x'),yat=1,zat=1,color='grey')  

## End(Not run)
</code></pre>

<hr>
<h2 id='coerce-methods'> Methods for Function coerce in Package &lsquo;orientlib&rsquo; </h2><span id='topic+coerce+2Cmatrix+2Corientation-method'></span><span id='topic+coerce+2Cmatrix+2Ceulerzyx-method'></span><span id='topic+coerce+2Cmatrix+2Ceulerzxz-method'></span><span id='topic+coerce+2Carray+2Corientation-method'></span><span id='topic+coerce+2Corientation+2Crotvector-method'></span><span id='topic+coerce+2Corientation+2Ceulerzyx-method'></span><span id='topic+coerce+2Corientation+2Cquaternion-method'></span><span id='topic+coerce+2Corientation+2Cskewvector-method'></span><span id='topic+coerce+2Corientation+2Cskewmatrix-method'></span><span id='topic+coerce+2Corientation+2Ceulerzxz-method'></span><span id='topic+coerce+2Crotvector+2Crotmatrix-method'></span><span id='topic+coerce+2Ceulerzyx+2Crotmatrix-method'></span><span id='topic+coerce+2Cquaternion+2Crotmatrix-method'></span><span id='topic+coerce+2Cskewvector+2Cquaternion-method'></span><span id='topic+coerce+2Cskewvector+2Crotmatrix-method'></span><span id='topic+coerce+2Cskewmatrix+2Cskewvector-method'></span><span id='topic+coerce+2Cskewmatrix+2Crotmatrix-method'></span><span id='topic+coerce+2Ceulerzxz+2Crotmatrix-method'></span>

<h3>Description</h3>

<p> Coercion methods are provided between all types of <code>orientation</code>
objects, and from matrices to the orientation classes.</p>

<hr>
<h2 id='eulerzxz'> Create an orientation using Euler angles </h2><span id='topic+eulerzxz'></span><span id='topic+eulerzxz+2Corientation+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Creates an <code><a href="#topic+eulerzxz-class">eulerzxz-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eulerzxz(phi, theta, psi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eulerzxz_+3A_phi">phi</code></td>
<td>
<p> Rotation about Z axis </p>
</td></tr>
<tr><td><code id="eulerzxz_+3A_theta">theta</code></td>
<td>
<p> Rotation about X axis </p>
</td></tr>
<tr><td><code id="eulerzxz_+3A_psi">psi</code></td>
<td>
<p> Further rotation about Z axis </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rotations are expressed in radians and applied in the order Z, X, Z.
</p>
<p>If <code>theta</code> and <code>psi</code> are missing, <code>phi</code> is taken to be an n x 3 matrix
(or 3 element vector) holding all 3 Euler angles; alternatively, it may be an orientation object.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+eulerzxz-class">eulerzxz-class</a></code> object.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p><code><a href="#topic+eulerzxz-class">eulerzxz-class</a></code>, <code><a href="#topic+eulerzyx-class">eulerzyx-class</a></code>, <code><a href="#topic+rotmatrix">rotmatrix</a></code>, <code><a href="#topic+rotvector">rotvector</a></code>, <code><a href="#topic+quaternion">quaternion</a></code>,
<code><a href="#topic+skewvector">skewvector</a></code>, <code><a href="#topic+skewmatrix">skewmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- eulerzxz(c(1,0,0), c(0,1,0), c(0,0,1))
x
rotmatrix(x)
</code></pre>

<hr>
<h2 id='eulerzyx'> Create an orientation using Euler angles </h2><span id='topic+eulerzyx'></span><span id='topic+eulerzyx+2Corientation+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Creates an <code><a href="#topic+eulerzyx-class">eulerzyx-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eulerzyx(psi, theta, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eulerzyx_+3A_psi">psi</code></td>
<td>
<p> Rotation about Z axis </p>
</td></tr>
<tr><td><code id="eulerzyx_+3A_theta">theta</code></td>
<td>
<p> Rotation about Y axis </p>
</td></tr>
<tr><td><code id="eulerzyx_+3A_phi">phi</code></td>
<td>
<p> Rotation about X axis </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rotations are expressed in radians and applied in the order Z, Y, X.
</p>
<p>If <code>theta</code> and <code>phi</code> are missing, <code>psi</code> is taken to be an n x 3 matrix
(or 3 element vector) holding all 3 Euler angles; alternatively, any orientation object
may be used.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+eulerzyx-class">eulerzyx-class</a></code> object.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p><code><a href="#topic+eulerzyx-class">eulerzyx-class</a></code>, <code><a href="#topic+rotmatrix">rotmatrix</a></code>, <code><a href="#topic+rotvector">rotvector</a></code>, <code><a href="#topic+quaternion">quaternion</a></code>,
<code><a href="#topic+skewvector">skewvector</a></code>, <code><a href="#topic+skewmatrix">skewmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- eulerzyx(c(1,0,0), c(0,1,0), c(0,0,1))
x
rotmatrix(x)
</code></pre>

<hr>
<h2 id='index-methods'> Methods for indexing orientations </h2><span id='topic++5B+2Crotmatrix-method'></span><span id='topic++5B+2Crotvector-method'></span><span id='topic++5B+2Ceulerzyx-method'></span><span id='topic++5B+2Cquaternion-method'></span><span id='topic++5B+2Cskewvector-method'></span><span id='topic++5B+2Cskewmatrix-method'></span><span id='topic++5B+2Ceulerzxz-method'></span><span id='topic++5B+5B+2Crotmatrix-method'></span><span id='topic++5B+5B+2Crotvector-method'></span><span id='topic++5B+5B+2Ceulerzyx-method'></span><span id='topic++5B+5B+2Cquaternion-method'></span><span id='topic++5B+5B+2Cskewvector-method'></span><span id='topic++5B+5B+2Cskewmatrix-method'></span><span id='topic++5B+5B+2Ceulerzxz-method'></span><span id='topic++5B+5B+3C-+2Crotmatrix-method'></span><span id='topic++5B+5B+3C-+2Crotvector-method'></span><span id='topic++5B+5B+3C-+2Ceulerzyx-method'></span><span id='topic++5B+5B+3C-+2Cquaternion-method'></span><span id='topic++5B+5B+3C-+2Cskewvector-method'></span><span id='topic++5B+5B+3C-+2Cskewmatrix-method'></span><span id='topic++5B+5B+3C-+2Ceulerzxz-method'></span><span id='topic++5B+3C-+2Crotmatrix-method'></span><span id='topic++5B+3C-+2Crotvector-method'></span><span id='topic++5B+3C-+2Ceulerzyx-method'></span><span id='topic++5B+3C-+2Cquaternion-method'></span><span id='topic++5B+3C-+2Cskewvector-method'></span><span id='topic++5B+3C-+2Cskewmatrix-method'></span><span id='topic++5B+3C-+2Ceulerzxz-method'></span>

<h3>Description</h3>

<p> Methods are defined for indexing all types of orientations. </p>


<h3>Details</h3>

<p>Single bracket indexing (e.g. <code>x[1:3]</code>) creates a new
orientation object of the same class as the original by selecting the
appropriate entries.  Double bracket indexing (e.g. <code>x[[3]]</code>) extracts
the chosen data as a matrix or vector, depending on the class of the orientation. </p>

<hr>
<h2 id='length-methods'> Length of orientation object </h2><span id='topic+length+2Crotmatrix-method'></span><span id='topic+length+2Crotvector-method'></span><span id='topic+length+2Ceulerzyx-method'></span><span id='topic+length+2Cquaternion-method'></span><span id='topic+length+2Cskewvector-method'></span><span id='topic+length+2Cskewmatrix-method'></span><span id='topic+length+2Ceulerzxz-method'></span>

<h3>Description</h3>

<p> The generic <code>length()</code> function has methods
for <code>orientations</code>; it counts the number of orientations in the
object.  </p>

<hr>
<h2 id='matrix-classes'>Matrix orientation classes </h2><span id='topic+matrix-classes'></span><span id='topic+rotmatrix-class'></span><span id='topic+skewmatrix-class'></span>

<h3>Description</h3>

<p> An orientation represented by 3 x 3 SO(3) matrices or 3 x 3 skew symmetric matrices </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code><a href="#topic+rotmatrix">rotmatrix</a>(x)</code> 
or <code><a href="#topic+skewmatrix">skewmatrix</a>(x)</code>.
The objects store the matrices in a 3 x 3 x n array.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>3 x 3 x n array holding the matrices. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"orientation"</code>, directly.
Class <code>"vector"</code>, by class &quot;orientation&quot;.
</p>


<h3>Methods</h3>


<dl>
<dt>[, [&lt;-</dt><dd><p>Extract or assign to subvector </p>
</dd>
<dt>[[, [[&lt;-</dt><dd><p>Extract or assign to an entry </p>
</dd>
<dt>length</dt><dd><p>The length of the <code>orientation</code> vector </p>
</dd>
<dt>coerce</dt><dd><p>Coerce methods are defined to convert all <code><a href="#topic+orientation">orientation</a></code> descendants
from one to another, and to coerce an appropriately shaped matrix or array to a <code>rotmatrix</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p><code><a href="#topic+orientation-class">orientation-class</a></code>, <code><a href="#topic+vector-classes">vector-classes</a></code>, <code><a href="#topic+rotmatrix">rotmatrix</a></code>, 
<code><a href="#topic+skewmatrix">skewmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rotmatrix(matrix(c(1,0,0, 0,1,0, 0,0,1), 3, 3))
x
skewmatrix(x)
</code></pre>

<hr>
<h2 id='matrix-methods'> Methods for matrix operations in &lsquo;orientlib&rsquo; </h2><span id='topic++25+2A+25+2Corientation+2Corientation-method'></span><span id='topic+t+2Corientation-method'></span><span id='topic++5E+2Corientation+2Cnumeric-method'></span>

<h3>Description</h3>

<p> Methods are defined for matrix multiplication <code>%*%</code>
transposition <code>t()</code>, and real powers <code>^</code>.  These operate on the orientations
term by term.</p>

<hr>
<h2 id='mean-methods'>Methods for calculating the mean</h2><span id='topic+mean-methods'></span><span id='topic+mean+2CANY-method'></span><span id='topic+mean+2Corientation-method'></span>

<h3>Description</h3>

<p>The mean function. </p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;ANY&quot;</dt><dd><p> the standard mean function </p>
</dd>
<dt>x = &quot;orientation&quot;</dt><dd><p> find the nearest SO(3) matrix to the mean <code><a href="#topic+rotmatrix-class">rotmatrix-class</a></code>
representation of the orientations </p>
</dd>
</dl>

<hr>
<h2 id='nearest'> Find nearest SO(3) or orthogonal matrix. </h2><span id='topic+nearest.SO3'></span><span id='topic+nearest.orthog'></span>

<h3>Description</h3>

<p>Converts arbitrary 3 x 3 matrices 
into the nearest SO(3) or orthogonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest.SO3(x)
nearest.orthog(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest_+3A_x">x</code></td>
<td>
<p> 3 x 3 matrices stored in a 3 x 3 x n array) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Stephens' (1979) algorithm to find the nearest (in entry-wise Euclidean sense)
SO(3) or orthogonal matrix to a given matrix.
</p>


<h3>Value</h3>

<p><code>nearest.SO3</code> produces an <code><a href="#topic+orientation-class">orientation-class</a></code> object holding the closest orientations.
</p>
<p><code>nearest.orthog</code> produces a 3 x 3 x n array of orthogonal matrices.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>References</h3>

<p> Stephens (1979).  Vector correlation.  <em>Biometrika</em> 66, 41-48.</p>


<h3>See Also</h3>

<p><code><a href="#topic+orientation-class">orientation-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(9), 3,3)
nearest.orthog(x)
nearest.SO3(x)
x &lt;- -x
nearest.orthog(x)
nearest.SO3(x)
</code></pre>

<hr>
<h2 id='orientation-class'>Class &quot;orientation&quot; </h2><span id='topic+orientation-class'></span><span id='topic+orientation'></span>

<h3>Description</h3>

<p>  Abstract class for vectors of various representations of SO(3) (orientation)
objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p>Methods are defined to coerce <code>orientation</code> objects to any
concrete descendant class.</p>
</dd>
<dt><code>%*%</code></dt><dd><p>Matrix multiplication acts on <code>orientation</code> objects 
component by component, producing compositions of the rotations.</p>
</dd>
<dt><code>^</code></dt><dd><p>An orientation is raised to a power by multiplying its component rotation angles
by that power.</p>
</dd>
<dt>t</dt><dd><p>The transpose of an <code>orientation</code> object is its 
component by component inverse.</p>
</dd>
<dt>mean</dt><dd><p>The mean of an <code>orientation</code> object is the nearest SO(3) matrix to 
the element-by-element mean of its 3 x 3 rotation matrix representation.</p>
</dd>
<dt>weighted.mean</dt><dd><p>The weighted mean, defined analogously to the <code>mean</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+matrix-classes">matrix-classes</a></code>, <code><a href="#topic+vector-classes">vector-classes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rotmatrix(diag(3))
x
rotvector(x)
eulerzyx(x)
eulerzxz(x)
quaternion(x)
</code></pre>

<hr>
<h2 id='orientlib'> Orientation Library </h2><span id='topic+orientlib'></span>

<h3>Description</h3>

<p>Representations, conversions and display of orientation data.
</p>


<h3>Details</h3>

<p>This package contains methods for working with orientation data, i.e.
data from SO(3).  The basic abstract class is the <code><a href="#topic+orientation">orientation</a></code>;
there are several concrete classes (<code><a href="#topic+rotmatrix">rotmatrix</a></code>, 
<code><a href="#topic+rotvector">rotvector</a></code>, <code><a href="#topic+eulerzyx">eulerzyx</a></code>, <code><a href="#topic+eulerzxz">eulerzxz</a></code>, 
<code><a href="#topic+quaternion">quaternion</a></code>, <code><a href="#topic+skewmatrix">skewmatrix</a></code> and <code><a href="#topic+skewvector">skewvector</a></code>) 
storing different 
representations of orientations.
</p>
<p>Methods are defined to get the length of a vector of orientations, as well
as to extract and replace elements, and to multiply orientations and raise 
them to real powers.
</p>
<p>There are also utility functions <code><a href="#topic+rotation.distance">rotation.distance</a></code>,
<code><a href="#topic+rotation.angle">rotation.angle</a></code>, <code><a href="#topic+nearest.orthog">nearest.orthog</a></code>, 
<code><a href="#topic+nearest.SO3">nearest.SO3</a></code>.
</p>
<p>There is a plotting method <code><a href="#topic+boat3d">boat3d</a></code> to display orientation data
in a 3D plot, and a linear modelling function <code><a href="#topic+orientlm">orientlm</a></code>.
</p>


<h3>Note</h3>

<p> Plots require either the <code><a href="rgl.html#topic+rgl-package">rgl</a></code>
or <code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code> package. </p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>

<hr>
<h2 id='orientlm'> Linear models for orientation data </h2><span id='topic+orientlm'></span>

<h3>Description</h3>

<p>Regression models for matched pairs of orientations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orientlm(observed, leftformula, trueorient = rotmatrix(diag(3)), 
         rightformula, data = list(), subset, weights, na.action, 
         iterations = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orientlm_+3A_observed">observed</code></td>
<td>
<p> Observed orientations </p>
</td></tr>
<tr><td><code id="orientlm_+3A_leftformula">leftformula</code></td>
<td>
<p> Formula for &ldquo;left&rdquo; model (see below) </p>
</td></tr>
<tr><td><code id="orientlm_+3A_trueorient">trueorient</code></td>
<td>
<p> &ldquo;True&rdquo; orientation (see below) </p>
</td></tr>
<tr><td><code id="orientlm_+3A_rightformula">rightformula</code></td>
<td>
<p> Formula for &ldquo;right&rdquo; model (see below) </p>
</td></tr>
<tr><td><code id="orientlm_+3A_data">data</code></td>
<td>
<p> Optional data frame for predictors in linear model </p>
</td></tr>
<tr><td><code id="orientlm_+3A_subset">subset</code></td>
<td>
<p> Optional logical vector indicating subset of data </p>
</td></tr>
<tr><td><code id="orientlm_+3A_weights">weights</code></td>
<td>
<p> Optional weights </p>
</td></tr>
<tr><td><code id="orientlm_+3A_na.action">na.action</code></td>
<td>
<p> Optional NA function for predictors </p>
</td></tr>
<tr><td><code id="orientlm_+3A_iterations">iterations</code></td>
<td>
<p> How many iterations to use.  Ignored unless both 
<code>leftformula</code> and <code>rightformula</code> are specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Prentice (1989) model for matched pairs of orientations was
</p>
<p style="text-align: center;"><code class="reqn">E(V_i) = k A_1^t U_i A_2</code>
</p>

<p>where <code class="reqn">V_i</code> is the observed orientation, <code class="reqn">A_1</code> and <code class="reqn">A_2</code> are orientation matrices,
and <code class="reqn">U_i</code> is the &ldquo;true&rdquo; orientation, and <code class="reqn">k</code> is a constant.  It was assumed that
errors were symmetrically distributed about the identity matrix.
</p>
<p>This function generalizes this model, allowing <code class="reqn">A_1</code> and <code class="reqn">A_2</code> to depend on
regressor variables through <code>leftformula</code> and <code>rightformula</code> respectively.  
These formulas should include the predictor variables (right hand side) only, e.g. use
<code>~ x + y + z</code> rather than <code>response ~ x + y + z</code>.  Specify the response using
the <code>observed</code> argument.  If 
both formulas are <code>~ 1</code>, i.e. intercepts only, then Prentice's original model is 
recovered.  More general models are fit by coordinatewise linear regression in the <code><a href="#topic+rotmatrix">rotmatrix</a></code>
representation of the orientation, with fitted values projected onto SO(3) using the 
<code><a href="#topic+nearest.SO3">nearest.SO3</a></code> function.
</p>
<p>When both left and right models are given, Prentice's iterative approach is used with
a fixed number of iterations.  Note that
Shin (1999) found that Prentice's scheme sometimes fails to find the 
global minimum; this function presumably suffers from the same failing.
</p>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>
<table>
<tr><td><code>leftfit</code></td>
<td>
<p>Result of <code><a href="stats.html#topic+lm">lm</a></code> call based on <code>leftformula</code></p>
</td></tr>
<tr><td><code>rightfit</code></td>
<td>
<p>Result of <code><a href="stats.html#topic+lm">lm</a></code> call based on <code>rightformula</code></p>
</td></tr>
<tr><td><code>A1</code></td>
<td>
<p>Fitted values of <code class="reqn">A_1</code> for each observation</p>
</td></tr>
<tr><td><code>A2</code></td>
<td>
<p>Fitted values of <code class="reqn">A_2</code> for each observation</p>
</td></tr>
<tr><td><code>predict</code></td>
<td>
<p>Fitted values of <code class="reqn">A_1^t U_i A_2</code> for each observation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>References</h3>

 
<p>Prentice, M.J. (1989).  Spherical regression on matched pairs of orientation statistics.
JRSS B 51, 241-248.
</p>
<p>Shin, H.S.H. (1999).  Experimental Design for Orientation Models.  PhD thesis, Queen's University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep(1:10,10)
y &lt;- rep(1:10,each=10)
A1 &lt;- skewvector(cbind(x/10,y/10,rep(0,100)))
A2 &lt;- skewvector(c(1,1,1))
trueorientation &lt;- skewvector(matrix(rnorm(300),100))
noise &lt;- skewvector(matrix(rnorm(300)/10,100))
obs &lt;- t(A1) %*% trueorientation %*% A2 %*% noise

fit &lt;- orientlm(obs, ~ x + y, trueorientation, ~ 1)

context &lt;- boat3d(A1, x, z=y, col = 'green', graphics='scatterplot3d')
boat3d(fit$A1, x, z=y, add=context)
</code></pre>

<hr>
<h2 id='quaternion'> Create an orientation using quaternions </h2><span id='topic+quaternion'></span><span id='topic+quaternion+2Corientation-method'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+quaternion-class">quaternion-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quaternion(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quaternion_+3A_m">m</code></td>
<td>
<p> n x 4 matrix or 4 element vector containing a unit quaternion, or an orientation object </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rows of <code>m</code> are 4 element unit vectors interpreted as 
follows:  the first 3 <code>(x,y,z)</code> define the axis of rotation,
and the last element gives the cosine of half the angle of
rotation in a counter-clockwise direction when looking down the 
axis towards the origin.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+quaternion-class">quaternion-class</a></code> object.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p><code><a href="#topic+quaternion-class">quaternion-class</a></code>, <code><a href="#topic+rotmatrix">rotmatrix</a></code>, <code><a href="#topic+rotvector">rotvector</a></code>, <code><a href="#topic+eulerzyx">eulerzyx</a></code>,
<code><a href="#topic+eulerzxz">eulerzxz</a></code>, <code><a href="#topic+skewvector">skewvector</a></code>, <code><a href="#topic+skewmatrix">skewmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- quaternion(c(1,0,0,0))
x
rotmatrix(x)
</code></pre>

<hr>
<h2 id='rotation.distance'> Rotation angle or distance </h2><span id='topic+rotation.distance'></span><span id='topic+rotation.angle'></span>

<h3>Description</h3>

<p>Calculates the angle (in radians) of the rotation taking one orientation to
another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation.angle(x)
rotation.distance(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotation.distance_+3A_x">x</code>, <code id="rotation.distance_+3A_y">y</code></td>
<td>
<p> Two orientation objects </p>
</td></tr>
</table>


<h3>Details</h3>

<p> If <code>y</code> is missing in a call to <code>rotation.distance</code>, 
it is treated as the identity, i.e.
<code><a href="#topic+rotation.angle">rotation.angle</a>(x)</code> is calculated.</p>


<h3>Value</h3>

<p><code>rotation.distance</code> returns a vector of length <code>max(length(x), length(y))</code> 
containing the
angle of the rotation taking corresponding elements of <code>x</code> to <code>y</code> (with the
usual recycling rules if they are different lengths). 
</p>
<p><code>rotation.angle</code> is equivalent to calculating the <code>rotation.distance</code> to the
identity matrix.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

 <p><code><a href="#topic+orientation-class">orientation-class</a></code>, <code><a href="#topic+rotation.angle">rotation.angle</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rotation.angle(eulerzyx(1,0,0))
rotation.distance(eulerzyx(1,0,0), eulerzyx(0,1,0))

</code></pre>

<hr>
<h2 id='rotmatrix'> Create an orientation using Euler angles </h2><span id='topic+rotmatrix'></span><span id='topic+rotmatrix+2Corientation-method'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+rotmatrix-class">rotmatrix-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotmatrix(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotmatrix_+3A_a">a</code></td>
<td>
<p> A 3 x 3 matrix or 3 x 3 x n array of matrices or an orientation object. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+rotmatrix-class">rotmatrix-class</a></code> object.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p><code><a href="#topic+rotmatrix-class">rotmatrix-class</a></code>,  <code><a href="#topic+rotvector">rotvector</a></code>, <code><a href="#topic+eulerzyx">eulerzyx</a></code>, 
<code><a href="#topic+eulerzxz">eulerzxz</a></code>, <code><a href="#topic+quaternion">quaternion</a></code>, <code><a href="#topic+skewvector">skewvector</a></code>, <code><a href="#topic+skewmatrix">skewmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rotmatrix(matrix(c(1,0,0, 0,1,0, 0,0,1), 3, 3))
x
</code></pre>

<hr>
<h2 id='rotvector'> Create an orientation using vectorized 3x3 matrices </h2><span id='topic+rotvector'></span><span id='topic+rotvector+2Corientation-method'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+rotvector-class">rotvector-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotvector(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotvector_+3A_m">m</code></td>
<td>
<p> n x 9 matrix or 9 element vector whose rows are vectorized 3x3 matrices, or an orientation object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a matrix whose rows are vectorized 3x3 matrices (in column-major form)
into an <code><a href="#topic+rotvector-class">rotvector-class</a></code> object.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+rotvector-class">rotvector-class</a></code> object.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p><code><a href="#topic+rotvector-class">rotvector-class</a></code>, <code><a href="#topic+rotmatrix">rotmatrix</a></code>,  <code><a href="#topic+eulerzyx">eulerzyx</a></code>,
<code><a href="#topic+eulerzxz">eulerzxz</a></code>, <code><a href="#topic+quaternion">quaternion</a></code>, <code><a href="#topic+skewvector">skewvector</a></code>, <code><a href="#topic+skewmatrix">skewmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rotvector(c(0,1,0,-1,0,0,0,0,1))
x
rotmatrix(x)
</code></pre>

<hr>
<h2 id='skewmatrix'> Create an orientation using the entries in a skew-symmetric matrix representation </h2><span id='topic+skewmatrix'></span><span id='topic+skewmatrix+2Corientation-method'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+skewmatrix-class">skewmatrix-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewmatrix(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewmatrix_+3A_a">a</code></td>
<td>
<p> 3 x 3 x n array or 3 x 3 matrix containing the entries of a skew-symmetric matrix,
or an orientation object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The entries <code>a[,,i]</code> are 3 x 3 skew-symmetric matrices.  
The matrix exponential of these give SO(3) matrices.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+skewmatrix-class">skewmatrix-class</a></code> object.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p><code><a href="#topic+skewvector-class">skewvector-class</a></code>, <code><a href="#topic+skewvector">skewvector</a></code>, <code><a href="#topic+rotmatrix">rotmatrix</a></code>, <code><a href="#topic+rotvector">rotvector</a></code>, <code><a href="#topic+eulerzyx">eulerzyx</a></code>,
<code><a href="#topic+eulerzxz">eulerzxz</a></code>, <code><a href="#topic+quaternion">quaternion</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- skewmatrix(matrix(c(0,1,2,-1,0,3,-2,-3,0),3,3))
x
rotmatrix(x)
skewvector(x)
rotation.angle(x)
</code></pre>

<hr>
<h2 id='skewvector'> Create an orientation using the entries in a skew-symmetric matrix representation </h2><span id='topic+skewvector'></span><span id='topic+skewvector+2Corientation-method'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+skewvector-class">skewvector-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewvector(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewvector_+3A_m">m</code></td>
<td>
<p> n x 3 matrix or 3 element vector containing a the entries of a skew-symmetric matrix,
or an orientation object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rows of <code>m</code> are 3 element vectors (x,y,z) interpreted as 
follows:  the matrix exponential of the matrix <code>((0, -z, y), (z, 0, -x), (-y, x, 0))</code>
is the SO(3) matrix.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+skewvector-class">skewvector-class</a></code> object.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p><code><a href="#topic+skewvector-class">skewvector-class</a></code>, <code><a href="#topic+skewmatrix">skewmatrix</a></code>, <code><a href="#topic+rotmatrix">rotmatrix</a></code>, <code><a href="#topic+rotvector">rotvector</a></code>, <code><a href="#topic+eulerzyx">eulerzyx</a></code>,
<code><a href="#topic+eulerzxz">eulerzxz</a></code>, <code><a href="#topic+quaternion">quaternion</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- skewvector(c(1,0,0))
x
rotmatrix(x)
rotation.angle(x)
</code></pre>

<hr>
<h2 id='vector-classes'>Orientation classes </h2><span id='topic+eulerzyx-class'></span><span id='topic+eulerzxz-class'></span><span id='topic+rotvector-class'></span><span id='topic+quaternion-class'></span><span id='topic+skewvector-class'></span><span id='topic+vector-classes'></span>

<h3>Description</h3>

<p> An vector of orientations, each represented by a vector of numbers.
Each of these types stores orientations as rows of a matrix in slot <code>x</code>.
</p>
<p>The <code>eulerzyx</code> class uses 3 Euler angles in the roll-pitch-yaw scheme
(rotation about Z axis, then Y axis, then X axis).
</p>
<p>The <code>eulerzxz</code> class uses 3 Euler angles in the X system scheme
(rotation about Z axis, then X axis, then Z axis again).
</p>
<p>The <code>rotvector</code> class uses the 9 components of a 3 x 3 rotation matrix, stored
in column-major order.
</p>
<p>The <code>quaternion</code> class uses the 4 components of a unit quaternion.
</p>
<p>The <code>skewvector</code> class uses the 3 non-zero components of a skew-symmetric matrix,
where <code>(x,y,z)</code> stores the matrix  <code>((0, -z, y), (z, 0, -x), (-y, x, 0))</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects of each class can be created by calls to the corresponding constructor
functions:  <code><a href="#topic+eulerzyx">eulerzyx</a></code>, <code><a href="#topic+eulerzxz">eulerzxz</a></code>, <code><a href="#topic+rotvector">rotvector</a></code>,
<code><a href="#topic+quaternion">quaternion</a></code>, <code><a href="#topic+skewmatrix">skewmatrix</a></code> and <code><a href="#topic+skewvector">skewvector</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>An n x m <code>matrix</code> object holding the vector representations, where
m is 3, 4, or 9. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"orientation"</code>, directly.
Class <code>"vector"</code>, by class &quot;orientation&quot;.
</p>


<h3>Methods</h3>


<dl>
<dt>[, [&lt;-</dt><dd><p>Extract or assign to subvector </p>
</dd>
<dt>[[, [[&lt;-</dt><dd><p>Extract or assign to an entry </p>
</dd>
<dt>length</dt><dd><p>The length of the <code>orientation</code> vector </p>
</dd>
<dt>coerce</dt><dd><p>Coerce methods are defined to convert all <code><a href="#topic+orientation">orientation</a></code> descendants
from one to another, and to coerce an appropriately shaped matrix or array to a <code>rotmatrix</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>See Also</h3>

<p>Constructor and coercion functions <code><a href="#topic+rotmatrix">rotmatrix</a></code>, <code><a href="#topic+eulerzyx">eulerzyx</a></code>, <code><a href="#topic+eulerzxz">eulerzxz</a></code>, <code><a href="#topic+rotvector">rotvector</a></code>,
<code><a href="#topic+quaternion">quaternion</a></code>, and <code><a href="#topic+skewvector">skewvector</a></code>. 
</p>
<p>Classes <code><a href="#topic+matrix-classes">matrix-classes</a></code>, <code><a href="#topic+orientation-class">orientation-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- eulerzyx(0,pi/4,0)
x
eulerzxz(x)
rotmatrix(x)
rotvector(x)
quaternion(x)
skewvector(x)
</code></pre>

<hr>
<h2 id='weighted.mean-methods'> Weighted mean method </h2><span id='topic+weighted.mean-methods'></span><span id='topic+weighted.mean+2CANY+2CANY-method'></span><span id='topic+weighted.mean+2Corientation+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The weighted mean function. </p>


<h3>Details</h3>

<p>The weighted mean for orientations is the nearest SO(3) matrix to the entrywise weighted mean
of the <code><a href="#topic+rotmatrix-class">rotmatrix-class</a></code> matrices.
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;ANY&quot;, w = &quot;ANY&quot;</dt><dd><p> the standard <code>stats::<a href="stats.html#topic+weighted.mean">weighted.mean</a></code> </p>
</dd>
<dt>x = &quot;orientation&quot;, w = &quot;numeric&quot;</dt><dd><p> weighted mean for orientations </p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
