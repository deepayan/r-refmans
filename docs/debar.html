<!DOCTYPE html><html><head><title>Help for package debar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {debar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aa_check'><p>Translate the sequence and it for stop codons</p></a></li>
<li><a href='#adj_seq'><p>Adjust the DNA sequence based on the ntPHMM path</p></a></li>
<li><a href='#adjust'><p>Adjust the sequences based on the nt path outputs.</p></a></li>
<li><a href='#censored_translation'><p>Censored Translation of a DNA string.</p></a></li>
<li><a href='#col_mode'><p>Determining the most common character in each column.</p></a></li>
<li><a href='#consensus'><p>Take the list of denoised sequences and obtain the consensus sequence.</p></a></li>
<li><a href='#debar'><p><span class="pkg">debar</span></p></a></li>
<li><a href='#denoise'><p>Run the denoiser pipeline for a sequence read.</p></a></li>
<li><a href='#denoise_file'><p>Denoise sequence data from a given file.</p></a></li>
<li><a href='#denoise_list'><p>List-to-list denoising of COI barcode sequences.</p></a></li>
<li><a href='#dir_check'><p>Take an input sequence and align both the forward and reverse compliments to the PHMM</p></a></li>
<li><a href='#DNAseq'><p>Build a DNAseq object from a DNA sequence string.</p></a></li>
<li><a href='#ex_nt_list'><p>An example of a list of four coi5p sequences, each containing indel errors.</p></a></li>
<li><a href='#example_nt_string'><p>Example coi5p DNA sequence string.</p></a></li>
<li><a href='#example_nt_string_errors'><p>Example coi5p DNA sequence string with insertion and deletion errors.</p></a></li>
<li><a href='#frame'><p>Take a DNAseq object and isolate the COI-5P region.</p></a></li>
<li><a href='#individual_DNAbin'><p>build an DNAbin with ape.</p></a></li>
<li><a href='#ins_front_trim'><p>check sequence for an early large string of deletions, if it exists then</p>
return the starting index by which to slice the path and the string</a></li>
<li><a href='#leading_ins'><p>Check for a large number of leading inserted bases,</p>
if this is the case, TRUE is returned and the PHMM
should be run a second time on the truncated data.</a></li>
<li><a href='#meta_check'><p>Run the log file and reject processing code after running the denoise pipeline.</p></a></li>
<li><a href='#new_DNAseq'><p>Build a new DNAseq class instance.</p></a></li>
<li><a href='#nt_PHMM'><p>Nucleotide profile hidden markov model for debar.</p></a></li>
<li><a href='#outseq'><p>Get the final denoised output sequence for a read.</p></a></li>
<li><a href='#print.DNAseq'><p>Print a concise summary of the DNAseq object</p></a></li>
<li><a href='#read_fasta'><p>Read in raw data from a fasta file.</p></a></li>
<li><a href='#read_fastq'><p>Read in raw data from a fastq file.</p></a></li>
<li><a href='#rev_comp'><p>Return the reverse compliment for a DNA sequence</p></a></li>
<li><a href='#set_frame'><p>Take an input sequence and get it into the reading frame.</p>
Uses the path of the sequence through the PHMM to located
the first long contigious stretch of 1s (matches)
Note - there is an imbalance in operation, namely the function
checks for a run of 10 additional 1s on the front of the sequence, and for
a run of only 3 additional matches on the back. The front of the sequence is high
priority because it is necessary to ensure the sequence is in frame.
whereas matching on the back is more lenient as insertions and deletions
can be tolerated here without large implications for the rest of the sequence</a></li>
<li><a href='#translate_codon'><p>Censored Translation of a codon.</p></a></li>
<li><a href='#triple_dels'><p>Look for triple deletes in the PHMM path.</p></a></li>
<li><a href='#triple_ins'><p>Look for triple inserts in the PHMM path.</p></a></li>
<li><a href='#validate_DNAseq'><p>Validate the new DNAseq class instance.</p></a></li>
<li><a href='#write_fasta'><p>Output the denoised consensus sequence to a fasta file.</p></a></li>
<li><a href='#write_fastq'><p>Output the denoised sequence to a fastq format with placeholder phred scores.</p></a></li>
<li><a href='#write_wrapper'><p>A wrapper function to deploy the fastq and fata output functions.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Post-Clustering Denoiser for COI-5P Barcode Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Cameron M. Nugent</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cameron M. Nugent &lt;camnugent@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'debar' sequence processing pipeline is designed for denoising high throughput 
    sequencing data for the animal DNA barcode marker cytochrome c oxidase I (COI). The package 
    is designed to detect and correct insertion and deletion errors within sequencer outputs. 
    This is accomplished through comparison of input sequences against a profile hidden Markov 
    model (PHMM) using the Viterbi algorithm (for algorithm details see Durbin et al. 1998, 
    ISBN: 9780521629713). Inserted base pairs are removed and deleted base pairs are accounted 
    for through the introduction of a placeholder character. Since the PHMM is a probabilistic 
    representation of the COI barcode, corrections are not always perfect. For this reason 
    'debar' censors base pairs adjacent to reported indel sites, turning them into placeholder 
    characters (default is 7 base pairs in either direction, this feature can be disabled).
    Testing has shown that this censorship results in the correct sequence length being restored, 
    and erroneous base pairs being masked the vast majority of the time (&gt;95%). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, aphid, seqinr, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-12 10:56:29 UTC; cnuge</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-12 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aa_check'>Translate the sequence and it for stop codons</h2><span id='topic+aa_check'></span><span id='topic+aa_check.DNAseq'></span>

<h3>Description</h3>

<p>A side product of the framing and adjustment functions is that the reading frame of the sequence is established
and translation can be conducted with high confidence. If the adjustment did in fact correct indel errors, the
translated sequence should feature no stop codons. If stop codons are present this is grounds for rejection as 
indel errors (or some other large issue) persists in the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa_check(x, ...)

## S3 method for class 'DNAseq'
aa_check(x, ..., trans_table = 0, frame_offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa_check_+3A_x">x</code></td>
<td>
<p>a ccs_reads class object.</p>
</td></tr>
<tr><td><code id="aa_check_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="aa_check_+3A_trans_table">trans_table</code></td>
<td>
<p>The translation table to use for translating from nucleotides to amino acids. Default is &quot;auto&quot;, meaning
that the translation table will be inferred from the ccs_reads object's order.</p>
</td></tr>
<tr><td><code id="aa_check_+3A_frame_offset">frame_offset</code></td>
<td>
<p>The offset to the reading frame to be applied for translation. By default the offset
is zero, so the first character in the framed sequence is considered the first nucelotide of the first codon.
Passing frame_offset = 1 would offset the sequence by one and therefore make the second character in the
framed sequence the the first nucelotide of the first codon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test has limitations, as any indels late in the DNA sequence may not lead to stop codons existing. Additionally
by default censored translation is used by this function when producing the amino acid sequence, so as to 
eliminate taxonomic bias against organisms with esoteric translation tables. The likelihood of catching errors is
increased if the genetic code corresponding to sequences is known.
</p>


<h3>Value</h3>

<p>a class object of code ccs_reads 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAseq">DNAseq</a></code>
</p>
<p><code><a href="#topic+frame">frame</a></code>
</p>
<p><code><a href="#topic+adjust">adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#previously called
ex_data = DNAseq(example_nt_string, name = 'ex1')
ex_data =  frame(ex_data)
ex_data = adjust(ex_data)
#run the aa check on the adjusted sequences
ex_data = aa_check(ex_data)
ex_data$aaSeq #view the amino acid sequence
ex_data$stop_codons # Boolean indicating if stop codons in the amino acid sequence

</code></pre>

<hr>
<h2 id='adj_seq'>Adjust the DNA sequence based on the ntPHMM path</h2><span id='topic+adj_seq'></span>

<h3>Description</h3>

<p>Adjust the DNA sequence based on the ntPHMM path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_seq(frame_dat, path_out, censor_length = 3, added_phred = "*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_seq_+3A_frame_dat">frame_dat</code></td>
<td>
<p>The DNAseq's framing data - generated by set_frame()</p>
</td></tr>
<tr><td><code id="adj_seq_+3A_path_out">path_out</code></td>
<td>
<p>The nucleotide PHMM path for the sequence.</p>
</td></tr>
<tr><td><code id="adj_seq_+3A_censor_length">censor_length</code></td>
<td>
<p>number of base pairs in either direction of a PHMM correction
to convert to placeholder characters.</p>
</td></tr>
<tr><td><code id="adj_seq_+3A_added_phred">added_phred</code></td>
<td>
<p>The phred character to use for characters inserted into the original sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list.
</p>

<hr>
<h2 id='adjust'>Adjust the sequences based on the nt path outputs.</h2><span id='topic+adjust'></span><span id='topic+adjust.DNAseq'></span>

<h3>Description</h3>

<p>Based on the PHMM path generated by the frame function, the sequence is the adjusted. Adjustments are limited
to the 657bp region represeneted by the PHMM (and the part of the input sequence matching this region). Censorship
can be applied around the corrections. This limits the number of indel errors missed by the PHMM correction algorithm,
but comes at a cost of lost DNA sequence. The default of 7 is a conservative paramater meant to lead to the coverage of
greater than 95
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust(x, ...)

## S3 method for class 'DNAseq'
adjust(x, ..., censor_length = 7, added_phred = "*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust_+3A_x">x</code></td>
<td>
<p>a DNAseq class object.</p>
</td></tr>
<tr><td><code id="adjust_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="adjust_+3A_censor_length">censor_length</code></td>
<td>
<p>the number of base pairs in either direction of a PHMM correction
to convert to placeholder characters. Default is 7.</p>
</td></tr>
<tr><td><code id="adjust_+3A_added_phred">added_phred</code></td>
<td>
<p>The phred character to use for characters inserted into the original sequence. Default is &quot;*&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the DNAseq object contains PHRED scores, the PHRED string will be adjusted along with the DNA sequence (corresponding)
value removed when a bp removed. The 'added_phred' value indicated the phred chracter to be added to the string when a 
placeholder nucleotide is added to the string to account for a deletion. Default is &quot;*&quot; which indicates a score of 9 (a 
relitavely low quality base).
</p>


<h3>Value</h3>

<p>a class object of code &quot;ccs_reads&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAseq">DNAseq</a></code>
</p>
<p><code><a href="#topic+frame">frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#previously called
ex_data = DNAseq(example_nt_string_errors, name = 'error_adj_example')
ex_data =  frame(ex_data)
#adjust the sequence with default censor length is 7
ex_data = adjust(ex_data)
ex_data$adjusted_sequence #output is a vector, use outseq to build the string
#with a custom censorship size
ex_data = adjust(ex_data, censor_length = 5)
ex_data$adjusted_sequence #less flanking base pairs turned to placeholders
ex_data$adjustment_count #get a count of the number of adjustments applied
</code></pre>

<hr>
<h2 id='censored_translation'>Censored Translation of a DNA string.</h2><span id='topic+censored_translation'></span>

<h3>Description</h3>

<p>Translate a DNA sequence using the censored translation table,
this translates codons for which the amino acids is unambigious across
mitochondrial genetic codes across the animal kingdom and does not
translate those for which the amino acid varies,
but rather outputs a ? in the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>censored_translation(dna_str, reading_frame = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="censored_translation_+3A_dna_str">dna_str</code></td>
<td>
<p>The DNA string to be translated.</p>
</td></tr>
<tr><td><code id="censored_translation_+3A_reading_frame">reading_frame</code></td>
<td>
<p>reading frame = 1 means the first bp in the string is the start of the
first codon, can pass 1, 2 or 3. For 2 and 3 the first 1 and 2 bp will be
dropped from translation respectively.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+aa_check">aa_check</a></code>
</p>

<hr>
<h2 id='col_mode'>Determining the most common character in each column.</h2><span id='topic+col_mode'></span>

<h3>Description</h3>

<p>Determining the most common character in each column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_mode(col_data)
</code></pre>


<h3>Value</h3>

<p>A single character string.
</p>

<hr>
<h2 id='consensus'>Take the list of denoised sequences and obtain the consensus sequence.</h2><span id='topic+consensus'></span><span id='topic+consensus_sequence'></span>

<h3>Description</h3>

<p>Take the list of denoised sequences and obtain the consensus sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus_sequence(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus_+3A_x">x</code></td>
<td>
<p>The list of adjusted DNA sequences, post censorship and AA correction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the consensus nucleotide sequence.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoise_list">denoise_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#denoise list of sequences with the k
ex_out = denoise_list(ex_nt_list, keep_flanks=FALSE)

barcode_seq = consensus_sequence(ex_out)
</code></pre>

<hr>
<h2 id='debar'><span class="pkg">debar</span></h2><span id='topic+debar'></span><span id='topic+debar-package'></span>

<h3>Description</h3>

<p><span class="pkg">debar</span> is an R package designed for the identification and removal 
of insertion and deletion errors from COI-5P DNA barcode data.
</p>


<h3>Details</h3>

<p><span class="pkg">debar</span> is built around the DNAseq object, which takes a COI-5P DNA barcode sequence
and optionally its associated name and PHRED quality information as input. The package utilizes
a nucleotide profile hidden Markov model (PHMM) for the identification of the COI-5P region of 
an input sequence and the identification and correction of indel errors from within the COI-5P 
region of the sequence. Indel corrections are by default applied in a conservative fashion, with subsequent
censorship of 7 base pairs in either direction of an indel correction to mask most instances where the exact
bp corresponding to the indel was not found exactly. Numerous filtering and double check steps are applied, and
the package includes functions for input/output for either fasta or fastq formats.
</p>
<p>The denoise pipeline is heavily paramaterized so that a user can tailor the denoising execution for their own 
data structure and goal.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code><a href="#topic+denoise_file">denoise_file</a></code> Run the denoise pipeline for each sequence in a specified input file.
</p>
</li>
<li> <p><code><a href="#topic+denoise">denoise</a></code> Run the denoise pipeline for a specified sequence
</p>
</li>
<li> <p><code><a href="#topic+read_fasta">read_fasta</a></code> Read data from a fasta file to a data frame.
</p>
</li>
<li> <p><code><a href="#topic+read_fastq">read_fastq</a></code> Read data from a fastq file to a data frame. 
</p>
</li>
<li> <p><code><a href="#topic+write_fasta">write_fasta</a></code> Write a denoised sequence to the specified fasta file.
</p>
</li>
<li> <p><code><a href="#topic+write_fastq">write_fastq</a></code> Write a denoised sequence and associated quality information to the specified fastq file.
</p>
</li>
<li> <p><code><a href="#topic+DNAseq">DNAseq</a></code> Builds a DNAseq class object
</p>
</li>
<li> <p><code><a href="#topic+frame">frame</a></code> Match a sequence against the COI-5P PHMM using the 
Viterbi algorithm to establish the reading frame,
optional rejection of sequence based on the quality of the match to the PHMM.
</p>
</li>
<li> <p><code><a href="#topic+adjust">adjust</a></code> Use the PHMM path output corresponding to the sequence to 
adjust the DNA sequence and remove indels.
Optional censorship of sequence around the corrections.
</p>
</li>
<li> <p><code><a href="#topic+aa_check">aa_check</a></code> Translate the adjusted sequence to amino acids and check it for stop codons.
</p>
</li>
<li> <p><code><a href="#topic+outseq">outseq</a></code> Construct the output data for the given sequence. 
Optionally can include or exculde sequence data from
outside of the COI-5P region (part of sequence that was not denoised).
</p>
</li></ul>



<h3>Data</h3>


<ul>
<li> <p><code><a href="#topic+example_nt_string">example_nt_string</a></code> An example COI-5P sequence with no errors.
</p>
</li>
<li> <p><code><a href="#topic+example_nt_string_errors">example_nt_string_errors</a></code> An example COI-5P sequence with two indel errors.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Cameron M. Nugent
</p>

<hr>
<h2 id='denoise'>Run the denoiser pipeline for a sequence read.</h2><span id='topic+denoise'></span><span id='topic+denoise.default'></span>

<h3>Description</h3>

<p>This function runs the complete denoising pipeline for a given input sequence and its corresponding
name and phred scores. The default behaviour is set to interface with fastq files (standard output for
most sequencers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoise(x, ...)

## Default S3 method:
denoise(x, ..., name = character(), phred = NULL,
  dir_check = TRUE, double_pass = TRUE, min_match = 100,
  max_inserts = 400, censor_length = 7, added_phred = "*",
  adjust_limit = 5, ambig_char = "N", to_file = FALSE,
  keep_flanks = TRUE, keep_phred = TRUE, outformat = "fastq",
  terminate_rejects = TRUE, outfile = NULL, phred_placeholder = "#",
  aa_check = TRUE, trans_table = 0, frame_offset = 0,
  append = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoise_+3A_x">x</code></td>
<td>
<p>a DNA sequence string.</p>
</td></tr>
<tr><td><code id="denoise_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="denoise_+3A_name">name</code></td>
<td>
<p>an optional character string. Identifier for the sequence.</p>
</td></tr>
<tr><td><code id="denoise_+3A_phred">phred</code></td>
<td>
<p>an optional character string. The phred score string corresponding to the nucleotide string.
If passed then the input phred scores will be modified along with the nucleotides and carried through
to the sequence output. Default = NULL.</p>
</td></tr>
<tr><td><code id="denoise_+3A_dir_check">dir_check</code></td>
<td>
<p>A boolean indicating if both the forward and reverse compliments of a sequence should 
be checked against the PHMM. Default is TRUE.</p>
</td></tr>
<tr><td><code id="denoise_+3A_double_pass">double_pass</code></td>
<td>
<p>A boolean indicating if a second pass through the Viterbi algorithm should be conducted for sequences
that had leading nucleotides not matching the PHMM. This improves the accurate establishment of reading frame and will
reduce false rejections by the amino acid check, but this comes at a cost of additional processing time. Default is TRUE.</p>
</td></tr>
<tr><td><code id="denoise_+3A_min_match">min_match</code></td>
<td>
<p>The minimum number of sequential matches to the PHMM for a sequence to be denoised.
Otherwise flag the sequence as a reject.</p>
</td></tr>
<tr><td><code id="denoise_+3A_max_inserts">max_inserts</code></td>
<td>
<p>The maximum number of sequention insert states occuring in a sequence 
(including the flanking regions). If this number is
exceeded than the entire read will be discarded if terminate_rejects = TRUE. Default is 400.</p>
</td></tr>
<tr><td><code id="denoise_+3A_censor_length">censor_length</code></td>
<td>
<p>the number of base pairs in either direction of a PHMM correction
to convert to placeholder characters. Default is 7.</p>
</td></tr>
<tr><td><code id="denoise_+3A_added_phred">added_phred</code></td>
<td>
<p>The phred character to use for characters inserted into the original sequence.</p>
</td></tr>
<tr><td><code id="denoise_+3A_adjust_limit">adjust_limit</code></td>
<td>
<p>the maximum number of corrections that can be applied to a sequence read. If this number is exceeded 
then the entire read is rejected. Default is 3.</p>
</td></tr>
<tr><td><code id="denoise_+3A_ambig_char">ambig_char</code></td>
<td>
<p>The character to use for ambigious positions in the sequence that is output to the file. Default is N.</p>
</td></tr>
<tr><td><code id="denoise_+3A_to_file">to_file</code></td>
<td>
<p>Boolean indicating whether the sequence should be written to a file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="denoise_+3A_keep_flanks">keep_flanks</code></td>
<td>
<p>Should the regions of the input sequence outside of the barcode region be readded to the denoised sequence
prior to outputting to the file. Options are TRUE, FALSE and 'right'. The 'right' option will keep the trailing flank
but remove the leading flank. Default is TRUE. 
False will lead to only the denoised sequence for the 657bp barcode region being output to the file.</p>
</td></tr>
<tr><td><code id="denoise_+3A_keep_phred">keep_phred</code></td>
<td>
<p>Should the original PHRED scores be kept in the output? Default is TRUE.</p>
</td></tr>
<tr><td><code id="denoise_+3A_outformat">outformat</code></td>
<td>
<p>The format of the output file. Options are fasta or fastq (default) format.</p>
</td></tr>
<tr><td><code id="denoise_+3A_terminate_rejects">terminate_rejects</code></td>
<td>
<p>Boolean indicating if analysis of sequences that fail to meet phred quality score or path 
match thresholds should be terminated early (prior to sequence adjustment and writing to file). Default it true.</p>
</td></tr>
<tr><td><code id="denoise_+3A_outfile">outfile</code></td>
<td>
<p>The name of the file to output the data to. Default filenames are respectively: denoised.fasta or denoised.fastq.</p>
</td></tr>
<tr><td><code id="denoise_+3A_phred_placeholder">phred_placeholder</code></td>
<td>
<p>The character to input for the phred score line. Default is '#'. 
Used with write_fastq and keep_phred == FALSE only.</p>
</td></tr>
<tr><td><code id="denoise_+3A_aa_check">aa_check</code></td>
<td>
<p>Boolean indicating whether the amino acid sequence should be generated and assessed for stop codons. Default = TRUE.</p>
</td></tr>
<tr><td><code id="denoise_+3A_trans_table">trans_table</code></td>
<td>
<p>The translation table to use for translating from nucleotides to amino acids. Default is 0, meaning
that censored translation is performed (amigious codons ignored). Used only when aa_check = TRUE.</p>
</td></tr>
<tr><td><code id="denoise_+3A_frame_offset">frame_offset</code></td>
<td>
<p>The offset to the reading frame to be applied for translation. By default the offset
is zero, so the first character in the framed sequence is considered the first nucelotide of the first codon.
Passing frame_offset = 1 would offset the sequence by one and therefore make the second character in the
framed sequence the the first nucelotide of the first codon. Used only when aa_check = TRUE.</p>
</td></tr>
<tr><td><code id="denoise_+3A_append">append</code></td>
<td>
<p>Should the denoised sequence be appended to the output file?(TRUE) 
Or should the sequence overwrite the output file?(FALSE) Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the pipeline is designed for recieving or outputting either fasta or fastq data, this function is 
hevaily paramaterized. Note that not all paramaters will affect all use cases (i.e. if your outformat is to 
a fasta file, then the phred_placeholder paramater is ignored
as this option only pertains to fastq outputs). The user is encouraged to read the vignette for a detailed 
walkthrough of the denoiser pipeline that will help identify the paramaters that relate to their given needs.
</p>


<h3>Value</h3>

<p>a class object of code &quot;DNAseq&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Denoise example sequence with default paramaters.
ex_data = denoise(example_nt_string_errors, 
                  name = 'example_sequence_1', 
                  keep_phred = FALSE, 
                  to_file = FALSE)

#fastq data from a file
#previously run
fastq_example_file = system.file('extdata/coi_sequel_data_subset.fastq', 
                                 package = 'debar')
data = read_fastq(fastq_example_file)
#denoise the first sequence in the file
#use a custom censor length and no amino acid check
dn_dat_1 = denoise(x = data$sequence[[1]], 
                    name = data$header[[1]], 
                    phred = data$quality[[1]], 
                    censor_length = 11, 
                    aa_check = FALSE, 
                    to_file = FALSE)
</code></pre>

<hr>
<h2 id='denoise_file'>Denoise sequence data from a given file.</h2><span id='topic+denoise_file'></span><span id='topic+denoise_file.default'></span>

<h3>Description</h3>

<p>This function allows for direct input to output exectution of the denoising pipeline. All paramaters for the 
fasta/fastq input and output functions as well as the denoise pipeline can be passed to this function. Please consult
the documentation for those functions for a list of available paramaters. The function will
run the denoise pipeline with the specified paramaters for all sequences in the input file, and write the denoised sequences
and corresponding header/quality information to the output file. Additionally the function allows for rejected reads to
be kept and sequestered to an additional output file (as opposed to being discarded) and also allows for a log file to
be produced that tracks several statistics including the execition time, number of denoised reads and number of
rejected reads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoise_file(x, ...)

## Default S3 method:
denoise_file(x, ..., outfile = "output.fastq",
  informat = "fastq", outformat = "fastq", to_file = TRUE,
  log_file = FALSE, keep_rejects = FALSE, multicore = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoise_file_+3A_x">x</code></td>
<td>
<p>The name of the file to denoise sequences from.</p>
</td></tr>
<tr><td><code id="denoise_file_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the <a href="#topic+denoise">denoise</a> and input/output functions.</p>
</td></tr>
<tr><td><code id="denoise_file_+3A_outfile">outfile</code></td>
<td>
<p>The name of the file to output sequences to.</p>
</td></tr>
<tr><td><code id="denoise_file_+3A_informat">informat</code></td>
<td>
<p>The format of the file to be denoised. Options are fastq or fasta. Default is fastq.</p>
</td></tr>
<tr><td><code id="denoise_file_+3A_outformat">outformat</code></td>
<td>
<p>The format of the output file. Options are fasta or fastq (default) format.</p>
</td></tr>
<tr><td><code id="denoise_file_+3A_to_file">to_file</code></td>
<td>
<p>Boolean indicating whether the sequence should be written to a file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="denoise_file_+3A_log_file">log_file</code></td>
<td>
<p>Boolean indicating if a log file should be produced. Default is FALSE.</p>
</td></tr>
<tr><td><code id="denoise_file_+3A_keep_rejects">keep_rejects</code></td>
<td>
<p>Boolean indicating if the bad reads should be written to a separate file (with the name
&quot;rejects_&quot; + outfile). Defaut is FALSE.</p>
</td></tr>
<tr><td><code id="denoise_file_+3A_multicore">multicore</code></td>
<td>
<p>An integer specifying the number of cores over which to multithread the denoising process. 
Default is FALSE, meaning the process is not multithreaded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using this function is optimized by the appropriation of the multicore option, which allows a user to specify a number of
cores that the denoising process should be multithreaded across. The more cores available, the faster the denoising of the 
input data. It should be noted that the multithreading relies on the entire fastq file being read into memory, because of
this your machine's available ram will need to exceed the size of the unzipped fastq file being denoised. If your file
size exceeds the available memory you may want to consider spliting the input into several smaller files and denoising them
each with this function (this is a fast solution as the multicore option can be used to speed up denoising). Alternatively,
you can depoly the 'denoise' function in an iterative fashion, reading in/denoising and writing only a single fq entry at
a time. This would require a much smaller memory footprint, but would be much slower due to the lack of multithreading.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoise">denoise</a></code>
</p>

<hr>
<h2 id='denoise_list'>List-to-list denoising of COI barcode sequences.</h2><span id='topic+denoise_list'></span>

<h3>Description</h3>

<p>This function provides a shortcut for running the denoise function
on a list of sequences. The to_return option can be used to control
whether this function returns a list of sequence strings (default), 
or a list of DNA seq objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoise_list(x, to_return = "seq", cores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoise_list_+3A_x">x</code></td>
<td>
<p>A list like object of barcode sequences.</p>
</td></tr>
<tr><td><code id="denoise_list_+3A_to_return">to_return</code></td>
<td>
<p>Indicate whether a the function should return a list of 
sequence ('seq') or the full DNAseq object ('DNAseq). Default is ('seq')</p>
</td></tr>
<tr><td><code id="denoise_list_+3A_cores">cores</code></td>
<td>
<p>The number of cores across which to thread the denosiing. Default is 1.</p>
</td></tr>
<tr><td><code id="denoise_list_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to the denoise algorithm.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+denoise">denoise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#denoise a list of sequences
out = denoise_list(ex_nt_list, dir_check = FALSE, double_pass = FALSE)
#denoise and add placehers to outputs 

#return a list of DNAseq objects 
ex_DNAseq_out = denoise_list(ex_nt_list, to_return = 'DNAseq',
 dir_check = FALSE, double_pass = FALSE)

</code></pre>

<hr>
<h2 id='dir_check'>Take an input sequence and align both the forward and reverse compliments to the PHMM</h2><span id='topic+dir_check'></span>

<h3>Description</h3>

<p>The fuction returns the sequence, DNAbin and Path and score of the optimal orientation.
Optimal orientation is determined by the direction with the longer string of consecutive 
ones in the path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir_check(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dir_check_+3A_x">x</code></td>
<td>
<p>a DNAseq class object.</p>
</td></tr>
</table>

<hr>
<h2 id='DNAseq'>Build a DNAseq object from a DNA sequence string.</h2><span id='topic+DNAseq'></span>

<h3>Description</h3>

<p>This can optionally include the DNA sequence's corresponding PHRED quality values and a sequencer identifier as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNAseq(x = character(), name = character(), phred = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DNAseq_+3A_x">x</code></td>
<td>
<p>a nucleotide string.
Valid characters within the nucleotide string are: a,t,g,c,-,n.
The nucleotide string can be input as upper case, but will be automatically converted to lower case.</p>
</td></tr>
<tr><td><code id="DNAseq_+3A_name">name</code></td>
<td>
<p>an optional character string. Identifier for the sequence.</p>
</td></tr>
<tr><td><code id="DNAseq_+3A_phred">phred</code></td>
<td>
<p>an optional character string. The phred score string corresponding to the nucleotide string.
If passed then the input phred scores will be modified along with the nucleotides and carried through
to the sequence output. Default = NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"coi5p"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat = DNAseq(example_nt_string)
#named DNAseq sequence
dat = DNAseq(example_nt_string, name = "example_seq1")
#components in output DNAseq object:
dat$raw
dat$name
</code></pre>

<hr>
<h2 id='ex_nt_list'>An example of a list of four coi5p sequences, each containing indel errors.</h2><span id='topic+ex_nt_list'></span>

<h3>Description</h3>

<p>An example of a list of four coi5p sequences, each containing indel errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_nt_list
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.</p>

<hr>
<h2 id='example_nt_string'>Example coi5p DNA sequence string.</h2><span id='topic+example_nt_string'></span>

<h3>Description</h3>

<p>This string of barcode data is used in the package documentation's examples
and within the vignette demonstrating how to use the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_nt_string
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.</p>

<hr>
<h2 id='example_nt_string_errors'>Example coi5p DNA sequence string with insertion and deletion errors.</h2><span id='topic+example_nt_string_errors'></span>

<h3>Description</h3>

<p>This string of barcode data is used in the package documentation's examples
and within the vignette demonstrating how to use the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_nt_string_errors
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.</p>

<hr>
<h2 id='frame'>Take a DNAseq object and isolate the COI-5P region.</h2><span id='topic+frame'></span><span id='topic+frame.DNAseq'></span>

<h3>Description</h3>

<p>Raw DNA sequence is taken and compared against the nucleotide profile hidden Markov model (PHMM), 
generating the statistical information later used to apply corrections to the sequence read. The 
speed of this function and how it operates are dependent on the paramaters chosen. When dir_check == TRUE
the function will compare the forward and reverse compliment against the PHMM. Since the PHMM comparison is
a computationally intensive process, this option should be set to FALSE if you're data are all forward reads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frame(x, ...)

## S3 method for class 'DNAseq'
frame(x, ..., dir_check = TRUE, double_pass = TRUE,
  min_match = 100, max_inserts = 400, terminate_rejects = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frame_+3A_x">x</code></td>
<td>
<p>a DNAseq class object.</p>
</td></tr>
<tr><td><code id="frame_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="frame_+3A_dir_check">dir_check</code></td>
<td>
<p>A boolean indicating if both the forward and reverse compliments of a sequence should 
be checked against the PHMM. Default is TRUE.</p>
</td></tr>
<tr><td><code id="frame_+3A_double_pass">double_pass</code></td>
<td>
<p>A boolean indicating if a second pass through the Viterbi algorithm should be conducted for sequences
that had leading nucleotides not matching the PHMM. This improves the accurate establishment of reading frame and will
reduce false rejections by the amino acid check, but this comes at a cost of additional processing time. Default is TRUE.</p>
</td></tr>
<tr><td><code id="frame_+3A_min_match">min_match</code></td>
<td>
<p>The minimum number of sequential matches to the PHMM for a sequence to be denoised.
Otherwise flag the sequence as a reject.</p>
</td></tr>
<tr><td><code id="frame_+3A_max_inserts">max_inserts</code></td>
<td>
<p>The maximum number of sequention insert states occuring in a sequence 
(including the flanking regions). If this number is exceeded than the entire read will be labelled for rejection. 
Default is 400.</p>
</td></tr>
<tr><td><code id="frame_+3A_terminate_rejects">terminate_rejects</code></td>
<td>
<p>Should a check be made to enusre minimum homology of the input sequence to the PHMM.
Makes sure the match conditions are met prior to continuing with the framing of the sequence. If conditions not
met then the function is stopped and the sequence labelled for rejection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The min match and max inserts provide the minimal amount of matching to the PHMM requried for a sequence to not
be flagged for rejection. If you are dealing with sequence fragments much shorter than the entire COI-5P region you
should lower these values.
</p>


<h3>Value</h3>

<p>a class object of code &quot;DNAseq&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAseq">DNAseq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#previously called
hi_phred = paste0(rep("~~~", 217), collapse="")
dat1 = DNAseq(example_nt_string_errors, name = "err_seq1", phred = hi_phred)
dat1= frame(dat1)
dat1$frame_dat # a labelled list with framing information is produced
dat1$reject == FALSE # the match criteria were met, not labelled for rejection
dat1$data$path #one can call and view the path diagram produced by the PHMM comparison.
</code></pre>

<hr>
<h2 id='individual_DNAbin'>build an DNAbin with ape.</h2><span id='topic+individual_DNAbin'></span>

<h3>Description</h3>

<p>Switches the dashes in the seq - to n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>individual_DNAbin(dna_string)
</code></pre>

<hr>
<h2 id='ins_front_trim'>check sequence for an early large string of deletions, if it exists then
return the starting index by which to slice the path and the string</h2><span id='topic+ins_front_trim'></span>

<h3>Description</h3>

<p>check sequence for an early large string of deletions, if it exists then
return the starting index by which to slice the path and the string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ins_front_trim(path_out, search_scope = 15)
</code></pre>

<hr>
<h2 id='leading_ins'>Check for a large number of leading inserted bases,
if this is the case, TRUE is returned and the PHMM
should be run a second time on the truncated data.</h2><span id='topic+leading_ins'></span>

<h3>Description</h3>

<p>Check for a large number of leading inserted bases,
if this is the case, TRUE is returned and the PHMM
should be run a second time on the truncated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leading_ins(seq_path)
</code></pre>

<hr>
<h2 id='meta_check'>Run the log file and reject processing code after running the denoise pipeline.</h2><span id='topic+meta_check'></span>

<h3>Description</h3>

<p>Run the log file and reject processing code after running the denoise pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta_check(x, log_data = list(), log_file = FALSE,
  keep_rejects = FALSE, reject_filename = "rejects.fastq", ...)
</code></pre>

<hr>
<h2 id='new_DNAseq'>Build a new DNAseq class instance.</h2><span id='topic+new_DNAseq'></span>

<h3>Description</h3>

<p>Build a new DNAseq class instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_DNAseq(x = character(), name = character(), phred = NULL)
</code></pre>

<hr>
<h2 id='nt_PHMM'>Nucleotide profile hidden markov model for debar.</h2><span id='topic+nt_PHMM'></span>

<h3>Description</h3>

<p>This model is stored in the package and was trained on a representitive
sample of the barcode of life database (http://www.boldsystems.org/index.php).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nt_PHMM
</code></pre>


<h3>Format</h3>

<p>An object of class <code>PHMM</code> of length 14.</p>

<hr>
<h2 id='outseq'>Get the final denoised output sequence for a read.</h2><span id='topic+outseq'></span><span id='topic+outseq.DNAseq'></span>

<h3>Description</h3>

<p>Get the final denoised output sequence for a read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outseq(x, ...)

## S3 method for class 'DNAseq'
outseq(x, ..., keep_flanks = TRUE, ambig_char = "N",
  adjust_limit = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outseq_+3A_x">x</code></td>
<td>
<p>a DNAseq class object.</p>
</td></tr>
<tr><td><code id="outseq_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="outseq_+3A_keep_flanks">keep_flanks</code></td>
<td>
<p>Should the regions of the input sequence outside of the barcode region be readded to the denoised sequence
prior to outputting to the file. Options are TRUE, FALSE and 'right'. The 'right' option will keep the trailing flank
but remove the leading flank. Default is TRUE. 
False will lead to only the denoised sequence for the 657bp barcode region being output to the file.</p>
</td></tr>
<tr><td><code id="outseq_+3A_ambig_char">ambig_char</code></td>
<td>
<p>The character to use for ambigious positions in the sequence.</p>
</td></tr>
<tr><td><code id="outseq_+3A_adjust_limit">adjust_limit</code></td>
<td>
<p>the maximum number of corrections that can be applied to a sequence read. If this number is exceeded 
then the entire read is masked with ambigious characters. Default is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a class object of code &quot;ccs_reads&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAseq">DNAseq</a></code>
</p>
<p><code><a href="#topic+frame">frame</a></code>
</p>
<p><code><a href="#topic+adjust">adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#previously run
excess_string = paste0("CCCCCC", example_nt_string_errors, 
                       "CCCCCCCC", collapse="")
ex_data = DNAseq(excess_string, name = 'ex1')
ex_data =  frame(ex_data)
ex_data = adjust(ex_data)
#build output sequence with trimmed edges
ex_data = outseq(ex_data, keep_flanks = TRUE)
ex_data$outseq #view the output sequence, edges were reattached
#you will avoid data loss on edge of sequence, but errors in edge, or
#off target sequence will be present in the output
#
#build output sequence with only the COI-5P region
ex_data = outseq(ex_data, keep_flanks = FALSE)
ex_data$outseq #view the output sequence
#Ns added to the front to buffer trimmed region
#Note some sequence is lost due to the strange 
#path match that occurs at the front of the sequence.
ex_data$data$path
</code></pre>

<hr>
<h2 id='print.DNAseq'>Print a concise summary of the DNAseq object</h2><span id='topic+print.DNAseq'></span>

<h3>Description</h3>

<p>Print a concise summary of the DNAseq object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DNAseq'
print(x, ...)
</code></pre>

<hr>
<h2 id='read_fasta'>Read in raw data from a fasta file.</h2><span id='topic+read_fasta'></span>

<h3>Description</h3>

<p>Read in raw data from a fasta file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fasta(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fasta_+3A_x">x</code></td>
<td>
<p>The name of the fasta file to read data from.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fasta_example_file = system.file('extdata/coi_sequel_data_subset.fastq', package = 'debar')
data = read_fasta(fasta_example_file)
</code></pre>

<hr>
<h2 id='read_fastq'>Read in raw data from a fastq file.</h2><span id='topic+read_fastq'></span>

<h3>Description</h3>

<p>Read in raw data from a fastq file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fastq(x, keep_quality = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fastq_+3A_x">x</code></td>
<td>
<p>The name of the fastq file to read data from.</p>
</td></tr>
<tr><td><code id="read_fastq_+3A_keep_quality">keep_quality</code></td>
<td>
<p>Boolean indicating if the Phred quality scores should be 
retained in the output dataframe. Default is TRUE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#read in an unzipped fastq file
fastq_example_file = system.file('extdata/coi_sequel_data_subset.fastq', 
                                  package = 'debar')
data = read_fastq(fastq_example_file)
#read in a gzipped fastq file and do not keep the phred scores
gz_fastq_example_file = system.file('extdata/coi_sequel_data_subset.fastq', 
                                    package = 'debar')
data2 = read_fastq(gz_fastq_example_file, keep_quality = FALSE)
</code></pre>

<hr>
<h2 id='rev_comp'>Return the reverse compliment for a DNA sequence</h2><span id='topic+rev_comp'></span>

<h3>Description</h3>

<p>Return the reverse compliment for a DNA sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_comp(x)
</code></pre>

<hr>
<h2 id='set_frame'>Take an input sequence and get it into the reading frame.
Uses the path of the sequence through the PHMM to located
the first long contigious stretch of 1s (matches)
Note - there is an imbalance in operation, namely the function
checks for a run of 10 additional 1s on the front of the sequence, and for
a run of only 3 additional matches on the back. The front of the sequence is high
priority because it is necessary to ensure the sequence is in frame.
whereas matching on the back is more lenient as insertions and deletions
can be tolerated here without large implications for the rest of the sequence</h2><span id='topic+set_frame'></span>

<h3>Description</h3>

<p>Take an input sequence and get it into the reading frame.
Uses the path of the sequence through the PHMM to located
the first long contigious stretch of 1s (matches)
Note - there is an imbalance in operation, namely the function
checks for a run of 10 additional 1s on the front of the sequence, and for
a run of only 3 additional matches on the back. The front of the sequence is high
priority because it is necessary to ensure the sequence is in frame.
whereas matching on the back is more lenient as insertions and deletions
can be tolerated here without large implications for the rest of the sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_frame(org_seq_vec, path_out)
</code></pre>

<hr>
<h2 id='translate_codon'>Censored Translation of a codon.</h2><span id='topic+translate_codon'></span>

<h3>Description</h3>

<p>Translate a codon of DNA sequence using the censored translation table.
this translates codons for which the amino acids is unambigious across
mitochondrial genetic codes across the animal kingdom and does not
translate those for which the amino acid varies,
but rather outputs a ? in the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_codon(codon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_codon_+3A_codon">codon</code></td>
<td>
<p>a three letter DNA string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string.
</p>

<hr>
<h2 id='triple_dels'>Look for triple deletes in the PHMM path.</h2><span id='topic+triple_dels'></span>

<h3>Description</h3>

<p>Look for triple deletes in the PHMM path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triple_dels(x, path_start, path_end)
</code></pre>

<hr>
<h2 id='triple_ins'>Look for triple inserts in the PHMM path.</h2><span id='topic+triple_ins'></span>

<h3>Description</h3>

<p>Look for triple inserts in the PHMM path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triple_ins(x, path_start, path_end)
</code></pre>

<hr>
<h2 id='validate_DNAseq'>Validate the new DNAseq class instance.</h2><span id='topic+validate_DNAseq'></span>

<h3>Description</h3>

<p>Validate the new DNAseq class instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_DNAseq(new_instance)
</code></pre>

<hr>
<h2 id='write_fasta'>Output the denoised consensus sequence to a fasta file.</h2><span id='topic+write_fasta'></span><span id='topic+write_fasta.DNAseq'></span>

<h3>Description</h3>

<p>Output the denoised consensus sequence to a fasta file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_fasta(x, ...)

## S3 method for class 'DNAseq'
write_fasta(x, ..., outfile = "denoised.fasta",
  append = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_fasta_+3A_x">x</code></td>
<td>
<p>a DNAseq class object.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_outfile">outfile</code></td>
<td>
<p>The name of the file to output the data to. Default is &quot;denoised.fasta&quot;.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_append">append</code></td>
<td>
<p>Should the ccs consensus sequence be appended to the output file?(TRUE) 
Or overwrite the file?(FALSE) Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a class object of code &quot;DNAseq&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAseq">DNAseq</a></code>
</p>
<p><code><a href="#topic+frame">frame</a></code>
</p>
<p><code><a href="#topic+adjust">adjust</a></code>
</p>

<hr>
<h2 id='write_fastq'>Output the denoised sequence to a fastq format with placeholder phred scores.</h2><span id='topic+write_fastq'></span><span id='topic+write_fastq.DNAseq'></span>

<h3>Description</h3>

<p>Output the denoised sequence to a fastq format with placeholder phred scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_fastq(x, ...)

## S3 method for class 'DNAseq'
write_fastq(x, ..., outfile = "denoised.fastq",
  append = TRUE, keep_phred = TRUE, phred_placeholder = "#")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_fastq_+3A_x">x</code></td>
<td>
<p>a DNAseq class object.</p>
</td></tr>
<tr><td><code id="write_fastq_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="write_fastq_+3A_outfile">outfile</code></td>
<td>
<p>The name of the file to output the data to. Default is &quot;denoised.fasta&quot;.</p>
</td></tr>
<tr><td><code id="write_fastq_+3A_append">append</code></td>
<td>
<p>Should the ccs consensus sequence be appended to the output file?(TRUE) 
Or overwrite the file?(FALSE) Default is TRUE.</p>
</td></tr>
<tr><td><code id="write_fastq_+3A_keep_phred">keep_phred</code></td>
<td>
<p>Should the original PHRED scores be kept in the output? Default is TRUE.</p>
</td></tr>
<tr><td><code id="write_fastq_+3A_phred_placeholder">phred_placeholder</code></td>
<td>
<p>The character to input for the phred score line. Default is '#'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a class object of code &quot;DNAseq&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNAseq">DNAseq</a></code>
</p>
<p><code><a href="#topic+frame">frame</a></code>
</p>
<p><code><a href="#topic+adjust">adjust</a></code>
</p>

<hr>
<h2 id='write_wrapper'>A wrapper function to deploy the fastq and fata output functions.</h2><span id='topic+write_wrapper'></span><span id='topic+write_wrapper.DNAseq'></span>

<h3>Description</h3>

<p>A wrapper function to deploy the fastq and fata output functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_wrapper(x, ...)

## S3 method for class 'DNAseq'
write_wrapper(x, ..., outfile = "denoised.fastq",
  outformat = "fastq", append = TRUE, keep_phred = TRUE,
  phred_placeholder = "#")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_wrapper_+3A_x">x</code></td>
<td>
<p>a DNAseq class object.</p>
</td></tr>
<tr><td><code id="write_wrapper_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="write_wrapper_+3A_outfile">outfile</code></td>
<td>
<p>The name of the file to output the data to. Default is &quot;denoised.fasta&quot;.</p>
</td></tr>
<tr><td><code id="write_wrapper_+3A_outformat">outformat</code></td>
<td>
<p>The format of the output data, either fasta for fastq. Default is fastq.</p>
</td></tr>
<tr><td><code id="write_wrapper_+3A_append">append</code></td>
<td>
<p>Should the ccs consensus sequence be appended to the output file?(TRUE) 
Or overwrite the file?(FALSE) Default is TRUE.</p>
</td></tr>
<tr><td><code id="write_wrapper_+3A_keep_phred">keep_phred</code></td>
<td>
<p>Should the original PHRED scores be kept in the output? Default is TRUE.</p>
</td></tr>
<tr><td><code id="write_wrapper_+3A_phred_placeholder">phred_placeholder</code></td>
<td>
<p>The character to input for the phred score line. Default is '#'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a class object of code &quot;DNAseq&quot;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
