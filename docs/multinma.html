<!DOCTYPE html><html><head><title>Help for package multinma</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multinma}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.default'><p>Set default values</p></a></li>
<li><a href='#adapt_delta'><p>Target average acceptance probability</p></a></li>
<li><a href='#add_integration'><p>Add numerical integration points to aggregate data</p></a></li>
<li><a href='#as.array.stan_nma'><p>Convert samples into arrays, matrices, or data frames</p></a></li>
<li><a href='#as.igraph.nma_data'><p>Convert networks to graph objects</p></a></li>
<li><a href='#as.stanfit'><p>as.stanfit</p></a></li>
<li><a href='#atrial_fibrillation'><p>Stroke prevention in atrial fibrillation patients</p></a></li>
<li><a href='#bcg_vaccine'><p>BCG vaccination</p></a></li>
<li><a href='#blocker'><p>Beta blockers to prevent mortality after MI</p></a></li>
<li><a href='#combine_network'><p>Combine multiple data sources into one network</p></a></li>
<li><a href='#dgent'><p>Generalised Student's t distribution (with location and scale)</p></a></li>
<li><a href='#diabetes'><p>Incidence of diabetes in trials of antihypertensive drugs</p></a></li>
<li><a href='#dic'><p>Deviance Information Criterion (DIC)</p></a></li>
<li><a href='#dietary_fat'><p>Reduced dietary fat to prevent mortality</p></a></li>
<li><a href='#distr'><p>Specify a general marginal distribution</p></a></li>
<li><a href='#dlogt'><p>Log Student's t distribution</p></a></li>
<li><a href='#dmspline'><p>Distribution functions for M-spline baseline hazards</p></a></li>
<li><a href='#example_ndmm'><p>Example newly-diagnosed multiple myeloma</p></a></li>
<li><a href='#example_pso_mlnmr'><p>Example plaque psoriasis ML-NMR</p></a></li>
<li><a href='#example_smk_fe'><p>Example smoking FE NMA</p></a></li>
<li><a href='#example_smk_nodesplit'><p>Example smoking node-splitting</p></a></li>
<li><a href='#example_smk_re'><p>Example smoking RE NMA</p></a></li>
<li><a href='#example_smk_ume'><p>Example smoking UME NMA</p></a></li>
<li><a href='#geom_km'><p>Kaplan-Meier curves of survival data</p></a></li>
<li><a href='#get_nodesplits'><p>Direct and indirect evidence</p></a></li>
<li><a href='#hta_psoriasis'><p>HTA Plaque Psoriasis</p></a></li>
<li><a href='#is_network_connected'><p>Check network connectedness</p></a></li>
<li><a href='#loo.stan_nma'><p>Model comparison using the <code>loo</code> package</p></a></li>
<li><a href='#make_knots'><p>Knot locations for M-spline baseline hazard models</p></a></li>
<li><a href='#mcmc_array-class'><p>Working with 3D MCMC arrays</p></a></li>
<li><a href='#multi'><p>Multinomial outcome data</p></a></li>
<li><a href='#multinma-package'><p>multinma: A Package for Network Meta-Analysis of Individual and Aggregate</p>
Data in Stan</a></li>
<li><a href='#ndmm_ipd'><p>Newly diagnosed multiple myeloma</p></a></li>
<li><a href='#nma'><p>Network meta-analysis models</p></a></li>
<li><a href='#nma_data-class'><p>The nma_data class</p></a></li>
<li><a href='#nma_dic-class'><p>The nma_dic class</p></a></li>
<li><a href='#nma_nodesplit-class'><p>The nma_nodesplit class</p></a></li>
<li><a href='#nma_prior-class'><p>The nma_prior class</p></a></li>
<li><a href='#nma_summary-class'><p>The <code>nma_summary</code> class</p></a></li>
<li><a href='#nodesplit_summary-class'><p>The <code>nodesplit_summary</code> class</p></a></li>
<li><a href='#pairs.stan_nma'><p>Matrix of plots for a <code>stan_nma</code> object</p></a></li>
<li><a href='#parkinsons'><p>Mean off-time reduction in Parkison's disease</p></a></li>
<li><a href='#plaque_psoriasis_ipd'><p>Plaque psoriasis data</p></a></li>
<li><a href='#plot_integration_error'><p>Plot numerical integration error</p></a></li>
<li><a href='#plot_prior_posterior'><p>Plot prior vs posterior distribution</p></a></li>
<li><a href='#plot.nma_data'><p>Network plots</p></a></li>
<li><a href='#plot.nma_dic'><p>Plots of model fit diagnostics</p></a></li>
<li><a href='#plot.nma_summary'><p>Plots of summary results</p></a></li>
<li><a href='#plot.nodesplit_summary'><p>Plots of node-splitting models</p></a></li>
<li><a href='#posterior_ranks'><p>Treatment rankings and rank probabilities</p></a></li>
<li><a href='#predict.stan_nma'><p>Predictions of absolute effects from NMA models</p></a></li>
<li><a href='#print.nma_data'><p>Print <code>nma_data</code> objects</p></a></li>
<li><a href='#print.nma_dic'><p>Print DIC details</p></a></li>
<li><a href='#print.nma_nodesplit_df'><p>Print <code>nma_nodesplit_df</code> objects</p></a></li>
<li><a href='#print.nma_summary'><p>Methods for <code>nma_summary</code> objects</p></a></li>
<li><a href='#print.nodesplit_summary'><p>Methods for <code>nodesplit_summary</code> objects</p></a></li>
<li><a href='#print.stan_nma'><p>Print <code>stan_nma</code> objects</p></a></li>
<li><a href='#priors'><p>Prior distributions</p></a></li>
<li><a href='#qbern'><p>The Bernoulli Distribution</p></a></li>
<li><a href='#qgamma'><p>The Gamma distribution</p></a></li>
<li><a href='#qlogitnorm'><p>The logit Normal distribution</p></a></li>
<li><a href='#RE_cor'><p>Random effects structure</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#relative_effects'><p>Relative treatment effects</p></a></li>
<li><a href='#set_agd_arm'><p>Set up arm-based aggregate data</p></a></li>
<li><a href='#set_agd_contrast'><p>Set up contrast-based aggregate data</p></a></li>
<li><a href='#set_agd_surv'><p>Set up aggregate survival data</p></a></li>
<li><a href='#set_ipd'><p>Set up individual patient data</p></a></li>
<li><a href='#smoking'><p>Smoking cessation data</p></a></li>
<li><a href='#stan_nma-class'><p>The stan_nma class</p></a></li>
<li><a href='#statins'><p>Statins for cholesterol lowering</p></a></li>
<li><a href='#summary.nma_nodesplit_df'><p>Summarise the results of node-splitting models</p></a></li>
<li><a href='#summary.nma_prior'><p>Summary of prior distributions</p></a></li>
<li><a href='#summary.stan_nma'><p>Posterior summaries from <code>stan_nma</code> objects</p></a></li>
<li><a href='#theme_multinma'><p>Plot theme for multinma plots</p></a></li>
<li><a href='#thrombolytics'><p>Thrombolytic treatments data</p></a></li>
<li><a href='#transfusion'><p>Granulocyte transfusion in patients with neutropenia or neutrophil</p>
dysfunction</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Network Meta-Analysis of Individual and Aggregate Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Network meta-analysis and network meta-regression models for 
    aggregate data, individual patient data, and mixtures of both individual 
    and aggregate data using multilevel network meta-regression as described by
    Phillippo et al. (2020) &lt;<a href="https://doi.org/10.1111%2Frssa.12579">doi:10.1111/rssa.12579</a>&gt;. Models are estimated in a
    Bayesian framework using 'Stan'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, graphics, survival, Rcpp (&ge; 0.12.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), rstantools (&ge;
2.0.0), Rdpack (&ge; 0.7), tibble (&ge; 2.1.3), dplyr (&ge; 1.0.0),
rlang, purrr, forcats, glue, randtoolbox, copula, tidyr (&ge;
1.0.0), stringr, Matrix, igraph, ggraph, ggplot2 (&ge; 3.3.0),
ggdist (&ge; 2.1.1), truncdist, bayesplot</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), withr, knitr, rmarkdown, parallel,
R.rsp, rprojroot, loo (&ge; 2.0.0), logitnorm, crayon, tidygraph,
pkgdown, splines2 (&ge; 0.5.0), flexsurv, rstpm2</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dmphillippo.github.io/multinma/">https://dmphillippo.github.io/multinma/</a>,
<a href="https://github.com/dmphillippo/multinma">https://github.com/dmphillippo/multinma</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dmphillippo/multinma/issues">https://github.com/dmphillippo/multinma/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 12:56:33 UTC; dp14189</td>
</tr>
<tr>
<td>Author:</td>
<td>David M. Phillippo
    <a href="https://orcid.org/0000-0003-2672-7841"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David M. Phillippo &lt;david.phillippo@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 01:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='.default'>Set default values</h2><span id='topic+.default'></span><span id='topic+.is_default'></span>

<h3>Description</h3>

<p>The <code>.default()</code> function is used internally to mark certain values as
default, so that the user may be notified when default values are being used.
For example, choosing a default reference treatment for a network, or using
default prior distributions. The function <code>.is_default()</code> checks whether an
argument/object is set to a default value. Neither of these functions are
intended to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.default(x = list())

.is_default(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".default_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>.default()</code>, an identical object with additional attribute
<code>.default</code>. For <code>.is_default()</code>, a logical value (<code>TRUE</code> or <code>FALSE</code>).
</p>

<hr>
<h2 id='adapt_delta'>Target average acceptance probability</h2><span id='topic+adapt_delta'></span>

<h3>Description</h3>

<p>The Stan control argument <code>adapt_delta</code> sets the target average acceptance
probability for the No-U-Turn Sampler (NUTS) used by Stan.
</p>


<h3>Details</h3>

<p>The default value of <code>adapt_delta</code> used by <code><a href="#topic+nma">nma()</a></code> is 0.8 for fixed
effect models, and 0.95 for random effects models.
</p>
<p>You should not need to change <code>adapt_delta</code> unless you see a warning
message about divergent transitions. Increasing <code>adapt_delta</code> from the
default to a value closer to 1 means that Stan will use a smaller step
size, making sampling slower but more robust, and resulting in fewer
divergent transitions.
</p>
<p>For more details see the Stan documentation available from
<a href="https://mc-stan.org/users/documentation/">https://mc-stan.org/users/documentation/</a>.
</p>

<hr>
<h2 id='add_integration'>Add numerical integration points to aggregate data</h2><span id='topic+add_integration'></span><span id='topic+add_integration.default'></span><span id='topic+add_integration.data.frame'></span><span id='topic+add_integration.nma_data'></span><span id='topic+unnest_integration'></span>

<h3>Description</h3>

<p>The <code>add_integration()</code> generic creates Quasi-Monte Carlo numerical
integration points using a Gaussian copula and Sobol' sequences, as described
in Phillippo et al. (2020). Methods are available for
networks stored in <code>nma_data</code> objects, and for data frames. The function
<code>unnest_integration()</code> unnests integration points stored in a data frame, to
aid plotting or other exploration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_integration(x, ...)

## Default S3 method:
add_integration(x, ...)

## S3 method for class 'data.frame'
add_integration(
  x,
  ...,
  cor = NULL,
  cor_adjust = NULL,
  n_int = 64L,
  int_args = list()
)

## S3 method for class 'nma_data'
add_integration(
  x,
  ...,
  cor = NULL,
  cor_adjust = NULL,
  n_int = 64L,
  int_args = list()
)

unnest_integration(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_integration_+3A_x">x</code></td>
<td>
<p>An <code>nma_data</code> object, as created by the <code style="white-space: pre;">&#8288;set_*()&#8288;</code> functions or
<code>combine_network()</code>, or data frame</p>
</td></tr>
<tr><td><code id="add_integration_+3A_...">...</code></td>
<td>
<p>Distributions for covariates, see &quot;Details&quot;</p>
</td></tr>
<tr><td><code id="add_integration_+3A_cor">cor</code></td>
<td>
<p>Correlation matrix to use for generating the integration points.
By default, this takes a weighted correlation matrix from all IPD studies.
Rows and columns should match the order of covariates specified in <code>...</code>.</p>
</td></tr>
<tr><td><code id="add_integration_+3A_cor_adjust">cor_adjust</code></td>
<td>
<p>Adjustment to apply to the correlation matrix given by
<code>cor</code> (or computed from the IPD if <code>cor = NULL</code>) to obtain the Gaussian
copula correlations, either <code>"spearman"</code>, <code>"pearson"</code>, or <code>"none"</code>, see
&quot;Details&quot;. The default when <code>cor = NULL</code> is <code>"spearman"</code>, otherwise the
default is <code>"pearson"</code>.</p>
</td></tr>
<tr><td><code id="add_integration_+3A_n_int">n_int</code></td>
<td>
<p>Number of integration points to generate, default 64. Powers of
2 are recommended, as these are expected to be particularly efficient for
QMC integration.</p>
</td></tr>
<tr><td><code id="add_integration_+3A_int_args">int_args</code></td>
<td>
<p>A named list of arguments to pass to
<code><a href="randtoolbox.html#topic+quasiRNG">sobol()</a></code></p>
</td></tr>
<tr><td><code id="add_integration_+3A_data">data</code></td>
<td>
<p>Data frame with nested integration points, stored in list
columns as <code style="white-space: pre;">&#8288;.int_&lt;variable name&gt;&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments passed to <code>...</code> specify distributions for the
covariates. Argument names specify the name of the covariate, which should
match a covariate name in the IPD (if IPD are present). The required
marginal distribution is then specified using the function <code><a href="#topic+distr">distr()</a></code>.
</p>
<p>The argument <code>cor_adjust</code> specifies how the correlation matrix given by
<code>cor</code> (or computed from the IPD if <code>cor = NULL</code>) is adjusted to obtain the
correlation matrix for the Gaussian copula, using the formulae in
Xiao and Zhou (2018).
</p>

<ul>
<li> <p><code>cor_adjust = "spearman"</code> should be used when the correlations <code>cor</code> have
been computed using Spearman's rank correlation. Correlations between
continuous covariates will be reproduced exactly by the integration points.
Correlations between discrete covariates will be reproduced approximately.
This is the default when <code>cor = NULL</code> and correlations are calculated from
the IPD studies.
</p>
</li>
<li> <p><code>cor_adjust = "pearson"</code> should be used when the correlations <code>cor</code> have
been computed using Pearson's product-moment correlation. Correlations between
Normal covariates will be reproduced exactly by the integration points, all
others will be reproduced approximately. Correlations between discrete
covariates will be reproduced approximately (and identically to <code>cor_adjust   = "spearman"</code>). This is the default when <code>cor</code> is provided by the user,
since <code><a href="stats.html#topic+cor">cor()</a></code> defaults to <code>method = "pearson"</code> and Pearson correlations are
most likely reported in published data. However, we recommend providing
Spearman correlations (e.g. from <code>cor(., method = "spearman")</code>) and using
<code>cor_adjust = "spearman"</code> where possible.
</p>
</li>
<li> <p><code>cor_adjust = "none"</code> allows the user to specify the correlation matrix
for the Gaussian copula directly; no adjustment is applied.
</p>
</li>
<li> <p><code>cor_adjust = "legacy"</code> is also available, which reproduces exactly the
behaviour from version 0.3.0 and earlier. This is similar to <code>cor_adjust =   "none"</code>, but unadjusted Spearman correlations are used if <code>cor = NULL</code>.
</p>
</li></ul>

<p>When adding integration points to a network object the correlation matrix
used is stored in <code style="white-space: pre;">&#8288;$int_cor&#8288;</code>, and the copula correlation matrix and
adjustment used are stored as attributes of <code style="white-space: pre;">&#8288;$int_cor&#8288;</code>. If this correlation
matrix is passed again to <code>add_integration()</code> (e.g. to reuse the
correlations for an external target population) this will be detected, and
the correct setting for <code>cor_adjust</code> will automatically be applied.
</p>


<h3>Value</h3>

<p>For the <code>nma_data</code> method, an object of class <a href="#topic+nma_data">nma_data</a>. For the
<code>data.frame</code> method, the input data frame is returned (as a <a href="tibble.html#topic+tibble">tibble</a>) with
an added column for each covariate (prefixed with &quot;.int_&quot;), containing the
numerical integration points nested as length-<code>n_int</code> vectors within each
row. For <code>unnest_integration()</code>, a data frame with integration points
unnested.
</p>


<h3>References</h3>

<p>Phillippo DM, Dias S, Ades AE, Belger M, Brnabic A, Schacht A, Saure D, Kadziola Z, Welton NJ (2020).
&ldquo;Multilevel Network Meta-Regression for population-adjusted treatment comparisons.&rdquo;
<em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, <b>183</b>(3), 1189&ndash;1210.
<a href="https://doi.org/10.1111/rssa.12579">doi:10.1111/rssa.12579</a>.<br /><br /> Xiao Q, Zhou S (2018).
&ldquo;Matching a correlation coefficient by a Gaussian copula.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>48</b>(7), 1728&ndash;1747.
<a href="https://doi.org/10.1080/03610926.2018.1439962">doi:10.1080/03610926.2018.1439962</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plaque psoriasis ML-NMR - network setup and adding integration points
# Set up plaque psoriasis network combining IPD and AgD
library(dplyr)
pso_ipd &lt;- filter(plaque_psoriasis_ipd,
                  studyc %in% c("UNCOVER-1", "UNCOVER-2", "UNCOVER-3"))

pso_agd &lt;- filter(plaque_psoriasis_agd,
                  studyc == "FIXTURE")

head(pso_ipd)
head(pso_agd)

pso_ipd &lt;- pso_ipd %&gt;%
  mutate(# Variable transformations
    bsa = bsa / 100,
    prevsys = as.numeric(prevsys),
    psa = as.numeric(psa),
    weight = weight / 10,
    durnpso = durnpso / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                         trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                         trtn == 4 ~ "TNFa blocker"),
    # Check complete cases for covariates of interest
    complete = complete.cases(durnpso, prevsys, bsa, weight, psa)
  )

pso_agd &lt;- pso_agd %&gt;%
  mutate(
    # Variable transformations
    bsa_mean = bsa_mean / 100,
    bsa_sd = bsa_sd / 100,
    prevsys = prevsys / 100,
    psa = psa / 100,
    weight_mean = weight_mean / 10,
    weight_sd = weight_sd / 10,
    durnpso_mean = durnpso_mean / 10,
    durnpso_sd = durnpso_sd / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                         trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                         trtn == 4 ~ "TNFa blocker")
  )

# Exclude small number of individuals with missing covariates
pso_ipd &lt;- filter(pso_ipd, complete)

pso_net &lt;- combine_network(
  set_ipd(pso_ipd,
          study = studyc,
          trt = trtc,
          r = pasi75,
          trt_class = trtclass),
  set_agd_arm(pso_agd,
              study = studyc,
              trt = trtc,
              r = pasi75_r,
              n = pasi75_n,
              trt_class = trtclass)
)

# Print network details
pso_net

# Add integration points to the network
pso_net &lt;- add_integration(pso_net,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  n_int = 64)


## Adding integration points to a data frame, e.g. for prediction
# Define a data frame of covariate summaries
new_agd_int &lt;- data.frame(
  bsa_mean = 0.6,
  bsa_sd = 0.3,
  prevsys = 0.1,
  psa = 0.2,
  weight_mean = 10,
  weight_sd = 1,
  durnpso_mean = 3,
  durnpso_sd = 1)

# Adding integration points, using the weighted average correlation matrix
# computed for the plaque psoriasis network
new_agd_int &lt;- add_integration(new_agd_int,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  cor = pso_net$int_cor,
  n_int = 64)

# Here, since we reused the correlation matrix pso_net$int_cor from the
# network, the correct setting of cor_adjust = "spearman" is automatically
# applied

new_agd_int

</code></pre>

<hr>
<h2 id='as.array.stan_nma'>Convert samples into arrays, matrices, or data frames</h2><span id='topic+as.array.stan_nma'></span><span id='topic+as.data.frame.stan_nma'></span><span id='topic+as_tibble.stan_nma'></span><span id='topic+as.tibble.stan_nma'></span><span id='topic+as.matrix.stan_nma'></span>

<h3>Description</h3>

<p>Samples (post warm-up) from a <code>stan_nma</code> model object can be coerced into an
array, matrix, or data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stan_nma'
as.array(x, ..., pars, include = TRUE)

## S3 method for class 'stan_nma'
as.data.frame(x, ..., pars, include = TRUE)

## S3 method for class 'stan_nma'
as_tibble(x, ..., pars, include = TRUE)

## S3 method for class 'stan_nma'
as.tibble(x, ..., pars, include = TRUE)

## S3 method for class 'stan_nma'
as.matrix(x, ..., pars, include = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.array.stan_nma_+3A_x">x</code></td>
<td>
<p>A <code>stan_nma</code> object</p>
</td></tr>
<tr><td><code id="as.array.stan_nma_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="rstan.html#topic+as.array.stanfit">as.array.stanfit()</a></code></p>
</td></tr>
<tr><td><code id="as.array.stan_nma_+3A_pars">pars</code></td>
<td>
<p>Optional character vector of parameter names to include in output. If not specified, all parameters are used.</p>
</td></tr>
<tr><td><code id="as.array.stan_nma_+3A_include">include</code></td>
<td>
<p>Logical, are parameters in <code>pars</code> to be included (<code>TRUE</code>, default) or excluded (<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>as.array()</code> method produces a 3D array [Iteration, Chain,
Parameter] containing posterior samples of each parameter (as class
<a href="#topic+mcmc_array">mcmc_array</a>). This has the side effect of enabling
<code><a href="bayesplot.html#topic+bayesplot-package">bayesplot</a></code> functions to
seamlessly work on <code>stan_nma</code> objects.
</p>
<p>The <code>as.data.frame()</code> method produces a data frame containing posterior
samples of each parameter, combined over all chains.
</p>
<p>The <code>as.matrix()</code> method produces a matrix containing posterior samples of
each parameter, combined over all chains.
</p>

<hr>
<h2 id='as.igraph.nma_data'>Convert networks to graph objects</h2><span id='topic+as.igraph.nma_data'></span><span id='topic+as_tbl_graph.nma_data'></span>

<h3>Description</h3>

<p>The method <code>as.igraph()</code> converts <code>nma_data</code> objects into the form used by
the <a href="igraph.html#topic+igraph">igraph</a> package. The method <code>as_tbl_graph()</code> converts <code>nma_data</code> objects
into the form used by the <a href="ggraph.html#topic+ggraph">ggraph</a> and
<a href="tidygraph.html#topic+tidygraph-package">tidygraph</a> packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma_data'
as.igraph(x, ..., collapse = TRUE)

## S3 method for class 'nma_data'
as_tbl_graph(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.igraph.nma_data_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+nma_data">nma_data</a> object to convert</p>
</td></tr>
<tr><td><code id="as.igraph.nma_data_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
<tr><td><code id="as.igraph.nma_data_+3A_collapse">collapse</code></td>
<td>
<p>Logical, collapse edges over studies? Default <code>TRUE</code>, only
one edge is produced for each comparison (by IPD or AgD study type) with a
<code>.nstudy</code> attribute giving the number of studies making that comparison. If
<code>FALSE</code>, repeated edges are added for each study making the comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>igraph</code> object for <code>as.igraph()</code>, a <code>tbl_graph</code> object for
<code>as_tbl_graph()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up network of smoking cessation data
head(smoking)

smk_net &lt;- set_agd_arm(smoking,
                       study = studyn,
                       trt = trtc,
                       r = r,
                       n = n,
                       trt_ref = "No intervention")

# Print details
smk_net

# Convert to igraph object
igraph::as.igraph(smk_net)  # Edges combined by default
igraph::as.igraph(smk_net, collapse = FALSE)  # Without combining edges

# Convert to tbl_graph object
tidygraph::as_tbl_graph(smk_net)  # Edges combined by default
tidygraph::as_tbl_graph(smk_net, collapse = FALSE)  # Without combining edges
</code></pre>

<hr>
<h2 id='as.stanfit'>as.stanfit</h2><span id='topic+as.stanfit'></span><span id='topic+as.stanfit.stan_nma'></span><span id='topic+as.stanfit.default'></span>

<h3>Description</h3>

<p>Attempt to turn an object into a <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.stanfit(x, ...)

## S3 method for class 'stan_nma'
as.stanfit(x, ...)

## Default S3 method:
as.stanfit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.stanfit_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="as.stanfit_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object.
</p>

<hr>
<h2 id='atrial_fibrillation'>Stroke prevention in atrial fibrillation patients</h2><span id='topic+atrial_fibrillation'></span>

<h3>Description</h3>

<p>Data frame containing the results of 26 trials comparing 17 treatments in 4
classes for the prevention of stroke in patients with atrial fibrillation
(Cooper et al. 2009). The data are the corrected versions
given by van Valkenhoef and Kuiper (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atrial_fibrillation
</code></pre>


<h3>Format</h3>

<p>A data frame with 63 rows and 11 variables:
</p>

<dl>
<dt>studyc</dt><dd><p>study name</p>
</dd>
<dt>studyn</dt><dd><p>numeric study ID</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>trt_class</dt><dd><p>treatment class</p>
</dd>
<dt>r</dt><dd><p>number of events</p>
</dd>
<dt>n</dt><dd><p>sample size</p>
</dd>
<dt>E</dt><dd><p>person-years at risk</p>
</dd>
<dt>stroke</dt><dd><p>proportion of individuals with prior stroke</p>
</dd>
<dt>year</dt><dd><p>year of study publication</p>
</dd>
<dt>followup</dt><dd><p>mean length of follow-up (years)</p>
</dd>
</dl>



<h3>References</h3>

<p>Cooper NJ, Sutton AJ, Morris D, Ades AE, Welton NJ (2009).
&ldquo;Addressing between-study heterogeneity and inconsistency in mixed treatment comparisons: Application to stroke prevention treatments in individuals with non-rheumatic atrial fibrillation.&rdquo;
<em>Statistics in Medicine</em>, <b>28</b>(14), 1861&ndash;1881.
<a href="https://doi.org/10.1002/sim.3594">doi:10.1002/sim.3594</a>.<br /><br /> van Valkenhoef G, Kuiper J (2016).
<em>gemtc: Network Meta-Analysis Using Bayesian Methods</em>.
R package version 0.8-2, <a href="https://CRAN.R-project.org/package=gemtc">https://CRAN.R-project.org/package=gemtc</a>.
</p>

<hr>
<h2 id='bcg_vaccine'>BCG vaccination</h2><span id='topic+bcg_vaccine'></span>

<h3>Description</h3>

<p>Data frame containing the results of 13 trials comparing BCG vaccination to
no vaccination for preventing tuberculosis (TB)
(Dias et al. 2011; Berkey et al. 1995). The numbers of individuals diagnosed
with TB in each arm during the study follow-up period are recorded. The
absolute degrees latitude at which the study was conducted are also recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcg_vaccine
</code></pre>


<h3>Format</h3>

<p>A data frame with 26 rows and 6 variables:
</p>

<dl>
<dt>studyn</dt><dd><p>numeric study ID</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>latitude</dt><dd><p>absolute degrees latitude</p>
</dd>
<dt>r</dt><dd><p>number diagnosed with TB</p>
</dd>
<dt>n</dt><dd><p>sample size</p>
</dd>
</dl>



<h3>References</h3>

<p>Berkey CS, Hoaglin DC, Mosteller F, Colditz GA (1995).
&ldquo;A random-effects regression model for meta-analysis.&rdquo;
<em>Statistics in Medicine</em>, <b>14</b>(4), 395&ndash;411.
<a href="https://doi.org/10.1002/sim.4780140406">doi:10.1002/sim.4780140406</a>.<br /><br /> Dias S, Sutton AJ, Welton NJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 3: Heterogeneity: subgroups, meta-regression, bias and bias-adjustment.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.
</p>

<hr>
<h2 id='blocker'>Beta blockers to prevent mortality after MI</h2><span id='topic+blocker'></span>

<h3>Description</h3>

<p>Data frame containing the number of deaths in 22 trials comparing beta
blockers vs. control for preventing mortality after myocardial infarction
(Carlin 1992; Dias et al. 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocker
</code></pre>


<h3>Format</h3>

<p>A data frame with 44 rows and 5 variables:
</p>

<dl>
<dt>studyn</dt><dd><p>numeric study ID</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>r</dt><dd><p>total number of events</p>
</dd>
<dt>n</dt><dd><p>total number of individuals</p>
</dd>
</dl>



<h3>References</h3>

<p>Carlin JB (1992).
&ldquo;Meta-analysis for 2 x 2 tables: A bayesian approach.&rdquo;
<em>Statistics in Medicine</em>, <b>11</b>(2), 141&ndash;158.
<a href="https://doi.org/10.1002/sim.4780110202">doi:10.1002/sim.4780110202</a>.<br /><br /> Dias S, Welton NJ, Sutton AJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 2: A generalised linear modelling framework for pair-wise and network meta-analysis of randomised controlled trials.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.
</p>

<hr>
<h2 id='combine_network'>Combine multiple data sources into one network</h2><span id='topic+combine_network'></span>

<h3>Description</h3>

<p>Multiple data sources created using <code><a href="#topic+set_ipd">set_ipd()</a></code>, <code><a href="#topic+set_agd_arm">set_agd_arm()</a></code>, or
<code><a href="#topic+set_agd_contrast">set_agd_contrast()</a></code> can be combined into a single network for analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_network(..., trt_ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_network_+3A_...">...</code></td>
<td>
<p>multiple data sources, as defined using the <code style="white-space: pre;">&#8288;set_*&#8288;</code> functions</p>
</td></tr>
<tr><td><code id="combine_network_+3A_trt_ref">trt_ref</code></td>
<td>
<p>reference treatment for the entire network, as a string (or
coerced as such) referring to the levels of the treatment factor variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+nma_data">nma_data</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_ipd">set_ipd()</a></code>, <code><a href="#topic+set_agd_arm">set_agd_arm()</a></code>, and <code><a href="#topic+set_agd_contrast">set_agd_contrast()</a></code> for defining
different data sources.
</p>
<p><code><a href="#topic+print.nma_data">print.nma_data()</a></code> for the print method displaying details of the
network, and <code><a href="#topic+plot.nma_data">plot.nma_data()</a></code> for network plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Parkinson's - combining contrast- and arm-based data
studies &lt;- parkinsons$studyn
(parkinsons_arm &lt;- parkinsons[studies %in% 1:3, ])
(parkinsons_contr &lt;- parkinsons[studies %in% 4:7, ])

park_arm_net &lt;- set_agd_arm(parkinsons_arm,
                            study = studyn,
                            trt = trtn,
                            y = y,
                            se = se,
                            sample_size = n)

park_contr_net &lt;- set_agd_contrast(parkinsons_contr,
                                   study = studyn,
                                   trt = trtn,
                                   y = diff,
                                   se = se_diff,
                                   sample_size = n)

park_net &lt;- combine_network(park_arm_net, park_contr_net)

# Print network details
park_net

# Plot network
plot(park_net, weight_edges = TRUE, weight_nodes = TRUE)

## Plaque Psoriasis - combining IPD and AgD in a network
# Set up plaque psoriasis network combining IPD and AgD
library(dplyr)
pso_ipd &lt;- filter(plaque_psoriasis_ipd,
                  studyc %in% c("UNCOVER-1", "UNCOVER-2", "UNCOVER-3"))

pso_agd &lt;- filter(plaque_psoriasis_agd,
                  studyc == "FIXTURE")

head(pso_ipd)
head(pso_agd)

pso_ipd &lt;- pso_ipd %&gt;%
  mutate(# Variable transformations
    bsa = bsa / 100,
    prevsys = as.numeric(prevsys),
    psa = as.numeric(psa),
    weight = weight / 10,
    durnpso = durnpso / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                         trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                         trtn == 4 ~ "TNFa blocker"),
    # Check complete cases for covariates of interest
    complete = complete.cases(durnpso, prevsys, bsa, weight, psa)
  )

pso_agd &lt;- pso_agd %&gt;%
  mutate(
    # Variable transformations
    bsa_mean = bsa_mean / 100,
    bsa_sd = bsa_sd / 100,
    prevsys = prevsys / 100,
    psa = psa / 100,
    weight_mean = weight_mean / 10,
    weight_sd = weight_sd / 10,
    durnpso_mean = durnpso_mean / 10,
    durnpso_sd = durnpso_sd / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                         trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                         trtn == 4 ~ "TNFa blocker")
  )

# Exclude small number of individuals with missing covariates
pso_ipd &lt;- filter(pso_ipd, complete)

pso_net &lt;- combine_network(
  set_ipd(pso_ipd,
          study = studyc,
          trt = trtc,
          r = pasi75,
          trt_class = trtclass),
  set_agd_arm(pso_agd,
              study = studyc,
              trt = trtc,
              r = pasi75_r,
              n = pasi75_n,
              trt_class = trtclass)
)

# Print network details
pso_net


# Plot network
plot(pso_net, weight_nodes = TRUE, weight_edges = TRUE, show_trt_class = TRUE)
</code></pre>

<hr>
<h2 id='dgent'>Generalised Student's t distribution (with location and scale)</h2><span id='topic+dgent'></span><span id='topic+pgent'></span><span id='topic+qgent'></span>

<h3>Description</h3>

<p>Density, distribution, and quantile function for the generalised t
distribution with degrees of freedom <code>df</code>, shifted by <code>location</code> and scaled
by <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgent(x, df, location = 0, scale = 1)

pgent(q, df, location = 0, scale = 1)

qgent(p, df, location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgent_+3A_x">x</code>, <code id="dgent_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dgent_+3A_df">df</code></td>
<td>
<p>Degrees of freedom, greater than zero</p>
</td></tr>
<tr><td><code id="dgent_+3A_location">location</code></td>
<td>
<p>Location parameter</p>
</td></tr>
<tr><td><code id="dgent_+3A_scale">scale</code></td>
<td>
<p>Scale parameter, greater than zero</p>
</td></tr>
<tr><td><code id="dgent_+3A_p">p</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dgent()</code> gives the density, <code>pgent()</code> gives the distribution
function, <code>qgent()</code> gives the quantile function.
</p>

<hr>
<h2 id='diabetes'>Incidence of diabetes in trials of antihypertensive drugs</h2><span id='topic+diabetes'></span>

<h3>Description</h3>

<p>Data frame containing the number of new cases of diabetes in 22 trials of 6
antihypertensive drugs (Elliott and Meyer 2007; Dias et al. 2011). The trial
duration (in years) is also recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diabetes
</code></pre>


<h3>Format</h3>

<p>A data frame with 48 rows and 7 variables:
</p>

<dl>
<dt>studyn</dt><dd><p>numeric study ID</p>
</dd>
<dt>studyc</dt><dd><p>study name</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>r</dt><dd><p>total number of events</p>
</dd>
<dt>n</dt><dd><p>total number of individuals</p>
</dd>
<dt>time</dt><dd><p>trial follow-up (years)</p>
</dd>
</dl>



<h3>References</h3>

<p>Dias S, Welton NJ, Sutton AJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 2: A generalised linear modelling framework for pair-wise and network meta-analysis of randomised controlled trials.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.<br /><br /> Elliott WJ, Meyer PM (2007).
&ldquo;Incident diabetes in clinical trials of antihypertensive drugs: a network meta-analysis.&rdquo;
<em>The Lancet</em>, <b>369</b>(9557), 201&ndash;207.
<a href="https://doi.org/10.1016/s0140-6736%2807%2960108-1">doi:10.1016/s0140-6736(07)60108-1</a>.
</p>

<hr>
<h2 id='dic'>Deviance Information Criterion (DIC)</h2><span id='topic+dic'></span>

<h3>Description</h3>

<p>Calculate the DIC for a model fitted using the <code><a href="#topic+nma">nma()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dic(x, penalty = c("pD", "pV"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dic_+3A_x">x</code></td>
<td>
<p>A fitted model object, inheriting class <a href="#topic+stan_nma">stan_nma</a></p>
</td></tr>
<tr><td><code id="dic_+3A_penalty">penalty</code></td>
<td>
<p>The method for estimating the effective number of parameters,
used to penalise model fit in the DIC. Either <code>"pD"</code> (the default), or
<code>"pV"</code>. For survival likelihoods only <code>"pV"</code> is currently available.</p>
</td></tr>
<tr><td><code id="dic_+3A_...">...</code></td>
<td>
<p>Other arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+nma_dic">nma_dic</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.nma_dic">print.nma_dic()</a></code> for printing details, <code><a href="#topic+plot.nma_dic">plot.nma_dic()</a></code> for
producing plots of residual deviance contributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation

# Run smoking FE NMA example if not already available
if (!exists("smk_fit_FE")) example("example_smk_fe", run.donttest = TRUE)


# Run smoking RE NMA example if not already available
if (!exists("smk_fit_RE")) example("example_smk_re", run.donttest = TRUE)


# Compare DIC of FE and RE models
(smk_dic_FE &lt;- dic(smk_fit_FE))
(smk_dic_RE &lt;- dic(smk_fit_RE))   # substantially better fit

# Plot residual deviance contributions under RE model
plot(smk_dic_RE)

# Check for inconsistency using UME model


# Run smoking UME NMA example if not already available
if (!exists("smk_fit_RE_UME")) example("example_smk_ume", run.donttest = TRUE)


# Compare DIC
smk_dic_RE
(smk_dic_RE_UME &lt;- dic(smk_fit_RE_UME))  # no difference in fit

# Compare residual deviance contributions
plot(smk_dic_RE, smk_dic_RE_UME, show_uncertainty = FALSE)

</code></pre>

<hr>
<h2 id='dietary_fat'>Reduced dietary fat to prevent mortality</h2><span id='topic+dietary_fat'></span>

<h3>Description</h3>

<p>Data frame containing the number of deaths and person-years at risk in 10
trials comparing reduced fat diets vs. control (non-reduced fat diet) for
preventing mortality (Hooper et al. 2000; Dias et al. 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dietary_fat
</code></pre>


<h3>Format</h3>

<p>A data frame with 21 rows and 7 variables:
</p>

<dl>
<dt>studyn</dt><dd><p>numeric study ID</p>
</dd>
<dt>studyc</dt><dd><p>study name</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>r</dt><dd><p>number of events</p>
</dd>
<dt>n</dt><dd><p>number randomised</p>
</dd>
<dt>E</dt><dd><p>person-years at risk</p>
</dd>
</dl>



<h3>References</h3>

<p>Dias S, Welton NJ, Sutton AJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 2: A generalised linear modelling framework for pair-wise and network meta-analysis of randomised controlled trials.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.<br /><br /> Hooper L, Summerbell CD, Higgins JPT, Thompson RL, Clements G, Capps N, Davey Smith G, Riemersma R, Ebrahim S (2000).
&ldquo;Reduced or modified dietary fat for preventing cardiovascular disease.&rdquo;
<em>Cochrane Database of Systematic Reviews</em>.
ISSN 1465-1858, <a href="https://doi.org/10.1002/14651858.CD002137">doi:10.1002/14651858.CD002137</a>.
</p>

<hr>
<h2 id='distr'>Specify a general marginal distribution</h2><span id='topic+distr'></span>

<h3>Description</h3>

<p><code>distr()</code> is used within the function <code><a href="#topic+add_integration">add_integration()</a></code> to specify marginal
distributions for the covariates, via a corresponding inverse CDF. It is also
used in <code><a href="#topic+predict.stan_nma">predict.stan_nma()</a></code> to specify a distribution for the baseline
response (intercept) when predicting absolute outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr(qfun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distr_+3A_qfun">qfun</code></td>
<td>
<p>an inverse CDF, either as a function name or a string</p>
</td></tr>
<tr><td><code id="distr_+3A_...">...</code></td>
<td>
<p>parameters of the distribution as arguments to <code>qfun</code>, these will
be quoted and evaluated later in the context of the aggregate data sources</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>qfun</code> should have a formal argument called <code>p</code>. This
restriction serves as a crude check for inverse CDFs (e.g. an error will be
given if <code>dnorm</code> is used instead of <code>qnorm</code>). If a user-written CDF is
supplied, it must have an argument <code>p</code> which takes a vector of
probabilities.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+distr">distr</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_integration">add_integration()</a></code> where <code>distr()</code> is used to specify marginal
distributions for covariates to integrate over, and <code><a href="#topic+predict.stan_nma">predict.stan_nma()</a></code>
where <code>distr()</code> is used to specify a distribution on the baseline response.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Specifying marginal distributions for integration

df &lt;- data.frame(x1_mean = 2, x1_sd = 0.5, x2 = 0.8)

# Distribution parameters are evaluated in the context of the data frame
add_integration(df,
                x1 = distr(qnorm, mean = x1_mean, sd = x1_sd),
                x2 = distr(qbern, prob = x2),
                cor = diag(2))

</code></pre>

<hr>
<h2 id='dlogt'>Log Student's t distribution</h2><span id='topic+dlogt'></span><span id='topic+plogt'></span><span id='topic+qlogt'></span>

<h3>Description</h3>

<p>Density, distribution, and quantile function for the log t distribution,
whose logarithm has degrees of freedom <code>df</code>, mean <code>location</code>, and standard
deviation <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlogt(x, df, location = 0, scale = 1)

plogt(q, df, location = 0, scale = 1)

qlogt(p, df, location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlogt_+3A_x">x</code>, <code id="dlogt_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dlogt_+3A_df">df</code></td>
<td>
<p>Degrees of freedom, greater than zero</p>
</td></tr>
<tr><td><code id="dlogt_+3A_location">location</code></td>
<td>
<p>Location parameter</p>
</td></tr>
<tr><td><code id="dlogt_+3A_scale">scale</code></td>
<td>
<p>Scale parameter, greater than zero</p>
</td></tr>
<tr><td><code id="dlogt_+3A_p">p</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">\log(Y) \sim t_\nu(\mu, \sigma^2)</code>, then <code class="reqn">Y</code> has a log t
distribution with <code>location</code> <code class="reqn">\mu</code>, <code>scale</code> <code class="reqn">\sigma</code>, and <code>df</code>
<code class="reqn">\nu</code>.
</p>
<p>The mean and all higher moments of the log t distribution are undefined or
infinite.
</p>
<p>If <code>df = 1</code> then the distribution is a log Cauchy distribution. As <code>df</code>
tends to infinity, this approaches a log Normal distribution.
</p>


<h3>Value</h3>

<p><code>dlogt()</code> gives the density, <code>plogt()</code> gives the distribution
function, <code>qlogt()</code> gives the quantile function.
</p>

<hr>
<h2 id='dmspline'>Distribution functions for M-spline baseline hazards</h2><span id='topic+dmspline'></span><span id='topic+pmspline'></span><span id='topic+qmspline'></span><span id='topic+hmspline'></span><span id='topic+Hmspline'></span><span id='topic+rmst_mspline'></span>

<h3>Description</h3>

<p>Density, distribution, quantile, hazard, cumulative hazard, and restricted
mean survival time functions for the M-spline baseline hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmspline(x, basis, scoef, rate, log = FALSE)

pmspline(q, basis, scoef, rate, lower.tail = TRUE, log.p = FALSE)

qmspline(p, basis, scoef, rate, lower.tail = TRUE, log.p = FALSE)

hmspline(x, basis, scoef, rate, log = FALSE)

Hmspline(x, basis, scoef, rate, log = FALSE)

rmst_mspline(t, basis, scoef, rate, start = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmspline_+3A_x">x</code>, <code id="dmspline_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="dmspline_+3A_basis">basis</code></td>
<td>
<p>M-spline basis produced by <code><a href="splines2.html#topic+mSpline">splines2::mSpline()</a></code></p>
</td></tr>
<tr><td><code id="dmspline_+3A_scoef">scoef</code></td>
<td>
<p>Vector (or matrix) of spline coefficients with length (or number
of columns) equal to the dimension of <code>basis</code></p>
</td></tr>
<tr><td><code id="dmspline_+3A_rate">rate</code></td>
<td>
<p>Vector of rate parameters</p>
</td></tr>
<tr><td><code id="dmspline_+3A_log">log</code>, <code id="dmspline_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if <code>TRUE</code>, probabilities <code>p</code> are given as
<code class="reqn">\log(p)</code></p>
</td></tr>
<tr><td><code id="dmspline_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), probabilities are
<code class="reqn">P(X \le x)</code>, otherwise <code class="reqn">P(X &gt; x)</code></p>
</td></tr>
<tr><td><code id="dmspline_+3A_p">p</code></td>
<td>
<p>Vector of probabilities</p>
</td></tr>
<tr><td><code id="dmspline_+3A_t">t</code></td>
<td>
<p>Vector of times to which the restricted mean survival time is
calculated</p>
</td></tr>
<tr><td><code id="dmspline_+3A_start">start</code></td>
<td>
<p>Optional left-truncation time or times. The returned restricted
mean survival will be conditioned on survival up to this time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Survival models with a flexible M-spline on the baseline hazard are
described by Brilleman et al. (2020).
Piecewise-exponential baseline hazards are a special case where the degree
of the M-spline polynomial is 0.
</p>
<p>The d/p/h/H functions are calculated from their definitions. <code>qmspline()</code>
uses numerical inversion via <code><a href="flexsurv.html#topic+qgeneric">flexsurv::qgeneric()</a></code>. <code>rmst_mspline()</code>uses
numerical integration via <code><a href="flexsurv.html#topic+rmst_generic">flexsurv::rmst_generic()</a></code>, except for the
special case of the piecewise-exponential hazard (i.e. degree 0 M-splines)
which uses the explicit formula from
Royston and Parmar (2013).
</p>
<p>Beyond the boundary knots, the hazard is assumed to be constant. (This
differs from the approach in <code><a href="splines2.html#topic+mSpline">splines2::mSpline()</a></code> that extrapolates the
polynomial basis functions, which is numerically unstable and highly
dependent on the data just before the boundary knots.) As with all
extrapolation, care should be taken when evaluating the splines at times
beyond the boundary knots (either directly through the d/p/h/H/rmst
functions, or indirectly by requesting quantiles with <code>qmspline()</code> that
correspond to times beyond the boundary knots). For this reason evaluating
the (unrestricted) mean survival time is not generally recommended as this
requires integrating over an infinite time horizon (i.e. <code>rmst_mspline()</code>
with <code>t = Inf</code>).
</p>


<h3>Value</h3>

<p><code>dmspline()</code> gives the density, <code>pmspline()</code> gives the distribution
function (CDF), <code>qmspline()</code> gives the quantile function (inverse-CDF),
<code>hmspline()</code> gives the hazard function, <code>Hmspline()</code> gives the cumulative
hazard function, and <code>rmst_mspline()</code> gives restricted mean survival times.
</p>


<h3>References</h3>

<p>Brilleman SL, Elci EM, Novik JB, Wolfe R (2020).
&ldquo;Bayesian Survival Analysis Using the rstanarm R Package.&rdquo;
<em>arXiv</em>.
<a href="https://doi.org/10.48550/arXiv.2002.09633">doi:10.48550/arXiv.2002.09633</a>, 2002.09633.<br /><br /> Royston P, Parmar MKB (2013).
&ldquo;Restricted mean survival time: an alternative to the hazard ratio for the design and analysis of randomized trials with a time-to-event outcome.&rdquo;
<em>BMC Medical Research Methodology</em>, <b>13</b>(1).
<a href="https://doi.org/10.1186/1471-2288-13-152">doi:10.1186/1471-2288-13-152</a>.
</p>

<hr>
<h2 id='example_ndmm'>Example newly-diagnosed multiple myeloma</h2><span id='topic+example_ndmm'></span>

<h3>Description</h3>

<p>Calling <code>example("example_ndmm")</code> will run a proportional
hazards Weibull NMA model on the newly-diagnosed multiple myeloma data,
using the code in the Examples section below. The resulting <code>stan_nma</code>
object <code>ndmm_fit</code> will then be available in the global environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up newly-diagnosed multiple myeloma network

head(ndmm_ipd)
head(ndmm_agd)

ndmm_net &lt;- combine_network(
  set_ipd(ndmm_ipd,
          study, trt,
          Surv = Surv(eventtime / 12, status)),
  set_agd_surv(ndmm_agd,
               study, trt,
               Surv = Surv(eventtime / 12, status),
               covariates = ndmm_agd_covs))

# Fit Weibull (PH) model
ndmm_fit &lt;- nma(ndmm_net, 
                likelihood = "weibull",
                prior_intercept = normal(scale = 100),
                prior_trt = normal(scale = 10),
                prior_aux = half_normal(scale = 10))

ndmm_fit


</code></pre>

<hr>
<h2 id='example_pso_mlnmr'>Example plaque psoriasis ML-NMR</h2><span id='topic+example_pso_mlnmr'></span>

<h3>Description</h3>

<p>Calling <code>example("example_pso_mlnmr")</code> will run a ML-NMR model
with the plaque psoriasis IPD and AgD, using the code in the Examples
section below. The resulting <code>stan_nma</code> object <code>pso_fit</code> will then be
available in the global environment.
</p>


<h3>Details</h3>

<p>Plaque psoriasis ML-NMR for use in examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up plaque psoriasis network combining IPD and AgD
library(dplyr)
pso_ipd &lt;- filter(plaque_psoriasis_ipd,
                  studyc %in% c("UNCOVER-1", "UNCOVER-2", "UNCOVER-3"))

pso_agd &lt;- filter(plaque_psoriasis_agd,
                  studyc == "FIXTURE")

head(pso_ipd)
head(pso_agd)

pso_ipd &lt;- pso_ipd %&gt;%
  mutate(# Variable transformations
    bsa = bsa / 100,
    prevsys = as.numeric(prevsys),
    psa = as.numeric(psa),
    weight = weight / 10,
    durnpso = durnpso / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                         trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                         trtn == 4 ~ "TNFa blocker"),
    # Check complete cases for covariates of interest
    complete = complete.cases(durnpso, prevsys, bsa, weight, psa)
  )

pso_agd &lt;- pso_agd %&gt;%
  mutate(
    # Variable transformations
    bsa_mean = bsa_mean / 100,
    bsa_sd = bsa_sd / 100,
    prevsys = prevsys / 100,
    psa = psa / 100,
    weight_mean = weight_mean / 10,
    weight_sd = weight_sd / 10,
    durnpso_mean = durnpso_mean / 10,
    durnpso_sd = durnpso_sd / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                         trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                         trtn == 4 ~ "TNFa blocker")
  )

# Exclude small number of individuals with missing covariates
pso_ipd &lt;- filter(pso_ipd, complete)

pso_net &lt;- combine_network(
  set_ipd(pso_ipd,
          study = studyc,
          trt = trtc,
          r = pasi75,
          trt_class = trtclass),
  set_agd_arm(pso_agd,
              study = studyc,
              trt = trtc,
              r = pasi75_r,
              n = pasi75_n,
              trt_class = trtclass)
)

# Print network details
pso_net

# Add integration points to the network
pso_net &lt;- add_integration(pso_net,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  n_int = 64)


# Fitting a ML-NMR model.
# Specify a regression model to include effect modifier interactions for five
# covariates, along with main (prognostic) effects. We use a probit link and
# specify that the two-parameter Binomial approximation for the aggregate-level
# likelihood should be used. We set treatment-covariate interactions to be equal
# within each class. We narrow the possible range for random initial values with
# init_r = 0.1, since probit models in particular are often hard to initialise.
# Using the QR decomposition greatly improves sampling efficiency here, as is
# often the case for regression models.
pso_fit &lt;- nma(pso_net, 
               trt_effects = "fixed",
               link = "probit",
               likelihood = "bernoulli2",
               regression = ~(durnpso + prevsys + bsa + weight + psa)*.trt,
               class_interactions = "common",
               prior_intercept = normal(scale = 10),
               prior_trt = normal(scale = 10),
               prior_reg = normal(scale = 10),
               init_r = 0.1,
               QR = TRUE)
pso_fit



</code></pre>

<hr>
<h2 id='example_smk_fe'>Example smoking FE NMA</h2><span id='topic+example_smk_fe'></span>

<h3>Description</h3>

<p>Calling <code>example("example_smk_fe")</code> will run a fixed effects
NMA model with the smoking cessation data, using the code in the Examples
section below. The resulting <code>stan_nma</code> object <code>smk_fit_FE</code> will then be
available in the global environment.
</p>


<h3>Details</h3>

<p>Smoking FE NMA for use in examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up network of smoking cessation data
head(smoking)

smk_net &lt;- set_agd_arm(smoking,
                       study = studyn,
                       trt = trtc,
                       r = r,
                       n = n,
                       trt_ref = "No intervention")

# Print details
smk_net


# Fitting a fixed effect model
smk_fit_FE &lt;- nma(smk_net, 
                  trt_effects = "fixed",
                  prior_intercept = normal(scale = 100),
                  prior_trt = normal(scale = 100))

smk_fit_FE



</code></pre>

<hr>
<h2 id='example_smk_nodesplit'>Example smoking node-splitting</h2><span id='topic+example_smk_nodesplit'></span>

<h3>Description</h3>

<p>Calling <code>example("example_smk_nodesplit")</code> will run
node-splitting models with the smoking cessation data, using the code in
the Examples section below. The resulting <code>nma_nodesplit_df</code> object
<code>smk_fit_RE_nodesplit</code> will then be available in the global environment.
</p>


<h3>Details</h3>

<p>Smoking node-splitting for use in examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up network of smoking cessation data
head(smoking)

smk_net &lt;- set_agd_arm(smoking,
                       study = studyn,
                       trt = trtc,
                       r = r,
                       n = n,
                       trt_ref = "No intervention")

# Print details
smk_net


# Fitting all possible node-splitting models
smk_fit_RE_nodesplit &lt;- nma(smk_net, 
                            consistency = "nodesplit",
                            trt_effects = "random",
                            prior_intercept = normal(scale = 100),
                            prior_trt = normal(scale = 100),
                            prior_het = normal(scale = 5))



</code></pre>

<hr>
<h2 id='example_smk_re'>Example smoking RE NMA</h2><span id='topic+example_smk_re'></span>

<h3>Description</h3>

<p>Calling <code>example("example_smk_re")</code> will run a random effects
NMA model with the smoking cessation data, using the code in the Examples
section below. The resulting <code>stan_nma</code> object <code>smk_fit_RE</code> will then be
available in the global environment.
</p>


<h3>Details</h3>

<p>Smoking RE NMA for use in examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up network of smoking cessation data
head(smoking)

smk_net &lt;- set_agd_arm(smoking,
                       study = studyn,
                       trt = trtc,
                       r = r,
                       n = n,
                       trt_ref = "No intervention")

# Print details
smk_net


# Fitting a random effects model
smk_fit_RE &lt;- nma(smk_net, 
                  trt_effects = "random",
                  prior_intercept = normal(scale = 100),
                  prior_trt = normal(scale = 100),
                  prior_het = normal(scale = 5))

smk_fit_RE



</code></pre>

<hr>
<h2 id='example_smk_ume'>Example smoking UME NMA</h2><span id='topic+example_smk_ume'></span>

<h3>Description</h3>

<p>Calling <code>example("example_smk_ume")</code> will run an unrelated mean
effects (inconsistency) NMA model with the smoking cessation data, using the
code in the Examples section below. The resulting <code>stan_nma</code> object
<code>smk_fit_RE_UME</code> will then be available in the global environment.
</p>


<h3>Details</h3>

<p>Smoking UME NMA for use in examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up network of smoking cessation data
head(smoking)

smk_net &lt;- set_agd_arm(smoking,
                       study = studyn,
                       trt = trtc,
                       r = r,
                       n = n,
                       trt_ref = "No intervention")

# Print details
smk_net


# Fitting an unrelated mean effects (inconsistency) model
smk_fit_RE_UME &lt;- nma(smk_net, 
                      consistency = "ume",
                      trt_effects = "random",
                      prior_intercept = normal(scale = 100),
                      prior_trt = normal(scale = 100),
                      prior_het = normal(scale = 5))

smk_fit_RE_UME



</code></pre>

<hr>
<h2 id='geom_km'>Kaplan-Meier curves of survival data</h2><span id='topic+geom_km'></span>

<h3>Description</h3>

<p>This helper function constructs a ggplot2 geom to plot Kaplan-Meier curves
from a network containing survival or time-to-event outcomes. This is useful
for overlaying the &quot;raw&quot; survival data on the estimated survival functions
created with plotted with <code><a href="#topic+plot.surv_nma_summary">plot.surv_nma_summary()</a></code>, but can also be used
standalone to plot Kaplan-Meier curves before fitting a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_km(
  network,
  ...,
  transform = c("identity", "cloglog", "log", "cumhaz"),
  curve_args = list(),
  cens_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_km_+3A_network">network</code></td>
<td>
<p>A <code>nma_data</code> network object containing survival outcomes</p>
</td></tr>
<tr><td><code id="geom_km_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="survival.html#topic+survfit">survival::survfit()</a></code></p>
</td></tr>
<tr><td><code id="geom_km_+3A_transform">transform</code></td>
<td>
<p>Character string giving the transformation to apply to the
KM curves before plotting. The default is <code>"identity"</code> for no
transformation; other options are <code>"cloglog"</code> for <code class="reqn">\log(-\log(S))</code>,
<code>"log"</code> for <code class="reqn">\log(S)</code>, or <code>"cumhaz"</code> for the cumulative hazard
<code class="reqn">-\log(S)</code>.</p>
</td></tr>
<tr><td><code id="geom_km_+3A_curve_args">curve_args</code></td>
<td>
<p>Optional list of arguments to customise the curves plotted
with <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_step()</a></code></p>
</td></tr>
<tr><td><code id="geom_km_+3A_cens_args">cens_args</code></td>
<td>
<p>Optional list of arguments to customise the censoring marks
plotted with <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 geom list that can be added to a ggplot2 plot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up newly-diagnosed multiple myeloma network

head(ndmm_ipd)
head(ndmm_agd)

ndmm_net &lt;- combine_network(
  set_ipd(ndmm_ipd,
          study, trt,
          Surv = Surv(eventtime / 12, status)),
  set_agd_surv(ndmm_agd,
               study, trt,
               Surv = Surv(eventtime / 12, status),
               covariates = ndmm_agd_covs))
# Plot KM curves using ggplot2
library(ggplot2)

# We need to create an empty ggplot object to add the curves to
ggplot() + geom_km(ndmm_net)

# Adding plotting options, facets, axis labels, and a plot theme
ggplot() +
  geom_km(ndmm_net,
          curve_args = list(linewidth = 0.5),
          cens_args = list(size = 3, shape = 124)) +
  facet_wrap(vars(Study)) +
  labs(xlab = "Time", ylab = "Survival Probability") +
  theme_multinma()

# Using the transform argument to produce log-log plots (e.g. to assess the
# proportional hazards assumption)
ggplot() +
  geom_km(ndmm_net, transform = "cloglog") +
  facet_wrap(vars(Study)) +
  theme_multinma()

# Using the transform argument to produce cumulative hazard plots
ggplot() +
  geom_km(ndmm_net, transform = "cumhaz") +
  facet_wrap(vars(Study)) +
  theme_multinma()

# This function can also be used to add KM data to plots of estimated survival
# curves from a fitted model, in a similar manner

# Run newly-diagnosed multiple myeloma example if not already available
if (!exists("ndmm_fit")) example("example_ndmm", run.donttest = TRUE)

# Plot estimated survival curves, and overlay the KM data

plot(predict(ndmm_fit, type = "survival")) + geom_km(ndmm_net)

</code></pre>

<hr>
<h2 id='get_nodesplits'>Direct and indirect evidence</h2><span id='topic+get_nodesplits'></span><span id='topic+has_direct'></span><span id='topic+has_indirect'></span>

<h3>Description</h3>

<p>Determine whether two treatments in a network are connected by direct and/or
indirect evidence, and generate a list of comparisons with both direct and
indirect evidence (i.e. potential inconsistency) for node-splitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nodesplits(network, include_consistency = FALSE)

has_direct(network, trt1, trt2)

has_indirect(network, trt1, trt2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nodesplits_+3A_network">network</code></td>
<td>
<p>An <code>nma_data</code> object, as created by the functions <code style="white-space: pre;">&#8288;set_*()&#8288;</code> or
<code>combine_network()</code>.</p>
</td></tr>
<tr><td><code id="get_nodesplits_+3A_include_consistency">include_consistency</code></td>
<td>
<p>Logical, whether to include a row of <code>NA</code>s to
indicate that a consistency model (i.e. a model with no node-splitting)
should also be fitted by the <code><a href="#topic+nma">nma()</a></code> function. Default is <code>FALSE</code> when
calling <code>get_nodesplits()</code> by hand, and <code><a href="#topic+nma">nma()</a></code> sets this to <code>TRUE</code> by
default.</p>
</td></tr>
<tr><td><code id="get_nodesplits_+3A_trt1">trt1</code>, <code id="get_nodesplits_+3A_trt2">trt2</code></td>
<td>
<p>Treatments, each as a single integer, string, or factor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of comparisons for node-splitting is generated following
the algorithm of van Valkenhoef et al. (2016). A
comparison between two treatments has the potential for inconsistency, and
is thus considered for node-splitting, if the comparison has both direct
evidence and <em>independent</em> indirect evidence.
</p>
<p>The notion of independent indirect evidence is necessary when multi-arm
trials are present, since by design these trials are internally consistent.
A comparison between two treatments has independent indirect evidence if,
after removing all studies comparing the two treatments from the network,
the two treatments are still connected by a path of evidence. This is the
criterion considered by the <code>has_indirect()</code> function.
</p>


<h3>Value</h3>

<p>For <code>has_direct()</code> and <code>has_indirect()</code>, a single logical value. For
<code>get_nodesplits()</code>, a data frame with two columns giving the comparisons
for node-splitting.
</p>


<h3>References</h3>

<p>van Valkenhoef G, Dias S, Ades AE, Welton NJ (2016).
&ldquo;Automated generation of node-splitting models for assessment of inconsistency in network meta-analysis.&rdquo;
<em>Research Synthesis Methods</em>, <b>7</b>(1), 80&ndash;93.
<a href="https://doi.org/10.1002/jrsm.1167">doi:10.1002/jrsm.1167</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parkinsons example
park_net &lt;- set_agd_arm(parkinsons,
                        study = studyn,
                        trt = trtn,
                        y = y,
                        se = se,
                        trt_ref = 1)

# View the network plot
plot(park_net)

# The 4 vs. 5 comparison is a spur on the network
has_direct(park_net, 4, 5)
has_indirect(park_net, 4, 5)

# 1 and 5 are not directly connected
has_direct(park_net, 1, 5)
has_indirect(park_net, 1, 5)

# The 1 vs. 2 comparison does not have independent indirect evidence, since
# the 1-2-4 loop is a multi-arm study
has_indirect(park_net, 1, 2)

# Get a list of comparisons with potential inconsistency for node-splitting
get_nodesplits(park_net)

# See van Valkenhoef (2016) for a discussion of this example
</code></pre>

<hr>
<h2 id='hta_psoriasis'>HTA Plaque Psoriasis</h2><span id='topic+hta_psoriasis'></span>

<h3>Description</h3>

<p>Data frame containing the results of 16 trials comparing 8 treatments for
moderate-to-severe plaque psoriasis from an HTA report
(Woolacott et al. 2006), analysed in TSD2
(Dias et al. 2011). Outcomes are success/failure to achieve 50%,
75%, or 90% reduction in symptoms on the Psoriasis Area and Severity Index
(PASI) scale. Some studies report all three ordered outcomes, others only one
or two. The latter are coded as missing values (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hta_psoriasis
</code></pre>


<h3>Format</h3>

<p>A data frame with 36 rows and 9 variables:
</p>

<dl>
<dt>studyn</dt><dd><p>numeric study ID</p>
</dd>
<dt>studyc</dt><dd><p>study name</p>
</dd>
<dt>year</dt><dd><p>year of publication</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>sample_size</dt><dd><p>sample size in each arm</p>
</dd>
<dt>PASI50, PASI75, PASI90</dt><dd><p>ordered multinomial outcome counts (exclusive, see details)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Outcome counts are &quot;exclusive&quot;; that is, for a study reporting all
outcomes, the counts represent the categories 50 &lt; PASI &lt; 75, 75 &lt; PASI &lt;
90, and 90 &lt; PASI &lt; 100, and are named by the lower end of the interval.
(As opposed to &quot;inclusive&quot; counts, which would represent the overlapping
categories PASI &gt; 50, PASI &gt; 70, and PASI &gt; 90.) The count for the fourth
category (the lowest), 0 &lt; PASI &lt; 50, is equal to <code>sample_size - PASI50 - PASI75 - PASI90</code>.
</p>
<p>Missing values are used where studies only report a subset of the outcomes.
For a study reporting only two outcomes, say 50 and 75, the counts
represent 50 &lt; PASI &lt; 75 and 75 &lt; PASI &lt; 100. For a study reporting only
one outcome, say PASI 75, the count represents 75 &lt; PASI &lt; 100.
</p>


<h3>References</h3>

<p>Dias S, Welton NJ, Sutton AJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 2: A generalised linear modelling framework for pair-wise and network meta-analysis of randomised controlled trials.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.<br /><br /> Woolacott N, Hawkins N, Mason A, Kainth A, Khadjesari Z, Bravo Vergel Y, Misso K, Light K, Chalmers R, Sculpher M, Riemsma R (2006).
&ldquo;Etanercept and efalizumab for the treatment of psoriasis: a systematic review.&rdquo;
<em>Health Technology Assessment</em>, <b>10</b>(46).
<a href="https://doi.org/10.3310/hta10460">doi:10.3310/hta10460</a>.
</p>

<hr>
<h2 id='is_network_connected'>Check network connectedness</h2><span id='topic+is_network_connected'></span>

<h3>Description</h3>

<p>Check whether a network is connected - whether there is a path of study
evidence linking every pair of treatments in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_network_connected(network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_network_connected_+3A_network">network</code></td>
<td>
<p>An <code>nma_data</code> object, as created by the functions <code style="white-space: pre;">&#8288;set_*()&#8288;</code> or
<code>combine_network()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models will still run with disconnected networks. However, estimated
relative effects between treatments across disconnected parts of the
network will be entirely based on the prior distribution (typically very
uncertain), as there is no information to update the prior distribution.
Relative effects within each connected sub-network will be estimated as if
each sub-network had been analysed separately.
</p>


<h3>Value</h3>

<p>Logical <code>TRUE</code> or <code>FALSE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation
# Set up network of smoking cessation data
head(smoking)

smk_net &lt;- set_agd_arm(smoking,
                       study = studyn,
                       trt = trtc,
                       r = r,
                       n = n,
                       trt_ref = "No intervention")

# Print details
smk_net

is_network_connected(smk_net)  # TRUE, network is connected
## A disconnected network
disc_net &lt;- set_agd_arm(smoking[smoking$studyn %in% c(15, 21), ],
                        study = studyn,
                        trt = trtc,
                        r = r,
                        n = n)
is_network_connected(disc_net)  # FALSE, network is disconnected
disc_net
plot(disc_net)
</code></pre>

<hr>
<h2 id='loo.stan_nma'>Model comparison using the <code>loo</code> package</h2><span id='topic+loo.stan_nma'></span><span id='topic+loo'></span><span id='topic+waic.stan_nma'></span><span id='topic+waic'></span>

<h3>Description</h3>

<p>The <code><a href="loo.html#topic+loo">loo()</a></code> and <code><a href="loo.html#topic+waic">waic()</a></code> functions from the <code>loo</code>
package may be called directly on <a href="#topic+stan_nma">stan_nma</a> and <a href="#topic+stan_mlnmr">stan_mlnmr</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stan_nma'
loo(x, ...)

## S3 method for class 'stan_nma'
waic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.stan_nma_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+stan_nma">stan_nma</a> or <a href="#topic+stan_mlnmr">stan_mlnmr</a></p>
</td></tr>
<tr><td><code id="loo.stan_nma_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="rstan.html#topic+stanfit-method-loo">loo()</a></code> or
<code><a href="loo.html#topic+waic">waic()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='make_knots'>Knot locations for M-spline baseline hazard models</h2><span id='topic+make_knots'></span>

<h3>Description</h3>

<p>Several different algorithms are provided to calculate knot locations for
M-spline baseline hazard models. This function is called internally within
the <code><a href="#topic+nma">nma()</a></code> function, but may be called directly by the user for more
control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_knots(
  network,
  n_knots = 7,
  type = c("quantile", "quantile_common", "quantile_lumped", "quantile_longest", "equal",
    "equal_common")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_knots_+3A_network">network</code></td>
<td>
<p>A network object, containing survival outcomes</p>
</td></tr>
<tr><td><code id="make_knots_+3A_n_knots">n_knots</code></td>
<td>
<p>Non-negative integer giving the number of internal knots
(default <code>7</code>)</p>
</td></tr>
<tr><td><code id="make_knots_+3A_type">type</code></td>
<td>
<p>String specifying the knot location algorithm to use (see
details). The default used by <code><a href="#topic+nma">nma()</a></code> is <code>"quantile"</code>, except when a
regression model is specified (using <code>aux_regression</code>) in which case the
default is <code>"quantile_common"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>type</code> argument can be used to choose between different
algorithms for placing the knots:
</p>

<dl>
<dt><code>"quantile"</code></dt><dd><p>Creates separate knot locations for each study,
internal knots are placed at evenly-spaced quantiles of the observed event
times within each study.</p>
</dd>
<dt><code>"quantile_lumped"</code></dt><dd><p>Creates a common set of knots for all studies,
calculated as evenly-spaced quantiles of the observed event times from all
studies lumped together.</p>
</dd>
<dt><code>"quantile_common"</code></dt><dd><p>Creates a common set of knots for all studies,
taking quantiles of the quantiles of the observed event times within each
study. This often seems to result in a more even knot spacing than
<code>"quantile_lumped"</code>, particularly when follow-up is uneven across studies,
and may handle differing behaviour in the baseline hazard across studies
better than <code>"quantile_longest"</code>.</p>
</dd>
<dt><code>"quantile_longest"</code></dt><dd><p>Creates a common set of knots for all studies,
using evenly-spaced quantiles of the observed event times in the longest
study.</p>
</dd>
<dt><code>"equal"</code></dt><dd><p>Creates separate knot locations for each study, at
evenly-spaced times between the boundary knots in each study.</p>
</dd>
<dt><code>"equal_common"</code></dt><dd><p>Creates a common set of knots for all studies, at
evenly-spaced times between the earliest entry time and last
event/censoring time in the network.</p>
</dd>
</dl>

<p>Boundary knots are calculated as follows:
</p>

<ul>
<li><p> For separate knot locations in each study, boundary knots are placed at the
earliest entry time and last event/censoring time in each study.
</p>
</li>
<li><p> For a common set of knots across all studies, boundary knots are placed at
the earliest entry time and last event/censoring time across all studies.
</p>
</li></ul>

<p>Models with regression on the spline coefficients (i.e. with <code>aux_regression</code>
specified) require a common set of knots across all studies.
</p>
<p>Provided that a sufficient number of knots are used, model fit should be
largely unaffected by the knot locations. However, sampling difficulties can
sometimes occur if knot placement is poor, for example if a knot is placed
just before the last follow-up time in a study.
</p>


<h3>Value</h3>

<p>A named list of vectors giving the knot locations in each study.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up newly-diagnosed multiple myeloma network

head(ndmm_ipd)
head(ndmm_agd)

ndmm_net &lt;- combine_network(
  set_ipd(ndmm_ipd,
          study, trt,
          Surv = Surv(eventtime / 12, status)),
  set_agd_surv(ndmm_agd,
               study, trt,
               Surv = Surv(eventtime / 12, status),
               covariates = ndmm_agd_covs))

# The default knot locations
make_knots(ndmm_net, type = "quantile")

# Increasing the number of knots
make_knots(ndmm_net, n_knots = 10)

# Comparing alternative knot positioning algorithms
# Visualise these with a quick function
plot_knots &lt;- function(network, knots) {
  ggplot2::ggplot() +
    geom_km(network) +
    ggplot2::geom_vline(ggplot2::aes(xintercept = .data$knot),
                        data = tidyr::pivot_longer(as.data.frame(knots), cols = dplyr::everything(),
                                                   names_to = "Study", values_to = "knot"),
                        linetype = 2, colour = "grey60") +
    ggplot2::facet_wrap(~Study) +
    theme_multinma()
}

plot_knots(ndmm_net, make_knots(ndmm_net, type = "quantile"))
plot_knots(ndmm_net, make_knots(ndmm_net, type = "quantile_common"))
plot_knots(ndmm_net, make_knots(ndmm_net, type = "quantile_lumped"))
plot_knots(ndmm_net, make_knots(ndmm_net, type = "quantile_longest"))
plot_knots(ndmm_net, make_knots(ndmm_net, type = "equal"))
plot_knots(ndmm_net, make_knots(ndmm_net, type = "equal_common"))

</code></pre>

<hr>
<h2 id='mcmc_array-class'>Working with 3D MCMC arrays</h2><span id='topic+mcmc_array-class'></span><span id='topic+mcmc_array'></span><span id='topic+summary.mcmc_array'></span><span id='topic+print.mcmc_array'></span><span id='topic+plot.mcmc_array'></span><span id='topic+names.mcmc_array'></span><span id='topic+names+3C-.mcmc_array'></span>

<h3>Description</h3>

<p>3D MCMC arrays (Iterations, Chains, Parameters) are produced by <code>as.array()</code>
methods applied to <code>stan_nma</code> or <code>nma_summary</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc_array'
summary(object, ..., probs = c(0.025, 0.25, 0.5, 0.75, 0.975))

## S3 method for class 'mcmc_array'
print(x, ...)

## S3 method for class 'mcmc_array'
plot(x, ...)

## S3 method for class 'mcmc_array'
names(x)

## S3 replacement method for class 'mcmc_array'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_array-class_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other methods</p>
</td></tr>
<tr><td><code id="mcmc_array-class_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of quantiles of interest</p>
</td></tr>
<tr><td><code id="mcmc_array-class_+3A_x">x</code>, <code id="mcmc_array-class_+3A_object">object</code></td>
<td>
<p>A 3D MCMC array of class <code>mcmc_array</code></p>
</td></tr>
<tr><td><code id="mcmc_array-class_+3A_value">value</code></td>
<td>
<p>Character vector of replacement parameter names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary()</code> method returns a <a href="#topic+nma_summary">nma_summary</a> object, the <code>print()</code>
method returns <code>x</code> invisibly. The <code>names()</code> method returns a character
vector of parameter names, and <code style="white-space: pre;">&#8288;names()&lt;-&#8288;</code> returns the object with updated
parameter names. The <code>plot()</code> method is a shortcut for
<code>plot(summary(x), ...)</code>, passing all arguments on to <code><a href="#topic+plot.nma_summary">plot.nma_summary()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation

# Run smoking RE NMA example if not already available
if (!exists("smk_fit_RE")) example("example_smk_re", run.donttest = TRUE)


# Working with arrays of posterior draws (as mcmc_array objects) is
# convenient when transforming parameters

# Transforming log odds ratios to odds ratios
LOR_array &lt;- as.array(relative_effects(smk_fit_RE))
OR_array &lt;- exp(LOR_array)

# mcmc_array objects can be summarised to produce a nma_summary object
smk_OR_RE &lt;- summary(OR_array)

# This can then be printed or plotted
smk_OR_RE
plot(smk_OR_RE, ref_line = 1)

# Transforming heterogeneity SD to variance
tau_array &lt;- as.array(smk_fit_RE, pars = "tau")
tausq_array &lt;- tau_array^2

# Correct parameter names
names(tausq_array) &lt;- "tausq"

# Summarise
summary(tausq_array)

</code></pre>

<hr>
<h2 id='multi'>Multinomial outcome data</h2><span id='topic+multi'></span>

<h3>Description</h3>

<p>This function aids the specification of multinomial outcome data when setting
up a network with <code><a href="#topic+set_agd_arm">set_agd_arm()</a></code> or <code><a href="#topic+set_ipd">set_ipd()</a></code>. It takes a set of columns
(or, more generally, numeric vectors of the same length) of outcome counts in
each category, and binds these together to produce a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi(..., inclusive = FALSE, type = c("ordered", "competing"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_+3A_...">...</code></td>
<td>
<p>Two or more numeric columns (or vectors) of category counts.
Argument names (optional) will be used to label the categories.</p>
</td></tr>
<tr><td><code id="multi_+3A_inclusive">inclusive</code></td>
<td>
<p>Logical, are ordered category counts inclusive (<code>TRUE</code>) or
exclusive (<code>FALSE</code>)? Default <code>FALSE</code>. Only used when <code>type = "ordered"</code>.
See details.</p>
</td></tr>
<tr><td><code id="multi_+3A_type">type</code></td>
<td>
<p>String, indicating whether categories are <code>"ordered"</code> or
<code>"competing"</code>. Currently only ordered categorical outcomes are supported by
the modelling functions in this package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When specifying ordered categorical counts, these can either be
given as <em>exclusive</em> counts (<code>inclusive = FALSE</code>, the default) where
individuals are only counted in the highest category they achieve, or
<em>inclusive</em> counts (<code>inclusive = TRUE</code>) where individuals are counted in
every category up to and including the highest category achieved.
(Competing outcomes, by nature, are always specified as exclusive counts.)
</p>
<p><code>NA</code> values can be used to indicate categories/cutpoints that were not
measured.
</p>


<h3>Value</h3>

<p>A matrix of (exclusive) category counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These two data sets specify the same ordered categorical data for outcomes
# r0 &lt; r1 &lt; r2, but the first uses the "inclusive" format and the second the
# "exclusive" format.
df_inclusive &lt;- tibble::tribble(~r0, ~r1, ~r2,
                                1, 1, 1,
                                5, 4, 1,
                                5, 2, 2,
                                10, 5, 0,
                                5, 5, 0,
                                7, NA, 6,   # Achieved r2 or not (no r1)
                                10, 4, NA)  # Achieved r1 or not (no r2)

df_exclusive &lt;- tibble::tribble(~r0, ~r1, ~r2,
                                0, 0, 1,
                                1, 3, 1,
                                3, 0, 2,
                                5, 5, 0,
                                0, 5, 0,
                                1, NA, 6,   # Achieved r2 or not (no r1)
                                6, 4, NA)   # Achieved r1 or not (no r2)

(r_inclusive &lt;- with(df_inclusive, multi(r0, r1, r2, inclusive = TRUE)))
(r_exclusive &lt;- with(df_exclusive, multi(r0, r1, r2, inclusive = FALSE)))

# Counts are always stored in exclusive format
stopifnot(isTRUE(all.equal(r_inclusive, r_exclusive)))


## HTA Plaque Psoriasis
library(dplyr)

# Ordered outcomes here are given as "exclusive" counts
head(hta_psoriasis)

# Calculate lowest category count (failure to achieve PASI 50)
pso_dat &lt;- hta_psoriasis %&gt;%
  mutate(`PASI&lt;50` = sample_size - rowSums(cbind(PASI50, PASI75, PASI90), na.rm = TRUE))

# Set up network
pso_net &lt;- set_agd_arm(pso_dat,
                       study = paste(studyc, year),
                       trt = trtc,
                       r = multi(`PASI&lt;50`, PASI50, PASI75, PASI90,
                                 inclusive = FALSE,
                                 type = "ordered"))

pso_net

</code></pre>

<hr>
<h2 id='multinma-package'>multinma: A Package for Network Meta-Analysis of Individual and Aggregate
Data in Stan</h2><span id='topic+multinma-package'></span><span id='topic+multinma'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.svg" width="120" style="float: right;" alt="multinma logo" />
An R package for performing network meta-analysis and network meta-regression
with aggregate data, individual patient data, or mixtures of both.
</p>


<h3>Details</h3>

<p>Network meta-analysis (NMA) combines (aggregate) data from multiple
studies on multiple treatments in order to produce consistent estimates of
relative treatment effects between each pair of treatments in the network
(Dias et al. 2011).
</p>
<p>Network meta-regression (NMR) extends NMA to include covariates, allowing
adjustment for differences in effect-modifying variables between studies
(Dias et al. 2011). NMR is typically performed using aggregate
data (AgD), which lacks power and is prone to ecological bias. NMR with
individual patient data (IPD) is the gold standard, if data are available.
</p>
<p>Multilevel network meta-regression (ML-NMR) allows IPD and AgD to be
incorporated together in a network meta-regression
(Phillippo et al. 2020; Phillippo 2019). As in IPD NMR, an
individual-level regression model is defined. AgD studies are then fitted
by integrating the individual-level model over the respective covariate
distributions. This correctly links the two levels of the model (instead of
&quot;plugging in&quot; mean covariate values), avoiding aggregation bias.
Population-adjusted treatment effects (Phillippo et al. 2016) can be
produced for any study population in the network, or for an external target
population.
</p>
<p>Models are estimated in a Bayesian framework using Stan
(Carpenter et al. 2017). Quasi-Monte Carlo numerical
integration based on Sobol' sequences is used for the integration in ML-NMR
models, with a Gaussian copula to account for correlations between
covariates (Phillippo et al. 2020; Phillippo 2019).
</p>


<h3>Getting Started</h3>

<p>A good place to start is with the package vignettes which walk through
example analyses, see <code>vignette("vignette_overview")</code> for an overview.
The series of NICE Technical Support Documents on evidence synthesis gives
a detailed introduction to network meta-analysis:
</p>
<p>Dias S, Welton NJ, Sutton AJ, Caldwell DM, Lu G, Reken S, Ades AE (2011).
&ldquo;NICE DSU Technical Support Documents 1-7: Evidence Synthesis for Decision Making.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.
</p>
<p>Multilevel network meta-regression is set out in the following methods paper:
</p>
<p>Phillippo DM, Dias S, Ades AE, Belger M, Brnabic A, Schacht A, Saure D, Kadziola Z, Welton NJ (2020).
&ldquo;Multilevel Network Meta-Regression for population-adjusted treatment comparisons.&rdquo;
<em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, <b>183</b>(3), 1189&ndash;1210.
<a href="https://doi.org/10.1111/rssa.12579">doi:10.1111/rssa.12579</a>.
</p>


<h3>References</h3>

<p>Carpenter B, Gelman A, Hoffman MD, Lee D, Goodrich B, Betancourt M, Brubaker M, Guo J, Li P, Riddell A (2017).
&ldquo;Stan: A Probabilistic Programming Language.&rdquo;
<em>Journal of Statistical Software</em>, <b>76</b>(1).
<a href="https://doi.org/10.18637/jss.v076.i01">doi:10.18637/jss.v076.i01</a>.<br /><br /> Dias S, Sutton AJ, Welton NJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 3: Heterogeneity: subgroups, meta-regression, bias and bias-adjustment.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.<br /><br /> Dias S, Welton NJ, Sutton AJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 2: A generalised linear modelling framework for pair-wise and network meta-analysis of randomised controlled trials.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.<br /><br /> Phillippo DM (2019).
<em>Calibration of Treatment Effects in Network Meta-Analysis using Individual Patient Data</em>.
Ph.D. thesis, University of Bristol.
Available from <a href="https://research-information.bris.ac.uk/">https://research-information.bris.ac.uk/</a>.<br /><br /> Phillippo DM, Ades AE, Dias S, Palmer S, Abrams KR, Welton NJ (2016).
&ldquo;NICE DSU Technical Support Document 18: Methods for population-adjusted indirect comparisons in submission to NICE.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.<br /><br /> Phillippo DM, Dias S, Ades AE, Belger M, Brnabic A, Schacht A, Saure D, Kadziola Z, Welton NJ (2020).
&ldquo;Multilevel Network Meta-Regression for population-adjusted treatment comparisons.&rdquo;
<em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, <b>183</b>(3), 1189&ndash;1210.
<a href="https://doi.org/10.1111/rssa.12579">doi:10.1111/rssa.12579</a>.
</p>

<hr>
<h2 id='ndmm_ipd'>Newly diagnosed multiple myeloma</h2><span id='topic+ndmm_ipd'></span><span id='topic+ndmm_agd'></span><span id='topic+ndmm_agd_covs'></span>

<h3>Description</h3>

<p>Three data frames, <code>ndmm_ipd</code>, <code>ndmm_agd</code>, and <code>ndmm_agd_covs</code> containing
(simulated) individual patient data (IPD) from three studies and aggregate
data (AgD) from two studies on newly diagnosed multiple myeloma. The outcome
of interest is progression-free survival after autologous stem cell
transplant. The IPD studies in <code>ndmm_ipd</code> provide event/censoring times and
covariate values for each individual. The AgD studies provide reconstructed
event/censoring times from digitized Kaplan-Meier curves in <code>ndmm_agd</code> and
covariate summaries in <code>ndmm_agd_covs</code>, obtained from published trial
reports. The data are constructed to resemble those used by
Leahy and Walsh (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndmm_ipd

ndmm_agd

ndmm_agd_covs
</code></pre>


<h3>Format</h3>

<p>The individual patient data are contained in a data frame <code>ndmm_ipd</code>
with 1325 rows, one per individual, and 10 variables:
</p>

<dl>
<dt>study, studyf</dt><dd><p>study name</p>
</dd>
<dt>trt, trtf</dt><dd><p>treatment name</p>
</dd>
<dt>eventtime</dt><dd><p>event/censoring time</p>
</dd>
<dt>status</dt><dd><p>censoring indicator (0 = censored, 1 = event)</p>
</dd>
<dt>age</dt><dd><p>age (years)</p>
</dd>
<dt>iss_stage3</dt><dd><p>ISS stage 3 (0 = no, 1 = yes)</p>
</dd>
<dt>response_cr_vgpr</dt><dd><p>complete or very good partial response (0 = no, 1 = yes)</p>
</dd>
<dt>male</dt><dd><p>male sex (0 = no, 1 = yes)</p>
</dd>
</dl>

<p>The reconstructed Kaplan-Meier data for the aggregate studies are
contained in a data frame <code>ndmm_agd</code> with 2819 rows and 6 variables:
</p>

<dl>
<dt>study, studyf</dt><dd><p>study name</p>
</dd>
<dt>trt, trtf</dt><dd><p>treatment name</p>
</dd>
<dt>eventtime</dt><dd><p>event/censoring time</p>
</dd>
<dt>status</dt><dd><p>censoring indicator (0 = censored, 1 = event)</p>
</dd>
</dl>

<p>The covariate summaries extracted from published reportes for the
aggregate studies are contained in a data frame <code>ndmm_agd_covs</code> with 4
rows, one per study arm, and 15 columns:
</p>

<dl>
<dt>study, studyf</dt><dd><p>study name</p>
</dd>
<dt>trt, trtf</dt><dd><p>treatment name</p>
</dd>
<dt>sample_size</dt><dd><p>sample size in each arm</p>
</dd>
<dt>age_min, age_iqr_l, age_median, age_iqr_h, age_max, age_mean, age_sd</dt><dd><p>summary statistics for age (years)</p>
</dd>
<dt>iss_stage3</dt><dd><p>proportion of participants with ISS stage 3</p>
</dd>
<dt>response_cr_vgpr</dt><dd><p>proportion of participants with complete or very good partial response</p>
</dd>
<dt>male</dt><dd><p>proportion of male participants</p>
</dd>
</dl>



<h3>References</h3>

<p>Leahy J, Walsh C (2019).
&ldquo;Assessing the impact of a matching-adjusted indirect comparison in a Bayesian network meta-analysis.&rdquo;
<em>Research Synthesis Methods</em>, <b>10</b>(4), 546&ndash;568.
<a href="https://doi.org/10.1002/jrsm.1372">doi:10.1002/jrsm.1372</a>.
</p>

<hr>
<h2 id='nma'>Network meta-analysis models</h2><span id='topic+nma'></span>

<h3>Description</h3>

<p>The <code>nma</code> function fits network meta-analysis and (multilevel) network
meta-regression models in Stan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nma(
  network,
  consistency = c("consistency", "ume", "nodesplit"),
  trt_effects = c("fixed", "random"),
  regression = NULL,
  class_interactions = c("common", "exchangeable", "independent"),
  likelihood = NULL,
  link = NULL,
  ...,
  nodesplit = get_nodesplits(network, include_consistency = TRUE),
  prior_intercept = .default(normal(scale = 100)),
  prior_trt = .default(normal(scale = 10)),
  prior_het = .default(half_normal(scale = 5)),
  prior_het_type = c("sd", "var", "prec"),
  prior_reg = .default(normal(scale = 10)),
  prior_aux = .default(),
  prior_aux_reg = .default(),
  aux_by = NULL,
  aux_regression = NULL,
  QR = FALSE,
  center = TRUE,
  adapt_delta = NULL,
  int_thin = 0,
  int_check = TRUE,
  mspline_degree = 3,
  n_knots = 7,
  knots = NULL,
  mspline_basis = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nma_+3A_network">network</code></td>
<td>
<p>An <code>nma_data</code> object, as created by the functions <code style="white-space: pre;">&#8288;set_*()&#8288;</code>,
<code>combine_network()</code>, or <code>add_integration()</code></p>
</td></tr>
<tr><td><code id="nma_+3A_consistency">consistency</code></td>
<td>
<p>Character string specifying the type of (in)consistency
model to fit, either <code>"consistency"</code>, <code>"ume"</code>, or <code>"nodesplit"</code></p>
</td></tr>
<tr><td><code id="nma_+3A_trt_effects">trt_effects</code></td>
<td>
<p>Character string specifying either <code>"fixed"</code> or <code>"random"</code> effects</p>
</td></tr>
<tr><td><code id="nma_+3A_regression">regression</code></td>
<td>
<p>A one-sided model formula, specifying the prognostic and
effect-modifying terms for a regression model. Any references to treatment
should use the <code>.trt</code> special variable, for example specifying effect
modifier interactions as <code>variable:.trt</code> (see details).</p>
</td></tr>
<tr><td><code id="nma_+3A_class_interactions">class_interactions</code></td>
<td>
<p>Character string specifying whether effect modifier
interactions are specified as <code>"common"</code>, <code>"exchangeable"</code>, or
<code>"independent"</code>.</p>
</td></tr>
<tr><td><code id="nma_+3A_likelihood">likelihood</code></td>
<td>
<p>Character string specifying a likelihood, if unspecified
will be inferred from the data (see details)</p>
</td></tr>
<tr><td><code id="nma_+3A_link">link</code></td>
<td>
<p>Character string specifying a link function, if unspecified will
default to the canonical link (see details)</p>
</td></tr>
<tr><td><code id="nma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling()</a></code>, such as <code>iter</code>,
<code>chains</code>, <code>cores</code>, etc.</p>
</td></tr>
<tr><td><code id="nma_+3A_nodesplit">nodesplit</code></td>
<td>
<p>For <code>consistency = "nodesplit"</code>, the comparison(s) to split
in the node-splitting model(s). Either a length 2 vector giving the
treatments in a single comparison, or a 2 column data frame listing
multiple treatment comparisons to split in turn. By default, all possible
comparisons will be chosen (see <code><a href="#topic+get_nodesplits">get_nodesplits()</a></code>).</p>
</td></tr>
<tr><td><code id="nma_+3A_prior_intercept">prior_intercept</code></td>
<td>
<p>Specification of prior distribution for the intercept</p>
</td></tr>
<tr><td><code id="nma_+3A_prior_trt">prior_trt</code></td>
<td>
<p>Specification of prior distribution for the treatment effects</p>
</td></tr>
<tr><td><code id="nma_+3A_prior_het">prior_het</code></td>
<td>
<p>Specification of prior distribution for the heterogeneity
(if <code>trt_effects = "random"</code>)</p>
</td></tr>
<tr><td><code id="nma_+3A_prior_het_type">prior_het_type</code></td>
<td>
<p>Character string specifying whether the prior
distribution <code>prior_het</code> is placed on the heterogeneity standard deviation
<code class="reqn">\tau</code> (<code>"sd"</code>, the default), variance <code class="reqn">\tau^2</code> (<code>"var"</code>), or
precision <code class="reqn">1/\tau^2</code> (<code>"prec"</code>).</p>
</td></tr>
<tr><td><code id="nma_+3A_prior_reg">prior_reg</code></td>
<td>
<p>Specification of prior distribution for the regression
coefficients (if <code>regression</code> formula specified)</p>
</td></tr>
<tr><td><code id="nma_+3A_prior_aux">prior_aux</code></td>
<td>
<p>Specification of prior distribution for the auxiliary
parameter, if applicable (see details). For <code>likelihood = "gengamma"</code> this
should be a list of prior distributions with elements <code>sigma</code> and <code>k</code>.</p>
</td></tr>
<tr><td><code id="nma_+3A_prior_aux_reg">prior_aux_reg</code></td>
<td>
<p>Specification of prior distribution for the auxiliary
regression parameters, if <code>aux_regression</code> is specified (see details).</p>
</td></tr>
<tr><td><code id="nma_+3A_aux_by">aux_by</code></td>
<td>
<p>Vector of variable names listing the variables to stratify the
auxiliary parameters by. Currently only used for survival models, see
details. Cannot be used with <code>aux_regression</code>.</p>
</td></tr>
<tr><td><code id="nma_+3A_aux_regression">aux_regression</code></td>
<td>
<p>A one-sided model formula giving a regression model for
the auxiliary parameters. Currently only used for survival models, see
details. Cannot be used with <code>aux_by</code>.</p>
</td></tr>
<tr><td><code id="nma_+3A_qr">QR</code></td>
<td>
<p>Logical scalar (default <code>FALSE</code>), whether to apply a QR
decomposition to the model design matrix</p>
</td></tr>
<tr><td><code id="nma_+3A_center">center</code></td>
<td>
<p>Logical scalar (default <code>TRUE</code>), whether to center the
(numeric) regression terms about the overall means</p>
</td></tr>
<tr><td><code id="nma_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>See <a href="#topic+adapt_delta">adapt_delta</a> for details</p>
</td></tr>
<tr><td><code id="nma_+3A_int_thin">int_thin</code></td>
<td>
<p>A single integer value, the thinning factor for returning
cumulative estimates of integration error. Saving cumulative estimates is
disabled by <code>int_thin = 0</code>, which is the default.</p>
</td></tr>
<tr><td><code id="nma_+3A_int_check">int_check</code></td>
<td>
<p>Logical, check sufficient accuracy of numerical integration
by fitting half of the chains with <code>n_int/2</code>? When <code>TRUE</code>, <code>Rhat</code> and
<code>n_eff</code> diagnostic warnings will be given if numerical integration has not
sufficiently converged (suggesting increasing <code>n_int</code> in
<code><a href="#topic+add_integration">add_integration()</a></code>). Default <code>TRUE</code>, but disabled (<code>FALSE</code>) when
<code>int_thin &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="nma_+3A_mspline_degree">mspline_degree</code></td>
<td>
<p>Non-negative integer giving the degree of the M-spline
polynomial for <code>likelihood = "mspline"</code>. Piecewise exponential hazards
(<code>likelihood = "pexp"</code>) are a special case with <code>mspline_degree = 0</code>.</p>
</td></tr>
<tr><td><code id="nma_+3A_n_knots">n_knots</code></td>
<td>
<p>For <code>mspline</code> and <code>pexp</code> likelihoods, a non-negative integer
giving the number of internal knots for partitioning the baseline hazard
into intervals. The knot locations within each study will be determined by
the corresponding quantiles of the observed event times, plus boundary
knots at the earliest entry time (0 with no delayed entry) and the maximum
event/censoring time. For example, with <code>n_knots = 3</code>, the internal knot
locations will be at the 25%, 50%, and 75% quantiles of the observed event
times. The default is <code>n_knots = 7</code>; overfitting is avoided by shrinking
towards a constant hazard with a random walk prior (see details). If
<code>aux_regression</code> is specified then a single set of knot locations will be
calculated across all studies in the network. See <code><a href="#topic+make_knots">make_knots()</a></code> for more
details on the knot positioning algorithms. Ignored when <code>knots</code> is
specified.</p>
</td></tr>
<tr><td><code id="nma_+3A_knots">knots</code></td>
<td>
<p>For <code>mspline</code> and <code>pexp</code> likelihoods, a named list of numeric
vectors of knot locations (including boundary knots) for each of the
studies in the network. Currently, each vector must have the same length
(i.e. each study must use the same number of knots). Alternatively, a
single numeric vector of knot locations can be provided which will be
shared across all studies in the network. If unspecified (the default), the
knots will be chosen based on <code>n_knots</code> as described above. If
<code>aux_regression</code> is specified then <code>knots</code> should be a single numeric
vector of knot locations which will be shared across all studies in the
network. <code><a href="#topic+make_knots">make_knots()</a></code> can be used to help specify <code>knots</code> directly, or to
investigate knot placement prior to model fitting.</p>
</td></tr>
<tr><td><code id="nma_+3A_mspline_basis">mspline_basis</code></td>
<td>
<p>Instead of specifying <code>mspline_degree</code> and <code>n_knots</code> or
<code>knots</code>, a named list of M-spline bases (one for each study) can be
provided with <code>mspline_basis</code> which will be used directly. In this case,
all other M-spline options will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When specifying a model formula in the <code>regression</code> argument, the
usual formula syntax is available (as interpreted by <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code>). The
only additional requirement here is that the special variable <code>.trt</code> should
be used to refer to treatment. For example, effect modifier interactions
should be specified as <code>variable:.trt</code>. Prognostic (main) effects and
interactions can be included together compactly as <code>variable*.trt</code>, which
expands to <code>variable + variable:.trt</code> (plus <code>.trt</code>, which is already in the
NMA model).
</p>
<p>For the advanced user, the additional specials <code>.study</code> and <code>.trtclass</code> are
also available, and refer to studies and (if specified) treatment classes
respectively. When node-splitting models are fitted (<code>consistency = "nodesplit"</code>) the special <code>.omega</code> is available, indicating the arms
to which the node-splitting inconsistency factor is added.
</p>
<p>See <code><a href="#topic+priors">?priors</a></code> for details on prior
specification. Default prior distributions are available, but may not be
appropriate for the particular setting and will raise a warning if used. No
attempt is made to tailor these defaults to the data provided. Please
consider appropriate prior distributions for the particular setting,
accounting for the scales of outcomes and covariates, etc. The function
<code><a href="#topic+plot_prior_posterior">plot_prior_posterior()</a></code> may be useful in examining the influence of the
chosen prior distributions on the posterior distributions, and the
<code><a href="#topic+summary.nma_prior">summary()</a></code> method for <code>nma_prior</code>
objects prints prior intervals.
</p>


<h3>Value</h3>

<p><code>nma()</code> returns a <a href="#topic+stan_nma">stan_nma</a> object, except when <code>consistency = "nodesplit"</code> when a <a href="#topic+nma_nodesplit">nma_nodesplit</a> or <a href="#topic+nma_nodesplit_df">nma_nodesplit_df</a> object is
returned. <code>nma.fit()</code> returns a <a href="rstan.html#topic+stanfit">stanfit</a> object.
</p>


<h3>Likelihoods and link functions</h3>

<p>Currently, the following likelihoods and link functions are supported for
each data type:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Data type</strong> </td><td style="text-align: left;"> <strong>Likelihood</strong> </td><td style="text-align: left;"> <strong>Link function</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Binary</strong> </td><td style="text-align: left;"> <code>bernoulli</code>, <code>bernoulli2</code> </td><td style="text-align: left;"> <code>logit</code>, <code>probit</code>, <code>cloglog</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Count</strong> </td><td style="text-align: left;"> <code>binomial</code>, <code>binomial2</code> </td><td style="text-align: left;"> <code>logit</code>, <code>probit</code>, <code>cloglog</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Rate</strong> </td><td style="text-align: left;"> <code>poisson</code> </td><td style="text-align: left;"> <code>log</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Continuous</strong> </td><td style="text-align: left;"> <code>normal</code> </td><td style="text-align: left;"> <code>identity</code>, <code>log</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Ordered</strong> </td><td style="text-align: left;"> <code>ordered</code> </td><td style="text-align: left;"> <code>logit</code>, <code>probit</code>, <code>cloglog</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Survival</strong> </td><td style="text-align: left;"> <code>exponential</code>, <code>weibull</code>, <code>gompertz</code>, <code>exponential-aft</code>, <code>weibull-aft</code>, <code>lognormal</code>, <code>loglogistic</code>, <code>gamma</code>, <code>gengamma</code>, <code>mspline</code>, <code>pexp</code> </td><td style="text-align: left;"> <code>log</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code>bernoulli2</code> and <code>binomial2</code> likelihoods correspond to a two-parameter
Binomial likelihood for arm-based AgD, which more closely matches the
underlying Poisson Binomial distribution for the summarised aggregate
outcomes in a ML-NMR model than the typical (one parameter) Binomial
distribution (see Phillippo et al. 2020).
</p>
<p>When a <code>cloglog</code> link is used, including an offset for log follow-up time
(i.e. <code>regression = ~offset(log(time))</code>) results in a model on the log
hazard (see Dias et al. 2011).
</p>
<p>For survival data, all accelerated failure time models (<code>exponential-aft</code>,
<code>weibull-aft</code>, <code>lognormal</code>, <code>loglogistic</code>, <code>gamma</code>, <code>gengamma</code>) are
parameterised so that the treatment effects and any regression parameters
are log Survival Time Ratios (i.e. a coefficient of <code class="reqn">\log(2)</code> means
that the treatment or covariate is associated with a doubling of expected
survival time). These can be converted to log Acceleration Factors using
the relation <code class="reqn">\log(\mathrm{AF}) = -\log(\mathrm{STR})</code> (or equivalently
<code class="reqn">\mathrm{AF} = 1/\mathrm{STR}</code>).
</p>
<p>Further details on each likelihood and link function are given by
Dias et al. (2011).
</p>


<h3>Auxiliary parameters</h3>

<p>Auxiliary parameters are only present in the following models.
</p>


<h4>Normal likelihood with IPD</h4>

<p>When a Normal likelihood is fitted to IPD, the auxiliary parameters are the
arm-level standard deviations <code class="reqn">\sigma_{jk}</code> on treatment <code class="reqn">k</code> in
study <code class="reqn">j</code>.
</p>



<h4>Ordered multinomial likelihood</h4>

<p>When fitting a model to <code class="reqn">M</code> ordered outcomes, the auxiliary parameters
are the latent cutoffs between each category, <code class="reqn">c_0 &lt; c_1 &lt; \dots &lt;
  c_M</code>. Only <code class="reqn">c_2</code> to <code class="reqn">c_{M-1}</code> are estimated; we fix <code class="reqn">c_0 =
  -\infty</code>, <code class="reqn">c_1 = 0</code>, and <code class="reqn">c_M = \infty</code>. When specifying priors for
these latent cutoffs, we choose to specify priors on the <em>differences</em>
<code class="reqn">c_{m+1} - c_m</code>. Stan automatically truncates any priors so that the
ordering constraints are satisfied.
</p>



<h4>Survival (time-to-event) likelihoods</h4>

<p>All survival likelihoods except the <code>exponential</code> and <code>exponential-aft</code>
likelihoods have auxiliary parameters. These are typically study-specific
shape parameters <code class="reqn">\gamma_j&gt;0</code>, except for the <code>lognormal</code> likelihood
where the auxiliary parameters are study-specific standard deviations on
the log scale <code class="reqn">\sigma_j&gt;0</code>.
</p>
<p>The <code>gengamma</code> likelihood has two sets of auxiliary parameters,
study-specific scale parameters <code class="reqn">\sigma_j&gt;0</code> and shape parameters
<code class="reqn">k_j</code>, following the parameterisation of
Lawless (1980), which permits a range of
behaviours for the baseline hazard including increasing, decreasing,
bathtub and arc-shaped hazards. This parameterisation is related to that
discussed by Cox et al. (2007) and implemented in the
<code>flexsurv</code> package with <code class="reqn">Q = k^{-0.5}</code>. The parameterisation used here
effectively bounds the shape parameter <code class="reqn">k</code> away from numerical
instabilities as <code class="reqn">k \rightarrow \infty</code> (i.e. away from <code class="reqn">Q
  \rightarrow 0</code>, the log-Normal distribution) via the prior distribution.
Implicitly, this parameterisation is restricted to <code class="reqn">Q &gt; 0</code> and so
certain survival distributions like the inverse-Gamma and inverse-Weibull
are not part of the parameter space; however, <code class="reqn">Q &gt; 0</code> still encompasses
the other survival distributions implemented in this package.
</p>
<p>For the <code>mspline</code> and <code>pexp</code> likelihoods, the auxiliary parameters are the
spline coefficients for each study. These form a unit simplex (i.e. lie
between 0 and 1, and sum to 1), and are given a random walk prior
distribution. <code>prior_aux</code> specifies the hyperprior on the random walk
standard deviation <code class="reqn">\sigma</code> which controls the level of smoothing of
the baseline hazard, with <code class="reqn">\sigma = 0</code> corresponding to a constant
baseline hazard.
</p>
<p>The auxiliary parameters can be stratified by additional factors through
the <code>aux_by</code> argument. For example, to allow the shape of the baseline
hazard to vary between treatment arms as well as studies, use <code>aux_by = c(".study", ".trt")</code>. (Technically, <code>.study</code> is always included in the
stratification even if omitted from <code>aux_by</code>, but we choose here to make
the stratification explicit.) This is a common way of relaxing the
proportional hazards assumption. The default is equivalent to <code>aux_by = ".study"</code> which stratifies the auxiliary parameters by study, as described
above.
</p>
<p>A regression model may be specified on the auxiliary parameters using
<code>aux_regression</code>. This is useful if we wish to model departures from
non-proportionality, rather than allowing the baseline hazards to be
completely independent using <code>aux_by</code>. This is necessary if absolute
predictions (e.g. survival curves) are required in a population for
unobserved combinations of covariates; for example, if <code>aux_by = .trt</code> then
absolute predictions may only be produced for the observed treatment arms
in each study population, whereas if <code>aux_regression = ~.trt</code> then absolute
predictions can be produced for all treatments in any population. For
<code>mspline</code> and <code>pexp</code> likelihoods, the regression coefficients are smoothed
over time using a random walk prior to avoid overfitting: <code>prior_aux_reg</code>
specifies the hyperprior for the random walk standard deviation. For other
parametric likelihoods, <code>prior_aux_reg</code> specifies the prior for the
auxiliary regression coefficients.
</p>



<h3>References</h3>

<p>Cox C, Chu H, Schneider MF, Muñoz A (2007).
&ldquo;Parametric survival analysis and taxonomy of hazard functions for the generalized gamma distribution.&rdquo;
<em>Statistics in Medicine</em>, <b>26</b>(23), 4352&ndash;4374.
<a href="https://doi.org/10.1002/sim.2836">doi:10.1002/sim.2836</a>.<br /><br /> Dias S, Welton NJ, Sutton AJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 2: A generalised linear modelling framework for pair-wise and network meta-analysis of randomised controlled trials.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.<br /><br /> Lawless JF (1980).
&ldquo;Inference in the Generalized Gamma and Log Gamma Distributions.&rdquo;
<em>Technometrics</em>, <b>22</b>(3), 409&ndash;419.
<a href="https://doi.org/10.1080/00401706.1980.10486173">doi:10.1080/00401706.1980.10486173</a>.<br /><br /> Phillippo DM, Dias S, Ades AE, Belger M, Brnabic A, Schacht A, Saure D, Kadziola Z, Welton NJ (2020).
&ldquo;Multilevel Network Meta-Regression for population-adjusted treatment comparisons.&rdquo;
<em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em>, <b>183</b>(3), 1189&ndash;1210.
<a href="https://doi.org/10.1111/rssa.12579">doi:10.1111/rssa.12579</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation NMA
# Set up network of smoking cessation data
head(smoking)

smk_net &lt;- set_agd_arm(smoking,
                       study = studyn,
                       trt = trtc,
                       r = r,
                       n = n,
                       trt_ref = "No intervention")

# Print details
smk_net


# Fitting a fixed effect model
smk_fit_FE &lt;- nma(smk_net, 
                  trt_effects = "fixed",
                  prior_intercept = normal(scale = 100),
                  prior_trt = normal(scale = 100))

smk_fit_FE



# Fitting a random effects model
smk_fit_RE &lt;- nma(smk_net, 
                  trt_effects = "random",
                  prior_intercept = normal(scale = 100),
                  prior_trt = normal(scale = 100),
                  prior_het = normal(scale = 5))

smk_fit_RE



# Fitting an unrelated mean effects (inconsistency) model
smk_fit_RE_UME &lt;- nma(smk_net, 
                      consistency = "ume",
                      trt_effects = "random",
                      prior_intercept = normal(scale = 100),
                      prior_trt = normal(scale = 100),
                      prior_het = normal(scale = 5))

smk_fit_RE_UME



# Fitting all possible node-splitting models
smk_fit_RE_nodesplit &lt;- nma(smk_net, 
                            consistency = "nodesplit",
                            trt_effects = "random",
                            prior_intercept = normal(scale = 100),
                            prior_trt = normal(scale = 100),
                            prior_het = normal(scale = 5))



# Summarise the node-splitting results
summary(smk_fit_RE_nodesplit)


## Plaque psoriasis ML-NMR
# Set up plaque psoriasis network combining IPD and AgD
library(dplyr)
pso_ipd &lt;- filter(plaque_psoriasis_ipd,
                  studyc %in% c("UNCOVER-1", "UNCOVER-2", "UNCOVER-3"))

pso_agd &lt;- filter(plaque_psoriasis_agd,
                  studyc == "FIXTURE")

head(pso_ipd)
head(pso_agd)

pso_ipd &lt;- pso_ipd %&gt;%
  mutate(# Variable transformations
    bsa = bsa / 100,
    prevsys = as.numeric(prevsys),
    psa = as.numeric(psa),
    weight = weight / 10,
    durnpso = durnpso / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                         trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                         trtn == 4 ~ "TNFa blocker"),
    # Check complete cases for covariates of interest
    complete = complete.cases(durnpso, prevsys, bsa, weight, psa)
  )

pso_agd &lt;- pso_agd %&gt;%
  mutate(
    # Variable transformations
    bsa_mean = bsa_mean / 100,
    bsa_sd = bsa_sd / 100,
    prevsys = prevsys / 100,
    psa = psa / 100,
    weight_mean = weight_mean / 10,
    weight_sd = weight_sd / 10,
    durnpso_mean = durnpso_mean / 10,
    durnpso_sd = durnpso_sd / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                         trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                         trtn == 4 ~ "TNFa blocker")
  )

# Exclude small number of individuals with missing covariates
pso_ipd &lt;- filter(pso_ipd, complete)

pso_net &lt;- combine_network(
  set_ipd(pso_ipd,
          study = studyc,
          trt = trtc,
          r = pasi75,
          trt_class = trtclass),
  set_agd_arm(pso_agd,
              study = studyc,
              trt = trtc,
              r = pasi75_r,
              n = pasi75_n,
              trt_class = trtclass)
)

# Print network details
pso_net

# Add integration points to the network
pso_net &lt;- add_integration(pso_net,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  n_int = 64)


# Fitting a ML-NMR model.
# Specify a regression model to include effect modifier interactions for five
# covariates, along with main (prognostic) effects. We use a probit link and
# specify that the two-parameter Binomial approximation for the aggregate-level
# likelihood should be used. We set treatment-covariate interactions to be equal
# within each class. We narrow the possible range for random initial values with
# init_r = 0.1, since probit models in particular are often hard to initialise.
# Using the QR decomposition greatly improves sampling efficiency here, as is
# often the case for regression models.
pso_fit &lt;- nma(pso_net, 
               trt_effects = "fixed",
               link = "probit",
               likelihood = "bernoulli2",
               regression = ~(durnpso + prevsys + bsa + weight + psa)*.trt,
               class_interactions = "common",
               prior_intercept = normal(scale = 10),
               prior_trt = normal(scale = 10),
               prior_reg = normal(scale = 10),
               init_r = 0.1,
               QR = TRUE)
pso_fit


## Newly-diagnosed multiple myeloma NMA
# Set up newly-diagnosed multiple myeloma network

head(ndmm_ipd)
head(ndmm_agd)

ndmm_net &lt;- combine_network(
  set_ipd(ndmm_ipd,
          study, trt,
          Surv = Surv(eventtime / 12, status)),
  set_agd_surv(ndmm_agd,
               study, trt,
               Surv = Surv(eventtime / 12, status),
               covariates = ndmm_agd_covs))

# Fit Weibull (PH) model
ndmm_fit &lt;- nma(ndmm_net, 
                likelihood = "weibull",
                prior_intercept = normal(scale = 100),
                prior_trt = normal(scale = 10),
                prior_aux = half_normal(scale = 10))

ndmm_fit

</code></pre>

<hr>
<h2 id='nma_data-class'>The nma_data class</h2><span id='topic+nma_data-class'></span><span id='topic+nma_data'></span><span id='topic+mlnmr_data'></span><span id='topic+mlnmr_data-class'></span>

<h3>Description</h3>

<p>The <code>nma_data</code> class contains the data for a NMA in a standard format,
created using the functions <code><a href="#topic+set_ipd">set_ipd()</a></code>, <code><a href="#topic+set_agd_arm">set_agd_arm()</a></code>,
<code><a href="#topic+set_agd_contrast">set_agd_contrast()</a></code>, <code><a href="#topic+set_agd_surv">set_agd_surv()</a></code>, or <code><a href="#topic+combine_network">combine_network()</a></code>. The sub-class
<code>mlnmr_data</code> is created by the function <code><a href="#topic+add_integration">add_integration()</a></code>, and further
contains numerical integration points for the aggregate data.
</p>


<h3>Details</h3>

<p>Objects of class <code>nma_data</code> have the following components:
</p>

<dl>
<dt><code>agd_arm</code></dt><dd><p>data from studies with aggregate data (arm format)</p>
</dd>
<dt><code>agd_contrast</code></dt><dd><p>data from studies with aggregate data (contrast
format)</p>
</dd>
<dt><code>ipd</code></dt><dd><p>data from studies with individual patient data</p>
</dd>
<dt><code>treatments</code></dt><dd><p>treatment coding factor for entire network</p>
</dd>
<dt><code>classes</code></dt><dd><p>treatment class coding factor (same length as <code>treatments</code>
for entire network)</p>
</dd>
<dt><code>studies</code></dt><dd><p>study coding factor for entire network</p>
</dd>
<dt><code>outcome</code></dt><dd><p>outcome type for each data source, named list</p>
</dd>
</dl>

<p>The <code>agd_arm</code>, <code>agd_contrast</code>, and <code>ipd</code> components are
tibbles with the following columns:
</p>

<dl>
<dt><code>.study</code></dt><dd><p>study (as factor)</p>
</dd>
<dt><code>.trt</code></dt><dd><p>treatment (as factor)</p>
</dd>
<dt><code>.trtclass</code></dt><dd><p>treatment class (as factor), if specified</p>
</dd>
<dt><code>.y</code></dt><dd><p>continuous outcome</p>
</dd>
<dt><code>.se</code></dt><dd><p>standard error (continuous)</p>
</dd>
<dt><code>.r</code></dt><dd><p>event count (discrete)</p>
</dd>
<dt><code>.n</code></dt><dd><p>event count denominator (discrete, <code>agd_arm</code> only)</p>
</dd>
<dt><code>.E</code></dt><dd><p>time at risk (discrete)</p>
</dd>
<dt><code>.Surv</code></dt><dd><p>survival outcome of type <code><a href="#topic+Surv">Surv</a></code> (time-to-event), nested by
study arm</p>
</dd>
<dt><code>.sample_size</code></dt><dd><p>sample size (<code style="white-space: pre;">&#8288;agd_*&#8288;</code> only)</p>
</dd>
<dt><code>...</code></dt><dd><p>other columns (typically covariates) from the original data
frame</p>
</dd>
</dl>

<p>Objects of class <code>mlnmr_data</code> additionally have components:
</p>

<dl>
<dt><code>n_int</code></dt><dd><p>number of numerical integration points</p>
</dd>
<dt><code>int_names</code></dt><dd><p>names of covariates with numerical integration points</p>
</dd>
<dt><code>int_cor</code></dt><dd><p>correlation matrix for covariates used to generate
numerical integration points</p>
</dd>
</dl>

<p>The <code>agd_arm</code> and <code>agd_contrast</code> tibbles have additional list columns with
prefix <code>.int_</code>, one for each covariate, which contain the numerical
integration points nested as length-<code>n_int</code> vectors within each row.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.nma_data">print.nma_data()</a></code> for the print method displaying details of the
network, and <code><a href="#topic+plot.nma_data">plot.nma_data()</a></code> for network plots.
</p>

<hr>
<h2 id='nma_dic-class'>The nma_dic class</h2><span id='topic+nma_dic-class'></span><span id='topic+nma_dic'></span>

<h3>Description</h3>

<p>The <code>nma_dic</code> class contains details of the Deviance Information Criterion
(DIC), produced using the <code><a href="#topic+dic">dic()</a></code> function.
</p>


<h3>Details</h3>

<p>Objects of class <code>nma_dic</code> have the following components:
</p>

<dl>
<dt><code>dic</code></dt><dd><p>The DIC value</p>
</dd>
<dt><code>pd</code>, <code>pv</code></dt><dd><p>The effective number of parameters</p>
</dd>
<dt><code>resdev</code></dt><dd><p>The total residual deviance</p>
</dd>
<dt><code>pointwise</code></dt><dd><p>A list of data frames containing the pointwise
contributions for the IPD and AgD.</p>
</dd>
<dt><code>resdev_array</code></dt><dd><p>A 3D MCMC array [Iterations, Chains, Parameters] of
posterior residual deviance samples.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+dic">dic()</a></code>, <code><a href="#topic+print.nma_dic">print.nma_dic()</a></code>, <code><a href="#topic+plot.nma_dic">plot.nma_dic()</a></code>.
</p>

<hr>
<h2 id='nma_nodesplit-class'>The nma_nodesplit class</h2><span id='topic+nma_nodesplit-class'></span><span id='topic+nma_nodesplit'></span><span id='topic+nma_nodesplit_df'></span><span id='topic+nma_nodesplit_df-class'></span>

<h3>Description</h3>

<p>The <code>nma_nodesplit</code> and <code>nma_nodesplit_df</code> classes contains the results from
running a node-splitting model with the function <code><a href="#topic+nma">nma()</a></code>.
</p>


<h3>Details</h3>

<p>Objects of class <code>nma_nodesplit</code> inherit from the <a href="#topic+stan_nma">stan_nma</a> class,
and contain the results of fitting a single node-split model. They have one
additional component, <code>nodesplit</code>, which gives the comparison that was
node-split as a length 2 vector.
</p>
<p>Objects of class <code>nma_nodesplit_df</code> are tibble data frames with one row
for each node-split comparison and columns:
</p>

<dl>
<dt><code>trt1</code>, <code>trt2</code></dt><dd><p>Treatments forming the comparison</p>
</dd>
<dt><code>model</code></dt><dd><p>A list column containing the results of each model as a
<code>nma_nodesplit</code> object</p>
</dd>
</dl>

<p>Optionally, there will be an additional row for the consistency model if
this was fitted (e.g. by <code>get_nodesplits(., include_consistency = TRUE)</code>)
with <code>trt1</code> and <code>trt2</code> both <code>NA</code>.
</p>

<hr>
<h2 id='nma_prior-class'>The nma_prior class</h2><span id='topic+nma_prior-class'></span><span id='topic+nma_prior'></span>

<h3>Description</h3>

<p>The <code>nma_prior</code> class is used to specify prior distributions.
</p>


<h3>Details</h3>

<p>Objects of class <code>nma_prior</code> have the following components:
</p>

<dl>
<dt><code>dist</code></dt><dd><p>Distribution name</p>
</dd>
<dt><code>fun</code></dt><dd><p>Name of constructor function, as string (e.g. <code>"normal"</code>)</p>
</dd>
<dt><code>...</code></dt><dd><p>Parameters of the distribution</p>
</dd>
</dl>

<p>The distribution parameters, specified as named components in <code>...</code>, match
those in the constructor functions (see <a href="#topic+priors">priors</a>).
</p>

<hr>
<h2 id='nma_summary-class'>The <code>nma_summary</code> class</h2><span id='topic+nma_summary-class'></span><span id='topic+nma_summary'></span><span id='topic+nma_rank_probs'></span>

<h3>Description</h3>

<p>The <code>nma_summary</code> class contains posterior summary statistics of model
parameters or other quantities of interest, and the draws used to obtain
these statistics.
</p>


<h3>Details</h3>

<p>Objects of class <code>nma_summary</code> have the following components:
</p>

<dl>
<dt>summary</dt><dd><p>A data frame containing the computed summary statistics.
Column <code>.trt</code> indicates the corresponding treatment, or columns <code>.trta</code> and
<code>.trtb</code> indicate the corresponding contrast (<code>.trtb</code> vs. <code>.trta</code>). If a
regression model was fitted with effect modifier interactions with
treatment, these summaries will be study-specific. In this case, the
corresponding study population is indicated in the <code>.study</code> column. If a
multinomial model was fitted, the <code>.category</code> column indicates the
corresponding category.</p>
</dd>
<dt>sims</dt><dd><p>A 3D array [Iteration, Chain, Parameter] of MCMC
simulations</p>
</dd>
<dt>studies</dt><dd><p>(Optional) A data frame containing study information,
printed along with the corresponding summary statistics if <code>summary</code>
contains a <code>.study</code> column. Should have a matching <code>.study</code> column.</p>
</dd>
</dl>

<p>The following attributes may also be set:
</p>

<dl>
<dt>xlab</dt><dd><p>Label for x axis in plots, usually either <code>"Treatment"</code> or
<code>"Contrast"</code>.</p>
</dd>
<dt>ylab</dt><dd><p>Label for y axis in plots, usually used for the scale e.g.
<code>"log Odds Ratio"</code>.</p>
</dd>
</dl>

<p>The subclass <code>nma_rank_probs</code> is used by the function
<code><a href="#topic+posterior_rank_probs">posterior_rank_probs()</a></code>, and contains posterior rank probabilities. This
subclass does not have a <code>sims</code> component, as the rank probabilities are
themselves posterior summaries of the ranks (i.e. they do not have a
posterior distribution). The posterior ranks from which the rank
probabilities are calculated may be obtained from <code><a href="#topic+posterior_ranks">posterior_ranks()</a></code>.
</p>

<hr>
<h2 id='nodesplit_summary-class'>The <code>nodesplit_summary</code> class</h2><span id='topic+nodesplit_summary-class'></span><span id='topic+nodesplit_summary'></span>

<h3>Description</h3>

<p>The <code>nodesplit_summary</code> class contains posterior summary statistics for
node-splitting models, as a result of calling <code>summary()</code> on a
<code>nma_nodesplit</code> or <code>nma_nodesplit_df</code> object.
</p>


<h3>Details</h3>

<p>Objects of class <code>nodesplit_summary</code> are tibble data frames, with one row
for each node-split comparison and columns:
</p>

<dl>
<dt><code>trt1</code>, <code>trt2</code></dt><dd><p>Treatments forming the comparison</p>
</dd>
<dt><code>summary</code></dt><dd><p>A list column containing <a href="#topic+nma_summary">nma_summary</a> objects with the
posterior summaries and draws for each of the node-splitting parameters</p>
</dd>
<dt><code>p_value</code></dt><dd><p>Bayesian p-value for inconsistency</p>
</dd>
<dt><code>dic</code></dt><dd><p>A list column containing <a href="#topic+nma_dic">nma_dic</a> objects, giving the model
fit statistics</p>
</dd>
</dl>

<p>The parameters included in <code>summary</code> are:
</p>

<dl>
<dt><code>d_net</code></dt><dd><p>Network estimate from the corresponding consistency model,
if available</p>
</dd>
<dt><code>d_dir</code></dt><dd><p>Direct estimate from the node-splitting model</p>
</dd>
<dt><code>d_ind</code></dt><dd><p>Indirect estimate from the node-splitting model</p>
</dd>
<dt><code>omega</code></dt><dd><p>Inconsistency factor <code class="reqn">\omega = d_\mathrm{dir} -
  d_\mathrm{ind}</code></p>
</dd>
<dt><code>tau</code></dt><dd><p>Heterogeneity standard deviation from the node-splitting
model, if a random effects model was fitted</p>
</dd>
<dt><code>tau_consistency</code></dt><dd><p>Heterogeneity standard deviation from the
corresponding consistency model, if available and if a random effects model
was fitted</p>
</dd>
</dl>


<hr>
<h2 id='pairs.stan_nma'>Matrix of plots for a <code>stan_nma</code> object</h2><span id='topic+pairs.stan_nma'></span>

<h3>Description</h3>

<p>A <code><a href="graphics.html#topic+pairs">pairs()</a></code> method for <code>stan_nma</code> objects, which calls
<code><a href="bayesplot.html#topic+MCMC-scatterplots">bayesplot::mcmc_pairs()</a></code> on the
underlying <code>stanfit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stan_nma'
pairs(x, ..., pars, include = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.stan_nma_+3A_x">x</code></td>
<td>
<p>An object of class <code>stan_nma</code></p>
</td></tr>
<tr><td><code id="pairs.stan_nma_+3A_...">...</code></td>
<td>
<p>Other arguments passed to
<code><a href="bayesplot.html#topic+MCMC-scatterplots">bayesplot::mcmc_pairs()</a></code></p>
</td></tr>
<tr><td><code id="pairs.stan_nma_+3A_pars">pars</code></td>
<td>
<p>Optional character vector of parameter names to include in
output. If not specified, all parameters are used.</p>
</td></tr>
<tr><td><code id="pairs.stan_nma_+3A_include">include</code></td>
<td>
<p>Logical, are parameters in <code>pars</code> to be included (<code>TRUE</code>,
default) or excluded (<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid of ggplot objects produced by
<code><a href="bayesplot.html#topic+MCMC-scatterplots">bayesplot::mcmc_pairs()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Parkinson's mean off time reduction
park_net &lt;- set_agd_arm(parkinsons,
                        study = studyn,
                        trt = trtn,
                        y = y,
                        se = se,
                        sample_size = n)

# Fitting a RE model
park_fit_RE &lt;- nma(park_net,
                   trt_effects = "random",
                   prior_intercept = normal(scale = 100),
                   prior_trt = normal(scale = 100),
                   prior_het = half_normal(scale = 5))

# We see a small number of divergent transition errors
# These do not go away entirely when adapt_delta is increased

# Try to diagnose with a pairs plot
pairs(park_fit_RE, pars = c("mu[4]", "d[3]", "delta[4: 3]", "tau"))

# Transforming tau onto log scale
pairs(park_fit_RE, pars = c("mu[4]", "d[3]", "delta[4: 3]", "tau"),
      transformations = list(tau = "log"))

# The divergent transitions occur in the upper tail of the heterogeneity
# standard deviation. In this case, with only a small number of studies, there
# is not very much information to estimate the heterogeneity standard deviation
# and the prior distribution may be too heavy-tailed. We could consider a more
# informative prior distribution for the heterogeneity variance to aid
# estimation.

## End(Not run)

</code></pre>

<hr>
<h2 id='parkinsons'>Mean off-time reduction in Parkison's disease</h2><span id='topic+parkinsons'></span>

<h3>Description</h3>

<p>Data frame containing the mean off-time reduction in patients given dopamine
agonists as adjunct therapy in Parkinson's disease, from 7 trials comparing
four active drugs and placebo (Dias et al. 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parkinsons
</code></pre>


<h3>Format</h3>

<p>A data frame with 15 rows and 7 variables:
</p>

<dl>
<dt>studyn</dt><dd><p>numeric study ID</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code (placebo = 1)</p>
</dd>
<dt>y</dt><dd><p>mean off-time reduction</p>
</dd>
<dt>se</dt><dd><p>standard error</p>
</dd>
<dt>n</dt><dd><p>sample size</p>
</dd>
<dt>diff</dt><dd><p>mean difference vs. treatment in reference arm</p>
</dd>
<dt>se_diff</dt><dd><p>standard error of mean difference, see details</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset may be analysed using either an arm-based likelihood
using <code>y</code> and <code>se</code>, or a contrast-based likelihood using <code>diff</code> and
<code>se_diff</code> (or a combination of the two across different studies).
</p>
<p>The contrast-based data is formatted as described in <code><a href="#topic+set_agd_contrast">set_agd_contrast()</a></code>.
That is, for the chosen reference arm in each study, the mean difference
<code>diff</code> is set to <code>NA</code>, and <code>se_diff</code> is set to the standard error <code>se</code> of
the outcome on the reference arm.
</p>


<h3>References</h3>

<p>Dias S, Welton NJ, Sutton AJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 2: A generalised linear modelling framework for pair-wise and network meta-analysis of randomised controlled trials.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.
</p>

<hr>
<h2 id='plaque_psoriasis_ipd'>Plaque psoriasis data</h2><span id='topic+plaque_psoriasis_ipd'></span><span id='topic+plaque_psoriasis'></span><span id='topic+plaque_psoriasis_agd'></span>

<h3>Description</h3>

<p>Two data frames, <code>plaque_psoriasis_ipd</code> and <code>plaque_psoriasis_agd</code>,
containing (simulated) individual patient data from four studies and
aggregate data from five studies (Phillippo 2019).
Outcomes are binary success/failure to achieve 75%, 90%, or 100% reduction in
symptoms on the Psoriasis Area and Severity Index (PASI) scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plaque_psoriasis_ipd

plaque_psoriasis_agd
</code></pre>


<h3>Format</h3>

<p>The individual patient data are contained in a data frame
<code>plaque_psoriasis_ipd</code> with 4118 rows, one per individual, and 16 variables:
</p>

<dl>
<dt>studyc</dt><dd><p>study name</p>
</dd>
<dt>trtc_long</dt><dd><p>treatment name (long format)</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>pasi75</dt><dd><p>binary PASI 75 outcome</p>
</dd>
<dt>pasi90</dt><dd><p>binary PASI 90 outcome</p>
</dd>
<dt>pasi100</dt><dd><p>binary PASI 100 outcome</p>
</dd>
<dt>age</dt><dd><p>age (years)</p>
</dd>
<dt>bmi</dt><dd><p>body mass index (BMI)</p>
</dd>
<dt>pasi_w0</dt><dd><p>PASI score at week 0</p>
</dd>
<dt>male</dt><dd><p>male sex (TRUE or FALSE)</p>
</dd>
<dt>bsa</dt><dd><p>body surface area (percent)</p>
</dd>
<dt>weight</dt><dd><p>weight (kilograms)</p>
</dd>
<dt>durnpso</dt><dd><p>duration of psoriasis (years)</p>
</dd>
<dt>prevsys</dt><dd><p>previous systemic treatment (TRUE or FALSE)</p>
</dd>
<dt>psa</dt><dd><p>psoriatic arthritis (TRUE or FALSE)</p>
</dd>
</dl>

<p>The aggregate data are contained in a data frame <code>plaque_psoriasis_agd</code> with 15
rows, one per study arm, and 26 variables:
</p>

<dl>
<dt>studyc</dt><dd><p>study name</p>
</dd>
<dt>trtc_long</dt><dd><p>treatment name (long format)</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>pasi75_r, pasi75_n</dt><dd><p>PASI 75 outcome count and denominator</p>
</dd>
<dt>pasi90_r, pasi90_n</dt><dd><p>PASI 75 outcome count and denominator</p>
</dd>
<dt>pasi100_r, pasi100_n</dt><dd><p>PASI 75 outcome count and denominator</p>
</dd>
<dt>sample_size_w0</dt><dd><p>sample size at week zero</p>
</dd>
<dt>age_mean, age_sd</dt><dd><p>mean and standard deviation of age (years)</p>
</dd>
<dt>bmi_mean, bmi_sd</dt><dd><p>mean and standard deviation of BMI</p>
</dd>
<dt>pasi_w0_mean, pasi_w0_sd</dt><dd><p>mean and standard deviation of PASI score at week 0</p>
</dd>
<dt>male</dt><dd><p>percentage of males</p>
</dd>
<dt>bsa_mean, bsa_sd</dt><dd><p>mean and standard deviation of body surface area (percent)</p>
</dd>
<dt>weight_mean, weight_sd</dt><dd><p>mean and standard deviation of weight (kilograms)</p>
</dd>
<dt>durnpso_mean, durnpso_sd</dt><dd><p>mean and standard deviation of duration of psoriasis (years)</p>
</dd>
<dt>prevsys</dt><dd><p>percentage of individuals with previous systemic treatment</p>
</dd>
<dt>psa</dt><dd><p>percentage of individuals with psoriatic arthritis</p>
</dd>
</dl>

<p>An object of class <code>data.frame</code> with 15 rows and 26 columns.
</p>


<h3>References</h3>

<p>Phillippo DM (2019).
<em>Calibration of Treatment Effects in Network Meta-Analysis using Individual Patient Data</em>.
Ph.D. thesis, University of Bristol.
Available from <a href="https://research-information.bris.ac.uk/">https://research-information.bris.ac.uk/</a>.
</p>

<hr>
<h2 id='plot_integration_error'>Plot numerical integration error</h2><span id='topic+plot_integration_error'></span>

<h3>Description</h3>

<p>For ML-NMR models, plot the estimated numerical integration error over the
entire posterior distribution, as the number of integration points increases.
See (Phillippo et al. 2020; Phillippo 2019) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_integration_error(
  x,
  ...,
  stat = "violin",
  orientation = c("vertical", "horizontal", "x", "y"),
  show_expected_rate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_integration_error_+3A_x">x</code></td>
<td>
<p>An object of type <code>stan_mlnmr</code></p>
</td></tr>
<tr><td><code id="plot_integration_error_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>ggdist</code> plot stat.</p>
</td></tr>
<tr><td><code id="plot_integration_error_+3A_stat">stat</code></td>
<td>
<p>Character string specifying the <code>ggdist</code> plot stat used to
summarise the integration error over the posterior. Default is <code>"violin"</code>,
which is equivalent to <code>"eye"</code> with some cosmetic tweaks.</p>
</td></tr>
<tr><td><code id="plot_integration_error_+3A_orientation">orientation</code></td>
<td>
<p>Whether the <code>ggdist</code> geom is drawn horizontally
(<code>"horizontal"</code>) or vertically (<code>"vertical"</code>), default <code>"vertical"</code></p>
</td></tr>
<tr><td><code id="plot_integration_error_+3A_show_expected_rate">show_expected_rate</code></td>
<td>
<p>Logical, show typical convergence rate <code class="reqn">1/N</code>?
Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total number of integration points is set by the <code>n_int</code>
argument to <code><a href="#topic+add_integration">add_integration()</a></code>, and the intervals at which integration
error is estimated are set by the <code>int_thin</code> argument to <code><a href="#topic+nma">nma()</a></code>. The
typical convergence rate of Quasi-Monte Carlo integration (as used here) is
<code class="reqn">1/N</code>, which by default is displayed on the plot output.
</p>
<p>The integration error at each thinning interval <code class="reqn">N_\mathrm{thin}</code> is
estimated for each point in the posterior distribution by subtracting the
final estimate (using all <code>n_int</code> points) from the estimate using only the
first <code class="reqn">N_\mathrm{thin}</code> points.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Note for survival models</h3>

<p>This function is not supported for survival/time-to-event models. These do
not save cumulative integration points for efficiency reasons (both time and
memory).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plaque psoriasis ML-NMR
# Set up plaque psoriasis network combining IPD and AgD
library(dplyr)
pso_ipd &lt;- filter(plaque_psoriasis_ipd,
                  studyc %in% c("UNCOVER-1", "UNCOVER-2", "UNCOVER-3"))

pso_agd &lt;- filter(plaque_psoriasis_agd,
                  studyc == "FIXTURE")

head(pso_ipd)
head(pso_agd)

pso_ipd &lt;- pso_ipd %&gt;%
  mutate(# Variable transformations
    bsa = bsa / 100,
    prevsys = as.numeric(prevsys),
    psa = as.numeric(psa),
    weight = weight / 10,
    durnpso = durnpso / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                         trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                         trtn == 4 ~ "TNFa blocker"),
    # Check complete cases for covariates of interest
    complete = complete.cases(durnpso, prevsys, bsa, weight, psa)
  )

pso_agd &lt;- pso_agd %&gt;%
  mutate(
    # Variable transformations
    bsa_mean = bsa_mean / 100,
    bsa_sd = bsa_sd / 100,
    prevsys = prevsys / 100,
    psa = psa / 100,
    weight_mean = weight_mean / 10,
    weight_sd = weight_sd / 10,
    durnpso_mean = durnpso_mean / 10,
    durnpso_sd = durnpso_sd / 10,
    # Treatment classes
    trtclass = case_when(trtn == 1 ~ "Placebo",
                         trtn %in% c(2, 3, 5, 6) ~ "IL blocker",
                         trtn == 4 ~ "TNFa blocker")
  )

# Exclude small number of individuals with missing covariates
pso_ipd &lt;- filter(pso_ipd, complete)

pso_net &lt;- combine_network(
  set_ipd(pso_ipd,
          study = studyc,
          trt = trtc,
          r = pasi75,
          trt_class = trtclass),
  set_agd_arm(pso_agd,
              study = studyc,
              trt = trtc,
              r = pasi75_r,
              n = pasi75_n,
              trt_class = trtclass)
)

# Print network details
pso_net

# Add integration points to the network
pso_net &lt;- add_integration(pso_net,
  durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
  prevsys = distr(qbern, prob = prevsys),
  bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
  weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
  psa = distr(qbern, prob = psa),
  n_int = 64)


# Fit the ML-NMR model
pso_fit &lt;- nma(pso_net, 
               trt_effects = "fixed",
               link = "probit",
               likelihood = "bernoulli2",
               regression = ~(durnpso + prevsys + bsa + weight + psa)*.trt,
               class_interactions = "common",
               prior_intercept = normal(scale = 10),
               prior_trt = normal(scale = 10),
               prior_reg = normal(scale = 10),
               init_r = 0.1,
               QR = TRUE,
               # Set the thinning factor for saving the cumulative results
               # (This also sets int_check = FALSE)
               int_thin = 8)
pso_fit

# Plot numerical integration error
plot_integration_error(pso_fit)

</code></pre>

<hr>
<h2 id='plot_prior_posterior'>Plot prior vs posterior distribution</h2><span id='topic+plot_prior_posterior'></span>

<h3>Description</h3>

<p>Produce plots comparing the prior and posterior distributions of model
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_prior_posterior(
  x,
  ...,
  prior = NULL,
  post_args = list(),
  prior_args = list(),
  overlay = c("prior", "posterior"),
  ref_line = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_prior_posterior_+3A_x">x</code></td>
<td>
<p>A <code>stan_nma</code> object</p>
</td></tr>
<tr><td><code id="plot_prior_posterior_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods</p>
</td></tr>
<tr><td><code id="plot_prior_posterior_+3A_prior">prior</code></td>
<td>
<p>Character vector selecting the prior and posterior
distribution(s) to plot. May include <code>"intercept"</code>, <code>"trt"</code>, <code>"het"</code>,
<code>"reg"</code>, or <code>"aux"</code>, as appropriate.</p>
</td></tr>
<tr><td><code id="plot_prior_posterior_+3A_post_args">post_args</code></td>
<td>
<p>List of arguments passed on to <a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram</a> to
control plot output for the posterior distribution</p>
</td></tr>
<tr><td><code id="plot_prior_posterior_+3A_prior_args">prior_args</code></td>
<td>
<p>List of arguments passed on to <a href="ggplot2.html#topic+geom_path">ggplot2::geom_path</a> to
control plot output for the prior distribution. Additionally, <code>n</code> controls
the number of points the density curve is evaluated at (default <code>500</code>), and
<code>p_limits</code> controls the endpoints of the curve as quantiles (default
<code>c(.001, .999)</code>).</p>
</td></tr>
<tr><td><code id="plot_prior_posterior_+3A_overlay">overlay</code></td>
<td>
<p>String, should prior or posterior be shown on top? Default
<code>"prior"</code>.</p>
</td></tr>
<tr><td><code id="plot_prior_posterior_+3A_ref_line">ref_line</code></td>
<td>
<p>Numeric vector of positions for reference lines, by default
no reference lines are drawn</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prior distributions are displayed as lines, posterior distributions
are displayed as histograms.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation NMA

# Run smoking RE NMA example if not already available
if (!exists("smk_fit_RE")) example("example_smk_re", run.donttest = TRUE)


# Plot prior vs. posterior, by default all parameters are plotted
plot_prior_posterior(smk_fit_RE)

# Plot prior vs. posterior for heterogeneity SD only
plot_prior_posterior(smk_fit_RE, prior = "het")

# Customise plot
plot_prior_posterior(smk_fit_RE, prior = "het",
                     prior_args = list(colour = "darkred", size = 2),
                     post_args = list(alpha = 0.6))


</code></pre>

<hr>
<h2 id='plot.nma_data'>Network plots</h2><span id='topic+plot.nma_data'></span>

<h3>Description</h3>

<p>Create a network plot from a <code>nma_data</code> network object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma_data'
plot(
  x,
  ...,
  layout,
  circular,
  weight_edges = TRUE,
  weight_nodes = FALSE,
  show_trt_class = FALSE,
  nudge = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nma_data_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+nma_data">nma_data</a> object to plot</p>
</td></tr>
<tr><td><code id="plot.nma_data_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggraph.html#topic+ggraph">ggraph()</a></code> and on to the layout
function</p>
</td></tr>
<tr><td><code id="plot.nma_data_+3A_layout">layout</code></td>
<td>
<p>The type of layout to create. Any layout accepted by <code><a href="ggraph.html#topic+ggraph">ggraph()</a></code>
may be used, including all of the layout functions provided by <a href="igraph.html#topic+igraph">igraph</a>.</p>
</td></tr>
<tr><td><code id="plot.nma_data_+3A_circular">circular</code></td>
<td>
<p>Whether to use a circular representation. See <code><a href="ggraph.html#topic+ggraph">ggraph()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.nma_data_+3A_weight_edges">weight_edges</code></td>
<td>
<p>Weight edges by the number of studies? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.nma_data_+3A_weight_nodes">weight_nodes</code></td>
<td>
<p>Weight nodes by the total sample size? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.nma_data_+3A_show_trt_class">show_trt_class</code></td>
<td>
<p>Colour treatment nodes by class, if <code>trt_class</code> is set?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.nma_data_+3A_nudge">nudge</code></td>
<td>
<p>Numeric value to nudge the treatment labels away from the nodes
when <code>weight_nodes = TRUE</code>. Default is <code>0</code> (no adjustment to label
position). A small value like <code>0.1</code> is usually sufficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default is equivalent to <code>layout = "linear"</code> and <code>circular = TRUE</code>, which places the treatment nodes on a circle in the order defined by
the treatment factor variable. An alternative layout which may give good
results for simple networks is <code>"sugiyama"</code>, which attempts to minimise the
number of edge crossings.
</p>
<p><code>weight_nodes = TRUE</code> requires that sample sizes have been specified for
any aggregate data in the network, using the <code>sample_size</code> option of
<code style="white-space: pre;">&#8288;set_agd_*()&#8288;</code>.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object, as produced by <code><a href="ggraph.html#topic+ggraph">ggraph()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Stroke prevention in atrial fibrillation
# Setting up the network
af_net &lt;- set_agd_arm(atrial_fibrillation,
                      study = studyc,
                      trt = abbreviate(trtc, minlength = 3),
                      r = r,
                      n = n,
                      trt_class = trt_class)
af_net

# Basic plot
plot(af_net)

# Turn off weighting edges by number of studies
plot(af_net, weight_edges = FALSE)

# Turn on weighting nodes by sample size
plot(af_net, weight_nodes = TRUE)

# Colour treatment nodes by class
plot(af_net, weight_nodes = TRUE, show_trt_class = TRUE)

# Nudge the treatment labels away from the nodes
plot(af_net, weight_nodes = TRUE, show_trt_class = TRUE, nudge = 0.1)

# Output may be customised using standard ggplot commands
# For example, to display the legends below the plot:
plot(af_net, weight_nodes = TRUE, show_trt_class = TRUE) +
  ggplot2::theme(legend.position = "bottom",
                 legend.box = "vertical",
                 legend.margin = ggplot2::margin(0, 0, 0, 0),
                 legend.spacing = ggplot2::unit(0.5, "lines"))

# Choosing a different ggraph layout, hiding some legends
plot(af_net, weight_nodes = TRUE, show_trt_class = TRUE,
     layout = "star") +
  ggplot2::guides(edge_width = "none", size = "none")

</code></pre>

<hr>
<h2 id='plot.nma_dic'>Plots of model fit diagnostics</h2><span id='topic+plot.nma_dic'></span>

<h3>Description</h3>

<p>The <code>plot()</code> method for <a href="#topic+nma_dic">nma_dic</a> objects produced by <code><a href="#topic+dic">dic()</a></code> produces
several useful diagnostic plots for checking model fit and model comparison.
Further detail on these plots and their interpretation is given by
Dias et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma_dic'
plot(
  x,
  y,
  ...,
  show_uncertainty = TRUE,
  stat = "pointinterval",
  orientation = c("vertical", "horizontal", "x", "y")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nma_dic_+3A_x">x</code></td>
<td>
<p>A <code>nma_dic</code> object</p>
</td></tr>
<tr><td><code id="plot.nma_dic_+3A_y">y</code></td>
<td>
<p>(Optional) A second <code>nma_dic</code> object, to produce &quot;dev-dev&quot; plots for
model comparison.</p>
</td></tr>
<tr><td><code id="plot.nma_dic_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="plot.nma_dic_+3A_show_uncertainty">show_uncertainty</code></td>
<td>
<p>Logical, show uncertainty with a <code>ggdist</code> plot
stat? Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.nma_dic_+3A_stat">stat</code></td>
<td>
<p>Character string specifying the <code>ggdist</code> plot stat to use if
<code>show_uncertainty = TRUE</code>, default <code>"pointinterval"</code>. If <code>y</code> is provided,
currently only <code>"pointinterval"</code> is supported.</p>
</td></tr>
<tr><td><code id="plot.nma_dic_+3A_orientation">orientation</code></td>
<td>
<p>Whether the <code>ggdist</code> geom is drawn horizontally
(<code>"horizontal"</code>) or vertically (<code>"vertical"</code>). Only used for residual
deviance plots, default <code>"vertical"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a single <code>nma_dic</code> object is given, a plot of the residual
deviance contribution for each data point is produced. For a good fitting
model, each data point is expected to have a residual deviance of 1; larger
values indicate data points that are fit poorly by the model.
</p>
<p>When two <code>nma_dic</code> objects are given, a &quot;dev-dev&quot; plot comparing the
residual deviance contributions under each model is produced. Data points
with residual deviance contributions lying on the line of equality are fit
equally well under either model. Data points lying below the line of
equality indicate better fit under the second model (<code>y</code>); conversely, data
points lying above the line of equality indicate better fit under the first
model (<code>x</code>). A common use case is to compare a standard consistency model
(fitted using <code><a href="#topic+nma">nma()</a></code> with <code>consistency = "consistency"</code>) with an unrelated
mean effects (UME) inconsistency model (fitted using <code><a href="#topic+nma">nma()</a></code> with
<code>consistency = "ume"</code>), to check for potential inconsistency.
</p>
<p>See Dias et al. (2011) for further details.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>References</h3>

<p>Dias S, Welton NJ, Sutton AJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 2: A generalised linear modelling framework for pair-wise and network meta-analysis of randomised controlled trials.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation

# Run smoking FE NMA example if not already available
if (!exists("smk_fit_FE")) example("example_smk_fe", run.donttest = TRUE)


# Run smoking RE NMA example if not already available
if (!exists("smk_fit_RE")) example("example_smk_re", run.donttest = TRUE)


# Compare DIC of FE and RE models
(smk_dic_FE &lt;- dic(smk_fit_FE))
(smk_dic_RE &lt;- dic(smk_fit_RE))   # substantially better fit

# Plot residual deviance contributions under RE model
plot(smk_dic_RE)

# Further customisation is possible using ggplot commands
# For example, highlighting data points with residual deviance above a certain threshold
plot(smk_dic_RE) +
  ggplot2::aes(colour = ggplot2::after_stat(ifelse(y &gt; 1.5, "darkorange", "black"))) +
  ggplot2::scale_colour_identity()

# Or by posterior probability, for example here a central probability of 0.6
# corresponds to a lower tail probability of (1 - 0.6)/2 = 0.2
plot(smk_dic_RE, .width = c(0.6, 0.95)) +
  ggplot2::aes(colour = ggplot2::after_stat(ifelse(ymin &gt; 1, "darkorange", "black"))) +
  ggplot2::scale_colour_identity()

# Check for inconsistency using UME model


# Run smoking UME NMA example if not already available
if (!exists("smk_fit_RE_UME")) example("example_smk_ume", run.donttest = TRUE)


# Compare DIC
smk_dic_RE
(smk_dic_RE_UME &lt;- dic(smk_fit_RE_UME))  # no difference in fit

# Compare residual deviance contributions with a "dev-dev" plot
plot(smk_dic_RE, smk_dic_RE_UME)

# By default the dev-dev plot can be a little cluttered
# Hiding the credible intervals
plot(smk_dic_RE, smk_dic_RE_UME, show_uncertainty = FALSE)

# Changing transparency
plot(smk_dic_RE, smk_dic_RE_UME, point_alpha = 0.5, interval_alpha = 0.1)

</code></pre>

<hr>
<h2 id='plot.nma_summary'>Plots of summary results</h2><span id='topic+plot.nma_summary'></span><span id='topic+plot.nma_parameter_summary'></span><span id='topic+plot.nma_rank_probs'></span><span id='topic+plot.surv_nma_summary'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for <code>nma_summary</code> objects is used to produce plots of
parameter estimates (when called on a <code>stan_nma</code> object or its summary),
relative effects (when called on the output of <code><a href="#topic+relative_effects">relative_effects()</a></code>),
absolute predictions (when called on the output of <code><a href="#topic+predict.stan_nma">predict.stan_nma()</a></code>),
posterior ranks and rank probabilities (when called on the output of
<code><a href="#topic+posterior_ranks">posterior_ranks()</a></code> or <code><a href="#topic+posterior_rank_probs">posterior_rank_probs()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma_summary'
plot(
  x,
  ...,
  stat = "pointinterval",
  orientation = c("horizontal", "vertical", "y", "x"),
  ref_line = NA_real_
)

## S3 method for class 'nma_parameter_summary'
plot(
  x,
  ...,
  stat = "pointinterval",
  orientation = c("horizontal", "vertical", "y", "x"),
  ref_line = NA_real_
)

## S3 method for class 'nma_rank_probs'
plot(x, ...)

## S3 method for class 'surv_nma_summary'
plot(x, ..., stat = "lineribbon")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nma_summary_+3A_x">x</code></td>
<td>
<p>A <code>nma_summary</code> object</p>
</td></tr>
<tr><td><code id="plot.nma_summary_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the underlying <code>ggdist</code> plot
stat, see Details</p>
</td></tr>
<tr><td><code id="plot.nma_summary_+3A_stat">stat</code></td>
<td>
<p>Character string specifying the <code>ggdist</code> plot stat to use,
default <code>"pointinterval"</code>, except when plotting estimated
survival/hazard/cumulative hazard curves from survival models where the
default is <code>"lineribbon"</code></p>
</td></tr>
<tr><td><code id="plot.nma_summary_+3A_orientation">orientation</code></td>
<td>
<p>Whether the <code>ggdist</code> geom is drawn horizontally
(<code>"horizontal"</code>) or vertically (<code>"vertical"</code>), default <code>"horizontal"</code></p>
</td></tr>
<tr><td><code id="plot.nma_summary_+3A_ref_line">ref_line</code></td>
<td>
<p>Numeric vector of positions for reference lines, by default
no reference lines are drawn</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting is handled by <a href="ggplot2.html#topic+ggplot2">ggplot2</a> and the stats and geoms provided in
the <a href="ggdist.html#topic+ggdist">ggdist</a> package. As a result, the output is very flexible. Any
plotting stats provided by <code>ggdist</code> may be used, via the argument
<code>stat</code>.
</p>
<p>The default uses
<code><a href="ggdist.html#topic+stat_pointinterval">ggdist::stat_pointinterval()</a></code>, to
produce medians and 95% Credible Intervals with 66% inner bands. Additional
arguments in <code>...</code> are passed to the <code>ggdist</code> stat, to customise the
output. For example, to produce means and Credible Intervals, specify
<code>point_interval = "mean_qi"</code>. To produce an 80% Credible Interval with no
inner band, specify <code>.width = c(0, 0.8)</code>.
</p>
<p>Alternative stats can be specified to produce different summaries. For
example, specify <code>stat = "[half]eye"</code> to produce (half) eye plots, or <code>stat = "histinterval"</code> to produce histograms with intervals.
</p>
<p>A full list of options and examples is found in the <code>ggdist</code> vignette
<code>vignette("slabinterval", package = "ggdist")</code>.
</p>
<p>For survival/hazard/cumulative hazard curves estimated from survival
models, the default uses
<code><a href="ggdist.html#topic+stat_lineribbon">ggdist::stat_lineribbon()</a></code> which
produces curves of posterior medians with 50%, 80%, and 95% Credible
Interval bands. Again, additional arguments in <code>...</code> are passed to the
<code>ggdist</code> stat. For example, to produce posterior means and 95% Credible
bands, specify <code>point_interval = "mean_qi"</code> and <code>.width = 0.95</code>.
</p>
<p>A <code>ggplot</code> object is returned which can be further modified through the
usual <a href="ggplot2.html#topic+ggplot2">ggplot2</a> functions to add further aesthetics, geoms, themes, etc.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation

# Run smoking RE NMA example if not already available
if (!exists("smk_fit_RE")) example("example_smk_re", run.donttest = TRUE)


# Produce relative effects
smk_releff_RE &lt;- relative_effects(smk_fit_RE)
plot(smk_releff_RE, ref_line = 0)

# Customise plot options
plot(smk_releff_RE, ref_line = 0, stat = "halfeye")

# Further customisation is possible with ggplot commands
plot(smk_releff_RE, ref_line = 0, stat = "halfeye", slab_alpha = 0.6) +
  ggplot2::aes(slab_fill = ggplot2::after_stat(ifelse(x &lt; 0, "darkred", "grey60")))

# Produce posterior ranks
smk_rank_RE &lt;- posterior_ranks(smk_fit_RE, lower_better = FALSE)
plot(smk_rank_RE)

# Produce rank probabilities
smk_rankprob_RE &lt;- posterior_rank_probs(smk_fit_RE, lower_better = FALSE)
plot(smk_rankprob_RE)

# Produce cumulative rank probabilities
smk_cumrankprob_RE &lt;- posterior_rank_probs(smk_fit_RE, lower_better = FALSE,
                                           cumulative = TRUE)
plot(smk_cumrankprob_RE)

# Further customisation is possible with ggplot commands
plot(smk_cumrankprob_RE) +
  ggplot2::facet_null() +
  ggplot2::aes(colour = Treatment)

</code></pre>

<hr>
<h2 id='plot.nodesplit_summary'>Plots of node-splitting models</h2><span id='topic+plot.nodesplit_summary'></span>

<h3>Description</h3>

<p>Produce summary plots of node-splitting models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nodesplit_summary'
plot(
  x,
  ...,
  pars = "d",
  stat = "dens_overlay",
  orientation = c("horizontal", "vertical", "y", "x"),
  ref_line = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nodesplit_summary_+3A_x">x</code></td>
<td>
<p>A <code>nodesplit_summary</code> object.</p>
</td></tr>
<tr><td><code id="plot.nodesplit_summary_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the underlying <code>ggdist</code> plot
stat, see Details.</p>
</td></tr>
<tr><td><code id="plot.nodesplit_summary_+3A_pars">pars</code></td>
<td>
<p>Character vector specifying the parameters to include in the
plot, choices include <code>"d"</code> for the direct, indirect, and network estimates
of relative effects, <code>"omega"</code> for the inconsistency factor, and <code>"tau"</code>
for heterogeneity standard deviation in random effects models. Default is
<code>"d"</code>.</p>
</td></tr>
<tr><td><code id="plot.nodesplit_summary_+3A_stat">stat</code></td>
<td>
<p>Character string specifying the <code>ggdist</code> plot stat to use. The
default <code>"dens_overlay"</code> is a special case, producing an overlaid density
plot.</p>
</td></tr>
<tr><td><code id="plot.nodesplit_summary_+3A_orientation">orientation</code></td>
<td>
<p>Whether the <code>ggdist</code> geom is drawn horizontally
(<code>"horizontal"</code>) or vertically (<code>"vertical"</code>), default <code>"horizontal"</code>.</p>
</td></tr>
<tr><td><code id="plot.nodesplit_summary_+3A_ref_line">ref_line</code></td>
<td>
<p>Numeric vector of positions for reference lines, by default
no reference lines are drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting is handled by <a href="ggplot2.html#topic+ggplot2">ggplot2</a> and the stats and geoms provided in
the <a href="ggdist.html#topic+ggdist">ggdist</a> package. As a result, the output is very flexible. Any
plotting stats provided by <code>ggdist</code> may be used, via the argument <code>stat</code>.
The default <code>"dens_overlay"</code> is a special exception, which uses
<code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>, to plot overlaid
densities. Additional arguments in <code>...</code> are passed to the <code>ggdist</code> stat,
to customise the output.
</p>
<p>Alternative stats can be specified to produce different summaries. For
example, specify <code>stat = "[half]eye"</code> to produce (half) eye plots, or <code>stat = "pointinterval"</code> to produce point estimates and credible intervals.
</p>
<p>A full list of options and examples is found in the <code>ggdist</code> vignette
<code>vignette("slabinterval", package = "ggdist")</code>.
</p>
<p>A <code>ggplot</code> object is returned which can be further modified through the
usual <a href="ggplot2.html#topic+ggplot2">ggplot2</a> functions to add further aesthetics, geoms, themes, etc.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nma_nodesplit_df">summary.nma_nodesplit_df()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run smoking node-splitting example if not already available
if (!exists("smk_fit_RE_nodesplit")) example("example_smk_nodesplit", run.donttest = TRUE)


# Summarise the node-splitting results
(smk_nodesplit_summary &lt;- summary(smk_fit_RE_nodesplit))

# Plot the node-splitting results
plot(smk_nodesplit_summary)

# Plot the inconsistency factors instead, change the plot stat to half-eye,
# and add a reference line at 0
plot(smk_nodesplit_summary, pars = "omega", stat = "halfeye", ref_line = 0)

# Plot a comparison of the heterogeneity under the node-split models vs.
# the consistency model
plot(smk_nodesplit_summary, pars = "tau")

</code></pre>

<hr>
<h2 id='posterior_ranks'>Treatment rankings and rank probabilities</h2><span id='topic+posterior_ranks'></span><span id='topic+posterior_rank_probs'></span>

<h3>Description</h3>

<p>Produce posterior treatment rankings and rank probabilities from a fitted NMA
model. When a meta-regression is fitted with effect modifier interactions
with treatment, these will differ by study population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_ranks(
  x,
  newdata = NULL,
  study = NULL,
  lower_better = TRUE,
  probs = c(0.025, 0.25, 0.5, 0.75, 0.975),
  sucra = FALSE,
  summary = TRUE
)

posterior_rank_probs(
  x,
  newdata = NULL,
  study = NULL,
  lower_better = TRUE,
  cumulative = FALSE,
  sucra = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_ranks_+3A_x">x</code></td>
<td>
<p>A <code>stan_nma</code> object created by <code><a href="#topic+nma">nma()</a></code></p>
</td></tr>
<tr><td><code id="posterior_ranks_+3A_newdata">newdata</code></td>
<td>
<p>Only used if a regression model is fitted. A data frame of
study details, one row per study, giving the covariate values at which to
produce relative effects. Column names must match variables in the
regression model. If <code>NULL</code>, relative effects are produced for all studies
in the network.</p>
</td></tr>
<tr><td><code id="posterior_ranks_+3A_study">study</code></td>
<td>
<p>Column of <code>newdata</code> which specifies study names, otherwise
studies will be labelled by row number.</p>
</td></tr>
<tr><td><code id="posterior_ranks_+3A_lower_better">lower_better</code></td>
<td>
<p>Logical, are lower treatment effects better (<code>TRUE</code>;
default) or higher better (<code>FALSE</code>)? See details.</p>
</td></tr>
<tr><td><code id="posterior_ranks_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of quantiles of interest to present in computed
summary, default <code>c(0.025, 0.25, 0.5, 0.75, 0.975)</code></p>
</td></tr>
<tr><td><code id="posterior_ranks_+3A_sucra">sucra</code></td>
<td>
<p>Logical, calculate the surface under the cumulative ranking
curve (SUCRA) for each treatment? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="posterior_ranks_+3A_summary">summary</code></td>
<td>
<p>Logical, calculate posterior summaries? Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="posterior_ranks_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical, return cumulative rank probabilities? Default is
<code>FALSE</code>, return posterior probabilities of each treatment having a given
rank. If <code>TRUE</code>, cumulative posterior rank probabilities are returned for
each treatment having a given rank or better.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>posterior_ranks()</code> produces posterior rankings, which
have a distribution (e.g. mean/median rank and 95% Credible Interval). The
function <code>posterior_rank_probs()</code> produces rank probabilities, which give
the posterior probabilities of being ranked first, second, etc. out of all
treatments.
</p>
<p>The argument <code>lower_better</code> specifies whether lower treatment
effects or higher treatment effects are preferred. For example, with a
negative binary outcome lower (more negative) log odds ratios are
preferred, so <code>lower_better = TRUE</code>. Conversely, for example, if treatments
aim to increase the rate of a positive outcome then <code>lower_better = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+nma_summary">nma_summary</a> object if <code>summary = TRUE</code>, otherwise a list
containing a 3D MCMC array of samples and (for regression models) a data
frame of study information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nma_summary">plot.nma_summary()</a></code> for plotting the ranks and rank probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation

# Run smoking RE NMA example if not already available
if (!exists("smk_fit_RE")) example("example_smk_re", run.donttest = TRUE)


# Produce posterior ranks
smk_rank_RE &lt;- posterior_ranks(smk_fit_RE, lower_better = FALSE)
smk_rank_RE
plot(smk_rank_RE)

# Produce rank probabilities
smk_rankprob_RE &lt;- posterior_rank_probs(smk_fit_RE, lower_better = FALSE)
smk_rankprob_RE
plot(smk_rankprob_RE)

# Produce cumulative rank probabilities
smk_cumrankprob_RE &lt;- posterior_rank_probs(smk_fit_RE, lower_better = FALSE,
                                           cumulative = TRUE)
smk_cumrankprob_RE
plot(smk_cumrankprob_RE)

# Further customisation is possible with ggplot commands
plot(smk_cumrankprob_RE) +
  ggplot2::facet_null() +
  ggplot2::aes(colour = Treatment)


## Plaque psoriasis ML-NMR

# Run plaque psoriasis ML-NMR example if not already available
if (!exists("pso_fit")) example("example_pso_mlnmr", run.donttest = TRUE)


# Produce population-adjusted rankings for all study populations in
# the network

# Ranks
pso_rank &lt;- posterior_ranks(pso_fit)
pso_rank
plot(pso_rank)

# Rank probabilities
pso_rankprobs &lt;- posterior_rank_probs(pso_fit)
pso_rankprobs
plot(pso_rankprobs)

# Cumulative rank probabilities
pso_cumrankprobs &lt;- posterior_rank_probs(pso_fit, cumulative = TRUE)
pso_cumrankprobs
plot(pso_cumrankprobs)

# Produce population-adjusted rankings for a different target
# population
new_agd_means &lt;- data.frame(
  bsa = 0.6,
  prevsys = 0.1,
  psa = 0.2,
  weight = 10,
  durnpso = 3)

# Ranks
posterior_ranks(pso_fit, newdata = new_agd_means)

# Rank probabilities
posterior_rank_probs(pso_fit, newdata = new_agd_means)

# Cumulative rank probabilities
posterior_rank_probs(pso_fit, newdata = new_agd_means,
                     cumulative = TRUE)

</code></pre>

<hr>
<h2 id='predict.stan_nma'>Predictions of absolute effects from NMA models</h2><span id='topic+predict.stan_nma'></span><span id='topic+predict.stan_nma_surv'></span>

<h3>Description</h3>

<p>Obtain predictions of absolute effects from NMA models fitted with <code><a href="#topic+nma">nma()</a></code>.
For example, if a model is fitted to binary data with a logit link, predicted
outcome probabilities or log odds can be produced. For survival models,
predictions can be made for survival probabilities, (cumulative) hazards,
(restricted) mean survival times, and quantiles including median survival
times.
When an IPD NMA or ML-NMR model has been fitted, predictions can be
produced either at an individual level or at an aggregate level.
Aggregate-level predictions are population-average absolute effects; these
are marginalised or standardised over a population. For example, average
event probabilities from a logistic regression, or marginal (standardised)
survival probabilities from a survival model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stan_nma'
predict(
  object,
  ...,
  baseline = NULL,
  newdata = NULL,
  study = NULL,
  trt_ref = NULL,
  type = c("link", "response"),
  level = c("aggregate", "individual"),
  baseline_type = c("link", "response"),
  baseline_level = c("individual", "aggregate"),
  probs = c(0.025, 0.25, 0.5, 0.75, 0.975),
  predictive_distribution = FALSE,
  summary = TRUE
)

## S3 method for class 'stan_nma_surv'
predict(
  object,
  times = NULL,
  ...,
  baseline = NULL,
  aux = NULL,
  newdata = NULL,
  study = NULL,
  trt_ref = NULL,
  type = c("survival", "hazard", "cumhaz", "mean", "median", "quantile", "rmst", "link"),
  quantiles = c(0.25, 0.5, 0.75),
  level = c("aggregate", "individual"),
  times_seq = NULL,
  probs = c(0.025, 0.25, 0.5, 0.75, 0.975),
  predictive_distribution = FALSE,
  summary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.stan_nma_+3A_object">object</code></td>
<td>
<p>A <code>stan_nma</code> object created by <code><a href="#topic+nma">nma()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code><a href="stats.html#topic+uniroot">uniroot()</a></code> for regression models
if <code>baseline_level = "aggregate"</code>.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_baseline">baseline</code></td>
<td>
<p>An optional <code><a href="#topic+distr">distr()</a></code> distribution for the baseline response
(i.e. intercept), about which to produce absolute effects. Can also be a
character string naming a study in the network to take the estimated
baseline response distribution from. If <code>NULL</code>, predictions are produced
using the baseline response for each study in the network with IPD or
arm-based AgD.
</p>
<p>For regression models, this may be a list of <code><a href="#topic+distr">distr()</a></code> distributions (or
study names in the network to use the baseline distributions from) of the
same length as the number of studies in <code>newdata</code>, possibly named by the
studies in <code>newdata</code> or otherwise in order of appearance in <code>newdata</code>.
</p>
<p>Use the <code>baseline_type</code> and <code>baseline_level</code> arguments to specify whether
this distribution is on the response or linear predictor scale, and (for
ML-NMR or models including IPD) whether this applies to an individual at
the reference level of the covariates or over the entire <code>newdata</code>
population, respectively. For example, in a model with a logit link with
<code>baseline_type = "link"</code>, this would be a distribution for the baseline log
odds of an event. For survival models, <code>baseline</code> always corresponds to the
intercept parameters in the linear predictor (i.e. <code>baseline_type</code> is
always <code>"link"</code>, and <code>baseline_level</code> is <code>"individual"</code> for IPD NMA or
ML-NMR, and <code>"aggregate"</code> for AgD NMA).
</p>
<p>Use the <code>trt_ref</code> argument to specify which treatment this distribution
applies to.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_newdata">newdata</code></td>
<td>
<p>Only required if a regression model is fitted and <code>baseline</code>
is specified. A data frame of covariate details, for which to produce
predictions. Column names must match variables in the regression model.
</p>
<p>If <code>level = "aggregate"</code> this should either be a data frame with integration
points as produced by <code><a href="#topic+add_integration">add_integration()</a></code> (one row per study), or a data
frame with individual covariate values (one row per individual) which are
summarised over.
</p>
<p>If <code>level = "individual"</code> this should be a data frame of individual
covariate values, one row per individual.
</p>
<p>If <code>NULL</code>, predictions are produced for all studies with IPD and/or
arm-based AgD in the network, depending on the value of <code>level</code>.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_study">study</code></td>
<td>
<p>Column of <code>newdata</code> which specifies study names or IDs. When not
specified: if <code>newdata</code> contains integration points produced by
<code><a href="#topic+add_integration">add_integration()</a></code>, studies will be labelled sequentially by row;
otherwise data will be assumed to come from a single study.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_trt_ref">trt_ref</code></td>
<td>
<p>Treatment to which the <code>baseline</code> response distribution
refers, if <code>baseline</code> is specified. By default, the baseline response
distribution will refer to the network reference treatment. Coerced to
character string.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_type">type</code></td>
<td>
<p>Whether to produce predictions on the <code>"link"</code> scale (the
default, e.g. log odds) or <code>"response"</code> scale (e.g. probabilities).
</p>
<p>For survival models, the options are <code>"survival"</code> for survival
probabilities (the default), <code>"hazard"</code> for hazards, <code>"cumhaz"</code> for
cumulative hazards, <code>"mean"</code> for mean survival times, <code>"quantile"</code> for
quantiles of the survival time distribution, <code>"median"</code> for median survival
times (equivalent to <code>type = "quantile"</code> with <code>quantiles = 0.5</code>), <code>"rmst"</code>
for restricted mean survival times, or <code>"link"</code> for the linear predictor.
For <code>type = "survival"</code>, <code>"hazard"</code> or <code>"cumhaz"</code>, predictions are given at
the times specified by <code>times</code> or at the event/censoring times in the
network if <code>times = NULL</code>. For <code>type = "rmst"</code>, the restricted time horizon
is specified by <code>times</code>, or if <code>times = NULL</code> the earliest last follow-up
time amongst the studies in the network is used. When <code>level = "aggregate"</code>, these all correspond to the standardised survival function
(see details).</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_level">level</code></td>
<td>
<p>The level at which predictions are produced, either
<code>"aggregate"</code> (the default), or <code>"individual"</code>. If <code>baseline</code> is not
specified, predictions are produced for all IPD studies in the network if
<code>level</code> is <code>"individual"</code> or <code>"aggregate"</code>, and for all arm-based AgD
studies in the network if <code>level</code> is <code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_baseline_type">baseline_type</code></td>
<td>
<p>When a <code>baseline</code> distribution is given, specifies
whether this corresponds to the <code>"link"</code> scale (the default, e.g. log odds)
or <code>"response"</code> scale (e.g. probabilities). For survival models, <code>baseline</code>
always corresponds to the intercept parameters in the linear predictor
(i.e. <code>baseline_type</code> is always <code>"link"</code>).</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_baseline_level">baseline_level</code></td>
<td>
<p>When a <code>baseline</code> distribution is given, specifies
whether this corresponds to an individual at the reference level of the
covariates (<code>"individual"</code>, the default), or from an (unadjusted) average
outcome on the reference treatment in the <code>newdata</code> population
(<code>"aggregate"</code>). Ignored for AgD NMA, since the only option is
<code>"aggregate"</code> in this instance. For survival models, <code>baseline</code> always
corresponds to the intercept parameters in the linear predictor (i.e.
<code>baseline_level</code> is <code>"individual"</code> for IPD NMA or ML-NMR, and <code>"aggregate"</code>
for AgD NMA).</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of quantiles of interest to present in computed
summary, default <code>c(0.025, 0.25, 0.5, 0.75, 0.975)</code></p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_predictive_distribution">predictive_distribution</code></td>
<td>
<p>Logical, when a random effects model has been
fitted, should the predictive distribution for absolute effects in a new
study be returned? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_summary">summary</code></td>
<td>
<p>Logical, calculate posterior summaries? Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_times">times</code></td>
<td>
<p>A numeric vector of times to evaluate predictions at.
Alternatively, if <code>newdata</code> is specified, <code>times</code> can be the name of a
column in <code>newdata</code> which contains the times. If <code>NULL</code> (the default) then
predictions are made at the event/censoring times from the studies included
in the network (or according to <code>times_seq</code>). Only used if <code>type</code> is
<code>"survival"</code>, <code>"hazard"</code>, <code>"cumhaz"</code> or <code>"rmst"</code>.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_aux">aux</code></td>
<td>
<p>An optional <code><a href="#topic+distr">distr()</a></code> distribution for the auxiliary parameter(s)
in the baseline hazard (e.g. shapes). Can also be a character string naming
a study in the network to take the estimated auxiliary parameter
distribution from. If <code>NULL</code>, predictions are produced using the parameter
estimates for each study in the network with IPD or arm-based AgD.
</p>
<p>For regression models, this may be a list of <code><a href="#topic+distr">distr()</a></code> distributions (or
study names in the network to use the auxiliary parameters from) of the
same length as the number of studies in <code>newdata</code>, possibly named by the
study names or otherwise in order of appearance in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_quantiles">quantiles</code></td>
<td>
<p>A numeric vector of quantiles of the survival time
distribution to produce estimates for when <code>type = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="predict.stan_nma_+3A_times_seq">times_seq</code></td>
<td>
<p>A positive integer, when specified evaluate predictions at
this many evenly-spaced event times between 0 and the latest follow-up time
in each study, instead of every observed event/censoring time. Only used if
<code>newdata = NULL</code> and <code>type</code> is <code>"survival"</code>, <code>"hazard"</code> or <code>"cumhaz"</code>. This
can be useful for plotting survival or (cumulative) hazard curves, where
prediction at every observed even/censoring time is unnecessary and can be
slow. When a call from within <code>plot()</code> is detected, e.g. like
<code>plot(predict(fit, type = "survival"))</code>, <code>times_seq</code> will default to 50.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+nma_summary">nma_summary</a> object if <code>summary = TRUE</code>, otherwise a list
containing a 3D MCMC array of samples and (for regression models) a data
frame of study information.
</p>


<h3>Aggregate-level predictions from IPD NMA and ML-NMR models</h3>

<p>Population-average absolute effects can be produced from IPD NMA and ML-NMR
models with <code>level = "aggregate"</code>. Predictions are averaged over the target
population (i.e. standardised/marginalised), either by (numerical)
integration over the joint covariate distribution (for AgD studies in the
network for ML-NMR, or AgD <code>newdata</code> with integration points created by
<code><a href="#topic+add_integration">add_integration()</a></code>), or by averaging predictions for a sample of individuals
(for IPD studies in the network for IPD NMA/ML-NMR, or IPD <code>newdata</code>).
</p>
<p>For example, with a binary outcome, the population-average event
probabilities on treatment <code class="reqn">k</code> in study/population <code class="reqn">j</code> are
</p>
<p style="text-align: center;"><code class="reqn">\bar{p}_{jk} = \int_\mathfrak{X} p_{jk}(\mathbf{x}) f_{jk}(\mathbf{x})
d\mathbf{x}</code>
</p>

<p>for a joint covariate distribution <code class="reqn">f_{jk}(\mathbf{x})</code> with
support <code class="reqn">\mathfrak{X}</code> or
</p>
<p style="text-align: center;"><code class="reqn">\bar{p}_{jk} = \sum_i p_{jk}(\mathbf{x}_i)</code>
</p>

<p>for a sample of individuals with covariates <code class="reqn">\mathbf{x}_i</code>.
</p>
<p>Population-average absolute predictions follow similarly for other types of
outcomes, however for survival outcomes there are specific considerations.
</p>


<h4>Standardised survival predictions</h4>

<p>Different types of population-average survival predictions, often called
standardised survival predictions, follow from the <strong>standardised survival
function</strong> created by integrating (or equivalently averaging) the
individual-level survival functions at each time <code class="reqn">t</code>:
</p>
<p style="text-align: center;"><code class="reqn">\bar{S}_{jk}(t) = \int_\mathfrak{X} S_{jk}(t | \mathbf{x}) f_{jk}(\mathbf{x})
d\mathbf{x}</code>
</p>

<p>which is itself produced using <code>type = "survival"</code>.
</p>
<p>The <strong>standardised hazard function</strong> corresponding to this standardised
survival function is a weighted average of the individual-level hazard
functions
</p>
<p style="text-align: center;"><code class="reqn">\bar{h}_{jk}(t) = \frac{\int_\mathfrak{X} S_{jk}(t | \mathbf{x}) h_{jk}(t | \mathbf{x}) f_{jk}(\mathbf{x})
d\mathbf{x} }{\bar{S}_{jk}(t)}</code>
</p>

<p>weighted by the probability of surviving to time <code class="reqn">t</code>. This is produced
using <code>type = "hazard"</code>.
</p>
<p>The corresponding <strong>standardised cumulative hazard function</strong> is
</p>
<p style="text-align: center;"><code class="reqn">\bar{H}_{jk}(t) = -\log(\bar{S}_{jk}(t))</code>
</p>

<p>and is produced using <code>type = "cumhaz"</code>.
</p>
<p><strong>Quantiles and medians</strong> of the standardised survival times are found by
solving
</p>
<p style="text-align: center;"><code class="reqn">\bar{S}_{jk}(t) = 1-\alpha</code>
</p>

<p>for the <code class="reqn">\alpha\%</code> quantile, using numerical root finding. These are
produced using <code>type = "quantile"</code> or <code>"median"</code>.
</p>
<p><strong>(Restricted) means</strong> of the standardised survival times are found by
integrating
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{RMST}_{jk}(t^*) = \int_0^{t^*} \bar{S}_{jk}(t) dt</code>
</p>

<p>up to the restricted time horizon <code class="reqn">t^*</code>, with <code class="reqn">t^*=\infty</code> for mean
standardised survival time. These are produced using <code>type = "rmst"</code> or
<code>"mean"</code>.
</p>



<h3>See Also</h3>

<p><code><a href="#topic+plot.nma_summary">plot.nma_summary()</a></code> for plotting the predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation

# Run smoking RE NMA example if not already available
if (!exists("smk_fit_RE")) example("example_smk_re", run.donttest = TRUE)


# Predicted log odds of success in each study in the network
predict(smk_fit_RE)

# Predicted probabilities of success in each study in the network
predict(smk_fit_RE, type = "response")

# Predicted probabilities in a population with 67 observed events out of 566
# individuals on No Intervention, corresponding to a Beta(67, 566 - 67)
# distribution on the baseline probability of response, using
# `baseline_type = "response"`
(smk_pred_RE &lt;- predict(smk_fit_RE,
                        baseline = distr(qbeta, 67, 566 - 67),
                        baseline_type = "response",
                        type = "response"))
plot(smk_pred_RE, ref_line = c(0, 1))

# Predicted probabilities in a population with a baseline log odds of
# response on No Intervention given a Normal distribution with mean -2
# and SD 0.13, using `baseline_type = "link"` (the default)
# Note: this is approximately equivalent to the above Beta distribution on
# the baseline probability
(smk_pred_RE2 &lt;- predict(smk_fit_RE,
                         baseline = distr(qnorm, mean = -2, sd = 0.13),
                         type = "response"))
plot(smk_pred_RE2, ref_line = c(0, 1))


## Plaque psoriasis ML-NMR

# Run plaque psoriasis ML-NMR example if not already available
if (!exists("pso_fit")) example("example_pso_mlnmr", run.donttest = TRUE)


# Predicted probabilities of response in each study in the network
(pso_pred &lt;- predict(pso_fit, type = "response"))
plot(pso_pred, ref_line = c(0, 1))

# Predicted probabilites of response in a new target population, with means
# and SDs or proportions given by
new_agd_int &lt;- data.frame(
  bsa_mean = 0.6,
  bsa_sd = 0.3,
  prevsys = 0.1,
  psa = 0.2,
  weight_mean = 10,
  weight_sd = 1,
  durnpso_mean = 3,
  durnpso_sd = 1
)

# We need to add integration points to this data frame of new data
# We use the weighted mean correlation matrix computed from the IPD studies
new_agd_int &lt;- add_integration(new_agd_int,
                               durnpso = distr(qgamma, mean = durnpso_mean, sd = durnpso_sd),
                               prevsys = distr(qbern, prob = prevsys),
                               bsa = distr(qlogitnorm, mean = bsa_mean, sd = bsa_sd),
                               weight = distr(qgamma, mean = weight_mean, sd = weight_sd),
                               psa = distr(qbern, prob = psa),
                               cor = pso_net$int_cor,
                               n_int = 64)

# Predicted probabilities of achieving PASI 75 in this target population, given
# a Normal(-1.75, 0.08^2) distribution on the baseline probit-probability of
# response on Placebo (at the reference levels of the covariates), are given by
(pso_pred_new &lt;- predict(pso_fit,
                         type = "response",
                         newdata = new_agd_int,
                         baseline = distr(qnorm, -1.75, 0.08)))
plot(pso_pred_new, ref_line = c(0, 1))


## Progression free survival with newly-diagnosed multiple myeloma

# Run newly-diagnosed multiple myeloma example if not already available
if (!exists("ndmm_fit")) example("example_ndmm", run.donttest = TRUE)


# We can produce a range of predictions from models with survival outcomes,
# chosen with the type argument to predict

# Predicted survival probabilities at 5 years
predict(ndmm_fit, type = "survival", times = 5)

# Survival curves
plot(predict(ndmm_fit, type = "survival"))

# Hazard curves
# Here we specify a vector of times to avoid attempting to plot infinite
# hazards for some studies at t=0
plot(predict(ndmm_fit, type = "hazard", times = seq(0.001, 6, length.out = 50)))

# Cumulative hazard curves
plot(predict(ndmm_fit, type = "cumhaz"))

# Survival time quantiles and median survival
predict(ndmm_fit, type = "quantile", quantiles = c(0.2, 0.5, 0.8))
plot(predict(ndmm_fit, type = "median"))

# Mean survival time
predict(ndmm_fit, type = "mean")

# Restricted mean survival time
# By default, the time horizon is the shortest follow-up time in the network
predict(ndmm_fit, type = "rmst")

# An alternative restriction time can be set using the times argument
predict(ndmm_fit, type = "rmst", times = 5)  # 5-year RMST

</code></pre>

<hr>
<h2 id='print.nma_data'>Print <code>nma_data</code> objects</h2><span id='topic+print.nma_data'></span><span id='topic+print.mlnmr_data'></span>

<h3>Description</h3>

<p>Print details of networks stored as <a href="#topic+nma_data">nma_data</a> objects, as created by
<code><a href="#topic+set_ipd">set_ipd()</a></code>, <code><a href="#topic+set_agd_arm">set_agd_arm()</a></code>, <code><a href="#topic+set_agd_contrast">set_agd_contrast()</a></code>, <code><a href="#topic+set_agd_surv">set_agd_surv()</a></code>, or
<code><a href="#topic+combine_network">combine_network()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma_data'
print(x, ..., n = 10)

## S3 method for class 'mlnmr_data'
print(x, ..., n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nma_data_+3A_x">x</code></td>
<td>
<p><code>nma_data</code> object</p>
</td></tr>
<tr><td><code id="print.nma_data_+3A_...">...</code></td>
<td>
<p>other options (not used)</p>
</td></tr>
<tr><td><code id="print.nma_data_+3A_n">n</code></td>
<td>
<p>number of studies of each type to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
</p>

<hr>
<h2 id='print.nma_dic'>Print DIC details</h2><span id='topic+print.nma_dic'></span>

<h3>Description</h3>

<p>Print details of DIC model fit statistics, computed by <code><a href="#topic+dic">dic()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma_dic'
print(x, digits = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nma_dic_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+nma_dic">nma_dic</a></p>
</td></tr>
<tr><td><code id="print.nma_dic_+3A_digits">digits</code></td>
<td>
<p>An integer passed to <code><a href="base.html#topic+round">round()</a></code></p>
</td></tr>
<tr><td><code id="print.nma_dic_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
</p>

<hr>
<h2 id='print.nma_nodesplit_df'>Print <code>nma_nodesplit_df</code> objects</h2><span id='topic+print.nma_nodesplit_df'></span><span id='topic+print.nma_nodesplit'></span>

<h3>Description</h3>

<p>Print <code>nma_nodesplit_df</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma_nodesplit_df'
print(x, ...)

## S3 method for class 'nma_nodesplit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nma_nodesplit_df_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+nma_nodesplit_df">nma_nodesplit_df</a> object</p>
</td></tr>
<tr><td><code id="print.nma_nodesplit_df_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="rstan.html#topic+print.stanfit">print.stanfit()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
</p>


<h3>See Also</h3>

<p>The summary method <code><a href="#topic+summary.nma_nodesplit_df">summary.nma_nodesplit_df()</a></code> summarises the
node-splitting results.
</p>

<hr>
<h2 id='print.nma_summary'>Methods for <code>nma_summary</code> objects</h2><span id='topic+print.nma_summary'></span><span id='topic+as.data.frame.nma_summary'></span><span id='topic+as.tibble.nma_summary'></span><span id='topic+as_tibble.nma_summary'></span><span id='topic+as.array.nma_summary'></span><span id='topic+as.matrix.nma_summary'></span><span id='topic+as.array.nma_rank_probs'></span><span id='topic+as.matrix.nma_rank_probs'></span>

<h3>Description</h3>

<p>The <code>as.data.frame()</code>, <code>as_tibble()</code>, and <code>as.tibble()</code> methods return the
posterior summary statistics in a data frame or tibble. The <code>as.matrix()</code>
method returns a matrix of posterior draws. The <code>as.array()</code> method returns a
3D array [Iteration, Chain, Parameter] of posterior draws (as class
<a href="#topic+mcmc_array">mcmc_array</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma_summary'
print(x, ..., digits = 2, pars, include = TRUE)

## S3 method for class 'nma_summary'
as.data.frame(x, ...)

## S3 method for class 'nma_summary'
as.tibble(x, ...)

## S3 method for class 'nma_summary'
as_tibble(x, ...)

## S3 method for class 'nma_summary'
as.array(x, ...)

## S3 method for class 'nma_summary'
as.matrix(x, ...)

## S3 method for class 'nma_rank_probs'
as.array(x, ...)

## S3 method for class 'nma_rank_probs'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nma_summary_+3A_x">x</code></td>
<td>
<p>A <code>nma_summary</code> object</p>
</td></tr>
<tr><td><code id="print.nma_summary_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="print.nma_summary_+3A_digits">digits</code></td>
<td>
<p>Integer number of digits to display</p>
</td></tr>
<tr><td><code id="print.nma_summary_+3A_pars">pars</code></td>
<td>
<p>Character vector of parameters to display in the printed summary</p>
</td></tr>
<tr><td><code id="print.nma_summary_+3A_include">include</code></td>
<td>
<p>Logical, are parameters named in <code>pars</code> included (<code>TRUE</code>) or excluded (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> for <code>as.data.frame()</code>, a <code>tbl_df</code> for <code>as.tibble()</code>
and <code>as_tibble()</code>, a <code>matrix</code> for <code>as.matrix()</code>, and an <code>mcmc_array</code> for
<code>as.array()</code>.
</p>
<p>The <code>print()</code> method returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nma_summary">plot.nma_summary()</a></code>
</p>

<hr>
<h2 id='print.nodesplit_summary'>Methods for <code>nodesplit_summary</code> objects</h2><span id='topic+print.nodesplit_summary'></span><span id='topic+as_tibble.nodesplit_summary'></span><span id='topic+as.tibble.nodesplit_summary'></span><span id='topic+as.data.frame.nodesplit_summary'></span>

<h3>Description</h3>

<p>The <code>as.data.frame()</code>, <code>as_tibble()</code>, and <code>as.tibble()</code> methods return the
node-splitting summaries in a data frame or tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nodesplit_summary'
print(x, ..., digits = 2)

## S3 method for class 'nodesplit_summary'
as_tibble(x, ..., nest = FALSE)

as.tibble.nodesplit_summary(x, ..., nest = FALSE)

## S3 method for class 'nodesplit_summary'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nodesplit_summary_+3A_x">x</code></td>
<td>
<p>A <code>nodesplit_summary</code> object</p>
</td></tr>
<tr><td><code id="print.nodesplit_summary_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="print.nodesplit_summary_+3A_digits">digits</code></td>
<td>
<p>Integer number of digits to display</p>
</td></tr>
<tr><td><code id="print.nodesplit_summary_+3A_nest">nest</code></td>
<td>
<p>Whether to return a nested tibble, with the full <a href="#topic+nma_summary">nma_summary</a>
and <a href="#topic+nma_dic">nma_dic</a> objects, or to unnest their summaries, default <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> for <code>as.data.frame()</code>, a <code>tbl_df</code> for <code>as.tibble()</code>
and <code>as_tibble()</code>.
</p>
<p>The <code>print()</code> method returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nodesplit_summary">plot.nodesplit_summary()</a></code>
</p>

<hr>
<h2 id='print.stan_nma'>Print <code>stan_nma</code> objects</h2><span id='topic+print.stan_nma'></span>

<h3>Description</h3>

<p>Print <code>stan_nma</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stan_nma'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.stan_nma_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+stan_nma">stan_nma</a> object</p>
</td></tr>
<tr><td><code id="print.stan_nma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="rstan.html#topic+print.stanfit">print.stanfit()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
</p>

<hr>
<h2 id='priors'>Prior distributions</h2><span id='topic+priors'></span><span id='topic+normal'></span><span id='topic+half_normal'></span><span id='topic+log_normal'></span><span id='topic+cauchy'></span><span id='topic+half_cauchy'></span><span id='topic+student_t'></span><span id='topic+half_student_t'></span><span id='topic+log_student_t'></span><span id='topic+exponential'></span><span id='topic+flat'></span>

<h3>Description</h3>

<p>These functions are used to specify prior distributions for the model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal(location = 0, scale)

half_normal(scale)

log_normal(location, scale)

cauchy(location = 0, scale)

half_cauchy(scale)

student_t(location = 0, scale, df)

half_student_t(scale, df)

log_student_t(location, scale, df)

exponential(scale = 1/rate, rate = 1/scale)

flat()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priors_+3A_location">location</code></td>
<td>
<p>Prior location. Typically prior mean (see details).</p>
</td></tr>
<tr><td><code id="priors_+3A_scale">scale</code></td>
<td>
<p>Prior scale. Typically prior standard deviation (see details).</p>
</td></tr>
<tr><td><code id="priors_+3A_df">df</code></td>
<td>
<p>Prior degrees of freedom.</p>
</td></tr>
<tr><td><code id="priors_+3A_rate">rate</code></td>
<td>
<p>Prior rate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>location</code> and <code>scale</code> parameters are typically the prior mean
and standard deviation, with the following exceptions:
</p>

<ul>
<li><p> For the Cauchy distribution <code>location</code> is the prior median and
<code>scale</code> is the prior scale.
</p>
</li>
<li><p> For the log-Normal distribution, <code>location</code> and <code>scale</code> are the prior
mean and standard deviation of the logarithm.
</p>
</li></ul>



<h4>Compatibility with model parameters</h4>

<p>The following table summarises which prior distributions may be used with
which model parameters. Essentially, priors that take only non-negative
values (e.g. half-Normal) may only be used for non-negative parameters
(heterogeneity SD/variance/precision, and any auxiliary parameter). If a
real-valued prior distribution is specified for a non-negative parameter, it
will be truncated at 0 to be non-negative.</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: center;"> <strong>Intercept</strong> <code>prior_intercept</code> </td><td style="text-align: center;"> <strong>Treatment effects</strong> <code>prior_trt</code> </td><td style="text-align: center;"> <strong>Heterogeneity</strong> <code>prior_het</code> </td><td style="text-align: center;"> <strong>Regression coefficients</strong> <code>prior_reg</code> </td><td style="text-align: center;"> <strong>Auxiliary parameter</strong> <code>prior_aux</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Normal</strong> <code>normal()</code> </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>half-Normal</strong> <code>half_normal()</code> </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>log-Normal</strong> <code>log_normal()</code> </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Cauchy </strong><code>cauchy()</code> </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>half-Cauchy</strong> <code>half_cauchy()</code> </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Student t</strong> <code>student_t()</code> </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>half-Student t</strong> <code>half_student_t()</code> </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>log-Student t</strong> <code>log_student_t()</code> </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Exponential</strong> <code>exponential()</code> </td><td style="text-align: center;"> - </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> - </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Flat</strong> <code>flat()</code> </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code>flat()</code> prior is a special case where no prior information is added to
the model, resulting in an implicit flat uniform prior distribution over the
entire support for a parameter. This will be an improper prior if the
parameter is unbounded, and is not generally advised. See the
<a href="https://mc-stan.org/docs/stan-users-guide/some-differences-in-the-statistical-models-that-are-allowed.html">Stan user's guide</a>
for more details.
</p>



<h3>Value</h3>

<p>Object of class <a href="#topic+nma_prior">nma_prior</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nma_prior">summary.nma_prior()</a></code> for summarising details of prior
distributions. <code><a href="#topic+plot_prior_posterior">plot_prior_posterior()</a></code> for plots comparing the prior and
posterior distributions of model parameters.
</p>

<hr>
<h2 id='qbern'>The Bernoulli Distribution</h2><span id='topic+qbern'></span><span id='topic+pbern'></span><span id='topic+dbern'></span>

<h3>Description</h3>

<p>The density function <code>dbern()</code>, distribution function <code>pbern()</code>, and quantile
function <code>qbern()</code> for a Bernoulli distribution, with success probability
<code>prob</code>. These are equivalent to <code>dbinom(p, 1, prob)</code>, <code>pbinom(p, 1, prob)</code>
and <code>qbinom(p, 1, prob)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qbern(p, prob, lower.tail = TRUE, log.p = FALSE)

pbern(q, prob, lower.tail = TRUE, log.p = FALSE)

dbern(x, prob, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qbern_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="qbern_+3A_prob">prob</code></td>
<td>
<p>probability of success</p>
</td></tr>
<tr><td><code id="qbern_+3A_lower.tail">lower.tail</code>, <code id="qbern_+3A_log.p">log.p</code>, <code id="qbern_+3A_log">log</code></td>
<td>
<p>see <a href="stats.html#topic+Binomial">stats::Binomial</a></p>
</td></tr>
<tr><td><code id="qbern_+3A_x">x</code>, <code id="qbern_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length equal to the maximum of the lengths of the
input arguments.
</p>

<hr>
<h2 id='qgamma'>The Gamma distribution</h2><span id='topic+qgamma'></span><span id='topic+dgamma'></span><span id='topic+pgamma'></span>

<h3>Description</h3>

<p>We provide convenient extensions of the <code style="white-space: pre;">&#8288;[dpq]gamma&#8288;</code> functions, which allow
the distribution to be specified in terms of its mean and standard deviation,
instead of shape and rate/scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgamma(
  p,
  shape,
  rate = 1,
  scale = 1/rate,
  lower.tail = TRUE,
  log.p = FALSE,
  mean,
  sd
)

dgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE, mean, sd)

pgamma(
  q,
  shape,
  rate = 1,
  scale = 1/rate,
  lower.tail = TRUE,
  log.p = FALSE,
  mean,
  sd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qgamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="qgamma_+3A_shape">shape</code>, <code id="qgamma_+3A_rate">rate</code>, <code id="qgamma_+3A_scale">scale</code>, <code id="qgamma_+3A_log">log</code>, <code id="qgamma_+3A_lower.tail">lower.tail</code>, <code id="qgamma_+3A_log.p">log.p</code></td>
<td>
<p>see <a href="stats.html#topic+GammaDist">stats::GammaDist</a></p>
</td></tr>
<tr><td><code id="qgamma_+3A_mean">mean</code>, <code id="qgamma_+3A_sd">sd</code></td>
<td>
<p>mean and standard deviation, overriding <code>shape</code> and
<code>rate</code> or <code>scale</code> if specified</p>
</td></tr>
<tr><td><code id="qgamma_+3A_x">x</code>, <code id="qgamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length equal to the maximum of the lengths of the
input arguments.
</p>

<hr>
<h2 id='qlogitnorm'>The logit Normal distribution</h2><span id='topic+qlogitnorm'></span><span id='topic+dlogitnorm'></span><span id='topic+plogitnorm'></span>

<h3>Description</h3>

<p>We provide convenient extensions of the <code style="white-space: pre;">&#8288;[dpq]logitnorm&#8288;</code> functions in the
package <a href="logitnorm.html#topic+logitnorm-package">logitnorm</a>, which allow the
distribution to be specified in terms of its mean and standard deviation,
instead of its logit-mean and logit-sd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qlogitnorm(p, mu = 0, sigma = 1, ..., mean, sd)

dlogitnorm(x, mu = 0, sigma = 1, ..., mean, sd)

plogitnorm(q, mu = 0, sigma = 1, ..., mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qlogitnorm_+3A_p">p</code>, <code id="qlogitnorm_+3A_x">x</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="qlogitnorm_+3A_mu">mu</code>, <code id="qlogitnorm_+3A_sigma">sigma</code>, <code id="qlogitnorm_+3A_...">...</code></td>
<td>
<p>see <code><a href="logitnorm.html#topic+logitnorm-package">logitnorm</a></code></p>
</td></tr>
<tr><td><code id="qlogitnorm_+3A_mean">mean</code>, <code id="qlogitnorm_+3A_sd">sd</code></td>
<td>
<p>mean and standard deviation, overriding <code>mu</code> and <code>sigma</code> if
specified</p>
</td></tr>
<tr><td><code id="qlogitnorm_+3A_q">q</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length equal to the maximum of the lengths of the
input arguments.
</p>

<hr>
<h2 id='RE_cor'>Random effects structure</h2><span id='topic+RE_cor'></span><span id='topic+which_RE'></span>

<h3>Description</h3>

<p>Use <code>RE_cor</code> to generate the random effects correlation matrix, under the
assumption of common heterogeneity variance (i.e. all within-study
correlations are 0.5). Use <code>which_RE</code> to return a vector of IDs for the RE
deltas (0 means no RE delta on this arm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RE_cor(study, trt, contrast, type = c("reftrt", "blshift"))

which_RE(study, trt, contrast, type = c("reftrt", "blshift"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RE_cor_+3A_study">study</code></td>
<td>
<p>A vector of study IDs (integer, character, or factor)</p>
</td></tr>
<tr><td><code id="RE_cor_+3A_trt">trt</code></td>
<td>
<p>A factor vector of treatment codes (or coercible as such), with
first level indicating the reference treatment</p>
</td></tr>
<tr><td><code id="RE_cor_+3A_contrast">contrast</code></td>
<td>
<p>A logical vector, of the same length as <code>study</code> and <code>trt</code>,
indicating whether the corresponding data are in contrast rather than arm
format.</p>
</td></tr>
<tr><td><code id="RE_cor_+3A_type">type</code></td>
<td>
<p>Character string, whether to generate RE structure under the
&quot;reference treatment&quot; parameterisation, or the &quot;baseline shift&quot;
parameterisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>RE_cor()</code>, a correlation matrix of dimension equal to the number
of random effects deltas (excluding those that are set equal to zero).
</p>
<p>For <code>which_RE()</code>, an integer vector of IDs indexing the rows and columns of
the correlation matrix returned by <code>RE_cor()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RE_cor(smoking$studyn, smoking$trtn, contrast = rep(FALSE, nrow(smoking)))
RE_cor(smoking$studyn, smoking$trtn, contrast = rep(FALSE, nrow(smoking)), type = "blshift")
which_RE(smoking$studyn, smoking$trtn, contrast = rep(FALSE, nrow(smoking)))
which_RE(smoking$studyn, smoking$trtn, contrast = rep(FALSE, nrow(smoking)), type = "blshift")
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+Surv'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>survival</dt><dd><p><code><a href="survival.html#topic+Surv">Surv</a></code></p>
</dd>
</dl>

<hr>
<h2 id='relative_effects'>Relative treatment effects</h2><span id='topic+relative_effects'></span>

<h3>Description</h3>

<p>Generate (population-average) relative treatment effects. If a ML-NMR or
meta-regression model was fitted, these are specific to each study
population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relative_effects(
  x,
  newdata = NULL,
  study = NULL,
  all_contrasts = FALSE,
  trt_ref = NULL,
  probs = c(0.025, 0.25, 0.5, 0.75, 0.975),
  predictive_distribution = FALSE,
  summary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relative_effects_+3A_x">x</code></td>
<td>
<p>A <code>stan_nma</code> object created by <code><a href="#topic+nma">nma()</a></code></p>
</td></tr>
<tr><td><code id="relative_effects_+3A_newdata">newdata</code></td>
<td>
<p>Only used if a regression model is fitted. A data frame of
study details, one row per study, giving the covariate values at which to
produce relative effects. Column names must match variables in the
regression model. If <code>NULL</code>, relative effects are produced for all studies
in the network.</p>
</td></tr>
<tr><td><code id="relative_effects_+3A_study">study</code></td>
<td>
<p>Column of <code>newdata</code> which specifies study names, otherwise
studies will be labelled by row number.</p>
</td></tr>
<tr><td><code id="relative_effects_+3A_all_contrasts">all_contrasts</code></td>
<td>
<p>Logical, generate estimates for all contrasts (<code>TRUE</code>),
or just the &quot;basic&quot; contrasts against the network reference treatment
(<code>FALSE</code>)? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="relative_effects_+3A_trt_ref">trt_ref</code></td>
<td>
<p>Reference treatment to construct relative effects against, if
<code>all_contrasts = FALSE</code>. By default, relative effects will be against the
network reference treatment. Coerced to character string.</p>
</td></tr>
<tr><td><code id="relative_effects_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of quantiles of interest to present in computed
summary, default <code>c(0.025, 0.25, 0.5, 0.75, 0.975)</code></p>
</td></tr>
<tr><td><code id="relative_effects_+3A_predictive_distribution">predictive_distribution</code></td>
<td>
<p>Logical, when a random effects model has been
fitted, should the predictive distribution for relative effects in a new
study be returned? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="relative_effects_+3A_summary">summary</code></td>
<td>
<p>Logical, calculate posterior summaries? Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+nma_summary">nma_summary</a> object if <code>summary = TRUE</code>, otherwise a list
containing a 3D MCMC array of samples and (for regression models) a data
frame of study information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nma_summary">plot.nma_summary()</a></code> for plotting the relative effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation

# Run smoking RE NMA example if not already available
if (!exists("smk_fit_RE")) example("example_smk_re", run.donttest = TRUE)


# Produce relative effects
smk_releff_RE &lt;- relative_effects(smk_fit_RE)
smk_releff_RE
plot(smk_releff_RE, ref_line = 0)

# Relative effects for all pairwise comparisons
relative_effects(smk_fit_RE, all_contrasts = TRUE)

# Relative effects against a different reference treatment
relative_effects(smk_fit_RE, trt_ref = "Self-help")

# Transforming to odds ratios
# We work with the array of relative effects samples
LOR_array &lt;- as.array(smk_releff_RE)
OR_array &lt;- exp(LOR_array)

# mcmc_array objects can be summarised to produce a nma_summary object
smk_OR_RE &lt;- summary(OR_array)

# This can then be printed or plotted
smk_OR_RE
plot(smk_OR_RE, ref_line = 1)


## Plaque psoriasis ML-NMR

# Run plaque psoriasis ML-NMR example if not already available
if (!exists("pso_fit")) example("example_pso_mlnmr", run.donttest = TRUE)


# Produce population-adjusted relative effects for all study populations in
# the network
pso_releff &lt;- relative_effects(pso_fit)
pso_releff
plot(pso_releff, ref_line = 0)

# Produce population-adjusted relative effects for a different target
# population
new_agd_means &lt;- data.frame(
  bsa = 0.6,
  prevsys = 0.1,
  psa = 0.2,
  weight = 10,
  durnpso = 3)

relative_effects(pso_fit, newdata = new_agd_means)

</code></pre>

<hr>
<h2 id='set_agd_arm'>Set up arm-based aggregate data</h2><span id='topic+set_agd_arm'></span>

<h3>Description</h3>

<p>Set up a network containing arm-based aggregate data (AgD), such as event
counts or mean outcomes on each arm. Multiple data sources may be combined
once created using <code><a href="#topic+combine_network">combine_network()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_agd_arm(
  data,
  study,
  trt,
  y = NULL,
  se = NULL,
  r = NULL,
  n = NULL,
  E = NULL,
  sample_size = NULL,
  trt_ref = NULL,
  trt_class = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_agd_arm_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="set_agd_arm_+3A_study">study</code></td>
<td>
<p>column of <code>data</code> specifying the studies, coded using integers,
strings, or factors</p>
</td></tr>
<tr><td><code id="set_agd_arm_+3A_trt">trt</code></td>
<td>
<p>column of <code>data</code> specifying treatments, coded using integers,
strings, or factors</p>
</td></tr>
<tr><td><code id="set_agd_arm_+3A_y">y</code></td>
<td>
<p>column of <code>data</code> specifying a continuous outcome</p>
</td></tr>
<tr><td><code id="set_agd_arm_+3A_se">se</code></td>
<td>
<p>column of <code>data</code> specifying the standard error for a continuous
outcome</p>
</td></tr>
<tr><td><code id="set_agd_arm_+3A_r">r</code></td>
<td>
<p>column of <code>data</code> specifying a binary or Binomial outcome count</p>
</td></tr>
<tr><td><code id="set_agd_arm_+3A_n">n</code></td>
<td>
<p>column of <code>data</code> specifying Binomial outcome numerator</p>
</td></tr>
<tr><td><code id="set_agd_arm_+3A_e">E</code></td>
<td>
<p>column of <code>data</code> specifying the total time at risk for Poisson
outcomes</p>
</td></tr>
<tr><td><code id="set_agd_arm_+3A_sample_size">sample_size</code></td>
<td>
<p>column of <code>data</code> giving the sample size in each arm.
Optional, see details.</p>
</td></tr>
<tr><td><code id="set_agd_arm_+3A_trt_ref">trt_ref</code></td>
<td>
<p>reference treatment for the network, as a single integer,
string, or factor. If not specified, a reasonable well-connected default
will be chosen (see details).</p>
</td></tr>
<tr><td><code id="set_agd_arm_+3A_trt_class">trt_class</code></td>
<td>
<p>column of <code>data</code> specifying treatment classes, coded using
integers, strings, or factors. By default, no classes are specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>trt_ref = NULL</code> and a network reference treatment will be chosen
that attempts to maximise computational efficiency and stability. If an
alternative reference treatment is chosen and the model runs slowly or has
low effective sample size (ESS) this may be the cause - try letting the
default reference treatment be used instead. Regardless of which treatment is
used as the network reference at the model fitting stage, results can be
transformed afterwards: see the <code>trt_ref</code> argument of
<code><a href="#topic+relative_effects">relative_effects()</a></code> and <code><a href="#topic+predict.stan_nma">predict.stan_nma()</a></code>.
</p>
<p>The <code>sample_size</code> argument is optional, but when specified:
</p>

<ul>
<li><p> Enables automatic centering of predictors (<code>center = TRUE</code>) in <code><a href="#topic+nma">nma()</a></code>
when a regression model is given for a network combining IPD and AgD
</p>
</li>
<li><p> Enables production of study-specific relative effects, rank probabilities,
etc. for studies in the network when a regression model is given
</p>
</li>
<li><p> Nodes in <code><a href="#topic+plot.nma_data">plot.nma_data()</a></code> may be weighted by sample size
</p>
</li></ul>

<p>If a Binomial outcome is specified and <code>sample_size</code> is omitted, <code>n</code> will be
used as the sample size by default. If a Multinomial outcome is specified and
<code>sample_size</code> is omitted, the sample size will be determined automatically
from the supplied counts by default.
</p>
<p>All arguments specifying columns of <code>data</code> accept the following:
</p>

<ul>
<li><p> A column name as a character string, e.g. <code>study = "studyc"</code>
</p>
</li>
<li><p> A bare column name, e.g. <code>study = studyc</code>
</p>
</li>
<li> <p><code>dplyr::mutate()</code> style semantics for inline variable transformations, e.g. <code>study = paste(author, year)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+nma_data">nma_data</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_ipd">set_ipd()</a></code> for individual patient data, <code><a href="#topic+set_agd_contrast">set_agd_contrast()</a></code> for
contrast-based aggregate data, and <code><a href="#topic+combine_network">combine_network()</a></code> for combining
several data sources in one network.
</p>
<p><code><a href="#topic+print.nma_data">print.nma_data()</a></code> for the print method displaying details of the
network, and <code><a href="#topic+plot.nma_data">plot.nma_data()</a></code> for network plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up network of smoking cessation data
head(smoking)

smk_net &lt;- set_agd_arm(smoking,
                       study = studyn,
                       trt = trtc,
                       r = r,
                       n = n,
                       trt_ref = "No intervention")

# Print details
smk_net


# Plot network
plot(smk_net)
</code></pre>

<hr>
<h2 id='set_agd_contrast'>Set up contrast-based aggregate data</h2><span id='topic+set_agd_contrast'></span>

<h3>Description</h3>

<p>Set up a network containing contrast-based aggregate data (AgD), i.e.
summaries of relative effects between treatments such as log Odds Ratios.
Multiple data sources may be combined once created using <code><a href="#topic+combine_network">combine_network()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_agd_contrast(
  data,
  study,
  trt,
  y = NULL,
  se = NULL,
  sample_size = NULL,
  trt_ref = NULL,
  trt_class = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_agd_contrast_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="set_agd_contrast_+3A_study">study</code></td>
<td>
<p>column of <code>data</code> specifying the studies, coded using integers,
strings, or factors</p>
</td></tr>
<tr><td><code id="set_agd_contrast_+3A_trt">trt</code></td>
<td>
<p>column of <code>data</code> specifying treatments, coded using integers,
strings, or factors</p>
</td></tr>
<tr><td><code id="set_agd_contrast_+3A_y">y</code></td>
<td>
<p>column of <code>data</code> specifying a continuous outcome</p>
</td></tr>
<tr><td><code id="set_agd_contrast_+3A_se">se</code></td>
<td>
<p>column of <code>data</code> specifying the standard error for a continuous
outcome</p>
</td></tr>
<tr><td><code id="set_agd_contrast_+3A_sample_size">sample_size</code></td>
<td>
<p>column of <code>data</code> giving the sample size in each arm.
Optional, see details.</p>
</td></tr>
<tr><td><code id="set_agd_contrast_+3A_trt_ref">trt_ref</code></td>
<td>
<p>reference treatment for the network, as a single integer,
string, or factor. If not specified, a reasonable well-connected default
will be chosen (see details).</p>
</td></tr>
<tr><td><code id="set_agd_contrast_+3A_trt_class">trt_class</code></td>
<td>
<p>column of <code>data</code> specifying treatment classes, coded using
integers, strings, or factors. By default, no classes are specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each study should have a single reference/baseline treatment,
against which relative effects in the other arm(s) are given. For the
reference arm, include a data row with continuous outcome <code>y</code> equal to
<code>NA</code>. If a study has three or more arms (so two or more relative effects),
set the standard error <code>se</code> for the reference arm data row equal to the
standard error of the mean outcome on the reference arm (this determines
the covariance of the relative effects, when expressed as differences in
mean outcomes between arms).
</p>
<p>All arguments specifying columns of <code>data</code> accept the following:
</p>

<ul>
<li><p> A column name as a character string, e.g. <code>study = "studyc"</code>
</p>
</li>
<li><p> A bare column name, e.g. <code>study = studyc</code>
</p>
</li>
<li> <p><code>dplyr::mutate()</code> style semantics for inline variable transformations, e.g. <code>study = paste(author, year)</code>
</p>
</li></ul>

<p>By default, <code>trt_ref = NULL</code> and a network reference treatment will be chosen
that attempts to maximise computational efficiency and stability. If an
alternative reference treatment is chosen and the model runs slowly or has
low effective sample size (ESS) this may be the cause - try letting the
default reference treatment be used instead. Regardless of which treatment is
used as the network reference at the model fitting stage, results can be
transformed afterwards: see the <code>trt_ref</code> argument of
<code><a href="#topic+relative_effects">relative_effects()</a></code> and <code><a href="#topic+predict.stan_nma">predict.stan_nma()</a></code>.
</p>
<p>The <code>sample_size</code> argument is optional, but when specified:
</p>

<ul>
<li><p> Enables automatic centering of predictors (<code>center = TRUE</code>) in <code><a href="#topic+nma">nma()</a></code>
when a regression model is given for a network combining IPD and AgD
</p>
</li>
<li><p> Enables production of study-specific relative effects, rank probabilities,
etc. for studies in the network when a regression model is given
</p>
</li>
<li><p> Nodes in <code><a href="#topic+plot.nma_data">plot.nma_data()</a></code> may be weighted by sample size
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+nma_data">nma_data</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_ipd">set_ipd()</a></code> for individual patient data, <code><a href="#topic+set_agd_arm">set_agd_arm()</a></code> for
arm-based aggregate data, and <code><a href="#topic+combine_network">combine_network()</a></code> for combining several
data sources in one network.
</p>
<p><code><a href="#topic+print.nma_data">print.nma_data()</a></code> for the print method displaying details of the
network, and <code><a href="#topic+plot.nma_data">plot.nma_data()</a></code> for network plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up network of Parkinson's contrast data
head(parkinsons)

park_net &lt;- set_agd_contrast(parkinsons,
                             study = studyn,
                             trt = trtn,
                             y = diff,
                             se = se_diff,
                             sample_size = n)

# Print details
park_net

# Plot network
plot(park_net)
</code></pre>

<hr>
<h2 id='set_agd_surv'>Set up aggregate survival data</h2><span id='topic+set_agd_surv'></span>

<h3>Description</h3>

<p>Set up a network containing aggregate survival data (AgD) in the form of
event/censoring times (e.g. reconstructed from digitized Kaplan-Meier curves)
and covariate summary statistics from each study. Multiple data sources may be
combined once created using <code><a href="#topic+combine_network">combine_network()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_agd_surv(
  data,
  study,
  trt,
  Surv,
  covariates = NULL,
  trt_ref = NULL,
  trt_class = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_agd_surv_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="set_agd_surv_+3A_study">study</code></td>
<td>
<p>column of <code>data</code> specifying the studies, coded using integers,
strings, or factors</p>
</td></tr>
<tr><td><code id="set_agd_surv_+3A_trt">trt</code></td>
<td>
<p>column of <code>data</code> specifying treatments, coded using integers,
strings, or factors</p>
</td></tr>
<tr><td><code id="set_agd_surv_+3A_surv">Surv</code></td>
<td>
<p>column of <code>data</code> specifying a survival or time-to-event outcome,
using the <code><a href="#topic+Surv">Surv()</a></code> function. Right/left/interval censoring and left
truncation (delayed entry) are supported.</p>
</td></tr>
<tr><td><code id="set_agd_surv_+3A_covariates">covariates</code></td>
<td>
<p>data frame of covariate summary statistics for each study
or study arm, with corresponding <code>study</code> and <code>trt</code> columns to match to
those in <code>data</code></p>
</td></tr>
<tr><td><code id="set_agd_surv_+3A_trt_ref">trt_ref</code></td>
<td>
<p>reference treatment for the network, as a single integer,
string, or factor. If not specified, a reasonable well-connected default
will be chosen (see details).</p>
</td></tr>
<tr><td><code id="set_agd_surv_+3A_trt_class">trt_class</code></td>
<td>
<p>column of <code>data</code> specifying treatment classes, coded using
integers, strings, or factors. By default, no classes are specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>trt_ref = NULL</code> and a network reference treatment will be chosen
that attempts to maximise computational efficiency and stability. If an
alternative reference treatment is chosen and the model runs slowly or has
low effective sample size (ESS) this may be the cause - try letting the
default reference treatment be used instead. Regardless of which treatment is
used as the network reference at the model fitting stage, results can be
transformed afterwards: see the <code>trt_ref</code> argument of
<code><a href="#topic+relative_effects">relative_effects()</a></code> and <code><a href="#topic+predict.stan_nma">predict.stan_nma()</a></code>.
</p>
<p>All arguments specifying columns of <code>data</code> accept the following:
</p>

<ul>
<li><p> A column name as a character string, e.g. <code>study = "studyc"</code>
</p>
</li>
<li><p> A bare column name, e.g. <code>study = studyc</code>
</p>
</li>
<li> <p><code>dplyr::mutate()</code> style semantics for inline variable transformations, e.g. <code>study = paste(author, year)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+nma_data">nma_data</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_ipd">set_ipd()</a></code> for individual patient data, <code><a href="#topic+set_agd_contrast">set_agd_contrast()</a></code> for
contrast-based aggregate data, and <code><a href="#topic+combine_network">combine_network()</a></code> for combining
several data sources in one network.
</p>
<p><code><a href="#topic+print.nma_data">print.nma_data()</a></code> for the print method displaying details of the
network, and <code><a href="#topic+plot.nma_data">plot.nma_data()</a></code> for network plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Newly diagnosed multiple myeloma

head(ndmm_agd)  # Reconstructed Kaplan-Meier data
ndmm_agd_covs   # Summary covariate information on each arm

set_agd_surv(ndmm_agd,
             study = studyf,
             trt = trtf,
             Surv = Surv(eventtime, status),
             covariates = ndmm_agd_covs)

</code></pre>

<hr>
<h2 id='set_ipd'>Set up individual patient data</h2><span id='topic+set_ipd'></span>

<h3>Description</h3>

<p>Set up a network containing individual patient data (IPD). Multiple data
sources may be combined once created using <code><a href="#topic+combine_network">combine_network()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_ipd(
  data,
  study,
  trt,
  y = NULL,
  r = NULL,
  E = NULL,
  Surv = NULL,
  trt_ref = NULL,
  trt_class = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_ipd_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="set_ipd_+3A_study">study</code></td>
<td>
<p>column of <code>data</code> specifying the studies, coded using integers,
strings, or factors</p>
</td></tr>
<tr><td><code id="set_ipd_+3A_trt">trt</code></td>
<td>
<p>column of <code>data</code> specifying treatments, coded using integers,
strings, or factors</p>
</td></tr>
<tr><td><code id="set_ipd_+3A_y">y</code></td>
<td>
<p>column of <code>data</code> specifying a continuous outcome</p>
</td></tr>
<tr><td><code id="set_ipd_+3A_r">r</code></td>
<td>
<p>column of <code>data</code> specifying a binary outcome or Poisson outcome count</p>
</td></tr>
<tr><td><code id="set_ipd_+3A_e">E</code></td>
<td>
<p>column of <code>data</code> specifying the total time at risk for Poisson
outcomes</p>
</td></tr>
<tr><td><code id="set_ipd_+3A_surv">Surv</code></td>
<td>
<p>column of <code>data</code> specifying a survival or time-to-event outcome,
using the <code><a href="#topic+Surv">Surv()</a></code> function. Right/left/interval censoring and left
truncation (delayed entry) are supported.</p>
</td></tr>
<tr><td><code id="set_ipd_+3A_trt_ref">trt_ref</code></td>
<td>
<p>reference treatment for the network, as a single integer,
string, or factor. If not specified, a reasonable well-connected default
will be chosen (see details).</p>
</td></tr>
<tr><td><code id="set_ipd_+3A_trt_class">trt_class</code></td>
<td>
<p>column of <code>data</code> specifying treatment classes, coded using
integers, strings, or factors. By default, no classes are specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>trt_ref = NULL</code> and a network reference treatment will be chosen
that attempts to maximise computational efficiency and stability. If an
alternative reference treatment is chosen and the model runs slowly or has
low effective sample size (ESS) this may be the cause - try letting the
default reference treatment be used instead. Regardless of which treatment is
used as the network reference at the model fitting stage, results can be
transformed afterwards: see the <code>trt_ref</code> argument of
<code><a href="#topic+relative_effects">relative_effects()</a></code> and <code><a href="#topic+predict.stan_nma">predict.stan_nma()</a></code>.
</p>
<p>All arguments specifying columns of <code>data</code> accept the following:
</p>

<ul>
<li><p> A column name as a character string, e.g. <code>study = "studyc"</code>
</p>
</li>
<li><p> A bare column name, e.g. <code>study = studyc</code>
</p>
</li>
<li> <p><code>dplyr::mutate()</code> style semantics for inline variable transformations, e.g. <code>study = paste(author, year)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+nma_data">nma_data</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_agd_arm">set_agd_arm()</a></code> for arm-based aggregate data, <code><a href="#topic+set_agd_contrast">set_agd_contrast()</a></code>
for contrast-based aggregate data, and <code><a href="#topic+combine_network">combine_network()</a></code> for combining
several data sources in one network.
</p>
<p><code><a href="#topic+print.nma_data">print.nma_data()</a></code> for the print method displaying details of the
network, and <code><a href="#topic+plot.nma_data">plot.nma_data()</a></code> for network plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up network of plaque psoriasis IPD
head(plaque_psoriasis_ipd)

pso_net &lt;- set_ipd(plaque_psoriasis_ipd,
                   study = studyc,
                   trt = trtc,
                   r = pasi75)

# Print network details
pso_net

# Plot network
plot(pso_net)

# Setting a different reference treatment
set_ipd(plaque_psoriasis_ipd,
        study = studyc,
        trt = trtc,
        r = pasi75,
        trt_ref = "PBO")
</code></pre>

<hr>
<h2 id='smoking'>Smoking cessation data</h2><span id='topic+smoking'></span>

<h3>Description</h3>

<p>Data frame containing the results of 24 trials of 4 smoking cessation
treatments (Hasselblad 1998; Dias et al. 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoking
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 rows and 5 variables:
</p>

<dl>
<dt>studyn</dt><dd><p>numeric study ID</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>r</dt><dd><p>total number of events</p>
</dd>
<dt>n</dt><dd><p>total number of individuals</p>
</dd>
</dl>



<h3>References</h3>

<p>Dias S, Welton NJ, Sutton AJ, Caldwell DM, Lu G, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 4: Inconsistency in networks of evidence based on randomised controlled trials.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.<br /><br /> Hasselblad V (1998).
&ldquo;Meta-analysis of Multitreatment Studies.&rdquo;
<em>Medical Decision Making</em>, <b>18</b>(1), 37&ndash;43.
<a href="https://doi.org/10.1177/0272989x9801800110">doi:10.1177/0272989x9801800110</a>.
</p>

<hr>
<h2 id='stan_nma-class'>The stan_nma class</h2><span id='topic+stan_nma-class'></span><span id='topic+stan_nma'></span><span id='topic+stan_mlnmr'></span>

<h3>Description</h3>

<p>The <code>stan_nma</code> and <code>stan_mlnmr</code> classes contains the results from running a
model with the function <code><a href="#topic+nma">nma()</a></code>.
</p>


<h3>Details</h3>

<p>Objects of class <code>stan_nma</code> and <code>stan_mlnmr</code> have the following
components:
</p>

<dl>
<dt><code>network</code></dt><dd><p>The network data from which the model was run (class
<a href="#topic+nma_data">nma_data</a> for <code>stan_nma</code>, or class <a href="#topic+mlnmr_data">mlnmr_data</a> for <code>stan_mlnmr</code>)</p>
</dd>
<dt><code>stanfit</code></dt><dd><p>The <code>stanfit</code> object returned by calling
<code><a href="rstan.html#topic+stanmodel-method-sampling">sampling()</a></code> for the model</p>
</dd>
<dt><code>trt_effects</code></dt><dd><p>Whether fixed or random effects were used (character
string)</p>
</dd>
<dt><code>consistency</code></dt><dd><p>The consistency/inconsistency model used (character
string)</p>
</dd>
<dt><code>regression</code></dt><dd><p>The regression model used (formula)</p>
</dd>
<dt><code>class_interactions</code></dt><dd><p>If treatment classes and a regression model are
specified, the model used for interactions within each class (common,
exchangeable, or independent)</p>
</dd>
<dt><code>xbar</code></dt><dd><p>A named vector of values used for centering</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>The likelihood used (character string)</p>
</dd>
<dt><code>link</code></dt><dd><p>The link function used (character string)</p>
</dd>
<dt><code>priors</code></dt><dd><p>A list containing the priors used (as <a href="#topic+nma_prior">nma_prior</a> objects)</p>
</dd>
<dt><code>basis</code></dt><dd><p>For <code>mspline</code> and <code>pexp</code> models, a named list of spline
bases for each study</p>
</dd>
</dl>

<p>The <code>stan_mlnmr</code> sub-class inherits from <code>stan_nma</code>, and differs only in the
class of the <code>network</code> object.
</p>

<hr>
<h2 id='statins'>Statins for cholesterol lowering</h2><span id='topic+statins'></span>

<h3>Description</h3>

<p>Data frame containing the results of 19 trials comparing statins to placebo
or usual care (Dias et al. 2011). The number of deaths (all-cause
mortality) are recorded. In some studies the aim was primary prevention
(patients had no previous heart disease), and in others the aim was secondary
prevention (patients had previous heart disease).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statins
</code></pre>


<h3>Format</h3>

<p>A data frame with 38 rows and 7 variables:
</p>

<dl>
<dt>studyn</dt><dd><p>numeric study ID</p>
</dd>
<dt>studyc</dt><dd><p>study name</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>prevention</dt><dd><p>primary or secondary prevention study</p>
</dd>
<dt>r</dt><dd><p>number of deaths</p>
</dd>
<dt>n</dt><dd><p>sample size</p>
</dd>
</dl>



<h3>References</h3>

<p>Dias S, Sutton AJ, Welton NJ, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 3: Heterogeneity: subgroups, meta-regression, bias and bias-adjustment.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.
</p>

<hr>
<h2 id='summary.nma_nodesplit_df'>Summarise the results of node-splitting models</h2><span id='topic+summary.nma_nodesplit_df'></span><span id='topic+summary.nma_nodesplit'></span><span id='topic+plot.nma_nodesplit'></span><span id='topic+plot.nma_nodesplit_df'></span>

<h3>Description</h3>

<p>Posterior summaries of node-splitting models (<code>nma_nodesplit</code> and
<code>nma_nodesplit_df</code> objects) can be produced using the <code>summary()</code> method, and
plotted using the <code>plot()</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma_nodesplit_df'
summary(
  object,
  consistency = NULL,
  ...,
  probs = c(0.025, 0.25, 0.5, 0.75, 0.975)
)

## S3 method for class 'nma_nodesplit'
summary(
  object,
  consistency = NULL,
  ...,
  probs = c(0.025, 0.25, 0.5, 0.75, 0.975)
)

## S3 method for class 'nma_nodesplit'
plot(x, consistency = NULL, ...)

## S3 method for class 'nma_nodesplit_df'
plot(x, consistency = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nma_nodesplit_df_+3A_consistency">consistency</code></td>
<td>
<p>Optional, a <code>stan_nma</code> object for the corresponding fitted
consistency model, to display the network estimates alongside the direct
and indirect estimates. The fitted consistency model present in the
<code>nma_nodesplit_df</code> object will be used if this is present (see
<code><a href="#topic+get_nodesplits">get_nodesplits()</a></code>).</p>
</td></tr>
<tr><td><code id="summary.nma_nodesplit_df_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="summary.nma_nodesplit_df_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of specifying quantiles of interest, default
<code>c(0.025, 0.25, 0.5, 0.75, 0.975)</code></p>
</td></tr>
<tr><td><code id="summary.nma_nodesplit_df_+3A_x">x</code>, <code id="summary.nma_nodesplit_df_+3A_object">object</code></td>
<td>
<p>A <code>nma_nodesplit</code> or <code>nma_nodesplit_df</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot()</code> method is a shortcut for <code>plot(summary(nma_nodesplit))</code>. For
details of plotting options, see <code><a href="#topic+plot.nodesplit_summary">plot.nodesplit_summary()</a></code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+nodesplit_summary">nodesplit_summary</a> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nodesplit_summary">plot.nodesplit_summary()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run smoking node-splitting example if not already available
if (!exists("smk_fit_RE_nodesplit")) example("example_smk_nodesplit", run.donttest = TRUE)


# Summarise the node-splitting results
summary(smk_fit_RE_nodesplit)

# Plot the node-splitting results
plot(smk_fit_RE_nodesplit)

</code></pre>

<hr>
<h2 id='summary.nma_prior'>Summary of prior distributions</h2><span id='topic+summary.nma_prior'></span>

<h3>Description</h3>

<p>Print a summary of prior distribution details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nma_prior'
summary(object, ..., probs = c(0.5, 0.95), digits = 2, trunc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nma_prior_+3A_object">object</code></td>
<td>
<p>Prior distribution as a <code>nma_prior</code> object</p>
</td></tr>
<tr><td><code id="summary.nma_prior_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used</p>
</td></tr>
<tr><td><code id="summary.nma_prior_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of probabilities to calculate prior intervals</p>
</td></tr>
<tr><td><code id="summary.nma_prior_+3A_digits">digits</code></td>
<td>
<p>Number of digits to display</p>
</td></tr>
<tr><td><code id="summary.nma_prior_+3A_trunc">trunc</code></td>
<td>
<p>Optional numeric vector of length 2, giving the truncation
limits of the prior distribution. Useful if a real-valued prior is assigned
to a positive-valued parameter, then <code>trunc = c(0, Inf)</code> will give the
correct prior intervals. By default, truncation is not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame is returned invisibly, giving the prior intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(normal(location = 0, scale = 1))
summary(half_normal(scale = 1))
summary(log_normal(location = -3.93, scale = 1.51))

# Truncation limits may be set, for example to restrict a prior to positive values
summary(normal(location = 0.5, scale = 1), trunc = c(0, Inf))

</code></pre>

<hr>
<h2 id='summary.stan_nma'>Posterior summaries from <code>stan_nma</code> objects</h2><span id='topic+summary.stan_nma'></span><span id='topic+plot.stan_nma'></span>

<h3>Description</h3>

<p>Posterior summaries of model parameters in <code>stan_nma</code> objects may be produced
using the <code>summary()</code> method and plotted with the <code>plot()</code> method. NOTE: To
produce relative effects, absolute predictions, or posterior ranks, see
<code><a href="#topic+relative_effects">relative_effects()</a></code>, <code><a href="#topic+predict.stan_nma">predict.stan_nma()</a></code>, <code><a href="#topic+posterior_ranks">posterior_ranks()</a></code>,
<code><a href="#topic+posterior_rank_probs">posterior_rank_probs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stan_nma'
summary(object, ..., pars, include, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))

## S3 method for class 'stan_nma'
plot(
  x,
  ...,
  pars,
  include,
  stat = "pointinterval",
  orientation = c("horizontal", "vertical", "y", "x"),
  ref_line = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stan_nma_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="summary.stan_nma_+3A_pars">pars</code>, <code id="summary.stan_nma_+3A_include">include</code></td>
<td>
<p>See <code><a href="rstan.html#topic+stanfit-method-extract">rstan::extract()</a></code></p>
</td></tr>
<tr><td><code id="summary.stan_nma_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of specifying quantiles of interest, default
<code>c(0.025, 0.25, 0.5, 0.75, 0.975)</code></p>
</td></tr>
<tr><td><code id="summary.stan_nma_+3A_x">x</code>, <code id="summary.stan_nma_+3A_object">object</code></td>
<td>
<p>A <code>stan_nma</code> object</p>
</td></tr>
<tr><td><code id="summary.stan_nma_+3A_stat">stat</code></td>
<td>
<p>Character string specifying the <code>ggdist</code> plot stat to use,
default <code>"pointinterval"</code></p>
</td></tr>
<tr><td><code id="summary.stan_nma_+3A_orientation">orientation</code></td>
<td>
<p>Whether the <code>ggdist</code> geom is drawn horizontally
(<code>"horizontal"</code>) or vertically (<code>"vertical"</code>), default <code>"horizontal"</code></p>
</td></tr>
<tr><td><code id="summary.stan_nma_+3A_ref_line">ref_line</code></td>
<td>
<p>Numeric vector of positions for reference lines, by default
no reference lines are drawn</p>
</td></tr>
<tr><td><code id="summary.stan_nma_+3A_summary">summary</code></td>
<td>
<p>Logical, calculate posterior summaries? Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot()</code> method is a shortcut for <code>plot(summary(stan_nma))</code>. For
details of plotting options, see <code><a href="#topic+plot.nma_summary">plot.nma_summary()</a></code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+nma_summary">nma_summary</a> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nma_summary">plot.nma_summary()</a></code>, <code><a href="#topic+relative_effects">relative_effects()</a></code>, <code><a href="#topic+predict.stan_nma">predict.stan_nma()</a></code>,
<code><a href="#topic+posterior_ranks">posterior_ranks()</a></code>, <code><a href="#topic+posterior_rank_probs">posterior_rank_probs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Smoking cessation

# Run smoking RE NMA example if not already available
if (!exists("smk_fit_RE")) example("example_smk_re", run.donttest = TRUE)


# Summary and plot of all model parameters
summary(smk_fit_RE)
plot(smk_fit_RE)

# Summary and plot of heterogeneity tau only
summary(smk_fit_RE, pars = "tau")
plot(smk_fit_RE, pars = "tau")

# Customising plot output
plot(smk_fit_RE,
     pars = c("d", "tau"),
     stat = "halfeye",
     ref_line = 0)

</code></pre>

<hr>
<h2 id='theme_multinma'>Plot theme for multinma plots</h2><span id='topic+theme_multinma'></span>

<h3>Description</h3>

<p>A simple <code>ggplot2</code> theme for plots in the <code>multinma</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_multinma(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_multinma_+3A_...">...</code></td>
<td>
<p>Arguments passed to
<code><a href="ggplot2.html#topic+ggtheme">ggplot2::theme_light()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> theme
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code>, <code><a href="ggplot2.html#topic+theme_get">ggplot2::theme_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
theme_set(theme_multinma())

</code></pre>

<hr>
<h2 id='thrombolytics'>Thrombolytic treatments data</h2><span id='topic+thrombolytics'></span>

<h3>Description</h3>

<p>Data frame containing the results of 50 trials of 8 thrombolytic drugs
(streptokinase, SK; alteplase, t-PA; accelerated alteplase, Acc t-PA;
streptokinase plus alteplase, SK+tPA; reteplase, r-PA; tenocteplase, TNK;
urokinase, UK; anistreptilase, ASPAC) plus per-cutaneous transluminal
coronary angioplasty (PTCA)
(Boland et al. 2003; Lu and Ades 2006; Dias et al. 2011). The number of
deaths in 30 or 35 days following acute myocardial infarction are recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thrombolytics
</code></pre>


<h3>Format</h3>

<p>A data frame with 102 rows and 5 variables:
</p>

<dl>
<dt>studyn</dt><dd><p>numeric study ID</p>
</dd>
<dt>trtn</dt><dd><p>numeric treatment code</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>r</dt><dd><p>total number of events</p>
</dd>
<dt>n</dt><dd><p>total number of individuals</p>
</dd>
</dl>



<h3>References</h3>

<p>Boland A, Dundar Y, Bagust A, Haycox A, Hill R, Mota RM, Walley T, Dickson R (2003).
&ldquo;Early thrombolysis for the treatment of acute myocardial infarction: a systematic review and economic evaluation.&rdquo;
<em>Health Technology Assessment</em>, <b>7</b>(15).
<a href="https://doi.org/10.3310/hta7150">doi:10.3310/hta7150</a>.<br /><br /> Dias S, Welton NJ, Sutton AJ, Caldwell DM, Lu G, Ades AE (2011).
&ldquo;NICE DSU Technical Support Document 4: Inconsistency in networks of evidence based on randomised controlled trials.&rdquo;
National Institute for Health and Care Excellence.
<a href="https://www.sheffield.ac.uk/nice-dsu">https://www.sheffield.ac.uk/nice-dsu</a>.<br /><br /> Lu GB, Ades AE (2006).
&ldquo;Assessing evidence inconsistency in mixed treatment comparisons.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>101</b>(474), 447&ndash;459.
<a href="https://doi.org/10.1198/016214505000001302">doi:10.1198/016214505000001302</a>.
</p>

<hr>
<h2 id='transfusion'>Granulocyte transfusion in patients with neutropenia or neutrophil
dysfunction</h2><span id='topic+transfusion'></span>

<h3>Description</h3>

<p>Data frame containing the number of deaths in 6 trials comparing transfusion
of granulocytes (white blood cells) to control
(Stanworth et al. 2005). Previously used to demonstrate
informative prior distributions for the heterogeneity variance by
Turner et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transfusion
</code></pre>


<h3>Format</h3>

<p>A data frame with 12 rows and 4 variables:
</p>

<dl>
<dt>studyc</dt><dd><p>study name</p>
</dd>
<dt>trtc</dt><dd><p>treatment name</p>
</dd>
<dt>r</dt><dd><p>total number of deaths</p>
</dd>
<dt>n</dt><dd><p>total number of individuals</p>
</dd>
</dl>



<h3>References</h3>

<p>Stanworth S, Massey E, Hyde C, Brunskill SJ, Navarette C, Lucas G, Marks D, Paulus U (2005).
&ldquo;Granulocyte transfusions for treating infections in patients with neutropenia or neutrophil dysfunction.&rdquo;
<em>Cochrane Database of Systematic Reviews</em>.
ISSN 1465-1858, <a href="https://doi.org/10.1002/14651858.CD005339">doi:10.1002/14651858.CD005339</a>.<br /><br /> Turner RM, Davey J, Clarke MJ, Thompson SG, Higgins JPT (2012).
&ldquo;Predicting the extent of heterogeneity in meta-analysis, using empirical data from the Cochrane Database of Systematic Reviews.&rdquo;
<em>International Journal of Epidemiology</em>, <b>41</b>(3), 818&ndash;827.
<a href="https://doi.org/10.1093/ije/dys041">doi:10.1093/ije/dys041</a>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
