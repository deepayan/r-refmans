<!DOCTYPE html><html lang="en"><head><title>Help for package OrdFacReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OrdFacReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#OrdFacReg-package'><p>Least Squares, Logistic, and Cox-Regression with Ordered Predictors</p></a></li>
<li><a href='#internal'><p>Internal functions for ordered factor regression functions</p></a></li>
<li><a href='#ordFacReg'><p>Compute least squares or logistic regression for ordered predictors</p></a></li>
<li><a href='#ordFacRegCox'><p>Compute Cox-regression for ordered predictors</p></a></li>
<li><a href='#prepareData'><p>Prepare input data to be used in active set algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Least Squares, Logistic, and Cox-Regression with Ordered
Predictors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-07-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Kaspar Rufibach</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kaspar Rufibach &lt;kaspar.rufibach@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival, eha, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Description:</td>
<td>In biomedical studies, researchers are often interested in assessing the association between one or more ordinal explanatory variables and an outcome variable, at the same time adjusting for covariates of any type. The outcome variable may be continuous, binary, or represent censored survival times. In the absence of a precise knowledge of the response function, using monotonicity constraints on the ordinal variables improves efficiency in estimating parameters, especially when sample sizes are small. This package implements an active set algorithm that efficiently computes such estimators.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-07-04 12:27:52 UTC; rufibach</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-07-04 15:27:12</td>
</tr>
</table>
<hr>
<h2 id='OrdFacReg-package'>Least Squares, Logistic, and Cox-Regression with Ordered Predictors</h2><span id='topic+OrdFacReg-package'></span><span id='topic+OrdFacReg'></span>

<h3>Description</h3>

<p>In biomedical studies, researchers are often interested in assessing the association between one or more
ordinal explanatory variables and an outcome variable, at the same time adjusting for covariates of any type.
The outcome variable may be continuous, binary, or represent censored survival times. In the absence of a precise
knowledge of the response function, using monotonicity constraints on the ordinal variables improves efficiency in
estimating parameters, especially when sample sizes are small. This package implements an active set algorithm
that efficiently computes such estimators.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package:  </td><td style="text-align: left;"> OrdFacReg  </td>
</tr>
<tr>
 <td style="text-align: left;">
Type:     </td><td style="text-align: left;"> Package    </td>
</tr>
<tr>
 <td style="text-align: left;">
Version:  </td><td style="text-align: left;"> 1.0.6      </td>
</tr>
<tr>
 <td style="text-align: left;">
Date:     </td><td style="text-align: left;"> 2015-07-03 </td>
</tr>
<tr>
 <td style="text-align: left;">
License:  </td><td style="text-align: left;"> GPL (&gt;=2)  </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes        </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Use this package to get estimates in least squares, logistic, or Cox-regression where coefficients corresponding to
dummy variables of ordered factors are estimated to be in non-decreasing order and at least 0.
The package offers an active set algorithm implemented in the functions <code><a href="#topic+ordFacReg">ordFacReg</a></code> for least squares
and logistic regression and <code><a href="#topic+ordFacRegCox">ordFacRegCox</a></code> for Cox-regression. 
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <br /> <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a></p>


<h3>References</h3>

<p>Rufibach, K. (2010).
An Active Set Algorithm to Estimate Parameters in Generalized Linear Models with Ordered Predictors.
<em>Comput. Statist. Data Anal.</em>, <b>54</b>, 1442-1456.
</p>


<h3>See Also</h3>

<p>Examples are given in the help files of the functions <code><a href="#topic+ordFacReg">ordFacReg</a></code> and <code><a href="#topic+ordFacRegCox">ordFacRegCox</a></code>.</p>

<hr>
<h2 id='internal'>Internal functions for ordered factor regression functions</h2><span id='topic+Abeta'></span><span id='topic+constraintMats'></span><span id='topic+coxDeriv'></span><span id='topic+coxLoglik'></span><span id='topic+coxSubspace'></span><span id='topic+dummy'></span><span id='topic+expandBeta'></span><span id='topic+indexDummy'></span><span id='topic+lmLSE'></span><span id='topic+lmSS'></span><span id='topic+logRegDeriv'></span><span id='topic+logRegLoglik'></span><span id='topic+logRegMLE'></span><span id='topic+logRegSubspace'></span><span id='topic+LSEsubspace'></span><span id='topic+maxStep'></span><span id='topic+phi_jl'></span><span id='topic+setminus'></span><span id='topic+shrinkBeta'></span>

<h3>Description</h3>

<p>Internal functions for ordered factor regression functions.</p>


<h3>Details</h3>

<p>These functions are not intended to be called by users directly. 
</p>

<ul>
<li><p><code><a href="#topic+Abeta">Abeta</a></code>Function <code class="reqn">A(\bold{\beta})</code> in Rufibach (2010) that collects the indices of
the inequalities violated by <code class="reqn">\bold{\beta}</code>.
</p>
</li>
<li><p><code><a href="#topic+constraintMats">constraintMats</a></code>Function that computes the matrices <code class="reqn">\bold{B}</code> (collects the basis vectors
given in Theorem 3.1 of Duembgen et al. (2007)) and <code class="reqn">\bold{V}</code> (collects the vectors <code class="reqn">\bold{v}_i</code> that 
make up the cone <code class="reqn">K</code> in Section 3.1 of Duembgen et al. (2007)).
</p>
</li>
<li><p><code><a href="#topic+coxDeriv">coxDeriv</a></code>Computes gradient of (pseudo-)log-likelihood function in Cox-regression.
</p>
</li>
<li><p><code><a href="#topic+coxLoglik">coxLoglik</a></code>Computes value of (pseudo-)log-likelihood function in Cox-regression.
</p>
</li>
<li><p><code><a href="#topic+coxSubspace">coxSubspace</a></code>Computes maximizer on subspace, denoted by <code class="reqn">\widetilde{\psi}(A)</code> in Table 1
of Duembgen et al. (2007).
</p>
</li>
<li><p><code><a href="#topic+dummy">dummy</a></code>Generate a matrix of dummy variables corresponding to the levels of the inputed factor.
The dummy variable corresponding to the lowest level of the factor is omitted.
</p>
</li>
<li><p><code><a href="#topic+expandBeta">expandBeta</a></code>After computation of <code class="reqn">\bold{\beta}</code> on subspace &ldquo;blow up&rdquo; this vector again
to original dimension.
</p>
</li>
<li><p><code><a href="#topic+indexDummy">indexDummy</a></code>Compute column numbers of the dummy variables of the ordered factor(s).
</p>
</li>
<li><p><code><a href="#topic+lmLSE">lmLSE</a></code>Compute value of least squares criterion and least squares estimate.
</p>
</li>
<li><p><code><a href="#topic+lmSS">lmSS</a></code>Compute value of least squares criterion and its gradient.
</p>
</li>
<li><p><code><a href="#topic+logRegDeriv">logRegDeriv</a></code>Gradient of log-likelihood function in logistic regression.
</p>
</li>
<li><p><code><a href="#topic+logRegLoglik">logRegLoglik</a></code>Compute value of log-likelihood function in logistic regression.
</p>
</li>
<li><p><code><a href="#topic+logRegSubspace">logRegSubspace</a></code>Computes maximizer on subspace, denoted by <code class="reqn">\widetilde{\psi}(A)</code> in 
Table 1 of Duembgen et al. (2007).
</p>
</li>
<li><p><code><a href="#topic+LSEsubspace">LSEsubspace</a></code>Computes maximizer on subspace, denoted by <code class="reqn">\widetilde{\psi}(A)</code> in 
Table 1 of Duembgen et al. (2007).
</p>
</li>
<li><p><code><a href="#topic+maxStep">maxStep</a></code>Compute maximal permissible steplength, denoted by <code class="reqn">t</code> in Table 1 in 
Duembgen et al. (2007).
</p>
</li>
<li><p><code><a href="#topic+phi_jl">phi_jl</a></code>Function <code class="reqn">\phi</code> in Rufibach (2010) that maps the original indices <code class="reqn">(i, j)</code> to
the inequality index <code class="reqn">i</code>.
</p>
</li>
<li><p><code><a href="#topic+setminus">setminus</a></code>Remove elements in vector <code class="reqn">B</code> from vector <code class="reqn">A</code>.
</p>
</li>
<li><p><code><a href="#topic+shrinkBeta">shrinkBeta</a></code>Collapse <code class="reqn">\bold{\beta}</code> according to the active constraints specified by the set <code class="reqn">A</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <br /> <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a></p>


<h3>References</h3>

<p>Duembgen, L., Huesler, A. and Rufibach, K. (2010).
Active set and EM algorithms for log-concave densities based on complete and censored data.
Technical report 61, IMSV, Univ. of Bern, available at <a href="http://arxiv.org/abs/0707.4643">http://arxiv.org/abs/0707.4643</a>.
</p>
<p>Rufibach, K. (2010).
An Active Set Algorithm to Estimate Parameters in Generalized Linear Models with Ordered Predictors.
<em>Comput. Statist. Data Anal.</em>, <b>54</b>, 1442-1456.
</p>


<h3>See Also</h3>

<p>All these functions are used by the ordered factor computation functions <code><a href="#topic+ordFacReg">ordFacReg</a></code> 
and <code><a href="#topic+ordFacRegCox">ordFacRegCox</a></code>.</p>

<hr>
<h2 id='ordFacReg'>Compute least squares or logistic regression for ordered predictors</h2><span id='topic+ordFacReg'></span>

<h3>Description</h3>

<p>This function computes estimates in least squares or logistic regression where coefficients corresponding to
dummy variables of ordered factors are estimated to be in non-decreasing order and at least 0.
An active set algorithm as described in Duembgen et al. (2007) is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordFacReg(D, Z, fact, ordfact, ordering = NA, type = c("LS", "logreg"), 
    intercept = TRUE, display = 0, eps = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordFacReg_+3A_d">D</code></td>
<td>
<p>Response vector, either in <code class="reqn">R^n</code> (least squares) or in <code class="reqn">\{0, 1\}^n</code> (logistic).</p>
</td></tr>
<tr><td><code id="ordFacReg_+3A_z">Z</code></td>
<td>
<p>Matrix of predictors. Factors are coded with levels from 1 to <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="ordFacReg_+3A_fact">fact</code></td>
<td>
<p>Specify columns in <code class="reqn">Z</code> that correspond to unordered factors.</p>
</td></tr>
<tr><td><code id="ordFacReg_+3A_ordfact">ordfact</code></td>
<td>
<p>Specify columns in <code class="reqn">Z</code> that correspond to ordered factors.</p>
</td></tr>
<tr><td><code id="ordFacReg_+3A_ordering">ordering</code></td>
<td>
<p>Vector of the same length as <code>ordfact</code>. Specifies ordering of ordered factors: <code>"i"</code> means
that the coefficients of the corresponding ordered factor are estimated in non-decreasing order and <code>"d"</code> means
non-increasing order. See the examples below for details.</p>
</td></tr>
<tr><td><code id="ordFacReg_+3A_type">type</code></td>
<td>
<p>Specify type of response variable.</p>
</td></tr>
<tr><td><code id="ordFacReg_+3A_intercept">intercept</code></td>
<td>
<p>If <code>TRUE</code>, an intercept (= column of all 1's) is added to the design matrix.</p>
</td></tr>
<tr><td><code id="ordFacReg_+3A_display">display</code></td>
<td>
<p>If <code>display == 1</code> progress of the algorithm is output.</p>
</td></tr>
<tr><td><code id="ordFacReg_+3A_eps">eps</code></td>
<td>
<p>Quantity to which the criterion in the Basic Procedure 2 in Duembgen et al. (2007) is compared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed description of the problem and the algorithm we refer to Rufibach (2010).</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>L</code></td>
<td>
<p>Value of the criterion function at the maximum.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Computed regression coefficients.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Set <code class="reqn">A</code> of active constraints.</p>
</td></tr>
<tr><td><code>design.matrix</code></td>
<td>
<p>Design matrix that was generated.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <br /> <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a></p>


<h3>References</h3>

<p>Duembgen, L., Huesler, A. and Rufibach, K. (2010).
Active set and EM algorithms for log-concave densities based on complete and censored data.
Technical report 61, IMSV, Univ. of Bern, available at <a href="http://arxiv.org/abs/0707.4643">http://arxiv.org/abs/0707.4643</a>.
</p>
<p>Rufibach, K. (2010).
An Active Set Algorithm to Estimate Parameters in Generalized Linear Models with Ordered Predictors.
<em>Comput. Statist. Data Anal.</em>, <b>54</b>, 1442-1456.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordFacRegCox">ordFacRegCox</a></code> computes estimates for Cox-regression.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ========================================================
## To illustrate least squares estimation, we generate the same data
## that was used in Rufibach (2010), Table 1.
## ========================================================

## --------------------------------------------------------
## initialization
## --------------------------------------------------------
n &lt;- 200
Z &lt;- NULL
intercept &lt;- FALSE

## --------------------------------------------------------
## quantitative variables
## --------------------------------------------------------
n.q &lt;- 3
set.seed(14012009)
if (n.q &gt; 0){for (i in 1:n.q){Z &lt;- cbind(Z, rnorm(n, mean = 1, sd = 2))}}

## --------------------------------------------------------
## unordered factors
## --------------------------------------------------------
un.levels &lt;- 3
for (i in 1:length(un.levels)){Z &lt;- cbind(Z, sample(rep(1:un.levels[i], 
    each = ceiling(n / un.levels)))[1:n])}
fact &lt;- n.q + 1:length(un.levels)

## --------------------------------------------------------
## ordered factors
## --------------------------------------------------------
levels &lt;- 8
for (i in 1:length(un.levels)){Z &lt;- cbind(Z, sample(rep(1:levels[i], 
    each = ceiling(n / levels)))[1:n])}
ordfact &lt;- n.q + length(un.levels) + 1:length(levels)

## --------------------------------------------------------
## generate data matrices
## --------------------------------------------------------
Y &lt;- prepareData(Z, fact, ordfact, ordering = NA, intercept)$Y

## --------------------------------------------------------
## generate response
## --------------------------------------------------------
D &lt;- apply(Y * matrix(c(rep(c(2, -3, 0), each = n), rep(c(1, 1), each = n), 
    rep(c(0, 2, 2, 2, 2, 5, 5), each = n)), ncol = ncol(Y)), 1, sum) + 
    rnorm(n, mean = 0, sd = 4)

## --------------------------------------------------------
## compute estimates
## --------------------------------------------------------
res1 &lt;- lmLSE(D, Y)
res2 &lt;- ordFacReg(D, Z, fact, ordfact, ordering = "i", type = "LS", intercept, 
    display = 1, eps = 0)
b1 &lt;- res1$beta
g1 &lt;- lmSS(b1, D, Y)$dL
b2 &lt;- res2$beta
g2 &lt;- lmSS(b2, D, Y)$dL
Ls &lt;- c(lmSS(b1, D, Y)$L, lmSS(b2, D, Y)$L)
names(Ls) &lt;- c("LSE", "ordFact") 
disp &lt;- cbind(1:length(b1), round(cbind(b1, g1, cumsum(g1)), 4), 
    round(cbind(b2, g2, cumsum(g2)), 4))

## --------------------------------------------------------
## display results
## --------------------------------------------------------
disp
Ls

## ========================================================
## Artificial data is used to illustrate logistic regression.
## ========================================================

## --------------------------------------------------------
## initialization
## --------------------------------------------------------
set.seed(1977)
n &lt;- 500
Z &lt;- NULL
intercept &lt;- FALSE

## --------------------------------------------------------
## quantitative variables
## --------------------------------------------------------
n.q &lt;- 2
if (n.q &gt; 0){for (i in 1:n.q){Z &lt;- cbind(Z, rnorm(n, rgamma(2, 2, 1)))}}

## --------------------------------------------------------
## unordered factors
## --------------------------------------------------------
un.levels &lt;- c(8, 2)
for (i in 1:length(un.levels)){Z &lt;- cbind(Z, sample(round(runif(n, 0, 
    un.levels[i] - 1)) + 1))}
fact &lt;- n.q + 1:length(un.levels)

## --------------------------------------------------------
## ordered factors
## --------------------------------------------------------
levels &lt;- c(2, 4, 10)
for (i in 1:length(levels)){Z &lt;- cbind(Z, sample(round(runif(n, 0, 
    levels[i] - 1)) + 1))}
ordfact &lt;- n.q + length(un.levels) + 1:length(levels)

## --------------------------------------------------------
## generate response
## --------------------------------------------------------
D &lt;- sample(c(rep(0, n / 2), rep(1, n/2)))

## --------------------------------------------------------
## generate design matrix
## --------------------------------------------------------
Y &lt;- prepareData(Z, fact, ordfact, ordering = NA, intercept)$Y

## --------------------------------------------------------
## compute estimates
## --------------------------------------------------------
res1 &lt;- matrix(glm.fit(Y, D, family = binomial(link = logit))$coefficients, ncol = 1)
res2 &lt;- ordFacReg(D, Z, fact, ordfact, ordering = NA, type = "logreg", 
    intercept = intercept, display = 1, eps = 0)
b1 &lt;- res1
g1 &lt;- logRegDeriv(b1, D, Y)$dL
b2 &lt;- res2$beta
g2 &lt;- logRegDeriv(b2, D, Y)$dL
Ls &lt;- unlist(c(logRegLoglik(res1, D, Y), res2$L))
names(Ls) &lt;- c("MLE", "ordFact") 
disp &lt;- cbind(1:length(b1), round(cbind(b1, g1, cumsum(g1)), 4), 
    round(cbind(b2, g2, cumsum(g2)), 4))

## --------------------------------------------------------
## display results
## --------------------------------------------------------
disp
Ls

## --------------------------------------------------------
## compute estimates when the third ordered factor should
## have *decreasing* estimated coefficients
## --------------------------------------------------------
res3 &lt;- ordFacReg(D, Z, fact, ordfact, ordering = c("i", "i", "d"), 
    type = "logreg", intercept = intercept, display = 1, eps = 0)
b3 &lt;- res3$beta
g3 &lt;- logRegDeriv(b3, D, Y)$dL
Ls &lt;- unlist(c(logRegLoglik(res1, D, Y), res2$L, res3$L))
names(Ls) &lt;- c("MLE", "ordFact ddd", "ordFact iid") 
disp &lt;- cbind(1:length(b1), round(cbind(b1, b2, b3), 4))

## --------------------------------------------------------
## display results
## --------------------------------------------------------
disp
Ls
</code></pre>

<hr>
<h2 id='ordFacRegCox'>Compute Cox-regression for ordered predictors</h2><span id='topic+ordFacRegCox'></span>

<h3>Description</h3>

<p>This function computes estimates in Cox-regression where coefficients corresponding to
dummy variables of ordered factors are estimated to be in non-decreasing order and at least 0.
An active set algorithm as described in Duembgen et al. (2007) is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordFacRegCox(ttf, tf, Z, fact, ordfact, ordering = NA, intercept = TRUE, 
    display = 0, eps = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordFacRegCox_+3A_ttf">ttf</code></td>
<td>
<p>Survival times.</p>
</td></tr>
<tr><td><code id="ordFacRegCox_+3A_tf">tf</code></td>
<td>
<p>Censoring indicator (1 = event, 0 = censored).</p>
</td></tr>
<tr><td><code id="ordFacRegCox_+3A_z">Z</code></td>
<td>
<p>Matrix of predictors. Factors are coded with levels from 1 to <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="ordFacRegCox_+3A_fact">fact</code></td>
<td>
<p>Specify columns in <code class="reqn">Z</code> that correspond to unordered factors.</p>
</td></tr>
<tr><td><code id="ordFacRegCox_+3A_ordfact">ordfact</code></td>
<td>
<p>Specify columns in <code class="reqn">Z</code> that correspond to ordered factors.</p>
</td></tr>
<tr><td><code id="ordFacRegCox_+3A_ordering">ordering</code></td>
<td>
<p>Vector of the same length as <code>ordfact</code>. Specifies ordering of ordered factors: <code>"i"</code> means
that the coefficients of the corresponding ordered factor are estimated in non-decreasing order and <code>"d"</code> means
non-increasing order. See the examples in <code>ordFacReg</code> for details.</p>
</td></tr>  
<tr><td><code id="ordFacRegCox_+3A_intercept">intercept</code></td>
<td>
<p>If <code>TRUE</code>, an intercept (= column of all 1's) is added to the design matrix.</p>
</td></tr>
<tr><td><code id="ordFacRegCox_+3A_display">display</code></td>
<td>
<p>If <code>display == 1</code> progress of the algorithm is output.</p>
</td></tr>
<tr><td><code id="ordFacRegCox_+3A_eps">eps</code></td>
<td>
<p>Quantity to which the criterion in the Basic Procedure 2 in Duembgen et al. (2007) is compared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed description of the problem and the algorithm we refer to Rufibach (2010).</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>L</code></td>
<td>
<p>Value of the criterion function at the maximum.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Computed regression coefficients.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Set <code class="reqn">A</code> of active constraints.</p>
</td></tr>
<tr><td><code>design.matrix</code></td>
<td>
<p>Design matrix that was generated.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <br /> <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a></p>


<h3>References</h3>

<p>Duembgen, L., Huesler, A. and Rufibach, K. (2010).
Active set and EM algorithms for log-concave densities based on complete and censored data.
Technical report 61, IMSV, Univ. of Bern, available at <a href="http://arxiv.org/abs/0707.4643">http://arxiv.org/abs/0707.4643</a>.
</p>
<p>Rufibach, K. (2010).
An Active Set Algorithm to Estimate Parameters in Generalized Linear Models with Ordered Predictors.
<em>Comput. Statist. Data Anal.</em>, <b>54</b>, 1442-1456.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordFacReg">ordFacReg</a></code> computes estimates for least squares and logistic regression.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ========================================================
## Artificial data is used to illustrate Cox-regression.
## ========================================================

## --------------------------------------------------------
## initialization
## --------------------------------------------------------
set.seed(1977)
n &lt;- 500
Z &lt;- NULL
intercept &lt;- FALSE

## --------------------------------------------------------
## quantitative variables
## --------------------------------------------------------
n.q &lt;- 2
if (n.q &gt; 0){for (i in 1:n.q){Z &lt;- cbind(Z, rnorm(n, rgamma(2, 2, 1)))}}

## --------------------------------------------------------
## unordered factors
## --------------------------------------------------------
un.levels &lt;- c(8, 2)[2]
for (i in 1:length(un.levels)){Z &lt;- cbind(Z, sample(round(runif(n, 0, 
    un.levels[i] - 1)) + 1))}
fact &lt;- n.q + 1:length(un.levels)

## --------------------------------------------------------
## ordered factors
## --------------------------------------------------------
levels &lt;- c(4, 5, 10)
for (i in 1:length(levels)){Z &lt;- cbind(Z, sample(round(runif(n, 0, 
    levels[i] - 1)) + 1))}
ordfact &lt;- n.q + length(un.levels) + 1:length(levels)

## --------------------------------------------------------
## generate response
## --------------------------------------------------------
ttf &lt;- rexp(n)
tf &lt;- round(runif(n))

## --------------------------------------------------------
## generate design matrix
## --------------------------------------------------------
Y &lt;- prepareData(Z, fact, ordfact, ordering = NA, intercept)$Y

## --------------------------------------------------------
## compute estimates
## --------------------------------------------------------
res1 &lt;- eha::coxreg.fit(Y, Surv(ttf, tf), max.survs = length(tf), 
    strats = rep(1, length(tf)))$coefficients
res2 &lt;- ordFacRegCox(ttf, tf, Z, fact, ordfact, ordering = NA, 
    intercept = intercept, display = 1, eps = 0)
b1 &lt;- matrix(res1, ncol = 1)
g1 &lt;- coxDeriv(b1, ttf, tf, Y)$dL
b2 &lt;- res2$beta
g2 &lt;- coxDeriv(b2, ttf, tf, Y)$dL
Ls &lt;- c(coxLoglik(b1, ttf, tf, Y)$L, res2$L)
names(Ls) &lt;- c("MLE", "ordFact") 
disp &lt;- cbind(1:length(b1), round(cbind(b1, g1, cumsum(g1)), 4), 
    round(cbind(b2, g2, cumsum(g2)), 4))

## --------------------------------------------------------
## display results
## --------------------------------------------------------
disp
Ls
</code></pre>

<hr>
<h2 id='prepareData'>Prepare input data to be used in active set algorithm</h2><span id='topic+prepareData'></span>

<h3>Description</h3>

<p>This function takes a matrix consisting of quantitative variables, unordered, and ordered factors
and generates the corresponding matrix of dummy variables, and some further quantities that are used
by the active set algorithm in <code><a href="#topic+ordFacReg">ordFacReg</a></code> and <code><a href="#topic+ordFacRegCox">ordFacRegCox</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareData(Z, fact = NA, ordfact, ordering = NA, intercept = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepareData_+3A_z">Z</code></td>
<td>
<p>Matrix with quantitative variables in the first <code class="reqn">c</code> columns, unordered factors in the next columns, 
and finally unordered factors. The latter two need to have levels from <code class="reqn">1</code> to <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_fact">fact</code></td>
<td>
<p>Specify columns in <code class="reqn">Z</code> that correspond to unordered factors.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_ordfact">ordfact</code></td>
<td>
<p>Specify columns in <code class="reqn">Z</code> that correspond to ordered factors.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_ordering">ordering</code></td>
<td>
<p>Vector of the same length as <code>ordfact</code>. Specifies ordering of ordered factors: <code>"i"</code> means
that the coefficients of the corresponding ordered factor are estimated in non-decreasing order and <code>"d"</code> means
non-increasing order. See the examples in <code>ordFacReg</code> for details.</p>
</td></tr>  
<tr><td><code id="prepareData_+3A_intercept">intercept</code></td>
<td>
<p>If <code>TRUE</code>, an intercept (= column of all 1's) is added to the design matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Quantities that are used by the active set algorithm. The names of the objects roughly correspond to
those in Rufibach (2010).</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <br /> <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a></p>


<h3>References</h3>

<p>Rufibach, K. (2010).
An Active Set Algorithm to Estimate Parameters in Generalized Linear Models with Ordered Predictors.
<em>Comput. Statist. Data Anal.</em>, <b>54</b>, 1442-1456.
</p>


<h3>See Also</h3>

<p>This function is used by the ordered factor computation functions <code><a href="#topic+ordFacReg">ordFacReg</a></code> 
and <code><a href="#topic+ordFacRegCox">ordFacRegCox</a></code>.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
