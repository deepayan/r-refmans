<!DOCTYPE html><html><head><title>Help for package longROC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {longROC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auc'><p>AUC</p></a></li>
<li><a href='#butstrap'><p>Bootstrapping AUC</p></a></li>
<li><a href='#butstrap.nri'><p>Bootstrapping NRI</p></a></li>
<li><a href='#butstrap.s'><p>Bootstrapping AUC</p></a></li>
<li><a href='#maxauc'><p>Optimal Score</p></a></li>
<li><a href='#maxauc.s'><p>Optimal Score</p></a></li>
<li><a href='#nri'><p>NRI</p></a></li>
<li><a href='#plotAUC'><p>AUC as a function of time</p></a></li>
<li><a href='#plotAUC.s'><p>AUC as a function of time</p></a></li>
<li><a href='#plotROC'><p>Plot ROC</p></a></li>
<li><a href='#roc'><p>ROC curve</p></a></li>
<li><a href='#roc.'><p>ROC curve</p></a></li>
<li><a href='#sensspec'><p>Sensitivity and Specificity</p></a></li>
<li><a href='#sensspec.s'><p>Sensitivity and Specificity</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time-Dependent Prognostic Accuracy with Multiply Evaluated Bio
Markers or Scores</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-11-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessio Farcomeni</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessio Farcomeni &lt;alessio.farcomeni@uniroma1.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Time-dependent Receiver Operating Characteristic curves, Area Under the Curve, and Net Reclassification Indexes for repeated measures. It is based on methods in Barbati and Farcomeni (2017) &lt;<a href="https://doi.org/10.1007%2Fs10260-017-0410-2">doi:10.1007/s10260-017-0410-2</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>survival</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-11-19 15:54:49 UTC; afarcome</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-11-20 12:17:47 UTC</td>
</tr>
</table>
<hr>
<h2 id='auc'>AUC</h2><span id='topic+auc'></span>

<h3>Description</h3>

<p>Compute area under the ROC curve</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(ss) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_ss">ss</code></td>
<td>
<p>Matrix with two columns (1-specificities,
sensitivities). It can be simply the output of <code>roc</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Area under the ROC curve.  
</p>


<h3>Value</h3>

<p>A scalar with the AUC. 
</p>


<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods &amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+roc">roc</a></cite>, <cite><a href="#topic+butstrap">butstrap</a></cite>, <cite><a href="#topic+maxauc">maxauc</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=100
tt=3
Tmax=10
u=1.5
s=2
vtimes=c(0,1,2,5)

# generate data 

ngrid=5000
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

## 

## an important marker 

ro=roc(S2,Ti,delta,u,tt,s,vtimes) 
auc(ro)

## an unrelated marker 

ro=roc(S1,Ti,delta,u,tt,s,vtimes) 
auc(ro)

</code></pre>

<hr>
<h2 id='butstrap'>Bootstrapping AUC</h2><span id='topic+butstrap'></span>

<h3>Description</h3>

<p>Boostrap the AUC for significance testing and confidence
interval calculation</p>


<h3>Usage</h3>

<pre><code class='language-R'>butstrap(X,etime,status,u=NULL,tt,s,vtimes,auc1,B=50,fc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="butstrap_+3A_x">X</code></td>
<td>
<p>n by S matrix of longitudinal score/biomarker for i-th
subject at j-th occasion (NA if unmeasured)</p>
</td></tr>
<tr><td><code id="butstrap_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="butstrap_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="butstrap_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity. Defaults to <code>vtimes[s]</code> (see below)</p>
</td></tr>
<tr><td><code id="butstrap_+3A_tt">tt</code></td>
<td>
<p>Upper limit (time-horizon) for evaluation of sensitivity
and specificity.</p>
</td></tr>
<tr><td><code id="butstrap_+3A_s">s</code></td>
<td>
<p>Scalar number of measurements/visits to use for each subject. s&lt;=S</p>
</td></tr>
<tr><td><code id="butstrap_+3A_vtimes">vtimes</code></td>
<td>
<p>S vector with visit times</p>
</td></tr>
<tr><td><code id="butstrap_+3A_auc1">auc1</code></td>
<td>
<p>AUC for the original data set</p>
</td></tr>
<tr><td><code id="butstrap_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates. Defaults to <code>50</code></p>
</td></tr>
<tr><td><code id="butstrap_+3A_fc">fc</code></td>
<td>
<p>Events are defined as fc = 1. Defaults to $I(cup X(t_j)&gt;cutoff)$</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to resample the AUC. The resulting p-value
is obtained after assumption that the resampled AUC is
Gaussian. Non-parametric confidence interval is obtained as the 2.5
and 97.5
confidence interval is simply given by a Gaussian approximation. 
</p>


<h3>Value</h3>

<p>A list with the following elements: 
</p>

<table>
<tr>
 <td style="text-align: left;">
 	<code>p.value</code> </td><td style="text-align: left;"> (Parametric) p-value for H0: AUC=0.5 </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>se</code> </td><td style="text-align: left;"> Standard deviation of the AUC replicates  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ci.np</code> </td><td style="text-align: left;"> Non-parametric 95% confidence interval for AUC  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ci.par</code> </td><td style="text-align: left;"> Parametric 95% confidence interval for AUC  </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods \&amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+roc">roc</a></cite>, <cite><a href="#topic+auc">auc</a></cite>, <cite><a href="#topic+maxauc">maxauc</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=100
tt=3
Tmax=10
u=1.5
s=2
vtimes=c(0,1,2,5)

# generate data 

ngrid=5000
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

## an unimportant marker 

ro=roc(S1,Ti,delta,u,tt,s,vtimes) 
but=butstrap(S1,Ti,delta,u,tt,s,vtimes,ro)

</code></pre>

<hr>
<h2 id='butstrap.nri'>Bootstrapping NRI</h2><span id='topic+butstrap.nri'></span>

<h3>Description</h3>

<p>Boostrap the AUC for significance testing and confidence
interval calculation</p>


<h3>Usage</h3>

<pre><code class='language-R'>butstrap.nri(risk1,risk2,etime,status,u,tt,nri1,wh,B=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="butstrap.nri_+3A_risk1">risk1</code></td>
<td>
<p>Baseline risk measurements</p>
</td></tr>
<tr><td><code id="butstrap.nri_+3A_risk2">risk2</code></td>
<td>
<p>Enhanced risk measurements</p>
</td></tr>
<tr><td><code id="butstrap.nri_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="butstrap.nri_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="butstrap.nri_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and specificity</p>
</td></tr>
<tr><td><code id="butstrap.nri_+3A_tt">tt</code></td>
<td>
<p>Upper limit (time-horizon) for evaluation of sensitivity
and specificity.</p>
</td></tr>
<tr><td><code id="butstrap.nri_+3A_nri1">nri1</code></td>
<td>
<p>NRI for the original data set</p>
</td></tr>
<tr><td><code id="butstrap.nri_+3A_wh">wh</code></td>
<td>
<p>Which NRI to boostrap? <code>wh=1</code> 1/2NRI, <code>wh=2</code> NRI
for events, <code>wh=3</code> NRI for non-events</p>
</td></tr>
<tr><td><code id="butstrap.nri_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates. Defaults to <code>1000</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to resample the NRI. The resulting p-value
is obtained after assumption that the resampled NRI is
Gaussian. Non-parametric confidence interval is obtained as the 2.5
and 97.5
confidence interval is simply given by a Gaussian approximation. 
</p>


<h3>Value</h3>

<p>A list with the following elements: 
</p>

<table>
<tr>
 <td style="text-align: left;">
 	<code>p.value</code> </td><td style="text-align: left;"> (Parametric) p-value for H0: NRI=0 </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>se</code> </td><td style="text-align: left;"> Standard deviation of the NRI replicates  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ci.np</code> </td><td style="text-align: left;"> Non-parametric 95% confidence interval for NRI  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ci.par</code> </td><td style="text-align: left;"> Parametric 95% confidence interval for NRI  </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods \&amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+nri">nri</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=25
tt=3
Tmax=10
u=1.5
s=2
vtimes=c(0,1,2,5)

# generate data 

ngrid=1000
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

risk1=apply(S1[,1:s],1,sum)
risk1=(risk1-min(risk1))/(max(risk1)-min(risk1))
risk2=apply(S2[,1:s],1,sum)
risk2=(risk2-min(risk2))/(max(risk2)-min(risk2))
butstrap.nri(risk1,risk2,Ti,delta,u,tt,nri(risk1,risk2,Ti,delta,u,tt)$nri,wh=1,B=500)


</code></pre>

<hr>
<h2 id='butstrap.s'>Bootstrapping AUC</h2><span id='topic+butstrap.s'></span>

<h3>Description</h3>

<p>Boostrap the AUC for significance testing and confidence
interval calculation</p>


<h3>Usage</h3>

<pre><code class='language-R'>butstrap.s(X,etime,status,u=NULL,tt,s,vtimes,auc1,B=50,fc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="butstrap.s_+3A_x">X</code></td>
<td>
<p>n by S matrix of longitudinal score/biomarker for i-th
subject at j-th occasion (NA if unmeasured)</p>
</td></tr>
<tr><td><code id="butstrap.s_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="butstrap.s_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="butstrap.s_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity. Defaults to <code>max(vtimes[s])</code> (see below)</p>
</td></tr>
<tr><td><code id="butstrap.s_+3A_tt">tt</code></td>
<td>
<p>Upper limit (time-horizon) for evaluation of sensitivity
and specificity.</p>
</td></tr>
<tr><td><code id="butstrap.s_+3A_s">s</code></td>
<td>
<p>n vector of number of measurements/visits to use for each subject. all(s&lt;=S)</p>
</td></tr>
<tr><td><code id="butstrap.s_+3A_vtimes">vtimes</code></td>
<td>
<p>S vector with visit times</p>
</td></tr>
<tr><td><code id="butstrap.s_+3A_auc1">auc1</code></td>
<td>
<p>AUC for the original data set</p>
</td></tr>
<tr><td><code id="butstrap.s_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replicates. Defaults to <code>50</code></p>
</td></tr>
<tr><td><code id="butstrap.s_+3A_fc">fc</code></td>
<td>
<p>Events are defined as fc = 1. Defaults to $I(cup X(t_j)&gt;cutoff)$</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to resample the AUC. The resulting p-value
is obtained after assumption that the resampled AUC is
Gaussian. Non-parametric confidence interval is obtained as the 2.5
and 97.5
confidence interval is simply given by a Gaussian approximation.  
</p>


<h3>Value</h3>

<p>A list with the following elements: 
</p>

<table>
<tr>
 <td style="text-align: left;">
 	<code>p.value</code> </td><td style="text-align: left;"> (Parametric) p-value for H0: AUC=0.5 </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>se</code> </td><td style="text-align: left;"> Standard deviation of the AUC replicates  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ci.np</code> </td><td style="text-align: left;"> Non-parametric 95% confidence interval for AUC  </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ci.par</code> </td><td style="text-align: left;"> Parametric 95% confidence interval for AUC  </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods \&amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+roc">roc</a></cite>, <cite><a href="#topic+auc">auc</a></cite>, <cite><a href="#topic+maxauc">maxauc</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=100
tt=3
Tmax=10
u=1.5
s=sample(3,n,replace=TRUE)
vtimes=c(0,1,2,5)

# generate data 

ngrid=5000
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

## an unimportant marker 

ro=roc.s(S1,Ti,delta,u,tt,s,vtimes) 
but=butstrap.s(S1,Ti,delta,u,tt,s,vtimes,ro)

</code></pre>

<hr>
<h2 id='maxauc'>Optimal Score</h2><span id='topic+maxauc'></span>

<h3>Description</h3>

<p>Compute optimal score for AUC</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxauc(X,etime,status,u=NULL,tt,s,vtimes,fc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxauc_+3A_x">X</code></td>
<td>
<p>p by n by S array of longitudinal scores/biomarkers for i-th
subject at j-th occasion (NA if unmeasured)</p>
</td></tr>
<tr><td><code id="maxauc_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="maxauc_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="maxauc_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity. Defaults to <code>vtimes[s]</code> (see below)</p>
</td></tr>
<tr><td><code id="maxauc_+3A_tt">tt</code></td>
<td>
<p>Upper limit (time-horizon) for evaluation of sensitivity
and specificity.</p>
</td></tr>
<tr><td><code id="maxauc_+3A_s">s</code></td>
<td>
<p>Scalar number of measurements/visits to use for each subject. s&lt;=S</p>
</td></tr>
<tr><td><code id="maxauc_+3A_vtimes">vtimes</code></td>
<td>
<p>S vector with visit times</p>
</td></tr>
<tr><td><code id="maxauc_+3A_fc">fc</code></td>
<td>
<p>Events are defined as fc = 1. Defaults to $I(cup X(t_j)&gt;cutoff)$</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to find an optimal linear combination of p
scores/biomarkers repeatedly measured over time. The resulting score
is optimal as it maximizes the AUC among all possible linear
combinations. The first biomarker in array X plays a special role, as
by default its coefficient is unitary. 
</p>


<h3>Value</h3>

<p>A list with the following elements: 
</p>

<table>
<tr>
 <td style="text-align: left;">
 	<code>beta</code> </td><td style="text-align: left;"> Beta coefficients for the optimal score </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>score</code> </td><td style="text-align: left;"> Optimal score </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods \&amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+auc">auc</a></cite>, <cite><a href="#topic+butstrap">butstrap</a></cite>, <cite><a href="#topic+maxauc">maxauc</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=25
tt=3
Tmax=10
u=1.5
s=2
vtimes=c(0,1,2,5)

# generate data 

ngrid=500
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

## 

X=array(NA,c(2,nrow(S1),ncol(S1)))
X[1,,]=round(S2) #fewer different values, quicker computation 
X[2,,]=S1

sc=maxauc(X,Ti,delta,u,tt,s,vtimes)

# beta coefficients

sc$beta

# final score (X[1,,]+X[2,,]*sc$beta[1]+...+X[p,,]*sc$beta[p-1])

sc$score

</code></pre>

<hr>
<h2 id='maxauc.s'>Optimal Score</h2><span id='topic+maxauc.s'></span>

<h3>Description</h3>

<p>Compute optimal score for AUC</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxauc.s(X,etime,status,u=NULL,tt,s,vtimes,fc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxauc.s_+3A_x">X</code></td>
<td>
<p>n by S matrix of longitudinal score/biomarker for i-th
subject at j-th occasion (NA if unmeasured)</p>
</td></tr>
<tr><td><code id="maxauc.s_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="maxauc.s_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="maxauc.s_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity. Defaults to <code>max(vtimes[s])</code> (see below)</p>
</td></tr>
<tr><td><code id="maxauc.s_+3A_tt">tt</code></td>
<td>
<p>Upper limit (time-horizon) for evaluation of sensitivity
and specificity.</p>
</td></tr>
<tr><td><code id="maxauc.s_+3A_s">s</code></td>
<td>
<p>n vector of number of measurements/visits to use for each subject. all(s&lt;=S)</p>
</td></tr>
<tr><td><code id="maxauc.s_+3A_vtimes">vtimes</code></td>
<td>
<p>S vector with visit times</p>
</td></tr>
<tr><td><code id="maxauc.s_+3A_fc">fc</code></td>
<td>
<p>Events are defined as fc = 1. Defaults to $I(cup X(t_j)&gt;cutoff)$</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to find an optimal linear combination of p
scores/biomarkers repeatedly measured over time. The resulting score
is optimal as it maximizes the AUC among all possible linear
combinations. The first biomarker in array X plays a special role, as
by default its coefficient is unitary. 
</p>


<h3>Value</h3>

<p>A list with the following elements: 
</p>

<table>
<tr>
 <td style="text-align: left;">
 	<code>beta</code> </td><td style="text-align: left;"> Beta coefficients for the optimal score </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>score</code> </td><td style="text-align: left;"> Optimal score </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods \&amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+auc">auc</a></cite>, <cite><a href="#topic+butstrap">butstrap</a></cite>, <cite><a href="#topic+maxauc">maxauc</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=20
tt=3
Tmax=10
u=1.5
s=sample(3,n,replace=TRUE)
vtimes=c(0,1,2,5)

# generate data 

ngrid=500
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

## 

X=array(NA,c(2,nrow(S1),ncol(S1)))
X[1,,]=round(S2) #fewer different values, quicker computation 
X[2,,]=S1

sc=maxauc.s(X,Ti,delta,u,tt,s,vtimes)

# beta coefficients

sc$beta

# final score (X[1,,]+X[2,,]*sc$beta[1]+...+X[p,,]*sc$beta[p-1])

sc$score
</code></pre>

<hr>
<h2 id='nri'>NRI</h2><span id='topic+nri'></span>

<h3>Description</h3>

<p>Compute NRI</p>


<h3>Usage</h3>

<pre><code class='language-R'>nri(risk1, risk2, etime,status,u,tt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nri_+3A_risk1">risk1</code></td>
<td>
<p>Baseline risk measures</p>
</td></tr>
<tr><td><code id="nri_+3A_risk2">risk2</code></td>
<td>
<p>Enhanced risk measures</p>
</td></tr>
<tr><td><code id="nri_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="nri_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="nri_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity.</p>
</td></tr>
<tr><td><code id="nri_+3A_tt">tt</code></td>
<td>
<p>Upper limit (time-horizon) for evaluation of sensitivity
and specificity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives the continuous NRI to compare two risk measures. 
</p>


<h3>Value</h3>

<p>A list with the following elements: 
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>nri</code> </td><td style="text-align: left;"> 1/2 NRI </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>nri.events</code> </td><td style="text-align: left;"> NRI for events </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>nri.nonevents</code> </td><td style="text-align: left;"> NRI for non-events </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods \&amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+butstrap.nri">butstrap.nri</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=100
tt=3
Tmax=10
u=1.5
s=2
vtimes=c(0,1,2,5)

# generate data 

ngrid=5000
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

risk1=apply(S1[,1:s],1,sum)
risk1=(risk1-min(risk1))/(max(risk1)-min(risk1))
risk2=apply(S2[,1:s],1,sum)
risk2=(risk2-min(risk2))/(max(risk2)-min(risk2))
nri(risk1,risk2,Ti,delta,u,tt)</code></pre>

<hr>
<h2 id='plotAUC'>AUC as a function of time</h2><span id='topic+plotAUC'></span>

<h3>Description</h3>

<p>Compute area under the ROC curve for several values of
time horizon</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAUC(X,etime,status,u=NULL,tt,s,vtimes,fc=NULL,plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAUC_+3A_x">X</code></td>
<td>
<p>n by S matrix of longitudinal score/biomarker for i-th
subject at j-th occasion (NA if unmeasured)</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity. Defaults to <code>vtimes[s]</code> (see below)</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_tt">tt</code></td>
<td>
<p>A vector of upper limits (time-horizons) for evaluation
of sensitivity and specificity.</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_s">s</code></td>
<td>
<p>Scalar number of measurements/visits to use for each subject. s&lt;=S</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_vtimes">vtimes</code></td>
<td>
<p>S vector with visit times</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_fc">fc</code></td>
<td>
<p>Events are defined as fc = 1. Defaults to $I(cup X(t_j)&gt;cutoff)$</p>
</td></tr>
<tr><td><code id="plotAUC_+3A_plot">plot</code></td>
<td>
<p>Do we plot the AUCs? Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Area under the ROC curve is computed for each value of the vector
tt. The resulting vector is returned. If <code>plot=TRUE</code> (which is
the default) also a plot of tt vs AUC is displayed. 
</p>


<h3>Value</h3>

<p>A vector with AUCs 
</p>


<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods &amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+roc">roc</a></cite>, <cite><a href="#topic+butstrap">butstrap</a></cite>, <cite><a href="#topic+auc">auc</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=25
tt=3
Tmax=10
u=1.5
s=2
vtimes=c(0,1,2,5)

# generate data 

ngrid=1000
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

## 

## an important marker 

aucs=plotAUC(S2,Ti,delta,u,seq(2,5,length=5),s,vtimes) 
</code></pre>

<hr>
<h2 id='plotAUC.s'>AUC as a function of time</h2><span id='topic+plotAUC.s'></span>

<h3>Description</h3>

<p>Compute area under the ROC curve for several values of
the time horizon</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAUC.s(X,etime,status,u=NULL,tt,s,vtimes,fc=NULL,plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAUC.s_+3A_x">X</code></td>
<td>
<p>n by S matrix of longitudinal score/biomarker for i-th
subject at j-th occasion (NA if unmeasured)</p>
</td></tr>
<tr><td><code id="plotAUC.s_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="plotAUC.s_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="plotAUC.s_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity. Defaults to <code>vtimes[s]</code> (see below)</p>
</td></tr>
<tr><td><code id="plotAUC.s_+3A_tt">tt</code></td>
<td>
<p>A vector of upper limits (time-horizons) for evaluation
of sensitivity and specificity.</p>
</td></tr>
<tr><td><code id="plotAUC.s_+3A_s">s</code></td>
<td>
<p>n vector of measurements/visits to use for each subject. all(s&lt;=S)</p>
</td></tr>
<tr><td><code id="plotAUC.s_+3A_vtimes">vtimes</code></td>
<td>
<p>S vector with visit times</p>
</td></tr>
<tr><td><code id="plotAUC.s_+3A_fc">fc</code></td>
<td>
<p>Events are defined as fc = 1. Defaults to $I(cup X(t_j)&gt;cutoff)$</p>
</td></tr>
<tr><td><code id="plotAUC.s_+3A_plot">plot</code></td>
<td>
<p>Do we plot the AUCs? Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Area under the ROC curve is computed for each value of the vector
tt. The resulting vector is returned. If <code>plot=TRUE</code> (which is
the default) also a plot of tt vs AUC is displayed. 
</p>


<h3>Value</h3>

<p>A vector with AUCs 
</p>


<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods &amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+roc.s">roc.s</a></cite>, <cite><a href="#topic+butstrap.s">butstrap.s</a></cite>, <cite><a href="#topic+auc">auc</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=25
tt=3
Tmax=10
u=1.5
s=sample(3,n,replace=TRUE)
vtimes=c(0,1,2,5)

# generate data 

ngrid=1000
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

## 

## an important marker 

aucs=plotAUC.s(S2,Ti,delta,u,seq(2,5,length=5),s,vtimes) 

</code></pre>

<hr>
<h2 id='plotROC'>Plot ROC</h2><span id='topic+plotROC'></span>

<h3>Description</h3>

<p>Plot the ROC curve</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotROC(ro, add=FALSE, col=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotROC_+3A_ro">ro</code></td>
<td>
<p>Matrix with two columns (1-specificities,
sensitivities). It can be simply the output of <code>roc</code> function</p>
</td></tr>
<tr><td><code id="plotROC_+3A_add">add</code></td>
<td>
<p>If <code>FALSE</code> (default) creates a new plot, otherwise
adds to the existing one</p>
</td></tr>
<tr><td><code id="plotROC_+3A_col">col</code></td>
<td>
<p>Colour for the ROC curve (defaults to red)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the area under the ROC curve.  
</p>


<h3>Value</h3>

<p>A plot or a new line in an open plot. 
</p>


<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods &amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+roc">roc</a></cite>, <cite><a href="#topic+roc.s">roc.s</a></cite>, <cite><a href="#topic+auc">auc</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=100
tt=3
Tmax=10
u=1.5
s=2
vtimes=c(0,1,2,5)

# generate data 

ngrid=5000
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

## 

## an important marker 

ro=roc(S2,Ti,delta,u,tt,s,vtimes) 
plotROC(ro)

## an unrelated marker 

ro=roc(S1,Ti,delta,u,tt,s,vtimes) 
plotROC(ro)

</code></pre>

<hr>
<h2 id='roc'>ROC curve</h2><span id='topic+roc'></span>

<h3>Description</h3>

<p>Compute ROC curve</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc(X,etime,status,u=NULL,tt,s,vtimes,fc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc_+3A_x">X</code></td>
<td>
<p>n by S matrix of longitudinal score/biomarker for i-th
subject at j-th occasion (NA if unmeasured)</p>
</td></tr>
<tr><td><code id="roc_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="roc_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="roc_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity. Defaults to <code>vtimes[s]</code> (see below)</p>
</td></tr>
<tr><td><code id="roc_+3A_tt">tt</code></td>
<td>
<p>Upper limit (time-horizon) for evaluation of sensitivity
and specificity.</p>
</td></tr>
<tr><td><code id="roc_+3A_s">s</code></td>
<td>
<p>Scalar number of measurements/visits to use for each subject. s&lt;=S</p>
</td></tr>
<tr><td><code id="roc_+3A_vtimes">vtimes</code></td>
<td>
<p>S vector with visit times</p>
</td></tr>
<tr><td><code id="roc_+3A_fc">fc</code></td>
<td>
<p>Events are defined as fc = 1. Defaults to $I(cup X(t_j)&gt;cutoff)$</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ROC curve is defined as the curve given by (1-specificities,
sensitivities). Here these are obtained for a time-dependent multiply-measured
marker are defined as 
</p>
<p>Se(t,c,s,u) = Pr(f_c(X(t_1),X(t_2),...,X(t_s_i))| u &lt;= T &lt;= t),
</p>
<p>and
</p>
<p>Sp(t,c,s,u) = 1-Pr(f_c(X(t_1),X(t_2),...,X(t_s_i)) | T &gt; t) 
</p>
<p>for some fixed f_c, where c is a cutoff. 
The default for f_c is that a positive diagnosis is given as soon as
any measurement among the s considered is above the threshold. 
</p>


<h3>Value</h3>

<p>A matrix with the following columns: 
</p>

<table>
<tr>
 <td style="text-align: left;">
 	<code>1-spec</code> </td><td style="text-align: left;"> 1-Specificities </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>sens</code> </td><td style="text-align: left;"> Sensitivities  </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods \&amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+auc">auc</a></cite>, <cite><a href="#topic+butstrap">butstrap</a></cite>, <cite><a href="#topic+maxauc">maxauc</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=100
tt=3
Tmax=10
u=1.5
s=2
vtimes=c(0,1,2,5)

# generate data 

ngrid=5000
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

## 

## an important marker 

ro=roc(S2,Ti,delta,u,tt,s,vtimes) 
plot(ro,type="l",col="red")
abline(a=0,b=1)

## an unrelated marker 

ro=roc(S1,Ti,delta,u,tt,s,vtimes) 
plot(ro,type="l",col="red")
abline(a=0,b=1)

</code></pre>

<hr>
<h2 id='roc.'>ROC curve</h2><span id='topic+roc.s'></span>

<h3>Description</h3>

<p>Compute ROC curve</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc.s(X,etime,status,u=NULL,tt,s,vtimes,fc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc._+3A_x">X</code></td>
<td>
<p>n by S matrix of longitudinal score/biomarker for i-th
subject at j-th occasion (NA if unmeasured)</p>
</td></tr>
<tr><td><code id="roc._+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="roc._+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="roc._+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity. Defaults to <code>max(vtimes[s])</code> (see below)</p>
</td></tr>
<tr><td><code id="roc._+3A_tt">tt</code></td>
<td>
<p>Upper limit (time-horizon) for evaluation of sensitivity
and specificity.</p>
</td></tr>
<tr><td><code id="roc._+3A_s">s</code></td>
<td>
<p>n vector of measurements/visits to use for each subject. all(s&lt;=S)</p>
</td></tr>
<tr><td><code id="roc._+3A_vtimes">vtimes</code></td>
<td>
<p>S vector with visit times</p>
</td></tr>
<tr><td><code id="roc._+3A_fc">fc</code></td>
<td>
<p>Events are defined as fc = 1. Defaults to $I(cup X(t_j)&gt;cutoff)$</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ROC curve is defined as the curve given by (1-specificities,
sensitivities). Here these are obtained for a time-dependent multiply-measured
marker are defined as 
</p>
<p>Se(t,c,s,u) = Pr(f_c(X(t_1),X(t_2),...,X(t_s_i))| u &lt;= T &lt;= t),
</p>
<p>and
</p>
<p>Sp(t,c,s,u) = 1-Pr(f_c(X(t_1),X(t_2),...,X(t_s_i)) | T &gt; t) 
</p>
<p>for some fixed f_c, where c is a cutoff. 
The default for f_c is that a positive diagnosis is given as soon as
any measurement among the s considered is above the threshold. 
</p>


<h3>Value</h3>

<p>A matrix with the following columns: 
</p>

<table>
<tr>
 <td style="text-align: left;">
 	<code>1-spec</code> </td><td style="text-align: left;"> 1-Specificities </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>sens</code> </td><td style="text-align: left;"> Sensitivities  </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods \&amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+auc">auc</a></cite>, <cite><a href="#topic+butstrap">butstrap</a></cite>, <cite><a href="#topic+maxauc">maxauc</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parameters
n=100
tt=3
Tmax=10
u=1.5
s=sample(3,n,replace=TRUE)
vtimes=c(0,1,2,5)

# generate data 

ngrid=5000
ts=seq(0,Tmax,length=ngrid)
X2=matrix(rnorm(n*ngrid,0,0.1),n,ngrid)
for(i in 1:n) {
sa=sample(ngrid/6,1)
vals=sample(3,1)-1
X2[i,1:sa[1]]=vals[1]+X2[i,1:sa[1]]
X2[i,(sa[1]+1):ngrid]=vals[1]+sample(c(-2,2),1)+X2[i,(sa[1]+1):ngrid]
}

S1=matrix(sample(4,n,replace=TRUE),n,length(vtimes))
S2=matrix(NA,n,length(vtimes))

S2[,1]=X2[,1]

for(j in 2:length(vtimes)) {
tm=which.min(abs(ts-vtimes[j]))
S2[,j]=X2[,tm]}

cens=runif(n)
ripart=1-exp(-0.01*apply(exp(X2),1,cumsum)*ts/1:ngrid)

Ti=rep(NA,n)
for(i in 1:n) {
Ti[i]=ts[which.min(abs(ripart[,i]-cens[i]))]
}

cens=runif(n,0,Tmax*2)
delta=ifelse(cens&gt;Ti,1,0)
Ti[cens&lt;Ti]=cens[cens&lt;Ti]

## 

## an important marker 

ro=roc.s(S2,Ti,delta,u,tt,s,vtimes) 
plot(ro,type="l",col="red")
abline(a=0,b=1)

## an unrelated marker 

ro=roc.s(S1,Ti,delta,u,tt,s,vtimes) 
plot(ro,type="l",col="red")
abline(a=0,b=1)

</code></pre>

<hr>
<h2 id='sensspec'>Sensitivity and Specificity</h2><span id='topic+sensspec'></span>

<h3>Description</h3>

<p>Compute sensitivity and specificity</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensspec(X,etime,status,u=NULL,tt,s,vtimes,cutoff=0,fc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensspec_+3A_x">X</code></td>
<td>
<p>n by S matrix of longitudinal score/biomarker for i-th
subject at j-th occasion (NA if unmeasured)</p>
</td></tr>
<tr><td><code id="sensspec_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="sensspec_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="sensspec_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity. Defaults to <code>vtimes[s]</code> (see below)</p>
</td></tr>
<tr><td><code id="sensspec_+3A_tt">tt</code></td>
<td>
<p>Upper limit (time-horizon) for evaluation of sensitivity
and specificity.</p>
</td></tr>
<tr><td><code id="sensspec_+3A_s">s</code></td>
<td>
<p>Scalar number of measurements/visits to use for each subject. s&lt;=S</p>
</td></tr>
<tr><td><code id="sensspec_+3A_vtimes">vtimes</code></td>
<td>
<p>S vector with visit times</p>
</td></tr>
<tr><td><code id="sensspec_+3A_cutoff">cutoff</code></td>
<td>
<p>cutoff for definining events. Defaults to <code>0</code></p>
</td></tr>
<tr><td><code id="sensspec_+3A_fc">fc</code></td>
<td>
<p>Events are defined as fc = 1. Defaults to $I(cup X(t_j)&gt;cutoff)$</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sensitivity and specificities for a time-dependent multiply-measured
marker are defined as 
</p>
<p>Se(t,c,s,u) = Pr(f_c(X(t_1),X(t_2),...,X(t_s_i))| u &lt;= T &lt;= t),
</p>
<p>and
</p>
<p>Sp(t,c,s,u) = 1-Pr(f_c(X(t_1),X(t_2),...,X(t_s_i)) | T &gt; t) 
</p>
<p>for some fixed f_c, where c is a cutoff. 
The default for f_c is that a positive diagnosis is given as soon as
any measurement among the s considered is above the threshold. 
</p>


<h3>Value</h3>

<p>A vector with the following elements: 
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>sens</code> </td><td style="text-align: left;"> Sensitivity at the cutoff </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>spec</code> </td><td style="text-align: left;"> Specificity at the cutoff </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods \&amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+roc">roc</a></cite>, <cite><a href="#topic+auc">auc</a></cite>, <cite><a href="#topic+butstrap">butstrap</a></cite>, <cite><a href="#topic+maxauc">maxauc</a></cite>
</p>

<hr>
<h2 id='sensspec.s'>Sensitivity and Specificity</h2><span id='topic+sensspec.s'></span>

<h3>Description</h3>

<p>Compute sensitivity and specificity</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensspec.s(X,etime,status,u=NULL,tt,s,vtimes,cutoff=0,fc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensspec.s_+3A_x">X</code></td>
<td>
<p>n by S matrix of longitudinal score/biomarker for i-th
subject at j-th occasion (NA if unmeasured)</p>
</td></tr>
<tr><td><code id="sensspec.s_+3A_etime">etime</code></td>
<td>
<p>n vector with follow-up times</p>
</td></tr>
<tr><td><code id="sensspec.s_+3A_status">status</code></td>
<td>
<p>n vector with event indicators</p>
</td></tr>
<tr><td><code id="sensspec.s_+3A_u">u</code></td>
<td>
<p>Lower limit for evaluation of sensitivity and
specificity. Defaults to <code>max(vtimes[s])</code> (see below)</p>
</td></tr>
<tr><td><code id="sensspec.s_+3A_tt">tt</code></td>
<td>
<p>Upper limit (time-horizon) for evaluation of sensitivity
and specificity.</p>
</td></tr>
<tr><td><code id="sensspec.s_+3A_s">s</code></td>
<td>
<p>n vector of measurements/visits to use for each subject. all(s&lt;=S)</p>
</td></tr>
<tr><td><code id="sensspec.s_+3A_vtimes">vtimes</code></td>
<td>
<p>S vector with visit times</p>
</td></tr>
<tr><td><code id="sensspec.s_+3A_cutoff">cutoff</code></td>
<td>
<p>cutoff for definining events. Defaults to <code>0</code></p>
</td></tr>
<tr><td><code id="sensspec.s_+3A_fc">fc</code></td>
<td>
<p>Events are defined as fc = 1. Defaults to $I(cup X(t_j)&gt;cutoff)$</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sensitivity and specificities for a time-dependent multiply-measured
marker are defined as 
</p>
<p>Se(t,c,s,u) = Pr(f_c(X(t_1),X(t_2),...,X(t_s_i))| u &lt;= T &lt;= t),
</p>
<p>and
</p>
<p>Sp(t,c,s,u) = 1-Pr(f_c(X(t_1),X(t_2),...,X(t_s_i)) | T &gt; t) 
</p>
<p>for some fixed f_c, where c is a cutoff. 
The default for f_c is that a positive diagnosis is given as soon as
any measurement among the s considered is above the threshold. 
</p>


<h3>Value</h3>

<p>A vector with the following elements: 
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>sens</code> </td><td style="text-align: left;"> Sensitivity at the cutoff </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>spec</code> </td><td style="text-align: left;"> Specificity at the cutoff </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Alessio Farcomeni <a href="mailto:alessio.farcomeni@uniroma1.it">alessio.farcomeni@uniroma1.it</a></p>


<h3>References</h3>

<p>Barbati, G. and Farcomeni, A. (2017) Prognostic assessment of
repeatedly measured time-dependent biomarkers, with application to
dilated cardiomuopathy, <em>Statistical Methods \&amp; Applications</em>, in
press 
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+roc">roc</a></cite>, <cite><a href="#topic+auc">auc</a></cite>, <cite><a href="#topic+butstrap">butstrap</a></cite>, <cite><a href="#topic+maxauc">maxauc</a></cite>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
