<!DOCTYPE html><html lang="en"><head><title>Help for package cultevo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cultevo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binaryfeaturematrix'><p>Convert a meaning matrix to a binary 'meaning-feature-present' matrix.</p></a></li>
<li><a href='#check.dist'><p>Check or fix a distance matrix.</p></a></li>
<li><a href='#count.substring.occurrences'><p>Count occurences of all possible substrings in one more strings.</p></a></li>
<li><a href='#enumerate.meaningcombinations'><p>Enumerate meaning combinations.</p></a></li>
<li><a href='#enumerate.substrings'><p>Enumerate all substrings of a string.</p></a></li>
<li><a href='#hammingdists'><p>Pairwise Hamming distances between matrix rows.</p></a></li>
<li><a href='#mantel.test'><p>Perform one or more Mantel permutation tests.</p></a></li>
<li><a href='#normalisedlevenshteindists'><p>Compute the normalised Levenshtein distances between strings.</p></a></li>
<li><a href='#orderinsensitivedists'><p>Calculate the bag-of-characters similarity between strings.</p></a></li>
<li><a href='#page.test'><p>Page test for monotonicity of ranks.</p></a></li>
<li><a href='#read.dist'><p>Read a distance matrix from a file or data frame.</p></a></li>
<li><a href='#repmatrix'><p>Extend a matrix by repetition of elements.</p></a></li>
<li><a href='#segment.string'><p>Split strings into their constituent segments.</p></a></li>
<li><a href='#shuffle.locations'><p>Permute the rows and columns of a square matrix.</p></a></li>
<li><a href='#sm.compositionality'><p>Spike's segmentation and measure of additive compositionality.</p></a></li>
<li><a href='#ssm.compositionality'><p>Find a segmentation that maximises the overall string coverage across all signals.</p></a></li>
<li><a href='#temperature.colors'><p>Create a vector of 'temperature' colors (from blue over white to red).</p></a></li>
<li><a href='#wrap.meaningdistfunction'><p>Make a meaning distance function vectorisable.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools, Measures and Statistical Tests for Cultural Evolution</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-04-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for measuring the compositionality of signalling systems (in particular the information-theoretic measure due to Spike (2016) <a href="http://hdl.handle.net/1842/25930">http://hdl.handle.net/1842/25930</a> and the Mantel test for distance matrix correlation (after Dietz 1983) &lt;<a href="https://doi.org/10.1093%2Fsysbio%2F32.1.21">doi:10.1093/sysbio/32.1.21</a>&gt;), functions for computing string and meaning distance matrices as well as an implementation of the Page test for monotonicity of ranks (Page 1963) &lt;<a href="https://doi.org/10.1080%2F01621459.1963.10500843">doi:10.1080/01621459.1963.10500843</a>&gt; with exact p-values up to k = 22.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kevinstadler.github.io/cultevo/">https://kevinstadler.github.io/cultevo/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kevinstadler/cultevo/issues">https://github.com/kevinstadler/cultevo/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>combinat, grDevices, graphics, Hmisc, pspearman, stats,
stringi, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>memoise, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-24 09:50:38 UTC; kevin</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Stadler [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Stadler &lt;a00425926@unet.univie.ac.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-24 10:28:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='binaryfeaturematrix'>Convert a meaning matrix to a binary 'meaning-feature-present' matrix.</h2><span id='topic+binaryfeaturematrix'></span>

<h3>Description</h3>

<p>Transforms a meaning matrix to 'wide' format where, instead of having
a column for every meaning dimension store all possible meaning values,
every possible value for any dimension is treated as its own categorical
'meaning feature' whose presence or absence is represented by a logical
<code>TRUE</code>/<code>FALSE</code> value in its own meaning feature column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binaryfeaturematrix(meanings, rownames = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binaryfeaturematrix_+3A_meanings">meanings</code></td>
<td>
<p>a matrix or data frame with meaning dimensions along columns
and different meaning combinations along rows (such as created by
<code><a href="#topic+enumerate.meaningcombinations">enumerate.meaningcombinations</a></code>).</p>
</td></tr>
<tr><td><code id="binaryfeaturematrix_+3A_rownames">rownames</code></td>
<td>
<p>optional character vector of the same length as the number
of rows of <code>meanings</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a matrix or data frame with meaning dimensions along columns and
different combinations of meaning feature values along rows, creates a
a matrix with the same number of rows but with one column for every
possible value for every meaning dimension.
</p>
<p>All meaning dimensions and values are treated <em>categorically</em>, i.e. as
factors with no gradual notion of meaning feature similarity, neither
within nor across the original meaning dimensions. Information about which
feature values correspond to which meaning dimensions is essentially
discarded in this representation, but could in principle be recovered
through the patterns of (non)-co-occurrence of different meaning features.
</p>
<p>In order for the resulting meaning columns to be interpretable, the column
names of the result are of the structure <code>columnname=value</code>, based on
the column names of the input meaning matrix (see Examples).
</p>


<h3>Value</h3>

<p>A matrix of <code>TRUE</code>/<code>FALSE</code> values with as many rows as
<code>meanings</code> and one column for every column-value combination in
<code>meanings</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>enumerate.meaningcombinations(c(2, 2))
binaryfeaturematrix(enumerate.meaningcombinations(c(2, 2)))
</code></pre>

<hr>
<h2 id='check.dist'>Check or fix a distance matrix.</h2><span id='topic+check.dist'></span>

<h3>Description</h3>

<p>Checks or fixes the given distance matrix specification and returns an
equivalent, symmetric <code>matrix</code> object with 0s in the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.dist(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.dist_+3A_x">x</code></td>
<td>
<p>an object (or list of objects) specifying a distance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the argument is a matrix, check whether it is a valid specification of a
distance matrix and return it, making it symmetric if it isn't already.
</p>
<p>If the argument is a list, calls <code>check.dist</code> on every of its elements
and returns a list of the results.
</p>
<p>For all other object types, attempts to coerce the argument to a <code>dist</code>
object and return the corresponding distance matrix (see above).
</p>


<h3>Value</h3>

<p>a symmetric <code>matrix</code> object (or list of such objects) of the
same dimension as <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>

<hr>
<h2 id='count.substring.occurrences'>Count occurences of all possible substrings in one more strings.</h2><span id='topic+count.substring.occurrences'></span>

<h3>Description</h3>

<p>Count occurences of all possible substrings in one more strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.substring.occurrences(strings, sortbylength = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count.substring.occurrences_+3A_strings">strings</code></td>
<td>
<p>a list or vector of character sequences</p>
</td></tr>
<tr><td><code id="count.substring.occurrences_+3A_sortbylength">sortbylength</code></td>
<td>
<p>logical indicating whether the substring columns should
be ordered according to the (decreasing) length of the substrings. Default
is to leave them in the original order in which they occur in the given
strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the original strings along rows and all substrings
of those strings along columns. The cell values indicate whether (and how
many times) the substring is contained in each of the strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count.substring.occurrences(c("asd", "asdd", "foo"))
</code></pre>

<hr>
<h2 id='enumerate.meaningcombinations'>Enumerate meaning combinations.</h2><span id='topic+enumerate.meaningcombinations'></span>

<h3>Description</h3>

<p>Enumerates all possible combinations of meanings for a meaning space of the
given dimensionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enumerate.meaningcombinations(dimensionality, uniquelabels = TRUE,
  offset = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enumerate.meaningcombinations_+3A_dimensionality">dimensionality</code></td>
<td>
<p>either a) a vector of integers specifying the number
of different possible values for every meaning dimension, or b) a list or
other (potentially ragged) 2-dimensional data structure listing the
possible meaning values for every dimension</p>
</td></tr>
<tr><td><code id="enumerate.meaningcombinations_+3A_uniquelabels">uniquelabels</code></td>
<td>
<p>logical, determines whether the same integers can be
reused across meaning dimensions or not. When <code>uniquelabels = FALSE</code>,
the resulting matrix will be very reminiscent of tables listing all binary
combinations of factors. Ignored when <code>dimensionality</code> specifies the
meaning values</p>
</td></tr>
<tr><td><code id="enumerate.meaningcombinations_+3A_offset">offset</code></td>
<td>
<p>a constant that is added to all meaning specifiers. Ignored
when <code>dimensionality</code> specifies the meaning values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting matrix can be passed straight on to
<code><a href="#topic+hammingdists">hammingdists</a></code> and other meaning distance functions created by
<code><a href="#topic+wrap.meaningdistfunction">wrap.meaningdistfunction</a></code>.
</p>


<h3>Value</h3>

<p>A matrix that has as many columns as there are dimensions, with
every row specifying one of the possible meaning combinations. The entries
of the first dimension cycle slowest (see examples).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hammingdists">hammingdists</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>enumerate.meaningcombinations(c(2, 2))
enumerate.meaningcombinations(c(3, 4))
enumerate.meaningcombinations(c(2, 2, 2, 2))
enumerate.meaningcombinations(8) # trivial
enumerate.meaningcombinations(list(shape=c("square", "circle"), color=c("red", "blue")))
</code></pre>

<hr>
<h2 id='enumerate.substrings'>Enumerate all substrings of a string.</h2><span id='topic+enumerate.substrings'></span>

<h3>Description</h3>

<p>Enumerate all substrings of a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enumerate.substrings(string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enumerate.substrings_+3A_string">string</code></td>
<td>
<p>a character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing all substrings of the string (including duplicates)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>enumerate.substrings("abccc")
</code></pre>

<hr>
<h2 id='hammingdists'>Pairwise Hamming distances between matrix rows.</h2><span id='topic+hammingdists'></span>

<h3>Description</h3>

<p>Returns a distance matrix giving all pairwise Hamming distances between the
rows of its argument <code>meanings</code>, which can be a matrix, data frame or
vector. Vectors are treated as matrices with a single column, so the
distances in its return value can only be 0 or 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hammingdists(meanings)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hammingdists_+3A_meanings">meanings</code></td>
<td>
<p>a matrix with the different dimensions encoded along
columns, and all combinations of meanings specified along rows. The data
type of the cells does not matter since distance is simply based on
equality (with the exception of <code>NA</code> values, see below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function behaves differently from calling
<code><a href="stats.html#topic+dist">dist</a>(meanings, method="manhattan")</code> in how <code>NA</code>
values are treated: specifying a meaning component as <code>NA</code> allows you
to <em>ignore</em> that dimension for the given row/meaning combinations,
(instead of counting a difference between <code>NA</code> and another value as a
distance of 1).
</p>


<h3>Value</h3>

<p>A distance matrix of type <code><a href="stats.html#topic+dist">dist</a></code> with <code>n*(n-1)/2</code>
rows/columns, where n is the number of rows in <code>meanings</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a 2x2 design using strings
print(strings &lt;- matrix(c("a1", "b1", "a1", "b2", "a2", "b1", "a2", "b2"),
  ncol=2, byrow=TRUE))
hammingdists(strings)

# a 2x3 design using integers
print(integers &lt;- matrix(c(0, 0, 0, 1, 0, 2, 1, 0, 1, 1, 1, 2), ncol=2, byrow=TRUE))
hammingdists(integers)

# a 3x2 design using factors (ncol is always the number of dimensions)
print(factors &lt;- data.frame(colour=c("red", "red", "green", "blue"),
                            animal=c("dog", "cat", "dog", "cat")))
hammingdists(factors)

# if some meaning dimension is not relevant for some combinations of
# meanings (e.g. optional arguments), specifying them as NA in the matrix
# will make them not be counted towards the hamming distance! in this
# example the value of the second dimension does not matter (and does not
# count towards the distance) when the the first dimension has value '1'
print(ignoredimension &lt;- matrix(c(0, 0, 0, 1, 1, NA), ncol=2, byrow=TRUE))
hammingdists(ignoredimension)

# trivial case of a vector: first and last two elements are identical,
# otherwise a difference of one
hammingdists(c(0, 0, 1, 1))
</code></pre>

<hr>
<h2 id='mantel.test'>Perform one or more Mantel permutation tests.</h2><span id='topic+mantel.test'></span><span id='topic+mantel.test.default'></span><span id='topic+mantel.test.formula'></span><span id='topic+mantel.test.list'></span><span id='topic+plot.mantel'></span>

<h3>Description</h3>

<p>Perform correlation tests between pairs of distance matrices. The Mantel
test is different from classical correlation tests (such as those
implemented by <code><a href="stats.html#topic+cor.test">cor.test</a></code>) in that the null distribution
(and significance level) are obtained through randomisation. The null
distribution is generated by shuffling the locations (matrix rows and
columns) of one of the matrices to calculate an empirical null distribution
for the given data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mantel.test(x, y, ...)

## Default S3 method:
mantel.test(x, y, plot = FALSE, method = c("spearman",
  "kendall", "pearson"), trials = 9999, omitzerodistances = FALSE, ...)

## S3 method for class 'formula'
mantel.test(x, y, groups = NULL,
  stringdistfun = utils::adist, meaningdistfun = hammingdists, ...)

## S3 method for class 'list'
mantel.test(x, y, plot = FALSE, ...)

## S3 method for class 'mantel'
plot(x, xlab = "generation", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mantel.test_+3A_x">x</code></td>
<td>
<p>a formula, distance matrix, or list of distance matrices (see below)</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_y">y</code></td>
<td>
<p>a data frame, distance matrix, or list of distance matrices of the
same length as <code>x</code></p>
</td></tr>
<tr><td><code id="mantel.test_+3A_...">...</code></td>
<td>
<p>further arguments which are passed on to the default method (in
particular <code>plot</code>, <code>method</code>, <code>trials</code> and <code>omitzerodistances</code>)</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_plot">plot</code></td>
<td>
<p>logical: immediately produce a plot of the test results (default:
<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_method">method</code></td>
<td>
<p>correlation coefficient to be computed. Passed on to
<code><a href="stats.html#topic+cor">cor</a></code>, so one of <code>"spearman"</code>, <code>"kendall"</code>, or, inadvisable
in the case of ties: <code>"pearson"</code>. Following Dietz (1983), <code>"spearman"</code> is
used as a default that is both powerful and robust across different
distance measures.</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_trials">trials</code></td>
<td>
<p>integer: maximum number of random permutations to be computed
(see Details).</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_omitzerodistances">omitzerodistances</code></td>
<td>
<p>logical: if <code>TRUE</code>, the calculation of the
correlation coefficient omits pairs of off-diagonal cells which contain a
0 in the <em>second</em> distance matrix argument. (For the formula
interface, this is the matrix which specifies the meaning distances.)</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_groups">groups</code></td>
<td>
<p>when <code>x</code> is a formula: column name by which the data in <code>y</code> is
split into separate data sets to run several Mantel tests on</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_stringdistfun">stringdistfun</code></td>
<td>
<p>when <code>x</code> is a formula: edit distance function used to
compute the distance matrix from the specified string column. Supports any
edit distance function that returns a distance matrix from a vector or
list of character strings. Default is Levenshtein distance
(<code><a href="utils.html#topic+adist">adist</a></code>), other options from this package include
<code><a href="#topic+normalisedlevenshteindists">normalisedlevenshteindists()</a></code> and <code><a href="#topic+orderinsensitivedists">orderinsensitivedists()</a></code>.</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_meaningdistfun">meaningdistfun</code></td>
<td>
<p>when <code>x</code> is a formula: meaning distance function used
to compute the distance matrix from the specified meaning columns.
Defaults to Hamming distances between meanings (<code><a href="#topic+hammingdists">hammingdists()</a></code>), custom
meaning functions can be created easily using
<code><a href="#topic+wrap.meaningdistfunction">wrap.meaningdistfunction()</a></code>.</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_xlab">xlab</code></td>
<td>
<p>the x axis label used when plotting the result of several Mantel
tests next to each other</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the number of possible permutations of the matrices is reasonably close
to the number of permutations specified by the <code>trials</code> parameter, a
deterministic enumeration of all the permutations will be carried out
instead of random sampling: such a deterministic test will return an exact
p-value.
</p>
<p><code>plot()</code> called on a data frame of class <code>mantel</code> plots a
visualisation of the test results (in particular, the distribution of
the permutated samples against the veridical correlation coefficient). If
the veridical correlation coefficient is plotted in blue it means
that it was higher than all other coefficients generated by random
permutations of the data. When the argument contains the result of more than
one Mantel tests, a side-by-side boxplot visualisation shows the mean and
standard deviation of the randomised samples (see examples). Additional
parameters <code>...</code> to <code>plot()</code> are passed on to
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>


<h3>Value</h3>

<p>A dataframe of class <code>mantel</code>, with one row per Mantel test carried
out, containing the following columns:
</p>

<dl>
<dt><code>method</code></dt><dd><p>Character string: type of correlation coefficient used</p>
</dd>
<dt><code>statistic</code></dt><dd><p>The veridical correlation coefficient between
the entries in the two distance matrices</p>
</dd>
<dt><code>rsample</code></dt><dd><p>A list of correlation coefficients calculated
from the permutations of the input matrices</p>
</dd>
<dt><code>mean</code></dt><dd><p>Average correlation coefficient produced by the permutations</p>
</dd>
<dt><code>sd</code></dt><dd><p>Standard deviation of the sampled correlation coefficients</p>
</dd>
<dt><code>p.value</code></dt><dd><p>Empirical p-value computed from the Mantel
test: let <code>ngreater</code> be the number of correlation coefficients
in <code>rsample</code> greater than or equal to <code>statistic</code>, then
<code>p.value</code> is <code>(ngreater+1)/(length(rsample)+1</code></p>
</dd>
<dt><code>p.approx</code></dt><dd><p>The theoretical p-value that would correspond
to the standard <code>z</code> score as calculated above.</p>
</dd>
<dt><code>is.unique.max</code></dt><dd><p>Logical, <code>TRUE</code> iff the veridical
correlation coefficient is greater than any of the coefficients
calculated for the permutations. If this is true, then
<code>p.value == 1 / (length(rsample)+1)</code></p>
</dd>
</dl>

<p>Multiple <code>mantel</code> objects can easily be combined by calling
<code>rbind(test1, test2, ...)</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Perform Mantel correlation test on two distance
matrices. The distance matrices can either be of type
<code><a href="stats.html#topic+dist">dist</a></code>, plain R matrices or any object that can be
interpreted by <code><a href="#topic+check.dist">check.dist</a></code>. The order of the two matrices does
not matter unless <code>omitzerodistances = TRUE</code>, in which case cells with
a 0 in the <em>second</em> matrix are omitted from the calculation of the
correlation coefficient. For consistency it is therefore recommended to
always pass the string distance matrix first, meaning distance matrix second.
</p>
</li>
<li> <p><code>formula</code>: This function can be called with raw experimental
result data frames, distance matrix calculation is taken care of internally.
<code>x</code> is a formula of the type <code>s ~ m1 + m2 + ...</code> where <code>s</code>
is the column name of the character strings in data frame or matrix <code>y</code>,
while <code>m1</code> etc. are the column names specifying the different meaning
dimensions. To calculate the respective distances, the function
<code>stringdistfun</code> is applied to the strings, <code>meaningdistfun</code> to the
meaning columns.
</p>
</li>
<li> <p><code>list</code>: When <code>x</code> is a list of distance matrices, and
<code>y</code> is either a single distance matrix or a list of distance matrices
the same length as <code>x</code>: runs a Mantel test for every pairwise
combination of distance matrices in <code>x</code> and <code>y</code> and returns a
<code>mantel</code> object with as many rows.
</p>
</li></ul>


<h3>References</h3>

<p>Dietz, E. J. 1983 “Permutation Tests for Association
Between Two Distance Matrices.” <em>Systematic Biology</em> 32 (1): 21-–26.
<a href="https://doi.org/10.1093/sysbio/32.1.21">https://doi.org/10.1093/sysbio/32.1.21</a>.
</p>
<p>North, B. V., D. Curtis and P. C. Sham. 2002 “A Note on the Calculation of
Empirical P Values from Monte Carlo Procedures.” <em>The American Journal of
Human Genetics</em> 71 (2): 439-–41. <a href="https://doi.org/10.1086/341527">https://doi.org/10.1086/341527</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>,
<code><a href="utils.html#topic+adist">adist</a></code>, <code><a href="#topic+hammingdists">hammingdists</a></code>,
<code><a href="#topic+normalisedlevenshteindists">normalisedlevenshteindists</a></code>,
<code><a href="#topic+orderinsensitivedists">orderinsensitivedists</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># small distance matrix, Mantel test run deterministically
mantel.test(dist(1:7), dist(1:7))


## Not run: 
# run test on smallest distance matrix which requires a random
# permutation test, and plot it
plot(mantel.test(dist(1:8), dist(1:8), method="kendall"))

## End(Not run)

## Not run: 
# 2x2x2x2 design
mantel.test(hammingdists(enumerate.meaningcombinations(c(2, 2, 2, 2))),
  dist(1:16), plot=TRUE)

## End(Not run)

# using the formula interface in combination with a data frame:
print(data &lt;- cbind(word=c("aa", "ab", "ba", "bb"),
  enumerate.meaningcombinations(c(2, 2))))

mantel.test(word ~ Var1 + Var2, data)

## Not run: 
# pass a list of distance matrices as the first argument, but just one
# distance matrix as the second argument: this runs separate tests on
# the pairwise combinations of the first and second argument
result &lt;- mantel.test(list(dist(1:8), dist(sample(8:1)), dist(runif(8))),
  hammingdists(enumerate.meaningcombinations(c(2, 2, 2))))

# print the result of the three independently run permutation tests
print(result)

# show the three test results in one plot
plot(result, xlab="group")

## End(Not run)
</code></pre>

<hr>
<h2 id='normalisedlevenshteindists'>Compute the normalised Levenshtein distances between strings.</h2><span id='topic+normalisedlevenshteindists'></span>

<h3>Description</h3>

<p>Compute the normalised Levenshtein distances between strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalisedlevenshteindists(strings)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalisedlevenshteindists_+3A_strings">strings</code></td>
<td>
<p>a vector or list of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix specifying all pairwise normalised Levenshtein
distances between the strings.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalisedlevenshteindists(c("abd", "absolute", "asdasd", "casd"))
</code></pre>

<hr>
<h2 id='orderinsensitivedists'>Calculate the bag-of-characters similarity between strings.</h2><span id='topic+orderinsensitivedists'></span>

<h3>Description</h3>

<p>Calculate the bag-of-characters similarity between strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderinsensitivedists(strings = NULL, split = NULL,
  segmentcounts = segment.counts(strings, split))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderinsensitivedists_+3A_strings">strings</code></td>
<td>
<p>a vector or list of strings</p>
</td></tr>
<tr><td><code id="orderinsensitivedists_+3A_split">split</code></td>
<td>
<p>boundary sequency at which to segment the strings (default
splits the string into all its constituent characters)</p>
</td></tr>
<tr><td><code id="orderinsensitivedists_+3A_segmentcounts">segmentcounts</code></td>
<td>
<p>if custom segmentation is required, the pre-segmented
strings can be passed as this argument (which is a list of lists)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance matrix
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orderinsensitivedists(c("xxxx", "asdf", "asd", "dsa"))
</code></pre>

<hr>
<h2 id='page.test'>Page test for monotonicity of ranks.</h2><span id='topic+page.test'></span><span id='topic+page.L'></span><span id='topic+page.compute.exact'></span>

<h3>Description</h3>

<p>Given <code>N</code> replications of <code>k</code> different treatments/conditions,
tests whether the <em>median ordinal ranks</em> <code class="reqn">m_i</code> of the treatments
are identical </p>
<p style="text-align: center;"><code class="reqn">m_1 = m_2 = \ldots = m_k</code>
</p>
<p> against the alternative
hypothesis </p>
<p style="text-align: center;"><code class="reqn">m_1 \leq m_2 \leq \ldots \leq m_k</code>
</p>
<p> where <em>at least
one</em> of the inequalities is a strict inequality (Siegel and Castellan
1988, p.184). Given that even a single point change in the distribution of
ranks across conditions represents evidence against the null hypothesis,
the Page test is simply a test for <em>some ordered differences in
ranks</em>, but not a 'trend test' in any meaningful way (see also the
<a href="https://kevinstadler.github.io/cultevo/articles/page.test.html">Page test tutorial</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>page.test(data, verbose = TRUE)

page.L(data, verbose = TRUE, ties.method = "average")

page.compute.exact(k, N, L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="page.test_+3A_data">data</code></td>
<td>
<p>a matrix with the different conditions along its <code>k</code>
columns and the <code>N</code> replications along rows. Conversion of the data
to ordinal ranks is taken care of internally.</p>
</td></tr>
<tr><td><code id="page.test_+3A_verbose">verbose</code></td>
<td>
<p>whether to print the final rankings based on which the L
statistic is computed</p>
</td></tr>
<tr><td><code id="page.test_+3A_ties.method">ties.method</code></td>
<td>
<p>how to resolve tied ranks. Passed on to
<code><a href="base.html#topic+rank">rank</a></code>, should be left on &quot;average&quot; (the default).</p>
</td></tr>
<tr><td><code id="page.test_+3A_k">k</code></td>
<td>
<p>number of conditions/generations</p>
</td></tr>
<tr><td><code id="page.test_+3A_n">N</code></td>
<td>
<p>number of replications/chains</p>
</td></tr>
<tr><td><code id="page.test_+3A_l">L</code></td>
<td>
<p>value of the Page L statistic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests the given matrix for monotonically <em>increasing</em> ranks across <code>k</code>
linearly ordered conditions (along columns) based on <code>N</code> replications
(along rows). To test for monotonically <em>decreasing</em> ranks, either reverse
the order of columns, or simply invert the rank ordering by calling <code>-</code> on
the entire dataset.
</p>
<p>Exact p-values are computed for <code>k</code> up to 22, using the pre-computed null
distributions from the
<a href="https://CRAN.R-project.org/package=pspearman">pspearman</a> package. For
larger <code>k</code>, p-values are computed based on a Normal distribution
approximation (Siegel and Castellan, 1988).
</p>


<h3>Value</h3>

<p><code>page.test</code> returns a list of class <code>pagetest</code> (and
<code>htest</code>) containing the following elements:
</p>

<dl>
<dt><code>statistic</code></dt><dd><p>value of the L statistic for the data set</p>
</dd>
<dt><code>parameter</code></dt><dd><p>a named vector specifying the number of
conditions (k) and replications (N) of the data (which is the number of
columns and rows of the data set, respectively)</p>
</dd>
<dt><code>p.value</code></dt><dd><p>significance level</p>
</dd>
<dt><code>p.type</code></dt><dd><p>whether the computed p-value is <code>"exact"</code> or
<code>"approximate"</code></p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>page.test</code>: See above.
</p>
</li>
<li> <p><code>page.L</code>: Calculate Page's L statistic for the given dataset.
</p>
</li>
<li> <p><code>page.compute.exact</code>: Calculate exact significance levels of the Page L
statistic. Returns a single numeric indicating the null probability of
the Page statistic with the given <code>k</code>, <code>N</code> being greater or equal than the
given <code>L</code>.
</p>
</li></ul>


<h3>References</h3>

<p>Siegel, S., and N. J. Castellan, Jr. (1988). Nonparametric
Statistics for the Behavioral Sciences. McGraw-Hill.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rank">rank</a></code>, <a href="https://kevinstadler.github.io/cultevo/articles/page.test.html">Page test tutorial</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># exact p value computation for N=4, k=4
page.test(t(replicate(4, sample(4))))

# exact p value computation for N=4, k=10
page.test(t(replicate(4, sample(10))))

# approximate p value computation for N=4, k=23
result &lt;- page.test(t(replicate(4, sample(23))), verbose = FALSE)

print(result)

# raw calculation of the significance levels
page.compute.exact(6, 4, 322)
</code></pre>

<hr>
<h2 id='read.dist'>Read a distance matrix from a file or data frame.</h2><span id='topic+read.dist'></span>

<h3>Description</h3>

<p>Read a distance matrix from a file or data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.dist(data, el1.column = 1, el2.column = 2, dist.columns = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.dist_+3A_data">data</code></td>
<td>
<p>a filename, data frame or matrix</p>
</td></tr>
<tr><td><code id="read.dist_+3A_el1.column">el1.column</code></td>
<td>
<p>the column name or id specifying the first element</p>
</td></tr>
<tr><td><code id="read.dist_+3A_el2.column">el2.column</code></td>
<td>
<p>the column name or id specifying the second element</p>
</td></tr>
<tr><td><code id="read.dist_+3A_dist.columns">dist.columns</code></td>
<td>
<p>the column name(s) or id(s) specifying the distance(s)
between the two corresponding elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance matrix (or list of distance matrixes when there is more
than one <code>dist.columns</code>) of type <code>matrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read.dist(cbind(c(1,1,1,2,2,3), c(2,3,4,3,4,4), 1:6, 6:1), dist.columns=c(3,4))
</code></pre>

<hr>
<h2 id='repmatrix'>Extend a matrix by repetition of elements.</h2><span id='topic+repmatrix'></span>

<h3>Description</h3>

<p>Returns a new matrix, where the entries of the original matrix are
repeated along both dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repmatrix(x, times = 1, each = 1, times.row = times, times.col = times,
  each.row = each, each.col = each, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repmatrix_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="repmatrix_+3A_times">times</code></td>
<td>
<p>how often the matrix should be replicated next to itself</p>
</td></tr>
<tr><td><code id="repmatrix_+3A_each">each</code></td>
<td>
<p>how often individual cells should be replicated next to themselves</p>
</td></tr>
<tr><td><code id="repmatrix_+3A_times.row">times.row</code></td>
<td>
<p>number of vertical repetitions of the matrix, overrides <code>times</code></p>
</td></tr>
<tr><td><code id="repmatrix_+3A_times.col">times.col</code></td>
<td>
<p>number of horizontal repetitions of the matrix, overrides <code>times</code></p>
</td></tr>
<tr><td><code id="repmatrix_+3A_each.row">each.row</code></td>
<td>
<p>number of vertical repetitions of individual elements, overrides <code>each</code></p>
</td></tr>
<tr><td><code id="repmatrix_+3A_each.col">each.col</code></td>
<td>
<p>number of horizontal repetitions of individual elements, overrides <code>each</code></p>
</td></tr>
<tr><td><code id="repmatrix_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, which will have <code>times*each</code> times more rows and
columns than the original matrix.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rep">rep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repmatrix(diag(4))
repmatrix(diag(4), times=2)
repmatrix(diag(4), each=2)
repmatrix(diag(3), times=2, each=2)
repmatrix(diag(4), each.row=2)
repmatrix(diag(4), times.row=2)
</code></pre>

<hr>
<h2 id='segment.string'>Split strings into their constituent segments.</h2><span id='topic+segment.string'></span><span id='topic+segment.counts'></span>

<h3>Description</h3>

<p>Split strings into their constituent segments (and count them).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.string(x, split = NULL)

segment.counts(x, split = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segment.string_+3A_x">x</code></td>
<td>
<p>one or more strings to be split (and, optionally, counted)</p>
</td></tr>
<tr><td><code id="segment.string_+3A_split">split</code></td>
<td>
<p>the boundary character or sequence at which to segment the
string(s). The default, <code>NULL</code>, splits the string after every character.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>segment.string</code>: Returns a list (of the same length as <code>x</code>), each item a vector of
character vectors.
</p>
</li>
<li> <p><code>segment.counts</code>: Calculate the frequency of individual characters in one or more strings.
Returns a matrix with one row for every string in <code>x</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>segment.string(c("asd", "fghj"))

segment.string(c("la-dee-da", "lala-la"), "-")
segment.counts(c("asd", "aasd", "asdf"))
</code></pre>

<hr>
<h2 id='shuffle.locations'>Permute the rows and columns of a square matrix.</h2><span id='topic+shuffle.locations'></span>

<h3>Description</h3>

<p>Returns the given matrix with rows and columns permuted in the same order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle.locations(m, perm = sample.int(dim(m)[1]))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle.locations_+3A_m">m</code></td>
<td>
<p>a matrix with an equal number of rows and columns</p>
</td></tr>
<tr><td><code id="shuffle.locations_+3A_perm">perm</code></td>
<td>
<p>vector of indices specifying the new order of rows/columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the same size as <code>m</code>
</p>

<hr>
<h2 id='sm.compositionality'>Spike's segmentation and measure of additive compositionality.</h2><span id='topic+sm.compositionality'></span><span id='topic+sm.segmentation'></span>

<h3>Description</h3>

<p>Implementation of the Spike-Montague segmentation and measure of additive
compositionality (Spike 2016), which finds the most predictive associations
between meaning features and substrings. Computation is deterministic and
fast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm.compositionality(x, y, groups = NULL, strict = FALSE)

sm.segmentation(x, y, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sm.compositionality_+3A_x">x</code></td>
<td>
<p>a list or vector of character sequences specifying the signals to
be analysed. Alternatively, <code>x</code> can also be a formula of the format
<code>s ~ m1 + m2 + ...</code>, where <code>s</code> and <code>m1</code>, <code>m2</code>, etc.
specify the column names of the signals and meaning features found in the
data frame that is passed as the second argument.</p>
</td></tr>
<tr><td><code id="sm.compositionality_+3A_y">y</code></td>
<td>
<p>a matrix or data frame with as many rows as there are signals,
indicating the presence/value of the different meaning dimensions along
columns (see section Meaning data format). If <code>x</code> is a formula, the
<code>y</code> data frame can contain any number of columns, but only the ones
whose column name is specified in the formula will be considered.</p>
</td></tr>
<tr><td><code id="sm.compositionality_+3A_groups">groups</code></td>
<td>
<p>a list or vector with as many items as strings, used to split
<code>strings</code> and <code>meanings</code> into data sets for which
compositionality measures are computed separately.</p>
</td></tr>
<tr><td><code id="sm.compositionality_+3A_strict">strict</code></td>
<td>
<p>logical: if <code>TRUE</code>, perform additional filtering of
candidate segments. In particular, it removes combinations of segments
(across meanings) which overlap in at least one of the strings where they
co-occur. For convenience, it also removes segments which are shorter
substrings of longer candidates (for the same meaning feature).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm works on compositional meanings that can be expressed as sets
of categorical meaning features (see below), and does not take the order
of elements into account. Rather than looking directly at how complex
meanings are expressed, the measure really captures the degree to which a
homonymy- and synonymy-free signalling system exists at the level of
<em>individual semantic features</em>.
</p>
<p>The segmentation algorithm provided by <code>sm.segmentation()</code> scans through
all sub-strings found in <code>strings</code> to find the pairings of meaning features
and sub-strings whose respective presence is <em>most predictive of each
other</em>. Mathematically, for every meaning feature <code class="reqn">f\in M</code>, it finds
the sub-string <code class="reqn">s_{ij}</code> from the set of strings <code class="reqn">S</code> that yields the
highest <em>mutual predictability</em> across all signals,
</p>
<p style="text-align: center;"><code class="reqn">mp(f,S) = \max_{s_{ij}\in S}\ P(f|s_{ij}) \cdot P(s_{ij}|f)\;.</code>
</p>

<p>Based on the mutual predictability levels obtained for the individual
meaning features, <code>sm.compositionality</code> then computes the mean mutual
predictability weighted by the individual features' relative frequencies of
attestation, i.e.
</p>
<p style="text-align: center;"><code class="reqn">mp(M,S) = \sum_{f\in M} freq_f \cdot mp(f,S)\;,</code>
</p>

<p>as a measure of the overall compositionality of the signalling system.
</p>
<p>Since mutual predictability is determined seperately for every meaning
feature, the most predictive sub-strings posited for different meaning
features as returned by <code>sm.segmentation()</code> can overlap, and even coincide
completely. Such results are generally indicative of either limited data
(in particular frequent co-occurrence of the meaning features in question),
or spurious results in the absence of a consistent signalling system. The
latter will also be indicated by the significance level of the given mutual
predictability.
</p>


<h3>Value</h3>

<p><code>sm.segmentation</code> provides detailed information about the most
predictably co-occurring segments for every meaning feature. It returns
a data frame with one row for every meaning feature, in descending order
of the mutual predictability from (and to) their corresponding string
segments. The data frame has the following columns:
</p>

<dl>
<dt><code>N</code></dt><dd><p>The number of signal-meaning pairings in which this
meaning feature was attested.</p>
</dd>
<dt><code>mp</code></dt><dd><p>The highest mutual predictability between this
meaning feature and one (or more) segments that was found.</p>
</dd>
<dt><code>p</code></dt><dd><p>Significance levels of the given mutual predictability,
i.e. the probability that the given mutual predictability level could
be reached by chance. The calculation depends on the frequency of the
meaning feature as well as the number and relative frequency of all
substrings across all signals (see below).</p>
</dd>
<dt><code>ties</code></dt><dd><p>The number of substrings found in <code>strings</code>
which have this same level of mutual predictability with the meaning
feature.</p>
</dd>
<dt><code>segments</code></dt><dd><p>For <code>strict=FALSE</code>: a list containing the
<code>ties</code> substrings in descending order of their length (the
ordering is for convenience only and not inherently meaningful). When
<code>strict=TRUE</code>, the lists of segments for each meaning feature
are all of the same length, with a meaningful relationship of the
order of segments across the different rows: every set of segments
which are found in the same position for each of the different
meaning features constitute a valid segmentation where the segments
occurrences in the actual signals do not overlap.</p>
</dd>
</dl>

<p><code>sm.compositionality</code> calculates the weighted average of the
mutual predictability of all meaning features and their most predictably
co-occurring strings, as computed by <code>sm.segmentation</code>. The function
returns a data frame of three columns:
<code>N</code> is the total number of signals (utterances) on which the computation
was based, <code>M</code> the number of distinct meaning features attested across
all signals, and <code>meanmp</code> the mean mutual predictability across all these
features, weighted by the features' relative frequency. When <code>groups</code> is
not <code>NULL</code>, the data frame contains one row for every group.
</p>


<h3>Null distribution and p-value calculation</h3>

<p>A perfectly unambiguous mapping between a meaning feature to a specific
string segment will always yield a mutual predictability of <code>1</code>. In the
absence of such a regular mapping, on the other hand, chance co-occurrences
of strings and meanings will in most cases stop the mutual predictability
from going all the way down to <code>0</code>. In order to help distinguish chance
co-occurrence levels from significant signal-meaning associations,
<code>sm.segmentation()</code> provides significance levels for the mutual
predictability levels obtained for each meaning feature.
</p>
<p>What is the baseline level of association between a meaning feature and a
set of sub-strings that we would expect to be due to chance co-occurrences?
This depends on several factors, from the number of data points on which the
analysis is based to the frequency of the meaning feature in question and,
perhaps most importantly, the overall makeup of the different substrings
that are present in the signals. Since every substring attested in the data
is a candidate for signalling the presence of a meaning feature, the
absolute number of different substrings greatly affects the likelihood of
chance signal-meaning associations. (Diversity of the set of substrings is
in turn heavily influenced by the size of the underlying alphabet, a factor
which is often not appreciated.)
</p>
<p>For every candidate substring, the degree of association with a specific
meaning feature that we would expect by chance is again dependent on the
absolute number of signals in which the substring is attested.
</p>
<p>Starting from the simplest case, take a meaning that is featured in <code class="reqn">m</code>
of the total <code class="reqn">n</code> signals (where <code class="reqn">0 &lt; m \leq n</code>). Assume next that
there is a string segment that is attested in <code class="reqn">s</code> of these signals
(where again <code class="reqn">0 &lt; s \leq n</code>). The degree of association between the
meaning feature and string segment is dependent on the number of times that
they co-occur, which can be no more than <code class="reqn">c_{max} = min(m, s)</code> times.
The null probability of getting a given number of co-occurrences can be
obtained by considering all possible reshufflings of the meaning feature in
question across all signals: if <code class="reqn">s</code> signals contain a given substring,
how many of <code class="reqn">s</code> randomly drawn signals from the pool of <code class="reqn">n</code> signals
would contain the meaning feature if a total of <code class="reqn">m</code> signals in the pool
did? Approached from this angle, the likelihood of the number of
co-occurrences follows the
<a href="https://en.wikipedia.org/wiki/Hypergeometric_distribution">hypergeometric distribution</a>,
with <code class="reqn">c</code> being the number of successes when taking <code class="reqn">s</code> draws without
replacement from a population of size <code class="reqn">n</code> with fixed number of successes
<code class="reqn">m</code>.
</p>
<p>For every number of co-occurrences <code class="reqn">c \in [0, c_{max}]</code>, one can
compute the corresponding mutual probability level as
<code class="reqn">p(c|s) \cdot p(c|m)</code> to obtain the null distribution of mutual
predictability levels between a meaning feature and <em>one</em> substring of a
particular frequency <code class="reqn">s</code>:
</p>
<p style="text-align: center;"><code class="reqn">Pr(mp = p(c|s) \cdot p(c|m)) = f(k=c; N=n, K=m, n=s)</code>
</p>

<p>From this, we can now derive the null distribution for the entire set of
attested substrings as follows: making the simplifying assumption that the
occurrences of different substrings are independent of each other, we first
aggregate over the null distributions of all the individual substrings to
obtain the mean probability <code class="reqn">p=Pr(X\ge mp)</code> of finding a given mutual
predictability level at least as high as <code class="reqn">mp</code> for one randomly drawn
string from the entire population of substrings. Assuming the total number
of candidate substrings is <code class="reqn">|S|</code>, the overall null probability that at
least one of them would yield a mutual predictability at least as high is
</p>
<p style="text-align: center;"><code class="reqn">Pr(X\ge 0), X \equiv B(n=|S|, p=p)\;.</code>
</p>

<p>Note that, since the null distribution also depends on the frequency with
which the meaning feature is attested, the significance levels corresponding
to a given mutual predictability level are not necessarily identical for
all meaning features, even within one analysis.
</p>
<p>(In theory, one can also compute an overall p-value of the weighted mean
mutual predictability as calculated by <code>sm.compositionality</code>. However, the
significance levels for the individual meaning features are much more
insightful and should therefore be consulted directly.)
</p>


<h3>Meaning data format</h3>

<p>The <code>meanings</code> argument can be a matrix or data frame in one of two formats.
If it is a matrix of logicals (<code>TRUE</code>/<code>FALSE</code> values), then the columns are
assumed to refer to meaning <em>features</em>, with individual cells indicating
whether the meaning feature is present or absent in the signal represented
by that row (see <code><a href="#topic+binaryfeaturematrix">binaryfeaturematrix()</a></code> for an explanation). If <code>meanings</code>
is a data frame or matrix of any other type, it is assumed that the columns
specify different meaning dimensions, with the cell values showing the
levels with which the different dimensions can be realised. This
dimension-based representation is automatically converted to a
feature-based one by calling <code><a href="#topic+binaryfeaturematrix">binaryfeaturematrix()</a></code>. As a consequence,
whatever the actual types of the columns in the meaning matrix, <em>they will
be treated as categorical factors</em> for the purpose of this algorithm, also
discarding any explicit knowledge of which 'meaning dimension' they might
belong to.
</p>


<h3>References</h3>

<p>Spike, M. 2016 <em>Minimal requirements for the cultural
evolution of language</em>. PhD thesis, The University of Edinburgh.
<a href="http://hdl.handle.net/1842/25930">http://hdl.handle.net/1842/25930</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binaryfeaturematrix">binaryfeaturematrix()</a></code>, <code><a href="#topic+ssm.compositionality">ssm.compositionality()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># perfect communication system for two meaning features (which are marked
# as either present or absent)
sm.compositionality(c("a", "b", "ab"),
  cbind(a=c(TRUE, FALSE, TRUE), b=c(FALSE, TRUE, TRUE)))
sm.segmentation(c("a", "b", "ab"),
  cbind(a=c(TRUE, FALSE, TRUE), b=c(FALSE, TRUE, TRUE)))

# not quite perfect communication system
sm.compositionality(c("as", "bas", "basf"),
  cbind(a=c(TRUE, FALSE, TRUE), b=c(FALSE, TRUE, TRUE)))
sm.segmentation(c("as", "bas", "basf"),
  cbind(a=c(TRUE, FALSE, TRUE), b=c(FALSE, TRUE, TRUE)))

# same communication system, but force candidate segments to be non-overlapping
# via the 'strict' option
sm.segmentation(c("as", "bas", "basf"),
  cbind(a=c(TRUE, FALSE, TRUE), b=c(FALSE, TRUE, TRUE)), strict=TRUE)


# the function also accepts meaning-dimension based matrix definitions:
print(twobytwoanimals &lt;- enumerate.meaningcombinations(c(animal=2, colour=2)))

# note how there are many more candidate segments than just the full length
# ones. the less data we have, the more likely it is that shorter substrings
# will be just as predictable as the full segments that contain them.
sm.segmentation(c("greendog", "bluedog", "greencat", "bluecat"), twobytwoanimals)

# perform the same analysis, but using the formula interface
print(twobytwosignalingsystem &lt;- cbind(twobytwoanimals,
  signal=c("greendog", "bluedog", "greencat", "bluecat")))

sm.segmentation(signal ~ colour + animal, twobytwosignalingsystem)

# since there is no overlap in the constituent characters of the identified
# 'morphemes', they are all tied in their mutual predictiveness with the
# (shorter) substrings they contain
#
# to reduce the pool of candidate segments to those which are
# non-overlapping and of maximal length, again use the 'strict=TRUE' option:

sm.segmentation(signal ~ colour + animal, twobytwosignalingsystem, strict=TRUE)

</code></pre>

<hr>
<h2 id='ssm.compositionality'>Find a segmentation that maximises the overall string coverage across all signals.</h2><span id='topic+ssm.compositionality'></span><span id='topic+ssm.segmentation'></span>

<h3>Description</h3>

<p>This algorithm builds on Spike's measure of compositionality (see
<code><a href="#topic+sm.compositionality">sm.compositionality</a></code>), except instead of simply determining
which segment(s) have the highest mutual predictability for each
meaning feature separately, it attempts to find a combination of
non-overlapping segments for each feature that maximises the overall string
coverage over all signals. In other words, it tries to find a segmentation
which can account for (or 'explain') as much of the string material in the
signals as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssm.compositionality(x, y, groups = NULL)

ssm.segmentation(x, y, mergefeatures = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssm.compositionality_+3A_x">x</code></td>
<td>
<p>a list or vector of character sequences</p>
</td></tr>
<tr><td><code id="ssm.compositionality_+3A_y">y</code></td>
<td>
<p>a matrix or data frame with as many rows as there are
strings (see section Meaning data format)</p>
</td></tr>
<tr><td><code id="ssm.compositionality_+3A_groups">groups</code></td>
<td>
<p>a list or vector with as many items as strings, used to split
the signals and meanings into data sets for which the compositionality
measures are computed separately.</p>
</td></tr>
<tr><td><code id="ssm.compositionality_+3A_mergefeatures">mergefeatures</code></td>
<td>
<p>logical: if <code>TRUE</code>, <code>ssm.segmentation</code> will
try to improve on the initial solution by incrementally merging pairs of
meaning features as long as doing so improves the overall string coverage
of the segmentation.</p>
</td></tr>
<tr><td><code id="ssm.compositionality_+3A_verbose">verbose</code></td>
<td>
<p>logical: if <code>TRUE</code>, messages detailed information about
the number of segment combinations considered for every coverage computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For large data sets and long strings, this computation can get very slow.
If the attested signals are such that no perfect segmentation is possible,
this algorithm is not guaranteed to find any segmentation (as no such
segmentation might exist).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sm.compositionality">sm.compositionality</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ssm.segmentation(c("as", "bas", "basf"),
  cbind(a=c(TRUE, FALSE, TRUE), b=c(FALSE, TRUE, TRUE)))


# signaling system where one meaning distinction is not encoded in the signals
print(threebytwoanimals &lt;- enumerate.meaningcombinations(list(animal=c("dog", "cat", "tiger"),
  colour=c("col1", "col2"))))

ssm.segmentation(c("greendog", "bluedog", "greenfeline", "bluefeline", "greenfeline", "bluefeline"),
  threebytwoanimals)

# the same analysis again, but allow merging of features
ssm.segmentation(c("greendog", "bluedog", "greenfeline", "bluefeline", "greenfeline", "bluefeline"),
  threebytwoanimals, mergefeatures=TRUE)
</code></pre>

<hr>
<h2 id='temperature.colors'>Create a vector of 'temperature' colors (from blue over white to red).</h2><span id='topic+temperature.colors'></span>

<h3>Description</h3>

<p>Create a vector of 'temperature' colors (from blue over white to red).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temperature.colors(mn, mx = NULL, intensity = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="temperature.colors_+3A_mn">mn</code></td>
<td>
<p>integer: when <code>mx</code> is not specified, total number of colors
(&gt;1) in the palette. when <code>mx</code> is specified: 'coldest' temperature (see examples)</p>
</td></tr>
<tr><td><code id="temperature.colors_+3A_mx">mx</code></td>
<td>
<p>integer: 'warmest' temperature (see examples)</p>
</td></tr>
<tr><td><code id="temperature.colors_+3A_intensity">intensity</code></td>
<td>
<p>saturation of the most extreme color(s), in the range <code>[0,1]</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+gray">gray</a></code>, <code><a href="grDevices.html#topic+hsv">hsv</a></code>, <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># full intensity
image(as.matrix(1:7), z=as.matrix(1:7), col=temperature.colors(7))
# half intensity
image(as.matrix(1:7), z=as.matrix(1:7), col=temperature.colors(7, intensity=0.5))
# skewed palette with more negative than positive temperature colors
image(as.matrix(1:7), z=as.matrix(1:7), col=temperature.colors(-4, 2))
</code></pre>

<hr>
<h2 id='wrap.meaningdistfunction'>Make a meaning distance function vectorisable.</h2><span id='topic+wrap.meaningdistfunction'></span>

<h3>Description</h3>

<p>This function takes as its only argument a function <code>f(m1, m2)</code> which
returns a single numeric indicating the distance between two 'meanings'
<code>m1, m2</code> (which are themselves most likely vectors or lists). Based
on <code>f</code>, this function returns a function <code>g(mm)</code> which takes as
its only argument a matrix or data frame <code>mm</code> with the meaning
elements (equivalent to the ones in <code>m1, m2</code>) along columns and
different meaning combinations (like <code>m1, m2, ...</code>) along rows. This
function returns a distance matrix of class <code><a href="stats.html#topic+dist">dist</a></code>
containing all pairwise distances between the rows of <code>mm</code>. The
resulting function <code>g</code> can be passed to other functions in this
package, in particular <code><a href="#topic+mantel.test">mantel.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap.meaningdistfunction(pairwisemeaningdistfun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrap.meaningdistfunction_+3A_pairwisemeaningdistfun">pairwisemeaningdistfun</code></td>
<td>
<p>a function of two arguments returning a
single numeric indicating the semantic distance between its arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The meaning distance function should be commutative, i.e.
<code>f(a,b) = f(b,a)</code>, and meanings should have a distance of zero to
themselves, i.e. <code>f(a,a) = 0</code>.
</p>


<h3>Value</h3>

<p>A function that takes a meaning matrix and returns a corresponding
distance matrix of class <code><a href="stats.html#topic+dist">dist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trivialdistance &lt;- function(a, b) return(a - b)

trivialmeanings &lt;- as.matrix(3:1)
trivialdistance(trivialmeanings[1], trivialmeanings[2])
trivialdistance(trivialmeanings[1], trivialmeanings[3])
trivialdistance(trivialmeanings[2], trivialmeanings[3])

distmatrixfunction &lt;- wrap.meaningdistfunction(trivialdistance)
distmatrixfunction(trivialmeanings)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
