<!DOCTYPE html><html lang="en"><head><title>Help for package this.path</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {this.path}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#this.path-package'><p>Get Script's Path</p></a></li>
<li><a href='#basename2'><p>Manipulate File Paths</p></a></li>
<li><a href='#check.path'><p>Check 'this.path()' is Functioning Correctly</p></a></li>
<li><a href='#Enhances'><p>Functions That Enhance the Use of Other Packages</p></a></li>
<li><a href='#ext'><p>File Extensions</p></a></li>
<li><a href='#FILE'><p>Macros in Package 'this.path'</p></a></li>
<li><a href='#getinitwd'><p>Get Initial Working Directory</p></a></li>
<li><a href='#here'><p>Construct Path to File, Starting With Script's Directory</p></a></li>
<li><a href='#is.main'><p>Top-Level Code Environment</p></a></li>
<li><a href='#LINENO'><p>Line Number of Executing Expression</p></a></li>
<li><a href='#make_fix_funs'><p>Constructs Path Functions Similar to 'this.path()'</p></a></li>
<li><a href='#OS.type'><p>Detect the Operating System Type</p></a></li>
<li><a href='#path.join'><p>Construct Path to File</p></a></li>
<li><a href='#path.split'><p>Split File Path Into Individual Components</p></a></li>
<li><a href='#print.ThisPathDocumentContext'><p>Printing &quot;ThisPathDocumentContext&quot; Objects</p></a></li>
<li><a href='#progArgs'><p>Providing Arguments to a Script</p></a></li>
<li><a href='#R.from.shell'><p>Using R From a Shell</p></a></li>
<li><a href='#relpath'><p>Make a Path Relative to Another</p></a></li>
<li><a href='#set.gui.path'><p>Declare GUI's Active Document</p></a></li>
<li><a href='#set.jupyter.path'><p>Declare Executing 'Jupyter' Notebook's Filename</p></a></li>
<li><a href='#set.sys.path'><p>Implement 'this.path()' For Arbitrary 'source()'-Like Functions</p></a></li>
<li><a href='#shFILE'><p>Get 'FILE' Provided to R by a Shell</p></a></li>
<li><a href='#source.exprs'><p>Evaluate and Print Expressions</p></a></li>
<li><a href='#startup_files'><p>Files Related to Initialization of the R Session</p></a></li>
<li><a href='#sys'><p>Call Stack Inspection</p></a></li>
<li><a href='#sys.path'><p>Variants of Core Functions in Package 'this.path'</p></a></li>
<li><a href='#Sys.putenv'><p>Set Environment Variables</p></a></li>
<li><a href='#this.path'><p>Determine Script's Filename</p></a></li>
<li><a href='#this.path-defunct'><p>Defunct Functions in Package 'this.path'</p></a></li>
<li><a href='#try.this.path'><p>Attempt to Determine Script's Filename</p></a></li>
<li><a href='#tryCatch2'><p>Condition Handling and Recovery</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.6.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-18</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Title:</td>
<td>Get Executing Script's Path</td>
</tr>
<tr>
<td>Description:</td>
<td>Determine the path of the executing script. Compatible
        with several popular GUIs: 'Rgui', 'RStudio', 'Positron',
        'VSCode', 'Jupyter', 'Emacs', and 'Rscript' (shell). Compatible
        with several functions and packages: 'source()',
        'sys.source()', 'debugSource()' in 'RStudio',
        'compiler::loadcmp()', 'utils::Sweave()', 'box::use()',
        'knitr::knit()', 'plumber::plumb()', 'shiny::runApp()',
        'package:targets', and 'testthat::source_file()'.</td>
</tr>
<tr>
<td>Author:</td>
<td>Iris Simmons [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Iris Simmons &lt;ikwsimmo@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>utils, jsonlite, microbenchmark, rprojroot</td>
</tr>
<tr>
<td>Enhances:</td>
<td>compiler, box, knitr, plumber, shiny, targets, testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ArcadeAntics/this.path">https://github.com/ArcadeAntics/this.path</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ArcadeAntics/this.path/issues">https://github.com/ArcadeAntics/this.path/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Biarch:</td>
<td>TRUE</td>
</tr>
<tr>
<td>BuildManual:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-18 00:48:32 UTC; iris</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-18 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='this.path-package'>Get Script's Path</h2><span id='topic+this.path-package'></span>

<h3>Description</h3>

<p>Determine the path of the executing script.
</p>
<p>Compatible with several popular GUIs:
</p>

<ul>
<li><p>&lsquo;Rgui&rsquo;
</p>
</li>
<li><p>&lsquo;<a href="https://posit.co/products/open-source/rstudio/">RStudio</a>&rsquo; (including
<a href="https://docs.posit.co/ide/user/ide/guide/tools/jobs.html">background jobs</a>)
</p>
</li>
<li><p>&lsquo;<a href="https://github.com/posit-dev/positron">Positron</a>&rsquo;
</p>
</li>
<li><p>&lsquo;<a href="https://code.visualstudio.com/">VSCode</a>&rsquo; + &lsquo;<a href="https://code.visualstudio.com/docs/languages/r">REditorSupport</a>&rsquo;
</p>
</li>
<li><p>&lsquo;<a href="https://jupyter.org/">Jupyter</a>&rsquo;
</p>
</li>
<li><p>&lsquo;<a href="https://www.gnu.org/software/emacs/">Emacs</a>&rsquo; + &lsquo;<a href="https://ess.r-project.org/">ESS</a>&rsquo;
</p>
</li>
<li><p>&lsquo;<code><a href="utils.html#topic+Rscript">Rscript</a></code>&rsquo;
(shell)
</p>
</li></ul>

<p>Compatible with several functions and packages: </p>
<ul>
<li><p><code><a href="base.html#topic+source">source</a>()</code> </p>
</li>
<li><p><code><a href="base.html#topic+sys.source">sys.source</a>()</code> </p>
</li>
<li><p><a href="https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE"><code>debugSource</code></a><code>()</code> in &lsquo;<a href="https://posit.co/products/open-source/rstudio/">RStudio</a>&rsquo; </p>
</li>
<li><p><code><a href="compiler.html#topic+compile">compiler::loadcmp</a>()</code> </p>
</li>
<li><p><code><a href="utils.html#topic+Sweave">utils::Sweave</a>()</code> </p>
</li>
<li><p><code><a href="box.html#topic+use">box::use</a>()</code> </p>
</li>
<li><p><code><a href="knitr.html#topic+knit">knitr::knit</a>()</code> </p>
</li>
<li><p><code><a href="plumber.html#topic+plumb">plumber::plumb</a>()</code> </p>
</li>
<li><p><code><a href="shiny.html#topic+runApp">shiny::runApp</a>()</code> </p>
</li>
<li><p><a href="https://CRAN.R-project.org/package=targets"><span class="pkg">package:targets</span></a> </p>
</li>
<li><p><code><a href="testthat.html#topic+source_file">testthat::source_file</a>()</code></p>
</li></ul>



<h3>Details</h3>

<p>The most important functions from <span class="pkg">package:this.path</span> are
<code><a href="#topic+this.path">this.path</a>()</code>, <code><a href="#topic+this.dir">this.dir</a>()</code>, <code><a href="#topic+here">here</a>()</code>,
and <code><a href="#topic+this.proj">this.proj</a>()</code>:
</p>

<ul>
<li><p><code><a href="#topic+this.path">this.path</a>()</code> returns the normalized path of the script
in which it is written.
</p>
</li>
<li><p><code><a href="#topic+this.dir">this.dir</a>()</code> returns the directory of
<code>this.path()</code>.
</p>
</li>
<li><p><code><a href="#topic+here">here</a>()</code> constructs file paths against
<code>this.dir()</code>.
</p>
</li>
<li><p><code><a href="#topic+this.proj">this.proj</a>()</code> constructs file paths against the project
root of <code>this.dir()</code>.
</p>
</li></ul>

<p>New additions include:
</p>

<ul>
<li><p><code><a href="#topic+LINENO">LINENO</a>()</code> returns the line number of the executing
expression.
</p>
</li>
<li><p><code><a href="#topic+shFILE">shFILE</a>()</code> looks through the command line arguments,
extracting <span class="option">FILE</span> from either of the following: <span class="option">-f</span>
<span class="option">FILE</span> or <span class="option">--file=FILE</span>
</p>
</li>
<li><p><code><a href="#topic+set.sys.path">set.sys.path</a>()</code> implements <code><a href="#topic+this.path">this.path</a>()</code> for
any <code><a href="base.html#topic+source">source</a>()</code>-like functions outside of the builtins.
</p>
</li>
<li><p><code><a href="#topic+with_init.file">with_init.file</a>()</code> allows <code>this.path()</code> and related
to be used in a user profile.
</p>
</li></ul>

<p><span class="pkg">package:this.path</span> also provides functions for constructing and
manipulating file paths:
</p>

<ul>
<li><p><code><a href="#topic+path.join">path.join</a>()</code>, <code><a href="#topic+basename2">basename2</a>()</code>, and
<code><a href="#topic+dirname2">dirname2</a>()</code> are drop in replacements for
<code><a href="base.html#topic+file.path">file.path</a>()</code>, <code><a href="base.html#topic+basename">basename</a>()</code>, and
<code><a href="base.html#topic+basename">dirname</a>()</code> which better handle drives and
network shares.
</p>
</li>
<li><p><code><a href="#topic+splitext">splitext</a>()</code>, <code><a href="#topic+removeext">removeext</a>()</code>,
<code><a href="#topic+ext">ext</a>()</code>, and <code><a href="#topic+ext+3C-">ext&lt;-</a>()</code> split a path into root and
extension, remove a file extension, get an extension, or set an extension
for a file path.
</p>
</li>
<li><p><code><a href="#topic+path.split">path.split</a>()</code>, <code><a href="#topic+path.split.1">path.split.1</a>()</code>, and
<code><a href="#topic+path.unsplit">path.unsplit</a>()</code> split the path to a file into components.
</p>
</li>
<li><p><code><a href="#topic+relpath">relpath</a>()</code>, <code><a href="#topic+rel2here">rel2here</a>()</code>, and
<code><a href="#topic+rel2proj">rel2proj</a>()</code> turn absolute paths into relative paths.
</p>
</li></ul>



<h3>Note</h3>

<p>This package started from a stack overflow posting:
</p>
<p><a href="https://stackoverflow.com/questions/1815606/determine-path-of-the-executing-script/64129649#64129649">https://stackoverflow.com/questions/1815606/determine-path-of-the-executing-script/64129649#64129649</a>
</p>
<p>If you like this package, please consider upvoting my answer so that more
people will see it! If you have an issue with this package, please use
<code><a href="utils.html#topic+bug.report">bug.report</a>(package = "this.path")</code> to
report your issue.
</p>


<h3>Author(s)</h3>

<p>Iris Simmons [aut, cre]
</p>
<p>Maintainer: Iris Simmons &lt;ikwsimmo@gmail.com&gt;
</p>

<hr>
<h2 id='basename2'>Manipulate File Paths</h2><span id='topic+basename2'></span><span id='topic+dirname2'></span>

<h3>Description</h3>

<p><code>basename2()</code> removes all of the path up to and including the last path
separator (if any).
</p>
<p><code>dirname2()</code> returns the part of the <code>path</code> up to but excluding the
last path separator, or <code>"."</code> if there is no path separator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basename2(path)
dirname2(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basename2_+3A_path">path</code></td>
<td>
<p>character vector, containing path names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tilde-expansion (see <code>?<a href="base.html#topic+path.expand">path.expand</a>()</code>) of the path will
be performed.
</p>
<p>Trailing path separators are removed before dissecting the path, and for
<code>dirname2()</code> any trailing file separators are removed from the result.
</p>


<h3>Value</h3>

<p>A character vector of the same length as <code>path</code>.
</p>


<h3>Behaviour on Windows</h3>

<p>If <code>path</code> is an empty string, then both <code>dirname2()</code> and
<code>basename2()</code> return an emty string.
</p>
<p><code>\</code> and <code>/</code> are accepted as
path separators, and <code>dirname2()</code> does <strong>NOT</strong> translate the path
separators.
</p>
<p>Recall that a network share looks like <code>"//host/share"</code> and a drive
looks like <code>"d:"</code>.
</p>
<p>For a path which starts with a network share or drive, the path specification
is the portion of the string immediately afterward, e.g.
<code>"/path/to/file"</code> is the path specification of
<code>"//host/share/path/to/file"</code> and <code>"d:/path/to/file"</code>. For a path
which does not start with a network share or drive, the path specification is
the entire string.
</p>
<p>The path specification of a network share will always be empty or absolute,
but the path specification of a drive does not have to be, e.g.
<code>"d:file"</code> is a valid path despite the fact that the path specification
does not start with <code>"/"</code>.
</p>
<p>If the path specification of <code>path</code> is empty or is <code>"/"</code>, then
<code>dirname2()</code> will return <code>path</code> and <code>basename2()</code> will return
an empty string.
</p>


<h3>Behaviour under Unix-alikes</h3>

<p>If <code>path</code> is an empty string, then both <code>dirname2()</code> and
<code>basename2()</code> return an emty string.
</p>
<p>Recall that a network share looks like <code>"//host/share"</code>.
</p>
<p>For a path which starts with a network share, the path specification is the
portion of the string immediately afterward, e.g. <code>"/path/to/file"</code> is
the path specification of <code>"//host/share/path/to/file"</code>. For a path
which does not start with a network share, the path specification is the
entire string.
</p>
<p>If the path specification of <code>path</code> is empty or is <code>"/"</code>, then
<code>dirname2()</code> will return <code>path</code> and <code>basename2()</code> will return
an empty string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- c("/usr/lib", "/usr/", "usr", "/", ".", "..")
x &lt;- cbind(path, dirname = dirname2(path), basename = basename2(path))
print(x, quote = FALSE, print.gap = 3)
</code></pre>

<hr>
<h2 id='check.path'>Check 'this.path()' is Functioning Correctly</h2><span id='topic+check.path'></span><span id='topic+check.dir'></span><span id='topic+check.proj'></span>

<h3>Description</h3>

<p>Add <code>check.path("path/to/file")</code> to the start of your script to
initialize <code><a href="#topic+this.path">this.path</a>()</code> and check that it is returning the
expected path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.path(...)
check.dir(...)

check.proj(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.path_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+path.join">path.join</a>()</code> which must
return a character string; the path you expect <code>this.path()</code> or
<code>this.dir()</code> to return. The specified path can be as deep as necessary
(just the basename, the last directory and the basename, the last two
directories and the basename, ...), but do not use an absolute path.
<code>this.path()</code> makes <span class="rlang"><b>R</b></span> scripts portable, but using an absolute path in
<code>check.path()</code> or <code>check.dir()</code> makes an <span class="rlang"><b>R</b></span> script non-portable,
defeating a major purpose of this package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>check.proj()</code> is a specialized version of <code>check.path()</code> that
checks the path up to the project root.
</p>


<h3>Value</h3>

<p>if the expected path / / directory matches <code>this.path()</code> / /
<code>this.dir()</code>, then <code>TRUE</code> invisibly, otherwise an error is thrown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ## I have a project called 'd_cead'
# ##
# ## Within this project, I have a folder called 'code'
# ## where I place all of my scripts.
# ##
# ## One of these scripts is called 'provrun.R'
# ##
# ## So, at the top of that R script, I could write:
#
#
# this.path::check.path("d_cead", "code", "provrun.R")
#
# ## or:
#
# this.path::check.path("d_cead/code/provrun.R")
</code></pre>

<hr>
<h2 id='Enhances'>Functions That Enhance the Use of Other Packages</h2><span id='topic+with_script_path'></span><span id='topic+make_fix_file'></span>

<h3>Description</h3>

<p>These functions improve the user experience of other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## enchances 'package:box'
with_script_path(expr, file, local = FALSE, n = 0, envir = parent.frame(n + 1),
    matchThisEnv = getOption("topLevelEnvironment"),
    srcfile = if (n) sys.parent(n) else 0)

## enchances 'package:rprojroot'
make_fix_file(criterion, local = FALSE, n = 0, envir = parent.frame(n + 1),
    matchThisEnv = getOption("topLevelEnvironment"),
    srcfile = if (n) sys.parent(n) else 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Enhances_+3A_expr">expr</code></td>
<td>
<p>an expression to evaluate after setting the current script in
<span class="pkg">package:box</span>; most commonly a call to
<code><a href="box.html#topic+use">box::use</a>()</code>.</p>
</td></tr>
<tr><td><code id="Enhances_+3A_file">file</code></td>
<td>
<p>a character string giving the pathname of the file.</p>
</td></tr>
<tr><td><code id="Enhances_+3A_criterion">criterion</code></td>
<td>
<p>argument passed to
<code><a href="rprojroot.html#topic+find_root">rprojroot::find_root</a>()</code>.</p>
</td></tr>
<tr><td><code id="Enhances_+3A_local">local</code>, <code id="Enhances_+3A_n">n</code>, <code id="Enhances_+3A_envir">envir</code>, <code id="Enhances_+3A_matchthisenv">matchThisEnv</code>, <code id="Enhances_+3A_srcfile">srcfile</code></td>
<td>
<p>See
<code>?<a href="#topic+this.path">this.path</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>with_script_path()</code> improves the experience of <a href="https://CRAN.R-project.org/package=box"><span class="pkg">package:box</span></a>; it
sets the current script in <span class="pkg">package:box</span> to <code>file</code> or
<code><a href="#topic+this.path">this.path</a>()</code> using
<code><a href="box.html#topic+script_path">box::set_script_path</a>()</code>, then evaluates its
argument, most commonly a <span class="pkg">package:box</span> import statement.
</p>
<p><code>make_fix_file()</code> improves the experience of <a href="https://CRAN.R-project.org/package=rprojroot"><span class="pkg">package:rprojroot</span></a>; it
looks for a project root starting with <code><a href="#topic+this.dir">this.dir</a>()</code>, then makes a
function that constructs file paths against said project root.
</p>


<h3>Value</h3>

<p>for <code>with_script_path()</code>, the result of evaluating <code>expr</code>.
</p>
<p>for <code>make_fix_file()</code>, a function with formals <code>(..., .. = 0)</code> that
returns a character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this.path::with_script_path(
# box::use(
#     &lt;import 1&gt;,
#     &lt;import 2&gt;,
#     &lt;...&gt;
# )
# )


# ## replace 'rprojroot::is_r_package' with desired criterion
#
# fix_file &lt;- this.path::make_fix_file(rprojroot::is_r_package)
</code></pre>

<hr>
<h2 id='ext'>File Extensions</h2><span id='topic+splitext'></span><span id='topic+removeext'></span><span id='topic+ext'></span><span id='topic+ext+3C-'></span>

<h3>Description</h3>

<p><code>splitext()</code> splits an extension from a path.
</p>
<p><code>removeext()</code> removes an extension from a path.
</p>
<p><code>ext()</code> gets the extension of a path.
</p>
<p><code>ext&lt;-()</code> sets the extension of a path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitext(path, compression = FALSE)
removeext(path, compression = FALSE)
ext(path, compression = FALSE)
ext(path, compression = FALSE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ext_+3A_path">path</code></td>
<td>
<p>character vector, containing path names.</p>
</td></tr>
<tr><td><code id="ext_+3A_compression">compression</code></td>
<td>
<p>should compression extensions <code>".gz"</code>, <code>".bz2"</code>,
and <code>".xz"</code> be taken into account when removing / / getting an
extension?</p>
</td></tr>
<tr><td><code id="ext_+3A_value">value</code></td>
<td>
<p>a character vector, typically of length
<code>1</code> or <code>length(path)</code>, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tilde-expansion (see <code>?<a href="base.html#topic+path.expand">path.expand</a>()</code>) of the path will
be performed.
</p>
<p>Trailing path separators are removed before dissecting the path.
</p>
<p>Except for <code>path &lt;- NA_character_</code>, it will always be true that
<code>path == paste0(removeext(path), ext(path))</code>.
</p>


<h3>Value</h3>

<p>for <code>splitext()</code>, a matrix with <code>2</code> rows and
<code>length(path)</code> columns. The first row will be the roots of the paths,
the second row will be the extensions of the paths.
</p>
<p>for <code>removeext()</code> and <code>ext()</code>, a character vector the same length
as <code>path</code>.
</p>
<p>for <code>ext&lt;-()</code>, the updated object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splitext(character(0))
splitext("")

splitext("file.ext")

path &lt;- c("file.tar.gz", "file.tar.bz2", "file.tar.xz")
splitext(path, compression = FALSE)
splitext(path, compression = TRUE)

path &lt;- "this.path_2.6.0.tar.gz"
ext(path) &lt;- ".png"
path

path &lt;- "this.path_2.6.0.tar.gz"
ext(path, compression = TRUE) &lt;- ".png"
path
</code></pre>

<hr>
<h2 id='FILE'>Macros in Package 'this.path'</h2><span id='topic+FILE'></span><span id='topic+LINE'></span>

<h3>Description</h3>

<p><code>FILE()</code> and <code>LINE()</code> are intended to be used in a similar manner
to the macros <code>__FILE__</code> and <code>__LINE__</code> in C. They are useful for
generating a diagnostic message / / warning / / error to about the status of
the program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FILE()
LINE()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>FILE.R &lt;- tempfile(fileext = ".R")
writeLines("fun &lt;- function ()
{
    message(sprintf('invalid value %d at %s, line %d',
        -1, FILE(), LINE()))
}
", FILE.R)
source(FILE.R, verbose = FALSE, keep.source = TRUE)
fun()
unlink(FILE.R)
</code></pre>

<hr>
<h2 id='getinitwd'>Get Initial Working Directory</h2><span id='topic+getinitwd'></span><span id='topic+initwd'></span>

<h3>Description</h3>

<p><code>getinitwd()</code> returns an absolute filepath representing the working
directory at the time of loading this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getinitwd()
initwd
</code></pre>


<h3>Value</h3>

<p>character string, or <code>NULL</code> if the initial working directory is not
available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat("\ninitial working directory:\n"); getinitwd()
cat("\ncurrent working directory:\n"); getwd()
</code></pre>

<hr>
<h2 id='here'>Construct Path to File, Starting With Script's Directory</h2><span id='topic+here'></span><span id='topic+ici'></span><span id='topic+this.proj'></span><span id='topic+reset.proj'></span>

<h3>Description</h3>

<p><code>here()</code> constructs file paths starting with <code><a href="#topic+this.dir">this.dir</a>()</code>.
</p>
<p><code>this.proj()</code> constructs file paths starting with the project root of
<code>this.dir()</code>.
</p>
<p><code>reset.proj()</code> resets the path cache of <code>this.proj()</code>. This can be
useful if you create a new project that you would like to be detected without
restarting your <span class="rlang"><b>R</b></span> session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>here(..., local = FALSE, n = 0,
     envir = parent.frame(n + 1),
     matchThisEnv = getOption("topLevelEnvironment"),
     srcfile = if (n) sys.parent(n) else 0, .. = 0)

this.proj(..., local = FALSE, n = 0,
          envir = parent.frame(n + 1),
          matchThisEnv = getOption("topLevelEnvironment"),
          srcfile = if (n) sys.parent(n) else 0)

reset.proj()

## alias for 'here'
ici(..., local = FALSE, n = 0,
    envir = parent.frame(n + 1),
    matchThisEnv = getOption("topLevelEnvironment"),
    srcfile = if (n) sys.parent(n) else 0, .. = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="here_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+path.join">path.join</a>()</code>.</p>
</td></tr>
<tr><td><code id="here_+3A_local">local</code>, <code id="here_+3A_n">n</code>, <code id="here_+3A_envir">envir</code>, <code id="here_+3A_matchthisenv">matchThisEnv</code>, <code id="here_+3A_srcfile">srcfile</code></td>
<td>
<p>See
<code>?<a href="#topic+this.path">this.path</a>()</code>.</p>
</td></tr>
<tr><td><code id="here_+3A_..">..</code></td>
<td>
<p>the number of directories to go back.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>this.proj()</code>, the project root has the same criterion as
<code>here::here()</code>, but unlike <code>here::here()</code>, <code>this.proj()</code>
supports sub-projects and multiple projects in use at once. Additionally,
<code>this.proj()</code> is independent of working directory, whereas
<code>here::here()</code> relies on the working directory being set somewhere
within the project when <span class="pkg">package:here</span> is loaded. Arguably, this makes it
better than <code>here::here()</code>.
</p>


<h3>Value</h3>

<p>A character vector of the arguments concatenated term-by-term.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmpdir &lt;- tempfile(pattern = "dir")
dir.create(tmpdir)

writeLines("this file signifies that its directory is the project root",
    this.path::path.join(tmpdir, ".here"))

FILE.R &lt;- this.path::path.join(tmpdir, "src", "R", "script1.R")
dir.create(this.path::dirname2(FILE.R), recursive = TRUE)
this.path:::.writeCode({
    this.path::this.path()
    this.path::this.proj()
    ## use 'here' to run another script located nearby
    this.path::here("script2.R")
    ## or maybe to read input from a file
    this.path::here(.. = 2, "input", "data1.csv")
    ## but sometimes it is easier to use the project root
    ## this allows you to move the R script up or down
    ## a directory without changing the .. number
    this.path::this.proj("input", "data1.csv")
}, FILE.R)

source(FILE.R, echo = TRUE)

unlink(tmpdir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='is.main'>Top-Level Code Environment</h2><span id='topic+is.main'></span><span id='topic+from.shell'></span>

<h3>Description</h3>

<p>Determine if a program is the main program, or if a program was run from a
shell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.main()
from.shell()
</code></pre>


<h3>Details</h3>

<p>If no scripts are being <code><a href="base.html#topic+source">source</a>()</code>-ed, then <code>is.main()</code> will be
<code>TRUE</code>, and <code>FALSE</code> otherwise.
</p>
<p>If <code>is.main()</code> is <code>TRUE</code> and <span class="rlang"><b>R</b></span> was invoked with the command-line
arguments <span class="option">-f</span> <span class="option">FILE</span>, <span class="option">--file=FILE</span>, or <span class="option">-e</span>
<span class="option">EXPR</span>, then <code>from.shell()</code> will be <code>TRUE</code>, and <code>FALSE</code>
otherwise.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FILE.R &lt;- tempfile(fileext = ".R")
this.path:::.writeCode({
    this.path:::.withAutoprint({
        from.shell()
        is.main()
    }, spaced = TRUE, verbose = FALSE,
       prompt.echo = "FILE.R&gt; ", continue.echo = "FILE.R+ ")
}, FILE.R)

this.path:::.Rscript(c(
    "--default-packages=this.path", "--vanilla",
    FILE.R
), show.command = FALSE, show.output.on.console = TRUE)

source(FILE.R, verbose = FALSE)

this.path:::.Rscript(c(
    "--default-packages=this.path", "--vanilla",
    "-e", "cat(\"\n&gt; from.shell()\\n\")",
    "-e", "from.shell()",
    "-e", "cat(\"\n&gt; is.main()\\n\")",
    "-e", "is.main()",
    "-e", "cat(\"\n&gt; source(commandArgs(trailingOnly = TRUE))\\n\")",
    "-e", "source(commandArgs(trailingOnly = TRUE))", FILE.R
), show.command = FALSE, show.output.on.console = TRUE)

unlink(FILE.R)
</code></pre>

<hr>
<h2 id='LINENO'>Line Number of Executing Expression</h2><span id='topic+LINENO'></span>

<h3>Description</h3>

<p>Get the line number of the executing expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LINENO(n = 0, envir = parent.frame(n + 1),
       matchThisEnv = getOption("topLevelEnvironment"),
       srcfile = if (n) sys.parent(n) else 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LINENO_+3A_n">n</code>, <code id="LINENO_+3A_envir">envir</code>, <code id="LINENO_+3A_matchthisenv">matchThisEnv</code>, <code id="LINENO_+3A_srcfile">srcfile</code></td>
<td>
<p>See <code>?<a href="#topic+this.path">this.path</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>LINENO()</code> only works if the expressions have a
<code><a href="base.html#topic+srcfile">srcref</a></code>.
</p>
<p>Scripts run with <code><a href="utils.html#topic+Rscript">Rscript</a></code> do not store their <code>srcref</code>, even when
<code><a href="base.html#topic+options">getOption</a>("keep.source")</code> is <code>TRUE</code>.
</p>
<p>For <code><a href="base.html#topic+source">source</a>()</code> and <code><a href="base.html#topic+sys.source">sys.source</a>()</code>, make sure to supply argument
<code>keep.source = TRUE</code> directly, or set options <code>"keep.source"</code> and
<code>"keep.source.pkgs"</code> to <code>TRUE</code>.
</p>
<p>For <a href="https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE"><code>debugSource</code></a><code>()</code> in &lsquo;<a href="https://posit.co/products/open-source/rstudio/">RStudio</a>&rsquo;, it has no argument <code>keep.source</code>, so set
option <code>"keep.source"</code> to <code>TRUE</code> before calling.
</p>
<p>For <code><a href="compiler.html#topic+compile">compiler::loadcmp</a>()</code>, the <code>srcref</code> is never stored for the compiled
code, there is nothing that can be done.
</p>
<p>For <code><a href="utils.html#topic+Sweave">utils::Sweave</a>()</code>, the <code>srcref</code> is never stored, there is nothing
that can be done.
</p>
<p>For <code><a href="knitr.html#topic+knit">knitr::knit</a>()</code>, the <code>srcref</code> is never stored, there is nothing that
can be done. I am looking into a fix.
</p>
<p>For <a href="https://CRAN.R-project.org/package=targets"><span class="pkg">package:targets</span></a>, set option <code>"keep.source"</code> to <code>TRUE</code> before
calling associated functions.
</p>
<p>For <code><a href="box.html#topic+use">box::use</a>()</code>, <code><a href="plumber.html#topic+plumb">plumber::plumb</a>()</code>, <code><a href="shiny.html#topic+runApp">shiny::runApp</a>()</code>, and
<code><a href="testthat.html#topic+source_file">testthat::source_file</a>()</code>, the <code>srcref</code> is always stored.
</p>


<h3>Value</h3>

<p>integer; <code>NA_integer_</code> if the line number is not found.
</p>


<h3>Note</h3>

<p>You can get a more accurate line number by wrapping <code>LINENO()</code> in
braces: </p>
<pre>{ LINENO() }</pre>


<h3>Examples</h3>

<pre><code class='language-R'>FILE.R &lt;- tempfile(fileext = ".R")
writeLines(c("
LINENO()
LINENO()
## LINENO() respects #line directives
#line 15
LINENO()
#line 1218
cat(sprintf('invalid value %d at %s, line %d\\n',
            -5, try.this.path(), LINENO()))
"), FILE.R)


if (getRversion() &gt;= "4.3.0") {
    source(FILE.R, echo = TRUE, verbose = FALSE,
        max.deparse.length = Inf, keep.source = TRUE)
} else {
    this.path:::.source(FILE.R, echo = TRUE, verbose = FALSE,
        max.deparse.length = Inf, keep.source = TRUE)
}


unlink(FILE.R)
</code></pre>

<hr>
<h2 id='make_fix_funs'>Constructs Path Functions Similar to 'this.path()'</h2><span id='topic+make_fix_funs'></span><span id='topic+path.functions'></span>

<h3>Description</h3>

<p><code>make_fix_funs()</code> accepts a pathname and constructs a set of
path-related functions, similar to <code>this.path()</code> and associated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_fix_funs(file, local = FALSE, n = 0,
               envir = parent.frame(n + 1),
               matchThisEnv = getOption("topLevelEnvironment"),
               srcfile = if (n) sys.parent(n) else 0)

## alias for 'make_fix_funs'
path.functions(file, local = FALSE, n = 0,
               envir = parent.frame(n + 1),
               matchThisEnv = getOption("topLevelEnvironment"),
               srcfile = if (n) sys.parent(n) else 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_fix_funs_+3A_file">file</code></td>
<td>
<p>a character string giving the pathname of the file or URL.</p>
</td></tr>
<tr><td><code id="make_fix_funs_+3A_local">local</code>, <code id="make_fix_funs_+3A_n">n</code>, <code id="make_fix_funs_+3A_envir">envir</code>, <code id="make_fix_funs_+3A_matchthisenv">matchThisEnv</code>, <code id="make_fix_funs_+3A_srcfile">srcfile</code></td>
<td>
<p>See <code>?<a href="#topic+this.path">this.path</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment with at least the following bindings:
</p>
<table role = "presentation">
<tr><td><code>this.path</code></td>
<td>

<p>Function with formals <code>(original = FALSE, contents = FALSE)</code> which
returns the
<code><a href="base.html#topic+normalizePath">normalized</a></code> file
path, the original file path, or the contents of the file.</p>
</td></tr>
<tr><td><code>this.dir</code></td>
<td>

<p>Function with no formals which returns the directory of the
<code><a href="base.html#topic+normalizePath">normalized</a></code> file
path.</p>
</td></tr>
<tr><td><code>here</code>, <code>ici</code></td>
<td>

<p>Function with formals <code>(..., .. = 0)</code> which constructs file paths,
starting with the file's directory.</p>
</td></tr>
<tr><td><code>this.proj</code></td>
<td>

<p>Function with formals <code>(..., .. = 0)</code> which constructs file paths,
starting with the project root.</p>
</td></tr>
<tr><td><code>rel2here</code>, <code>rel2proj</code></td>
<td>

<p>Functions with formals <code>(path)</code> which turn absolute paths into
relative paths, against the file's directory / / project root.</p>
</td></tr>
<tr><td><code>LINENO</code></td>
<td>

<p>Function with no formals which returns the line number of the executing
expression in <code>file</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='OS.type'>Detect the Operating System Type</h2><span id='topic+OS.type'></span>

<h3>Description</h3>

<p><code>OS.type</code> is a list of <code>TRUE</code> / / <code>FALSE</code> values dependent on
the platform under which this package was built.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OS.type
</code></pre>


<h3>Value</h3>



<p>A list with at least the following components:
</p>
<table role = "presentation">
<tr><td><code>AIX</code></td>
<td>

<p>Built under IBM AIX.</p>
</td></tr>
<tr><td><code>HPUX</code></td>
<td>

<p>Built under Hewlett-Packard HP-UX.</p>
</td></tr>
<tr><td><code>linux</code></td>
<td>

<p>Built under some distribution of Linux.</p>
</td></tr>
<tr><td><code>darwin</code></td>
<td>

<p>Built under Apple OSX and iOS (Darwin).</p>
</td></tr>
<tr><td><code>iOS.simulator</code></td>
<td>

<p>Built under iOS in Xcode simulator.</p>
</td></tr>
<tr><td><code>iOS</code></td>
<td>

<p>Built under iOS on iPhone, iPad, etc.</p>
</td></tr>
<tr><td><code>macOS</code></td>
<td>

<p>Built under OSX.</p>
</td></tr>
<tr><td><code>solaris</code></td>
<td>

<p>Built under Solaris (SunOS).</p>
</td></tr>
<tr><td><code>cygwin</code></td>
<td>

<p>Built under Cygwin POSIX under Microsoft Windows.</p>
</td></tr>
<tr><td><code>windows</code></td>
<td>

<p>Built under Microsoft Windows.</p>
</td></tr>
<tr><td><code>win64</code></td>
<td>

<p>Built under Microsoft Windows (64-bit).</p>
</td></tr>
<tr><td><code>win32</code></td>
<td>

<p>Built under Microsoft Windows (32-bit).</p>
</td></tr>
<tr><td><code>UNIX</code></td>
<td>

<p>Built under a UNIX-style OS.</p>
</td></tr>
</table>


<h3>Source</h3>

<p><a href="http://web.archive.org/web/20191012035921/http://nadeausoftware.com/articles/2012/01/c_c_tip_how_use_compiler_predefined_macros_detect_operating_system">http://web.archive.org/web/20191012035921/http://nadeausoftware.com/articles/2012/01/c_c_tip_how_use_compiler_predefined_macros_detect_operating_system</a>
</p>

<hr>
<h2 id='path.join'>Construct Path to File</h2><span id='topic+path.join'></span>

<h3>Description</h3>

<p>Construct the path to a file from components / / paths in a
platform-<strong>DEPENDENT</strong> way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path.join(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path.join_+3A_...">...</code></td>
<td>
<p>character vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When constructing a path to a file, the last absolute path is selected and
all trailing components are appended. This is different from
<code><a href="base.html#topic+file.path">file.path</a>()</code> where all trailing paths are treated as
components.
</p>


<h3>Value</h3>

<p>A character vector of the arguments concatenated term-by-term and separated
by <code>"/"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path.join("/", "test1")

path.join("/path/to/file1", "/path/to/file2")

path.join("//host-name/share-name/path/to/file1", "/path/to/file2")

path.join("testing", "/testing", "~", "~/testing", "//host",
    "//host/share", "//host/share/path/to/file", "not-an-abs-path")

path.join("/test1", "test2", "test3")

path.join("test1", "/test2", "test3", "//host/share/test4", "test5",
    "/test6", "test7", "test8", "test9")
</code></pre>

<hr>
<h2 id='path.split'>Split File Path Into Individual Components</h2><span id='topic+path.split'></span><span id='topic+path.split.1'></span><span id='topic+path.unsplit'></span>

<h3>Description</h3>

<p>Split the path to a file into components in a platform-<strong>DEPENDENT</strong>
way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path.split(path)
path.split.1(path)
path.unsplit(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path.split_+3A_path">path</code></td>
<td>
<p>character vector.</p>
</td></tr>
<tr><td><code id="path.split_+3A_...">...</code></td>
<td>
<p>character vectors, or one list of character vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>path.split()</code>, a list of character vectors.
</p>
<p>for <code>path.split.1()</code> and <code>path.unsplit()</code>, a character vector.
</p>


<h3>Note</h3>

<p><code>path.unsplit()</code> is <strong>NOT</strong> the same as <code><a href="#topic+path.join">path.join</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- c(
    NA,
    "",
    paste0("https://raw.githubusercontent.com/ArcadeAntics/PACKAGES/",
           "src/contrib/Archive/this.path/this.path_1.0.0.tar.gz"),
    "//host/share/path/to/file",
    "//host/share/",
    "//host//share",
    "/path/to/file",
    "~/path/to/file",
    "path/to/file",
    ## paths with character encodings
    `Encoding&lt;-`("path/to/fil\xe9", "latin1"),
    "/home/iris/Documents/\u03b4.R"
)
print(x &lt;- path.split(path))
print(path.unsplit(x))
</code></pre>

<hr>
<h2 id='print.ThisPathDocumentContext'>Printing &quot;ThisPathDocumentContext&quot; Objects</h2><span id='topic+print.ThisPathDocumentContext'></span><span id='topic+format.ThisPathDocumentContext'></span><span id='topic+as.character.ThisPathDocumentContext'></span>

<h3>Description</h3>

<p>Print a <code>"ThisPathDocumentContext"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ThisPathDocumentContext'
print(x, ..., quote = TRUE)

## S3 method for class 'ThisPathDocumentContext'
format(x, ...)

## S3 method for class 'ThisPathDocumentContext'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ThisPathDocumentContext_+3A_x">x</code></td>
<td>
<p>object of class <code>"ThisPathDocumentContext"</code>.</p>
</td></tr>
<tr><td><code id="print.ThisPathDocumentContext_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="print.ThisPathDocumentContext_+3A_quote">quote</code></td>
<td>
<p>logical, indicating whether or not strings should be printed
with surrounding quotes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ThisPathDocumentContext"</code> is generated upon calling
<code><a href="#topic+set.sys.path">set.sys.path</a>()</code>, <code><a href="#topic+wrap.source">wrap.source</a>()</code>,
<code><a href="#topic+sys.path">sys.path</a>()</code>, <code><a href="#topic+env.path">env.path</a>()</code>, or
<code><a href="#topic+src.path">src.path</a>()</code>, and by extension <code><a href="#topic+this.path">this.path</a>()</code>. It
contains information about the path of the executing / / current script.
</p>
<p>These objects are not usually user-visible.
</p>


<h3>Value</h3>

<p>for <code>print.ThisPathDocumentContext()</code>, <code>x</code> invisibly.
</p>
<p>for <code>format.ThisPathDocumentContext()</code>, a character vector of lines.
</p>
<p>for <code>as.character.ThisPathDocumentContext()</code>, a character string of
concatenated lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- function (file)
{
    set.sys.path(file, Function = "fun")
    `.this.path::document.context`
}


fun()


fun("clipboard")


fun(paste0("https://raw.githubusercontent.com/ArcadeAntics/",
           "this.path/main/tests/sys-path-with-urls.R"))


FILE.R &lt;- tempfile(fileext = ".R"); file.create(FILE.R)

x &lt;- fun(FILE.R)
print(x)
print(x, quote = FALSE)
format(x)
as.character(x)

unlink(FILE.R)
</code></pre>

<hr>
<h2 id='progArgs'>Providing Arguments to a Script</h2><span id='topic+asArgs'></span><span id='topic+progArgs'></span><span id='topic+withArgs'></span>

<h3>Description</h3>

<p><code>withArgs()</code> allows you to <code><a href="base.html#topic+source">source</a>()</code> an <span class="rlang"><b>R</b></span> script while providing
arguments. As opposed to running with <code><a href="utils.html#topic+Rscript">Rscript</a></code>, the code will be
evaluated in the same session in an environment of your choosing.
</p>
<p><code>progArgs()</code> is a generalized version of
<code><a href="base.html#topic+commandArgs">commandArgs</a>(trailingOnly = TRUE)</code>, allowing you to access
the program's arguments whether it was <code>source()</code>-ed or run from a shell.
</p>
<p><code>asArgs()</code> coerces <span class="rlang"><b>R</b></span> objects into a character vector, for use with
command line applications and <code>withArgs()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asArgs(...)
progArgs(ifnotfound = character())
withArgs(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="progArgs_+3A_...">...</code></td>
<td>
<p><span class="rlang"><b>R</b></span> objects to turn into script arguments; typically
<code><a href="base.html#topic+logical">logical</a></code>, <code><a href="base.html#topic+numeric">numeric</a></code>,
<code><a href="base.html#topic+character">character</a></code>, <code><a href="base.html#topic+Dates">Date</a></code>, and
<code><a href="base.html#topic+DateTimeClasses">POSIXt</a></code> vectors.
</p>
<p>for <code>withArgs()</code>, the first argument should be an (unevaluated) call
to a <code>source()</code>-like function.</p>
</td></tr>
<tr><td><code id="progArgs_+3A_ifnotfound">ifnotfound</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object, e.g., <code>character(0)</code>, <code>NULL</code>, a
call to <code><a href="base.html#topic+stop">stop</a>()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>progArgs()</code> will return the arguments associated with the executing
script, or <code>commandArgs(trailingOnly = TRUE)</code> when there is no executing
script.
</p>
<p><code>asArgs()</code> coerces objects into command-line arguments. <code>...</code> is
first put into a list, and then each non-list element is converted to
character. They are converted as follows:
</p>

<dl>
<dt>Factors (class <code>"factor"</code>)</dt><dd>
<p>using <code><a href="base.html#topic+character">as.character.factor</a>()</code></p>
</dd>
<dt>Date-Times (class <code>"POSIXct"</code> and <code>"POSIXlt"</code>)</dt><dd>
<p>using format
<code>"%Y-%m-%d %H:%M:%OS6"</code>
(retains as much precision as possible)</p>
</dd>
<dt>Numbers (class <code>"numeric"</code> and <code>"complex"</code>)</dt><dd>
<p>with 17 significant digits (retains as much precision as possible) and
<code>"."</code> as the decimal point character.</p>
</dd>
<dt>Raw Bytes (class <code>"raw"</code>)</dt><dd>
<p>using
<code><a href="base.html#topic+sprintf">sprintf</a>("0x%02x", )</code>
(for easy conversion back to raw with <code><a href="base.html#topic+raw">as.raw</a>()</code> or
<code><a href="base.html#topic+vector">as.vector</a>(, "raw")</code>)</p>
</dd>
</dl>

<p>All others will be converted to character using
<code><a href="base.html#topic+character">as.character</a>()</code> and its methods.
</p>
<p>The arguments will then be unlisted, and all attributes will be removed.
Arguments that are <code>NA_character_</code> after conversion will be converted to
<code>"NA"</code> (since the command-line arguments also never have missing
strings).
</p>


<h3>Value</h3>

<p>for <code>asArgs()</code> and <code>progArgs()</code>, a character vector.
</p>
<p>for <code>withArgs()</code>, the result of evaluating the first argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>this.path::asArgs(NULL, c(TRUE, FALSE, NA), 1:5, pi, exp(6i),
    letters[1:5], as.raw(0:4), Sys.Date(), Sys.time(),
    list(list(list("lists are recursed"))))


FILE.R &lt;- tempfile(fileext = ".R")
this.path:::.writeCode({
    this.path:::.withAutoprint({
        this.path::sys.path()
        this.path::progArgs()
    }, spaced = TRUE, verbose = FALSE, width.cutoff = 60L)
}, FILE.R)


## wrap your source call with a call to withArgs()
this.path::withArgs(
    source(FILE.R, local = TRUE, verbose = FALSE),
    letters[6:10], pi, exp(1)
)
this.path:::.Rscript(c("--default-packages=NULL", "--vanilla", FILE.R,
    this.path::asArgs(letters[16:20], pi, Sys.time())))
this.path:::.Rscript(c("--default-packages=NULL", "--vanilla",
    rbind("-e", readLines(FILE.R)[-2L]),
    this.path::asArgs(letters[16:20], pi, Sys.time())))


# ## with R &gt;= 4.1.0, use the forward pipe operator '|&gt;' to
# ## make calls to withArgs() more intuitive:
# source(FILE.R, local = TRUE, verbose = FALSE) |&gt; this.path::withArgs(
#     letters[6:10], pi, exp(1))


## withArgs() also works with set.sys.path()
sourcelike &lt;- function (file, envir = parent.frame())
{
    file &lt;- set.sys.path(file)
    envir &lt;- as.environment(envir)
    exprs &lt;- parse(n = -1, file = file)
    for (i in seq_along(exprs)) eval(exprs[i], envir)
}
this.path::withArgs(sourcelike(FILE.R), letters[21:26])


unlink(FILE.R)
</code></pre>

<hr>
<h2 id='R.from.shell'>Using R From a Shell</h2><span id='topic+R.from.shell'></span>

<h3>Description</h3>

<p>How to use <span class="rlang"><b>R</b></span> from a shell (including the Windows command-line / / Unix
terminal).
</p>


<h3>Details</h3>

<p>For the purpose of running <span class="rlang"><b>R</b></span> scripts, there are four ways to do it. Suppose
our <span class="rlang"><b>R</b></span> script has filename <span class="option">script1.R</span>, we could write any of:
</p>

<ul>
<li><p><code style="white-space: pre;">&#8288;R -f script1.R&#8288;</code>
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;R --file=script1.R&#8288;</code>
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;R CMD BATCH script1.R&#8288;</code>
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;Rscript script1.R&#8288;</code>
</p>
</li></ul>

<p>The first two are different ways of writing equivalent statements. The third
statement is the first statement plus options <span class="option">--restore</span>
<span class="option">--save</span> (plus option <span class="option">--no-readline</span> under Unix-alikes), and
it also saves the <code><a href="base.html#topic+showConnections">stdout</a></code> and
<code><a href="base.html#topic+showConnections">stderr</a></code> in a file of your choosing. The
fourth statement is the second statement plus options <span class="option">--no-echo</span>
<span class="option">--no-restore</span>. You can try:
</p>

<ul>
<li><p><code style="white-space: pre;">&#8288;R --help&#8288;</code>
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;R CMD BATCH --help&#8288;</code>
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;Rscript --help&#8288;</code>
</p>
</li></ul>

<p>for a help message that describes what these options mean. In general,
<code>Rscript</code> is the one you want to use. It should be noted that
<code>Rscript</code> has some exclusive
<code><a href="base.html#topic+EnvVar">environment variables</a></code> (not used by the other
executables) that will make its behaviour different from <code>R</code>.
</p>
<p>For the purpose of making packages, <code>R CMD</code> is what you will need.
Most commonly, you will use:
</p>

<ul>
<li><p><code style="white-space: pre;">&#8288;R CMD build&#8288;</code>
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;R CMD INSTALL&#8288;</code>
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;R CMD check&#8288;</code>
</p>
</li></ul>

<p><code>R CMD build</code> will turn an <span class="rlang"><b>R</b></span> package (specified by a directory) into
tarball. This allows for easy sharing of <span class="rlang"><b>R</b></span> packages with other people,
including
<a href="https://cran.r-project.org/submit.html">submitting a package to CRAN</a>.
<code>R CMD INSTALL</code> will install an <span class="rlang"><b>R</b></span> package (specified by a directory
or tarball), and is used by
<code><a href="utils.html#topic+install.packages">install.packages</a>()</code>.
<code>R CMD check</code> will check an <span class="rlang"><b>R</b></span> package (specified by a tarball) for
possible errors in code, documentation, tests, and much more.
</p>
<p>If, when you execute one of the previous commands, you see the following
error message: &ldquo;&lsquo;R&rsquo; is not recognized as an internal or
external command, operable program or batch file.&rdquo;, see section
<strong>Ease of Use on Windows</strong>.
</p>


<h3>Ease of Use on Windows</h3>

<p>Under Unix-alikes, it is easy to invoke an <span class="rlang"><b>R</b></span> session from a shell by typing
the name of the <span class="rlang"><b>R</b></span> executable you wish to run. On Windows, you should see
that typing the name of the <span class="rlang"><b>R</b></span> executable you wish to run does not run that
application, but instead signals an error. Instead, you will have to type the
full path of the directory where your <span class="rlang"><b>R</b></span> executables are located (see section
<strong>Where are my R executable files located?</strong>), followed by the name of
the <span class="rlang"><b>R</b></span> executable you wish to run.
</p>
<p>This is not very convenient to type everytime something needs to be run from
a shell, plus it has another issue of being computer dependent. The solution
is to add the path of the directory where your <span class="rlang"><b>R</b></span> executables are located to
the <span class="env">Path</span> environment variable. The <span class="env">Path</span> environment variable is a
list of directories where executable programs are located. When you type the
name of an executable program you wish to run, Windows looks for that program
through each directory in the <span class="env">Path</span> environment variable. When you add
the full path of the directory where your <span class="rlang"><b>R</b></span> executables are located to your
<span class="env">Path</span> environment variable, you should be able to run any of those
executable programs by their basenames (&lsquo;R&rsquo;, &lsquo;Rcmd&rsquo;,
&lsquo;Rscript&rsquo;, and &lsquo;Rterm&rsquo;) instead of their full paths.
</p>
<p>To add a new path to your <span class="env">Path</span> environment variable:
</p>

<ol>
<li><p>Open the Windows search bar (press <strong>Windows</strong> key)
</p>
</li>
<li><p>Type <strong>Edit environment variables for your account</strong>
</p>
</li>
<li><p>Click the variable <span class="env">Path</span>
</p>
</li>
<li><p>Click the button <strong>Edit...</strong>
</p>
</li>
<li><p>Click the button <strong>New</strong>
</p>
</li>
<li><p>Type (or paste) the full path of the directory where your <span class="rlang"><b>R</b></span>
executables are located and click the <strong>OK</strong> button
</p>
</li></ol>

<p>This will modify your environment variable <span class="env">Path</span>, not the systems. If
another user wishes to run <span class="rlang"><b>R</b></span> from a shell, they will have to add the
directory to their <span class="env">Path</span> environment variable as well.
</p>
<p>If you wish to modify the system environment variable <span class="env">Path</span> (you will
need admin permissions):
</p>

<ol>
<li><p>Open the Windows search bar (press <strong>Windows</strong> key)
</p>
</li>
<li><p>Type <strong>Edit the system environment variables</strong>
</p>
</li>
<li><p>Click the button <strong>Environment Variables...</strong>
</p>
</li>
<li><p>Click the variable <span class="env">Path</span> in section <strong>System variables</strong>
</p>
</li>
<li><p>Click the button <strong>Edit...</strong>
</p>
</li>
<li><p>Click the button <strong>New</strong>
</p>
</li>
<li><p>Type (or paste) the full path of the directory where your <span class="rlang"><b>R</b></span>
executables are located and click the <strong>OK</strong> button
</p>
</li></ol>

<p>To check that this worked correctly, open a shell and execute the following
commands:
</p>

<ul>
<li><p><code style="white-space: pre;">&#8288;R --help&#8288;</code>
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;R --version&#8288;</code>
</p>
</li></ul>

<p>You should see that the first prints the usage message for the <span class="rlang"><b>R</b></span> executable
while the second prints information about the version of <span class="rlang"><b>R</b></span> currently being
run. If you have multiple versions of <span class="rlang"><b>R</b></span> installed, make sure this is the
version of <span class="rlang"><b>R</b></span> you wish to run.
</p>


<h3>Where are my R executable files located?</h3>

<p>In an <span class="rlang"><b>R</b></span> session, you can find the location of your <span class="rlang"><b>R</b></span> executable files with
the following command:
</p>
<p><code>R.home("bin")</code>
</p>
<p>For me, this is:
</p>
<p>&lsquo;<span class="file"><code style="white-space: pre;">&#8288;/usr/lib/R/bin&#8288;</code></span>&rsquo;
&lsquo;<span class="file"><code style="white-space: pre;">&#8288;C:/PROGRA~1/R/R-&#8288;</code>4.4.2<code style="white-space: pre;">&#8288;/bin/x64&#8288;</code></span>&rsquo;
</p>

<hr>
<h2 id='relpath'>Make a Path Relative to Another</h2><span id='topic+relpath'></span><span id='topic+rel2here'></span><span id='topic+rel2proj'></span>

<h3>Description</h3>

<p>When working with <span class="pkg">this.path</span>, you will be dealing with a lot of absolute
paths. These paths are not portable for saving within files nor tables, so
convert them to relative paths with <code>relpath()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relpath(path, relative.to = getwd())

rel2here(path, local = FALSE, n = 0, envir = parent.frame(n + 1),
         matchThisEnv = getOption("topLevelEnvironment"),
         srcfile = if (n) sys.parent(n) else 0)

rel2proj(path, local = FALSE, n = 0,
         envir = parent.frame(n + 1),
         matchThisEnv = getOption("topLevelEnvironment"),
         srcfile = if (n) sys.parent(n) else 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relpath_+3A_path">path</code></td>
<td>
<p>character vector of file / / URL pathnames.</p>
</td></tr>
<tr><td><code id="relpath_+3A_relative.to">relative.to</code></td>
<td>
<p>character string; the file / / URL pathname to make
<code>path</code> relative to.</p>
</td></tr>
<tr><td><code id="relpath_+3A_local">local</code>, <code id="relpath_+3A_n">n</code>, <code id="relpath_+3A_envir">envir</code>, <code id="relpath_+3A_matchthisenv">matchThisEnv</code>, <code id="relpath_+3A_srcfile">srcfile</code></td>
<td>
<p>See
<code>?<a href="#topic+this.path">this.path</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tilde-expansion (see <code>?<a href="base.html#topic+path.expand">path.expand</a>()</code>) is first done on
<code>path</code> and <code>relative.to</code>.
</p>
<p>If <code>path</code> and <code>relative.to</code> are equivalent, <code>"."</code> will be
returned. If <code>path</code> and <code>relative.to</code> have no base in common, the
<code><a href="base.html#topic+normalizePath">normalized</a></code>
<code>path</code> will be returned.
</p>


<h3>Value</h3>

<p>character vector of the same length as <code>path</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
relpath(
    c(
        ## paths which are equivalent will return "."
        "/home/effective_user/Documents/this.path/man",


        ## paths which have no base in common return as themselves
        paste0("https://raw.githubusercontent.com/ArcadeAntics/",
               "this.path/main/tests/sys-path-with-urls.R"),
        "//host-name/share-name/path/to/file",


        "/home/effective_user/Documents/testing",
        "/home/effective_user",
        "/home/effective_user/Documents/R/thispath.R"
    ),
    relative.to = "/home/effective_user/Documents/this.path/man"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='set.gui.path'>Declare GUI's Active Document</h2><span id='topic+set.gui.path'></span><span id='topic+thisPathNotExistsError'></span><span id='topic+thisPathNotFoundError'></span>

<h3>Description</h3>

<p><code>set.gui.path()</code> can be used to implement <code><a href="#topic+this.path">this.path</a>()</code> for
arbitrary GUIs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.gui.path(...)

thisPathNotExistsError(..., call. = TRUE, domain = NULL,
                       call = .getCurrentCall())

thisPathNotFoundError(..., call. = TRUE, domain = NULL,
                      call = .getCurrentCall())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.gui.path_+3A_...">...</code>, <code id="set.gui.path_+3A_call.">call.</code>, <code id="set.gui.path_+3A_domain">domain</code>, <code id="set.gui.path_+3A_call">call</code></td>
<td>
<p>See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>thisPathNotExistsError()</code> and <code>thisPathNotFoundError()</code> are
provided for use inside <code>set.gui.path()</code>, and should not be used
elsewhere.
</p>
<p>If no arguments are passed to <code>set.gui.path()</code>, the default behaviour
will be restored.
</p>
<p>If one argument is passed to <code>set.gui.path()</code>, it must be a function
that returns the path of the active document in your GUI. It must accept the
following arguments: <code>(verbose, original, for.msg, contents)</code> (default
values are unnecessary). This makes sense for a GUI which can edit and run <span class="rlang"><b>R</b></span>
code from several different documents such as RGui, <a href="https://posit.co/products/open-source/rstudio/">RStudio</a>, <a href="https://github.com/posit-dev/positron">Positron</a>,
<a href="https://code.visualstudio.com/">VSCode</a> + <a href="https://code.visualstudio.com/docs/languages/r">REditorSupport</a>, and <a href="https://www.gnu.org/software/emacs/">Emacs</a> + <a href="https://ess.r-project.org/">ESS</a>.
</p>
<p>If two or three arguments are passed to <code>set.gui.path()</code>, they must be
the name of the GUI, the path of the active document, and optionally a
function to get the contents of the document. If provided, the function must
accept at least one argument which will be the normalized path of the
document. This makes sense for a GUI which can edit and run <span class="rlang"><b>R</b></span> code from only
one document such as <a href="https://jupyter.org/">Jupyter</a> and shell.
</p>
<p>It is best to call this function as a user hook.
</p>
<pre>setHook(packageEvent("this.path"),
function(pkgname, pkgpath)
{
    this.path::set.gui.path(&lt;...&gt;)
}, action = "prepend")</pre>
<p>An example for a GUI which can run code from multiple documents:
</p>
<pre>evalq(envir = new.env(parent = .BaseNamespaceEnv), {
    .guiname &lt;- "myGui"
    .custom_gui_path &lt;- function(verbose, original, for.msg, contents) {
        if (verbose)
            cat("Source: document in", .guiname, "\n")

        ## your GUI needs to know which document is active
        ## and some way to retrieve that document from R
        doc &lt;- &lt;.myGui_activeDocument()&gt;

        ## if no documents are open, 'doc' should be NULL
        ## or some other object to represent no documents open
        if (is.null(doc)) {
            if (for.msg)
                NA_character_
            else stop(this.path::thisPathNotExistsError(
                "R is running from ", .guiname, " with no documents open\n",
                " (or document has no path)"))
        }
        else if (contents) {
            ## somehow, get and return the contents of the document
            &lt;doc$contents&gt;
        }
        else {
            ## somehow, get the path of the document
            path &lt;- &lt;doc$path&gt;
            if (nzchar(path)) {
                ## if the path is not normalized, this will normalize it
                if (isFALSE(original))
                    normalizePath(path, "/", TRUE)
                else path
                # ## otherwise, you could just do:
                # path
            }
            else if (for.msg)
                ## return "Untitled" possibly translated
                gettext("Untitled", domain = "RGui", trim = FALSE)
            else
                stop(this.path::thisPathNotFoundError(
                    "document in ", .guiname, " does not exist"))
        }
    }
    ## recommended to prevent tampering
    lockEnvironment(environment(), bindings = TRUE)
    setHook(packageEvent("this.path"),
    function(pkgname, pkgpath) {
        this.path::set.gui.path(.custom_gui_path)
    }, action = "prepend")
})</pre>
<p>An example for a GUI which can run code from only one document:
</p>
<pre>evalq(envir = new.env(parent = .BaseNamespaceEnv), {
    .guiname &lt;- "myGui"
    .path &lt;- "~/example.R"
    .custom_get_contents &lt;- function(path) {
        ## get the contents of the document
        readLines(path, warn = FALSE)
    }
    ## recommended to prevent tampering
    lockEnvironment(environment(), bindings = TRUE)
    setHook(packageEvent("this.path"), function(pkgname, pkgpath) {
        this.path::set.gui.path(.guiname, .path, .custom_get_contents)
    }, action = "prepend")
    # ## if your GUI does not have/need a .custom_get_contents
    # ## function, then this works just as well:
    # setHook(packageEvent("this.path"), function(pkgname, pkgpath) {
    #     this.path::set.gui.path(.guiname, .path)
    # }, action = "prepend")
})</pre>


<h3>Value</h3>

<p>a list of the previous settings for <code>set.gui.path()</code>, similar to
<code><a href="base.html#topic+options">options</a>()</code>.
</p>

<hr>
<h2 id='set.jupyter.path'>Declare Executing 'Jupyter' Notebook's Filename</h2><span id='topic+set.jupyter.path'></span>

<h3>Description</h3>

<p><code><a href="#topic+this.path">this.path</a>()</code> does some guess work to determine the path of the
executing notebook in &lsquo;<a href="https://jupyter.org/">Jupyter</a>&rsquo;. This involves listing all the files
in the initial working directory, filtering those which are <span class="rlang"><b>R</b></span> notebooks,
then filtering those with contents matching the top-level expression.
</p>
<p>This could possibly select the wrong file if the same top-level expression is
found in another file. As such, you can use <code>set.jupyter.path()</code> to
declare the executing &lsquo;Jupyter&rsquo; notebook's filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.jupyter.path(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.jupyter.path_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+path.join">path.join</a>()</code>. If no
arguments are provided or exactly one argument is provided that is
<code><a href="base.html#topic+NA">NA</a></code> or <code><a href="base.html#topic+NULL">NULL</a></code>, the &lsquo;Jupyter&rsquo; path
is unset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may only be called from a top-level context in
&lsquo;Jupyter&rsquo;. It is recommended that you do <strong>NOT</strong> provide an
absolute path. Instead, provide just the basename and the directory will be
determined by the initial working directory.
</p>


<h3>Value</h3>

<p>character string, invisibly; the declared path for &lsquo;Jupyter&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ## if you opened the file "~/file50b816a24ec1.ipynb", the initial
# ## working directory should be "~". You can write:
#
# set.jupyter.path("file50b816a24ec1.ipynb")
#
# ## and then this.path() will return "~/file50b816a24ec1.ipynb"
</code></pre>

<hr>
<h2 id='set.sys.path'>Implement 'this.path()' For Arbitrary 'source()'-Like Functions</h2><span id='topic+set.sys.path'></span><span id='topic+set.env.path'></span><span id='topic+set.src.path'></span><span id='topic+unset.sys.path'></span><span id='topic+set.sys.path.function'></span><span id='topic+with_sys.path'></span><span id='topic+wrap.source'></span>

<h3>Description</h3>

<p><code><a href="#topic+sys.path">sys.path</a>()</code> is implemented to work with these functions and
packages: </p>
<ul>
<li><p><code><a href="base.html#topic+source">source</a>()</code> </p>
</li>
<li><p><code><a href="base.html#topic+sys.source">sys.source</a>()</code> </p>
</li>
<li><p><a href="https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE"><code>debugSource</code></a><code>()</code> in &lsquo;<a href="https://posit.co/products/open-source/rstudio/">RStudio</a>&rsquo; </p>
</li>
<li><p><code><a href="compiler.html#topic+compile">compiler::loadcmp</a>()</code> </p>
</li>
<li><p><code><a href="utils.html#topic+Sweave">utils::Sweave</a>()</code> </p>
</li>
<li><p><code><a href="box.html#topic+use">box::use</a>()</code> </p>
</li>
<li><p><code><a href="knitr.html#topic+knit">knitr::knit</a>()</code> </p>
</li>
<li><p><code><a href="plumber.html#topic+plumb">plumber::plumb</a>()</code> </p>
</li>
<li><p><code><a href="shiny.html#topic+runApp">shiny::runApp</a>()</code> </p>
</li>
<li><p><a href="https://CRAN.R-project.org/package=targets"><span class="pkg">package:targets</span></a> </p>
</li>
<li><p><code><a href="testthat.html#topic+source_file">testthat::source_file</a>()</code></p>
</li></ul>

<p><code>set.sys.path()</code> can be used to implement <code>sys.path()</code> for any
other <code>source()</code>-like functions.
</p>
<p><code>set.env.path()</code> and <code>set.src.path()</code> can be used alongside
<code>set.sys.path()</code> to implement <code><a href="#topic+env.path">env.path</a>()</code> and
<code><a href="#topic+src.path">src.path</a>()</code>, thereby fully implementing
<code><a href="#topic+this.path">this.path</a>()</code>. Note that <code>set.env.path()</code> only makes sense
if the code is being modularized, see <strong>Examples</strong>.
</p>
<p><code>unset.sys.path()</code> will undo a call to <code>set.sys.path()</code>. You will
need to use this if you wish to call <code>set.sys.path()</code> multiple times
within a function.
</p>
<p><code>set.sys.path.function()</code> is a special variant of <code>set.sys.path()</code>
to be called within <code>callr::r()</code> on a function with an appropriate
<code><a href="base.html#topic+srcfile">srcref</a></code>.
</p>
<p><code>with_sys.path()</code> is a convenient way to evaluate code within the
context of a file. Whereas <code>set.sys.path()</code> can only be used within a
function, <code>with_sys.path()</code> can only be used outside a function.
</p>
<p>See <code>?<a href="#topic+sys.path">sys.path</a>(local = TRUE)</code> which returns the path of the
executing script, confining the search to the local environment in which
<code>set.sys.path()</code> was called.
</p>
<p><code>wrap.source()</code> should not be used, save for one specific use-case. See
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.sys.path(file,
    path.only = FALSE,
    character.only = path.only,
    file.only = path.only,
    conv2utf8 = FALSE,
    allow.blank.string = FALSE,
    allow.clipboard = !file.only,
    allow.stdin = !file.only,
    allow.url = !file.only,
    allow.file.uri = !path.only,
    allow.unz = !path.only,
    allow.pipe = !file.only,
    allow.terminal = !file.only,
    allow.textConnection = !file.only,
    allow.rawConnection = !file.only,
    allow.sockconn = !file.only,
    allow.servsockconn = !file.only,
    allow.customConnection = !file.only,
    ignore.all = FALSE,
    ignore.blank.string = ignore.all,
    ignore.clipboard = ignore.all,
    ignore.stdin = ignore.all,
    ignore.url = ignore.all,
    ignore.file.uri = ignore.all,
    Function = NULL, ofile)

set.env.path(envir, matchThisEnv = getOption("topLevelEnvironment"))

set.src.path(srcfile)

unset.sys.path()

set.sys.path.function(fun)

with_sys.path(file, expr, ...)

wrap.source(expr,
    path.only = FALSE,
    character.only = path.only,
    file.only = path.only,
    conv2utf8 = FALSE,
    allow.blank.string = FALSE,
    allow.clipboard = !file.only,
    allow.stdin = !file.only,
    allow.url = !file.only,
    allow.file.uri = !path.only,
    allow.unz = !path.only,
    allow.pipe = !file.only,
    allow.terminal = !file.only,
    allow.textConnection = !file.only,
    allow.rawConnection = !file.only,
    allow.sockconn = !file.only,
    allow.servsockconn = !file.only,
    allow.customConnection = !file.only,
    ignore.all = FALSE,
    ignore.blank.string = ignore.all,
    ignore.clipboard = ignore.all,
    ignore.stdin = ignore.all,
    ignore.url = ignore.all,
    ignore.file.uri = ignore.all)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.sys.path_+3A_expr">expr</code></td>
<td>
<p>for <code>with_sys.path()</code>, an expression to evaluate within the
context of a file.
</p>
<p>for <code>wrap.source()</code>, an (unevaluated) call to a <code>source()</code>-like
function.</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_file">file</code></td>
<td>
<p>a
<code><a href="base.html#topic+connections">connection</a></code> or a
character string giving the pathname of the file or URL to read from.</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_path.only">path.only</code></td>
<td>
<p>must <code>file</code> be an existing path? This implies
<code>character.only</code> and <code>file.only</code> are <code>TRUE</code> and implies
<code>allow.file.uri</code> and <code>allow.unz</code> are <code>FALSE</code>, though these
can be manually changed.</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_character.only">character.only</code></td>
<td>
<p>must <code>file</code> be a character string?</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_file.only">file.only</code></td>
<td>
<p>must <code>file</code> refer to an existing file?</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_conv2utf8">conv2utf8</code></td>
<td>
<p>if <code>file</code> is a character string, should it be converted
to UTF-8?</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_allow.blank.string">allow.blank.string</code></td>
<td>
<p>may <code>file</code> be a blank string, i.e.
<code>""</code>?</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_allow.clipboard">allow.clipboard</code></td>
<td>
<p>may <code>file</code> be <code>"clipboard"</code> or a clipboard
connection?</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_allow.stdin">allow.stdin</code></td>
<td>
<p>may <code>file</code> be <code>"stdin"</code>? Note that
<code>"stdin"</code> refers to the C-level &lsquo;standard input&rsquo; of the
process, differing from <code><a href="base.html#topic+showConnections">stdin</a>()</code> which
refers to the R-level &lsquo;standard input&rsquo;.</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_allow.url">allow.url</code></td>
<td>
<p>may <code>file</code> be a URL pathname or a connection of class
<code>"url-libcurl"</code> / / <code>"url-wininet"</code>?</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_allow.file.uri">allow.file.uri</code></td>
<td>
<p>may <code>file</code> be a &lsquo;<span class="samp">&#8288;file://&#8288;</span>&rsquo; URL?</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_allow.unz">allow.unz</code>, <code id="set.sys.path_+3A_allow.pipe">allow.pipe</code>, <code id="set.sys.path_+3A_allow.terminal">allow.terminal</code>, <code id="set.sys.path_+3A_allow.textconnection">allow.textConnection</code>, <code id="set.sys.path_+3A_allow.rawconnection">allow.rawConnection</code>, <code id="set.sys.path_+3A_allow.sockconn">allow.sockconn</code>, <code id="set.sys.path_+3A_allow.servsockconn">allow.servsockconn</code></td>
<td>
<p>may
<code>file</code> be a connection of class
<code>"<a href="base.html#topic+connections">unz</a>"</code>
/ / <code>"pipe"</code> / / <code>"terminal"</code> / / <code>"textConnection"</code> / /
<code>"rawConnection"</code> / / <code>"sockconn"</code> / / <code>"servsockconn"</code>?</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_allow.customconnection">allow.customConnection</code></td>
<td>
<p>may <code>file</code> be a custom connection?</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_ignore.all">ignore.all</code>, <code id="set.sys.path_+3A_ignore.blank.string">ignore.blank.string</code>, <code id="set.sys.path_+3A_ignore.clipboard">ignore.clipboard</code>, <code id="set.sys.path_+3A_ignore.stdin">ignore.stdin</code>, <code id="set.sys.path_+3A_ignore.url">ignore.url</code>, <code id="set.sys.path_+3A_ignore.file.uri">ignore.file.uri</code></td>
<td>
<p>ignore the special meaning of these types
of strings, treating it as a path instead?</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_function">Function</code></td>
<td>
<p>character vector of length <code>1</code> or
<code>2</code>; the name of the function and package in which
<code>set.sys.path()</code> is called.</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_ofile">ofile</code></td>
<td>
<p>a
<code><a href="base.html#topic+connections">connection</a></code> or a
character string specifying the original file argument. This overwrites the
value returned by <code><a href="#topic+sys.path">sys.path</a>(original = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_envir">envir</code>, <code id="set.sys.path_+3A_matchthisenv">matchThisEnv</code></td>
<td>
<p>arguments passed to
<code><a href="base.html#topic+ns-topenv">topenv</a>()</code> to determine the top level
environment in which to assign an associated path.</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_srcfile">srcfile</code></td>
<td>
<p>source file in which to assign a pathname.</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_fun">fun</code></td>
<td>
<p>function with a <code>srcref</code>.</p>
</td></tr>
<tr><td><code id="set.sys.path_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>set.sys.path()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>set.sys.path()</code> should be added to the body of your <code>source()</code>-like
function before reading / / evaluating the expressions.
</p>
<p><code>wrap.source()</code>, unlike <code>set.sys.path()</code>, does not accept an
argument <code>file</code>. Instead, an attempt is made to extract the file from
<code>expr</code>, after which <code>expr</code> is evaluated. It is assumed that the
file is the first argument of the function, as is the case with most
<code>source()</code>-like functions. The function of the call is evaluated, its
<code><a href="base.html#topic+formals">formals</a>()</code> are retrieved,
and then the arguments of <code>expr</code> are searched for a name matching the
name of the first formal argument. If a match cannot be found by name, the
first unnamed argument is taken instead. If no such argument exists, the file
is assumed missing.
</p>
<p><code>wrap.source()</code> does non-standard evaluation and does some guess work to
determine the file. As such, it is less desirable than <code>set.sys.path()</code>
when the option is available. I can think of exactly one scenario in which
<code>wrap.source()</code> might be preferable: suppose there is a
<code>source()</code>-like function <code>sourcelike()</code> in a foreign package (a
package for which you do not have write permission). Suppose that you write
your own function in which the formals are <code>(...)</code> to wrap
<code>sourcelike()</code>: </p>
<pre>wrapper &lt;- function (...)
{
    ## possibly more args to wrap.source()
    wrap.source(sourcelike(...))
}</pre>
<p>This is the only scenario in which <code>wrap.source()</code> is preferable, since
extracting the file from the <code>...</code> list would be a pain. Then again,
you could simply change the formals of <code>wrapper()</code> from <code>(...)</code>
to <code>(file, ...)</code>. If this does not describe your exact scenario, use
<code>set.sys.path()</code> instead.
</p>


<h3>Value</h3>

<p>for <code>set.sys.path()</code>, if <code>file</code> is a path, then the normalized
path with the same attributes, otherwise <code>file</code> itself. The return value
of <code>set.sys.path()</code> should be assigned to a variable before use,
something like: </p>
<pre>{
    file &lt;- set.sys.path(file, ...)
    sourcelike(file)
}</pre>
<p>for <code>set.env.path()</code>, <code>envir</code> invisibly.
</p>
<p>for <code>set.src.path()</code>, <code>srcfile</code> invisibly.
</p>
<p>for <code>unset.sys.path()</code> and <code>set.sys.path.function()</code>, <code>NULL</code>
invisibly.
</p>
<p>for <code>with_sys.path()</code> and <code>wrap.source()</code>, the result of evaluating
<code>expr</code>.
</p>


<h3>Using 'ofile'</h3>

<p><code>ofile</code> can be used when the <code>file</code> argument supplied to
<code>set.sys.path()</code> is not the same as the <code>file</code> argument supplied to
the <code>source()</code>-like function:
</p>
<pre>sourcelike &lt;- function (file)
{
    ofile &lt;- file
    if (!is.character(ofile) || length(ofile) != 1)
        stop(gettextf("'%s' must be a character string", "file"))
    ## if the file exists, do nothing
    if (file.exists(file)) {
    }
    ## look for the file in the home directory
    ## if it exists, do nothing
    else if (file.exists(file &lt;- this.path::path.join("~", ofile))) {
    }
    ## you could add other directories to look in,
    ## but this is good enough for an example
    else stop(gettextf("'%s' is not an existing file", ofile))
    file &lt;- this.path::set.sys.path(file, ofile = ofile)
    exprs &lt;- parse(n = -1, file = file)
    for (i in seq_along(exprs)) eval(exprs[i], envir)
    invisible()
}</pre>


<h3>Examples</h3>

<pre><code class='language-R'>FILE.R &lt;- tempfile(fileext = ".R")
this.path:::.writeCode({
    this.path::sys.path(verbose = TRUE)
    try(this.path::env.path(verbose = TRUE))
    this.path::src.path(verbose = TRUE)
    this.path::this.path(verbose = TRUE)
}, FILE.R)


## here we have a source-like function, suppose this
## function is in a package for which you have write permission
sourcelike &lt;- function (file, envir = parent.frame())
{
    ofile &lt;- file
    file &lt;- set.sys.path(file, Function = "sourcelike")
    lines &lt;- readLines(file, warn = FALSE)
    filename &lt;- sys.path(local = TRUE, for.msg = TRUE)
    isFile &lt;- !is.na(filename)
    if (isFile) {
        timestamp &lt;- file.mtime(filename)[1]
        ## in case 'ofile' is a URL pathname / / 'unz' connection
        if (is.na(timestamp))
            timestamp &lt;- Sys.time()
    }
    else {
        filename &lt;- if (is.character(ofile)) ofile else "&lt;connection&gt;"
        timestamp &lt;- Sys.time()
    }
    srcfile &lt;- srcfilecopy(filename, lines, timestamp, isFile)
    set.src.path(srcfile)
    exprs &lt;- parse(text = lines, srcfile = srcfile, keep.source = FALSE)
    invisible(source.exprs(exprs, evaluated = TRUE, envir = envir))
}


sourcelike(FILE.R)
sourcelike(conn &lt;- file(FILE.R)); close(conn)


## here we have another source-like function, suppose this function
## is in a foreign package for which you do not have write permission
sourcelike2 &lt;- function (pathname, envir = globalenv())
{
    if (!(is.character(pathname) &amp;&amp; file.exists(pathname)))
        stop(gettextf("'%s' is not an existing file",
             pathname, domain = "R-base"))
    envir &lt;- as.environment(envir)
    lines &lt;- readLines(pathname, warn = FALSE)
    srcfile &lt;- srcfilecopy(pathname, lines, isFile = TRUE)
    exprs &lt;- parse(text = lines, srcfile = srcfile, keep.source = FALSE)
    invisible(source.exprs(exprs, evaluated = TRUE, envir = envir))
}


## the above function is similar to sys.source(), and it
## expects a character string referring to an existing file
##
## with the following, you should be able
## to use 'sys.path()' within 'FILE.R':
wrap.source(sourcelike2(FILE.R), path.only = TRUE)


# ## with R &gt;= 4.1.0, use the forward pipe operator '|&gt;' to
# ## make calls to 'wrap.source' more intuitive:
# sourcelike2(FILE.R) |&gt; wrap.source(path.only = TRUE)


## 'wrap.source' can recognize arguments by name, so they
## do not need to appear in the same order as the formals
wrap.source(sourcelike2(envir = new.env(), pathname = FILE.R),
    path.only = TRUE)


## it it much easier to define a new function to do this
sourcelike3 &lt;- function (...)
wrap.source(sourcelike2(...), path.only = TRUE)


## the same as before
sourcelike3(FILE.R)


## however, this is preferable:
sourcelike4 &lt;- function (pathname, ...)
{
    ## pathname is now normalized
    pathname &lt;- set.sys.path(pathname, path.only = TRUE)
    sourcelike2(pathname = pathname, ...)
}
sourcelike4(FILE.R)


## perhaps you wish to run several scripts in the same function
fun &lt;- function (paths, ...)
{
    for (pathname in paths) {
        pathname &lt;- set.sys.path(pathname, path.only = TRUE)
        sourcelike2(pathname = pathname, ...)
        unset.sys.path(pathname)
    }
}


## here we have a source-like function which modularizes its code
sourcelike5 &lt;- function (file)
{
    ofile &lt;- file
    file &lt;- set.sys.path(file, Function = "sourcelike5")
    lines &lt;- readLines(file, warn = FALSE)
    filename &lt;- sys.path(local = TRUE, for.msg = TRUE)
    isFile &lt;- !is.na(filename)
    if (isFile) {
        timestamp &lt;- file.mtime(filename)[1]
        ## in case 'ofile' is a URL pathname / / 'unz' connection
        if (is.na(timestamp))
            timestamp &lt;- Sys.time()
    }
    else {
        filename &lt;- if (is.character(ofile)) ofile else "&lt;connection&gt;"
        timestamp &lt;- Sys.time()
    }
    srcfile &lt;- srcfilecopy(filename, lines, timestamp, isFile)
    set.src.path(srcfile)
    envir &lt;- new.env(hash = TRUE, parent = .BaseNamespaceEnv)
    envir$.packageName &lt;- filename
    oopt &lt;- options(topLevelEnvironment = envir)
    on.exit(options(oopt))
    set.env.path(envir)
    exprs &lt;- parse(text = lines, srcfile = srcfile, keep.source = FALSE)
    source.exprs(exprs, evaluated = TRUE, envir = envir)
    envir
}


sourcelike5(FILE.R)


## the code can be made much simpler in some cases
sourcelike6 &lt;- function (file)
{
    ## we expect a character string refering to a file
    ofile &lt;- file
    filename &lt;- set.sys.path(file, path.only = TRUE, ignore.all = TRUE,
        Function = "sourcelike6")
    lines &lt;- readLines(filename, warn = FALSE)
    timestamp &lt;- file.mtime(filename)[1]
    srcfile &lt;- srcfilecopy(filename, lines, timestamp, isFile = TRUE)
    set.src.path(srcfile)
    envir &lt;- new.env(hash = TRUE, parent = .BaseNamespaceEnv)
    envir$.packageName &lt;- filename
    oopt &lt;- options(topLevelEnvironment = envir)
    on.exit(options(oopt))
    set.env.path(envir)
    exprs &lt;- parse(text = lines, srcfile = srcfile, keep.source = FALSE)
    source.exprs(exprs, evaluated = TRUE, envir = envir)
    envir
}


sourcelike6(FILE.R)


unlink(FILE.R)
</code></pre>

<hr>
<h2 id='shFILE'>Get 'FILE' Provided to R by a Shell</h2><span id='topic+shFILE'></span>

<h3>Description</h3>

<p>Look through the command line arguments, extracting <span class="option">FILE</span> from either
of the following: <span class="option">-f</span> <span class="option">FILE</span> or <span class="option">--file=FILE</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shFILE(original = FALSE, for.msg = FALSE, default, else.)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shFILE_+3A_original">original</code></td>
<td>
<p><code>TRUE</code>, <code>FALSE</code>, or <code>NA</code>; should the original
or the normalized path be returned? <code>NA</code> means the normalized path
will be returned if it has already been forced, and the original path
otherwise.</p>
</td></tr>
<tr><td><code id="shFILE_+3A_for.msg">for.msg</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>; do you want the path for the
purpose of printing a diagnostic message / / warning / / error?
<code>for.msg = TRUE</code> will ignore <code>original = FALSE</code>, and will use
<code>original = NA</code> instead.</p>
</td></tr>
<tr><td><code id="shFILE_+3A_default">default</code></td>
<td>
<p>if <span class="option">FILE</span> is not found, this value is returned.</p>
</td></tr>
<tr><td><code id="shFILE_+3A_else.">else.</code></td>
<td>
<p>missing or a function to apply if <span class="option">FILE</span> is found. See
<code><a href="#topic+tryCatch2">tryCatch2</a>()</code> for
inspiration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string, or <code>default</code> if <span class="option">FILE</span> was not found.
</p>


<h3>Note</h3>

<p>The original and the normalized path are saved; this makes them faster when
called subsequent times.
</p>
<p>On Windows, the normalized path will use <code>/</code> as the
file separator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+this.path">this.path</a>()</code>, <code><a href="#topic+here">here</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FILE.R &lt;- tempfile(fileext = ".R")
this.path:::.writeCode({
    this.path:::.withAutoprint({
        shFILE(original = TRUE)
        shFILE()
        shFILE(default = {
            stop("since 'FILE.R' will be found,\n",
                 "this error will not be thrown")
        })
    }, spaced = TRUE, verbose = FALSE, width.cutoff = 60L)
}, FILE.R)
this.path:::.Rscript(
    c("--default-packages=this.path", "--vanilla", FILE.R)
)
unlink(FILE.R)


for (expr in c("shFILE(original = TRUE)",
               "shFILE(original = TRUE, default = NULL)",
               "shFILE()",
               "shFILE(default = NULL)"))
{
    cat("\n\n")
    this.path:::.Rscript(
        c("--default-packages=this.path", "--vanilla", "-e", expr)
    )
}
</code></pre>

<hr>
<h2 id='source.exprs'>Evaluate and Print Expressions</h2><span id='topic+source.exprs'></span>

<h3>Description</h3>

<p><code>source.exprs()</code> evaluates and auto-prints expressions as if in a
toplevel context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>source.exprs(exprs, evaluated = FALSE, envir = parent.frame(),
             echo = TRUE, print.eval = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="source.exprs_+3A_exprs">exprs</code>, <code id="source.exprs_+3A_evaluated">evaluated</code>, <code id="source.exprs_+3A_envir">envir</code>, <code id="source.exprs_+3A_echo">echo</code>, <code id="source.exprs_+3A_print.eval">print.eval</code></td>
<td>
<p>See
<code><a href="base.html#topic+source">withAutoprint</a>()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='startup_files'>Files Related to Initialization of the R Session</h2><span id='topic+site.file'></span><span id='topic+init.file'></span><span id='topic+with_site.file'></span><span id='topic+with_init.file'></span>

<h3>Description</h3>

<p><code>site.file()</code> and <code>init.file()</code> return the
<code><a href="base.html#topic+normalizePath">normalized</a></code> paths
of the site-wide startup profile file and the user profile that were run at
<code><a href="base.html#topic+Startup">startup</a></code>.
</p>
<p><code>with_init.file()</code> declares that the current script is the user profile
then evaluates and auto-prints the sub-expressions of its argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>site.file(original = FALSE, for.msg = FALSE, default, else.)
init.file(original = FALSE, for.msg = FALSE, default, else.)

with_site.file(expr)
with_init.file(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="startup_files_+3A_original">original</code>, <code id="startup_files_+3A_for.msg">for.msg</code>, <code id="startup_files_+3A_default">default</code>, <code id="startup_files_+3A_else.">else.</code></td>
<td>
<p>Same as <code><a href="#topic+shFILE">shFILE</a>()</code>.</p>
</td></tr>
<tr><td><code id="startup_files_+3A_expr">expr</code></td>
<td>
<p>a braced expression, the sub-expressions of which to evaluate and
auto-print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>site.file()</code> and <code>init.file()</code>, a character string, or
<code>default</code> if it was not found.
</p>
<p>for <code>with_site.file()</code> and <code>with_init.file()</code>, <code>NULL</code>
invisibly.
</p>


<h3>Note</h3>

<p><code>with_site.file()</code> is unneeded now that the site-wide startup profile
file can be automatically detected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## if you wish to use this.path() in a user profile,
## instead of writing:
##
## &lt;expr 1&gt;
## &lt;expr 2&gt;
## &lt;...&gt;
##
## write this:
##
## this.path::with_init.file({
## &lt;expr 1&gt;
## &lt;expr 2&gt;
## &lt;...&gt;
## })
</code></pre>

<hr>
<h2 id='sys'>Call Stack Inspection</h2><span id='topic+sys.srcref'></span><span id='topic+sys.whiches'></span>

<h3>Description</h3>

<p><code>sys.srcref()</code> is the R-level version of the function that implements
<code><a href="#topic+this.path">this.path</a>()</code>. It retrieves the
<code><a href="base.html#topic+srcfile">srcref</a></code> of the call <code>n</code> generations back from
itself.
</p>
<p><code>sys.whiches()</code> is the R-level version of the function that implements
<code>sys.srcref()</code>. It returns the frame numbers of all calls with a common
parent frame <code>n</code> generations back from itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sys.srcref(n = 1, which = if (n) sys.parent(n) else 0)
sys.whiches(n = 1, which = if (n) sys.parent(n) else 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sys_+3A_n">n</code></td>
<td>
<p>See <code>?<a href="#topic+this.path">this.path</a>()</code>. However, note that <code>n</code> defaults
to <code>0</code> in <code>this.path()</code> but defaults to <code>1</code> here.</p>
</td></tr>
<tr><td><code id="sys_+3A_which">which</code></td>
<td>
<p>frame number to inspect. An alternative to specifying <code>n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>sys.srcref()</code>, a <code>srcref</code> object or <code>NULL</code>.
</p>
<p>for <code>sys.whiches()</code>, an integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## this example will not work with 'Run examples'
## which uses 'package:knitr' since knitted
## documents do not store source references
fun &lt;- function ()
{
    list(
        `sys.srcref()` = this.path::sys.srcref(),
        ## while this might seem like a simpler alternative,
        ## you will see it does not work in a couple cases below
        `attr(sys.call(sys.parent()), "srcref")` =
            attr(sys.call(sys.parent()), "srcref")
    )
}


## the braces are unnecessary when using example("sys.srcref"),
## but are needed when copied into the R Console
{ fun() }
{ print(fun()) }
{ try(print(fun())) }





fun2 &lt;- function ()
{
    list(
        ## if copied directly into the R Console,
        ## should be 1 6 7
        ## 1 is the frame number associated with 'try'
        ## 6                                     'force'
        ## 7                                     'fun2'
        this.path::sys.whiches(),


        ## if copied directly into the R Console,
        ## should be  8 12 13
        ##  8 is the frame number associated with 'tryCatch'
        ## 12                                     'identity'
        ## 13                                     'sys.whiches'
        tryCatch(identity(this.path::sys.whiches(0)),
            error = function(e) NULL)
    )
}


try(force(fun2()))


</code></pre>

<hr>
<h2 id='sys.path'>Variants of Core Functions in Package 'this.path'</h2><span id='topic+sys.path'></span><span id='topic+src.path'></span><span id='topic+src.dir'></span><span id='topic+src.here'></span><span id='topic+src.proj'></span><span id='topic+rel2src.dir'></span><span id='topic+rel2src.proj'></span><span id='topic+src.LINENO'></span><span id='topic+try.src.path'></span><span id='topic+env.path'></span><span id='topic+env.dir'></span><span id='topic+env.here'></span><span id='topic+env.proj'></span><span id='topic+rel2env.dir'></span><span id='topic+rel2env.proj'></span><span id='topic+env.LINENO'></span><span id='topic+try.env.path'></span><span id='topic+sys.dir'></span><span id='topic+sys.here'></span><span id='topic+sys.proj'></span><span id='topic+rel2sys.dir'></span><span id='topic+rel2sys.proj'></span><span id='topic+sys.LINENO'></span><span id='topic+try.sys.path'></span>

<h3>Description</h3>

<p><code><a href="#topic+this.path">this.path</a>()</code> is composed of three sections:
</p>

<ol>
<li><p>examining argument <code>srcfile</code>.
</p>
</li>
<li><p>examining arguments <code>envir</code> and <code>matchThisEnv</code>.
</p>
</li>
<li><p>examining the call stack and the GUI in use.
</p>
</li></ol>

<p><code>src.path()</code>, <code>env.path()</code>, and <code>sys.path()</code> can be used to
perform any of those sections individually.
</p>
<p>The other functions listed here are similar such variants of the core
functions <code><a href="#topic+this.dir">this.dir</a>()</code>, <code><a href="#topic+here">here</a>()</code>,
<code><a href="#topic+this.proj">this.proj</a>()</code>, <code><a href="#topic+rel2here">rel2here</a>()</code>,
<code><a href="#topic+rel2proj">rel2proj</a>()</code>, <code><a href="#topic+LINENO">LINENO</a>()</code>, and
<code><a href="#topic+try.this.path">try.this.path</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>src.path(verbose = getOption("verbose"), original = FALSE,
         for.msg = FALSE, contents = FALSE, n = 0,
         srcfile = if (n) sys.parent(n) else 0,
         default, else.)
src.dir(verbose = getOption("verbose"), n = 0,
        srcfile = if (n) sys.parent(n) else 0,
        default, else.)
src.here(..., n = 0,
         srcfile = if (n) sys.parent(n) else 0, .. = 0)
src.proj(..., n = 0,
         srcfile = if (n) sys.parent(n) else 0)
rel2src.dir(path, n = 0,
            srcfile = if (n) sys.parent(n) else 0)
rel2src.proj(path, n = 0,
             srcfile = if (n) sys.parent(n) else 0)
src.LINENO(n = 0, srcfile = if (n) sys.parent(n) else 0)
try.src.path(contents = FALSE, n = 0,
             srcfile = if (n) sys.parent(n) else 0)

env.path(verbose = getOption("verbose"), original = FALSE,
         for.msg = FALSE, contents = FALSE, n = 0,
         envir = parent.frame(n + 1),
         matchThisEnv = getOption("topLevelEnvironment"),
         default, else.)
env.dir(verbose = getOption("verbose"), n = 0,
        envir = parent.frame(n + 1),
        matchThisEnv = getOption("topLevelEnvironment"),
        default, else.)
env.here(..., n = 0, envir = parent.frame(n + 1),
         matchThisEnv = getOption("topLevelEnvironment"), .. = 0)
env.proj(..., n = 0, envir = parent.frame(n + 1),
         matchThisEnv = getOption("topLevelEnvironment"))
rel2env.dir(path, n = 0, envir = parent.frame(n + 1),
            matchThisEnv = getOption("topLevelEnvironment"))
rel2env.proj(path, n = 0, envir = parent.frame(n + 1),
             matchThisEnv = getOption("topLevelEnvironment"))
env.LINENO(n = 0, envir = parent.frame(n + 1),
           matchThisEnv = getOption("topLevelEnvironment"))
try.env.path(contents = FALSE, n = 0,
             envir = parent.frame(n + 1),
             matchThisEnv = getOption("topLevelEnvironment"))

sys.path(verbose = getOption("verbose"), original = FALSE,
         for.msg = FALSE, contents = FALSE, local = FALSE,
         default, else.)
sys.dir(verbose = getOption("verbose"), local = FALSE,
        default, else.)
sys.here(..., local = FALSE, .. = 0)
sys.proj(..., local = FALSE)
rel2sys.dir(path, local = FALSE)
rel2sys.proj(path, local = FALSE)
sys.LINENO()
try.sys.path(contents = FALSE, local = FALSE)
</code></pre>


<h3>Details</h3>

<p>Before <span class="pkg">this.path 2.0.0</span>, <code>this.path()</code> did not have arguments
<code>srcfile</code>, <code>envir</code>, nor <code>matchThisEnv</code>. It only examined the
call stack and the GUI in use. In the major update, the original
implementation of <code>this.path()</code> was renamed to <code>sys.path()</code>.
<code>sys.path()</code> and related are available for backwards compatibility.
However, they are unlikely to be useful compared to the advancements made in
<code>this.path()</code>.
</p>
<p><code>env.path()</code> and <code>src.path()</code> and related are unlikely to be useful
when called with no arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the important difference between 'this.path()' and 'sys.path()'
FILE1.R &lt;- tempfile("FILE1-", fileext = ".R")
this.path:::.writeCode({
    fun &lt;- function() {
        cat("\n&gt; this.path()\n")
        print(this.path::this.path(verbose = TRUE))
        cat("\n&gt; sys.path()\n")
        print(this.path::sys.path(verbose = TRUE))
    }
    ## 'this.path()' and 'sys.path()' should be identical because the
    ## executing script is the same as the script of the source file
    fun()
}, FILE1.R)
source(FILE1.R, keep.source = TRUE)

FILE2.R &lt;- tempfile("FILE2-", fileext = ".R")
this.path:::.writeCode({
    ## 'this.path()' and 'sys.path()' should no longer be identical
    ## since FILE2.R is now the executing script, and FILE1.R is not
    fun()
}, FILE2.R)
source(FILE2.R)

unlink(c(FILE1.R, FILE2.R))
</code></pre>

<hr>
<h2 id='Sys.putenv'>Set Environment Variables</h2><span id='topic+Sys.putenv'></span>

<h3>Description</h3>

<p><code>Sys.putenv()</code> sets environment variables (for other processes called
from within <span class="rlang"><b>R</b></span> or future calls to <code><a href="base.html#topic+Sys.getenv">Sys.getenv</a>()</code> from this
<span class="rlang"><b>R</b></span> process).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sys.putenv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sys.putenv_+3A_x">x</code></td>
<td>
<p>a character vector, or an object coercible to character. Strings
must be of the form
<code>"<var>name</var>=<var>value</var>"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, with elements being true if setting the corresponding
variable succeeded.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Sys.setenv">Sys.setenv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sys.putenv(c("R_TEST=testit", "A+C=123"))
Sys.getenv("R_TEST")
Sys.unsetenv("R_TEST")  ## under Unix-alikes may warn and not succeed
Sys.getenv("R_TEST", unset = NA)
</code></pre>

<hr>
<h2 id='this.path'>Determine Script's Filename</h2><span id='topic+this.path'></span><span id='topic+this.dir'></span>

<h3>Description</h3>

<p><code>this.path()</code> returns the
<code><a href="base.html#topic+normalizePath">normalized</a></code> path of
the script in which it was written.
</p>
<p><code>this.dir()</code> returns the directory of <code>this.path()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>this.path(verbose = getOption("verbose"), original = FALSE,
          for.msg = FALSE, contents = FALSE, local = FALSE,
          n = 0, envir = parent.frame(n + 1),
          matchThisEnv = getOption("topLevelEnvironment"),
          srcfile = if (n) sys.parent(n) else 0,
          default, else.)

this.dir(verbose = getOption("verbose"), local = FALSE,
         n = 0, envir = parent.frame(n + 1),
         matchThisEnv = getOption("topLevelEnvironment"),
         srcfile = if (n) sys.parent(n) else 0,
         default, else.)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="this.path_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>; should the method in which the
path was determined be printed?</p>
</td></tr>
<tr><td><code id="this.path_+3A_original">original</code></td>
<td>
<p><code>TRUE</code>, <code>FALSE</code>, or <code>NA</code>; should the original
or the normalized path be returned? <code>NA</code> means the normalized path
will be returned if it has already been forced, and the original path
otherwise.</p>
</td></tr>
<tr><td><code id="this.path_+3A_for.msg">for.msg</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>; do you want the path for the
purpose of printing a diagnostic message / / warning / / error? This will
return <code><a href="base.html#topic+NA">NA_character_</a></code> in most cases where an error
would have been thrown.
</p>
<p><code>for.msg = TRUE</code> will ignore <code>original = FALSE</code>, and will use
<code>original = NA</code> instead.</p>
</td></tr>
<tr><td><code id="this.path_+3A_contents">contents</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>; should the contents of the
script be returned instead?
</p>
<p>In &lsquo;Jupyter&rsquo;, a list of character vectors will be returned, the
contents separated into cells. Otherwise, a character vector will be
returned. If the executing script cannot be determined and <code>for.msg</code>
is <code>TRUE</code>, <code>NULL</code> will be returned.
</p>
<p>You could use
<code><a href="base.html#topic+character">as.character</a>(<a href="base.html#topic+unlist">unlist</a>(this.path(contents = TRUE)))</code>
if you require a character vector.
</p>
<p>This is intended for logging purposes. This is useful in &lsquo;Rgui&rsquo;,
&lsquo;RStudio&rsquo;, &lsquo;VSCode&rsquo;, and &lsquo;Emacs&rsquo; when the source
document has contents but no path.</p>
</td></tr>
<tr><td><code id="this.path_+3A_local">local</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>; should the search for the executing
script be confined to the local environment in which
<code><a href="#topic+set.sys.path">set.sys.path</a>()</code> was called?</p>
</td></tr>
<tr><td><code id="this.path_+3A_n">n</code></td>
<td>
<p>the number of additional generations to go back. By default,
<code>this.path()</code> will look for a path based on the
<code><a href="base.html#topic+srcfile">srcref</a></code> of the call
to <code>this.path()</code> and the environment in which <code>this.path()</code> was
called. This can be changed to be based on the <code>srcref</code> of the call
and the calling environment <code>n</code> generations up the stack. See section
<strong>Argument 'n'</strong> for more details.</p>
</td></tr>
<tr><td><code id="this.path_+3A_envir">envir</code>, <code id="this.path_+3A_matchthisenv">matchThisEnv</code></td>
<td>
<p>arguments passed to
<code><a href="base.html#topic+ns-topenv">topenv</a>()</code> to determine the top level
environment in which to search for an associated path.</p>
</td></tr>
<tr><td><code id="this.path_+3A_srcfile">srcfile</code></td>
<td>
<p>source file in which to search for a pathname, or an object
containing a source file. This includes a source reference, a call, an
expression object, or a closure.</p>
</td></tr>
<tr><td><code id="this.path_+3A_default">default</code></td>
<td>
<p>this value is returned if there is no executing script.</p>
</td></tr>
<tr><td><code id="this.path_+3A_else.">else.</code></td>
<td>
<p>function to apply if there is an executing script. See
<code><a href="#topic+tryCatch2">tryCatch2</a>()</code> for inspiration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>this.path()</code> starts by examining argument <code>srcfile</code>. It looks at
the bindings <code>filename</code> and <code>wd</code> to determine the associated file
path. A source file of class <code>"srcfilecopy"</code> in which binding
<code>isFile</code> is <code>FALSE</code> will be ignored. A source file of class
<code>"srcfilealias"</code> will use the aliased <code>filename</code> in determining the
associated path. Filenames such as <code>""</code>, <code>"clipboard"</code>, and
<code>"stdin"</code> will be ignored since they do not refer to files.
</p>
<p>If it does not find a path associated with <code>srcfile</code>, it will next
examine arguments <code>envir</code> and <code>matchThisEnv</code>. Specifically, it
calculates <code><a href="base.html#topic+ns-topenv">topenv</a>(envir, matchThisEnv)</code> then
looks for an associated path. It will find a path associated with the top
level environment in two ways:
</p>

<ul>
<li><p>from a <a href="https://CRAN.R-project.org/package=box"><span class="pkg">package:box</span></a> module's namespace
</p>
</li>
<li><p>from an attribute <code>"path"</code>
</p>
</li></ul>

<p>If it does not find an associated path with <code>envir</code> and
<code>matchThisEnv</code>, it will next examine the call stack looking for a source
call; a call to one of these functions: </p>
<ul>
<li><p><code><a href="base.html#topic+source">source</a>()</code> </p>
</li>
<li><p><code><a href="base.html#topic+sys.source">sys.source</a>()</code> </p>
</li>
<li><p><a href="https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE"><code>debugSource</code></a><code>()</code> in &lsquo;<a href="https://posit.co/products/open-source/rstudio/">RStudio</a>&rsquo; </p>
</li>
<li><p><code><a href="compiler.html#topic+compile">compiler::loadcmp</a>()</code> </p>
</li>
<li><p><code><a href="utils.html#topic+Sweave">utils::Sweave</a>()</code> </p>
</li>
<li><p><code><a href="box.html#topic+use">box::use</a>()</code> </p>
</li>
<li><p><code><a href="knitr.html#topic+knit">knitr::knit</a>()</code> </p>
</li>
<li><p><code><a href="plumber.html#topic+plumb">plumber::plumb</a>()</code> </p>
</li>
<li><p><code><a href="shiny.html#topic+runApp">shiny::runApp</a>()</code> </p>
</li>
<li><p><code><a href="targets.html#topic+tar_callr_inner_try">targets::tar_callr_inner_try</a>()</code> <br /> <code><a href="targets.html#topic+tar_load_globals">targets::tar_load_globals</a>()</code> <br /> <code><a href="targets.html#topic+tar_source">targets::tar_source</a>()</code> <br /> <code><a href="targets.html#topic+tar_workspace">targets::tar_workspace</a>()</code> </p>
</li>
<li><p><code><a href="testthat.html#topic+source_file">testthat::source_file</a>()</code></p>
</li></ul>
<p> If a source call is
found, the file argument is returned from the function's evaluation
environment. If you have your own <code>source()</code>-like function that you would
like to be recognized by <code>this.path()</code>, please use
<code><a href="#topic+set.sys.path">set.sys.path</a>()</code> or contact the package maintainer so that it can
be implemented.
</p>
<p>If no source call is found up the calling stack, it will next examine the GUI
in use. If <span class="rlang"><b>R</b></span> is running from:
</p>

<dl>
<dt>a shell, such as the Windows command-line / / Unix terminal</dt><dd>
<p>then the shell arguments are searched for <span class="option">-f</span> <span class="option">FILE</span> or
<span class="option">--file=FILE</span> (the two methods of taking input from <span class="option">FILE</span>)
(<span class="option">-f</span> <span class="option">-</span> and <span class="option">--file=-</span> are ignored). The last
<span class="option">FILE</span> is extracted and returned. If no arguments of either type
are supplied, an error is thrown.
</p>
<p>If <span class="rlang"><b>R</b></span> is running from a shell under a Unix-alike with <span class="option">-g</span>
<span class="option">Tk</span> or <span class="option">--gui=Tk</span>, an error is thrown. &lsquo;Tk&rsquo; does
not make use of its <span class="option">-f</span> <span class="option">FILE</span>, <span class="option">--file=FILE</span>
arguments.</p>
</dd>
<dt>&lsquo;Rgui&rsquo;</dt><dd>
<p>then the source document's filename (the document most recently
interacted with) is returned (at the time of evaluation). Please note
that minimized documents <em>WILL</em> be included when looking for the
most recently used document. It is important to not leave the current
document (either by closing the document or interacting with another
document) while any calls to <code>this.path()</code> have yet to be evaluated
in the run selection. If no documents are open or the source document
does not exist (not saved anywhere), an error is thrown.</p>
</dd>
<dt>&lsquo;<a href="https://posit.co/products/open-source/rstudio/">RStudio</a>&rsquo;</dt><dd>
<p>then the active document's filename (the document in which the cursor is
active) is returned (at the time of evaluation). If the active document
is the <span class="rlang"><b>R</b></span> console, the source document's filename (the document open in
the current tab) is returned (at the time of evaluation). Please note
that the source document will <em>NEVER</em> be a document open in another
window (with the <strong>Show in new window</strong> button). Please also note
that an active document open in another window can sometimes lose focus
and become inactive, thus returning the incorrect path. It is best
<strong>NOT</strong> to not run <span class="rlang"><b>R</b></span> code from a document open in another window.
It is important to not leave the current tab (either by closing or
switching tabs) while any calls to <code>this.path()</code> have yet to be
evaluated in the run selection. If no documents are open or the source
document does not exist (not saved anywhere), an error is thrown.</p>
</dd>
<dt>&lsquo;<a href="https://github.com/posit-dev/positron">Positron</a>&rsquo;</dt><dd>
<p>then the source document's filename is returned (at the time of
evaluation). It is important to not leave the current tab (either by
closing or switching tabs) while any calls to <code>this.path()</code> have yet
to be evaluated in the run selection. If no documents are open or the
source document does not exist (not saved anywhere), an error is thrown.</p>
</dd>
<dt>&lsquo;<a href="https://code.visualstudio.com/">VSCode</a>&rsquo; + &lsquo;<a href="https://code.visualstudio.com/docs/languages/r">REditorSupport</a>&rsquo;</dt><dd>
<p>then the source document's filename is returned (at the time of
evaluation). It is important to not leave the current tab (either by
closing or switching tabs) while any calls to <code>this.path()</code> have yet
to be evaluated in the run selection. If no documents are open or the
source document does not exist (not saved anywhere), an error is thrown.</p>
</dd>
<dt>&lsquo;<a href="https://jupyter.org/">Jupyter</a>&rsquo;</dt><dd>
<p>then the source document's filename is guessed by looking for <span class="rlang"><b>R</b></span>
notebooks in the initial working directory, then searching the contents
of those files for an expression matching the top-level expression.
Please be sure to save your notebook before using <code>this.path()</code>, or
explicitly use <code><a href="#topic+set.jupyter.path">set.jupyter.path</a>()</code>.</p>
</dd>
<dt>&lsquo;<a href="https://www.gnu.org/software/emacs/">Emacs</a>&rsquo; + &lsquo;<a href="https://ess.r-project.org/">ESS</a>&rsquo;</dt><dd>
<p>then the source document's filename is returned (at the time of
evaluation). &lsquo;Emacs&rsquo; must be running as a server, either by
running <code>(server-start)</code> (consider adding to your &lsquo;<span class="file">~/.emacs</span>&rsquo;
file) or typing <code>M-x server-start</code>. It is important to not leave the
current window (either by closing or switching buffers) while any calls
to <code>this.path()</code> have yet to be evaluated in the run selection. If
multiple frames are active, <code>this.path()</code> will pick the first frame
containing the corresponding <span class="rlang"><b>R</b></span> session.
</p>
<p>If multiple &lsquo;Emacs&rsquo; sessions are active, <code>this.path()</code> will
only work in the primary session due to limitations in
</p>
<p>&lsquo;emacsclient&rsquo;.
If you want to run multiple <span class="rlang"><b>R</b></span> sessions, it is better to run one
&lsquo;Emacs&rsquo; session with multiple frames, one <span class="rlang"><b>R</b></span> session per frame.
Use <code>M-x make-frame</code> to make a new frame, or <code>C-x 5 f</code> to visit
a file in a new frame.
</p>
<p>Additionally, never use <code>C-c C-b</code> to send the current buffer to the
<span class="rlang"><b>R</b></span> process. This copies the buffer contents to a new file which is then
<code>source()</code>-ed. The source references now point to the wrong file.
Instead, use <code>C-x h</code> to select the entire buffer then <code>C-c C-r</code>
to evaluate the selection.</p>
</dd>
<dt>&lsquo;AQUA&rsquo;</dt><dd>
<p>then the executing script's path cannot be determined. Until such a time
that there is a method for requesting the path of an open document,
consider using &lsquo;RStudio&rsquo;, &lsquo;Positron&rsquo;, &lsquo;VSCode&rsquo;, or
&lsquo;Emacs&rsquo;.</p>
</dd>
</dl>

<p>If <span class="rlang"><b>R</b></span> is running in another manner, an error is thrown.
</p>
<p>If your GUI of choice is not implemented with <code>this.path()</code>, please
contact the package maintainer so that it can be implemented.
</p>


<h3>Value</h3>

<p><code>default</code> if there is no executing script.
</p>
<p>If <code>contents</code> is <code>TRUE</code>, there are a variety of return values. If a
custom GUI is implemented with <code><a href="#topic+set.gui.path">set.gui.path</a>()</code>, any <span class="rlang"><b>R</b></span> object.
If the executing script cannot be determined and <code>for.msg</code> is
<code>TRUE</code>, then <code>NULL</code>. In <a href="https://jupyter.org/">Jupyter</a>, a list of character vectors, the
contents separated into cells. Otherwise, a character vector.
</p>
<p>Otherwise, a character string.
</p>


<h3>Argument 'n'</h3>

<p>By default, <code>this.path()</code> will look for a path based on the
<code>srcref</code> of the call to <code>this.path()</code> and the environment in which
<code>this.path()</code> was called. For example: </p>
<pre>{
#line 1 "file1.R"
fun &lt;- function() this.path::this.path(original = TRUE)
fun()
}


{
#line 1 "file2.R"
fun()
}</pre>
<p>Both of these will return <code>"file1.R"</code> because that is where the call to
<code>this.path()</code> is written.
</p>
<p>But suppose we do not care to know where <code>this.path()</code> is called, but
instead want to know where <code>fun()</code> is called. Pass argument <code>n = 1</code>;
<code>this.path()</code> will inspect the call and the calling environment one
generation up the stack: </p>
<pre>{
#line 1 "file1.R"
fun &lt;- function() this.path::this.path(original = TRUE, n = 1)
fun()
}


{
#line 1 "file2.R"
fun()
}</pre>
<p>These will return <code>"file1.R"</code> and <code>"file2.R"</code>, respectively,
because those are where the calls to <code>fun()</code> are written.
</p>
<p>But now suppose we wish to make a second function that uses <code>fun()</code>. We
do not care to know where <code>fun()</code> is called, but instead want to know
where <code>fun2()</code> is called. Add a formal argument <code>n = 0</code> to each
function and pass <code>n = n + 1</code> to each sub-function: </p>
<pre>{
#line 1 "file1.R"
fun &lt;- function(n = 0) {
    this.path::this.path(original = TRUE, n = n + 1)
}
fun()
}


{
#line 1 "file2.R"
fun2 &lt;- function(n = 0) fun(n = n + 1)
list(fun = fun(), fun2 = fun2())
}


{
#line 1 "file3.R"
fun3 &lt;- function(n = 0) fun2(n = n + 1)
list(fun = fun(), fun2 = fun2(), fun3 = fun3())
}</pre>
<p>Within each file, all these functions will return the path in which they are
called, regardless of how deep <code>this.path()</code> is called.
</p>


<h3>Note</h3>

<p>If you need to use <code>this.path()</code> inside a user profile, please use
<code><a href="#topic+with_init.file">with_init.file</a>()</code>. i.e. instead of writing:
</p>
<pre>&lt;expr 1&gt;
&lt;expr 2&gt;
&lt;...&gt;</pre>
<p>write this: </p>
<pre>this.path::with_init.file({
&lt;expr 1&gt;
&lt;expr 2&gt;
&lt;...&gt;
})</pre>


<h3>See Also</h3>

<p><code><a href="#topic+shFILE">shFILE</a>()</code>
</p>
<p><code><a href="#topic+set.sys.path">set.sys.path</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FILE1.R &lt;- tempfile(fileext = ".R")
writeLines("writeLines(sQuote(this.path::this.path()))", FILE1.R)

## 'this.path()' works with 'source()'
source(FILE1.R)

## 'this.path()' works with 'sys.source()'
sys.source(FILE1.R, envir = environment())

## 'this.path()' works with 'debugSource()' in 'RStudio'
if (.Platform$GUI == "RStudio")
    get("debugSource", "tools:rstudio", inherits = FALSE)(FILE1.R)

## 'this.path()' works with 'testthat::source_file()'
if (requireNamespace("testthat"))
    testthat::source_file(FILE1.R, chdir = FALSE, wrap = FALSE)

## 'this.path()' works with 'compiler::loadcmp()'
if (requireNamespace("compiler")) {
    FILE2.Rc &lt;- tempfile(fileext = ".Rc")
    compiler::cmpfile(FILE1.R, FILE2.Rc)
    compiler::loadcmp(FILE2.Rc)
    unlink(FILE2.Rc)
}

## 'this.path()' works with 'Rscript'
this.path:::.Rscript(c("--default-packages=NULL", "--vanilla", FILE1.R))

## 'this.path()' also works when 'source()'-ing a URL
## (included tryCatch in case an internet connection is not available)
tryCatch({
    source(paste0("https://raw.githubusercontent.com/ArcadeAntics/",
                  "this.path/main/tests/sys-path-with-urls.R"))
}, condition = this.path:::.cat_condition)

unlink(FILE1.R)
</code></pre>

<hr>
<h2 id='this.path-defunct'>Defunct Functions in Package 'this.path'</h2><span id='topic+this.path-defunct'></span><span id='topic+this.path2'></span><span id='topic+this.dir2'></span><span id='topic+this.dir3'></span><span id='topic+normalized.shFILE'></span><span id='topic+as.rel.path'></span><span id='topic+as.relative.path'></span><span id='topic+local.path'></span><span id='topic+reset.this.proj'></span><span id='topic+set.this.path.jupyter'></span><span id='topic+inside.source'></span><span id='topic+set.this.path'></span><span id='topic+unset.this.path'></span><span id='topic+set.sys.path.jupyter'></span><span id='topic+fileArgs'></span>

<h3>Description</h3>

<p>The functions or variables listed here are no longer part of
<span class="pkg">this.path</span> as they are no longer needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Defunct in 1.1.0
this.path2(...)
this.dir2(...)
this.dir3(...)
normalized.shFILE(default, else.)

# Defunct in 1.3.0
as.rel.path(path)
as.relative.path(path)

# Defunct in 1.4.0
local.path(verbose = getOption("verbose"), original = FALSE,
    for.msg = FALSE, contents = FALSE, default, else.)

# Defunct in 2.0.0
reset.this.proj()
set.this.path.jupyter(...)
inside.source(file, path.only = FALSE, character.only = path.only,
    file.only = path.only, conv2utf8 = FALSE, allow.blank.string = FALSE,
    allow.clipboard = !file.only, allow.stdin = !file.only, allow.url = !file.only,
    allow.file.uri = !path.only, allow.unz = !path.only, allow.pipe = !file.only,
    allow.terminal = !file.only, allow.textConnection = !file.only,
    allow.rawConnection = !file.only, allow.sockconn = !file.only,
    allow.servsockconn = !file.only, allow.customConnection = !file.only,
    ignore.all = FALSE, ignore.blank.string = ignore.all, ignore.clipboard = ignore.all,
    ignore.stdin = ignore.all, ignore.url = ignore.all, ignore.file.uri = ignore.all,
    Function = NULL, ofile)
set.this.path(file, path.only = FALSE, character.only = path.only,
    file.only = path.only, conv2utf8 = FALSE, allow.blank.string = FALSE,
    allow.clipboard = !file.only, allow.stdin = !file.only, allow.url = !file.only,
    allow.file.uri = !path.only, allow.unz = !path.only, allow.pipe = !file.only,
    allow.terminal = !file.only, allow.textConnection = !file.only,
    allow.rawConnection = !file.only, allow.sockconn = !file.only,
    allow.servsockconn = !file.only, allow.customConnection = !file.only,
    ignore.all = FALSE, ignore.blank.string = ignore.all, ignore.clipboard = ignore.all,
    ignore.stdin = ignore.all, ignore.url = ignore.all, ignore.file.uri = ignore.all,
    Function = NULL, ofile)
unset.this.path()

# Defunct in 2.4.0
set.sys.path.jupyter(...)
fileArgs()
</code></pre>


<h3>Details</h3>

<p><code>this.path2()</code>, <code>this.dir2()</code>, and <code>this.dir3()</code> were used
before <code><a href="#topic+this.path">this.path</a>()</code> and <code><a href="#topic+this.dir">this.dir</a>()</code> were given an
argument <code>default</code>. Should be replaced by
<code><a href="#topic+this.path">this.path</a>(default = NULL)</code>,
<code><a href="#topic+this.dir">this.dir</a>(default = NULL)</code>, and
<code><a href="#topic+this.dir">this.dir</a>(default = <a href="base.html#topic+getwd">getwd</a>())</code>,
respectively.
</p>
<p><code>normalized.shFILE()</code> was used before <code><a href="#topic+shFILE">shFILE</a>()</code> was given
an argument <code>original</code>. Should be replaced by <code><a href="#topic+shFILE">shFILE</a>()</code>.
</p>
<p><code>as.rel.path()</code> and <code>as.relative.path()</code> were poorly chosen names
given their functionality. Should be replaced by <code><a href="#topic+rel2here">rel2here</a>()</code>.
</p>
<p><code>local.path()</code> was used when it called a different C function than
<code><a href="#topic+this.path">this.path</a>()</code>. Should be replaced by
<code><a href="#topic+this.path">this.path</a>(local = TRUE)</code>.
</p>
<p><code>reset.this.proj()</code> was used when <code><a href="#topic+this.proj">this.proj</a>()</code> was the only
project related function. Now that <code><a href="#topic+src.proj">src.proj</a>()</code>,
<code><a href="#topic+env.proj">env.proj</a>()</code>, and <code><a href="#topic+sys.proj">sys.proj</a>()</code> exist, the function
was renamed to <code><a href="#topic+reset.proj">reset.proj</a>()</code>.
</p>
<p>In <span class="pkg">this.path 2.0.0</span>, the original implementation of
<code><a href="#topic+this.path">this.path</a>()</code> was renamed to <code><a href="#topic+sys.path">sys.path</a>()</code>, so
<code>set.this.path.jupyter()</code>, <code>set.this.path()</code>, and
<code>unset.this.path()</code> were accordingly renamed to
<code><a href="#topic+set.jupyter.path">set.jupyter.path</a>()</code>, <code><a href="#topic+set.sys.path">set.sys.path</a>()</code>, and
<code><a href="#topic+unset.sys.path">unset.sys.path</a>()</code>. Since <code>set.this.path()</code> was already
being made defunct, <code>inside.source()</code> was also made defunct.
</p>
<p><code>set.sys.path.jupyter()</code> was renamed to
<code><a href="#topic+set.jupyter.path">set.jupyter.path</a>()</code>.
</p>
<p><code>fileArgs()</code> should be replaced by <code><a href="#topic+progArgs">progArgs</a>()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Defunct">Defunct</a></code>
</p>

<hr>
<h2 id='try.this.path'>Attempt to Determine Script's Filename</h2><span id='topic+try.this.path'></span><span id='topic+try.shFILE'></span>

<h3>Description</h3>

<p><code>try.this.path()</code> attempts to return <code><a href="#topic+this.path">this.path</a>()</code>,
returning <code>this.path(original = TRUE)</code> if that fails, returning
<code><a href="base.html#topic+NA">NA_character_</a></code> if that fails as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try.this.path(contents = FALSE, local = FALSE, n = 0,
              envir = parent.frame(n + 1),
              matchThisEnv = getOption("topLevelEnvironment"),
              srcfile = if (n) sys.parent(n) else 0)

try.shFILE()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="try.this.path_+3A_contents">contents</code>, <code id="try.this.path_+3A_local">local</code>, <code id="try.this.path_+3A_n">n</code>, <code id="try.this.path_+3A_envir">envir</code>, <code id="try.this.path_+3A_matchthisenv">matchThisEnv</code>, <code id="try.this.path_+3A_srcfile">srcfile</code></td>
<td>
<p>See
<code>?<a href="#topic+this.path">this.path</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This should <strong>NOT</strong> be used to construct file paths against the script's
directory. This should exclusively be used for diagnostic messages / /
warnings / / errors / / logging. The returned path may not exist, may be
relative instead of absolute, or may be undefined.
</p>


<h3>Value</h3>

<p>character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>try.shFILE()
try.this.path()
try.this.path(contents = TRUE)
</code></pre>

<hr>
<h2 id='tryCatch2'>Condition Handling and Recovery</h2><span id='topic+tryCatch2'></span><span id='topic+tryCatch3'></span><span id='topic+last.condition'></span>

<h3>Description</h3>

<p>Variants of <code><a href="base.html#topic+conditions">tryCatch</a>()</code> that accept an
<code>else.</code> argument, similar to <code>try except</code> in &lsquo;<a href="https://www.python.org/">Python</a>&rsquo;.
</p>
<p><code>last.condition</code> will be the last thrown and caught condition in
<code>tryCatch3()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryCatch2(expr, ..., else., finally)
tryCatch3(expr, ..., else., finally)

last.condition
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tryCatch2_+3A_expr">expr</code></td>
<td>
<p>expression to be evaluated.</p>
</td></tr>
<tr><td><code id="tryCatch2_+3A_...">...</code></td>
<td>
<p>for <code>tryCatch2()</code>, condition handlers. for
<code>tryCatch3()</code>, expressions to be conditionally evaluated.
</p>
<p>Arguments which are missing will use the next non-missing argument. If
there is no next non-missing argument, <code>NULL</code> will be returned
invisibly.</p>
</td></tr>
<tr><td><code id="tryCatch2_+3A_else.">else.</code></td>
<td>
<p>expression to be evaluated if evaluating <code>expr</code> does not
throw an error nor a condition is caught.</p>
</td></tr>
<tr><td><code id="tryCatch2_+3A_finally">finally</code></td>
<td>
<p>expression to be evaluated before returning or exiting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of the <code>else.</code> argument is better than adding additional code to
<code>expr</code> because it avoids accidentally catching a condition that was not
being protected by the <code>tryCatch()</code> call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FILES &lt;- tempfile(c("existent-file_", "non-existent-file_"))
writeLines("line1\nline2", FILES[[1L]])
for (FILE in FILES) {
    conn &lt;- file(FILE)
    tryCatch2({
        open(conn, "r")
    }, condition = function(cond) {
        cat("cannot open", FILE, "\n")
    }, else. = {
        cat(FILE, "has", length(readLines(conn)), "lines\n")
    }, finally = {
        close(conn)
    })
    # ## or more naturely with tryCatch3:
    # tryCatch3({
    #     open(conn, "r")
    # }, condition = {
    #     cat("cannot open", FILE, "\n")
    # }, else. = {
    #     cat(FILE, "has", length(readLines(conn)), "lines\n")
    # }, finally = {
    #     close(conn)
    # })
}
unlink(FILES)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
