<!DOCTYPE html><html><head><title>Help for package convoSPAT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {convoSPAT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Aniso_fit'><p>Fit the stationary spatial model</p></a></li>
<li><a href='#cov_spatial'><p>Calculate spatial covariance.</p></a></li>
<li><a href='#evaluate_CV'><p>Evaluation criteria</p></a></li>
<li><a href='#f_mc_kernels'><p>Calculate mixture component kernel matrices.</p></a></li>
<li><a href='#kernel_cov'><p>Calculate a kernel covariance matrix.</p></a></li>
<li><a href='#make_global_loglik1'><p>Constructor functions for global parameter estimation.</p></a></li>
<li><a href='#make_global_loglik1_kappa'><p>Constructor functions for global parameter estimation.</p></a></li>
<li><a href='#make_global_loglik2'><p>Constructor functions for global parameter estimation.</p></a></li>
<li><a href='#make_global_loglik2_kappa'><p>Constructor functions for global parameter estimation.</p></a></li>
<li><a href='#make_global_loglik3'><p>Constructor functions for global parameter estimation.</p></a></li>
<li><a href='#make_global_loglik3_kappa'><p>Constructor functions for global parameter estimation.</p></a></li>
<li><a href='#make_global_loglik4_kappa'><p>Constructor functions for global parameter estimation.</p></a></li>
<li><a href='#make_local_lik'><p>Constructor functions for local parameter estimation.</p></a></li>
<li><a href='#mc_N'><p>Calculate local sample sizes.</p></a></li>
<li><a href='#NSconvo_fit'><p>Fit the nonstationary spatial model</p></a></li>
<li><a href='#NSconvo_sim'><p>Simulate data from the nonstationary model.</p></a></li>
<li><a href='#plot.Aniso'><p>Plot of the estimated correlations from the stationary model.</p></a></li>
<li><a href='#plot.NSconvo'><p>Plot from the nonstationary model.</p></a></li>
<li><a href='#predict.Aniso'><p>Obtain predictions at unobserved locations for the stationary</p>
spatial model.</a></li>
<li><a href='#predict.NSconvo'><p>Obtain predictions at unobserved locations for the nonstationary</p>
spatial model.</a></li>
<li><a href='#simdata'><p>Simulated nonstationary dataset</p></a></li>
<li><a href='#summary.Aniso'><p>Summarize the stationary model fit.</p></a></li>
<li><a href='#summary.NSconvo'><p>Summarize the nonstationary model fit.</p></a></li>
<li><a href='#US.mc.grids'><p>Mixture component grids for the western United States</p></a></li>
<li><a href='#US.prediction.locs'><p>Prediction locations for the western United States</p></a></li>
<li><a href='#USprecip97'><p>Annual precipitation measurements from the western United States, 1997</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Convolution-Based Nonstationary Spatial Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-15</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits convolution-based nonstationary
    Gaussian process models to point-referenced spatial data. The nonstationary
    covariance function allows the user to specify the underlying correlation
    structure and which spatial dependence parameters should be allowed to
    vary over space: the anisotropy, nugget variance, and process variance.
    The parameters are estimated via maximum likelihood, using a local
    likelihood approach. Also provided are functions to fit stationary spatial
    models for comparison, calculate the Kriging predictor and standard errors,
    and create various plots to visualize nonstationarity.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, ellipse, fields, MASS, plotrix, StatMatch</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/markdrisser/convoSPAT">http://github.com/markdrisser/convoSPAT</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-15 17:41:56 UTC; MDRisser</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark D. Risser [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark D. Risser &lt;markdrisser@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-16 00:50:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='Aniso_fit'>Fit the stationary spatial model</h2><span id='topic+Aniso_fit'></span>

<h3>Description</h3>

<p><code>Aniso_fit</code> estimates the parameters of the stationary spatial model.
Required inputs are the observed data and locations.
Optional inputs include the covariance model (exponential is the default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aniso_fit(
  sp.SPDF = NULL,
  coords = NULL,
  data = NULL,
  cov.model = "exponential",
  mean.model = data ~ 1,
  fixed.nugg2.var = NULL,
  method = "reml",
  fix.tausq = FALSE,
  tausq = 0,
  fix.kappa = FALSE,
  kappa = 0.5,
  local.pars.LB = NULL,
  local.pars.UB = NULL,
  local.ini.pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Aniso_fit_+3A_sp.spdf">sp.SPDF</code></td>
<td>
<p>A &quot;<code>SpatialPointsDataFrame</code>&quot; object, which contains the
spatial coordinates and additional attribute variables corresponding to the
spatoal coordinates</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_coords">coords</code></td>
<td>
<p>An N x 2 matrix where each row has the two-dimensional
coordinates of the N data locations.</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_data">data</code></td>
<td>
<p>A vector or matrix with N rows, containing the data values.
Inputting a vector corresponds to a single replicate of data, while
inputting a matrix corresponds to replicates. In the case of replicates,
the model assumes the replicates are independent and identically
distributed.</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_cov.model">cov.model</code></td>
<td>
<p>A string specifying the model for the correlation
function; defaults to <code>"exponential"</code>.
Options available in this package are: &quot;<code>exponential</code>&quot;,
<code>"matern"</code>, or <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_mean.model">mean.model</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
specifying the mean model to be used. Defaults to an intercept only.</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_fixed.nugg2.var">fixed.nugg2.var</code></td>
<td>
<p>Optional; describes the variance/covariance for
a fixed (second) nugget term (represents a known error term). Either
a vector of length N containing a station-specific variances (implying
independent error) or an NxN covariance matrix (implying dependent error).
Defaults to zero.</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_method">method</code></td>
<td>
<p>Indicates the estimation method, either maximum likelihood
(<code>"ml"</code>) or restricted maximum likelihood (<code>"reml"</code>).</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_fix.tausq">fix.tausq</code></td>
<td>
<p>Logical; indicates whether the default nugget term
(tau^2) should be fixed (<code>TRUE</code>) or estimated (<code>FALSE</code>). Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_tausq">tausq</code></td>
<td>
<p>Scalar; fixed value for the nugget variance (when
<code>fix.tausq = TRUE</code>).</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_fix.kappa">fix.kappa</code></td>
<td>
<p>Logical; indicates if the kappa parameter should be
fixed (<code>TRUE</code>) or estimated (<code>FALSE</code>). Defaults to <code>FALSE</code>
(only valid for <code>cov.model = "matern"</code> and <code>cov.model = "cauchy"</code>).</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_kappa">kappa</code></td>
<td>
<p>Scalar; value of the kappa parameter. Only used if
<code>fix.kappa = TRUE</code>.</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_local.pars.lb">local.pars.LB</code>, <code id="Aniso_fit_+3A_local.pars.ub">local.pars.UB</code></td>
<td>
<p>Optional vectors of lower and upper
bounds, respectively, used by the <code>"L-BFGS-B"</code> method option in the
<code><a href="stats.html#topic+optim">optim</a></code> function for the local parameter estimation.
Each vector must be of length five,
containing values for lam1, lam2, tausq, sigmasq, and nu. Default for
<code>local.pars.LB</code> is <code>rep(1e-05,5)</code>; default for
<code>local.pars.UB</code> is <code>c(max.distance/2, max.distance/2, 4*resid.var, 4*resid.var, 100)</code>,
where <code>max.distance</code> is the maximum interpoint distance of the
observed data and <code>resid.var</code> is the residual variance from using
<code><a href="stats.html#topic+lm">lm</a></code> with <code>mean.model</code>.</p>
</td></tr>
<tr><td><code id="Aniso_fit_+3A_local.ini.pars">local.ini.pars</code></td>
<td>
<p>Optional vector of initial values used by the
<code>"L-BFGS-B"</code> method option in the <code><a href="stats.html#topic+optim">optim</a></code>
function for the local parameter estimation. The vector must be of length
five, containing values for lam1, lam2, tausq, sigmasq, and nu. Defaults
to <code>c(max.distance/10, max.distance/10, 0.1*resid.var, 0.9*resid.var, 1)</code>,
where <code>max.distance</code> is the maximum interpoint distance of the
observed data and <code>resid.var</code> is the residual variance from using
<code><a href="stats.html#topic+lm">lm</a></code> with <code>mean.model</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>MLEs.save</code></td>
<td>
<p>Table of local maximum likelihood estimates for each
mixture component location.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Observed data values.</p>
</td></tr>
<tr><td><code>beta.GLS</code></td>
<td>
<p>Vector of generalized least squares estimates of beta,
the mean coefficients.</p>
</td></tr>
<tr><td><code>beta.cov</code></td>
<td>
<p>Covariance matrix of the generalized least squares
estimate of beta.</p>
</td></tr>
<tr><td><code>Mean.coefs</code></td>
<td>
<p>&quot;Regression table&quot; for the mean coefficient estimates,
listing the estimate, standard error, and t-value.</p>
</td></tr>
<tr><td><code>Cov.mat</code></td>
<td>
<p>Estimated covariance matrix (<code>N.obs</code> x <code>N.obs</code>)
using all relevant parameter estimates.</p>
</td></tr>
<tr><td><code>Cov.mat.chol</code></td>
<td>
<p>Cholesky of <code>Cov.mat</code> (i.e., <code>chol(Cov.mat)</code>),
the estimated covariance matrix (<code>N.obs</code> x <code>N.obs</code>).</p>
</td></tr>
<tr><td><code>aniso.pars</code></td>
<td>
<p>Vector of MLEs for the anisotropy parameters lam1,
lam2, eta.</p>
</td></tr>
<tr><td><code>aniso.mat</code></td>
<td>
<p>2 x 2 anisotropy matrix, calculated from
<code>aniso.pars</code>.</p>
</td></tr>
<tr><td><code>tausq.est</code></td>
<td>
<p>Scalar maximum likelihood estimate of tausq (nugget
variance).</p>
</td></tr>
<tr><td><code>sigmasq.est</code></td>
<td>
<p>Scalar maximum likelihood estimate of sigmasq
(process variance).</p>
</td></tr>
<tr><td><code>kappa.MLE</code></td>
<td>
<p>Scalar maximum likelihood estimate for kappa (when
applicable).</p>
</td></tr>
<tr><td><code>fixed.nugg2.var</code></td>
<td>
<p>N x N matrix with the fixed
variance/covariance for the second (measurement error) nugget term (defaults
to zero).</p>
</td></tr>
<tr><td><code>cov.model</code></td>
<td>
<p>String; the correlation model used for estimation.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>N x 2 matrix of observation locations.</p>
</td></tr>
<tr><td><code>global.loglik</code></td>
<td>
<p>Scalar value of the maximized likelihood from the
global optimization (if available).</p>
</td></tr>
<tr><td><code>Xmat</code></td>
<td>
<p>Design matrix, obtained from using <code><a href="stats.html#topic+lm">lm</a></code>
with <code>mean.model</code>.</p>
</td></tr>
<tr><td><code>fix.kappa</code></td>
<td>
<p>Logical, indicating if kappa was fixed (<code>TRUE</code>) or
estimated (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Scalar; fixed value of kappa.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Using iid standard Gaussian data
aniso.fit &lt;- Aniso_fit( coords = cbind(runif(100), runif(100)),
data = rnorm(100) )

## End(Not run)

</code></pre>

<hr>
<h2 id='cov_spatial'>Calculate spatial covariance.</h2><span id='topic+cov_spatial'></span>

<h3>Description</h3>

<p>This function replaces the geoR function <code>cov.spatial</code>, which
is now defunct.
Options available in this package are: &quot;<code>exponential</code>&quot;,
<code>"matern"</code>, and <code>"gaussian"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_spatial(
  Dist.mat,
  cov.model = "exponential",
  cov.pars = c(1, 1),
  kappa = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_spatial_+3A_dist.mat">Dist.mat</code></td>
<td>
<p>A matrix of scaled distances.</p>
</td></tr>
<tr><td><code id="cov_spatial_+3A_cov.model">cov.model</code></td>
<td>
<p>A string specifying the model for the correlation
function; defaults to <code>"exponential"</code>.
Options available in this package are: &quot;<code>exponential</code>&quot;,
<code>"matern"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="cov_spatial_+3A_cov.pars">cov.pars</code></td>
<td>
<p>Fixed values; not used in the function.</p>
</td></tr>
<tr><td><code id="cov_spatial_+3A_kappa">kappa</code></td>
<td>
<p>Scalar; value of the smoothness parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Distmat &lt;- as.matrix(dist(matrix(runif(20), ncol = 2), diag = TRUE, upper = TRUE))
C &lt;- cov_spatial( Dist.mat = Distmat )

</code></pre>

<hr>
<h2 id='evaluate_CV'>Evaluation criteria</h2><span id='topic+evaluate_CV'></span>

<h3>Description</h3>

<p>Calculate three evaluation criteria &ndash; continuous rank probability score
(CRPS), prediction mean square deviation ratio (pMSDR), and mean squared prediction
error (MSPE) &ndash; comparing hold-out data and predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_CV(holdout.data, pred.mean, pred.SDs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_CV_+3A_holdout.data">holdout.data</code></td>
<td>
<p>Observed/true data that has been held out for model
comparison.</p>
</td></tr>
<tr><td><code id="evaluate_CV_+3A_pred.mean">pred.mean</code></td>
<td>
<p>Predicted mean values corresponding to the hold-out
locations.</p>
</td></tr>
<tr><td><code id="evaluate_CV_+3A_pred.sds">pred.SDs</code></td>
<td>
<p>Predicted standard errors corresponding to the hold-out
locations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>CRPS</code></td>
<td>
<p>The CRPS averaged over all hold-out locations.</p>
</td></tr>
<tr><td><code>MSPE</code></td>
<td>
<p>The mean squared prediction error.</p>
</td></tr>
<tr><td><code>pMSDR</code></td>
<td>
<p>The prediction mean square deviation ratio.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
evaluate_CV( holdout.data = simdata$sim.data[holdout.index],
pred.mean = pred.NS$pred.means, pred.SDs = pred.NS$pred.SDs )

## End(Not run)

</code></pre>

<hr>
<h2 id='f_mc_kernels'>Calculate mixture component kernel matrices.</h2><span id='topic+f_mc_kernels'></span>

<h3>Description</h3>

<p><code>f_mc_kernels</code> calculates spatially-varying mixture component kernels using
generalized linear models for each of the eigenvalues (lam1 and lam2) and
the angle of rotation (eta).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_mc_kernels(
  y.min = 0,
  y.max = 5,
  x.min = 0,
  x.max = 5,
  N.mc = 3^2,
  lam1.coef = c(-1.3, 0.5, -0.6),
  lam2.coef = c(-1.4, -0.1, 0.2),
  logit.eta.coef = c(0, -0.15, 0.15)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_mc_kernels_+3A_y.min">y.min</code></td>
<td>
<p>Lower bound for the y-coordinate axis.</p>
</td></tr>
<tr><td><code id="f_mc_kernels_+3A_y.max">y.max</code></td>
<td>
<p>Upper bound for the y-coordinate axis.</p>
</td></tr>
<tr><td><code id="f_mc_kernels_+3A_x.min">x.min</code></td>
<td>
<p>Lower bound for the y-coordinate axis.</p>
</td></tr>
<tr><td><code id="f_mc_kernels_+3A_x.max">x.max</code></td>
<td>
<p>Upper bound for the y-coordinate axis.</p>
</td></tr>
<tr><td><code id="f_mc_kernels_+3A_n.mc">N.mc</code></td>
<td>
<p>Number of mixture component locations.</p>
</td></tr>
<tr><td><code id="f_mc_kernels_+3A_lam1.coef">lam1.coef</code></td>
<td>
<p>Log-linear regression coefficients for lam1; the
coefficients correspond to the intercept, longitude, and latitude.</p>
</td></tr>
<tr><td><code id="f_mc_kernels_+3A_lam2.coef">lam2.coef</code></td>
<td>
<p>Log-linear regression coefficients for lam2; the
coefficients correspond to the intercept, longitude, and latitude.</p>
</td></tr>
<tr><td><code id="f_mc_kernels_+3A_logit.eta.coef">logit.eta.coef</code></td>
<td>
<p>Scaled logit regression coefficients for eta; the
coefficients correspond to the intercept, longitude, and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>mc.locations</code></td>
<td>
<p>A <code>N.mc</code> x 2 matrix of the mixture component
locations.</p>
</td></tr>
<tr><td><code>mc.kernels</code></td>
<td>
<p>A <code>N.mc</code> x 2 x 2 array of kernel matrices
corresponding to each of the mixture component locations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f_mc_kernels( y.min = 0, y.max = 5, x.min = 0,
x.max = 5, N.mc = 3^2, lam1.coef = c(-1.3, 0.5, -0.6),
lam2.coef = c(-1.4, -0.1, 0.2), logit.eta.coef = c(0, -0.15, 0.15) )


</code></pre>

<hr>
<h2 id='kernel_cov'>Calculate a kernel covariance matrix.</h2><span id='topic+kernel_cov'></span>

<h3>Description</h3>

<p><code>kernel_cov</code> calculates a 2 x 2 matrix based on the eigendecomposition
components (two eigenvalues and angle of rotation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_cov(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_cov_+3A_params">params</code></td>
<td>
<p>A vector of three parameters, corresponding to
(lam1, lam2, eta). The eigenvalues (lam1 and lam2) must be positive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2 x 2 kernel covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kernel_cov(c(1, 2, pi/3))

</code></pre>

<hr>
<h2 id='make_global_loglik1'>Constructor functions for global parameter estimation.</h2><span id='topic+make_global_loglik1'></span>

<h3>Description</h3>

<p>This function generates another function to be used within <code>optim</code> to
obtain maximum likelihood estimates of
global variance parameters tausq, sigmasq with a fixed correlation
matrix (smoothness is fixed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_global_loglik1(data, Xmat, Corr, nugg2.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_global_loglik1_+3A_data">data</code></td>
<td>
<p>A vector or matrix of data to use in the likelihood
calculation.</p>
</td></tr>
<tr><td><code id="make_global_loglik1_+3A_xmat">Xmat</code></td>
<td>
<p>The design matrix for the mean model.</p>
</td></tr>
<tr><td><code id="make_global_loglik1_+3A_corr">Corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code id="make_global_loglik1_+3A_nugg2.var">nugg2.var</code></td>
<td>
<p>Fixed values for the covariance of the second nugget term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns another function for use in <code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
make_global_loglik1( data, Xmat, Corr, nugg2.var )

## End(Not run)

</code></pre>

<hr>
<h2 id='make_global_loglik1_kappa'>Constructor functions for global parameter estimation.</h2><span id='topic+make_global_loglik1_kappa'></span>

<h3>Description</h3>

<p>This function generates another function to be used within <code>optim</code> to
obtain maximum likelihood estimates of
global variance parameters tausq, sigmasq, and nu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_global_loglik1_kappa(data, Xmat, cov.model, Scalemat, Distmat, nugg2.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_global_loglik1_kappa_+3A_data">data</code></td>
<td>
<p>A vector or matrix of data to use in the likelihood
calculation.</p>
</td></tr>
<tr><td><code id="make_global_loglik1_kappa_+3A_xmat">Xmat</code></td>
<td>
<p>The design matrix for the mean model.</p>
</td></tr>
<tr><td><code id="make_global_loglik1_kappa_+3A_cov.model">cov.model</code></td>
<td>
<p>String; the covariance model.</p>
</td></tr>
<tr><td><code id="make_global_loglik1_kappa_+3A_scalemat">Scalemat</code></td>
<td>
<p>Matrix; contains the scaling quantities from the
covariance function.</p>
</td></tr>
<tr><td><code id="make_global_loglik1_kappa_+3A_distmat">Distmat</code></td>
<td>
<p>Matrix; contains the scaled distances.</p>
</td></tr>
<tr><td><code id="make_global_loglik1_kappa_+3A_nugg2.var">nugg2.var</code></td>
<td>
<p>Fixed values for the covariance of the second nugget term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns another function for use in <code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
make_global_loglik1_kappa( data, Xmat, cov.model, Scalemat, Distmat, nugg2.var )

## End(Not run)

</code></pre>

<hr>
<h2 id='make_global_loglik2'>Constructor functions for global parameter estimation.</h2><span id='topic+make_global_loglik2'></span>

<h3>Description</h3>

<p>This function generates another function to be used within <code>optim</code> to
obtain maximum likelihood estimates of
global variance parameter sigmasq with a fixed correlation
matrix (smoothness is fixed). The nugget variance is taken
to be spatially-varing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_global_loglik2(data, Xmat, Corr, obs.nuggets, nugg2.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_global_loglik2_+3A_data">data</code></td>
<td>
<p>A vector or matrix of data to use in the likelihood
calculation.</p>
</td></tr>
<tr><td><code id="make_global_loglik2_+3A_xmat">Xmat</code></td>
<td>
<p>The design matrix for the mean model.</p>
</td></tr>
<tr><td><code id="make_global_loglik2_+3A_corr">Corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code id="make_global_loglik2_+3A_obs.nuggets">obs.nuggets</code></td>
<td>
<p>A vector containing the spatially-varying nuggets
corresponding to each data location.</p>
</td></tr>
<tr><td><code id="make_global_loglik2_+3A_nugg2.var">nugg2.var</code></td>
<td>
<p>Fixed values for the covariance of the second nugget term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns another function for use in <code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
make_global_loglik2( data, Xmat, Corr, obs.nuggets, nugg2.var )

## End(Not run)

</code></pre>

<hr>
<h2 id='make_global_loglik2_kappa'>Constructor functions for global parameter estimation.</h2><span id='topic+make_global_loglik2_kappa'></span>

<h3>Description</h3>

<p>This function generates another function to be used within <code>optim</code> to
obtain maximum likelihood estimates of
global variance parameters sigmasq and nu. The nugget variance is
taken to be spatially-varying.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_global_loglik2_kappa(
  data,
  Xmat,
  cov.model,
  Scalemat,
  Distmat,
  obs.nuggets,
  nugg2.var
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_global_loglik2_kappa_+3A_data">data</code></td>
<td>
<p>A vector or matrix of data to use in the likelihood
calculation.</p>
</td></tr>
<tr><td><code id="make_global_loglik2_kappa_+3A_xmat">Xmat</code></td>
<td>
<p>The design matrix for the mean model.</p>
</td></tr>
<tr><td><code id="make_global_loglik2_kappa_+3A_cov.model">cov.model</code></td>
<td>
<p>String; the covariance model.</p>
</td></tr>
<tr><td><code id="make_global_loglik2_kappa_+3A_scalemat">Scalemat</code></td>
<td>
<p>Matrix; contains the scaling quantities from the
covariance function.</p>
</td></tr>
<tr><td><code id="make_global_loglik2_kappa_+3A_distmat">Distmat</code></td>
<td>
<p>Matrix; contains the scaled distances.</p>
</td></tr>
<tr><td><code id="make_global_loglik2_kappa_+3A_obs.nuggets">obs.nuggets</code></td>
<td>
<p>A vector containing the spatially-varying nuggets
corresponding to each data location.</p>
</td></tr>
<tr><td><code id="make_global_loglik2_kappa_+3A_nugg2.var">nugg2.var</code></td>
<td>
<p>Fixed values for the covariance of the second nugget term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns another function for use in <code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
make_global_loglik2_kappa( data, Xmat, cov.model, Scalemat, Distmat, obs.nuggets, nugg2.var )

## End(Not run)

</code></pre>

<hr>
<h2 id='make_global_loglik3'>Constructor functions for global parameter estimation.</h2><span id='topic+make_global_loglik3'></span>

<h3>Description</h3>

<p>This function generates another function to be used within <code>optim</code> to
obtain maximum likelihood estimates of
global variance parameter tausq with a fixed correlation
matrix (smoothness is fixed). The process variance is taken
to be spatially-varing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_global_loglik3(data, Xmat, Corr, obs.variance, nugg2.var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_global_loglik3_+3A_data">data</code></td>
<td>
<p>A vector or matrix of data to use in the likelihood
calculation.</p>
</td></tr>
<tr><td><code id="make_global_loglik3_+3A_xmat">Xmat</code></td>
<td>
<p>The design matrix for the mean model.</p>
</td></tr>
<tr><td><code id="make_global_loglik3_+3A_corr">Corr</code></td>
<td>
<p>The correlation matrix matrix.</p>
</td></tr>
<tr><td><code id="make_global_loglik3_+3A_obs.variance">obs.variance</code></td>
<td>
<p>A vector containing the spatially-varying variance
corresponding to each data location.</p>
</td></tr>
<tr><td><code id="make_global_loglik3_+3A_nugg2.var">nugg2.var</code></td>
<td>
<p>Fixed values for the covariance of the second nugget term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns another function for use in <code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
make_global_loglik3( data, Xmat, Corr, obs.variance, nugg2.var )

## End(Not run)

</code></pre>

<hr>
<h2 id='make_global_loglik3_kappa'>Constructor functions for global parameter estimation.</h2><span id='topic+make_global_loglik3_kappa'></span>

<h3>Description</h3>

<p>This function generates another function to be used within <code>optim</code> to
obtain maximum likelihood estimates of
global variance parameters tausq and nu. The process variance is
taken to be spatially-varying.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_global_loglik3_kappa(
  data,
  Xmat,
  cov.model,
  Scalemat,
  Distmat,
  obs.variance,
  nugg2.var
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_global_loglik3_kappa_+3A_data">data</code></td>
<td>
<p>A vector or matrix of data to use in the likelihood
calculation.</p>
</td></tr>
<tr><td><code id="make_global_loglik3_kappa_+3A_xmat">Xmat</code></td>
<td>
<p>The design matrix for the mean model.</p>
</td></tr>
<tr><td><code id="make_global_loglik3_kappa_+3A_cov.model">cov.model</code></td>
<td>
<p>String; the covariance model.</p>
</td></tr>
<tr><td><code id="make_global_loglik3_kappa_+3A_scalemat">Scalemat</code></td>
<td>
<p>Matrix; contains the scaling quantities from the
covariance function.</p>
</td></tr>
<tr><td><code id="make_global_loglik3_kappa_+3A_distmat">Distmat</code></td>
<td>
<p>Matrix; contains the scaled distances.</p>
</td></tr>
<tr><td><code id="make_global_loglik3_kappa_+3A_obs.variance">obs.variance</code></td>
<td>
<p>A vector containing the spatially-varying variance
corresponding to each data location.</p>
</td></tr>
<tr><td><code id="make_global_loglik3_kappa_+3A_nugg2.var">nugg2.var</code></td>
<td>
<p>Fixed values for the covariance of the second nugget term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns another function for use in <code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
make_global_loglik3_kappa( data, Xmat, cov.model, Scalemat, Distmat, obs.variance, nugg2.var )

## End(Not run)

</code></pre>

<hr>
<h2 id='make_global_loglik4_kappa'>Constructor functions for global parameter estimation.</h2><span id='topic+make_global_loglik4_kappa'></span>

<h3>Description</h3>

<p>This function generates another function to be used within <code>optim</code> to
obtain maximum likelihood estimates of
global variance parameters nu. The process variance
and nugget variance are taken to be spatially-varying.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_global_loglik4_kappa(
  data,
  Xmat,
  cov.model,
  Scalemat,
  Distmat,
  obs.variance,
  obs.nuggets,
  nugg2.var
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_global_loglik4_kappa_+3A_data">data</code></td>
<td>
<p>A vector or matrix of data to use in the likelihood
calculation.</p>
</td></tr>
<tr><td><code id="make_global_loglik4_kappa_+3A_xmat">Xmat</code></td>
<td>
<p>The design matrix for the mean model.</p>
</td></tr>
<tr><td><code id="make_global_loglik4_kappa_+3A_cov.model">cov.model</code></td>
<td>
<p>String; the covariance model.</p>
</td></tr>
<tr><td><code id="make_global_loglik4_kappa_+3A_scalemat">Scalemat</code></td>
<td>
<p>Matrix; contains the scaling quantities from the
covariance function.</p>
</td></tr>
<tr><td><code id="make_global_loglik4_kappa_+3A_distmat">Distmat</code></td>
<td>
<p>Matrix; contains the scaled distances.</p>
</td></tr>
<tr><td><code id="make_global_loglik4_kappa_+3A_obs.variance">obs.variance</code></td>
<td>
<p>A vector containing the spatially-varying variance
corresponding to each data location.</p>
</td></tr>
<tr><td><code id="make_global_loglik4_kappa_+3A_obs.nuggets">obs.nuggets</code></td>
<td>
<p>A vector containing the spatially-varying nuggets
corresponding to each data location.</p>
</td></tr>
<tr><td><code id="make_global_loglik4_kappa_+3A_nugg2.var">nugg2.var</code></td>
<td>
<p>Fixed values for the covariance of the second nugget term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns another function for use in <code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
make_global_loglik4_kappa( data, Xmat, cov.model, Scalemat, Distmat,
obs.variance, obs.nuggets, nugg2.var )

## End(Not run)

</code></pre>

<hr>
<h2 id='make_local_lik'>Constructor functions for local parameter estimation.</h2><span id='topic+make_local_lik'></span>

<h3>Description</h3>

<p>This function generates another function to be used within <code>optim</code> to
obtain maximum likelihood estimates of covariance (and possibly mean) parameters.
The function includes options for
(1) maximum likelihood (<code>"ml"</code>) vs. restricted maximum likelihood
(<code>"reml"</code>),
(2) smoothness (<code>kappa</code>): models without smoothness vs. estimating the
smoothness vs. using fixed smoothness,
(3) locally isotropic vs. locally anisotropic, and
(4) fixed nugget variance (<code>tausq</code>): fixed vs. estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_local_lik(
  locations,
  cov.model,
  data,
  Xmat,
  nugg2.var = matrix(0, nrow(locations), nrow(locations)),
  tausq = 0,
  kappa = 0.5,
  fixed = rep(FALSE, 6),
  method = "reml",
  local.aniso = TRUE,
  fix.tausq = FALSE,
  fix.kappa = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_local_lik_+3A_locations">locations</code></td>
<td>
<p>A matrix of locations.</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_cov.model">cov.model</code></td>
<td>
<p>String; the covariance model.</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_data">data</code></td>
<td>
<p>A vector or matrix of data to use in the likelihood
calculation.</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_xmat">Xmat</code></td>
<td>
<p>The design matrix for the mean model.</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_nugg2.var">nugg2.var</code></td>
<td>
<p>Fixed values for the variance/covariance of the second nugget term; defaults
to a matrix of zeros.</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_tausq">tausq</code></td>
<td>
<p>Scalar; fixed value for the nugget variance (when
<code>fix.tausq = TRUE</code>).</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_kappa">kappa</code></td>
<td>
<p>Scalar; fixed value for the smoothness (when <code>fix.kappa = TRUE</code>).</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_fixed">fixed</code></td>
<td>
<p>Logical vector of <code>FALSE</code> values; length corresponds to the number
of parameters to be estimated.</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_method">method</code></td>
<td>
<p>Indicates the estimation method, either maximum likelihood (<code>"ml"</code>)
or restricted maximum likelihood (<code>"reml"</code>).</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_local.aniso">local.aniso</code></td>
<td>
<p>Logical; indicates if the local covariance should be
anisotropic (<code>TRUE</code>) or isotropic (<code>FALSE</code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_fix.tausq">fix.tausq</code></td>
<td>
<p>Logical; indicates whether the default nugget term
(tau^2) should be fixed (<code>TRUE</code>) or estimated (<code>FALSE</code>). Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="make_local_lik_+3A_fix.kappa">fix.kappa</code></td>
<td>
<p>Logical; indicates if the kappa parameter should be
fixed (<code>TRUE</code>) or estimated (<code>FALSE</code>). Defaults to <code>FALSE</code>
(only valid for <code>cov.model = "matern"</code> and <code>cov.model = "cauchy"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns another function for use in <code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
make_local_lik( locations, cov.model, data, Xmat )

## End(Not run)

</code></pre>

<hr>
<h2 id='mc_N'>Calculate local sample sizes.</h2><span id='topic+mc_N'></span>

<h3>Description</h3>

<p><code>mc_N</code> calculates the number of observations (sample size) that
fall within a certain fit radius for each mixture component location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_N(coords, mc.locations, fit.radius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_N_+3A_coords">coords</code></td>
<td>
<p>A matrix of observation locations.</p>
</td></tr>
<tr><td><code id="mc_N_+3A_mc.locations">mc.locations</code></td>
<td>
<p>A matrix of the mixture component locations to
use in the model fitting.</p>
</td></tr>
<tr><td><code id="mc_N_+3A_fit.radius">fit.radius</code></td>
<td>
<p>Scalar; defines the fitting radius for local likelihood
estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector <code>mc.N.fit</code>, which summarizes the number of
observation locations in <code>coords</code> that fall within the fit radius
for each mixture component location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mc_N( coords = simdata$sim.locations, mc.locations = simdata$mc.locations,
fit.radius = 1 )

## End(Not run)

</code></pre>

<hr>
<h2 id='NSconvo_fit'>Fit the nonstationary spatial model</h2><span id='topic+NSconvo_fit'></span>

<h3>Description</h3>

<p><code>NSconvo_fit</code> estimates the parameters of the nonstationary
convolution-based spatial model. Required inputs are the observed data and
locations. Optional inputs include mixture component locations (if not provided,
the number of mixture component locations are required), the fit radius,
the covariance model (exponential is the default), and whether or not the
nugget and process variance will be spatially-varying.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSconvo_fit(
  sp.SPDF = NULL,
  coords = NULL,
  data = NULL,
  cov.model = "exponential",
  mean.model = data ~ 1,
  mc.locations = NULL,
  N.mc = NULL,
  lambda.w = NULL,
  fixed.nugg2.var = NULL,
  mean.model.df = NULL,
  mc.kernels = NULL,
  fit.radius = NULL,
  ns.nugget = FALSE,
  ns.variance = FALSE,
  ns.mean = FALSE,
  local.aniso = TRUE,
  fix.tausq = FALSE,
  tausq = 0,
  fix.kappa = FALSE,
  kappa = 0.5,
  method = "reml",
  print.progress = TRUE,
  local.pars.LB = NULL,
  local.pars.UB = NULL,
  global.pars.LB = NULL,
  global.pars.UB = NULL,
  local.ini.pars = NULL,
  global.ini.pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NSconvo_fit_+3A_sp.spdf">sp.SPDF</code></td>
<td>
<p>A &quot;<code>SpatialPointsDataFrame</code>&quot; object, which contains the
spatial coordinates and additional attribute variables corresponding to the
spatoal coordinates</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_coords">coords</code></td>
<td>
<p>An N x 2 matrix where each row has the two-dimensional
coordinates of the N data locations.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_data">data</code></td>
<td>
<p>A vector or matrix with N rows, containing the data values.
Inputting a vector corresponds to a single replicate of data, while
inputting a matrix corresponds to replicates. In the case of replicates,
the model assumes the replicates are independent and identically
distributed.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_cov.model">cov.model</code></td>
<td>
<p>A string specifying the model for the correlation
function; defaults to <code>"exponential"</code>.
Options available in this package are: &quot;<code>exponential</code>&quot;,
<code>"matern"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_mean.model">mean.model</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
specifying the mean model to be used. Defaults to an intercept only.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_mc.locations">mc.locations</code></td>
<td>
<p>Optional; matrix of mixture component locations.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_n.mc">N.mc</code></td>
<td>
<p>Optional; if <code>mc.locations</code> is not specified, the
function will create a rectangular grid of size <code>N.mc</code> over the
spatial domain.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_lambda.w">lambda.w</code></td>
<td>
<p>Scalar; tuning parameter for the weight function.
Defaults to be the square of one-half of the minimum distance between
mixture component locations.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_fixed.nugg2.var">fixed.nugg2.var</code></td>
<td>
<p>Optional; describes the variance/covariance for
a fixed (second) nugget term (represents a known error term). Either
a vector of length N containing a station-specific variances (implying
independent error) or an NxN covariance matrix (implying dependent error).
Defaults to zero.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_mean.model.df">mean.model.df</code></td>
<td>
<p>Optional data frame; refers to the variables used
in <code>mean.model</code>. Important when using categorical variables in
<code>mean.model</code>, as a subset of the full design matrix will likely
be rank deficient. Specifying <code>mean.model.df</code> allows <code>NSconvo_fit</code>
to calculate a design matrix specific to the points used to fit each
local model.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_mc.kernels">mc.kernels</code></td>
<td>
<p>Optional specification of mixture component kernel
matrices (based on expert opinion, etc.).</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_fit.radius">fit.radius</code></td>
<td>
<p>Scalar; specifies the fit radius or neighborhood size
for the local likelihood estimation.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_ns.nugget">ns.nugget</code></td>
<td>
<p>Logical; indicates if the nugget variance (tausq) should
be spatially-varying (<code>TRUE</code>) or constant (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_ns.variance">ns.variance</code></td>
<td>
<p>Logical; indicates if the process variance (sigmasq)
should be spatially-varying (<code>TRUE</code>) or constant (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_ns.mean">ns.mean</code></td>
<td>
<p>Logical; indicates if the mean coefficeints (beta)
should be spatially-varying (<code>TRUE</code>) or constant (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_local.aniso">local.aniso</code></td>
<td>
<p>Logical; indicates if the local covariance should be
anisotropic (<code>TRUE</code>) or isotropic (<code>FALSE</code>). Defaults to <code>TRUE</code>.
In the case of a locally isotropic model, the bounds and initial values
for lam will default to the first element of <code>local.pars.LB</code>,
<code>local.pars.UB</code>, and <code>local.ini.pars</code> (while still required, the
second and third elements of these vectors will be ignored.)</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_fix.tausq">fix.tausq</code></td>
<td>
<p>Logical; indicates whether the default nugget term
(tau^2) should be fixed (<code>TRUE</code>) or estimated (<code>FALSE</code>). Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_tausq">tausq</code></td>
<td>
<p>Scalar; fixed value for the nugget variance (when
<code>fix.tausq = TRUE</code>).</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_fix.kappa">fix.kappa</code></td>
<td>
<p>Logical; indicates if the kappa parameter should be
fixed (<code>TRUE</code>) or estimated (<code>FALSE</code>). Defaults to <code>FALSE</code>
(only valid for <code>cov.model = "matern"</code> and <code>cov.model = "cauchy"</code>).</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_kappa">kappa</code></td>
<td>
<p>Scalar; value of the kappa parameter. Only used if
<code>fix.kappa = TRUE</code>.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_method">method</code></td>
<td>
<p>Indicates the estimation method, either maximum likelihood
(<code>"ml"</code>) or restricted maximum likelihood (<code>"reml"</code>).</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_print.progress">print.progress</code></td>
<td>
<p>Logical; if <code>TRUE</code>, text indicating the progress
of local model fitting in real time.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_local.pars.lb">local.pars.LB</code>, <code id="NSconvo_fit_+3A_local.pars.ub">local.pars.UB</code></td>
<td>
<p>Optional vectors of lower and upper
bounds, respectively, used by the <code>"L-BFGS-B"</code> method option in the
<code><a href="stats.html#topic+optim">optim</a></code> function for the local parameter estimation.
Each vector must be of length five,
containing values for lam1, lam2, tausq, sigmasq, and nu. Default for
<code>local.pars.LB</code> is <code>rep(1e-05,5)</code>; default for
<code>local.pars.UB</code> is <code>c(max.distance/2, max.distance/2, 4*resid.var, 4*resid.var, 100)</code>,
where <code>max.distance</code> is the maximum interpoint distance of the
observed data and <code>resid.var</code> is the residual variance from using
<code><a href="stats.html#topic+lm">lm</a></code> with <code>mean.model</code>.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_global.pars.lb">global.pars.LB</code>, <code id="NSconvo_fit_+3A_global.pars.ub">global.pars.UB</code></td>
<td>
<p>Optional vectors of lower and upper
bounds, respectively, used by the <code>"L-BFGS-B"</code> method option in the
<code><a href="stats.html#topic+optim">optim</a></code> function for the global parameter estimation.
Each vector must be of length three,
containing values for tausq, sigmasq, and nu. Default for
<code>global.pars.LB</code> is <code>rep(1e-05,3)</code>; default for
<code>global.pars.UB</code> is <code>c(4*resid.var, 4*resid.var, 100)</code>,
where <code>resid.var</code> is the residual variance from using
<code><a href="stats.html#topic+lm">lm</a></code> with <code>mean.model</code>.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_local.ini.pars">local.ini.pars</code></td>
<td>
<p>Optional vector of initial values used by the
<code>"L-BFGS-B"</code> method option in the <code><a href="stats.html#topic+optim">optim</a></code>
function for the local parameter estimation. The vector must be of length
five, containing values for lam1, lam2, tausq, sigmasq, and nu. Defaults
to <code>c(max.distance/10, max.distance/10, 0.1*resid.var, 0.9*resid.var, 1)</code>,
where <code>max.distance</code> is the maximum interpoint distance of the
observed data and <code>resid.var</code> is the residual variance from using
<code><a href="stats.html#topic+lm">lm</a></code> with <code>mean.model</code>.</p>
</td></tr>
<tr><td><code id="NSconvo_fit_+3A_global.ini.pars">global.ini.pars</code></td>
<td>
<p>Optional vector of initial values used by the
<code>"L-BFGS-B"</code> method option in the <code><a href="stats.html#topic+optim">optim</a></code>
function for the global parameter estimation. The vector must be of length
three, containing values for tausq, sigmasq, and nu. Defaults to
<code>c(0.1*resid.var, 0.9*resid.var, 1)</code>, where <code>resid.var</code> is the
residual variance from using <code><a href="stats.html#topic+lm">lm</a></code> with <code>mean.model</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;NSconvo&quot; object, with the following components:
</p>
<table>
<tr><td><code>mc.locations</code></td>
<td>
<p>Mixture component locations used for the simulated
data.</p>
</td></tr>
<tr><td><code>mc.kernels</code></td>
<td>
<p>Mixture component kernel matrices used for the simulated
data.</p>
</td></tr>
<tr><td><code>MLEs.save</code></td>
<td>
<p>Table of local maximum likelihood estimates for each
mixture component location.</p>
</td></tr>
<tr><td><code>kernel.ellipses</code></td>
<td>
<p><code>N.obs</code> x 2 x 2 array, containing the kernel
matrices corresponding to each of the simulated values.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Observed data values.</p>
</td></tr>
<tr><td><code>beta.GLS</code></td>
<td>
<p>Generalized least squares estimates of beta,
the mean coefficients. For <code>ns.mean = FALSE</code>, this is a vector
(containing the global mean coefficients); for <code>ns.mean = TRUE</code>,
this is a matrix (one column for each mixture component location).</p>
</td></tr>
<tr><td><code>beta.cov</code></td>
<td>
<p>Covariance matrix of the generalized least squares
estimate of beta. For <code>ns.mean = FALSE</code>, this is a matrix
(containing the covariance of theglobal mean coefficients); for
<code>ns.mean = TRUE</code>, this is an array (one matrix for each mixture
component location).</p>
</td></tr>
<tr><td><code>Mean.coefs</code></td>
<td>
<p>&quot;Regression table&quot; for the mean coefficient estimates,
listing the estimate, standard error, and t-value (for <code>ns.mean =
FALSE</code> only).</p>
</td></tr>
<tr><td><code>tausq.est</code></td>
<td>
<p>Estimate of tausq (nugget variance), either scalar (when
<code>ns.nugget = "FALSE"</code>) or a vector of length N (when
<code>ns.nugget = "TRUE"</code>), which contains the estimated nugget variance
for each observation location.</p>
</td></tr>
<tr><td><code>sigmasq.est</code></td>
<td>
<p>Estimate of sigmasq (process variance), either scalar
(when <code>ns.variance = "FALSE"</code>) or a vector of length N (when
<code>ns.variance = "TRUE"</code>), which contains the estimated process
variance for each observation location.</p>
</td></tr>
<tr><td><code>beta.est</code></td>
<td>
<p>Estimate of beta (mean coefficients), either a vector
(when <code>ns.mean = "FALSE"</code>) or a matrix with N rows (when
<code>ns.mean = "TRUE"</code>), each row of which contains the estimated
(smoothed) mean coefficients for each observation location.</p>
</td></tr>
<tr><td><code>kappa.MLE</code></td>
<td>
<p>Scalar maximum likelihood estimate for kappa (when
applicable).</p>
</td></tr>
<tr><td><code>Cov.mat</code></td>
<td>
<p>Estimated covariance matrix (<code>N.obs</code> x <code>N.obs</code>)
using all relevant parameter estimates.</p>
</td></tr>
<tr><td><code>Cov.mat.chol</code></td>
<td>
<p>Cholesky of <code>Cov.mat</code> (i.e., <code>chol(Cov.mat)</code>),
the estimated covariance matrix (<code>N.obs</code> x <code>N.obs</code>).</p>
</td></tr>
<tr><td><code>cov.model</code></td>
<td>
<p>String; the correlation model used for estimation.</p>
</td></tr>
<tr><td><code>ns.nugget</code></td>
<td>
<p>Logical, indicating if the nugget variance was estimated
as spatially-varing (<code>TRUE</code>) or constant (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>ns.variance</code></td>
<td>
<p>Logical, indicating if the process variance was
estimated as spatially-varying (<code>TRUE</code>) or constant (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>fixed.nugg2.var</code></td>
<td>
<p>N x N matrix with the fixed
variance/covariance for the second (measurement error) nugget term (defaults
to zero).</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>N x 2 matrix of observation locations.</p>
</td></tr>
<tr><td><code>global.loglik</code></td>
<td>
<p>Scalar value of the maximized likelihood from the
global optimization (if available).</p>
</td></tr>
<tr><td><code>Xmat</code></td>
<td>
<p>Design matrix, obtained from using <code><a href="stats.html#topic+lm">lm</a></code>
with <code>mean.model</code>.</p>
</td></tr>
<tr><td><code>lambda.w</code></td>
<td>
<p>Tuning parameter for the weight function.</p>
</td></tr>
<tr><td><code>fix.kappa</code></td>
<td>
<p>Logical, indicating if kappa was fixed (<code>TRUE</code>) or
estimated (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Scalar; fixed value of kappa.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Using white noise data
fit.model &lt;- NSconvo_fit( coords = cbind( runif(100), runif(100)),
data = rnorm(100), fit.radius = 0.4, N.mc = 4 )

## End(Not run)

</code></pre>

<hr>
<h2 id='NSconvo_sim'>Simulate data from the nonstationary model.</h2><span id='topic+NSconvo_sim'></span>

<h3>Description</h3>

<p><code>NSconvo_sim</code> simulates data from the nonstationary model, given
mixture component kernel matrices. The function requires either a mixture
component kernel object, from the function f.mc.kernels(), or a direct
specification of the mixture component locations and mixture component
kernels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSconvo_sim(
  grid = TRUE,
  y.min = 0,
  y.max = 5,
  x.min = 0,
  x.max = 5,
  N.obs = 20^2,
  sim.locations = NULL,
  mc.kernels.obj = NULL,
  mc.kernels = NULL,
  mc.locations = NULL,
  lambda.w = NULL,
  tausq = 0.1,
  sigmasq = 1,
  beta.coefs = 4,
  kappa = NULL,
  covariates = rep(1, N.obs),
  cov.model = "exponential"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NSconvo_sim_+3A_grid">grid</code></td>
<td>
<p>Logical; indicates of the simulated data should fall on a
grid (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_y.min">y.min</code></td>
<td>
<p>Lower bound for the y-coordinate axis.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_y.max">y.max</code></td>
<td>
<p>Upper bound for the y-coordinate axis.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_x.min">x.min</code></td>
<td>
<p>Lower bound for the y-coordinate axis.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_x.max">x.max</code></td>
<td>
<p>Upper bound for the y-coordinate axis.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_n.obs">N.obs</code></td>
<td>
<p>Number of simulated data values.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_sim.locations">sim.locations</code></td>
<td>
<p>Optional <code>N.obs</code> x 2 matrix; allows the user
to specify the locations of the simulated data.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_mc.kernels.obj">mc.kernels.obj</code></td>
<td>
<p>Object from the <code><a href="#topic+f_mc_kernels">f_mc_kernels</a></code> function.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_mc.kernels">mc.kernels</code></td>
<td>
<p>Optional specification of mixture component kernel
matrices.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_mc.locations">mc.locations</code></td>
<td>
<p>Optional specification of mixture component locations.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_lambda.w">lambda.w</code></td>
<td>
<p>Scalar; tuning parameter for the weight function.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_tausq">tausq</code></td>
<td>
<p>Scalar; true nugget variance.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_sigmasq">sigmasq</code></td>
<td>
<p>Scalar; true process variance.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_beta.coefs">beta.coefs</code></td>
<td>
<p>Vector of true regression coefficients. Length must
match the number of columns in <code>covariates</code>.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_kappa">kappa</code></td>
<td>
<p>Scalar; true smoothness.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_covariates">covariates</code></td>
<td>
<p>Matrix with <code>N.obs</code> rows, corresponding to
covariate information for each of the simualted values.</p>
</td></tr>
<tr><td><code id="NSconvo_sim_+3A_cov.model">cov.model</code></td>
<td>
<p>A string specifying the model for the correlation
function; defaults to <code>"exponential"</code>.
Options available in this package are: &quot;<code>exponential</code>&quot;,
<code>"matern"</code>, and <code>"gaussian"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>sim.locations</code></td>
<td>
<p>Matrix of locations for the simulated values.</p>
</td></tr>
<tr><td><code>mc.locations</code></td>
<td>
<p>Mixture component locations used for the simulated
data.</p>
</td></tr>
<tr><td><code>mc.kernels</code></td>
<td>
<p>Mixture component kernel matrices used for the simulated
data.</p>
</td></tr>
<tr><td><code>kernel.ellipses</code></td>
<td>
<p><code>N.obs</code> x 2 x 2 array, containing the kernel
matrices corresponding to each of the simulated values.</p>
</td></tr>
<tr><td><code>Cov.mat</code></td>
<td>
<p>True covariance matrix (<code>N.obs</code> x <code>N.obs</code>)
corresponding to the simulated data.</p>
</td></tr>
<tr><td><code>sim.data</code></td>
<td>
<p>Simulated data values.</p>
</td></tr>
<tr><td><code>lambda.w</code></td>
<td>
<p>Tuning parameter for the weight function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
NSconvo_sim( grid = TRUE, y.min = 0, y.max = 5, x.min = 0,
x.max = 5, N.obs = 20^2, sim.locations = NULL, mc.kernels.obj = NULL,
mc.kernels = NULL, mc.locations = NULL, lambda.w = NULL,
tausq = 0.1, sigmasq = 1, beta.coefs = 4, kappa = NULL,
covariates = rep(1,N.obs), cov.model = "exponential" )

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.Aniso'>Plot of the estimated correlations from the stationary model.</h2><span id='topic+plot.Aniso'></span>

<h3>Description</h3>

<p>This function plots the estimated correlation between a reference
point and all other prediction locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Aniso'
plot(x, ref.loc = NULL, all.pred.locs = NULL, grid = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Aniso_+3A_x">x</code></td>
<td>
<p>An &quot;Aniso&quot; object, from Aniso_fit().</p>
</td></tr>
<tr><td><code id="plot.Aniso_+3A_ref.loc">ref.loc</code></td>
<td>
<p>Vector of length 2; the reference location.</p>
</td></tr>
<tr><td><code id="plot.Aniso_+3A_all.pred.locs">all.pred.locs</code></td>
<td>
<p>A matrix of all prediction locations.</p>
</td></tr>
<tr><td><code id="plot.Aniso_+3A_grid">grid</code></td>
<td>
<p>Logical; indicates if the <code>all.pred.locs</code>
are on a rectangular grid (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.Aniso_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>plot</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of either the estimated ellipses or estimated
correlation is printed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot.Aniso( Aniso.object )

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.NSconvo'>Plot from the nonstationary model.</h2><span id='topic+plot.NSconvo'></span>

<h3>Description</h3>

<p>This function plots either the estimated anisotropy ellipses for each
of the mixture component locations or the estimated correlation
between a reference point and all other prediction locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NSconvo'
plot(
  x,
  plot.ellipses = TRUE,
  fit.radius = NULL,
  aniso.mat = NULL,
  true.mc = NULL,
  ref.loc = NULL,
  all.pred.locs = NULL,
  grid = TRUE,
  true.col = 1,
  aniso.col = 4,
  ns.col = 2,
  plot.mc.locs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NSconvo_+3A_x">x</code></td>
<td>
<p>A &quot;NSconvo&quot; object, from NSconvo_fit().</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_plot.ellipses">plot.ellipses</code></td>
<td>
<p>Logical; indicates whether the estimated
ellipses should be plotted (<code>TRUE</code>) or estiamted correlations
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_fit.radius">fit.radius</code></td>
<td>
<p>Scalar; defines the fit radius used for the local
likelihood estimation.</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_aniso.mat">aniso.mat</code></td>
<td>
<p>2 x 2 matrix; contains the estimated anisotropy
ellipse from the stationary model (for comparison).</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_true.mc">true.mc</code></td>
<td>
<p>The true mixture component ellipses, if known.</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_ref.loc">ref.loc</code></td>
<td>
<p>Vector of length 2; the reference location.</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_all.pred.locs">all.pred.locs</code></td>
<td>
<p>A matrix of all prediction locations.</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_grid">grid</code></td>
<td>
<p>Logical; indicates if the <code>all.pred.locs</code>
are on a rectangular grid (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_true.col">true.col</code></td>
<td>
<p>Color value for the true mixture component ellipses
(if plotted).</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_aniso.col">aniso.col</code></td>
<td>
<p>Color value for the anisotropy ellipse (if
plotted).</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_ns.col">ns.col</code></td>
<td>
<p>Color value for the mixture component ellipses.</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_plot.mc.locs">plot.mc.locs</code></td>
<td>
<p>Logical; indicates whether the mixture
component locations should be plotted (<code>TRUE</code>) or not
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.NSconvo_+3A_...">...</code></td>
<td>
<p>Other options passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of either the estimated ellipses or estimated
correlation is printed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot.NSconvo( NSconvo.object )

## End(Not run)

</code></pre>

<hr>
<h2 id='predict.Aniso'>Obtain predictions at unobserved locations for the stationary
spatial model.</h2><span id='topic+predict.Aniso'></span>

<h3>Description</h3>

<p><code>predict.Aniso</code> calculates the kriging predictor and corresponding
standard errors at unmonitored sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Aniso'
predict(
  object,
  pred.coords,
  pred.covariates = NULL,
  pred.fixed.nugg2.var = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.Aniso_+3A_object">object</code></td>
<td>
<p>An &quot;Aniso&quot; object, from <code>Aniso_fit</code>.</p>
</td></tr>
<tr><td><code id="predict.Aniso_+3A_pred.coords">pred.coords</code></td>
<td>
<p>Matrix of locations where predictions are required.</p>
</td></tr>
<tr><td><code id="predict.Aniso_+3A_pred.covariates">pred.covariates</code></td>
<td>
<p>Matrix of covariates for the prediction locations,
NOT including an intercept. The number of columns for this matrix must
match the design matrix from <code>mean.model</code> in <code><a href="#topic+NSconvo_fit">NSconvo_fit</a></code>.
Defaults to an intercept only.</p>
</td></tr>
<tr><td><code id="predict.Aniso_+3A_pred.fixed.nugg2.var">pred.fixed.nugg2.var</code></td>
<td>
<p>An optional vector or matrix describing the
the variance/covariance a fixed second nugget term (corresponds to
<code>fixed.nugg2.var</code> in <code>Aniso_fit</code>; often useful if conducting
prediction for held-out data). Defaults to zero.</p>
</td></tr>
<tr><td><code id="predict.Aniso_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>pred.means</code></td>
<td>
<p>Vector of the kriging predictor, for each location in
<code>pred.coords</code>.</p>
</td></tr>
<tr><td><code>pred.SDs</code></td>
<td>
<p>Vector of the kriging standard errors, for each location
in <code>pred.coords</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pred.S &lt;- predict( Aniso.obj,
pred.coords = cbind(runif(300),runif(300)) )

## End(Not run)

</code></pre>

<hr>
<h2 id='predict.NSconvo'>Obtain predictions at unobserved locations for the nonstationary
spatial model.</h2><span id='topic+predict.NSconvo'></span>

<h3>Description</h3>

<p><code>predict.NSconvo</code> calculates the kriging predictor and corresponding
standard errors at unmonitored sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NSconvo'
predict(
  object,
  pred.coords,
  pred.covariates = NULL,
  pred.fixed.nugg2.var = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.NSconvo_+3A_object">object</code></td>
<td>
<p>A &quot;NSconvo&quot; object, from <code>NSconvo_fit</code>.</p>
</td></tr>
<tr><td><code id="predict.NSconvo_+3A_pred.coords">pred.coords</code></td>
<td>
<p>Matrix of locations where predictions are required.</p>
</td></tr>
<tr><td><code id="predict.NSconvo_+3A_pred.covariates">pred.covariates</code></td>
<td>
<p>Matrix of covariates for the prediction locations,
NOT including an intercept. The number of columns for this matrix must
match the design matrix from <code>mean.model</code> in <code><a href="#topic+NSconvo_fit">NSconvo_fit</a></code>.
Defaults to an intercept only.</p>
</td></tr>
<tr><td><code id="predict.NSconvo_+3A_pred.fixed.nugg2.var">pred.fixed.nugg2.var</code></td>
<td>
<p>An optional vector or matrix describing the
the variance/covariance a fixed second nugget term (corresponds to
<code>fixed.nugg2.var</code> in <code>NSconvo_fit</code>; often useful if conducting
prediction for held-out data). Defaults to zero.</p>
</td></tr>
<tr><td><code id="predict.NSconvo_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>pred.means</code></td>
<td>
<p>Vector of the kriging predictor, for each location in
<code>pred.coords</code>.</p>
</td></tr>
<tr><td><code>pred.SDs</code></td>
<td>
<p>Vector of the kriging standard errors, for each location
in <code>pred.coords</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pred.NS &lt;- predict( NSconvo.obj,
pred.coords = matrix(c(1,1), ncol=2),
pred.covariates = matrix(c(1,1), ncol=2) )

## End(Not run)

</code></pre>

<hr>
<h2 id='simdata'>Simulated nonstationary dataset</h2><span id='topic+simdata'></span>

<h3>Description</h3>

<p>A data set containing the necessary components to fit the nonstationary
spatial model, simulated from the true model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdata
</code></pre>


<h3>Format</h3>

<p>A list with the following objects:
</p>

<dl>
<dt>sim.locations</dt><dd><p>A matrix of longitude/latitude coordinates of the
simulated locations.</p>
</dd>
<dt>mc.locations</dt><dd><p>A matrix of longitude/latitude coordinates of the
mixture component locations.</p>
</dd>
<dt>mc.kernel</dt><dd><p>A three-dimensional array, containing the true 2 x 2
kernel covariance matrices for each mixture component location.</p>
</dd>
<dt>kernel.ellipses</dt><dd><p>A three-dimensional array, containing the true 2 x 2
kernel covariance matrices for each simulated location.</p>
</dd>
<dt>sim.data</dt><dd><p>A matrix of the simulated data; each of the ten columns
correspond to an independent and identically distribured replicate.</p>
</dd>
<dt>lambda.w</dt><dd><p>Scalar; the value of the tuning parameter used in the
weight function.</p>
</dd>
<dt>holdout.index</dt><dd><p>Vector; indicates which of the simulated locations
should be used in the hold-out sample.</p>
</dd>
</dl>


<hr>
<h2 id='summary.Aniso'>Summarize the stationary model fit.</h2><span id='topic+summary.Aniso'></span>

<h3>Description</h3>

<p><code>summary.Aniso</code> prints relevant output from the model fitting
procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Aniso'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Aniso_+3A_object">object</code></td>
<td>
<p>An &quot;Aniso&quot; object, from <code>Aniso_fit</code>.</p>
</td></tr>
<tr><td><code id="summary.Aniso_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text containing the model fitting results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summary.Aniso( Aniso.object )

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.NSconvo'>Summarize the nonstationary model fit.</h2><span id='topic+summary.NSconvo'></span>

<h3>Description</h3>

<p><code>summary.NSconvo</code> prints relevant output from the model fitting
procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NSconvo'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.NSconvo_+3A_object">object</code></td>
<td>
<p>A &quot;NSconvo&quot; object, from <code>NSconvo_fit</code>.</p>
</td></tr>
<tr><td><code id="summary.NSconvo_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text containing the model fitting results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summary.NSconvo( NSconvo.object )

## End(Not run)

</code></pre>

<hr>
<h2 id='US.mc.grids'>Mixture component grids for the western United States</h2><span id='topic+US.mc.grids'></span>

<h3>Description</h3>

<p>A list of two mixture component grids for fitting the nonstationary
model to the western United States precipitation data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>US.mc.grids
</code></pre>


<h3>Format</h3>

<p>A list with two elements:
</p>

<dl>
<dt>Element 1</dt><dd><p>Coarse mixture component grid.</p>
</dd>
<dt>Element 2</dt><dd><p>Fine mixture component grid.</p>
</dd>
</dl>


<hr>
<h2 id='US.prediction.locs'>Prediction locations for the western United States</h2><span id='topic+US.prediction.locs'></span>

<h3>Description</h3>

<p>A matrix with two columns containing a fine grid of locations for
which to make a filled-in prediction map for the western United States.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>US.prediction.locs
</code></pre>


<h3>Format</h3>

<p>A matrix with two columns:
</p>

<dl>
<dt>Column 1</dt><dd><p>Longitude of the prediction grid.</p>
</dd>
<dt>Column 2</dt><dd><p>Latitude of the prediction grid.</p>
</dd>
</dl>


<hr>
<h2 id='USprecip97'>Annual precipitation measurements from the western United States, 1997</h2><span id='topic+USprecip97'></span>

<h3>Description</h3>

<p>A data set containing the annual precipitation for 1270 locations
in the western United States.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USprecip97
</code></pre>


<h3>Format</h3>

<p>A data frame with the following variables:
</p>

<dl>
<dt>longitude</dt><dd><p>Longitude of the monitoring site.</p>
</dd>
<dt>latitude</dt><dd><p>Latitude of the monitoring site.</p>
</dd>
<dt>annual.ppt</dt><dd><p>Annual precipitation for the monitoring site, in
millimeters.</p>
</dd>
<dt>log.annual.ppt</dt><dd><p>Annual precipitation for the monitoring site, in
log millimeters.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.image.ucar.edu/GSP/Data/US.monthly.met/">http://www.image.ucar.edu/GSP/Data/US.monthly.met/</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
