<!DOCTYPE html><html lang="en"><head><title>Help for package dnr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dnr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beach'><p>Dynamically changing network of inter personal communication among the visitors of a beach in southern California.</p></a></li>
<li><a href='#binaryPlot'><p>binaryPlot</p></a></li>
<li><a href='#clustCoef'><p>clustCoef</p></a></li>
<li><a href='#dnr'><p>dnr: A package for simulating dynamic networks using ERGM family models.</p></a></li>
<li><a href='#engineEdge'><p>Implementation of simulation engine for dynamic networks using smoothing estimates of change statistics.</p></a></li>
<li><a href='#engineEdgeBayes'><p>Implementation of simulation engine for dynamic networks using smoothing estimates of change statistics.</p></a></li>
<li><a href='#engineEdgeNS'><p>Implementation of simulation engine for dynamic networks without using smoothing estimates of change statistics.</p></a></li>
<li><a href='#engineVertex'><p>Simulation Engine for dynamic Vertex case.</p></a></li>
<li><a href='#engineVertexNS'><p>Simulation Engine for dynamic Vertex case without smoothing of estimated predictor matrices.</p></a></li>
<li><a href='#expdeg'><p>expdeg</p></a></li>
<li><a href='#ntriangles'><p>ntriangles</p></a></li>
<li><a href='#paramEdge'><p>Parameter estimation for static vertex case.</p></a></li>
<li><a href='#paramVertex'><p>Parameter estimation for Vertex dynamics</p></a></li>
<li><a href='#paramVertexOnly'><p>Parameter estimation for Vertex model only for a list of dynamic networks.</p></a></li>
<li><a href='#paramVertexOnlyGroup'><p>Parameter estimation for Vertex model only for a list of dynamic networks.</p></a></li>
<li><a href='#rdNets'><p>Blog citation network</p></a></li>
<li><a href='#regEngine'><p>General purpose regression engine for the methods bayesglm, glm and glmnet</p></a></li>
<li><a href='#vdegree'><p>vdegree</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simulate Dynamic Networks using Exponential Random Graph Models
(ERGM) Family</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions are provided to fit temporal lag models to dynamic
    networks. The models are build on top of exponential random graph models (ERGM) framework. There are
    functions for simulating or forecasting networks for future time points.
    Abhirup Mallik &amp; Zack W. Almquist (2019) Stable Multiple Time Step Simulation/Prediction From Lagged Dynamic Network Regression Models, Journal of Computational and Graphical Statistics, 28:4, 967-979, &lt;<a href="https://doi.org/10.1080%2F10618600.2019.1594834">doi:10.1080/10618600.2019.1594834</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), network, ergm</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>sna, igraph, arm, glmnet</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-30 16:40:08 UTC; avi</td>
</tr>
<tr>
<td>Author:</td>
<td>Abhirup Mallik [aut, cre],
  Zack Almquist [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Abhirup Mallik &lt;abhirupkgp@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-30 17:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='beach'>Dynamically changing network of inter personal communication among the visitors of a beach in southern California.</h2><span id='topic+beach'></span>

<h3>Description</h3>

<p>A data set containing the dynamic network of inter personal interactions among the visitors of a beach in southern California.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beach
</code></pre>


<h3>Format</h3>

<p>A list with 31 elements, each element represent one observation in time. Each element is a network of varying size.
</p>


<h3>Source</h3>

<p>Almquist, Z. W. and C. T. Butts (2014b). Logistic network regression for scalable analysis of networks with joint edge/ vertex dynamics. Sociological Methodology 44 (1), 1-33.
</p>

<hr>
<h2 id='binaryPlot'>binaryPlot</h2><span id='topic+binaryPlot'></span>

<h3>Description</h3>

<p>Plot for binary matrices, especially adjacency matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binaryPlot(x, axlabs = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binaryPlot_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="binaryPlot_+3A_axlabs">axlabs</code></td>
<td>
<p>Binary, should the axis labels be shown.</p>
</td></tr>
<tr><td><code id="binaryPlot_+3A_...">...</code></td>
<td>
<p>title, xlabs, ylabs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>binaryPlot
</p>

<hr>
<h2 id='clustCoef'>clustCoef</h2><span id='topic+clustCoef'></span>

<h3>Description</h3>

<p>Calculates the cluster coefficient from a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustCoef(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustCoef_+3A_x">x</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a network in the form of adjacency matrix, this calculates the cluster
coefficient. For a definition of cluster coefficient, please refer to
the igraph documentation.
</p>


<h3>Value</h3>

<p>scaler
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clustCoef(beach[[1]][, ])
</code></pre>

<hr>
<h2 id='dnr'>dnr: A package for simulating dynamic networks using ERGM family models.</h2><span id='topic+dnr'></span>

<h3>Description</h3>

<p>This package provides functions for fitting lagged exponential family models on dynamic network data, simulation from the models and model diagnostics. <br />
</p>


<h3>note</h3>

<p>This package was developed with help from ARO YIP award \#W911NF-14-1-0577. <br />
</p>


<h3>references</h3>

<p>Abhirup Mallik &amp; Zack W. Almquist (2019) Stable Multiple Time Step Simulation/Prediction From Lagged Dynamic Network Regression Models, Journal of Computational and Graphical Statistics, 28:4, 967-979, &lt;DOI: 10.1080/10618600.2019.1594834&gt;. <br />
Abhirup Mallik and Zack W. Almquist (2017). &quot;An R Package for Dynamic Network Regression.&quot; Working paper. University of Minnesota. <br />
Zack W. Almquist and Carter T. Butts (forthcoming). &quot;Dynamic Network Analysis with Missing Data: Theory and Methods.&quot; Statistica Sinica. &lt;doi:10.5705/ss.202016.0108&gt;. <br />
Zack W. Almquist and Carter T. Butts. (2013). &quot;Dynamic Network Logistic Regression: A Logistic Choice Analysis of Inter- and Intra-group Blog Citation Dynamics in the 2004 US Presidential Election.&quot; Political Analysis, 21(4), 430-448. <br />
Zack W. Almquist and Carter T. Butts. (2014). &quot;Bayesian Analysis of Dynamic Network Regression with Joint Edge/Vertex Dynamics.&quot; In Bayesian Inference in the Social Sciences. Ed. by I. Jeliazkov and X.-S. Yang. Hoboken, New Jersey: John Wiley &amp; Sons. <br />
</p>

<hr>
<h2 id='engineEdge'>Implementation of simulation engine for dynamic networks using smoothing estimates of change statistics.</h2><span id='topic+engineEdge'></span>

<h3>Description</h3>

<p>Implementation of simulation engine for dynamic networks using smoothing estimates of change statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engineEdge(
  start_network,
  inputcoeff,
  ns,
  model.terms,
  model.formula,
  graph_mode,
  group,
  intercept,
  exvar,
  maxlag,
  lagmat,
  ylag,
  lambda = NA,
  method = "bayesglm",
  alpha.glmnet,
  paramout = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engineEdge_+3A_start_network">start_network</code></td>
<td>
<p>Initial list of networks</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_inputcoeff">inputcoeff</code></td>
<td>
<p>coefficient vector</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_ns">ns</code></td>
<td>
<p>number of time points for simulation</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_model.terms">model.terms</code></td>
<td>
<p>model terms in formula</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_model.formula">model.formula</code></td>
<td>
<p>model formula (ergm)</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_graph_mode">graph_mode</code></td>
<td>
<p>'digraph' by default</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_group">group</code></td>
<td>
<p>group terms</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_intercept">intercept</code></td>
<td>
<p>intercept terms</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_exvar">exvar</code></td>
<td>
<p>extraneous covariates</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_maxlag">maxlag</code></td>
<td>
<p>maximum lag</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_lagmat">lagmat</code></td>
<td>
<p>lag matrix</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_ylag">ylag</code></td>
<td>
<p>lag vector for network lag terms</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_lambda">lambda</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_method">method</code></td>
<td>
<p>'bayesglm' by default</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_alpha.glmnet">alpha.glmnet</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="engineEdge_+3A_paramout">paramout</code></td>
<td>
<p>T/F parameter estimation is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list:
out_network: list of predicted networks
coefmat: if paramout is TRUE, matrix of coefficients at all time.
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
input_network=rdNets[1:6];
model.terms=c("triadcensus.003", "triadcensus.012", "triadcensus.102", "triadcensus.021D", "gwesp");
model.formula = net~triadcensus(0:3)+gwesp(decay = 0, fixed=FALSE, cutoff=30)-1;
graph_mode='digraph';
group='dnc';
alpha.glmnet=1
directed=TRUE;
method &lt;- 'bayesglm'
maxlag &lt;- 3
lambda=NA
intercept = c("edges")
cdim &lt;- length(model.terms)
lagmat &lt;- matrix(sample(c(0,1),(maxlag+1)*cdim,replace = TRUE),ncol = cdim)
ylag &lt;- rep(1,maxlag)
lagmat[1,] &lt;- rep(0,ncol(lagmat))
out &lt;- paramEdge(input_network,model.terms, model.formula,
                graph_mode="digraph",group,intercept = c("edges"),exvar=NA,
                maxlag = 3,
                lagmat = lagmat,
                ylag = rep(1,maxlag),
                lambda = NA, method='bayesglm',
                alpha.glmnet=1)
#
start_network &lt;- input_network
inputcoeff &lt;- out$coef$coef
nvertex &lt;- 47
ns &lt;- 10
exvar &lt;- NA
tmp &lt;- suppressWarnings(engineEdge(start_network=start_network,inputcoeff=inputcoeff,ns=ns,
                     model.terms=model.terms, model.formula=model.formula,
                     graph_mode=graph_mode,group=group,intercept=intercept,
                     exvar=exvar,
                     maxlag=maxlag,
                     lagmat=lagmat,
                     ylag=ylag,
                     lambda = NA, method='bayesglm',
                     alpha.glmnet=alpha.glmnet))
## End(Not run)

</code></pre>

<hr>
<h2 id='engineEdgeBayes'>Implementation of simulation engine for dynamic networks using smoothing estimates of change statistics.</h2><span id='topic+engineEdgeBayes'></span>

<h3>Description</h3>

<p>Implementation of simulation engine for dynamic networks using smoothing estimates of change statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engineEdgeBayes(
  start_network,
  inputcoeff,
  ns,
  model.terms,
  model.formula,
  graph_mode,
  group,
  intercept,
  exvar,
  maxlag,
  lagmat,
  ylag,
  lambda = NA,
  method = "bayesglm",
  alpha.glmnet,
  paramout = TRUE,
  Theta = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engineEdgeBayes_+3A_start_network">start_network</code></td>
<td>
<p>Initial list of networks</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_inputcoeff">inputcoeff</code></td>
<td>
<p>coefficient vector</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_ns">ns</code></td>
<td>
<p>number of time points for simulation</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_model.terms">model.terms</code></td>
<td>
<p>model terms in formula</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_model.formula">model.formula</code></td>
<td>
<p>model formula (ergm)</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_graph_mode">graph_mode</code></td>
<td>
<p>'digraph' by default</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_group">group</code></td>
<td>
<p>group terms</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_intercept">intercept</code></td>
<td>
<p>intercept terms</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_exvar">exvar</code></td>
<td>
<p>extraneous covariates</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_maxlag">maxlag</code></td>
<td>
<p>maximum lag</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_lagmat">lagmat</code></td>
<td>
<p>lag matrix</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_ylag">ylag</code></td>
<td>
<p>lag vector for network lag terms</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_lambda">lambda</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_method">method</code></td>
<td>
<p>'bayesglm' by default</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_alpha.glmnet">alpha.glmnet</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_paramout">paramout</code></td>
<td>
<p>T/F parameter estimation is returned.</p>
</td></tr>
<tr><td><code id="engineEdgeBayes_+3A_theta">Theta</code></td>
<td>
<p>= prior probability matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
startNet &lt;- rdNets[1:50]
model.terms=c("triadcensus.003", "triadcensus.012", "triadcensus.102", "triadcensus.021D", "gwesp")
model.formula = net~triadcensus(0:3)+gwesp(alpha=0, fixed=FALSE, cutoff=30)-1
graph_mode &lt;- 'digraph'
group &lt;- 'dnc'
alpha.glmnet &lt;- 1
method &lt;- 'bayesglm'
maxlag &lt;- 3
lambda &lt;- NA
intercept &lt;- "edges"
cdim &lt;- length(model.terms)
lagmat &lt;- matrix(sample(c(0,1),(maxlag+1)*cdim,replace = TRUE),ncol = cdim)
ylag &lt;- rep(1,maxlag)
lagmat[1,] &lt;- rep(0,ncol(lagmat))

out.coef &lt;- paramEdge(input_network = startNet,
                model.terms = model.terms,
                model.formula = model.formula,
                graph_mode='digraph',
                group=group,intercept = intercept,
                exvar=NA,
                maxlag = maxlag,
                lagmat = lagmat,
                ylag = ylag,
                lambda = NA, method='bayesglm',
                alpha.glmnet=1)


inputcoeff &lt;- out.coef$coef$coef.edge
nvertex &lt;- 47 ##find vertex here
ns &lt;- 1
exvar &lt;- NA
for(i in seq_along(startNet)) Theta &lt;- Theta + startNet[[i]][,]
Theta &lt;- Theta/length(startNet)
Theta &lt;- thresh(Theta)
out.bayes &lt;- engineEdgeBayes(start_network=startNet,
inputcoeff=inputcoeff,
ns=ns,
model.terms=model.terms,
model.formula=model.formula,
graph_mode=graph_mode,
group=group,intercept=intercept,
exvar=exvar,
maxlag=maxlag,
lagmat=lagmat,
ylag=ylag,
lambda = NA, method='bayesglm',
alpha.glmnet=alpha.glmnet,
Theta = Theta)

## End(Not run)
</code></pre>

<hr>
<h2 id='engineEdgeNS'>Implementation of simulation engine for dynamic networks without using smoothing estimates of change statistics.</h2><span id='topic+engineEdgeNS'></span>

<h3>Description</h3>

<p>Implementation of simulation engine for dynamic networks without using smoothing estimates of change statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engineEdgeNS(
  start_network,
  inputcoeff,
  ns,
  model.terms,
  model.formula,
  graph_mode,
  group,
  intercept,
  exvar,
  maxlag,
  lagmat,
  ylag,
  lambda = NA,
  method = "bayesglm",
  alpha.glmnet,
  paramout = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engineEdgeNS_+3A_start_network">start_network</code></td>
<td>
<p>Initial list of networks</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_inputcoeff">inputcoeff</code></td>
<td>
<p>coefficient vector</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_ns">ns</code></td>
<td>
<p>number of time points for simulation</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_model.terms">model.terms</code></td>
<td>
<p>model terms in formula</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_model.formula">model.formula</code></td>
<td>
<p>model formula (ergm)</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_graph_mode">graph_mode</code></td>
<td>
<p>'digraph' by default</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_group">group</code></td>
<td>
<p>group terms</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_intercept">intercept</code></td>
<td>
<p>intercept terms</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_exvar">exvar</code></td>
<td>
<p>extraneous covariates</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_maxlag">maxlag</code></td>
<td>
<p>maximum lag</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_lagmat">lagmat</code></td>
<td>
<p>lag matrix</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_ylag">ylag</code></td>
<td>
<p>lag vector for network lag terms</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_lambda">lambda</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_method">method</code></td>
<td>
<p>'bayesglm' by default</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_alpha.glmnet">alpha.glmnet</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="engineEdgeNS_+3A_paramout">paramout</code></td>
<td>
<p>T/F parameter estimation is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list:
out_network: list of predicted networks
coefmat: if paramout is TRUE, matrix of coefficients at all time.
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
input_network=rdNets[1:6];
model.terms=c("triadcensus.003", "triadcensus.012", "triadcensus.102", "triadcensus.021D", "gwesp");
model.formula = net~triadcensus(0:3)+gwesp(decay=0, fixed=FALSE, cutoff=30)-1;
graph_mode='digraph';
group='dnc';
alpha.glmnet=1
directed=TRUE;
method &lt;- 'bayesglm'
maxlag &lt;- 3
lambda=NA
intercept = c("edges")
cdim &lt;- length(model.terms)
lagmat &lt;- matrix(sample(c(0,1),(maxlag+1)*cdim,replace = TRUE),ncol = cdim)
ylag &lt;- rep(1,maxlag)
lagmat[1,] &lt;- rep(0,ncol(lagmat))
out &lt;- paramEdge(input_network,model.terms, model.formula,
                graph_mode="digraph",group,intercept = c("edges"),exvar=NA,
                maxlag = 3,
                lagmat = lagmat,
                ylag = rep(1,maxlag),
                lambda = NA, method='bayesglm',
                alpha.glmnet=1)
#
start_network &lt;- input_network
inputcoeff &lt;- out$coef$coef
nvertex &lt;- 47
ns &lt;- 10
exvar &lt;- NA
tmp &lt;- suppressWarnings(engineEdgeNS(start_network=start_network,
                     inputcoeff=inputcoeff,ns=ns,
                     model.terms=model.terms, model.formula=model.formula,
                     graph_mode=graph_mode,group=group,intercept=intercept,
                     exvar=exvar,
                     maxlag=maxlag,
                     lagmat=lagmat,
                     ylag=ylag,
                     lambda = NA, method='bayesglm',
                     alpha.glmnet=alpha.glmnet))
## End(Not run)

</code></pre>

<hr>
<h2 id='engineVertex'>Simulation Engine for dynamic Vertex case.</h2><span id='topic+engineVertex'></span>

<h3>Description</h3>

<p>Simulation engine for dynamic networks with variable number of vertices. 
Implements exponential family based hierarchical model for vertices and the edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engineVertex(
  InputNetwork,
  numSim,
  maxLag,
  VertexStatsvec = rep(1, nvertexstats),
  VertexLag = rep(1, maxLag),
  VertexLagMatrix = matrix(1, maxLag, length(VertexStatsvec)),
  VertexModelGroup = NA,
  VertexAttLag = rep(1, maxLag),
  dayClassObserved = NA,
  dayClassFuture = NA,
  EdgeModelTerms,
  EdgeModelFormula,
  EdgeGroup = NA,
  EdgeIntercept = c("edges"),
  EdgeNetparam = NA,
  EdgeExvar = NA,
  EdgeLag = rep(1, maxLag),
  EdgeLagMatrix = matrix(1, maxLag, length(EdgeModelTerms)),
  regMethod = "bayesglm",
  paramout = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engineVertex_+3A_inputnetwork">InputNetwork</code></td>
<td>
<p>List of input networks</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_numsim">numSim</code></td>
<td>
<p>number of time points to simulate</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_maxlag">maxLag</code></td>
<td>
<p>maximum Lag</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_vertexstatsvec">VertexStatsvec</code></td>
<td>
<p>Binary vector for vertex model.</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_vertexlag">VertexLag</code></td>
<td>
<p>vector of lag for vertex</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_vertexlagmatrix">VertexLagMatrix</code></td>
<td>
<p>matrix of lags for vertex stats.</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_vertexmodelgroup">VertexModelGroup</code></td>
<td>
<p>Group term for vertex model.</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_vertexattlag">VertexAttLag</code></td>
<td>
<p>Lag vector for group term for vertex.</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_dayclassobserved">dayClassObserved</code></td>
<td>
<p>Observed day class.</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_dayclassfuture">dayClassFuture</code></td>
<td>
<p>Dayclass vector for future, must be of size numsim.</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_edgemodelterms">EdgeModelTerms</code></td>
<td>
<p>Edge Model terms</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_edgemodelformula">EdgeModelFormula</code></td>
<td>
<p>Edge model formula</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_edgegroup">EdgeGroup</code></td>
<td>
<p>edge group term</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_edgeintercept">EdgeIntercept</code></td>
<td>
<p>edge intercept</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_edgenetparam">EdgeNetparam</code></td>
<td>
<p>edge network parameter name</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_edgeexvar">EdgeExvar</code></td>
<td>
<p>edge extraneous variable</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_edgelag">EdgeLag</code></td>
<td>
<p>edge Lag vector</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_edgelagmatrix">EdgeLagMatrix</code></td>
<td>
<p>edge lag matrix</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_regmethod">regMethod</code></td>
<td>
<p>regression method. &quot;bayesglm&quot; by default</p>
</td></tr>
<tr><td><code id="engineVertex_+3A_paramout">paramout</code></td>
<td>
<p>T/F on if regression needs to run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with following elements:
SimNetwork: Output Networks
EdgeParameterMat: Matrix of edge parameter
VertexParameterMat: Matrix of Vertex parameters.
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nvertexstats &lt;- 9
maxLag = 3
VertexLag = rep(1, maxLag)
VertexLagMatrix &lt;- matrix(0, maxLag, nvertexstats)
VertexLagMatrix[, c(4, 7)] &lt;- 1
VertexLagMatrix[c(2,3),7] &lt;- 0

getWeekend &lt;- function(z){
    weekends &lt;- c("Saturday", "Sunday")
    if(!network::is.network(z)){
        if(is.na(z)) return(NA)
    } else {
         zDay &lt;- get.network.attribute(z, attrname = "day")
         out &lt;- ifelse(zDay %in% weekends, 1, 0)
         return(out)   
    }
}

dayClass &lt;- numeric(length(beach))
for(i in seq_along(dayClass)) {
    dayClass[i] &lt;- getWeekend(beach[[i]])
}
dayClass &lt;- na.omit(dayClass)
simResult &lt;- suppressWarnings(engineVertex(InputNetwork = beach,
                          numSim = 5,
                          maxLag = 3,
                          VertexStatsvec = rep(1, nvertexstats),
                          VertexModelGroup = "regular",
                          VertexAttLag = rep(1, maxLag),
                          VertexLag = rep(1, maxLag),
                          VertexLagMatrix = VertexLagMatrix,
                          dayClassObserved = dayClass,
                          dayClassFuture = c(1, 0, 0, 0, 0),
                          EdgeModelTerms = NA,
                          EdgeModelFormula = NA,
                          EdgeGroup = NA,
                          EdgeIntercept = c("edges"),
                          EdgeNetparam = c("logSize"),
                          EdgeExvar = NA,
                          EdgeLag = c(0, 1, 0),
                          paramout = TRUE
                          ))
## End(Not run)

</code></pre>

<hr>
<h2 id='engineVertexNS'>Simulation Engine for dynamic Vertex case without smoothing of estimated predictor matrices.</h2><span id='topic+engineVertexNS'></span>

<h3>Description</h3>

<p>Simulation engine for dynamic networks with variable number of vertices. 
Implements exponential family based hierarchical model for vertices and the edges. This does not 
implement smoothing for estimated predictor matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engineVertexNS(
  InputNetwork,
  numSim,
  maxLag,
  VertexStatsvec = rep(1, nvertexstats),
  VertexLag = rep(1, maxLag),
  VertexLagMatrix = matrix(1, maxLag, length(VertexStatsvec)),
  VertexModelGroup = NA,
  VertexAttLag = rep(1, maxLag),
  dayClassObserved = NA,
  dayClassFuture = NA,
  EdgeModelTerms,
  EdgeModelFormula,
  EdgeGroup = NA,
  EdgeIntercept = c("edges"),
  EdgeNetparam = NA,
  EdgeExvar = NA,
  EdgeLag = rep(1, maxLag),
  EdgeLagMatrix = matrix(1, maxLag, length(EdgeModelTerms)),
  regMethod = "bayesglm",
  paramout = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engineVertexNS_+3A_inputnetwork">InputNetwork</code></td>
<td>
<p>List of input networks</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_numsim">numSim</code></td>
<td>
<p>number of time points to simulate</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_maxlag">maxLag</code></td>
<td>
<p>maximum Lag</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_vertexstatsvec">VertexStatsvec</code></td>
<td>
<p>Binary vector for vertex model.</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_vertexlag">VertexLag</code></td>
<td>
<p>vector of lag for vertex</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_vertexlagmatrix">VertexLagMatrix</code></td>
<td>
<p>matrix of lags for vertex stats.</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_vertexmodelgroup">VertexModelGroup</code></td>
<td>
<p>Group term for vertex model.</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_vertexattlag">VertexAttLag</code></td>
<td>
<p>Lag vector for group term for vertex.</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_dayclassobserved">dayClassObserved</code></td>
<td>
<p>Observed day class.</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_dayclassfuture">dayClassFuture</code></td>
<td>
<p>Dayclass vector for future, must be of size numsim.</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_edgemodelterms">EdgeModelTerms</code></td>
<td>
<p>Edge Model terms</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_edgemodelformula">EdgeModelFormula</code></td>
<td>
<p>Edge model formula</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_edgegroup">EdgeGroup</code></td>
<td>
<p>edge group term</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_edgeintercept">EdgeIntercept</code></td>
<td>
<p>edge intercept</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_edgenetparam">EdgeNetparam</code></td>
<td>
<p>edge network parameter name</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_edgeexvar">EdgeExvar</code></td>
<td>
<p>edge extraneous variable</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_edgelag">EdgeLag</code></td>
<td>
<p>edge Lag vector</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_edgelagmatrix">EdgeLagMatrix</code></td>
<td>
<p>edge lag matrix</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_regmethod">regMethod</code></td>
<td>
<p>regression method. &quot;bayesglm&quot; by default</p>
</td></tr>
<tr><td><code id="engineVertexNS_+3A_paramout">paramout</code></td>
<td>
<p>T/F on if regression needs to run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with following elements:
SimNetwork: Output Networks <br />
EdgeParameterMat: Matrix of edge parameter <br />
VertexParameterMat: Matrix of Vertex parameters. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nvertexstats &lt;- 9
maxLag &lt;- 3
VertexLag &lt;- rep(1, maxLag)
VertexLagMatrix &lt;- matrix(0, maxLag, nvertexstats)
VertexLagMatrix[, c(4, 7)] &lt;- 1
VertexLagMatrix[c(2, 3), ] &lt;- 1
simResult &lt;- suppressWarnings(engineVertexNS(InputNetwork = beach,
                          numSim = 5,
                          maxLag = 3,
                          VertexStatsvec = rep(1, nvertexstats),
                          VertexModelGroup = "regular",
                          VertexAttLag = rep(1, maxLag),
                          VertexLag = rep(1, maxLag),
                          VertexLagMatrix = VertexLagMatrix,
                          EdgeModelTerms = NA,
                          EdgeModelFormula = NA,
                          EdgeGroup = NA,
                          EdgeIntercept = c("edges")
                          ))
## End(Not run)
</code></pre>

<hr>
<h2 id='expdeg'>expdeg</h2><span id='topic+expdeg'></span>

<h3>Description</h3>

<p>Calculate the expectation of degree distribution of network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expdeg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expdeg_+3A_x">x</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a network in adjacency matrix form, this calculates the expected
degree statistic using igraph degree distribution function.
</p>


<h3>Value</h3>

<p>scaler
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expdeg(beach[[1]][, ])
</code></pre>

<hr>
<h2 id='ntriangles'>ntriangles</h2><span id='topic+ntriangles'></span>

<h3>Description</h3>

<p>Calculate number of triangles of a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ntriangles(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ntriangles_+3A_x">x</code></td>
<td>
<p>square matrix (adjacency matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the number of triangles in a network given an
adjacency matrix. We use igraph for this.
</p>


<h3>Value</h3>

<p>scaler, number of triangles
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ntriangles(beach[[1]][, ])
</code></pre>

<hr>
<h2 id='paramEdge'>Parameter estimation for static vertex case.</h2><span id='topic+paramEdge'></span>

<h3>Description</h3>

<p>Parameter estimation for the static vertex case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramEdge(
  input_network,
  model.terms,
  model.formula,
  graph_mode = "digraph",
  group,
  intercept = c("edges"),
  exvar = NA,
  maxlag = 3,
  lagmat = matrix(sample(c(0, 1), (maxlag + 1) * length(model.terms), replace = T),
    ncol = length(model.terms)),
  ylag = rep(1, maxlag),
  lambda = NA,
  method = "glmnet",
  alpha.glmnet = 1,
  paramout = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paramEdge_+3A_input_network">input_network</code></td>
<td>
<p>Input network.</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_model.terms">model.terms</code></td>
<td>
<p>model terms, must be ERGM terms expanded.</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_model.formula">model.formula</code></td>
<td>
<p>ERGM formula for each time point.</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_graph_mode">graph_mode</code></td>
<td>
<p>'digraph' by default for bidirectional.</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_group">group</code></td>
<td>
<p>grouping covariates for vertices.</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_intercept">intercept</code></td>
<td>
<p>intercept terms.</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_exvar">exvar</code></td>
<td>
<p>Extraneous variables</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_maxlag">maxlag</code></td>
<td>
<p>maximum lag.</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_lagmat">lagmat</code></td>
<td>
<p>Matrix of dimension (maxlag+1)x(length(model.terms))</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_ylag">ylag</code></td>
<td>
<p>lag vectors of length=maxlag.</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_lambda">lambda</code></td>
<td>
<p>NA</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_method">method</code></td>
<td>
<p>Regression method, default is 'bayesglm'</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_alpha.glmnet">alpha.glmnet</code></td>
<td>
<p>if regularization is used. not needed for bayesglm.</p>
</td></tr>
<tr><td><code id="paramEdge_+3A_paramout">paramout</code></td>
<td>
<p>TRUE by default. if parameters are needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements:
coef: coefficients
mplematfull: full matrix of change statistics
mplemat: subset of matrix of change statistics
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
input_network=rdNets[1:6]
model.terms=c("triadcensus.003", "triadcensus.012", "triadcensus.102", "triadcensus.021D", "gwesp");
model.formula = net~triadcensus(0:3)+gwesp(decay=0, fixed=FALSE, cutoff=30)-1;
graph_mode='digraph';
group='dnc';
alpha.glmnet=1
directed=TRUE;
method &lt;- 'bayesglm'
maxlag &lt;- 3
lambda=NA
intercept = c("edges")
cdim &lt;- length(model.terms)
lagmat &lt;- matrix(sample(c(0,1),(maxlag+1)*cdim,replace = TRUE),ncol = cdim)
ylag &lt;- rep(1,maxlag)
exvar &lt;- NA
out &lt;- paramEdge(input_network,model.terms, model.formula,
                graph_mode='digraph',group,intercept = c("edges"),exvar=NA,
                maxlag = 3,
                lagmat = matrix(sample(c(0,1),(maxlag+1)*cdim,
                                       replace = TRUE),ncol = cdim),
                ylag = rep(1,maxlag),
                lambda = NA, method='bayesglm',
                alpha.glmnet=1)
## End(Not run)

</code></pre>

<hr>
<h2 id='paramVertex'>Parameter estimation for Vertex dynamics</h2><span id='topic+paramVertex'></span>

<h3>Description</h3>

<p>Parameter estimation fro dynamic vertex case. The interface remaining almost identical to the static vertex one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramVertex(
  InputNetwork,
  VertexStatsvec = rep(1, nvertexstats),
  maxLag,
  VertexLag = rep(1, maxLag),
  VertexLagMatrix = matrix(1, maxLag, length(VertexStatsvec)),
  VertexModelGroup = NA,
  VertexAttLag = rep(1, maxLag),
  dayClass = NA,
  EdgeModelTerms,
  EdgeModelFormula,
  EdgeGroup,
  EdgeIntercept = c("edges"),
  EdgeNetparam = NA,
  EdgeExvar = NA,
  EdgeLag = rep(1, maxLag),
  EdgeLagMatrix = matrix(1, maxLag, length(EdgeModelTerms)),
  regMethod = "bayesglm",
  paramout = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paramVertex_+3A_inputnetwork">InputNetwork</code></td>
<td>
<p>list of networks.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_vertexstatsvec">VertexStatsvec</code></td>
<td>
<p>binary vector of size 8.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_maxlag">maxLag</code></td>
<td>
<p>maximum lag, numeric.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_vertexlag">VertexLag</code></td>
<td>
<p>binary vector of length maxLag.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_vertexlagmatrix">VertexLagMatrix</code></td>
<td>
<p>binary matrix of size maxLag x 8.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_vertexmodelgroup">VertexModelGroup</code></td>
<td>
<p>Grouping term for vertex model. Must be from vertex attribute list.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_vertexattlag">VertexAttLag</code></td>
<td>
<p>Lag vector for vertex group terms. Of length maxLag.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_dayclass">dayClass</code></td>
<td>
<p>Any network level present time attribute vector. Here used to indicate week/weekend as 0/1.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_edgemodelterms">EdgeModelTerms</code></td>
<td>
<p>Model terms in edge model.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_edgemodelformula">EdgeModelFormula</code></td>
<td>
<p>Model formula in edge model.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_edgegroup">EdgeGroup</code></td>
<td>
<p>Group terms in edge model.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_edgeintercept">EdgeIntercept</code></td>
<td>
<p>Intercept for edge model.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_edgenetparam">EdgeNetparam</code></td>
<td>
<p>Network level parameter for edge model (currently only supported parameter is current network size).</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_edgeexvar">EdgeExvar</code></td>
<td>
<p>Extraneous variable for edge model.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_edgelag">EdgeLag</code></td>
<td>
<p>binary vector of length maxLag.</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_edgelagmatrix">EdgeLagMatrix</code></td>
<td>
<p>binary matrix of dim maxLag x length(EdgeModelTerms)</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_regmethod">regMethod</code></td>
<td>
<p>Regression method. default: &quot;bayesglm&quot;</p>
</td></tr>
<tr><td><code id="paramVertex_+3A_paramout">paramout</code></td>
<td>
<p>T/F Should the parameter estimates be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Vertex model parameter list is as follows (Freeman degree, In degree, Out degree, Eigen Centrality, Between centrality, Info centrality, Closeness centrality, log k cycles, log size). For more details about the definitions of the terms, please refer to the vertexstats.R file, which implements all of these. The definitions are in sna or igraph.
</p>


<h3>Value</h3>

<p>list with following elements: <br />
EdgeCoef: edge coefficients. <br />
Edgemplematfull: MPLE matrix from edges. <br />
Edgemplemat: Subsetted MPLE matrix. <br />
VertexCoef: Coefficients from vertex. <br />
Vstats: Vertex statistics matrix.<br />
EdgePredictor0: Edge predictors with imputations with 0.<br />
EdgePredictor1: Edge predictors with imputations with 1. <br />
EdgePredictorNA: Edge predictors with imputations with NA. <br />
EdgeFit: Edge model. <br /> 
VertexStatsFull: Vertex statistics matrix, full. <br />
VertexFit: Vertex model. <br />
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nvertexstats &lt;- 9
maxLag = 3
VertexLag = rep(1, maxLag)
VertexLagMatrix &lt;- matrix(0, maxLag, nvertexstats)
VertexLagMatrix[, c(4, 7)] &lt;- 1
VertexLagMatrix[c(2,3),7] &lt;- 0

getWeekend &lt;- function(z){
    weekends &lt;- c("Saturday", "Sunday")
    if(!network::is.network(z)){
        if(is.na(z)) return(NA)
    } else {
         zDay &lt;- get.network.attribute(z, attrname = "day")
         out &lt;- ifelse(zDay %in% weekends, 1, 0)
         return(out)   
    }
}

dayClass &lt;- numeric(length(beach))
for(i in seq_along(dayClass)) {
    dayClass[i] &lt;- getWeekend(beach[[i]])
}
dayClass &lt;- na.omit(dayClass)


out &lt;- paramVertex(InputNetwork = beach,
                   maxLag = 3,
                   VertexStatsvec = rep(1, nvertexstats),
                   VertexModelGroup = "regular",
                   VertexLag = rep(1, maxLag),
                   VertexLagMatrix = VertexLagMatrix,
                   dayClass = dayClass,
                   EdgeModelTerms = NA,
                   EdgeModelFormula = NA,
                   EdgeGroup = NA,
                   EdgeIntercept = c("edges"),
                   EdgeNetparam = c("logSize"),
                   EdgeExvar = NA,
                   EdgeLag = c(1, 1, 0),
                   paramout = TRUE)
</code></pre>

<hr>
<h2 id='paramVertexOnly'>Parameter estimation for Vertex model only for a list of dynamic networks.</h2><span id='topic+paramVertexOnly'></span>

<h3>Description</h3>

<p>Parameter estimation for Vertex model only for a list of dynamic networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramVertexOnly(
  InputNetwork,
  VertexStatsvec = rep(1, nvertexstats),
  maxLag,
  VertexLag = rep(1, maxLag),
  VertexLagMatrix = matrix(1, maxLag, length(VertexStatsvec)),
  dayClass = NA,
  regMethod = "bayesglm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paramVertexOnly_+3A_inputnetwork">InputNetwork</code></td>
<td>
<p>Input network list.</p>
</td></tr>
<tr><td><code id="paramVertexOnly_+3A_vertexstatsvec">VertexStatsvec</code></td>
<td>
<p>Binary vector of size 9, indicating vertex model.</p>
</td></tr>
<tr><td><code id="paramVertexOnly_+3A_maxlag">maxLag</code></td>
<td>
<p>maximum lag.</p>
</td></tr>
<tr><td><code id="paramVertexOnly_+3A_vertexlag">VertexLag</code></td>
<td>
<p>Binary vector of size maxLag, indicating Lag terms in the model.</p>
</td></tr>
<tr><td><code id="paramVertexOnly_+3A_vertexlagmatrix">VertexLagMatrix</code></td>
<td>
<p>Binary matrix indicating lagged vertex statistics in
the model.</p>
</td></tr>
<tr><td><code id="paramVertexOnly_+3A_dayclass">dayClass</code></td>
<td>
<p>Any network level present time attribute vector. Here used to indicate week/weekend as 0/1.</p>
</td></tr>
<tr><td><code id="paramVertexOnly_+3A_regmethod">regMethod</code></td>
<td>
<p>one of &quot;glm&quot;, &quot;glmnet&quot;, &quot;bayesglm&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of 3 elements:<br />
VertexFit: Output from regEngine. <br />
VertexStats: Subsetted vertex stats matrix. <br />
VertexStatsFull: Full matrix of vertex stats.
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nvertexstats &lt;- 9
maxLag = 3
VertexLag = rep(1, maxLag)
VertexLagMatrix &lt;- matrix(0, maxLag, nvertexstats)
VertexLagMatrix[, c(4, 7)] &lt;- 1
VertexLagMatrix[c(2,3),7] &lt;- 0
getWeekend &lt;- function(z){
    weekends &lt;- c("Saturday", "Sunday")
    if(!network::is.network(z)){
        if(is.na(z)) return(NA)
    } else {
         zDay &lt;- get.network.attribute(z, attrname = "day")
         out &lt;- ifelse(zDay %in% weekends, 1, 0)
         return(out)   
    }
}

## for(i in 1:31) print(getWeekend(beach[[i]]))
## generate a vector of network level exogenous variable
dayClass &lt;- numeric(length(beach))
for(i in seq_along(dayClass)) {
    dayClass[i] &lt;- getWeekend(beach[[i]])
}
out &lt;- paramVertexOnly(InputNetwork = beach,
                       maxLag = 3,
                       VertexStatsvec = rep(1, nvertexstats),
                       VertexLag = rep(1, maxLag),
                       VertexLagMatrix = VertexLagMatrix,
                       dayClass = dayClass)
</code></pre>

<hr>
<h2 id='paramVertexOnlyGroup'>Parameter estimation for Vertex model only for a list of dynamic networks.</h2><span id='topic+paramVertexOnlyGroup'></span>

<h3>Description</h3>

<p>Parameter estimation for Vertex model only for a list of dynamic networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramVertexOnlyGroup(
  InputNetwork,
  VertexStatsvec = rep(1, nvertexstats),
  maxLag,
  VertexModelGroup = NA,
  VertexLag = rep(1, maxLag),
  VertexAttLag = rep(1, maxLag),
  VertexLagMatrix = matrix(1, maxLag, length(VertexStatsvec)),
  regMethod = "bayesglm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paramVertexOnlyGroup_+3A_inputnetwork">InputNetwork</code></td>
<td>
<p>Input network list.</p>
</td></tr>
<tr><td><code id="paramVertexOnlyGroup_+3A_vertexstatsvec">VertexStatsvec</code></td>
<td>
<p>Binary vector of size 9, indicating vertex model.</p>
</td></tr>
<tr><td><code id="paramVertexOnlyGroup_+3A_maxlag">maxLag</code></td>
<td>
<p>maximum lag.</p>
</td></tr>
<tr><td><code id="paramVertexOnlyGroup_+3A_vertexmodelgroup">VertexModelGroup</code></td>
<td>
<p>Group term for vertex model.</p>
</td></tr>
<tr><td><code id="paramVertexOnlyGroup_+3A_vertexlag">VertexLag</code></td>
<td>
<p>Binary vector of size maxLag, indicating Lag terms in the model.</p>
</td></tr>
<tr><td><code id="paramVertexOnlyGroup_+3A_vertexattlag">VertexAttLag</code></td>
<td>
<p>Vertex group term lag vector.</p>
</td></tr>
<tr><td><code id="paramVertexOnlyGroup_+3A_vertexlagmatrix">VertexLagMatrix</code></td>
<td>
<p>Binary matrix indicating lagged vertex statistics in
the model.</p>
</td></tr>
<tr><td><code id="paramVertexOnlyGroup_+3A_regmethod">regMethod</code></td>
<td>
<p>one of &quot;glm&quot;, &quot;glmnet&quot;, &quot;bayesglm&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of 3 elements:<br />
VertexFit: Output from regEngine. <br />
VertexStats: Subsetted vertex stats matrix. <br />
VertexStatsFull: Full matrix of vertex stats.
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nvertexstats &lt;- 9
InputNetwork &lt;- beach
maxLag &lt;- 3
VertexStatsvec &lt;- rep(1, nvertexstats)
VertexLag &lt;- rep(1, maxLag)
regMethod &lt;- "bayesglm"
VertexModelGroup &lt;- "regular"
VertexLagMatrix &lt;- matrix(0, maxLag, nvertexstats)
VertexLagMatrix[, c(4, 7)] &lt;- 1
VertexLagMatrix[c(2,3),7] &lt;- 0
Vout1 &lt;- paramVertexOnlyGroup(InputNetwork = beach,
                          maxLag = maxLag,
                          VertexStatsvec = VertexStatsvec,
                          VertexModelGroup = VertexModelGroup,
                          VertexLag = VertexLag,
                          VertexLagMatrix = VertexLagMatrix)
summary(Vout1$VertexFit$fit)
</code></pre>

<hr>
<h2 id='rdNets'>Blog citation network</h2><span id='topic+rdNets'></span>

<h3>Description</h3>

<p>A data set of temporal inter and intra group blog citation network, with fixed number of vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdNets
</code></pre>


<h3>Format</h3>

<p>A list with 484 elements. Each element is a network of size 47 number of vertices.
</p>


<h3>Source</h3>

<p>Butts, C. T. and B. R. Cross (2009). Change and external events in computer-mediated citation networks, English language weblogs and the 2004 u.s. electoral cycle. The Journal of Social Structure 10 (3), 1-29.
</p>

<hr>
<h2 id='regEngine'>General purpose regression engine for the methods bayesglm, glm and glmnet</h2><span id='topic+regEngine'></span>

<h3>Description</h3>

<p>General purpose regression engine for the methods bayesglm, glm and glmnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regEngine(
  XYdata,
  method = "bayesglm",
  regIntercept = FALSE,
  lambda = NA,
  alpha = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regEngine_+3A_xydata">XYdata</code></td>
<td>
<p>matrix with X and Y columns. First column is named as y, other columns are X.</p>
</td></tr>
<tr><td><code id="regEngine_+3A_method">method</code></td>
<td>
<p>string among (&quot;glm&quot;, &quot;glmnet&quot;, &quot;bayesglm&quot;).</p>
</td></tr>
<tr><td><code id="regEngine_+3A_regintercept">regIntercept</code></td>
<td>
<p>Logical. Should intercept be included in the model?</p>
</td></tr>
<tr><td><code id="regEngine_+3A_lambda">lambda</code></td>
<td>
<p>for method &quot;glmnet&quot;.</p>
</td></tr>
<tr><td><code id="regEngine_+3A_alpha">alpha</code></td>
<td>
<p>for &quot;glmnet&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements: coef, se, lambda, fit (Coefficients, SE, lambda, if used, fit object.)
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>

<hr>
<h2 id='vdegree'>vdegree</h2><span id='topic+vdegree'></span>

<h3>Description</h3>

<p>Calculates the degree of each vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdegree(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vdegree_+3A_x">x</code></td>
<td>
<p>Adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a network as adjacency matrix, calculate degree stats for each vertex.
</p>


<h3>Value</h3>

<p>vector of length number of vertices.
</p>


<h3>Author(s)</h3>

<p>Abhirup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vdegree(beach[[1]][, ])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
