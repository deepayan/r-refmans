<!DOCTYPE html><html><head><title>Help for package nleqslv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nleqslv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nleqslv'><p>Solving systems of nonlinear equations with Broyden or Newton</p></a></li>
<li><a href='#nleqslv-iterationreport'><p>Detailed iteration report of nleqslv</p></a></li>
<li><a href='#nleqslv-package'><p>Solve Systems of Nonlinear Equations</p></a></li>
<li><a href='#print.test.nleqslv'><p>Printing the result of <code>testnslv</code></p></a></li>
<li><a href='#searchZeros'><p>Solve a nonlinear equation system with multiple roots</p>
from multiple initial estimates</a></li>
<li><a href='#testnslv'><p>Test different methods for solving with <code>nleqslv</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.3.5</td>
</tr>
<tr>
<td>Title:</td>
<td>Solve Systems of Nonlinear Equations</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Berend Hasselman</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Berend Hasselman &lt;bhh@xs4all.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Solve a system of nonlinear equations using a Broyden or a Newton method
             with a choice of global strategies such as line search and trust region.
             There are options for using a numerical or user supplied Jacobian,
             for specifying a banded numerical Jacobian and for allowing
             a singular or ill-conditioned Jacobian.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-24 19:45:26 UTC; berendhasselman</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-26 23:30:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='nleqslv'>Solving systems of nonlinear equations with Broyden or Newton</h2><span id='topic+nleqslv'></span>

<h3>Description</h3>

<p>The function solves a system of nonlinear equations with either a Broyden or a
full Newton method. It provides line search and trust region global strategies
for difficult systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nleqslv(x, fn, jac=NULL, ...,
               method = c("Broyden", "Newton"),
               global = c("dbldog", "pwldog",
                          "cline", "qline", "gline", "hook", "none"),
               xscalm = c("fixed","auto"),
               jacobian=FALSE,
               control = list()
	)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nleqslv_+3A_x">x</code></td>
<td>
<p>A numeric vector with an initial guess of the root of the function.</p>
</td></tr>
<tr><td><code id="nleqslv_+3A_fn">fn</code></td>
<td>
<p>A function of <code>x</code> returning a vector of function values
with the same length as the vector <code>x</code>.</p>
</td></tr>
<tr><td><code id="nleqslv_+3A_jac">jac</code></td>
<td>
<p>A function to return the Jacobian for the <code>fn</code> function.
For a vector valued function <code>fn</code> the Jacobian must be a numeric
matrix of the correct dimensions.
For a scalar valued function <code>fn</code> the <code>jac</code> function may return a scalar.
If not supplied numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="nleqslv_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>fn</code> and <code>jac</code>.</p>
</td></tr>
<tr><td><code id="nleqslv_+3A_method">method</code></td>
<td>
<p>The method to use for finding a solution. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="nleqslv_+3A_global">global</code></td>
<td>
<p>The global strategy to apply. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="nleqslv_+3A_xscalm">xscalm</code></td>
<td>
<p>The type of x scaling to use. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="nleqslv_+3A_jacobian">jacobian</code></td>
<td>
<p>A logical indicating if the estimated (approximate) jacobian in the solution should be returned.
See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="nleqslv_+3A_control">control</code></td>
<td>
<p>A named list of control parameters. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms implemented in <code>nleqslv</code> are based on Dennis and Schnabel (1996).
</p>


<h4>Methods</h4>

<p>Method <code>Broyden</code> starts with a computed Jacobian of the function and
then updates this Jacobian after each successful iteration using the so-called Broyden update.
This method often shows super linear convergence towards a solution.
When <code>nleqslv</code> determines that it cannot
continue with the current Broyden matrix it will compute a new Jacobian.
</p>
<p>Method <code>Newton</code> calculates a Jacobian of the function <code>fn</code> at each iteration.
Close to a solution this method will usually show quadratic convergence.
</p>
<p>Both methods apply a so-called (backtracking) global strategy to find
a better (more acceptable) iterate.  The function criterion used by the algorithm is half of
the sum of squares of the function values and &ldquo;acceptable&rdquo; means sufficient decrease
of the current function criterion value compared to that of the previous iteration.
A comprehensive discussion of these issues can be found in Dennis and Schnabel (1996).
Both methods apply an unpivoted QR-decomposition to the Jacobian as implemented in Lapack.
The Broyden method applies a rank-1 update to the Jacobian at the end of each iteration
and is based on a simplified and modernized version of the algorithm described in Reichel and Gragg (1990).
</p>



<h4>Global strategies</h4>

<p>When applying a full Newton or Broyden step does not yield a sufficiently smaller
function criterion value <code>nleqslv</code> will attempt to decrease the steplength using
one of several so-called global strategies.
</p>
<p>The <code>global</code> argument indicates which global strategy to use or to use no global strategy
</p>

<dl>
<dt><code>cline</code></dt><dd><p>a cubic line search</p>
</dd>
<dt><code>qline</code></dt><dd><p>a quadratic line search</p>
</dd>
<dt><code>gline</code></dt><dd><p>a geometric line search</p>
</dd>
<dt><code>dbldog</code></dt><dd><p>a trust region method using the double dogleg method as described in
Dennis and Schnabel (1996)</p>
</dd>
<dt><code>pwldog</code></dt><dd><p>a trust region method using the Powell dogleg method
as developed by Powell (1970).</p>
</dd>
<dt><code>hook</code></dt><dd><p>a trust region method described by Dennis and Schnabel (1996) as
<em>The locally constrained optimal (&ldquo;hook&rdquo;) step</em>.
It is equivalent to a Levenberg-Marquardt algorithm as described in
Moré (1978) and Nocedal and Wright (2006).</p>
</dd>
<dt><code>none</code></dt><dd><p>Only a pure local Newton or Broyden iteration is used.
The maximum stepsize (see below) is taken into account.
The default maximum number of iterations (see below) is set to 20.</p>
</dd>
</dl>

<p>The double dogleg method is the default global strategy employed by this package.
</p>
<p>Which global strategy to use in a particular situation is a matter of trial and error.
When one of the trust region methods fails, one of the line search strategies should be tried.
Sometimes a trust region will work and sometimes a line search method; neither has a clear advantage but
in many cases the double dogleg method works quite well.
</p>
<p>When the function to be solved returns non-finite function values for a parameter vector <code>x</code>
and the algorithm is <em>not</em> evaluating a numerical Jacobian, then any non-finite
values will be replaced by a large number forcing the algorithm to backtrack,
i.e. decrease the line search factor or decrease the trust region radius.
</p>



<h4>Scaling</h4>

<p>The elements of vector <code>x</code> may be scaled during the search for a zero of <code>fn</code>.
The  <code>xscalm</code> argument provides two possibilities for scaling
</p>

<dl>
<dt><code>fixed</code></dt><dd><p>the scaling factors are set to the values supplied in
the <code>control</code> argument and remain unchanged during the iterations.
The scaling factor of any element of <code>x</code>  should be set
to the inverse of the typical value of that element of <code>x</code>,
ensuring that all elements of <code>x</code> are approximately equal in size.</p>
</dd>
<dt><code>auto</code></dt><dd><p>the scaling factors
are calculated from the euclidean norms of the columns of the Jacobian matrix.
When a new Jacobian is computed, the scaling values will be set to the
euclidean norm of the corresponding column if that is larger than the current scaling value.
Thus the scaling values will not decrease during the iteration.
This is the method described in Moré (1978).
Usually manual scaling is preferable.</p>
</dd>
</dl>




<h4>Jacobian</h4>

<p>When evaluating a numerical Jacobian, an error message will be issued
on detecting non-finite function values.
An error message will also be issued when a user supplied jacobian contains non-finite entries.
</p>
<p>When the <code>jacobian</code> argument is set to <code>TRUE</code> the final Jacobian or Broyden matrix
will be returned in the return list.
The default value is <code>FALSE</code>; i.e. to not return the final matrix.
There is no guarantee that the final Broyden matrix resembles the actual Jacobian.
</p>
<p>The package can cope with a singular or ill-conditioned Jacobian if needed
by setting the <code>allowSingular</code> component of the <code>control</code> argument.
The method used is described in Dennis and Schnabel (1996);
it is equivalent to a Levenberg-Marquardt type adjustment with a small damping factor.
<em>There is no guarantee that this method will be successful.</em>
Warning: <em><code>nleqslv</code> may report spurious convergence in this case.</em>
</p>
<p>By default <code>nleqslv</code> returns an error
if a Jacobian becomes singular or very ill-conditioned.
A Jacobian is considered to be very ill-conditioned when the estimated inverse
condition is less than or equal to a specified tolerance with a default value
equal to <code class="reqn">10^{-12}</code>; this can be changed and made smaller
with the <code>cndtol</code> item of the <code>control</code> argument.
<em>There is no guarantee that any change will be effective.</em>
</p>



<h4>Control options</h4>

<p>The <code>control</code> argument is a named list that can supply any of the
following components:
</p>

<dl>
<dt><code>xtol</code></dt><dd><p>The relative steplength tolerance.
When the relative  steplength of all scaled x values is smaller than this value
convergence is declared. The default value is <code class="reqn">10^{-8}</code>.
</p>
</dd>
<dt><code>ftol</code></dt><dd><p>The function value tolerance.
Convergence is declared when the largest absolute function value is smaller than <code>ftol</code>.
The default value is <code class="reqn">10^{-8}</code>.
</p>
</dd>
<dt><code>btol</code></dt><dd><p>The backtracking tolerance.
When the relative steplength in a backtracking step to find an acceptable point is smaller
than the backtracking tolerance, the backtracking is terminated.
In the <code>Broyden</code> method a new Jacobian will be calculated if the Jacobian is outdated.
The default value is <code class="reqn">10^{-3}</code>.
</p>
</dd>
<dt><code>cndtol</code></dt><dd><p>The tolerance of the test for ill conditioning of
the Jacobian or Broyden approximation. If less than the machine precision it will
be silently set to the machine precision.
When the estimated inverse condition of the (approximated) Jacobian matrix is less than or equal to
the value of <code>cndtol</code> the matrix is deemed to be ill-conditioned,
in which case an error will be reported if the <code>allowSingular</code> component is set to <code>FALSE</code>.
The default value is <code class="reqn">10^{-12}</code>.
</p>
</dd>
<dt><code>sigma</code></dt><dd><p>Reduction factor for the geometric line search. The default value is 0.5.</p>
</dd>
<dt><code>scalex</code></dt><dd><p>a vector of scaling values for the parameters.
The inverse of a scale value is an indication of the size of a parameter.
The default value is 1.0 for all scale values.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>The maximum number of major iterations.
The default value is 150 if a global strategy has been specified.
If no global strategy has been specified the default is 20.</p>
</dd>
<dt><code>trace</code></dt><dd><p>Non-negative integer. A value of 1 will give a detailed report of the
progress of the iteration. For a description see <code><a href="#topic+Iteration+20report">Iteration report</a></code>.</p>
</dd>
<dt><code>chkjac</code></dt><dd><p>A logical value indicating whether to check a user supplied Jacobian, if
supplied. The default value is <code>FALSE</code>. The first 10 errors are printed.
The code for this check is derived from the code in Bouaricha and Schnabel (1997).</p>
</dd>
<dt><code>delta</code></dt><dd><p>Initial (scaled) trust region radius.
A value of <code class="reqn">-1.0</code> or <code>"cauchy"</code> is replaced by the length of the Cauchy step in the initial point.
A value of <code class="reqn">-2.0</code> or <code>"newton"</code> is replaced by the length of the Newton step in the initial point.
Any numeric value less than or equal to 0 and not equal to <code class="reqn">-2.0</code>, will be replaced by <code class="reqn">-1.0</code>;
the algorithm will then start with the length of the Cauchy step in the initial point.
If it is numeric and positive it will be set to the smaller of the value supplied or the maximum stepsize.
If it is not numeric and not one of the permitted character strings then an error message will be issued.
The default is <code class="reqn">-2.0</code>.</p>
</dd>
<dt><code>stepmax</code></dt><dd><p>Maximum scaled stepsize.
If this is negative then the maximum stepsize is set to the largest positive representable number.
The default is <code class="reqn">-1.0</code>, so there is no default maximum stepsize.</p>
</dd>
<dt><code>dsub</code></dt><dd><p>Number of non zero subdiagonals of a banded Jacobian.
The default is to assume that the Jacobian is <em>not</em> banded.
Must be specified if <code>dsuper</code> has been specified and must be larger than zero when <code>dsuper</code> is zero.</p>
</dd>
<dt><code>dsuper</code></dt><dd><p>Number of non zero super diagonals of a banded Jacobian.
The default is to assume that the Jacobian is <em>not</em> banded.
Must be specified if <code>dsub</code> has been specified and must be larger than zero when <code>dsub</code> is zero.</p>
</dd>
<dt><code>allowSingular</code></dt><dd><p>A logical value indicating if a small correction
to the Jacobian when it is singular or too ill-conditioned is allowed.
If the correction is less than <code>100*.Machine$double.eps</code> the correction
cannot be applied and an unusable Jacobian will be reported.
The method used is similar to a Levenberg-Marquardt correction and
is explained in Dennis and Schnabel (1996) on page 151.
It may be necessary to choose a higher value for <code>cndtol</code> to enforce the correction.
The default value is <code>FALSE</code>.
</p>
</dd>
</dl>




<h3>Value</h3>

<p>A list containing components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>final values for x</p>
</td></tr>
<tr><td><code>fvec</code></td>
<td>
<p>function values</p>
</td></tr>
<tr><td><code>termcd</code></td>
<td>
<p>termination code as integer.
The values returned are
</p>

<dl>
<dt><code>1</code></dt><dd><p>Function criterion is near zero.
Convergence of function values has been achieved.</p>
</dd>
<dt><code>2</code></dt><dd><p>x-values within tolerance. This means that the relative distance between two
consecutive x-values is smaller than <code>xtol</code> but that
the function value criterion is still larger than <code>ftol</code>.
<em>Function values may not be near zero; therefore the user must check if
function values are acceptably small.</em></p>
</dd>
<dt><code>3</code></dt><dd><p>No better point found.
This means that the algorithm has stalled and cannot find an acceptable new point.
This may or may not indicate acceptably small function values.</p>
</dd>
<dt><code>4</code></dt><dd><p>Iteration limit <code>maxit</code> exceeded.</p>
</dd>
<dt><code>5</code></dt><dd><p>Jacobian is too ill-conditioned.</p>
</dd>
<dt><code>6</code></dt><dd><p>Jacobian is singular.</p>
</dd>
<dt><code>7</code></dt><dd><p>Jacobian is unusable.</p>
</dd>
<dt><code>-10</code></dt><dd><p>User supplied Jacobian is most likely incorrect.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>message</code></td>
<td>
<p>a string describing the termination code</p>
</td></tr>
<tr><td><code>scalex</code></td>
<td>
<p>a vector containing the scaling factors,
which will be the final values when automatic scaling was selected</p>
</td></tr>
<tr><td><code>njcnt</code></td>
<td>
<p>number of Jacobian evaluations</p>
</td></tr>
<tr><td><code>nfcnt</code></td>
<td>
<p>number of function evaluations, excluding those required for calculating a Jacobian and
excluding the initial function evaluation (at iteration 0)</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of outer iterations used by the algorithm. This excludes the initial iteration.
The number of backtracks can be calculated as the difference between the <code>nfcnt</code> and <code>iter</code>
components.</p>
</td></tr>
<tr><td><code>jac</code></td>
<td>
<p>the final Jacobian or the Broyden approximation if <code>jacobian</code> was set to <code>TRUE</code>.
If no iterations were executed, as may happen when the initial guess are sufficiently close
the solution, there is no Broyden approximation and the returned matrix will always be the actual Jacobian.
If the matrix is singular or too ill-conditioned the returned matrix is of no value.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>You cannot use this function recursively.
Thus function <code>fn</code> should not in its turn call <code>nleqslv</code>.
</p>


<h3>References</h3>

<p>Bouaricha, A. and Schnabel, R.B. (1997),
Algorithm 768: TENSOLVE: A Software Package for
Solving Systems of Nonlinear Equations and Nonlinear
Least-squares Problems Using Tensor Methods,
<em>Transactions on Mathematical Software</em>, <b>23</b>, 2, pp. 174&ndash;195.
</p>
<p>Dennis, J.E. Jr  and Schnabel, R.B. (1996), <em>Numerical Methods for Unconstrained Optimization
and Nonlinear Equations</em>, Siam.
</p>
<p>Moré, J.J. (1978), The Levenberg-Marquardt Algorithm, Implementation and Theory,
In <em>Numerical Analysis</em>, G.A. Watson (Ed.),
Lecture Notes in Mathematics 630, Springer-Verlag, pp. 105&ndash;116.
</p>
<p>Golub, G.H and C.F. Van Loan (1996), Matrix Computations (3rd edition), The John Hopkins University Press.
</p>
<p>Higham, N.J. (2002), Accuracy and Stability of Numerical Algorithms, 2nd ed., SIAM, pp. 10&ndash;11.
</p>
<p>Nocedal, J. and Wright, S.J. (2006), <em>Numerical Optimization</em>, Springer.
</p>
<p>Powell, M.J.D. (1970), A hybrid method for nonlinear algebraic equations,
In <em>Numerical Methods for Nonlinear Algebraic Equations</em>, P. Rabinowitz (Ed.), Gordon &amp; Breach.
</p>
<p>Powell, M.J.D. (1970), A Fortran subroutine for solving systems nonlinear equations,
In <em>Numerical Methods for Nonlinear Algebraic Equations</em>, P. Rabinowitz (Ed.), Gordon &amp; Breach.
</p>


<p>Reichel, L. and W.B. Gragg (1990), Algorithm 686: FORTRAN subroutines for updating the QR decomposition,
<em>ACM Trans. Math. Softw.</em>, <b>16</b>, 4, pp. 369&ndash;377.
</p>


<h3>See Also</h3>

<p>If this function cannot solve the supplied function then it is
a good idea to try the function <a href="#topic+testnslv">testnslv</a> in this package.
For detecting multiple solutions see <a href="#topic+searchZeros">searchZeros</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Dennis Schnabel example 6.5.1 page 149
dslnex &lt;- function(x) {
    y &lt;- numeric(2)
    y[1] &lt;- x[1]^2 + x[2]^2 - 2
    y[2] &lt;- exp(x[1]-1) + x[2]^3 - 2
    y
}

jacdsln &lt;- function(x) {
    n &lt;- length(x)
    Df &lt;- matrix(numeric(n*n),n,n)
    Df[1,1] &lt;- 2*x[1]
    Df[1,2] &lt;- 2*x[2]
    Df[2,1] &lt;- exp(x[1]-1)
    Df[2,2] &lt;- 3*x[2]^2

    Df
}

BADjacdsln &lt;- function(x) {
    n &lt;- length(x)
    Df &lt;- matrix(numeric(n*n),n,n)
    Df[1,1] &lt;- 4*x[1]
    Df[1,2] &lt;- 2*x[2]
    Df[2,1] &lt;- exp(x[1]-1)
    Df[2,2] &lt;- 5*x[2]^2

    Df
}

xstart &lt;- c(2,0.5)
fstart &lt;- dslnex(xstart)
xstart
fstart

# a solution is c(1,1)

nleqslv(xstart, dslnex, control=list(btol=.01))

# Cauchy start
nleqslv(xstart, dslnex, control=list(trace=1,btol=.01,delta="cauchy"))

# Newton start
nleqslv(xstart, dslnex, control=list(trace=1,btol=.01,delta="newton"))

# final Broyden approximation of Jacobian (quite good)
z &lt;- nleqslv(xstart, dslnex, jacobian=TRUE,control=list(btol=.01))
z$x
z$jac
jacdsln(z$x)

# different initial start; not a very good final approximation
xstart &lt;- c(0.5,2)
z &lt;- nleqslv(xstart, dslnex, jacobian=TRUE,control=list(btol=.01))
z$x
z$jac
jacdsln(z$x)

## Not run: 
# no global strategy but limit stepsize
# but look carefully: a different solution is found
nleqslv(xstart, dslnex, method="Newton", global="none", control=list(trace=1,stepmax=5))

# but if the stepsize is limited even more the c(1,1) solution is found
nleqslv(xstart, dslnex, method="Newton", global="none", control=list(trace=1,stepmax=2))

# Broyden also finds the c(1,1) solution when the stepsize is limited
nleqslv(xstart, dslnex, jacdsln, method="Broyden", global="none", control=list(trace=1,stepmax=2))

## End(Not run)

# example with a singular jacobian in the initial guess
f &lt;- function(x) {
    y &lt;- numeric(3)
    y[1] &lt;- x[1] + x[2] - x[1]*x[2] - 2
    y[2] &lt;- x[1] + x[3] - x[1]*x[3] - 3
    y[3] &lt;- x[2] + x[3] - 4
    return(y)
}

Jac &lt;- function(x) {
    J &lt;- matrix(0,nrow=3,ncol=3)
    J[,1] &lt;- c(1-x[2],1-x[3],0)
    J[,2] &lt;- c(1-x[1],0,1)
    J[,3] &lt;- c(0,1-x[1],1)
    J
}

# exact solution
xsol &lt;- c(-.5, 5/3 , 7/3)
xsol

xstart &lt;- c(1,2,3)
J &lt;- Jac(xstart)
J
rcond(J)

z &lt;- nleqslv(xstart,f,Jac, method="Newton",control=list(trace=1,allowSingular=TRUE))
all.equal(z$x,xsol)
</code></pre>

<hr>
<h2 id='nleqslv-iterationreport'>Detailed iteration report of nleqslv</h2><span id='topic+Iteration+20report'></span>

<h3>Description</h3>

<p> The format of the iteration report
provided by nleqslv when the <code>trace</code> component of the <code>control</code> argument
has been set to 1.
</p>


<h3>Details</h3>

<p>All iteration reports consist of a series of columns with a header summarising the contents.
Common column headers are
</p>

<dl>
<dt><code>Iter</code></dt><dd><p>Iteration counter</p>
</dd>
<dt><code>Jac</code></dt><dd><p>Jacobian type. The Jacobian type is indicated by <code>N</code> for a Newton Jacobian
or <code>B</code> for a Broyden updated matrix; optionally followed by the letter <code>s</code>
indicating a totally singular matrix or the letter <code>i</code> indicating an ill-conditioned matrix.
Unless the Jacobian is singular, the Jacobian type is followed by an estimate
of the inverse condition number of the Jacobian in parentheses as computed by Lapack.
This column will be blank when backtracking is active.</p>
</dd>
<dt><code>Fnorm</code></dt><dd><p>square of the euclidean norm of function values / 2</p>
</dd>
<dt><code>Largest |f|</code></dt><dd><p>infinity norm of <code class="reqn">f(x)</code> at the current point</p>
</dd>
</dl>



<h3>Report for linesearch methods</h3>

<p>A sample iteration report for the linesearch global methods (<code>cline</code>, <code>qline</code> and <code>gline</code>) is
(some intercolumn space has been removed to make the table fit)
</p>
<pre>
Iter        Jac Lambda        Ftarg         Fnorm   Largest |f|
   0                                 2.886812e+00  2.250000e+00
   1 N(9.6e-03) 1.0000 2.886235e+00  5.787362e+05  1.070841e+03
   1            0.1000 2.886754e+00  9.857947e+00  3.214799e+00
   1            0.0100 2.886806e+00  2.866321e+00  2.237878e+00
   2 B(2.2e-02) 1.0000 2.865748e+00  4.541965e+03  9.341610e+01
   2            0.1000 2.866264e+00  3.253536e+00  2.242344e+00
   2            0.0298 2.866304e+00  2.805872e+00  2.200544e+00
   3 B(5.5e-02) 1.0000 2.805311e+00  2.919089e+01  7.073082e+00
   3            0.1000 2.805816e+00  2.437606e+00  2.027297e+00
   4 B(1.0e-01) 1.0000 2.437118e+00  9.839802e-01  1.142529e+00
</pre>
<p>The column headed by <code>Lambda</code> shows the value of the line search parameter.
The column headed by <code>Ftarg</code> follows from a sufficient decrease requirement and
is the value below which <code>Fnorm</code> must drop if the current step is to be accepted.
</p>
<p>The value of <code>Lambda</code> may not be lower than a threshold determined
by the setting of control parameter <code>xtol</code> to avoid reporting
false convergence. When no acceptable <code>Lambda</code> is possible and the Broyden method
is being used, a new Jacobian will be computed.
</p>


<h3>Report for the pure method</h3>

<p>The iteration report for the global method <code>none</code> is almost the same as the above report,
except that the column labelled  <code>Ftarg</code> is omitted.
The column <code>Lambda</code> gives the ratio of the maximum stepsize and the length of
the full Newton step. It is either exactly 1.0, indicating that the Newton step is smaller
than the maximum stepsize and therefore used unmodified, or smaller than 1.0,
indicating that the Newton step is larger than the maximum stepsize and therefore truncated.
</p>


<h3>Report for the double dogleg global method</h3>

<p>A sample iteration report for the global method <code>dbldog</code> is
(some intercolumn space has been removed to make the table fit)
</p>
<pre>
Iter        Jac   Lambda    Eta   Dlt0   Dltn        Fnorm  Largest |f|
   0                                           2.886812e+00 2.250000e+00
   1 N(9.6e-03) C        0.9544 0.4671 0.9343* 1.699715e-01 5.421673e-01
   1            W 0.0833 0.9544 0.9343 0.4671  1.699715e-01 5.421673e-01
   2 B(1.1e-02) W 0.1154 0.4851 0.4671 0.4671  1.277667e-01 5.043571e-01
   3 B(7.3e-02) W 0.7879 0.7289 0.4671 0.0759  5.067893e-01 7.973542e-01
   3            C        0.7289 0.0759 0.1519  5.440250e-02 2.726084e-01
   4 B(8.3e-02) W 0.5307 0.3271 0.1519 0.3037  3.576547e-02 2.657553e-01
   5 B(1.8e-01) N        0.6674 0.2191 0.4383  6.566182e-03 8.555110e-02
   6 B(1.8e-01) N        0.9801 0.0376 0.0752  4.921645e-04 3.094104e-02
   7 B(1.9e-01) N        0.7981 0.0157 0.0313  4.960629e-06 2.826064e-03
   8 B(1.6e-01) N        0.3942 0.0029 0.0058  1.545503e-08 1.757498e-04
   9 B(1.5e-01) N        0.6536 0.0001 0.0003  2.968676e-11 5.983765e-06
  10 B(1.5e-01) N        0.4730 0.0000 0.0000  4.741792e-14 2.198380e-07
  11 B(1.5e-01) N        0.9787 0.0000 0.0000  6.451792e-19 8.118586e-10
</pre>
<p>After the column for the Jacobian the letters indicate the following
</p>

<dl>
<dt><code>C</code></dt><dd><p>a fraction (<code class="reqn">\le1.0</code>) of the Cauchy or steepest descent step is taken where
the fraction is the ratio of the trust region radius and the Cauchy steplength.</p>
</dd>
<dt><code>W</code></dt><dd><p>a convex combination of the Cauchy and <code>eta</code>*(Newton step) is taken.
The number in the column headed by <code>Lambda</code> is the weight of the partial
Newton step.</p>
</dd>
<dt><code>P</code></dt><dd><p>a fraction (<code class="reqn">\ge1.0</code>) of the partial Newton step, equal to <code>eta</code>*(Newton step),
is taken where
the fraction is the ratio of the trust region radius and the partial Newton steplength.</p>
</dd>
<dt><code>N</code></dt><dd><p>a normal full Newton step is taken.</p>
</dd>
</dl>

<p>The number in the  column headed by <code>Eta</code> is calculated from an upper limit on the ratio
of the length of the steepest descent direction and the length of the Newton step.
See Dennis and Schnabel (1996) pp.139ff for the details.
The column headed by <code>Dlt0</code> gives the trust region size at the start of the current
iteration.
The column headed by <code>Dltn</code> gives the trust region size when the current
step has been accepted by the dogleg algorithm.
</p>
<p>The trust region size is decreased when the actual reduction of the function value norm
does not agree well with the predicted reduction from the linear approximation of the function
or does not exhibit sufficient decrease.
And increased when the actual and predicted reduction are sufficiently close.
The trust region size is not allowed to decrease beyond a threshold determined
by the setting of control parameter <code>xtol</code>; when that happens the backtracking
is regarded as a failure and is terminated.
In that case a new Jacobian will be calculated if the Broyden method is being used.
</p>
<p>The current trust region step is continued with a doubled trust region size
when the actual and predicted reduction agree extremely well. This is indicated
by <code>*</code> immediately following the value in the column
headed by <code>Dltn</code>. This could save gradient calculations.
However, a trial step is never taken if the current step is a Newton step.
If the trial step does not succeed then the previous trust region size is restored
by halving the trial size.
The exception is when a trial step takes a Newton step.
In that case the trust region size is
immediately set to the size of the Newton step which implies that a
halving of the new size leads to a smaller size for the trust region than before.
</p>
<p>Normally the initial trust region radius is the same as
the final trust region radius of the previous iteration but the trust region size is
restricted by the size of the current Newton step. So when full Newton steps
are being taken, the trust region radius at the start of an iteration may be less than the
final value of the previous iteration.
The double dogleg method and the trust region updating procedure are fully explained
in sections 6.4.2 and 6.4.3 of Dennis and Schnabel (1996).
</p>


<h3>Report for the single (Powell) dogleg global method</h3>

<p>A sample iteration report for the global method <code>pwldog</code> is
(some intercolumn space has been removed to make the table fit)
</p>
<pre>
Iter        Jac   Lambda   Dlt0   Dltn         Fnorm  Largest |f|
   0                                    2.886812e+00 2.250000e+00
   1 N(9.6e-03) C        0.4671 0.9343* 1.699715e-01 5.421673e-01
   1            W 0.0794 0.9343 0.4671  1.699715e-01 5.421673e-01
   2 B(1.1e-02) W 0.0559 0.4671 0.4671  1.205661e-01 4.890487e-01
   3 B(7.3e-02) W 0.5662 0.4671 0.0960  4.119560e-01 7.254441e-01
   3            W 0.0237 0.0960 0.1921  4.426507e-02 2.139252e-01
   4 B(8.8e-02) W 0.2306 0.1921 0.3842* 2.303135e-02 2.143943e-01
   4            W 0.4769 0.3842 0.1921  2.303135e-02 2.143943e-01
   5 B(1.9e-01) N        0.1375 0.2750  8.014508e-04 3.681498e-02
   6 B(1.7e-01) N        0.0162 0.0325  1.355741e-05 5.084627e-03
   7 B(1.3e-01) N        0.0070 0.0035  1.282776e-05 4.920962e-03
   8 B(1.8e-01) N        0.0028 0.0056  3.678140e-08 2.643592e-04
   9 B(1.9e-01) N        0.0001 0.0003  1.689182e-12 1.747622e-06
  10 B(1.9e-01) N        0.0000 0.0000  9.568768e-16 4.288618e-08
  11 B(1.9e-01) N        0.0000 0.0000  1.051357e-18 1.422036e-09
</pre>
<p>This is much simpler than the double dogleg report, since the single dogleg takes
either a steepest descent step, a convex combination of the steepest descent and Newton steps
or a full Newton step. The number in the column <code>Lambda</code> is the weight of the Newton step.
The single dogleg method is a special case of the double dogleg method with <code>eta</code> equal to 1.
It uses the same method of updating the trust region size as the double dogleg method.
</p>


<h3>Report for the hook step global method</h3>

<p>A sample iteration report for the global method <code>hook</code> is
(some intercolumn space has been removed to make the table fit)
</p>
<pre>
Iter         Jac       mu  dnorm    Dlt0   Dltn         Fnorm   Largest |f|
   0                                             2.886812e+00  2.250000e+00
   1  N(9.6e-03) H 0.1968 0.4909  0.4671 0.9343* 1.806293e-01  5.749418e-01
   1             H 0.0366 0.9381  0.9343 0.4671  1.806293e-01  5.749418e-01
   2  B(2.5e-02) H 0.1101 0.4745  0.4671 0.2336  1.797759e-01  5.635028e-01
   3  B(1.4e-01) H 0.0264 0.2341  0.2336 0.4671  3.768809e-02  2.063234e-01
   4  B(1.6e-01) N        0.0819  0.0819 0.1637  3.002274e-03  7.736213e-02
   5  B(1.8e-01) N        0.0513  0.0513 0.1025  5.355533e-05  1.018879e-02
   6  B(1.5e-01) N        0.0090  0.0090 0.0179  1.357039e-06  1.224357e-03
   7  B(1.5e-01) N        0.0004  0.0004 0.0008  1.846111e-09  6.070166e-05
   8  B(1.4e-01) N        0.0000  0.0000 0.0001  3.292896e-12  2.555851e-06
   9  B(1.5e-01) N        0.0000  0.0000 0.0000  7.281583e-18  3.800552e-09
</pre>
<p>The column headed by <code>mu</code> shows the Levenberg-Marquardt parameter when the Newton step is
larger than the trust region radius. The column headed by <code>dnorm</code> gives
the Euclidean norm of the step (adjustment of the current <code>x</code>) taken by the algorithm.
The absolute value of the difference with <code>Dlt0</code> is less than 0.1 times the trust region radius.
</p>
<p>After the column for the Jacobian the letters indicate the following
</p>

<dl>
<dt><code>H</code></dt><dd><p>a Levenberg-Marquardt restricted step is taken.</p>
</dd>
<dt><code>N</code></dt><dd><p>a normal full Newton step is taken.</p>
</dd>
</dl>

<p>The meaning of the columns headed by <code>Dlt0</code> and <code>Dltn</code> is identical to that of the same
columns for the double dogleg method.
The method of updating the trust region size is the same as in the double dogleg method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nleqslv">nleqslv</a></code></p>

<hr>
<h2 id='nleqslv-package'>Solve Systems of Nonlinear Equations</h2><span id='topic+nleqslv-package'></span><span id='topic+nleqslv.Intro'></span>

<h3>Description</h3>

<p>Solve a system of nonlinear equations using a Broyden or a Newton method
             with a choice of global strategies such as line search and trust region.
             There are options for using a numerical or user supplied Jacobian,
             for specifying a banded numerical Jacobian and for allowing
             a singular or ill-conditioned Jacobian.</p>


<h3>Details</h3>

<p>The <span class="pkg">nleqslv</span> package provides two algorithms for solving (dense) nonlinear systems of equations.
The methods provided are
</p>

<ul>
<li><p> a Broyden Secant method where the matrix of derivatives is updated after each major iteration
using the Broyden rank 1 update.
</p>
</li>
<li><p> a full Newton method where the Jacobian matrix of derivatives is recalculated at each iteration
</p>
</li></ul>

<p>Both methods utilize global strategies such as line search or trust region methods
whenever the standard Newton/Broyden step does not lead to a point closer to a root
of the equation system. Both methods can also be used without a norm reducing global strategy.
Line search may be either cubic, quadratic or geometric. The trust region methods are either
the double dogleg method, the Powell single dogleg method or a Levenberg-Marquardt type method.
</p>
<p>There is a facility for specifying that the Jacobian is banded; this can significantly
speedup the calculation of a numerical Jacobian when the number of sub- and super diagonals is small
compared to the size of the system of equations. For example the Jacobian of a tridiagonal system
can be calculated with only three evaluations of the function.
</p>
<p>The package provides an option to attempt to solve the system of equations
when the Jacobian is singular or ill-conditioned using an approximation to the
Moore-Penrose pseudoinverse of the Jacobian.
</p>
<p>The algorithms provided in this package are derived from Dennis and Schnabel (1996).
The code is written in Fortran 77 and Fortran 95
and uses Lapack and BLAS routines as provided by the R system.
</p>


<h3>References</h3>

<p>Dennis, J.E. Jr  and Schnabel, R.B. (1996), <em>Numerical Methods for Unconstrained Optimization
and Nonlinear Equations</em>, Siam.
</p>

<hr>
<h2 id='print.test.nleqslv'>Printing the result of <code>testnslv</code></h2><span id='topic+print'></span><span id='topic+print.test.nleqslv'></span>

<h3>Description</h3>

<p>Print method for <code>test.nleqslv</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'test.nleqslv'
print(x, digits=4, width.cutoff=45L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.test.nleqslv_+3A_x">x</code></td>
<td>
<p>a <code>test.nleqslv</code> object</p>
</td></tr>
<tr><td><code id="print.test.nleqslv_+3A_digits">digits</code></td>
<td>
<p>specifies the minimum number of significant digits to be printed in values.</p>
</td></tr>
<tr><td><code id="print.test.nleqslv_+3A_width.cutoff">width.cutoff</code></td>
<td>
<p>integer passed to <code><a href="base.html#topic+deparse">deparse</a></code> which sets the cutoff at which line-breaking is tried.</p>
</td></tr>
<tr><td><code id="print.test.nleqslv_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>print</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>print</code> method for objects inheriting from
class <code>test.nleqslv</code>. It prints the call to <code>testnslv</code> followed by the description of the experiment
(if the <code>title</code> argument was specified in the call to <code>testnslv</code>)
and the dataframe containing the results of <code>testnslv</code>.
</p>


<h3>Value</h3>

<p>It returns the object <code>x</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dslnex &lt;- function(x) {
    y &lt;- numeric(2)
    y[1] &lt;- x[1]^2 + x[2]^2 - 2
    y[2] &lt;- exp(x[1]-1) + x[2]^3 - 2
    y
}
xstart &lt;- c(1.5,0.5)
fstart &lt;- dslnex(xstart)
z &lt;- testnslv(xstart,dslnex)
print(z)
</code></pre>

<hr>
<h2 id='searchZeros'>Solve a nonlinear equation system with multiple roots
from multiple initial estimates</h2><span id='topic+searchZeros'></span>

<h3>Description</h3>

<p>This function solves a system of nonlinear equations with <code>nleqlsv</code>
for multiple initial estimates of the roots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchZeros(x, fn, digits=4, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchZeros_+3A_x">x</code></td>
<td>
<p>A matrix with each row containing an initial guess of the roots.</p>
</td></tr>
<tr><td><code id="searchZeros_+3A_fn">fn</code></td>
<td>
<p>A function of <code>x</code> returning a vector of function values
with the same length as the vector <code>x</code>.</p>
</td></tr>
<tr><td><code id="searchZeros_+3A_digits">digits</code></td>
<td>
<p>integer passed to <code><a href="base.html#topic+round">round</a></code>
for locating and removing duplicate rounded solutions.</p>
</td></tr>
<tr><td><code id="searchZeros_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+nleqslv">nleqslv</a></code>, <code>fn</code> and <code>jac</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row of <code>x</code> is a vector of initial estimates for the argument
<code>x</code> of <code>nleqslv</code>.
The function runs <code>nleqslv</code> for each row of the matrix <code>x</code>.
The first initial value is treated separately and slightly differently from the
other initial estimates. It is used to check if all
arguments in <code>...</code> are valid arguments for <code>nleqslv</code> and the function
to be solved. This is done by running <code>nleqslv</code> with no condition handling.
If an error is then detected an error message is issued and the function stops.
For the remaining initial estimates <code>nleqslv</code> is executed silently.
Only solutions for which the <code>nleqslv</code> termination code <code>tcode</code> equals <code>1</code>
are regarded as valid solutions. The rounded solutions (after removal of duplicates)
are used to order the solutions in increasing order.
These rounded solutions are not included in the return value of the function.
</p>


<h3>Value</h3>

<p>If no solutions are found <code>NULL</code> is returned.
Otherwise a list containing the following components is returned
</p>

<dl>
<dt><code>x</code></dt><dd><p>a matrix with each row containing a unique solution (unrounded)</p>
</dd>
<dt><code>xfnorm</code></dt><dd><p>a vector of the function criterion associated with each row of
the solution matrix <code>x</code>.</p>
</dd>
<dt><code>fnorm</code></dt><dd><p>a vector containing the function criterion for every converged result</p>
</dd>
<dt><code>idxcvg</code></dt><dd><p>a vector containing the row indices of the matrix
of initial estimates for which function value convergence
was achieved</p>
</dd>
<dt><code>idxxtol</code></dt><dd><p>a vector containing the row indices of the matrix
of initial estimates for which x-value convergence was achieved</p>
</dd>
<dt><code>idxnocvg</code></dt><dd><p>a vector containing the row indices of the matrix
of initial estimates which lead to an <code>nleqslv</code>
termination code &gt; 2</p>
</dd>
<dt><code>idxfatal</code></dt><dd><p>a vector containing the row indices of the matrix
of initial estimates for which a fatal error occurred
that made <code>nleqslv</code> stop</p>
</dd>
<dt><code>xstart</code></dt><dd><p>a matrix of the initial estimates
corresponding to the solution matrix</p>
</dd>
<dt><code>cvgstart</code></dt><dd><p>a matrix of all initial estimates
for which convergence was achieved</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Dennis Schnabel example 6.5.1 page 149 (two solutions)
set.seed(123)
dslnex &lt;- function(x) {
    y &lt;- numeric(2)
    y[1] &lt;- x[1]^2 + x[2]^2 - 2
    y[2] &lt;- exp(x[1]-1) + x[2]^3 - 2
    y
}
xstart &lt;- matrix(runif(50, min=-2, max=2),ncol=2)
ans &lt;- searchZeros(xstart,dslnex, method="Broyden",global="dbldog")
ans

# more complicated example
# R. Baker Kearfott, Some tests of Generalized Bisection,
# ACM Transactions on Methematical Software, Vol. 13, No. 3, 1987, pp 197-220

# A high-degree polynomial system (section 4.3 Problem 12)
# There are 12 real roots (and 126 complex roots to this system!)

hdp &lt;- function(x) {
    f &lt;- numeric(length(x))
    f[1] &lt;- 5 * x[1]^9 - 6 * x[1]^5 * x[2]^2 + x[1] * x[2]^4 + 2 * x[1] * x[3]
    f[2] &lt;- -2 * x[1]^6 * x[2] + 2 * x[1]^2 * x[2]^3 + 2 * x[2] * x[3]
    f[3] &lt;- x[1]^2 + x[2]^2 - 0.265625
    f
}


N &lt;- 40 # at least to find all 12 roots
set.seed(123)
xstart &lt;- matrix(runif(3*N,min=-1,max=1), N, 3)  # N initial guesses, each of length 3
ans &lt;- searchZeros(xstart,hdp, method="Broyden",global="dbldog")
ans$x
</code></pre>

<hr>
<h2 id='testnslv'>Test different methods for solving with <code>nleqslv</code></h2><span id='topic+testnslv'></span>

<h3>Description</h3>

<p>The function tests different methods and global strategies for solving a system of nonlinear equations with <code>nleqslv</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testnslv(x, fn, jac=NULL, ...,
          method = c("Newton", "Broyden"),
          global = c("cline", "qline", "gline", "pwldog", "dbldog", "hook", "none"),
          Nrep=0L, title=NULL
        )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testnslv_+3A_x">x</code></td>
<td>
<p>A numeric vector with an initial guess of the root.</p>
</td></tr>
<tr><td><code id="testnslv_+3A_fn">fn</code></td>
<td>
<p>A function of <code>x</code> returning the function values.</p>
</td></tr>
<tr><td><code id="testnslv_+3A_jac">jac</code></td>
<td>
<p>A function to return the Jacobian for the <code>fn</code> function.
For a vector valued function <code>fn</code> the Jacobian must be a numeric
matrix of the correct dimensions.
For a scalar valued function <code>fn</code> the <code>jac</code> function may return a scalar.
If not supplied numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="testnslv_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>fn</code> and <code>jac</code> and <code><a href="#topic+nleqslv">nleqslv</a></code>.</p>
</td></tr>
<tr><td><code id="testnslv_+3A_method">method</code></td>
<td>
<p>The methods to use for finding a solution.</p>
</td></tr>
<tr><td><code id="testnslv_+3A_global">global</code></td>
<td>
<p>The global strategies to test. The argument may consist of several possibly abbreviated items.</p>
</td></tr>
<tr><td><code id="testnslv_+3A_nrep">Nrep</code></td>
<td>
<p>Number of repetitions to apply. Default is no repetitions.</p>
</td></tr>
<tr><td><code id="testnslv_+3A_title">title</code></td>
<td>
<p>a description of this experiment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function solves the function <code>fn</code> with <code><a href="#topic+nleqslv">nleqslv</a></code> for the specified methods and global strategies.
When argument <code>Nrep</code> has been set to a number greater than or equal to 1,
repetitions of the solving process are performed and the used CPU time in seconds is recorded.
</p>
<p>If checking a user supplied jacobian is enabled, then <code>testnslv</code> will stop immediately when a possibly
incorrect jacobian is detected.
</p>


<h3>Value</h3>

<p><code>testnslv</code> returns an object of class <code>"test.nleqslv"</code> which is a list containing the following elements
</p>

<dl>
<dt><code>call</code></dt><dd><p>the matched call</p>
</dd>
<dt><code>out</code></dt><dd><p> a dataframe containing the results with the following columns
</p>

<dl>
<dt><code>Method</code></dt><dd><p>method used.</p>
</dd>
<dt><code>Global</code></dt><dd><p>global strategy used.</p>
</dd>
<dt><code>termcd</code></dt><dd><p>termination code of <code>nleqslv</code>.</p>
</dd>
<dt><code>Fcnt</code></dt><dd><p>number of function evaluations used by the method and global strategy.
This excludes function evaluations made when computing a numerical Jacobian.</p>
</dd>
<dt><code>Jcnt</code></dt><dd><p>number of Jacobian evaluations.</p>
</dd>
<dt><code>Iter</code></dt><dd><p>number of outer iterations used by the algorithm.</p>
</dd>
<dt><code>Message</code></dt><dd><p>a string describing the termination code in an abbreviated form.</p>
</dd>
<dt><code>Fnorm</code></dt><dd><p>square of the euclidean norm of the vector of function results divided by 2.</p>
</dd>
<dt><code>cpusecs</code></dt><dd><p>CPU seconds used by the requested number of repetitions (only present when
argument <code>Nrep</code> is not 0).</p>
</dd>
</dl>

</dd>
<dt><code>title</code></dt><dd><p>the description if specified</p>
</dd>
</dl>

<p>The abbreviated strings are
</p>

<dl>
<dt><code>Fcrit</code></dt><dd><p>Convergence of function values has been achieved.</p>
</dd>
<dt><code>Xcrit</code></dt><dd><p>This means that the relative distance between two
consecutive x-values is smaller than <code>xtol</code>.</p>
</dd>
<dt><code>Stalled</code></dt><dd><p>The algorithm cannot find an acceptable new point.</p>
</dd>
<dt><code>Maxiter</code></dt><dd><p>Iteration limit <code>maxit</code> exceeded.</p>
</dd>
<dt><code>Illcond</code></dt><dd><p>Jacobian is too ill-conditioned.</p>
</dd>
<dt><code>Singular</code></dt><dd><p>Jacobian is singular.</p>
</dd>
<dt><code>BadJac</code></dt><dd><p>Jacobian is unusable.</p>
</dd>
<dt><code>ERROR</code></dt><dd><p><code>nleqslv</code> stopped because of a fatal error.</p>
</dd>
</dl>



<h3>Warning</h3>

<p>Any <code>nleqslv</code> error message will be displayed immediately and
an error for the particular combination of method and global strategy will be recorded in the final dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dslnex &lt;- function(x) {
    y &lt;- numeric(2)
    y[1] &lt;- x[1]^2 + x[2]^2 - 2
    y[2] &lt;- exp(x[1]-1) + x[2]^3 - 2
    y
}
xstart &lt;- c(0.5,0.5)
fstart &lt;- dslnex(xstart)
testnslv(xstart,dslnex)
# this will encounter an error
xstart &lt;- c(2.0,0.5)
fstart &lt;- dslnex(xstart)
testnslv(xstart,dslnex)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
