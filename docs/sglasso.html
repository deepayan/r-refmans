<!DOCTYPE html><html><head><title>Help for package sglasso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sglasso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fglasso'><p>L1-penalized Factorial Graphical Lasso Model</p></a></li>
<li><a href='#gplot'><p>Plotting Sparse Graph</p></a></li>
<li><a href='#gplot.fglasso'><p>Plotting Sparse Factorial Dynamic Gaussian Graphical Model</p></a></li>
<li><a href='#gplot.sglasso'><p>Plotting Sparse Graphs</p></a></li>
<li><a href='#Kh'><p>Extract Sparse Structured Precision Matrices</p></a></li>
<li><a href='#klcv'><p>Cross-Validated Kullback-Leibler Divergence</p></a></li>
<li><a href='#loglik'><p>Extract Log-Likelihood</p></a></li>
<li><a href='#neisseria'>
<p>Neisseria Data Set</p></a></li>
<li><a href='#plot.klcv'><p>Plot Method for Leave-One-Out Cross-Validated Kullback-Leibler Divergence</p></a></li>
<li><a href='#plot.sglasso'><p>Plot Method for the Weighted l1-Penalized RCON(V, E) Model</p></a></li>
<li><a href='#sglasso'><p>Lasso Method for the RCON(V, E) Models</p></a></li>
<li><a href='#sglasso-internal'><p>Internal sglasso functions</p></a></li>
<li><a href='#sglasso-package'>
<p>Lasso Method for RCON(V, E) Models</p></a></li>
<li><a href='#summary.sglasso'><p>Summarizing sglasso Fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Lasso Method for RCON(V,E) Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Luigi Augugliaro</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luigi Augugliaro &lt;luigi.augugliaro@unipa.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, igraph, R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, graphics, grDevices</td>
</tr>
<tr>
<td>Description:</td>
<td>RCON(V, E) models are a kind of restriction of the Gaussian Graphical Models defined by a set of equality constraints on the entries of the concentration matrix. 'sglasso' package implements the structured graphical lasso (sglasso) estimator proposed in Abbruzzo et al. (2014) for the weighted l1-penalized RCON(V, E) model. Two cyclic coordinate algorithms are implemented to compute the sglasso estimator, i.e. a cyclic coordinate minimization (CCM) and a cyclic coordinate descent (CCD) algorithm.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.unipa.it/persone/docenti/a/luigi.augugliaro">http://www.unipa.it/persone/docenti/a/luigi.augugliaro</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-03 08:10:33 UTC; francesca</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-03 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fglasso'>L1-penalized Factorial Graphical Lasso Model</h2><span id='topic+fglasso'></span>

<h3>Description</h3>

<p>Fit the weight l1-penlized factorial dynamic Gaussian Graphical Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fglasso(S, model, tp, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fglasso_+3A_s">S</code></td>
<td>
<p>the empirical variance/covariance matrix;</p>
</td></tr>
<tr><td><code id="fglasso_+3A_model">model</code></td>
<td>
<p>a list or a matrix used to specify the factorial dynamic Gaussian Graphical Model (see Details);</p>
</td></tr>
<tr><td><code id="fglasso_+3A_tp">tp</code></td>
<td>
<p>number of time points;</p>
</td></tr>
<tr><td><code id="fglasso_+3A_p">p</code></td>
<td>
<p>number of random variables observed for each time point;</p>
</td></tr>
<tr><td><code id="fglasso_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>sglasso</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factorial dynamic Gaussian Graphical Model (Abbruzzo et al., 2015) is a special kind of <em>RCON(V, E)</em> model (Hojsgaard, et al.,2008) proposed to study dynamic networks. Let <code class="reqn">X_t = (X_{it},\ldots,X_{it})'</code> be a <code class="reqn">p</code>-dimensional random variable at time <code class="reqn">t</code>. Assuming that <code class="reqn">X = (X'_1,\ldots,X'_T)</code> follows a multivariate normal distribution, the concentration matrix <code class="reqn">K</code> has the following block structure
</p>
<p style="text-align: center;"><code class="reqn">
K = \left(
\begin{array}{cccc}
K_{1,1} &amp; K_{1,2} &amp; \ldots &amp; K_{1,T}\\
K_{2,1} &amp; K_{2,2} &amp; \ldots &amp; K_{2,T}\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
K_{T,1} &amp; K_{T,2} &amp; \ldots &amp; K_{T,T}
\end{array}\right),
</code>
</p>

<p>where <code class="reqn">K_{t,t}</code> give information about the conditinal independence structure among the <code class="reqn">p</code> random variables at time <code class="reqn">t</code>, and <code class="reqn">K_{t,t + h}</code> give information about the conditional independence structure between <code class="reqn">X_t</code> and <code class="reqn">X_{t + h}</code>. An interpretation of the elements of the submatrices <code class="reqn">K_{t,t + h}</code> brings to the notion of natural structure, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">
K_{t,t + h} = \left(
\begin{array}{cccc}
k_{1,1}^{t,t+h} &amp; 0 &amp; \ldots &amp; 0\\
0 &amp; k_{2,2}^{t,t+h} &amp; \ldots &amp; 0\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
0 &amp; 0 &amp; \ldots &amp; k_{p,p}^{t,t+h}
\end{array}\right) + \left(
\begin{array}{cccc}
0 &amp; k_{1,2}^{t,t+h} &amp; \ldots &amp; k_{1,p}^{t,t+h}\\
k_{2,1}^{t,t+h} &amp; 0 &amp; \ldots &amp; 0\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
k_{p,1}^{t,t+h} &amp; k_{p,2}^{t,t+h} &amp; \ldots &amp; 0
\end{array}\right).
</code>
</p>

<p>The entries of the first matrix are called <b>self-self conditinal dependences</b> at temporal lag <code class="reqn">h</code> and represents the (negative) self-similarity of a given random variable across different time points. The entries of the second matrix are the <b>conditional dependence</b> among the <code class="reqn">p</code> random variables. To make the interpretation of the results more relevant and, at the same time, reduce the number of parameters, the authors propose the following equality constraints:
</p>

<table>
<tr>
 <td style="text-align: center;">
</td><td style="text-align: left;"> <code class="reqn">k_{i,i}^{t,t+h}</code> </td><td style="text-align: center;"> effect </td><td style="text-align: center;"> <code>R</code> code </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code class="reqn">k_{i,j}^{t,t+h}</code> </td><td style="text-align: center;"> effect </td><td style="text-align: center;"> <code>R</code> code </td>
</tr>
<tr>
 <td style="text-align: center;">
i.	</td><td style="text-align: left;"> <code class="reqn">0</code> </td><td style="text-align: center;"> zero </td><td style="text-align: center;"> <code>"."</code> </td><td style="text-align: center;"> iv. </td><td style="text-align: left;"> <code class="reqn">0</code> </td><td style="text-align: center;"> zero </td><td style="text-align: center;"> <code>"."</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
ii.	</td><td style="text-align: left;"> <code class="reqn">s^h</code> </td><td style="text-align: center;"> costant </td><td style="text-align: center;"> <code>"c"</code> </td><td style="text-align: center;"> ii. </td><td style="text-align: left;"> <code class="reqn">n^h</code> </td><td style="text-align: center;"> costant </td><td style="text-align: center;"> <code>"c"</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
iii.</td><td style="text-align: left;"> <code class="reqn">s^h_i</code> </td><td style="text-align: center;"> unit </td><td style="text-align: center;"> <code>"u"</code> </td><td style="text-align: center;"> iii. </td><td style="text-align: left;"> <code class="reqn">n^h_i</code> </td><td style="text-align: center;"> unit </td><td style="text-align: center;"> <code>"u"</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
iv.	</td><td style="text-align: left;"> <code class="reqn">s^{t,h}</code> </td><td style="text-align: center;"> time </td><td style="text-align: center;"> <code>"t"</code> </td><td style="text-align: center;"> iv. </td><td style="text-align: left;"> <code class="reqn">n^{t,h}</code> </td><td style="text-align: center;"> time </td><td style="text-align: center;"> <code>"t"</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
v.	</td><td style="text-align: left;"> <code class="reqn">s^{t,h}_i</code> </td><td style="text-align: center;"> interaction </td><td style="text-align: center;"> <code>"ut"</code> </td><td style="text-align: center;"> v. </td><td style="text-align: left;"> <code class="reqn">n^{t,h}_{i,j}</code> </td><td style="text-align: center;"> interaction </td><td style="text-align: center;"> <code>"ut"</code>
</td>
</tr>

</table>

<p>Argument <code>model</code> is used to specify the restrinctions previously describted. This argument can be a named list or a matrix with dimension <code class="reqn">nlag\times 2</code>, where <code class="reqn">nlag\le\code{tp}</code>. To gain more insight, suppose that we want to model only the sub-matrices <code class="reqn">K_{t,t}</code> and <code class="reqn">K_{t,t+1}</code>, i.e., the sub-matrices corresponding to the temporal lag zero and one. A possible <code>R code</code> is<br />
</p>
<p><code>model.mat &lt;- matrix("", nrow = 2, ncol = 2)</code><br />
<code>rownames(model.mat) &lt;- c("lag0", "lag1")</code><br />
<code>colnames(model.mat) &lt;- c("s", "n")</code><br />
<code>model.mat[1, ] &lt;- c("c", "ut")</code><br />
<code>model.mat[2, ] &lt;- c("t", ".")</code><br />
</p>
<p>In this example we are modelling the diagonal elements of the sub-matrices <code class="reqn">K_{t,t}</code> with the constant effect while the off-diagonal elements are modelled by the interaction effect. In the same way, the diagonal elements of the sub-matrices <code class="reqn">K_{t,t+1}</code> are modelled by the time effect while the remaning elements are equal to zero. The <code>fglasso</code> function passes the matrix <code>model.mat</code> to the internal function <code>fglasso_model2mask</code>, i.e.,<br /> 
</p>
<p><code>mask &lt;- fglasso_model2mask(model.mat, tp = 3, p = 3)</code><br />
</p>
<p>which returns the mask used in <code>sglasso</code> to fit the specified factorial dynamic Gaussian Graphical model. The same model can be specified by the following named list<br />
</p>
<p><code>model.list &lt;- list(lag0 = c(s = "c", n = "ut"), lag1 = c(s = "t", n = "."))</code><br />
</p>
<p>See the example below for more details.
</p>


<h3>Value</h3>

<p><code>fglasso</code> returns an obejct with S3 class <code>"sglasso"</code>. See the corresponding manual for more details.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a>
</p>


<h3>References</h3>

<p>Wit, E. C. and Abbruzzo, A.(2015) Dynamic factorial graphical models for dynamic networks. <em>Network Science</em>, Vol. <b>3(1)</b>, 37&ndash; 57
<br />
</p>
<p>Abbruzzo, A., Augugliaro, L., Mineo, A.M. and Wit, E.C. (2014) Cyclic coordinate for penalized Gaussian Graphical Models with symmetry restrictions. In <em>Proceeding of COMPSTAT 2014 - 21th International Conference on Computational Statistics</em>. Geneva, August 19-24, 2014.
<br />
</p>
<p>Hojsgaard, S. and Lauritzen, S.L. (2008) Graphical gaussian models with edge and vertex symmetries. <em>J. Roy. Statist. Soc. Ser. B.</em>, Vol. <b>70(5)</b>, 1005&ndash;1027.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sglasso">sglasso</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################
# fglasso solution path
#######################
N &lt;- 50
tp &lt;- 3
p &lt;- 3
X &lt;- matrix(rnorm(N * p * tp), N, tp * p)
S &lt;- crossprod(X) / N
model &lt;- list(lag0 = c(s = "c", n = "ut"), lag1 = c(s = "t", n = "."))
out.fglasso &lt;- fglasso(S = S, model = model, tp = tp, p = p)
out.fglasso
</code></pre>

<hr>
<h2 id='gplot'>Plotting Sparse Graph</h2><span id='topic+gplot'></span>

<h3>Description</h3>

<p><code>gplot</code> is a generic function for plotting sparse graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gplot_+3A_object">object</code></td>
<td>
<p>fitted <code>sglasso</code>/<code>fglasso</code> object;</p>
</td></tr>
<tr><td><code id="gplot_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>gplot.sglasso</code> or <code>gplot.fglasso</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gplot</code> is a generic function used to plot a graph estimated by <code>sglasso</code> or <code>fglasso</code>. See the method function <code>gplot.sglasso</code> or <code>gplot.fglasso</code> for more details about the specific arguments.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gplot.sglasso">gplot.sglasso</a></code> and <code><a href="#topic+gplot.fglasso">gplot.fglasso</a></code> method functions.
</p>

<hr>
<h2 id='gplot.fglasso'>Plotting Sparse Factorial Dynamic Gaussian Graphical Model</h2><span id='topic+gplot.fglasso'></span>

<h3>Description</h3>

<p><code>gplot.fglasso</code> shows the sequence of graphs estimated by <code>fglasso</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fglasso'
gplot(object, rhoid, tp = c(1, 2), sub.tp1, sub.tp2, cex.sub = 1, 
    k = 1.5, layout = layout.circle, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gplot.fglasso_+3A_object">object</code></td>
<td>
<p>fitted <code>fglasso</code> object;</p>
</td></tr>
<tr><td><code id="gplot.fglasso_+3A_rhoid">rhoid</code></td>
<td>
<p>an integer used to specificy the <code class="reqn">\rho</code>-value used to fit the fglasso model;</p>
</td></tr>
<tr><td><code id="gplot.fglasso_+3A_tp">tp</code></td>
<td>
<p>a vector of length equal to two used to specify the time points of the two graphs that will be compared. By default the first two time points are used;</p>
</td></tr>
<tr><td><code id="gplot.fglasso_+3A_sub.tp1">sub.tp1</code></td>
<td>
<p>sub title for the graph estimated at time point <code>tp[1]</code>;</p>
</td></tr>
<tr><td><code id="gplot.fglasso_+3A_sub.tp2">sub.tp2</code></td>
<td>
<p>sub title for the graph estimated at time point <code>tp[2]</code>;</p>
</td></tr>
<tr><td><code id="gplot.fglasso_+3A_cex.sub">cex.sub</code></td>
<td>
<p>a numerical value giving the amount by which plotting sub titles should be magnified relateve to the default;</p>
</td></tr>
<tr><td><code id="gplot.fglasso_+3A_k">k</code></td>
<td>
<p>value used to specify the distance between the two graphs;</p>
</td></tr>
<tr><td><code id="gplot.fglasso_+3A_layout">layout</code></td>
<td>
<p>a function or a matrix used to specify the layout of the graphs that will be plotted. By default the <code>layout.circle</code> function is used;</p>
</td></tr>
<tr><td><code id="gplot.fglasso_+3A_...">...</code></td>
<td>
<p>further graphical parameters used to plot the graphs. See package <span class="pkg">igraph</span> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given value of the tuning parameter, specified by the argument <code>rhoid</code>, <code>gplot.fglasso</code> shows the graphs estimated at the time points <code>tp[1]</code> and <code>tp[2]</code>. By convention, the graph associated to the sub matrix <code class="reqn">K_{tp[1],tp[2]}</code> is represented by a directed graph where a directed edge is drawn by an arrow from a vertex in the first graph pointing forwards a vertex in the second graph.
</p>


<h3>Value</h3>

<p><code>gplot.fglasso</code> returns a list with components:
</p>
<table>
<tr><td><code>graph.tp1</code></td>
<td>
<p>an object with class <code>igraph</code> representing the undirected graph estimated at the time point <code>tp[1]</code>;</p>
</td></tr>
<tr><td><code>graph.tp2</code></td>
<td>
<p>an object with class <code>igraph</code> representing the undirected graph estimated at the time point <code>tp[2]</code>;</p>
</td></tr>
<tr><td><code>graph.net</code></td>
<td>
<p>an object with class <code>igraph</code> representing the directed graph associated to the submatrix <code class="reqn">K_{tp[1],tp[2]}</code>;</p>
</td></tr>
<tr><td><code>layout</code></td>
<td>
<p>the matrix used to specify the placement of the vertices.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fglasso">fglasso</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 50
tp &lt;- 3
p &lt;- 3
X &lt;- matrix(rnorm(N * p * tp), N, tp * p)
S &lt;- crossprod(X) / N
model &lt;- list(lag0 = c(s = "c", n = "ut"), lag1 = c(s = "t", n = "t"))
out.fglasso &lt;- fglasso(S = S, model = model, tp = tp, p = p)
gplot(out.fglasso, rhoid = 50, sub.tp1 = "First graph", 
   sub.tp2 = "Second graph")
</code></pre>

<hr>
<h2 id='gplot.sglasso'>Plotting Sparse Graphs</h2><span id='topic+gplot.sglasso'></span>

<h3>Description</h3>

<p><code>gplot.sglasso</code> shows the sequence of graphs estimated by <code>sglasso</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sglasso'
gplot(object, rhoid, layout = layout.circle, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gplot.sglasso_+3A_object">object</code></td>
<td>
<p>fitted <code>sglasso</code> object;</p>
</td></tr>
<tr><td><code id="gplot.sglasso_+3A_rhoid">rhoid</code></td>
<td>
<p>vector of integers used to specificy the <code class="reqn">\rho</code>-values used to fit the sglasso model. By default <code>gplot.sglasso</code> shows the sequence of graphs estimated by <code>sglasso</code>. Only topologically different graphs are plotted;</p>
</td></tr>
<tr><td><code id="gplot.sglasso_+3A_layout">layout</code></td>
<td>
<p>a function or a matrix used to specify the layout of the graphs that will be plotted. By default the <code>layout.circle</code> function is used;</p>
</td></tr>
<tr><td><code id="gplot.sglasso_+3A_...">...</code></td>
<td>
<p>further graphical parameters used to plot the graphs. See package <span class="pkg">igraph</span> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gplot.sglasso</code> shows the sequence of topologically different graphs estimated by <code>sglasso</code>. To specify the layout of the graphs, the user can use any layout function available in the R package <span class="pkg">igraph</span>. The user can also specify the placement of the vertices by a matrix with two columns and the same number of rows as the number of vertices.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sglasso">sglasso</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
p &lt;- 5
X &lt;- matrix(rnorm(N * p), N, p)
S &lt;- crossprod(X)/N
mask &lt;- outer(1:p, 1:p, function(i,j) 0.5^abs(i-j))
mask[1,5] &lt;- mask[1,4] &lt;- mask[2,5] &lt;- NA
mask[5,1] &lt;- mask[4,1] &lt;- mask[5,2] &lt;- NA
out.sglasso_path &lt;- sglasso(S, mask, tol = 1.0e-13)
gplot(out.sglasso_path)
gplot(out.sglasso_path, rhoid = 1:5)
</code></pre>

<hr>
<h2 id='Kh'>Extract Sparse Structured Precision Matrices</h2><span id='topic+Kh'></span>

<h3>Description</h3>

<p>Function <code>Kh</code> computes the sequence of sparse structured precision matrices estimated by <code>sglasso</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kh(object, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kh_+3A_object">object</code></td>
<td>
<p>fitted <code>sglasso</code> object;</p>
</td></tr>
<tr><td><code id="Kh_+3A_rho">rho</code></td>
<td>
<p>a subset of the values of the tuning parameter used in <code>sglasso</code> to compute the solution path. By default, the entire sequence of estimated sparse structured precision matrices is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Kh</code> returns a named list containing the sequence of estimated sparse structured precision matrices.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sglasso">sglasso</a></code> function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
p &lt;- 5
X &lt;- matrix(rnorm(N * p), N, p)
S &lt;- crossprod(X) / N
mask &lt;- outer(1:p, 1:p, function(i, j) 0.5^abs(i - j))
out.sglasso_path &lt;- sglasso(S, mask, nrho = 5, tol = 1.0e-13)
out.sglasso_path
Kh(out.sglasso_path)
rho &lt;- out.sglasso_path$rho[3]
out.sglasso_single &lt;- sglasso(S, mask, nrho = 1, min_rho = rho, 
   tol = 1.0e-13, algorithm = "ccm")
Kh(out.sglasso_single)
</code></pre>

<hr>
<h2 id='klcv'>Cross-Validated Kullback-Leibler Divergence</h2><span id='topic+klcv'></span><span id='topic+print.klcv'></span>

<h3>Description</h3>

<p>Model selection criterion based on the leave-one-out cross-validated Kullback-Leibler divergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>klcv(object, X, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="klcv_+3A_object">object</code></td>
<td>
<p>fitted <code>sglasso</code>/<code>fglasso</code> object;</p>
</td></tr>
<tr><td><code id="klcv_+3A_x">X</code></td>
<td>
<p>the matrix used to compute the empirical variance/covariance matrix. Its dimension is <code>N</code> <code class="reqn">\times</code> <code>p</code>, where <code>p</code> is the number of random variables and <code>N</code> is the samlpe size;</p>
</td></tr>
<tr><td><code id="klcv_+3A_scale">scale</code></td>
<td>
<p>scalar value used to scale the estimated degrees-of-freedom. See below for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>klcv</code> function implements the leave-one-out cross-validate Kullback-Leibler divergence criterion proposed in Vujacic et al. (2015). For <code class="reqn">l_1</code>-penalized Gaussian Graphical Models this measure of goodness-of-fit has the following form </p>
<p style="text-align: center;"><code class="reqn">klcv(\rho) = -\frac{\ell(\hat K(\rho))}{N} + \frac{\code{scale}}{2N} gdf(\hat K(\rho)),</code>
</p>
<p> where <code class="reqn">\hat K(\rho)</code> is the glasso estimate of the concentration matrix, <code class="reqn">\ell(\hat K(\rho))</code> is the corresponding value of the log-likelihood function, <code>scale</code> is a scale factor for the complexity part, i.e. <code class="reqn">gdf(\hat K(\rho))</code>, which is defined as </p>
<p style="text-align: center;"><code class="reqn">gdf(\hat K(\rho)) = \frac{1}{N-1}\sum_{k=1}^N vec\{(\hat K(\rho)^{-1} - S_k)\circ 1_\rho\}'vec[\hat K(\rho)\{(S-S_k)\circ 1_\rho\}\hat K(\rho)].</code>
</p>
<p> In the previous expression <code class="reqn">S</code> is the empirical variance/covariance matrix, <code class="reqn">S_k = X_k X_k'</code>, <code class="reqn">1_\rho</code> is a matrix with entries <code class="reqn">I(\hat k_{ij}(\rho)\ne 0)</code> and <code class="reqn">\circ</code> is the Hadamard product operator.
</p>


<h3>Value</h3>

<p><code>klcv</code> returns an S3 object with calls <code>klcv</code>, i.e. a named list with the following components:
</p>
<table>
<tr><td><code>klcv</code></td>
<td>
<p>the vector with the leave-one-out cross-validated Kullback-Leibler divergence;</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>the rho-values used to compute the leave-one-out cross-validated Kullback-Leibler divergence;</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>a vector with the log-likelihood computed for the sequence of weighted l1-penalized <em>RCON(V, E);</em></p>
</td></tr>
<tr><td><code>gdf</code></td>
<td>
<p>a vector returning the generalized degrees-of-freedom;</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scale value used to define the leave-one-out cross-validated Kullback-Leibler divergence;</p>
</td></tr>
<tr><td><code>min.klcv</code></td>
<td>
<p>minimum value of the leave-one-out cross-validated Kullback-Leibler divergence;</p>
</td></tr>
<tr><td><code>rho.opt</code></td>
<td>
<p>the rho-value corresponding to minimum leave-one-out cross-validated Kullback-Leibler divergence;</p>
</td></tr>
<tr><td><code>rhoid</code></td>
<td>
<p>the index of the rho-value identified by the leave-one-out cross-validated Kullback-Leibler divergence.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>References</h3>

<p>Vujacic, I., Abbruzzo, A. and Wit, E. C. (2015) A computationally fast alternative to cross-validation in penalized Gaussian graphical models. <em>J. Stat. Comput. Simul.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sglasso">sglasso</a></code>, <code><a href="#topic+loglik">loglik</a></code> functions and <code><a href="#topic+plot.klcv">plot.klcv</a></code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
p &lt;- 5
X &lt;- matrix(rnorm(N * p), N, p)
S &lt;- crossprod(X) / N
mask &lt;- outer(1:p, 1:p, function(i,j) 0.5^abs(i-j))
mask[1,5] &lt;- mask[1,4] &lt;- mask[2,5] &lt;- NA
mask[5,1] &lt;- mask[4,1] &lt;- mask[5,2] &lt;- NA
out.sglasso_path &lt;- sglasso(S, mask, tol = 1.0e-13)
out.klcv &lt;- klcv(out.sglasso_path, X)
out.klcv
</code></pre>

<hr>
<h2 id='loglik'>Extract Log-Likelihood</h2><span id='topic+loglik'></span>

<h3>Description</h3>

<p>This function extracts the log-likelihood for the sequence of weighted l1-penalized <em>RCON(V, E)</em> models estimated by <code>sglasso</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik(object, N = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_+3A_object">object</code></td>
<td>
<p>a fitted <code>sglasso</code> object;</p>
</td></tr>
<tr><td><code id="loglik_+3A_n">N</code></td>
<td>
<p>sample size. Default value is 2 to remove the constant term in the log-likelihood function. See below for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denoted with <code class="reqn">\psi = (\eta',\theta')'</code> the parameter vector of the structured concentration matrix <code class="reqn">K(\psi)</code>, the log-likelihood function of the <em>RCON(V, E)</em> model is equal, up to a constant, to the following expression </p>
<p style="text-align: center;"><code class="reqn">\ell(\psi) = \frac{N}{2}[\log det K(\psi) - tr\{S K(\psi)\}],</code>
</p>
<p> where <code class="reqn">S = N^{-1}\sum_{i=1}^NX_iX_i^T</code>, <code class="reqn">N</code> is the sample size and <code class="reqn">X_i</code> is the <code class="reqn">i</code>th observed <code class="reqn">p</code>-dimensional vector. Denoted with <code class="reqn">\hat\psi = (\hat\eta',\hat\theta')'</code> the sglasso estimates, straightforward algebra shows that </p>
<p style="text-align: center;"><code class="reqn">\ell(\hat\psi) = \frac{N}{2}[\log det K(\hat\psi) - p + \rho\sum_{m=1}^S w_m|\hat\theta_m|],</code>
</p>
<p> where <code class="reqn">\rho</code> is the tuning parameter and <code class="reqn">w_m</code> are the weights used to define the weighted l1-norm.
</p>


<h3>Value</h3>

<p><code>loglik</code> returns a vector containing the log-likelihood computed for the sequence of weighted l1-penalized <em>RCON(V, E)</em>.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br />
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.sglasso">summary.sglasso</a></code> method and <code><a href="#topic+sglasso">sglasso</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
p &lt;- 5
X &lt;- matrix(rnorm(N * p), N, p)
S &lt;- crossprod(X) / N
mask &lt;- outer(1:p, 1:p, function(i, j) 0.5^abs(i-j))
out.sglasso_path &lt;- sglasso(S, mask, nrho = 5, tol = 1.0e-13)
out.sglasso_path
loglik(out.sglasso_path, N = N)
rho &lt;- out.sglasso_path$rho[3]
out.sglasso_single &lt;- sglasso(S, mask, nrho = 1, min_rho = rho, 
   tol = 1.0e-13, algorithm = "ccm")
loglik(out.sglasso_single, N = N)
</code></pre>

<hr>
<h2 id='neisseria'>
Neisseria Data Set
</h2><span id='topic+neisseria'></span>

<h3>Description</h3>

<p>This data set contains the gene expression data from a high-resolution time-course experiment besed on the sequenced Neisseria meningitidis serogroup strain B strain MC58. Specifically, the expression level of ten genes is measured at ten different time points. Each column is standardized to have zero mean and standard deviation equal to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("neisseria")</code></pre>

<hr>
<h2 id='plot.klcv'>Plot Method for Leave-One-Out Cross-Validated Kullback-Leibler Divergence</h2><span id='topic+plot.klcv'></span>

<h3>Description</h3>

<p><code>plot.klcv</code> produces a plot to study the sequence of leave-one-out cross-validated Kullback-Leibler divergences computed by <code>klcv</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'klcv'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.klcv_+3A_x">x</code></td>
<td>
<p>fitted <code>klcv</code> object;</p>
</td></tr>
<tr><td><code id="plot.klcv_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through the plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method function produces a plot showing the sequence of leave-one-out cross-validated Kullback-Leibler as function of the tuning parameter <code class="reqn">rho</code>. The optimal value of the tuning parameter is identified by a vertical dashed line.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+klcv">klcv</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
p &lt;- 5
X &lt;- matrix(rnorm(N * p), N, p)
S &lt;- crossprod(X) / N
mask &lt;- outer(1:p, 1:p, function(i,j) 0.5^abs(i-j))
mask[1,5] &lt;- mask[1,4] &lt;- mask[2,5] &lt;- NA
mask[5,1] &lt;- mask[4,1] &lt;- mask[5,2] &lt;- NA
out.sglasso_path &lt;- sglasso(S, mask, tol = 1.0e-13)
out.klcv &lt;- klcv(out.sglasso_path, X)
plot(out.klcv)
</code></pre>

<hr>
<h2 id='plot.sglasso'>Plot Method for the Weighted l1-Penalized RCON(V, E) Model</h2><span id='topic+plot.sglasso'></span>

<h3>Description</h3>

<p><code>plot.sglasso</code> produces two plots to study the sequence of models estimates by <code>sglasso</code> or <code>fglasso</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sglasso'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sglasso_+3A_x">x</code></td>
<td>
<p>fitted <code>sglasso</code>/<code>fglasso</code> object;</p>
</td></tr>
<tr><td><code id="plot.sglasso_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through the plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces two different plots. The first one shows the path of the estimated parameters as function of the tuning parameter <code class="reqn">\rho</code>. In the same way, the second plot shows the path of the weighted scores as function of <code class="reqn">\rho</code>.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sglasso">sglasso</a></code> function and <code><a href="#topic+summary.sglasso">summary.sglasso</a></code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
p &lt;- 5
X &lt;- matrix(rnorm(N * p), N, p)
S &lt;- crossprod(X)/N
mask &lt;- outer(1:p, 1:p, function(i,j) 0.5^abs(i-j))
mask[1,5] &lt;- mask[1,4] &lt;- mask[2,5] &lt;- NA
mask[5,1] &lt;- mask[4,1] &lt;- mask[5,2] &lt;- NA
out.sglasso_path &lt;- sglasso(S, mask, tol = 1.0e-13)
plot(out.sglasso_path)
</code></pre>

<hr>
<h2 id='sglasso'>Lasso Method for the RCON(V, E) Models</h2><span id='topic+sglasso'></span><span id='topic+print.sglasso'></span>

<h3>Description</h3>

<p>Fit the weighted l1-penalized <em>RCON(V, E)</em> models using a cyclic coordinate algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sglasso(S, mask, w = NULL, flg = NULL, min_rho = 1.0e-02, nrho = 50,  
        nstep = 1.0e+05, algorithm = c("ccd","ccm"), truncate = 1e-05, 
        tol = 1.0e-03)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sglasso_+3A_s">S</code></td>
<td>
<p>the empirical variance/covariance matrix;</p>
</td></tr>
<tr><td><code id="sglasso_+3A_mask">mask</code></td>
<td>
<p>a symmetric matrix used to specify the equality constraints on the entries of the concentration matrix. See the example bellow for more details;</p>
</td></tr>
<tr><td><code id="sglasso_+3A_w">w</code></td>
<td>
<p>a vector specifying the weights used to compute the weighted l1-norm of the parameters of the <em>RCON(V, E)</em> model;</p>
</td></tr>
<tr><td><code id="sglasso_+3A_flg">flg</code></td>
<td>
<p>a logical vector used to specify if a parameter is penalized, i.e., if <code>flg[i] = TRUE</code> then the i-th parameter is penalized, otherwise (<code>flg[i] = FALSE</code>) the maximum likelihood estimate is computed;</p>
</td></tr>
<tr><td><code id="sglasso_+3A_min_rho">min_rho</code></td>
<td>
<p>last value of the sequence of tuning parameters used to compute the sglasso solution path. If <code>nrho = 1</code>, then <code>min_rho</code> is the value used to compute the sglasso estimate. Default value is 1.0e-02;</p>
</td></tr>
<tr><td><code id="sglasso_+3A_nrho">nrho</code></td>
<td>
<p>number of tuning parameters used to compute the sglasso solution path. Default is 50;</p>
</td></tr>
<tr><td><code id="sglasso_+3A_nstep">nstep</code></td>
<td>
<p>nonnegative integer used to specify the maximun number of iterations of the two cyclic coordinate algorithms. Default is 1.0e+05;</p>
</td></tr>
<tr><td><code id="sglasso_+3A_algorithm">algorithm</code></td>
<td>
<p>character by means of to specify the algorithm used to fit the model, i.e., a cyclic coordinate descente (<code>ccd</code>) algorithm or a cyclic coordinate minimization (<code>ccm</code>) algorithm. Default is <code>ccd</code>;</p>
</td></tr>
<tr><td><code id="sglasso_+3A_truncate">truncate</code></td>
<td>
<p>at convergence all estimates below this value will be set to zero. Default is 1e-05;</p>
</td></tr>
<tr><td><code id="sglasso_+3A_tol">tol</code></td>
<td>
<p>value used for convergence. Default value is 1.0e-05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>RCON(V, E)</em> model (Hojsgaard et al., 2008) is a kind of restriction of the Gaussian Graphical Model defined using a coloured graph to specify a set of equality constraints on the entries of the concentration matrix. Roughly speaking, a coloured graph implies a partition of the vertex set into <code class="reqn">R</code> disjoint subsets, called vertex colour classes, and a partition of the edge set into <code class="reqn">S</code> disjoint subsets, called edge colour classes. At each vertex/edge colour class is associated a specific colour. If we denote by <code class="reqn">K = (k_{ij})</code> the concentration matrix, i.e. the inverse of the variance/covariance matrix <code class="reqn">\Sigma</code>, the coloured graph implies the following equality constraints:</p>

<ol>
<li> <p><code class="reqn">k_{ii} = \eta_n</code> for any index <code class="reqn">i</code> belonging to the <code class="reqn">n</code>th vertex colour class;
</p>
</li>
<li> <p><code class="reqn">k_{ij} = \theta_m</code> for any pair <code class="reqn">(i,j)</code> belonging to the <code class="reqn">m</code>th edge colour class.
</p>
</li></ol>
<p> Denoted with <code class="reqn">\psi = (\eta',\theta')'</code> the <code class="reqn">(R+S)</code>-dimensional parameter vector, the concentration matrix can be defined as </p>
<p style="text-align: center;"><code class="reqn">K(\psi) = \sum_{n=1}^R\eta_nD_n + \sum_{m=1}^S\theta_mT_m,</code>
</p>
<p> where <code class="reqn">D_n</code> is a diagonal matrix with entries <code class="reqn">D^n_{ii} = 1</code> if the index <code class="reqn">i</code> belongs to the <code class="reqn">n</code>th vertex colour class and zero otherwise. In the same way, <code class="reqn">T_m</code> is a symmetrix matrix with entries <code class="reqn">T^m_{ij} = 1</code> if the pair <code class="reqn">(i,j)</code> belongs to the <code class="reqn">m</code>th edge colour class. Using the previous specification of the concentration matrix, the structured graphical lasso (sglasso) estimator (Abbruzzo et al., 2014) is defined as </p>
<p style="text-align: center;"><code class="reqn">\hat\psi = \arg\max_{\psi} \log det K(\psi) - tr\{Sk(\psi)\} - \rho\sum_{m=1}^Sw_m|\theta_m|,</code>
</p>
<p> where <code class="reqn">S</code> is the empirical variance/covariance matrix, <code class="reqn">\rho</code> is the tuning parameter used to control the ammount of shrinkage and <code class="reqn">w_m</code> are weights used to define the weighted <code class="reqn">\ell_1</code>-norm. By default, the <code>sglasso</code> function sets the weights equal to the cardinality of the edge colour classes.
</p>


<h3>Value</h3>

<p><code>sglasso</code> returns an obejct with S3 class <code>"sglasso"</code>, i.e. a named list containing the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object;</p>
</td></tr>
<tr><td><code>nv</code></td>
<td>
<p>number of vertex colour classes;</p>
</td></tr>
<tr><td><code>ne</code></td>
<td>
<p>number of edge colour classes;</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>the matrix of the sglasso estimates. The first <code>nv</code> rows correspond to the unpenalized parameters while the remaining rows correspond to the weighted l1-penalized parameters;</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the vector of weights used to define the weighted l1-norm;</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p><code>nrho</code>-dimensional vector of the number of estimated nonzero parameters;</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p><code>nrho</code>-dimensional vector of the sequence of tuning parameters;</p>
</td></tr>
<tr><td><code>grd</code></td>
<td>
<p>the matrix of the scores;</p>
</td></tr>
<tr><td><code>nstep</code></td>
<td>
<p>nonnegative integer used to specify the maximum number of iterations of the algorithms;</p>
</td></tr>
<tr><td><code>nrho</code></td>
<td>
<p>number of tuning parameters used to compute the sglasso solution path;</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>the algorithm used to fit the model;</p>
</td></tr>
<tr><td><code>truncate</code></td>
<td>
<p>the value used to set to zero the estimated parameters;</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>a nonnegative value used to define the convergence of the algorithms;</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>the empirical variace/covariance matrix used to compute the sglasso solution path;</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>the <code>mask</code> used to define the equality constraints on the entries of the concentration matrix;</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of interations of the algorithm;</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>an integer value used to encode the warnings related to the algorihtms. If <code>conv = 0</code> the convergence has been achieved otherwise the maximum number of iterations has been achieved.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>References</h3>

<p>Abbruzzo, A., Augugliaro, L., Mineo, A. M. and Wit, E. C. (2014) 
Cyclic coordinate for penalized Gaussian Graphical Models with symmetry restrictions. In <em>Proceeding of COMPSTAT 2014 - 21th International Conference on Computational Statistics</em>, Geneva, August 19-24, 2014.
<br />
</p>
<p>Hojsgaard, S. and Lauritzen, S. L. (2008)
Graphical gaussian models with edge and vertex symmetries. <em>J. Roy. Statist. Soc. Ser. B.</em>, Vol. <b>70(5)</b>, 1005&ndash;1027.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.sglasso">summary.sglasso</a></code>, <code><a href="#topic+plot.sglasso">plot.sglasso</a></code> <code><a href="#topic+gplot.sglasso">gplot.sglasso</a></code> and methods.
</p>
<p>The function <code><a href="#topic+Kh">Kh</a></code> extracts the estimated sparse structured concentration matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################################
# sglasso solution path
#
## structural zeros:
## there are two ways to specify structural zeros which are 
## related to the kind of mask. If mask is a numeric matrix
## NA is used to identify the structural zero. If mask is a
## character matrix then the structural zeros are specified
## using NA or ".".
N &lt;- 100
p &lt;- 5
X &lt;- matrix(rnorm(N * p), N, p)
S &lt;- crossprod(X) / N
mask &lt;- outer(1:p, 1:p, function(i,j) 0.5^abs(i-j))
mask[1,5] &lt;- mask[1,4] &lt;- mask[2,5] &lt;- NA
mask[5,1] &lt;- mask[4,1] &lt;- mask[5,2] &lt;- NA
mask

out.sglasso_path &lt;- sglasso(S, mask, tol = 1.0e-13)
out.sglasso_path

rho &lt;- out.sglasso_path$rho[20]
out.sglasso &lt;- sglasso(S, mask, nrho = 1, min_rho = rho, tol = 1.0e-13, algorithm = "ccm")
out.sglasso

out.sglasso_path$theta[, 20]
out.sglasso$theta[, 1]
</code></pre>

<hr>
<h2 id='sglasso-internal'>Internal sglasso functions</h2><span id='topic+sglasso.fit'></span><span id='topic+make_sglasso'></span><span id='topic+make_action'></span><span id='topic+setDiff'></span><span id='topic+mask2Tv'></span><span id='topic+mask2Te'></span><span id='topic+theta2Kh'></span><span id='topic+fglasso_model2mask'></span><span id='topic+zero'></span>

<h3>Description</h3>

<p>Internal sglasso functions</p>


<h3>Details</h3>

<p>These are not intended for use by users</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro</p>

<hr>
<h2 id='sglasso-package'>
Lasso Method for RCON(V, E) Models
</h2><span id='topic+sglasso-package'></span>

<h3>Description</h3>

<p><em>RCON(V, E)</em> models (Hojsgaard, et al., 2008) are a kind of restriction of the Gaussian Graphical Models defined by a set of equality constraints on the entries of the concentration matrix. <code>sglasso</code> package implements the structured graphical lasso (sglasso) estimator proposed in Abbruzzo et al. (2014) for the weighted l1-penalized <em>RCON(V, E)</em> model. Two cyclic coordinate algorithms are implemented to compute the sglasso estimator, i.e. a cyclic coordinate minimization (CCM) and a cyclic coordinate descent (CCD) algorithm.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> sglasso</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-12-03</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /><br />
Maintainer:<br />
Luigi Augugliaro &lt;luigi.augugliaro@unipa.it&gt;
</p>


<h3>References</h3>

<p>Abbruzzo, A., Augugliaro, L., Mineo, A. M. and Wit, E. C. (2014)
Cyclic coordinate for penalized Gaussian Graphical Models with symmetry restrictions. In <em>Proceeding of COMPSTAT 2014 - 21th International Conference on Computational Statistics</em>, Geneva, August 19-24, 2014.
<br />
</p>
<p>Hojsgaard, S. and Lauritzen, S. L. (2008)
Graphical gaussian models with edge and vertex symmetries. <em>J. Roy. Statist. Soc. Ser. B.</em>, Vol. <b>70(5)</b>, 1005&ndash;1027.
</p>

<hr>
<h2 id='summary.sglasso'>Summarizing sglasso Fits</h2><span id='topic+summary.sglasso'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"sglasso"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sglasso'
summary(object, N, k = c("bic","aic"), 
        digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sglasso_+3A_object">object</code></td>
<td>
<p>fitted <code>sglasso</code> object;</p>
</td></tr>
<tr><td><code id="summary.sglasso_+3A_n">N</code></td>
<td>
<p>sample size;</p>
</td></tr>
<tr><td><code id="summary.sglasso_+3A_k">k</code></td>
<td>
<p>character/numeric argument used to specify the 'weight' of the complexity part in the measure of goodness-of-fit used to select the best model (see below for more details). Default is <code>k = "bic"</code>;</p>
</td></tr>
<tr><td><code id="summary.sglasso_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout;</p>
</td></tr>
<tr><td><code id="summary.sglasso_+3A_...">...</code></td>
<td>
<p>additional print arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.sglasso</code> gives us information about the sequence of models estimated by the sglasso estimator. To select the best model, summary method uses a measure of Goodness-of-Fit (GoF) defined as follows: </p>
<p style="text-align: center;"><code class="reqn">-2\ell(\hat\psi) + k \times df,</code>
</p>
<p> where <code class="reqn">\ell(\hat\psi)</code> is the log-likelihood of the estimated weighted l1-penalized <em>RCON(V, E)</em> model, <code class="reqn">df</code> is the number of nonzero estimated parameters and <code class="reqn">k</code> is a non-negative value used to weight the complexity part in the measure of goodness-of-fit. By default the summary method computes the BIC criterion to select the best model (<code>k = "bic"</code>). The AIC criterion can be easily computed setting <code>k = "aic"</code>. The user can also define other measures of goodness-of-fit specifying <code>k</code> as any non-negative value.
</p>
<p>The output of the summary method is divided in two sections. First section shows the call producing the argument <code>object</code> followed by a <code>data.frame</code>. The column named <code>rho</code> shows the sequence of the <code class="reqn">\rho</code> values used to compute the solution curve, while the column <code>log-lik</code> shows the corresponding values of the log-likelihood function. The remaining columns show the number of estimated non-zero parameters, the values of the GoF and the asscoated ranking of the estimated models. Finally, the second section shows the estimated parameters of the best model identified by the used GoF criterion. Informations about the algorithm and the corresponding convergence are also provided.
</p>


<h3>Value</h3>

<p>A list with components <code>table</code> and <code>theta_gof</code> is silently returned. The <code>table</code> component is the <code>data.frame</code> previously described while the component <code>theta_gof</code> is the vector of the estimated parameters corresponding to the best models identified by the GoF criterion.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sglasso">sglasso</a></code> and <code><a href="#topic+loglik">loglik</a></code> functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
p &lt;- 5
X &lt;- matrix(rnorm(N * p), N, p)
S &lt;- crossprod(X) / N
mask &lt;- outer(1:p, 1:p, function(i,j) 0.5^abs(i-j))
mask[1,5] &lt;- mask[1,4] &lt;- mask[2,5] &lt;- NA
mask[5,1] &lt;- mask[4,1] &lt;- mask[5,2] &lt;- NA
out.sglasso_path &lt;- sglasso(S, mask, tol = 1.0e-13)
summary(out.sglasso_path, N)
rho &lt;- out.sglasso_path$rho[20]
out.sglasso &lt;- sglasso(S, mask, nrho = 1, min_rho = rho, tol = 1.0e-13)
summary(out.sglasso, N)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
