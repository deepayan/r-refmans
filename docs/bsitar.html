<!DOCTYPE html><html><head><title>Help for package bsitar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bsitar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_model_criterion.bgmfit'><p>Add model fit criteria to model</p></a></li>
<li><a href='#berkeley'><p>Berkeley Child Guidance Study Data</p></a></li>
<li><a href='#berkeley_exdata'><p>Berkeley Child Guidance Study Data for females</p></a></li>
<li><a href='#berkeley_exfit'><p>Model fit to the Berkeley Child Guidance Study Data for females</p></a></li>
<li><a href='#bsitar'><p>Fit Bayesian SITAR growth curve model</p></a></li>
<li><a href='#expose_model_functions.bgmfit'><p>Expose user defined Stan function for post-processing</p></a></li>
<li><a href='#fitted_draws.bgmfit'><p>Fitted (expected) values from the posterior draws</p></a></li>
<li><a href='#getNsObject'><p>Check and get namespace object if exists</p></a></li>
<li><a href='#growthparameters_comparison.bgmfit'><p>Compare growth parameters</p></a></li>
<li><a href='#growthparameters.bgmfit'><p>Estimate growth parameters from the model fit</p></a></li>
<li><a href='#loo_validation.bgmfit'><p>Perform leave-one-out (loo) cross-validation</p></a></li>
<li><a href='#marginal_comparison.bgmfit'><p>Compare growth curves</p></a></li>
<li><a href='#marginal_draws.bgmfit'><p>Fitted (expected) values from the posterior draws</p></a></li>
<li><a href='#optimize_model.bgmfit'><p>Optimize SITAR model</p></a></li>
<li><a href='#plot_conditional_effects.bgmfit'><p>Visualize conditional effects of predictor</p></a></li>
<li><a href='#plot_curves.bgmfit'><p>Plot growth curves</p></a></li>
<li><a href='#plot_ppc.bgmfit'><p>Perform posterior predictive distribution checks</p></a></li>
<li><a href='#predict_draws.bgmfit'><p>Predicted values from the posterior predictive distribution</p></a></li>
<li><a href='#update_model.bgmfit'><p>Update model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Super Imposition by Translation and Rotation Growth
Curve Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Satpal Sandhu &lt;satpal.sandhu@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Super Imposition by Translation and Rotation (SITAR) model 
    is a shape-invariant nonlinear mixed effect model that fits a natural cubic 
    spline mean curve to the growth data, and aligns individual-specific growth 
    curves to the underlying mean curve via a set of random effects (see Cole, 
    2010 &lt;<a href="https://doi.org/10.1093%2Fije%2Fdyq115">doi:10.1093/ije/dyq115</a>&gt; for details). The non-Bayesian version of the 
    SITAR model can be fit by using an already available R package 'sitar'. 
    While 'sitar' package allows modelling of a single outcome only, the 'bsitar' 
    package offers a great flexibility in fitting models of varying complexities 
    that include joint modelling of multiple outcomes such as height and weight 
    (multivariate model). Also, the 'bsitar' package allows simultaneous analysis 
    of a single outcome separately for sub groups defined by a factor variable such 
    as gender. This is achieved by fitting separate models for each sub group 
    (such as males and females for gender variable). An advantage of such approach 
    is that posterior draws for each sub group are part of a single model object 
    that makes it possible to compare coefficients across groups and test hypotheses. 
    As 'bsitar' package is a front-end to the R package 'brms', it offers an excellent 
    support for post-processing of posterior draws via various functions that are 
    directly available from the 'brms' package. In addition, the 'bsitar' package 
    include various customized functions that allow estimation and visualization 
    growth curves such as distance (increase in size with age) and velocity 
    (change in growth rate as a function of age).       </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brms (&ge; 2.17.0), rstan (&ge; 2.26.0), loo (&ge; 2.7.0), dplyr (&ge;
1.1.3), rlang (&ge; 1.1.2), Rdpack (&ge; 2.5), insight (&ge; 0.19.7),
marginaleffects (&ge; 0.18.0), sitar, magrittr, methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2 (&ge; 3.4.0), bayesplot (&ge; 1.11.0), posterior (&ge;
1.3.1), testthat (&ge; 3.0.0), collapse (&ge; 2.0.3), tidyr, nlme,
purrr, future, future.apply, forcats, jtools, patchwork,
tibble, pracma, extraDistr, bookdown, knitr, kableExtra,
rmarkdown, spelling, Hmisc, R.rsp, graphics, grDevices, ggtext,
glue, stats</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Sandhu-SS/bsitar">https://github.com/Sandhu-SS/bsitar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Sandhu-SS/bsitar/issues">https://github.com/Sandhu-SS/bsitar/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>no</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-19 11:52:17 UTC; drsat</td>
</tr>
<tr>
<td>Author:</td>
<td>Satpal Sandhu <a href="https://orcid.org/0000-0002-8539-6897"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-19 17:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_model_criterion.bgmfit'>Add model fit criteria to model</h2><span id='topic+add_model_criterion.bgmfit'></span><span id='topic+add_model_criterion'></span>

<h3>Description</h3>

<p>The <strong>add_model_criterion()</strong> is a wrapper around the
<code><a href="brms.html#topic+add_criterion">brms::add_criterion()</a></code>. Note that arguments <code>compare</code> and
<code>pointwise</code> are relevant only for <a href="brms.html#topic+add_ic">brms::add_loo</a> whereas arguments
<code>summary</code>, <code>robust</code>, and <code>probs</code> ignored except for the
<code><a href="brms.html#topic+bayes_R2.brmsfit">brms::bayes_R2()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
add_model_criterion(
  model,
  criterion = c("loo", "waic"),
  ndraws = NULL,
  draw_ids = NULL,
  compare = TRUE,
  pointwise = FALSE,
  model_names = NULL,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  newdata = NULL,
  resp = NULL,
  cores = 1,
  deriv_model = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

add_model_criterion(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_model_criterion.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_criterion">criterion</code></td>
<td>
<p>Names of model fit criteria
to compute. Currently supported are <code>"loo"</code>,
<code>"waic"</code>, <code>"kfold"</code>, <code>"loo_subsample"</code>,
<code>"bayes_R2"</code> (Bayesian R-squared),
<code>"loo_R2"</code> (LOO-adjusted R-squared), and
<code>"marglik"</code> (log marginal likelihood).</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_compare">compare</code></td>
<td>
<p>A flag indicating if the information criteria
of the models should be compared to each other
via <code><a href="brms.html#topic+loo_compare">loo_compare</a></code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_pointwise">pointwise</code></td>
<td>
<p>A flag indicating whether to compute the full
log-likelihood matrix at once or separately for each observation.
The latter approach is usually considerably slower but
requires much less working memory. Accordingly, if one runs
into memory issues, <code>pointwise = TRUE</code> is the way to go.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_summary">summary</code></td>
<td>
<p>A logical indicating whether only the estimate should be
computed (<code>TRUE</code>, default), or estimate along with SE and CI should be
returned (<code>FALSE</code>). Setting <code>summary</code> as <code>FALSE</code> will
increase the computation time.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_robust">robust</code></td>
<td>
<p>A logical to specify the summarize options. If <code>FALSE</code>
(the default) the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If <code>TRUE</code>, the
median and the median absolute deviation (MAD) are applied instead. Ignored
if <code>summary</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify response
variable when processing posterior draws for the <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used when running the parallel
computations (if <code>future = TRUE</code>). On non-Windows systems this
argument can be set globally via the mc.cores option. For the default
<code>NULL</code> option, the number of cores are set automatically by calling
the <code><a href="future.html#topic+re-exports">future::availableCores()</a></code>. The number of cores used are the maximum
number of cores avaialble minus one, i.e., <code>future::availableCores() -
  1</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>brms::fitted.brmsfit()</code> and
<code>brms::predict()</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class class <code>bgmfit</code> with fit criteria added.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><a href="brms.html#topic+add_ic">brms::add_loo</a> <a href="brms.html#topic+add_ic">brms::add_loo</a> <code><a href="brms.html#topic+add_ic">brms::add_ic()</a></code> <code><a href="brms.html#topic+add_ic">brms::add_waic()</a></code>
<code><a href="brms.html#topic+bayes_R2.brmsfit">brms::bayes_R2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

model &lt;- berkeley_exfit

model &lt;- add_model_criterion(model, criterion = c("waic"))



</code></pre>

<hr>
<h2 id='berkeley'>Berkeley Child Guidance Study Data</h2><span id='topic+berkeley'></span>

<h3>Description</h3>

<p>Data provide longitudinal growth records for 136 children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berkeley
</code></pre>


<h3>Format</h3>

<p>A data frame with 4884 observations on the following 10 variables:
</p>

<dl>
<dt>id</dt><dd><p>factor with levels 201-278 for males, and 301-385 for females</p>
</dd>
<dt>age</dt><dd><p>years, numeric vector</p>
</dd>
<dt>height</dt><dd><p>cm, numeric vector</p>
</dd>
<dt>weight</dt><dd><p>kg, numeric vector</p>
</dd>
<dt>stem.length</dt><dd><p>cm, numeric vector</p>
</dd>
<dt>bi.acromial</dt><dd><p>cm, numeric vector</p>
</dd>
<dt>bi.iliac</dt><dd><p>cm, numeric vector</p>
</dd>
<dt>leg.circ</dt><dd><p>cm, numeric vector</p>
</dd>
<dt>strength</dt><dd><p>lb, numeric vector</p>
</dd>
<dt>sex</dt><dd><p>factor with level 1 male and level 2 female</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data originally included as an appendix in the book â€œPhysical growth
of California boys and girls from birth to eighteen years&quot; authored by
Tuddenham and Snyder (1954), and later used as an example
dataset in the <span class="pkg">sitar</span> (Cole 2022) package after
correcting for the transcription errors.
</p>
<p>A detailed description of the data including the frequency of measurements
per year is provided in the <span class="pkg">sitar</span> package.
(Cole 2022). Briefly, the data comprise of repeated growth
measurements made on 66 boys and 70 girls (birth to 21 years). Children
were born in 1928-29 (Berkeley, California) and were of north European
ancestry. Measurements were made at the following ages: 0 (i.e, at birth),
0.085 year, 0.25 to 2 years (every 3 month), 2 to 8 years (annually), and 8
to 21 years (6-monthly). The children were measured for height, weight
(undressed), stem length, biacromial diameter, bi-iliac diameter, leg
circumference, and dynamo metric strength.
</p>


<h3>Value</h3>

<p>A data frame with 10 columns.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>References</h3>

<p>Cole T (2022).
<em>sitar: Super Imposition by Translation and Rotation Growth Curve Analysis</em>.
R package version 1.3.0, <a href="https://CRAN.R-project.org/package=sitar">https://CRAN.R-project.org/package=sitar</a>.<br /><br /> Tuddenham RD, Snyder MM (1954).
&ldquo;Physical growth of California boys and girls from birth to eighteen years.&rdquo;
<em>Publications in Child Development. University of California, Berkeley</em>, <b>1</b>(2), 183&ndash;364.
<a href="https://pubmed.ncbi.nlm.nih.gov/13217130/">https://pubmed.ncbi.nlm.nih.gov/13217130/</a>.
</p>

<hr>
<h2 id='berkeley_exdata'>Berkeley Child Guidance Study Data for females</h2><span id='topic+berkeley_exdata'></span>

<h3>Description</h3>

<p>A subset of the <a href="#topic+berkeley">berkeley</a> data that contains
longitudinal growth data for 70 females (8 to 18 years of age).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berkeley_exdata
</code></pre>


<h3>Format</h3>

<p>A data frame with following 3 variables:
</p>

<dl>
<dt>id</dt><dd><p>factor variable</p>
</dd>
<dt>age</dt><dd><p>years, numeric vector</p>
</dd>
<dt>height</dt><dd><p>cm, numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>A detailed description of the full data is provided in the
<a href="#topic+berkeley">berkeley</a> data.
</p>


<h3>Value</h3>

<p>A data frame with 3 columns.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>

<hr>
<h2 id='berkeley_exfit'>Model fit to the Berkeley Child Guidance Study Data for females</h2><span id='topic+berkeley_exfit'></span>

<h3>Description</h3>

<p>Bayesian SITAR model fit to the <a href="#topic+berkeley_exdata">berkeley_exdata</a>
data (70 females, 8 to 18 years of age).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berkeley_exfit
</code></pre>


<h3>Format</h3>

<p>Model fit comprising summary of posterior draws.
</p>


<h3>Details</h3>

<p>Data details are provided in the <a href="#topic+berkeley_exdata">berkeley_exdata</a>
</p>


<h3>Value</h3>

<p>An object of class <code>bgmfit</code> with posterior draws.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>

<hr>
<h2 id='bsitar'>Fit Bayesian SITAR growth curve model</h2><span id='topic+bsitar'></span>

<h3>Description</h3>

<p>The <strong>bsitar()</strong> is the main function that fits the
Bayesian version of the super imposition by translation and rotation
(<em>SITAR</em>) model. The <em>SITAR</em> model is a nonlinear mixed effects
model that has been used extensively to summarize growth processes (such as
height and weight) from early childhood through the adulthood. The
frequentist version of the <em>SITAR</em> model can be fit by using an
already available R package, <span class="pkg">sitar</span> (Cole 2022).
Besides Bayesian implementation, the <span class="pkg">bsitar</span> package greatly enhances
the modelling capabilities of the <em>SITAR</em>. For example, in addition to
the univariate analysis (i.e, modelling a single outcome), the <span class="pkg">bsitar</span>
allows univariate-by-subgroup and multivariate model fitting. In
univariate-by-subgroup analysis, a single outcome is simultaneously
analysed for subgroups defined by a factor variable such as gender. An
advantage of univariate-by-subgroup analysis is that posterior draws for
each sub group are part of a single model object that makes it possible to
compare coefficients across groups and also test various hypotheses. The
multivariate analysis involves simultaneous joint modelling of two or more
outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsitar(
  x,
  y,
  id,
  data,
  df = 4,
  knots = NA,
  fixed = a + b + c,
  random = a + b + c,
  xoffset = mean,
  bstart = xoffset,
  cstart = 0,
  xfun = NULL,
  yfun = NULL,
  bound = 0.04,
  terms_rhs = NULL,
  a_formula = ~1,
  b_formula = ~1,
  c_formula = ~1,
  d_formula = ~1,
  s_formula = ~1,
  a_formula_gr = ~1,
  b_formula_gr = ~1,
  c_formula_gr = ~1,
  d_formula_gr = ~1,
  a_formula_gr_str = NULL,
  b_formula_gr_str = NULL,
  c_formula_gr_str = NULL,
  d_formula_gr_str = NULL,
  d_adjusted = FALSE,
  sigma_formula = NULL,
  sigma_formula_gr = NULL,
  sigma_formula_gr_str = NULL,
  dpar_formula = NULL,
  autocor_formula = NULL,
  family = gaussian(),
  custom_family = NULL,
  custom_stanvars = NULL,
  group_arg = list(groupvar = NULL, by = NULL, cor = un, cov = NULL, dist = gaussian),
  sigma_group_arg = list(groupvar = NULL, by = NULL, cor = un, cov = NULL, dist =
    gaussian),
  univariate_by = list(by = NA, cor = un, terms = subset),
  multivariate = list(mvar = FALSE, cor = un, rescor = TRUE),
  a_prior_beta = student_t(3, ymean, ysd, autoscale = TRUE),
  b_prior_beta = student_t(3, 0, 3.5, autoscale = FALSE),
  c_prior_beta = student_t(3, 0, 1.5, autoscale = FALSE),
  d_prior_beta = student_t(3, 0, 1, autoscale = TRUE),
  s_prior_beta = student_t(3, 0, lm, autoscale = TRUE),
  a_cov_prior_beta = student_t(3, 0, 5, autoscale = FALSE),
  b_cov_prior_beta = student_t(3, 0, 1, autoscale = FALSE),
  c_cov_prior_beta = student_t(3, 0, 0.1, autoscale = FALSE),
  d_cov_prior_beta = student_t(3, 0, 1, autoscale = FALSE),
  s_cov_prior_beta = student_t(3, 0, 10, autoscale = FALSE),
  a_prior_sd = student_t(3, 0, ysd, autoscale = TRUE),
  b_prior_sd = student_t(3, 0, 2, autoscale = FALSE),
  c_prior_sd = student_t(3, 0, 1.25, autoscale = FALSE),
  d_prior_sd = student_t(3, 0, 1, autoscale = TRUE),
  a_cov_prior_sd = student_t(3, 0, 5, autoscale = FALSE),
  b_cov_prior_sd = student_t(3, 0, 1, autoscale = FALSE),
  c_cov_prior_sd = student_t(3, 0, 0.1, autoscale = FALSE),
  d_cov_prior_sd = student_t(3, 0, 1, autoscale = FALSE),
  a_prior_sd_str = NULL,
  b_prior_sd_str = NULL,
  c_prior_sd_str = NULL,
  d_prior_sd_str = NULL,
  a_cov_prior_sd_str = NULL,
  b_cov_prior_sd_str = NULL,
  c_cov_prior_sd_str = NULL,
  d_cov_prior_sd_str = NULL,
  sigma_prior_beta = student_t(3, 0, 1, autoscale = FALSE),
  sigma_cov_prior_beta = student_t(3, 0, 0.5, autoscale = FALSE),
  sigma_prior_sd = student_t(3, 0, 0.25, autoscale = FALSE),
  sigma_cov_prior_sd = student_t(3, 0, 0.15, autoscale = FALSE),
  sigma_prior_sd_str = NULL,
  sigma_cov_prior_sd_str = NULL,
  rsd_prior_sigma = exponential(ysd, autoscale = TRUE),
  dpar_prior_sigma = student_t(3, 0, ysd, autoscale = TRUE),
  dpar_cov_prior_sigma = student_t(3, 0, 1, autoscale = FALSE),
  autocor_prior_acor = uniform(-1, 1, autoscale = FALSE),
  autocor_prior_unstr_acor = lkj(1),
  gr_prior_cor = lkj(1),
  gr_prior_cor_str = lkj(1),
  sigma_prior_cor = lkj(1),
  sigma_prior_cor_str = lkj(1),
  mvr_prior_rescor = lkj(1),
  init = NULL,
  init_r = NULL,
  a_init_beta = lm,
  b_init_beta = 0,
  c_init_beta = 0,
  d_init_beta = 0,
  s_init_beta = lm,
  a_cov_init_beta = 0,
  b_cov_init_beta = 0,
  c_cov_init_beta = 0,
  d_cov_init_beta = 0,
  s_cov_init_beta = lm,
  a_init_sd = random,
  b_init_sd = random,
  c_init_sd = random,
  d_init_sd = random,
  a_cov_init_sd = random,
  b_cov_init_sd = random,
  c_cov_init_sd = random,
  d_cov_init_sd = random,
  sigma_init_beta = random,
  sigma_cov_init_beta = random,
  sigma_init_sd = random,
  sigma_cov_init_sd = random,
  gr_init_cor = random,
  sigma_init_cor = random,
  rsd_init_sigma = random,
  dpar_init_sigma = random,
  dpar_cov_init_sigma = random,
  autocor_init_acor = random,
  autocor_init_unstr_acor = random,
  mvr_init_rescor = random,
  r_init_z = random,
  vcov_init_0 = TRUE,
  jitter_init_beta = NULL,
  jitter_init_sd = NULL,
  jitter_init_cor = NULL,
  prior_data = NULL,
  init_data = NULL,
  init_custom = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  get_stancode = FALSE,
  get_standata = FALSE,
  get_formula = FALSE,
  get_stanvars = FALSE,
  get_priors = FALSE,
  get_priors_eval = FALSE,
  get_init_eval = FALSE,
  validate_priors = FALSE,
  set_self_priors = NULL,
  set_replace_priors = NULL,
  set_same_priors_hierarchy = FALSE,
  outliers = NULL,
  unused = NULL,
  chains = 4,
  iter = 2000,
  warmup = floor(iter/2),
  thin = 1,
  cores = getOption("mc.cores", "optimize"),
  backend = getOption("brms.backend", "rstan"),
  threads = getOption("brms.threads", "optimize"),
  opencl = getOption("brms.opencl", NULL),
  normalize = getOption("brms.normalize", TRUE),
  algorithm = getOption("brms.algorithm", "sampling"),
  control = list(adapt_delta = 0.8, max_treedepth = 15),
  sample_prior = "no",
  save_pars = NULL,
  drop_unused_levels = TRUE,
  stan_model_args = list(),
  refresh = NULL,
  silent = 1,
  seed = 123,
  save_model = NULL,
  fit = NA,
  file = NULL,
  file_compress = TRUE,
  file_refit = getOption("brms.file_refit", "never"),
  future = getOption("future", FALSE),
  parameterization = "ncp",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsitar_+3A_x">x</code></td>
<td>
<p>Predictor variable (typically age in years). For <code>univariate</code>
model, the <code>x</code> is a single variable whereas for <code>univariate_by</code>
and <code>multivariate</code> models, the <code>x</code> can be same for sub models, or
different for each sub model. For example, when fitting a bivariate model,
the <code>x = list(x1, x2)</code> specifies that <code>x1</code> is the predictor
variable for the first sub model, and <code>x2</code> for the second sub model. To
specify <code>x1</code> as a common predictor
variable for both sub models, the argument <code>x</code> is defined as <code>x =
 list(x1)</code> or simply <code>x = x1</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_y">y</code></td>
<td>
<p>Response variable (e.g., repeated height measurements). For
<code>univariate</code> and <code>univariate_by</code> models, <code>y</code> is specified as
a single variable. For <code>univariate_by</code> model, the response vector for
each sub model is created and named internally based on the factor levels of
the variable that is used to set up the <code>univariate_by</code> model. As an
example, the model specified as <code>univariate_by = sex</code> creates response
vectors <code>Female</code> and  <code>Male</code> when <code>Female</code> is the first level
and <code>Male</code> is the second level of the <code>sex</code> variable. For
<code>multivariate</code> model, the response variables are specified as a list
such as <code>y = list(y1, y2</code>) where <code>y1</code> is the response variable for
the first sub model and <code>y2</code> for the second sub model. Note that for
<code>multivariate</code> model, data are not stacked but rather response vectors
are separate variables in the <code>data</code> and are of same length.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_id">id</code></td>
<td>
<p>A factor variable uniquely identifying the groups (e.g.,
individuals) in the data frame. For <code>univariate_by</code> and
<code>multivariate</code> models, the <code>id</code> can be same (typically) for sub
models or different for each sub model (see argument <code>x</code> for details on
setting different arguments for sub models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_data">data</code></td>
<td>
<p>Data frame containing variables such as <code>x</code>, <code>y</code>,
<code>id</code> etc.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_df">df</code></td>
<td>
<p>Degrees of freedom for the natural cubic spline design matrix
(default <code>4</code>). The <code>df</code> is internally used to construct the
knots (quantiles of <code>x</code> distribution) that are then used in the
construction of the spline design matrix. For <code>univariate_by</code>
and <code>multivariate</code> models, the <code>df</code> can be same (e.g., <code>df  =
 4</code>) for sub models or different for each sub model such as
<code>df=list(4, 5)</code> where <code>df</code> is 4 is for the first sub model, and 5
for the second sub model.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_knots">knots</code></td>
<td>
<p>A numeric vector vector specifying the knots for the natural
cubic spline design matrix (default <code>NULL</code>) Note that <code>df</code> and
<code>knots</code> can not be specified together, and also both of them can not be
<code>NULL</code>. In other words, either <code>df</code> or <code>knots</code> must be
specified. Like <code>df</code>, the <code>knots</code> can be same for sub models or
different for each sub model when fitting <code>univariate_by</code> and
<code>multivariate</code> models (see <code>df</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_fixed">fixed</code></td>
<td>
<p>A character string specifying the fixed effects structure
(default <code>'a+b+c'</code>). Note that different fixed effect structures can be
specified when fitting <code>univariate_by</code> and <code>multivariate</code> models.
As an example, <code>fixed = list('a+b+c', 'a+b')</code> implies that the fixed
effect structure for the first sub model is <code>'a+b+c'</code>, and <code>'a+b'</code>
for the second sub model.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_random">random</code></td>
<td>
<p>A character string specifying the random effects structure
(default <code>'a+b+c'</code>). The approach used in setting the <code>random</code> is
same as described above for the fixed effects structure (see <code>fixed</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_xoffset">xoffset</code></td>
<td>
<p>An optional character string, or a numeric value to set up the
origin of the predictor variable, <code>x</code> (i.e., centering of <code>x</code>).
The options available are <code>'mean'</code> (mean of x, i.e., <code>mean(x)</code>),
<code>'max'</code> (maximum value of x, i.e., <code>max(x)</code>), <code>'min'</code>
(minimum value of x, i.e., <code>min(x)</code>), <code>'apv'</code> (age at peak
velocity estimated from the velocity curve derived from the simple linear
model fit to the data), or any real number such as <code>xoffset = 12</code>.
The default is <code>xoffset = 'mean'</code>. For <code>univariate_by</code>
and <code>multivariate</code> models, the <code>xoffset</code> can be same for sub
models or different for each sub model (see argument <code>x</code> for details
on setting different arguments for sub models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_bstart">bstart</code></td>
<td>
<p>An optional character string, or a numeric value to set up the
origin of the fixed effect parameter <code>b</code>. The argument <code>bstart</code>
can be used to set up the location parameter for the location-scale based
priors (such as <code>normal()</code>) via <code>b_prior_beta</code> argument and/or the
initial value via the <code>b_init_beta</code> argument. The options available to
set up the <code>bstart</code> are same as described above for the <code>xoffset</code>
i.e., <code>'mean'</code>, <code>'min'</code>, <code>'max'</code>, <code>'apv'</code> or a real
number such as <code>12</code>. The default is same as <code>xoffset</code> i.e.,
<code>bstart = 'xoffset'</code>. For <code>univariate_by</code> and  <code>multivariate</code>
models, the <code>xoffset</code> can be same for sub models (typically), or
different for each sub model (see argument <code>x</code> for details on setting
different arguments for sub models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_cstart">cstart</code></td>
<td>
<p>An optional character string, or a numeric value to set up the
origin of the fixed effect parameter <code>c</code>. The argument <code>cstart</code>
can be used to set up the location parameter for the location-scale based
priors (such as <code>normal()</code>) via <code>c_prior_beta</code> argument and/or the
initial value via the <code>c_init_beta</code> argument. The options available to
set up the <code>cstart</code> are <code>'pv'</code> (peak velocity estimated from the
velocity curve derived from the simple linear model fit to the data), or a
real number such as <code>1</code>. Note that since parameter <code>c</code> is
estimated on the exponential scale, the argument <code>cstart</code> should be
adjusted accordingly. The default <code>cstart</code> is '0' i.e., <code>cstart =
 '0'</code>. For <code>univariate_by</code> and <code>multivariate</code> models,
the <code>xoffset</code> can be same for sub models (typically), or different for
each sub model (see argument <code>x</code> for details on setting different
arguments for sub models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_xfun">xfun</code></td>
<td>
<p>An optional character string to specify the transformation of the
predictor variable, The default is <code>NULL</code> indicating that no
transformation is applied i.e., model is fit to the data with original scale
of the <code>x</code>. Available transformation options are <code>'log'</code>
(logarithmic transformation) and <code>'sqrt'</code> (square root transformation).
For <code>univariate_by</code> and <code>multivariate</code> models, the <code>xfun</code> can
be same for sub models (typically), or different for each sub model (see
argument <code>x</code> for details on setting different arguments for sub
models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_yfun">yfun</code></td>
<td>
<p>An optional character string to specify the transformation of the
response variable, The default is <code>NULL</code>, indicating that no
transformation is applied i.e., model is fit to the data with original scale
of the <code>y</code>. Available transformation options are <code>'log'</code>
(logarithmic transformation) and <code>'sqrt'</code> (square root transformation).
For <code>univariate_by</code> and <code>multivariate</code> models, the <code>xfun</code> can
be same for sub models (typically), or different for each sub model (see
argument <code>x</code> for details on setting different arguments for sub
models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_bound">bound</code></td>
<td>
<p>An optional real number to extend the span of the predictor
variable <code>x</code> by a small value (default 0.04). See package
<code><a href="sitar.html#topic+sitar">sitar::sitar()</a></code> for details. For <code>univariate_by</code> and
<code>multivariate</code> models, the <code>bound</code> can be same for sub models
(typically), or different for each sub model (see argument <code>x</code> for
details on setting different arguments for sub models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_terms_rhs">terms_rhs</code></td>
<td>
<p>An optional character string (default <code>NULL</code>) to specify
terms on the right hand side of the response variable (separated by
<code>|</code>) but before the formula tilde sign i.e., <code>~</code>. The
<code>terms_rhs</code> is used when fitting a measurement error model. As an
example, consider fitting a model with measurement error in the response
variable which is specified in the <code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code> as
<code>brmsformula(y | mi(sdy) ~ ..)</code>. In this example, the <code>mi(sdy)</code> is
passed to <code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code> as <code>terms_rhs = mi(sdy)</code>. For
<code>multivariate</code> model, each outcome can have its own measurement error
variable that can be specified as follows: <br /> <code>terms_rhs =
 list(mi(sdy1), mi(sdy2))</code>. Note that <code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code> does not allow
combining <code>mi()</code> with the <code>subset()</code> formulation that is used for
fitting <code>univariate_by</code> model.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_formula">a_formula</code></td>
<td>
<p>Formula for the fixed effect parameter, <code>a</code> (default
<code>~ 1</code>). User can specify different formula when fitting
<code>univariate_by</code> and <code>multivariate</code> models. As an example
<code>a_formula = list(~1, ~1 + cov)</code> implies that the <code>a_formula</code> for
the first sub model includes an intercept only whereas the second sub model
includes an intercept and a covariate, <code>cov</code>. The covariate(s)  can be
continuous variable(s) or factor variable(s). For factor covariates, dummy
variables are created internally via the <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>). The
formula can include any combination of continuous and factor variables as
well as their interactions.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_formula">b_formula</code></td>
<td>
<p>Formula for the fixed effect parameter, <code>b</code> (default
<code>~ 1</code>). See <code>a_formula</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_formula">c_formula</code></td>
<td>
<p>Formula for the fixed effect parameter, <code>c</code> (default
<code>~ 1</code>). See <code>a_formula</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_formula">d_formula</code></td>
<td>
<p>Formula for the fixed effect parameter, <code>d</code> (default
<code>~ 1</code>). See <code>a_formula</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_s_formula">s_formula</code></td>
<td>
<p>Formula for the fixed effect parameter, <code>s</code> (default
<code>~ 1</code>). The <code>s_formula</code> sets up the the spline design matrix.
Typically, covariate(s) are not included in the <code>s_formula</code> to limit
the population curve to be single curve for the whole data. In fact, the
<code><a href="sitar.html#topic+sitar">sitar::sitar()</a></code> does not provide any option to include covariates in the
<code>s_formula</code>, However, <span class="pkg">bsitar</span> package allows inclusion of
covariates but the user need to justify the modelling of separate curves for
each category when covariate is a factor variable.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_formula_gr">a_formula_gr</code></td>
<td>
<p>Formula for the random effect parameter, <code>a</code> (default
<code>~ 1</code>). Similar to <code>a_formula</code>, user can specify different formula
when fitting <code>univariate_by</code> and <code>multivariate</code> models and formula
can include continuous and/or factor variable(s) including their
interactions as covariates (see <code>a_formula</code> for details). In addition
to setting up the design matrix for the random effect parameter <code>a</code>,
user can set up the group identifier and the correlation structure for
random effects via the vertical bar <code>||</code> approach. For example,
consider only an intercept for the random effects <code>a</code>, <code>b</code>, and
<code>c</code> specified as <code>a_formula_gr = ~1</code>, <code>b_formula_gr = ~1</code>
and <code>c_formula_gr = ~1</code>. To specify the group identifier
(e.g., <code>id</code>) and an unstructured correlation structure, the formula
argument as specified as follows: <br />
<code>a_formula_gr = ~ (1|i|id)</code> <br />
<code>b_formula_gr = ~ (1|i|id)</code> <br />
<code>c_formula_gr = ~ (1|i|id)</code> <br />
where  <code>i</code> within the vertical bars <code>||</code> is just a placeholder. A
common identifier (i.e., <code>i</code>) shared across random effect formulas are
modeled as unstructured correlated. For more details on the the vertical bar
approach, please see <code><a href="brms.html#topic+brm">brms::brm()</a></code>. As explained below, an alternative
approach to set up the group identifier and the correlation structure is to
use <code>group_by</code> argument. In other words, to achieve the same set up as
defined above by using the vertical bar approach, user can just specify the
design matrix part of the formula as
<code>a_formula_gr = ~ 1</code> <br />
<code>b_formula_gr = ~ 1</code> <br />
<code>c_formula_gr = ~ 1</code> <br />
and use the <code>group_by</code> argument as <code>group_by = list(groupvar = id,
 cor = un)</code> where <code>id</code> specifies the group identifier and <code>un</code> sets
up the unstructured correlation structure. See <code>group_by</code> argument for
details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_formula_gr">b_formula_gr</code></td>
<td>
<p>Formula for the random effect parameter, <code>b</code> (default
<code>~ 1</code>). See <code>a_formula_gr</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_formula_gr">c_formula_gr</code></td>
<td>
<p>Formula for the random effect parameter, <code>c</code> (default
<code>~ 1</code>). See <code>a_formula_gr</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_formula_gr">d_formula_gr</code></td>
<td>
<p>Formula for the random effect parameter, <code>d</code> (default
<code>~ 1</code>). See <code>a_formula_gr</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_formula_gr_str">a_formula_gr_str</code></td>
<td>
<p>Formula for the random effect parameter, <code>a</code>
(default <code>NULL</code>) when fitting a hierarchical model with three or more
levels of hierarchy. An example is model applied to the data that comprise
repeated measurements (level 1) on individuals (level 2) nested further
within the growth studies (level 3). Note that When using
<code>a_formula_gr_str</code> argument, only the vertical bar approach (see
<code>a_formula_gr</code>) can be used to set up the group identifiers and the
correlation structure. An example of setting up the formula for a three
level model with random effect parameter <code>a</code>, <code>b</code> is as follows:
<br />
<code>a_formula_gr_str = ~ (1|i|id:study) + (1|i2|study)</code> <br />
<code>b_formula_gr_str = ~ (1|i|id:study) + (1|i2|study)</code> <br />
<code>c_formula_gr_str = ~ (1|i|id:study) + (1|i2|study)</code> <br />
where <code>|i|</code> and <code>|i2|</code> set up the unstructured correlation
structure for individual and study level random effects. Note that
<code>|i|</code> and <code>|i2|</code> need to be distinct because random effect
parameters are not allowed to be correlated across different levels of
hierarchy.
It is worth mentioning that user can set up model with any number of
hierarchical levels and include covariate into the random effect formula.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_formula_gr_str">b_formula_gr_str</code></td>
<td>
<p>Formula for the random effect parameter, <code>b</code>
(default <code>NULL</code>) when fitting a hierarchical model with three or more
levels of hierarchy. See <code>a_formula_gr_str</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_formula_gr_str">c_formula_gr_str</code></td>
<td>
<p>Formula for the random effect parameter, <code>c</code>
(default <code>NULL</code>) when fitting a hierarchical model with three or more
levels of hierarchy. See <code>a_formula_gr_str</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_formula_gr_str">d_formula_gr_str</code></td>
<td>
<p>Formula for the random effect parameter, <code>d</code>
(default <code>NULL</code>) when fitting a hierarchical model with three or more
levels of hierarchy. See <code>a_formula_gr_str</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_adjusted">d_adjusted</code></td>
<td>
<p>A logical indicator to set up the scale of predictor
variable <code>x</code> when fitting the model with random effect parameter
<code>d</code>. The coefficient of parameter <code>d</code> is estimated as a linear
function of <code>x</code> i.e., <code>d * x</code>. If <code>FALSE</code> (default), the
original <code>x</code> is used. When <code>d_adjusted = TRUE</code>, the <code>x</code> is
adjusted for the timing (<code>b</code>) and intensity (<code>c</code>) parameters as
<code>x</code> - <code>b</code>) * <code>exp(c)</code> i.e., <code>d * ((x-b)*exp(c))</code>. The
adjusted scale of <code>x</code> reflects individual developmental age rather than
chronological age. This makes d more sensitive to the timing of puberty in
individuals. See <code><a href="sitar.html#topic+sitar">sitar::sitar()</a></code> function for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_formula">sigma_formula</code></td>
<td>
<p>Formula for the fixed effect distributional parameter,
<code>sigma</code>. The <code>sigma_formula</code> sets up the fixed effect design
matrix that may include continuous and/or factor variables (and their
interactions) as covariates(s) for  the distributional parameter. In other
words, setting up the covariates for <code>sigma_formula</code> is same as for any
other fixed parameter such as <code>a</code> (see <code>a_formula</code> for details).
Note that <code>sigma_formula</code> estimates <code>sigma</code> parameter at
<code>log</code> scale. By default, the <code>sigma_formula</code> is <code>NULL</code>
because the <code><a href="brms.html#topic+brm">brms::brm()</a></code> itself models the <code>sigma</code> as a residual
standard deviation (<code>RSD</code>) parameter at the link scale. The
<code>sigma_formula</code> along with the arguments <code>sigma_formula_gr</code> and
<code>sigma_formula_gr_str</code> allow estimating the scale parameters as random
effects for <code>sigma</code>. The set up to specify the fixed and random effects
for <code>sigma</code> is similar to setting fixed and random effect structures
for other model parameters such as <code>a</code>, <code>b</code>, and <code>c</code>. It is
important to note that an alternative way to set up the fixed effect design
matrix for the distributional parameter <code>sigma</code> is to use the
<code>dpar_formula</code> argument. An advantage of <code>dpar_formula</code> over
<code>sigma_formula</code> is that user can specify the linear and nonlinear
formulation as allowed by the <code><a href="brms.html#topic+brmsformula-helpers">brms::lf()</a></code> and <code><a href="brms.html#topic+brmsformula-helpers">brms::nlf()</a></code> syntax. The
<code><a href="brms.html#topic+brmsformula-helpers">brms::lf()</a></code> and <code><a href="brms.html#topic+brmsformula-helpers">brms::nlf()</a></code> offer flexibility in centering the predictors
and also allows enabling/disabling of cell mean centering when excluding
<code>intercept</code> via <code>0 + </code> formulation. A disadvantage of
<code>dpar_formula</code> approach is that it is not possible to include random
effects for the <code>sigma</code>. Note that <code>sigma_formula</code> and
<code>dpar_formula</code> can not be specified together. When either
<code>sigma_formula</code> or <code>dpar_formula</code> is used, the default estimation
of the <code>RSD</code> by <code><a href="brms.html#topic+brm">brms::brm()</a></code> is automatically turned off.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_formula_gr">sigma_formula_gr</code></td>
<td>
<p>Formula for the random effect parameter, <code>sigma</code>
(default <code>NULL</code>). See <code>a_formula_gr</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_formula_gr_str">sigma_formula_gr_str</code></td>
<td>
<p>Formula for the random effect parameter,
<code>sigma</code> when fitting a hierarchical model with three or more
levels of hierarchy. See <code>a_formula_gr_str</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_dpar_formula">dpar_formula</code></td>
<td>
<p>Formula for the distributional fixed effect parameter,
<code>sigma</code> (default <code>NULL</code>). See <code>sigma_formula</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_autocor_formula">autocor_formula</code></td>
<td>
<p>Formula to set up the autocorrelation structure of
residuals (default <code>NULL</code>). Allowed autocorrelation structures are:
</p>

<ul>
<li><p> autoregressive moving average (<code>arma</code>) of order <code>p</code> and
<code>q</code> specified as <code>autocor_formula = ~arms(p=1, q=1)</code>.
</p>
</li>
<li><p> autoregressive (<code>ar</code>) of order <code>p</code> specified as
<code>autocor_formula = ~ar(p=1)</code>.
</p>
</li>
<li><p> moving average (<code>ma</code>) of order <code>q</code> specified as
<code>autocor_formula = ~ma(q=1)</code>.
</p>
</li>
<li><p> unstructured (<code>unstr</code>) over time (and individuals), The
<code>unstr</code> structure is specified as
<code>autocor_formula = ~unstr(time, id))</code>.
</p>
</li></ul>

<p>See <code><a href="brms.html#topic+brm">brms::brm()</a></code> for further details on modeling autocorrelation structure
of residuals</p>
</td></tr>
<tr><td><code id="bsitar_+3A_family">family</code></td>
<td>
<p>Family distribution (default <code>gaussian</code>) and the link
function (default <code>identity</code>). See <code><a href="brms.html#topic+brm">brms::brm()</a></code> for details on
available distributions and link functions, and how to specify them. For
<code>univariate_by</code> and <code>multivariate</code> models, the <code>family</code> can
be same (e.g., <code>family = gaussian()</code>) for sub models or different for
each sub model such as <code>family = list(gaussian(), student())</code> which
sets <code>gaussian</code> distribution for the first sub model and
<code>student_t</code> distribution for the second sub model. Please note that
argument <code>family</code> is ignored when use specifies <code>custom_family</code>
i.e., <code>custom_family</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_custom_family">custom_family</code></td>
<td>
<p>Specify  custom families (i.e. response distribution).
Default <code>NULL</code>. Please see <code><a href="brms.html#topic+custom_family">brms::custom_family()</a></code> for details. It is
important no note that user defined Stan functions must be expose by setting
<code>expose_functions = TRUE</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_custom_stanvars">custom_stanvars</code></td>
<td>
<p>Prepare and pass user-defined variables that need to be
added to the Stan's program blocks (default <code>NULL</code>). This is primarily
useful when defining <code>custom_family</code>. Please see
<code><a href="brms.html#topic+custom_family">brms::custom_family()</a></code> for details on specifying <code>stanvars</code>. Note that
<code>custom_stanvars</code> are passed directly without conducting any sanity
checks.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_group_arg">group_arg</code></td>
<td>
<p>Specify arguments for group-level random effects. The
<code>group_arg</code> should be a named list that may include <code>groupvar</code>,
<code>dist</code>, <code>cor</code> and <code>by</code> as described below:
</p>

<ul>
<li><p> The <code>groupvar</code> specifies the subject identifier. In case
<code>groupvar = NULL</code> (default), the <code>groupvar</code> is automatically
assigned based on the <code>id</code> argument.
</p>
</li>
<li><p> The <code>dist</code> specifies the distribution from which the random
effects are drawn (default <code>gaussian</code>). As per the <code><a href="brms.html#topic+brm">brms::brm()</a></code>
documentation, the <code>gaussian</code> distribution is the only available
distribution (as of now).
</p>
</li>
<li><p> The <code>by</code> argument can be used to estimate separate variance
covariance structure (i.e., standard deviation and correlation parameters)
for random effect parameters (default <code>NULL</code>). If specified, variable
used to set up the <code>by</code> argument must be a factor variable. For
example, <code>by = 'sex'</code> implies that separate variance covariance
structure are estimated for males and females.
</p>
</li>
<li><p> The <code>cor</code> is used to set up the covariance (i.e., correlation)
structure for random effect parameters. The default covariance is
unstructured (i.e, <code>cor = un</code>) for all three model settings, i.e.,
<code>univariate</code>, <code>univariate_by</code> and <code>multivariate</code>. The
alternative correlation structure available for <code>univariate</code> and
<code>univariate_by</code> models is <code>diagonal</code>. While the <code>cor = un</code>
models the full unstructured variance covariance structure, the <code>cor
 = diagonal</code> estimates only the variance (i.e, standard deviation) parameters
and the covariance (i.e., correlation) parameters are set to zero. For
<em>multivariate</em> model, options include <code>un</code>, <code>diagonal</code> and
<code>un_s</code>. The <code>un</code> sets up the unstructured correlation implying
that the group level random effects across response variables are drawn for
a joint multivariate normal distribution with shared correlation parameters.
The <code>cor = diagonal</code> specifies that only the variance parameter are
estimates for each sub model whereas the correlation parameters set to zero.
Option <code>cor = un_s</code> allows for estimating unstructured variance
covariance parameters separately for each response variable.
</p>
</li></ul>

<p>Note that user need not to define all or any of these options (i.e.,
<code>groupvar</code>, <code>dist</code>, <code>cor</code>, or <code>by</code>) because if
unspecified, they are are automatically set to their default values. Also
note that only <code>groupvar</code> from the <code>group_arg</code> argument is passed
on to the <em>univariate_by</em> and <em>multivariate</em> models because these
model have their own additional options specified via the
<code>univariate_by</code> and <code>multivariate</code> arguments. Lastly, the
<code>group_arg</code> is completely ignored when user specify random effects via
the vertical bar <code>||</code> approach (see <code>a_formula_gr</code> for details) or
when fitting a hierarchical model with three or more levels of hierarchy
(see <code>a_formula_gr_str</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_group_arg">sigma_group_arg</code></td>
<td>
<p>Specify arguments for modelling distributional level
random effects, <code>sigma</code>. The approach used in setting up the
<code>sigma_group_arg</code> is exactly same as described above for the group
level random effects (see <code>group_arg</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_univariate_by">univariate_by</code></td>
<td>
<p>Set up the univariate-by-subgroup model fitting (default
<code>NULL</code>) via a named list as described below:
</p>

<ul>
<li><p> The <code>by</code> (an optional character string) is used to specify the
variable (must be a factor variable) to define the sub models (default
<code>NA</code>).
</p>
</li>
<li><p> The <code>cor</code> (an optional character string) specifies the
correlation structure. The options available are <code>un</code> and
<code>diagonal</code>. The <code>un = un</code> (default) models the full unstructured
variance covariance structure, whereas the <code>cor = diagonal</code> estimates
only the variance (i.e, standard deviation) parameters and the covariance
(i.e., correlation) parameters are set to zero.
</p>
</li>
<li><p> The <code>terms</code> (an optional character string) specifies the method
used in setting up the sub models. Options are <code>'subset'</code> (default) and
<code>'weights'</code>. See <code>brms::`addition-terms`</code> for details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_multivariate">multivariate</code></td>
<td>
<p>Set up the multivariate model fitting (default
<code>NULL</code>) arguments as a named list:
</p>

<ul>
<li><p> The <code>mvar</code> (logical, default <code>FALSE</code>) indicates whether to
fit a multivariate model.
</p>
</li>
<li><p> The <code>cor</code> (an optional character string) sets up the correlation
structure. The options available are <code>un</code>, <code>diagonal</code> and
<code>un_s</code>. The <code>un</code> sets up the unstructured correlation implying
that the group level random effects across response variables are drawn for
a joint multivariate normal distribution with shared correlation parameters.
The <code>cor = diagonal</code> specifies that only the variance parameter are
estimates for each sub model whereas the correlation parameters set to zero.
Option <code>cor = un_s</code> allows for estimating unstructured variance
covariance parameters separately for each response variable.
</p>
</li>
<li><p> The <code>rescor</code> (logical, default <code>TRUE</code>) indicates whether to
estimate the residual correlation between response variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_a_prior_beta">a_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect parameter, <code>a</code>.
(default <code>student_t(3, ymean, ysd, autoscale = TRUE)</code>). The key points
in prior specification that are applicable for all parameters are
highlighted below. For full details on prior specification, please see
<code><a href="brms.html#topic+set_prior">brms::prior()</a></code>.
</p>

<ul>
<li><p> Allowed distributions are <code>normal</code>, <code>student_t</code>,
<code>cauchy</code>, <code>lognormal</code>, <code>uniform</code>, <code>exponential</code>,
<code>gamma</code> and <code>inv_gamma</code> (inverse gamma). </p>
</li>
<li><p> For each
distribution, upper and lower bounds can be set via options <code>lb</code> and
<code>ub</code> (default <code>NA</code> for both <code>lb</code> and <code>ub</code>). </p>
</li>
<li><p> For
location-scale based distributions (such as <code>normal</code>, <code>student_t</code>,
<code>cauchy</code>, and <code>lognormal</code>), an option <code>autosclae</code> (default
<code>FALSE</code>) can be used to multiply the scale parameter by a numeric
value. Both <span class="pkg">brms</span> and <span class="pkg">rstanarm</span> packages allow similar auto
scaling under the hood. While <span class="pkg">rstanarm</span> earlier used to set
<code>autosclae</code> as <code>TRUE</code> which internally multiplied scale parameter
by a value 2.5 (recently authors changed this behavior to <code>FALSE</code>), the
<span class="pkg">brms</span> package sets scaling factor as 1.0 or 2.5 depending on the
standard deviation of the response variable (See <code><a href="brms.html#topic+set_prior">brms::prior()</a></code>). The
<span class="pkg">bsitar</span> package offers full flexibility in choosing the scaling factor
as any real number instead of 1.0 or 2.5 (e.g., <code>autosclae = 5.0</code>).
When <code>autosclae = TRUE</code>, <code>2.5</code> is the default scaling factor.
</p>
</li>
<li><p> For location-scale based distributions such as <code>normal</code>, options
<code>fxl</code> (<code>function location</code>) and <code>fxs</code> (<code>function scale</code>)
are available to apply any function such as <code>log</code> and <code>sqrt</code>,
or a function defined in the R environment to transform the location and
scale parameters. For example, prior <code>normal(2, 5, fxl = 'log', fxs =
 'sqrt')</code> will be translated internally as <code>normal(log(2), sqrt(5))</code>
implying that the actually prior assigned will be  <code>normal(0.693,
 2.23)</code>. The default for both  <code>fxl</code> and <code>fxs</code> is <code>NULL</code>.
</p>
</li>
<li><p> Like <code>fxl</code> and <code>fxs</code> functions, another function <code>fxls</code>
(<code>function location scale</code>) is available to transform location and
scale parameters for the location-scale based distributions such
as <code>normal</code>. Unlike <code>fxl</code> and <code>fxs</code> functions which transform
location and scale parameters individually, the <code>fxls</code> function is used
for those transformation for which both location and scale parameters are
needed in the transformation of these parameters. For example, the
transformation of location and scale parameters for the normal prior on log
scale is as follows: <br />
<code>log_location = log(location / sqrt(scale^2 / location^2 + 1))</code>, <br />
<code>log_scale = sqrt(log(scale^2 / location^2 + 1))</code>, <br />
where location and scale are the original parameters supplied by the user
and log_location and log_scale are the equivalent parameters on the log
scale. The <code>fxls</code> can be set as a character string or a list comprised
of two functions where first function of the list will be used to transform
the location parameter and the second function will be for the scale
transformation. If a character string is used such as <code>fxls = 'log'</code>,
then the above transformation for the log parametrization will be applied
automatically. Note that if using a list, then the list must be crated
within the R environment and then passed this to the  <code>fxls</code> as: <br />
<code>location_fun &lt;- function(location, scale) {
 log(location / sqrt(scale^2 / location^2 + 1))
 }</code> <br />
<code>scale_fun &lt;- function(location, scale) {
 sqrt(log(scale^2 / location^2 + 1))
 }</code> <br />
fxls_fun &lt;- list(location_fun = location_fun, scale_fun = scale_fun) <br />
<code>fxls = 'fxls_fun'</code> <br />
As an example, <code>normal(2, 5, fxls = 'fxls_fun'</code>. The default for
<code>fxls</code> is <code>NULL</code>.
</p>
</li>
<li><p> For strictly positive distributions such as <code>exponential</code>,
<code>gamma</code> and <code>inv_gamma</code>, the lower bound (<code>lb</code>) is
automatically set to zero i.e., <code>lb = 0</code>. </p>
</li>
<li><p> For uniform
distribution, an option <code>addrange</code> is available to symmetrically widen
the prior range. For example, prior <code>uniform(a, b, addrange = 5)</code>
implies that the lower and upper limits will be evaluated as
<code>uniform(a-5, b+5)</code>. </p>
</li>
<li><p> For exponential distribution, the rate
parameter is evaluated as inverse. In other words, prior set as
<code>exponential(10)</code> is translated to 0.1 i.e.,
<code>exponential(1.0/10.0)</code>. </p>
</li>
<li><p> User need not to specify each option
explicitly because the missing options are set to their default values
automatically. For example, the prior specified as
<code>a_prior_beta = normal(location = 5, scale = 1, lb = NA, ub = NA,
 addrange = NA, autosclae = FALSE, fxl = NULL, fxs = NULL)</code>) is same
as <code>a_prior_beta = normal(5, 1)</code>).
</p>
</li>
<li><p> For <code>univariate_by</code> <code>multivariate</code> models, priors
can be same for sub models (e.g., <code>a_prior_beta =
 normal(5, 1)</code>), or different for each sub such as <code>a_prior_beta =
 list(normal(5,1), normal(10, 5)</code>).
</p>
</li></ul>

<p>The location parameter for the location-scale based distributions can be
specified as mean (by specifying <code>'ymean'</code>) or the median (by using
<code>'ymedian'</code>) of the response variable. Similarly, the scale parameter
can be set as the standard deviation (SD) or the median absolute deviation
(MAD) of the response variable via <code>'ysd'</code> and <code>'ymad'</code> options.
Another option available is to use the coefficients <code>'lm'</code> from the
simple linear model applied to the data (e.g., <code>lm(y ~ age, data =
 data</code>). This is true even when model has covariates i.e.,
<code>lm(y ~ age + cov, data = data</code>).  A few examples of specifying priors
using these options are: <br />
<code>a_prior_beta = normal(ymean, ysd)</code>, <br />
<code>a_prior_beta = normal(ymean, ysd)</code>, <br />
<code>a_prior_beta = normal(ymedian, ymad)</code>, <br />
<code>a_prior_beta = normal(lm, ysd)</code>, <br />
Note that options <code>'ymean'</code>, <code>'ymedian'</code>, <code>'ysd'</code>,
<code>'ymad'</code>, <code>'ymad'</code> and <code>'lm'</code> are available only for the
fixed effect parameter, <code>a</code> and not for parameters <code>b</code>, <code>c</code>
or <code>d</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_prior_beta">b_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect parameter, <code>b</code>.
(default <code>student_t(3, 0, 3.5, autoscale = FALSE)</code>). See
<code>a_prior_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_prior_beta">c_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect parameter, <code>c</code>.
(default <code>student_t(3, 0, 1.5, autoscale = FALSE)</code>). See
<code>a_prior_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_prior_beta">d_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect parameter, <code>d</code>.
(default <code>student_t(3, 0, 1.0, autoscale = FALSE)</code>). See
<code>a_prior_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_s_prior_beta">s_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect parameter, <code>s</code>
(i.e., spline coefficients). (default <code>student_t(3, 0, 'lm', autoscale
 = TRUE)</code>). The general approach is same as described
earlier for the fixed effect parameters (see <code>a_prior_beta</code> for
details). A few key points are highlighted below:
</p>

<ul>
<li><p> When specifying location-scale based priors using 'lm' such as
<code>s_prior_beta = normal(lm, 'lm')</code> , it sets spline coefficients
obtained from the simple linear model fit as location parameter whereas
scale parameter is based on the standard deviation of the spline design
matrix. However, typically, the location parameter is set at '0' (default),
and the autoscale option is set as <code>TRUE</code>.
</p>
</li>
<li><p> For location-scale based priors, an option <code>sethp</code> (logical,
default <code>FALSE</code>) is available to set up the hierarchical priors. To set <code>sethp</code> as <code>TRUE</code>, the prior is
specified as <code>s_prior_beta = normal(0, 'lm', autoscale = TRUE, sethp =
 TRUE)</code>). When <code>sethp = TRUE</code>, instead of setting prior as <code>s ~ normal(0,
 'lm')</code> the hierarchical priors are set as <code>s ~ normal(0, 'hp')</code> where
<code>'hp'</code> is defined as <code>hp ~ normal(0, 'lm')</code>. Note that the scale
parameter for the  <code>hp ~ normal(0, 'lm')</code> is automatically taken from the
<code>s ~ normal(0, 'hp')</code>. Setting <code>sethp = TRUE</code> implies that the
scale for spline coefficients is estimated from the data itself. The
distribution of hierarchical priors is automatically matched with the prior
set for the <code>s</code> parameter, or else can be set by the same <code>sethp</code>
option. For example, <code>s_prior_beta = normal(0, 'lm', sethp = cauchy)</code>
will be translated to <code>s ~ normal(0, 'lm')</code>, <code>hp  ~ cauchy(0, 'lm')</code>.
</p>
</li>
<li><p> For <code>uniform</code> priors, the  option<code>addrange</code> can be used to
symmetrically expand the prior range.
</p>
</li></ul>

<p>It is observed that location scale based prior distributions (e.g,
<code>normal</code>, <code>student_t</code>, and <code>cauchy</code>) perform well for the
spline coefficients.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_cov_prior_beta">a_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
fixed effect parameter, <code>a</code> (default <code>student_t(3, 0, 5.0,
 autoscale = FALSE)</code>). The approach is same as described earlier for the
<code>a_prior_beta</code> except that options <code>'ymean'</code>, <code>'ymedian'</code>,
<code>'ysd'</code>, and <code>'ymad'</code> are not allowed. The Option <code>'lm'</code> for
the location parameter sets covariate(s) coefficient obtained from the
simple linear model fit to the data. Note that option <code>'lm'</code> is allowed
only for the <code>a_cov_prior_beta</code> and not for the covariate(s) included
in the other fixed or random effect parameters. Lastly, separate priors can
be specified for sub models when fitting <code>univariate_by</code> and
<code>a_prior_beta</code> models (see <code>a_prior_beta</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_cov_prior_beta">b_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
fixed effect parameter, <code>b</code> (default <code>student_t(3, 0, 1.0,
 autoscale = FALSE)</code>). See <code>a_cov_prior_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_cov_prior_beta">c_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
fixed effect parameter, <code>c</code> (default <code>student_t(3, 0, 0.1,
 autoscale = FALSE)</code>). See <code>a_cov_prior_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_cov_prior_beta">d_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
fixed effect parameter, <code>d</code> (default <code>student_t(3, 0, 1.0,
 autoscale = FALSE)</code>). See <code>a_cov_prior_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_s_cov_prior_beta">s_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
fixed effect parameter, <code>s</code> (default <code>student_t(3, 0, 10.0,
 autoscale = FALSE)</code>). However, as described earlier, (see <code>s_formual</code>),
the <em>SITAR</em> model does not allows for inclusion of covariate(s) in the
spline design matrix. If and when covariate(s) are specified (see
<code>s_formual</code>), the approach of setting priors for the covariate(s)
included in the parameter, <code>s</code> via <code>s_cov_prior_beta</code> is same as
described earlier for the fixed effect parameter <code>a</code> (see
<code>a_cov_prior_beta</code>). For the location-scale based priors, the option
<code>'lm'</code> sets the location parameter same as the spline coefficients
obtained from fitting a simple linear to the data.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_prior_sd">a_prior_sd</code></td>
<td>
<p>Specify priors  for the random effect parameter, <code>a</code>.
(default <code>student_t(3, 0, 'ysd', autoscale = FALSE)</code>). Note that prior
is on the standard deviation (which is the square root of the variance) and
not on the variance itself. The approach of setting the prior is same as
described earlier for the fixed effect parameter, <code>a</code> (See
<code>a_prior_beta</code>) with the exception that location parameter is always
zero. The lower bound <code>0</code> is automatically set by the
<code>brms::brm()</code>. For <code>univariate_by</code> and <code>multivariate</code> models,
priors can be same for sub models or different for each sub model (See
<code>a_prior_beta</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_prior_sd">b_prior_sd</code></td>
<td>
<p>Specify priors  for the random effect parameter, <code>b</code>
(default <code>student_t(3, 0, 2.0, autoscale = FALSE)</code>). See
<code>a_prior_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_prior_sd">c_prior_sd</code></td>
<td>
<p>Specify priors  for the random effect parameter, <code>c</code>
(default <code>student_t(3, 0, 1.25, autoscale = FALSE)</code>). See
<code>a_prior_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_prior_sd">d_prior_sd</code></td>
<td>
<p>Specify priors  for the random effect parameter,
<code>d</code> (default <code>student_t(3, 0, 1.0, autoscale = FALSE)</code>). See
<code>a_prior_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_cov_prior_sd">a_cov_prior_sd</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>a</code> (default <code>student_t(3, 0, 5.0,
 autoscale = FALSE)</code>). The approach is same as described earlier for the
<code>a_cov_prior_beta</code> except that no pre-defined option (e.g.,
<code>'lm'</code>) is allowed.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_cov_prior_sd">b_cov_prior_sd</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>b</code> (default <code>student_t(3, 0, 1.0,
 autoscale = FALSE)</code>). See <code>a_cov_prior_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_cov_prior_sd">c_cov_prior_sd</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>c</code> (default <code>student_t(3, 0, 0.1,
 autoscale = FALSE)</code>). See <code>a_cov_prior_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_cov_prior_sd">d_cov_prior_sd</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>d</code> (default <code>student_t(3, 0, 1.0,
 autoscale = FALSE)</code>). See <code>a_cov_prior_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_prior_sd_str">a_prior_sd_str</code></td>
<td>
<p>Specify priors for the random effect parameter, <code>a</code>
when fitting a hierarchical model with three or more levels of hierarchy
(default <code>NULL</code>). The approach is same as described earlier (see the
<code>a_prior_sd</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_prior_sd_str">b_prior_sd_str</code></td>
<td>
<p>Specify priors for the random effect parameter, <code>b</code>
when fitting a hierarchical model with three or more levels of hierarchy
(default <code>NULL</code>). The approach is same as described earlier (see the
<code>a_prior_sd_str</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_prior_sd_str">c_prior_sd_str</code></td>
<td>
<p>Specify priors for the random effect parameter, <code>c</code>
when fitting a hierarchical model with three or more levels of hierarchy
(default <code>NULL</code>). The approach is same as described earlier (see the
<code>a_prior_sd_str</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_prior_sd_str">d_prior_sd_str</code></td>
<td>
<p>Specify priors for the random effect parameter, <code>d</code>
when fitting a hierarchical model with three or more levels of hierarchy
(default <code>NULL</code>). The approach is same as described earlier (see the
<code>a_prior_sd_str</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_cov_prior_sd_str">a_cov_prior_sd_str</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>a</code> when fitting a hierarchical model with
three or more levels of hierarchy (default <code>NULL</code>). The approach is
same as described earlier (see the <code>a_cov_prior_sd</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_cov_prior_sd_str">b_cov_prior_sd_str</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>b</code> when fitting a hierarchical model with
three or more levels of hierarchy (default <code>NULL</code>). The approach is
same as described earlier (see the <code>a_cov_prior_sd_str</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_cov_prior_sd_str">c_cov_prior_sd_str</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>c</code> when fitting a hierarchical model with
three or more levels of hierarchy (default <code>NULL</code>). The approach is
same as described earlier (see the <code>a_cov_prior_sd_str</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_cov_prior_sd_str">d_cov_prior_sd_str</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>d</code> when fitting a hierarchical model with
three or more levels of hierarchy (default <code>NULL</code>). The approach is
same as described earlier (see the <code>a_cov_prior_sd_str</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_prior_beta">sigma_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect distributional
parameter, <code>sigma</code> (default <code>student_t(3, 0, 1.0, autoscale =
 FALSE)</code>). The approach is same as described earlier for the fixed effect
parameter, <code>a</code> (See <code>a_prior_beta</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_cov_prior_beta">sigma_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in
the fixed effect distributional parameter, <code>sigma</code> (default
<code>student_t(3, 0, 0.5, autoscale = FALSE)</code>). The approach is same as
described earlier for the covariate(s) included the fixed effect parameter,
<code>a</code> (see <code>a_cov_prior_beta</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_prior_sd">sigma_prior_sd</code></td>
<td>
<p>Specify priors for the random effect distributional
parameter, <code>sigma</code> (default <code>student_t(3, 0, 0.25, autoscale =
 FALSE)</code>). The approach is same as described earlier the random effect
parameter <code>a</code> (see <code>a_prior_sd</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_cov_prior_sd">sigma_cov_prior_sd</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect distributional parameter, <code>sigma</code> (default
<code>student_t(3, 0, 0.15, autoscale = FALSE)</code>). The approach is same as
described earlier for the covariate(s) included in the random effect
parameter <code>a</code> (see <code>a_cov_prior_sd</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_prior_sd_str">sigma_prior_sd_str</code></td>
<td>
<p>Specify priors for the the random effect
distributional parameter, <code>sigma</code> when fitting a hierarchical model
with three or more levels of hierarchy (default <code>NULL</code>). The approach
is same as described earlier for the random effect parameter, <code>a</code> (See
<code>a_prior_sd_str</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_cov_prior_sd_str">sigma_cov_prior_sd_str</code></td>
<td>
<p>Specify priors for the covariate(s) included in
the random effect distributional parameter, <code>sigma</code> when fitting a
hierarchical model with three or more levels of hierarchy (default
<code>NULL</code>). The approach is same as described earlier for the covariate(s)
included in the random effect parameter, <code>a</code> (See
<code>a_cov_prior_sd_str</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_rsd_prior_sigma">rsd_prior_sigma</code></td>
<td>
<p>Specify priors for the residual standard deviation
parameter <code>sigma</code> (default <code>exponential('ysd', autoscale =
 TRUE)</code>). Note that this argument is evaluated only when both
<code>dpar_formula</code> and <code>sigma_formula</code> are <code>NULL</code>. For location
scale based distributions, user can use specify standard deviation
(<code>ysd</code>) or the median absolute deviation (<code>ymad</code>) as scale
parameter.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_dpar_prior_sigma">dpar_prior_sigma</code></td>
<td>
<p>Specify priors for the fixed effect distributional
parameter <code>sigma</code> (default <code>student_t(3, 0, 'ysd', autoscale =
 TRUE)</code>). The argument is evaluated only when
<code>sigma_formula</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_dpar_cov_prior_sigma">dpar_cov_prior_sigma</code></td>
<td>
<p>Specify priors for the covariate(s) included in
the fixed effect distributional parameter <code>sigma</code> (default
<code>student_t(3, 0, 1.0, autoscale = FALSE)</code>). The argument is evaluated
only when <code>sigma_formula</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_autocor_prior_acor">autocor_prior_acor</code></td>
<td>
<p>Specify priors for the autocorrelation parameters
when fitting a model with the <code>'arma'</code>, <code>'ar'</code> or the <code>'ma'</code>
autocorrelation structures (see <code>autocor_formula</code> for details). The
only allowed distribution is <code>uniform</code> distribution bounded between -1
and +1 (default <code>uniform(-1, 1, autoscale = FALSE)</code>). For the
unstructured residual correlation structure, a separate argument
<code>autocor_prior_unstr_acor</code> is used to specify the priors (see below).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_autocor_prior_unstr_acor">autocor_prior_unstr_acor</code></td>
<td>
<p>Specify priors for the autocorrelation
parameters when fitting a model with the unstructured (<code>'un'</code>)
autocorrelation structure (see <code>autocor_formula</code> for details). The
only allowed distribution is the <code>lkj</code> (default <code>lkj(1)</code>). See
<code>gr_prior_cor</code> below for details on setting up the <code>lkj</code> prior.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_gr_prior_cor">gr_prior_cor</code></td>
<td>
<p>Specify priors for the correlation parameter(s) of
group-level random effects (default <code>lkj(1)</code>). The only allowed
distribution is <code>lkj</code> that is specified via a single parameter
<code>eta</code> (see <code><a href="brms.html#topic+set_prior">brms::prior()</a></code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_gr_prior_cor_str">gr_prior_cor_str</code></td>
<td>
<p>Specify priors for the correlation parameter(s) of
group-level random effects when fitting a hierarchical model with three or
more levels of hierarchy (default <code>lkj(1)</code>). The approach is same as
described above (See <code>gr_prior_cor</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_prior_cor">sigma_prior_cor</code></td>
<td>
<p>Specify priors for the correlation parameter(s) of
distributional random effects <code>sigma</code> (default <code>lkj(1)</code>). The only
allowed distribution is <code>lkj</code> (see <code>gr_prior_cor</code> for details).
Note that currently <code>brms::brm()</code> does not allow for setting different
<code>lkj</code> priors for the group level and distributional random effects that
share the same group identifier (<code>id</code>). Therefore, either create a copy
of group identifier and use that but then this will not allow correlation
parameter across group random effects and sigma.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_prior_cor_str">sigma_prior_cor_str</code></td>
<td>
<p>Specify priors for the correlation parameter(s) of
distributional random effects <code>sigma</code> when fitting a hierarchical model
with three or more levels of hierarchy (default <code>lkj(1)</code>). The approach
is same as described above (See <code>sigma_prior_cor</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_mvr_prior_rescor">mvr_prior_rescor</code></td>
<td>
<p>Specify priors for the residual correlation parameter
when fitting a multivariate model (default <code>lkj(1)</code>). The only allowed
distribution is <code>lkj</code> (see <code>gr_prior_cor</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_init">init</code></td>
<td>
<p>Initial values for the sampler. If <code>init = '0'</code>, all
parameters are initialized to zero. For <code>init = 'random'</code>,
<strong>Stan</strong> will randomly generate initial values for each parameter
within a range specified by the <code>init_r</code> (see below), or between -2 and
2 in unconstrained space when <code>init_r = NULL</code>. Another available option
is <code>init = 'prior'</code> which sets initial values based on the prior
specified for each parameter. Lastly, when <code>init = NULL</code> (default),
initial value for each parameter is specified by the corresponding init
arguments defined see below.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_init_r">init_r</code></td>
<td>
<p>A positive real value to set range for the random generation of
initial values (default <code>NULL</code>). This argument is evaluated only when
<code>init = 'random'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_init_beta">a_init_beta</code></td>
<td>
<p>Initial values for the fixed effect parameter, <code>a</code>
(default 'lm'). Options available are <code>'0'</code>, <code>'random'</code> and
<code>'prior'</code>. In addition, user can specify <code>'ymean'</code> and
<code>'ymedian'</code> to set initial as the mean or the median of the response
variable. Also, option <code>'lm'</code> can be used to set coefficients obtained
from the simple linear model fitted to the data as initial values for the
fixed effect parameter, <code>a</code>. Note that this is similar to the location
parameter for prior on the fixed effect parameter <code>a</code> (see
<code>a_prior_beta</code> for details). These options (<code>'ymean'</code>,
<code>'ymedian'</code>, and <code>'lm'</code>) are available only for the fixed effect
parameter <code>a</code> and not for other parameters described below. Lastly, For
<code>univariate_by</code> and <code>multivariate</code> models, the initials can be
same (e.g., <code>a_init_beta = 0</code>) for sub models or different for each sub
model such as <br /> <code>list(a_init_beta = '0', a_init_beta = 'lm')</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_init_beta">b_init_beta</code></td>
<td>
<p>Initial values for the fixed effect parameter, <code>b</code>
(default '0'). See <code>a_init_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_init_beta">c_init_beta</code></td>
<td>
<p>Initial values for the fixed effect parameter, <code>c</code>
(default '0'). See <code>a_init_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_init_beta">d_init_beta</code></td>
<td>
<p>Initial values for the fixed effect parameter, <code>d</code>
(default '0'). See <code>a_init_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_s_init_beta">s_init_beta</code></td>
<td>
<p>Initial values for the fixed effect parameter, <code>s</code>
(default 'lm'). Options available are <code>'0'</code>, <code>'random'</code>,
<code>'prior'</code>, and <code>'lm'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_cov_init_beta">a_cov_init_beta</code></td>
<td>
<p>Initial values for the covariate(s) included in the
fixed effect parameter, <code>a</code> (default '0'). Options available are
<code>'0'</code>, <code>'random'</code>, <code>'prior'</code> and <code>'lm'</code>. The option
<code>'lm'</code> is available only for the <code>a_cov_init_beta</code> and not for the
covariate(s) included in other fixed effect parameters <code>b</code>, <code>c</code>,
or <code>d</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_cov_init_beta">b_cov_init_beta</code></td>
<td>
<p>Initial values for covariate(s) included in the fixed
effect parameter, <code>b</code> (default '0'). See <code>a_cov_init_beta</code> for
details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_cov_init_beta">c_cov_init_beta</code></td>
<td>
<p>Initial values for covariate(s) included in the fixed
effect parameter, <code>c</code> (default '0'). See <code>a_cov_init_beta</code> for
details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_cov_init_beta">d_cov_init_beta</code></td>
<td>
<p>Initial values for covariate(s) included in the fixed
effect parameter, <code>d</code> (default '0'). See <code>a_cov_init_beta</code> for
details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_s_cov_init_beta">s_cov_init_beta</code></td>
<td>
<p>Initial values for covariate(s) included in the fixed
effect parameter, <code>s</code> (default 'lm'). See <code>a_cov_init_beta</code> for
details. The option <code>'lm'</code> will set the spline coefficients obtained
from the simple linear model fitted to the data. Note that
<code>s_cov_init_beta</code> is only a placeholder and is not valuated because
covariate(s) are not allowed for the <code>s</code> parameter. See
<code>s_formula</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_init_sd">a_init_sd</code></td>
<td>
<p>Initial value for the standard deviation of group level
random effect parameter, <code>a</code> (default 'random'). Options available are
<code>'0'</code>, <code>'random'</code> and <code>'prior'</code>. In addition, <code>'ysd'</code>,
<code>'ymad'</code>, <code>'lme_sd_a'</code>, and <code>'lm_sd_a'</code> can be used to
specify initial values as described below:
</p>

<ul>
<li><p> The <code>'ysd'</code> sets standard deviation (<code>sd</code>) of the response
variable as an initial value.
</p>
</li>
<li><p> The <code>'ymad'</code> sets median absolute deviation (<code>mad</code>) of the
response variable as an initial value.
</p>
</li>
<li><p> The <code>'lme_sd_a'</code> sets initial value based on the standard
deviation of random Intercept obtained from the linear mixed model
(<code>nlme::lme()</code>) fitted to the data. Note that in case
<code>nlme::lme()</code> fails to converge, the option <code>'lm_sd_a'</code>
(see below) is set automatically.
</p>
</li>
<li><p> The <code>'lm_sd_a'</code> sets square root of the residual variance
obtained from the simple linear model applied to the data as an initial
value.
</p>
</li></ul>

<p>Note that these option described above (<code>'ysd'</code>, <code>'ymad'</code>,
<code>'lme_sd_a'</code>, and <code>'lm_sd_a'</code>) are available only for the random
effect parameter <code>a</code> and not for other group level random effects.
Lastly, when fitting <code>univariate_by</code> and <code>multivariate</code> models,
user can set same initials for sub models, or different for each sub model.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_init_sd">b_init_sd</code></td>
<td>
<p>Initial value for the standard deviation of group level
random effect parameter, <code>b</code> (default 'random'). See <code>a_init_sd</code>
for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_init_sd">c_init_sd</code></td>
<td>
<p>Initial values for the group level random effect parameter,
<code>c</code> (default 'random'). See <code>a_init_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_init_sd">d_init_sd</code></td>
<td>
<p>Initial value for the standard deviation of group level
random effect parameter, <code>d</code> (default 'random'). See <code>a_init_sd</code>
for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_cov_init_sd">a_cov_init_sd</code></td>
<td>
<p>Initial values for the covariate(s) included in the
random effect parameter, <code>a</code> (default 'random'). Options available are
<code>'0'</code>, <code>'random'</code> and <code>'prior'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_cov_init_sd">b_cov_init_sd</code></td>
<td>
<p>Initial values for the covariate(s) included in the
random effect parameter, <code>b</code> (default 'random'). See
<code>a_cov_init_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_cov_init_sd">c_cov_init_sd</code></td>
<td>
<p>Initial values for the covariate(s) included in the
random effect parameter, <code>c</code> (default 'random'). See
<code>a_cov_init_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_cov_init_sd">d_cov_init_sd</code></td>
<td>
<p>Initial values for the covariate(s) included in the
random effect parameter, <code>d</code> (default 'random'). See
<code>a_cov_init_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_init_beta">sigma_init_beta</code></td>
<td>
<p>Initial values for the fixed effect distributional
parameter, <code>sigma</code> (default 'random'). Options available are
<code>'0'</code>, <code>'random'</code> and <code>'prior'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_cov_init_beta">sigma_cov_init_beta</code></td>
<td>
<p>Initial values for the covariate(s)
included in the fixed effect distributional parameter, <code>sigma</code> (See
<code>sigma_init_beta</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_init_sd">sigma_init_sd</code></td>
<td>
<p>Initial value for the standard deviation of
distributional random effect parameter, <code>sigma</code> (default 'random'). The
approach is same as described earlier for the group level random effect
parameters such as <code>a</code> (See <code>a_init_sd</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_cov_init_sd">sigma_cov_init_sd</code></td>
<td>
<p>Initial values for the covariate(s) included in the
distributional random effect parameter, <code>sigma</code> (default 'random').
(See <code>a_cov_init_sd</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_gr_init_cor">gr_init_cor</code></td>
<td>
<p>Initial values for the correlation parameters of
group-level random effects parameters (default 'random'). Allowed options
are <code>'0'</code>, <code>'random'</code> and <code>'prior'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_init_cor">sigma_init_cor</code></td>
<td>
<p>Initial values for the correlation parameters of
distributional random effects parameter <code>sigma</code> (default 'random').
Allowed options are <code>'0'</code>, <code>'random'</code> and <code>'prior'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_rsd_init_sigma">rsd_init_sigma</code></td>
<td>
<p>Initial values for the residual standard deviation
parameter, <code>sigma</code> (default 'random'). Options available are
<code>'0'</code>, <code>'random'</code> and <code>'prior'</code>. In addition, options
<code>'lme_rsd'</code> and <code>'lm_rsd'</code> can be used as follows. The
<code>lme_rsd</code> sets initial value based on the standard deviation of
residuals obtained from the linear mixed model (<code>nlme::lme()</code>) fitted
to the data. The initial value set by the <code>'lm_rsd'</code> is the square root
of the residual variance from the simple linear model applied to the data.
Note that in case <code>nlme::lme()</code> fails to converge, then option
<code>'lm_sd_a'</code> is set automatically. The argument <code>rsd_init_sigma</code> is
evaluated when <code>dpar_formula</code> and <code>sigma_formula</code> are set to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_dpar_init_sigma">dpar_init_sigma</code></td>
<td>
<p>Initial values for the distributional parameter
<code>sigma</code> (default 'random'). The approach and options available are same
as described above for the <code>rsd_init_sigma</code>. This argument is evaluated
only when <code>dpar_formula</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_dpar_cov_init_sigma">dpar_cov_init_sigma</code></td>
<td>
<p>Initial values for the covariate(s) included in the
distributional parameter, <code>sigma</code> (default 'random'). Allowed options
are <code>'0'</code>, <code>'random'</code>, and <code>'prior'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_autocor_init_acor">autocor_init_acor</code></td>
<td>
<p>Initial values for autocorrelation parameter (see
<code>autocor_formula</code> for details). Allowed options are <code>'0'</code>,
<code>'random'</code>, and <code>'prior'</code> (default 'random').</p>
</td></tr>
<tr><td><code id="bsitar_+3A_autocor_init_unstr_acor">autocor_init_unstr_acor</code></td>
<td>
<p>Initial values for unstructured residual
autocorrelation parameters (default 'random'). Allowed options are
<code>'0'</code>, <code>'random'</code>, and <code>'prior'</code>. Note that the approach to
set initials for <code>autocor_init_unstr_acor</code> is identical to the
<code>gr_init_cor</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_mvr_init_rescor">mvr_init_rescor</code></td>
<td>
<p>Initial values for the residual correlation parameter
when fitting a <code>multivariate</code> model (default 'random'). Allowed options
are <code>'0'</code>, <code>'random'</code>, and <code>'prior'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_r_init_z">r_init_z</code></td>
<td>
<p>Initial values for the standardized group level random effect
parameters (default 'random'). These parameters are part of the Non-Centered
Parameterization (NCP) approach used in the <code><a href="brms.html#topic+brm">brms::brm()</a></code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_vcov_init_0">vcov_init_0</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to set initials for
variance (i.e, standard deviation) and covariance (i.e., correlation)
parameters as zero. This allows for setting custom initials for the fixed
effects parameters but zero for variance covariance parameters.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_jitter_init_beta">jitter_init_beta</code></td>
<td>
<p>A value as proportion (between 0 and 1) to perturb the
initial values for fixed effect parameters. The default is <code>NULL</code>
indicating that same initials are used across all chains. A sensible option
can be <code>jitter_init_beta = 0.1</code> as it mildly perturb the initials. Note
that jitter is not absolute but proportion of the specified initial value.
For example, if initial value is <code>100</code>, then <code>jitter_init_beta =
 0.1</code> implies that the perturbed initial value will be within <code>90</code> and
<code>110</code>. On the other hand, if initial values is <code>10</code>, then the
perturbed initial value will be within <code>9</code> and <code>11</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_jitter_init_sd">jitter_init_sd</code></td>
<td>
<p>A value as proportion (between 0 and 1) to perturb
the initials for standard deviation of random effect parameters. The default
is <code>NULL</code> indicating that same initials are used across all chains.
An option of setting <code>jitter_init_beta = 0.01</code> looked good during early
testing.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_jitter_init_cor">jitter_init_cor</code></td>
<td>
<p>A value as proportion (between 0 and 1) to perturb the
initials for correlation parameters of random effects. The default is
<code>NULL</code> indicating that same initials are used across all chains. An
option of setting <code>jitter_init_beta = 0.001</code> looked good during early
testing.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_prior_data">prior_data</code></td>
<td>
<p>An optional argument (a named list, default <code>NULL</code>)
that can be used to pass information to the prior arguments for each
parameter (e.g., <code>a_prior_beta</code>). The <code>prior_data</code> is particularly
helpful in passing a long vector or a matrix as priors. These vectors and
matrices can be created in the R framework and then passed using the
<code>prior_data</code>. For example, to pass a vector of location and scale
parameters when setting priors for covariate coefficients (with 10 dummy
variables) included in the fixed effects parameter <code>a</code>, the following
steps can be used to set covariate priors that each has scale parameter
(<code>sd</code>) as 5 but mean values are drawn from a normal distribution with
<code>mean = 0</code> and <code>sd = 1</code>:
</p>

<ul>
<li><p> create the named objects <code>prior_a_cov_location</code> and
<code>prior_a_cov_scale</code> in the R environment as follows: <br />
<code>prior_a_cov_location &lt;- rnorm(n = 10, mean = 0, sd = 1)</code> <br />
<code>prior_a_cov_scale &lt;- rep(5, 10)</code> <br />
</p>
</li>
<li><p> specify the above created objects <code>prior_a_cov_location</code> and
<code>prior_a_cov_scale</code> in the <code>prior_data</code> as follows: <br />
<code>prior_data = list(prior_a_cov_location = prior_a_cov_location, 
 prior_a_cov_scale = prior_a_cov_scale)</code>.
</p>
</li>
<li><p> now use the <code>prior_data</code> objects to set up the priors as: <br />
<code>a_cov_prior_beta = normal(prior_a_cov_location, prior_a_cov_scale)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_init_data">init_data</code></td>
<td>
<p>An optional argument (a named list, default <code>NULL</code>) that
can be used to pass information to the initial arguments. The approach is
the exact same as described above for the <code>prior_data</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_init_custom">init_custom</code></td>
<td>
<p>Specify a custom initials object (a named list). The named
list is directly passed to the <code>init</code> argument without checking for the
dimensions and name matching. Note that in case initials are set for
some parameter by using parameter specific argument (e.g., <code>a_init_beta
 = 0</code>), then <code>init_custom</code> is only passed to those parameters for which
initials are missing. If user want to override this behaviors i.e., to pass
all <code>init_custom</code> ignoring parameter specific initials, then
<code>init</code> should be set as <code>init = 'custom'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the model
formula priors, and initials. As an example, the user might be interested in
knowing the response variables created for the sub model when fitting a
univariate-by-subgroup model. This information can then be used in setting
the desired order of options passed to each such model such as <code>df</code>,
<code>prior</code>, <code>initials</code> etc.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to expose Stan function used in model fitting.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_stancode">get_stancode</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
get the stancode (see <code><a href="brms.html#topic+stancode.brmsfit">brms::stancode()</a></code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_standata">get_standata</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
get the standata (see <code><a href="brms.html#topic+standata.brmsfit">brms::standata()</a></code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_formula">get_formula</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
get the formula. (see <code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_stanvars">get_stanvars</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
get the stanvars (see <code><a href="brms.html#topic+stanvar">brms::stanvar()</a></code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_priors">get_priors</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
get the priors. (see <code>brms::get_prior()</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_priors_eval">get_priors_eval</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
get the priors specified by the user.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_init_eval">get_init_eval</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
get the initial values specified by the user.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_validate_priors">validate_priors</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
validate the specified priors. (see <code><a href="brms.html#topic+validate_prior">brms::validate_prior()</a></code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_set_self_priors">set_self_priors</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to manually
specify the priors. Note that <code>set_self_priors</code> is passed directly to
the <code><a href="brms.html#topic+brm">brms::brm()</a></code> without performing any checks.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_set_replace_priors">set_replace_priors</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to
replace part of prior object. This is for internal use only.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_set_same_priors_hierarchy">set_same_priors_hierarchy</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to
replace part of the prior object. This is for internal use only.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_outliers">outliers</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to remove outliers.
The argument should be a named list which is passed directly to the
<code><a href="sitar.html#topic+velout">sitar::velout()</a></code> and <code><a href="sitar.html#topic+codeplot">sitar::zapvelout()</a></code> functions. This is for internal
use only.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_unused">unused</code></td>
<td>
<p>An optional formula that defines variables that are unused in
the model but should still be stored in the model's data frame. This can be
useful when variables are required during the post-processing.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains (default 4).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_iter">iter</code></td>
<td>
<p>Number of total iterations per chain, including warmup (default
2000)</p>
</td></tr>
<tr><td><code id="bsitar_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the number of warmup (aka burnin)
iterations. This also specifies the number of iterations used for stepsize
adaptation, so warmup draws should not be used for inference. The number of
warmup should not be larger than <code>iter</code> and the default is
<code>iter/2</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_thin">thin</code></td>
<td>
<p>A positive integer. Set <code>thin &gt; 1</code> to save memory and
computation time if <code>iter</code> is large. The <code>thin &gt; 1</code> is often used
in cases with high autocorrelation of MCMC draws An indication of high
autocorrelation is poor mixing of chain ( i.e., high <code>rhat</code> values)
despite the fact that model recovers the parameters well. An easy diagnostic
to check for autocorrelation of MCMC draws is to use the <code>mcmc_acf</code>
function from the <span class="pkg">bayesplot</span>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used when executing the chains in parallel.
See <code><a href="brms.html#topic+brm">brms::brm()</a></code> for details. Note that unlike <code><a href="brms.html#topic+brm">brms::brm()</a></code>, which sets
default <code>cores</code> argument as <code>cores=getOption("mc.cores", 1)</code>, the
default <code>cores</code> in <span class="pkg">bsitar</span> package is
<code>cores=getOption("mc.cores", 'optimize')</code> which optimizes the
utilization of system resources. The maximum number of cores that can be
deployed is calculated as the maximum number of available cores minus 1.
When the number of available cores is greater than the number of chains (see
<code>chains</code>), then number of cores is set equal to the number of chains.
Another option is to set <code>cores</code> as <code>getOption("mc.cores",
 'maximise')</code> which sets the number of cores as the maximum number of cores
available from the system regardless of the number of chains specified. Note
that the user can also set <code>cores</code> argument similar to the
<code><a href="brms.html#topic+brm">brms::brm()</a></code> i.e., <code>getOption("mc.cores", 1)</code>. All these three options
can be set globally as <code>options(mc.cores = x</code>) where x can be
<code>'optimize'</code>, <code>'maximise'</code> or <code>1</code>. Lastly, the <code>cores</code>
can set by directly by specifying an integer e.g., <code>cores = 4</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_backend">backend</code></td>
<td>
<p>A character string naming the package to be used when executing
the the Stan model. Options are <code>"rstan"</code> (the default) or
<code>"cmdstanr"</code>. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.backend"</code>. See <code><a href="brms.html#topic+brm">brms::brm()</a></code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_threads">threads</code></td>
<td>
<p>Number of threads to be used in within-chain parallelization.
Note that unlike the <code><a href="brms.html#topic+brm">brms::brm()</a></code> which sets the <code>threads</code> argument as
<code>getOption("brms.threads", NULL)</code> implying that no within-chain
parallelization is used by default, the <span class="pkg">bsitar</span> package, by default,
sets <code>threads</code> as <code>getOption("brms.threads", 'optimize')</code> to
utilize the available resources from the modern computing systems. The
number of threads per chain is set as the maximum number of cores available
minus 1. Another option is to set <code>threads</code> as
<code>getOption("brms.threads", 'maximise')</code> which set the number threads
per chains same as the  maximum number of cores available. User can also set
the <code>threads</code> similar to the <code>brms</code> i.e.,
<code>getOption("brms.threads", NULL)</code>. All these three options can be set
globally as <code>options(brms.threads = x</code>) where x can be
<code>'optimize'</code>, <code>'maximise'</code> or <code>NULL</code>.
Alternatively, the number of threads can be set directly as <code>threads
 = threading(x)</code> where <code>X</code> is an integer. Other arguments that can be
passed to the <code>threads</code> are <code>grainsize</code> and the <code>static</code>. See
<code><a href="brms.html#topic+brm">brms::brm()</a></code> for further details on within-chain parallelization.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_opencl">opencl</code></td>
<td>
<p>The platform and device IDs of the OpenCL device to use for
fitting using GPU support. If you don't know the IDs of your OpenCL device,
<code>c(0,0)</code> is most likely what you need. For more details, see
<code><a href="brms.html#topic+opencl">opencl</a></code>. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.opencl"</code> option.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_normalize">normalize</code></td>
<td>
<p>Indicates whether normalization constants should be included
in the Stan code (default <code>TRUE</code>). Setting it to <code>FALSE</code> requires
Stan version &gt;= 2.25. If <code>FALSE</code>, sampling efficiency may be increased
but some post processing functions such as <code><a href="brms.html#topic+bridge_sampler.brmsfit">brms::bridge_sampler()</a></code> will not
be available. This option can be controlled globally via the
<code>brms.normalize</code> option.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string naming the estimation approach to use.
Options are <code>"sampling"</code> for MCMC (the default), <code>"meanfield"</code> for
variational inference with independent normal distributions,
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution, or <code>"fixed_param"</code> for sampling from fixed parameter
values. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.algorithm"</code> option (see <code><a href="base.html#topic+options">options</a></code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> to control the sampler's behavior. The
default are same as <code><a href="brms.html#topic+brm">brms::brm()</a></code> with the exception that the
<code>max_treedepth</code> has been increased form 10 to 12 to allow better
exploration of typically challenging posterior geometry posed by the
nonlinear model. However, another control parameter, the <code>adpat_delta</code>
which is also  often need to be increased for nonlinear model, has be set to
default setting as in <code><a href="brms.html#topic+brm">brms::brm()</a></code> i.e, 0.8. This is to avoid unnecessarily
increasing the sampling time. See <code><a href="brms.html#topic+brm">brms::brm()</a></code> for full details on control
parameters and their default values.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sample_prior">sample_prior</code></td>
<td>
<p>Indicates whether to draw sample from priors in addition
to the posterior draws. Options are <code>"no"</code> (the default), <code>"yes"</code>,
and <code>"only"</code>. Among others, these draws can be used to calculate Bayes
factors for point hypotheses via <code><a href="brms.html#topic+hypothesis.brmsfit">brms::hypothesis()</a></code>. Please note that
improper priors are not sampled, including the default improper priors used
by <code>brm</code>. See <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code> on how to set (proper) priors. Please
also note that prior draws for the overall intercept are not obtained by
default for technical reasons. See <code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code> how to obtain prior
draws for the intercept. If <code>sample_prior</code> is set to <code>"only"</code>,
draws are drawn solely from the priors ignoring the likelihood, which allows
among others to generate draws from the prior predictive distribution. In
this case, all parameters must have proper priors.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_save_pars">save_pars</code></td>
<td>
<p>An object generated by <code><a href="brms.html#topic+save_pars">save_pars</a></code> controlling
which parameters should be saved in the model. The argument has no impact on
the model fitting itself.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_drop_unused_levels">drop_unused_levels</code></td>
<td>
<p>Should unused factors levels in the data be dropped?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_stan_model_args">stan_model_args</code></td>
<td>
<p>A <code>list</code> of further arguments passed to
<code><a href="rstan.html#topic+stan_model">rstan::stan_model</a></code> for <code>backend =
  "rstan"</code> or <code>backend = "cmdstanr"</code>, which allows to change how
models are compiled.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_refresh">refresh</code></td>
<td>
<p>An integer to set the printing of every nth iteration. Default
<code>NULL</code> indicates that refresh will be set automatically by the
<code><a href="brms.html#topic+brm">brms::brm()</a></code>. Setting  <code>refresh</code> is useful especially when <code>thin</code>
is greater than <code>1</code>. In that case, the <code>refresh</code> is recalculated
as (<code>refresh</code> * <code>thin</code>) / <code>thin</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_silent">silent</code></td>
<td>
<p>Verbosity level between <code>0</code> and <code>2</code>. If <code>1</code> (the
default), most of the informational messages of compiler and sampler are
suppressed. If <code>2</code>, even more messages are suppressed. The actual
sampling progress is still printed. Set <code>refresh = 0</code> to turn this off
as well. If using <code>backend = "rstan"</code> you can also set
<code>open_progress = FALSE</code> to prevent opening additional progress bars.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation to make results
reproducible. If <code>NA</code> (the default), <span class="pkg">Stan</span> will set the seed
randomly.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_save_model">save_model</code></td>
<td>
<p>A character string or <code>NULL</code> (default). If not
<code>NULL</code>, then the model's Stan code is saved via in a text file named
after the string supplied in <code>save_model</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_fit">fit</code></td>
<td>
<p>An instance of S3 class <code>brmsfit</code> derived from a previous fit;
defaults to <code>NA</code>. If <code>fit</code> is of class <code>brmsfit</code>, the
compiled model associated with the fitted result is re-used and all
arguments modifying the model code or data are ignored. It is not
recommended to use this argument directly, but to call the
<code><a href="brms.html#topic+update.brmsfit">update</a></code> method, instead.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_file">file</code></td>
<td>
<p>Either <code>NULL</code> or a character string. In the latter case, the
fitted model object is saved via <code><a href="base.html#topic+saveRDS">saveRDS</a></code> in a file named after
the string supplied in <code>file</code>. The <code>.rds</code> extension is added
automatically. If the file already exists, <code>brm</code> will load and return
the saved model object instead of refitting the model. Unless you specify
the <code>file_refit</code> argument as well, the existing files won't be
overwritten, you have to manually remove the file in order to refit and save
the model under an existing file name. The file name is stored in the
<code>brmsfit</code> object for later usage.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_file_compress">file_compress</code></td>
<td>
<p>Logical or a character string, specifying one of the
compression algorithms supported by <code><a href="base.html#topic+saveRDS">saveRDS</a></code>. If the
<code>file</code> argument is provided, this compression will be used when saving
the fitted model object.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_file_refit">file_refit</code></td>
<td>
<p>Modifies when the fit stored via the <code>file</code> argument is
re-used. Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.file_refit"</code> option (see <code><a href="base.html#topic+options">options</a></code>). For
<code>"never"</code> (default) the fit is always loaded if it exists and fitting
is skipped. For <code>"always"</code> the model is always refitted. If set to
<code>"on_change"</code>, brms will refit the model if model, data or algorithm as
passed to Stan differ from what is stored in the file. This also covers
changes in priors, <code>sample_prior</code>, <code>stanvars</code>, covariance
structure, etc. If you believe there was a false positive, you can use
<code><a href="brms.html#topic+brmsfit_needs_refit">brmsfit_needs_refit</a></code> to see why refit is deemed necessary.
Refit will not be triggered for changes in additional parameters of the fit
(e.g., initial values, number of iterations, control arguments, ...). A
known limitation is that a refit will be triggered if within-chain
parallelization is switched on/off.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_future">future</code></td>
<td>
<p>Logical; If <code>TRUE</code>, the <span class="pkg"><a href="future.html#topic+future">future</a></span>
package is used for parallel execution of the chains and argument
<code>cores</code> will be ignored. Can be set globally for the current <span class="rlang"><b>R</b></span> session
via the <code>"future"</code> option. The execution type is controlled via
<code><a href="future.html#topic+plan">plan</a></code> (see the examples section below).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_parameterization">parameterization</code></td>
<td>
<p>A character string to specify Non-centered
parameterization, NCP (<code>'ncp'</code>) or the Centered parameterization, CP
(<code>'cp'</code>) to draw group level random effect. The NCP is generally
recommended when likelihood is not strong (e.g., a few number of
observations per individual). The NCP is the default (and only) approach
implemented in the <code><a href="brms.html#topic+brm">brms::brm()</a></code>. The CP parameterization, on the other
hand, is often considered more efficient than NCP when a relatively large
number of observations are available across individual. The 'relatively
large number' is not defined in the literature and we follow a general
approach wherein CP parameterization is used when each individual provides
at least 10 repeated measurements and NCP otherwise. Note this automatic
behavior is set only when the argument <code>parameterization = NULL</code>. To
set CP parameterization, use <code>parameterization = 'cp'</code>. The default is
<code>parameterization = 'ncp'</code>. Note that since <code><a href="brms.html#topic+brm">brms::brm()</a></code> does not
offer CP parameterization, the <code><a href="brms.html#topic+brm">brms::brm()</a></code> generated <code>stancode</code> is
first edited internally and then the model is fit using the <code><a href="rstan.html#topic+rstan">rstan::rstan()</a></code>
or <code>cmdstanr</code>, depending on the <code>backend</code> choice. Therefore, we
caution that CP parameterization should be considered experimental and it
may fail if structure of the <code><a href="brms.html#topic+brm">brms::brm()</a></code> generated <code>stancode</code> changes
in future.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+brm">brms::brm()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>SITAR</em> is a shape-invariant nonlinear mixed effect growth
curve model that fits a population average (i.e., mean average) curve to
the data, and aligns each individual's growth trajectory to the underlying
population average curve via a set of (typically) three random effects: the
<code>size</code>, <code>timing</code> and <code>intensity</code>. Additionally, a slope
parameter can be included as a random effect to estimate the variability in
adult growth rate (See <code><a href="sitar.html#topic+sitar">sitar::sitar()</a></code> for details). The concept of shape
invariant model (SIM) was first described by
Lindstrom (1995) and later used by
Beath (2007) to model infant growth data (birth
to 2 years). The current version of the <em>SITAR</em> model is developed by
Cole et al. (2010) and has been used extensively for
modelling growth data
(see Nembidzane et al. 2020 and Sandhu 2020).
</p>
<p>The frequentist version of the <em>SITAR</em> model can be fit by using an
already available R package, the <span class="pkg">sitar</span> (Cole 2022).
The framework of Bayesian implementation of the <em>SITAR</em> model in
<span class="pkg">bsitar</span> package is same as the <span class="pkg">sitar</span> package with the exception
that unlike the <span class="pkg">sitar</span> package which uses B spline basis for the
natural cubic spline design matrix (by calling the <code><a href="splines.html#topic+ns">splines::ns()</a></code>), the
<span class="pkg">bsitar</span> package uses the truncated power basis approach (see
Harrell and others (2001), and
Harrell Jr. (2022) for details) to construct the spline
design matrix. Note that <span class="pkg">bsitar</span> package builds the spline design
matrix on the fly which is then included in the <code>functions</code> block of
the <strong>Stan</strong> program and hence compiled (via the c++) during the model fit.
</p>
<p>Like <span class="pkg">sitar</span> package (Cole et al. 2010), the <span class="pkg">bsitar</span>
package fits <em>SITAR</em> model with (usually) up to three random effects:
the size (parameter defined as <code>a</code>), the timing (parameter defined as
<code>b</code>) and the intensity (parameter defined as <code>c</code>). In addition,
there is a slope parameter (defined as <code>d</code>) that models the variability
in the adult slope of the growth curve (See <code><a href="sitar.html#topic+sitar">sitar::sitar()</a></code> for details).
Please note that author of the <span class="pkg">sitar</span> package
(Cole et al. 2010) enforces the inclusion of parameter
<code>d</code> as a random effects only and therefore excludes it from the
fixed fixed structure of the model. However, the <span class="pkg">bsitar</span> package allows
inclusion of parameter <code>d</code> in fixed and/or in the random effects
structures of the <em>SITAR</em> model. For the three parameter version of the
<em>SITAR</em> model (default), the fixed effects structure (i.e., population
average trajectory) is specified as <code>fixed = 'a+b+c'</code>, and the
random effects structure that captures the deviation of individual
trajectories from the population average curve is specified as <code>random
 = 'a+b+c'</code>. Note that user need not to include all the three parameters in
the fixed or the random effect structure. For example, a fixed effect
version of the <em>SITAR</em> model can be fit by setting randoms as an empty
string i.e., <code>random = ''</code>. Furthermore, the fixed effect structure may
include only a sub set of the parameters e.g., size and timing parameters
(<code>fixed = 'a+b'</code>) or the size and the intensity parameters
(<code>fixed = 'a+c'</code>). The four parameters version of the <em>SITAR</em>
model is fit by including parameter <code>d</code> in the <code>fixed</code> and/or the
<code>random</code> arguments. Similar to the three parameter <em>SITAR</em> model,
user can fit model with a sub set of the fixed and/or the random effects.
</p>
<p>The <span class="pkg">sitar</span> package internally depends on the <span class="pkg">brms</span>
package (see BÃ¼rkner 2022; BÃ¼rkner 2021). The <span class="pkg">brms</span> can
fit a wide range of hierarchical linear and nonlinear regression models
including multivariate models. The <span class="pkg">brms</span> itself depends on the <strong>Stan</strong>
software program full Bayesian inference
(see Stan Development Team 2023; Gelman et al. 2015). Like
<span class="pkg">brms</span>, the <span class="pkg">bsitar</span> package allows a wide range of prior
specifications that encourage the users to specify priors that
actually reflect their prior knowledge about the human growth processes,
(such as timing and intensity of the growth spurt). For prior
specification, we follow the carefully crafted approaches used in the
<span class="pkg">brms</span> and <span class="pkg">rstanarm</span> packages. For example, we follow the
<span class="pkg">brms</span> package in using the <code>student_t</code> distribution for the
regression coefficients as well as the standard deviation for group
level random effects, but set <code>exponential</code> distribution for the
residual standard deviation as used in the <span class="pkg">rstanarm</span> package.
Like <span class="pkg">brms</span> and <span class="pkg">rstanarm</span> packages, the <span class="pkg">bsitar</span> package allows
for auto scaling of the scale parameter for the location-scale based
distributions such as <code>normal</code> and <code>student_t</code>. While
<span class="pkg">rstanarm</span> earlier used to set <code>autosclae</code> as <code>2.5</code> (recently
authors changed this behavior to <code>FALSE</code>), the <span class="pkg">brms</span> package sets
it as <code>1.0</code> or <code>2.5</code> depending on the standard deviation of the
response variable (See <code><a href="brms.html#topic+set_prior">brms::prior()</a></code>). The <span class="pkg">bsitar</span> package, on the
other hand, offers full flexibility in choosing the scale factor as any real
number (e.g., <code>autosclae = 5.0</code>). When <code>autosclae = TRUE</code>, the
<code>2.5</code> is the default scaling factor. We strongly recommend to go
through the well documented details on prior specifications used in
<span class="pkg">brms</span> and <span class="pkg">rstanarm</span> packages.
</p>
<p>Like <span class="pkg">brms</span> package, the <span class="pkg">bsitar</span> package offers a range of tools to
evaluate the model fit that include posterior predictive check (see
<code><a href="brms.html#topic+pp_check.brmsfit">brms::pp_check()</a></code>) and the leave one out (<code>loo</code>) cross validation (see
<code><a href="brms.html#topic+loo.brmsfit">brms::loo()</a></code>). Furthermore, while the excellent post-processing support
offered by the <span class="pkg">brms</span> package is directly available to the users, the
<span class="pkg">bsitar</span> package includes many customized functions that allow for
estimation and visualization of population average and individual specific
distance (increase in size) and velocity (change in rate of growth), as well
as computation of population average and individual specific growth
parameters such as age at peak growth velocity (APGV) and the peak growth
velocity (PGV).
</p>
<p>Finally, the <span class="pkg">bsitar</span> package allows three different types of model
specifications: <code>'univariate'</code>, <code>'univariate_by'</code> and
<code>'multivariate'</code>. A <code>'univariate'</code> fitting involves a single model
applied to an outcome whereas both <code>'univariate_by'</code> and
<code>'multivariate'</code> specifications comprise two or more sub models. The
<code>'univariate_by'</code> fits two or more sub models to an outcome variable
defined by a factor variable (e.g, sex). The data are typically stacked and
the factor variable is used to set-up the sub models via the <code>'subset'</code>
option available in the <code><a href="brms.html#topic+brm">brms::brm()</a></code>. The <code>'multivariate'</code> model allows
simultaneous modelling of two or more outcomes with joint a distribution of
the random effects. For both <code>'univariate_by'</code> and <code>'multivariate'</code>
models, the <span class="pkg">bsitar</span> package allows full flexibility in specifying
separate arguments such as predictor variables (<code>x</code>), degree of freedom
(<code>df</code>) for design matrix as well as the priors and the initial values.
Furthermore, to enhance the ease of specifying different options and to make
it user-friendly, there is no need to enclose the character option(s) in
single or double quotes. For example to specify the <code>'univariate_by'</code>
for sex, the <code>univariate_by = sex</code> is same as <code>univariate_by =
 'sex'</code> or <code>univariate_by = "sex"</code>. The same applies for all character
string options.
</p>


<h3>Value</h3>

<p>An object of class <code>brmsfit, bsiatr</code>, that contains the posterior
draws and other useful information about the model.
</p>


<h3>Note</h3>

<p>The package is under continuous development and new models and
post-processing features will be added soon.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>References</h3>

<p>Beath KJ (2007).
&ldquo;Infant growth modelling using a shape invariant model with random effects.&rdquo;
<em>Statistics in Medicine</em>, <b>26</b>(12), 2547&ndash;2564.
<a href="https://doi.org/10.1002/sim.2718">doi:10.1002/sim.2718</a>, Type: Journal article.<br /><br /> BÃ¼rkner P (2021).
&ldquo;Bayesian Item Response Modeling in R with brms and Stan.&rdquo;
<em>Journal of Statistical Software</em>, <b>100</b>(5), 1&ndash;54.
<a href="https://doi.org/10.18637/jss.v100.i05">doi:10.18637/jss.v100.i05</a>.<br /><br /> BÃ¼rkner P (2022).
<em>brms: Bayesian Regression Models using Stan</em>.
R package version 2.18.0, <a href="https://CRAN.R-project.org/package=brms">https://CRAN.R-project.org/package=brms</a>.<br /><br /> Cole T (2022).
<em>sitar: Super Imposition by Translation and Rotation Growth Curve Analysis</em>.
R package version 1.3.0, <a href="https://CRAN.R-project.org/package=sitar">https://CRAN.R-project.org/package=sitar</a>.<br /><br /> Cole TJ, Donaldson MDC, Ben-Shlomo Y (2010).
&ldquo;SITARâ€”a useful instrument for growth curve analysis.&rdquo;
<em>International Journal of Epidemiology</em>, <b>39</b>(6), 1558&ndash;1566.
ISSN 0300-5771, <a href="https://doi.org/10.1093/ije/dyq115">doi:10.1093/ije/dyq115</a>, tex.eprint: https://academic.oup.com/ije/article-pdf/39/6/1558/18480886/dyq115.pdf.<br /><br /> Gelman A, Lee D, Guo J (2015).
&ldquo;Stan: A Probabilistic Programming Language for Bayesian Inference and Optimization.&rdquo;
<em>Journal of Educational and Behavioral Statistics</em>, <b>40</b>(5), 530-543.
<a href="https://doi.org/10.3102/1076998615606113">doi:10.3102/1076998615606113</a>.<br /><br /> Harrell FE, others (2001).
<em>Regression modeling strategies: with applications to linear models, logistic regression, and survival analysis</em>, volume 608.
Springer.<br /><br /> Harrell Jr. FE (2022).
<em>Hmisc: Harrell Miscellaneous</em>.
R package version 4.7-2, <a href="https://hbiostat.org/R/Hmisc/">https://hbiostat.org/R/Hmisc/</a>.<br /><br /> Lindstrom MJ (1995).
&ldquo;Self-modelling with random shift and scale parameters and a free-knot spline shape function.&rdquo;
<em>Statistics in Medicine</em>, <b>14</b>(18), 2009-2021.
<a href="https://doi.org/10.1002/sim.4780141807">doi:10.1002/sim.4780141807</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/8677401/">https://pubmed.ncbi.nlm.nih.gov/8677401/</a>.<br /><br /> Nembidzane C, Lesaoana M, Monyeki KD, Boateng A, Makgae PJ (2020).
&ldquo;Using the SITAR Method to Estimate Age at Peak Height Velocity of Children in Rural South Africa: Ellisras Longitudinal Study.&rdquo;
<em>Children</em>, <b>7</b>(3), 17.
ISSN 2227-9067, <a href="https://doi.org/10.3390/children7030017">doi:10.3390/children7030017</a>, <a href="https://www.mdpi.com/2227-9067/7/3/17">https://www.mdpi.com/2227-9067/7/3/17</a>.<br /><br /> Sandhu SS (2020).
<em>Analysis of longitudinal jaw growth data to study sex differences in timing and intensity of the adolescent growth spurt for normal growth and skeletal discrepancies</em>.
Thesis, University of Bristol.<br /><br /> Stan Development Team (2023).
<em>Stan Reference Manual version 2.31</em>.
<a href="https://mc-stan.org/docs/reference-manual/">https://mc-stan.org/docs/reference-manual/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+brm">brms::brm()</a></code> <code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code> <code><a href="brms.html#topic+set_prior">brms::prior()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Examples below fits SITAR model to the 'berkeley_exdata' which is a subset
# of the  Berkley height data. The same subset of the  Berkley height data
# has been used as an example data in the vignette for the 'sitar' package.
#
# The Berkley height data comprise of repeated growth measurements made on
# 66 boys and 70 girls (birth to 21 years). 
#
# The subset of the Berkley height data analysed here include growth 
# measurements for 70 girls (8 to 18 years).
#
# See 'sitar' package documentation for details on Berkley height data   
# (help file ?sitar::berkeley ). The details on subset data for 70 girls is 
# provided in the vignette('Fitting_models_with_SITAR', package = 'sitar').
  
# Fit frequentist SITAR model with df = 5 by using the sitar package 

# Get 'berkeley_exdata' data that has been already saved
berkeley_exdata &lt;- getNsObject(berkeley_exdata)

model_ml &lt;- sitar::sitar(x = age, y = height, id = id, 
                          df = 5, 
                          data = berkeley_exdata, 
                          xoffset = 'mean',
                          fixed = 'a+b+c', 
                          random = 'a+b+c',
                          a.formula = ~1, 
                          b.formula = ~1, 
                          c.formula = ~1
                          )


# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to  
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# The model is fit using 2 chain (2000 iterations per) with thin set as 4 to 
# save time and memory.

# Check and confirm whether model fit object 'berkeley_exfit' exists
# berkeley_exfit &lt;- bsitar:::berkeley_exfit
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)
 
 print(berkeley_exfit)
if(exists('berkeley_exfit')) {
  model &lt;- berkeley_exfit
} else {
 # Fit model with default priors 
 # See documentation for prior on each parameter
  model &lt;- bsitar(x = age, y = height, id = id, 
                  df = 3, 
                  data = berkeley_exdata,
                  xoffset = 'mean', 
                  fixed = 'a+b+c', 
                  random = 'a+b+c',
                  a_formula = ~1, 
                  b_formula = ~1, 
                  c_formula = ~1, 
                  threads = brms::threading(NULL),
                  chains = 2, cores = 2, iter = 6000, thin = 15)
                  
# Note that we can test for the sensitivity to the priors by re fitting the
# above model with flat (i.e., uniform) priors on the regression coefficients
# for parameters a, b and c.
model &lt;- bsitar(x = age, y = height, id = id, 
                  df = 3, 
                  data = berkeley_exdata,
                  xoffset = 'mean', 
                  fixed = 'a+b+c', 
                  random = 'a+b+c',
                  a_formula = ~1, 
                  b_formula = ~1, 
                  c_formula = ~1, 
                  a_prior_beta = flat,
                  b_prior_beta = flat,
                  c_prior_beta = flat,
                  threads = brms::threading(NULL),
                  chains = 2, cores = 2, iter = 6000, thin = 15)
}

# Generate model summary
summary(model)

# Compare model summary with the maximum likelihood SITAR model
print(model_ml)


# Check model fit via posterior predictive checks. The plot_ppc is a based
# on the pp_check function from the brms package.  

plot_ppc(model, ndraws = 100)

# Plot distance and velocity curves using plot_conditional_effects() function.
# This function works exactly same as as conditional_effects() from the brms
# package with the exception that plot_conditional_effects allows for 
# plotting velocity curve also.

# Distance
plot_conditional_effects(model, deriv = 0)

# Velocity
plot_conditional_effects(model, deriv = 1)

# Plot distance and velocity curve along with the parameter estimates using 
# the plot_curves() function. This function works exactly the same way as 
# plot.sitar from the sitar package

plot_curves(model, apv = TRUE)

# Compare plot with the maximum likelihood SITAR model

plot(model_ml)



</code></pre>

<hr>
<h2 id='expose_model_functions.bgmfit'>Expose user defined Stan function for post-processing</h2><span id='topic+expose_model_functions.bgmfit'></span><span id='topic+expose_model_functions'></span>

<h3>Description</h3>

<p>The <strong>expose_model_functions()</strong> is a wrapper around the
<code><a href="rstan.html#topic+expose_stan_functions">rstan::expose_stan_functions()</a></code> to expose user defined
<code>Stan</code> function(s). These exposed functions are needed during the
post-processing of the posterior draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
expose_model_functions(
  model,
  scode = NULL,
  expose = TRUE,
  select_model = NULL,
  returnobj = TRUE,
  vectorize = FALSE,
  verbose = FALSE,
  envir = NULL,
  ...
)

expose_model_functions(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expose_model_functions.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_scode">scode</code></td>
<td>
<p>A character string (<code>Stan code</code>) containing the
user-defined Stan function(s). If <code>NULL</code> (default), the <code>scode</code>
is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_expose">expose</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to indicate whether to expose
functions and add them to the <code>model</code> as an attribute.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_select_model">select_model</code></td>
<td>
<p>A character string (default <code>NULL</code>) to indicate the
model name. This is for internal use only.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_returnobj">returnobj</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to indicate whether to
return the model object. When <code>expose = TRUE</code>, then it is advisable to
set <code>returnobj = TRUE</code> too.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_vectorize">vectorize</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether the
exposed functions should be vectorized via <code><a href="base.html#topic+Vectorize">base::Vectorize()</a></code>. Note that
currently <code>vectorize</code> should be set to <code>FALSE</code> because setting it
<code>TRUE</code> may not work as expected.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the
<code><a href="rstan.html#topic+expose_stan_functions">rstan::expose_stan_functions()</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bgmfit</code> if <code>returnobj=TRUE</code>, otherwise
invisible <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="rstan.html#topic+expose_stan_functions">rstan::expose_stan_functions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# To save time, argument expose is set as FALSE which runs a dummy test 
# and avoid model compilation which often takes time

expose_model_functions(model, expose = FALSE)


</code></pre>

<hr>
<h2 id='fitted_draws.bgmfit'>Fitted (expected) values from the posterior draws</h2><span id='topic+fitted_draws.bgmfit'></span><span id='topic+fitted_draws'></span>

<h3>Description</h3>

<p>The <strong>fitted_draws()</strong> is a wrapper around the
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> function to obtain fitted values (and their
summary) from the posterior draws. See <code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> for
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
fitted_draws(
  model,
  newdata = NULL,
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty",
  incl_autocor = TRUE,
  numeric_cov_at = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  aux_variables = NULL,
  ipts = 10,
  deriv = 0,
  deriv_model = TRUE,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  xrange = NULL,
  xrange_search = NULL,
  parms_eval = FALSE,
  parms_method = "getPeak",
  idata_method = NULL,
  verbose = FALSE,
  fullframe = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

fitted_draws(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted_draws.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify response
variable when processing posterior draws for the <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include the
individual/group-level effects in the estimation. When <code>NA</code> (default),
the individual-level effects are excluded and therefore population average
growth parameters are computed. When <code>NULL</code>, individual-level effects
are included in the computation and hence the growth parameters estimates
returned are individual-specific. In both situations, (i.e,, <code>NA</code> or
<code>NULL</code>), continuous and factor covariate(s) are appropriately included
in the estimation. The continuous covariates by default are set to their
means (see <code>numeric_cov_at</code> for details) whereas factor covariates are
left unaltered thereby allowing estimation of covariate specific population
average and individual-specific growth parameter.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option set the
continuous covariate(s) at their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate varibale 'xx' at 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariate is
included in the model.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for
hierarchical model (default <code>NULL</code>). It is used only when model is
applied to the data with 3 or more levels of hierarchy. For a two level
model, the <code>levels_id</code> is automatically inferred from the model fit.
Even for 3 or higher level model, the <code>levels_id</code> is inferred from the
model fit but under the assumption that hierarchy is specified from lowest
to upper most level i.e, <code>id</code> followed by <code>study</code> where <code>id</code>
is nested within the <code>study</code> Note that it is not guaranteed that the
<code>levels_id</code> is sorted correctly, and therefore it is better to set it
manually when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and  <code>reby</code> (typically <code>NULL</code> indicating that
parameters are integrated over the random effects) such as
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location scale models and measurement error models. An
indication to use <code>aux_variables</code> is when post processing functions
throw an error such as <code>variable 'x' not found either 'data' or
 'data2'</code></p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable to get a
smooth velocity curve. The <code>NULL</code> will return original values whereas
an integer such as <code>ipts = 10</code> (default) will interpolate the
predictor. It is important to note that these interpolations do not alter
the range of predictor when calculating population average and/or the
individual specific growth curves.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>An integer to indicate whether to estimate distance curve or its
derivative (i.e., velocity curve). The <code>deriv = 0</code> (default) is for
the distance curve whereas <code>deriv = 1</code> for the velocity curve.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_summary">summary</code></td>
<td>
<p>A logical indicating whether only the estimate should be
computed (<code>TRUE</code>, default), or estimate along with SE and CI should be
returned (<code>FALSE</code>). Setting <code>summary</code> as <code>FALSE</code> will
increase the computation time.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_robust">robust</code></td>
<td>
<p>A logical to specify the summarize options. If <code>FALSE</code>
(the default) the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If <code>TRUE</code>, the
median and the median absolute deviation (MAD) are applied instead. Ignored
if <code>summary</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (i.e., age) when
executing the interpolation via <code>ipts</code>. The default <code>NULL</code> sets
the individual specific predictor range whereas code <code>xrange = 1</code> sets
identical range for individuals within the same higher grouping variable
(e.g., study). Code <code>xrange  = 2</code> sets the identical range across the
entire sample. Lastly, a paired numeric values can be supplied e.g.,
<code>xrange = c(6, 20)</code> to set the range within those values.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_xrange_search">xrange_search</code></td>
<td>
<p>A vector of length two, or a character string
<code>'range'</code> to set the range of predictor variable (<code>x</code> ) within
which growth parameters are searched. This is useful when there is more
than one peak and user wants to summarize peak within a given range of the
<code>x</code> variable. Default <code>xrange_search = NULL</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_parms_eval">parms_eval</code></td>
<td>
<p>A logical to specify whether or not to get growth
parameters on the fly. This is for internal use only and mainly needed for
compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_parms_method">parms_method</code></td>
<td>
<p>A character to specify the method used to when evaluating
<code>parms_eval</code>. The default is <code>getPeak</code> which uses the
<code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code> function from the <code>sitar</code> package. The alternative
option is <code>findpeaks</code> that uses the <code><a href="pracma.html#topic+findpeaks">pracma::findpeaks()</a></code> function
function from the <code>pracma</code> package. This is for internal use only and
mainly needed for compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of of interpolation points is set up the <code>ipts</code> argument.
Options available for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>). The
<em>method 1</em> (<code>'m1'</code>) is adapted from the the <span class="pkg">iapvbs</span> package
and is documented here
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R</a>
whereas <em>method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span>
package as documented here
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R</a>.
The <code>'m1'</code> method works by internally constructing the data frame based
on the model configuration whereas the method <code>'m2'</code> uses the exact
data frame used in model fit and can be accessed via <code>fit$data</code>. If
<code>idata_method = NULL, default</code>, then method <code>'m2'</code> is
automatically set. Note that method <code>'m1'</code> might fail in some cases
when model involves covariates particularly when model is fit as
<code>univariate_by</code>. Therefore, it is advised to switch to method
<code>'m2'</code> in case <code>'m1'</code> results in error.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_fullframe">fullframe</code></td>
<td>
<p>A logical to indicate whether to return <code>fullframe</code>
object in which <code>newdata</code> is bind to the summary estimates. Note that
<code>fullframe</code> can not be combined with <code>summary = FALSE</code>.
Furthermore, <code>fullframe</code> can only be used when <code>idata_method =
  'm2'</code>. A particular use case is when fitting <code>univariate_by</code> model.
The <code>fullframe</code> is mainly for internal use only.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) that is used to
convert dummy variables into a factor variable. The named elements are
<code>factor.dummy</code>, <code>factor.name</code>, and <code>factor.level</code>. The
<code>factor.dummy</code> is a vector of character strings that need to be
converted to a factor variable whereas the <code>factor.name</code> is a single
character string that is used to name the newly created factor variable.
The <code>factor.level</code> is used to name the levels of newly created factor.
When <code>factor.name</code> is <code>NULL</code>, then the factor name is internally
set as <code>'factor.var'</code>. If <code>factor.level</code> is <code>NULL</code>, then
names of factor levels are take from the <code>factor.dummy</code> i.e., the
factor levels are assigned same name as <code>factor.dummy</code>. Note that when
<code>factor.level</code> is not <code>NULL</code>, its length must be same as the
length of the <code>factor.dummy</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>
function. Please see <code>brms::fitted.brmsfit()</code> for details on
various options available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>fitted_draws()</strong> computes the fitted values from the
posterior draws. The <code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> function from the <span class="pkg">brms</span>
package can used to get the fitted (distance) values when outcome (e.g.,
height) is untransformed. However, when the outcome is log or square root
transformed, the <code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> function will return the fitted
curve on the log or square root scale whereas the <strong>fitted_draws()</strong>
function returns the fitted values on the original scale. Furthermore, the
<strong>fitted_draws()</strong> also compute the first derivative of (velocity)
that too on the original scale after making required back-transformation.
Except for these differences, both these functions (i.e.,
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> and <code><a href="#topic+fitted_draws">fitted_draws()</a></code>) work in the same manner. In
other words, user can specify all the options available in the
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>.
</p>


<h3>Value</h3>

<p>An array of predicted mean response values. See
<a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit</a> for details.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average distance curve
fitted_draws(model, deriv = 0, re_formula = NA)


# Individual-specific distance curves
fitted_draws(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
fitted_draws(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
fitted_draws(model, deriv = 1, re_formula = NULL)


</code></pre>

<hr>
<h2 id='getNsObject'>Check and get namespace object if exists</h2><span id='topic+getNsObject'></span>

<h3>Description</h3>

<p>Check and get namespace object if exists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNsObject(object, namespace = NULL, envir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNsObject_+3A_object">object</code></td>
<td>
<p>An object to be retrieved. Note that <code>object</code> must be a
symbol and not a character string.</p>
</td></tr>
<tr><td><code id="getNsObject_+3A_namespace">namespace</code></td>
<td>
<p>A character string specifying the namespace to be checked.</p>
</td></tr>
<tr><td><code id="getNsObject_+3A_envir">envir</code></td>
<td>
<p>An environment to be used (default <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of same class as input <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Check whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)


</code></pre>

<hr>
<h2 id='growthparameters_comparison.bgmfit'>Compare growth parameters</h2><span id='topic+growthparameters_comparison.bgmfit'></span><span id='topic+growthparameters_comparison'></span>

<h3>Description</h3>

<p>The <strong>growthparameters_comparison()</strong> function estimates and
compare growth parameters such as peak growth velocity and the age at peak
growth velocity. This function is a wrapper around the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>.
The <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> computes unit-level (conditional)
estimates whereas <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> return average
(marginal) estimates. A detailed explanation is available
<a href="https://marginaleffects.com">here</a>. Note that for the current use case,
i.e., to estimate and compare growth parameters, the arguments
<code>variables</code> and <code>comparion</code> of <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code>
and <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> are modified (see below).
Furthermore, comparison of growth parameters is performed via the
<code>hypothesis</code> argument of the <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
growthparameters_comparison(
  model,
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  newdata = NULL,
  datagrid = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "gaussian",
  parameter = NULL,
  xrange = 1,
  acg_velocity = 0.1,
  digits = 2,
  numeric_cov_at = NULL,
  aux_variables = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  idata_method = NULL,
  ipts = NULL,
  seed = 123,
  future = FALSE,
  future_session = "multisession",
  cores = NULL,
  average = FALSE,
  plot = FALSE,
  showlegends = NULL,
  variables = NULL,
  deriv = NULL,
  deriv_model = NULL,
  comparison = "difference",
  type = NULL,
  by = FALSE,
  conf_level = 0.95,
  transform = NULL,
  cross = FALSE,
  wts = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  eps = NULL,
  reformat = NULL,
  estimate_center = NULL,
  estimate_interval = NULL,
  dummy_to_factor = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

growthparameters_comparison(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify response
variable when processing posterior draws for the <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_datagrid">datagrid</code></td>
<td>
<p>Generate a grid of user-specified values for use in the
<code>newdata</code> argument in various functions of the <span class="pkg">marginaleffects</span>
package. This is useful to define where in the predictor space we want to
evaluate the quantities of interest. See <code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code> for
details. The default value for the <code>datagrid</code> is <code>NULL</code> implying
that no custom grid is constructed. To set a data grid, the argument should
be a data.frame constructed by using the <code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code>
function, or else a named list which are internally used for setting up the
grid. For the user convenience, we also allow setting an empty list
<code>datagrid = list()</code> in which case essential arguments such as
<code>model</code>, <code>newdata</code> are taken up from the respective arguments
specified elsewhere. Further, the level 1 predictor (such as age) and any
covariate included in the model fit (e.g., gender) are also automatically
inferred from the <code>model</code> object.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include the
individual/group-level effects in the estimation. When <code>NA</code> (default),
the individual-level effects are excluded and therefore population average
growth parameters are computed. When <code>NULL</code>, individual-level effects
are included in the computation and hence the growth parameters estimates
returned are individual-specific. In both situations, (i.e,, <code>NA</code> or
<code>NULL</code>), continuous and factor covariate(s) are appropriately included
in the estimation. The continuous covariates by default are set to their
means (see <code>numeric_cov_at</code> for details) whereas factor covariates are
left unaltered thereby allowing estimation of covariate specific population
average and individual-specific growth parameter.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_parameter">parameter</code></td>
<td>
<p>A single character string, or a character vector specifying
the growth parameter(s) to be estimated. Options are <code>'tgv'</code> (takeoff
growth velocity), <code>'atgv'</code> (age at takeoff growth velocity),
<code>'pgv'</code> (peak growth velocity), <code>'apgv'</code> (age at peak growth
velocity), <code>'cgv'</code> (cessation growth velocity), and <code>'acgv'</code> (age
at cessation growth velocity), and <code>'all'</code>. If <code>parameter = NULL</code>
(default), age at peak growth velocity (<code>'apgv'</code>) is estimated where
when <code>parameter = 'all'</code>, all six parameters are estimated. Note that
option <code>'all'</code> can not be used when argument <code>by</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (i.e., age) when
executing the interpolation via <code>ipts</code>. The default <code>NULL</code> sets
the individual specific predictor range whereas code <code>xrange = 1</code> sets
identical range for individuals within the same higher grouping variable
(e.g., study). Code <code>xrange  = 2</code> sets the identical range across the
entire sample. Lastly, a paired numeric values can be supplied e.g.,
<code>xrange = c(6, 20)</code> to set the range within those values.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_acg_velocity">acg_velocity</code></td>
<td>
<p>A real number to set the percentage of peak growth growth
velocity as the cessation velocity when estimating the <code>cgv</code> and
<code>acgv</code> growth parameters. The <code>acg_velocity</code> should be greater
than <code>0</code> and less than <code>1</code>. The default <code>acg_velocity =
  0.10</code> indicates that a 10 per cent of the peak growth velocity will be used
to get the cessation velocity and the corresponding age at the cessation
velocity. For example if peak growth velocity estimate is <code>10
  mm/year</code>, then cessation growth velocity is <code>1 mm/year</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) to set the decimal places for the
estimated growth parameters. The <code>digits</code> is passed on to the
<code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option set the
continuous covariate(s) at their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate varibale 'xx' at 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariate is
included in the model.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location scale models and measurement error models. An
indication to use <code>aux_variables</code> is when post processing functions
throw an error such as <code>variable 'x' not found either 'data' or
 'data2'</code></p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for
hierarchical model (default <code>NULL</code>). It is used only when model is
applied to the data with 3 or more levels of hierarchy. For a two level
model, the <code>levels_id</code> is automatically inferred from the model fit.
Even for 3 or higher level model, the <code>levels_id</code> is inferred from the
model fit but under the assumption that hierarchy is specified from lowest
to upper most level i.e, <code>id</code> followed by <code>study</code> where <code>id</code>
is nested within the <code>study</code> Note that it is not guaranteed that the
<code>levels_id</code> is sorted correctly, and therefore it is better to set it
manually when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and  <code>reby</code> (typically <code>NULL</code> indicating that
parameters are integrated over the random effects) such as
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of of interpolation points is set up the <code>ipts</code> argument.
Options available for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>). The
<em>method 1</em> (<code>'m1'</code>) is adapted from the the <span class="pkg">iapvbs</span> package
and is documented here
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R</a>
whereas <em>method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span>
package as documented here
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R</a>.
The <code>'m1'</code> method works by internally constructing the data frame based
on the model configuration whereas the method <code>'m2'</code> uses the exact
data frame used in model fit and can be accessed via <code>fit$data</code>. If
<code>idata_method = NULL, default</code>, then method <code>'m2'</code> is
automatically set. Note that method <code>'m1'</code> might fail in some cases
when model involves covariates particularly when model is fit as
<code>univariate_by</code>. Therefore, it is advised to switch to method
<code>'m2'</code> in case <code>'m1'</code> results in error.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable to get a
smooth velocity curve. The <code>NULL</code> will return original values whereas
an integer such as <code>ipts = 10</code> (default) will interpolate the
predictor. It is important to note that these interpolations do not alter
the range of predictor when calculating population average and/or the
individual specific growth curves.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_seed">seed</code></td>
<td>
<p>An integer (default <code>123</code>) that is passed to the estimation
method.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_future">future</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to specify whether or not to
perform parallel computations. If set to <code>TRUE</code>, the
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code> function is used to summarize draws.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_future_session">future_session</code></td>
<td>
<p>A character string to set the session type when
<code>future = TRUE</code>. The <code>'multisession'</code> (default) options sets the
multisession whereas the <code>'multicore'</code> sets the multicore session.
Note that option <code>'multicore'</code> is not supported on Windows systems.
For more details, see <code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used when running the parallel
computations (if <code>future = TRUE</code>). On non-Windows systems this
argument can be set globally via the mc.cores option. For the default
<code>NULL</code> option, the number of cores are set automatically by calling
the <code><a href="future.html#topic+re-exports">future::availableCores()</a></code>. The number of cores used are the maximum
number of cores avaialble minus one, i.e., <code>future::availableCores() -
  1</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_average">average</code></td>
<td>
<p>A logical to indicate whether to internally call the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> or the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> function. If <code>FALSE</code> (default),
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> is called otherwise
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> when <code>average = TRUE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_plot">plot</code></td>
<td>
<p>A logical to specify whether to plot comparisons by calling the
<code><a href="marginaleffects.html#topic+plot_comparisons">marginaleffects::plot_comparisons()</a></code> function (<code>FALSE</code>) or not
(<code>FALSE</code>). If <code>FALSE</code> (default), then
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> or <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>
are called to compute predictions (see <code>average</code> for details).</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_showlegends">showlegends</code></td>
<td>
<p>An argument to specify whether to show legends
(<code>TRUE</code>) or not (<code>FALSE</code>). If <code>NULL</code> (default), then
<code>showlegends</code> is internally set to <code>TRUE</code> if <code>re_formula =
  NA</code>, and <code>FALSE</code> if <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_variables">variables</code></td>
<td>
<p>For estimating growth parameters in the current use case,
the <code>variables</code> is the level 1 predictor such as
<code>age</code>/<code>time</code>. The <code>variables</code> is a named list where value is
set via the <code>esp</code> argument (default 1e-6). If <code>NULL</code>, the
<code>variables</code> is set internally by retrieving the relevant information
from the <code>model</code>. Otherwise, user can define it as follows:
<code>variables = list('x' = 1e-6)</code> where <code>'x'</code> is the level 1
predictor. Note that <code>variables = list('age' = 1e-6)</code> is the default
behavior for the <span class="pkg">marginaleffects</span> because velocity is typically
calculated by differentiating the distance curve via <code>dydx</code> approach,
and therefore argument <code>deriv</code> is automatically set as <code>0</code> and
<code>deriv_model</code> as <code>FALSE</code>. If user want to estimate parameters
based on the model based first derivative, then argument <code>deriv</code> must
be set as <code>1</code> and internally argument <code>variables</code> is defined as
<code>variables = list('age' = 0)</code> i.e, original level 1 predictor
variable, <code>'x'</code>. It is important to consider that if default behavior
is used i.e, <code>deriv = 0</code> and <code>variables = list('x' = 1e-6)</code>, then
user can not pass additional arguments to the <code>variables</code> argument. On
the other hand, alternative approach i.e, <code>deriv = 0</code> and
<code>variables = list('x' = 0)</code>, additional options can be passed to the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>
functions.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>A numeric to specify whether to estimate parameters based on the
differentiation of the distance curve or the model based first derivative.
Please see argument <code>variables</code> for more details.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_comparison">comparison</code></td>
<td>
<p>For estimating growth parameters in the current use case,
options allowed for the <code>comparison</code> are <code>'difference'</code> and
<code>'differenceavg'</code>. Note that <code>comparison</code> is a placeholder and is
only used to setup the the internal function that estimates
<code>'parameter'</code> via <code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code>, <code><a href="sitar.html#topic+getPeakTrough">sitar::getTakeoff()</a></code> and
<code><a href="sitar.html#topic+getPeakTrough">sitar::getTrough()</a></code> functions to estimate various growth parameters.
Options <code>'difference'</code> and <code>'differenceavg'</code> are internally
restructured according to the user specified <code>hypothesis</code> argument.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_transform">transform</code></td>
<td>
<p>string or function. Transformation applied to unit-level estimates and confidence intervals just before the function returns results. Functions must accept a vector and return a vector of the same length. Support string shortcuts: &quot;exp&quot;, &quot;ln&quot;</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_cross">cross</code></td>
<td>

<ul>
<li> <p><code>FALSE</code>: Contrasts represent the change in adjusted predictions when one predictor changes and all other variables are held constant.
</p>
</li>
<li> <p><code>TRUE</code>: Contrasts represent the changes in adjusted predictions when all the predictors specified in the <code>variables</code> argument are manipulated simultaneously (a &quot;cross-contrast&quot;).
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_wts">wts</code></td>
<td>
<p>string or numeric: weights to use when computing average contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not the unit-level estimates themselves. Internally, estimates and weights are passed to the <code>weighted.mean()</code> function.
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a numeric value, vector, or matrix, a string, or a string formula.
</p>

<ul>
<li><p> Numeric:
</p>

<ul>
<li><p> Single value: the null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li><p> Vector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the <code>hypothesis</code> argument.
</p>
</li>
<li><p> Matrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.
</p>
</li></ul>

</li>
<li><p> String formula to specify linear or non-linear hypothesis tests. If the <code>term</code> column uniquely identifies rows, terms can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">&#8288;b*&#8288;</code> wildcard can be used to test hypotheses on all estimates. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;b* / b1 = 1&#8288;</code>
</p>
</li></ul>

</li>
<li><p> String:
</p>

<ul>
<li><p> &quot;pairwise&quot;: pairwise differences between estimates in each row.
</p>
</li>
<li><p> &quot;reference&quot;: differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li><p> &quot;sequential&quot;: difference between an estimate and the estimate in the next row.
</p>
</li>
<li><p> &quot;revpairwise&quot;, &quot;revreference&quot;, &quot;revsequential&quot;: inverse of the corresponding hypotheses, as described above.
</p>
</li></ul>

</li>
<li><p> See the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_equivalence">equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_eps">eps</code></td>
<td>
<p>NULL or numeric value which determines the step size to use when
calculating numerical derivatives: (f(x+eps)-f(x))/eps. When <code>eps</code> is
<code>NULL</code>, the step size is 0.0001 multiplied by the difference between
the maximum and minimum values of the variable with respect to which we
are taking the derivative. Changing <code>eps</code> may be necessary to avoid
numerical problems in certain models.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_reformat">reformat</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to reformat the  output
returned by the <code>marginaleffects</code> as a data.frame with column names
re-defined as follows: <code>conf.low</code> as <code>Q2.5</code>, and <code>conf.high</code>
as <code>Q97.5</code> (assuming that <code>conf_int = 0.95</code>). Also, following
columns are dropped from the data frame: <code>term</code>, <code>contrast</code>,
<code>tmp_idx</code>, <code>predicted_lo</code>, <code>predicted_hi</code>, <code>predicted</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_estimate_center">estimate_center</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify
whether to center estimate as <code>'mean'</code> or as <code>'median'</code>. Note
that <code>estimate_center</code> is used to set the global options as follows:
<br />
<code> options("marginaleffects_posterior_center" = "mean")</code>, or <br />
<code>options("marginaleffects_posterior_center" = "median")</code> <br />
The pre-specified global options are restored on exit via the
<code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_estimate_interval">estimate_interval</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify
whether to compute credible intervals as equal-tailed intervals,
<code>'eti'</code> or highest density intervals, <code>'hdi'</code>. Note that
<code>estimate_interval</code> is used to set the global options as follows: <br />
<code> options("marginaleffects_posterior_interval" = "eti")</code>, or <br />
<code> options("marginaleffects_posterior_interval" = "hdi")</code> <br />
The pre-specified global options are restored on exit via the
<code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) that is used to
convert dummy variables into a factor variable. The named elements are
<code>factor.dummy</code>, <code>factor.name</code>, and <code>factor.level</code>. The
<code>factor.dummy</code> is a vector of character strings that need to be
converted to a factor variable whereas the <code>factor.name</code> is a single
character string that is used to name the newly created factor variable.
The <code>factor.level</code> is used to name the levels of newly created factor.
When <code>factor.name</code> is <code>NULL</code>, then the factor name is internally
set as <code>'factor.var'</code>. If <code>factor.level</code> is <code>NULL</code>, then
names of factor levels are take from the <code>factor.dummy</code> i.e., the
factor levels are assigned same name as <code>factor.dummy</code>. Note that when
<code>factor.level</code> is not <code>NULL</code>, its length must be same as the
length of the <code>factor.dummy</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>brms::fitted.brmsfit()</code> and
<code>brms::predict()</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>growthparameters_comparison</code> function estimates and
returns the following growth parameters:
</p>

<ul>
<li><p> pgv  - peak growth velocity
</p>
</li>
<li><p> apgv - age at peak growth velocity
</p>
</li>
<li><p> tgv  - takeoff growth velocity
</p>
</li>
<li><p> atgv - age at takeoff growth velocity
</p>
</li>
<li><p> cgv  - cessation growth velocity
</p>
</li>
<li><p> acgv - age at cessation growth velocity
</p>
</li></ul>

<p>The takeoff growth velocity is the lowest velocity just before the peak
starts and it indicates the beginning of the pubertal growth spurt. The
cessation growth velocity indicates the end of the active pubertal growth
spurt and is calculated as some percentage of the peak velocity (<code>pgv</code>).
Typically, a 10 percent of the <code>pgv</code> is considered as a good indicator
of the cessation of the active pubertal growth spurt
(Hardin et al. 2022). The percentage is controlled via the
<code>acg_velocity</code> argument which takes a positive real value bounded
between 0 and 1 (default <code>0.1</code> implying 10 percent).
</p>


<h3>Value</h3>

<p>A data frame objects with estimates and CIs for computed parameter(s)
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>References</h3>

<p>Hardin AM, Knigge RP, Oh HS, Valiathan M, Duren DL, McNulty KP, Middleton KM, Sherwood RJ (2022).
&ldquo;Estimating Craniofacial Growth Cessation: Comparison of Asymptote- and Rate-Based Methods.&rdquo;
<em>The Cleft Palate Craniofacial Journal</em>, <b>59</b>(2), 230-238.
<a href="https://doi.org/10.1177/10556656211002675">doi:10.1177/10556656211002675</a>, PMID: 33998905.
</p>


<h3>See Also</h3>

<p><code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code>
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>
<code><a href="marginaleffects.html#topic+plot_comparisons">marginaleffects::plot_comparisons()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

growthparameters_comparison(model, parameter = 'apgv', ndraws = 10)


</code></pre>

<hr>
<h2 id='growthparameters.bgmfit'>Estimate growth parameters from the model fit</h2><span id='topic+growthparameters.bgmfit'></span><span id='topic+growthparameters'></span>

<h3>Description</h3>

<p>The <strong>growthparameters()</strong> computes population
average and and individual-specific growth parameters (such as age at peak
growth velocity) and the uncertainty (standard error, SE and the credible
interval, CI).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
growthparameters(
  model,
  newdata = NULL,
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  summary = TRUE,
  robust = FALSE,
  re_formula = NA,
  peak = TRUE,
  takeoff = FALSE,
  trough = FALSE,
  acgv = FALSE,
  acgv_velocity = 0.1,
  estimation_method = "fitted",
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty",
  incl_autocor = TRUE,
  numeric_cov_at = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  aux_variables = NULL,
  ipts = 10,
  deriv_model = TRUE,
  conf = 0.95,
  xrange = NULL,
  xrange_search = NULL,
  digits = 2,
  seed = 123,
  future = FALSE,
  future_session = "multisession",
  cores = NULL,
  parms_eval = FALSE,
  idata_method = NULL,
  parms_method = "getPeak",
  verbose = FALSE,
  fullframe = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

growthparameters(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growthparameters.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify response
variable when processing posterior draws for the <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_summary">summary</code></td>
<td>
<p>A logical indicating whether only the estimate should be
computed (<code>TRUE</code>, default), or estimate along with SE and CI should be
returned (<code>FALSE</code>). Setting <code>summary</code> as <code>FALSE</code> will
increase the computation time.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_robust">robust</code></td>
<td>
<p>A logical to specify the summarize options. If <code>FALSE</code>
(the default) the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If <code>TRUE</code>, the
median and the median absolute deviation (MAD) are applied instead. Ignored
if <code>summary</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include the
individual/group-level effects in the estimation. When <code>NA</code> (default),
the individual-level effects are excluded and therefore population average
growth parameters are computed. When <code>NULL</code>, individual-level effects
are included in the computation and hence the growth parameters estimates
returned are individual-specific. In both situations, (i.e,, <code>NA</code> or
<code>NULL</code>), continuous and factor covariate(s) are appropriately included
in the estimation. The continuous covariates by default are set to their
means (see <code>numeric_cov_at</code> for details) whereas factor covariates are
left unaltered thereby allowing estimation of covariate specific population
average and individual-specific growth parameter.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_peak">peak</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to indicate whether or
not to calculate the age at peak velocity (APGV) and the peak velocity
(PGV) parameters.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_takeoff">takeoff</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether
or not to calculate the age at takeoff velocity (ATGV) and the takeoff
growth velocity (TGV) parameters.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_trough">trough</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether or
not to calculate the age at cessation of growth velocity (ACGV) and the
cessation of growth velocity (CGV) parameters.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_acgv">acgv</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether or not to
calculate the age at cessation of growth velocity from the velocity curve.
If <code>TRUE</code>, age at cessation of growth velocity (ACGV) and the
cessation growth velocity (CGV) are  calculated based on the percentage of
the peak growth velocity as defined by the <code>acgv_velocity</code> argument
(see below). The <code>acgv_velocity</code> is typically set at 10 percent of the
peak growth velocity. The ACGV and CGV are calculated along with the the
uncertainty (SE and CI) around the ACGV and CGV parameters.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_acgv_velocity">acgv_velocity</code></td>
<td>
<p>Specify the percentage of the peak growth velocity to be
used when estimating <code>acgv</code>. The default value is <code>0.10</code> i.e.,
10 percent of the peak growth velocity.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_estimation_method">estimation_method</code></td>
<td>
<p>A character string to specify the estimation method
when calculating the velocity from the posterior draws. The <code>'fitted'</code>
method internally calls the <code><a href="#topic+fitted_draws">fitted_draws()</a></code> whereas the option
<code>predict</code> calls the <code><a href="#topic+predict_draws">predict_draws()</a></code>. See
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> and <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> for derails.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option set the
continuous covariate(s) at their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate varibale 'xx' at 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariate is
included in the model.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for
hierarchical model (default <code>NULL</code>). It is used only when model is
applied to the data with 3 or more levels of hierarchy. For a two level
model, the <code>levels_id</code> is automatically inferred from the model fit.
Even for 3 or higher level model, the <code>levels_id</code> is inferred from the
model fit but under the assumption that hierarchy is specified from lowest
to upper most level i.e, <code>id</code> followed by <code>study</code> where <code>id</code>
is nested within the <code>study</code> Note that it is not guaranteed that the
<code>levels_id</code> is sorted correctly, and therefore it is better to set it
manually when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and  <code>reby</code> (typically <code>NULL</code> indicating that
parameters are integrated over the random effects) such as
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location scale models and measurement error models. An
indication to use <code>aux_variables</code> is when post processing functions
throw an error such as <code>variable 'x' not found either 'data' or
 'data2'</code></p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable to get a
smooth velocity curve. The <code>NULL</code> will return original values whereas
an integer such as <code>ipts = 10</code> (default) will interpolate the
predictor. It is important to note that these interpolations do not alter
the range of predictor when calculating population average and/or the
individual specific growth curves.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_conf">conf</code></td>
<td>
<p>A numeric value (default <code>0.95</code>) to compute CI. Internally,
the <code>conf</code> is translated into a paired probability values as
<code>c((1 - conf)/2, 1 - (1 - conf) / 2)</code>. For <code>conf = 0.95</code>, this
will compute 95% CI and the variables with lower and upper limits will be
named as <code>Q.2.5</code> and <code>Q.97.5</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (i.e., age) when
executing the interpolation via <code>ipts</code>. The default <code>NULL</code> sets
the individual specific predictor range whereas code <code>xrange = 1</code> sets
identical range for individuals within the same higher grouping variable
(e.g., study). Code <code>xrange  = 2</code> sets the identical range across the
entire sample. Lastly, a paired numeric values can be supplied e.g.,
<code>xrange = c(6, 20)</code> to set the range within those values.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_xrange_search">xrange_search</code></td>
<td>
<p>A vector of length two, or a character string
<code>'range'</code> to set the range of predictor variable (<code>x</code> ) within
which growth parameters are searched. This is useful when there is more
than one peak and user wants to summarize peak within a given range of the
<code>x</code> variable. Default <code>xrange_search = NULL</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) to set the decimal argument for
the <code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_seed">seed</code></td>
<td>
<p>An integer (default <code>123</code>) that is passed to the estimation
method.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_future">future</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to specify whether or not to
perform parallel computations. If set to <code>TRUE</code>, the
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code> function is used to summarize draws.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_future_session">future_session</code></td>
<td>
<p>A character string to set the session type when
<code>future = TRUE</code>. The <code>'multisession'</code> (default) options sets the
multisession whereas the <code>'multicore'</code> sets the multicore session.
Note that option <code>'multicore'</code> is not supported on Windows systems.
For more details, see <code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used when running the parallel
computations (if <code>future = TRUE</code>). On non-Windows systems this
argument can be set globally via the mc.cores option. For the default
<code>NULL</code> option, the number of cores are set automatically by calling
the <code><a href="future.html#topic+re-exports">future::availableCores()</a></code>. The number of cores used are the maximum
number of cores avaialble minus one, i.e., <code>future::availableCores() -
  1</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_parms_eval">parms_eval</code></td>
<td>
<p>A logical to specify whether or not to get growth
parameters on the fly. This is for internal use only and mainly needed for
compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of of interpolation points is set up the <code>ipts</code> argument.
Options available for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>). The
<em>method 1</em> (<code>'m1'</code>) is adapted from the the <span class="pkg">iapvbs</span> package
and is documented here
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R</a>
whereas <em>method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span>
package as documented here
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R</a>.
The <code>'m1'</code> method works by internally constructing the data frame based
on the model configuration whereas the method <code>'m2'</code> uses the exact
data frame used in model fit and can be accessed via <code>fit$data</code>. If
<code>idata_method = NULL, default</code>, then method <code>'m2'</code> is
automatically set. Note that method <code>'m1'</code> might fail in some cases
when model involves covariates particularly when model is fit as
<code>univariate_by</code>. Therefore, it is advised to switch to method
<code>'m2'</code> in case <code>'m1'</code> results in error.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_parms_method">parms_method</code></td>
<td>
<p>A character to specify the method used to when evaluating
<code>parms_eval</code>. The default is <code>getPeak</code> which uses the
<code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code> function from the <code>sitar</code> package. The alternative
option is <code>findpeaks</code> that uses the <code><a href="pracma.html#topic+findpeaks">pracma::findpeaks()</a></code> function
function from the <code>pracma</code> package. This is for internal use only and
mainly needed for compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_fullframe">fullframe</code></td>
<td>
<p>A logical to indicate whether to return <code>fullframe</code>
object in which <code>newdata</code> is bind to the summary estimates. Note that
<code>fullframe</code> can not be combined with <code>summary = FALSE</code>.
Furthermore, <code>fullframe</code> can only be used when <code>idata_method =
  'm2'</code>. A particular use case is when fitting <code>univariate_by</code> model.
The <code>fullframe</code> is mainly for internal use only.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) that is used to
convert dummy variables into a factor variable. The named elements are
<code>factor.dummy</code>, <code>factor.name</code>, and <code>factor.level</code>. The
<code>factor.dummy</code> is a vector of character strings that need to be
converted to a factor variable whereas the <code>factor.name</code> is a single
character string that is used to name the newly created factor variable.
The <code>factor.level</code> is used to name the levels of newly created factor.
When <code>factor.name</code> is <code>NULL</code>, then the factor name is internally
set as <code>'factor.var'</code>. If <code>factor.level</code> is <code>NULL</code>, then
names of factor levels are take from the <code>factor.dummy</code> i.e., the
factor levels are assigned same name as <code>factor.dummy</code>. Note that when
<code>factor.level</code> is not <code>NULL</code>, its length must be same as the
length of the <code>factor.dummy</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>brms::fitted.brmsfit()</code> and
<code>brms::predict()</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>growthparameters()</strong> internally calls the
<code><a href="#topic+fitted_draws">fitted_draws()</a></code> or the <code><a href="#topic+predict_draws">predict_draws()</a></code> function to estimate the first
derivative based growth parameters for each posterior draw. The growth
parameters estimated are age at peak growth velocity (APGV), peak growth
velocity (PGV), age at takeoff growth velocity (ATGV), takeoff growth
velocity (TGV), age at cessation of growth velocity (ACGV), and the
cessation growth velocity (CGV). The APGV and PGV are estimated by calling
the <code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code> function whereas the ATGV and TGV are estimated by
using the <code><a href="sitar.html#topic+getPeakTrough">sitar::getTakeoff()</a></code> function. The <code><a href="sitar.html#topic+getPeakTrough">sitar::getTrough()</a></code> function
is used to estimates ACGV and CGV parameters. The parameters obtained from
each posterior draw are then summarized appropriately to get the estimates
and the uncertainty (SEs and CIs) around these estimates. Please note that
it is not always possible to estimate cessation and takeoff growth
parameters when there are no distinct pre-peak or post-peak troughs.
</p>


<h3>Value</h3>

<p>A data frame with either five columns (when <code>summary = TRUE</code>),
or two columns when <code>summary = False</code> (assuming <code>re_formual =
  NULL</code>). The first two columns common to each scenario (<code>summary =
  TRUE/False</code>) are <code>'Parameter'</code> and <code>'Estimate'</code> which define the
name of the growth parameter (e.g., APGV, PGV etc), and estimate. When
<code>summary = TRUE</code>, the three additional columns are <code>'Est.Error'</code>,
and a paired vector of names defining the lower and upper limits of the
CIs. The CI columns are named as Q with appropriate suffix taken from the
percentiles used to construct these intervals (such as  <code>Q.2.5</code> and
<code>Q.97.5</code> where<code>2.5</code> and  <code>97.5</code> are the  <code>0.025</code> and
<code>0.975</code> percentiles used to compute by the 95% CI by calling the
quantile function. When <code>re_formual = NULL</code>, an additional column is
added that denotes the individual identifier (typically <code>id</code>).
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average age and velocity during the peak growth spurt
growthparameters(model, re_formula = NA)


# Population average age and velocity during the take-off and the peak 
# growth spurt (APGV, PGV. ATGV, TGV)

growthparameters(model, re_formula = NA, peak = TRUE, takeoff = TRUE)

# Individual-specific age and velocity during the take-off and the peak
# growth spurt (APGV, PGV. ATGV, TGV)

growthparameters(model, re_formula = NULL, peak = TRUE, takeoff = TRUE)


</code></pre>

<hr>
<h2 id='loo_validation.bgmfit'>Perform leave-one-out (loo) cross-validation</h2><span id='topic+loo_validation.bgmfit'></span><span id='topic+loo_validation'></span>

<h3>Description</h3>

<p>The <strong>loo_validation()</strong> is a wrapper around the
<code><a href="brms.html#topic+loo.brmsfit">brms::loo()</a></code> function to perform approximate leave-one-out
cross-validation based on the posterior likelihood. See <code><a href="brms.html#topic+loo.brmsfit">brms::loo()</a></code> for
more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
loo_validation(
  model,
  compare = TRUE,
  resp = NULL,
  pointwise = FALSE,
  moment_match = FALSE,
  reloo = FALSE,
  k_threshold = 0.7,
  save_psis = FALSE,
  moment_match_args = list(),
  reloo_args = list(),
  model_names = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  cores = 1,
  deriv_model = NULL,
  verbose = FALSE,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

loo_validation(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_validation.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_compare">compare</code></td>
<td>
<p>A flag indicating if the information criteria of the models
should be compared to each other via <code><a href="loo.html#topic+loo_compare">loo::loo_compare()</a></code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_pointwise">pointwise</code></td>
<td>
<p>A flag indicating whether to compute the full
log-likelihood matrix at once or separately for each observation.
The latter approach is usually considerably slower but
requires much less working memory. Accordingly, if one runs
into memory issues, <code>pointwise = TRUE</code> is the way to go.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_moment_match">moment_match</code></td>
<td>
<p>A logical argument to indicate whether
<code><a href="loo.html#topic+loo_moment_match">loo::loo_moment_match()</a></code> should be applied on problematic observations.
Defaults to <code>FALSE</code>. For most models, moment matching will only work
if you have set <code>save_pars = save_pars(all = TRUE)</code> when fitting the
model with <code><a href="brms.html#topic+brm">brms::brm()</a></code>. See <code><a href="brms.html#topic+loo_moment_match.brmsfit">brms::loo_moment_match()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_reloo">reloo</code></td>
<td>
<p>A logical argument to indicate whether <code><a href="brms.html#topic+reloo.brmsfit">brms::reloo()</a></code> should be
applied on problematic observations. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_k_threshold">k_threshold</code></td>
<td>
<p>The threshold at which pareto <code class="reqn">k</code>
estimates are treated as problematic. Defaults to <code>0.7</code>.
Only used if argument <code>reloo</code> is <code>TRUE</code>.
See <code><a href="loo.html#topic+pareto-k-diagnostic">pareto_k_ids</a></code> for more details.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_save_psis">save_psis</code></td>
<td>
<p>Should the <code>"psis"</code> object created internally be saved
in the returned object? For more details see <code><a href="loo.html#topic+loo">loo</a></code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_moment_match_args">moment_match_args</code></td>
<td>
<p>An optional <code>list</code> of additional arguments
passed to <code><a href="loo.html#topic+loo_moment_match">loo::loo_moment_match()</a></code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_reloo_args">reloo_args</code></td>
<td>
<p>An optional <code>list</code> of additional arguments passed to
<code><a href="brms.html#topic+reloo.brmsfit">brms::reloo()</a></code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used when running the parallel
computations (if <code>future = TRUE</code>). On non-Windows systems this
argument can be set globally via the mc.cores option. For the default
<code>NULL</code> option, the number of cores are set automatically by calling
the <code><a href="future.html#topic+re-exports">future::availableCores()</a></code>. The number of cores used are the maximum
number of cores avaialble minus one, i.e., <code>future::availableCores() -
  1</code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) that is used to
convert dummy variables into a factor variable. The named elements are
<code>factor.dummy</code>, <code>factor.name</code>, and <code>factor.level</code>. The
<code>factor.dummy</code> is a vector of character strings that need to be
converted to a factor variable whereas the <code>factor.name</code> is a single
character string that is used to name the newly created factor variable.
The <code>factor.level</code> is used to name the levels of newly created factor.
When <code>factor.name</code> is <code>NULL</code>, then the factor name is internally
set as <code>'factor.var'</code>. If <code>factor.level</code> is <code>NULL</code>, then
names of factor levels are take from the <code>factor.dummy</code> i.e., the
factor levels are assigned same name as <code>factor.dummy</code>. Note that when
<code>factor.level</code> is not <code>NULL</code>, its length must be same as the
length of the <code>factor.dummy</code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+loo.brmsfit">brms::loo()</a></code> function.
Please see <code>brms::loo</code> for details on various options available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="loo.html#topic+loo_compare">loo::loo_compare()</a></code> for details on model comparisons. For
<code>bgmfit</code> objects, <code>LOO</code> is an alias of <code>loo</code>. Use method
<code><a href="brms.html#topic+add_criterion">brms::add_criterion()</a></code>  to store information criteria in the fitted model
object for later usage.
</p>


<h3>Value</h3>

<p>If only one model object is provided, then an object of class
<code>loo</code> is returned. If multiple objects are provided, an object of
class <code>loolist</code>.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+loo.brmsfit">brms::loo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit


loo_validation(model, cores = 1)



</code></pre>

<hr>
<h2 id='marginal_comparison.bgmfit'>Compare growth curves</h2><span id='topic+marginal_comparison.bgmfit'></span><span id='topic+marginal_comparison'></span>

<h3>Description</h3>

<p>The <strong>marginal_comparison()</strong> function estimates and
compare growth curves such as distance and velocity. This function is a wrapper around the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>.
The <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> computes unit-level (conditional)
estimates whereas <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> return average
(marginal) estimates. A detailed explanation is available
<a href="https://marginaleffects.com">here</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
marginal_comparison(
  model,
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  newdata = NULL,
  datagrid = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "gaussian",
  xrange = 1,
  digits = 2,
  numeric_cov_at = NULL,
  aux_variables = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  idata_method = NULL,
  ipts = NULL,
  seed = 123,
  future = FALSE,
  future_session = "multisession",
  cores = NULL,
  average = FALSE,
  plot = FALSE,
  showlegends = NULL,
  variables = NULL,
  deriv = NULL,
  deriv_model = NULL,
  comparison = "difference",
  type = NULL,
  by = FALSE,
  conf_level = 0.95,
  transform = NULL,
  cross = FALSE,
  wts = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  eps = NULL,
  reformat = NULL,
  estimate_center = NULL,
  estimate_interval = NULL,
  dummy_to_factor = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

marginal_comparison(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal_comparison.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify response
variable when processing posterior draws for the <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_datagrid">datagrid</code></td>
<td>
<p>Generate a grid of user-specified values for use in the
<code>newdata</code> argument in various functions of the <span class="pkg">marginaleffects</span>
package. This is useful to define where in the predictor space we want to
evaluate the quantities of interest. See <code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code> for
details. The default value for the <code>datagrid</code> is <code>NULL</code> implying
that no custom grid is constructed. To set a data grid, the argument should
be a data.frame constructed by using the <code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code>
function, or else a named list which are internally used for setting up the
grid. For the user convenience, we also allow setting an empty list
<code>datagrid = list()</code> in which case essential arguments such as
<code>model</code>, <code>newdata</code> are taken up from the respective arguments
specified elsewhere. Further, the level 1 predictor (such as age) and any
covariate included in the model fit (e.g., gender) are also automatically
inferred from the <code>model</code> object.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include the
individual/group-level effects in the estimation. When <code>NA</code> (default),
the individual-level effects are excluded and therefore population average
growth parameters are computed. When <code>NULL</code>, individual-level effects
are included in the computation and hence the growth parameters estimates
returned are individual-specific. In both situations, (i.e,, <code>NA</code> or
<code>NULL</code>), continuous and factor covariate(s) are appropriately included
in the estimation. The continuous covariates by default are set to their
means (see <code>numeric_cov_at</code> for details) whereas factor covariates are
left unaltered thereby allowing estimation of covariate specific population
average and individual-specific growth parameter.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (i.e., age) when
executing the interpolation via <code>ipts</code>. The default <code>NULL</code> sets
the individual specific predictor range whereas code <code>xrange = 1</code> sets
identical range for individuals within the same higher grouping variable
(e.g., study). Code <code>xrange  = 2</code> sets the identical range across the
entire sample. Lastly, a paired numeric values can be supplied e.g.,
<code>xrange = c(6, 20)</code> to set the range within those values.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) to set the decimal places for the
estimates. The <code>digits</code> is passed on to the
<code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option set the
continuous covariate(s) at their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate varibale 'xx' at 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariate is
included in the model.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location scale models and measurement error models. An
indication to use <code>aux_variables</code> is when post processing functions
throw an error such as <code>variable 'x' not found either 'data' or
 'data2'</code></p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for
hierarchical model (default <code>NULL</code>). It is used only when model is
applied to the data with 3 or more levels of hierarchy. For a two level
model, the <code>levels_id</code> is automatically inferred from the model fit.
Even for 3 or higher level model, the <code>levels_id</code> is inferred from the
model fit but under the assumption that hierarchy is specified from lowest
to upper most level i.e, <code>id</code> followed by <code>study</code> where <code>id</code>
is nested within the <code>study</code> Note that it is not guaranteed that the
<code>levels_id</code> is sorted correctly, and therefore it is better to set it
manually when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and  <code>reby</code> (typically <code>NULL</code> indicating that
parameters are integrated over the random effects) such as
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of of interpolation points is set up the <code>ipts</code> argument.
Options available for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>). The
<em>method 1</em> (<code>'m1'</code>) is adapted from the the <span class="pkg">iapvbs</span> package
and is documented here
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R</a>
whereas <em>method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span>
package as documented here
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R</a>.
The <code>'m1'</code> method works by internally constructing the data frame based
on the model configuration whereas the method <code>'m2'</code> uses the exact
data frame used in model fit and can be accessed via <code>fit$data</code>. If
<code>idata_method = NULL, default</code>, then method <code>'m2'</code> is
automatically set. Note that method <code>'m1'</code> might fail in some cases
when model involves covariates particularly when model is fit as
<code>univariate_by</code>. Therefore, it is advised to switch to method
<code>'m2'</code> in case <code>'m1'</code> results in error.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable to get a
smooth velocity curve. The <code>NULL</code> will return original values whereas
an integer such as <code>ipts = 10</code> (default) will interpolate the
predictor. It is important to note that these interpolations do not alter
the range of predictor when calculating population average and/or the
individual specific growth curves.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_seed">seed</code></td>
<td>
<p>An integer (default <code>123</code>) that is passed to the estimation
method.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_future">future</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to specify whether or not to
perform parallel computations. If set to <code>TRUE</code>, the
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code> function is used to summarize draws.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_future_session">future_session</code></td>
<td>
<p>A character string to set the session type when
<code>future = TRUE</code>. The <code>'multisession'</code> (default) options sets the
multisession whereas the <code>'multicore'</code> sets the multicore session.
Note that option <code>'multicore'</code> is not supported on Windows systems.
For more details, see <code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used when running the parallel
computations (if <code>future = TRUE</code>). On non-Windows systems this
argument can be set globally via the mc.cores option. For the default
<code>NULL</code> option, the number of cores are set automatically by calling
the <code><a href="future.html#topic+re-exports">future::availableCores()</a></code>. The number of cores used are the maximum
number of cores avaialble minus one, i.e., <code>future::availableCores() -
  1</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_average">average</code></td>
<td>
<p>A logical to indicate whether to internally call the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> or the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> function. If <code>FALSE</code> (default),
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> is called otherwise
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> when <code>average = TRUE</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_plot">plot</code></td>
<td>
<p>A logical to specify whether to plot comparisons by calling the
<code><a href="marginaleffects.html#topic+plot_comparisons">marginaleffects::plot_comparisons()</a></code> function (<code>FALSE</code>) or not
(<code>FALSE</code>). If <code>FALSE</code> (default), then
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> or <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>
are called to compute predictions (see <code>average</code> for details)</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_showlegends">showlegends</code></td>
<td>
<p>An argument to specify whether to show legends
(<code>TRUE</code>) or not (<code>FALSE</code>). If <code>NULL</code> (default), then
<code>showlegends</code> is internally set to <code>TRUE</code> if <code>re_formula =
  NA</code>, and <code>FALSE</code> if <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_variables">variables</code></td>
<td>
<p>For estimating growth parameters in the current use case,
the <code>variables</code> is the level 1 predictor such as
<code>age</code>/<code>time</code>. The <code>variables</code> is a named list where value is
set via the <code>esp</code> argument (default 1e-6). If <code>NULL</code>, the
<code>variables</code> is set internally by retrieving the relevant information
from the <code>model</code>. Otherwise, user can define it as follows:
<code>variables = list('x' = 1e-6)</code> where <code>'x'</code> is the level 1
predictor. Note that <code>variables = list('age' = 1e-6)</code> is the default
behavior for the <span class="pkg">marginaleffects</span> because velocity is typically
calculated by differentiating the distance curve via <code>dydx</code> approach,
and therefore argument <code>deriv</code> is automatically set as <code>0</code> and
<code>deriv_model</code> as <code>FALSE</code>. If user want to estimate parameters
based on the model based first derivative, then argument <code>deriv</code> must
be set as <code>1</code> and internally argument <code>variables</code> is defined as
<code>variables = list('age' = 0)</code> i.e, original level 1 predictor
variable, <code>'x'</code>. It is important to consider that if default behavior
is used i.e, <code>deriv = 0</code> and <code>variables = list('x' = 1e-6)</code>, then
user can not pass additional arguments to the <code>variables</code> argument. On
the other hand, alternative approach i.e, <code>deriv = 0</code> and
<code>variables = list('x' = 0)</code>, additional options can be passed to the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>
functions.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>A numeric to specify whether to estimate parameters based on the
differentiation of the distance curve or the model based first derivative.
Please see argument <code>variables</code> for more details.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_comparison">comparison</code></td>
<td>
<p>For estimating growth parameters in the current use case,
options allowed for the <code>comparison</code> are <code>'difference'</code> and
<code>'differenceavg'</code>. Note that <code>comparison</code> is a placeholder and is
only used to setup the the internal function that estimates
<code>'parameter'</code> via <code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code>, <code><a href="sitar.html#topic+getPeakTrough">sitar::getTakeoff()</a></code> and
<code><a href="sitar.html#topic+getPeakTrough">sitar::getTrough()</a></code> functions to estimate various growth parameters.
Options <code>'difference'</code> and <code>'differenceavg'</code> are internally
restructured according to the user specified <code>hypothesis</code> argument.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_transform">transform</code></td>
<td>
<p>string or function. Transformation applied to unit-level estimates and confidence intervals just before the function returns results. Functions must accept a vector and return a vector of the same length. Support string shortcuts: &quot;exp&quot;, &quot;ln&quot;</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_cross">cross</code></td>
<td>

<ul>
<li> <p><code>FALSE</code>: Contrasts represent the change in adjusted predictions when one predictor changes and all other variables are held constant.
</p>
</li>
<li> <p><code>TRUE</code>: Contrasts represent the changes in adjusted predictions when all the predictors specified in the <code>variables</code> argument are manipulated simultaneously (a &quot;cross-contrast&quot;).
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_wts">wts</code></td>
<td>
<p>string or numeric: weights to use when computing average contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not the unit-level estimates themselves. Internally, estimates and weights are passed to the <code>weighted.mean()</code> function.
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a numeric value, vector, or matrix, a string, or a string formula.
</p>

<ul>
<li><p> Numeric:
</p>

<ul>
<li><p> Single value: the null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li><p> Vector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the <code>hypothesis</code> argument.
</p>
</li>
<li><p> Matrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.
</p>
</li></ul>

</li>
<li><p> String formula to specify linear or non-linear hypothesis tests. If the <code>term</code> column uniquely identifies rows, terms can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">&#8288;b*&#8288;</code> wildcard can be used to test hypotheses on all estimates. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;b* / b1 = 1&#8288;</code>
</p>
</li></ul>

</li>
<li><p> String:
</p>

<ul>
<li><p> &quot;pairwise&quot;: pairwise differences between estimates in each row.
</p>
</li>
<li><p> &quot;reference&quot;: differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li><p> &quot;sequential&quot;: difference between an estimate and the estimate in the next row.
</p>
</li>
<li><p> &quot;revpairwise&quot;, &quot;revreference&quot;, &quot;revsequential&quot;: inverse of the corresponding hypotheses, as described above.
</p>
</li></ul>

</li>
<li><p> See the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_equivalence">equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_eps">eps</code></td>
<td>
<p>NULL or numeric value which determines the step size to use when
calculating numerical derivatives: (f(x+eps)-f(x))/eps. When <code>eps</code> is
<code>NULL</code>, the step size is 0.0001 multiplied by the difference between
the maximum and minimum values of the variable with respect to which we
are taking the derivative. Changing <code>eps</code> may be necessary to avoid
numerical problems in certain models.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_reformat">reformat</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to reformat the  output
returned by the <code>marginaleffects</code> as a data.frame with column names
re-defined as follows: <code>conf.low</code> as <code>Q2.5</code>, and <code>conf.high</code>
as <code>Q97.5</code> (assuming that <code>conf_int = 0.95</code>). Also, following
columns are dropped from the data frame: <code>term</code>, <code>contrast</code>,
<code>tmp_idx</code>, <code>predicted_lo</code>, <code>predicted_hi</code>, <code>predicted</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_estimate_center">estimate_center</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify
whether to center estimate as <code>'mean'</code> or as <code>'median'</code>. Note
that <code>estimate_center</code> is used to set the global options as follows:
<br />
<code> options("marginaleffects_posterior_center" = "mean")</code>, or <br />
<code>options("marginaleffects_posterior_center" = "median")</code> <br />
The pre-specified global options are restored on exit via the
<code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_estimate_interval">estimate_interval</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify
whether to compute credible intervals as equal-tailed intervals,
<code>'eti'</code> or highest density intervals, <code>'hdi'</code>. Note that
<code>estimate_interval</code> is used to set the global options as follows: <br />
<code> options("marginaleffects_posterior_interval" = "eti")</code>, or <br />
<code> options("marginaleffects_posterior_interval" = "hdi")</code> <br />
The pre-specified global options are restored on exit via the
<code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) that is used to
convert dummy variables into a factor variable. The named elements are
<code>factor.dummy</code>, <code>factor.name</code>, and <code>factor.level</code>. The
<code>factor.dummy</code> is a vector of character strings that need to be
converted to a factor variable whereas the <code>factor.name</code> is a single
character string that is used to name the newly created factor variable.
The <code>factor.level</code> is used to name the levels of newly created factor.
When <code>factor.name</code> is <code>NULL</code>, then the factor name is internally
set as <code>'factor.var'</code>. If <code>factor.level</code> is <code>NULL</code>, then
names of factor levels are take from the <code>factor.dummy</code> i.e., the
factor levels are assigned same name as <code>factor.dummy</code>. Note that when
<code>factor.level</code> is not <code>NULL</code>, its length must be same as the
length of the <code>factor.dummy</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>brms::fitted.brmsfit()</code> and
<code>brms::predict()</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame objects with estimates and CIs for computed parameter(s)
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code>
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>
<code><a href="marginaleffects.html#topic+plot_comparisons">marginaleffects::plot_comparisons()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

marginal_comparison(model, parameter = 'apgv', draw_ids = 1)


</code></pre>

<hr>
<h2 id='marginal_draws.bgmfit'>Fitted (expected) values from the posterior draws</h2><span id='topic+marginal_draws.bgmfit'></span><span id='topic+marginal_draws'></span>

<h3>Description</h3>

<p>The <strong>marginal_draws()</strong> function estimates and plots
growth curves (distance and velocity) by using <span class="pkg">marginaleffects</span>
package as back-end. This function can compute growth curves (via
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code>), average growth curves (via
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code>) or plot growth curves (via
<code><a href="marginaleffects.html#topic+plot_predictions">marginaleffects::plot_predictions()</a></code>). Please see
<a href="https://marginaleffects.com/">here</a> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
marginal_draws(
  model,
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  newdata = NULL,
  datagrid = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "gaussian",
  parameter = NULL,
  xrange = 1,
  acg_velocity = 0.1,
  digits = 2,
  numeric_cov_at = NULL,
  aux_variables = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  idata_method = NULL,
  ipts = NULL,
  seed = 123,
  future = FALSE,
  future_session = "multisession",
  cores = NULL,
  fullframe = FALSE,
  average = FALSE,
  plot = FALSE,
  showlegends = NULL,
  variables = NULL,
  condition = NULL,
  deriv = 0,
  deriv_model = TRUE,
  type = NULL,
  by = NULL,
  conf_level = 0.95,
  transform = NULL,
  byfun = NULL,
  wts = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  reformat = NULL,
  estimate_center = NULL,
  estimate_interval = NULL,
  dummy_to_factor = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

marginal_draws(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal_draws.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify response
variable when processing posterior draws for the <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_datagrid">datagrid</code></td>
<td>
<p>Generate a grid of user-specified values for use in the
<code>newdata</code> argument in various functions of the <span class="pkg">marginaleffects</span>
package. This is useful to define where in the predictor space we want to
evaluate the quantities of interest. See <code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code> for
details. The default value for the <code>datagrid</code> is <code>NULL</code> implying
that no custom grid is constructed. To set a data grid, the argument should
be a data.frame constructed by using the <code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code>
function, or else a named list which are internally used for setting up the
grid. For the user convenience, we also allow setting an empty list
<code>datagrid = list()</code> in which case essential arguments such as
<code>model</code>, <code>newdata</code> are taken up from the respective arguments
specified elsewhere. Further, the level 1 predictor (such as age) and any
covariate included in the model fit (e.g., gender) are also automatically
inferred from the <code>model</code> object.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include the
individual/group-level effects in the estimation. When <code>NA</code> (default),
the individual-level effects are excluded and therefore population average
growth parameters are computed. When <code>NULL</code>, individual-level effects
are included in the computation and hence the growth parameters estimates
returned are individual-specific. In both situations, (i.e,, <code>NA</code> or
<code>NULL</code>), continuous and factor covariate(s) are appropriately included
in the estimation. The continuous covariates by default are set to their
means (see <code>numeric_cov_at</code> for details) whereas factor covariates are
left unaltered thereby allowing estimation of covariate specific population
average and individual-specific growth parameter.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_parameter">parameter</code></td>
<td>
<p>A single character string, or a character vector specifying
the growth parameter(s) to be estimated. Options are <code>'tgv'</code> (takeoff
growth velocity), <code>'atgv'</code> (age at takeoff growth velocity),
<code>'pgv'</code> (peak growth velocity), <code>'apgv'</code> (age at peak growth
velocity), <code>'cgv'</code> (cessation growth velocity), and <code>'acgv'</code> (age
at cessation growth velocity), and <code>'all'</code>. If <code>parameter = NULL</code>
(default), age at peak growth velocity (<code>'apgv'</code>) is estimated where
when <code>parameter = 'all'</code>, all six parameters are estimated. Note that
option <code>'all'</code> can not be used when argument <code>by</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (i.e., age) when
executing the interpolation via <code>ipts</code>. The default <code>NULL</code> sets
the individual specific predictor range whereas code <code>xrange = 1</code> sets
identical range for individuals within the same higher grouping variable
(e.g., study). Code <code>xrange  = 2</code> sets the identical range across the
entire sample. Lastly, a paired numeric values can be supplied e.g.,
<code>xrange = c(6, 20)</code> to set the range within those values.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_acg_velocity">acg_velocity</code></td>
<td>
<p>A real number to set the percentage of peak growth growth
velocity as the cessation velocity when estimating the <code>cgv</code> and
<code>acgv</code> growth parameters. The <code>acg_velocity</code> should be greater
than <code>0</code> and less than <code>1</code>. The default <code>acg_velocity =
  0.10</code> indicates that a 10 per cent of the peak growth velocity will be used
to get the cessation velocity and the corresponding age at the cessation
velocity. For example if peak growth velocity estimate is <code>10
  mm/year</code>, then cessation growth velocity is <code>1 mm/year</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) to set the decimal argument for
the <code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option set the
continuous covariate(s) at their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate varibale 'xx' at 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariate is
included in the model.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location scale models and measurement error models. An
indication to use <code>aux_variables</code> is when post processing functions
throw an error such as <code>variable 'x' not found either 'data' or
 'data2'</code></p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for
hierarchical model (default <code>NULL</code>). It is used only when model is
applied to the data with 3 or more levels of hierarchy. For a two level
model, the <code>levels_id</code> is automatically inferred from the model fit.
Even for 3 or higher level model, the <code>levels_id</code> is inferred from the
model fit but under the assumption that hierarchy is specified from lowest
to upper most level i.e, <code>id</code> followed by <code>study</code> where <code>id</code>
is nested within the <code>study</code> Note that it is not guaranteed that the
<code>levels_id</code> is sorted correctly, and therefore it is better to set it
manually when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and  <code>reby</code> (typically <code>NULL</code> indicating that
parameters are integrated over the random effects) such as
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of of interpolation points is set up the <code>ipts</code> argument.
Options available for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>). The
<em>method 1</em> (<code>'m1'</code>) is adapted from the the <span class="pkg">iapvbs</span> package
and is documented here
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R</a>
whereas <em>method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span>
package as documented here
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R</a>.
The <code>'m1'</code> method works by internally constructing the data frame based
on the model configuration whereas the method <code>'m2'</code> uses the exact
data frame used in model fit and can be accessed via <code>fit$data</code>. If
<code>idata_method = NULL, default</code>, then method <code>'m2'</code> is
automatically set. Note that method <code>'m1'</code> might fail in some cases
when model involves covariates particularly when model is fit as
<code>univariate_by</code>. Therefore, it is advised to switch to method
<code>'m2'</code> in case <code>'m1'</code> results in error.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable to get a
smooth velocity curve. The <code>NULL</code> will return original values whereas
an integer such as <code>ipts = 10</code> (default) will interpolate the
predictor. It is important to note that these interpolations do not alter
the range of predictor when calculating population average and/or the
individual specific growth curves.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_seed">seed</code></td>
<td>
<p>An integer (default <code>123</code>) that is passed to the estimation
method.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_future">future</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to specify whether or not to
perform parallel computations. If set to <code>TRUE</code>, the
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code> function is used to summarize draws.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_future_session">future_session</code></td>
<td>
<p>A character string to set the session type when
<code>future = TRUE</code>. The <code>'multisession'</code> (default) options sets the
multisession whereas the <code>'multicore'</code> sets the multicore session.
Note that option <code>'multicore'</code> is not supported on Windows systems.
For more details, see <code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used when running the parallel
computations (if <code>future = TRUE</code>). On non-Windows systems this
argument can be set globally via the mc.cores option. For the default
<code>NULL</code> option, the number of cores are set automatically by calling
the <code><a href="future.html#topic+re-exports">future::availableCores()</a></code>. The number of cores used are the maximum
number of cores avaialble minus one, i.e., <code>future::availableCores() -
  1</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_fullframe">fullframe</code></td>
<td>
<p>A logical to indicate whether to return <code>fullframe</code>
object in which <code>newdata</code> is bind to the summary estimates. Note that
<code>fullframe</code> can not be combined with <code>summary = FALSE</code>.
Furthermore, <code>fullframe</code> can only be used when <code>idata_method =
  'm2'</code>. A particular use case is when fitting <code>univariate_by</code> model.
The <code>fullframe</code> is mainly for internal use only.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_average">average</code></td>
<td>
<p>A logical to indicate whether to internally call the
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> or the
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code> function. If <code>FALSE</code> (default),
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> is called otherwise
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code> when <code>average = TRUE</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_plot">plot</code></td>
<td>
<p>A logical to specify whether to plot predictions by calling the
<code><a href="marginaleffects.html#topic+plot_predictions">marginaleffects::plot_predictions()</a></code> function (<code>FALSE</code>) or not
(<code>FALSE</code>). If <code>FALSE</code> (default), then
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> or <code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code>
are called to compute predictions (see <code>average</code> for details)</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_showlegends">showlegends</code></td>
<td>
<p>An argument to specify whether to show legends
(<code>TRUE</code>) or not (<code>FALSE</code>). If <code>NULL</code> (default), then
<code>showlegends</code> is internally set to <code>TRUE</code> if <code>re_formula =
  NA</code>, and <code>FALSE</code> if <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_variables">variables</code></td>
<td>
<p>For estimating growth parameters in the current use case,
the <code>variables</code> is the level 1 predictor such as
<code>age</code>/<code>time</code>. The <code>variables</code> is a named list where value is
set via the <code>esp</code> argument (default 1e-6). If <code>NULL</code>, the
<code>variables</code> is set internally by retrieving the relevant information
from the <code>model</code>. Otherwise, user can define it as follows:
<code>variables = list('x' = 1e-6)</code> where <code>'x'</code> is the level 1
predictor. Note that <code>variables = list('age' = 1e-6)</code> is the default
behavior for the <span class="pkg">marginaleffects</span> because velocity is typically
calculated by differentiating the distance curve via <code>dydx</code> approach,
and therefore argument <code>deriv</code> is automatically set as <code>0</code> and
<code>deriv_model</code> as <code>FALSE</code>. If user want to estimate parameters
based on the model based first derivative, then argument <code>deriv</code> must
be set as <code>1</code> and internally argument <code>variables</code> is defined as
<code>variables = list('age' = 0)</code> i.e, original level 1 predictor
variable, <code>'x'</code>. It is important to consider that if default behavior
is used i.e, <code>deriv = 0</code> and <code>variables = list('x' = 1e-6)</code>, then
user can not pass additional arguments to the <code>variables</code> argument. On
the other hand, alternative approach i.e, <code>deriv = 0</code> and
<code>variables = list('x' = 0)</code>, additional options can be passed to the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>
functions.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_condition">condition</code></td>
<td>
<p>Conditional predictions
</p>

<ul>
<li><p> Character vector (max length 4): Names of the predictors to display.
</p>
</li>
<li><p> Named list (max length 4): List names correspond to predictors. List elements can be:
</p>

<ul>
<li><p> Numeric vector
</p>
</li>
<li><p> Function which returns a numeric vector or a set of unique categorical values
</p>
</li>
<li><p> Shortcut strings for common reference values: &quot;minmax&quot;, &quot;quartile&quot;, &quot;threenum&quot;
</p>
</li></ul>

</li>
<li><p> 1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).
</p>
</li>
<li><p> Numeric variables in positions 2 and 3 are summarized by Tukey's five numbers <code>?stats::fivenum</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>An integer to indicate whether to estimate distance curve or its
derivative (i.e., velocity curve). The <code>deriv = 0</code> (default) is for
the distance curve whereas <code>deriv = 1</code> for the velocity curve.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_transform">transform</code></td>
<td>
<p>string or function. Transformation applied to unit-level estimates and confidence intervals just before the function returns results. Functions must accept a vector and return a vector of the same length. Support string shortcuts: &quot;exp&quot;, &quot;ln&quot;</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_byfun">byfun</code></td>
<td>
<p>A function such as <code>mean()</code> or <code>sum()</code> used to aggregate
estimates within the subgroups defined by the <code>by</code> argument. <code>NULL</code> uses the
<code>mean()</code> function. Must accept a numeric vector and return a single numeric
value. This is sometimes used to take the sum or mean of predicted
probabilities across outcome or predictor
levels. See examples section.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_wts">wts</code></td>
<td>
<p>string or numeric: weights to use when computing average contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not the unit-level estimates themselves. Internally, estimates and weights are passed to the <code>weighted.mean()</code> function.
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a numeric value, vector, or matrix, a string, or a string formula.
</p>

<ul>
<li><p> Numeric:
</p>

<ul>
<li><p> Single value: the null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li><p> Vector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the <code>hypothesis</code> argument.
</p>
</li>
<li><p> Matrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.
</p>
</li></ul>

</li>
<li><p> String formula to specify linear or non-linear hypothesis tests. If the <code>term</code> column uniquely identifies rows, terms can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">&#8288;b*&#8288;</code> wildcard can be used to test hypotheses on all estimates. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;b* / b1 = 1&#8288;</code>
</p>
</li></ul>

</li>
<li><p> String:
</p>

<ul>
<li><p> &quot;pairwise&quot;: pairwise differences between estimates in each row.
</p>
</li>
<li><p> &quot;reference&quot;: differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li><p> &quot;sequential&quot;: difference between an estimate and the estimate in the next row.
</p>
</li>
<li><p> &quot;revpairwise&quot;, &quot;revreference&quot;, &quot;revsequential&quot;: inverse of the corresponding hypotheses, as described above.
</p>
</li></ul>

</li>
<li><p> See the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_equivalence">equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_reformat">reformat</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to reformat the  output
returned by the <code>marginaleffects</code> as a data.frame with column names
re-defined as follows: <code>conf.low</code> as <code>Q2.5</code>, and <code>conf.high</code>
as <code>Q97.5</code> (assuming that <code>conf_int = 0.95</code>). Also, following
columns are dropped from the data frame: <code>term</code>, <code>contrast</code>,
<code>tmp_idx</code>, <code>predicted_lo</code>, <code>predicted_hi</code>, <code>predicted</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_estimate_center">estimate_center</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify
whether to center estimate as <code>'mean'</code> or as <code>'median'</code>. Note
that <code>estimate_center</code> is used to set the global options as follows:
<br />
<code> options("marginaleffects_posterior_center" = "mean")</code>, or <br />
<code>options("marginaleffects_posterior_center" = "median")</code> <br />
The pre-specified global options are restored on exit via the
<code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_estimate_interval">estimate_interval</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify
whether to compute credible intervals as equal-tailed intervals,
<code>'eti'</code> or highest density intervals, <code>'hdi'</code>. Note that
<code>estimate_interval</code> is used to set the global options as follows: <br />
<code> options("marginaleffects_posterior_interval" = "eti")</code>, or <br />
<code> options("marginaleffects_posterior_interval" = "hdi")</code> <br />
The pre-specified global options are restored on exit via the
<code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) that is used to
convert dummy variables into a factor variable. The named elements are
<code>factor.dummy</code>, <code>factor.name</code>, and <code>factor.level</code>. The
<code>factor.dummy</code> is a vector of character strings that need to be
converted to a factor variable whereas the <code>factor.name</code> is a single
character string that is used to name the newly created factor variable.
The <code>factor.level</code> is used to name the levels of newly created factor.
When <code>factor.name</code> is <code>NULL</code>, then the factor name is internally
set as <code>'factor.var'</code>. If <code>factor.level</code> is <code>NULL</code>, then
names of factor levels are take from the <code>factor.dummy</code> i.e., the
factor levels are assigned same name as <code>factor.dummy</code>. Note that when
<code>factor.level</code> is not <code>NULL</code>, its length must be same as the
length of the <code>factor.dummy</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>
function. Please see <code>brms::fitted.brmsfit()</code> for details on
various options available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>marginal_draws()</strong> estimates fitted values (via
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>) or the posterior draws from the posterior
distribution (via <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>) depending on the <code>type</code>
argument.
</p>


<h3>Value</h3>

<p>An array of predicted mean response values. See
<a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit</a> for details.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code>
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code>
<code><a href="marginaleffects.html#topic+plot_predictions">marginaleffects::plot_predictions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average distance curve
marginal_draws(model, deriv = 0, re_formula = NA)


# Individual-specific distance curves
marginal_draws(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
marginal_draws(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
marginal_draws(model, deriv = 1, re_formula = NULL)


</code></pre>

<hr>
<h2 id='optimize_model.bgmfit'>Optimize SITAR model</h2><span id='topic+optimize_model.bgmfit'></span><span id='topic+optimize_model'></span>

<h3>Description</h3>

<p>Select the best fitting SITAR model that involves choosing the
optimum degrees of freedom (<code>df</code>) for the natural cubic-spline curve
and the appropriate transformations of the predictor <code>x</code> and response
<code>y</code> variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
optimize_model(
  model,
  newdata = NULL,
  optimize_df = NULL,
  optimize_x = list(NULL, log, sqrt),
  optimize_y = list(NULL, log, sqrt),
  transform_prior_class = c("beta", "sd", "rsd", "sigma", "dpar"),
  transform_beta_coef = c("b", "c", "d"),
  transform_sd_coef = c("b", "c", "d"),
  exclude_default_funs = TRUE,
  add_fit_criteria = NULL,
  add_bayes_R = NULL,
  byresp = FALSE,
  digits = 2,
  cores = 1,
  verbose = FALSE,
  expose_function = NULL,
  usesavedfuns = FALSE,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

optimize_model(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_model.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_optimize_df">optimize_df</code></td>
<td>
<p>A list of integers specifying the degree of freedom
(<code>df</code>) values to be optimized. If <code>NULL</code> (default), the <code>df</code>
is taken from the original model. For optimization over different
<code>df</code>, say for example <code>df</code> 4 and <code>df</code> 5, the corresponding
code is <code>optimize_df = list(4,5)</code>. For <code>univariate_by</code> and
<code>multivariate</code> models, <code>optimize_df</code> can be a single integer
(e.g., <code>optimize_df = 4</code>) or a list (e.g., <code>optimize_df =
  list(4,5)</code>), or a a list of lists. As an example, consider optimization
over <code>df</code> 4 and <code>df</code> 5 for the first sub model, and <code>df</code> 5
and <code>df</code> 6 for the second sub model, the corresponding code is
<code>optimize_df = list(list(4,5), list(5,6))</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_optimize_x">optimize_x</code></td>
<td>
<p>A vector specifying the transformations for the predictor
variable (i.e., <code>x</code>). The options available are <code>NULL</code>,
<code>'log'</code>, <code>'sqrt'</code>, or their combinations. Note that user need not
to enclose these options in a single or double quotes as they are take care
of internally. The default setting is to explore all possible combination
i.e., <code>optimize_x = list(NULL, log,  sqrt)</code>. Similar to the
<code>optimize_df</code>, user can specify different <code>optimize_x</code> for
<code>univariate_by</code> and <code>multivariate</code> sub models.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_optimize_y">optimize_y</code></td>
<td>
<p>A vector specifying the transformations of the the response
variable (i.e., <code>y</code>). The approach and options available for
<code>optimize_y</code> are same as described above for the <code>optimize_x</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_transform_prior_class">transform_prior_class</code></td>
<td>
<p>A character vector (default <code>NULL</code>)
specifying the transformations of location-scale based priors such as
<code>normal()</code> when response variable (i.e., <code>y</code>) is <code>'log'</code> or
<code>'sqrt'</code> transformed. The prior type that could be transformed are
<code>'beta'</code>, <code>'sd'</code>, <code>'rsd'</code>, <code>'sigma'</code> and <code>'dpar'</code>.
Currently it is available only for <code>'log'</code> transformed <code>y</code>. Each
prior type (i.e., <code>'beta', 'sd', 'rsd', 'sigma', 'dpar'</code>) specified
via <code>transform_prior_class</code> is log transformed as follows: <br />
<code>log_location = log(location / sqrt(scale^2 / location^2 + 1))</code>, <br />
<code>log_scale = sqrt(log(scale^2 / location^2 + 1))</code>, <br />
where location and scale are the original parameters supplied by the user
and the log_location and log_scale are the equivalent parameters on the log
scale. For more details, see <code>a_prior_beta</code> argument in <code><a href="#topic+bsitar">bsitar()</a></code>
function. Note that <code>transform_prior_class</code> is used as an experiment
and therefore results may not be what user intended. Thus we recommend to
explicitly set the desired prior and not to use
<code>transform_prior_class</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_transform_beta_coef">transform_beta_coef</code></td>
<td>
<p>A character vector (default <code>NULL</code>)
specifying the transformations of location-scale based priors for specific
regression coefficient(s) when response variable (i.e., <code>y</code>) is
<code>'log'</code> or <code>'sqrt'</code> transformed. The coefficient that could be
transformed are <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, <code>'d'</code> and
<code>'s'</code>. The default is <code>transform_beta_coef = c('b',' b', 'd')</code>
which implies that parameters <code>'a'</code>, <code>'a'</code> and <code>'a'</code> will be
transformed whereas parameter <code>'a'</code> will be left unchanged because
default prior for parameter <code>'a'</code> is based on outcome  <code>y</code> itself
(e.g., <code>a_prior_beta = normal(ymean, ysd)</code>) which has be transformed.
However, we strongly suggest that user explicitly set the desired prior and
not to rely on <code>transform_beta_coef</code> because it is included on
experimental basis. See <code>transform_prior_class</code> for details.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_transform_sd_coef">transform_sd_coef</code></td>
<td>
<p>A character vector (default <code>NULL</code>) specifying
the transformations of location-scale based priors for specific group level
coefficient(s) when response variable (i.e., <code>y</code>) is <code>'log'</code> or
<code>'sqrt'</code> transformed. The coefficient that could be transformed are
<code>'a'</code>, <code>'b'</code>, <code>'c'</code>, <code>'d'</code> and <code>'s'</code>. The default
is <code>transform_beta_coef = c('b',' b', 'd')</code>. See
<code>transform_prior_class</code> and <code>transform_beta_coef</code>  for details.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_exclude_default_funs">exclude_default_funs</code></td>
<td>
<p>A logical to indicate whether transformations for
(<code>x</code> and <code>y</code>) variables used in the original model fit should be
excluded. If <code>TRUE</code> (default), the transformations specified for the
<code>x</code> and <code>y</code> variables in the original model fit are excluded from
the <code>optimize_x</code> and <code>optimize_y</code>. From example, if original
model is fit with <code>xvar = log</code> and <code>yvar = NULL</code>, then
<code>optimize_x</code> is translated into <code>optimize_x = list(NULL, sqrt)</code>,
and similarly <code>optimize_y</code> is reset as <code>optimize_y = list(log,
  sqrt)</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_add_fit_criteria">add_fit_criteria</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to
indicate whether to add fit criteria to the returned model fit. Options
available are <code>'loo'</code> and <code>'waic'</code>. Please see
<code><a href="brms.html#topic+add_criterion">brms::add_criterion()</a></code> for details.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_add_bayes_r">add_bayes_R</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to indicate
whether to add Bayesian R square to the returned model fit. To estimate and
add <code>bayes_R2</code> to the model fit, the argument <code>add_bayes_R</code> is
set as <code>add_bayes_R = 'bayes_R2'</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_byresp">byresp</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate if response wise
fit criteria to be calculated. This argument is evaluated only for the
<code>multivariate</code> model in which user can select whether to get joint
calculation of point wise log likelihood (<code>byresp = FALSE</code>) or
response specific (<code>byresp = TRUE</code>). For, <code>univariate_by</code> model,
the only option available is to calculate separate point wise log
likelihood for each sub-model, i.e., <code>byresp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) to set the decimal argument for
the <code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_cores">cores</code></td>
<td>
<p>The number of cores to used in parallel processing (default
<code>1</code>). The argument <code>cores</code> is passed to the
<code><a href="brms.html#topic+add_criterion">brms::add_criterion()</a></code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+update_model">update_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the optimized models of class <code>bgmfit</code>, and
the the summary statistics if <code>add_fit_criteria</code> and/or
<code>add_bayes_R</code> are specified.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+add_criterion">brms::add_criterion()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Below example shows dummy call to optimization to save time. 
# Note that in case degree of freedom and both  optimize_x and optimize_y are
# NULL (i.e., nothing to optimize), the original model object is returned.   
# To explicitly get this information whether model is being optimized or not, 
# user can set verbose = TRUE. The verbose = TRUE also useful in getting the
# information regarding what all arguments have been changed as compared to
# the original model.

model2 &lt;- optimize_model(model, 
  optimize_df = NULL, 
  optimize_x = NULL, 
  optimize_y = NULL,
  verbose = TRUE)



</code></pre>

<hr>
<h2 id='plot_conditional_effects.bgmfit'>Visualize conditional effects of predictor</h2><span id='topic+plot_conditional_effects.bgmfit'></span><span id='topic+plot_conditional_effects'></span>

<h3>Description</h3>

<p>Display conditional effects of one or more numeric and/or categorical
predictors including two-way interaction effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
plot_conditional_effects(
  model,
  effects = NULL,
  conditions = NULL,
  int_conditions = NULL,
  re_formula = NA,
  spaghetti = FALSE,
  surface = FALSE,
  categorical = FALSE,
  ordinal = FALSE,
  transform = NULL,
  resolution = 100,
  select_points = 0,
  too_far = 0,
  prob = 0.95,
  robust = TRUE,
  newdata = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  levels_id = NULL,
  resp = NULL,
  ipts = 10,
  deriv = 0,
  deriv_model = NULL,
  idata_method = NULL,
  verbose = FALSE,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

plot_conditional_effects(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_effects">effects</code></td>
<td>
<p>An optional character vector naming effects (main effects or
interactions) for which to compute conditional plots. Interactions are
specified by a <code>:</code> between variable names. If <code>NULL</code> (the
default), plots are generated for all main effects and two-way interactions
estimated in the model. When specifying <code>effects</code> manually, <em>all</em>
two-way interactions (including grouping variables) may be plotted
even if not originally modeled.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_conditions">conditions</code></td>
<td>
<p>An optional <code>data.frame</code> containing variable values
to condition on. Each effect defined in <code>effects</code> will
be plotted separately for each row of <code>conditions</code>. Values in the
<code>cond__</code> column will be used as titles of the subplots. If <code>cond__</code>
is not given, the row names will be used for this purpose instead.
It is recommended to only define a few rows in order to keep the plots clear.
See <code><a href="brms.html#topic+make_conditions">make_conditions</a></code> for an easy way to define conditions.
If <code>NULL</code> (the default), numeric variables will be conditionalized by
using their means and factors will get their first level assigned.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_int_conditions">int_conditions</code></td>
<td>
<p>An optional named <code>list</code> whose elements are
vectors of values of the variables specified in <code>effects</code>.
At these values, predictions are evaluated. The names of
<code>int_conditions</code> have to match the variable names exactly.
Additionally, the elements of the vectors may be named themselves,
in which case their names appear as labels for the conditions in the plots.
Instead of vectors, functions returning vectors may be passed and are
applied on the original values of the corresponding variable.
If <code>NULL</code> (the default), predictions are evaluated at the
<code class="reqn">mean</code> and at <code class="reqn">mean +/- sd</code> for numeric predictors and at
all categories for factor-like predictors.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>A formula containing group-level effects to be considered
in the conditional predictions. If <code>NULL</code>, include all group-level
effects; if <code>NA</code> (default), include no group-level effects.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_spaghetti">spaghetti</code></td>
<td>
<p>Logical. Indicates if predictions should
be visualized via spaghetti plots. Only applied for numeric
predictors. If <code>TRUE</code>, it is recommended
to set argument <code>ndraws</code> to a relatively small value
(e.g., <code>100</code>) in order to reduce computation time.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_surface">surface</code></td>
<td>
<p>Logical. Indicates if interactions or
two-dimensional smooths should be visualized as a surface.
Defaults to <code>FALSE</code>. The surface type can be controlled
via argument <code>stype</code> of the related plotting method.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_categorical">categorical</code></td>
<td>
<p>Logical. Indicates if effects of categorical
or ordinal models should be shown in terms of probabilities
of response categories. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_ordinal">ordinal</code></td>
<td>
<p>(Deprecated) Please use argument <code>categorical</code>.
Logical. Indicates if effects in ordinal models
should be visualized as a raster with the response categories
on the y-axis. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_transform">transform</code></td>
<td>
<p>A function or a character string naming
a function to be applied on the predicted responses
before summary statistics are computed. Only allowed
if <code>method = "posterior_predict"</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_resolution">resolution</code></td>
<td>
<p>Number of support points used to generate
the plots. Higher resolution leads to smoother plots.
Defaults to <code>100</code>. If <code>surface</code> is <code>TRUE</code>,
this implies <code>10000</code> support points for interaction terms,
so it might be necessary to reduce <code>resolution</code>
when only few RAM is available.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_select_points">select_points</code></td>
<td>
<p>Positive number.
Only relevant if <code>points</code> or <code>rug</code> are set to <code>TRUE</code>:
Actual data points of numeric variables that
are too far away from the values specified in <code>conditions</code>
can be excluded from the plot. Values are scaled into
the unit interval and then points more than <code>select_points</code>
from the values in <code>conditions</code> are excluded.
By default, all points are used.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_too_far">too_far</code></td>
<td>
<p>Positive number.
For surface plots only: Grid points that are too
far away from the actual data points can be excluded from the plot.
<code>too_far</code> determines what is too far. The grid is scaled into
the unit square and then grid points more than <code>too_far</code>
from the predictor variables are excluded. By default, all
grid points are used. Ignored for non-surface plots.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_prob">prob</code></td>
<td>
<p>A value between 0 and 1 indicating the desired probability
to be covered by the uncertainty intervals. The default is 0.95.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_robust">robust</code></td>
<td>
<p>If <code>TRUE</code> (the default) the median is used as the
measure of central tendency. If <code>FALSE</code> the mean is used instead.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for
hierarchical model (default <code>NULL</code>). It is used only when model is
applied to the data with 3 or more levels of hierarchy. For a two level
model, the <code>levels_id</code> is automatically inferred from the model fit.
Even for 3 or higher level model, the <code>levels_id</code> is inferred from the
model fit but under the assumption that hierarchy is specified from lowest
to upper most level i.e, <code>id</code> followed by <code>study</code> where <code>id</code>
is nested within the <code>study</code> Note that it is not guaranteed that the
<code>levels_id</code> is sorted correctly, and therefore it is better to set it
manually when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify response
variable when processing posterior draws for the <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable to get a
smooth velocity curve. The <code>NULL</code> will return original values whereas
an integer such as <code>ipts = 10</code> (default) will interpolate the
predictor. It is important to note that these interpolations do not alter
the range of predictor when calculating population average and/or the
individual specific growth curves.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>An integer to indicate whether to estimate distance curve or its
derivative (i.e., velocity curve). The <code>deriv = 0</code> (default) is for
the distance curve whereas <code>deriv = 1</code> for the velocity curve.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of of interpolation points is set up the <code>ipts</code> argument.
Options available for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>). The
<em>method 1</em> (<code>'m1'</code>) is adapted from the the <span class="pkg">iapvbs</span> package
and is documented here
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R</a>
whereas <em>method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span>
package as documented here
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R</a>.
The <code>'m1'</code> method works by internally constructing the data frame based
on the model configuration whereas the method <code>'m2'</code> uses the exact
data frame used in model fit and can be accessed via <code>fit$data</code>. If
<code>idata_method = NULL, default</code>, then method <code>'m2'</code> is
automatically set. Note that method <code>'m1'</code> might fail in some cases
when model involves covariates particularly when model is fit as
<code>univariate_by</code>. Therefore, it is advised to switch to method
<code>'m2'</code> in case <code>'m1'</code> results in error.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) that is used to
convert dummy variables into a factor variable. The named elements are
<code>factor.dummy</code>, <code>factor.name</code>, and <code>factor.level</code>. The
<code>factor.dummy</code> is a vector of character strings that need to be
converted to a factor variable whereas the <code>factor.name</code> is a single
character string that is used to name the newly created factor variable.
The <code>factor.level</code> is used to name the levels of newly created factor.
When <code>factor.name</code> is <code>NULL</code>, then the factor name is internally
set as <code>'factor.var'</code>. If <code>factor.level</code> is <code>NULL</code>, then
names of factor levels are take from the <code>factor.dummy</code> i.e., the
factor levels are assigned same name as <code>factor.dummy</code>. Note that when
<code>factor.level</code> is not <code>NULL</code>, its length must be same as the
length of the <code>factor.dummy</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code>
function. Please see <code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>plot_conditional_effects()</strong> is a wrapper around the
<code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code>. The <code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code> function
from the <span class="pkg">brms</span> package can used to plot the fitted (distance) curve
when response (e.g., height) is not transformed. However, when the outcome
is log or square root transformed, the <code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code> will
return the fitted curve on the log or square root scale whereas the
<strong>plot_conditional_effects()</strong> will return the fitted curve on the
original scale. Furthermore, the <strong>plot_conditional_effects()</strong> also
plots the velocity curve on the original scale after making required
back-transformation. Apart from these differences, both these functions
(<a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects</a> and <strong>plot_conditional_effects()</strong> work
in the same manner. In other words, user can specify all the arguments
which are available in the <code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class 'brms_conditional_effects' which is a named list
with one data.frame per effect containing all information required to
generate conditional effects plots. See brms::conditional_effects for
details.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average distance curve
plot_conditional_effects(model, deriv = 0, re_formula = NA)


# Individual-specific distance curves
plot_conditional_effects(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
plot_conditional_effects(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
plot_conditional_effects(model, deriv = 1, re_formula = NULL)


</code></pre>

<hr>
<h2 id='plot_curves.bgmfit'>Plot growth curves</h2><span id='topic+plot_curves.bgmfit'></span><span id='topic+plot_curves'></span>

<h3>Description</h3>

<p>The <strong>plot_curves()</strong> provides visualization of six
different types of growth curves that are plotted by using the <span class="pkg">ggplot2</span>
package. The <strong>plot_curves()</strong> also allows users to make their own
detailed plots from the data returned as a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
plot_curves(
  model,
  opt = "dv",
  apv = FALSE,
  bands = NULL,
  conf = 0.95,
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  newdata = NULL,
  summary = TRUE,
  digits = 2,
  re_formula = NULL,
  numeric_cov_at = NULL,
  aux_variables = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  ipts = 10,
  deriv_model = TRUE,
  xrange = NULL,
  xrange_search = NULL,
  takeoff = FALSE,
  trough = FALSE,
  acgv = FALSE,
  acgv_velocity = 0.1,
  seed = 123,
  estimation_method = "fitted",
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty",
  incl_autocor = TRUE,
  robust = FALSE,
  future = FALSE,
  future_session = "multisession",
  cores = NULL,
  trim = 0,
  layout = "single",
  linecolor = NULL,
  linecolor1 = NULL,
  linecolor2 = NULL,
  label.x = NULL,
  label.y = NULL,
  legendpos = NULL,
  linetype.apv = NULL,
  linewidth.main = NULL,
  linewidth.apv = NULL,
  linetype.groupby = NA,
  color.groupby = NA,
  band.alpha = NULL,
  show_age_takeoff = TRUE,
  show_age_peak = TRUE,
  show_age_cessation = TRUE,
  show_vel_takeoff = FALSE,
  show_vel_peak = FALSE,
  show_vel_cessation = FALSE,
  returndata = FALSE,
  returndata_add_parms = FALSE,
  parms_eval = FALSE,
  idata_method = NULL,
  parms_method = "getPeak",
  verbose = FALSE,
  fullframe = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

plot_curves(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_curves.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_opt">opt</code></td>
<td>
<p>A character string containing letter(s) corresponding to the
following plotting options: 'd' for population average distance curve, 'v'
for population average velocity curve, 'D' for individual-specific distance
curves, 'V' for individual-specific velocity curves, 'u' for unadjusted
individual-specific distance curves, and 'a' for adjusted
individual-specific distance curves (adjusted for the random effects).
Options 'd' and 'D' can not be specified simultaneously. Likewise, Options
'v' and 'V' can not be specified simultaneously. All other combinations are
allowed. For example, dvau', Dvau', dVau', DVau', or dvau'.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_apv">apv</code></td>
<td>
<p>An optional logical (default <code>FALSE</code>) specifying whether or
not to calculate and plot the age at peak velocity (APGV) when <code>opt</code>)
includes 'v' or 'V'.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_bands">bands</code></td>
<td>
<p>A character string containing letter(s), or <code>NULL</code> (default)
to indicate if CI bands to be plotted around the distance and velocity
curves (and also the APGV). If <code>NULL</code>, no band plotted. Alternatively,
user can specify a string with any one of the following or their
combination(s): <code>'d'</code> for band around the distance curve, <code>'v} for
band around the velocity curve, and \code{'p</code> for band around the the
vertical line denoting the APGV parameter. The <code>'dvp'</code> will include CI
bands for distance and velocity curves, and the APGV.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_conf">conf</code></td>
<td>
<p>A numeric value (default <code>0.95</code>) to be used to compute the CI
and hence the width of the <code>bands</code>. See <code><a href="#topic+growthparameters">growthparameters()</a></code>
for further details.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify response
variable when processing posterior draws for the <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_summary">summary</code></td>
<td>
<p>A logical indicating whether only the estimate should be
computed (<code>TRUE</code>, default), or estimate along with SE and CI should be
returned (<code>FALSE</code>). Setting <code>summary</code> as <code>FALSE</code> will
increase the computation time.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) to set the decimal argument for
the <code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include the
individual/group-level effects in the estimation. When <code>NA</code> (default),
the individual-level effects are excluded and therefore population average
growth parameters are computed. When <code>NULL</code>, individual-level effects
are included in the computation and hence the growth parameters estimates
returned are individual-specific. In both situations, (i.e,, <code>NA</code> or
<code>NULL</code>), continuous and factor covariate(s) are appropriately included
in the estimation. The continuous covariates by default are set to their
means (see <code>numeric_cov_at</code> for details) whereas factor covariates are
left unaltered thereby allowing estimation of covariate specific population
average and individual-specific growth parameter.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option set the
continuous covariate(s) at their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate varibale 'xx' at 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariate is
included in the model.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variables to be
passed to the <code>ipts</code> argument. This is useful when fitting location
scale models and the measurement error models.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for
hierarchical model (default <code>NULL</code>). It is used only when model is
applied to the data with 3 or more levels of hierarchy. For a two level
model, the <code>levels_id</code> is automatically inferred from the model fit.
Even for 3 or higher level model, the <code>levels_id</code> is inferred from the
model fit but under the assumption that hierarchy is specified from lowest
to upper most level i.e, <code>id</code> followed by <code>study</code> where <code>id</code>
is nested within the <code>study</code> Note that it is not guaranteed that the
<code>levels_id</code> is sorted correctly, and therefore it is better to set it
manually when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and  <code>reby</code> (typically <code>NULL</code> indicating that
parameters are integrated over the random effects) such as
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable to get a
smooth velocity curve. The <code>NULL</code> will return original values whereas
an integer such as <code>ipts = 10</code> (default) will interpolate the
predictor. It is important to note that these interpolations do not alter
the range of predictor when calculating population average and/or the
individual specific growth curves.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (i.e., age) when
executing the interpolation via <code>ipts</code>. The default <code>NULL</code> sets
the individual specific predictor range whereas code <code>xrange = 1</code> sets
identical range for individuals within the same higher grouping variable
(e.g., study). Code <code>xrange  = 2</code> sets the identical range across the
entire sample. Lastly, a paired numeric values can be supplied e.g.,
<code>xrange = c(6, 20)</code> to set the range within those values.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_xrange_search">xrange_search</code></td>
<td>
<p>A vector of length two, or a character string
<code>'range'</code> to set the range of predictor variable (<code>x</code> ) within
which growth parameters are searched. This is useful when there is more
than one peak and user wants to summarize peak within a given range of the
<code>x</code> variable. Default <code>xrange_search = NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_takeoff">takeoff</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether
or not to calculate the age at takeoff velocity (ATGV) and the takeoff
growth velocity (TGV) parameters.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_trough">trough</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether or
not to calculate the age at cessation of growth velocity (ACGV) and the
cessation of growth velocity (CGV) parameters.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_acgv">acgv</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether or not to
calculate the age at cessation of growth velocity from the velocity curve.
If <code>TRUE</code>, age at cessation of growth velocity (ACGV) and the
cessation growth velocity (CGV) are  calculated based on the percentage of
the peak growth velocity as defined by the <code>acgv_velocity</code> argument
(see below). The <code>acgv_velocity</code> is typically set at 10 percent of the
peak growth velocity. The ACGV and CGV are calculated along with the the
uncertainty (SE and CI) around the ACGV and CGV parameters.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_acgv_velocity">acgv_velocity</code></td>
<td>
<p>Specify the percentage of the peak growth velocity to be
used when estimating <code>acgv</code>. The default value is <code>0.10</code> i.e.,
10 percent of the peak growth velocity.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_seed">seed</code></td>
<td>
<p>An integer (default <code>123</code>) that is passed to the estimation
method.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_estimation_method">estimation_method</code></td>
<td>
<p>A character string to specify the estimation method
when calculating the velocity from the posterior draws. The <code>'fitted'</code>
method internally calls the <code><a href="#topic+fitted_draws">fitted_draws()</a></code> whereas the option
<code>predict</code> calls the <code><a href="#topic+predict_draws">predict_draws()</a></code>. See
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> and <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> for derails.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_robust">robust</code></td>
<td>
<p>A logical to specify the summarize options. If <code>FALSE</code>
(the default) the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If <code>TRUE</code>, the
median and the median absolute deviation (MAD) are applied instead. Ignored
if <code>summary</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_future">future</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to specify whether or not to
perform parallel computations. If set to <code>TRUE</code>, the
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code> function is used to summarize draws.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_future_session">future_session</code></td>
<td>
<p>A character string to set the session type when
<code>future = TRUE</code>. The <code>'multisession'</code> (default) options sets the
multisession whereas the <code>'multicore'</code> sets the multicore session.
Note that option <code>'multicore'</code> is not supported on Windows systems.
For more details, see <code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used when running the parallel
computations (if <code>future = TRUE</code>). On non-Windows systems this
argument can be set globally via the mc.cores option. For the default
<code>NULL</code> option, the number of cores are set automatically by calling
the <code><a href="future.html#topic+re-exports">future::availableCores()</a></code>. The number of cores used are the maximum
number of cores avaialble minus one, i.e., <code>future::availableCores() -
  1</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_trim">trim</code></td>
<td>
<p>A number (default 0) of long line segments to be excluded from
plot with option 'u' or 'a'. See <a href="sitar.html#topic+plot.sitar">sitar::plot.sitar</a> for details.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_layout">layout</code></td>
<td>
<p>A character string defining the layout structure of the plot. A
<code>'single'</code> (default) layout provides overlaid distance and velocity
curves on a single plot when opt includes <code>'dv'</code>, <code>'Dv'</code>,
<code>'dV'</code> or <code>'DV'</code> options.  Similarly, when opt includes
<code>'au'</code>, the adjusted and unadjusted curves are plotted as a single
plot. When opt is a single letter (e.g., <code>'d'</code>. <code>'v'</code> <code>'D'</code>,
<code>'V'</code>, <code>'a'</code>, <code>'u'</code>), the <code>'single'</code> optiion is ignored.
The alternative layout option, the <code>'facet'</code> uses the <code>facet_wrap</code>
from the <code>ggplot2</code>. to map and draw plot when <code>opt</code> include two or
more letters.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linecolor">linecolor</code></td>
<td>
<p>The color of line used when layout is <code>'facet'</code>. The
default is <code>NULL</code> which internally set the <code>linecolor</code> as
<code>'grey50'</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linecolor1">linecolor1</code></td>
<td>
<p>The color of first line when layout is <code>'single'</code>. For
example, for <code>opt = 'dv'</code>, the color of distance line is controlled by
the <code>linecolor1</code>. Default <code>NULL</code> will internally set
<code>linecolor1</code> as <code>'orange2'</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linecolor2">linecolor2</code></td>
<td>
<p>The color of second line when layout is <code>'single'</code>. For
example, for <code>opt = 'dv'</code>, the color of velocity line is controlled by
the <code>linecolor2</code>. Default <code>NULL</code> sets the color <code>'green4'</code>
for <code>linecolor2</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_label.x">label.x</code></td>
<td>
<p>An optional character string to label the x axis. When
<code>NULL</code> (default), the x axis label is taken from the predictor (e.g.,
age).</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_label.y">label.y</code></td>
<td>
<p>An optional character string to label the y axis. When
<code>NULL</code> (default), the y axis label is taken from the type of plot
(e.g., distance, velocity etc.). Note that when layout option is
<code>'facet'</code>, then y axis label is removed and instead the same label is
used as a title.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_legendpos">legendpos</code></td>
<td>
<p>An optional character string to specify the position of
legends. When <code>NULL</code> (default), the legend position is set as 'bottom'
for distance and velocity curves with <code>'single'</code> layout option for the
population average curves, and <code>'none'</code> for the individual specific
curves. The <code>'none'</code> suppress all legends that helps in avoiding
printing legends for each individual.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linetype.apv">linetype.apv</code></td>
<td>
<p>An optional character string to specify the type of the
vertical line drawn to mark the APGV. Default <code>NULL</code> sets the linetype
as <code>dotted</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linewidth.main">linewidth.main</code></td>
<td>
<p>An optional character string to specify the width of the
the line for the distance and velocity curves. The default <code>NULL</code> will
set it as 0.35.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linewidth.apv">linewidth.apv</code></td>
<td>
<p>An optional character string to specify the width of the
the vertical line drawn to mark the APGV. The default <code>NULL</code> will set
it as 0.25.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linetype.groupby">linetype.groupby</code></td>
<td>
<p>An optional argument to specify the line type for the
distance and velocity curves when drawing plots for a model that includes
factor covariate(s) or when visualising individual specific
distance/velocity curves (default <code>NA</code>). Setting it to <code>NULL</code> will
automatically sets the linetype for each factor level or individual This
will also add legends for the factor level covariate or individuals whereas
<code>NA</code> will set a 'solid' line type and suppress legends. It is
recommended to keep the default <code>NULL</code> option when plotting population
average curves for when model included factor covariates because this would
appropriately set the legends otherwise it is difficult to differentiate
which curve belongs to which level of factor. For individual specific
curves, the line type can be set to <code>NULL</code> when the number of
individuals is small. However, when the number of individuals is large,
<code>NA</code> is a better choice which prevents printing a large number of
legends for each individual.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_color.groupby">color.groupby</code></td>
<td>
<p>An optional argument to specify the line color for
distance and velocity curves when drawing plots for a model that includes
factor covariate(s), or when visualising individual specific
distance/velocity curves (default <code>NA</code>). Setting it to <code>NULL</code> will
automatically sets the line color for each factor level or individual. This
will also add legends for the factor level covariate or individuals.
However, setting it as <code>NA</code> will set a 'solid' line type and suppress
legends. It is recommended to keep the default <code>NULL</code> option when
plotting population average curves for factor covariates because this would
appropriately set the legends otherwise it is difficult to differentiate
which curve belongs to which level of the factor. For individual specific
curves, the line color can be set to <code>NULL</code> when the number of
individuals is small. However, when the number of individuals is large,
<code>NA</code> is a better choice which prevents printing a large number of
legends for each individual.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_band.alpha">band.alpha</code></td>
<td>
<p>An optional numeric value to specify the transparency of the
CI band(s) around the distance curve, velocity curve and the line indicating
the APGV. The default <code>NULL</code> will set this value to 0.4.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_age_takeoff">show_age_takeoff</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to indicate whether to
display the ATGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_age_peak">show_age_peak</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to indicate whether to
display the APGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_age_cessation">show_age_cessation</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to indicate whether
to display the ACGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_vel_takeoff">show_vel_takeoff</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether
to display the TGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_vel_peak">show_vel_peak</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether to
display the PGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_vel_cessation">show_vel_cessation</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether
to display the CGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_returndata">returndata</code></td>
<td>
<p>A logical (default <code>FALSE</code>) indicating whether to plot
the data or return the data. If <code>TRUE</code>, the data is returned as a
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_returndata_add_parms">returndata_add_parms</code></td>
<td>
<p>A logical (default <code>FALSE</code>) indicating
whether add growth parameters to the <code>returndata</code>. The
<code>returndata_add_parms</code> is ignored when <code>returndata = FALSE</code>. If
<code>TRUE</code>, the growth parameters such as <code>APGV</code> and <code>PGV</code> are
added to the returned <code>data.frame</code>. Note that growth parameters are
estimated only when <code>'opt'</code> argument include either <code>'v'</code> or
<code>'V'</code> option and the argument <code>'apv'</code> is set to <code>TRUE</code>. If
any of these conditions are missing, then <code>returndata_add_parms</code> will
ignored ignored.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_parms_eval">parms_eval</code></td>
<td>
<p>A logical to specify whether or not to get growth
parameters on the fly. This is for internal use only and mainly needed for
compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of of interpolation points is set up the <code>ipts</code> argument.
Options available for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>). The
<em>method 1</em> (<code>'m1'</code>) is adapted from the the <span class="pkg">iapvbs</span> package
and is documented here
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R</a>
whereas <em>method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span>
package as documented here
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R</a>.
The <code>'m1'</code> method works by internally constructing the data frame based
on the model configuration whereas the method <code>'m2'</code> uses the exact
data frame used in model fit and can be accessed via <code>fit$data</code>. If
<code>idata_method = NULL, default</code>, then method <code>'m2'</code> is
automatically set. Note that method <code>'m1'</code> might fail in some cases
when model involves covariates particularly when model is fit as
<code>univariate_by</code>. Therefore, it is advised to switch to method
<code>'m2'</code> in case <code>'m1'</code> results in error.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_parms_method">parms_method</code></td>
<td>
<p>A character to specify the method used to when evaluating
<code>parms_eval</code>. The default is <code>getPeak</code> which uses the
<code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code> function from the <code>sitar</code> package. The alternative
option is <code>findpeaks</code> that uses the <code><a href="pracma.html#topic+findpeaks">pracma::findpeaks()</a></code> function
function from the <code>pracma</code> package. This is for internal use only and
mainly needed for compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_fullframe">fullframe</code></td>
<td>
<p>A logical to indicate whether to return <code>fullframe</code>
object in which <code>newdata</code> is bind to the summary estimates. Note that
<code>fullframe</code> can not be combined with <code>summary = FALSE</code>.
Furthermore, <code>fullframe</code> can only be used when <code>idata_method =
  'm2'</code>. A particular use case is when fitting <code>univariate_by</code> model.
The <code>fullframe</code> is mainly for internal use only.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) that is used to
convert dummy variables into a factor variable. The named elements are
<code>factor.dummy</code>, <code>factor.name</code>, and <code>factor.level</code>. The
<code>factor.dummy</code> is a vector of character strings that need to be
converted to a factor variable whereas the <code>factor.name</code> is a single
character string that is used to name the newly created factor variable.
The <code>factor.level</code> is used to name the levels of newly created factor.
When <code>factor.name</code> is <code>NULL</code>, then the factor name is internally
set as <code>'factor.var'</code>. If <code>factor.level</code> is <code>NULL</code>, then
names of factor levels are take from the <code>factor.dummy</code> i.e., the
factor levels are assigned same name as <code>factor.dummy</code>. Note that when
<code>factor.level</code> is not <code>NULL</code>, its length must be same as the
length of the <code>factor.dummy</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>brms::fitted.brmsfit()</code> and
<code>brms::predict()</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>plot_curves()</strong> is a generic function that allows
visualization of following six curves: population average distance curve,
population average velocity curve, individual-specific distance curves,
individual-specific velocity curves, unadjusted individual growth curves
(i.e, observed growth curves), and the adjusted individual growth curves
(adjusted for the model estimated random effects). The
<strong>plot_curves()</strong> internally calls the <code><a href="#topic+growthparameters">growthparameters()</a></code> function to
estimate and summaries the distance and velocity curves and to estimate
growth parameters such as the age at peak growth velocity (APGV). The
<strong>plot_curves()</strong> in turn calls the <code><a href="#topic+fitted_draws">fitted_draws()</a></code> or the
<code><a href="#topic+predict_draws">predict_draws()</a></code> functions to make inference from the posterior draws.
Thus, <strong>plot_curves()</strong> allows plotting fitted or predicted curves. See
<code><a href="#topic+fitted_draws">fitted_draws()</a></code> and <code><a href="#topic+predict_draws">predict_draws()</a></code> for details on these functions and
the difference between fitted and predicted values.
</p>


<h3>Value</h3>

<p>A plot object (default), or a <code>data.frame</code> when
<code>returndata = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+growthparameters">growthparameters()</a></code> <a href="#topic+fitted_draws">fitted_draws</a> <code><a href="#topic+predict_draws">predict_draws()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average distance and velocity curves with default options
plot_curves(model, opt = 'dv')


# Individual-specific distance and velocity curves with default options
# Note that legendpos = 'none' will suppress the legend positions. This   
# suppression is useful when plotting individual-specific curves

plot_curves(model, opt = 'DV')

# Population average distance and velocity curves with APGV

plot_curves(model, opt = 'dv', apv = TRUE)

# Individual-specific distance and velocity curves with APGV

plot_curves(model, opt = 'DV', apv = TRUE)

# Population average distance curve, velocity curve, and APGV with CI bands
# To construct CI bands, growth parameters are first calculated for each  
# posterior draw and then summarized across draws. Therefore,summary 
# option must be set to FALSE

plot_curves(model, opt = 'dv', apv = TRUE, bands = 'dvp', summary = FALSE)

# Adjusted and unadjusted individual curves
# Note ipts = NULL (i.e., no interpolation of predictor (i.e., age) to plot a 
# smooth curve). This is because it does not a make sense to interploate data 
# when estimating adjusted curves. Also, layout = 'facet' (and not default 
# layout = 'single') is used for the ease of visualizing the plotted 
# adjusted and unadjusted individual curves. However, these lines can be 
# superimposed on each other by setting the set layout = 'single'.
# For other plots shown above, layout can be set as 'single' or 'facet'

# Separate plots for adjusted and unadjusted curves (layout = 'facet')
plot_curves(model, opt = 'au', ipts = NULL, layout = 'facet')

# Superimposed adjusted and unadjusted curves (layout = 'single')
plot_curves(model, opt = 'au', ipts = NULL, layout = 'single')



</code></pre>

<hr>
<h2 id='plot_ppc.bgmfit'>Perform posterior predictive distribution checks</h2><span id='topic+plot_ppc.bgmfit'></span><span id='topic+plot_ppc'></span>

<h3>Description</h3>

<p>Perform posterior predictive checks with the help
of the <span class="pkg">bayesplot</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
plot_ppc(
  model,
  type,
  ndraws = NULL,
  draw_ids = NULL,
  prefix = c("ppc", "ppd"),
  group = NULL,
  x = NULL,
  newdata = NULL,
  resp = NULL,
  size = 0.25,
  alpha = 0.7,
  trim = FALSE,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n_dens = 1024,
  pad = TRUE,
  discrete = FALSE,
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE,
  y_draw = c("violin", "points", "both"),
  y_size = 1,
  y_alpha = 1,
  y_jitter = 0.1,
  verbose = FALSE,
  deriv_model = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

plot_ppc(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ppc.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_type">type</code></td>
<td>
<p>Type of the ppc plot as given by a character string.
See <code><a href="bayesplot.html#topic+PPC-overview">PPC</a></code> for an overview
of currently supported types. You may also use an invalid
type (e.g. <code>type = "xyz"</code>) to get a list of supported
types in the resulting error message.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_prefix">prefix</code></td>
<td>
<p>The prefix of the <span class="pkg">bayesplot</span> function to be applied. 
Either '&quot;ppc&quot;' (posterior predictive check; the default)
or '&quot;ppd&quot;' (posterior predictive distribution), the latter being the same
as the former except that the observed data is not shown for '&quot;ppd&quot;'.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_group">group</code></td>
<td>
<p>Optional name of a factor variable in the model
by which to stratify the ppc plot. This argument is required for
ppc <code>*_grouped</code> types and ignored otherwise.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_x">x</code></td>
<td>
<p>Optional name of a variable in the model.
Only used for ppc types having an <code>x</code> argument
and ignored otherwise.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify response
variable when processing posterior draws for the <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_size">size</code>, <code id="plot_ppc.bgmfit_+3A_alpha">alpha</code></td>
<td>
<p>Passed to the appropriate geom to control the appearance of
the predictive distributions.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_trim">trim</code></td>
<td>
<p>A logical scalar passed to <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_bw">bw</code>, <code id="plot_ppc.bgmfit_+3A_adjust">adjust</code>, <code id="plot_ppc.bgmfit_+3A_kernel">kernel</code>, <code id="plot_ppc.bgmfit_+3A_n_dens">n_dens</code></td>
<td>
<p>Optional arguments passed to
<code><a href="stats.html#topic+density">stats::density()</a></code> to override default kernel density estimation
parameters. <code>n_dens</code> defaults to <code>1024</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_pad">pad</code></td>
<td>
<p>A logical scalar passed to <code><a href="ggplot2.html#topic+stat_ecdf">ggplot2::stat_ecdf()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_discrete">discrete</code></td>
<td>
<p>For <code>ppc_ecdf_overlay()</code>, should the data be treated as
discrete? The default is <code>FALSE</code>, in which case <code>geom="line"</code> is
passed to <code><a href="ggplot2.html#topic+stat_ecdf">ggplot2::stat_ecdf()</a></code>. If <code>discrete</code> is set to
<code>TRUE</code> then <code>geom="step"</code> is used.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_bins">bins</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_freq">freq</code></td>
<td>
<p>For histograms, <code>freq=TRUE</code> (the default) puts count on the
y-axis. Setting <code>freq=FALSE</code> puts density on the y-axis. (For many
plots the y-axis text is off by default. To view the count or density
labels on the y-axis see the <code><a href="bayesplot.html#topic+yaxis_text">yaxis_text()</a></code> convenience
function.)</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_y_draw">y_draw</code></td>
<td>
<p>For <code>ppc_violin_grouped()</code>, a string specifying how to draw
<code>y</code>: <code>"violin"</code> (default), <code>"points"</code> (jittered points), or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_y_jitter">y_jitter</code>, <code id="plot_ppc.bgmfit_+3A_y_size">y_size</code>, <code id="plot_ppc.bgmfit_+3A_y_alpha">y_alpha</code></td>
<td>
<p>For <code>ppc_violin_grouped()</code>, if <code>y_draw</code> is
<code>"points"</code> or <code>"both"</code> then <code>y_size</code>, <code>y_alpha</code>, and <code>y_jitter</code> are passed
to to the <code>size</code>, <code>alpha</code>, and <code>width</code> arguments of <code><a href="ggplot2.html#topic+geom_jitter">ggplot2::geom_jitter()</a></code>
to control the appearance of <code>y</code> points. The default of <code>y_jitter=NULL</code>
will let <strong>ggplot2</strong> determine the amount of jitter.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) that is used to
convert dummy variables into a factor variable. The named elements are
<code>factor.dummy</code>, <code>factor.name</code>, and <code>factor.level</code>. The
<code>factor.dummy</code> is a vector of character strings that need to be
converted to a factor variable whereas the <code>factor.name</code> is a single
character string that is used to name the newly created factor variable.
The <code>factor.level</code> is used to name the levels of newly created factor.
When <code>factor.name</code> is <code>NULL</code>, then the factor name is internally
set as <code>'factor.var'</code>. If <code>factor.level</code> is <code>NULL</code>, then
names of factor levels are take from the <code>factor.dummy</code> i.e., the
factor levels are assigned same name as <code>factor.dummy</code>. Note that when
<code>factor.level</code> is not <code>NULL</code>, its length must be same as the
length of the <code>factor.dummy</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+pp_check.brmsfit">brms::pp_check.brmsfit()</a></code>
function. Please see <code><a href="brms.html#topic+pp_check.brmsfit">brms::pp_check.brmsfit()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>plot_ppc()</strong> is a wrapper around the <code><a href="brms.html#topic+pp_check.brmsfit">brms::pp_check()</a></code>.
</p>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the
ggplot2 package.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

plot_ppc(model, ndraws = 100)

</code></pre>

<hr>
<h2 id='predict_draws.bgmfit'>Predicted values from the posterior predictive distribution</h2><span id='topic+predict_draws.bgmfit'></span><span id='topic+predict_draws'></span>

<h3>Description</h3>

<p>The <strong>predict_draws()</strong> is a wrapper around the
<code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> function to obtain predicted values (and their
summary) from the posterior distribution. See <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> for
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
predict_draws(
  model,
  newdata = NULL,
  resp = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty",
  incl_autocor = TRUE,
  numeric_cov_at = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  aux_variables = NULL,
  ipts = 10,
  deriv = 0,
  deriv_model = TRUE,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  xrange = NULL,
  xrange_search = NULL,
  parms_eval = FALSE,
  parms_method = "getPeak",
  idata_method = NULL,
  verbose = FALSE,
  fullframe = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

predict_draws(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_draws.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame to be used in estimation. If
<code>NULL</code> (default), the <code>newdata</code> is retrieved from the
<code>model</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify response
variable when processing posterior draws for the <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
be used in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer indicating the specific posterior draw(s)
to be used in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include the
individual/group-level effects in the estimation. When <code>NA</code> (default),
the individual-level effects are excluded and therefore population average
growth parameters are computed. When <code>NULL</code>, individual-level effects
are included in the computation and hence the growth parameters estimates
returned are individual-specific. In both situations, (i.e,, <code>NA</code> or
<code>NULL</code>), continuous and factor covariate(s) are appropriately included
in the estimation. The continuous covariates by default are set to their
means (see <code>numeric_cov_at</code> for details) whereas factor covariates are
left unaltered thereby allowing estimation of covariate specific population
average and individual-specific growth parameter.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option set the
continuous covariate(s) at their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate varibale 'xx' at 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariate is
included in the model.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for
hierarchical model (default <code>NULL</code>). It is used only when model is
applied to the data with 3 or more levels of hierarchy. For a two level
model, the <code>levels_id</code> is automatically inferred from the model fit.
Even for 3 or higher level model, the <code>levels_id</code> is inferred from the
model fit but under the assumption that hierarchy is specified from lowest
to upper most level i.e, <code>id</code> followed by <code>study</code> where <code>id</code>
is nested within the <code>study</code> Note that it is not guaranteed that the
<code>levels_id</code> is sorted correctly, and therefore it is better to set it
manually when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and  <code>reby</code> (typically <code>NULL</code> indicating that
parameters are integrated over the random effects) such as
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location scale models and measurement error models. An
indication to use <code>aux_variables</code> is when post processing functions
throw an error such as <code>variable 'x' not found either 'data' or
 'data2'</code></p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable to get a
smooth velocity curve. The <code>NULL</code> will return original values whereas
an integer such as <code>ipts = 10</code> (default) will interpolate the
predictor. It is important to note that these interpolations do not alter
the range of predictor when calculating population average and/or the
individual specific growth curves.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>An integer to indicate whether to estimate distance curve or its
derivative (i.e., velocity curve). The <code>deriv = 0</code> (default) is for
the distance curve whereas <code>deriv = 1</code> for the velocity curve.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical to specify whether to estimate velocity curve
from the derivative function, or the differentiation of the distance curve.
The argument <code>deriv_model</code> is set to <code>TRUE</code> for those functions
which need velocity curve such as <code>growthparameters()</code> and
<code>plot_curves()</code>, and <code>NULL</code> for functions which explicitly use
the distance curve (i.e., fitted values) such as <code>loo_validation()</code>
and <code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_summary">summary</code></td>
<td>
<p>A logical indicating whether only the estimate should be
computed (<code>TRUE</code>, default), or estimate along with SE and CI should be
returned (<code>FALSE</code>). Setting <code>summary</code> as <code>FALSE</code> will
increase the computation time.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_robust">robust</code></td>
<td>
<p>A logical to specify the summarize options. If <code>FALSE</code>
(the default) the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If <code>TRUE</code>, the
median and the median absolute deviation (MAD) are applied instead. Ignored
if <code>summary</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (i.e., age) when
executing the interpolation via <code>ipts</code>. The default <code>NULL</code> sets
the individual specific predictor range whereas code <code>xrange = 1</code> sets
identical range for individuals within the same higher grouping variable
(e.g., study). Code <code>xrange  = 2</code> sets the identical range across the
entire sample. Lastly, a paired numeric values can be supplied e.g.,
<code>xrange = c(6, 20)</code> to set the range within those values.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_xrange_search">xrange_search</code></td>
<td>
<p>A vector of length two, or a character string
<code>'range'</code> to set the range of predictor variable (<code>x</code> ) within
which growth parameters are searched. This is useful when there is more
than one peak and user wants to summarize peak within a given range of the
<code>x</code> variable. Default <code>xrange_search = NULL</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_parms_eval">parms_eval</code></td>
<td>
<p>A logical to specify whether or not to get growth
parameters on the fly. This is for internal use only and mainly needed for
compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_parms_method">parms_method</code></td>
<td>
<p>A character to specify the method used to when evaluating
<code>parms_eval</code>. The default is <code>getPeak</code> which uses the
<code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code> function from the <code>sitar</code> package. The alternative
option is <code>findpeaks</code> that uses the <code><a href="pracma.html#topic+findpeaks">pracma::findpeaks()</a></code> function
function from the <code>pracma</code> package. This is for internal use only and
mainly needed for compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of of interpolation points is set up the <code>ipts</code> argument.
Options available for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>). The
<em>method 1</em> (<code>'m1'</code>) is adapted from the the <span class="pkg">iapvbs</span> package
and is documented here
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R</a>
whereas <em>method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span>
package as documented here
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R</a>.
The <code>'m1'</code> method works by internally constructing the data frame based
on the model configuration whereas the method <code>'m2'</code> uses the exact
data frame used in model fit and can be accessed via <code>fit$data</code>. If
<code>idata_method = NULL, default</code>, then method <code>'m2'</code> is
automatically set. Note that method <code>'m1'</code> might fail in some cases
when model involves covariates particularly when model is fit as
<code>univariate_by</code>. Therefore, it is advised to switch to method
<code>'m2'</code> in case <code>'m1'</code> results in error.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_fullframe">fullframe</code></td>
<td>
<p>A logical to indicate whether to return <code>fullframe</code>
object in which <code>newdata</code> is bind to the summary estimates. Note that
<code>fullframe</code> can not be combined with <code>summary = FALSE</code>.
Furthermore, <code>fullframe</code> can only be used when <code>idata_method =
  'm2'</code>. A particular use case is when fitting <code>univariate_by</code> model.
The <code>fullframe</code> is mainly for internal use only.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) that is used to
convert dummy variables into a factor variable. The named elements are
<code>factor.dummy</code>, <code>factor.name</code>, and <code>factor.level</code>. The
<code>factor.dummy</code> is a vector of character strings that need to be
converted to a factor variable whereas the <code>factor.name</code> is a single
character string that is used to name the newly created factor variable.
The <code>factor.level</code> is used to name the levels of newly created factor.
When <code>factor.name</code> is <code>NULL</code>, then the factor name is internally
set as <code>'factor.var'</code>. If <code>factor.level</code> is <code>NULL</code>, then
names of factor levels are take from the <code>factor.dummy</code> i.e., the
factor levels are assigned same name as <code>factor.dummy</code>. Note that when
<code>factor.level</code> is not <code>NULL</code>, its length must be same as the
length of the <code>factor.dummy</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether to
use the already exposed and saved <code>Stan</code> functions. Depending on
whether the user have exposed Stan functions within the <code><a href="#topic+bsitar">bsitar()</a></code> call via
<code>expose_functions</code> argument in the <code><a href="#topic+bsitar">bsitar()</a></code>, the <code>usesavedfuns</code>
is automatically set to <code>TRUE</code> (if <code>expose_functions = TRUE</code>) or
<code>FALSE</code> (if <code>expose_functions = FALSE</code>). Therefore, manual
setting of <code>usesavedfuns</code> as <code>TRUE</code>/<code>FALSE</code> is rarely
needed. This is for internal purposes only and mainly used during the
testing of the functions and therefore should not be used by users as it
might lead to unreliable estimates.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical to indicate whether to clear the exposed
function from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code> (default), then <code>clearenvfuns</code> is set as <code>TRUE</code> when
<code>usesavedfuns</code> is <code>TRUE</code>, and <code>FALSE</code> if <code>usesavedfuns</code>
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>
function. Please see <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> for details on various
options available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>predict_draws()</strong> function computed the fitted values
from the posterior distribution. The <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> function
from the <span class="pkg">brms</span> package can used to get the predicted (distance) values
when outcome (e.g., height) is untransformed. However, when the outcome is
log or square root transformed, the <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> function will
return the fitted curve on the log or square root scale whereas the
<strong>predict_draws()</strong> function returns the fitted values on the original
scale. Furthermore, the <strong>predict_draws()</strong> also compute the first
derivative of (velocity) that too on the original scale after making
required back-transformation. Except for these differences, both these
functions (i.e., <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> and <code><a href="#topic+predict_draws">predict_draws()</a></code>) work in
the same manner. In other words, user can specify all the options available
in the <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>.
</p>


<h3>Value</h3>

<p>An array of predicted response values. See <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>
for details.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average distance curve
predict_draws(model, deriv = 0, re_formula = NA)


# Individual-specific distance curves
predict_draws(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
predict_draws(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
predict_draws(model, deriv = 1, re_formula = NULL)
 

</code></pre>

<hr>
<h2 id='update_model.bgmfit'>Update model</h2><span id='topic+update_model.bgmfit'></span><span id='topic+update_model'></span>

<h3>Description</h3>

<p>The <strong>update_model()</strong> is a wrapper around the
<code>update()</code> function in the <span class="pkg">brms</span> package which refits the model
as per the user specified updated arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
update_model(
  model,
  newdata = NULL,
  recompile = NULL,
  expose_function = FALSE,
  verbose = FALSE,
  check_newargs = FALSE,
  envir = NULL,
  ...
)

update_model(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_model.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional <code>data.frame</code> to be used when updating the
model. If <code>NULL</code> (default), the data used in the original model fit is
re used. Note that data-dependent default priors are not updated
automatically.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_recompile">recompile</code></td>
<td>
<p>A logical to indicate whether the Stan model should be
recompiled. When <code>NULL</code> (default), <strong>update_model()</strong> tries to
figure out internally whether recompilation is required or not. Setting
<code>recompile</code> to <code>FALSE</code> will ignore Stan code changing arguments.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional logical argument to indicate whether to
expose Stan functions (default <code>FALSE</code>). Note that if user has already
exposed Stan functions during model fit by setting <code>expose_function =
  TRUE</code> in the <code><a href="#topic+bsitar">bsitar()</a></code>, then those exposed functions are saved and can be
used during post processing of the posterior draws and therefore
<code>expose_function</code> is by default set as <code>FALSE</code> in all post
processing functions except <code><a href="#topic+optimize_model">optimize_model()</a></code>. For <code><a href="#topic+optimize_model">optimize_model()</a></code>, the
default setting is <code>expose_function = NULL</code>. The reason is that each
optimized model has different Stan function and therefore it need to be re
exposed and saved. The <code>expose_function = NULL</code> implies that the
setting for <code>expose_function</code> is taken from the original <code>model</code>
fit. Note that <code>expose_function</code> must be set to <code>TRUE</code> when
adding <code>fit criteria</code> and/or <code>bayes_R2</code> during model
optimization.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the
object(s).</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_check_newargs">check_newargs</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to check whether
arguments in the original <code>model</code> fit and the <code>update_model</code> are
same. When <code>check_newargs = TRUE</code> and arguments are same, it implies
that update is not needed and hence the original <code>model</code> object is
returned along with the message if <code>verbose = TRUE</code>.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_envir">envir</code></td>
<td>
<p>Environment used for function evaluation. The default is
<code>NULL</code> which will set <code>parent.frame()</code> as default environment.
Note that since most of post processing functions are based on <span class="pkg">brms</span>,
the functions needed for evaluation should be in the <code>.GlobalEnv</code>.
Therefore, it is strongly recommended to set <code> envir = globalenv()</code>
(or <code>envir = .GlobalEnv</code>). This is particularly true for the
derivatives such as velocity curve.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="brms.html#topic+brms">brms</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an adapted version of the <strong>update()</strong> function from
available the the<span class="pkg">brms</span> package.
</p>


<h3>Value</h3>

<p>An updated object of class <code>brmsfit</code>.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Update model
# Note that in case all arguments supplied to the update_model() call are 
# same as the original model fit (checked via check_newargs = TRUE), then  
# original model object is returned.   
# To explicitly get this information whether model is being updated or not, 
# user can set verbose = TRUE. The verbose = TRUE also useful in getting the
# information regarding what all arguments have been changed as compared to
# the original model.

model2 &lt;- update_model(model, df = 5, check_newargs = TRUE, verbose = TRUE)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
