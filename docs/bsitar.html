<!DOCTYPE html><html lang="en-US"><head><title>Help for package bsitar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bsitar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_model_criterion.bgmfit'><p>Add Model Fit Criteria to Model</p></a></li>
<li><a href='#berkeley'><p>Berkeley Child Guidance Study Data</p></a></li>
<li><a href='#berkeley_exdata'><p>Berkeley Child Guidance Study Data for Females</p></a></li>
<li><a href='#berkeley_exfit'><p>Model Fit to the Berkeley Child Guidance Study Data for Females</p></a></li>
<li><a href='#bsitar'><p>Fit Bayesian SITAR Growth Curve Model</p></a></li>
<li><a href='#expose_model_functions.bgmfit'><p>Expose User-Defined Stan Functions for Post-Processing</p></a></li>
<li><a href='#fitted_draws.bgmfit'><p>Fitted (Expected) Values from the Posterior Draws</p></a></li>
<li><a href='#getNsObject'><p>Check and Get Namespace Object If Exists</p></a></li>
<li><a href='#growthparameters_comparison.bgmfit'><p>Estimate and Compare Growth Parameters</p></a></li>
<li><a href='#growthparameters.bgmfit'><p>Estimate Growth Parameters from the Model Fit</p></a></li>
<li><a href='#loo_validation.bgmfit'><p>Perform leave-one-out (LOO) cross-validation</p></a></li>
<li><a href='#marginal_comparison.bgmfit'><p>Estimate and compare growth curves</p></a></li>
<li><a href='#marginal_draws.bgmfit'><p>Estimate growth curves</p></a></li>
<li><a href='#optimize_model.bgmfit'><p>Optimize SITAR Model</p></a></li>
<li><a href='#plot_conditional_effects.bgmfit'><p>Visualize conditional effects of predictor</p></a></li>
<li><a href='#plot_curves.bgmfit'><p>Plot Growth Curves</p></a></li>
<li><a href='#plot_ppc.bgmfit'><p>Perform posterior predictive distribution checks</p></a></li>
<li><a href='#predict_draws.bgmfit'><p>Predicted values from the posterior predictive distribution</p></a></li>
<li><a href='#update_model.bgmfit'><p>Update model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Super Imposition by Translation and Rotation Growth
Curve Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Satpal Sandhu &lt;satpal.sandhu@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Super Imposition by Translation and Rotation (SITAR) model 
    is a shape-invariant nonlinear mixed effect model that fits a natural cubic 
    spline mean curve to the growth data and aligns individual-specific growth 
    curves to the underlying mean curve via a set of random effects (see Cole, 
    2010 &lt;<a href="https://doi.org/10.1093%2Fije%2Fdyq115">doi:10.1093/ije/dyq115</a>&gt; for details). The non-Bayesian version of the 
    SITAR model can be fit by using the already available R package 'sitar'. While 
    the 'sitar' package allows modelling of a single outcome only, the 'bsitar' 
    package offers great flexibility in fitting models of varying complexities, 
    including joint modelling of multiple outcomes such as height and weight 
    (multivariate model). Additionally, the 'bsitar' package allows for the simultaneous  
    analysis of an outcome separately for subgroups defined by a factor variable such 
    as gender. This is achieved by fitting separate models for each subgroup 
    (for example males and females for gender variable). An advantage of this approach 
    is that posterior draws for each subgroup are part of a single model object, 
    making it possible to compare coefficients across subgroups and test hypotheses. 
    Since the 'bsitar' package is a front-end to the R package 'brms', it offers excellent 
    support for post-processing of posterior draws via various functions that are 
    directly available from the 'brms' package. In addition, the 'bsitar' package 
    includes various customized functions that allow for the visualization of distance 
    (increase in size with age) and velocity (change in growth rate as a function of age), 
    as well as the estimation of growth spurt parameters such as age at peak growth velocity  
    and peak growth velocity.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brms (&ge; 2.22.0), rstan (&ge; 2.32.6), loo (&ge; 2.7.0), dplyr (&ge;
1.1.3), rlang (&ge; 1.1.2), Rdpack (&ge; 2.6.2), insight (&ge;
1.0.1), data.table (&ge; 1.16.4), collapse (&ge; 2.0.19),
marginaleffects (&ge; 0.25.0), sitar, magrittr, methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2 (&ge; 3.4.0), bayesplot (&ge; 1.11.0), posterior (&ge;
1.3.1), testthat (&ge; 3.0.0), dtplyr (&ge; 1.3.1), checkmate (&ge;
2.3.1), doParallel (&ge; 1.0.17), parallel (&ge; 4.3.1), foreach
(&ge; 1.5.2), ggridges (&ge; 0.5.6), jtools (&ge; 2.2.2), fastplyr
(&ge; 0.2.0), doFuture (&ge; 1.0.1), cheapr (&ge; 0.9.8), installr
(&ge; 0.23.4), splines2 (&ge; 0.5.3), tidyr, nlme, purrr, future,
future.apply, forcats, patchwork, tibble, pracma, extraDistr,
bookdown, knitr, kableExtra, rmarkdown, spelling, Hmisc, R.rsp,
graphics, grDevices, ggtext, glue, stats, here</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Sandhu-SS/bsitar">https://github.com/Sandhu-SS/bsitar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Sandhu-SS/bsitar/issues">https://github.com/Sandhu-SS/bsitar/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>no</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-07 06:23:11 UTC; drsat</td>
</tr>
<tr>
<td>Author:</td>
<td>Satpal Sandhu <a href="https://orcid.org/0000-0002-8539-6897"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-07 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_model_criterion.bgmfit'>Add Model Fit Criteria to Model</h2><span id='topic+add_model_criterion.bgmfit'></span><span id='topic+add_model_criterion'></span>

<h3>Description</h3>

<p>The <strong>add_model_criterion()</strong> function is a wrapper around
<code><a href="brms.html#topic+add_criterion">brms::add_criterion()</a></code> that allows adding fit criteria to a model. Note
that arguments such as <code>compare</code> and <code>pointwise</code> are relevant
only for <a href="brms.html#topic+add_ic">brms::add_loo</a>, while <code>summary</code>, <code>robust</code>, and
<code>probs</code> are ignored except for the <code><a href="brms.html#topic+bayes_R2.brmsfit">brms::bayes_R2()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
add_model_criterion(
  model,
  criterion = c("loo", "waic"),
  ndraws = NULL,
  draw_ids = NULL,
  compare = TRUE,
  pointwise = FALSE,
  model_names = NULL,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  newdata = NULL,
  resp = NULL,
  cores = 1,
  deriv_model = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

add_model_criterion(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_model_criterion.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code> representing the model to which
the fit criteria will be added.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_criterion">criterion</code></td>
<td>
<p>Names of model fit criteria
to compute. Currently supported are <code>"loo"</code>,
<code>"waic"</code>, <code>"kfold"</code>, <code>"loo_subsample"</code>,
<code>"bayes_R2"</code> (Bayesian R-squared),
<code>"loo_R2"</code> (LOO-adjusted R-squared), and
<code>"marglik"</code> (log marginal likelihood).</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_compare">compare</code></td>
<td>
<p>A flag indicating if the information criteria
of the models should be compared to each other
via <code><a href="brms.html#topic+loo_compare">loo_compare</a></code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_pointwise">pointwise</code></td>
<td>
<p>A flag indicating whether to compute the full
log-likelihood matrix at once or separately for each observation.
The latter approach is usually considerably slower but
requires much less working memory. Accordingly, if one runs
into memory issues, <code>pointwise = TRUE</code> is the way to go.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_summary">summary</code></td>
<td>
<p>A logical value indicating whether only the estimate should be
computed (<code>TRUE</code>), or whether the estimate along with SE and CI should
be returned (<code>FALSE</code>, default). Setting <code>summary</code> to <code>FALSE</code>
will increase computation time. Note that <code>summary = FALSE</code> is
required to obtain correct estimates when <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_robust">robust</code></td>
<td>
<p>A logical value to specify the summary options. If <code>FALSE</code>
(default), the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If <code>TRUE</code>, the
median and median absolute deviation (MAD) are applied instead. Ignored if
<code>summary</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the response
variable when processing posterior draws for <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used for parallel computations if
<code>future = TRUE</code>. On non-Windows systems, this argument can be set
globally via the <code>mc.cores</code> option. By default, <code>NULL</code>, the
number of cores is automatically determined using
<code><a href="future.html#topic+re-exports">future::availableCores()</a></code>, and it will use the maximum number of cores
available minus one (i.e., <code>future::availableCores() - 1</code>).</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="add_model_criterion.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>brms::fitted.brmsfit()</code>
and <code>brms::predict()</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bgmfit</code> with the specified fit criteria added.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><a href="brms.html#topic+add_ic">brms::add_loo</a>, <code><a href="brms.html#topic+add_ic">brms::add_ic()</a></code>, <code><a href="brms.html#topic+add_ic">brms::add_waic()</a></code>,
<code><a href="brms.html#topic+bayes_R2.brmsfit">brms::bayes_R2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fit Bayesian SITAR model 

# To avoid model estimation which can take time, the Bayesian SITAR model fit
# to the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

model &lt;- berkeley_exfit

# Add model fit criteria (e.g., WAIC)
model &lt;- add_model_criterion(model, criterion = c("waic"))


</code></pre>

<hr>
<h2 id='berkeley'>Berkeley Child Guidance Study Data</h2><span id='topic+berkeley'></span>

<h3>Description</h3>

<p>Longitudinal growth records for 136 children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berkeley
</code></pre>


<h3>Format</h3>

<p>A data frame with 4884 observations on the following 10 variables:
</p>

<dl>
<dt>id</dt><dd><p>Factor variable with levels 201-278 for males and 301-385 for females.</p>
</dd>
<dt>age</dt><dd><p>Age in years (numeric vector).</p>
</dd>
<dt>height</dt><dd><p>Height in cm (numeric vector).</p>
</dd>
<dt>weight</dt><dd><p>Weight in kg (numeric vector).</p>
</dd>
<dt>stem.length</dt><dd><p>Stem length in cm (numeric vector).</p>
</dd>
<dt>bi.acromial</dt><dd><p>Biacromial diameter in cm (numeric vector).</p>
</dd>
<dt>bi.iliac</dt><dd><p>Bi-iliac diameter in cm (numeric vector).</p>
</dd>
<dt>leg.circ</dt><dd><p>Leg circumference in cm (numeric vector).</p>
</dd>
<dt>strength</dt><dd><p><code>Dynamometric</code> strength in pounds (numeric vector).</p>
</dd>
<dt>sex</dt><dd><p>Factor variable with level 1 for male and level 2 for female.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was originally included as an appendix in the book
<em>Physical Growth of California Boys and Girls from Birth to Eighteen Years</em>
authored by Tuddenham and Snyder (1954). The dataset was
later used as an example in the <span class="pkg">sitar</span> (Cole 2022)
package after correcting transcription errors.
</p>
<p>A more detailed description, including the frequency of measurements per
year, is provided in the <span class="pkg">sitar</span> package (Cole 2022).
Briefly, the data consists of repeated growth measurements made on 66 boys
and 70 girls (ages 0 to 21). The children were born in 1928-29 in Berkeley,
California, and were of northern European ancestry. Measurements were taken
at the following ages:
</p>

<ul>
<li><p> 0 years (at birth),
</p>
</li>
<li><p> 0.085 years,
</p>
</li>
<li><p> 0.25 to 2 years (every 3 months),
</p>
</li>
<li><p> 2 to 8 years (annually),
</p>
</li>
<li><p> 8 to 21 years (every 6 months).
</p>
</li></ul>

<p>The data includes measurements for height, weight (undressed), stem length,
biacromial diameter, bi-iliac diameter, leg circumference, and
<code>dynamometric</code> strength.
</p>


<h3>Value</h3>

<p>A data frame with 10 columns.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>References</h3>

<p>Cole T (2022).
<em>sitar: Super Imposition by Translation and Rotation Growth Curve Analysis</em>.
R package version 1.3.0, <a href="https://CRAN.R-project.org/package=sitar">https://CRAN.R-project.org/package=sitar</a>.<br /><br /> Tuddenham RD, Snyder MM (1954).
&ldquo;Physical growth of California boys and girls from birth to eighteen years.&rdquo;
<em>Publications in Child Development. University of California, Berkeley</em>, <b>1</b>(2), 183&ndash;364.
<a href="https://pubmed.ncbi.nlm.nih.gov/13217130/">https://pubmed.ncbi.nlm.nih.gov/13217130/</a>.
</p>

<hr>
<h2 id='berkeley_exdata'>Berkeley Child Guidance Study Data for Females</h2><span id='topic+berkeley_exdata'></span>

<h3>Description</h3>

<p>A subset of the <a href="#topic+berkeley">berkeley</a> data, containing
longitudinal growth data for 70 females (aged 8 to 18 years).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berkeley_exdata
</code></pre>


<h3>Format</h3>

<p>A data frame with the following 3 variables:
</p>

<dl>
<dt>id</dt><dd><p>A factor variable identifying the subject.</p>
</dd>
<dt>age</dt><dd><p>Age in years, numeric vector.</p>
</dd>
<dt>height</dt><dd><p>Height in centimeters, numeric vector.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Detailed information about the full dataset can be found in the
<a href="#topic+berkeley">berkeley</a> data.
</p>


<h3>Value</h3>

<p>A data frame with 3 columns.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>

<hr>
<h2 id='berkeley_exfit'>Model Fit to the Berkeley Child Guidance Study Data for Females</h2><span id='topic+berkeley_exfit'></span>

<h3>Description</h3>

<p>Bayesian SITAR model fit to the <a href="#topic+berkeley_exdata">berkeley_exdata</a>
dataset (70 females, aged 8 to 18 years).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berkeley_exfit
</code></pre>


<h3>Format</h3>

<p>A model fit object containing a summary of the posterior draws.
</p>


<h3>Details</h3>

<p>Detailed information about the data can be found in the
<a href="#topic+berkeley_exdata">berkeley_exdata</a> dataset.
</p>


<h3>Value</h3>

<p>An object of class <code>bgmfit</code> containing the posterior draws.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>

<hr>
<h2 id='bsitar'>Fit Bayesian SITAR Growth Curve Model</h2><span id='topic+bsitar'></span>

<h3>Description</h3>

<p>The <strong>bsitar()</strong> function fits the Bayesian version of the
Super Imposition by Translation and Rotation (<em>SITAR</em>) model. The
<em>SITAR</em> model is a nonlinear mixed-effects model that has been widely
used to summarize growth processes (such as height and weight) from early
childhood through adulthood.
</p>
<p>The frequentist version of the <em>SITAR</em> model can be fit using the
already available R package, <span class="pkg">sitar</span> (Cole 2022).
However, the <span class="pkg">bsitar</span> package offers an enhanced Bayesian
implementation that improves modeling capabilities. In addition to
univariate analysis (i.e., modeling a single outcome), <span class="pkg">bsitar</span> also
supports:
</p>

<ul>
<li><p> Univariate-by-subgroup analysis: This allows for simultaneous
modeling of a single outcome across different subgroups defined by a
factor variable (e.g., gender). The advantage is that posterior draws for
each subgroup are part of a single model object, enabling comparisons of
coefficients across groups and testing of various hypotheses.
</p>
</li>
<li><p> Multivariate analysis: This approach involves simultaneous joint
modeling of two or more outcomes, allowing for more comprehensive growth
modeling.
</p>
</li></ul>

<p>The Bayesian implementation in <span class="pkg">bsitar</span> provides a more flexible and
robust framework for growth curve modeling compared to the frequentist
approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsitar(
  x,
  y,
  id,
  data,
  df = 4,
  knots = NA,
  fixed = a + b + c,
  random = a + b + c,
  xoffset = mean,
  bstart = xoffset,
  cstart = 0,
  xfun = NULL,
  yfun = NULL,
  bound = 0.04,
  stype = nsp,
  terms_rhs = NULL,
  a_formula = ~1,
  b_formula = ~1,
  c_formula = ~1,
  d_formula = ~1,
  s_formula = ~1,
  a_formula_gr = ~1,
  b_formula_gr = ~1,
  c_formula_gr = ~1,
  d_formula_gr = ~1,
  a_formula_gr_str = NULL,
  b_formula_gr_str = NULL,
  c_formula_gr_str = NULL,
  d_formula_gr_str = NULL,
  d_adjusted = FALSE,
  sigma_formula = NULL,
  sigma_formula_gr = NULL,
  sigma_formula_gr_str = NULL,
  sigma_formula_manual = NULL,
  sigmax = NULL,
  sigmadf = 4,
  sigmaknots = NA,
  sigmafixed = a + b + c,
  sigmarandom = "",
  sigmaxoffset = mean,
  sigmabstart = sigmaxoffset,
  sigmacstart = 0,
  sigmaxfun = NULL,
  sigmabound = 0.04,
  dpar_formula = NULL,
  autocor_formula = NULL,
  family = gaussian(),
  custom_family = NULL,
  custom_stanvars = NULL,
  group_arg = list(groupvar = NULL, by = NULL, cor = un, cov = NULL, dist = gaussian),
  sigma_group_arg = list(groupvar = NULL, by = NULL, cor = un, cov = NULL, dist =
    gaussian),
  univariate_by = list(by = NA, cor = un, terms = subset),
  multivariate = list(mvar = FALSE, cor = un, rescor = TRUE),
  a_prior_beta = normal(lm, ysd, autoscale = TRUE),
  b_prior_beta = normal(0, 1.5, autoscale = FALSE),
  c_prior_beta = normal(0, 0.5, autoscale = FALSE),
  d_prior_beta = normal(0, 1, autoscale = TRUE),
  s_prior_beta = normal(lm, lm, autoscale = TRUE),
  a_cov_prior_beta = normal(0, 5, autoscale = FALSE),
  b_cov_prior_beta = normal(0, 1, autoscale = FALSE),
  c_cov_prior_beta = normal(0, 0.1, autoscale = FALSE),
  d_cov_prior_beta = normal(0, 1, autoscale = FALSE),
  s_cov_prior_beta = normal(lm, lm, autoscale = TRUE),
  a_prior_sd = normal(0, ysd, autoscale = FALSE),
  b_prior_sd = normal(0, 1, autoscale = FALSE),
  c_prior_sd = normal(0, 0.25, autoscale = FALSE),
  d_prior_sd = normal(0, 1, autoscale = TRUE),
  a_cov_prior_sd = normal(0, 5, autoscale = FALSE),
  b_cov_prior_sd = normal(0, 1, autoscale = FALSE),
  c_cov_prior_sd = normal(0, 0.1, autoscale = FALSE),
  d_cov_prior_sd = normal(0, 1, autoscale = FALSE),
  a_prior_sd_str = NULL,
  b_prior_sd_str = NULL,
  c_prior_sd_str = NULL,
  d_prior_sd_str = NULL,
  a_cov_prior_sd_str = NULL,
  b_cov_prior_sd_str = NULL,
  c_cov_prior_sd_str = NULL,
  d_cov_prior_sd_str = NULL,
  sigma_prior_beta = normal(0, 1, autoscale = FALSE),
  sigma_cov_prior_beta = normal(0, 0.5, autoscale = FALSE),
  sigma_prior_sd = normal(0, 0.25, autoscale = FALSE),
  sigma_cov_prior_sd = normal(0, 0.15, autoscale = FALSE),
  sigma_prior_sd_str = NULL,
  sigma_cov_prior_sd_str = NULL,
  rsd_prior_sigma = normal(0, ysd, autoscale = FALSE),
  dpar_prior_sigma = normal(0, ysd, autoscale = FALSE),
  dpar_cov_prior_sigma = normal(0, 1, autoscale = FALSE),
  autocor_prior_acor = uniform(-1, 1, autoscale = FALSE),
  autocor_prior_unstr_acor = lkj(1),
  gr_prior_cor = lkj(1),
  gr_prior_cor_str = lkj(1),
  sigma_prior_cor = lkj(1),
  sigma_prior_cor_str = lkj(1),
  mvr_prior_rescor = lkj(1),
  init = NULL,
  init_r = NULL,
  a_init_beta = lm,
  b_init_beta = 0,
  c_init_beta = 0,
  d_init_beta = random,
  s_init_beta = lm,
  a_cov_init_beta = random,
  b_cov_init_beta = random,
  c_cov_init_beta = random,
  d_cov_init_beta = random,
  s_cov_init_beta = random,
  a_init_sd = random,
  b_init_sd = random,
  c_init_sd = random,
  d_init_sd = random,
  a_cov_init_sd = random,
  b_cov_init_sd = random,
  c_cov_init_sd = random,
  d_cov_init_sd = random,
  sigma_init_beta = random,
  sigma_cov_init_beta = random,
  sigma_init_sd = random,
  sigma_cov_init_sd = random,
  gr_init_cor = random,
  sigma_init_cor = random,
  rsd_init_sigma = random,
  dpar_init_sigma = random,
  dpar_cov_init_sigma = random,
  autocor_init_acor = random,
  autocor_init_unstr_acor = random,
  mvr_init_rescor = random,
  r_init_z = random,
  vcov_init_0 = FALSE,
  jitter_init_beta = NULL,
  jitter_init_sd = NULL,
  jitter_init_cor = NULL,
  prior_data = NULL,
  init_data = NULL,
  init_custom = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  get_stancode = FALSE,
  get_standata = FALSE,
  get_formula = FALSE,
  get_stanvars = FALSE,
  get_priors = FALSE,
  get_priors_eval = FALSE,
  get_init_eval = FALSE,
  validate_priors = FALSE,
  set_self_priors = NULL,
  add_self_priors = NULL,
  set_replace_priors = NULL,
  set_same_priors_hierarchy = FALSE,
  outliers = NULL,
  unused = NULL,
  chains = 4,
  iter = 2000,
  warmup = floor(iter/2),
  thin = 1,
  cores = getOption("mc.cores", "optimize"),
  backend = getOption("brms.backend", "rstan"),
  threads = getOption("brms.threads", "optimize"),
  opencl = getOption("brms.opencl", NULL),
  normalize = getOption("brms.normalize", TRUE),
  algorithm = getOption("brms.algorithm", "sampling"),
  control = list(adapt_delta = 0.8, max_treedepth = 15),
  empty = FALSE,
  rename = TRUE,
  pathfinder_args = NULL,
  pathfinder_init = FALSE,
  sample_prior = "no",
  save_pars = NULL,
  drop_unused_levels = TRUE,
  stan_model_args = list(),
  refresh = NULL,
  silent = 1,
  seed = 123,
  save_model = NULL,
  fit = NA,
  file = NULL,
  file_compress = TRUE,
  file_refit = getOption("brms.file_refit", "never"),
  future = getOption("future", FALSE),
  parameterization = "ncp",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsitar_+3A_x">x</code></td>
<td>
<p>Predictor variable (typically age in years). For a <code>univariate</code>
model, <code>x</code> is a single variable. For <code>univariate_by</code> and
<code>multivariate</code> models, <code>x</code> can either be the same for all
sub-models, or different for each sub-model. For example, when fitting a
bivariate model, <code>x = list(x1, x2)</code> specifies that <code>x1</code> is the
predictor variable for the first sub-model, and <code>x2</code> is the predictor
for the second sub-model. To use <code>x1</code> as a common predictor variable
for both sub-models, you can specify <code>x = list(x1)</code> or simply <code>x =
 x1</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_y">y</code></td>
<td>
<p>Response variable (e.g., repeated height measurements). For
<code>univariate</code> and <code>univariate_by</code> models, <code>y</code> is specified as
a single variable. In the case of a <code>univariate_by</code> model, the response
vector for each sub-model is created and named internally based on the
factor levels of the variable used to define the sub-model. For example,
specifying <code>univariate_by = sex</code> creates response vectors <code>Female</code>
and <code>Male</code> when <code>Female</code> is the first level and <code>Male</code> is the
second level of the <code>sex</code> variable. In a <code>multivariate</code> model, the
response variables are provided as a list, such as <code>y = list(y1, y2)</code>,
where <code>y1</code> is the response variable for the first sub-model, and
<code>y2</code> is the response for the second sub-model. Note that for the
<code>multivariate</code> model, the data are not stacked; instead, response
vectors are separate variables in the <code>data</code> and must be of equal
length.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_id">id</code></td>
<td>
<p>A factor variable uniquely identifying the groups (e.g.,
individuals) in the data frame. For <code>univariate_by</code> and
<code>multivariate</code> models, the <code>id</code> can be the same (typically) for
all sub-models, or different for each sub-model (see the <code>x</code> argument
for details on setting different arguments for sub-models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_data">data</code></td>
<td>
<p>A data frame containing variables such as <code>x</code>, <code>y</code>,
<code>id</code>, etc.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_df">df</code></td>
<td>
<p>Degrees of freedom for the natural cubic spline design matrix
(default <code>4</code>). The <code>df</code> is used internally to construct knots
(quantiles of the <code>x</code> distribution) for the spline design matrix. For
<code>univariate_by</code> and <code>multivariate</code> models, the <code>df</code> can be
the same across sub-models (e.g., <code>df = 4</code>) or different for each
sub-model, such as <code>df = list(4, 5)</code>, where <code>df = 4</code> applies to
the first sub-model and <code>df = 5</code> applies to the second sub-model.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_knots">knots</code></td>
<td>
<p>A numeric vector specifying the knots for the natural cubic
spline design matrix (default <code>NULL</code>). Note that you cannot specify
both <code>df</code> and <code>knots</code> at the same time, nor can both be
<code>NULL</code>. In other words, either <code>df</code> or <code>knots</code> must be
specified. Like <code>df</code>, the <code>knots</code> can be the same for all
sub-models, or different for each sub-model when fitting
<code>univariate_by</code> and <code>multivariate</code> models (see <code>df</code> for
details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_fixed">fixed</code></td>
<td>
<p>A character string specifying the fixed effects structure
(default <code>'a+b+c'</code>). For <code>univariate_by</code> and <code>multivariate</code>
models, you can specify different fixed effect structures for each
sub-model. For example, <code>fixed = list('a+b+c', 'a+b')</code> implies that
the fixed effects structure for the first sub-model is <code>'a+b+c'</code>, and
for the second sub-model it is <code>'a+b'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_random">random</code></td>
<td>
<p>A character string specifying the random effects structure
(default <code>'a+b+c'</code>). The approach to setting the <code>random</code> is the
same as for the fixed effects structure (see <code>fixed</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_xoffset">xoffset</code></td>
<td>
<p>An optional character string or numeric value to set the
origin of the predictor variable, <code>x</code> (i.e., centering of <code>x</code>).
Available options include:
</p>

<ul>
<li> <p><code>'mean'</code>: The mean of <code>x</code> (i.e., <code>mean(x)</code>),
</p>
</li>
<li> <p><code>'max'</code>: The maximum value of <code>x</code> (i.e., <code>max(x)</code>),
</p>
</li>
<li> <p><code>'min'</code>: The minimum value of <code>x</code> (i.e., <code>min(x)</code>),
</p>
</li>
<li> <p><code>'apv'</code>: Age at peak velocity estimated from the velocity curve
derived from a simple linear model fit to the data,
</p>
</li>
<li><p> Any real number (e.g., <code>xoffset = 12</code>).
The default is <code>xoffset = 'mean'</code>.
</p>
</li></ul>

<p>For <code>univariate_by</code> and <code>multivariate</code> models, <code>xoffset</code> can
be the same or different for each sub-model (see <code>x</code> for details on
setting different arguments for sub-models). If <code>xoffset</code> is a numeric
value, it will be transformed internally (e.g., <code>log</code> or <code>sqrt</code>)
depending on the <code>xfun</code> argument. Similarly, when <code>xoffset</code> is
<code>'mean'</code>, <code>'min'</code>, or <code>'max'</code>, these values are calculated
after applying the <code>log</code> or <code>sqrt</code> transformation to <code>x</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_bstart">bstart</code></td>
<td>
<p>An optional character string or numeric value to set the origin
of the fixed effect parameter <code>b</code>. The <code>bstart</code> argument is used
to establish the location parameter for location-scale based priors (such
as <code>normal()</code>) via the <code>b_prior_beta</code> argument, and/or the
initial value via the <code>b_init_beta</code> argument. The available options
for <code>bstart</code> are:
</p>

<ul>
<li> <p><code>'mean'</code>: The mean of <code>x</code> (i.e., <code>mean(x)</code>),
</p>
</li>
<li> <p><code>'min'</code>: The minimum value of <code>x</code> (i.e., <code>min(x)</code>),
</p>
</li>
<li> <p><code>'max'</code>: The maximum value of <code>x</code> (i.e., <code>max(x)</code>),
</p>
</li>
<li> <p><code>'apv'</code>: Age at peak velocity estimated from the velocity curve
derived from a simple linear model fit to the data,
</p>
</li>
<li><p> Any real number (e.g., <code>bstart = 12</code>).
</p>
</li></ul>

<p>The default is <code>bstart = 'xoffset'</code> (i.e., the same value as
<code>xoffset</code>). For <code>univariate_by</code> and <code>multivariate</code> models,
<code>bstart</code> can be the same for all sub-models (typically), or different
for each sub-model (refer to <code>x</code> for details on setting different
arguments for sub-models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_cstart">cstart</code></td>
<td>
<p>An optional character string or numeric value to set the origin
of the fixed effect parameter <code>c</code>. The <code>cstart</code> argument is used
to establish the location parameter for location-scale based priors (such
as <code>normal()</code>) via the <code>c_prior_beta</code> argument, and/or the
initial value via the <code>c_init_beta</code> argument. The available options
for <code>cstart</code> are:
</p>

<ul>
<li> <p><code>'pv'</code>: Peak velocity estimated from the velocity curve derived
from the simple linear model fit to the data,
</p>
</li>
<li><p> Any real number (e.g., <code>cstart = 1</code>).
</p>
</li></ul>

<p>Note that since parameter <code>c</code> is estimated on the exponential scale, the
<code>cstart</code> should be adjusted accordingly. The default <code>cstart</code> is
<code>'0'</code> (i.e., <code>cstart = '0'</code>). For <code>univariate_by</code> and
<code>multivariate</code> models, <code>cstart</code> can be the same for all sub-models
(typically), or different for each sub-model (refer to <code>x</code> for details
on setting different arguments for sub-models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_xfun">xfun</code></td>
<td>
<p>An optional character string specifying the transformation of the
predictor variable <code>x</code>. The default value is <code>NULL</code>, indicating
that no transformation is applied and the model is fit to the data with the
original scale of <code>x</code>. The available transformation options are:
</p>

<ul>
<li> <p><code>'log'</code>: Logarithmic transformation,
</p>
</li>
<li> <p><code>'sqrt'</code>: Square root transformation.
</p>
</li></ul>

<p>For <code>univariate_by</code> and <code>multivariate</code> models, the <code>xfun</code> can
be the same for all sub-models (typically), or different for each sub-model
(refer to <code>x</code> for details on setting different arguments for
sub-models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_yfun">yfun</code></td>
<td>
<p>An optional character string specifying the transformation of the
response variable <code>y</code>. The default value is <code>NULL</code>, indicating
that no transformation is applied and the model is fit to the data with the
original scale of <code>y</code>. The available transformation options are:
</p>

<ul>
<li> <p><code>'log'</code>: Logarithmic transformation,
</p>
</li>
<li> <p><code>'sqrt'</code>: Square root transformation.
</p>
</li></ul>

<p>For <code>univariate_by</code> and <code>multivariate</code> models, the <code>yfun</code> can
be the same for all sub-models (typically), or different for each sub-model
(refer to <code>x</code> for details on setting different arguments for
sub-models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_bound">bound</code></td>
<td>
<p>An optional real number specifying the value by which the span
of the predictor variable <code>x</code> should be extended (default is
<code>0.04</code>). This extension can help in modeling edge cases. For more
details, refer to the <span class="pkg">sitar</span> package documentation. For
<code>univariate_by</code> and <code>multivariate</code> models, the <code>bound</code> can
be the same for all sub-models (typically), or different for each sub-model
(refer to <code>x</code> for details on setting different arguments for
sub-models).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_stype">stype</code></td>
<td>
<p>A character string or a named list specifying the spline type to
be used. The available options are:
</p>

<ul>
<li> <p><code>'rcs'</code>: Constructs the spline design matrix using the truncated
power basis (Harrell's method), implemented in <code><a href="Hmisc.html#topic+rcspline.eval">Hmisc::rcspline.eval()</a></code>.
</p>
</li>
<li> <p><code>'nks'</code>: Implements a B-spline based natural cubic spline method,
similar to <code><a href="splines2.html#topic+naturalSpline">splines2::nsk()</a></code>.
</p>
</li>
<li> <p><code>'nsp'</code>: Implements a B-spline based natural cubic spline method,
similar to <code><a href="splines2.html#topic+naturalSpline">splines2::nsp()</a></code>.
The default is <code>'nsp'</code>.
</p>
</li></ul>

<p>The <code>'rcs'</code> method uses a truncated power basis, whereas <code>'nks'</code>
and <code>'nsp'</code> are B-spline-based methods. Unlike <code><a href="splines2.html#topic+naturalSpline">splines2::nsp()</a></code> and
<code><a href="splines2.html#topic+naturalSpline">splines2::nsk()</a></code>, which normalize the spline basis by default, <code>'nks'</code>
and <code>'nsp'</code> return the non-normalized version of the spline. If
normalization is desired, the user can specify <code>normalize = TRUE</code> in a
list. For example, to use a normalized <code>'nsp'</code>, one can specify
<code>stype = list(type = 'nsp', normalize = TRUE)</code>.
</p>
<p>For more details, see <code><a href="Hmisc.html#topic+rcspline.eval">Hmisc::rcspline.eval()</a></code>, <code><a href="splines2.html#topic+naturalSpline">splines2::nsk()</a></code>, and
<code><a href="splines2.html#topic+naturalSpline">splines2::nsp()</a></code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_terms_rhs">terms_rhs</code></td>
<td>
<p>An optional character string (default <code>NULL</code>) specifying
terms on the right-hand side of the response variable, but before the
formula tilde sign <code>~</code>. The <code>terms_rhs</code> is used when fitting a
measurement error model.
</p>
<p>For example, when fitting a model with measurement error in the response
variable, the formula in <code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code> could be specified as
<code>brmsformula(y | mi(sdy) ~ ...)</code>. In this case, <code>mi(sdy)</code> is
passed to the formula via <code>terms_rhs = 'mi(sdy)'</code>.
</p>
<p>For a <code>multivariate</code> model, each outcome can have its own measurement
error variable. For instance, the <code>terms_rhs</code> can be specified as a
list: <code>terms_rhs = list(mi(sdy1), mi(sdy2))</code>.
</p>
<p>Note that <code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code> does not allow combining <code>mi()</code> with
the <code>subset()</code> formulation used in fitting <code>univariate_by</code> models.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_formula">a_formula</code></td>
<td>
<p>Formula for the fixed effect parameter, <code>a</code> (default
<code>~ 1</code>). Users can specify different formulas when fitting
<code>univariate_by</code> and <code>multivariate</code> models.
</p>
<p>For example, <code>a_formula = list(~1, ~1 + cov)</code> specifies that the
<code>a_formula</code> for the first sub-model includes only an intercept, while
the second sub-model includes both an intercept and a covariate <code>cov</code>.
The covariate(s) can be either continuous or factor variables. For factor
covariates, dummy variables are created internally using
<code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code>.
</p>
<p>The formula can include a combination of continuous and factor variables, as
well as their interactions.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_formula">b_formula</code></td>
<td>
<p>Formula for the fixed effect parameter, <code>b</code> (default
<code>~ 1</code>). See <code>a_formula</code> for details on how to specify the formula.
The behavior and structure of <code>b_formula</code> are similar to
<code>a_formula</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_formula">c_formula</code></td>
<td>
<p>Formula for the fixed effect parameter, <code>c</code> (default
<code>~ 1</code>). See <code>a_formula</code> for details on how to specify the formula.
The behavior and structure of <code>c_formula</code> are similar to
<code>a_formula</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_formula">d_formula</code></td>
<td>
<p>Formula for the fixed effect parameter, <code>d</code> (default
<code>~ 1</code>). See <code>a_formula</code> for details on how to specify the formula.
The behavior and structure of <code>d_formula</code> are similar to
<code>a_formula</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_s_formula">s_formula</code></td>
<td>
<p>Formula for the fixed effect parameter, <code>s</code> (default
<code>~ 1</code>). The <code>s_formula</code> sets up the spline design matrix.
Typically, covariates are not included in the <code>s_formula</code> to limit the
population curve to a single curve for the entire data. In fact, the
<span class="pkg">sitar</span> package does not provide an option to include covariates in the
<code>s_formula</code>. However, the <span class="pkg">bsitar</span> package allows the inclusion of
covariates. In such cases, the user must justify the modeling of separate
curves for each category when the covariate is a factor variable.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_formula_gr">a_formula_gr</code></td>
<td>
<p>Formula for the random effect parameter, <code>a</code>
(default <code>~ 1</code>). Similar to <code>a_formula</code>, users can specify
different formulas when fitting <code>univariate_by</code> and
<code>multivariate</code> models. The formula can include continuous and/or
factor variables, including their interactions as covariates (see
<code>a_formula</code> for details). In addition to setting up the design matrix
for the random effect parameter <code>a</code>, users can define the group
identifier and the correlation structure for random effects using the
vertical bar <code>||</code> notation. For example, to include only an intercept
for the random effects <code>a</code>, <code>b</code>, and <code>c</code>, you can specify:
</p>
<p><code>a_formula_gr = ~1</code>, <code>b_formula_gr = ~1</code>, <code>c_formula_gr = ~1</code>.
</p>
<p>To specify the group identifier (e.g., <code>id</code>) and an unstructured
correlation structure, use the vertical bar notation:
</p>
<p><code>a_formula_gr = ~ (1|i|id)</code> <br />
<code>b_formula_gr = ~ (1|i|id)</code> <br />
<code>c_formula_gr = ~ (1|i|id)</code> <br />
</p>
<p>Here, <code>i</code> within the vertical bars is a placeholder, and a common
identifier (e.g., <code>i</code>) shared across the random effect formulas will
model them as unstructured correlated random effects. For more details on
this vertical bar approach, please see <code>[brms::brm()]</code>.
</p>
<p>An alternative approach to specify the group identifier and correlation
structure is through the <code>group_by</code> argument. To achieve the same setup
as described above with the vertical bar approach, users can define the
formula part as:
</p>
<p><code>a_formula_gr = ~1</code>, <code>b_formula_gr = ~1</code>, <code>c_formula_gr = ~1</code>,
</p>
<p>and use <code>group_by</code> as <code>group_by = list(groupvar = id, cor = un)</code>,
where <code>id</code> specifies the group identifier and <code>un</code> sets the
unstructured correlation structure. See the <code>group_by</code> argument for more
details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_formula_gr">b_formula_gr</code></td>
<td>
<p>Formula for the random effect parameter, <code>b</code>
(default <code>~ 1</code>). Similar to <code>a_formula_gr</code>, user can specify
different formulas when fitting <code>univariate_by</code> and
<code>multivariate</code> models. The formula can include continuous and/or
factor variable(s), including their interactions as covariates (see
<code>a_formula_gr</code> for details). In addition to setting up the design
matrix for the random effect parameter <code>b</code>, the user can set up the
group identifier and the correlation structure for random effects via the
vertical bar <code>||</code> approach. For example, consider only an intercept
for the random effects <code>a</code>, <code>b</code>, and <code>c</code> specified as
<code>a_formula_gr = ~1</code>, <code>b_formula_gr = ~1</code> and <code>c_formula_gr =
  ~1</code>. To specify the group identifier (e.g., <code>id</code>) and an unstructured
correlation structure, the formula argument can be specified as: <br />
<code>a_formula_gr = ~ (1|i|id)</code> <br /> <code>b_formula_gr = ~ (1|i|id)</code> <br />
<code>c_formula_gr = ~ (1|i|id)</code> <br /> where <code>i</code> within the vertical
bars <code>||</code> is just a placeholder. A common identifier (i.e., <code>i</code>)
shared across random effect formulas are modeled as unstructured
correlated. For more details on the vertical bar approach, please see
<code><a href="brms.html#topic+brm">brms::brm()</a></code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_formula_gr">c_formula_gr</code></td>
<td>
<p>Formula for the random effect parameter, <code>c</code>
(default <code>~ 1</code>). See <code>b_formula_gr</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_formula_gr">d_formula_gr</code></td>
<td>
<p>Formula for the random effect parameter, <code>d</code>
(default <code>~ 1</code>). See <code>b_formula_gr</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_formula_gr_str">a_formula_gr_str</code></td>
<td>
<p>Formula for the random effect parameter, <code>a</code>
(default <code>NULL</code>), used when fitting a hierarchical model with three or
more levels of hierarchy. For example, a model applied to data that
includes repeated measurements (level 1) on individuals (level 2), which
are further nested within growth studies (level 3).
</p>
<p>For <code>a_formula_gr_str</code> argument, only the vertical bar approach (see
<code>a_formula_gr</code>) can be used to define the group identifiers and
correlation structure. An example of setting up a formula for a three-level
model with random effect parameters <code>a</code>, <code>b</code>, and <code>c</code> is as
follows: <br />
<code>a_formula_gr_str = ~ (1|i|id:study) + (1|i2|study)</code> <br />
<code>b_formula_gr_str = ~ (1|i|id:study) + (1|i2|study)</code> <br />
<code>c_formula_gr_str = ~ (1|i|id:study) + (1|i2|study)</code> <br />
</p>
<p>In this example, <code>|i|</code> and <code>|i2|</code> set up unstructured correlation
structures for the random effects at the individual and study levels,
respectively. Note that <code>|i|</code> and <code>|i2|</code> must be distinct, as
random effect parameters cannot be correlated across different levels of
hierarchy.
</p>
<p>Additionally, users can specify models with any number of hierarchical
levels and include covariates in the random effect formula.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_formula_gr_str">b_formula_gr_str</code></td>
<td>
<p>Formula for the random effect parameter, <code>b</code>
(default <code>NULL</code>), used when fitting a hierarchical model with three
or more levels of hierarchy. For details, see <code>a_formula_gr_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_formula_gr_str">c_formula_gr_str</code></td>
<td>
<p>Formula for the random effect parameter, <code>c</code>
(default <code>NULL</code>), used when fitting a hierarchical model with three
or more levels of hierarchy. For details, see <code>a_formula_gr_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_formula_gr_str">d_formula_gr_str</code></td>
<td>
<p>Formula for the random effect parameter, <code>d</code>
(default <code>NULL</code>), used when fitting a hierarchical model with three
or more levels of hierarchy. For details, see <code>a_formula_gr_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_adjusted">d_adjusted</code></td>
<td>
<p>A logical indicator to adjust the scale of the predictor
variable <code>x</code> when fitting the model with the random effect parameter
<code>d</code>. The coefficient of parameter <code>d</code> is estimated as a linear
function of <code>x</code>, i.e., <code>d * x</code>. If <code>FALSE</code> (default), the
original <code>x</code> is used. When <code>d_adjusted = TRUE</code>, <code>x</code> is
adjusted for the timing (<code>b</code>) and intensity (<code>c</code>) parameters as
<code>x</code> - <code>b</code>) * <code>exp(c)</code> i.e., <code>d * ((x-b)*exp(c))</code>. The
adjusted scale of <code>x</code> reflects individual developmental age rather than
chronological age. This makes d more sensitive to the timing of puberty in
individuals. See <code><a href="sitar.html#topic+sitar">sitar::sitar()</a></code> function for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_formula">sigma_formula</code></td>
<td>
<p>Formula for the fixed effect distributional parameter,
<code>sigma</code>. The <code>sigma_formula</code> sets up the fixed effect design
matrix, which may include continuous and/or factor variables (and their
interactions) as covariates for the distributional parameter. In other
words, setting up the covariates for <code>sigma_formula</code> follows the same
approach as for other fixed parameters, such as <code>a</code> (see
<code>a_formula</code> for details). Note that <code>sigma_formula</code> estimates the
<code>sigma</code> parameter on the <code>log</code> scale. By default,
<code>sigma_formula</code> is <code>NULL</code>, as the <code><a href="brms.html#topic+brm">brms::brm()</a></code> function itself
models <code>sigma</code> as a residual standard deviation (<code>RSD</code>) parameter
on the link scale. The <code>sigma_formula</code>, along with the arguments
<code>sigma_formula_gr</code> and <code>sigma_formula_gr_str</code>, allows
<code>sigma</code> to be estimated as a random effect. The setup for fixed and
random effects for <code>sigma</code> is similar to the approach used for other
parameters such as <code>a</code>, <code>b</code>, and <code>c</code>.
</p>
<p>It is important to note that an alternative way to set up the fixed effect
design matrix for the distributional parameter <code>sigma</code> is to use the
<code>dpar_formula</code> argument. The advantage of <code>dpar_formula</code> over
<code>sigma_formula</code> is that it allows users to specify both linear and
nonlinear formulations using the <code><a href="brms.html#topic+brmsformula-helpers">brms::lf()</a></code> and <code><a href="brms.html#topic+brmsformula-helpers">brms::nlf()</a></code> syntax.
These functions offer more flexibility, such as centering the predictors
and enabling or disabling cell mean centering by excluding the intercept
via <code>0 + </code> formulation. However, a disadvantage of the
<code>dpar_formula</code> approach is that random effects cannot be included for
<code>sigma</code>.
</p>
<p><code>sigma_formula</code> and <code>dpar_formula</code> cannot be specified together.
When either <code>sigma_formula</code> or <code>dpar_formula</code> is used, the
default estimation of <code>RSD</code> by <code><a href="brms.html#topic+brm">brms::brm()</a></code> is automatically turned
off.
</p>
<p>Users can specify an external function, such as <code>poly</code>, but only with
a single argument (the predictor), i.e., <code>poly(age)</code>. Additional
arguments must be specified externally. For example, to set the degree of
the polynomial to 3, a copy of the <code>poly</code> function can be created and
modified as follows: <br /> <code>mypoly = poly; formals(mypoly)[['degree']]
  &lt;- 3; mypoly(age)</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_formula_gr">sigma_formula_gr</code></td>
<td>
<p>Formula for the random effect parameter, <code>sigma</code>
(default <code>NULL</code>). See <code>a_formula_gr</code> for details. Similar to
<code>sigma_formula</code>, external functions such as <code>poly</code> can be used.
For further details, please refer to the description of
<code>sigma_formula</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_formula_gr_str">sigma_formula_gr_str</code></td>
<td>
<p>Formula for the random effect parameter,
<code>sigma</code>, when fitting a hierarchical model with three or more levels
of hierarchy. See <code>a_formula_gr_str</code> for details. As with
<code>sigma_formula</code>, external functions such as <code>poly</code> can be used.
For further details, please refer to the description of
<code>sigma_formula</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_formula_manual">sigma_formula_manual</code></td>
<td>
<p>Formula for the random effect parameter,
<code>sigma</code>, provided as a character string that explicitly uses the
<code><a href="brms.html#topic+brmsformula-helpers">brms::nlf()</a></code> and <code><a href="brms.html#topic+brmsformula-helpers">brms::lf()</a></code> functions (default <code>NULL</code>). An example
is: <br />
<code>nlf(sigma ~ z) + lf(z ~ 1 + age + (1 + age |55| gr(id, by = NULL)))</code>.
</p>
<p>Another use case for <code>sigma_formula_manual</code> is modeling a
location-scale model in the <code>SITAR</code> framework, where the same
<code>SITAR</code> formula can be used to model the scale (<code>sigma</code>). An
example is: <br />
</p>
<p><code>nlf(sigma ~ sigmaSITARFun(logage, sigmaa, sigmab, sigmac, sigmas1,
 sigmas2, sigmas3, sigmas4), loop = FALSE) +
 lf(sigmaa ~ 1 + (1 |110| gr(id, by = NULL))+(1 |330| gr(study, by = NULL))) +
 lf(sigmab ~ 1 + (1 |110| gr(id, by = NULL))+(1 |330| gr(study, by = NULL))) +
 lf(sigmac ~ 1 + (1 |110| gr(id, by = NULL))+(1 |330| gr(study, by = NULL))) +
 lf(sigmas1 + sigmas2 + sigmas3 + sigmas4 ~ 1)</code>.
</p>
<p>Here, <code>sigmaSITARFun</code> (and all other required sub-functions) are
defined through the <code>sigmax</code>, <code>sigmadf</code>, <code>sigmaknots</code>,
<code>sigmafixed</code>, <code>sigmarandom</code>, <code>sigmaxoffset</code>,
<code>sigmaxfun</code>, and <code>sigmabound</code> arguments. Ensure the
<code>sigma_formula_manual</code> code matches the <code>sigmaSITARFun</code> function
created by these arguments.
</p>
<p>Note that for <code>sigma_formula_manual</code>, priors must be set up manually
using the <code>add_self_priors</code> argument. To see which priors are
required, the user can run the code with <code>get_priors = TRUE</code>.
Additionally, no initial values are defined, so initial values for these
parameters should be set to either <code>0</code> or <code>random</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigmax">sigmax</code></td>
<td>
<p>Predictor for the distributional parameter <code>sigma</code>. See
<code>x</code> for details. Ignored if <code>sigma_formula_manual = NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigmadf">sigmadf</code></td>
<td>
<p>Degree of freedom for the spline function used for
<code>sigma</code>. See <code>df</code> for details. Ignored if
<code>sigma_formula_manual = NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigmaknots">sigmaknots</code></td>
<td>
<p>Knots for the spline function used for <code>sigma</code>. See
<code>knots</code> for details. Ignored if <code>sigma_formula_manual = NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigmafixed">sigmafixed</code></td>
<td>
<p>Fixed effect formula for the <code>sigma</code> structure. See
<code>fixed</code> for details. Ignored if <code>sigma_formula_manual = NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigmarandom">sigmarandom</code></td>
<td>
<p>Random effect formula for the <code>sigma</code> structure. See
<code>random</code> for details. Ignored if <code>sigma_formula_manual = NULL</code>.
Currently not used even when <code>sigma_formula_manual</code> is specified.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigmaxoffset">sigmaxoffset</code></td>
<td>
<p>Offset for the <code>x</code> in the <code>sigma</code> structure.
See <code>xoffset</code> for details. Ignored if <code>sigma_formula_manual =
  NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigmabstart">sigmabstart</code></td>
<td>
<p>Starting value for the <code>b</code> parameter in the
<code>sigma</code> structure. See <code>bstart</code> for details. Ignored if
<code>sigma_formula_manual = NULL</code>. Currently not used even when
<code>sigma_formula_manual</code> is specified.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigmacstart">sigmacstart</code></td>
<td>
<p>Starting value for the <code>c</code> parameter in the
<code>sigma</code> structure. See <code>cstart</code> for details. Ignored if
<code>sigma_formula_manual = NULL</code>. Currently not used even when
<code>sigma_formula_manual</code> is specified.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigmaxfun">sigmaxfun</code></td>
<td>
<p>Transformation function for <code>x</code> in the <code>sigma</code>
structure. See <code>xfun</code> for details. Ignored if
<code>sigma_formula_manual = NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigmabound">sigmabound</code></td>
<td>
<p>Bounds for the <code>x</code> in the <code>sigma</code> structure. See
<code>bound</code> for details. Ignored if <code>sigma_formula_manual = NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_dpar_formula">dpar_formula</code></td>
<td>
<p>Formula for the distributional fixed effect parameter,
<code>sigma</code> (default <code>NULL</code>). See <code>sigma_formula</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_autocor_formula">autocor_formula</code></td>
<td>
<p>Formula to set up the autocorrelation structure of
residuals (default <code>NULL</code>). Allowed autocorrelation structures include:
</p>

<ul>
<li><p> autoregressive moving average (<code>arma</code>) of order <code>p</code> and
<code>q</code>, specified as <code>autocor_formula = ~arma(p = 1, q = 1)</code>.
</p>
</li>
<li><p> autoregressive (<code>ar</code>) of order <code>p</code>, specified as
<code>autocor_formula = ~ar(p = 1)</code>.
</p>
</li>
<li><p> moving average (<code>ma</code>) of order <code>q</code>, specified as
<code>autocor_formula = ~ma(q = 1)</code>.
</p>
</li>
<li><p> unstructured (<code>unstr</code>) over time (and individuals), specified as
<code>autocor_formula = ~unstr(time, id)</code>.
</p>
</li></ul>

<p>See <code><a href="brms.html#topic+brm">brms::brm()</a></code> for further details on modeling the autocorrelation
structure of residuals.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_family">family</code></td>
<td>
<p>Family distribution (default <code>gaussian</code>) and the link
function (default <code>identity</code>). See <code><a href="brms.html#topic+brm">brms::brm()</a></code> for details on
available distributions and link functions, and how to specify them. For
<code>univariate_by</code> and <code>multivariate</code> models, the <code>family</code> can
be the same for all sub-models (e.g., <code>family = gaussian()</code>) or
different for each sub-model, such as <code>family = list(gaussian(),
  student())</code>, which sets <code>gaussian</code> distribution for the first
sub-model and <code>student_t</code> distribution for the second. Note that the
<code>family</code> argument is ignored if <code>custom_family</code> is specified
(i.e., if <code>custom_family</code> is not <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_custom_family">custom_family</code></td>
<td>
<p>Specifies custom families (i.e., response distribution).
Default is <code>NULL</code>. For details, see <code><a href="brms.html#topic+custom_family">brms::custom_family()</a></code>. Note that
user-defined Stan functions must be exposed by setting
<code>expose_functions = TRUE</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_custom_stanvars">custom_stanvars</code></td>
<td>
<p>Allows the preparation and passing of user-defined
variables to be added to Stan's program blocks (default <code>NULL</code>). This
is primarily useful when defining a <code>custom_family</code>. For more details
on specifying <code>stanvars</code>, see <code><a href="brms.html#topic+custom_family">brms::custom_family()</a></code>. Note that
<code>custom_stanvars</code> are passed directly without conducting any sanity
checks.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_group_arg">group_arg</code></td>
<td>
<p>Specify arguments for group-level random effects. The
<code>group_arg</code> should be a named list that may include <code>groupvar</code>,
<code>dist</code>, <code>cor</code>, and <code>by</code> as described below:
</p>

<ul>
<li> <p><code>groupvar</code> specifies the subject identifier. If <code>groupvar =
  NULL</code> (default), <code>groupvar</code> is automatically assigned based on the
<code>id</code> argument. </p>
</li>
<li> <p><code>dist</code> specifies the distribution from which
the random effects are drawn (default <code>gaussian</code>). Currently,
<code>gaussian</code> is the only available distribution (as per the
<code><a href="brms.html#topic+brm">brms::brm()</a></code> documentation).
</p>
</li>
<li> <p><code>by</code> can be used to estimate a separate variance-covariance
structure (i.e., standard deviation and correlation parameters) for random
effect parameters (default <code>NULL</code>). If specified, the variable used
for <code>by</code> must be a factor variable. For example, <code>by = 'sex'</code>
estimates separate variance-covariance structures for males and females.
</p>
</li>
<li> <p><code>cor</code> specifies the covariance (i.e., correlation) structure for
random effect parameters. The default covariance is unstructured (<code>cor
  = un</code>) for all model types (i.e., <code>univariate</code>, <code>univariate_by</code>,
and <code>multivariate</code>). The alternative correlation structure available
for <code>univariate</code> and <code>univariate_by</code> models is <code>diagonal</code>,
which estimates only the variance parameters (standard deviations), while
setting the covariance (correlation) parameters to zero. For
<em>multivariate</em> models, options include <code>un</code>, <code>diagonal</code>, and
<code>un_s</code>. The <code>un</code> structure models a full unstructured
correlation, meaning that the group-level random effects across response
variables are drawn from a joint multivariate normal distribution with
shared correlation parameters. The <code>cor = diagonal</code> option estimates
only variance parameters for each sub-model, while setting the correlation
parameters to zero. The <code>cor = un_s</code> option allows for separate
estimation of unstructured variance-covariance parameters for each response
variable.
</p>
</li></ul>

<p>Note that it is not necessary to define all or any of these options
(<code>groupvar</code>, <code>dist</code>, <code>cor</code>, or <code>by</code>), as they will
automatically be set to their default values if unspecified. Additionally,
only <code>groupvar</code> from the <code>group_arg</code> argument is passed to the
<em>univariate_by</em> and <em>multivariate</em> models, as these models have
their own additional options specified via the <code>univariate_by</code> and
<code>multivariate</code> arguments. Lastly, the <code>group_arg</code> is ignored when
random effects are specified using the vertical bar <code>||</code> approach (see
<code>a_formula_gr</code> for details) or when fitting a hierarchical model with
three or more levels of hierarchy (see <code>a_formula_gr_str</code> for
details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_group_arg">sigma_group_arg</code></td>
<td>
<p>Specify arguments for modeling distributional-level
random effects for <code>sigma</code>. The setup for <code>sigma_group_arg</code>
follows the same approach as described for group-level random effects (see
<code>group_arg</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_univariate_by">univariate_by</code></td>
<td>
<p>Set up the univariate-by-subgroup model fitting (default
<code>NULL</code>) via a named list with the following elements:
</p>

<ul>
<li> <p><code>by</code> (optional, character string): Specifies the factor variable
used to define the sub-models (default <code>NA</code>).
</p>
</li>
<li> <p><code>cor</code> (optional, character string): Defines the correlation
structure. Options include <code>un</code> (default) for a full unstructured
variance-covariance structure and <code>diagonal</code> for a structure with only
variance parameters (i.e., standard deviations) and no covariance (i.e.,
correlations set to zero).
</p>
</li>
<li> <p><code>terms</code> (optional, character string): Specifies the method for
setting up the sub-models. Options are <code>'subset'</code> (default) and
<code>'weights'</code>. See <code>brms::`addition-terms`</code> for more details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_multivariate">multivariate</code></td>
<td>
<p>Set up the multivariate model fitting (default <code>NULL</code>)
using a named list with the following elements:
</p>

<ul>
<li> <p><code>mvar</code> (logical, default <code>FALSE</code>): Indicates whether to fit
a multivariate model.
</p>
</li>
<li> <p><code>cor</code> (optional, character string): Specifies the correlation
structure. Available options are:
</p>

<ul>
<li> <p><code>un</code> (default): Models a full unstructured correlation, where
group-level random effects across response variables are drawn from a joint
multivariate normal distribution with shared correlation parameters. </p>
</li>
<li>
<p><code>diagonal</code>: Estimates only the variance parameters for each sub-model,
with the correlation parameters set to zero. </p>
</li>
<li> <p><code>un_s</code>: Estimates
unstructured variance-covariance parameters separately for each response
variable.
</p>
</li></ul>

</li>
<li> <p><code>rescor</code> (logical, default <code>TRUE</code>): Indicates whether to
estimate the residual correlation between response variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_a_prior_beta">a_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect parameter, <code>a</code>.
(default <code>normal(lm, ysd, autoscale = TRUE)</code>). The following key
points are applicable for all prior specifications. For full details, see
<code><a href="brms.html#topic+set_prior">brms::prior()</a></code>:
</p>

<ul>
<li><p> Allowed distributions: <code>normal</code>, <code>student_t</code>,
<code>cauchy</code>, <code>lognormal</code>, <code>uniform</code>, <code>exponential</code>,
<code>gamma</code>, and <code>inv_gamma</code> (inverse gamma).
</p>
</li>
<li><p> For each distribution, upper and lower bounds can be set via
<code>lb</code> and <code>ub</code> (default <code>NA</code>).
</p>
</li>
<li><p> Location-scale based distributions (such as <code>normal</code>,
<code>student_t</code>, <code>cauchy</code>, and <code>lognormal</code>) have an
<code>autoscale</code> option (default <code>FALSE</code>). This option multiplies the
scale parameter by a numeric value. While <span class="pkg">brms</span> typically uses a
scaling factor of 1.0 or 2.5, the <span class="pkg">bsitar</span> package allows any real
number to be used (e.g., <code>autoscale = 5.0</code>).
</p>
</li>
<li><p> For location-scale distributions, <code>fxl</code> (<code>function
  location</code>) and <code>fxs</code> (<code>function scale</code>) are available to apply
transformations to the location and scale parameters. For example, setting
<code>normal(2, 5, fxl = 'log', fxs = 'sqrt')</code> translates to
<code>normal(log(2), sqrt(5))</code>.
</p>
</li>
<li> <p><code>fxls</code> (<code>function location scale</code>) transforms both location
and scale parameters. The transformation applies when both parameters are
involved, as in the log-transformation for normal priors:
<code>log_location = log(location / sqrt(scale^2 / location^2 + 1))</code>,
<code>log_scale = sqrt(log(scale^2 / location^2 + 1))</code>. This can be
specified as a character string or a list of functions.
</p>
</li>
<li><p> For strictly positive distributions like <code>exponential</code>,
<code>gamma</code>, and <code>inv_gamma</code>, the lower bound (<code>lb</code>) is
automatically set to zero.
</p>
</li>
<li><p> For uniform distributions, the option <code>addrange</code> widens the
prior range symmetrically. For example, <code>uniform(a, b, addrange = 5)</code>
adjusts the range to <code>uniform(a-5, b+5)</code>.
</p>
</li>
<li><p> For exponential distributions, the rate parameter is evaluated as the
inverse of the specified value. For instance, <code>exponential(10.0)</code> is
internally treated as <code>exponential(1.0 / 10.0)</code> =
<code>exponential(0.1)</code>.
</p>
</li>
<li><p> Users do not need to specify each option explicitly, as missing
options will automatically default to their respective values. For example,
<code>a_prior_beta = normal(location = 5, scale = 1)</code> is equivalent to
<code>a_prior_beta = normal(5, 1)</code>.
</p>
</li>
<li><p> For <code>univariate_by</code> and <code>multivariate</code> models, priors can
either be the same for all submodels (e.g., <code>a_prior_beta = normal(5,
  1)</code>) or different for each submodel (e.g., <code>a_prior_beta =
  list(normal(5, 1), normal(10, 5))</code>).
</p>
</li>
<li><p> For location-scale distributions, the location parameter can be
specified as the mean (<code>ymean</code>) or median (<code>ymedian</code>) of the
response variable, and the scale parameter can be specified as the standard
deviation (<code>ysd</code>) or median absolute deviation (<code>ymad</code>).
Alternatively, coefficients from a simple linear model can be used (e.g.,
<code>lm(y ~ age)</code>).
</p>
<p>Example prior specifications include:
<code>a_prior_beta = normal(ymean, ysd)</code>,
<code>a_prior_beta = normal(ymedian, ymad)</code>,
<code>a_prior_beta = normal(lm, ysd)</code>.
</p>
<p>Note that options such as <code>ymean</code>, <code>ymedian</code>, <code>ysd</code>,
<code>ymad</code>, and <code>lm</code> are available only for the fixed effect
parameter <code>a</code>, not for other parameters like <code>b</code>, <code>c</code>, or
<code>d</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_b_prior_beta">b_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect parameter, <code>b</code>.
The default prior is <code>normal(0, 1.5, autoscale = FALSE)</code>. For full
details on prior specification, please refer to <code>a_prior_beta</code>.
</p>

<ul>
<li><p> Allowed distributions include <code>normal</code>, <code>student_t</code>,
<code>cauchy</code>, <code>lognormal</code>, <code>uniform</code>, <code>exponential</code>,
<code>gamma</code>, and <code>inv_gamma</code>. </p>
</li>
<li><p> You can set upper and lower
bounds (<code>lb</code>, <code>ub</code>) as needed (default is <code>NA</code>). </p>
</li>
<li><p> The
<code>autoscale</code> option controls scaling of the prior’s scale parameter. By
default, this is set to <code>FALSE</code>. </p>
</li>
<li><p> Further customization and
transformations can be applied, similar to the <code>a_prior_beta</code>
specification.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_c_prior_beta">c_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect parameter, <code>c</code>.
The default prior is <code>normal(0, 0.5, autoscale = FALSE)</code>. For full
details on prior specification, please refer to <code>a_prior_beta</code>.
</p>

<ul>
<li><p> Allowed distributions include <code>normal</code>, <code>student_t</code>,
<code>cauchy</code>, <code>lognormal</code>, <code>uniform</code>, <code>exponential</code>,
<code>gamma</code>, and <code>inv_gamma</code>. </p>
</li>
<li><p> Upper and lower bounds
(<code>lb</code>, <code>ub</code>) can be set as necessary (default is <code>NA</code>).
</p>
</li>
<li><p> The <code>autoscale</code> option is also available for scaling the prior's
scale parameter (default <code>FALSE</code>). </p>
</li>
<li><p> Similar to
<code>a_prior_beta</code>, further transformations or customization can be
applied.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_d_prior_beta">d_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect parameter, <code>d</code>.
The default prior is <code>normal(0, 1.0, autoscale = FALSE)</code>. For full
details on prior specification, please refer to <code>a_prior_beta</code>.
</p>

<ul>
<li><p> Allowed distributions include <code>normal</code>, <code>student_t</code>,
<code>cauchy</code>, <code>lognormal</code>, <code>uniform</code>, <code>exponential</code>,
<code>gamma</code>, and <code>inv_gamma</code>. </p>
</li>
<li><p> The option to set upper and lower
bounds (<code>lb</code>, <code>ub</code>) is available (default is <code>NA</code>). </p>
</li>
<li>
<p><code>autoscale</code> allows scaling of the prior’s scale parameter and is
<code>FALSE</code> by default. </p>
</li>
<li><p> For more advanced transformations or
customization, similar to <code>a_prior_beta</code>, these options are available.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_s_prior_beta">s_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect parameter, <code>s</code>
(i.e., spline coefficients). The default prior is <code>normal(0, 'lm',
  autoscale = TRUE)</code>. The general approach is similar to the one described
for other fixed effect parameters (see <code>a_prior_beta</code> for details).
Key points to note:
</p>

<ul>
<li><p> When using location-scale based priors with 'lm' (e.g.,
<code>s_prior_beta = normal(lm, 'lm')</code>), the location parameter is set from
the spline coefficients obtained from the simple linear model fit, and the
scale parameter is based on the standard deviation of the spline design
matrix. The location parameter is typically set to 0 (default), and
<code>autoscale</code> is set to <code>TRUE</code>. </p>
</li>
<li><p> For location-scale based
priors, the option <code>sethp</code> (logical, default <code>FALSE</code>) is
available to define hierarchical priors. Setting <code>sethp = TRUE</code> alters
the prior setup to use hierarchical priors: <code>s ~ normal(0, 'lm')</code>
becomes <code>s ~ normal(0, 'hp')</code>, where <code>'hp'</code> is defined as
<code>hp ~ normal(0, 'lm')</code>. The scale for the hierarchical prior is
automatically taken from the <code>s</code> parameter, and it can also be defined
using the same <code>sethp</code> option. For example, <code>s_prior_beta =
  normal(0, 'lm', sethp = cauchy)</code> will result in <code>s ~ normal(0, 'lm')</code>,
<code>hp ~ cauchy(0, 'lm')
  </code>.
</p>
</li>
<li><p> For <code>uniform</code> priors, you can use the option <code>addrange</code> to
symmetrically expand the prior range.
</p>
</li></ul>

<p>It is observed that location-scale based prior distributions (such as
<code>normal</code>, <code>student_t</code>, and <code>cauchy</code>) typically work well for
spline coefficients.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_cov_prior_beta">a_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
fixed effect parameter, <code>a</code> (default <code>normal(0, 5.0, autoscale =
  FALSE)</code>). The approach for specifying priors is similar to
<code>a_prior_beta</code>, with a few differences:
</p>

<ul>
<li><p> The options <code>'ymean'</code>, <code>'ymedian'</code>, <code>'ysd'</code>, and
<code>'ymad'</code> are not allowed for <code>a_cov_prior_beta</code>. </p>
</li>
<li><p> The
<code>'lm'</code> option for the location parameter allows the covariate
coefficient(s) to be obtained from a simple linear model fit to the data.
Note that the <code>'lm'</code> option is only allowed for
<code>a_cov_prior_beta</code> and not for covariates in other fixed or random
effect parameters. </p>
</li>
<li><p> Separate priors can be specified for submodels
when fitting <code>univariate_by</code> and <code>a_prior_beta</code> models (see
<code>a_prior_beta</code> for details).
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_b_cov_prior_beta">b_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
fixed effect parameter, <code>b</code> (default <code>normal(0, 1.0, autoscale =
  FALSE)</code>). See <code>a_cov_prior_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_cov_prior_beta">c_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
fixed effect parameter, <code>c</code> (default <code>normal(0, 0.1, autoscale =
  FALSE)</code>). See <code>a_cov_prior_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_cov_prior_beta">d_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
fixed effect parameter, <code>d</code> (default <code>normal(0, 1.0, autoscale =
  FALSE)</code>). See <code>a_cov_prior_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_s_cov_prior_beta">s_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
fixed effect parameter, <code>s</code> (default <code>normal(0, 10.0, autoscale =
  FALSE)</code>). As described in <code>s_formula</code>, the <em>SITAR</em> model does not
allow covariates in the spline design matrix. If covariates are specified
(see <code>s_formula</code>), the approach to setting priors for the covariates
in parameter <code>s</code> is the same as for <code>a</code> (see
<code>a_cov_prior_beta</code>). For location-scale based priors, the option
<code>'lm'</code> sets the location parameter based on spline coefficients
obtained from fitting a simple linear model to the data.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_prior_sd">a_prior_sd</code></td>
<td>
<p>Specify priors for the random effect parameter, <code>a</code>.
(default <code>normal(0, 'ysd', autoscale = FALSE)</code>). The prior is applied
to the standard deviation (the square root of the variance), not the
variance itself. The approach for setting the prior is similar to
<code>a_prior_beta</code>, with the location parameter always set to zero. The
lower bound is automatically set to <code>0</code> by <code>brms::brm()</code>. For
<code>univariate_by</code> and <code>multivariate</code> models, priors can be the same
or different for each submodel (see <code>a_prior_beta</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_prior_sd">b_prior_sd</code></td>
<td>
<p>Specify priors for the random effect parameter, <code>b</code>.
(default <code>normal(0, 1.0, autoscale = FALSE)</code>). See <code>a_prior_sd</code>
for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_prior_sd">c_prior_sd</code></td>
<td>
<p>Specify priors for the random effect parameter, <code>c</code>.
(default <code>normal(0, 0.25, autoscale = FALSE)</code>). See <code>a_prior_sd</code>
for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_prior_sd">d_prior_sd</code></td>
<td>
<p>Specify priors for the random effect parameter, <code>d</code>.
(default <code>normal(0, 1.0, autoscale = FALSE)</code>). See <code>a_prior_sd</code>
for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_cov_prior_sd">a_cov_prior_sd</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>a</code>. (default <code>normal(0, 5.0, autoscale
  = FALSE)</code>). The approach is the same as described for
<code>a_cov_prior_beta</code>, except that no pre-defined options (e.g.,
<code>'lm'</code>) are allowed.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_cov_prior_sd">b_cov_prior_sd</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>b</code>. (default <code>normal(0, 1.0, autoscale
  = FALSE)</code>). See <code>a_cov_prior_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_cov_prior_sd">c_cov_prior_sd</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>c</code>. (default <code>normal(0, 0.1, autoscale
  = FALSE)</code>). See <code>a_cov_prior_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_cov_prior_sd">d_cov_prior_sd</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>d</code>. (default <code>normal(0, 1.0, autoscale
  = FALSE)</code>). See <code>a_cov_prior_sd</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_prior_sd_str">a_prior_sd_str</code></td>
<td>
<p>Specify priors for the random effect parameter,
<code>a</code>, when fitting a hierarchical model with three or more levels of
hierarchy. (default <code>NULL</code>). The approach is the same as described for
<code>a_prior_sd</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_prior_sd_str">b_prior_sd_str</code></td>
<td>
<p>Specify priors for the random effect parameter,
<code>b</code>, when fitting a hierarchical model with three or more levels of
hierarchy. (default <code>NULL</code>). The approach is the same as described for
<code>a_prior_sd_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_prior_sd_str">c_prior_sd_str</code></td>
<td>
<p>Specify priors for the random effect parameter,
<code>c</code>, when fitting a hierarchical model with three or more levels of
hierarchy. (default <code>NULL</code>). The approach is the same as described for
<code>a_prior_sd_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_prior_sd_str">d_prior_sd_str</code></td>
<td>
<p>Specify priors for the random effect parameter,
<code>d</code>, when fitting a hierarchical model with three or more levels of
hierarchy. (default <code>NULL</code>). The approach is the same as described for
<code>a_prior_sd_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_cov_prior_sd_str">a_cov_prior_sd_str</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>a</code>, when fitting a hierarchical model with
three or more levels of hierarchy. (default <code>NULL</code>). The approach is
the same as described for <code>a_cov_prior_sd</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_cov_prior_sd_str">b_cov_prior_sd_str</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>b</code>, when fitting a hierarchical model with
three or more levels of hierarchy. (default <code>NULL</code>). The approach is
the same as described for <code>a_cov_prior_sd_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_cov_prior_sd_str">c_cov_prior_sd_str</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>c</code>, when fitting a hierarchical model with
three or more levels of hierarchy. (default <code>NULL</code>). The approach is
the same as described for <code>a_cov_prior_sd_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_cov_prior_sd_str">d_cov_prior_sd_str</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect parameter, <code>d</code>, when fitting a hierarchical model with
three or more levels of hierarchy. (default <code>NULL</code>). The approach is
the same as described for <code>a_cov_prior_sd_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_prior_beta">sigma_prior_beta</code></td>
<td>
<p>Specify priors for the fixed effect distributional
parameter, <code>sigma</code>. (default <code>normal(0, 1.0, autoscale =
  FALSE)</code>). The approach is similar to that for <code>a_prior_beta</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_cov_prior_beta">sigma_cov_prior_beta</code></td>
<td>
<p>Specify priors for the covariate(s) included in
the fixed effect distributional parameter, <code>sigma</code>. (default
<code>normal(0, 0.5, autoscale = FALSE)</code>). Follows the same approach as
<code>a_cov_prior_beta</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_prior_sd">sigma_prior_sd</code></td>
<td>
<p>Specify priors for the random effect distributional
parameter, <code>sigma</code>. (default <code>normal(0, 0.25, autoscale =
  FALSE)</code>). Same approach as <code>a_prior_sd</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_cov_prior_sd">sigma_cov_prior_sd</code></td>
<td>
<p>Specify priors for the covariate(s) included in the
random effect distributional parameter, <code>sigma</code>. (default
<code>normal(0, 0.15, autoscale = FALSE)</code>). Follows the same approach as
<code>a_cov_prior_sd</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_prior_sd_str">sigma_prior_sd_str</code></td>
<td>
<p>Specify priors for the random effect distributional
parameter, <code>sigma</code>, when fitting a hierarchical model with three or
more levels of hierarchy. (default <code>NULL</code>). Same approach as
<code>a_prior_sd_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_cov_prior_sd_str">sigma_cov_prior_sd_str</code></td>
<td>
<p>Specify priors for the covariate(s) included in
the random effect distributional parameter, <code>sigma</code>, when fitting a
hierarchical model with three or more levels of hierarchy. (default
<code>NULL</code>). Follows the same approach as <code>a_cov_prior_sd_str</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_rsd_prior_sigma">rsd_prior_sigma</code></td>
<td>
<p>Specify priors for the residual standard deviation
parameter <code>sigma</code> (default <code>normal(0, 'ysd', autoscale =
  FALSE)</code>). Evaluated when both <code>dpar_formula</code> and <code>sigma_formula</code>
are <code>NULL</code>. For location-scale based distributions, user can specify
standard deviation (<code>ysd</code>) or the median absolute deviation
(<code>ymad</code>) of outcome as the scale parameter. Also, residual standard
deviation from the linear mixed model (<code>nlme::lme()</code>) or the linear
model (<code>base::lm()</code>) fitted to the data. These are specified as
<code>'lme_rsd'</code> and <code>'lm_rsd'</code>, respectively. Note that if
<code>nlme::lme()</code> fails to converge, the option <code>'lm_rsd'</code> is set
automatically. The argument <code>rsd_prior_sigma</code> is evaluated when both
<code>dpar_formula</code> and <code>sigma_formula</code> are set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_dpar_prior_sigma">dpar_prior_sigma</code></td>
<td>
<p>Specify priors for the fixed effect distributional
parameter <code>sigma</code> (default <code>normal(0, 'ysd', autoscale =
  FALSE)</code>). Evaluated when <code>sigma_formula</code> is <code>NULL</code>. See
<code>rsd_prior_sigma</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_dpar_cov_prior_sigma">dpar_cov_prior_sigma</code></td>
<td>
<p>Specify priors for the covariate(s) included in
the fixed effect distributional parameter <code>sigma</code>. (default
<code>normal(0, 1.0, autoscale = FALSE)</code>). Evaluated when
<code>sigma_formula</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_autocor_prior_acor">autocor_prior_acor</code></td>
<td>
<p>Specify priors for the autocorrelation parameters
when fitting a model with <code>'arma'</code>, <code>'ar'</code>, or <code>'ma'</code>
autocorrelation structures (see <code>autocor_formula</code>). The only allowed
distribution is <code>uniform</code>, bounded between -1 and +1 (default
<code>uniform(-1, 1, autoscale = FALSE)</code>). For the unstructured residual
correlation structure, use <code>autocor_prior_unstr_acor</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_autocor_prior_unstr_acor">autocor_prior_unstr_acor</code></td>
<td>
<p>Specify priors for the autocorrelation
parameters when fitting a model with the unstructured (<code>'un'</code>)
autocorrelation structure (see <code>autocor_formula</code>). The only allowed
distribution is <code>lkj</code> (default <code>lkj(1)</code>). See <code>gr_prior_cor</code>
for details on setting up the <code>lkj</code> prior.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_gr_prior_cor">gr_prior_cor</code></td>
<td>
<p>Specify priors for the correlation parameter(s) of
group-level random effects (default <code>lkj(1)</code>). The only allowed
distribution is <code>lkj</code>, specified via a single parameter <code>eta</code>
(see <code>brms::prior()</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_gr_prior_cor_str">gr_prior_cor_str</code></td>
<td>
<p>Specify priors for the correlation parameter(s) of
group-level random effects when fitting a hierarchical model with three or
more levels of hierarchy (default <code>lkj(1)</code>). Same as
<code>gr_prior_cor</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_prior_cor">sigma_prior_cor</code></td>
<td>
<p>Specify priors for the correlation parameter(s) of
distributional random effects <code>sigma</code> (default <code>lkj(1)</code>). The
only allowed distribution is <code>lkj</code> (see <code>gr_prior_cor</code> for
details). Note that <code>brms::brm()</code> does not currently allow different
<code>lkj</code> priors for the group level and distributional random effects
sharing the same group identifier (<code>id</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_prior_cor_str">sigma_prior_cor_str</code></td>
<td>
<p>Specify priors for the correlation parameter(s) of
distributional random effects <code>sigma</code> when fitting a hierarchical
model with three or more levels of hierarchy (default <code>lkj(1)</code>). Same
as <code>sigma_prior_cor</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_mvr_prior_rescor">mvr_prior_rescor</code></td>
<td>
<p>Specify priors for the residual correlation parameter
when fitting a multivariate model (default <code>lkj(1)</code>). The only allowed
distribution is <code>lkj</code> (see <code>gr_prior_cor</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_init">init</code></td>
<td>
<p>Initial values for the sampler. Options include:
</p>

<ul>
<li> <p><code>'0'</code>: All parameters are initialized to zero. </p>
</li>
<li>
<p><code>'random'</code>: <strong>Stan</strong> randomly generates initial values for each
parameter within a range defined by <code>init_r</code> (see below), or between
-2 and 2 in unconstrained space if <code>init_r = NULL</code>. </p>
</li>
<li>
<p><code>'prior'</code>: Initializes parameters based on the specified prior. </p>
</li>
<li>
<p><code>NULL</code> (default): Initial values are provided by the corresponding
init arguments defined below.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_init_r">init_r</code></td>
<td>
<p>A positive real value that defines the range for the random
generation of initial values (default <code>NULL</code>). This argument is used
only when <code>init = 'random'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_init_beta">a_init_beta</code></td>
<td>
<p>Initial values for the fixed effect parameter, <code>a</code>
(default <code>'random'</code>). Available options include:
</p>

<ul>
<li> <p><code>'0'</code>: Initializes the parameter to zero. </p>
</li>
<li>
<p><code>'random'</code>: Initializes with random values within a specified range.
</p>
</li>
<li> <p><code>'prior'</code>: Uses values drawn from the prior distribution. </p>
</li>
<li>
<p><code>'ymean'</code>: Initializes with the mean of the response variable. </p>
</li>
<li>
<p><code>'ymedian'</code>: Initializes with the median of the response variable.
</p>
</li>
<li> <p><code>'lm'</code>: Initializes with the coefficients from a simple linear
model fitted to the data.
</p>
</li></ul>

<p>Note that options <code>'ymean'</code>, <code>'ymedian'</code>, and <code>'lm'</code> are only
available for the fixed effect parameter <code>a</code>. For <code>univariate_by</code>
and <code>multivariate</code> models, initial values can be the same across
submodels (e.g., <code>a_init_beta = '0'</code>) or different for each submodel
(e.g., <code>list(a_init_beta = '0', a_init_beta = 'lm')</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_init_beta">b_init_beta</code></td>
<td>
<p>Initial values for the fixed effect parameter, <code>b</code>
(default <code>'random'</code>). See <code>a_init_beta</code> for details on available
options.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_init_beta">c_init_beta</code></td>
<td>
<p>Initial values for the fixed effect parameter, <code>c</code>
(default <code>'random'</code>). See <code>a_init_beta</code> for details on available
options.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_init_beta">d_init_beta</code></td>
<td>
<p>Initial values for the fixed effect parameter, <code>d</code>
(default <code>'random'</code>). See <code>a_init_beta</code> for details on available
options.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_s_init_beta">s_init_beta</code></td>
<td>
<p>Initial values for the fixed effect parameter, <code>s</code>
(default <code>'random'</code>). Available options include:
</p>

<ul>
<li> <p><code>'0'</code>: Initializes the parameter to zero. </p>
</li>
<li>
<p><code>'random'</code>: Initializes with random values within a specified range.
</p>
</li>
<li> <p><code>'prior'</code>: Uses values drawn from the prior distribution. </p>
</li>
<li>
<p><code>'lm'</code>: Initializes with the coefficients from a simple linear model
fitted to the data.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_a_cov_init_beta">a_cov_init_beta</code></td>
<td>
<p>Initial values for the covariate(s) included in the
fixed effect parameter, <code>a</code> (default <code>'random'</code>). Available
options include:
</p>

<ul>
<li> <p><code>'0'</code>: Initializes the covariates to zero. </p>
</li>
<li>
<p><code>'random'</code>: Initializes with random values within a specified range.
</p>
</li>
<li> <p><code>'prior'</code>: Uses values drawn from the prior distribution. </p>
</li>
<li>
<p><code>'lm'</code>: Initializes with the coefficients from a simple linear model
fitted to the data.
</p>
</li></ul>

<p>Note that the <code>'lm'</code> option is only available for
<code>a_cov_init_beta</code> and not for covariates in other parameters such as
<code>b</code>, <code>c</code>, or <code>d</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_cov_init_beta">b_cov_init_beta</code></td>
<td>
<p>Initial values for the covariate(s) included in the
fixed effect parameter, <code>b</code> (default <code>'random'</code>). See
<code>a_cov_init_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_cov_init_beta">c_cov_init_beta</code></td>
<td>
<p>Initial values for the covariate(s) included in the
fixed effect parameter, <code>c</code> (default <code>'random'</code>). See
<code>a_cov_init_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_cov_init_beta">d_cov_init_beta</code></td>
<td>
<p>Initial values for the covariate(s) included in the
fixed effect parameter, <code>d</code> (default <code>'random'</code>). See
<code>a_cov_init_beta</code> for details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_s_cov_init_beta">s_cov_init_beta</code></td>
<td>
<p>Initial values for the covariate(s) included in the
fixed effect parameter, <code>s</code> (default <code>'lm'</code>). See
<code>a_cov_init_beta</code> for details. The option <code>'lm'</code> sets the spline
coefficients obtained from a simple linear model fitted to the data.
However, note that <code>s_cov_init_beta</code> serves as a placeholder and is
not evaluated, as covariates are not allowed for the <code>s</code> parameter.
For more details on covariates for <code>s</code>, refer to <code>s_formula</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_init_sd">a_init_sd</code></td>
<td>
<p>Initial value for the standard deviation of the group-level
random effect parameter, <code>a</code> (default <code>'random'</code>). Available
options are:
</p>

<ul>
<li> <p><code>'random'</code>: Initializes with random values within a specified
range.
</p>
</li>
<li> <p><code>'prior'</code>: Uses values drawn from the prior distribution.
</p>
</li>
<li> <p><code>'ysd'</code>: Sets the standard deviation (<code>sd</code>) of the
response variable as the initial value.
</p>
</li>
<li> <p><code>'ymad'</code>: Sets the median absolute deviation (<code>mad</code>) of
the response variable as the initial value.
</p>
</li>
<li> <p><code>'lme_sd_a'</code>: Sets the initial value based on the standard
deviation of the random intercept obtained from a linear mixed model
(<code>nlme::lme()</code>) fitted to the data. If <code>nlme::lme()</code> fails to
converge, the option <code>'lm_sd_a'</code> will be used automatically.
</p>
</li>
<li> <p><code>'lm_sd_a'</code>: Sets the square root of the residual variance
obtained from a simple linear model applied to the data as the initial
value.
</p>
</li></ul>

<p>Note that the options <code>'ysd'</code>, <code>'ymad'</code>, <code>'lme_sd_a'</code>, and
<code>'lm_sd_a'</code> are available only for the random effect parameter <code>a</code>
and not for other group-level random effects.
</p>
<p>Additionally, when fitting <code>univariate_by</code> and <code>multivariate</code>
models, the user can set the same initial values for all sub-models, or
different initial values for each sub-model.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_b_init_sd">b_init_sd</code></td>
<td>
<p>Initial value for the standard deviation of the group-level
random effect parameter, <code>b</code> (default <code>'random'</code>). Refer to
<code>a_init_sd</code> for available options and details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_init_sd">c_init_sd</code></td>
<td>
<p>Initial value for the standard deviation of the group-level
random effect parameter, <code>c</code> (default <code>'random'</code>). Refer to
<code>a_init_sd</code> for available options and details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_init_sd">d_init_sd</code></td>
<td>
<p>Initial value for the standard deviation of the group-level
random effect parameter, <code>d</code> (default <code>'random'</code>). Refer to
<code>a_init_sd</code> for available options and details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_a_cov_init_sd">a_cov_init_sd</code></td>
<td>
<p>Initial values for the covariate(s) included in the
random effect parameter <code>a</code> (default <code>'random'</code>). Available
options include:
</p>

<ul>
<li> <p><code>'random'</code>: Random initialization.
</p>
</li>
<li> <p><code>'prior'</code>: Uses prior distribution values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_b_cov_init_sd">b_cov_init_sd</code></td>
<td>
<p>Initial values for the covariate(s) included in the
random effect parameter <code>b</code> (default <code>'random'</code>). Refer to
<code>a_cov_init_sd</code> for available options and details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_c_cov_init_sd">c_cov_init_sd</code></td>
<td>
<p>Initial values for the covariate(s) included in the
random effect parameter <code>c</code> (default <code>'random'</code>). Refer to
<code>a_cov_init_sd</code> for available options and details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_d_cov_init_sd">d_cov_init_sd</code></td>
<td>
<p>Initial values for the covariate(s) included in the
random effect parameter <code>d</code> (default <code>'random'</code>). Refer to
<code>a_cov_init_sd</code> for available options and details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_init_beta">sigma_init_beta</code></td>
<td>
<p>Initial values for the fixed effect distributional
parameter <code>sigma</code> (default <code>'random'</code>). Available options
include:
</p>

<ul>
<li> <p><code>'random'</code>: Random initialization.
</p>
</li>
<li> <p><code>'prior'</code>: Uses prior distribution values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_cov_init_beta">sigma_cov_init_beta</code></td>
<td>
<p>Initial values for the covariate(s) included in
the fixed effect distributional parameter <code>sigma</code> (default
<code>'random'</code>). Refer to <code>sigma_init_beta</code> for available options and
details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_init_sd">sigma_init_sd</code></td>
<td>
<p>Initial value for the standard deviation of the
distributional random effect parameter <code>sigma</code> (default
<code>'random'</code>). The approach is the same as described earlier for the
group-level random effect parameters such as <code>a</code> (See <code>a_init_sd</code>
for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_cov_init_sd">sigma_cov_init_sd</code></td>
<td>
<p>Initial values for the covariate(s) included in the
distributional random effect parameter <code>sigma</code> (default
<code>'random'</code>). The approach is the same as described for
<code>a_cov_init_sd</code> (See <code>a_cov_init_sd</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_gr_init_cor">gr_init_cor</code></td>
<td>
<p>Initial values for the correlation parameters of
group-level random effects parameters (default <code>'random'</code>). Allowed
options are:
</p>

<ul>
<li> <p><code>'random'</code>: Random initialization.
</p>
</li>
<li> <p><code>'prior'</code>: Uses prior distribution values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_sigma_init_cor">sigma_init_cor</code></td>
<td>
<p>Initial values for the correlation parameters of
distributional random effects parameter <code>sigma</code> (default
<code>'random'</code>). Allowed options are:
</p>

<ul>
<li> <p><code>'random'</code>: Random initialization.
</p>
</li>
<li> <p><code>'prior'</code>: Uses prior distribution values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_rsd_init_sigma">rsd_init_sigma</code></td>
<td>
<p>Initial values for the residual standard deviation
parameter, <code>sigma</code> (default <code>'random'</code>). Options available are:
</p>

<ul>
<li> <p><code>'0'</code>: Initializes the residual standard deviation to zero.
</p>
</li>
<li> <p><code>'random'</code>: Random initialization of the residual standard
deviation.
</p>
</li>
<li> <p><code>'prior'</code>: Initializes the residual standard deviation based on
prior distribution values.
</p>
</li>
<li> <p><code>'lme_rsd'</code>: Sets the initial value based on the standard
deviation of residuals obtained from the linear mixed model
(<code>nlme::lme()</code>) fitted to the data.
</p>
</li>
<li> <p><code>'lm_rsd'</code>: Sets the initial value as the square root of the
residual variance from the simple linear model fitted to the data.
</p>
</li></ul>

<p>Note that if <code>nlme::lme()</code> fails to converge, the option
<code>'lm_rsd'</code> is set automatically. The argument <code>rsd_init_sigma</code> is
evaluated when both <code>dpar_formula</code> and <code>sigma_formula</code> are set to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_dpar_init_sigma">dpar_init_sigma</code></td>
<td>
<p>Initial values for the distributional parameter
<code>sigma</code> (default <code>'random'</code>). The approach and available options
are the same as described for <code>rsd_init_sigma</code>. This argument is
evaluated only when <code>dpar_formula</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_dpar_cov_init_sigma">dpar_cov_init_sigma</code></td>
<td>
<p>Initial values for the covariate(s) included in
the distributional parameter <code>sigma</code> (default <code>'random'</code>).
Allowed options are <code>'0'</code>, <code>'random'</code>, and <code>'prior'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_autocor_init_acor">autocor_init_acor</code></td>
<td>
<p>Initial values for the autocorrelation parameter
(see <code>autocor_formula</code> for details). Allowed options are <code>'0'</code>,
<code>'random'</code>, and <code>'prior'</code> (default <code>'random'</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_autocor_init_unstr_acor">autocor_init_unstr_acor</code></td>
<td>
<p>Initial values for unstructured residual
autocorrelation parameters (default <code>'random'</code>). Allowed options are
<code>'0'</code>, <code>'random'</code>, and <code>'prior'</code>. The approach for setting
initials for <code>autocor_init_unstr_acor</code> is the same as for
<code>gr_init_cor</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_mvr_init_rescor">mvr_init_rescor</code></td>
<td>
<p>Initial values for the residual correlation parameter
when fitting a <code>multivariate</code> model (default <code>'random'</code>). Allowed
options are <code>'0'</code>, <code>'random'</code>, and <code>'prior'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_r_init_z">r_init_z</code></td>
<td>
<p>Initial values for the standardized group-level random effect
parameters (default <code>'random'</code>). These parameters are part of the
Non-Centered Parameterization (NCP) approach used in the <code><a href="brms.html#topic+brm">brms::brm()</a></code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_vcov_init_0">vcov_init_0</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to set initial values for
variance (standard deviation) and covariance (correlation) parameters to
zero. This allows for setting custom initial values for the fixed effects
parameters while keeping the variance-covariance parameters at zero.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_jitter_init_beta">jitter_init_beta</code></td>
<td>
<p>A proportion (between 0 and 1) to perturb the initial
values for fixed effect parameters. The default is <code>NULL</code>, which means
that the same initial values are used across all chains. A sensible option
might be <code>jitter_init_beta = 0.1</code>, which mildly perturbs the initial
values. Note that the jitter is applied as a proportion of the specified
initial value, not an absolute amount. For example, if the initial value is
<code>100</code>, setting <code>jitter_init_beta = 0.1</code> means the perturbed
initial value will be within the range <code>90</code> to <code>110</code>. Conversely,
if the initial value is <code>10</code>, the perturbed value will fall within the
range <code>9</code> to <code>11</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_jitter_init_sd">jitter_init_sd</code></td>
<td>
<p>A proportion (between 0 and 1) to perturb the initial
values for the standard deviation of random effect parameters. The default
is <code>NULL</code>, which means the same initial values are used across all
chains. A reasonable option might be <code>jitter_init_sd = 0.01</code>, which
was found to work well during early testing.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_jitter_init_cor">jitter_init_cor</code></td>
<td>
<p>A proportion (between 0 and 1) to perturb the initial
values for the correlation parameters of random effects. The default is
<code>NULL</code>, which means the same initial values are used across all
chains. An option of setting <code>jitter_init_cor = 0.001</code> was found to be
effective during early testing.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_prior_data">prior_data</code></td>
<td>
<p>An optional argument (a named list, default <code>NULL</code>)
that can be used to pass information to the prior arguments for each
parameter (e.g., <code>a_prior_beta</code>). The <code>prior_data</code> is
particularly helpful when passing a long vector or matrix as priors. These
vectors and matrices can be created in the R framework and then passed
using the <code>prior_data</code>. For example, to pass a vector of location and
scale parameters when setting priors for covariate coefficients (with 10
dummy variables) included in the fixed effects parameter <code>a</code>, the
following steps can be used:
</p>

<ul>
<li><p> Create the named objects <code>prior_a_cov_location</code> and
<code>prior_a_cov_scale</code> in the R environment:
<code>prior_a_cov_location &lt;- rnorm(n = 10, mean = 0, sd = 1)</code>
<code>prior_a_cov_scale &lt;- rep(5, 10)</code>.
</p>
</li>
<li><p> Specify these objects in the <code>prior_data</code> list:
<code>prior_data = list(prior_a_cov_location = prior_a_cov_location, 
 prior_a_cov_scale = prior_a_cov_scale)</code>.
</p>
</li>
<li><p> Use the <code>prior_data</code> objects to set up the priors:
<code>a_cov_prior_beta = normal(prior_a_cov_location, prior_a_cov_scale)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bsitar_+3A_init_data">init_data</code></td>
<td>
<p>An optional argument (a named list, default <code>NULL</code>)
that can be used to pass information to the initial arguments. The approach
is identical to how <code>prior_data</code> is handled (as described above).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_init_custom">init_custom</code></td>
<td>
<p>Specify a custom initialization object (a named list). The
named list is directly passed to the <code>init</code> argument without verifying
the dimensions or name matching. If initial values are set for some
parameters via parameter-specific arguments (e.g., <code>a_init_beta = 0</code>),
<code>init_custom</code> will only be passed to those parameters that do not have
initialized values. To override this behavior and use all of
<code>init_custom</code> values regardless of parameter-specific initials, set
<code>init = 'custom'</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_verbose">verbose</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
indicate whether to print information collected during setting up the model
formula priors, and initials. As an example, the user might be interested in
knowing the response variables created for the sub model when fitting a
univariate-by-subgroup model. This information can then be used in setting
the desired order of options passed to each such model such as <code>df</code>,
<code>prior</code>, <code>initials</code> etc.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_expose_function">expose_function</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>)
to indicate whether to expose the Stan function used in model fitting.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_stancode">get_stancode</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
retrieve the Stan code (see <code>[brms::stancode()]</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_standata">get_standata</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
retrieve the Stan data (see <code>[brms::standata()]</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_formula">get_formula</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
retrieve the model formula (see <code>[brms::brmsformula()]</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_stanvars">get_stanvars</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
retrieve the Stan variables (see <code>[brms::stanvar()]</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_priors">get_priors</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
retrieve the priors (see <code>[brms::get_prior()]</code> for details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_priors_eval">get_priors_eval</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>)
to retrieve the priors specified by the user.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_get_init_eval">get_init_eval</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>) to
retrieve the initial values specified by the user.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_validate_priors">validate_priors</code></td>
<td>
<p>An optional argument (logical, default <code>FALSE</code>)
to validate the specified priors (see <code>[brms::validate_prior()]</code> for
details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_set_self_priors">set_self_priors</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to manually
specify the priors. <code>set_self_priors</code> is passed directly to
<code>[brms::brm()]</code> without performing any checks.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_add_self_priors">add_self_priors</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to append
part of the prior object. This is for internal use only.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_set_replace_priors">set_replace_priors</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to
replace part of the prior object. This is for internal use only.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_set_same_priors_hierarchy">set_same_priors_hierarchy</code></td>
<td>
<p>An optional argument (default <code>NULL</code>)
to replace part of the prior object. This is for internal use only.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_outliers">outliers</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to remove
outliers. This should be a named list passed directly to
<code>[sitar::velout()]</code> and <code>[sitar::zapvelout()]</code> functions. This is
for internal use only.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_unused">unused</code></td>
<td>
<p>An optional formula defining variables that are unused in the
model but should still be stored in the model's data frame. Useful when
variables are needed during post-processing.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_chains">chains</code></td>
<td>
<p>The number of Markov chains (default 4).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_iter">iter</code></td>
<td>
<p>The total number of iterations per chain, including warmup
(default 2000).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the number of warmup (aka
burn-in) iterations. This also specifies the number of iterations used for
stepsize adaptation, so warmup draws should not be used for inference. The
number of warmup iterations should not exceed <code>iter</code>, and the default
is <code>iter/2</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_thin">thin</code></td>
<td>
<p>A positive integer specifying the thinning interval. Set
<code>thin &gt; 1</code> to save memory and computation time if <code>iter</code> is
large. Thinning is often used in cases with high autocorrelation of MCMC
draws. An indication of high autocorrelation is poor mixing of chains
(i.e., high <code>rhat</code> values) despite the model recovering parameters
well. A useful diagnostic to check for autocorrelation of MCMC draws is the
<code>mcmc_acf</code> function from the <span class="pkg">bayesplot</span> package.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used when executing the chains in
parallel. See <code><a href="brms.html#topic+brm">brms::brm()</a></code> for details. Unlike <code><a href="brms.html#topic+brm">brms::brm()</a></code>, which
defaults the <code>cores</code> argument to <code>cores=getOption("mc.cores",
  1)</code>, the default <code>cores</code> in the <span class="pkg">bsitar</span> package is
<code>cores=getOption("mc.cores", 'optimize')</code>, which optimizes the
utilization of system resources. The maximum number of cores that can be
deployed is calculated as the maximum number of available cores minus 1.
When the number of available cores exceeds the number of chains (see
<code>chains</code>), then the number of cores is set equal to the number of
chains.
</p>
<p>Another option is to set <code>cores</code> as <code>getOption("mc.cores",
 'maximise')</code>, which sets the number of cores to the maximum number of cores
available on the system regardless of the number of chains specified.
Alternatively, the user can specify <code>cores</code> in the same way as
<code><a href="brms.html#topic+brm">brms::brm()</a></code> with <code>getOption("mc.cores", 1)</code>.
</p>
<p>These options can be set globally using <code>options(mc.cores = x)</code>, where
<code>x</code> can be <code>'optimize'</code>, <code>'maximise'</code>, or <code>1</code>. The
<code>cores</code> argument can also be directly specified as an integer (e.g.,
<code>cores = 4</code>).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_backend">backend</code></td>
<td>
<p>A character string specifying the package to be used when
executing the Stan model. The available options are <code>"rstan"</code> (the
default) or <code>"cmdstanr"</code>. The backend can also be set globally for the
current <span class="rlang"><b>R</b></span> session using the <code>"brms.backend"</code> option. See
<code><a href="brms.html#topic+brm">brms::brm()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_threads">threads</code></td>
<td>
<p>Number of threads to be used in within-chain parallelization.
Note that unlike the <code><a href="brms.html#topic+brm">brms::brm()</a></code> which sets the <code>threads</code> argument as
<code>getOption("brms.threads", NULL)</code> implying that no within-chain
parallelization is used by default, the <span class="pkg">bsitar</span> package, by default,
sets <code>threads</code> as <code>getOption("brms.threads", 'optimize')</code> to
utilize the available resources from the modern computing systems. The
number of threads per chain is set as the maximum number of cores available
minus 1. Another option is to set <code>threads</code> as
<code>getOption("brms.threads", 'maximise')</code> which set the number threads
per chains same as the  maximum number of cores available. User can also set
the <code>threads</code> similar to the <code>brms</code> i.e.,
<code>getOption("brms.threads", NULL)</code>. All these three options can be set
globally as <code>options(brms.threads = x</code>) where x can be
<code>'optimize'</code>, <code>'maximise'</code> or <code>NULL</code>.
Alternatively, the number of threads can be set directly as <code>threads
 = threading(x)</code> where <code>X</code> is an integer. Other arguments that can be
passed to the <code>threads</code> are <code>grainsize</code> and the <code>static</code>. See
<code><a href="brms.html#topic+brm">brms::brm()</a></code> for further details on within-chain parallelization.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_opencl">opencl</code></td>
<td>
<p>The platform and device IDs of the OpenCL device to use for GPU
support during model fitting. If you are unsure about the IDs of your
OpenCL device, <code>c(0,0)</code> is typically the default that should work. For
more details on how to find the correct platform and device IDs, refer to
<code><a href="brms.html#topic+opencl">brms::opencl()</a></code>. This parameter can also be set globally for the current
<span class="rlang"><b>R</b></span> session using the <code>"brms.opencl"</code> option.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_normalize">normalize</code></td>
<td>
<p>Logical flag indicating whether normalization constants
should be included in the Stan code (default is <code>TRUE</code>). If set to
<code>FALSE</code>, normalization constants are omitted, which may increase
sampling efficiency. However, this requires Stan version &gt;= 2.25. Note that
setting <code>normalize = FALSE</code> will disable some post-processing
functions, such as <code><a href="brms.html#topic+bridge_sampler.brmsfit">brms::bridge_sampler()</a></code>. This option can be controlled
globally via the <code>brms.normalize</code> option.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_algorithm">algorithm</code></td>
<td>
<p>A character string specifying the estimation method to use.
Available options are:
</p>

<ul>
<li> <p><code>"sampling"</code> (default): Markov Chain Monte Carlo (MCMC) method.
</p>
</li>
<li> <p><code>"meanfield"</code>: Variational inference with independent normal
distributions.
</p>
</li>
<li> <p><code>"fullrank"</code>: Variational inference with a multivariate normal
distribution.
</p>
</li>
<li> <p><code>"fixed_param"</code>: Sampling from fixed parameter values.
</p>
</li></ul>

<p>This parameter can be set globally via the <code>"brms.algorithm"</code> option
(see <code><a href="base.html#topic+options">options</a></code> for more details).</p>
</td></tr>
<tr><td><code id="bsitar_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> to control the sampler's behavior. The
default settings are the same as those in <code><a href="brms.html#topic+brm">brms::brm()</a></code>, with one
exception: the <code>max_treedepth</code> has been increased from 10 to 12 to
better explore the typically challenging posterior geometry in nonlinear
models. However, the <code>adapt_delta</code>, which is often increased for
nonlinear models, retains its default value of 0.8 to avoid unnecessarily
increasing sampling time. For full details on control parameters and their
default values, refer to <code><a href="brms.html#topic+brm">brms::brm()</a></code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_empty">empty</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the Stan model is not created
and compiled and the corresponding <code>'fit'</code> slot of the <code>brmsfit</code>
object will be empty. This is useful if you have estimated a brms-created
Stan model outside of <span class="pkg">brms</span> and want to feed it back into the package.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_rename">rename</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_pathfinder_args">pathfinder_args</code></td>
<td>
<p>A named <code>list</code> of arguments passed to the
<code>'pathfinder'</code> algorithm. This is used to set
<code>'pathfinder'</code>-based initial values for the <code>'MCMC'</code> sampling.
Note that <code>'pathfinder_args'</code> currently only works when <code>backend
  = "cmdstanr"</code>. If <code>pathfinder_args</code> is not <code>NULL</code> and the user
specifies <code>backend = "rstan"</code>, the backend will automatically be
changed to <code>cmdstanr</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_pathfinder_init">pathfinder_init</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) indicating
whether to use initial values from the <code>'pathfinder'</code> algorithm when
fitting the final model (i.e., <code>'MCMC'</code> sampling). Note that
<code>'pathfinder_args'</code> currently works only when <code>backend =
  "cmdstanr"</code>. If <code>pathfinder_args</code> is not <code>NULL</code> and the user
specifies <code>backend = "rstan"</code>, the backend will automatically switch
to <code>cmdstanr</code>. The arguments passed to the <code>'pathfinder'</code>
algorithm are specified via <code>'pathfinder_args'</code>; if
<code>'pathfinder_args'</code> is <code>NULL</code>, the default arguments from
<code>'cmdstanr'</code> will be used.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_sample_prior">sample_prior</code></td>
<td>
<p>A character string indicating whether to draw samples
from the priors in addition to the posterior draws. Options are <code>"no"</code>
(the default), <code>"yes"</code>, and <code>"only"</code>. These prior draws can be
used for various purposes, such as calculating Bayes factors for point
hypotheses via <code><a href="brms.html#topic+hypothesis.brmsfit">brms::hypothesis()</a></code>. Note that improper priors (including
the default improper priors used by <code>brm</code>) are not sampled. For proper
priors, see <code><a href="brms.html#topic+set_prior">brms::set_prior()</a></code>. Also, prior draws for the overall
intercept are not obtained by default for technical reasons. See
<code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code> for instructions on obtaining prior draws for the
intercept. If <code>sample_prior</code> is set to <code>"only"</code>, draws will be
taken solely from the priors, ignoring the likelihood, which allows you to
generate draws from the prior predictive distribution. In this case, all
parameters must have proper priors.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_save_pars">save_pars</code></td>
<td>
<p>An object generated by <code><a href="brms.html#topic+save_pars">brms::save_pars()</a></code> that controls
which parameters should be saved in the model. This argument does not
affect the model fitting process itself but provides control over which
parameters are retained in the final output.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_drop_unused_levels">drop_unused_levels</code></td>
<td>
<p>A logical value indicating whether unused factor
levels in the data should be dropped. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_stan_model_args">stan_model_args</code></td>
<td>
<p>A <code>list</code> of additional arguments passed to
<code><a href="rstan.html#topic+stan_model">rstan::stan_model</a></code> when using the
<code>backend = "rstan"</code> or <code>backend = "cmdstanr"</code>. This allows
customization of how models are compiled.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_refresh">refresh</code></td>
<td>
<p>An integer specifying the frequency of printing every nth
iteration. By default, <code>NULL</code> indicates that the refresh rate will be
automatically set by <code><a href="brms.html#topic+brm">brms::brm()</a></code>. Setting <code>refresh</code> is especially
useful when <code>thin</code> is greater than <code>1</code>, in which case the refresh
rate is recalculated as (<code>refresh</code> * <code>thin</code>) / <code>thin</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_silent">silent</code></td>
<td>
<p>A verbosity level between <code>0</code> and <code>2</code>. When set to
<code>1</code> (the default), most informational messages from the compiler and
sampler are suppressed. Setting it to <code>2</code> suppresses even more
messages. The sampling progress is still printed. To turn off all printing,
set <code>refresh = 0</code>. Additionally, when using <code>backend = "rstan"</code>,
you can prevent the opening of additional progress bars by setting
<code>open_progress = FALSE</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_seed">seed</code></td>
<td>
<p>An integer or <code>NA</code> (default) specifying the seed for random
number generation, ensuring reproducibility of results. If set to
<code>NA</code>, <span class="pkg">Stan</span> will randomly select the seed.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_save_model">save_model</code></td>
<td>
<p>A character string or <code>NULL</code> (default). If provided,
the Stan code for the model will be saved in a text file with the name
corresponding to the string specified in <code>save_model</code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_fit">fit</code></td>
<td>
<p>An instance of class <code>brmsfit</code> from a previous fit (default
is <code>NA</code>). If a <code>brmsfit</code> object is provided, the compiled model
associated with the fitted result is reused, and any arguments that modify
the model code or data are ignored. It is generally recommended to use the
<code><a href="brms.html#topic+update.brmsfit">update</a></code> method for this purpose, rather
than directly passing the <code>fit</code> argument.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_file">file</code></td>
<td>
<p>Either <code>NULL</code> or a character string. If a character string
is provided, the fitted model object is saved using <code><a href="base.html#topic+saveRDS">saveRDS</a></code>
in a file named after the string supplied in <code>file</code>. The <code>.rds</code>
extension is automatically added. If the specified file already exists, the
existing model object is loaded and returned instead of refitting the
model. To overwrite an existing file, you must manually remove the file or
specify the <code>file_refit</code> argument. The file name is stored within the
<code>brmsfit</code> object for later use.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_file_compress">file_compress</code></td>
<td>
<p>Logical or a character string, specifying one of the
compression algorithms supported by <code><a href="base.html#topic+saveRDS">saveRDS</a></code>. If the
<code>file</code> argument is provided, this compression will be used when saving
the fitted model object.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_file_refit">file_refit</code></td>
<td>
<p>Modifies when the fit stored via the <code>file</code> argument
is re-used. This can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.file_refit"</code> option (see <code><a href="base.html#topic+options">options</a></code>). The possible
options are:
</p>

<ul>
<li> <p><code>"never"</code> (default): The fit is always loaded if it exists, and
fitting is skipped.
</p>
</li>
<li> <p><code>"always"</code>: The model is always refitted, regardless of
existing fits.
</p>
</li>
<li> <p><code>"on_change"</code>: The model is refitted only if the model, data,
algorithm, priors, <code>sample_prior</code>, <code>stanvars</code>, covariance
structure, or similar parameters have changed.
</p>
</li></ul>

<p>If you believe a false positive occurred, you can use
<code>[brms::brmsfit_needs_refit()]</code> to investigate why a refit is deemed
necessary. A refit will not be triggered for changes in additional
parameters of the fit (e.g., initial values, number of iterations, control
arguments). A known limitation is that a refit will be triggered if
within-chain parallelization is switched on/off.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_future">future</code></td>
<td>
<p>Logical; If <code>TRUE</code>, the <span class="pkg"><a href="future.html#topic+future">future</a></span>
package is used for parallel execution of the chains. In this case, the
<code>cores</code> argument will be ignored. The execution type is controlled via
<code><a href="future.html#topic+plan">plan</a></code> (see the examples section below). This
argument can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"future"</code> option.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_parameterization">parameterization</code></td>
<td>
<p>A character string specifying the type of
parameterization to use for drawing group-level random effects. Options
are: <code>'ncp'</code> for Non-Centered Parameterization (NCP), and <code>'cp'</code>
for Centered Parameterization (CP).
</p>
<p>The NCP is generally recommended when the likelihood is weak (e.g., few
observations per individual) and is the default approach (and only option)
in <code><a href="brms.html#topic+brm">brms::brm()</a></code>.
</p>
<p>The CP parameterization is typically more efficient when a relatively large
number of observations are available across individuals. We consider a
'relatively large number' as at least 10 repeated measurements per
individual. If there are fewer than 10, NCP is used automatically. This
behavior applies only when <code>parameterization = NULL</code>. To explicitly set
CP parameterization, use <code>parameterization = 'cp'</code>.
</p>
<p>Note that since <code><a href="brms.html#topic+brm">brms::brm()</a></code> does not support CP, the <code>stancode</code>
generated by <code><a href="brms.html#topic+brm">brms::brm()</a></code> is edited internally before fitting the model
using <code><a href="rstan.html#topic+rstan">rstan::rstan()</a></code> or <code>"cmdstanr"</code>, depending on the chosen
<code>backend</code>. Therefore, CP parameterization is considered experimental
and may fail if the structure of the generated <code>stancode</code> changes in
future versions of <code><a href="brms.html#topic+brm">brms::brm()</a></code>.</p>
</td></tr>
<tr><td><code id="bsitar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+brm">brms::brm()</a></code>. This can include
additional arguments that are either passed directly to the underlying
model fitting function or used for internal purposes. Specifically, the
<code>...</code> can also be used to pass arguments used for testing and
debugging, such as: <code>match_sitar_a_form</code>, <code>match_sitar_d_form</code>,
<code>sigmamatch_sitar_a_form</code>, <code>displayit</code>, <code>setcolh</code>,
<code>setcolb</code>.
</p>
<p>These internal arguments are typically not used in regular model fitting but
can be relevant for certain testing scenarios or advanced customization.
Users are generally not expected to interact with these unless working on
debugging or testing specific features of the model fitting process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>SITAR</em> is a shape-invariant nonlinear mixed-effects growth
curve model that fits a population average (i.e., mean) curve to the data and
aligns each individual's growth trajectory to the underlying population curve
via a set of (typically) three random effects: <code>size</code>, <code>timing</code>,
and <code>intensity</code>. Additionally, a slope parameter can be included as a
random effect to estimate the variability in adult growth rate (see
<code><a href="sitar.html#topic+sitar">sitar::sitar()</a></code> for details).
</p>
<p>The concept of a shape-invariant model (SIM) was first introduced by
Lindstrom (1995), and later used by
Beath (2007) to model infant growth data (birth to
2 years). The current version of the <em>SITAR</em> model was developed by
Cole et al. (2010) and has been extensively used for
modeling growth data
(see Nembidzane et al. 2020 and Sandhu 2020).
</p>
<p>The frequentist version of the <em>SITAR</em> model can be fit using the
already available R package, <span class="pkg">sitar</span> (Cole 2022). The
framework of the Bayesian implementation of the <em>SITAR</em> model in the
<span class="pkg">bsitar</span> package is similar to the <span class="pkg">sitar</span> package, with the main
difference being that <span class="pkg">sitar</span> uses <code><a href="splines.html#topic+ns">splines::ns()</a></code> to construct the
B-splines based natural cubic spline design matrix, whereas <span class="pkg">bsitar</span>
implements a different strategy to create natural cubic splines. The
<span class="pkg">bsitar</span> offers three different types of splines: <span class="pkg">nsp</span>, <span class="pkg">nsk</span>,
and <span class="pkg">rcs</span>. Both <span class="pkg">nsp</span> and <span class="pkg">nsk</span> use the B-splines basis to
generate the natural cubic spline design matrix as implemented in
<code><a href="splines2.html#topic+naturalSpline">splines2::nsp()</a></code> and <code><a href="splines2.html#topic+naturalSpline">splines2::nsk()</a></code>, whereas <span class="pkg">rcs</span> is based on the
truncated power basis approach (see
Harrell and others (2001) and
Harrell Jr. (2022) for details) to construct the spline
design matrix. While all approaches produce the same growth curves, the
model-estimated spline coefficients differ from each other.
</p>
<p>Like the <span class="pkg">sitar</span> package (Cole et al. 2010), the <span class="pkg">bsitar</span>
package fits the <em>SITAR</em> model with (usually) three random effects: size
(parameter <code>a</code>), timing (parameter <code>b</code>), and intensity (parameter
<code>c</code>). Additionally, there is a slope parameter (parameter <code>d</code>) that
models the variability in the adult slope of the growth curve (see
<code><a href="sitar.html#topic+sitar">sitar::sitar()</a></code> for details).
</p>
<p>Note that the author of the <span class="pkg">sitar</span> package (Cole et al. 2010)
enforces the inclusion of the <code>d</code> parameter as a random effect only,
excluding it from the fixed structure of the model. However, the <span class="pkg">bsitar</span>
package allows inclusion of the <code>d</code> parameter in both the fixed and/or
random effects structures of the <em>SITAR</em> model.
</p>
<p>For the three-parameter version of the <em>SITAR</em> model (default), the
fixed effects structure (i.e., population average trajectory) is specified as
<code>fixed = 'a+b+c'</code>, and the random effects structure, capturing the
deviation of individual trajectories from the population average curve, is
specified as <code>random = 'a+b+c'</code>.
</p>
<p>The <span class="pkg">bsitar</span> package offers flexibility in model specification. For
example:
</p>

<ul>
<li><p> A fixed-effect version of the <em>SITAR</em> model can be fit by
setting <code>random = ''</code>. </p>
</li>
<li><p> The fixed-effect structure can include a
subset of parameters,
such as size and timing (<code>fixed = 'a+b'</code>) or size and intensity
(<code>fixed = 'a+c'</code>).
</p>
</li>
<li><p> For a four-parameter version of the <em>SITAR</em> model, parameter
<code>d</code> is included in the <code>fixed</code> and/or <code>random</code> arguments.
</p>
</li></ul>

<p>The <span class="pkg">sitar</span> package internally depends on the <span class="pkg">brms</span>
package (see Bürkner 2022; Bürkner 2021), which fits a wide
range of hierarchical linear and nonlinear regression models, including
multivariate models. The <span class="pkg">brms</span> package itself depends on <strong>Stan</strong> for
full Bayesian
inference (see Stan Development Team 2023; Gelman et al. 2015).
Like <span class="pkg">brms</span>, the <span class="pkg">bsitar</span> package allows flexible prior
specifications based on user's knowledge of growth processes (e.g., timing
and intensity of growth spurts).
</p>
<p>The <span class="pkg">brms</span> package uses a combination of <code>normal</code> and
<code>student_t</code> distributions for regression coefficients, group-level
random effects, and the distributional parameter (<code>sigma</code>), while
<span class="pkg">rstanarm</span> uses <code>normal</code> distributions for regression coefficients
and group-level random effects, but sets <code>exponential</code> for the
distributional parameter (<code>sigma</code>). By default, <span class="pkg">bsitar</span> uses
<code>normal</code> distributions for all parameters, including regression
coefficients, standard deviations of group-level random effects, and the
distributional parameter. Additionally, <span class="pkg">bsitar</span> provides flexibility in
choosing scale parameters for location-scale distributions (such as
<code>normal</code> and <code>student_t</code>).
</p>
<p>The <span class="pkg">bsitar</span> package also allows three types of model specifications:
<code>'univariate'</code>, <code>'univariate_by'</code>, and <code>'multivariate'</code>:
</p>

<ul>
<li> <p><code>'univariate'</code> fits a single model to an outcome variable.
</p>
</li>
<li> <p><code>'univariate_by'</code> fits two or more sub-models to an outcome
defined by a factor variable (e.g., sex).
</p>
</li>
<li> <p><code>'multivariate'</code> fits a joint model to multiple outcomes with
shared random effects.
</p>
</li></ul>

<p>The <span class="pkg">bsitar</span> package offers full flexibility in specifying predictors,
degrees of freedom for design matrices, priors, and initial values. The
package also allows users to specify options in a user-friendly manner (e.g.,
<code>univariate_by = sex</code> is equivalent to <code>univariate_by = 'sex'</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>brmsfit, bsitar</code>, which contains the
posterior draws, model coefficients, and other useful information related
to the model fitting. This object includes details such as the fitted
model, the data used, prior distributions, and any other relevant outputs
from the Stan model fitting process. The resulting object can be used for
further analysis, diagnostics, and post-processing, including model summary
statistics, predictions, and visualizations.
</p>


<h3>Note</h3>

<p>The package is under continuous development, and new models,
post-processing features, and improvements are being actively worked on.
Keep an eye on future releases for additional functionality and updates to
enhance model fitting, diagnostics, and analysis capabilities.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>References</h3>

<p>Beath KJ (2007).
&ldquo;Infant growth modelling using a shape invariant model with random effects.&rdquo;
<em>Statistics in Medicine</em>, <b>26</b>(12), 2547&ndash;2564.
<a href="https://doi.org/10.1002/sim.2718">doi:10.1002/sim.2718</a>, Type: Journal article.<br /><br /> Bürkner P (2021).
&ldquo;Bayesian Item Response Modeling in R with brms and Stan.&rdquo;
<em>Journal of Statistical Software</em>, <b>100</b>(5), 1&ndash;54.
<a href="https://doi.org/10.18637/jss.v100.i05">doi:10.18637/jss.v100.i05</a>.<br /><br /> Bürkner P (2022).
<em>brms: Bayesian Regression Models using Stan</em>.
R package version 2.18.0, <a href="https://CRAN.R-project.org/package=brms">https://CRAN.R-project.org/package=brms</a>.<br /><br /> Cole T (2022).
<em>sitar: Super Imposition by Translation and Rotation Growth Curve Analysis</em>.
R package version 1.3.0, <a href="https://CRAN.R-project.org/package=sitar">https://CRAN.R-project.org/package=sitar</a>.<br /><br /> Cole TJ, Donaldson MDC, Ben-Shlomo Y (2010).
&ldquo;SITAR—a useful instrument for growth curve analysis.&rdquo;
<em>International Journal of Epidemiology</em>, <b>39</b>(6), 1558&ndash;1566.
ISSN 0300-5771, <a href="https://doi.org/10.1093/ije/dyq115">doi:10.1093/ije/dyq115</a>, tex.eprint: https://academic.oup.com/ije/article-pdf/39/6/1558/18480886/dyq115.pdf.<br /><br /> Gelman A, Lee D, Guo J (2015).
&ldquo;Stan: A Probabilistic Programming Language for Bayesian Inference and Optimization.&rdquo;
<em>Journal of Educational and Behavioral Statistics</em>, <b>40</b>(5), 530-543.
<a href="https://doi.org/10.3102/1076998615606113">doi:10.3102/1076998615606113</a>.<br /><br /> Harrell FE, others (2001).
<em>Regression modeling strategies: with applications to linear models, logistic regression, and survival analysis</em>, volume 608.
Springer.<br /><br /> Harrell Jr. FE (2022).
<em>Hmisc: Harrell Miscellaneous</em>.
R package version 4.7-2, <a href="https://hbiostat.org/R/Hmisc/">https://hbiostat.org/R/Hmisc/</a>.<br /><br /> Lindstrom MJ (1995).
&ldquo;Self-modelling with random shift and scale parameters and a free-knot spline shape function.&rdquo;
<em>Statistics in Medicine</em>, <b>14</b>(18), 2009-2021.
<a href="https://doi.org/10.1002/sim.4780141807">doi:10.1002/sim.4780141807</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/8677401/">https://pubmed.ncbi.nlm.nih.gov/8677401/</a>.<br /><br /> Nembidzane C, Lesaoana M, Monyeki KD, Boateng A, Makgae PJ (2020).
&ldquo;Using the SITAR Method to Estimate Age at Peak Height Velocity of Children in Rural South Africa: Ellisras Longitudinal Study.&rdquo;
<em>Children</em>, <b>7</b>(3), 17.
ISSN 2227-9067, <a href="https://doi.org/10.3390/children7030017">doi:10.3390/children7030017</a>, <a href="https://www.mdpi.com/2227-9067/7/3/17">https://www.mdpi.com/2227-9067/7/3/17</a>.<br /><br /> Sandhu SS (2020).
<em>Analysis of longitudinal jaw growth data to study sex differences in timing and intensity of the adolescent growth spurt for normal growth and skeletal discrepancies</em>.
Thesis, University of Bristol.<br /><br /> Stan Development Team (2023).
<em>Stan Reference Manual version 2.31</em>.
<a href="https://mc-stan.org/docs/reference-manual/">https://mc-stan.org/docs/reference-manual/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+brm">brms::brm()</a></code> <code><a href="brms.html#topic+brmsformula">brms::brmsformula()</a></code> <code><a href="brms.html#topic+set_prior">brms::prior()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Below, we fit a SITAR model to a subset of the Berkley height data, 
# specifically the data for 70 girls between the ages of 8 and 18.  
# This subset is used as an example in the vignette for the 'sitar' package.
#
# The original Berkley height data contains repeated growth measurements for
# 66 boys and 70 girls (ages 0-21). For this example, we use a subset of the 
# data for 70 girls aged 8 to 18 years.
#
# For details on the full Berkley height dataset, refer to 'sitar' package
# documentation (help file: ?sitar::berkeley). Further details on the subset
# of the data used here can be found in the vignette ('Fitting_models_with_SITAR', 
# package = 'sitar').

# Load the 'berkeley_exdata' that has been pre-saved
berkeley_exdata &lt;- getNsObject(berkeley_exdata)

# Fit frequentist SITAR model with df = 3 using the sitar package 

model_ml &lt;- sitar::sitar(x = age, y = height, id = id, 
                          df = 3, 
                          data = berkeley_exdata, 
                          xoffset = 'mean',
                          fixed = 'a+b+c', 
                          random = 'a+b+c',
                          a.formula = ~1, 
                          b.formula = ~1, 
                          c.formula = ~1
                          )


# Fit Bayesian SITAR model 

# To avoid time-consuming model estimation, the Bayesian SITAR model fit has 
# been saved as an example fit ('berkeley_exfit'). This model was fit using 
# 2 chains (2000 iterations per chain) with thinning set to 5 for memory  
# efficiency. Users are encouraged to refit the model using default settings 
# (4 chains, 2000 iterations per chain, thin = 1) as suggested by the Stan team.
# Note that with thinning set to 5 (thin = 5), only one fifth of total draws 
# will be saved and hence the effective sample size is expected to be small.

# Check if the pre-saved model 'berkeley_exfit' exists
# berkeley_exfit &lt;- bsitar:::berkeley_exfit

berkeley_exfit &lt;- getNsObject(berkeley_exfit)
 
if(exists('berkeley_exfit')) {
  model &lt;- berkeley_exfit
} else {
  # Fit model with default priors
  # Refer to the documentation for prior on each parameter
  model &lt;- bsitar(x = age, y = height, id = id, 
                  df = 3, 
                  data = berkeley_exdata,
                  xoffset = 'mean', 
                  fixed = 'a+b+c', 
                  random = 'a+b+c',
                  a_formula = ~1, 
                  b_formula = ~1, 
                  c_formula = ~1, 
                  threads = brms::threading(NULL),
                  chains = 2, cores = 2, iter = 2000, thin = 5)
                  
}

# Generate model summary
summary(model)

# Compare model summary with the frequentist SITAR model
print(model_ml)

# Check model fit via posterior predictive checks using plot_ppc.
# This function is based on pp_check from the 'brms' package.
plot_ppc(model, ndraws = 100)

# Plot distance and velocity curves using plot_conditional_effects.
# This function works like conditional_effects from the 'brms' package,
# with the added option to plot velocity curves.

# Distance curve
plot_conditional_effects(model, deriv = 0)

# Velocity curve
plot_conditional_effects(model, deriv = 1)

# Plot distance and velocity curves along with parameter estimates using 
# plot_curves (similar to plot.sitar from the sitar package).
plot_curves(model, apv = TRUE)

# Compare plots with the frequentist SITAR model
plot(model_ml)


</code></pre>

<hr>
<h2 id='expose_model_functions.bgmfit'>Expose User-Defined Stan Functions for Post-Processing</h2><span id='topic+expose_model_functions.bgmfit'></span><span id='topic+expose_model_functions'></span>

<h3>Description</h3>

<p>The <strong>expose_model_functions()</strong> function is a wrapper
around <code><a href="rstan.html#topic+expose_stan_functions">rstan::expose_stan_functions()</a></code> that exposes user-defined Stan
function(s). These functions are necessary for post-processing the
posterior draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
expose_model_functions(
  model,
  scode = NULL,
  expose = TRUE,
  select_model = NULL,
  returnobj = TRUE,
  vectorize = FALSE,
  verbose = FALSE,
  envir = NULL,
  ...
)

expose_model_functions(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expose_model_functions.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_scode">scode</code></td>
<td>
<p>A character string containing the user-defined Stan function(s)
in <code>Stan</code> code. If <code>NULL</code> (the default), the <code>scode</code> will be
retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_expose">expose</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to indicate whether to expose
the functions and add them as an attribute to the <code>model</code>.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_select_model">select_model</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the
model name. This parameter is for internal use only.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_returnobj">returnobj</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to specify whether to return
the model object. If <code>expose = TRUE</code>, it is advisable to set
<code>returnobj = TRUE</code>.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_vectorize">vectorize</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether the
exposed functions should be vectorized using <code><a href="base.html#topic+Vectorize">base::Vectorize()</a></code>. Note that
currently, <code>vectorize</code> should be set to <code>FALSE</code>, as setting it to
<code>TRUE</code> may not work as expected.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="expose_model_functions.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the
<code><a href="rstan.html#topic+expose_stan_functions">rstan::expose_stan_functions()</a></code> function. The &quot;...&quot; can be used to set the
compiler, which can be either <code><a href="rstan.html#topic+stanc">rstan::stanc()</a></code> or <code><a href="rstan.html#topic+stan_model">rstan::stan_model()</a></code>.
You can also pass other compiler-specific arguments such as <code>save_dso</code>
for <code><a href="rstan.html#topic+stan_model">rstan::stan_model()</a></code>. Note that while both <code><a href="rstan.html#topic+stanc">rstan::stanc()</a></code> and
<code><a href="rstan.html#topic+stan_model">rstan::stan_model()</a></code> can be used as compilers before calling
<code><a href="rstan.html#topic+expose_stan_functions">rstan::expose_stan_functions()</a></code>, it is important to note that the
execution time for <code><a href="rstan.html#topic+stan_model">rstan::stan_model()</a></code> is approximately twice as long as
<code><a href="rstan.html#topic+stanc">rstan::stanc()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bgmfit</code> if <code>returnobj = TRUE</code>;
otherwise, it returns <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="rstan.html#topic+expose_stan_functions">rstan::expose_stan_functions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether the model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# To save time, argument expose is set as FALSE, which runs a dummy test 
# and avoids model compilation that often takes time.

expose_model_functions(model, expose = FALSE)


</code></pre>

<hr>
<h2 id='fitted_draws.bgmfit'>Fitted (Expected) Values from the Posterior Draws</h2><span id='topic+fitted_draws.bgmfit'></span><span id='topic+fitted_draws'></span>

<h3>Description</h3>

<p>The <strong>fitted_draws()</strong> function is a wrapper around the
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> function, which allows users to obtain fitted
values (and their summaries) from the posterior draws. For more details,
refer to the documentation for <code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
fitted_draws(
  model,
  newdata = NULL,
  resp = NULL,
  dpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty",
  incl_autocor = TRUE,
  numeric_cov_at = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  aux_variables = NULL,
  ipts = 10,
  deriv = 0,
  deriv_model = TRUE,
  summary = TRUE,
  robust = FALSE,
  transform = NULL,
  probs = c(0.025, 0.975),
  xrange = NULL,
  xrange_search = NULL,
  parms_eval = FALSE,
  parms_method = "getPeak",
  idata_method = NULL,
  verbose = FALSE,
  fullframe = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  funlist = NULL,
  envir = NULL,
  ...
)

fitted_draws(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted_draws.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the response
variable when processing posterior draws for <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include
individual/group-level effects in the estimation. When <code>NA</code> (default),
individual-level effects are excluded, and population average growth
parameters are computed. When <code>NULL</code>, individual-level effects are
included in the computation, and the resulting growth parameters are
individual-specific. In both cases (<code>NA</code> or <code>NULL</code>), continuous
and factor covariates are appropriately included in the estimation.
Continuous covariates are set to their means by default (see
<code>numeric_cov_at</code> for details), while factor covariates remain
unaltered, allowing for the estimation of covariate-specific population
average and individual-specific growth parameters.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option sets the
continuous covariate(s) to their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate variable 'xx' to 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariates are
included in the model.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for the
hierarchical model (default <code>NULL</code>). It is used only when the model is
applied to data with three or more levels of hierarchy. For a two-level
model, <code>levels_id</code> is automatically inferred from the model fit. For
models with three or more levels, <code>levels_id</code> is inferred from the
model fit under the assumption that hierarchy is specified from the lowest
to the uppermost level, i.e., <code>id</code> followed by <code>study</code>, where
<code>id</code> is nested within <code>study</code>. However, it is not guaranteed that
<code>levels_id</code> is sorted correctly, so it is better to set it manually
when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters, such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically a
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and <code>reby</code> (typically <code>NULL</code>, indicating that
parameters are integrated over the random effects). For example,
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location-scale models and measurement error models. If
post-processing functions throw an error such as <code>variable 'x' not
  found in either 'data' or 'data2'</code>, consider using <code>aux_variables</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable for
generating a smooth velocity curve. If <code>NULL</code>, the original values are
returned. If an integer (e.g., <code>ipts = 10</code>, default), the predictor is
interpolated. Note that these interpolations do not alter the range of the
predictor when calculating population averages and/or individual-specific
growth curves.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>An integer indicating whether to estimate the distance curve
or its derivative (velocity curve). The default <code>deriv = 0</code> is for
the distance curve, while <code>deriv = 1</code> is for the velocity curve.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_summary">summary</code></td>
<td>
<p>A logical value indicating whether only the estimate should be
computed (<code>TRUE</code>), or whether the estimate along with SE and CI should
be returned (<code>FALSE</code>, default). Setting <code>summary</code> to <code>FALSE</code>
will increase computation time. Note that <code>summary = FALSE</code> is
required to obtain correct estimates when <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_robust">robust</code></td>
<td>
<p>A logical value to specify the summary options. If <code>FALSE</code>
(default), the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If <code>TRUE</code>, the
median and median absolute deviation (MAD) are applied instead. Ignored if
<code>summary</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_transform">transform</code></td>
<td>
<p>A function applied to individual draws from the posterior
distribution before computing summaries. The argument <code>transform</code> is
based on the <code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> function. This should not be
confused with <code>transform</code> from <code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>, which is
now deprecated.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (e.g., age) when
executing the interpolation via <code>ipts</code>. By default, <code>NULL</code> sets
the individual-specific predictor range. Setting <code>xrange = 1</code> applies
the same range for individuals within the same higher grouping variable
(e.g., study). Setting <code>xrange = 2</code> applies an identical range across
the entire sample. Alternatively, a numeric vector (e.g., <code>xrange =
  c(6, 20)</code>) can be provided to set the range within the specified values.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_xrange_search">xrange_search</code></td>
<td>
<p>A vector of length two or a character string
<code>'range'</code> to set the range of the predictor variable (<code>x</code>) within
which growth parameters are searched. This is useful when there is more
than one peak and the user wants to summarize the peak within a specified
range of the <code>x</code> variable. The default value is <code>xrange_search =
  NULL</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_parms_eval">parms_eval</code></td>
<td>
<p>A logical value to specify whether or not to compute growth
parameters on the fly. This is for internal use only and is mainly needed
for compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_parms_method">parms_method</code></td>
<td>
<p>A character string specifying the method used when
evaluating <code>parms_eval</code>. The default method is <code>getPeak</code>, which
uses the <code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code> function from the <code>sitar</code> package.
Alternatively, <code>findpeaks</code> uses the <code>findpeaks</code> function from the
<code>pracma</code> package. This parameter is for internal use and ensures
compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of interpolation points is set by the <code>ipts</code> argument.
Available options for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>).
</p>

<ul>
<li> <p><em>Method 1</em> (<code>'m1'</code>) is adapted from the <span class="pkg">iapvbs</span> package
and is documented
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">here</a>.
</p>
</li>
<li> <p><em>Method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span> package
and is documented
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">here</a>.
The <code>'m1'</code> method works by internally constructing the data frame
based on the model configuration, while the <code>'m2'</code> method uses the
exact data frame from the model fit, accessible via <code>fit$data</code>. If
<code>idata_method = NULL</code> (default), method <code>'m2'</code> is automatically
selected. Note that method <code>'m1'</code> may fail in certain cases,
especially when the model includes covariates (particularly in
<code>univariate_by</code> models). In such cases, it is recommended to use
method <code>'m2'</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_fullframe">fullframe</code></td>
<td>
<p>A logical value indicating whether to return a
<code>fullframe</code> object in which <code>newdata</code> is bound to the summary
estimates. Note that <code>fullframe</code> cannot be used with <code>summary =
  FALSE</code>, and it is only applicable when <code>idata_method = 'm2'</code>. A
typical use case is when fitting a <code>univariate_by</code> model. This option
is mainly for internal use.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) to convert dummy
variables into a factor variable. The list must include the following
elements:
</p>

<ul>
<li> <p><code>factor.dummy</code>: A character vector of dummy variables to be
converted to factors.
</p>
</li>
<li> <p><code>factor.name</code>: The name for the newly created factor variable
(default is <code>'factor.var'</code> if <code>NULL</code>).
</p>
</li>
<li> <p><code>factor.level</code>: A vector specifying the factor levels.
If <code>NULL</code>, levels are taken from <code>factor.dummy</code>.
If <code>factor.level</code> is provided, its length must match
<code>factor.dummy</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_funlist">funlist</code></td>
<td>
<p>A list (default <code>NULL</code>) specifying function names. This
is rarely needed, as required functions are typically retrieved
automatically. A use case for <code>funlist</code> is when <code>sigma_formula</code>,
<code>sigma_formula_gr</code>, or <code>sigma_formula_gr_str</code> use an external
function (e.g., <code>poly(age)</code>). The <code>funlist</code> should include
function names defined in the <code>globalenv()</code>. For functions needing
both distance and velocity curves (e.g., <code>plot_curves(..., opt =
  'dv')</code>), <code>funlist</code> must include two functions: one for the distance
curve and one for the velocity curve.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="fitted_draws.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>
function. For details on available options, please refer to
<code>brms::fitted.brmsfit()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>fitted_draws()</strong> function computes the fitted values
from the posterior draws. While the <code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> function
from the <span class="pkg">brms</span> package can be used to obtain fitted (distance)
values when the outcome (e.g., height) is untransformed, it returns
fitted values on the log or square root scale if the outcome is
transformed. In contrast, <strong>fitted_draws()</strong> returns fitted values
on the original scale. Additionally, <strong>fitted_draws()</strong> computes
the first derivative (velocity) on the original scale, after applying
the necessary back-transformation. Apart from these differences, both
functions—<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> and <code><a href="#topic+fitted_draws">fitted_draws()</a></code>—operate in the
same manner, allowing users to specify all options available in
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>.
</p>


<h3>Value</h3>

<p>An array of predicted mean response values when <code>summarise =
  FALSE</code>, or a <code>data.frame</code> when <code>summarise = TRUE</code>. For further
details, refer to <a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit</a>.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid time-consuming model estimation, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See the 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check if the model fit object 'berkeley_exfit' exists
berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average distance curve
fitted_draws(model, deriv = 0, re_formula = NA)

# Individual-specific distance curves
fitted_draws(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
fitted_draws(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
fitted_draws(model, deriv = 1, re_formula = NULL)


</code></pre>

<hr>
<h2 id='getNsObject'>Check and Get Namespace Object If Exists</h2><span id='topic+getNsObject'></span>

<h3>Description</h3>

<p>This function checks if an object exists within a specified namespace and
returns the object if it exists. The object must be provided as a symbol
(not a character string). The function is designed to facilitate the
retrieval of model or other objects from a specified environment or
namespace. This function is mainly for internal purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNsObject(object, namespace = NULL, envir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNsObject_+3A_object">object</code></td>
<td>
<p>A symbol representing the object to be retrieved. The input
must be a symbol (i.e., not a character string) corresponding to an
existing object within the specified namespace.</p>
</td></tr>
<tr><td><code id="getNsObject_+3A_namespace">namespace</code></td>
<td>
<p>A character string specifying the namespace to check for the
object. If the object exists within the given namespace, it will be
returned.</p>
</td></tr>
<tr><td><code id="getNsObject_+3A_envir">envir</code></td>
<td>
<p>An environment in which to search for the object. If set to
<code>NULL</code> (default), the function uses the global environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object of the same class as the input <code>object</code>, if it
exists. If the object doesn't exist in the specified namespace or
environment, an error is raised.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Check whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)


</code></pre>

<hr>
<h2 id='growthparameters_comparison.bgmfit'>Estimate and Compare Growth Parameters</h2><span id='topic+growthparameters_comparison.bgmfit'></span><span id='topic+growthparameters_comparison'></span>

<h3>Description</h3>

<p>The <strong>growthparameters_comparison()</strong> function estimates
and compares growth parameters, such as peak growth velocity and the age at
peak growth velocity. This function serves as a wrapper around
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>.
The <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> function computes unit-level
(conditional) estimates, whereas <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>
returns average (marginal) estimates. A detailed explanation is available
<a href="https://marginaleffects.com">here</a>. Note that for the current use case—
estimating and comparing growth parameters—the arguments <code>variables</code> and
<code>comparison</code> in <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> are modified (see below).
Furthermore, comparisons of growth parameters are performed via the
<code>hypothesis</code> argument of both the <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> functions. Please note that the
<span class="pkg">marginaleffects</span> package is highly flexible, and users are expected to
have a strong understanding of its workings. Additionally, since the
<span class="pkg">marginaleffects</span> package is rapidly evolving, results obtained from the
current implementation should be considered experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
growthparameters_comparison(
  model,
  resp = NULL,
  dpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  newdata = NULL,
  datagrid = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "gaussian",
  parameter = NULL,
  xrange = 1,
  acg_velocity = 0.1,
  digits = 2,
  numeric_cov_at = NULL,
  aux_variables = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  idata_method = NULL,
  ipts = NULL,
  seed = 123,
  future = FALSE,
  future_session = "multisession",
  future_splits = NULL,
  future_method = "future",
  future_re_expose = NULL,
  usedtplyr = FALSE,
  usecollapse = TRUE,
  parallel = FALSE,
  cores = NULL,
  average = FALSE,
  plot = FALSE,
  showlegends = NULL,
  variables = NULL,
  deriv = NULL,
  deriv_model = NULL,
  method = "custom",
  marginals = NULL,
  pdraws = FALSE,
  pdrawso = FALSE,
  pdrawsp = FALSE,
  pdrawsh = FALSE,
  comparison = "difference",
  type = NULL,
  by = FALSE,
  bys = NULL,
  conf_level = 0.95,
  transform = NULL,
  cross = FALSE,
  wts = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  eps = NULL,
  constrats_by = FALSE,
  constrats_at = FALSE,
  constrats_subset = FALSE,
  reformat = NULL,
  estimate_center = NULL,
  estimate_interval = NULL,
  dummy_to_factor = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  funlist = NULL,
  envir = NULL,
  ...
)

growthparameters_comparison(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the response
variable when processing posterior draws for <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_datagrid">datagrid</code></td>
<td>
<p>A grid of user-specified values to be used in the
<code>newdata</code> argument of various functions in the <span class="pkg">marginaleffects</span>
package. This allows you to define the regions of the predictor space
where you want to evaluate the quantities of interest. See
<code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code> for more details. By default, the
<code>datagrid</code> is set to <code>NULL</code>, meaning no custom grid is constructed.
To set a custom grid, the argument should either be a data frame created
using <code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code>, or a named list, which is internally
used for constructing the grid. For convenience, you can also pass an empty
list <code>datagrid = list()</code>, in which case essential arguments like
<code>model</code> and <code>newdata</code> are inferred from the respective arguments
specified elsewhere. Additionally, the first-level predictor (such as age)
and any covariates included in the model (e.g., gender) are automatically
inferred from the <code>model</code> object.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include
individual/group-level effects in the estimation. When <code>NA</code> (default),
individual-level effects are excluded, and population average growth
parameters are computed. When <code>NULL</code>, individual-level effects are
included in the computation, and the resulting growth parameters are
individual-specific. In both cases (<code>NA</code> or <code>NULL</code>), continuous
and factor covariates are appropriately included in the estimation.
Continuous covariates are set to their means by default (see
<code>numeric_cov_at</code> for details), while factor covariates remain
unaltered, allowing for the estimation of covariate-specific population
average and individual-specific growth parameters.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_parameter">parameter</code></td>
<td>
<p>A single character string or a character vector specifying
the growth parameter(s) to be estimated. Options include <code>'tgv'</code>
(takeoff growth velocity), <code>'atgv'</code> (age at takeoff growth velocity),
<code>'pgv'</code> (peak growth velocity), <code>'apgv'</code> (age at peak growth
velocity), <code>'cgv'</code> (cessation growth velocity), <code>'acgv'</code> (age at
cessation growth velocity), and <code>'all'</code>. If <code>parameter = NULL</code>
(default), age at peak growth velocity (<code>'apgv'</code>) is estimated. When
<code>parameter = 'all'</code>, all six parameters are estimated. Note that the
<code>'all'</code> option cannot be used when the <code>by</code> argument is set to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (e.g., age) when
executing the interpolation via <code>ipts</code>. By default, <code>NULL</code> sets
the individual-specific predictor range. Setting <code>xrange = 1</code> applies
the same range for individuals within the same higher grouping variable
(e.g., study). Setting <code>xrange = 2</code> applies an identical range across
the entire sample. Alternatively, a numeric vector (e.g., <code>xrange =
  c(6, 20)</code>) can be provided to set the range within the specified values.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_acg_velocity">acg_velocity</code></td>
<td>
<p>A real number specifying the percentage of peak growth
velocity to be used as the cessation velocity when estimating the
<code>cgv</code> and <code>acgv</code> growth parameters. The <code>acg_velocity</code>
should be greater than <code>0</code> and less than <code>1</code>. The default value
of <code>acg_velocity = 0.10</code> indicates that 10 percent of the peak growth
velocity will be used to calculate the cessation growth velocity and the
corresponding age at cessation velocity. For example, if the peak growth
velocity estimate is <code>10 mm/year</code>, then the cessation growth velocity
will be <code>1 mm/year</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) specifying the number of decimal
places to round the estimated growth parameters. The <code>digits</code> value is
passed to the <code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option sets the
continuous covariate(s) to their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate variable 'xx' to 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariates are
included in the model.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location-scale models and measurement error models. If
post-processing functions throw an error such as <code>variable 'x' not
  found in either 'data' or 'data2'</code>, consider using <code>aux_variables</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for the
hierarchical model (default <code>NULL</code>). It is used only when the model is
applied to data with three or more levels of hierarchy. For a two-level
model, <code>levels_id</code> is automatically inferred from the model fit. For
models with three or more levels, <code>levels_id</code> is inferred from the
model fit under the assumption that hierarchy is specified from the lowest
to the uppermost level, i.e., <code>id</code> followed by <code>study</code>, where
<code>id</code> is nested within <code>study</code>. However, it is not guaranteed that
<code>levels_id</code> is sorted correctly, so it is better to set it manually
when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters, such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically a
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and <code>reby</code> (typically <code>NULL</code>, indicating that
parameters are integrated over the random effects). For example,
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of interpolation points is set by the <code>ipts</code> argument.
Available options for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>).
</p>

<ul>
<li> <p><em>Method 1</em> (<code>'m1'</code>) is adapted from the <span class="pkg">iapvbs</span> package
and is documented
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">here</a>.
</p>
</li>
<li> <p><em>Method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span> package
and is documented
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">here</a>.
The <code>'m1'</code> method works by internally constructing the data frame
based on the model configuration, while the <code>'m2'</code> method uses the
exact data frame from the model fit, accessible via <code>fit$data</code>. If
<code>idata_method = NULL</code> (default), method <code>'m2'</code> is automatically
selected. Note that method <code>'m1'</code> may fail in certain cases,
especially when the model includes covariates (particularly in
<code>univariate_by</code> models). In such cases, it is recommended to use
method <code>'m2'</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable for
generating a smooth velocity curve. If <code>NULL</code>, the original values are
returned. If an integer (e.g., <code>ipts = 10</code>, default), the predictor is
interpolated. Note that these interpolations do not alter the range of the
predictor when calculating population averages and/or individual-specific
growth curves.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_seed">seed</code></td>
<td>
<p>An integer (default <code>123</code>) that is passed to the estimation
method to ensure reproducibility.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_future">future</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) to specify whether or
not to perform parallel computations. If set to <code>TRUE</code>, the
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code> function is used to summarize the posterior
draws in parallel.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_future_session">future_session</code></td>
<td>
<p>A character string specifying the session type when
<code>future = TRUE</code>. The <code>'multisession'</code> (default) option sets the
multisession environment, while the <code>'multicore'</code> option sets up a
multicore session. Note that <code>'multicore'</code> is not supported on Windows
systems. For more details, see <code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_future_splits">future_splits</code></td>
<td>
<p>A list (default <code>NULL</code>) that can be an unnamed
numeric list, a logical value, or a numeric vector of length 1 or 2. It is
used to split the processing of posterior draws into smaller subsets for
parallel computation.
</p>

<ul>
<li><p> If passed as a list (e.g., <code>future_splits = list(1:6, 7:10)</code>),
each sequence of
numbers is passed to the <code>draw_ids</code> argument.
</p>
</li>
<li><p> If passed as a numeric vector (e.g., <code>future_splits = c(10, 2)</code>),
the first element
specifies the number of draws (see <code>draw_ids</code>) and the second element
indicates the number of splits. The splits are created using
<code><a href="parallel.html#topic+splitIndices">parallel::splitIndices()</a></code>.
</p>
</li>
<li><p> If passed as a numeric vector of length 1, the first element is
internally set as the
number of draws (<code>ndraws</code> or <code>draw_ids</code>) depending on which one
is not <code>NULL</code>.
</p>
</li>
<li><p> If <code>TRUE</code>, a numeric vector for <code>future_splits</code> is created
based on the number
of draws (<code>ndraws</code>) and the number of cores (<code>cores</code>).
</p>
</li>
<li><p> If <code>FALSE</code>, <code>future_splits</code> is ignored.
The use case for <code>future_splits</code> is to save memory and improve
performance, especially on <code>Linux</code> systems when <code>future::plan()</code>
is set to <code>multicore</code>. Note: on Windows systems, R processes may not
be freed automatically when using <code>'multisession'</code>. In such cases, the
R processes can be interrupted using <code><a href="installr.html#topic+kill_all_Rscript_s">installr::kill_all_Rscript_s()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_future_method">future_method</code></td>
<td>
<p>A character string (default <code>'future'</code>) to specify
the method for parallel computation. Options include:
</p>

<ul>
<li> <p><code>'future'</code>: Uses <code><a href="future.html#topic+future">future::future()</a></code> along with
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_lapply()</a></code> for parallel execution.
</p>
</li>
<li> <p><code>'foreach'</code>: Uses <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> with the
<code>'dofuture'</code> function from the <code>doFuture</code> package for parallel
execution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_future_re_expose">future_re_expose</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether
to re-expose <code>Stan</code> functions when <code>future = TRUE</code>. This is
especially relevant when <code><a href="future.html#topic+plan">future::plan()</a></code> is set to <code>'multisession'</code>,
as already exposed C++ <code>Stan</code> functions cannot be passed across
multiple sessions.
</p>

<ul>
<li><p> When <code>future_re_expose = NULL</code> (the default), <code>future_re_expose</code>
is automatically set to <code>TRUE</code> for the <code>'multisession'</code> plan.
</p>
</li>
<li><p> It is advised to explicitly set <code>future_re_expose = TRUE</code> for speed
gains when using parallel processing with <code>future = TRUE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_usedtplyr">usedtplyr</code></td>
<td>
<p>A logical (default <code>FALSE</code>) indicating whether to use
the <span class="pkg">dtplyr</span> package for summarizing the draws. This package uses
<span class="pkg">data.table</span> as a back-end. It is useful when the data has a large
number of observations. For typical use cases, it does not make a
significant performance difference. The <code>usedtplyr</code> argument is
evaluated only when <code>method = 'custom'</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_usecollapse">usecollapse</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether to
use the <span class="pkg">collapse</span> package for summarizing the draws.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_parallel">parallel</code></td>
<td>
<p>A logical (default <code>FALSE</code>) indicating whether to use
parallel computation (via <span class="pkg">doParallel</span> and <span class="pkg">foreach</span>) when
<span class="pkg">usecollapse = TRUE</span>. When <code>parallel = TRUE</code>,
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> sets the cluster type as <code>"PSOCK"</code>, which
works on all operating systems, including <code>Windows</code>. If you want to
use a faster option for Unix-based systems, you can set <code>parallel =
  "FORK"</code>, but note that it is not compatible with <code>Windows</code> systems.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_cores">cores</code></td>
<td>
<p>A positive integer (default <code>1</code>) specifying the number of
CPU cores to use when <code>parallel = TRUE</code>. To automatically detect the
number of available cores, set <code>cores = NULL</code>. This is useful for
optimizing performance when working with large datasets.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_average">average</code></td>
<td>
<p>A logical value indicating whether to internally call the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> or the
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> function. If <code>FALSE</code> (default),
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> is called, otherwise
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> is used when <code>average = TRUE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_plot">plot</code></td>
<td>
<p>A logical value specifying whether to plot comparisons by calling
the <code><a href="marginaleffects.html#topic+plot_comparisons">marginaleffects::plot_comparisons()</a></code> function (<code>TRUE</code>) or not
(<code>FALSE</code>). If <code>FALSE</code> (default), then
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> or <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>
are called to compute predictions (see the <code>average</code> argument for
details).</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_showlegends">showlegends</code></td>
<td>
<p>A logical value to specify whether to show legends
(<code>TRUE</code>) or not (<code>FALSE</code>). If <code>NULL</code> (default), the value of
<code>showlegends</code> is internally set to <code>TRUE</code> if <code>re_formula =
  NA</code>, and <code>FALSE</code> if <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_variables">variables</code></td>
<td>
<p>A named list specifying the level 1 predictor, such as
<code>age</code> or <code>time</code>, used for estimating growth parameters in the
current use case. The <code>variables</code> list is set via the <code>esp</code>
argument (default value is <code>1e-6</code>). If <code>variables</code> is
<code>NULL</code>, the relevant information is retrieved internally from the
<code>model</code>. Alternatively, users can define <code>variables</code> as a named
list, e.g., <code>variables = list('x' = 1e-6)</code> where <code>'x'</code> is the
level 1 predictor. By default, <code>variables = list('age' = 1e-6)</code> in the
<span class="pkg">marginaleffects</span> package, as velocity is usually computed by
differentiating the distance curve using the <code>dydx</code> approach. When
using this default, the argument <code>deriv</code> is automatically set to
<code>0</code> and <code>deriv_model</code> to <code>FALSE</code>. If parameters are to be
estimated based on the model's first derivative, <code>deriv</code> must be set
to <code>1</code> and <code>variables</code> will be defined as <code>variables =
  list('age' = 0)</code>. Note that if the default behavior is used (<code>deriv =
  0</code> and <code>variables = list('x' = 1e-6)</code>), additional arguments cannot be
passed to <code>variables</code>. In contrast, when using an alternative approach
(<code>deriv = 0</code> and <code>variables = list('x' = 0)</code>), additional options
can be passed to the <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> functions.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>A numeric value specifying whether to estimate parameters based
on the differentiation of the distance curve or the model's first
derivative. Please refer to the <code>variables</code> argument for more details.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_method">method</code></td>
<td>
<p>A character string indicating whether to compute estimates
using the <code>'marginaleffects'</code> package (<code>method = 'pkg'</code>) or
custom functions for efficiency and speed (<code>method = 'custom'</code>,
default). The <code>method = 'pkg'</code> option is only suitable for simple
cases and should be used with caution. <code>method = 'custom'</code> is the
preferred option because it allows for simultaneous estimation of multiple
parameters (e.g., <code>'apgv'</code> and <code>'pgv'</code>). This method works during
the post-draw stage, supports multiple parameter comparisons via the
<code>hypothesis</code> argument, and allows users to add or return draws (see
<code>pdraws</code> for details). If <code>method = 'pkg'</code>, the <code>by</code>
argument must not contain the predictor (e.g., <code>age</code>), and
<code>variables</code> must either be <code>NULL</code> (which defaults to
<code>list(age = 1e-6)</code>) or a list with factor variables like
<code>variables = list(class = 'pairwise')</code> or <code>variables = list(age =
  1e-6, class = 'pairwise')</code>. With <code>method = 'custom'</code>, the <code>by</code>
argument can include predictors, which will be ignored, and
<code>variables</code> should not contain predictors, but can accept factor
variables as a vector (e.g., <code>variables = c('class')</code>). Using
<code>method = 'custom'</code> is strongly recommended for better performance and
flexibility.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_marginals">marginals</code></td>
<td>
<p>A <code>list</code>, <code>data.frame</code>, or <code>tibble</code> returned
by the <span class="pkg">marginaleffects</span> functions (default <code>NULL</code>). This is only
evaluated when <code>method = 'custom'</code>. The <code>marginals</code> can be the
output from <span class="pkg">marginaleffects</span> functions or posterior draws from
<code>marginaleffects::posterior_draws()</code>. The <code>marginals</code> argument is
primarily used for internal purposes.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_pdraws">pdraws</code></td>
<td>
<p>A character string (default <code>FALSE</code>) that indicates
whether to return the raw posterior draws. Options include:
</p>

<ul>
<li> <p><code>'return'</code>: returns the raw draws,
</p>
</li>
<li> <p><code>'add'</code>: adds the raw draws to the final return object,
</p>
</li>
<li> <p><code>'returns'</code>: returns the summary of the raw draws,
</p>
</li>
<li> <p><code>'adds'</code>: adds the summary of raw draws to the final return
object.
</p>
</li></ul>

<p>The <code>pdraws</code> are the velocity estimates for each posterior sample. For
more details, see <code><a href="marginaleffects.html#topic+posterior_draws">marginaleffects::posterior_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_pdrawso">pdrawso</code></td>
<td>
<p>A character string (default <code>FALSE</code>) to indicate whether
to return the original posterior draws for parameters. Options include:
</p>

<ul>
<li> <p><code>'return'</code>: returns the original posterior draws,
</p>
</li>
<li> <p><code>'add'</code>: adds the original posterior draws to the outcome.
</p>
</li></ul>

<p>When <code>pdrawso = TRUE</code>, the default behavior is <code>pdrawso =
  'return'</code>. Note that the posterior draws are returned before calling
<code><a href="marginaleffects.html#topic+posterior_draws">marginaleffects::posterior_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_pdrawsp">pdrawsp</code></td>
<td>
<p>A character string (default <code>FALSE</code>) to indicate whether
to return the posterior draws for parameters. Options include:
</p>

<ul>
<li> <p><code>'return'</code>: returns the posterior draws for parameters,
</p>
</li>
<li> <p><code>'add'</code>: adds the posterior draws to the outcome.
</p>
</li></ul>

<p>When <code>pdrawsp = TRUE</code>, the default behavior is <code>pdrawsp =
  'return'</code>. The <code>pdrawsp</code> represent the parameter estimates for each of
the posterior samples, and the summary of these are the estimates returned.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_pdrawsh">pdrawsh</code></td>
<td>
<p>A character string (default <code>FALSE</code>) to indicate whether
to return the posterior draws for parameter contrasts. Options include:
</p>

<ul>
<li> <p><code>'return'</code>: returns the posterior draws for contrasts.
</p>
</li></ul>

<p>The summary of posterior draws for parameters is the default returned
object. The <code>pdrawsh</code> represent the contrast estimates for each of the
posterior samples, and the summary of these are the contrast returned.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_comparison">comparison</code></td>
<td>
<p>A character string specifying the comparison type for
growth parameter estimation. Options are <code>'difference'</code> and
<code>'differenceavg'</code>. This argument sets up the internal function for
estimating parameters using <code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code>, <code><a href="sitar.html#topic+getPeakTrough">sitar::getTakeoff()</a></code>, and
<code><a href="sitar.html#topic+getPeakTrough">sitar::getTrough()</a></code> functions. These options are restructured according to
the user-specified <code>hypothesis</code> argument.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_bys">bys</code></td>
<td>
<p>A character string (default <code>NULL</code>) specifying the variables
over which the parameters need to be summarized. If <code>bys</code> is not
<code>NULL</code>, the summary statistics will be calculated for each unique
combination of the specified variables.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_transform">transform</code></td>
<td>
<p>A function applied to individual draws from the posterior
distribution before computing summaries. The argument <code>transform</code> is
based on the <code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> function. This should not be
confused with <code>transform</code> from <code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>, which is
now deprecated.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_cross">cross</code></td>
<td>

<ul>
<li> <p><code>FALSE</code>: Contrasts represent the change in adjusted predictions when one predictor changes and all other variables are held constant.
</p>
</li>
<li> <p><code>TRUE</code>: Contrasts represent the changes in adjusted predictions when all the predictors specified in the <code>variables</code> argument are manipulated simultaneously (a &quot;cross-contrast&quot;).
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_wts">wts</code></td>
<td>
<p>logical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not unit-level estimates. See <code>?weighted.mean</code>
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li>
<li><p> FALSE: Equal weights.
</p>
</li>
<li><p> TRUE: Extract weights from the fitted object with <code>insight::find_weights()</code> and use them when taking weighted averages of estimates. Warning: <code>newdata=datagrid()</code> returns a single average weight, which is equivalent to using <code>wts=FALSE</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a number , formula, string equation, vector, matrix, or function.
</p>

<ul>
<li><p> Number: The null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li><p> String: Equation to specify linear or non-linear hypothesis tests. If the terms in <code>coef(object)</code> uniquely identify estimates, they can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">&#8288;b*&#8288;</code> wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;b* / b1 = 1&#8288;</code>
</p>
</li></ul>

</li>
<li><p> Formula: <code>lhs ~ rhs | group</code>
</p>

<ul>
<li> <p><code>lhs</code>
</p>

<ul>
<li> <p><code>ratio</code>
</p>
</li>
<li> <p><code>difference</code>
</p>
</li>
<li><p> Leave empty for default value
</p>
</li></ul>

</li>
<li> <p><code>rhs</code>
</p>

<ul>
<li> <p><code>pairwise</code> and <code>revpairwise</code>: pairwise differences between estimates in each row.
</p>
</li>
<li> <p><code>reference</code>: differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li> <p><code>sequential</code>: difference between an estimate and the estimate in the next row.
</p>
</li>
<li> <p><code>meandev</code>: difference between an estimate and the mean of all estimates.
</p>
</li>
<li><p> 'meanotherdev: difference between an estimate and the mean of all other estimates, excluding the current one.
</p>
</li>
<li> <p><code>poly</code>: polynomial contrasts, as computed by the <code>stats::contr.poly()</code> function.
</p>
</li>
<li> <p><code>helmert</code>: Helmert contrasts, as computed by the <code>stats::contr.helmert()</code> function. Contrast 2nd level to the first, 3rd to the average of the first two, and so on.
</p>
</li>
<li> <p><code>trt_vs_ctrl</code>: difference between the mean of estimates (except the first) and the first estimate.
</p>
</li>
<li> <p><code>I(fun(x))</code>: custom function to manipulate the vector of estimates <code>x</code>. The function <code>fun()</code> can return multiple (potentially named) estimates.
</p>
</li></ul>

</li>
<li> <p><code>group</code> (optional)
</p>

<ul>
<li><p> Column name of <code>newdata</code>. Conduct hypothesis tests withing subsets of the data.
</p>
</li></ul>

</li>
<li><p> Examples:
</p>

<ul>
<li> <p><code>~ poly</code>
</p>
</li>
<li> <p><code>~ sequential | groupid</code>
</p>
</li>
<li> <p><code>~ reference</code>
</p>
</li>
<li> <p><code>ratio ~ pairwise</code>
</p>
</li>
<li> <p><code>difference ~ pairwise | groupid</code>
</p>
</li>
<li> <p><code>~ I(x - mean(x)) | groupid</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;~ I(\(x) c(a = x[1], b = mean(x[2:3]))) | groupid&#8288;</code>
</p>
</li></ul>

</li></ul>

</li>
<li><p> Matrix or Vector: Each column is a vector of weights. The the output is the dot product between these vectors of weights and the vector of estimates. The matrix can have column names to label the estimates.
</p>
</li>
<li><p> Function:
</p>

<ul>
<li><p> Accepts an argument <code>x</code>: object produced by a <code>marginaleffects</code> function or a data frame with column <code>rowid</code> and <code>estimate</code>
</p>
</li>
<li><p> Returns a data frame with columns <code>term</code> and <code>estimate</code> (mandatory) and <code>rowid</code> (optional).
</p>
</li>
<li><p> The function can also accept optional input arguments: <code>newdata</code>, <code>by</code>, <code>draws</code>.
</p>
</li>
<li><p> This function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use <code>get_draws()</code> to extract and manipulate the draws directly.
</p>
</li></ul>

</li>
<li><p> See the Examples section below and the vignette: <a href="https://marginaleffects.com/chapters/hypothesis.html">https://marginaleffects.com/chapters/hypothesis.html</a>
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_equivalence">equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_eps">eps</code></td>
<td>
<p>NULL or numeric value which determines the step size to use when
calculating numerical derivatives: (f(x+eps)-f(x))/eps. When <code>eps</code> is
<code>NULL</code>, the step size is 0.0001 multiplied by the difference between
the maximum and minimum values of the variable with respect to which we
are taking the derivative. Changing <code>eps</code> may be necessary to avoid
numerical problems in certain models.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_constrats_by">constrats_by</code></td>
<td>
<p>A character vector (default <code>FALSE</code>) specifying the
variable(s) by which estimates and contrasts (during the post-draw stage)
should be computed using the <code>hypothesis</code> argument. The variable(s) in
<code>constrats_by</code> should be a subset of those specified in the <code>by</code>
argument. If <code>constrats_by = NULL</code>, it will copy all variables from
<code>by</code>, except for the level-1 predictor (e.g., <code>age</code>). To disable
this automatic behavior, use <code>constrats_by = FALSE</code>. This argument is
evaluated only when <code>method = 'custom'</code> and <code>hypothesis</code> is not
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_constrats_at">constrats_at</code></td>
<td>
<p>A named list (default <code>FALSE</code>) to specify the values
at which estimates and contrasts should be computed during the post-draw
stage using the <code>hypothesis</code> argument. The values can be specified as
<code>'max'</code>, <code>'min'</code>, <code>'unique'</code>, or <code>'range'</code> (e.g.,
<code>constrats_at = list(age = 'min')</code>) or as numeric values or vectors
(e.g., <code>constrats_at = list(age = c(6, 7))</code>). If <code>constrats_at =
  NULL</code>, level-1 predictors (e.g., <code>age</code>) are automatically set to their
unique values (i.e., <code>constrats_at = list(age = 'unique')</code>). To turn
off this behavior, use <code>constrats_at = FALSE</code>. Note that
<code>constrats_at</code> only affects data subsets prepared via
<code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code> or the <code>newdata</code> argument. The argument
is evaluated only when <code>method = 'custom'</code> and <code>hypothesis</code> is
not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_constrats_subset">constrats_subset</code></td>
<td>
<p>A named list (default <code>FALSE</code>) to filter the
estimates at which contrasts are computed using the <code>hypothesis</code>
argument. This is similar to <code>constrats_at</code>, except that
<code>constrats_subset</code> filters based on a character vector of variable
names (e.g., <code>constrats_subset = list(id = c('id1', 'id2'))</code>) rather
than numeric values. The argument is evaluated only when <code>method =
  'custom'</code> and <code>hypothesis</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_reformat">reformat</code></td>
<td>
<p>A logical (default <code>TRUE</code>) indicating whether to
reformat the output returned by <code>marginaleffects</code> as a data frame.
Column names are redefined as <code>conf.low</code> to <code>Q2.5</code> and
<code>conf.high</code> to <code>Q97.5</code> (assuming <code>conf_int = 0.95</code>).
Additionally, some columns (<code>term</code>, <code>contrast</code>, etc.) are dropped
from the data frame.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_estimate_center">estimate_center</code></td>
<td>
<p>A character string (default <code>NULL</code>) specifying
how to center estimates: either <code>'mean'</code> or <code>'median'</code>. This
option sets the global options as follows:
<code>options("marginaleffects_posterior_center" = "mean")</code> or
<code>options("marginaleffects_posterior_center" = "median")</code>. These global
options are restored upon function exit using <code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_estimate_interval">estimate_interval</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify
the type of credible intervals: <code>'eti'</code> for equal-tailed intervals or
<code>'hdi'</code> for highest density intervals. This option sets the global
options as follows: <code>options("marginaleffects_posterior_interval" =
  "eti")</code> or <code>options("marginaleffects_posterior_interval" = "hdi")</code>,
and is restored on exit using <code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) to convert dummy
variables into a factor variable. The list must include the following
elements:
</p>

<ul>
<li> <p><code>factor.dummy</code>: A character vector of dummy variables to be
converted to factors.
</p>
</li>
<li> <p><code>factor.name</code>: The name for the newly created factor variable
(default is <code>'factor.var'</code> if <code>NULL</code>).
</p>
</li>
<li> <p><code>factor.level</code>: A vector specifying the factor levels.
If <code>NULL</code>, levels are taken from <code>factor.dummy</code>.
If <code>factor.level</code> is provided, its length must match
<code>factor.dummy</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_funlist">funlist</code></td>
<td>
<p>A list (default <code>NULL</code>) specifying function names. This
is rarely needed, as required functions are typically retrieved
automatically. A use case for <code>funlist</code> is when <code>sigma_formula</code>,
<code>sigma_formula_gr</code>, or <code>sigma_formula_gr_str</code> use an external
function (e.g., <code>poly(age)</code>). The <code>funlist</code> should include
function names defined in the <code>globalenv()</code>. For functions needing
both distance and velocity curves (e.g., <code>plot_curves(..., opt =
  'dv')</code>), <code>funlist</code> must include two functions: one for the distance
curve and one for the velocity curve.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="growthparameters_comparison.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>brms::fitted.brmsfit()</code>
and <code>brms::predict()</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>growthparameters_comparison</code> function estimates and
returns the following growth parameters:
</p>

<ul>
<li> <p><code>pgv</code> - peak growth velocity
</p>
</li>
<li> <p><code>apgv</code> - age at peak growth velocity
</p>
</li>
<li> <p><code>tgv</code> - takeoff growth velocity
</p>
</li>
<li> <p><code>atgv</code> - age at takeoff growth velocity
</p>
</li>
<li> <p><code>cgv</code> - cessation growth velocity
</p>
</li>
<li> <p><code>acgv</code> - age at cessation growth velocity
</p>
</li></ul>

<p>The takeoff growth velocity is the lowest velocity just before the peak
begins, indicating the start of the pubertal growth spurt. The cessation
growth velocity marks the end of the active pubertal growth spurt and is
calculated as a certain percentage of the peak velocity (<code>pgv</code>).
Typically, 10 percent of <code>pgv</code> is considered a good indicator for the
cessation of the active pubertal growth spurt (Hardin et al. 2022).
This percentage is controlled via the <code>acg_velocity</code> argument, which
accepts a positive real value bounded between 0 and 1 (with the default value
being <code>0.1</code>, indicating 10 percent).
</p>


<h3>Value</h3>

<p>A data frame object with estimates and credible intervals (CIs) for
the computed parameter(s). The returned data frame includes the parameter
estimates, along with lower and upper bounds of the credible intervals,
typically labeled as <code>Q2.5</code> and <code>Q97.5</code>, assuming a 95%
confidence level. The specific columns may vary depending on the
computation method and the parameters being estimated.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>References</h3>

<p>Hardin AM, Knigge RP, Oh HS, Valiathan M, Duren DL, McNulty KP, Middleton KM, Sherwood RJ (2022).
&ldquo;Estimating Craniofacial Growth Cessation: Comparison of Asymptote- and Rate-Based Methods.&rdquo;
<em>The Cleft Palate Craniofacial Journal</em>, <b>59</b>(2), 230-238.
<a href="https://doi.org/10.1177/10556656211002675">doi:10.1177/10556656211002675</a>, PMID: 33998905.
</p>


<h3>See Also</h3>

<p><code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code>
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>
<code><a href="marginaleffects.html#topic+plot_comparisons">marginaleffects::plot_comparisons()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fit Bayesian SITAR model

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Note that since no covariate is part of the model fit, the below example 
# doesn't make sense and is included here only for the purpose of completeness.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

growthparameters_comparison(model, parameter = 'apgv', ndraws = 10)


</code></pre>

<hr>
<h2 id='growthparameters.bgmfit'>Estimate Growth Parameters from the Model Fit</h2><span id='topic+growthparameters.bgmfit'></span><span id='topic+growthparameters'></span>

<h3>Description</h3>

<p>The <strong>growthparameters()</strong> function estimates both
population-average and individual-specific growth parameters (e.g., age at
peak growth velocity). It also provides measures of uncertainty, including
standard errors (SE) and credible intervals (CIs). For a more advanced
analysis, consider using the <code><a href="#topic+growthparameters_comparison">growthparameters_comparison()</a></code> function,
which not only estimates adjusted parameters but also enables comparisons
of these parameters across different groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
growthparameters(
  model,
  newdata = NULL,
  resp = NULL,
  dpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  summary = FALSE,
  robust = FALSE,
  transform = NULL,
  re_formula = NA,
  peak = TRUE,
  takeoff = FALSE,
  trough = FALSE,
  acgv = FALSE,
  acgv_velocity = 0.1,
  estimation_method = "fitted",
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty",
  incl_autocor = TRUE,
  numeric_cov_at = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  aux_variables = NULL,
  ipts = 10,
  deriv_model = TRUE,
  conf = 0.95,
  xrange = NULL,
  xrange_search = NULL,
  digits = 2,
  seed = 123,
  future = FALSE,
  future_session = "multisession",
  cores = NULL,
  parms_eval = FALSE,
  idata_method = NULL,
  parms_method = "getPeak",
  verbose = FALSE,
  fullframe = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  funlist = NULL,
  envir = NULL,
  ...
)

growthparameters(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="growthparameters.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the response
variable when processing posterior draws for <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_summary">summary</code></td>
<td>
<p>A logical value indicating whether only the estimate should be
computed (<code>TRUE</code>), or whether the estimate along with SE and CI should
be returned (<code>FALSE</code>, default). Setting <code>summary</code> to <code>FALSE</code>
will increase computation time. Note that <code>summary = FALSE</code> is
required to obtain correct estimates when <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_robust">robust</code></td>
<td>
<p>A logical value to specify the summary options. If <code>FALSE</code>
(default), the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If <code>TRUE</code>, the
median and median absolute deviation (MAD) are applied instead. Ignored if
<code>summary</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_transform">transform</code></td>
<td>
<p>A function applied to individual draws from the posterior
distribution before computing summaries. The argument <code>transform</code> is
based on the <code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> function. This should not be
confused with <code>transform</code> from <code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>, which is
now deprecated.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include
individual/group-level effects in the estimation. When <code>NA</code> (default),
individual-level effects are excluded, and population average growth
parameters are computed. When <code>NULL</code>, individual-level effects are
included in the computation, and the resulting growth parameters are
individual-specific. In both cases (<code>NA</code> or <code>NULL</code>), continuous
and factor covariates are appropriately included in the estimation.
Continuous covariates are set to their means by default (see
<code>numeric_cov_at</code> for details), while factor covariates remain
unaltered, allowing for the estimation of covariate-specific population
average and individual-specific growth parameters.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_peak">peak</code></td>
<td>
<p>A logical value (default <code>TRUE</code>) indicating whether to
calculate the age at peak velocity (APGV) and the peak velocity (PGV)
parameters.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_takeoff">takeoff</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) indicating whether to
calculate the age at takeoff velocity (ATGV) and the takeoff growth
velocity (TGV) parameters.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_trough">trough</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) indicating whether to
calculate the age at cessation of growth velocity (ACGV) and the cessation
of growth velocity (CGV) parameters.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_acgv">acgv</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) indicating whether to
calculate the age at cessation of growth velocity from the velocity curve.
If <code>TRUE</code>, the age at cessation of growth velocity (ACGV) and the
cessation growth velocity (CGV) are calculated based on the percentage of
the peak growth velocity, as defined by the <code>acgv_velocity</code> argument
(see below). The <code>acgv_velocity</code> is typically set at 10 percent of the
peak growth velocity. ACGV and CGV are calculated along with the
uncertainty (SE and CI) around the ACGV and CGV parameters.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_acgv_velocity">acgv_velocity</code></td>
<td>
<p>The percentage of the peak growth velocity to use when
estimating <code>acgv</code>. The default value is <code>0.10</code>, i.e., 10 percent
of the peak growth velocity.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_estimation_method">estimation_method</code></td>
<td>
<p>A character string specifying the estimation method
when calculating the velocity from the posterior draws. The <code>'fitted'</code>
method internally calls <code><a href="#topic+fitted_draws">fitted_draws()</a></code>, while the
<code>'predict'</code> method calls <code><a href="#topic+predict_draws">predict_draws()</a></code>. See
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> and <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> for details.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option sets the
continuous covariate(s) to their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate variable 'xx' to 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariates are
included in the model.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for the
hierarchical model (default <code>NULL</code>). It is used only when the model is
applied to data with three or more levels of hierarchy. For a two-level
model, <code>levels_id</code> is automatically inferred from the model fit. For
models with three or more levels, <code>levels_id</code> is inferred from the
model fit under the assumption that hierarchy is specified from the lowest
to the uppermost level, i.e., <code>id</code> followed by <code>study</code>, where
<code>id</code> is nested within <code>study</code>. However, it is not guaranteed that
<code>levels_id</code> is sorted correctly, so it is better to set it manually
when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters, such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically a
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and <code>reby</code> (typically <code>NULL</code>, indicating that
parameters are integrated over the random effects). For example,
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location-scale models and measurement error models. If
post-processing functions throw an error such as <code>variable 'x' not
  found in either 'data' or 'data2'</code>, consider using <code>aux_variables</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable for
generating a smooth velocity curve. If <code>NULL</code>, the original values are
returned. If an integer (e.g., <code>ipts = 10</code>, default), the predictor is
interpolated. Note that these interpolations do not alter the range of the
predictor when calculating population averages and/or individual-specific
growth curves.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_conf">conf</code></td>
<td>
<p>A numeric value (default <code>0.95</code>) to compute the confidence
interval (CI). Internally, <code>conf</code> is translated into paired
probability values as <code>c((1 - conf)/2, 1 - (1 - conf)/2)</code>. For
<code>conf = 0.95</code>, this computes a 95% CI where the lower and upper limits
are named <code>Q.2.5</code> and <code>Q.97.5</code>, respectively.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (e.g., age) when
executing the interpolation via <code>ipts</code>. By default, <code>NULL</code> sets
the individual-specific predictor range. Setting <code>xrange = 1</code> applies
the same range for individuals within the same higher grouping variable
(e.g., study). Setting <code>xrange = 2</code> applies an identical range across
the entire sample. Alternatively, a numeric vector (e.g., <code>xrange =
  c(6, 20)</code>) can be provided to set the range within the specified values.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_xrange_search">xrange_search</code></td>
<td>
<p>A vector of length two or a character string
<code>'range'</code> to set the range of the predictor variable (<code>x</code>) within
which growth parameters are searched. This is useful when there is more
than one peak and the user wants to summarize the peak within a specified
range of the <code>x</code> variable. The default value is <code>xrange_search =
  NULL</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) to set the decimal places for
rounding the results using the <code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_seed">seed</code></td>
<td>
<p>An integer (default <code>123</code>) that is passed to the estimation
method to ensure reproducibility.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_future">future</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) to specify whether or
not to perform parallel computations. If set to <code>TRUE</code>, the
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code> function is used to summarize the posterior
draws in parallel.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_future_session">future_session</code></td>
<td>
<p>A character string specifying the session type when
<code>future = TRUE</code>. The <code>'multisession'</code> (default) option sets the
multisession environment, while the <code>'multicore'</code> option sets up a
multicore session. Note that <code>'multicore'</code> is not supported on Windows
systems. For more details, see <code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used for parallel computations if
<code>future = TRUE</code>. On non-Windows systems, this argument can be set
globally via the <code>mc.cores</code> option. By default, <code>NULL</code>, the
number of cores is automatically determined using
<code><a href="future.html#topic+re-exports">future::availableCores()</a></code>, and it will use the maximum number of cores
available minus one (i.e., <code>future::availableCores() - 1</code>).</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_parms_eval">parms_eval</code></td>
<td>
<p>A logical value to specify whether or not to compute growth
parameters on the fly. This is for internal use only and is mainly needed
for compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of interpolation points is set by the <code>ipts</code> argument.
Available options for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>).
</p>

<ul>
<li> <p><em>Method 1</em> (<code>'m1'</code>) is adapted from the <span class="pkg">iapvbs</span> package
and is documented
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">here</a>.
</p>
</li>
<li> <p><em>Method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span> package
and is documented
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">here</a>.
The <code>'m1'</code> method works by internally constructing the data frame
based on the model configuration, while the <code>'m2'</code> method uses the
exact data frame from the model fit, accessible via <code>fit$data</code>. If
<code>idata_method = NULL</code> (default), method <code>'m2'</code> is automatically
selected. Note that method <code>'m1'</code> may fail in certain cases,
especially when the model includes covariates (particularly in
<code>univariate_by</code> models). In such cases, it is recommended to use
method <code>'m2'</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_parms_method">parms_method</code></td>
<td>
<p>A character string specifying the method used when
evaluating <code>parms_eval</code>. The default method is <code>getPeak</code>, which
uses the <code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code> function from the <code>sitar</code> package.
Alternatively, <code>findpeaks</code> uses the <code>findpeaks</code> function from the
<code>pracma</code> package. This parameter is for internal use and ensures
compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_fullframe">fullframe</code></td>
<td>
<p>A logical value indicating whether to return a
<code>fullframe</code> object in which <code>newdata</code> is bound to the summary
estimates. Note that <code>fullframe</code> cannot be used with <code>summary =
  FALSE</code>, and it is only applicable when <code>idata_method = 'm2'</code>. A
typical use case is when fitting a <code>univariate_by</code> model. This option
is mainly for internal use.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) to convert dummy
variables into a factor variable. The list must include the following
elements:
</p>

<ul>
<li> <p><code>factor.dummy</code>: A character vector of dummy variables to be
converted to factors.
</p>
</li>
<li> <p><code>factor.name</code>: The name for the newly created factor variable
(default is <code>'factor.var'</code> if <code>NULL</code>).
</p>
</li>
<li> <p><code>factor.level</code>: A vector specifying the factor levels.
If <code>NULL</code>, levels are taken from <code>factor.dummy</code>.
If <code>factor.level</code> is provided, its length must match
<code>factor.dummy</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_funlist">funlist</code></td>
<td>
<p>A list (default <code>NULL</code>) specifying function names. This
is rarely needed, as required functions are typically retrieved
automatically. A use case for <code>funlist</code> is when <code>sigma_formula</code>,
<code>sigma_formula_gr</code>, or <code>sigma_formula_gr_str</code> use an external
function (e.g., <code>poly(age)</code>). The <code>funlist</code> should include
function names defined in the <code>globalenv()</code>. For functions needing
both distance and velocity curves (e.g., <code>plot_curves(..., opt =
  'dv')</code>), <code>funlist</code> must include two functions: one for the distance
curve and one for the velocity curve.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="growthparameters.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>brms::fitted.brmsfit()</code>
and <code>brms::predict()</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>growthparameters()</strong> function internally calls either the
<code><a href="#topic+fitted_draws">fitted_draws()</a></code> or the <code><a href="#topic+predict_draws">predict_draws()</a></code> function to estimate
first-derivative growth parameters for each posterior draw. The estimated
growth parameters include:
</p>

<ul>
<li><p> Age at Peak Growth Velocity (APGV)
</p>
</li>
<li><p> Peak Growth Velocity (PGV)
</p>
</li>
<li><p> Age at Takeoff Growth Velocity (ATGV)
</p>
</li>
<li><p> Takeoff Growth Velocity (TGV)
</p>
</li>
<li><p> Age at Cessation of Growth Velocity (ACGV)
</p>
</li>
<li><p> Cessation Growth Velocity (CGV)
</p>
</li></ul>

<p>APGV and PGV are estimated using the <code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code> function, while
ATGV and TGV are estimated using the <code><a href="sitar.html#topic+getPeakTrough">sitar::getTakeoff()</a></code> function. The
<code><a href="sitar.html#topic+getPeakTrough">sitar::getTrough()</a></code> function is employed to estimate ACGV and CGV. The
parameters from each posterior draw are then summarized to provide
estimates along with uncertainty measures (SEs and CIs).
</p>
<p>Please note that estimating cessation and takeoff growth parameters may not
be possible if there are no distinct pre-peak or post-peak troughs in the
data.
</p>


<h3>Value</h3>

<p>A data frame with either five columns (when <code>summary = TRUE</code>) or
two columns (when <code>summary = FALSE</code>, assuming <code>re_formual =
  NULL</code>). The first two columns, common to both scenarios, are
<code>'Parameter'</code> and <code>'Estimate'</code>, representing the growth parameter
(e.g., APGV, PGV) and its estimate. When <code>summary = TRUE</code>, three
additional columns are included: <code>'Est.Error'</code> and two columns
representing the lower and upper bounds of the confidence intervals, named
<code>Q.2.5</code> and <code>Q.97.5</code> (for the 95% CI). If <code>re_formual =
  NULL</code>, an additional column with individual identifiers (e.g., <code>id</code>)
is included.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR Model 

# To avoid mode estimation, which takes time, the Bayesian SITAR model fit 
# to the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check if the model fit object 'berkeley_exfit' exists and load it
berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average age and velocity during the peak growth spurt
growthparameters(model, re_formula = NA)

# Population average age and velocity during the take-off and peak 
# growth spurt (APGV, PGV, ATGV, TGV)
growthparameters(model, re_formula = NA, peak = TRUE, takeoff = TRUE)

# Individual-specific age and velocity during the take-off and peak
# growth spurt (APGV, PGV, ATGV, TGV)
growthparameters(model, re_formula = NULL, peak = TRUE, takeoff = TRUE)


</code></pre>

<hr>
<h2 id='loo_validation.bgmfit'>Perform leave-one-out (LOO) cross-validation</h2><span id='topic+loo_validation.bgmfit'></span><span id='topic+loo_validation'></span>

<h3>Description</h3>

<p>The <strong>loo_validation()</strong> function is a wrapper around the
<code><a href="brms.html#topic+loo.brmsfit">brms::loo()</a></code> function to perform approximate leave-one-out cross-validation
based on the posterior likelihood. See <code><a href="brms.html#topic+loo.brmsfit">brms::loo()</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
loo_validation(
  model,
  compare = TRUE,
  resp = NULL,
  dpar = NULL,
  pointwise = FALSE,
  moment_match = FALSE,
  reloo = FALSE,
  k_threshold = 0.7,
  save_psis = FALSE,
  moment_match_args = list(),
  reloo_args = list(),
  model_names = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  cores = 1,
  deriv_model = NULL,
  verbose = FALSE,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

loo_validation(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loo_validation.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_compare">compare</code></td>
<td>
<p>A logical flag indicating if the information criteria of the
models should be compared using <code><a href="loo.html#topic+loo_compare">loo::loo_compare()</a></code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_resp">resp</code></td>
<td>
<p>Optional names of response variables. If specified, predictions
are performed only for the specified response variables.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_pointwise">pointwise</code></td>
<td>
<p>A flag indicating whether to compute the full
log-likelihood matrix at once or separately for each observation.
The latter approach is usually considerably slower but
requires much less working memory. Accordingly, if one runs
into memory issues, <code>pointwise = TRUE</code> is the way to go.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_moment_match">moment_match</code></td>
<td>
<p>A logical flag to indicate whether
<code><a href="loo.html#topic+loo_moment_match">loo::loo_moment_match()</a></code> should be applied to problematic observations.
Defaults to <code>FALSE</code>. For most models, moment matching will only work
if <code>save_pars = save_pars(all = TRUE)</code> was set when fitting the model
with <code><a href="brms.html#topic+brm">brms::brm()</a></code>. See <code><a href="brms.html#topic+loo_moment_match.brmsfit">brms::loo_moment_match()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_reloo">reloo</code></td>
<td>
<p>A logical flag indicating whether <code><a href="brms.html#topic+reloo.brmsfit">brms::reloo()</a></code> should be
applied to problematic observations. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_k_threshold">k_threshold</code></td>
<td>
<p>The Pareto <code class="reqn">k</code> threshold for which observations
<code><a href="brms.html#topic+loo_moment_match">loo_moment_match</a></code> or <code><a href="brms.html#topic+reloo">reloo</a></code> is applied if
argument <code>moment_match</code> or <code>reloo</code> is <code>TRUE</code>.
Defaults to <code>0.7</code>.
See <code><a href="loo.html#topic+pareto-k-diagnostic">pareto_k_ids</a></code> for more details.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_save_psis">save_psis</code></td>
<td>
<p>Should the <code>"psis"</code> object created internally be saved
in the returned object? For more details see <code><a href="loo.html#topic+loo">loo</a></code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_moment_match_args">moment_match_args</code></td>
<td>
<p>An optional <code>list</code> of additional arguments
passed to <code><a href="loo.html#topic+loo_moment_match">loo::loo_moment_match()</a></code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_reloo_args">reloo_args</code></td>
<td>
<p>An optional <code>list</code> of additional arguments passed to
<code><a href="brms.html#topic+reloo.brmsfit">brms::reloo()</a></code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names
derived from deparsing the call. Otherwise will use the passed
values as model names.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used for parallel computations if
<code>future = TRUE</code>. On non-Windows systems, this argument can be set
globally via the <code>mc.cores</code> option. By default, <code>NULL</code>, the
number of cores is automatically determined using
<code><a href="future.html#topic+re-exports">future::availableCores()</a></code>, and it will use the maximum number of cores
available minus one (i.e., <code>future::availableCores() - 1</code>).</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) to convert dummy
variables into a factor variable. The list must include the following
elements:
</p>

<ul>
<li> <p><code>factor.dummy</code>: A character vector of dummy variables to be
converted to factors.
</p>
</li>
<li> <p><code>factor.name</code>: The name for the newly created factor variable
(default is <code>'factor.var'</code> if <code>NULL</code>).
</p>
</li>
<li> <p><code>factor.level</code>: A vector specifying the factor levels.
If <code>NULL</code>, levels are taken from <code>factor.dummy</code>.
If <code>factor.level</code> is provided, its length must match
<code>factor.dummy</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="loo_validation.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+loo.brmsfit">brms::loo()</a></code> function.
Please see <code>brms::loo</code> for details on various options available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function supports model comparisons using <code><a href="loo.html#topic+loo_compare">loo::loo_compare()</a></code>
for comparing information criteria across models. For <code>bgmfit</code>
objects, <code>LOO</code> is simply an alias for <code>loo</code>. Additionally, you
can use <code><a href="brms.html#topic+add_criterion">brms::add_criterion()</a></code> to store information criteria in the fitted
model object for later use.
</p>


<h3>Value</h3>

<p>If only one model object is provided, an object of class <code>loo</code>
is returned. If multiple objects are provided, an object of class
<code>loolist</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+loo.brmsfit">brms::loo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Perform leave-one-out cross-validation
loo_validation(model, cores = 1)


</code></pre>

<hr>
<h2 id='marginal_comparison.bgmfit'>Estimate and compare growth curves</h2><span id='topic+marginal_comparison.bgmfit'></span><span id='topic+marginal_comparison'></span>

<h3>Description</h3>

<p>The <strong>marginal_comparison()</strong> function estimates and
compares growth curves such as distance and velocity. This function is a
wrapper around <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>. The <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code>
function computes unit-level (conditional) estimates, whereas
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> returns average (marginal) estimates.
A detailed explanation is available <a href="https://marginaleffects.com">here</a>.
Note that the <span class="pkg">marginaleffects</span> package is highly flexible, and users
are expected to have a strong understanding of its workings. Additionally,
since the <span class="pkg">marginaleffects</span> package is evolving rapidly, results from
the current implementation should be considered experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
marginal_comparison(
  model,
  resp = NULL,
  dpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  newdata = NULL,
  datagrid = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "gaussian",
  xrange = 1,
  digits = 2,
  numeric_cov_at = NULL,
  aux_variables = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  idata_method = NULL,
  ipts = NULL,
  seed = 123,
  future = FALSE,
  future_session = "multisession",
  future_splits = NULL,
  future_method = "future",
  future_re_expose = NULL,
  usedtplyr = FALSE,
  usecollapse = TRUE,
  cores = NULL,
  average = FALSE,
  plot = FALSE,
  showlegends = NULL,
  variables = NULL,
  deriv = NULL,
  deriv_model = NULL,
  method = "pkg",
  marginals = NULL,
  pdrawso = FALSE,
  pdrawsp = FALSE,
  pdrawsh = FALSE,
  comparison = "difference",
  type = NULL,
  by = FALSE,
  conf_level = 0.95,
  transform = NULL,
  cross = FALSE,
  wts = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  eps = NULL,
  constrats_by = NULL,
  constrats_at = NULL,
  reformat = NULL,
  estimate_center = NULL,
  estimate_interval = NULL,
  dummy_to_factor = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  funlist = NULL,
  envir = NULL,
  ...
)

marginal_comparison(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marginal_comparison.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the response
variable when processing posterior draws for <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_datagrid">datagrid</code></td>
<td>
<p>A data frame or named list for setting up a custom grid of
predictor values to evaluate the quantities of interest. If <code>NULL</code>
(default), no custom grid is used. The grid can be constructed using
<code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code>. If <code>datagrid = list()</code>, essential
arguments such as <code>model</code> and <code>newdata</code> are inferred
automatically from the respective arguments in the model fit.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include
individual/group-level effects in the estimation. When <code>NA</code> (default),
individual-level effects are excluded, and population average growth
parameters are computed. When <code>NULL</code>, individual-level effects are
included in the computation, and the resulting growth parameters are
individual-specific. In both cases (<code>NA</code> or <code>NULL</code>), continuous
and factor covariates are appropriately included in the estimation.
Continuous covariates are set to their means by default (see
<code>numeric_cov_at</code> for details), while factor covariates remain
unaltered, allowing for the estimation of covariate-specific population
average and individual-specific growth parameters.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (e.g., age) when
executing the interpolation via <code>ipts</code>. By default, <code>NULL</code> sets
the individual-specific predictor range. Setting <code>xrange = 1</code> applies
the same range for individuals within the same higher grouping variable
(e.g., study). Setting <code>xrange = 2</code> applies an identical range across
the entire sample. Alternatively, a numeric vector (e.g., <code>xrange =
  c(6, 20)</code>) can be provided to set the range within the specified values.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) for rounding the estimates to the
specified number of decimal places using <code><a href="base.html#topic+Round">base::round()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option sets the
continuous covariate(s) to their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate variable 'xx' to 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariates are
included in the model.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location-scale models and measurement error models. If
post-processing functions throw an error such as <code>variable 'x' not
  found in either 'data' or 'data2'</code>, consider using <code>aux_variables</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for the
hierarchical model (default <code>NULL</code>). It is used only when the model is
applied to data with three or more levels of hierarchy. For a two-level
model, <code>levels_id</code> is automatically inferred from the model fit. For
models with three or more levels, <code>levels_id</code> is inferred from the
model fit under the assumption that hierarchy is specified from the lowest
to the uppermost level, i.e., <code>id</code> followed by <code>study</code>, where
<code>id</code> is nested within <code>study</code>. However, it is not guaranteed that
<code>levels_id</code> is sorted correctly, so it is better to set it manually
when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters, such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically a
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and <code>reby</code> (typically <code>NULL</code>, indicating that
parameters are integrated over the random effects). For example,
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of interpolation points is set by the <code>ipts</code> argument.
Available options for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>).
</p>

<ul>
<li> <p><em>Method 1</em> (<code>'m1'</code>) is adapted from the <span class="pkg">iapvbs</span> package
and is documented
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">here</a>.
</p>
</li>
<li> <p><em>Method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span> package
and is documented
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">here</a>.
The <code>'m1'</code> method works by internally constructing the data frame
based on the model configuration, while the <code>'m2'</code> method uses the
exact data frame from the model fit, accessible via <code>fit$data</code>. If
<code>idata_method = NULL</code> (default), method <code>'m2'</code> is automatically
selected. Note that method <code>'m1'</code> may fail in certain cases,
especially when the model includes covariates (particularly in
<code>univariate_by</code> models). In such cases, it is recommended to use
method <code>'m2'</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable for
generating a smooth velocity curve. If <code>NULL</code>, the original values are
returned. If an integer (e.g., <code>ipts = 10</code>, default), the predictor is
interpolated. Note that these interpolations do not alter the range of the
predictor when calculating population averages and/or individual-specific
growth curves.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_seed">seed</code></td>
<td>
<p>An integer (default <code>123</code>) that is passed to the estimation
method to ensure reproducibility.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_future">future</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) to specify whether or
not to perform parallel computations. If set to <code>TRUE</code>, the
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code> function is used to summarize the posterior
draws in parallel.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_future_session">future_session</code></td>
<td>
<p>A character string specifying the session type when
<code>future = TRUE</code>. The <code>'multisession'</code> (default) option sets the
multisession environment, while the <code>'multicore'</code> option sets up a
multicore session. Note that <code>'multicore'</code> is not supported on Windows
systems. For more details, see <code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_future_splits">future_splits</code></td>
<td>
<p>A list (default <code>NULL</code>) that can be an unnamed
numeric list, a logical value, or a numeric vector of length 1 or 2. It is
used to split the processing of posterior draws into smaller subsets for
parallel computation.
</p>

<ul>
<li><p> If passed as a list (e.g., <code>future_splits = list(1:6, 7:10)</code>),
each sequence of
numbers is passed to the <code>draw_ids</code> argument.
</p>
</li>
<li><p> If passed as a numeric vector (e.g., <code>future_splits = c(10, 2)</code>),
the first element
specifies the number of draws (see <code>draw_ids</code>) and the second element
indicates the number of splits. The splits are created using
<code><a href="parallel.html#topic+splitIndices">parallel::splitIndices()</a></code>.
</p>
</li>
<li><p> If passed as a numeric vector of length 1, the first element is
internally set as the
number of draws (<code>ndraws</code> or <code>draw_ids</code>) depending on which one
is not <code>NULL</code>.
</p>
</li>
<li><p> If <code>TRUE</code>, a numeric vector for <code>future_splits</code> is created
based on the number
of draws (<code>ndraws</code>) and the number of cores (<code>cores</code>).
</p>
</li>
<li><p> If <code>FALSE</code>, <code>future_splits</code> is ignored.
The use case for <code>future_splits</code> is to save memory and improve
performance, especially on <code>Linux</code> systems when <code>future::plan()</code>
is set to <code>multicore</code>. Note: on Windows systems, R processes may not
be freed automatically when using <code>'multisession'</code>. In such cases, the
R processes can be interrupted using <code><a href="installr.html#topic+kill_all_Rscript_s">installr::kill_all_Rscript_s()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_future_method">future_method</code></td>
<td>
<p>A character string (default <code>'future'</code>) to specify
the method for parallel computation. Options include:
</p>

<ul>
<li> <p><code>'future'</code>: Uses <code><a href="future.html#topic+future">future::future()</a></code> along with
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_lapply()</a></code> for parallel execution.
</p>
</li>
<li> <p><code>'foreach'</code>: Uses <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> with the
<code>'dofuture'</code> function from the <code>doFuture</code> package for parallel
execution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_future_re_expose">future_re_expose</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether
to re-expose <code>Stan</code> functions when <code>future = TRUE</code>. This is
especially relevant when <code><a href="future.html#topic+plan">future::plan()</a></code> is set to <code>'multisession'</code>,
as already exposed C++ <code>Stan</code> functions cannot be passed across
multiple sessions.
</p>

<ul>
<li><p> When <code>future_re_expose = NULL</code> (the default), <code>future_re_expose</code>
is automatically set to <code>TRUE</code> for the <code>'multisession'</code> plan.
</p>
</li>
<li><p> It is advised to explicitly set <code>future_re_expose = TRUE</code> for speed
gains when using parallel processing with <code>future = TRUE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_usedtplyr">usedtplyr</code></td>
<td>
<p>A logical (default <code>FALSE</code>) indicating whether to use
the <span class="pkg">dtplyr</span> package for summarizing the draws. This package uses
<span class="pkg">data.table</span> as a back-end. It is useful when the data has a large
number of observations. For typical use cases, it does not make a
significant performance difference. The <code>usedtplyr</code> argument is
evaluated only when <code>method = 'custom'</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_usecollapse">usecollapse</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether to
use the <span class="pkg">collapse</span> package for summarizing the draws.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used for parallel computations if
<code>future = TRUE</code>. On non-Windows systems, this argument can be set
globally via the <code>mc.cores</code> option. By default, <code>NULL</code>, the
number of cores is automatically determined using
<code><a href="future.html#topic+re-exports">future::availableCores()</a></code>, and it will use the maximum number of cores
available minus one (i.e., <code>future::availableCores() - 1</code>).</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_average">average</code></td>
<td>
<p>A logical indicating whether to call
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> (if <code>FALSE</code>) or
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> (if <code>TRUE</code>). Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_plot">plot</code></td>
<td>
<p>A logical indicating whether to plot the comparisons using
<code><a href="marginaleffects.html#topic+plot_comparisons">marginaleffects::plot_comparisons()</a></code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_showlegends">showlegends</code></td>
<td>
<p>A logical value to specify whether to show legends
(<code>TRUE</code>) or not (<code>FALSE</code>). If <code>NULL</code> (default), the value of
<code>showlegends</code> is internally set to <code>TRUE</code> if <code>re_formula =
  NA</code>, and <code>FALSE</code> if <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_variables">variables</code></td>
<td>
<p>A named list specifying the level 1 predictor, such as
<code>age</code> or <code>time</code>, used for estimating growth parameters in the
current use case. The <code>variables</code> list is set via the <code>esp</code>
argument (default value is <code>1e-6</code>). If <code>variables</code> is
<code>NULL</code>, the relevant information is retrieved internally from the
<code>model</code>. Alternatively, users can define <code>variables</code> as a named
list, e.g., <code>variables = list('x' = 1e-6)</code> where <code>'x'</code> is the
level 1 predictor. By default, <code>variables = list('age' = 1e-6)</code> in the
<span class="pkg">marginaleffects</span> package, as velocity is usually computed by
differentiating the distance curve using the <code>dydx</code> approach. When
using this default, the argument <code>deriv</code> is automatically set to
<code>0</code> and <code>deriv_model</code> to <code>FALSE</code>. If parameters are to be
estimated based on the model's first derivative, <code>deriv</code> must be set
to <code>1</code> and <code>variables</code> will be defined as <code>variables =
  list('age' = 0)</code>. Note that if the default behavior is used (<code>deriv =
  0</code> and <code>variables = list('x' = 1e-6)</code>), additional arguments cannot be
passed to <code>variables</code>. In contrast, when using an alternative approach
(<code>deriv = 0</code> and <code>variables = list('x' = 0)</code>), additional options
can be passed to the <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> functions.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>A numeric value indicating whether to estimate parameters based
on the differentiation of the distance curve or the model's first
derivative.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_method">method</code></td>
<td>
<p>A character string specifying whether to compute comparisons
using the <span class="pkg">marginaleffects</span> machinery (<code>method = 'pkg'</code>) or via
custom functions for efficiency (<code>method = 'custom'</code>). Default is
<code>'pkg'</code>. The <code>'custom'</code> method is useful when testing hypotheses
and should be used cautiously.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_marginals">marginals</code></td>
<td>
<p>A <code>list</code>, <code>data.frame</code>, or <code>tibble</code> returned
by the <span class="pkg">marginaleffects</span> functions (default <code>NULL</code>). This is only
evaluated when <code>method = 'custom'</code>. The <code>marginals</code> can be the
output from <span class="pkg">marginaleffects</span> functions or posterior draws from
<code>marginaleffects::posterior_draws()</code>. The <code>marginals</code> argument is
primarily used for internal purposes.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_pdrawso">pdrawso</code></td>
<td>
<p>A character string (default <code>FALSE</code>) to indicate whether
to return the original posterior draws for parameters. Options include:
</p>

<ul>
<li> <p><code>'return'</code>: returns the original posterior draws,
</p>
</li>
<li> <p><code>'add'</code>: adds the original posterior draws to the outcome.
</p>
</li></ul>

<p>When <code>pdrawso = TRUE</code>, the default behavior is <code>pdrawso =
  'return'</code>. Note that the posterior draws are returned before calling
<code><a href="marginaleffects.html#topic+posterior_draws">marginaleffects::posterior_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_pdrawsp">pdrawsp</code></td>
<td>
<p>A character string (default <code>FALSE</code>) to indicate whether
to return the posterior draws for parameters. Options include:
</p>

<ul>
<li> <p><code>'return'</code>: returns the posterior draws for parameters,
</p>
</li>
<li> <p><code>'add'</code>: adds the posterior draws to the outcome.
</p>
</li></ul>

<p>When <code>pdrawsp = TRUE</code>, the default behavior is <code>pdrawsp =
  'return'</code>. The <code>pdrawsp</code> represent the parameter estimates for each of
the posterior samples, and the summary of these are the estimates returned.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_pdrawsh">pdrawsh</code></td>
<td>
<p>A character string (default <code>FALSE</code>) to indicate whether
to return the posterior draws for parameter contrasts. Options include:
</p>

<ul>
<li> <p><code>'return'</code>: returns the posterior draws for contrasts.
</p>
</li></ul>

<p>The summary of posterior draws for parameters is the default returned
object. The <code>pdrawsh</code> represent the contrast estimates for each of the
posterior samples, and the summary of these are the contrast returned.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_comparison">comparison</code></td>
<td>
<p>A character string specifying the comparison type for
growth parameter estimation. Options are <code>'difference'</code> and
<code>'differenceavg'</code>. This argument sets up the internal function for
estimating parameters using <code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code>, <code><a href="sitar.html#topic+getPeakTrough">sitar::getTakeoff()</a></code>, and
<code><a href="sitar.html#topic+getPeakTrough">sitar::getTrough()</a></code> functions. These options are restructured according to
the user-specified <code>hypothesis</code> argument.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_transform">transform</code></td>
<td>
<p>A function applied to individual draws from the posterior
distribution before computing summaries. The argument <code>transform</code> is
based on the <code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> function. This should not be
confused with <code>transform</code> from <code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>, which is
now deprecated.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_cross">cross</code></td>
<td>

<ul>
<li> <p><code>FALSE</code>: Contrasts represent the change in adjusted predictions when one predictor changes and all other variables are held constant.
</p>
</li>
<li> <p><code>TRUE</code>: Contrasts represent the changes in adjusted predictions when all the predictors specified in the <code>variables</code> argument are manipulated simultaneously (a &quot;cross-contrast&quot;).
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_wts">wts</code></td>
<td>
<p>logical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not unit-level estimates. See <code>?weighted.mean</code>
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li>
<li><p> FALSE: Equal weights.
</p>
</li>
<li><p> TRUE: Extract weights from the fitted object with <code>insight::find_weights()</code> and use them when taking weighted averages of estimates. Warning: <code>newdata=datagrid()</code> returns a single average weight, which is equivalent to using <code>wts=FALSE</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a number , formula, string equation, vector, matrix, or function.
</p>

<ul>
<li><p> Number: The null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li><p> String: Equation to specify linear or non-linear hypothesis tests. If the terms in <code>coef(object)</code> uniquely identify estimates, they can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">&#8288;b*&#8288;</code> wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;b* / b1 = 1&#8288;</code>
</p>
</li></ul>

</li>
<li><p> Formula: <code>lhs ~ rhs | group</code>
</p>

<ul>
<li> <p><code>lhs</code>
</p>

<ul>
<li> <p><code>ratio</code>
</p>
</li>
<li> <p><code>difference</code>
</p>
</li>
<li><p> Leave empty for default value
</p>
</li></ul>

</li>
<li> <p><code>rhs</code>
</p>

<ul>
<li> <p><code>pairwise</code> and <code>revpairwise</code>: pairwise differences between estimates in each row.
</p>
</li>
<li> <p><code>reference</code>: differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li> <p><code>sequential</code>: difference between an estimate and the estimate in the next row.
</p>
</li>
<li> <p><code>meandev</code>: difference between an estimate and the mean of all estimates.
</p>
</li>
<li><p> 'meanotherdev: difference between an estimate and the mean of all other estimates, excluding the current one.
</p>
</li>
<li> <p><code>poly</code>: polynomial contrasts, as computed by the <code>stats::contr.poly()</code> function.
</p>
</li>
<li> <p><code>helmert</code>: Helmert contrasts, as computed by the <code>stats::contr.helmert()</code> function. Contrast 2nd level to the first, 3rd to the average of the first two, and so on.
</p>
</li>
<li> <p><code>trt_vs_ctrl</code>: difference between the mean of estimates (except the first) and the first estimate.
</p>
</li>
<li> <p><code>I(fun(x))</code>: custom function to manipulate the vector of estimates <code>x</code>. The function <code>fun()</code> can return multiple (potentially named) estimates.
</p>
</li></ul>

</li>
<li> <p><code>group</code> (optional)
</p>

<ul>
<li><p> Column name of <code>newdata</code>. Conduct hypothesis tests withing subsets of the data.
</p>
</li></ul>

</li>
<li><p> Examples:
</p>

<ul>
<li> <p><code>~ poly</code>
</p>
</li>
<li> <p><code>~ sequential | groupid</code>
</p>
</li>
<li> <p><code>~ reference</code>
</p>
</li>
<li> <p><code>ratio ~ pairwise</code>
</p>
</li>
<li> <p><code>difference ~ pairwise | groupid</code>
</p>
</li>
<li> <p><code>~ I(x - mean(x)) | groupid</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;~ I(\(x) c(a = x[1], b = mean(x[2:3]))) | groupid&#8288;</code>
</p>
</li></ul>

</li></ul>

</li>
<li><p> Matrix or Vector: Each column is a vector of weights. The the output is the dot product between these vectors of weights and the vector of estimates. The matrix can have column names to label the estimates.
</p>
</li>
<li><p> Function:
</p>

<ul>
<li><p> Accepts an argument <code>x</code>: object produced by a <code>marginaleffects</code> function or a data frame with column <code>rowid</code> and <code>estimate</code>
</p>
</li>
<li><p> Returns a data frame with columns <code>term</code> and <code>estimate</code> (mandatory) and <code>rowid</code> (optional).
</p>
</li>
<li><p> The function can also accept optional input arguments: <code>newdata</code>, <code>by</code>, <code>draws</code>.
</p>
</li>
<li><p> This function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use <code>get_draws()</code> to extract and manipulate the draws directly.
</p>
</li></ul>

</li>
<li><p> See the Examples section below and the vignette: <a href="https://marginaleffects.com/chapters/hypothesis.html">https://marginaleffects.com/chapters/hypothesis.html</a>
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_equivalence">equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_eps">eps</code></td>
<td>
<p>NULL or numeric value which determines the step size to use when
calculating numerical derivatives: (f(x+eps)-f(x))/eps. When <code>eps</code> is
<code>NULL</code>, the step size is 0.0001 multiplied by the difference between
the maximum and minimum values of the variable with respect to which we
are taking the derivative. Changing <code>eps</code> may be necessary to avoid
numerical problems in certain models.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_constrats_by">constrats_by</code></td>
<td>
<p>A character vector (default <code>NULL</code>) specifying the
variables by which hypotheses should be tested (e.g., for post-draw
comparisons). These variables should be a subset of the variables in the
<code>by</code> argument of <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_constrats_at">constrats_at</code></td>
<td>
<p>A character vector (default <code>NULL</code>) specifying the
values at which hypotheses should be tested. Useful for large estimates to
limit testing to fewer rows.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_reformat">reformat</code></td>
<td>
<p>A logical (default <code>TRUE</code>) to reformat the output from
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> as a data.frame, with column names such as
<code>conf.low</code> as <code>Q2.5</code>, <code>conf.high</code> as <code>Q97.5</code>, and
dropping unnecessary columns like <code>term</code>, <code>contrast</code>, and
<code>predicted</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_estimate_center">estimate_center</code></td>
<td>
<p>A character string (default <code>NULL</code>) specifying
how to center estimates: either <code>'mean'</code> or <code>'median'</code>. This
option sets the global options as follows:
<code>options("marginaleffects_posterior_center" = "mean")</code> or
<code>options("marginaleffects_posterior_center" = "median")</code>. These global
options are restored upon function exit using <code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_estimate_interval">estimate_interval</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify
the type of credible intervals: <code>'eti'</code> for equal-tailed intervals or
<code>'hdi'</code> for highest density intervals. This option sets the global
options as follows: <code>options("marginaleffects_posterior_interval" =
  "eti")</code> or <code>options("marginaleffects_posterior_interval" = "hdi")</code>,
and is restored on exit using <code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) to convert dummy
variables into a factor variable. The list must include the following
elements:
</p>

<ul>
<li> <p><code>factor.dummy</code>: A character vector of dummy variables to be
converted to factors.
</p>
</li>
<li> <p><code>factor.name</code>: The name for the newly created factor variable
(default is <code>'factor.var'</code> if <code>NULL</code>).
</p>
</li>
<li> <p><code>factor.level</code>: A vector specifying the factor levels.
If <code>NULL</code>, levels are taken from <code>factor.dummy</code>.
If <code>factor.level</code> is provided, its length must match
<code>factor.dummy</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_funlist">funlist</code></td>
<td>
<p>A list (default <code>NULL</code>) specifying function names. This
is rarely needed, as required functions are typically retrieved
automatically. A use case for <code>funlist</code> is when <code>sigma_formula</code>,
<code>sigma_formula_gr</code>, or <code>sigma_formula_gr_str</code> use an external
function (e.g., <code>poly(age)</code>). The <code>funlist</code> should include
function names defined in the <code>globalenv()</code>. For functions needing
both distance and velocity curves (e.g., <code>plot_curves(..., opt =
  'dv')</code>), <code>funlist</code> must include two functions: one for the distance
curve and one for the velocity curve.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="marginal_comparison.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>brms::fitted.brmsfit()</code>
and <code>brms::predict()</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with estimates and confidence intervals for the
specified parameters, or a list when <code>method = 'custom'</code> and
<code>hypothesis</code> is not <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code>,
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code>,
<code><a href="marginaleffects.html#topic+plot_comparisons">marginaleffects::plot_comparisons()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Note: Since no covariates are included in this model, the 'marginal_comparison' 
# function is being shown here as a dummy example. In practice, comparisons may 
# not make sense without relevant covariates. 

# Check and confirm whether model fit object 'berkeley_exfit' exists
berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Call marginal_comparison to demonstrate the function
marginal_comparison(model, draw_ids = 1)


</code></pre>

<hr>
<h2 id='marginal_draws.bgmfit'>Estimate growth curves</h2><span id='topic+marginal_draws.bgmfit'></span><span id='topic+marginal_draws'></span>

<h3>Description</h3>

<p>The <strong>marginal_draws()</strong> function estimates and plots
growth curves (distance and velocity) by using the <span class="pkg">marginaleffects</span>
package as a back-end. This function can compute growth curves (via
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code>), average growth curves (via
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code>), or plot growth curves (via
<code><a href="marginaleffects.html#topic+plot_predictions">marginaleffects::plot_predictions()</a></code>). Please see
<a href="https://marginaleffects.com/">here</a> for details. Note that the
<span class="pkg">marginaleffects</span> package is highly flexible, and therefore, it
is expected that the user has a strong understanding of its workings.
Furthermore, since <span class="pkg">marginaleffects</span> is rapidly evolving, the
results obtained from the current implementation should be considered
experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
marginal_draws(
  model,
  resp = NULL,
  dpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  newdata = NULL,
  datagrid = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "gaussian",
  parameter = NULL,
  xrange = 1,
  acg_velocity = 0.1,
  digits = 2,
  numeric_cov_at = NULL,
  aux_variables = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  idata_method = NULL,
  ipts = NULL,
  seed = 123,
  future = FALSE,
  future_session = "multisession",
  future_splits = NULL,
  future_method = "future",
  future_re_expose = NULL,
  usedtplyr = FALSE,
  usecollapse = TRUE,
  cores = NULL,
  fullframe = FALSE,
  average = FALSE,
  plot = FALSE,
  showlegends = NULL,
  variables = NULL,
  condition = NULL,
  deriv = 0,
  deriv_model = TRUE,
  method = "custom",
  marginals = NULL,
  pdrawso = FALSE,
  pdrawsp = FALSE,
  pdrawsh = FALSE,
  type = NULL,
  by = NULL,
  conf_level = 0.95,
  transform = NULL,
  byfun = NULL,
  wts = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  constrats_by = NULL,
  constrats_at = NULL,
  reformat = NULL,
  estimate_center = NULL,
  estimate_interval = NULL,
  dummy_to_factor = NULL,
  verbose = FALSE,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  funlist = NULL,
  envir = NULL,
  ...
)

marginal_draws(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marginal_draws.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the response
variable when processing posterior draws for <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_datagrid">datagrid</code></td>
<td>
<p>A grid of user-specified values to be used in the
<code>newdata</code> argument of various functions in the <span class="pkg">marginaleffects</span>
package. This allows you to define the regions of the predictor space
where you want to evaluate the quantities of interest. See
<code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code> for more details. By default, the
<code>datagrid</code> is set to <code>NULL</code>, meaning no custom grid is constructed.
To set a custom grid, the argument should either be a data frame created
using <code><a href="marginaleffects.html#topic+datagrid">marginaleffects::datagrid()</a></code>, or a named list, which is internally
used for constructing the grid. For convenience, you can also pass an empty
list <code>datagrid = list()</code>, in which case essential arguments like
<code>model</code> and <code>newdata</code> are inferred from the respective arguments
specified elsewhere. Additionally, the first-level predictor (such as age)
and any covariates included in the model (e.g., gender) are automatically
inferred from the <code>model</code> object.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include
individual/group-level effects in the estimation. When <code>NA</code> (default),
individual-level effects are excluded, and population average growth
parameters are computed. When <code>NULL</code>, individual-level effects are
included in the computation, and the resulting growth parameters are
individual-specific. In both cases (<code>NA</code> or <code>NULL</code>), continuous
and factor covariates are appropriately included in the estimation.
Continuous covariates are set to their means by default (see
<code>numeric_cov_at</code> for details), while factor covariates remain
unaltered, allowing for the estimation of covariate-specific population
average and individual-specific growth parameters.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_parameter">parameter</code></td>
<td>
<p>A single character string or a character vector specifying
the growth parameter(s) to be estimated. Options include <code>'tgv'</code>
(takeoff growth velocity), <code>'atgv'</code> (age at takeoff growth velocity),
<code>'pgv'</code> (peak growth velocity), <code>'apgv'</code> (age at peak growth
velocity), <code>'cgv'</code> (cessation growth velocity), <code>'acgv'</code> (age at
cessation growth velocity), and <code>'all'</code>. If <code>parameter = NULL</code>
(default), age at peak growth velocity (<code>'apgv'</code>) is estimated. When
<code>parameter = 'all'</code>, all six parameters are estimated. Note that the
<code>'all'</code> option cannot be used when the <code>by</code> argument is set to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (e.g., age) when
executing the interpolation via <code>ipts</code>. By default, <code>NULL</code> sets
the individual-specific predictor range. Setting <code>xrange = 1</code> applies
the same range for individuals within the same higher grouping variable
(e.g., study). Setting <code>xrange = 2</code> applies an identical range across
the entire sample. Alternatively, a numeric vector (e.g., <code>xrange =
  c(6, 20)</code>) can be provided to set the range within the specified values.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_acg_velocity">acg_velocity</code></td>
<td>
<p>A real number specifying the percentage of peak growth
velocity to be used as the cessation velocity when estimating the
<code>cgv</code> and <code>acgv</code> growth parameters. The <code>acg_velocity</code>
should be greater than <code>0</code> and less than <code>1</code>. The default value
of <code>acg_velocity = 0.10</code> indicates that 10 percent of the peak growth
velocity will be used to calculate the cessation growth velocity and the
corresponding age at cessation velocity. For example, if the peak growth
velocity estimate is <code>10 mm/year</code>, then the cessation growth velocity
will be <code>1 mm/year</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) to set the decimal places for
rounding the results using the <code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option sets the
continuous covariate(s) to their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate variable 'xx' to 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariates are
included in the model.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location-scale models and measurement error models. If
post-processing functions throw an error such as <code>variable 'x' not
  found in either 'data' or 'data2'</code>, consider using <code>aux_variables</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for the
hierarchical model (default <code>NULL</code>). It is used only when the model is
applied to data with three or more levels of hierarchy. For a two-level
model, <code>levels_id</code> is automatically inferred from the model fit. For
models with three or more levels, <code>levels_id</code> is inferred from the
model fit under the assumption that hierarchy is specified from the lowest
to the uppermost level, i.e., <code>id</code> followed by <code>study</code>, where
<code>id</code> is nested within <code>study</code>. However, it is not guaranteed that
<code>levels_id</code> is sorted correctly, so it is better to set it manually
when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters, such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically a
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and <code>reby</code> (typically <code>NULL</code>, indicating that
parameters are integrated over the random effects). For example,
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of interpolation points is set by the <code>ipts</code> argument.
Available options for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>).
</p>

<ul>
<li> <p><em>Method 1</em> (<code>'m1'</code>) is adapted from the <span class="pkg">iapvbs</span> package
and is documented
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">here</a>.
</p>
</li>
<li> <p><em>Method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span> package
and is documented
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">here</a>.
The <code>'m1'</code> method works by internally constructing the data frame
based on the model configuration, while the <code>'m2'</code> method uses the
exact data frame from the model fit, accessible via <code>fit$data</code>. If
<code>idata_method = NULL</code> (default), method <code>'m2'</code> is automatically
selected. Note that method <code>'m1'</code> may fail in certain cases,
especially when the model includes covariates (particularly in
<code>univariate_by</code> models). In such cases, it is recommended to use
method <code>'m2'</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable for
generating a smooth velocity curve. If <code>NULL</code>, the original values are
returned. If an integer (e.g., <code>ipts = 10</code>, default), the predictor is
interpolated. Note that these interpolations do not alter the range of the
predictor when calculating population averages and/or individual-specific
growth curves.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_seed">seed</code></td>
<td>
<p>An integer (default <code>123</code>) that is passed to the estimation
method to ensure reproducibility.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_future">future</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) to specify whether or
not to perform parallel computations. If set to <code>TRUE</code>, the
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code> function is used to summarize the posterior
draws in parallel.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_future_session">future_session</code></td>
<td>
<p>A character string specifying the session type when
<code>future = TRUE</code>. The <code>'multisession'</code> (default) option sets the
multisession environment, while the <code>'multicore'</code> option sets up a
multicore session. Note that <code>'multicore'</code> is not supported on Windows
systems. For more details, see <code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_future_splits">future_splits</code></td>
<td>
<p>A list (default <code>NULL</code>) that can be an unnamed
numeric list, a logical value, or a numeric vector of length 1 or 2. It is
used to split the processing of posterior draws into smaller subsets for
parallel computation.
</p>

<ul>
<li><p> If passed as a list (e.g., <code>future_splits = list(1:6, 7:10)</code>),
each sequence of
numbers is passed to the <code>draw_ids</code> argument.
</p>
</li>
<li><p> If passed as a numeric vector (e.g., <code>future_splits = c(10, 2)</code>),
the first element
specifies the number of draws (see <code>draw_ids</code>) and the second element
indicates the number of splits. The splits are created using
<code><a href="parallel.html#topic+splitIndices">parallel::splitIndices()</a></code>.
</p>
</li>
<li><p> If passed as a numeric vector of length 1, the first element is
internally set as the
number of draws (<code>ndraws</code> or <code>draw_ids</code>) depending on which one
is not <code>NULL</code>.
</p>
</li>
<li><p> If <code>TRUE</code>, a numeric vector for <code>future_splits</code> is created
based on the number
of draws (<code>ndraws</code>) and the number of cores (<code>cores</code>).
</p>
</li>
<li><p> If <code>FALSE</code>, <code>future_splits</code> is ignored.
The use case for <code>future_splits</code> is to save memory and improve
performance, especially on <code>Linux</code> systems when <code>future::plan()</code>
is set to <code>multicore</code>. Note: on Windows systems, R processes may not
be freed automatically when using <code>'multisession'</code>. In such cases, the
R processes can be interrupted using <code><a href="installr.html#topic+kill_all_Rscript_s">installr::kill_all_Rscript_s()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_future_method">future_method</code></td>
<td>
<p>A character string (default <code>'future'</code>) to specify
the method for parallel computation. Options include:
</p>

<ul>
<li> <p><code>'future'</code>: Uses <code><a href="future.html#topic+future">future::future()</a></code> along with
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_lapply()</a></code> for parallel execution.
</p>
</li>
<li> <p><code>'foreach'</code>: Uses <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code> with the
<code>'dofuture'</code> function from the <code>doFuture</code> package for parallel
execution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_future_re_expose">future_re_expose</code></td>
<td>
<p>A logical (default <code>NULL</code>) to indicate whether
to re-expose <code>Stan</code> functions when <code>future = TRUE</code>. This is
especially relevant when <code><a href="future.html#topic+plan">future::plan()</a></code> is set to <code>'multisession'</code>,
as already exposed C++ <code>Stan</code> functions cannot be passed across
multiple sessions.
</p>

<ul>
<li><p> When <code>future_re_expose = NULL</code> (the default), <code>future_re_expose</code>
is automatically set to <code>TRUE</code> for the <code>'multisession'</code> plan.
</p>
</li>
<li><p> It is advised to explicitly set <code>future_re_expose = TRUE</code> for speed
gains when using parallel processing with <code>future = TRUE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_usedtplyr">usedtplyr</code></td>
<td>
<p>A logical (default <code>FALSE</code>) indicating whether to use
the <span class="pkg">dtplyr</span> package for summarizing the draws. This package uses
<span class="pkg">data.table</span> as a back-end. It is useful when the data has a large
number of observations. For typical use cases, it does not make a
significant performance difference. The <code>usedtplyr</code> argument is
evaluated only when <code>method = 'custom'</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_usecollapse">usecollapse</code></td>
<td>
<p>A logical (default <code>FALSE</code>) to indicate whether to
use the <span class="pkg">collapse</span> package for summarizing the draws.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used for parallel computations if
<code>future = TRUE</code>. On non-Windows systems, this argument can be set
globally via the <code>mc.cores</code> option. By default, <code>NULL</code>, the
number of cores is automatically determined using
<code><a href="future.html#topic+re-exports">future::availableCores()</a></code>, and it will use the maximum number of cores
available minus one (i.e., <code>future::availableCores() - 1</code>).</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_fullframe">fullframe</code></td>
<td>
<p>A logical value indicating whether to return a
<code>fullframe</code> object in which <code>newdata</code> is bound to the summary
estimates. Note that <code>fullframe</code> cannot be used with <code>summary =
  FALSE</code>, and it is only applicable when <code>idata_method = 'm2'</code>. A
typical use case is when fitting a <code>univariate_by</code> model. This option
is mainly for internal use.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_average">average</code></td>
<td>
<p>A logical indicating whether to internally call the
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> or <code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code>
function. If <code>FALSE</code> (default), <code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> is
called; otherwise, <code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code> is used when
<code>average = TRUE</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_plot">plot</code></td>
<td>
<p>A logical specifying whether to plot predictions by calling
<code><a href="marginaleffects.html#topic+plot_predictions">marginaleffects::plot_predictions()</a></code> (<code>TRUE</code>) or not (<code>FALSE</code>).
If <code>FALSE</code> (default), <code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> or
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code> are called to compute predictions (see
<code>average</code> for details). Note that
<code><a href="marginaleffects.html#topic+plot_predictions">marginaleffects::plot_predictions()</a></code> allows either <code>condition</code> or
<code>by</code> arguments, but not both. Therefore, when the <code>condition</code>
argument is not <code>NULL</code>, the <code>by</code> argument is set to <code>NULL</code>.
This step is required because <strong>marginal_draws()</strong> automatically
assigns the <code>by</code> argument when the model includes a covariate.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_showlegends">showlegends</code></td>
<td>
<p>A logical value to specify whether to show legends
(<code>TRUE</code>) or not (<code>FALSE</code>). If <code>NULL</code> (default), the value of
<code>showlegends</code> is internally set to <code>TRUE</code> if <code>re_formula =
  NA</code>, and <code>FALSE</code> if <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_variables">variables</code></td>
<td>
<p>A named list specifying the level 1 predictor, such as
<code>age</code> or <code>time</code>, used for estimating growth parameters in the
current use case. The <code>variables</code> list is set via the <code>esp</code>
argument (default value is <code>1e-6</code>). If <code>variables</code> is
<code>NULL</code>, the relevant information is retrieved internally from the
<code>model</code>. Alternatively, users can define <code>variables</code> as a named
list, e.g., <code>variables = list('x' = 1e-6)</code> where <code>'x'</code> is the
level 1 predictor. By default, <code>variables = list('age' = 1e-6)</code> in the
<span class="pkg">marginaleffects</span> package, as velocity is usually computed by
differentiating the distance curve using the <code>dydx</code> approach. When
using this default, the argument <code>deriv</code> is automatically set to
<code>0</code> and <code>deriv_model</code> to <code>FALSE</code>. If parameters are to be
estimated based on the model's first derivative, <code>deriv</code> must be set
to <code>1</code> and <code>variables</code> will be defined as <code>variables =
  list('age' = 0)</code>. Note that if the default behavior is used (<code>deriv =
  0</code> and <code>variables = list('x' = 1e-6)</code>), additional arguments cannot be
passed to <code>variables</code>. In contrast, when using an alternative approach
(<code>deriv = 0</code> and <code>variables = list('x' = 0)</code>), additional options
can be passed to the <code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> and
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::avg_comparisons()</a></code> functions.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_condition">condition</code></td>
<td>
<p>Conditional predictions
</p>

<ul>
<li><p> Character vector (max length 4): Names of the predictors to display.
</p>
</li>
<li><p> Named list (max length 4): List names correspond to predictors. List elements can be:
</p>

<ul>
<li><p> Numeric vector
</p>
</li>
<li><p> Function which returns a numeric vector or a set of unique categorical values
</p>
</li>
<li><p> Shortcut strings for common reference values: &quot;minmax&quot;, &quot;quartile&quot;, &quot;threenum&quot;
</p>
</li></ul>

</li>
<li><p> 1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).
</p>
</li>
<li><p> Numeric variables in positions 2 and 3 are summarized by Tukey's five numbers <code>?stats::fivenum</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>An integer to indicate whether to estimate the distance curve or
its derivative (i.e., velocity curve). The <code>deriv = 0</code> (default) is
for the distance curve, whereas <code>deriv = 1</code> is for the velocity curve.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_method">method</code></td>
<td>
<p>A character string specifying the computation method: whether
to use the <span class="pkg">marginaleffects</span> machinery at the post-draw stage, i.e.,
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code> (<code>method = 'pkg'</code>) or to use custom
functions for efficiency and speed (<code>method = 'custom'</code>, default).
Note that <code>method = 'custom'</code> is particularly useful when testing
hypotheses. Also, when <code>method = 'custom'</code>,
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> is used internally instead of
<code><a href="marginaleffects.html#topic+comparisons">marginaleffects::comparisons()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_marginals">marginals</code></td>
<td>
<p>A <code>list</code>, <code>data.frame</code>, or <code>tibble</code> returned
by the <span class="pkg">marginaleffects</span> functions (default <code>NULL</code>). This is only
evaluated when <code>method = 'custom'</code>. The <code>marginals</code> can be the
output from <span class="pkg">marginaleffects</span> functions or posterior draws from
<code>marginaleffects::posterior_draws()</code>. The <code>marginals</code> argument is
primarily used for internal purposes.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_pdrawso">pdrawso</code></td>
<td>
<p>A character string (default <code>FALSE</code>) to indicate whether
to return the original posterior draws for parameters. Options include:
</p>

<ul>
<li> <p><code>'return'</code>: returns the original posterior draws,
</p>
</li>
<li> <p><code>'add'</code>: adds the original posterior draws to the outcome.
</p>
</li></ul>

<p>When <code>pdrawso = TRUE</code>, the default behavior is <code>pdrawso =
  'return'</code>. Note that the posterior draws are returned before calling
<code><a href="marginaleffects.html#topic+posterior_draws">marginaleffects::posterior_draws()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_pdrawsp">pdrawsp</code></td>
<td>
<p>A character string (default <code>FALSE</code>) to indicate whether
to return the posterior draws for parameters. Options include:
</p>

<ul>
<li> <p><code>'return'</code>: returns the posterior draws for parameters,
</p>
</li>
<li> <p><code>'add'</code>: adds the posterior draws to the outcome.
</p>
</li></ul>

<p>When <code>pdrawsp = TRUE</code>, the default behavior is <code>pdrawsp =
  'return'</code>. The <code>pdrawsp</code> represent the parameter estimates for each of
the posterior samples, and the summary of these are the estimates returned.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_pdrawsh">pdrawsh</code></td>
<td>
<p>A character string (default <code>FALSE</code>) to indicate whether
to return the posterior draws for parameter contrasts. Options include:
</p>

<ul>
<li> <p><code>'return'</code>: returns the posterior draws for contrasts.
</p>
</li></ul>

<p>The summary of posterior draws for parameters is the default returned
object. The <code>pdrawsh</code> represent the contrast estimates for each of the
posterior samples, and the summary of these are the contrast returned.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_transform">transform</code></td>
<td>
<p>A function applied to individual draws from the posterior
distribution before computing summaries. The argument <code>transform</code> is
based on the <code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> function. This should not be
confused with <code>transform</code> from <code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>, which is
now deprecated.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_byfun">byfun</code></td>
<td>
<p>A function such as <code>mean()</code> or <code>sum()</code> used to aggregate
estimates within the subgroups defined by the <code>by</code> argument. <code>NULL</code> uses the
<code>mean()</code> function. Must accept a numeric vector and return a single numeric
value. This is sometimes used to take the sum or mean of predicted
probabilities across outcome or predictor
levels. See examples section.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_wts">wts</code></td>
<td>
<p>logical, string or numeric: weights to use when computing average predictions, contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not unit-level estimates. See <code>?weighted.mean</code>
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li>
<li><p> FALSE: Equal weights.
</p>
</li>
<li><p> TRUE: Extract weights from the fitted object with <code>insight::find_weights()</code> and use them when taking weighted averages of estimates. Warning: <code>newdata=datagrid()</code> returns a single average weight, which is equivalent to using <code>wts=FALSE</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a number , formula, string equation, vector, matrix, or function.
</p>

<ul>
<li><p> Number: The null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li><p> String: Equation to specify linear or non-linear hypothesis tests. If the terms in <code>coef(object)</code> uniquely identify estimates, they can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">&#8288;b*&#8288;</code> wildcard can be used to test hypotheses on all estimates. If a named vector is used, the names are used as labels in the output. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;b* / b1 = 1&#8288;</code>
</p>
</li></ul>

</li>
<li><p> Formula: <code>lhs ~ rhs | group</code>
</p>

<ul>
<li> <p><code>lhs</code>
</p>

<ul>
<li> <p><code>ratio</code>
</p>
</li>
<li> <p><code>difference</code>
</p>
</li>
<li><p> Leave empty for default value
</p>
</li></ul>

</li>
<li> <p><code>rhs</code>
</p>

<ul>
<li> <p><code>pairwise</code> and <code>revpairwise</code>: pairwise differences between estimates in each row.
</p>
</li>
<li> <p><code>reference</code>: differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li> <p><code>sequential</code>: difference between an estimate and the estimate in the next row.
</p>
</li>
<li> <p><code>meandev</code>: difference between an estimate and the mean of all estimates.
</p>
</li>
<li><p> 'meanotherdev: difference between an estimate and the mean of all other estimates, excluding the current one.
</p>
</li>
<li> <p><code>poly</code>: polynomial contrasts, as computed by the <code>stats::contr.poly()</code> function.
</p>
</li>
<li> <p><code>helmert</code>: Helmert contrasts, as computed by the <code>stats::contr.helmert()</code> function. Contrast 2nd level to the first, 3rd to the average of the first two, and so on.
</p>
</li>
<li> <p><code>trt_vs_ctrl</code>: difference between the mean of estimates (except the first) and the first estimate.
</p>
</li>
<li> <p><code>I(fun(x))</code>: custom function to manipulate the vector of estimates <code>x</code>. The function <code>fun()</code> can return multiple (potentially named) estimates.
</p>
</li></ul>

</li>
<li> <p><code>group</code> (optional)
</p>

<ul>
<li><p> Column name of <code>newdata</code>. Conduct hypothesis tests withing subsets of the data.
</p>
</li></ul>

</li>
<li><p> Examples:
</p>

<ul>
<li> <p><code>~ poly</code>
</p>
</li>
<li> <p><code>~ sequential | groupid</code>
</p>
</li>
<li> <p><code>~ reference</code>
</p>
</li>
<li> <p><code>ratio ~ pairwise</code>
</p>
</li>
<li> <p><code>difference ~ pairwise | groupid</code>
</p>
</li>
<li> <p><code>~ I(x - mean(x)) | groupid</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;~ I(\(x) c(a = x[1], b = mean(x[2:3]))) | groupid&#8288;</code>
</p>
</li></ul>

</li></ul>

</li>
<li><p> Matrix or Vector: Each column is a vector of weights. The the output is the dot product between these vectors of weights and the vector of estimates. The matrix can have column names to label the estimates.
</p>
</li>
<li><p> Function:
</p>

<ul>
<li><p> Accepts an argument <code>x</code>: object produced by a <code>marginaleffects</code> function or a data frame with column <code>rowid</code> and <code>estimate</code>
</p>
</li>
<li><p> Returns a data frame with columns <code>term</code> and <code>estimate</code> (mandatory) and <code>rowid</code> (optional).
</p>
</li>
<li><p> The function can also accept optional input arguments: <code>newdata</code>, <code>by</code>, <code>draws</code>.
</p>
</li>
<li><p> This function approach will not work for Bayesian models or with bootstrapping. In those cases, it is easy to use <code>get_draws()</code> to extract and manipulate the draws directly.
</p>
</li></ul>

</li>
<li><p> See the Examples section below and the vignette: <a href="https://marginaleffects.com/chapters/hypothesis.html">https://marginaleffects.com/chapters/hypothesis.html</a>
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_equivalence">equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_constrats_by">constrats_by</code></td>
<td>
<p>A character vector (default <code>NULL</code>) specifying the
variable(s) by which hypotheses (at the post-draw stage) should be tested.
Note that the variable(s) in <code>constrats_by</code> should be a subset of the
variables included in the <code>'by'</code> argument.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_constrats_at">constrats_at</code></td>
<td>
<p>A character vector (default <code>NULL</code>) specifying the
variable(s) at which hypotheses (at the post-draw stage) should be tested.
<code>constrats_at</code> is particularly useful when the number of rows in the
estimates is large because <span class="pkg">marginaleffects</span> does not allow hypotheses
testing when the number of rows exceeds 25.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_reformat">reformat</code></td>
<td>
<p>A logical (default <code>TRUE</code>) indicating whether to
reformat the output returned by <code>marginaleffects</code> as a data frame.
Column names are redefined as <code>conf.low</code> to <code>Q2.5</code> and
<code>conf.high</code> to <code>Q97.5</code> (assuming <code>conf_int = 0.95</code>).
Additionally, some columns (<code>term</code>, <code>contrast</code>, etc.) are dropped
from the data frame.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_estimate_center">estimate_center</code></td>
<td>
<p>A character string (default <code>NULL</code>) specifying
how to center estimates: either <code>'mean'</code> or <code>'median'</code>. This
option sets the global options as follows:
<code>options("marginaleffects_posterior_center" = "mean")</code> or
<code>options("marginaleffects_posterior_center" = "median")</code>. These global
options are restored upon function exit using <code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_estimate_interval">estimate_interval</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify
the type of credible intervals: <code>'eti'</code> for equal-tailed intervals or
<code>'hdi'</code> for highest density intervals. This option sets the global
options as follows: <code>options("marginaleffects_posterior_interval" =
  "eti")</code> or <code>options("marginaleffects_posterior_interval" = "hdi")</code>,
and is restored on exit using <code><a href="base.html#topic+on.exit">base::on.exit()</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) to convert dummy
variables into a factor variable. The list must include the following
elements:
</p>

<ul>
<li> <p><code>factor.dummy</code>: A character vector of dummy variables to be
converted to factors.
</p>
</li>
<li> <p><code>factor.name</code>: The name for the newly created factor variable
(default is <code>'factor.var'</code> if <code>NULL</code>).
</p>
</li>
<li> <p><code>factor.level</code>: A vector specifying the factor levels.
If <code>NULL</code>, levels are taken from <code>factor.dummy</code>.
If <code>factor.level</code> is provided, its length must match
<code>factor.dummy</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_funlist">funlist</code></td>
<td>
<p>A list (default <code>NULL</code>) specifying function names. This
is rarely needed, as required functions are typically retrieved
automatically. A use case for <code>funlist</code> is when <code>sigma_formula</code>,
<code>sigma_formula_gr</code>, or <code>sigma_formula_gr_str</code> use an external
function (e.g., <code>poly(age)</code>). The <code>funlist</code> should include
function names defined in the <code>globalenv()</code>. For functions needing
both distance and velocity curves (e.g., <code>plot_curves(..., opt =
  'dv')</code>), <code>funlist</code> must include two functions: one for the distance
curve and one for the velocity curve.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="marginal_draws.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>
function. Please see <code>brms::fitted.brmsfit()</code> for details on
various options available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>marginal_draws()</strong> function estimates fitted values (via
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code>) or the posterior draws from the posterior
distribution (via <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>) depending on the <code>type</code>
argument.
</p>


<h3>Value</h3>

<p>An array of predicted mean response values. See
<a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit</a> for details.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code>
<code><a href="marginaleffects.html#topic+predictions">marginaleffects::avg_predictions()</a></code>
<code><a href="marginaleffects.html#topic+plot_predictions">marginaleffects::plot_predictions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average distance curve
marginal_draws(model, deriv = 0, re_formula = NA)

# Individual-specific distance curves
marginal_draws(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
marginal_draws(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
marginal_draws(model, deriv = 1, re_formula = NULL)


</code></pre>

<hr>
<h2 id='optimize_model.bgmfit'>Optimize SITAR Model</h2><span id='topic+optimize_model.bgmfit'></span><span id='topic+optimize_model'></span>

<h3>Description</h3>

<p>The optimization process for selecting the best-fitting SITAR
model involves choosing the optimal degrees of freedom (<code>df</code>) for the
natural cubic spline curve, as well as determining the appropriate
transformations for the predictor (<code>x</code>) and/or outcome (<code>y</code>)
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
optimize_model(
  model,
  newdata = NULL,
  optimize_df = NULL,
  optimize_x = list(NULL, log, sqrt),
  optimize_y = list(NULL, log, sqrt),
  transform_prior_class = NULL,
  transform_beta_coef = NULL,
  transform_sd_coef = NULL,
  exclude_default_funs = TRUE,
  add_fit_criteria = NULL,
  byresp = FALSE,
  model_name = NULL,
  overwrite = FALSE,
  file = NULL,
  force_save = FALSE,
  save_each = FALSE,
  digits = 2,
  cores = 1,
  verbose = FALSE,
  expose_function = NULL,
  usesavedfuns = FALSE,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

optimize_model(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_model.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_optimize_df">optimize_df</code></td>
<td>
<p>A list of integers specifying the degrees of freedom
(<code>df</code>) values to be optimized. If <code>NULL</code> (default), the <code>df</code>
is taken from the original model. To optimize over different <code>df</code>
values, for example, <code>df</code> 4 and <code>df</code> 5, the corresponding code
would be <code>optimize_df = list(4, 5)</code>. For <code>univariate_by</code> and
<code>multivariate</code> models, <code>optimize_df</code> can be a single integer
(e.g., <code>optimize_df = 4</code>), a list (e.g., <code>optimize_df = list(4,
  5)</code>), or a list of lists. For instance, to optimize over <code>df</code> 4 and
<code>df</code> 5 for the first submodel, and <code>df</code> 5 and <code>df</code> 6 for the
second submodel, the corresponding code would be <code>optimize_df =
  list(list(4, 5), list(5, 6))</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_optimize_x">optimize_x</code></td>
<td>
<p>A list specifying the transformations for the predictor
variable (i.e., <code>x</code>). The available options are <code>NULL</code>,
<code>'log'</code>, <code>'sqrt'</code>, or their combinations. Note that the user need
not enclose these options in single or double quotes, as they are handled
internally. The default setting explores all possible combinations, i.e.,
<code>optimize_x = list(NULL, 'log', 'sqrt')</code>. Similar to
<code>optimize_df</code>, the user can specify different <code>optimize_x</code> values
for <code>univariate_by</code> and <code>multivariate</code> submodels. Additionally,
it is possible to pass any primitive function instead of fixed functions
like <code>log</code> and <code>sqrt</code>. This greatly enhances the flexibility of
model optimization by allowing the search for a wide range of <code>x</code>
transformations, such as <code>optimize_x = list(function(x) log(x +
  3/4))</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_optimize_y">optimize_y</code></td>
<td>
<p>A list specifying the transformations of the response
variable (i.e., <code>y</code>). The approach and available options for
<code>optimize_y</code> are the same as described above for <code>optimize_x</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_transform_prior_class">transform_prior_class</code></td>
<td>
<p>A character vector (default <code>NULL</code>)
specifying the parameter classes for which transformations of
user-specified priors should be performed. The prior classes that can be
transformed are <code>'beta'</code>, <code>'sd'</code>, <code>'rsd'</code>, <code>'sigma'</code>,
and <code>'dpar'</code>, and they can be specified as: <br />
<code>transform_prior_class = c('beta', 'sd', 'rsd', 'sigma', 'dpar')</code>.
Note that transformations can only be applied to location-scale based
priors (such as <code>normal()</code>). For example, the <code>'log'</code>
transformation of a prior is performed as follows: <br />
<code>log_location = log(location / sqrt(scale^2 / location^2 + 1))</code>, <br />
<code>log_scale = sqrt(log(scale^2 / location^2 + 1))</code>, <br /> where
<code>location</code> and <code>scale</code> are the original parameters supplied by
the user, and <code>log_location</code> and <code>log_scale</code> are the equivalent
parameters on the log scale. Note that <code>transform_prior_class</code> is used
on an experimental basis, and therefore the results may not be as intended.
We recommend explicitly setting the desired prior for the <code>y</code> scale.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_transform_beta_coef">transform_beta_coef</code></td>
<td>
<p>A character vector (default <code>NULL</code>)
specifying the regression coefficients for which transformations are
applied. The coefficients that can be transformed are <code>'a'</code>,
<code>'b'</code>, <code>'c'</code>, <code>'d'</code>, and <code>'s'</code>. The default is
<code>transform_beta_coef = c('b', 'c', 'd')</code>, which implies that the
parameters <code>'b'</code>, <code>'c'</code>, and <code>'d'</code> will be transformed,
while parameter <code>'a'</code> will be left unchanged because the default prior
for parameter <code>'a'</code> is based on the outcome <code>y</code> scale itself
(e.g., <code>a_prior_beta = normal(ymean, ysd)</code>), which gets transformed
automatically. Note that <code>transform_beta_coef</code> is ignored when
<code>transform_prior_class = NULL</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_transform_sd_coef">transform_sd_coef</code></td>
<td>
<p>A character vector (default <code>NULL</code>) specifying
the <code>sd</code> parameters for which transformations are applied. The
coefficients that can be transformed are <code>'a'</code>, <code>'b'</code>,
<code>'c'</code>, <code>'d'</code>, and <code>'s'</code>. The default is
<code>transform_sd_coef = c('b', 'c', 'd')</code>, which implies that the
parameters <code>'b'</code>, <code>'c'</code>, and <code>'d'</code> will be transformed,
while parameter <code>'a'</code> will be left unchanged because the default prior
for parameter <code>'a'</code> is based on the outcome <code>y</code> scale itself
(e.g., <code>a_prior_beta = normal(ymean, ysd)</code>), which gets transformed
automatically. Note that <code>transform_sd_coef</code> is ignored when
<code>transform_prior_class = NULL</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_exclude_default_funs">exclude_default_funs</code></td>
<td>
<p>A logical indicating whether transformations for
(<code>x</code> and <code>y</code>) variables used in the original model fit should be
excluded. If <code>TRUE</code> (default), the transformations specified for the
<code>x</code> and <code>y</code> variables in the original model fit are excluded from
<code>optimize_x</code> and <code>optimize_y</code>. For example, if the original model
is fit with <code>xvar = log</code> and <code>yvar = NULL</code>, then
<code>optimize_x</code> is translated into <code>optimize_x = list(NULL, sqrt)</code>,
and <code>optimize_y</code> is reset as <code>optimize_y = list(log, sqrt)</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_add_fit_criteria">add_fit_criteria</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to
indicate whether to add fit criteria to the returned model fit. Available
options are <code>'loo'</code>, <code>'waic'</code>, and <code>'bayes_R2'</code>. Please see
<code>[brms::add_criterion()]</code> for details.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_byresp">byresp</code></td>
<td>
<p>A logical (default <code>FALSE</code>) indicating whether
response-wise fit criteria should be calculated. This argument is evaluated
only for the <code>multivariate</code> model, where the user can select whether
to get a joint calculation of point-wise log likelihood (<code>byresp =
  FALSE</code>) or response-specific calculations (<code>byresp = TRUE</code>). For the
<code>univariate_by</code> model, the only available option is to calculate
separate point-wise log likelihood for each submodel, i.e., <code>byresp =
  TRUE</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_model_name">model_name</code></td>
<td>
<p>Optional name of the model. If <code>NULL</code>
(the default) the name is taken from the call to <code>x</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical; Indicates if already stored fit
indices should be overwritten. Defaults to <code>FALSE</code>.
Setting it to <code>TRUE</code> is useful for example when changing
additional arguments of an already stored criterion.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_file">file</code></td>
<td>
<p>Either <code>NULL</code> or a character string. In the latter case, the
fitted model object including the newly added criterion values is saved via
<code><a href="base.html#topic+saveRDS">saveRDS</a></code> in a file named after the string supplied in
<code>file</code>. The <code>.rds</code> extension is added automatically. If <code>x</code>
was already stored in a file before, the file name will be reused
automatically (with a message) unless overwritten by <code>file</code>. In any
case, <code>file</code> only applies if new criteria were actually added via
<code>add_criterion</code> or if <code>force_save</code> was set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_force_save">force_save</code></td>
<td>
<p>Logical; only relevant if <code>file</code> is specified and
ignored otherwise. If <code>TRUE</code>, the fitted model object will be saved
regardless of whether new criteria were added via <code>add_criterion</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_save_each">save_each</code></td>
<td>
<p>A logical (default <code>FALSE</code>) indicating whether to save
each model (as a <code>.rds</code> file) when running the loop. Note that the
user can also specify <code>save_each</code> as a named list to pass the
following information when saving each model: <br />
<code>'prefix'</code> a character string (default <code>NULL</code>), <br />
<code>'suffix'</code> a character string (default <code>NULL</code>), <br />
<code>'extension'</code> a character string, either <code>.rds</code> or
<code>.RData</code> (default <code>.rds</code>), <br />
<code>'compress'</code> a character string, either <code>'xz'</code>, <code>'gzip'</code>, or
<code>'bzip2'</code> (default <code>'xz'</code>). These options are set as follows: <br />
<code>save_each = list(prefix = '', suffix = '', extension = 'rds',
  compress = 'xz')</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) to set the decimal places for
rounding the results using the <code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use in parallel processing (default
<code>1</code>). The argument <code>cores</code> is passed to
<code>[brms::add_criterion()]</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="optimize_model.bgmfit_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+update_model">update_model</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the optimized models of class <code>bgmfit</code>, and
the the summary statistics if <code>add_fit_criteria</code> are specified.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+add_criterion">brms::add_criterion()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid model estimation, which takes time, the Bayesian SITAR model fit  
# to the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether the model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# The following example shows a dummy call for optimization to save time. 
# Note that if the degree of freedom, and both the \code{optimize_x} and 
# \code{optimize_y} are \code{NULL} (i.e., nothing to optimize), the original 
# model object is returned.   
# To explicitly check whether the model is being optimized or not, 
# the user can set \code{verbose = TRUE}. This is useful for getting
# information about what arguments have changed compared to the 
# original model.

model2 &lt;- optimize_model(model, 
  optimize_df = NULL, 
  optimize_x = NULL, 
  optimize_y = NULL,
  verbose = TRUE)



</code></pre>

<hr>
<h2 id='plot_conditional_effects.bgmfit'>Visualize conditional effects of predictor</h2><span id='topic+plot_conditional_effects.bgmfit'></span><span id='topic+plot_conditional_effects'></span>

<h3>Description</h3>

<p>Display conditional effects of one or more numeric and/or categorical
predictors including two-way interaction effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
plot_conditional_effects(
  model,
  effects = NULL,
  conditions = NULL,
  int_conditions = NULL,
  re_formula = NA,
  spaghetti = FALSE,
  surface = FALSE,
  categorical = FALSE,
  ordinal = FALSE,
  method = "posterior_epred",
  transform = NULL,
  resolution = 100,
  select_points = 0,
  too_far = 0,
  prob = 0.95,
  robust = TRUE,
  newdata = NULL,
  ndraws = NULL,
  dpar = NULL,
  draw_ids = NULL,
  levels_id = NULL,
  resp = NULL,
  ipts = 10,
  deriv = 0,
  deriv_model = NULL,
  idata_method = NULL,
  verbose = FALSE,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  funlist = NULL,
  envir = NULL,
  ...
)

plot_conditional_effects(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_effects">effects</code></td>
<td>
<p>An optional character vector naming effects (main effects or
interactions) for which to compute conditional plots. Interactions are
specified by a <code>:</code> between variable names. If <code>NULL</code> (the
default), plots are generated for all main effects and two-way interactions
estimated in the model. When specifying <code>effects</code> manually, <em>all</em>
two-way interactions (including grouping variables) may be plotted
even if not originally modeled.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_conditions">conditions</code></td>
<td>
<p>An optional <code>data.frame</code> containing variable values
to condition on. Each effect defined in <code>effects</code> will
be plotted separately for each row of <code>conditions</code>. Values in the
<code>cond__</code> column will be used as titles of the subplots. If <code>cond__</code>
is not given, the row names will be used for this purpose instead.
It is recommended to only define a few rows in order to keep the plots clear.
See <code><a href="brms.html#topic+make_conditions">make_conditions</a></code> for an easy way to define conditions.
If <code>NULL</code> (the default), numeric variables will be conditionalized by
using their means and factors will get their first level assigned.
<code>NA</code> values within factors are interpreted as if all dummy
variables of this factor are zero. This allows, for instance, to make
predictions of the grand mean when using sum coding.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_int_conditions">int_conditions</code></td>
<td>
<p>An optional named <code>list</code> whose elements are
vectors of values of the variables specified in <code>effects</code>.
At these values, predictions are evaluated. The names of
<code>int_conditions</code> have to match the variable names exactly.
Additionally, the elements of the vectors may be named themselves,
in which case their names appear as labels for the conditions in the plots.
Instead of vectors, functions returning vectors may be passed and are
applied on the original values of the corresponding variable.
If <code>NULL</code> (the default), predictions are evaluated at the
<code class="reqn">mean</code> and at <code class="reqn">mean +/- sd</code> for numeric predictors and at
all categories for factor-like predictors.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>A formula containing group-level effects to be considered
in the conditional predictions. If <code>NULL</code>, include all group-level
effects; if <code>NA</code> (default), include no group-level effects.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_spaghetti">spaghetti</code></td>
<td>
<p>Logical. Indicates if predictions should
be visualized via spaghetti plots. Only applied for numeric
predictors. If <code>TRUE</code>, it is recommended
to set argument <code>ndraws</code> to a relatively small value
(e.g., <code>100</code>) in order to reduce computation time.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_surface">surface</code></td>
<td>
<p>Logical. Indicates if interactions or
two-dimensional smooths should be visualized as a surface.
Defaults to <code>FALSE</code>. The surface type can be controlled
via argument <code>stype</code> of the related plotting method.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_categorical">categorical</code></td>
<td>
<p>Logical. Indicates if effects of categorical
or ordinal models should be shown in terms of probabilities
of response categories. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_ordinal">ordinal</code></td>
<td>
<p>(Deprecated) Please use argument <code>categorical</code>.
Logical. Indicates if effects in ordinal models
should be visualized as a raster with the response categories
on the y-axis. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_method">method</code></td>
<td>
<p>Method used to obtain predictions. Can be set to
<code>"posterior_epred"</code> (the default), <code>"posterior_predict"</code>,
or <code>"posterior_linpred"</code>. For more details, see the respective
function documentations.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_transform">transform</code></td>
<td>
<p>A function or a character string naming
a function to be applied on the predicted responses
before summary statistics are computed. Only allowed
if <code>method = "posterior_predict"</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_resolution">resolution</code></td>
<td>
<p>Number of support points used to generate
the plots. Higher resolution leads to smoother plots.
Defaults to <code>100</code>. If <code>surface</code> is <code>TRUE</code>,
this implies <code>10000</code> support points for interaction terms,
so it might be necessary to reduce <code>resolution</code>
when only few RAM is available.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_select_points">select_points</code></td>
<td>
<p>Positive number.
Only relevant if <code>points</code> or <code>rug</code> are set to <code>TRUE</code>:
Actual data points of numeric variables that
are too far away from the values specified in <code>conditions</code>
can be excluded from the plot. Values are scaled into
the unit interval and then points more than <code>select_points</code>
from the values in <code>conditions</code> are excluded.
By default, all points are used.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_too_far">too_far</code></td>
<td>
<p>Positive number.
For surface plots only: Grid points that are too
far away from the actual data points can be excluded from the plot.
<code>too_far</code> determines what is too far. The grid is scaled into
the unit square and then grid points more than <code>too_far</code>
from the predictor variables are excluded. By default, all
grid points are used. Ignored for non-surface plots.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_prob">prob</code></td>
<td>
<p>A value between 0 and 1 indicating the desired probability
to be covered by the uncertainty intervals. The default is 0.95.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_robust">robust</code></td>
<td>
<p>If <code>TRUE</code> (the default) the median is used as the
measure of central tendency. If <code>FALSE</code> the mean is used instead.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for the
hierarchical model (default <code>NULL</code>). It is used only when the model is
applied to data with three or more levels of hierarchy. For a two-level
model, <code>levels_id</code> is automatically inferred from the model fit. For
models with three or more levels, <code>levels_id</code> is inferred from the
model fit under the assumption that hierarchy is specified from the lowest
to the uppermost level, i.e., <code>id</code> followed by <code>study</code>, where
<code>id</code> is nested within <code>study</code>. However, it is not guaranteed that
<code>levels_id</code> is sorted correctly, so it is better to set it manually
when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the response
variable when processing posterior draws for <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable for
generating a smooth velocity curve. If <code>NULL</code>, the original values are
returned. If an integer (e.g., <code>ipts = 10</code>, default), the predictor is
interpolated. Note that these interpolations do not alter the range of the
predictor when calculating population averages and/or individual-specific
growth curves.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>An integer indicating whether to estimate the distance curve
or its derivative (velocity curve). The default <code>deriv = 0</code> is for
the distance curve, while <code>deriv = 1</code> is for the velocity curve.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of interpolation points is set by the <code>ipts</code> argument.
Available options for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>).
</p>

<ul>
<li> <p><em>Method 1</em> (<code>'m1'</code>) is adapted from the <span class="pkg">iapvbs</span> package
and is documented
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">here</a>.
</p>
</li>
<li> <p><em>Method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span> package
and is documented
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">here</a>.
The <code>'m1'</code> method works by internally constructing the data frame
based on the model configuration, while the <code>'m2'</code> method uses the
exact data frame from the model fit, accessible via <code>fit$data</code>. If
<code>idata_method = NULL</code> (default), method <code>'m2'</code> is automatically
selected. Note that method <code>'m1'</code> may fail in certain cases,
especially when the model includes covariates (particularly in
<code>univariate_by</code> models). In such cases, it is recommended to use
method <code>'m2'</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) to convert dummy
variables into a factor variable. The list must include the following
elements:
</p>

<ul>
<li> <p><code>factor.dummy</code>: A character vector of dummy variables to be
converted to factors.
</p>
</li>
<li> <p><code>factor.name</code>: The name for the newly created factor variable
(default is <code>'factor.var'</code> if <code>NULL</code>).
</p>
</li>
<li> <p><code>factor.level</code>: A vector specifying the factor levels.
If <code>NULL</code>, levels are taken from <code>factor.dummy</code>.
If <code>factor.level</code> is provided, its length must match
<code>factor.dummy</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_funlist">funlist</code></td>
<td>
<p>A list (default <code>NULL</code>) specifying function names. This
is rarely needed, as required functions are typically retrieved
automatically. A use case for <code>funlist</code> is when <code>sigma_formula</code>,
<code>sigma_formula_gr</code>, or <code>sigma_formula_gr_str</code> use an external
function (e.g., <code>poly(age)</code>). The <code>funlist</code> should include
function names defined in the <code>globalenv()</code>. For functions needing
both distance and velocity curves (e.g., <code>plot_curves(..., opt =
  'dv')</code>), <code>funlist</code> must include two functions: one for the distance
curve and one for the velocity curve.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="plot_conditional_effects.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code>
function. Please see <code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>plot_conditional_effects()</strong> is a wrapper around the
<code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code>. The <code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code> function
from the <span class="pkg">brms</span> package can be used to plot the fitted (distance) curve
when response (e.g., height) is not transformed. However, when the outcome
is log or square root transformed, the <code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code> will
return the fitted curve on the log or square root scale, whereas the
<strong>plot_conditional_effects()</strong> will return the fitted curve on the
original scale. Furthermore, the <strong>plot_conditional_effects()</strong> also
plots the velocity curve on the original scale after making the required
back-transformation. Apart from these differences, both these functions
(<a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects</a> and <strong>plot_conditional_effects()</strong>) work
in the same manner. In other words, the user can specify all the arguments
which are available in the <code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>'brms_conditional_effects'</code>, which is a
named list with one data.frame per effect containing all information
required to generate conditional effects plots. See
<code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+conditional_effects.brmsfit">brms::conditional_effects()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average distance curve
plot_conditional_effects(model, deriv = 0, re_formula = NA)

# Individual-specific distance curves
plot_conditional_effects(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
plot_conditional_effects(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
plot_conditional_effects(model, deriv = 1, re_formula = NULL)


</code></pre>

<hr>
<h2 id='plot_curves.bgmfit'>Plot Growth Curves</h2><span id='topic+plot_curves.bgmfit'></span><span id='topic+plot_curves'></span>

<h3>Description</h3>

<p>The <strong>plot_curves()</strong> function visualizes six different
types of growth curves using the <span class="pkg">ggplot2</span> package. Additionally, it
allows users to create customized plots from the data returned as a
<code>data.frame</code>. For an alternative approach, the <code><a href="#topic+marginal_draws">marginal_draws()</a></code>
function can be used, which not only estimates adjusted curves but also
enables comparison across groups using the <code>hypotheses</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
plot_curves(
  model,
  opt = "dv",
  apv = FALSE,
  bands = NULL,
  conf = 0.95,
  resp = NULL,
  dpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  newdata = NULL,
  summary = FALSE,
  digits = 2,
  re_formula = NULL,
  numeric_cov_at = NULL,
  aux_variables = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  ipts = 10,
  deriv_model = TRUE,
  xrange = NULL,
  xrange_search = NULL,
  takeoff = FALSE,
  trough = FALSE,
  acgv = FALSE,
  acgv_velocity = 0.1,
  seed = 123,
  estimation_method = "fitted",
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty",
  incl_autocor = TRUE,
  robust = FALSE,
  transform = NULL,
  future = FALSE,
  future_session = "multisession",
  cores = NULL,
  trim = 0,
  layout = "single",
  linecolor = NULL,
  linecolor1 = NULL,
  linecolor2 = NULL,
  label.x = NULL,
  label.y = NULL,
  legendpos = NULL,
  linetype.apv = NULL,
  linewidth.main = NULL,
  linewidth.apv = NULL,
  linetype.groupby = NA,
  color.groupby = NA,
  band.alpha = NULL,
  show_age_takeoff = TRUE,
  show_age_peak = TRUE,
  show_age_cessation = TRUE,
  show_vel_takeoff = FALSE,
  show_vel_peak = FALSE,
  show_vel_cessation = FALSE,
  returndata = FALSE,
  returndata_add_parms = FALSE,
  parms_eval = FALSE,
  idata_method = NULL,
  parms_method = "getPeak",
  verbose = FALSE,
  fullframe = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  funlist = NULL,
  envir = NULL,
  ...
)

plot_curves(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_curves.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_opt">opt</code></td>
<td>
<p>A character string containing one or more of the following
plotting options:
</p>

<ul>
<li><p> 'd': Population average distance curve
</p>
</li>
<li><p> 'v': Population average velocity curve
</p>
</li>
<li><p> 'D': Individual-specific distance curves
</p>
</li>
<li><p> 'V': Individual-specific velocity curves
</p>
</li>
<li><p> 'u': Unadjusted individual-specific distance curves
</p>
</li>
<li><p> 'a': Adjusted individual-specific distance curves (adjusted for
random effects)
</p>
</li></ul>

<p>Note that 'd' and 'D' cannot be specified simultaneously, nor can 'v' and
'V'. Other combinations are allowed, e.g., 'dvau', 'Dvau', 'dVau', etc.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_apv">apv</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) indicating whether to
calculate and plot the age at peak velocity (APGV) when <code>opt</code> includes
'v' or 'V'.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_bands">bands</code></td>
<td>
<p>A character string containing one or more of the following
options, or <code>NULL</code> (default), indicating if CI bands should be plotted
around the curves:
</p>

<ul>
<li><p> 'd': Band around the distance curve
</p>
</li>
<li><p> 'v': Band around the velocity curve
</p>
</li>
<li><p> 'p': Band around the vertical line denoting the APGV parameter
</p>
</li></ul>

<p>The <code>'dvp'</code> option will include CI bands for distance and velocity
curves, and the APGV.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_conf">conf</code></td>
<td>
<p>A numeric value (default <code>0.95</code>) specifying the confidence
interval (CI) level for the bands. See <code><a href="#topic+growthparameters">growthparameters()</a></code> for
more details.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the response
variable when processing posterior draws for <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_summary">summary</code></td>
<td>
<p>A logical value indicating whether only the estimate should be
computed (<code>TRUE</code>), or whether the estimate along with SE and CI should
be returned (<code>FALSE</code>, default). Setting <code>summary</code> to <code>FALSE</code>
will increase computation time. Note that <code>summary = FALSE</code> is
required to obtain correct estimates when <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_digits">digits</code></td>
<td>
<p>An integer (default <code>2</code>) to set the decimal places for
rounding the results using the <code><a href="base.html#topic+Round">base::round()</a></code> function.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include
individual/group-level effects in the estimation. When <code>NA</code> (default),
individual-level effects are excluded, and population average growth
parameters are computed. When <code>NULL</code>, individual-level effects are
included in the computation, and the resulting growth parameters are
individual-specific. In both cases (<code>NA</code> or <code>NULL</code>), continuous
and factor covariates are appropriately included in the estimation.
Continuous covariates are set to their means by default (see
<code>numeric_cov_at</code> for details), while factor covariates remain
unaltered, allowing for the estimation of covariate-specific population
average and individual-specific growth parameters.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option sets the
continuous covariate(s) to their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate variable 'xx' to 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariates are
included in the model.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify variables passed to the
<code>ipts</code> argument, useful when fitting location-scale or measurement
error models.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for the
hierarchical model (default <code>NULL</code>). It is used only when the model is
applied to data with three or more levels of hierarchy. For a two-level
model, <code>levels_id</code> is automatically inferred from the model fit. For
models with three or more levels, <code>levels_id</code> is inferred from the
model fit under the assumption that hierarchy is specified from the lowest
to the uppermost level, i.e., <code>id</code> followed by <code>study</code>, where
<code>id</code> is nested within <code>study</code>. However, it is not guaranteed that
<code>levels_id</code> is sorted correctly, so it is better to set it manually
when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters, such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically a
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and <code>reby</code> (typically <code>NULL</code>, indicating that
parameters are integrated over the random effects). For example,
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable for
generating a smooth velocity curve. If <code>NULL</code>, the original values are
returned. If an integer (e.g., <code>ipts = 10</code>, default), the predictor is
interpolated. Note that these interpolations do not alter the range of the
predictor when calculating population averages and/or individual-specific
growth curves.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (e.g., age) when
executing the interpolation via <code>ipts</code>. By default, <code>NULL</code> sets
the individual-specific predictor range. Setting <code>xrange = 1</code> applies
the same range for individuals within the same higher grouping variable
(e.g., study). Setting <code>xrange = 2</code> applies an identical range across
the entire sample. Alternatively, a numeric vector (e.g., <code>xrange =
  c(6, 20)</code>) can be provided to set the range within the specified values.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_xrange_search">xrange_search</code></td>
<td>
<p>A vector of length two or a character string
<code>'range'</code> to set the range of the predictor variable (<code>x</code>) within
which growth parameters are searched. This is useful when there is more
than one peak and the user wants to summarize the peak within a specified
range of the <code>x</code> variable. The default value is <code>xrange_search =
  NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_takeoff">takeoff</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) indicating whether to
calculate the age at takeoff velocity (ATGV) and the takeoff growth
velocity (TGV) parameters.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_trough">trough</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) indicating whether to
calculate the age at cessation of growth velocity (ACGV) and the cessation
of growth velocity (CGV) parameters.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_acgv">acgv</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) indicating whether to
calculate the age at cessation of growth velocity from the velocity curve.
If <code>TRUE</code>, the age at cessation of growth velocity (ACGV) and the
cessation growth velocity (CGV) are calculated based on the percentage of
the peak growth velocity, as defined by the <code>acgv_velocity</code> argument
(see below). The <code>acgv_velocity</code> is typically set at 10 percent of the
peak growth velocity. ACGV and CGV are calculated along with the
uncertainty (SE and CI) around the ACGV and CGV parameters.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_acgv_velocity">acgv_velocity</code></td>
<td>
<p>The percentage of the peak growth velocity to use when
estimating <code>acgv</code>. The default value is <code>0.10</code>, i.e., 10 percent
of the peak growth velocity.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_seed">seed</code></td>
<td>
<p>An integer (default <code>123</code>) that is passed to the estimation
method to ensure reproducibility.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_estimation_method">estimation_method</code></td>
<td>
<p>A character string specifying the estimation method
when calculating the velocity from the posterior draws. The <code>'fitted'</code>
method internally calls <code><a href="#topic+fitted_draws">fitted_draws()</a></code>, while the
<code>'predict'</code> method calls <code><a href="#topic+predict_draws">predict_draws()</a></code>. See
<code><a href="brms.html#topic+fitted.brmsfit">brms::fitted.brmsfit()</a></code> and <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_robust">robust</code></td>
<td>
<p>A logical value to specify the summary options. If <code>FALSE</code>
(default), the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If <code>TRUE</code>, the
median and median absolute deviation (MAD) are applied instead. Ignored if
<code>summary</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_transform">transform</code></td>
<td>
<p>A function applied to individual draws from the posterior
distribution before computing summaries. The argument <code>transform</code> is
based on the <code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> function. This should not be
confused with <code>transform</code> from <code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>, which is
now deprecated.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_future">future</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) to specify whether or
not to perform parallel computations. If set to <code>TRUE</code>, the
<code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code> function is used to summarize the posterior
draws in parallel.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_future_session">future_session</code></td>
<td>
<p>A character string specifying the session type when
<code>future = TRUE</code>. The <code>'multisession'</code> (default) option sets the
multisession environment, while the <code>'multicore'</code> option sets up a
multicore session. Note that <code>'multicore'</code> is not supported on Windows
systems. For more details, see <code><a href="future.apply.html#topic+future_lapply">future.apply::future_sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used for parallel computations if
<code>future = TRUE</code>. On non-Windows systems, this argument can be set
globally via the <code>mc.cores</code> option. By default, <code>NULL</code>, the
number of cores is automatically determined using
<code><a href="future.html#topic+re-exports">future::availableCores()</a></code>, and it will use the maximum number of cores
available minus one (i.e., <code>future::availableCores() - 1</code>).</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_trim">trim</code></td>
<td>
<p>A numeric value (default <code>0</code>) indicating the number of long
line segments to be excluded from the plot when the option 'u' or 'a' is
selected. See <a href="sitar.html#topic+plot.sitar">sitar::plot.sitar</a> for further details.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_layout">layout</code></td>
<td>
<p>A character string defining the plot layout. The default
<code>'single'</code> layout overlays distance and velocity curves on a single
plot when <code>opt</code> includes combinations like <code>'dv'</code>, <code>'Dv'</code>,
<code>'dV'</code>, or <code>'DV'</code>. The alternative layout option <code>'facet'</code>
uses <code>facet_wrap</code> from <span class="pkg">ggplot2</span> to map and draw plots when
<code>opt</code> includes two or more letters.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linecolor">linecolor</code></td>
<td>
<p>The color of the lines when the layout is <code>'facet'</code>.
The default is <code>NULL</code>, which sets the line color to <code>'grey50'</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linecolor1">linecolor1</code></td>
<td>
<p>The color of the first line when the layout is
<code>'single'</code>. For example, in <code>opt = 'dv'</code>, the distance line is
controlled by <code>linecolor1</code>. The default <code>NULL</code> sets
<code>linecolor1</code> to <code>'orange2'</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linecolor2">linecolor2</code></td>
<td>
<p>The color of the second line when the layout is
<code>'single'</code>. For example, in <code>opt = 'dv'</code>, the velocity line is
controlled by <code>linecolor2</code>. The default <code>NULL</code> sets
<code>linecolor2</code> to <code>'green4'</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_label.x">label.x</code></td>
<td>
<p>An optional character string to label the x-axis. If
<code>NULL</code> (default), the x-axis label will be taken from the predictor
(e.g., age).</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_label.y">label.y</code></td>
<td>
<p>An optional character string to label the y-axis. If
<code>NULL</code> (default), the y-axis label will be taken from the plot type
(e.g., distance, velocity). When <code>layout = 'facet'</code>, the label is
removed, and the same label is used as the title.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_legendpos">legendpos</code></td>
<td>
<p>A character string to specify the position of the legend. If
<code>NULL</code> (default), the legend position is set to 'bottom' for distance
and velocity curves in the <code>'single'</code> layout. For individual-specific
curves, the legend position is set to <code>'none'</code> to suppress the legend.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linetype.apv">linetype.apv</code></td>
<td>
<p>A character string to specify the type of the vertical
line marking the APGV. Default <code>NULL</code> sets the linetype to
<code>dotted</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linewidth.main">linewidth.main</code></td>
<td>
<p>A numeric value to specify the line width for distance
and velocity curves. The default <code>NULL</code> sets the width to 0.35.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linewidth.apv">linewidth.apv</code></td>
<td>
<p>A numeric value to specify the width of the vertical
line marking the APGV. The default <code>NULL</code> sets the width to 0.25.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_linetype.groupby">linetype.groupby</code></td>
<td>
<p>A character string specifying the line type for
distance and velocity curves when drawing plots for a model with factor
covariates or individual-specific curves. The default is <code>NA</code>, which
sets the line type to 'solid' and suppresses legends.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_color.groupby">color.groupby</code></td>
<td>
<p>A character string specifying the line color for
distance and velocity curves when drawing plots for a model with factor
covariates or individual-specific curves. The default is <code>NA</code>, which
suppresses legends.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_band.alpha">band.alpha</code></td>
<td>
<p>A numeric value to specify the transparency of the CI bands
around the curves. The default <code>NULL</code> sets the transparency to 0.4.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_age_takeoff">show_age_takeoff</code></td>
<td>
<p>A logical value (default <code>TRUE</code>) to indicate
whether to display the ATGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_age_peak">show_age_peak</code></td>
<td>
<p>A logical value (default <code>TRUE</code>) to indicate
whether to display the APGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_age_cessation">show_age_cessation</code></td>
<td>
<p>A logical value (default <code>TRUE</code>) to indicate
whether to display the ACGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_vel_takeoff">show_vel_takeoff</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) to indicate
whether to display the TGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_vel_peak">show_vel_peak</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) to indicate
whether to display the PGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_show_vel_cessation">show_vel_cessation</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) to indicate
whether to display the CGV line(s) on the plot.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_returndata">returndata</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) to indicate whether
to plot the data or return it as a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_returndata_add_parms">returndata_add_parms</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) to specify
whether to add growth parameters to the returned <code>data.frame</code>. Ignored
when <code>returndata = FALSE</code>. Growth parameters are added when the
<code>opt</code> argument includes 'v' or 'V' and <code>apv = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_parms_eval">parms_eval</code></td>
<td>
<p>A logical value to specify whether or not to compute growth
parameters on the fly. This is for internal use only and is mainly needed
for compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of interpolation points is set by the <code>ipts</code> argument.
Available options for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>).
</p>

<ul>
<li> <p><em>Method 1</em> (<code>'m1'</code>) is adapted from the <span class="pkg">iapvbs</span> package
and is documented
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">here</a>.
</p>
</li>
<li> <p><em>Method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span> package
and is documented
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">here</a>.
The <code>'m1'</code> method works by internally constructing the data frame
based on the model configuration, while the <code>'m2'</code> method uses the
exact data frame from the model fit, accessible via <code>fit$data</code>. If
<code>idata_method = NULL</code> (default), method <code>'m2'</code> is automatically
selected. Note that method <code>'m1'</code> may fail in certain cases,
especially when the model includes covariates (particularly in
<code>univariate_by</code> models). In such cases, it is recommended to use
method <code>'m2'</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_parms_method">parms_method</code></td>
<td>
<p>A character string specifying the method used when
evaluating <code>parms_eval</code>. The default method is <code>getPeak</code>, which
uses the <code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code> function from the <code>sitar</code> package.
Alternatively, <code>findpeaks</code> uses the <code>findpeaks</code> function from the
<code>pracma</code> package. This parameter is for internal use and ensures
compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_fullframe">fullframe</code></td>
<td>
<p>A logical value indicating whether to return a
<code>fullframe</code> object in which <code>newdata</code> is bound to the summary
estimates. Note that <code>fullframe</code> cannot be used with <code>summary =
  FALSE</code>, and it is only applicable when <code>idata_method = 'm2'</code>. A
typical use case is when fitting a <code>univariate_by</code> model. This option
is mainly for internal use.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) to convert dummy
variables into a factor variable. The list must include the following
elements:
</p>

<ul>
<li> <p><code>factor.dummy</code>: A character vector of dummy variables to be
converted to factors.
</p>
</li>
<li> <p><code>factor.name</code>: The name for the newly created factor variable
(default is <code>'factor.var'</code> if <code>NULL</code>).
</p>
</li>
<li> <p><code>factor.level</code>: A vector specifying the factor levels.
If <code>NULL</code>, levels are taken from <code>factor.dummy</code>.
If <code>factor.level</code> is provided, its length must match
<code>factor.dummy</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_funlist">funlist</code></td>
<td>
<p>A list (default <code>NULL</code>) specifying function names. This
is rarely needed, as required functions are typically retrieved
automatically. A use case for <code>funlist</code> is when <code>sigma_formula</code>,
<code>sigma_formula_gr</code>, or <code>sigma_formula_gr_str</code> use an external
function (e.g., <code>poly(age)</code>). The <code>funlist</code> should include
function names defined in the <code>globalenv()</code>. For functions needing
both distance and velocity curves (e.g., <code>plot_curves(..., opt =
  'dv')</code>), <code>funlist</code> must include two functions: one for the distance
curve and one for the velocity curve.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="plot_curves.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>brms::fitted.brmsfit()</code>
and <code>brms::predict()</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>plot_curves()</strong> function is a generic tool for
visualizing the following six curves:
</p>

<ul>
<li><p> Population average distance curve
</p>
</li>
<li><p> Population average velocity curve
</p>
</li>
<li><p> Individual-specific distance curves
</p>
</li>
<li><p> Individual-specific velocity curves
</p>
</li>
<li><p> Unadjusted individual growth curves (i.e., observed growth curves)
</p>
</li>
<li><p> Adjusted individual growth curves (adjusted for the model-estimated
random effects)
</p>
</li></ul>

<p>Internally, <strong>plot_curves()</strong> calls the <code><a href="#topic+growthparameters">growthparameters()</a></code> function
to estimate and summarize the distance and velocity curves, as well as to
compute growth parameters such as the age at peak growth velocity (APGV).
The function also calls <code><a href="#topic+fitted_draws">fitted_draws()</a></code> or <code><a href="#topic+predict_draws">predict_draws()</a></code> to make
inferences based on posterior draws. As a result, <strong>plot_curves()</strong>
can plot either fitted or predicted curves. For more details, see
<code><a href="#topic+fitted_draws">fitted_draws()</a></code> and <code><a href="#topic+predict_draws">predict_draws()</a></code> to understand the difference between
fitted and predicted values.
</p>


<h3>Value</h3>

<p>A plot object (default) or a <code>data.frame</code> when <code>returndata
  = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+growthparameters">growthparameters()</a></code> <code><a href="#topic+fitted_draws">fitted_draws()</a></code> <code><a href="#topic+predict_draws">predict_draws()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model is fit to 
# the 'berkeley_exdata' and saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether the model fit object 'berkeley_exfit' exists
berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average distance and velocity curves with default options
plot_curves(model, opt = 'dv')

# Individual-specific distance and velocity curves with default options
# Note that \code{legendpos = 'none'} will suppress the legend positions. 
# This suppression is useful when plotting individual-specific curves

plot_curves(model, opt = 'DV')

# Population average distance and velocity curves with APGV

plot_curves(model, opt = 'dv', apv = TRUE)

# Individual-specific distance and velocity curves with APGV

plot_curves(model, opt = 'DV', apv = TRUE)

# Population average distance curve, velocity curve, and APGV with CI bands
# To construct CI bands, growth parameters are first calculated for each  
# posterior draw and then summarized across draws. Therefore,summary 
# option must be set to FALSE

plot_curves(model, opt = 'dv', apv = TRUE, bands = 'dvp', summary = FALSE)

# Adjusted and unadjusted individual curves
# Note ipts = NULL (i.e., no interpolation of predictor (i.e., age) to plot a 
# smooth curve). This is because it does not a make sense to interploate data 
# when estimating adjusted curves. Also, layout = 'facet' (and not default 
# layout = 'single') is used for the ease of visualizing the plotted 
# adjusted and unadjusted individual curves. However, these lines can be 
# superimposed on each other by setting the set layout = 'single'.
# For other plots shown above, layout can be set as 'single' or 'facet'

# Separate plots for adjusted and unadjusted curves (layout = 'facet')
plot_curves(model, opt = 'au', ipts = NULL, layout = 'facet')

# Superimposed adjusted and unadjusted curves (layout = 'single')
plot_curves(model, opt = 'au', ipts = NULL, layout = 'single')



</code></pre>

<hr>
<h2 id='plot_ppc.bgmfit'>Perform posterior predictive distribution checks</h2><span id='topic+plot_ppc.bgmfit'></span><span id='topic+plot_ppc'></span>

<h3>Description</h3>

<p>Perform posterior predictive checks with the help
of the <span class="pkg">bayesplot</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
plot_ppc(
  model,
  type,
  ndraws = NULL,
  dpar = NULL,
  draw_ids = NULL,
  prefix = c("ppc", "ppd"),
  group = NULL,
  x = NULL,
  newdata = NULL,
  resp = NULL,
  size = 0.25,
  alpha = 0.7,
  trim = FALSE,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n_dens = 1024,
  pad = TRUE,
  discrete = FALSE,
  binwidth = NULL,
  bins = NULL,
  breaks = NULL,
  freq = TRUE,
  y_draw = c("violin", "points", "both"),
  y_size = 1,
  y_alpha = 1,
  y_jitter = 0.1,
  verbose = FALSE,
  deriv_model = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  envir = NULL,
  ...
)

plot_ppc(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ppc.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_type">type</code></td>
<td>
<p>Type of the ppc plot as given by a character string.
See <code><a href="bayesplot.html#topic+PPC-overview">PPC</a></code> for an overview
of currently supported types. You may also use an invalid
type (e.g. <code>type = "xyz"</code>) to get a list of supported
types in the resulting error message.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_prefix">prefix</code></td>
<td>
<p>The prefix of the <span class="pkg">bayesplot</span> function to be applied.
Either '&quot;ppc&quot;' (posterior predictive check; the default)
or '&quot;ppd&quot;' (posterior predictive distribution), the latter being the same
as the former except that the observed data is not shown for '&quot;ppd&quot;'.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_group">group</code></td>
<td>
<p>Optional name of a factor variable in the model
by which to stratify the ppc plot. This argument is required for
ppc <code>*_grouped</code> types and ignored otherwise.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_x">x</code></td>
<td>
<p>Optional name of a variable in the model.
Only used for ppc types having an <code>x</code> argument
and ignored otherwise.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the response
variable when processing posterior draws for <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_size">size</code>, <code id="plot_ppc.bgmfit_+3A_alpha">alpha</code></td>
<td>
<p>Passed to the appropriate geom to control the appearance of
the predictive distributions.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_trim">trim</code></td>
<td>
<p>A logical scalar passed to <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_bw">bw</code>, <code id="plot_ppc.bgmfit_+3A_adjust">adjust</code>, <code id="plot_ppc.bgmfit_+3A_kernel">kernel</code>, <code id="plot_ppc.bgmfit_+3A_n_dens">n_dens</code></td>
<td>
<p>Optional arguments passed to
<code><a href="stats.html#topic+density">stats::density()</a></code> to override default kernel density estimation
parameters. <code>n_dens</code> defaults to <code>1024</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_pad">pad</code></td>
<td>
<p>A logical scalar passed to <code><a href="ggplot2.html#topic+stat_ecdf">ggplot2::stat_ecdf()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_discrete">discrete</code></td>
<td>
<p>For <code>ppc_ecdf_overlay()</code>, should the data be treated as
discrete? The default is <code>FALSE</code>, in which case <code>geom="line"</code> is
passed to <code><a href="ggplot2.html#topic+stat_ecdf">ggplot2::stat_ecdf()</a></code>. If <code>discrete</code> is set to
<code>TRUE</code> then <code>geom="step"</code> is used.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_binwidth">binwidth</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_bins">bins</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> to override
the default binwidth.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code> as an
alternative to <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_freq">freq</code></td>
<td>
<p>For histograms, <code>freq=TRUE</code> (the default) puts count on the
y-axis. Setting <code>freq=FALSE</code> puts density on the y-axis. (For many
plots the y-axis text is off by default. To view the count or density
labels on the y-axis see the <code><a href="bayesplot.html#topic+yaxis_text">yaxis_text()</a></code> convenience
function.)</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_y_draw">y_draw</code></td>
<td>
<p>For <code>ppc_violin_grouped()</code>, a string specifying how to draw
<code>y</code>: <code>"violin"</code> (default), <code>"points"</code> (jittered points), or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_y_jitter">y_jitter</code>, <code id="plot_ppc.bgmfit_+3A_y_size">y_size</code>, <code id="plot_ppc.bgmfit_+3A_y_alpha">y_alpha</code></td>
<td>
<p>For <code>ppc_violin_grouped()</code>, if <code>y_draw</code> is
<code>"points"</code> or <code>"both"</code> then <code>y_size</code>, <code>y_alpha</code>, and <code>y_jitter</code> are passed
to to the <code>size</code>, <code>alpha</code>, and <code>width</code> arguments of <code><a href="ggplot2.html#topic+geom_jitter">ggplot2::geom_jitter()</a></code>
to control the appearance of <code>y</code> points. The default of <code>y_jitter=NULL</code>
will let <strong>ggplot2</strong> determine the amount of jitter.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) to convert dummy
variables into a factor variable. The list must include the following
elements:
</p>

<ul>
<li> <p><code>factor.dummy</code>: A character vector of dummy variables to be
converted to factors.
</p>
</li>
<li> <p><code>factor.name</code>: The name for the newly created factor variable
(default is <code>'factor.var'</code> if <code>NULL</code>).
</p>
</li>
<li> <p><code>factor.level</code>: A vector specifying the factor levels.
If <code>NULL</code>, levels are taken from <code>factor.dummy</code>.
If <code>factor.level</code> is provided, its length must match
<code>factor.dummy</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="plot_ppc.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+pp_check.brmsfit">brms::pp_check.brmsfit()</a></code>
function. Please refer to <code><a href="brms.html#topic+pp_check.brmsfit">brms::pp_check.brmsfit()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>plot_ppc()</strong> function is a wrapper around the
<code><a href="brms.html#topic+pp_check.brmsfit">brms::pp_check()</a></code> function, which allows for the visualization of
posterior predictive checks.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object that can be further customized using the
<span class="pkg">ggplot2</span> package.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid mode estimation, which takes time, the Bayesian SITAR model is fit to 
# the 'berkeley_exdata' and saved as an example fit ('berkeley_exfit').
# See the 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether the model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

plot_ppc(model, ndraws = 100)


</code></pre>

<hr>
<h2 id='predict_draws.bgmfit'>Predicted values from the posterior predictive distribution</h2><span id='topic+predict_draws.bgmfit'></span><span id='topic+predict_draws'></span>

<h3>Description</h3>

<p>The <strong>predict_draws()</strong> function is a wrapper around the
<code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> function, which obtains predicted values (and
their summary) from the posterior distribution. See
<code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
predict_draws(
  model,
  newdata = NULL,
  resp = NULL,
  dpar = NULL,
  ndraws = NULL,
  draw_ids = NULL,
  re_formula = NA,
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty",
  incl_autocor = TRUE,
  numeric_cov_at = NULL,
  levels_id = NULL,
  avg_reffects = NULL,
  aux_variables = NULL,
  ipts = 10,
  deriv = 0,
  deriv_model = TRUE,
  summary = TRUE,
  robust = FALSE,
  transform = NULL,
  probs = c(0.025, 0.975),
  xrange = NULL,
  xrange_search = NULL,
  parms_eval = FALSE,
  parms_method = "getPeak",
  idata_method = NULL,
  verbose = FALSE,
  fullframe = NULL,
  dummy_to_factor = NULL,
  expose_function = FALSE,
  usesavedfuns = NULL,
  clearenvfuns = NULL,
  funlist = NULL,
  envir = NULL,
  ...
)

predict_draws(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_draws.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for estimation. If <code>NULL</code>
(default), <code>newdata</code> is retrieved from the <code>model</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_resp">resp</code></td>
<td>
<p>A character string (default <code>NULL</code>) to specify the response
variable when processing posterior draws for <code>univariate_by</code> and
<code>multivariate</code> models. See <code><a href="#topic+bsitar">bsitar()</a></code> for details on
<code>univariate_by</code> and <code>multivariate</code> models.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_dpar">dpar</code></td>
<td>
<p>Optional name of a predicted distributional parameter.
If specified, expected predictions of this parameters are returned.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_ndraws">ndraws</code></td>
<td>
<p>A positive integer indicating the number of posterior draws to
use in estimation. If <code>NULL</code> (default), all draws are used.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_draw_ids">draw_ids</code></td>
<td>
<p>An integer specifying the specific posterior draw(s) to use
in estimation (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_re_formula">re_formula</code></td>
<td>
<p>Option to indicate whether or not to include
individual/group-level effects in the estimation. When <code>NA</code> (default),
individual-level effects are excluded, and population average growth
parameters are computed. When <code>NULL</code>, individual-level effects are
included in the computation, and the resulting growth parameters are
individual-specific. In both cases (<code>NA</code> or <code>NULL</code>), continuous
and factor covariates are appropriately included in the estimation.
Continuous covariates are set to their means by default (see
<code>numeric_cov_at</code> for details), while factor covariates remain
unaltered, allowing for the estimation of covariate-specific population
average and individual-specific growth parameters.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>A flag indicating if new levels of group-level
effects are allowed (defaults to <code>FALSE</code>). Only relevant if
<code>newdata</code> is provided.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>Indicates how to sample new levels for grouping
factors specified in <code>re_formula</code>. This argument is only relevant if
<code>newdata</code> is provided and <code>allow_new_levels</code> is set to
<code>TRUE</code>. If <code>"uncertainty"</code> (default), each posterior sample for a
new level is drawn from the posterior draws of a randomly chosen existing
level. Each posterior sample for a new level may be drawn from a different
existing level such that the resulting set of new posterior draws
represents the variation across existing levels. If <code>"gaussian"</code>,
sample new levels from the (multivariate) normal distribution implied by the
group-level standard deviations and correlations. This options may be useful
for conducting Bayesian power analysis or predicting new levels in
situations where relatively few levels where observed in the old_data. If
<code>"old_levels"</code>, directly sample new levels from the existing levels,
where a new level is assigned all of the posterior draws of the same
(randomly chosen) existing level.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_incl_autocor">incl_autocor</code></td>
<td>
<p>A flag indicating if correlation structures originally
specified via <code>autocor</code> should be included in the predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_numeric_cov_at">numeric_cov_at</code></td>
<td>
<p>An optional (named list) argument to specify the value
of continuous covariate(s). The default <code>NULL</code> option sets the
continuous covariate(s) to their mean. Alternatively, a named list can be
supplied to manually set these values. For example, <code>numeric_cov_at =
  list(xx = 2)</code> will set the continuous covariate variable 'xx' to 2. The
argument <code>numeric_cov_at</code> is ignored when no continuous covariates are
included in the model.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_levels_id">levels_id</code></td>
<td>
<p>An optional argument to specify the <code>ids</code> for the
hierarchical model (default <code>NULL</code>). It is used only when the model is
applied to data with three or more levels of hierarchy. For a two-level
model, <code>levels_id</code> is automatically inferred from the model fit. For
models with three or more levels, <code>levels_id</code> is inferred from the
model fit under the assumption that hierarchy is specified from the lowest
to the uppermost level, i.e., <code>id</code> followed by <code>study</code>, where
<code>id</code> is nested within <code>study</code>. However, it is not guaranteed that
<code>levels_id</code> is sorted correctly, so it is better to set it manually
when fitting a model with three or more levels of hierarchy.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_avg_reffects">avg_reffects</code></td>
<td>
<p>An optional argument (default <code>NULL</code>) to calculate
(marginal/average) curves and growth parameters, such as APGV and PGV. If
specified, it must be a named list indicating the <code>over</code> (typically a
level 1 predictor, such as age), <code>feby</code> (fixed effects, typically a
factor variable), and <code>reby</code> (typically <code>NULL</code>, indicating that
parameters are integrated over the random effects). For example,
<code>avg_reffects = list(feby = 'study', reby = NULL, over = 'age')</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_aux_variables">aux_variables</code></td>
<td>
<p>An optional argument to specify the variable(s) that can
be passed to the <code>ipts</code> argument (see below). This is useful when
fitting location-scale models and measurement error models. If
post-processing functions throw an error such as <code>variable 'x' not
  found in either 'data' or 'data2'</code>, consider using <code>aux_variables</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_ipts">ipts</code></td>
<td>
<p>An integer to set the length of the predictor variable for
generating a smooth velocity curve. If <code>NULL</code>, the original values are
returned. If an integer (e.g., <code>ipts = 10</code>, default), the predictor is
interpolated. Note that these interpolations do not alter the range of the
predictor when calculating population averages and/or individual-specific
growth curves.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_deriv">deriv</code></td>
<td>
<p>An integer indicating whether to estimate the distance curve
or its derivative (velocity curve). The default <code>deriv = 0</code> is for
the distance curve, while <code>deriv = 1</code> is for the velocity curve.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_deriv_model">deriv_model</code></td>
<td>
<p>A logical value specifying whether to estimate the
velocity curve from the derivative function or by differentiating the
distance curve. Set <code>deriv_model = TRUE</code> for functions that require
the velocity curve, such as <code>growthparameters()</code> and
<code>plot_curves()</code>. Set it to <code>NULL</code> for functions that use the
distance curve (i.e., fitted values), such as <code>loo_validation()</code> and
<code>plot_ppc()</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_summary">summary</code></td>
<td>
<p>A logical value indicating whether only the estimate should be
computed (<code>TRUE</code>), or whether the estimate along with SE and CI should
be returned (<code>FALSE</code>, default). Setting <code>summary</code> to <code>FALSE</code>
will increase computation time. Note that <code>summary = FALSE</code> is
required to obtain correct estimates when <code>re_formula = NULL</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_robust">robust</code></td>
<td>
<p>A logical value to specify the summary options. If <code>FALSE</code>
(default), the mean is used as the measure of central tendency and the
standard deviation as the measure of variability. If <code>TRUE</code>, the
median and median absolute deviation (MAD) are applied instead. Ignored if
<code>summary</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_transform">transform</code></td>
<td>
<p>A function applied to individual draws from the posterior
distribution before computing summaries. The argument <code>transform</code> is
based on the <code><a href="marginaleffects.html#topic+predictions">marginaleffects::predictions()</a></code> function. This should not be
confused with <code>transform</code> from <code><a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict()</a></code>, which is
now deprecated.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_xrange">xrange</code></td>
<td>
<p>An integer to set the predictor range (e.g., age) when
executing the interpolation via <code>ipts</code>. By default, <code>NULL</code> sets
the individual-specific predictor range. Setting <code>xrange = 1</code> applies
the same range for individuals within the same higher grouping variable
(e.g., study). Setting <code>xrange = 2</code> applies an identical range across
the entire sample. Alternatively, a numeric vector (e.g., <code>xrange =
  c(6, 20)</code>) can be provided to set the range within the specified values.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_xrange_search">xrange_search</code></td>
<td>
<p>A vector of length two or a character string
<code>'range'</code> to set the range of the predictor variable (<code>x</code>) within
which growth parameters are searched. This is useful when there is more
than one peak and the user wants to summarize the peak within a specified
range of the <code>x</code> variable. The default value is <code>xrange_search =
  NULL</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_parms_eval">parms_eval</code></td>
<td>
<p>A logical value to specify whether or not to compute growth
parameters on the fly. This is for internal use only and is mainly needed
for compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_parms_method">parms_method</code></td>
<td>
<p>A character string specifying the method used when
evaluating <code>parms_eval</code>. The default method is <code>getPeak</code>, which
uses the <code><a href="sitar.html#topic+getPeakTrough">sitar::getPeak()</a></code> function from the <code>sitar</code> package.
Alternatively, <code>findpeaks</code> uses the <code>findpeaks</code> function from the
<code>pracma</code> package. This parameter is for internal use and ensures
compatibility across internal functions.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_idata_method">idata_method</code></td>
<td>
<p>A character string to indicate the interpolation method.
The number of interpolation points is set by the <code>ipts</code> argument.
Available options for <code>idata_method</code> are <em>method 1</em> (specified as
<code>'m1'</code>) and <em>method 2</em> (specified as <code>'m2'</code>).
</p>

<ul>
<li> <p><em>Method 1</em> (<code>'m1'</code>) is adapted from the <span class="pkg">iapvbs</span> package
and is documented
<a href="https://rdrr.io/github/Zhiqiangcao/iapvbs/src/R/exdata.R">here</a>.
</p>
</li>
<li> <p><em>Method 2</em> (<code>'m2'</code>) is based on the <span class="pkg">JMbayes</span> package
and is documented
<a href="https://github.com/drizopoulos/JMbayes/blob/master/R/dynPred_lme.R">here</a>.
The <code>'m1'</code> method works by internally constructing the data frame
based on the model configuration, while the <code>'m2'</code> method uses the
exact data frame from the model fit, accessible via <code>fit$data</code>. If
<code>idata_method = NULL</code> (default), method <code>'m2'</code> is automatically
selected. Note that method <code>'m1'</code> may fail in certain cases,
especially when the model includes covariates (particularly in
<code>univariate_by</code> models). In such cases, it is recommended to use
method <code>'m2'</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_fullframe">fullframe</code></td>
<td>
<p>A logical value indicating whether to return a
<code>fullframe</code> object in which <code>newdata</code> is bound to the summary
estimates. Note that <code>fullframe</code> cannot be used with <code>summary =
  FALSE</code>, and it is only applicable when <code>idata_method = 'm2'</code>. A
typical use case is when fitting a <code>univariate_by</code> model. This option
is mainly for internal use.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_dummy_to_factor">dummy_to_factor</code></td>
<td>
<p>A named list (default <code>NULL</code>) to convert dummy
variables into a factor variable. The list must include the following
elements:
</p>

<ul>
<li> <p><code>factor.dummy</code>: A character vector of dummy variables to be
converted to factors.
</p>
</li>
<li> <p><code>factor.name</code>: The name for the newly created factor variable
(default is <code>'factor.var'</code> if <code>NULL</code>).
</p>
</li>
<li> <p><code>factor.level</code>: A vector specifying the factor levels.
If <code>NULL</code>, levels are taken from <code>factor.dummy</code>.
If <code>factor.level</code> is provided, its length must match
<code>factor.dummy</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_usesavedfuns">usesavedfuns</code></td>
<td>
<p>A logical value (default <code>NULL</code>) indicating whether
to use already exposed and saved Stan functions. This is typically set
automatically based on the <code>expose_functions</code> argument from the
<code><a href="#topic+bsitar">bsitar()</a></code> call. Manual specification of <code>usesavedfuns</code> is rarely
needed and is intended for internal testing, as improper use can lead to
unreliable estimates.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_clearenvfuns">clearenvfuns</code></td>
<td>
<p>A logical value indicating whether to clear the exposed
Stan functions from the environment (<code>TRUE</code>) or not (<code>FALSE</code>). If
<code>NULL</code>, <code>clearenvfuns</code> is set based on the value of
<code>usesavedfuns</code>: <code>TRUE</code> if <code>usesavedfuns = TRUE</code>, or
<code>FALSE</code> if <code>usesavedfuns = FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_funlist">funlist</code></td>
<td>
<p>A list (default <code>NULL</code>) specifying function names. This
is rarely needed, as required functions are typically retrieved
automatically. A use case for <code>funlist</code> is when <code>sigma_formula</code>,
<code>sigma_formula_gr</code>, or <code>sigma_formula_gr_str</code> use an external
function (e.g., <code>poly(age)</code>). The <code>funlist</code> should include
function names defined in the <code>globalenv()</code>. For functions needing
both distance and velocity curves (e.g., <code>plot_curves(..., opt =
  'dv')</code>), <code>funlist</code> must include two functions: one for the distance
curve and one for the velocity curve.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="predict_draws.bgmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>
function. Please see <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> for details on the various
options available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>predict_draws()</strong> function computes the fitted values
from the posterior distribution. The <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> function
from the <span class="pkg">brms</span> package can be used to obtain predicted (distance)
values when the outcome (e.g., height) is untransformed. However, when the
outcome is log or square root transformed, the <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>
function will return the fitted curve on the log or square root scale. In
contrast, the <strong>predict_draws()</strong> function returns the fitted values
on the original scale. Furthermore, <strong>predict_draws()</strong> also computes
the first derivative (velocity), again on the original scale, after making
the necessary back-transformation. Aside from these differences, both
functions (<code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code> and <strong>predict_draws()</strong>) work
similarly. In other words, the user can specify all the options available
in <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>.
</p>


<h3>Value</h3>

<p>An array of predicted response values. See <code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>
for details.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+predict.brmsfit">brms::predict.brmsfit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model

# To avoid mode estimation, which takes time, the Bayesian SITAR model is fit 
# to the 'berkeley_exdata' and saved as an example fit ('berkeley_exfit').
# See the 'bsitar' function for details on 'berkeley_exdata' and 
# berkeley_exfit'.

# Check and confirm whether the model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Population average distance curve
predict_draws(model, deriv = 0, re_formula = NA)

# Individual-specific distance curves
predict_draws(model, deriv = 0, re_formula = NULL)

# Population average velocity curve
predict_draws(model, deriv = 1, re_formula = NA)

# Individual-specific velocity curves
predict_draws(model, deriv = 1, re_formula = NULL)
 
 
</code></pre>

<hr>
<h2 id='update_model.bgmfit'>Update model</h2><span id='topic+update_model.bgmfit'></span><span id='topic+update_model'></span>

<h3>Description</h3>

<p>The <strong>update_model()</strong> function is a wrapper around the
<code>update()</code> function from the <span class="pkg">brms</span> package, which refits the model
based on the user-specified updated arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgmfit'
update_model(
  model,
  newdata = NULL,
  recompile = NULL,
  expose_function = FALSE,
  verbose = FALSE,
  check_newargs = FALSE,
  envir = NULL,
  ...
)

update_model(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_model.bgmfit_+3A_model">model</code></td>
<td>
<p>An object of class <code>bgmfit</code>.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_newdata">newdata</code></td>
<td>
<p>An optional <code>data.frame</code> to be used when updating the
model. If <code>NULL</code> (default), the data used in the original model fit is
reused. Note that data-dependent default priors are not automatically updated.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_recompile">recompile</code></td>
<td>
<p>A logical value indicating whether the Stan model should be
recompiled. When <code>NULL</code> (default), <strong>update_model()</strong> tries to
internally determine whether recompilation is required. Setting
<code>recompile</code> to <code>FALSE</code> will ignore any changes in the Stan code.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_expose_function">expose_function</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to indicate
whether Stan functions should be exposed. If <code>TRUE</code>, any Stan
functions exposed during the model fit using <code>expose_function = TRUE</code>
in the <code><a href="#topic+bsitar">bsitar()</a></code> function are saved and can be used in post-processing. By
default, <code>expose_function = FALSE</code> in post-processing functions,
except in <code><a href="#topic+optimize_model">optimize_model()</a></code> where it is set to <code>NULL</code>. If
<code>NULL</code>, the setting is inherited from the original model fit. It must
be set to <code>TRUE</code> when adding <code>fit criteria</code> or <code>bayes_R2</code>
during model optimization.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument (default <code>FALSE</code>) to specify whether
to print information collected during the setup of the object(s).</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_check_newargs">check_newargs</code></td>
<td>
<p>A logical value (default <code>FALSE</code>) indicating whether
to check if the arguments in the original <code>model</code> fit and the
<code>update_model</code> are identical. When <code>check_newargs = TRUE</code> and the
arguments are identical, it indicates that an update is unnecessary. In this
case, the original <code>model</code> object is returned, along with a message if
<code>verbose = TRUE</code>.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_envir">envir</code></td>
<td>
<p>The environment used for function evaluation. The default is
<code>NULL</code>, which sets the environment to <code>parent.frame()</code>. Since
most post-processing functions rely on <span class="pkg">brms</span>, it is recommended to set
<code>envir = globalenv()</code> or <code>envir = .GlobalEnv</code>, especially for
derivatives like velocity curves.</p>
</td></tr>
<tr><td><code id="update_model.bgmfit_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>[brms::brm()]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an adapted version of the <strong>update()</strong> function
from the <span class="pkg">brms</span> package.
</p>


<h3>Value</h3>

<p>An updated object of class <code>brmsfit</code>.
</p>


<h3>Author(s)</h3>

<p>Satpal Sandhu  <a href="mailto:satpal.sandhu@bristol.ac.uk">satpal.sandhu@bristol.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Fit Bayesian SITAR model 

# To avoid mode estimation which takes time, the Bayesian SITAR model fit to 
# the 'berkeley_exdata' has been saved as an example fit ('berkeley_exfit').
# See 'bsitar' function for details on 'berkeley_exdata' and 'berkeley_exfit'.

# Check and confirm whether model fit object 'berkeley_exfit' exists
 berkeley_exfit &lt;- getNsObject(berkeley_exfit)

model &lt;- berkeley_exfit

# Update model
# Note that in case all arguments supplied to the update_model() call are 
# same as the original model fit (checked via check_newargs = TRUE), then  
# original model object is returned.   
# To explicitly get this information whether model is being updated or not, 
# user can set verbose = TRUE. The verbose = TRUE also useful in getting the
# information regarding what all arguments have been changed as compared to
# the original model.

model2 &lt;- update_model(model, df = 5, check_newargs = TRUE, verbose = TRUE)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
