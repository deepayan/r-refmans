<!DOCTYPE html><html><head><title>Help for package ROptEst</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ROptEst}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ROptEst-package'>
<p>Optimally robust estimation</p></a></li>
<li><a href='#asAnscombe'><p>Generating function for asAnscombe-class</p></a></li>
<li><a href='#asAnscombe-class'><p>Asymptotic Anscombe risk</p></a></li>
<li><a href='#asL1'><p>Generating function for asMSE-class</p></a></li>
<li><a href='#asL1-class'><p>Asymptotic mean absolute error</p></a></li>
<li><a href='#asL4'><p>Generating function for asL4-class</p></a></li>
<li><a href='#asL4-class'><p>Asymptotic mean power 4 error</p></a></li>
<li><a href='#checkIC-methods'><p>Methods for Checking and Making ICs</p></a></li>
<li><a href='#cniperCont'><p> Functions for Computation and Plot of Cniper Contamination</p>
and Cniper Points.</a></li>
<li><a href='#CniperPointPlot'><p>Wrapper function for cniperPointPlot - Computation and Plot</p>
of Cniper Contamination and Cniper Points</a></li>
<li><a href='#comparePlot-methods'><p>Compare - Plots</p></a></li>
<li><a href='#get.asGRisk.fct-methods'><p>Methods for Function get.asGRisk.fct in Package &lsquo;ROptEst&rsquo;</p></a></li>
<li><a href='#getAsRisk'><p>Generic Function for Computation of Asymptotic Risks</p></a></li>
<li><a href='#getBiasIC'><p>Generic function for the computation of the asymptotic bias for an IC</p></a></li>
<li><a href='#getFixClip'><p>Generic Function for the Computation of the Optimal Clipping Bound</p></a></li>
<li><a href='#getFixRobIC'><p> Generic Function for the Computation of Optimally Robust ICs</p></a></li>
<li><a href='#getIneffDiff'><p>Generic Function for the Computation of Inefficiency Differences</p></a></li>
<li><a href='#getInfCent'><p>Generic Function for the Computation of the Optimal Centering Constant/Lower Clipping Bound</p></a></li>
<li><a href='#getInfClip'><p>Generic Function for the Computation of the Optimal Clipping Bound</p></a></li>
<li><a href='#getInfGamma'><p>Generic Function for the Computation of the Optimal Clipping Bound</p></a></li>
<li><a href='#getInfLM'><p>Functions to determine Lagrange multipliers</p></a></li>
<li><a href='#getInfRad'><p>Generic Function for the Computation of the Optimal Radius for Given Clipping Bound</p></a></li>
<li><a href='#getInfRobIC'><p> Generic Function for the Computation of Optimally Robust ICs</p></a></li>
<li><a href='#getInfStand'><p> Generic Function for the Computation of the Standardizing Matrix</p></a></li>
<li><a href='#getInfV'><p>Generic Function for the Computation of the asymptotic Variance of a Hampel type IC</p></a></li>
<li><a href='#getL1normL2deriv'><p>Calculation of L1 norm of L2derivative</p></a></li>
<li><a href='#getL2normL2deriv'><p>Calculation of L2 norm of L2derivative</p></a></li>
<li><a href='#getMaxIneff'><p>getMaxIneff &ndash; computation of the maximal inefficiency of an IC</p></a></li>
<li><a href='#getModifyIC'><p>Generic Function for the Computation of Functions for Slot modifyIC</p></a></li>
<li><a href='#getRadius'><p>Computation of the Optimal Radius for Given Clipping Bound</p></a></li>
<li><a href='#getReq'><p>getReq &ndash; computation of the radius interval where IC1 is better than IC2.</p></a></li>
<li><a href='#getRiskFctBV-methods'><p>Methods for Function getRiskFctBV  in Package &lsquo;ROptEst&rsquo;</p></a></li>
<li><a href='#getRiskIC'><p>Generic function for the computation of a risk for an IC</p></a></li>
<li><a href='#getStartIC-methods'><p>Methods for Function getStartIC in Package &lsquo;ROptEst&rsquo;</p></a></li>
<li><a href='#inputGenerators'><p>Input generating functions for function 'robest'</p></a></li>
<li><a href='#internal_interpolate_helpers'><p>Internal helper functions for generating interpolation grids for</p>
speed up in package ROptEst</a></li>
<li><a href='#internals_for_MBRE_computation'><p>Internal / Helper function of package ROptEst for MBRE calculation</p></a></li>
<li><a href='#internals_for_ROptEst'><p>Internal / Helper functions of package ROptEst</p></a></li>
<li><a href='#internals_for_ROptEst_Cniperplots'><p>Internal / Helper functions of package ROptEst for cniper plot functions</p></a></li>
<li><a href='#internals_for_ROptEst_robest'><p>Internal / Helper functions of package ROptEst for function robest</p></a></li>
<li><a href='#leastFavorableRadius'><p>Generic Function for the Computation of Least Favorable Radii</p></a></li>
<li><a href='#lowerCaseRadius'><p>Computation of the lower case radius</p></a></li>
<li><a href='#minmaxBias'><p> Generic Function for the Computation of Bias-Optimally Robust ICs</p></a></li>
<li><a href='#optIC'><p>Generic function for the computation of optimally robust ICs</p></a></li>
<li><a href='#optRisk'><p>Generic function for the computation of the minimal risk</p></a></li>
<li><a href='#ORobEstimate-class'><p>ORobEstimate-class.</p></a></li>
<li><a href='#plot-methods'><p> Methods for Function plot in Package &lsquo;ROptEst&rsquo;</p></a></li>
<li><a href='#radiusMinimaxIC'><p>Generic function for the computation of the radius minimax IC</p></a></li>
<li><a href='#RMXEOMSEMBREOBRE'><p> Optimally robust estimation: RMXE, OMSE, MBRE, and OBRE</p></a></li>
<li><a href='#robest'><p> Optimally robust estimation</p></a></li>
<li><a href='#roptest'><p> Optimally robust estimation</p></a></li>
<li><a href='#updateNorm-methods'><p> Methods for Function updateNorm in Package &lsquo;ROptEst&rsquo;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimally Robust Estimation</td>
</tr>
<tr>
<td>Description:</td>
<td>R infrastructure for optimally robust estimation in general smoothly
            parameterized models using S4 classes and methods as decribed Kohl, M.,
            Ruckdeschel, P., and Rieder, H. (2010), &lt;<a href="https://doi.org/10.1007%2Fs10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>&gt;, and in
            Rieder, H., Kohl, M., and Ruckdeschel, P. (2008), &lt;<a href="https://doi.org/10.1007%2Fs10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4), methods, distr(&ge; 2.8.0), distrEx(&ge; 2.8.0),
distrMod(&ge; 2.8.1), RandVar(&ge; 1.2.0), RobAStBase(&ge; 1.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>startupmsg, MASS, stats, graphics, utils, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RobLox</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://robast.r-forge.r-project.org/">http://robast.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LastChangedDate:</td>
<td>{$LastChangedDate: 2024-02-06 23:02:35 +0100 (Di, 06.
Feb 2024) $}</td>
</tr>
<tr>
<td>LastChangedRevision:</td>
<td>{$LastChangedRevision: 1287 $}</td>
</tr>
<tr>
<td>VCS/SVNRevision:</td>
<td>1286</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 06:57:08 UTC; kohlm</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl <a href="https://orcid.org/0000-0001-9514-8910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, cph],
  Mykhailo Pupashenko [ctb] (contributed wrapper functions for diagnostic
    plots),
  Gerald Kroisandt [ctb] (contributed testing routines),
  Peter Ruckdeschel <a href="https://orcid.org/0000-0001-7815-4809"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kohl &lt;Matthias.Kohl@stamats.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-07 11:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ROptEst-package'>
Optimally robust estimation
</h2><span id='topic+ROptEst-package'></span><span id='topic+ROptEst'></span>

<h3>Description</h3>

<p>Optimally robust estimation in general smoothly parameterized models 
using S4 classes and methods.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ROptEst </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3.3 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-07 </td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.4), methods, distr(&gt;= 2.8.0), distrEx(&gt;= 2.8.0), distrMod(&gt;= 2.8.1),RandVar(&gt;= 1.2.0), RobAStBase(&gt;= 1.2.0) </td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> RobLox </td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> startupmsg, MASS, stats, graphics, utils, grDevices </td>
</tr>
<tr>
 <td style="text-align: left;">
ByteCompile: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> latin1 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://robast.r-forge.r-project.org/</td>
</tr>
<tr>
 <td style="text-align: left;">
VCS/SVNRevision: </td><td style="text-align: left;"> 1286 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Package versions</h3>

<p>Note: The first two numbers of package versions do not necessarily reflect
package-individual development, but rather are chosen for the
RobAStXXX family as a whole in order to ease updating &quot;depends&quot;
information.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br />
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a><br />
Maintainer: Matthias Kohl  <a href="mailto:matthias.kohl@stamats.de">matthias.kohl@stamats.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
H. Rieder (1994): Robust Asymptotic Statistics. Springer. 
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>
H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of Not Knowing the Radius.
Statistical Methods and Applications  <em>17</em>(1): 13-40. <a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>
P. Ruckdeschel (2005). Optimally One-Sided Bounded Influence Curves.
Mathematical Methods of Statistics <em>14</em>(1), 105-131.
P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code><a href="distr.html#topic+0distr-package">distr-package</a></code>, 
<code><a href="distrEx.html#topic+0distrEx-package">distrEx-package</a></code>,
<code><a href="distrMod.html#topic+0distrMod-package">distrMod-package</a></code>, 
<code><a href="RandVar.html#topic+0RandVar-package">RandVar-package</a></code>,
<code><a href="RobAStBase.html#topic+0RobAStBase-package">RobAStBase-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## don't test to reduce check time on CRAN

library(ROptEst)
## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
x &lt;- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532), 
       rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27), 
       rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))
## ML-estimate from package distrMod
MLest &lt;- MLEstimator(x, PoisFamily())
MLest
## confidence interval based on CLT
confint(MLest)
## compute optimally (w.r.t to MSE) robust estimator (unknown contamination)
robEst &lt;- roptest(x, PoisFamily(), eps.upper = 0.1, steps = 3)
estimate(robEst)
## check influence curve
pIC(robEst)
checkIC(pIC(robEst))
## plot influence curve
plot(pIC(robEst))
## confidence interval based on LAN - neglecting bias
confint(robEst)
## confidence interval based on LAN - including bias
confint(robEst, method = symmetricBias())

</code></pre>

<hr>
<h2 id='asAnscombe'>Generating function for asAnscombe-class</h2><span id='topic+asAnscombe'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"asAnscombe"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asAnscombe(eff = .95, biastype = symmetricBias(), normtype = NormType())</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asAnscombe_+3A_eff">eff</code></td>
<td>
<p> value in (0,1]: ARE in the ideal model </p>
</td></tr>
<tr><td><code id="asAnscombe_+3A_biastype">biastype</code></td>
<td>
<p> a bias type of class <code>BiasType</code></p>
</td></tr>
<tr><td><code id="asAnscombe_+3A_normtype">normtype</code></td>
<td>
<p> a norm type of class <code>NormType</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>asAnscombe</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@fraunhofer.itwm.de">peter.ruckdeschel@fraunhofer.itwm.de</a></p>


<h3>References</h3>

<p>F.J. Anscombe (1960). Rejection of Outliers. Technometrics <em>2</em>(2): 123-146.
<a href="https://doi.org/10.1080/00401706.1960.10489888">doi:10.1080/00401706.1960.10489888</a>.
</p>
<p>F. Hampel et al. (1986). <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
<a href="https://doi.org/10.1002/9781118186435">doi:10.1002/9781118186435</a>.
</p>
<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness.</em>
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder (1994). <em>Robust Asymptotic Statistics.</em> Springer. 
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asAnscombe-class">asAnscombe-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asAnscombe()

## The function is currently defined as
function(eff = .95, biastype = symmetricBias(), normtype = NormType()){ 
    new("asAnscombe", eff = eff, biastype = biastype, normtype = normtype) }
</code></pre>

<hr>
<h2 id='asAnscombe-class'>Asymptotic Anscombe risk</h2><span id='topic+asAnscombe-class'></span><span id='topic+eff'></span><span id='topic+eff+2CasAnscombe-method'></span><span id='topic+show+2CasAnscombe-method'></span>

<h3>Description</h3>

<p>Class of asymptotic Anscombe risk which is
the ARE (asymptotic relative efficiency) in the ideal model
obtained by an optimal bias robust IC . </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("asAnscombe", ...)</code>.
More frequently they are created via the generating function 
<code>asAnscombe</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>: 
&ldquo;optimal bias robust IC (OBRI) for given ARE (asymptotic relative efficiency)&rdquo;. </p>
</dd>
<dt><code>eff</code></dt><dd><p>Object of class <code>"numeric"</code>: 
given ARE (asymptotic relative efficiency) to be attained in the ideal model. </p>
</dd>
<dt><code>biastype</code></dt><dd><p>Object of class <code>"BiasType"</code>: 
symmetric, one-sided or asymmetric </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asRiskwithBias"</code>, directly.<br />
Class <code>"asRisk"</code>, by class <code>"asRiskwithBias"</code>.
Class <code>"RiskType"</code>, by class <code>"asRisk"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>eff</dt><dd><p><code>signature(object = "asAnscombe")</code>: 
accessor function for slot <code>eff</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "asAnscombe")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@fraunhofer.itwm.de">peter.ruckdeschel@fraunhofer.itwm.de</a></p>


<h3>References</h3>

<p>F.J. Anscombe (1960). Rejection of Outliers. Technometrics <em>2</em>(2): 123-146.
<a href="https://doi.org/10.1080/00401706.1960.10489888">doi:10.1080/00401706.1960.10489888</a>.
</p>
<p>F. Hampel et al. (1986). <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
<a href="https://doi.org/10.1002/9781118186435">doi:10.1002/9781118186435</a>.
</p>
<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness.</em>
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder (1994). <em>Robust Asymptotic Statistics.</em> Springer. 
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+asRisk-class">asRisk-class</a></code>, <code><a href="#topic+asAnscombe">asAnscombe</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("asAnscombe")
</code></pre>

<hr>
<h2 id='asL1'>Generating function for asMSE-class</h2><span id='topic+asL1'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"asMSE"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asL1(biastype = symmetricBias(), normtype = NormType())</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asL1_+3A_biastype">biastype</code></td>
<td>
<p>a bias type of class <code>BiasType</code></p>
</td></tr>
<tr><td><code id="asL1_+3A_normtype">normtype</code></td>
<td>
<p> a norm type of class <code>NormType</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"asMSE"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

 
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asL1-class">asL1-class</a></code>, <code><a href="distrMod.html#topic+asMSE">asMSE</a></code>, <code><a href="#topic+asL4">asL4</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asL1()

## The function is currently defined as
function(biastype = symmetricBias(), normtype = NormType()){ 
         new("asL1", biastype = biastype, normtype = normtype) }
</code></pre>

<hr>
<h2 id='asL1-class'>Asymptotic mean absolute error</h2><span id='topic+asL1-class'></span>

<h3>Description</h3>

<p>Class of asymptotic mean absolute error.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("asL1", ...)</code>.
More frequently they are created via the generating function 
<code>asL1</code>.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>: 
&ldquo;asymptotic mean square error&rdquo;. </p>
</dd>
<dt><code>biastype</code></dt><dd><p>Object of class <code>"BiasType"</code>: 
symmetric, one-sided or asymmetric </p>
</dd>
<dt><code>normtype</code></dt><dd><p>Object of class <code>"NormType"</code>: 
norm in which a multivariate parameter is considered</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asGRisk"</code>, directly.<br />
Class <code>"asRiskwithBias"</code>, by class <code>"asGRisk"</code>.<br />
Class <code>"asRisk"</code>, by class <code>"asRiskwithBias"</code>.<br />
Class <code>"RiskType"</code>, by class <code>"asGRisk"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;asL1&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+asGRisk-class">asGRisk-class</a></code>, <code><a href="distrMod.html#topic+asMSE">asMSE</a></code>, <code><a href="distrMod.html#topic+asMSE-class">asMSE-class</a></code>, <code><a href="#topic+asL4-class">asL4-class</a></code>, <code><a href="#topic+asL1">asL1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("asMSE")
</code></pre>

<hr>
<h2 id='asL4'>Generating function for asL4-class</h2><span id='topic+asL4'></span>

<h3>Description</h3>

<p>Generates an object of class <code>"asL4"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asL4(biastype = symmetricBias(), normtype = NormType())</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asL4_+3A_biastype">biastype</code></td>
<td>
<p>a bias type of class <code>BiasType</code></p>
</td></tr>
<tr><td><code id="asL4_+3A_normtype">normtype</code></td>
<td>
<p> a norm type of class <code>NormType</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"asL4"</code></p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

 
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asL4-class">asL4-class</a></code>, <code><a href="distrMod.html#topic+asMSE">asMSE</a></code>, <code><a href="#topic+asL1">asL1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asL4()

## The function is currently defined as
function(biastype = symmetricBias(), normtype = NormType()){ 
         new("asL4", biastype = biastype, normtype = normtype) }
</code></pre>

<hr>
<h2 id='asL4-class'>Asymptotic mean power 4 error</h2><span id='topic+asL4-class'></span>

<h3>Description</h3>

<p>Class of asymptotic mean power 4 error.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("asL4", ...)</code>.
More frequently they are created via the generating function 
<code>asL4</code>.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>Object of class <code>"character"</code>: 
&ldquo;asymptotic mean square error&rdquo;. </p>
</dd>
<dt><code>biastype</code></dt><dd><p>Object of class <code>"BiasType"</code>: 
symmetric, one-sided or asymmetric </p>
</dd>
<dt><code>normtype</code></dt><dd><p>Object of class <code>"NormType"</code>: 
norm in which a multivariate parameter is considered</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"asGRisk"</code>, directly.<br />
Class <code>"asRiskwithBias"</code>, by class <code>"asGRisk"</code>.<br />
Class <code>"asRisk"</code>, by class <code>"asRiskwithBias"</code>.<br />
Class <code>"RiskType"</code>, by class <code>"asGRisk"</code>.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;asL4&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+asGRisk-class">asGRisk-class</a></code>, <code><a href="distrMod.html#topic+asMSE">asMSE</a></code>, <code><a href="distrMod.html#topic+asMSE-class">asMSE-class</a></code>, <code><a href="#topic+asL1-class">asL1-class</a></code>, <code><a href="#topic+asL4">asL4</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>new("asMSE")
</code></pre>

<hr>
<h2 id='checkIC-methods'>Methods for Checking and Making ICs</h2><span id='topic+makeIC'></span><span id='topic+checkIC'></span><span id='topic+makeIC+2CContIC+2CL2ParamFamily-method'></span><span id='topic+checkIC+2CContIC+2CL2ParamFamily-method'></span>

<h3>Description</h3>

<p>Particular methods for checking centering and Fisher
consistency of ICs, resp. making an IC out of an
IC possibly violating the conditions so far.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ContIC,L2ParamFamily'
checkIC(IC, L2Fam, out = TRUE,
              forceContICMethod = FALSE, ..., diagnostic = FALSE)
## S4 method for signature 'ContIC,L2ParamFamily'
makeIC(IC, L2Fam,
              forceContICMethod = FALSE, ..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIC-methods_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"IC"</code> </p>
</td></tr>
<tr><td><code id="checkIC-methods_+3A_l2fam">L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures. </p>
</td></tr>
<tr><td><code id="checkIC-methods_+3A_out">out</code></td>
<td>
<p> logical: Should the values of the checks be printed out?</p>
</td></tr>
<tr><td><code id="checkIC-methods_+3A_forceconticmethod">forceContICMethod</code></td>
<td>
<p> logical: Should we force to use the method for
signature <code>ContIC,L2ParamFamily</code>
in any case (even if it is not indicated by symmetry arguments)?
Otherwise it uses internal method <code>.getComp</code> to compute the number
of integrals to be computed, taking care of symmetries as indicated through
the symmetry slots of the model <code>L2Fam</code>. Only if this
number is smaller than the  number of integrals to be computed in the range
of the pIC the present method is used, otherwise it switches back to the
<code>IC,L2ParamFamily</code>  method.
&ndash; The <code>ContIC,L2ParamFamily</code> up to skipped entries due to further
symmetry arguments is $<code>(k+1)k/2+k+1=(k+1)(k+2)/2</code> for <code>k</code> the
length of the unknown parameter / length of slot <code>L2deriv</code> of <code>L2Fam</code>,
while the number of integrals on the pIC scale underlying the more general
method for   signature <code>ContIC,L2ParamFamily</code> is <code>p (k+1)</code> where
<code>p</code> is the length of the pIC / the length of the parameter of interest
as indicated in the number of rows in the <code>trafo</code> slot of the underlying
slot <code>param</code> of <code>L2Fam</code>.</p>
</td></tr>
<tr><td><code id="checkIC-methods_+3A_...">...</code></td>
<td>
<p> additional parameters to be passed on to expectation
<code>E</code>. </p>
</td></tr>
<tr><td><code id="checkIC-methods_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code> (and in case <code>checkIC</code> if
argument <code>out==TRUE</code>), diagnostic information on the integration
is printed and returned as attribute <code>diagnostic</code> of the return value. </p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>In <code>checkIC</code>, the precisions of the centering and the Fisher consistency
are computed. <code>makeIC</code> affinely transforms a given IC (not necessarily
satisfying the centering and Fisher consistency condition so far) such that
after this transformation it becomes an IC (satisfying the conditions).
Here particular methods for ICs of class <code>ContIC</code> are provided using
the particular structure of this class which allows for speed up in certain cases.
</p>


<h3>Value</h3>

<p>The maximum deviation from the IC properties is returned.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:Peter.Ruckdeschel@uni-oldenburg.de">Peter.Ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness.</em>
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>H. Rieder (1994): <em>Robust Asymptotic Statistics.</em> Springer. 
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- new("IC")
checkIC(IC1)
</code></pre>

<hr>
<h2 id='cniperCont'> Functions for Computation and Plot of Cniper Contamination
and Cniper Points. </h2><span id='topic+cniperCont'></span><span id='topic+cniperPoint'></span><span id='topic+cniperPointPlot'></span>

<h3>Description</h3>

<p>These functions and their methods can be used to determine cniper
contamination as well as cniper points. That is, under which (Dirac) 
contamination is the risk of one procedure larger than the risk of some
other procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cniperCont(IC1, IC2, data = NULL, ...,
           neighbor, risk, lower=getdistrOption("DistrResolution"),
           upper=1-getdistrOption("DistrResolution"), n = 101,
           with.automatic.grid = TRUE, scaleX = FALSE, scaleX.fct,
           scaleX.inv, scaleY = FALSE, scaleY.fct = pnorm, scaleY.inv=qnorm,
           scaleN = 9, x.ticks = NULL, y.ticks = NULL, cex.pts = 1,
           cex.pts.fun = NULL, col.pts = par("col"), pch.pts = 19,
           cex.npts = 0.6, cex.npts.fun = NULL, col.npts = "red", pch.npts = 20,
           jit.fac = 1, jit.tol = .Machine$double.eps, with.lab = FALSE,
           lab.pts = NULL, lab.font = NULL, alpha.trsp = NA, which.lbs = NULL,
           which.Order  = NULL, which.nonlbs = NULL, attr.pre = FALSE,
           return.Order = FALSE, withSubst = TRUE)

cniperPoint(L2Fam, neighbor, risk, lower, upper)

cniperPointPlot(L2Fam, data=NULL, ..., neighbor, risk= asMSE(),
                        lower=getdistrOption("DistrResolution"),
                        upper=1-getdistrOption("DistrResolution"), n = 101,
                        withMaxRisk = TRUE, with.automatic.grid = TRUE,
                           scaleX = FALSE, scaleX.fct, scaleX.inv,
                           scaleY = FALSE, scaleY.fct = pnorm, scaleY.inv=qnorm,
                           scaleN = 9, x.ticks = NULL, y.ticks = NULL,
                           cex.pts = 1, cex.pts.fun = NULL, col.pts = par("col"),
                           pch.pts = 19,
                           cex.npts = 1, cex.npts.fun = NULL, col.npts = par("col"),
                           pch.npts = 19,
                           jit.fac = 1, jit.tol = .Machine$double.eps,
                           with.lab = FALSE,
                           lab.pts = NULL, lab.font = NULL, alpha.trsp = NA,
                           which.lbs = NULL, which.nonlbs = NULL,
                           which.Order  = NULL, attr.pre = FALSE, return.Order = FALSE,
                           withSubst = TRUE, withMakeIC = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cniperCont_+3A_ic1">IC1</code></td>
<td>
<p> object of class <code>IC</code> </p>
</td></tr>
<tr><td><code id="cniperCont_+3A_ic2">IC2</code></td>
<td>
<p> object of class <code>IC</code> </p>
</td></tr>
<tr><td><code id="cniperCont_+3A_l2fam">L2Fam</code></td>
<td>
<p> object of class <code>L2ParamFamily</code> </p>
</td></tr>
<tr><td><code id="cniperCont_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>Neighborhood</code> </p>
</td></tr>
<tr><td><code id="cniperCont_+3A_risk">risk</code></td>
<td>
<p> object of class <code>RiskType</code> </p>
</td></tr>
<tr><td><code id="cniperCont_+3A_...">...</code></td>
<td>
<p> additional parameters (in particular to be passed on to <code>plot</code>). </p>
</td></tr>
<tr><td><code id="cniperCont_+3A_data">data</code></td>
<td>
<p>data to be plotted in</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_lower">lower</code>, <code id="cniperCont_+3A_upper">upper</code></td>
<td>
<p> the lower and upper end points of the 
contamination interval (in prob-scale). </p>
</td></tr>
<tr><td><code id="cniperCont_+3A_n">n</code></td>
<td>
<p> number of points between <code>lower</code> and <code>upper</code></p>
</td></tr>
<tr><td><code id="cniperCont_+3A_withmaxrisk">withMaxRisk</code></td>
<td>
<p>logical; if <code>TRUE</code>, for risk comparison
uses the maximal risk of the classically optimal IC <code class="reqn">\psi</code> in all
situations with contamination in Dirac points 'no larger' than
the respective evaluation point and the optimally-robust
IC <code class="reqn">\eta</code> at its least favorable contamination situation
('over all real Dirac contamination points'). This is the default and
was the  behavior prior to package version 0.9).
If <code>FALSE</code> it uses exactly the situation
with Dirac contamination in the evaluation point for both ICs
<code class="reqn">\psi</code> and <code class="reqn">\eta</code> which amounts to calling <code>cniperCont</code>
with <code>IC1=psi</code>, <code>IC2=eta</code>.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_with.automatic.grid">with.automatic.grid</code></td>
<td>
<p>logical; should a grid be plotted alongside
with the ticks of the axes, automatically? If <code>TRUE</code> a respective
call to <code>grid</code> in argument <code>panel.first</code> is ignored. </p>
</td></tr>
<tr><td><code id="cniperCont_+3A_scalex">scaleX</code></td>
<td>
<p>logical; shall X-axis be rescaled (by default according to the cdf of
the underlying distribution)?</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_scaley">scaleY</code></td>
<td>
<p>logical; shall Y-axis be rescaled (by default according to a probit scale)?</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_scalex.fct">scaleX.fct</code></td>
<td>
<p>an isotone, vectorized function mapping the domain of the IC(s)
to [0,1]; if <code>scaleX</code> is <code>TRUE</code> and <code>scaleX.fct</code> is
missing, the cdf of the underlying observation distribution.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_scalex.inv">scaleX.inv</code></td>
<td>
<p>the inverse function to <code>scale.fct</code>, i.e., an isotone,
vectorized function mapping [0,1] to the domain of the IC(s)
such that for any <code>x</code> in the domain,
<code>scaleX.inv(scaleX.fct(x))==x</code>; if <code>scaleX</code> is <code>TRUE</code>
and <code>scaleX.inv</code> is
missing, the quantile function of the underlying observation distribution.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_scaley.fct">scaleY.fct</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate the
range of the respective coordinate of the IC(s)
to [0,1]; defaulting to the cdf of <code class="reqn">{\cal N}(0,1)</code>.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_scaley.inv">scaleY.inv</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate
the range [0,1] into the range of the respective coordinate of the IC(s);
defaulting to the quantile function of  <code class="reqn">{\cal N}(0,1)</code>.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_scalen">scaleN</code></td>
<td>
<p>integer; defaults to 9; on rescaled axes, number of x
and y ticks if drawn automatically;</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_x.ticks">x.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given x-ticks (on original scale);</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_y.ticks">y.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given y-ticks (on original scale);</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_cex.pts">cex.pts</code></td>
<td>
<p>size of the points of the second argument plotted (vectorized);</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_cex.pts.fun">cex.pts.fun</code></td>
<td>
<p>rescaling function for the size of the points to be plotted;
either <code>NULL</code> (default), then <code>log(1+abs(x))</code> is used for
the rescaling, or a function which is then used for the
rescaling.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_col.pts">col.pts</code></td>
<td>
<p>color of the points of the second argument plotted (vectorized);</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_pch.pts">pch.pts</code></td>
<td>
<p>symbol of the points of the second argument plotted (vectorized);</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_col.npts">col.npts</code></td>
<td>
<p>color of the non-labelled points of the <code>data</code> argument
plotted (vectorized);</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_pch.npts">pch.npts</code></td>
<td>
<p>symbol of the non-labelled points of the <code>data</code> argument
plotted (vectorized);</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_cex.npts">cex.npts</code></td>
<td>
<p>size of the non-labelled points of the <code>data</code> argument
plotted (vectorized);</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_cex.npts.fun">cex.npts.fun</code></td>
<td>
<p>rescaling function for the size of the non-labelled points
to be plotted; either <code>NULL</code> (default), then <code>log(1+abs(x))</code>
is used for each of the rescalings, or a function which is then used
for each of the rescalings.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_with.lab">with.lab</code></td>
<td>
<p>logical; shall labels be plotted to the observations?</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_lab.pts">lab.pts</code></td>
<td>
<p>character or NULL; labels to be plotted to the observations; if <code>NULL</code>
observation indices;</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_lab.font">lab.font</code></td>
<td>
<p>font to be used for labels</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_alpha.trsp">alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.lbl</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the data-symbols to be plotted.
Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_jit.fac">jit.fac</code></td>
<td>
<p>jittering factor used in case of a <code>DiscreteDistribution</code>
for plotting points of the second argument in a jittered fashion.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_jit.tol">jit.tol</code></td>
<td>
<p>jittering tolerance used in case of a <code>DiscreteDistribution</code>
for plotting points of the second argument in a jittered fashion.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_which.lbs">which.lbs</code></td>
<td>
<p>either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then no observation is excluded</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_which.nonlbs">which.nonlbs</code></td>
<td>
<p>indices of the observations which should be plotted but
not labelled; either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> &mdash; then all non-labelled
observations are plotted.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_which.order">which.Order</code></td>
<td>
<p>we order the observations (descending) according to the norm given by
<code>normtype(object)</code>; then <code>which.Order</code>
either is an integer vector with the indices of the <em>ordered</em>
observations (remaining after a possible reduction by argument <code>which.lbs</code>)
to be plotted into graph or <code>NULL</code> &mdash; then no (further) observation
is excluded.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_attr.pre">attr.pre</code></td>
<td>
<p>logical; do graphical attributes for plotted data refer
to indices prior (<code>TRUE</code>) or posterior to selection
via arguments <code>which.lbs</code>, <code>which.Order</code>, <code>which.nonlbs</code>
(<code>FALSE</code>)? </p>
</td></tr>
<tr><td><code id="cniperCont_+3A_return.order">return.Order</code></td>
<td>
<p>logical; if <code>TRUE</code>, an order vector
is returned; more specifically, the order of the (remaining) observations
given by their original index is returned (remaining means: after a possible
reduction by argument <code>which.lbs</code>, and ordering is according to the norm given by
<code>normtype(object)</code>);
otherwise we return <code>invisible()</code> as usual.</p>
</td></tr>
<tr><td><code id="cniperCont_+3A_withsubst">withSubst</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and lables is used; otherwise no substitution is used. </p>
</td></tr>
<tr><td><code id="cniperCont_+3A_withmakeic">withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of <code>cniperCont</code> the difference between the risks of two ICs 
is plotted.
</p>
<p>The function <code>cniperPoint</code> can be used to determine cniper
points. That is, points such that the optimally robust estimator
has smaller minimax risk than the classical optimal estimator under 
contamination with Dirac measures at the cniper points. 
</p>
<p>As such points might be difficult to find, we provide the
function <code>cniperPointPlot</code> which can be used to obtain a plot
of the risk difference; in this function the usual arguments for
<code>plot</code> can be used. For arguments <code>col</code>, <code>lwd</code>,
vectors can be used; then the first coordinate is taken for the
curve, the second one for the balancing line. For argument <code>lty</code>,
a list can be used; its first component is then taken for the
curve, the second one for the balancing line.
</p>
<p>If argument <code>withSubst</code> is <code>TRUE</code>, in all title 
and axis lable arguments of <code>cniperCont</code> and <code>cniperPointPlot</code>, 
the following patterns are substituted:
</p>

<dl>
<dt><code>"%C"</code></dt><dd><p>class of argument <code>L2Fam</code> (for  <code>cniperPointPlot</code>)</p>
</dd>
<dt><code>"%A"</code></dt><dd><p>deparsed argument  <code>L2Fam</code> (for  <code>cniperPointPlot</code>)</p>
</dd>
<dt><code>"%C1"</code></dt><dd><p>class of argument <code>IC1</code> (for  <code>cniperCont</code>)</p>
</dd>
<dt><code>"%A1"</code></dt><dd><p>deparsed argument  <code>IC1</code> (for  <code>cniperCont</code>)</p>
</dd>
<dt><code>"%C2"</code></dt><dd><p>class of argument <code>IC2</code> (for  <code>cniperCont</code>)</p>
</dd>
<dt><code>"%A2"</code></dt><dd><p>deparsed argument  <code>IC2</code> (for  <code>cniperCont</code>)</p>
</dd>
<dt><code>"%D"</code></dt><dd><p>time/date-string when the plot was generated</p>
</dd>
</dl>

<p>For more details about cniper contamination and cniper points we refer 
to Section~3.5 of Kohl et al. (2008) as well as Ruckdeschel (2004) and 
the Introduction of Kohl (2005).
</p>


<h3>Value</h3>

<p>The cniper point is returned by <code>cniperPoint</code>.
In case of <code>cniperPointPlot</code>, we return
an S3 object of class <code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>P. Ruckdeschel (2004). Higher Order Asymptotics for the MSE of M-Estimators
on Shrinking Neighborhoods. Unpublished Manuscript.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## cniper contamination
P &lt;- PoisFamily(lambda = 4)
RobP1 &lt;- InfRobModel(center = P, neighbor = ContNeighborhood(radius = 0.1))
IC1 &lt;- optIC(model=RobP1, risk=asMSE())
RobP2 &lt;- InfRobModel(center = P, neighbor = ContNeighborhood(radius = 1))
IC2 &lt;- optIC(model=RobP2, risk=asMSE())
cniperCont(IC1 = IC1, IC2 = IC2,
           neighbor = ContNeighborhood(radius = 0.5), 
           risk = asMSE(),
           lower = 0, upper = 8, n = 101)

## cniper point plot
cniperPointPlot(P, neighbor = ContNeighborhood(radius = 0.5), 
                risk = asMSE(), lower = 0, upper = 10)

## Don't run to reduce check time on CRAN

## cniper point
cniperPoint(P, neighbor = ContNeighborhood(radius = 0.5), 
            risk = asMSE(), lower = 0, upper = 4)
cniperPoint(P, neighbor = ContNeighborhood(radius = 0.5), 
            risk = asMSE(), lower = 4, upper = 8)

</code></pre>

<hr>
<h2 id='CniperPointPlot'>Wrapper function for cniperPointPlot - Computation and Plot
of Cniper Contamination and Cniper Points</h2><span id='topic+CniperPointPlot'></span>

<h3>Description</h3>

<p>The wrapper <code>CniperPointPlot</code> (capital C!) takes most of arguments 
to the <code>cniperPointPlot</code> (lower case c!) function by default and gives 
a user possibility to run the function with low number of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CniperPointPlot(fam, ...,
    lower = getdistrOption("DistrResolution"),
    upper = 1 - getdistrOption("DistrResolution"),
    with.legend = TRUE, rescale = FALSE, withCall = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CniperPointPlot_+3A_fam">fam</code></td>
<td>
<p>object of class L2ParamFamily</p>
</td></tr>
<tr><td><code id="CniperPointPlot_+3A_...">...</code></td>
<td>
<p>additional parameters (in particular to be
passed on to <code>plot</code>)</p>
</td></tr>
<tr><td><code id="CniperPointPlot_+3A_lower">lower</code></td>
<td>
<p>the lower end point of the contamination
interval</p>
</td></tr>
<tr><td><code id="CniperPointPlot_+3A_upper">upper</code></td>
<td>
<p>the upper end point of the contamination
interval</p>
</td></tr>
<tr><td><code id="CniperPointPlot_+3A_with.legend">with.legend</code></td>
<td>
<p>the flag for showing the legend of the
plot</p>
</td></tr>
<tr><td><code id="CniperPointPlot_+3A_rescale">rescale</code></td>
<td>
<p>the flag for rescaling the axes for better view of the plot</p>
</td></tr>
<tr><td><code id="CniperPointPlot_+3A_withcall">withCall</code></td>
<td>
<p>the flag for the call output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(NULL)
</p>


<h3>Details</h3>

<p>Calls <code>cniperPointPlot</code> with suitably chosen
defaults; if <code>withCall == TRUE</code>, the call to
<code>cniperPointPlot</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L2fam &lt;- NormLocationScaleFamily()
CniperPointPlot(fam=L2fam, main = "Normal location and scale", 
                lower = 0, upper = 2.5, withCall = FALSE)
</code></pre>

<hr>
<h2 id='comparePlot-methods'>Compare - Plots</h2><span id='topic+comparePlot'></span><span id='topic+comparePlot-methods'></span><span id='topic+comparePlot+2CIC+2CIC-method'></span>

<h3>Description</h3>

<p>Plots 2-4 influence curves to the same model.
</p>


<h3>Details</h3>

<p>S4-Method <code>comparePlot</code> for signature <code>IC,IC</code> has been enhanced compared to
its original definition in <span class="pkg">RobAStBase</span> so that if
argument <code>MBRB</code> is <code>NA</code>, it is filled automatically by a call
to <code>optIC</code> which computes the MBR-IC on the fly. To this end, there
is an additional argument <code>n.MBR</code> defaulting to 10000
to determine the number of evaluation points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## all (interesting) examples to this function need
## more time than 5 seconds;
## you can find them in 
## system.file("scripts", "examples_taking_longer.R", 
##              package="ROptEst")
</code></pre>

<hr>
<h2 id='get.asGRisk.fct-methods'>Methods for Function get.asGRisk.fct in Package &lsquo;ROptEst&rsquo; </h2><span id='topic+get.asGRisk.fct-methods'></span><span id='topic+get.asGRisk.fct'></span><span id='topic+get.asGRisk.fct+2CasL1-method'></span><span id='topic+get.asGRisk.fct+2CasL4-method'></span><span id='topic+get.asGRisk.fct+2CasMSE-method'></span>

<h3>Description</h3>

<p>get.asGRisk.fct-methods to produce a function in r,s,b for computing
a particular asGRisk</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.asGRisk.fct(Risk)
## S4 method for signature 'asMSE'
get.asGRisk.fct(Risk)     
## S4 method for signature 'asL1'
get.asGRisk.fct(Risk)     
## S4 method for signature 'asL4'
get.asGRisk.fct(Risk)     
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.asGRisk.fct-methods_+3A_risk">Risk</code></td>
<td>
<p>a risk of class <code>"asGRisk"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get.asGRisk.fct</code> is used internally in functions <code><a href="#topic+getAsRisk">getAsRisk</a></code>
and <code><a href="#topic+getReq">getReq</a></code>.</p>


<h3>Value</h3>

<table>
<tr><td><code>get.asGRisk.fct</code></td>
<td>
<p>a function with arguments <code>r</code> (radius), <code>s</code> 
(square root of (trace of) variance), <code>b</code> bias to compute the respective risk of an IC
with this bias and variance at the respective radius.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>get.asGRisk.fct</dt><dd><p><code>signature(Risk = "asMSE")</code>: method for asymptotic mean squared error.</p>
</dd>
<dt>get.asGRisk.fct</dt><dd><p><code>signature(Risk = "asL1")</code>: method for asymptotic mean absolute error.</p>
</dd>
<dt>get.asGRisk.fct</dt><dd><p><code>signature(Risk = "asL4")</code>: method for asymptotic mean power 4 error.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>

<hr>
<h2 id='getAsRisk'>Generic Function for Computation of Asymptotic Risks</h2><span id='topic+getAsRisk'></span><span id='topic+getAsRisk-methods'></span><span id='topic+getAsRisk+2CasMSE+2CUnivariateDistribution+2CNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasL1+2CUnivariateDistribution+2CNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasL4+2CUnivariateDistribution+2CNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasMSE+2CEuclRandVariable+2CNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasBias+2CUnivariateDistribution+2CContNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasBias+2CUnivariateDistribution+2CContNeighborhood+2ConesidedBias-method'></span><span id='topic+getAsRisk+2CasBias+2CUnivariateDistribution+2CContNeighborhood+2CasymmetricBias-method'></span><span id='topic+getAsRisk+2CasBias+2CUnivariateDistribution+2CTotalVarNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasBias+2CRealRandVariable+2CContNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasBias+2CRealRandVariable+2CTotalVarNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasCov+2CUnivariateDistribution+2CContNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasCov+2CUnivariateDistribution+2CTotalVarNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasCov+2CRealRandVariable+2CContNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CtrAsCov+2CUnivariateDistribution+2CUncondNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CtrAsCov+2CRealRandVariable+2CContNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasAnscombe+2CUnivariateDistribution+2CUncondNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasAnscombe+2CRealRandVariable+2CContNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasUnOvShoot+2CUnivariateDistribution+2CUncondNeighborhood+2CANY-method'></span><span id='topic+getAsRisk+2CasSemivar+2CUnivariateDistribution+2CNeighborhood+2ConesidedBias-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of asymptotic risks.
This function is rarely called directly. It is used by 
other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAsRisk(risk, L2deriv, neighbor, biastype, ...)

## S4 method for signature 'asMSE,UnivariateDistribution,Neighborhood,ANY'
getAsRisk(risk,
    L2deriv, neighbor, biastype, normtype = NULL, clip = NULL, cent = NULL,
    stand, trafo, ...)

## S4 method for signature 'asL1,UnivariateDistribution,Neighborhood,ANY'
getAsRisk(risk,
    L2deriv, neighbor, biastype, normtype = NULL, clip = NULL, cent = NULL,
    stand, trafo, ...)

## S4 method for signature 'asL4,UnivariateDistribution,Neighborhood,ANY'
getAsRisk(risk,
    L2deriv, neighbor, biastype, normtype = NULL, clip = NULL, cent = NULL,
    stand, trafo, ...)

## S4 method for signature 'asMSE,EuclRandVariable,Neighborhood,ANY'
getAsRisk(risk,
    L2deriv, neighbor, biastype, normtype = NULL, clip = NULL, cent = NULL,
    stand, trafo, ...)

## S4 method for signature 'asBias,UnivariateDistribution,ContNeighborhood,ANY'
getAsRisk(risk,
    L2deriv, neighbor, biastype, normtype = NULL, clip = NULL, cent = NULL,
    stand = NULL, trafo, ...)

## S4 method for signature 
## 'asBias,UnivariateDistribution,ContNeighborhood,onesidedBias'
getAsRisk(
    risk, L2deriv, neighbor, biastype, normtype = NULL, clip = NULL, cent = NULL,
    stand = NULL, trafo, ...)

## S4 method for signature 
## 'asBias,UnivariateDistribution,ContNeighborhood,asymmetricBias'
getAsRisk(
    risk, L2deriv, neighbor, biastype, normtype = NULL, clip = NULL, cent = NULL,
    stand = NULL, trafo, ...)

## S4 method for signature 
## 'asBias,UnivariateDistribution,TotalVarNeighborhood,ANY'
getAsRisk(
    risk, L2deriv, neighbor, biastype, normtype = NULL, clip = NULL, cent = NULL,
    stand = NULL, trafo, ...)

## S4 method for signature 'asBias,RealRandVariable,ContNeighborhood,ANY'
getAsRisk(
    risk,L2deriv, neighbor, biastype, normtype = NULL, clip = NULL, cent = NULL,
    stand = NULL, Distr, DistrSymm, L2derivSymm,
    L2derivDistrSymm, Finfo, trafo, z.start, A.start, maxiter, tol,
    warn, verbose = NULL, ...)
## S4 method for signature 'asBias,RealRandVariable,TotalVarNeighborhood,ANY'
getAsRisk(
    risk, L2deriv, neighbor, biastype, normtype = NULL, 
    clip = NULL, cent = NULL, stand = NULL, Distr, DistrSymm, L2derivSymm,
    L2derivDistrSymm, Finfo, trafo, z.start, A.start, maxiter, tol,
    warn, verbose = NULL, ...)

## S4 method for signature 'asCov,UnivariateDistribution,ContNeighborhood,ANY'
getAsRisk(
    risk, L2deriv, neighbor, biastype, normtype = NULL, clip, cent, stand,
    trafo = NULL, ...)

## S4 method for signature 
## 'asCov,UnivariateDistribution,TotalVarNeighborhood,ANY'
getAsRisk(
    risk, L2deriv, neighbor, biastype, normtype = NULL, clip, cent, stand,
    trafo = NULL, ...)

## S4 method for signature 'asCov,RealRandVariable,ContNeighborhood,ANY'
getAsRisk(risk,
    L2deriv, neighbor, biastype, normtype = NULL, clip = NULL, cent, stand,
    Distr, trafo = NULL, V.comp =  matrix(TRUE, ncol = nrow(stand),
    nrow = nrow(stand)), w, ...)

## S4 method for signature 
## 'trAsCov,UnivariateDistribution,UncondNeighborhood,ANY'
getAsRisk(
    risk, L2deriv, neighbor, biastype, normtype = NULL, clip, cent, stand,
    trafo = NULL, ...)

## S4 method for signature 'trAsCov,RealRandVariable,ContNeighborhood,ANY'
getAsRisk(risk,
    L2deriv, neighbor, biastype, normtype, clip, cent, stand, Distr,
    trafo = NULL,  V.comp =  matrix(TRUE, ncol = nrow(stand),
    nrow = nrow(stand)), w, ...)
  
## S4 method for signature 
## 'asAnscombe,UnivariateDistribution,UncondNeighborhood,ANY'
getAsRisk(
    risk, L2deriv, neighbor, biastype, normtype = NULL, clip, cent, stand,
    trafo = NULL, FI, ...)

## S4 method for signature 'asAnscombe,RealRandVariable,ContNeighborhood,ANY'
getAsRisk(risk,
    L2deriv, neighbor, biastype, normtype, clip, cent, stand, Distr, trafo = NULL, 
    V.comp =  matrix(TRUE, ncol = nrow(stand), nrow = nrow(stand)),
    FI, w, ...)
  

## S4 method for signature 
## 'asUnOvShoot,UnivariateDistribution,UncondNeighborhood,ANY'
getAsRisk(
    risk, L2deriv, neighbor, biastype, normtype = NULL, clip, cent, stand,
    trafo, ...)

## S4 method for signature 
## 'asSemivar,UnivariateDistribution,Neighborhood,onesidedBias'
getAsRisk(
    risk, L2deriv, neighbor, biastype, normtype = NULL, clip, cent, stand,
    trafo, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAsRisk_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"asRisk"</code>. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family
of probability distributions. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_biastype">biastype</code></td>
<td>
<p> object of class <code>"ANY"</code>. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_...">...</code></td>
<td>
<p> additional parameters; often used to enable flexible calls. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_clip">clip</code></td>
<td>
<p> optimal clipping bound. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_cent">cent</code></td>
<td>
<p> optimal centering constant. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_stand">stand</code></td>
<td>
<p> standardizing matrix. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_finfo">Finfo</code></td>
<td>
<p> matrix: the Fisher Information of the parameter. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_distrsymm">DistrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_l2derivsymm">L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_l2derivdistrsymm">L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_normtype">normtype</code></td>
<td>
<p> object of class <code>"NormType"</code>. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_v.comp">V.comp</code></td>
<td>
<p> matrix: indication which components of the standardizing
matrix have to be computed. </p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_w">w</code></td>
<td>
<p>object of class <code>RobWeight</code>; current weight</p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_fi">FI</code></td>
<td>
<p>trace of the respective Fisher Information</p>
</td></tr>
<tr><td><code id="getAsRisk_+3A_verbose">verbose</code></td>
<td>
<p>logical: if <code>TRUE</code> some diagnostics are printed out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function is rarely called directly. It is used by 
other functions/methods. </p>


<h3>Value</h3>

<p>The asymptotic risk is computed.</p>


<h3>Methods</h3>


<dl>
<dt>risk = &quot;asMSE&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;Neighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes asymptotic mean square error in methods for
function <code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asL1&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;Neighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes asymptotic mean absolute error in methods for
function <code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asL4&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;Neighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes asymptotic mean power 4 error in methods for
function <code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asMSE&quot;, L2deriv = &quot;EuclRandVariable&quot;,
neighbor = &quot;Neighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes asymptotic mean square error in methods for
function <code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asBias&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes standardized asymptotic bias in methods
for function <code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asBias&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;onesidedBias&quot;:</dt><dd>
<p>computes standardized asymptotic bias in methods for function
<code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asBias&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;asymmetricBias&quot;:</dt><dd>
<p>computes standardized asymptotic bias in methods for function
<code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asBias&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;TotalVarNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes standardized asymptotic bias in methods for function
<code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asBias&quot;, L2deriv = &quot;RealRandVariable&quot;,
neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes standardized asymptotic bias in methods for function
<code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asCov&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes asymptotic covariance in methods for function
<code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asCov&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;TotalVarNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes asymptotic covariance in methods for function
<code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asCov&quot;, L2deriv = &quot;RealRandVariable&quot;,
neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes asymptotic covariance in methods for function
<code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;trAsCov&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;UncondNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes trace of asymptotic covariance in methods 
for function <code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;trAsCov&quot;, L2deriv = &quot;RealRandVariable&quot;,
neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes trace of asymptotic covariance in methods for 
function <code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asAnscombe&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;UncondNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes the ARE in the ideal model in methods 
for function <code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asAnscombe&quot;, L2deriv = &quot;RealRandVariable&quot;,
neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes the ARE in the ideal model in methods for 
function <code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asUnOvShoot&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;UncondNeighborhood&quot;, biastype = &quot;ANY&quot;:</dt><dd>
<p>computes asymptotic under-/overshoot risk in methods for 
function <code>getInfRobIC</code>. </p>
</dd>
<dt>risk = &quot;asSemivar&quot;, L2deriv = &quot;UnivariateDistribution&quot;,
neighbor = &quot;Neighborhood&quot;, biastype = &quot;onesidedBias&quot;:</dt><dd>
<p>computes asymptotic semivariance in methods for
function <code>getInfRobIC</code>. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>H. Rieder (1994): Robust Asymptotic Statistics. Springer. 
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>
</p>
<p>P. Ruckdeschel (2005). Optimally One-Sided Bounded Influence Curves.
Mathematical Methods of Statistics <em>14</em>(1), 105-131.
</p>
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+asRisk-class">asRisk-class</a></code></p>

<hr>
<h2 id='getBiasIC'>Generic function for the computation of the asymptotic bias for an IC</h2><span id='topic+getBiasIC'></span><span id='topic+getBiasIC-methods'></span><span id='topic+getBiasIC+2CHampIC+2CUncondNeighborhood-method'></span><span id='topic+getBiasIC+2CTotalVarIC+2CUncondNeighborhood-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the asymptotic bias for an IC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBiasIC(IC, neighbor, ...)

## S4 method for signature 'HampIC,UncondNeighborhood'
getBiasIC(IC, neighbor, L2Fam, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBiasIC_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"InfluenceCurve"</code> </p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_l2fam">L2Fam</code></td>
<td>
<p> object of class <code>"L2ParamFamily"</code>. </p>
</td></tr>
<tr><td><code id="getBiasIC_+3A_...">...</code></td>
<td>
<p> additional parameters </p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function is rarely called directly. It is used by 
other functions/methods. </p>


<h3>Value</h3>

<p>The bias of the IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>IC = &quot;HampIC&quot;, neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>reads off the as. bias from the risks-slot of the IC. </p>
</dd>
<dt>IC = &quot;TotalVarIC&quot;, neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>reads off the as. bias from the risks-slot of the IC,
resp. if this is <code>NULL</code> from the corresponding
Lagrange Multipliers. </p>
</dd>
</dl>


<h3>Note</h3>

<p>This generic function is still under construction.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>
<p>Ruckdeschel, P. and Kohl, M. (2005) Computation of the Finite Sample Bias
of M-estimators on Neighborhoods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRiskIC-methods">getRiskIC-methods</a></code>, <code><a href="RobAStBase.html#topic+InfRobModel-class">InfRobModel-class</a></code></p>

<hr>
<h2 id='getFixClip'>Generic Function for the Computation of the Optimal Clipping Bound</h2><span id='topic+getFixClip'></span><span id='topic+getFixClip-methods'></span><span id='topic+getFixClip+2Cnumeric+2CNorm+2CfiUnOvShoot+2CContNeighborhood-method'></span><span id='topic+getFixClip+2Cnumeric+2CNorm+2CfiUnOvShoot+2CTotalVarNeighborhood-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the optimal clipping bound
in case of robust models with fixed neighborhoods. This function is 
rarely called directly. It is used to compute optimally robust ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFixClip(clip, Distr, risk, neighbor,  ...)

## S4 method for signature 'numeric,Norm,fiUnOvShoot,ContNeighborhood'
getFixClip(clip, Distr, risk, neighbor)

## S4 method for signature 'numeric,Norm,fiUnOvShoot,TotalVarNeighborhood'
getFixClip(clip, Distr, risk, neighbor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFixClip_+3A_clip">clip</code></td>
<td>
<p> positive real: clipping bound </p>
</td></tr>
<tr><td><code id="getFixClip_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="getFixClip_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getFixClip_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getFixClip_+3A_...">...</code></td>
<td>
<p> additional parameters. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimal clipping bound is computed.</p>


<h3>Methods</h3>


<dl>
<dt>clip = &quot;numeric&quot;, Distr = &quot;Norm&quot;, risk = &quot;fiUnOvShoot&quot;, neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for finite-sample under-/overshoot risk. </p>
</dd>
<dt>clip = &quot;numeric&quot;, Distr = &quot;Norm&quot;, risk = &quot;fiUnOvShoot&quot;, neighbor = &quot;TotalVarNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for finite-sample under-/overshoot risk. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="RobAStBase.html#topic+TotalVarIC-class">TotalVarIC-class</a></code></p>

<hr>
<h2 id='getFixRobIC'> Generic Function for the Computation of Optimally Robust ICs </h2><span id='topic+getFixRobIC'></span><span id='topic+getFixRobIC-methods'></span><span id='topic+getFixRobIC+2CNorm+2CfiUnOvShoot+2CUncondNeighborhood-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of optimally robust ICs 
in case of robust models with fixed neighborhoods. This function is 
rarely called directly. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFixRobIC(Distr, risk, neighbor, ...)

## S4 method for signature 'Norm,fiUnOvShoot,UncondNeighborhood'
getFixRobIC(Distr, risk, neighbor, 
          sampleSize, upper, lower, maxiter, tol, warn, Algo, cont)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFixRobIC_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="getFixRobIC_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getFixRobIC_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getFixRobIC_+3A_...">...</code></td>
<td>
<p> additional parameters. </p>
</td></tr>
<tr><td><code id="getFixRobIC_+3A_samplesize">sampleSize</code></td>
<td>
<p> integer: sample size. </p>
</td></tr>  
<tr><td><code id="getFixRobIC_+3A_upper">upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="getFixRobIC_+3A_lower">lower</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="getFixRobIC_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="getFixRobIC_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="getFixRobIC_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>
<tr><td><code id="getFixRobIC_+3A_algo">Algo</code></td>
<td>
<p> &quot;A&quot; or &quot;B&quot;. </p>
</td></tr>
<tr><td><code id="getFixRobIC_+3A_cont">cont</code></td>
<td>
<p> &quot;left&quot; or &quot;right&quot;. </p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Computation of the optimally robust IC in sense of Huber (1968) which
is also treated in Kohl (2005). The Algorithm used to compute the exact
finite sample risk is introduced and explained in Kohl (2005). It is
based on FFT.
</p>


<h3>Value</h3>

<p>The optimally robust IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>Distr = &quot;Norm&quot;, risk = &quot;fiUnOvShoot&quot;, neighbor = &quot;UncondNeighborhood&quot;</dt><dd> 
<p>computes the optimally robust influence curve for one-dimensional
normal location and finite-sample under-/overshoot risk. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106-115.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+FixRobModel-class">FixRobModel-class</a></code></p>

<hr>
<h2 id='getIneffDiff'>Generic Function for the Computation of Inefficiency Differences</h2><span id='topic+getIneffDiff'></span><span id='topic+getIneffDiff-methods'></span><span id='topic+getIneffDiff+2Cnumeric+2CL2ParamFamily+2CUncondNeighborhood+2CasMSE-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of inefficiency differencies.
This function is rarely called directly. It is used to compute
the radius minimax IC and the least favorable radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIneffDiff(radius, L2Fam, neighbor, risk, ...)

## S4 method for signature 'numeric,L2ParamFamily,UncondNeighborhood,asMSE'
getIneffDiff(
          radius, L2Fam, neighbor, risk, loRad, upRad, loRisk, upRisk, 
          z.start = NULL, A.start = NULL, upper.b = NULL, lower.b = NULL,
          OptOrIter = "iterate", MaxIter, eps, warn, loNorm = NULL, upNorm = NULL,
          verbose = NULL, ..., withRetIneff = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIneffDiff_+3A_radius">radius</code></td>
<td>
<p> neighborhood radius. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_l2fam">L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_lorad">loRad</code></td>
<td>
<p> the lower end point of the interval to be searched. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_uprad">upRad</code></td>
<td>
<p> the upper end point of the interval to be searched. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_lorisk">loRisk</code></td>
<td>
<p> the risk at the lower end point of the interval. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_uprisk">upRisk</code></td>
<td>
<p> the risk at the upper end point of the interval. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_upper.b">upper.b</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_lower.b">lower.b</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_optoriter">OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_maxiter">MaxIter</code></td>
<td>
<p> the maximum number of iterations </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_eps">eps</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>  
<tr><td><code id="getIneffDiff_+3A_lonorm">loNorm</code></td>
<td>
<p>object of class <code>"NormType"</code>; used in selfstandardization
to evaluate the bias of the current IC in the norm of the lower 
bound</p>
</td></tr>  
<tr><td><code id="getIneffDiff_+3A_upnorm">upNorm</code></td>
<td>
<p>object of class <code>"NormType"</code>; used in selfstandardization
to evaluate the bias of the current IC in the norm of the upper 
bound</p>
</td></tr>  
<tr><td><code id="getIneffDiff_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code>getInfRobIC</code></p>
</td></tr>
<tr><td><code id="getIneffDiff_+3A_withretineff">withRetIneff</code></td>
<td>
<p>logical: if <code>TRUE</code>, <code>getIneffDiff</code>  returns the
vector of lower and upper inefficiency (components named &quot;lo&quot; and &quot;up&quot;),
otherwise (default) the difference.
The latter was used in <code>radiusMinimaxIC</code> up to version 0.8
for a call to <code>uniroot</code> directly.  In order to speed up things
(i.e., not to call the expensive <code>getInfRobIC</code> once again at the zero,
up to version 0.8 we had some awkward <code>assign</code>-<code>sys.frame</code>
construction to modify the caller writing the upper inefficiency already
computed to the caller environment; having capsulated this into <code>try</code>
from version 0.9 on, this became even more awkward, so from version 0.9
onwards, we instead use the <code>TRUE</code>-alternative when calling it
from <code>radiusMinimaxIC</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inefficieny difference between the left and
the right margin of a given radius interval is computed.
</p>


<h3>Methods</h3>


<dl>
<dt>radius = &quot;numeric&quot;, L2Fam = &quot;L2ParamFamily&quot;, 
neighbor = &quot;UncondNeighborhood&quot;, risk = &quot;asMSE&quot;:</dt><dd> 
<p>computes difference of asymptotic MSE&ndash;inefficiency for
the boundaries of a given radius interval.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of not Knowing
the Radius. Statistical Methods and Applications, <em>17</em>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2001). The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>.
</p>
<p>P. Ruckdeschel (2005). Optimally One-Sided Bounded Influence Curves.
Mathematical Methods of Statistics <em>14</em>(1), 105-131.
</p>
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radiusMinimaxIC">radiusMinimaxIC</a></code>, <code><a href="#topic+leastFavorableRadius">leastFavorableRadius</a></code></p>

<hr>
<h2 id='getInfCent'>Generic Function for the Computation of the Optimal Centering Constant/Lower Clipping Bound</h2><span id='topic+getInfCent'></span><span id='topic+getInfCent-methods'></span><span id='topic+getInfCent+2CUnivariateDistribution+2CContNeighborhood+2CBiasType-method'></span><span id='topic+getInfCent+2CUnivariateDistribution+2CTotalVarNeighborhood+2CBiasType-method'></span><span id='topic+getInfCent+2CRealRandVariable+2CContNeighborhood+2CBiasType-method'></span><span id='topic+getInfCent+2CRealRandVariable+2CTotalVarNeighborhood+2CBiasType-method'></span><span id='topic+getInfCent+2CUnivariateDistribution+2CContNeighborhood+2ConesidedBias-method'></span><span id='topic+getInfCent+2CUnivariateDistribution+2CContNeighborhood+2CasymmetricBias-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the optimal centering constant
(contamination neighborhoods) respectively, of the optimal lower clipping
bound (total variation neighborhood).
This function is rarely called directly. It is used to 
compute optimally robust ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInfCent(L2deriv, neighbor, biastype, ...)

## S4 method for signature 'UnivariateDistribution,ContNeighborhood,BiasType'
getInfCent(L2deriv, 
     neighbor, biastype, clip, cent, tol.z, symm, trafo)

## S4 method for signature 
## 'UnivariateDistribution,TotalVarNeighborhood,BiasType'
getInfCent(L2deriv, 
     neighbor, biastype, clip, cent, tol.z, symm, trafo)

## S4 method for signature 'RealRandVariable,ContNeighborhood,BiasType'
getInfCent(L2deriv,
     neighbor, biastype, Distr, z.comp, w, tol.z = .Machine$double.eps^.5, ...)

## S4 method for signature 'RealRandVariable,TotalVarNeighborhood,BiasType'
getInfCent(L2deriv,
     neighbor, biastype, Distr, z.comp, w, tol.z = .Machine$double.eps^.5,...)

## S4 method for signature 
## 'UnivariateDistribution,ContNeighborhood,onesidedBias'
getInfCent(L2deriv,
     neighbor, biastype, clip, cent, tol.z, symm, trafo)

## S4 method for signature 
## 'UnivariateDistribution,ContNeighborhood,asymmetricBias'
getInfCent(L2deriv, 
     neighbor, biastype, clip, cent, tol.z, symm, trafo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInfCent_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family 
of probability measures. </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_biastype">biastype</code></td>
<td>
<p> object of class <code>"BiasType"</code>. </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_...">...</code></td>
<td>
<p> additional parameters, in particular for expectation <code>E</code>. </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_clip">clip</code></td>
<td>
<p> optimal clipping bound. </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_cent">cent</code></td>
<td>
<p> optimal centering constant. </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_tol.z">tol.z</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_symm">symm</code></td>
<td>
<p> logical: indicating symmetry of <code>L2deriv</code>. </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_distr">Distr</code></td>
<td>
<p>object of class <code>Distribution</code>. </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_z.comp">z.comp</code></td>
<td>
<p> logical vector: indication which components of the 
centering constant have to be computed. </p>
</td></tr>
<tr><td><code id="getInfCent_+3A_w">w</code></td>
<td>
<p>object of class <code>RobWeight</code>; current weight. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimal centering constant is computed.</p>


<h3>Methods</h3>


<dl>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;BiasType&quot;</dt><dd> 
<p>computation of optimal centering constant for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;TotalVarNeighborhood&quot;, biastype = &quot;BiasType&quot;</dt><dd> 
<p>computation of optimal lower clipping bound for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, neighbor = &quot;TotalVarNeighborhood&quot;, biastype = &quot;BiasType&quot;</dt><dd>
<p>computation of optimal centering constant for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;BiasType&quot;</dt><dd>
<p>computation of optimal centering constant for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;onesidedBias&quot;</dt><dd>
<p>computation of optimal centering constant for onesided bias. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;ContNeighborhood&quot;, biastype = &quot;asymmetricBias&quot;</dt><dd> 
<p>computation of optimal centering constant for asymmetric bias. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="RobAStBase.html#topic+TotalVarIC-class">TotalVarIC-class</a></code></p>

<hr>
<h2 id='getInfClip'>Generic Function for the Computation of the Optimal Clipping Bound</h2><span id='topic+getInfClip'></span><span id='topic+getInfClip-methods'></span><span id='topic+getInfClip+2Cnumeric+2CUnivariateDistribution+2CasMSE+2CContNeighborhood-method'></span><span id='topic+getInfClip+2Cnumeric+2CUnivariateDistribution+2CasMSE+2CTotalVarNeighborhood-method'></span><span id='topic+getInfClip+2Cnumeric+2CUnivariateDistribution+2CasL1+2CContNeighborhood-method'></span><span id='topic+getInfClip+2Cnumeric+2CUnivariateDistribution+2CasL1+2CTotalVarNeighborhood-method'></span><span id='topic+getInfClip+2Cnumeric+2CUnivariateDistribution+2CasL4+2CContNeighborhood-method'></span><span id='topic+getInfClip+2Cnumeric+2CUnivariateDistribution+2CasL4+2CTotalVarNeighborhood-method'></span><span id='topic+getInfClip+2Cnumeric+2CEuclRandVariable+2CasMSE+2CUncondNeighborhood-method'></span><span id='topic+getInfClip+2Cnumeric+2CUnivariateDistribution+2CasUnOvShoot+2CUncondNeighborhood-method'></span><span id='topic+getInfClip+2Cnumeric+2CUnivariateDistribution+2CasSemivar+2CContNeighborhood-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the optimal clipping bound
in case of infinitesimal robust models. This function is rarely called 
directly. It is used to compute optimally robust ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInfClip(clip, L2deriv, risk, neighbor, ...)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asMSE,ContNeighborhood'
getInfClip(
     clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asMSE,TotalVarNeighborhood'
getInfClip(
     clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asL1,ContNeighborhood'
getInfClip(
     clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asL1,TotalVarNeighborhood'
getInfClip(
     clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asL4,ContNeighborhood'
getInfClip(
     clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asL4,TotalVarNeighborhood'
getInfClip(
     clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 'numeric,EuclRandVariable,asMSE,UncondNeighborhood'
getInfClip(
     clip, L2deriv, risk, neighbor, biastype, Distr, stand, cent, trafo, ...)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asUnOvShoot,UncondNeighborhood'
getInfClip(
     clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asSemivar,ContNeighborhood'
getInfClip(
     clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInfClip_+3A_clip">clip</code></td>
<td>
<p> positive real: clipping bound </p>
</td></tr>
<tr><td><code id="getInfClip_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family 
of probability measures. </p>
</td></tr>
<tr><td><code id="getInfClip_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getInfClip_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getInfClip_+3A_...">...</code></td>
<td>
<p> additional parameters, in particular for expectation <code>E</code> </p>
</td></tr>
<tr><td><code id="getInfClip_+3A_biastype">biastype</code></td>
<td>
<p> object of class <code>"BiasType"</code> </p>
</td></tr>
<tr><td><code id="getInfClip_+3A_cent">cent</code></td>
<td>
<p> optimal centering constant. </p>
</td></tr>
<tr><td><code id="getInfClip_+3A_stand">stand</code></td>
<td>
<p> standardizing matrix. </p>
</td></tr>
<tr><td><code id="getInfClip_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="getInfClip_+3A_symm">symm</code></td>
<td>
<p> logical: indicating symmetry of <code>L2deriv</code>. </p>
</td></tr>
<tr><td><code id="getInfClip_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimal clipping bound is computed.</p>


<h3>Methods</h3>


<dl>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asMSE&quot;, neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean square error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asMSE&quot;, neighbor = &quot;TotalVarNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean square error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;EuclRandVariable&quot;, 
risk = &quot;asMSE&quot;, neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>optimal clipping bound for asymtotic mean square error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asL1&quot;, neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean absolute error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asL1&quot;, neighbor = &quot;TotalVarNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean absolute error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asL4&quot;, neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean power 4 error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asL4&quot;, neighbor = &quot;TotalVarNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean power 4 error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asUnOvShoot&quot;, neighbor = &quot;UncondNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic under-/overshoot risk. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asSemivar&quot;, neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic semivariance.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="RobAStBase.html#topic+TotalVarIC-class">TotalVarIC-class</a></code></p>

<hr>
<h2 id='getInfGamma'>Generic Function for the Computation of the Optimal Clipping Bound</h2><span id='topic+getInfGamma'></span><span id='topic+getInfGamma-methods'></span><span id='topic+getInfGamma+2CUnivariateDistribution+2CasGRisk+2CContNeighborhood+2CBiasType-method'></span><span id='topic+getInfGamma+2CUnivariateDistribution+2CasGRisk+2CTotalVarNeighborhood+2CBiasType-method'></span><span id='topic+getInfGamma+2CRealRandVariable+2CasMSE+2CContNeighborhood+2CBiasType-method'></span><span id='topic+getInfGamma+2CRealRandVariable+2CasMSE+2CTotalVarNeighborhood+2CBiasType-method'></span><span id='topic+getInfGamma+2CUnivariateDistribution+2CasUnOvShoot+2CContNeighborhood+2CBiasType-method'></span><span id='topic+getInfGamma+2CUnivariateDistribution+2CasMSE+2CContNeighborhood+2ConesidedBias-method'></span><span id='topic+getInfGamma+2CUnivariateDistribution+2CasMSE+2CContNeighborhood+2CasymmetricBias-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the optimal clipping bound.
This function is rarely called directly. It is called by <code>getInfClip</code> 
to compute optimally robust ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInfGamma(L2deriv, risk, neighbor, biastype, ...)

## S4 method for signature 
## 'UnivariateDistribution,asGRisk,ContNeighborhood,BiasType'
getInfGamma(L2deriv, 
     risk, neighbor, biastype, cent, clip)

## S4 method for signature 
## 'UnivariateDistribution,asGRisk,TotalVarNeighborhood,BiasType'
getInfGamma(L2deriv, 
     risk, neighbor, biastype, cent, clip)

## S4 method for signature 'RealRandVariable,asMSE,ContNeighborhood,BiasType'
getInfGamma(L2deriv, 
     risk, neighbor, biastype, Distr, stand, cent, clip, power = 1L, ...)

## S4 method for signature 
## 'RealRandVariable,asMSE,TotalVarNeighborhood,BiasType'
getInfGamma(L2deriv,
     risk, neighbor, biastype, Distr, stand, cent, clip, power = 1L, ...)

## S4 method for signature 
## 'UnivariateDistribution,asUnOvShoot,ContNeighborhood,BiasType'
getInfGamma(L2deriv,
     risk, neighbor, biastype, cent, clip)

## S4 method for signature 
## 'UnivariateDistribution,asMSE,ContNeighborhood,onesidedBias'
getInfGamma(L2deriv, 
     risk, neighbor, biastype, cent, clip)

## S4 method for signature 
## 'UnivariateDistribution,asMSE,ContNeighborhood,asymmetricBias'
getInfGamma(L2deriv, 
    risk, neighbor, biastype, cent, clip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInfGamma_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family 
of probability measures. </p>
</td></tr>
<tr><td><code id="getInfGamma_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getInfGamma_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getInfGamma_+3A_biastype">biastype</code></td>
<td>
<p> object of class <code>"BiasType"</code>. </p>
</td></tr>
<tr><td><code id="getInfGamma_+3A_...">...</code></td>
<td>
<p> additional parameters, in particular for expectation <code>E</code>. </p>
</td></tr>
<tr><td><code id="getInfGamma_+3A_cent">cent</code></td>
<td>
<p> optimal centering constant. </p>
</td></tr>
<tr><td><code id="getInfGamma_+3A_clip">clip</code></td>
<td>
<p> optimal clipping bound. </p>
</td></tr>
<tr><td><code id="getInfGamma_+3A_stand">stand</code></td>
<td>
<p> standardizing matrix. </p>
</td></tr>
<tr><td><code id="getInfGamma_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="getInfGamma_+3A_power">power</code></td>
<td>
<p> exponent for the integrand; by default <code>1</code>, but
may also be <code>2</code>, for optimization in <code>getLagrangeMultByOptim</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used in case of asymptotic G-risks; confer
Ruckdeschel and Rieder (2004).
</p>


<h3>Value</h3>

<p>The optimal clipping height is computed. More specifically, the optimal
clipping height <code class="reqn">b</code> is determined in a zero search of a certain function
<code class="reqn">\gamma</code>, where the respective  <code>getInf</code>-method will return 
the value of  <code class="reqn">\gamma(b)</code>. The actual function <code class="reqn">\gamma</code>
varies according to whether the parameter is one dimensional or higher dimensional,
according to the risk, according to the neighborhood, and according to the
bias type, which leads to the different methods.</p>


<h3>Methods</h3>


<dl>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asGRisk&quot;, 
neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;BiasType&quot;</dt><dd><p> used by <code>getInfClip</code> for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asGRisk&quot;, 
neighbor = &quot;TotalVarNeighborhood&quot;, 
biastype = &quot;BiasType&quot;</dt><dd><p> used by <code>getInfClip</code> for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, risk = &quot;asMSE&quot;, 
neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;BiasType&quot;</dt><dd><p> used by <code>getInfClip</code> for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, risk = &quot;asMSE&quot;,
neighbor = &quot;TotalVarNeighborhood&quot;,
biastype = &quot;BiasType&quot;</dt><dd><p> used by <code>getInfClip</code> for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asUnOvShoot&quot;, 
neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;BiasType&quot;</dt><dd><p> used by <code>getInfClip</code> for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asMSE&quot;, 
neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;onesidedBias&quot;</dt><dd><p> used by <code>getInfClip</code> for onesided bias. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asMSE&quot;, 
neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;asymmetricBias&quot;</dt><dd><p> used by <code>getInfClip</code> for asymmetric bias. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+asGRisk-class">asGRisk-class</a></code>, <code><a href="distrMod.html#topic+asMSE-class">asMSE-class</a></code>,
<code><a href="distrMod.html#topic+asUnOvShoot-class">asUnOvShoot-class</a></code>, <code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, 
<code><a href="RobAStBase.html#topic+TotalVarIC-class">TotalVarIC-class</a></code></p>

<hr>
<h2 id='getInfLM'>Functions to determine Lagrange multipliers</h2><span id='topic+getInfLM'></span><span id='topic+getLagrangeMultByOptim'></span><span id='topic+getLagrangeMultByIter'></span>

<h3>Description</h3>

<p>Functions to determine Lagrange multipliers <code>A</code> and <code>a</code>
in a Hampel problem or in a(n) (inner) loop in a MSE problem; can be done
either by optimization or by fixed point iteration. These functions are
rarely called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLagrangeMultByIter(b, L2deriv, risk, trafo,
                      neighbor, biastype, normtype, Distr,
                      a.start, z.start, A.start, w.start, std, z.comp,
                      A.comp, maxiter, tol, verbose = NULL,
                      warnit = TRUE, ...)
getLagrangeMultByOptim(b, L2deriv, risk, FI, trafo,
                      neighbor, biastype, normtype, Distr,
                      a.start, z.start, A.start, w.start,  std, z.comp,
                      A.comp, maxiter, tol, verbose = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInfLM_+3A_b">b</code></td>
<td>
<p>numeric; (<code class="reqn">&gt;b_{\rm\scriptstyle min}</code>; clipping bound
for which the Lagrange multipliers are searched</p>
</td></tr>
<tr><td><code id="getInfLM_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family
of probability measures. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_fi">FI</code></td>
<td>
<p> matrix: Fisher information. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_biastype">biastype</code></td>
<td>
<p>object of class <code>"BiasType"</code> &mdash; the bias type with we work.</p>
</td></tr>
<tr><td><code id="getInfLM_+3A_normtype">normtype</code></td>
<td>
<p>object of class <code>"NormType"</code> &mdash; the norm type with we work.</p>
</td></tr>
<tr><td><code id="getInfLM_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_a.start">a.start</code></td>
<td>
<p> initial value for the centering constant (in <code>p</code>-space). </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant (in <code>k</code>-space). </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_w.start">w.start</code></td>
<td>
<p> initial value for the weight function. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_std">std</code></td>
<td>
<p> matrix of (or which may coerced to) class
<code>PosSemDefSymmMatrix</code> for use of different
(standardizing) norm. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_z.comp">z.comp</code></td>
<td>
<p> logical vector: indication which components of the
centering constant have to be computed. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_a.comp">A.comp</code></td>
<td>
<p> matrix: indication which components of the standardizing
matrix have to be computed. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="getInfLM_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_warnit">warnit</code></td>
<td>
<p> logical: if <code>TRUE</code> warning is issued if
maximal number of iterations is reached. </p>
</td></tr>
<tr><td><code id="getInfLM_+3A_...">...</code></td>
<td>
<p> additional parameters for <code>optim</code> and <code>E</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with items
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Lagrange multiplier <code>A</code> (standardizing matrix)</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>Lagrange multiplier <code>a</code> (centering in <code>p</code>-space)</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>Lagrange multiplier <code>z</code> (centering in <code>k</code>-space)</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>weight function involving Lagrange multipliers</p>
</td></tr>
<tr><td><code>biastype</code></td>
<td>
<p>(possibly modified) bias type <code>biastype</code> from argument</p>
</td></tr>
<tr><td><code>normtype</code></td>
<td>
<p>(possibly modified) norm type <code>normtype</code> from argument</p>
</td></tr>
<tr><td><code>normtype.old</code></td>
<td>
<p>(possibly modified) norm type <code>normtype</code>
before last (internal) update</p>
</td></tr>
<tr><td><code>risk</code></td>
<td>
<p>(possibly [norm-]modified) risk <code>risk</code> from argument</p>
</td></tr>
<tr><td><code>std</code></td>
<td>
<p>(possibly modified) argument <code>std</code></p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations needed</p>
</td></tr>
<tr><td><code>prec</code></td>
<td>
<p>precision achieved</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>used clippng height <code>b</code></p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>call with which either <code>getLagrangeMultByIter</code> or
<code>getLagrangeMultByOptim</code> was called </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106-115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <b>22</b>: 201-223.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+InfRobModel-class">InfRobModel-class</a></code></p>

<hr>
<h2 id='getInfRad'>Generic Function for the Computation of the Optimal Radius for Given Clipping Bound</h2><span id='topic+getInfRad'></span><span id='topic+getInfRad-methods'></span><span id='topic+getInfRad+2Cnumeric+2CUnivariateDistribution+2CasMSE+2CContNeighborhood-method'></span><span id='topic+getInfRad+2Cnumeric+2CUnivariateDistribution+2CasMSE+2CTotalVarNeighborhood-method'></span><span id='topic+getInfRad+2Cnumeric+2CUnivariateDistribution+2CasL1+2CContNeighborhood-method'></span><span id='topic+getInfRad+2Cnumeric+2CUnivariateDistribution+2CasL1+2CTotalVarNeighborhood-method'></span><span id='topic+getInfRad+2Cnumeric+2CUnivariateDistribution+2CasL4+2CContNeighborhood-method'></span><span id='topic+getInfRad+2Cnumeric+2CUnivariateDistribution+2CasL4+2CTotalVarNeighborhood-method'></span><span id='topic+getInfRad+2Cnumeric+2CEuclRandVariable+2CasMSE+2CUncondNeighborhood-method'></span><span id='topic+getInfRad+2Cnumeric+2CUnivariateDistribution+2CasUnOvShoot+2CUncondNeighborhood-method'></span><span id='topic+getInfRad+2Cnumeric+2CUnivariateDistribution+2CasSemivar+2CContNeighborhood-method'></span>

<h3>Description</h3>

<p>The usual robust optimality problem for given asGRisk searches the optimal
clipping height b of a Hampel-type IC to given radius of the neighborhood.
Instead, again for given asGRisk  and for given Hampel-Type IC with
given clipping height b we may determine the radius of the neighborhood
for which it is optimal in the sense of the first sentence. This
radius is determined by <code>getInfRad</code>. This function is rarely called
directly. It is used withing <code><a href="#topic+getRadius">getRadius</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInfRad(clip, L2deriv, risk, neighbor, ...)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asMSE,ContNeighborhood'
getInfRad(
          clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asMSE,TotalVarNeighborhood'
getInfRad(
          clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asL1,ContNeighborhood'
getInfRad(
          clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asL1,TotalVarNeighborhood'
getInfRad(
          clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asL4,ContNeighborhood'
getInfRad(
          clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asL4,TotalVarNeighborhood'
getInfRad(
          clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 'numeric,EuclRandVariable,asMSE,UncondNeighborhood'
getInfRad(
          clip, L2deriv, risk, neighbor, biastype, Distr, stand, cent, trafo, ...)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asUnOvShoot,UncondNeighborhood'
getInfRad(
          clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)

## S4 method for signature 
## 'numeric,UnivariateDistribution,asSemivar,ContNeighborhood'
getInfRad(
          clip, L2deriv, risk, neighbor, biastype, cent, symm, trafo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInfRad_+3A_clip">clip</code></td>
<td>
<p> positive real: clipping bound </p>
</td></tr>
<tr><td><code id="getInfRad_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family 
of probability measures. </p>
</td></tr>
<tr><td><code id="getInfRad_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getInfRad_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getInfRad_+3A_...">...</code></td>
<td>
<p> additional parameters. </p>
</td></tr>
<tr><td><code id="getInfRad_+3A_biastype">biastype</code></td>
<td>
<p> object of class <code>"BiasType"</code> </p>
</td></tr>
<tr><td><code id="getInfRad_+3A_cent">cent</code></td>
<td>
<p> optimal centering constant. </p>
</td></tr>
<tr><td><code id="getInfRad_+3A_stand">stand</code></td>
<td>
<p> standardizing matrix. </p>
</td></tr>
<tr><td><code id="getInfRad_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="getInfRad_+3A_symm">symm</code></td>
<td>
<p> logical: indicating symmetry of <code>L2deriv</code>. </p>
</td></tr>
<tr><td><code id="getInfRad_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimal clipping bound is computed.</p>


<h3>Methods</h3>


<dl>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asMSE&quot;, neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean square error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asMSE&quot;, neighbor = &quot;TotalVarNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean square error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;EuclRandVariable&quot;, 
risk = &quot;asMSE&quot;, neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>optimal clipping bound for asymtotic mean square error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asL1&quot;, neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean absolute error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asL1&quot;, neighbor = &quot;TotalVarNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean absolute error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asL4&quot;, neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean power 4 error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asL4&quot;, neighbor = &quot;TotalVarNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic mean power 4 error. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asUnOvShoot&quot;, neighbor = &quot;UncondNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic under-/overshoot risk. </p>
</dd>
<dt>clip = &quot;numeric&quot;, L2deriv = &quot;UnivariateDistribution&quot;, 
risk = &quot;asSemivar&quot;, neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>optimal clipping bound for asymtotic semivariance.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="RobAStBase.html#topic+TotalVarIC-class">TotalVarIC-class</a></code></p>

<hr>
<h2 id='getInfRobIC'> Generic Function for the Computation of Optimally Robust ICs </h2><span id='topic+getInfRobIC'></span><span id='topic+getInfRobIC-methods'></span><span id='topic+getInfRobIC+2CUnivariateDistribution+2CasCov+2CContNeighborhood-method'></span><span id='topic+getInfRobIC+2CUnivariateDistribution+2CasCov+2CTotalVarNeighborhood-method'></span><span id='topic+getInfRobIC+2CRealRandVariable+2CasCov+2CUncondNeighborhood-method'></span><span id='topic+getInfRobIC+2CUnivariateDistribution+2CasBias+2CUncondNeighborhood-method'></span><span id='topic+getInfRobIC+2CRealRandVariable+2CasBias+2CUncondNeighborhood-method'></span><span id='topic+getInfRobIC+2CUnivariateDistribution+2CasHampel+2CUncondNeighborhood-method'></span><span id='topic+getInfRobIC+2CRealRandVariable+2CasHampel+2CUncondNeighborhood-method'></span><span id='topic+getInfRobIC+2CUnivariateDistribution+2CasAnscombe+2CUncondNeighborhood-method'></span><span id='topic+getInfRobIC+2CRealRandVariable+2CasAnscombe+2CUncondNeighborhood-method'></span><span id='topic+getInfRobIC+2CUnivariateDistribution+2CasGRisk+2CUncondNeighborhood-method'></span><span id='topic+getInfRobIC+2CRealRandVariable+2CasGRisk+2CUncondNeighborhood-method'></span><span id='topic+getInfRobIC+2CUnivariateDistribution+2CasUnOvShoot+2CUncondNeighborhood-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of optimally robust ICs 
in case of infinitesimal robust models. This function is 
rarely called directly. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInfRobIC(L2deriv, risk, neighbor, ...)

## S4 method for signature 'UnivariateDistribution,asCov,ContNeighborhood'
getInfRobIC(L2deriv,
                       risk, neighbor, Finfo, trafo, verbose = NULL)

## S4 method for signature 'UnivariateDistribution,asCov,TotalVarNeighborhood'
getInfRobIC(L2deriv,
                       risk, neighbor, Finfo, trafo, verbose = NULL)

## S4 method for signature 'RealRandVariable,asCov,UncondNeighborhood'
getInfRobIC(L2deriv, risk,
                       neighbor, Distr, Finfo, trafo, QuadForm = diag(nrow(trafo)),
                       verbose = NULL)

## S4 method for signature 'UnivariateDistribution,asBias,UncondNeighborhood'
getInfRobIC(L2deriv,
                       risk, neighbor, symm, trafo, maxiter, tol, warn, Finfo,
                       verbose = NULL, ...)

## S4 method for signature 'RealRandVariable,asBias,UncondNeighborhood'
getInfRobIC(L2deriv, risk,
                       neighbor, Distr, DistrSymm, L2derivSymm,
                       L2derivDistrSymm, z.start, A.start, Finfo, trafo,
                       maxiter, tol, warn, verbose = NULL, ...)

## S4 method for signature 'UnivariateDistribution,asHampel,UncondNeighborhood'
getInfRobIC(L2deriv,
                       risk, neighbor, symm, Finfo, trafo, upper = NULL,
                       lower=NULL, maxiter, tol, warn, noLow = FALSE,
                       verbose = NULL, checkBounds = TRUE, ...)

## S4 method for signature 'RealRandVariable,asHampel,UncondNeighborhood'
getInfRobIC(L2deriv, risk,
                       neighbor, Distr, DistrSymm, L2derivSymm,
                       L2derivDistrSymm, Finfo, trafo, onesetLM = FALSE,
                       z.start, A.start, upper = NULL, lower=NULL,
                       OptOrIter = "iterate", maxiter, tol, warn,
                       verbose = NULL, checkBounds = TRUE, ...,
                       .withEvalAsVar = TRUE)

## S4 method for signature 
## 'UnivariateDistribution,asAnscombe,UncondNeighborhood'
getInfRobIC(
                       L2deriv, risk, neighbor, symm, Finfo, trafo, upper = NULL,
                       lower=NULL, maxiter, tol, warn, noLow = FALSE,
                       verbose = NULL, checkBounds = TRUE, ...)

## S4 method for signature 'RealRandVariable,asAnscombe,UncondNeighborhood'
getInfRobIC(L2deriv, 
                       risk, neighbor, Distr, DistrSymm, L2derivSymm,
                       L2derivDistrSymm, Finfo, trafo, onesetLM = FALSE,
                       z.start, A.start, upper = NULL, lower=NULL,
                       OptOrIter = "iterate", maxiter, tol, warn,
                       verbose = NULL, checkBounds = TRUE, ...)

## S4 method for signature 'UnivariateDistribution,asGRisk,UncondNeighborhood'
getInfRobIC(L2deriv,
                       risk, neighbor, symm, Finfo, trafo, upper = NULL,
                       lower = NULL, maxiter, tol, warn, noLow = FALSE,
                       verbose = NULL, ...)

## S4 method for signature 'RealRandVariable,asGRisk,UncondNeighborhood'
getInfRobIC(L2deriv, risk,
                       neighbor,  Distr, DistrSymm, L2derivSymm,
                       L2derivDistrSymm, Finfo, trafo, onesetLM = FALSE, z.start,
                       A.start, upper = NULL, lower = NULL, OptOrIter = "iterate",
                       maxiter, tol, warn, verbose = NULL, withPICcheck = TRUE,
                       ..., .withEvalAsVar = TRUE)

## S4 method for signature 
## 'UnivariateDistribution,asUnOvShoot,UncondNeighborhood'
getInfRobIC(
                       L2deriv, risk, neighbor, symm, Finfo, trafo,
                       upper, lower, maxiter, tol, warn, verbose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInfRobIC_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family 
of probability measures. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_...">...</code></td>
<td>
<p> additional parameters (mainly for <code>optim</code>). </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_symm">symm</code></td>
<td>
<p> logical: indicating symmetry of <code>L2deriv</code>. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_distrsymm">DistrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_l2derivsymm">L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_l2derivdistrsymm">L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_finfo">Finfo</code></td>
<td>
<p> Fisher information matrix. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_upper">upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_lower">lower</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_optoriter">OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_nolow">noLow</code></td>
<td>
<p> logical: is lower case to be computed? </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_onesetlm">onesetLM</code></td>
<td>
<p> logical: use one set of Lagrange multipliers? </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_quadform">QuadForm</code></td>
<td>
<p> matrix of (or which may coerced to) class 
<code>PosSemDefSymmMatrix</code> for use of different 
(standardizing) norm </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_checkbounds">checkBounds</code></td>
<td>
<p> logical: if <code>TRUE</code>, minimal and maximal clipping bound are 
computed to check if a valid bound was specified. </p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_withpiccheck">withPICcheck</code></td>
<td>
<p>logical: at the end of the algorithm, shall we check
how accurately this is a pIC; this will only be done if
<code>withPICcheck &amp;&amp; verbose</code>.</p>
</td></tr>
<tr><td><code id="getInfRobIC_+3A_.withevalasvar">.withEvalAsVar</code></td>
<td>
<p>logical (of length 1):
if <code>TRUE</code>, risks based on covariances are to be
evaluated (default), otherwise just a call is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimally robust IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asCov&quot;, 
neighbor = &quot;ContNeighborhood&quot;</dt><dd> 
<p>computes the classical optimal influence curve for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asCov&quot;, 
neighbor = &quot;TotalVarNeighborhood&quot;</dt><dd>
<p>computes the classical optimal influence curve for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, risk = &quot;asCov&quot;, 
neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>computes the classical optimal influence curve for L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate;
for total variation neighborhoods only is implemented for the case
where there is a <code class="reqn">1\times k</code> transformation <code>trafo</code>
matrix. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asBias&quot;, 
neighbor = &quot;UncondNeighborhood&quot;</dt><dd> 
<p>computes the bias optimal influence curve for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, risk = &quot;asBias&quot;, 
neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>computes the bias optimal influence curve for L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asHampel&quot;, 
neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>computes the optimally robust influence curve for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, risk = &quot;asHampel&quot;, 
neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>computes the optimally robust influence curve for L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate;
for total variation neighborhoods only is implemented for the case
where there is a <code class="reqn">1\times k</code> transformation <code>trafo</code>
matrix. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asAnscombe&quot;, 
neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>computes the optimally bias-robust influence curve to given ARE in the
ideal model for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, risk = &quot;asAnscombe&quot;, 
neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>computes the optimally bias-robust influence curve to given ARE in the
ideal modelfor L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate;
for total variation neighborhoods only is implemented for the case
where there is a <code class="reqn">1\times k</code> transformation <code>trafo</code>
matrix. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asGRisk&quot;, 
neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>computes the optimally robust influence curve for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, risk = &quot;asGRisk&quot;, 
neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>computes the optimally robust influence curve for L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate;
for total variation neighborhoods only is implemented for the case
where there is a <code class="reqn">1\times k</code> transformation <code>trafo</code>
matrix. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, risk = &quot;asUnOvShoot&quot;, 
neighbor = &quot;UncondNeighborhood&quot;</dt><dd>
<p>computes the optimally robust influence curve for one-dimensional
L2 differentiable parametric families and 
asymptotic under-/overshoot risk. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106-115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <b>22</b>: 201-223.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+InfRobModel-class">InfRobModel-class</a></code></p>

<hr>
<h2 id='getInfStand'> Generic Function for the Computation of the Standardizing Matrix </h2><span id='topic+getInfStand'></span><span id='topic+getInfStand-methods'></span><span id='topic+getInfStand+2CUnivariateDistribution+2CContNeighborhood+2CBiasType-method'></span><span id='topic+getInfStand+2CUnivariateDistribution+2CTotalVarNeighborhood+2CBiasType-method'></span><span id='topic+getInfStand+2CRealRandVariable+2CUncondNeighborhood+2CBiasType-method'></span><span id='topic+getInfStand+2CUnivariateDistribution+2CContNeighborhood+2ConesidedBias-method'></span><span id='topic+getInfStand+2CUnivariateDistribution+2CContNeighborhood+2CasymmetricBias-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the standardizing matrix which
takes care of the Fisher consistency of the corresponding IC. This function 
is rarely called directly. It is used to compute optimally robust ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInfStand(L2deriv, neighbor, biastype, ...)

## S4 method for signature 'UnivariateDistribution,ContNeighborhood,BiasType'
getInfStand(L2deriv, 
     neighbor, biastype, clip, cent, trafo)

## S4 method for signature 
## 'UnivariateDistribution,TotalVarNeighborhood,BiasType'
getInfStand(L2deriv, 
     neighbor, biastype, clip, cent, trafo)

## S4 method for signature 'RealRandVariable,UncondNeighborhood,BiasType'
getInfStand(L2deriv,
     neighbor, biastype, Distr, A.comp, cent, trafo, w, ...)

## S4 method for signature 
## 'UnivariateDistribution,ContNeighborhood,onesidedBias'
getInfStand(L2deriv,
     neighbor, biastype, clip, cent, trafo, ...)

## S4 method for signature 
## 'UnivariateDistribution,ContNeighborhood,asymmetricBias'
getInfStand(L2deriv,
     neighbor, biastype, clip, cent, trafo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInfStand_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family 
of probability measures. </p>
</td></tr>
<tr><td><code id="getInfStand_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getInfStand_+3A_biastype">biastype</code></td>
<td>
<p> object of class <code>"BiasType"</code>. </p>
</td></tr>
<tr><td><code id="getInfStand_+3A_...">...</code></td>
<td>
<p> additional parameters, in particular for expectation <code>E</code>. </p>
</td></tr>
<tr><td><code id="getInfStand_+3A_clip">clip</code></td>
<td>
<p> optimal clipping bound. </p>
</td></tr>
<tr><td><code id="getInfStand_+3A_cent">cent</code></td>
<td>
<p> optimal centering constant. </p>
</td></tr>
<tr><td><code id="getInfStand_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="getInfStand_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td></tr>  
<tr><td><code id="getInfStand_+3A_a.comp">A.comp</code></td>
<td>
<p> matrix: indication which components of the standardizing
matrix have to be computed. </p>
</td></tr>
<tr><td><code id="getInfStand_+3A_w">w</code></td>
<td>
<p>object of class <code>RobWeight</code>; current weight. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The standardizing matrix is computed.</p>


<h3>Methods</h3>


<dl>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;BiasType&quot;</dt><dd> 
<p>computes standardizing matrix for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;TotalVarNeighborhood&quot;, 
biastype = &quot;BiasType&quot;</dt><dd> 
<p>computes standardizing matrix for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, neighbor = &quot;UncondNeighborhood&quot;,
biastype = &quot;BiasType&quot;</dt><dd> 
<p>computes standardizing matrix for symmetric bias. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;onesidedBias&quot;</dt><dd> 
<p>computes standardizing matrix for onesided bias. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;asymmetricBias&quot;</dt><dd> 
<p>computes standardizing matrix for asymmetric bias. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="RobAStBase.html#topic+TotalVarIC-class">TotalVarIC-class</a></code></p>

<hr>
<h2 id='getInfV'>Generic Function for the Computation of the asymptotic Variance of a Hampel type IC</h2><span id='topic+getInfV'></span><span id='topic+getInfV-methods'></span><span id='topic+getInfV+2CUnivariateDistribution+2CContNeighborhood+2CBiasType-method'></span><span id='topic+getInfV+2CUnivariateDistribution+2CTotalVarNeighborhood+2CBiasType-method'></span><span id='topic+getInfV+2CRealRandVariable+2CContNeighborhood+2CBiasType-method'></span><span id='topic+getInfV+2CRealRandVariable+2CTotalVarNeighborhood+2CBiasType-method'></span><span id='topic+getInfV+2CUnivariateDistribution+2CContNeighborhood+2ConesidedBias-method'></span><span id='topic+getInfV+2CUnivariateDistribution+2CContNeighborhood+2CasymmetricBias-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the optimal clipping bound
in case of infinitesimal robust models. This function is rarely called 
directly. It is used to compute optimally robust ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInfV(L2deriv, neighbor, biastype, ...)
## S4 method for signature 'UnivariateDistribution,ContNeighborhood,BiasType'
getInfV(L2deriv, 
         neighbor, biastype, clip, cent, stand)
## S4 method for signature 
## 'UnivariateDistribution,TotalVarNeighborhood,BiasType'
getInfV(L2deriv, 
         neighbor, biastype, clip, cent, stand)
## S4 method for signature 'RealRandVariable,ContNeighborhood,BiasType'
getInfV(L2deriv, 
         neighbor, biastype, Distr, V.comp, cent, stand, 
         w, ...)
## S4 method for signature 'RealRandVariable,TotalVarNeighborhood,BiasType'
getInfV(L2deriv,
         neighbor, biastype, Distr, V.comp, cent, stand,
         w, ...)
## S4 method for signature 
## 'UnivariateDistribution,ContNeighborhood,onesidedBias'
getInfV(L2deriv,
         neighbor, biastype, clip, cent, stand, ...)
## S4 method for signature 
## 'UnivariateDistribution,ContNeighborhood,asymmetricBias'
getInfV(L2deriv, 
         neighbor, biastype, clip, cent, stand)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInfV_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family 
of probability measures. </p>
</td></tr>
<tr><td><code id="getInfV_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getInfV_+3A_biastype">biastype</code></td>
<td>
<p> object of class <code>"BiasType"</code>. </p>
</td></tr>
<tr><td><code id="getInfV_+3A_...">...</code></td>
<td>
<p> additional parameters, in particular for expectation <code>E</code>. </p>
</td></tr>
<tr><td><code id="getInfV_+3A_clip">clip</code></td>
<td>
<p> positive real: clipping bound </p>
</td></tr>
<tr><td><code id="getInfV_+3A_cent">cent</code></td>
<td>
<p> optimal centering constant. </p>
</td></tr>
<tr><td><code id="getInfV_+3A_stand">stand</code></td>
<td>
<p> standardizing matrix. </p>
</td></tr>
<tr><td><code id="getInfV_+3A_distr">Distr</code></td>
<td>
<p> standardizing matrix. </p>
</td></tr>
<tr><td><code id="getInfV_+3A_v.comp">V.comp</code></td>
<td>
<p> matrix: indication which components of the standardizing
matrix have to be computed. </p>
</td></tr>
<tr><td><code id="getInfV_+3A_w">w</code></td>
<td>
<p>object of class <code>RobWeight</code>; current weight. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The asymptotic variance of an ALE to IC of Hampel type is computed.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="RobAStBase.html#topic+TotalVarIC-class">TotalVarIC-class</a></code></p>

<hr>
<h2 id='getL1normL2deriv'>Calculation of L1 norm of L2derivative</h2><span id='topic+getL1normL2deriv'></span><span id='topic+getL1normL2deriv-methods'></span><span id='topic+getL1normL2deriv+2CUnivariateDistribution-method'></span><span id='topic+getL1normL2deriv+2CRealRandVariable-method'></span>

<h3>Description</h3>

<p>Methods to calculate the L1 norm of the L2derivative in a smooth parametric model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getL1normL2deriv(L2deriv, ...)
## S4 method for signature 'UnivariateDistribution'
getL1normL2deriv(L2deriv, 
     cent, ...)

## S4 method for signature 'RealRandVariable'
getL1normL2deriv(L2deriv, 
     cent, stand, Distr, normtype, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getL1normL2deriv_+3A_l2deriv">L2deriv</code></td>
<td>
<p>L2derivative of the model</p>
</td></tr>
<tr><td><code id="getL1normL2deriv_+3A_cent">cent</code></td>
<td>
<p>centering Lagrange Multiplier</p>
</td></tr>
<tr><td><code id="getL1normL2deriv_+3A_stand">stand</code></td>
<td>
<p>standardizing Lagrange Multiplier</p>
</td></tr>
<tr><td><code id="getL1normL2deriv_+3A_distr">Distr</code></td>
<td>
<p>distribution of the L2derivative</p>
</td></tr>
<tr><td><code id="getL1normL2deriv_+3A_normtype">normtype</code></td>
<td>
<p>object of class <code>NormType</code>; the norm under which we work</p>
</td></tr>
<tr><td><code id="getL1normL2deriv_+3A_...">...</code></td>
<td>
<p>further arguments (not used at the moment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>L1 norm of the L2derivative</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##
</code></pre>

<hr>
<h2 id='getL2normL2deriv'>Calculation of L2 norm of L2derivative</h2><span id='topic+getL2normL2deriv'></span>

<h3>Description</h3>

<p>Function to calculate the L2 norm of the L2derivative in a smooth parametric model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getL2normL2deriv(aFinfo, cent, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getL2normL2deriv_+3A_afinfo">aFinfo</code></td>
<td>
<p>trace of the Fisher information</p>
</td></tr>
<tr><td><code id="getL2normL2deriv_+3A_cent">cent</code></td>
<td>
<p>centering</p>
</td></tr>
<tr><td><code id="getL2normL2deriv_+3A_...">...</code></td>
<td>
<p>further arguments (not used at the moment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>L2 norm of the L2derivative</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##
</code></pre>

<hr>
<h2 id='getMaxIneff'>getMaxIneff &ndash; computation of the maximal inefficiency of an IC</h2><span id='topic+getMaxIneff'></span>

<h3>Description</h3>

<p>computes the maximal inefficiency of an IC for the radius range [0,Inf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxIneff(IC, neighbor, biastype = symmetricBias(), 
                        normtype = NormType(), z.start = NULL, 
                        A.start = NULL, maxiter = 50, 
                        tol = .Machine$double.eps^0.4,
                        warn = TRUE, verbose = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMaxIneff_+3A_ic">IC</code></td>
<td>
<p>some IC of class <code>IC</code></p>
</td></tr>
<tr><td><code id="getMaxIneff_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>Neighborhood</code>; 
the neighborhood at which to compute the bias. </p>
</td></tr>
<tr><td><code id="getMaxIneff_+3A_biastype">biastype</code></td>
<td>
<p>a bias type of class <code>BiasType</code></p>
</td></tr>
<tr><td><code id="getMaxIneff_+3A_normtype">normtype</code></td>
<td>
<p> a norm type of class <code>NormType</code></p>
</td></tr>
<tr><td><code id="getMaxIneff_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="getMaxIneff_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="getMaxIneff_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="getMaxIneff_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="getMaxIneff_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>  
<tr><td><code id="getMaxIneff_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td></tr>
<tr><td><code id="getMaxIneff_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to <code>E</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The maximal inefficiency, i.e.; a number in [1,Inf).</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@fraunhofer.itwm.de">peter.ruckdeschel@fraunhofer.itwm.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of not Knowing
the Radius. Statistical Methods and Applications, <em>17</em>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2001). The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>.
</p>
<p>P. Ruckdeschel (2005). Optimally One-Sided Bounded Influence Curves.
Mathematical Methods of Statistics <em>14</em>(1), 105-131.
</p>
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N0 &lt;- NormLocationFamily(mean=2, sd=3)
## L_2 family + infinitesimal neighborhood
neighbor &lt;- ContNeighborhood(radius = 0.5)
N0.Rob1 &lt;- InfRobModel(center = N0, neighbor = neighbor)
## OBRE solution (ARE 95%)
N0.ICA &lt;- optIC(model = N0.Rob1, risk = asAnscombe(.95))
## OMSE solution radius 0.5
N0.ICM &lt;- optIC(model=N0.Rob1, risk=asMSE())
## RMX solution 
N0.ICR &lt;- radiusMinimaxIC(L2Fam=N0, neighbor=neighbor,risk=asMSE())

getMaxIneff(N0.ICA,neighbor)
getMaxIneff(N0.ICM,neighbor)
getMaxIneff(N0.ICR,neighbor)

## Don't run to reduce check time on CRAN

N0ls &lt;- NormLocationScaleFamily()
ICsc &lt;- makeIC(list(sin,cos),N0ls)
getMaxIneff(ICsc,neighbor)

</code></pre>

<hr>
<h2 id='getModifyIC'>Generic Function for the Computation of Functions for Slot modifyIC</h2><span id='topic+getModifyIC'></span><span id='topic+scaleUpdateIC'></span><span id='topic+getModifyIC-methods'></span><span id='topic+scaleUpdateIC-methods'></span><span id='topic+scaleUpdateIC+2CUncondNeighborhood-method'></span><span id='topic+scaleUpdateIC+2CContNeighborhood-method'></span><span id='topic+scaleUpdateIC+2CTotalVarNeighborhood-method'></span><span id='topic+getModifyIC+2CL2ParamFamily+2CNeighborhood+2CasRisk-method'></span><span id='topic+getModifyIC+2CL2LocationFamily+2CUncondNeighborhood+2CasGRisk-method'></span><span id='topic+getModifyIC+2CL2LocationFamily+2CUncondNeighborhood+2CfiUnOvShoot-method'></span><span id='topic+getModifyIC+2CL2ScaleFamily+2CUncondNeighborhood+2CasGRisk-method'></span><span id='topic+getModifyIC+2CL2LocationScaleFamily+2CUncondNeighborhood+2CasGRisk-method'></span>

<h3>Description</h3>

<p>These function is used by internal computations and is rarely called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModifyIC(L2FamIC, neighbor, risk,...)
## S4 method for signature 'L2ParamFamily,Neighborhood,asRisk'
getModifyIC(L2FamIC,
          neighbor, risk, ...)
## S4 method for signature 'L2LocationFamily,UncondNeighborhood,asGRisk'
getModifyIC(L2FamIC,
          neighbor, risk, ...)
## S4 method for signature 'L2LocationFamily,UncondNeighborhood,fiUnOvShoot'
getModifyIC(L2FamIC,
          neighbor, risk, ...)
## S4 method for signature 'L2ScaleFamily,UncondNeighborhood,asGRisk'
getModifyIC(L2FamIC,
          neighbor, risk, ..., modifyICwarn = NULL)
## S4 method for signature 'L2LocationScaleFamily,UncondNeighborhood,asGRisk'
getModifyIC(L2FamIC,
          neighbor, risk, ..., modifyICwarn = NULL)

scaleUpdateIC(neighbor,...)
## S4 method for signature 'UncondNeighborhood'
scaleUpdateIC(neighbor, sdneu, sdalt, IC)
## S4 method for signature 'ContNeighborhood'
scaleUpdateIC(neighbor, sdneu, sdalt, IC)
## S4 method for signature 'TotalVarNeighborhood'
scaleUpdateIC(neighbor, sdneu, sdalt, IC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getModifyIC_+3A_l2famic">L2FamIC</code></td>
<td>
<p> object of class <code>L2ParamFamily</code>. </p>
</td></tr>
<tr><td><code id="getModifyIC_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getModifyIC_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code> </p>
</td></tr>
<tr><td><code id="getModifyIC_+3A_...">...</code></td>
<td>
<p>further arguments to be passed over to <code>optIC</code>.</p>
</td></tr>
<tr><td><code id="getModifyIC_+3A_sdneu">sdneu</code></td>
<td>
<p>positive numeric of length one; the new scale.</p>
</td></tr>
<tr><td><code id="getModifyIC_+3A_sdalt">sdalt</code></td>
<td>
<p>positive numeric of length one; the new scale.</p>
</td></tr>
<tr><td><code id="getModifyIC_+3A_ic">IC</code></td>
<td>
<p>a Hampel-IC to be updated.</p>
</td></tr>
<tr><td><code id="getModifyIC_+3A_modifyicwarn">modifyICwarn</code></td>
<td>
<p>logical: should a (warning) information be added if
<code>modifyIC</code> is applied and hence some optimality information could
no longer be valid? Defaults to <code>NULL</code> in which case this value
is taken from <code>RobAStBaseOptions</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function is used for internal computations.
By setting <code>RobAStBaseOption("all.verbose" = TRUE)</code> somewhere
globally, the generated function <code>modifyIC</code> will generate
calls to <code>optIC</code> with argument <code>verbose=TRUE</code>.
</p>


<h3>Value</h3>


<dl>
<dt>getmodifyIC</dt><dd><p>Function for slot <code>modifyIC</code> of <code>IC</code>s</p>
</dd>
<dt>scaleUpdateIC</dt><dd><p>a list to be digested in corresponding methods
of <code>getmodifyIC</code> by <code>generateIC</code></p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optIC">optIC</a></code>, <code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>

<hr>
<h2 id='getRadius'>Computation of the Optimal Radius for Given Clipping Bound</h2><span id='topic+getRadius'></span>

<h3>Description</h3>

<p>The usual robust optimality problem for given asGRisk searches the optimal
clipping height b of a Hampel-type IC to given radius of the neighborhood.
Instead, again for given asGRisk  and for given Hampel-Type IC with
given clipping height b we may determine the radius of the neighborhood
for which it is optimal in the sense of the first sentence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRadius(IC, risk, neighbor, L2Fam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRadius_+3A_ic">IC</code></td>
<td>
<p> an IC of class <code>"HampIC"</code>.</p>
</td></tr>
<tr><td><code id="getRadius_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getRadius_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="getRadius_+3A_l2fam">L2Fam</code></td>
<td>
<p> object of class <code>"L2FamParameter"</code>. Can be missing;
in this case it is constructed from slot <code>CallL2Fam</code> of
<code>IC</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimal radius is computed.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="RobAStBase.html#topic+TotalVarIC-class">TotalVarIC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- NormLocationFamily(mean=0, sd=1)
nb &lt;- ContNeighborhood(); ri &lt;- asMSE()
radIC &lt;- radiusMinimaxIC(L2Fam=N, neighbor=nb, risk=ri, loRad=0.1, upRad=0.5)
getRadius(radIC, L2Fam=N, neighbor=nb, risk=ri)

## taken from script NormalScaleModel.R in folder scripts
N0 &lt;- NormScaleFamily(mean=0, sd=1)
(N0.IC7 &lt;- radiusMinimaxIC(L2Fam=N0, neighbor=nb, risk=ri, loRad=0, upRad=Inf))
##
getRadius(N0.IC7, risk=asMSE(), neighbor=nb, L2Fam=N0)
getRadius(N0.IC7, risk=asL4(), neighbor=nb, L2Fam=N0)
</code></pre>

<hr>
<h2 id='getReq'>getReq &ndash; computation of the radius interval where IC1 is better than IC2.</h2><span id='topic+getReq'></span>

<h3>Description</h3>

<p>(tries to) compute a radius interval where IC1 is better than IC2,
respectively the number of (worst-case) outliers interval where IC1 is
better than IC2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReq(Risk,neighbor,IC1,IC2,n=1,upper=15, radOrOutl=c("radius","Outlier"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReq_+3A_risk">Risk</code></td>
<td>
<p>an object of class <code>"asGRisk"</code> &ndash; the risk at which IC1 is better than IC2.</p>
</td></tr>
<tr><td><code id="getReq_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>; the neighborhood at which to compute the bias. </p>
</td></tr>
<tr><td><code id="getReq_+3A_ic1">IC1</code></td>
<td>
<p>some IC of class <code>"IC"</code></p>
</td></tr>
<tr><td><code id="getReq_+3A_ic2">IC2</code></td>
<td>
<p>some IC of class <code>"IC"</code></p>
</td></tr>
<tr><td><code id="getReq_+3A_n">n</code></td>
<td>
<p>the sample size; by default set to 1; then the radius interval refers to starting radii 
in the shrinking neighborhood setting of Rieder[94]. Otherwise the radius interval is scaled
down accordingly.</p>
</td></tr>
<tr><td><code id="getReq_+3A_upper">upper</code></td>
<td>
<p>the upper bound of the radius interval in which to search</p>
</td></tr>  
<tr><td><code id="getReq_+3A_radoroutl">radOrOutl</code></td>
<td>
<p> a character string specifying whether an interval of
radii  or a number of outliers is returned; must be one
of &quot;radius&quot; (default) and &quot;Outlier&quot;. </p>
</td></tr>
<tr><td><code id="getReq_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on <code>E()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The radius interval (given by its endpoints) where <code>IC1</code> is better than <code>IC2</code>
according to the risk. In case <code>IC2</code> is better than <code>IC1</code> as to both variance and bias,
the return value is <code>NA</code>.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@fraunhofer.itwm.de">peter.ruckdeschel@fraunhofer.itwm.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N0 &lt;- NormLocationFamily(mean=2, sd=3)
## L_2 family + infinitesimal neighborhood
neighbor &lt;- ContNeighborhood(radius = 0.5)
N0.Rob1 &lt;- InfRobModel(center = N0, neighbor = neighbor)
## OBRE solution (ARE 95%)
N0.ICA &lt;- optIC(model = N0.Rob1, risk = asAnscombe(.95))
## MSE solution
N0.ICM &lt;- optIC(model=N0.Rob1, risk=asMSE())

getReq(asMSE(),neighbor,N0.ICA,N0.ICM,n=1)
getReq(asMSE(),neighbor,N0.ICA,N0.ICM,n=30)

## Don't test to reduce check time on CRAN

## RMX solution
N0.ICR &lt;- radiusMinimaxIC(L2Fam=N0, neighbor=neighbor,risk=asMSE())

getReq(asL1(),neighbor,N0.ICA,N0.ICM,n=30)
getReq(asL4(),neighbor,N0.ICA,N0.ICM,n=30)
getReq(asMSE(),neighbor,N0.ICA,N0.ICR,n=30)
getReq(asL1(),neighbor,N0.ICA,N0.ICR,n=30)
getReq(asL4(),neighbor,N0.ICA,N0.ICR,n=30)
getReq(asMSE(),neighbor,N0.ICM,N0.ICR,n=30)


### when to use MAD and when Qn 
##  for Qn, see C. Croux, P. Rousseeuw (1993). Alternatives to the Median 
##      Absolute Deviation, JASA 88(424):1273-1283
L2M &lt;- NormScaleFamily()
IC.mad &lt;- makeIC(function(x)sign(abs(x)-qnorm(.75)),L2M)
d.qn &lt;- (2^.5*qnorm(5/8))^-1
IC.qn &lt;- makeIC(function(x) d.qn*(1/4 - pnorm(x+1/d.qn) + pnorm(x-1/d.qn)), L2M)
getReq(asMSE(), neighbor, IC.mad, IC.qn)
getReq(asMSE(), neighbor, IC.mad, IC.qn, radOrOutl = "Outlier", n = 30)
# =&gt; MAD is better once r &gt; 0.5144 (i.e. for more than 2 outliers for n = 30)

</code></pre>

<hr>
<h2 id='getRiskFctBV-methods'>Methods for Function getRiskFctBV  in Package &lsquo;ROptEst&rsquo;</h2><span id='topic+getRiskFctBV'></span><span id='topic+getRiskFctBV-methods'></span><span id='topic+getRiskFctBV+2CasL1+2CANY-method'></span><span id='topic+getRiskFctBV+2CasL4+2CANY-method'></span>

<h3>Description</h3>

<p>getRiskFctBV for a given object of S4 class <code>asGRisk</code>
returns a function in bias and variance to compute the asymptotic
risk.</p>


<h3>Methods</h3>


<dl>
<dt>getRiskFctBV</dt><dd><p><code>signature(risk = "asL1", biastype = "ANY")</code>:
returns a function with arguments <code>bias</code> and <code>variance</code>
to compute the asymptotic absolute (L1) error for a given ALE at a situation
where it has bias <code>bias</code> (including the radius!) and variance <code>variance</code>. </p>
</dd>
<dt>getRiskFctBV</dt><dd><p><code>signature(risk = "asL4", biastype = "ANY")</code>:
returns a function with arguments <code>bias</code> and <code>variance</code>
to compute the asymptotic L4 error for a given ALE at a situation where
it has bias <code>bias</code> (including the radius!) and variance <code>variance</code>. </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>myrisk &lt;- asMSE()
getRiskFctBV(myrisk)
</code></pre>

<hr>
<h2 id='getRiskIC'>Generic function for the computation of a risk for an IC</h2><span id='topic+getRiskIC'></span><span id='topic+getRiskIC-methods'></span><span id='topic+getRiskIC+2CHampIC+2CasCov+2Cmissing+2Cmissing-method'></span><span id='topic+getRiskIC+2CHampIC+2CasCov+2Cmissing+2CL2ParamFamily-method'></span><span id='topic+getRiskIC+2CTotalVarIC+2CasCov+2Cmissing+2CL2ParamFamily-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of a risk for an IC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRiskIC(IC, risk, neighbor, L2Fam, ...)

## S4 method for signature 'HampIC,asCov,missing,missing'
getRiskIC(IC, risk, withCheck= TRUE, ...)

## S4 method for signature 'HampIC,asCov,missing,L2ParamFamily'
getRiskIC(IC, risk, L2Fam, withCheck= TRUE, ...)
## S4 method for signature 'TotalVarIC,asCov,missing,L2ParamFamily'
getRiskIC(IC, risk, L2Fam, withCheck = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRiskIC_+3A_ic">IC</code></td>
<td>
<p> object of class <code>"InfluenceCurve"</code> </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>; missing in the methods described here. </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_...">...</code></td>
<td>
<p> additional parameters to be passed to <code>E</code> </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_l2fam">L2Fam</code></td>
<td>
<p> object of class <code>"L2ParamFamily"</code>. </p>
</td></tr>
<tr><td><code id="getRiskIC_+3A_withcheck">withCheck</code></td>
<td>
<p>logical: should a call to <code>checkIC</code> be done to
check accuracy (defaults to <code>TRUE</code>; ignored
if nothing is computed but simply a slot is read out).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To make sure that the results are valid, it is recommended
to include an additional check of the IC properties of <code>IC</code>
using <code>checkIC</code>.</p>


<h3>Value</h3>

<p>The risk of an IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>IC = &quot;HampIC&quot;, risk = &quot;asCov&quot;, neighbor = &quot;missing&quot;, L2Fam = &quot;missing&quot;</dt><dd>
<p>asymptotic covariance of <code>IC</code> read off from corresp. <code>Risks</code> slot. </p>
</dd>
<dt>IC = &quot;HampIC&quot;, risk = &quot;asCov&quot;, neighbor = &quot;missing&quot;, L2Fam = &quot;L2ParamFamily&quot;</dt><dd>
<p>asymptotic covariance of <code>IC</code> under <code>L2Fam</code> read off from corresp. <code>Risks</code> slot. </p>
</dd>
<dt>IC = &quot;TotalVarIC&quot;, risk = &quot;asCov&quot;, neighbor = &quot;missing&quot;, L2Fam = &quot;L2ParamFamily&quot;</dt><dd>
<p>asymptotic covariance of <code>IC</code> read off from corresp. <code>Risks</code> slot,
resp. if this is <code>NULL</code> calculates it via <code><a href="#topic+getInfV">getInfV</a></code>.</p>
</dd>
</dl>


<h3>Note</h3>

<p>This generic function is still under construction.</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>
<p>Ruckdeschel, P. and Kohl, M. (2005) Computation of the Finite Sample Risk
of M-estimators on Neighborhoods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRiskIC">getRiskIC</a></code>, <code><a href="RobAStBase.html#topic+InfRobModel-class">InfRobModel-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- BinomFamily(size = 25, prob = 0.25)

## classical optimal IC
IC0 &lt;- optIC(model = B, risk = asCov())
getRiskIC(IC0, asCov())
</code></pre>

<hr>
<h2 id='getStartIC-methods'>Methods for Function getStartIC in Package &lsquo;ROptEst&rsquo; </h2><span id='topic+getStartIC-methods'></span><span id='topic+getStartIC'></span><span id='topic+getStartIC+2CANY+2CANY-method'></span><span id='topic+getStartIC+2CL2ParamFamily+2CasGRisk-method'></span><span id='topic+getStartIC+2CL2ParamFamily+2CasBias-method'></span><span id='topic+getStartIC+2CL2ParamFamily+2CasCov-method'></span><span id='topic+getStartIC+2CL2ParamFamily+2CasAnscombe-method'></span><span id='topic+getStartIC+2CL2ParamFamily+2CtrAsCov-method'></span><span id='topic+getStartIC+2CL2LocationFamily+2CinterpolRisk-method'></span><span id='topic+getStartIC+2CL2ScaleFamily+2CinterpolRisk-method'></span><span id='topic+getStartIC+2CL2LocationScaleFamily+2CinterpolRisk-method'></span>

<h3>Description</h3>

<p><code>getStartIC</code> computes the optimally-robust IC to be used as
argument <code>ICstart</code> in <code>kStepEstimator</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStartIC(model, risk, ...)
## S4 method for signature 'ANY,ANY'
getStartIC(model, risk, ...)
## S4 method for signature 'L2ParamFamily,asGRisk'
getStartIC(model, risk, ...,
                      withEvalAsVar = TRUE, withMakeIC = FALSE, ..debug=FALSE,
                      modifyICwarn = NULL, diagnostic = FALSE)
## S4 method for signature 'L2ParamFamily,asBias'
getStartIC(model, risk, ..., withMakeIC = FALSE,
        ..debug=FALSE, modifyICwarn = NULL, diagnostic = FALSE)
## S4 method for signature 'L2ParamFamily,asCov'
getStartIC(model, risk, ..., withMakeIC = FALSE,
    ..debug=FALSE)
## S4 method for signature 'L2ParamFamily,trAsCov'
getStartIC(model, risk, ..., withMakeIC = FALSE,
    ..debug=FALSE)
## S4 method for signature 'L2ParamFamily,asAnscombe'
getStartIC(model, risk, ...,
                      withEvalAsVar = TRUE, withMakeIC = FALSE, ..debug=FALSE,
                      modifyICwarn = NULL, diagnostic = FALSE)
## S4 method for signature 'L2LocationFamily,interpolRisk'
getStartIC(model, risk, ...)
## S4 method for signature 'L2ScaleFamily,interpolRisk'
getStartIC(model, risk, ...)
## S4 method for signature 'L2LocationScaleFamily,interpolRisk'
getStartIC(model, risk, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStartIC-methods_+3A_model">model</code></td>
<td>
<p>normtype of class <code>NormType</code></p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_risk">risk</code></td>
<td>
<p>normtype of class <code>NormType</code></p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to specific methods.</p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_withevalasvar">withEvalAsVar</code></td>
<td>
<p>logical (of length 1):
if <code>TRUE</code>, risks based on covariances are to be
evaluated (default), otherwise just a call is returned.</p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_withmakeic">withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the IC is passed through
<code>makeIC</code> before return.</p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_..debug">..debug</code></td>
<td>
<p>logical; if <code>TRUE</code> information for debugging is issued.</p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_modifyicwarn">modifyICwarn</code></td>
<td>
<p>logical: should a (warning) information be added if
<code>modifyIC</code> is applied and hence some optimality information could
no longer be valid? Defaults to <code>NULL</code> in which case this value
is taken from <code>RobAStBaseOptions</code>.</p>
</td></tr>
<tr><td><code id="getStartIC-methods_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>,
diagnostic information on the performed integrations is gathered and
shipped out as an attribute <code>diagnostic</code> of the return value
of the estimators. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getStartIC</code> is used internally in functions <code>robest</code>
and <code>roptest</code> to compute the optimally robust influence function
according to the arguments given to them.</p>


<h3>Value</h3>

<p>An IC of type <code>HampIC</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>getStartIC</dt><dd><p><code>signature(model = "ANY", risk = "ANY")</code>:
issue that this is not yet implemented. </p>
</dd>
<dt>getStartIC</dt><dd><p><code>signature(model = "L2ParamFamily", risk = "asGRisk")</code>:
depending on the values of argument <code>eps</code> (to be passed on through
the <code>...</code> argument) computes the optimally robust influence
function on the fly via calls to <code>optIC</code> or <code>radiusMinimaxIC</code>. </p>
</dd>
<dt>getStartIC</dt><dd><p><code>signature(model = "L2ParamFamily", risk = "asBias")</code>:
computes the most-bias-robust influence function on the fly via
calls to <code>optIC</code>. </p>
</dd>
<dt>getStartIC</dt><dd><p><code>signature(model = "L2ParamFamily", risk = "asCov")</code>:
computes the classically optimal influence function on the fly via
calls to <code>optIC</code>. </p>
</dd>
<dt>getStartIC</dt><dd><p><code>signature(model = "L2ParamFamily", risk = "trAsCov")</code>:
computes the classically optimal influence function on the fly via
calls to <code>optIC</code>. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+robest">robest</a></code>,<code><a href="#topic+optIC">optIC</a></code>, <code><a href="#topic+radiusMinimaxIC">radiusMinimaxIC</a></code></p>

<hr>
<h2 id='inputGenerators'>Input generating functions for function 'robest'</h2><span id='topic+inputGenerators'></span><span id='topic+gennbCtrl'></span><span id='topic+genstartCtrl'></span><span id='topic+genstartICCtrl'></span><span id='topic+genkStepCtrl'></span>

<h3>Description</h3>

<p>Generating functions to generate structured input for function <code>robest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genkStepCtrl(useLast = getRobAStBaseOption("kStepUseLast"),
                    withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
                    IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
                    withICList = getRobAStBaseOption("withICList"),
                    withPICList = getRobAStBaseOption("withPICList"),
                    scalename = "scale", withLogScale = TRUE,
                    withEvalAsVar = NULL, withMakeIC = FALSE,
                    E.argList = NULL)
genstartCtrl(initial.est = NULL, initial.est.ArgList = NULL,
                        startPar = NULL, distance = CvMDist, withMDE = NULL,
                        E.argList = NULL)
gennbCtrl(neighbor = ContNeighborhood(), eps, eps.lower, eps.upper)
genstartICCtrl(withMakeIC = FALSE, withEvalAsVar = NULL, modifyICwarn = NULL,
               E.argList = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inputGenerators_+3A_uselast">useLast</code></td>
<td>
<p> which parameter estimate (initial estimate or
k-step estimate) shall be used to fill the slots <code>pIC</code>,
<code>asvar</code> and <code>asbias</code> of the return value. </p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_withupdateinker">withUpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>, shall
the parameter be updated on <code class="reqn">{\rm ker}(D)</code>?</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_ic.updateinker">IC.UpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>,
the IC to be used for this; if <code>NULL</code> the result of <code>getboundedIC(L2Fam,D)</code> is taken;
this IC will then be projected onto <code class="reqn">{\rm ker}(D)</code>.</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_withiclist">withICList</code></td>
<td>
<p>logical: shall slot <code>ICList</code> of return value
be filled?</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_withpiclist">withPICList</code></td>
<td>
<p>logical: shall slot <code>pICList</code> of return value
be filled?</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_scalename">scalename</code></td>
<td>
<p>character: name of the respective scale component.</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_withlogscale">withLogScale</code></td>
<td>
<p>logical; shall a scale component (if existing and found
with name <code>scalename</code>) be computed on log-scale and backtransformed
afterwards? This avoids crossing 0.</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_withevalasvar">withEvalAsVar</code></td>
<td>
<p>logical or <code>NULL</code>: if <code>TRUE</code> (default), tells R
to evaluate the asymptotic variance or if <code>FALSE</code> just to produces a call
to do so. If <code>withEvalAsVar</code> is <code>NULL</code> (default),  the content
of slot <code>.withEvalAsVar</code> in the L2 family is used instead to take
this decision.</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_withmakeic">withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_modifyicwarn">modifyICwarn</code></td>
<td>
<p>logical: should a (warning) information be added if
<code>modifyIC</code> is applied and hence some optimality information could
no longer be valid? Defaults to <code>NULL</code> in which case this value
is taken from <code>RobAStBaseOptions</code>.</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_initial.est">initial.est</code></td>
<td>
<p> initial estimate for unknown parameter. If missing
minimum distance estimator is computed. </p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_initial.est.arglist">initial.est.ArgList</code></td>
<td>
<p>a list of arguments to be given to argument <code>start</code> if the latter
is a function; this list by default already starts with two unnamed items,
the sample <code>x</code>, and the model <code>L2Fam</code>.</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_startpar">startPar</code></td>
<td>
<p> initial information used by <code>optimize</code> resp. <code>optim</code>;
i.e; if (total) parameter is of length 1, <code>startPar</code> is
a search interval, else it is an initial parameter value; if <code>NULL</code>
slot <code>startPar</code> of <code>ParamFamily</code> is used to produce it;
in the multivariate case, <code>startPar</code> may also be of class <code>Estimate</code>,
in which case slot <code>untransformed.estimate</code> is used.</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_distance">distance</code></td>
<td>
<p> distance function </p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_withmde">withMDE</code></td>
<td>
<p> logical or NULL: Shall a minimum distance estimator be used as
starting estimator in <code>roptest()</code> / <code>robest()</code>&mdash;in addition to
the function given in argument <code>startPar</code> of the current function
or, if the argument is <code>NULL</code>, in slot <code>startPar</code> of the L2
family? If <code>NULL</code> (default) the content of slot <code>.withMDE</code> in
the L2 family is used instead to take this decision.</p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"UncondNeighborhood"</code> </p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_eps">eps</code></td>
<td>
<p> positive real (0 &lt; <code>eps</code> &lt;= 0.5): amount of gross errors.
See details below. </p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_eps.lower">eps.lower</code></td>
<td>
<p> positive real (0 &lt;= <code>eps.lower</code> &lt;= <code>eps.upper</code>):
lower bound for the amount of gross errors. See details below. </p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_eps.upper">eps.upper</code></td>
<td>
<p> positive real (<code>eps.lower</code> &lt;= <code>eps.upper</code> &lt;= 0.5):
upper bound for the amount of gross errors. See details below. </p>
</td></tr>
<tr><td><code id="inputGenerators_+3A_e.arglist">E.argList</code></td>
<td>
<p><code>NULL</code> (default) or a list of arguments to be passed
to calls to <code>E</code>; appears (and may vary from instance to instance)
as argument in the generators <code>genkStepCtrl</code>, <code>genstartCtrl</code>
<code>genstartICCtrl</code>. The one in <code>genstartCtrl</code> is used for
<code>MDEstimator</code> in case <code>initial.est</code> is <code>NULL</code> only.
Arguments for calls to <code>E</code> in an explicit function argument
<code>initial.est</code> should be entered to argument <code>initial.est.ArgList</code>.
Potential clashes with arguments of the same name in <code>...</code>
are resolved by inserting the items of argument list <code>E.argList</code>
as named items to the argument lists, so in case of collisions the
item of <code>E.argList</code> overwrites the
existing one from <code>...</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these functions bundle their respective input to (reusable) lists
which can be used as arguments in function <code><a href="#topic+robest">robest</a></code>.
For details, see this function.
</p>


<h3>Value</h3>

<p>A list of arguments to be (re-)used as (structured) input for function <code>robest</code>;
more specifically, all arguments of the respective function are bundled into
a list, where arguments not explicitly specified in the call are filled with 
corresponding defaults as given in the usage section of this help file.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

 <p><code><a href="RobLox.html#topic+roblox">roblox</a></code>,
<code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>
<code><a href="RobAStBase.html#topic+UncondNeighborhood-class">UncondNeighborhood-class</a></code>,
<code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>genkStepCtrl()
genstartICCtrl()
genstartCtrl()
gennbCtrl()
</code></pre>

<hr>
<h2 id='internal_interpolate_helpers'>Internal helper functions for generating interpolation grids for
speed up in package ROptEst</h2><span id='topic+internal_interpolate_helpers'></span><span id='topic+internalInterpolate'></span><span id='topic+.saveGridToCSV'></span><span id='topic+.readGridFromCSV'></span><span id='topic+.generateInterpGrid'></span><span id='topic+.getLMGrid'></span><span id='topic+.RMXE.th'></span><span id='topic+.MBRE.th'></span><span id='topic+.OMSE.th'></span>

<h3>Description</h3>

<p>These functions are used internally to generate interpolation grids,
for Lagrange multipliers or LDEstimators in package <span class="pkg">RobExtremes</span>,
to be stored in the
respective &lsquo;<span class="file">sysdata.rda</span>&rsquo; file. </p>


<h3>Usage</h3>

<pre><code class='language-R'>
.RMXE.th(th, PFam, modifyfct, loRad = 0, upRad = Inf, z.start = NULL,
             A.start = NULL, upper = NULL, lower = NULL,
             OptOrIter = "iterate", maxiter = 50,
             tol = .Machine$double.eps^0.4, loRad0 = 1e-3, ...)
.MBRE.th(th, PFam, modifyfct,
             z.start = NULL, A.start = NULL, upper = 1e4,
             lower = 1e-4, OptOrIter = "iterate",
             maxiter = 50, tol = .Machine$double.eps^0.4, ...)
.OMSE.th(th, PFam, modifyfct, radius = 0.5,
             z.start = NULL, A.start = NULL, upper = 1e4,
             lower = 1e-4, OptOrIter = "iterate",
             maxiter = 50, tol = .Machine$double.eps^0.4, ...)

.getLMGrid(thGrid, PFam, optFct = .RMXE.th, modifyfct, radius = 0.5,
           GridFileName = "LMGrid.Rdata", withPrint = FALSE,
           upper = 1e4, lower = 1e-4, OptOrIter = "iterate",
           maxiter = 50, tol = .Machine$double.eps^0.4,
           loRad = 0, upRad = Inf, loRad0 = 1e-3,
           loRad.s = 0.2, upRad.s = 1, withStartLM = TRUE, len = 13)


.saveGridToCSV(Grid, toFileCSV, namPFam, nameInSysdata)

.readGridFromCSV(fromFileCSV)

.generateInterpGrid(thGrid, PFam, toFileCSV = "temp.csv",
            getFun = .getLMGrid, ..., modifyfct, nameInSysdata,
            GridFileName, withPrint = TRUE, len = 13)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal_interpolate_helpers_+3A_th">th</code></td>
<td>
<p>numeric of length 1; the grid value at which to compute LMs. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_pfam">PFam</code></td>
<td>
<p>an object of class <code>"ParamFamily"</code>, the parametric family
at which to evaluate the Lagrange multipliers or LDEstimators;
in our use case, it is a shape-scale model, hence the respective
(main) parameter must contain <code>"scale"</code> and <code>"shape"</code>. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_modifyfct">modifyfct</code></td>
<td>
<p>function with arguments <code>th</code> and <code>PFam</code> to move
the parametric family to the point of the grid value; returns the
moved parametric family.</p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_radius">radius</code></td>
<td>
<p> [for OMSE]: positive numeric of length 1: the radius of the
neighborhood for which the LM's are to be computed;
defaults to 0.5. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_lorad">loRad</code></td>
<td>
<p> the lower end point of the interval to be searched
in the inner optimization (for the least favorable situation
to the user-guessed radius). </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_uprad">upRad</code></td>
<td>
<p> the upper end point of the interval to be searched in the
inner optimization (for the least favorable situation
to the user-guessed radius). </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_lorad.s">loRad.s</code></td>
<td>
<p> the lower end point of the interval
to be searched in the outer optimization
(for the user-guessed radius); if <code>NULL</code>
set to <code>loRad</code> in the algorithm. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_uprad.s">upRad.s</code></td>
<td>
<p> the upper end point of the interval to be searched in the
outer optimization (for the user-guessed radius); if
<code>NULL</code> set to <code>upRad</code> in the algorithm. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_upper">upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_lower">lower</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_optoriter">OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_lorad0">loRad0</code></td>
<td>
<p> for numerical reasons: the effective lower bound for the zero search;
internally set to <code>max(loRad,loRad0)</code>. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_withstartlm">withStartLM</code></td>
<td>
<p> logical of length 1: shall the LM's of the preceding grid
value serve as starting value for the next grid value? </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_withprint">withPrint</code></td>
<td>
<p>logical of length 1: shall current grid value be printed out? </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_thgrid">thGrid</code></td>
<td>
<p>numeric; grid values. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_optfct">optFct</code></td>
<td>
<p>function with arguments <code>theta</code>, <code>PFam</code>,
and modifyfct; determines the Lagrange multipliers. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_gridfilename">GridFileName</code></td>
<td>
<p>character; if <code>GridFileName!=""</code>, the pure
y-grid values are saved under this filename. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_grid">Grid</code></td>
<td>
<p>numeric; grid matrix (x- and y-values). </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_tofilecsv">toFileCSV</code></td>
<td>
<p>character; name of the csv file to which the grid is written. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_nampfam">namPFam</code></td>
<td>
<p>character; name of the parametric family for which the grid
was generated. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_nameinsysdata">nameInSysdata</code></td>
<td>
<p>character; grid name (e.g., 'OMSE', 'Sn') for which the grid
was generated. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_fromfilecsv">fromFileCSV</code></td>
<td>
<p>character; name of the csv file from which the grid is read. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_getfun">getFun</code></td>
<td>
<p>function with first argument <code>th</code>, second argument
<code>PFam</code> and last arguments <code>GridFileName</code>,
<code>withPrint</code>; produces the y-values for the
interpolation grid. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on, e.g., to <code>getFun</code>. </p>
</td></tr>
<tr><td><code id="internal_interpolate_helpers_+3A_len">len</code></td>
<td>
<p>integer; number of Lagrange multipliers to be calibrated. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.MBRE.th</code> computes the Lagrange multipliers for the MBRE estimator,
<code>.OMSE.th</code> for the OMSE estimator at radius <code>radius</code>,
and <code>.RMXE.th</code> the RMXE estimator.
</p>
<p><code>.getLMGrid</code> in a large loop computes the Lagrange multipliers for
optimally robust IFs for each element of a given grid.
</p>
<p><code>.saveGridToCSV</code> saves a given grid to a csv file, and in addition,
in a file with same name but with file extension &quot;.txt&quot; writes the
parametric family and the grid name.
</p>
<p><code>.readGridFromCSV</code> reads in a grid from a csv file together with the
information given in the corresponding &quot;.txt&quot; file.
</p>
<p><code>.generateInterpGrid</code> by means of calls to function-argument <code>getFun</code>
(e.g. <code>getLMGrid</code> computes the grid, if desired smoothes it, and
then saves it to <code>.csv</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.MBRE.th</code></td>
<td>
<p>A list with items <code>b</code> (a number; clipping height),
<code>a</code> (a 2-vector; outer centering),
<code>a.w</code> (a 2-vector; inner centering, in
the weight), <code>A</code> (a 2x2 matrix; outer standardization),
<code>A.w</code> (a 2x2 matrix; inner standardization, in the weight).
</p>
</td></tr>
<tr><td><code>.OMSE.th</code></td>
<td>
<p>as <code>.MBRE.th</code>. </p>
</td></tr>
<tr><td><code>.RMXE.th</code></td>
<td>
<p>as <code>.MBRE.th</code>. </p>
</td></tr>
<tr><td><code>.getLMGrid</code></td>
<td>
<p>A grid (in form  of a matrix of x and y-values) pasted
together by <code>cbind</code>. </p>
</td></tr>
<tr><td><code>.saveGridToCSV</code></td>
<td>
<p><code>invisible(NULL)</code>. </p>
</td></tr>
<tr><td><code>.readGridFromCSV</code></td>
<td>
<p> a list with the read-in items, i.e.,
an item <code>Grid</code> with the grid, an item <code>namPFam</code> with the name of
the parametric family, and <code>namInSysdata</code>, the name of the read in grid. </p>
</td></tr>
<tr><td><code>.generateInterpGrid</code></td>
<td>
<p><code>invisible(NULL)</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>These functions are only meant for the developers of package
<span class="pkg">ROptEst</span> (or respective packages).
They can be used to speed up things by interpolation.
Our use case is a speed up for further scale-shape families (or enhance
existing speed-ups) such that the respective grids are stored in
a  &lsquo;<span class="file">sysdata.rda</span>&rsquo; file of an external package <span class="pkg">RobAStRda</span>
&mdash;see mail exchange P.Ruckdeschel - U.Ligges on R-devel&mdash;
<a href="https://stat.ethz.ch/pipermail/r-devel/2013-February/065794.html">https://stat.ethz.ch/pipermail/r-devel/2013-February/065794.html</a>.
Special attention has to be paid for R-versions pre and post R-2.16
which is why we use <code>.versionSuff</code>.
</p>

<hr>
<h2 id='internals_for_MBRE_computation'>Internal / Helper function of package ROptEst for MBRE calculation</h2><span id='topic+internals_for_MBRE_computation'></span><span id='topic+.getExtremeCoordIC'></span>

<h3>Description</h3>

<p>This function computes the coordinatewise min and max of an IC
numerically.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getExtremeCoordIC(IC, D, indi, n = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_MBRE_computation_+3A_ic">IC</code></td>
<td>
<p>object of class <code>IC</code></p>
</td></tr>
<tr><td><code id="internals_for_MBRE_computation_+3A_d">D</code></td>
<td>
<p>a univariate distribution; by means of <code>q(D)</code>,
we determine the evaluation grid.</p>
</td></tr>
<tr><td><code id="internals_for_MBRE_computation_+3A_indi">indi</code></td>
<td>
<p>integer; the indices of the coordinates at which to compute min
and max.</p>
</td></tr>
<tr><td><code id="internals_for_MBRE_computation_+3A_n">n</code></td>
<td>
<p>integer; number of grid points for evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with <code>length(indi)</code> rows and 2 columns <code>min</code> and <code>max</code>:
the coordinate-wise min and max of the IC.</p>

<hr>
<h2 id='internals_for_ROptEst'>Internal / Helper functions of package ROptEst</h2><span id='topic+internals_for_ROptEst'></span><span id='topic+.checkUpLow'></span><span id='topic+.getUpperSol'></span><span id='topic+.getLowerSol'></span><span id='topic+.getLowUpB'></span><span id='topic+.checkPIC'></span><span id='topic+.LowerCaseMultivariate'></span><span id='topic+.LowerCaseMultivariateTV'></span><span id='topic+.isVirginW'></span><span id='topic+.getSB'></span>

<h3>Description</h3>

<p>These functions are used internally by package <span class="pkg">ROptEst</span>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>### helper function to check whether given b is in (bmin, bmax)
###        if not returns corresponding upper / lower case solution

.checkUpLow(L2deriv, b, risk, neighbor, biastype, normtype,
                        Distr, Finfo, DistrSymm, L2derivSymm,
                        L2derivDistrSymm, z.start, A.start, trafo, maxiter,
                        tol, QuadForm, verbose, nrvalpts, warn, ...)
                        
### helper function to return the upper case solution if r=0
.getUpperSol(L2deriv, radius, risk, neighbor, biastype,
                       normtype, Distr, Finfo, trafo,
                       QuadForm, verbose, warn, ...)

### helper function to return the lower case solution if b-search was not successful
.getLowerSol(L2deriv, risk, neighbor, Distr, DistrSymm,
                         L2derivSymm, L2derivDistrSymm,
                         z.start, A.start, trafo,
                         maxiter, tol, warn, Finfo, QuadForm, verbose, ...)


### helper function to return upper &amp; lower bounds for b for b-search
.getLowUpB(L2deriv, Finfo, Distr, normtype, z, A, radius, iter)

### helper function to check whether (TotalVariation) weight w has already been modified
.isVirginW(w)

### helper function to check whether (intermediate) results give a pIC
.checkPIC(L2deriv, neighbor, Distr, trafo, z, A, w, z.comp, A.comp, ...)

.LowerCaseMultivariate(L2deriv, neighbor, biastype,
             normtype, Distr, Finfo, trafo, z.start = NULL,
             A.start = NULL, z.comp = NULL, A.comp = NULL,
             maxiter, tol, verbose = NULL, ...)

.LowerCaseMultivariateTV(L2deriv, neighbor, biastype,
             normtype, Distr, Finfo, trafo,
             A.start,  maxiter, tol,
             verbose = NULL, ...)

.getSB(IC,neighbor, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_ROptEst_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family
of probability measures. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_b">b</code></td>
<td>
<p>numeric; clipping bound under consideration.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_biastype">biastype</code></td>
<td>
<p>object of class <code>"BiasType"</code> &mdash; the bias type with we work.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_normtype">normtype</code></td>
<td>
<p>object of class <code>"NormType"</code> &mdash; the norm type with we work.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_finfo">Finfo</code></td>
<td>
<p> Fisher information matrix. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_distrsymm">DistrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_l2derivsymm">L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_l2derivdistrsymm">L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_quadform">QuadForm</code></td>
<td>
<p> matrix of (or which may coerced to) class
<code>PosSemDefSymmMatrix</code> for use of different
(standardizing) norm </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_nrvalpts">nrvalpts</code></td>
<td>
<p>integer: number of evaluation points.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_radius">radius</code></td>
<td>
<p>radius of the neighborhood.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_z">z</code></td>
<td>
<p>centering constant (in <code>k</code>-space)</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_a">A</code></td>
<td>
<p>standardizing matrix.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_w">w</code></td>
<td>
<p>a weight of class <code>"BdStWeight"</code></p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_z.comp">z.comp</code></td>
<td>
<p>logical vector: indicator which components of <code>z</code> need
to be computed</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_a.comp">A.comp</code></td>
<td>
<p>logical matrix: indicator which components of <code>A</code> need
to be computed</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_iter">iter</code></td>
<td>
<p>the number of iterations computed so far; used for specifying
a different value of the clipping component of the weight in
total variation case in the very first iteration.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_ic">IC</code></td>
<td>
<p>some IC of class <code>"IC"</code></p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on <code>E()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.checkUpLow</code> checks whether the given clipping height <code>b</code> lies in
<code class="reqn">(b_{\rm\scriptstyle min},b_{\rm\scriptstyle min})</code>;
<code>.getUpperSol</code> determines the upper case/classical solution and computes
corresponding risks
<code>.getLowerSol</code> determines the lower case (minimax bias) solution and computes
corresponding risks
<code>.getLowUpB</code> determines a search interval for <code>b</code> to given radius
<code>r</code>, i.e., lower and upper bounds for
<code class="reqn">(b_{\rm\scriptstyle min},b_{\rm\scriptstyle min})</code>
<code>.isVirginW</code> checks whether the (total variation) weight <code>w</code> in
the argument has already been modified since creation (<code>TRUE</code> if not)
<code>.checkPIC</code> checks whether (intermediate) results give a pIC
<code>.LowerCaseMultivariatefunction</code> determines the Lagrange multipliers for
the multivariate lower case solution for convex contamination
by solving a corresponding dual problem (Rieder[94],p.199 eq.(18)).
<code>.LowerCaseMultivariatefunctionTV</code> determines the Lagrange multipliers for
the multivariate lower case solution for total variation in dimension <code class="reqn">p=1</code>
and <code class="reqn">k&gt;1</code> by solving a corresponding dual problem (Rieder[94],p.205 eq.(58)).
<code>.getSB</code> computes the bias and (the square root of the trace of) the variance
of the IC.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.checkUpLow</code></td>
<td>
<p>a list with items <code>up</code> (logical)
<code>low</code> (logical) and <code>res</code> a return list for
<code>getInfRobIC</code> or <code>NULL</code>: if <code>up</code> is <code>TRUE</code>,
<code>res</code> contains the upper case solution,
if <code>low</code> is <code>TRUE</code> the lower case solution
and if both <code>low</code> and <code>up</code> are <code>FALSE</code>
<code>NULL</code>.</p>
</td></tr>
<tr><td><code>.getUpperSol</code></td>
<td>
<p>a return list for <code>getInfRobIC</code></p>
</td></tr>
<tr><td><code>.getLowerSol</code></td>
<td>
<p>a return list for <code>getInfRobIC</code></p>
</td></tr>
<tr><td><code>.checkUpLow</code></td>
<td>
<p>a list with items <code>lower</code> and <code>upper</code> (both numeric).</p>
</td></tr>
<tr><td><code>.isVirginW</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code></p>
</td></tr>
<tr><td><code>.checkPIC</code></td>
<td>
<p>nothing is returned; precision values are issued.</p>
</td></tr>
<tr><td><code>.LowerCaseMultivariatefunction</code></td>
<td>
<p>a list with elements
<code>erg</code> the return value of the corresponding call to <code>optim</code>,
<code>w</code> the corresponding weight (of class <code>HampelWeight</code>),
<code>normtype</code> the norm &mdash;possibly modified,
<code>z.comp</code> the indices of non-null entries in <code>z</code>.</p>
</td></tr>
<tr><td><code>.LowerCaseMultivariatefunctionTV</code></td>
<td>
<p>a list with elements
<code>A</code> the standardization matrix,
<code>b</code> the minimax bias,
<code>w</code> the corresponding weight (of class <code>BdStWeight</code>),
<code>a</code> the corresponding infimum of the [p]IC.</p>
</td></tr>
<tr><td><code>.getSB</code></td>
<td>
<p>a list with elements <code>s</code>, (the square root of the trace of) 
the variance and <code>b</code>, the bias.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>

<hr>
<h2 id='internals_for_ROptEst_Cniperplots'>Internal / Helper functions of package ROptEst for cniper plot functions</h2><span id='topic+internals_for_ROptEst_Cniperplots'></span><span id='topic+.plotData'></span><span id='topic+.getFunCnip'></span>

<h3>Description</h3>

<p>These functions are internally used helper function for <code><a href="#topic+cniperCont">cniperCont</a></code>
and <code>cniperPointPlot</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.plotData(data, dots, fun, L2Fam,  IC, jit.fac, jit.tol, plotInfo )
.getFunCnip(IC1,IC2, risk, L2Fam, r, b20=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_data">data</code></td>
<td>
<p>data to be plot in</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_dots">dots</code></td>
<td>
<p>list; argument <code>...</code> from the calling function</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_fun">fun</code></td>
<td>
<p>function from data to reals; function according to which
the data is ordered</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_l2fam">L2Fam</code></td>
<td>
<p> object of class <code>L2ParamFamily</code> </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_ic">IC</code></td>
<td>
<p>object of class <code>IC</code>: To determine the size of the observation
symbols, we compute the norm of the IC evaluated at this point.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_ic1">IC1</code></td>
<td>
<p>object of class <code>IC</code>: one of the ICs from which to take the
risk difference.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_ic2">IC2</code></td>
<td>
<p>object of class <code>IC</code>: one of the ICs from which to take the
risk difference.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_risk">risk</code></td>
<td>
<p>object of class <code>asGRisk</code>: the risk to take the fifference
from</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_r">r</code></td>
<td>
<p>positive numeric of length 1: the neighborhood radius</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_b20">b20</code></td>
<td>
<p>positive numeric of length 1: the maximal bias of <code>IC2</code>.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_jit.fac">jit.fac</code></td>
<td>
<p>jittering factor used in case of a <code>DiscreteDistribution</code>
for plotting points of the second argument in a jittered fashion.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_jit.tol">jit.tol</code></td>
<td>
<p>jittering tolerance used in case of a <code>DiscreteDistribution</code>
for plotting points of the second argument in a jittered fashion.</p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_Cniperplots_+3A_plotinfo">plotInfo</code></td>
<td>
<p>stored info from the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.plotData</code> takes argument <code>data</code> and plots it into the cniper graph.
</p>
<p><code>.getFunCnip</code> produces a function to compute the risk difference. If
argument <code>b20</code> is not <code>NULL</code>, in the risk difference, for <code>IC2</code>
uses the least favorable contamination situation
('over all real Dirac contamination points'), i.e. leading to a bias
of <code>b20</code>. Otherwise it uses the bias obtaine from a contamination
in the evaluation point.
</p>


<h3>Value</h3>

<table>
<tr><td><code>.plotData</code></td>
<td>

<p>If argument <code>dots</code> contains an element <code>return.Order</code> and
if this equals <code>TRUE</code>, the order of the (remaining) observations
given by their original index is returned (remaining means: after a possible
reduction by argument <code>which.lbs</code>, and ordering is according <code>fun</code>;
otherwise we return <code>invisible()</code> as usual.</p>
</td></tr>
<tr><td><code>.getFunCnip</code></td>
<td>

<p>a vectorized function to compute the risk difference.
</p>
</td></tr>
</table>

<hr>
<h2 id='internals_for_ROptEst_robest'>Internal / Helper functions of package ROptEst for function robest</h2><span id='topic+internals_for_ROptEst_robest'></span><span id='topic+.dynScopeEval'></span><span id='topic+.constructArg.list'></span><span id='topic+.fix.in.defaults'></span><span id='topic+.pretreat'></span><span id='topic+.check.eps'></span><span id='topic+.isOKsteps'></span><span id='topic+.isOKfsCor'></span>

<h3>Description</h3>

<p>These functions are internally used helper functions for <code><a href="#topic+robest">robest</a></code>,
in package <span class="pkg">ROptEst</span>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.dynScopeEval(expr)
.constructArg.list(fun,matchCall, onlyFormal=FALSE, debug =FALSE)
.fix.in.defaults(call.list, fun, withEval=TRUE)
.pretreat(x, na.rm = TRUE)
.check.eps(...)
.isOKsteps(steps)
.isOKfsCor(fsCor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internals_for_ROptEst_robest_+3A_expr">expr</code></td>
<td>
<p>an expression. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_fun">fun</code></td>
<td>
<p>function, a matched call of which is manipulated. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_matchcall">matchCall</code></td>
<td>
<p>a return value of a call to <code>match.call</code>. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_onlyformal">onlyFormal</code></td>
<td>
<p>logical; shall arguments not explicitely contained in
the formals of <code>fun</code> be kept in the matched call? </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_debug">debug</code></td>
<td>
<p>logical: if switched on, issues information for debugging. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_call.list">call.list</code></td>
<td>
<p>a list of matched arguments drawn from a call to <code>match.call</code>
applied to <code>fun</code> which is to be supplemented by defaults of
not-yet-matched formals. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_witheval">withEval</code></td>
<td>
<p>logical: shall arguments be evaluated? </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_x">x</code></td>
<td>
<p>input data <code>x</code> of <code>robest</code> or <code>roptest</code>. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at
<code>complete.cases(x)</code>. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_...">...</code></td>
<td>
<p>input from <code>robest</code> or <code>roptest</code> from which to conclude
on radiuses. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_steps">steps</code></td>
<td>
<p>number of steps to be used in kStep estimator in <code>robest</code>. </p>
</td></tr>
<tr><td><code id="internals_for_ROptEst_robest_+3A_fscor">fsCor</code></td>
<td>
<p>argument <code>fsCor</code> of <code>robest</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.dynScopeEval</code> marches up the stack of calls to evaluate an expression,
hence realizes dynamical scoping.
</p>
<p><code>.constructArg.list</code> takes a function <code>fun</code> and the return value
of <code>match.call</code> and, as return value, produces a list of arguments where
the formal arguments of <code>fun</code> are set to their default values and
with extra item <code>esc</code>.<br />
</p>
<p>If argument <code>onlyFormals</code> is <code>TRUE</code> and the formals contain <code>...</code>,
the returned list only contains formal arguments of  <code>fun</code>, filled with
default values from the definition where available, and, in addition,
in element <code>esc</code> a list with element one of the original matched call
and, as subsequent elements, with the named, evaluated arguments of the
matched call which are no formal arguments of <code>fun</code>.<br />
</p>
<p>If argument <code>onlyFormals</code> is <code>FALSE</code> or the formals do not contain
<code>...</code>, the returned list again contains formal arguments of  <code>fun</code>
filled in with defaults where available, but in addition it contains the arguments
of the matched calls non matched to formals (in particular those passed on through
<code>...</code>). Then element <code>esc</code> in the returned list with contains
element one of the original matched call coerced to list, i.e., the name of
the called function.
</p>
<p><code>.fix.in.defaults</code> takes a list of arguments  of <code>fun</code> taken from a
matched call obtained by <code>match.call</code> from within a call of <code>fun</code>
(after coercing to list) and supplements this list by formal arguments of
<code>fun</code> which are not yet matched but have default arguments (with exactly
these default values). The return value is the prolongated list.
</p>
<p><code>.pretreat</code>,  if <code>is.numeric(x)</code> is <code>FALSE</code>, coerces <code>x</code>
to a numeric matrix (by a call to <code>data.matrix</code> in case
<code>x</code> is a data.frame, respectively, by a call to <code>as.matrix</code> else.
If <code>na.rm</code> is <code>TRUE</code>, <code>x</code> is reduced to <code>na.omit(x)</code>.
The return value is a list of elements <code>x</code>, the possibly modified
input <code>x</code>, and <code>completecases</code>, the return value of
<code>compeletecases(x)</code>.
</p>
<p><code>.check.eps</code> takes its input (possibly empty in part)
and returns a list <code>eps</code> with elements <code>sqn</code>, <code>e</code>,
<code>lower</code>, and <code>upper</code>. Necessarily the input <code>...</code> must
contain an argument matching to <code>x</code>, and <code>sqn</code> is the square root
of either the length of <code>x</code> (if <code>x</code> is a vector) or the number of
columns of <code>x</code> (in case <code>dim(x)==2</code>). In case <code>...</code> contains
none of the elements <code>eps</code>, <code>eps.lower</code>, <code>eps.upper</code>, elements
<code>lower</code> and <code>upper</code> of the return value are set to <code>0</code> and
<code>0.5</code>, respectively. Else, if <code>eps</code> is contained input <code>...</code>
element <code>e</code> of the return list is set to <code>eps</code>, and
<code>lower</code> and <code>upper</code> are left empty. Otherwise, element <code>e</code>
of the return list is left empty and  <code>lower</code> and <code>upper</code> are filled
with <code>eps.lower</code> and <code>eps.upper</code> from input <code>...</code> if available
and else with default values <code>0</code> and <code>0.5</code>, respectively.
</p>
<p><code>.isOKsteps</code> checks whether argument <code>steps</code> is a valid
argument, i.e., is an integer larger than 0 of length 1 and, accordingly,
returns <code>TRUE</code> or <code>FALSE</code>.
</p>
<p><code>.isOKfsCor</code> checks whether argument <code>fsCor</code> is a valid
argument, i.e., larger than 0 and of length 1 and, accordingly,
returns <code>TRUE</code> or <code>FALSE</code>.
</p>

<hr>
<h2 id='leastFavorableRadius'>Generic Function for the Computation of Least Favorable Radii</h2><span id='topic+leastFavorableRadius'></span><span id='topic+leastFavorableRadius-methods'></span><span id='topic+leastFavorableRadius+2CL2ParamFamily+2CUncondNeighborhood+2CasGRisk-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of least favorable radii.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leastFavorableRadius(L2Fam, neighbor, risk, ...)

## S4 method for signature 'L2ParamFamily,UncondNeighborhood,asGRisk'
leastFavorableRadius(
          L2Fam, neighbor, risk, rho, upRad = 1, 
            z.start = NULL, A.start = NULL, upper = 100,
            OptOrIter = "iterate", maxiter = 100,
            tol = .Machine$double.eps^0.4, warn = FALSE, verbose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leastFavorableRadius_+3A_l2fam">L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures. </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_uprad">upRad</code></td>
<td>
<p> the upper end point of the radius interval to be searched. </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_rho">rho</code></td>
<td>
<p> The considered radius interval is: <code class="reqn">[r \rho, r/\rho]</code>
with <code class="reqn">\rho\in(0,1)</code>. </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_upper">upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_optoriter">OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td></tr>
<tr><td><code id="leastFavorableRadius_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to <code>E</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The least favorable radius and the corresponding inefficiency 
are computed.
</p>


<h3>Methods</h3>


<dl>
<dt>L2Fam = &quot;L2ParamFamily&quot;, neighbor = &quot;UncondNeighborhood&quot;, 
risk = &quot;asGRisk&quot;</dt><dd><p> computation of the least favorable radius. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

 
<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of not Knowing
the Radius. Statistical Methods and Applications, <em>17</em>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2001). The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>.
</p>
<p>P. Ruckdeschel (2005). Optimally One-Sided Bounded Influence Curves.
Mathematical Methods of Statistics <em>14</em>(1), 105-131.
</p>
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radiusMinimaxIC">radiusMinimaxIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- NormLocationFamily(mean=0, sd=1) 
leastFavorableRadius(L2Fam=N, neighbor=ContNeighborhood(),
                     risk=asMSE(), rho=0.5)
</code></pre>

<hr>
<h2 id='lowerCaseRadius'>Computation of the lower case radius</h2><span id='topic+lowerCaseRadius'></span><span id='topic+lowerCaseRadius-methods'></span><span id='topic+lowerCaseRadius+2CL2ParamFamily+2CContNeighborhood+2CasMSE+2CANY-method'></span><span id='topic+lowerCaseRadius+2CL2ParamFamily+2CTotalVarNeighborhood+2CasMSE+2CANY-method'></span><span id='topic+lowerCaseRadius+2CL2ParamFamily+2CContNeighborhood+2CasMSE+2ConesidedBias-method'></span><span id='topic+lowerCaseRadius+2CUnivariateDistribution+2CContNeighborhood+2CasMSE+2ConesidedBias-method'></span><span id='topic+lowerCaseRadius+2CL2ParamFamily+2CContNeighborhood+2CasMSE+2CasymmetricBias-method'></span>

<h3>Description</h3>

<p>The lower case radius is computed; confer Subsection 2.1.2 
in Kohl (2005) and formula (4.5) in Ruckdeschel (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowerCaseRadius(L2Fam, neighbor, risk, biastype, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowerCaseRadius_+3A_l2fam">L2Fam</code></td>
<td>
<p> L2 differentiable parametric family </p>
</td></tr>
<tr><td><code id="lowerCaseRadius_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code> </p>
</td></tr>
<tr><td><code id="lowerCaseRadius_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code> </p>
</td></tr>
<tr><td><code id="lowerCaseRadius_+3A_biastype">biastype</code></td>
<td>
<p> object of class <code>"BiasType"</code> </p>
</td></tr>
<tr><td><code id="lowerCaseRadius_+3A_...">...</code></td>
<td>
<p> additional parameters </p>
</td></tr>
</table>


<h3>Value</h3>

<p>lower case radius</p>


<h3>Methods</h3>


<dl>
<dt>L2Fam = &quot;L2ParamFamily&quot;, neighbor = &quot;ContNeighborhood&quot;, risk = &quot;asMSE&quot;,
biastype = &quot;BiasType&quot;</dt><dd>
<p>lower case radius for risk <code>"asMSE"</code> in case of <code>"ContNeighborhood"</code>
for symmetric bias.</p>
</dd>
<dt>L2Fam = &quot;L2ParamFamily&quot;, neighbor = &quot;TotalVarNeighborhood&quot;, risk = &quot;asMSE&quot;,
biastype = &quot;BiasType&quot;</dt><dd>
<p>lower case radius for risk <code>"asMSE"</code> in case of <code>"TotalVarNeighborhood"</code>;
(argument biastype is just for signature reasons).</p>
</dd>
<dt>L2Fam = &quot;L2ParamFamily&quot;, neighbor = &quot;ContNeighborhood&quot;, risk = &quot;asMSE&quot;,
biastype = &quot;onesidedBias&quot;</dt><dd>
<p>lower case radius for risk <code>"asMSE"</code> in case of <code>"ContNeighborhood"</code>
for onesided bias.</p>
</dd>
<dt>L2Fam = &quot;L2ParamFamily&quot;, neighbor = &quot;ContNeighborhood&quot;, risk = &quot;asMSE&quot;,
biastype = &quot;asymmetricBias&quot;</dt><dd>
<p>lower case radius for risk <code>"asMSE"</code> in case of <code>"ContNeighborhood"</code>
for asymmetric bias.</p>
</dd>
<dt>L2Fam = &quot;UnivariateDistribution&quot;, neighbor = &quot;ContNeighborhood&quot;, risk = &quot;asMSE&quot;,
biastype = &quot;onesidedBias&quot;</dt><dd><p> used only internally; 
trick to be able to call lower case radius from within minmax bias solver</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>, <code><a href="RobAStBase.html#topic+Neighborhood-class">Neighborhood-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lowerCaseRadius(BinomFamily(size = 10), ContNeighborhood(), asMSE())
lowerCaseRadius(BinomFamily(size = 10), TotalVarNeighborhood(), asMSE())
</code></pre>

<hr>
<h2 id='minmaxBias'> Generic Function for the Computation of Bias-Optimally Robust ICs </h2><span id='topic+minmaxBias'></span><span id='topic+minmaxBias-methods'></span><span id='topic+minmaxBias+2CUnivariateDistribution+2CContNeighborhood+2CBiasType-method'></span><span id='topic+minmaxBias+2CUnivariateDistribution+2CContNeighborhood+2ConesidedBias-method'></span><span id='topic+minmaxBias+2CUnivariateDistribution+2CContNeighborhood+2CasymmetricBias-method'></span><span id='topic+minmaxBias+2CUnivariateDistribution+2CTotalVarNeighborhood+2CBiasType-method'></span><span id='topic+minmaxBias+2CRealRandVariable+2CContNeighborhood+2CBiasType-method'></span><span id='topic+minmaxBias+2CRealRandVariable+2CTotalVarNeighborhood+2CBiasType-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of bias-optimally robust ICs 
in case of infinitesimal robust models. This function is 
rarely called directly. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minmaxBias(L2deriv, neighbor, biastype, ...)

## S4 method for signature 'UnivariateDistribution,ContNeighborhood,BiasType'
minmaxBias(L2deriv,
     neighbor, biastype, symm, trafo, maxiter, tol, warn, Finfo, verbose = NULL)

## S4 method for signature 
## 'UnivariateDistribution,ContNeighborhood,asymmetricBias'
minmaxBias(
     L2deriv, neighbor, biastype, symm, trafo, maxiter, tol, warn, Finfo, verbose = NULL)

## S4 method for signature 
## 'UnivariateDistribution,ContNeighborhood,onesidedBias'
minmaxBias(
     L2deriv, neighbor, biastype, symm, trafo, maxiter, tol, warn, Finfo, verbose = NULL)

## S4 method for signature 
## 'UnivariateDistribution,TotalVarNeighborhood,BiasType'
minmaxBias(
     L2deriv, neighbor, biastype, symm, trafo, maxiter, tol, warn, Finfo, verbose = NULL)

## S4 method for signature 'RealRandVariable,ContNeighborhood,BiasType'
minmaxBias(L2deriv,
     neighbor, biastype, normtype, Distr, z.start, A.start,  z.comp, A.comp,
     Finfo, trafo, maxiter, tol, verbose = NULL, ...)

## S4 method for signature 'RealRandVariable,TotalVarNeighborhood,BiasType'
minmaxBias(L2deriv,
     neighbor, biastype, normtype, Distr, z.start, A.start,  z.comp, A.comp,
     Finfo, trafo, maxiter, tol, verbose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minmaxBias_+3A_l2deriv">L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family 
of probability measures. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_biastype">biastype</code></td>
<td>
<p> object of class <code>"BiasType"</code>. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_normtype">normtype</code></td>
<td>
<p> object of class <code>"NormType"</code>. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to <code>E</code> </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_distr">Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_symm">symm</code></td>
<td>
<p> logical: indicating symmetry of <code>L2deriv</code>. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_z.comp">z.comp</code></td>
<td>
 <p><code>logical</code> indicator which indices need to be computed and which are 0 due to symmetry. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_a.comp">A.comp</code></td>
<td>
 <p><code>matrix</code> of <code>logical</code> indicator which indices need to be computed and which are 0 due to symmetry.</p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_trafo">trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_finfo">Finfo</code></td>
<td>
<p> Fisher information matrix. </p>
</td></tr>
<tr><td><code id="minmaxBias_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The bias-optimally robust IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;BiasType&quot;</dt><dd> 
<p>computes the bias optimal influence curve for symmetric bias for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;asymmetricBias&quot;</dt><dd> 
<p>computes the bias optimal influence curve for asymmetric bias for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = &quot;UnivariateDistribution&quot;, neighbor = &quot;TotalVarNeighborhood&quot;, 
biastype = &quot;BiasType&quot;</dt><dd> 
<p>computes the bias optimal influence curve for symmetric bias for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, neighbor = &quot;ContNeighborhood&quot;, 
biastype = &quot;BiasType&quot;</dt><dd> 
<p>computes the bias optimal influence curve for symmetric bias for L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate. </p>
</dd>
<dt>L2deriv = &quot;RealRandVariable&quot;, neighbor = &quot;TotalNeighborhood&quot;,
biastype = &quot;BiasType&quot;</dt><dd>
<p>computes the bias optimal influence curve for symmetric bias for L2 differentiable
parametric families in a setting where we are interested in a <code class="reqn">p=1</code>
dimensional aspect of an unknown <code class="reqn">k</code>-dimensional parameter
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+InfRobModel-class">InfRobModel-class</a></code></p>

<hr>
<h2 id='optIC'>Generic function for the computation of optimally robust ICs</h2><span id='topic+optIC'></span><span id='topic+optIC-methods'></span><span id='topic+optIC+2CInfRobModel+2CasRisk-method'></span><span id='topic+optIC+2CInfRobModel+2CasUnOvShoot-method'></span><span id='topic+optIC+2CFixRobModel+2CfiUnOvShoot-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of optimally robust ICs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optIC(model, risk, ...)

## S4 method for signature 'InfRobModel,asRisk'
optIC(model, risk, z.start = NULL, A.start = NULL,
                                     upper = 1e4, lower = 1e-4,
                                     OptOrIter = "iterate", maxiter = 50,
                                     tol = .Machine$double.eps^0.4, warn = TRUE, 
                                     noLow = FALSE, verbose = NULL, ...,
                                     .withEvalAsVar = TRUE, withMakeIC = FALSE,
                                     returnNAifProblem = FALSE, modifyICwarn = NULL)

## S4 method for signature 'InfRobModel,asUnOvShoot'
optIC(model, risk, upper = 1e4,
                                          lower = 1e-4, maxiter = 50,
                                          tol = .Machine$double.eps^0.4,
                                          withMakeIC = FALSE, warn = TRUE,
                                          verbose = NULL, modifyICwarn = NULL, ...)

## S4 method for signature 'FixRobModel,fiUnOvShoot'
optIC(model, risk, sampleSize, upper = 1e4, lower = 1e-4,
                                          maxiter = 50, tol = .Machine$double.eps^0.4, 
                                          withMakeIC = FALSE, warn = TRUE,
                                          Algo = "A", cont = "left",
                                          verbose = NULL, modifyICwarn = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optIC_+3A_model">model</code></td>
<td>
<p> probability model. </p>
</td></tr>
<tr><td><code id="optIC_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="optIC_+3A_...">...</code></td>
<td>
<p>additional arguments; e.g. are passed on to <code>E</code> via
e.g. <code>makeIC</code> in case of all signature,
and, in addition, to <code>getInfRobIC</code> in case of
<code>signature("InfRobModel","asRisk")</code>.</p>
</td></tr>
<tr><td><code id="optIC_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="optIC_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="optIC_+3A_upper">upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="optIC_+3A_lower">lower</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="optIC_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="optIC_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="optIC_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>  
<tr><td><code id="optIC_+3A_samplesize">sampleSize</code></td>
<td>
<p> integer: sample size. </p>
</td></tr>
<tr><td><code id="optIC_+3A_algo">Algo</code></td>
<td>
<p> &quot;A&quot; or &quot;B&quot;. </p>
</td></tr>
<tr><td><code id="optIC_+3A_cont">cont</code></td>
<td>
<p> &quot;left&quot; or &quot;right&quot;. </p>
</td></tr>
<tr><td><code id="optIC_+3A_nolow">noLow</code></td>
<td>
<p> logical: is lower case to be computed? </p>
</td></tr>
<tr><td><code id="optIC_+3A_optoriter">OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations. </p>
</td></tr>
<tr><td><code id="optIC_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed. </p>
</td></tr>
<tr><td><code id="optIC_+3A_.withevalasvar">.withEvalAsVar</code></td>
<td>
<p>logical (of length 1):
if <code>TRUE</code>, risks based on covariances are to be
evaluated (default), otherwise just a call is returned. </p>
</td></tr>
<tr><td><code id="optIC_+3A_withmakeic">withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td></tr>
<tr><td><code id="optIC_+3A_returnnaifproblem">returnNAifProblem</code></td>
<td>
<p>logical (of length 1):
if <code>TRUE</code> (not the default), in case of convergence problems in
the algorithm, returns <code>NA</code>. </p>
</td></tr>
<tr><td><code id="optIC_+3A_modifyicwarn">modifyICwarn</code></td>
<td>
<p>logical: should a (warning) information be added if
<code>modifyIC</code> is applied and hence some optimality information could
no longer be valid? Defaults to <code>NULL</code> in which case this value
is taken from <code>RobAStBaseOptions</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> In case of the finite-sample risk <code>"fiUnOvShoot"</code> one can choose
between two algorithms for the computation of this risk where the least favorable
contamination is assumed to be left or right of some bound. For more details
we refer to Section 11.3 of Kohl (2005).</p>


<h3>Value</h3>

<p>Some optimally robust IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>model = &quot;InfRobModel&quot;, risk = &quot;asRisk&quot;</dt><dd> 
<p>computes optimally robust influence curve for 
robust models with infinitesimal neighborhoods and
various asymptotic risks. </p>
</dd>
<dt>model = &quot;InfRobModel&quot;, risk = &quot;asUnOvShoot&quot;</dt><dd> 
<p>computes optimally robust influence curve for 
robust models with infinitesimal neighborhoods and
asymptotic under-/overshoot risk. </p>
</dd>
<dt>model = &quot;FixRobModel&quot;, risk = &quot;fiUnOvShoot&quot;</dt><dd> 
<p>computes optimally robust influence curve for 
robust models with fixed neighborhoods and
finite-sample under-/overshoot risk. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P. (2010): R package distrMod: 
Object-Oriented Implementation of Probability Models. 
J. Statist. Softw.  <b>35</b>(10), 1&ndash;27. <a href="https://doi.org/10.18637/jss.v035.i10">doi:10.18637/jss.v035.i10</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333&ndash;354.  <a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2008) The Costs of not Knowing
the Radius. Statistical Methods and Applications <b>17</b>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2001) The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+InfluenceCurve-class">InfluenceCurve-class</a></code>, <code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- BinomFamily(size = 25, prob = 0.25) 

## classical optimal IC
IC0 &lt;- optIC(model = B, risk = asCov())
plot(IC0) # plot IC
checkIC(IC0, B)
</code></pre>

<hr>
<h2 id='optRisk'>Generic function for the computation of the minimal risk</h2><span id='topic+optRisk'></span><span id='topic+optRisk-methods'></span><span id='topic+optRisk+2CL2ParamFamily+2CasCov-method'></span><span id='topic+optRisk+2CInfRobModel+2CasRisk-method'></span><span id='topic+optRisk+2CFixRobModel+2CfiUnOvShoot-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the optimal (i.e., minimal) 
risk for a probability model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optRisk(model, risk, ...)

## S4 method for signature 'L2ParamFamily,asCov'
optRisk(model, risk)

## S4 method for signature 'InfRobModel,asRisk'
optRisk(model, risk, z.start = NULL,
                   A.start = NULL, upper = 1e4, maxiter = 50,
                   tol = .Machine$double.eps^0.4, warn = TRUE, noLow = FALSE)

## S4 method for signature 'FixRobModel,fiUnOvShoot'
optRisk(model, risk, sampleSize,
                   upper = 1e4, maxiter = 50, tol = .Machine$double.eps^0.4,
                   warn = TRUE, Algo = "A", cont = "left")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optRisk_+3A_model">model</code></td>
<td>
<p> probability model </p>
</td></tr>
<tr><td><code id="optRisk_+3A_risk">risk</code></td>
<td>
<p> object of class <code>RiskType</code> </p>
</td></tr>
<tr><td><code id="optRisk_+3A_...">...</code></td>
<td>
<p> additional parameters </p>
</td></tr>
<tr><td><code id="optRisk_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="optRisk_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="optRisk_+3A_upper">upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="optRisk_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations </p>
</td></tr>
<tr><td><code id="optRisk_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="optRisk_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>    
<tr><td><code id="optRisk_+3A_samplesize">sampleSize</code></td>
<td>
<p> integer: sample size. </p>
</td></tr>
<tr><td><code id="optRisk_+3A_algo">Algo</code></td>
<td>
<p> &quot;A&quot; or &quot;B&quot;. </p>
</td></tr>
<tr><td><code id="optRisk_+3A_cont">cont</code></td>
<td>
<p> &quot;left&quot; or &quot;right&quot;. </p>
</td></tr>
<tr><td><code id="optRisk_+3A_nolow">noLow</code></td>
<td>
<p> logical: is lower case to be computed? </p>
</td></tr>
</table>


<h3>Details</h3>

<p> In case of the finite-sample risk <code>"fiUnOvShoot"</code> one can choose
between two algorithms for the computation of this risk where the least favorable
contamination is assumed to be left or right of some bound. For more details
we refer to Section 11.3 of Kohl (2005).</p>


<h3>Value</h3>

<p>The minimal risk is computed.</p>


<h3>Methods</h3>


<dl>
<dt>model = &quot;L2ParamFamily&quot;, risk = &quot;asCov&quot;</dt><dd> 
<p>asymptotic covariance of L2 differentiable parameteric
family. </p>
</dd>
<dt>model = &quot;InfRobModel&quot;, risk = &quot;asRisk&quot;</dt><dd> 
<p>asymptotic risk of a infinitesimal robust model. </p>
</dd>
<dt>model = &quot;FixRobModel&quot;, risk = &quot;fiUnOvShoot&quot;</dt><dd> 
<p>finite-sample under-/overshoot risk of a robust model
with fixed neighborhood. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1968) Robust Confidence Limits. Z. Wahrscheinlichkeitstheor.
Verw. Geb. <b>10</b>:269&ndash;278.
</p>
<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106&ndash;115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>optRisk(model = NormLocationScaleFamily(), risk = asCov())
</code></pre>

<hr>
<h2 id='ORobEstimate-class'>ORobEstimate-class.</h2><span id='topic+ORobEstimate-class'></span><span id='topic+steps'></span><span id='topic+steps+2CORobEstimate-method'></span><span id='topic+ksteps'></span><span id='topic+ksteps+2CORobEstimate-method'></span><span id='topic+uksteps'></span><span id='topic+uksteps+2CORobEstimate-method'></span><span id='topic+ICList'></span><span id='topic+ICList+2CORobEstimate-method'></span><span id='topic+pICList'></span><span id='topic+pICList+2CORobEstimate-method'></span><span id='topic+roptestCall'></span><span id='topic+roptestCall+2CORobEstimate-method'></span><span id='topic+robestCall'></span><span id='topic+robestCall+2CORobEstimate-method'></span><span id='topic+start+2CORobEstimate-method'></span><span id='topic+startval'></span><span id='topic+startval+2CORobEstimate-method'></span><span id='topic+ustartval'></span><span id='topic+ustartval+2CORobEstimate-method'></span><span id='topic+show+2CORobEstimate-method'></span><span id='topic+timings+2CORobEstimate-method'></span><span id='topic+kStepTimings'></span><span id='topic+kStepTimings+2CORobEstimate-method'></span>

<h3>Description</h3>

<p>Class of optimally robust asymptotically linear estimates.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ORobEstimate", ...)</code>.
More frequently they are created as results of functions
<code>roptest</code>, <code>MBREstimator</code>, <code>RMXEstimator</code>, or
<code>OMSEstimator</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>:
name of the estimator. [*]</p>
</dd>
<dt><code>estimate</code></dt><dd><p>Object of class <code>"ANY"</code>:
estimate. [*]</p>
</dd>
<dt><code>estimate.call</code></dt><dd><p>Object of class <code>"call"</code>:
call by which estimate was produced. [*]</p>
</dd>
<dt><code>samplesize</code></dt><dd><p> object of class <code>"numeric"</code> &mdash;
the samplesize (only complete cases are counted)
at which the estimate was evaluated. [*]</p>
</dd>
<dt><code>completecases</code>:</dt><dd><p> object of class <code>"logical"</code> &mdash;
complete cases at which the estimate was evaluated. [*]</p>
</dd>
<dt><code>asvar</code></dt><dd><p> object of class <code>"OptionalNumericOrMatrix"</code>
which may contain the asymptotic (co)variance of the estimator. [*]</p>
</dd>
<dt><code>asbias</code></dt><dd><p>Optional object of class <code>"numeric"</code>:
asymptotic bias. [*]</p>
</dd>
<dt><code>pIC</code></dt><dd><p>Optional object of class <code>InfluenceCurve</code>:
influence curve. [*]</p>
</dd>
<dt><code>nuis.idx</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>: 
indices of <code>estimate</code> belonging to the nuisance part. [*]</p>
</dd>
<dt><code>fixed</code></dt><dd><p> object of class <code>"OptionalNumeric"</code>:
the fixed and known part of the parameter. [*]</p>
</dd>
<dt><code>steps</code></dt><dd><p>Object of class <code>"integer"</code>: number
of steps. [*]</p>
</dd>
<dt><code>Infos</code></dt><dd><p> object of class <code>"matrix"</code>
with two columns named <code>method</code> and <code>message</code>:
additional informations. [*]</p>
</dd>
<dt><code>trafo</code></dt><dd><p> object of class <code>"list"</code>:
a list with components <code>fct</code> and <code>mat</code> (see below). [*]</p>
</dd>
<dt><code>untransformed.estimate</code>:</dt><dd><p>Object of class <code>"ANY"</code>:
untransformed estimate. [*]</p>
</dd>
<dt><code>untransformed.asvar</code>:</dt><dd><p> object of class <code>"OptionalNumericOrMatrix"</code>
which may contain the asymptotic (co)variance of the untransformed
estimator. [*]</p>
</dd>
<dt><code>pICList</code></dt><dd><p>Optional object of class <code>"OptionalpICList"</code>:
the list of (intermediate) (partial) influence curves used;
only filled when called from <code>ORobEstimator</code> with argument
<code>withPICList==TRUE</code>. [*]</p>
</dd>
<dt><code>ICList</code></dt><dd><p>Optional object of class <code>"OptionalpICList"</code>:
the list of (intermediate) (total) influence curves used;
only filled when called from <code>ORobEstimator</code> with argument
<code>withICList==TRUE</code>. [*]</p>
</dd>
<dt><code>start</code></dt><dd><p>The argument <code>start</code> &mdash; of class <code>"StartClass"</code>
used in call to <code>ORobEstimator</code>. [*]</p>
</dd>
<dt><code>startval</code></dt><dd><p>Object of class <code>matrix</code>:
the starting value with which the k-step Estimator was initialized
(in <code class="reqn">p</code>-space / transformed). [*]</p>
</dd>
<dt><code>ustartval</code></dt><dd><p>Object of class <code>matrix</code>:
the starting value with which the k-step Estimator was initialized
(in <code class="reqn">k</code>-space / untransformed). [*]</p>
</dd>
<dt><code>ksteps</code></dt><dd><p>Object of class <code>"OptionalMatrix"</code>:
the intermediate estimates (in <code class="reqn">p</code>-space) for the parameter;
only filled when called from <code>ORobEstimator</code>. [*]</p>
</dd>
<dt><code>uksteps</code></dt><dd><p>Object of class <code>"OptionalMatrix"</code>:
the intermediate estimates (in <code class="reqn">k</code>-space) for the parameter;
only filled when called from <code>ORobEstimator</code>. [*]</p>
</dd>
<dt><code>robestcall</code></dt><dd><p>Object of class <code>"OptionalCall"</code>, i.e.,
a <code>call</code> or <code>NULL</code>: only filled when called from <code>roptest</code>. [*]</p>
</dd>
<dt><code>roptestcall</code></dt><dd><p>Object of class <code>"OptionalCall"</code>, i.e.,
a <code>call</code> or <code>NULL</code>: only filled when called from <code>roptest</code>,
<code>MBREstimator</code>, <code>RMXEstimator</code>, or <code>OMSEstimator</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"kStepEstimate"</code>, directly.<br />
Class <code>"ALEstimate"</code> and class <code>"Estimate"</code>, by
class <code>"kStepstimate"</code>. All slots and methods marked with [*] are inherited.
</p>


<h3>Methods</h3>


<dl>
<dt>steps</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for slot <code>steps</code>. [*]</p>
</dd>
<dt>ksteps</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for slot <code>ksteps</code>; has additional argument
<code>diff</code>, defaulting to <code>FALSE</code>; if the latter is <code>TRUE</code>,
the starting value from slot <code>startval</code> is prepended as first column;
otherwise we return the corresponding increments in each step. [*]</p>
</dd>
<dt>uksteps</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for slot <code>uksteps</code>; has additional argument
<code>diff</code>, defaulting to <code>FALSE</code>; if the latter is <code>TRUE</code>,
the starting value from slot <code>ustartval</code> is prepended as first column;
otherwise we return the corresponding increments in each step. [*]</p>
</dd>
<dt>start</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for slot <code>start</code>. [*]</p>
</dd>
<dt>startval</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for slot <code>startval</code>. [*]</p>
</dd>
<dt>ustartval</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for slot <code>startval</code>. [*]</p>
</dd>
<dt>ICList</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for slot <code>ICList</code>. [*]</p>
</dd>
<dt>pICList</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for slot <code>pICList</code>. [*]</p>
</dd>
<dt>robestCall</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for slot <code>robestCall</code>. [*]</p>
</dd>
<dt>roptestCall</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for slot <code>roptestCall</code>. </p>
</dd>
<dt>timings</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for attribute <code>"timings"</code>.
with additional argument <code>withKStep</code> defaulting to <code>FALSE</code>;
in case argument <code>withKStep==TRUE</code>, the return value is a list
with items <code>timings</code> and <code>kStepTimings</code> combining the
two timing informaion attributes.
</p>
</dd>
<dt>kSteptimings</dt><dd><p><code>signature(object = "ORobEstimate")</code>:
accessor function for attribute <code>"timings"</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ORobEstimate")</code>: a show method; [*]</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:Peter.Ruckdeschel@uni-oldenburg.de">Peter.Ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ALEstimate-class">ALEstimate-class</a></code>, <code><a href="RobAStBase.html#topic+kStepEstimate-class">kStepEstimate-class</a></code></p>

<hr>
<h2 id='plot-methods'> Methods for Function plot in Package &lsquo;ROptEst&rsquo; </h2><span id='topic+plot'></span><span id='topic+plot-methods'></span><span id='topic+plot+2CIC+2Cmissing-method'></span>

<h3>Description</h3>

<p>plot-methods</p>


<h3>Details</h3>

<p>S4-Method <code>plot</code> for for signature <code>IC,missing</code> has been enhanced
compared to its original definition in <span class="pkg">RobAStBase</span> so that if
argument <code>MBRB</code> is <code>NA</code>, it is filled automatically by a call
to <code>optIC</code> which computes the MBR-IC on the fly. To this end, there
is an additional argument <code>n.MBR</code> defaulting to 10000
to determine the number of evaluation points.
points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- NormLocationScaleFamily(mean=0, sd=1)
IC &lt;- optIC(model = N, risk = asCov())
## Don't run to reduce check time on CRAN

plot(IC, main = TRUE, panel.first= grid(),
     col = "blue", cex.main = 2, cex.inner = 0.6,
     withMBR=TRUE)

</code></pre>

<hr>
<h2 id='radiusMinimaxIC'>Generic function for the computation of the radius minimax IC</h2><span id='topic+radiusMinimaxIC'></span><span id='topic+radiusMinimaxIC-methods'></span><span id='topic+radiusMinimaxIC+2CL2ParamFamily+2CUncondNeighborhood+2CasGRisk-method'></span>

<h3>Description</h3>

<p>Generic function for the computation of the radius minimax IC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radiusMinimaxIC(L2Fam, neighbor, risk, ...)

## S4 method for signature 'L2ParamFamily,UncondNeighborhood,asGRisk'
radiusMinimaxIC(
        L2Fam, neighbor, risk, loRad = 0, upRad = Inf, z.start = NULL, A.start = NULL, 
        upper = NULL, lower = NULL, OptOrIter = "iterate",
        maxiter = 50, tol = .Machine$double.eps^0.4,
        warn = FALSE, verbose = NULL, loRad0 = 1e-3, ...,
        returnNAifProblem = FALSE, loRad.s = NULL, upRad.s = NULL,
        modifyICwarn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radiusMinimaxIC_+3A_l2fam">L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_lorad">loRad</code></td>
<td>
<p> the lower end point of the interval to be searched
in the inner optimization (for the least favorable situation
to the user-guessed radius). </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_uprad">upRad</code></td>
<td>
<p> the upper end point of the interval to be searched in the
inner optimization (for the least favorable situation
to the user-guessed radius). </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_z.start">z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_a.start">A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_upper">upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_lower">lower</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_optoriter">OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_tol">tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_warn">warn</code></td>
<td>
<p> logical: print warnings. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_lorad0">loRad0</code></td>
<td>
<p> for numerical reasons: the effective lower bound for the zero search;
internally set to <code>max(loRad,loRad0)</code>.</p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code>getInfRobIC</code></p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_returnnaifproblem">returnNAifProblem</code></td>
<td>
<p>logical (of length 1):
if <code>TRUE</code> (not the default), in case of convergence problems in
the algorithm, returns <code>NA</code>. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_lorad.s">loRad.s</code></td>
<td>
<p> the lower end point of the interval
to be searched in the outer optimization
(for the user-guessed radius); if <code>NULL</code> (default)
set to <code>loRad</code> in the algorithm. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_uprad.s">upRad.s</code></td>
<td>
<p> the upper end point of the interval to be searched in the
outer optimization (for the user-guessed radius); if
<code>NULL</code> (default) set to <code>upRad</code> in the algorithm. </p>
</td></tr>
<tr><td><code id="radiusMinimaxIC_+3A_modifyicwarn">modifyICwarn</code></td>
<td>
<p>logical: should a (warning) information be added if
<code>modifyIC</code> is applied and hence some optimality information could
no longer be valid? Defaults to <code>NULL</code> in which case this value
is taken from <code>RobAStBaseOptions</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case the neighborhood radius is unknown, Rieder et al. (2001, 2008)
and Kohl (2005) show that there is nevertheless a way to compute an
optimally robust IC - the so-called radius-minimax IC - which is 
optimal for some radius interval.
</p>


<h3>Value</h3>

<p>The radius minimax IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>L2Fam = &quot;L2ParamFamily&quot;, neighbor = &quot;UncondNeighborhood&quot;, risk = &quot;asGRisk&quot;:</dt><dd> 
<p>computation of the radius minimax IC for an L2 differentiable parametric family. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

 
<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of not Knowing
the Radius. Statistical Methods and Applications, <em>17</em>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2001). The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>.
</p>
<p>P. Ruckdeschel (2005). Optimally One-Sided Bounded Influence Curves.
Mathematical Methods of Statistics <em>14</em>(1), 105-131.
</p>
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radiusMinimaxIC">radiusMinimaxIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- NormLocationFamily(mean=0, sd=1) 
radIC &lt;- radiusMinimaxIC(L2Fam=N, neighbor=ContNeighborhood(), 
                         risk=asMSE(), loRad=0.1, upRad=0.5)
checkIC(radIC)
</code></pre>

<hr>
<h2 id='RMXEOMSEMBREOBRE'> Optimally robust estimation: RMXE, OMSE, MBRE, and OBRE </h2><span id='topic+RMXEstimator'></span><span id='topic+OMSEstimator'></span><span id='topic+OBREstimator'></span><span id='topic+MBREstimator'></span>

<h3>Description</h3>

<p>These are wrapper functions to 'roptest' to compute
optimally robust estimates, more specifically RMXEs, OMSEs, MBREs, and OBREs,
for L2-differentiable parametric families via k-step construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMXEstimator(x, L2Fam, fsCor = 1, initial.est, neighbor = ContNeighborhood(),
             steps = 1L, distance = CvMDist, startPar = NULL, verbose = NULL,
             OptOrIter = "iterate", useLast = getRobAStBaseOption("kStepUseLast"),
             withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
             IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
             withICList = getRobAStBaseOption("withICList"),
             withPICList = getRobAStBaseOption("withPICList"), na.rm = TRUE,
             initial.est.ArgList, ..., withLogScale = TRUE, ..withCheck=FALSE,
             withTimings = FALSE, withMDE = NULL, withEvalAsVar = NULL,
             withMakeIC = FALSE, modifyICwarn = NULL, E.argList = NULL,
             diagnostic = FALSE)
OMSEstimator(x, L2Fam, eps=0.5, fsCor = 1, initial.est, neighbor = ContNeighborhood(),
             steps = 1L, distance = CvMDist, startPar = NULL, verbose = NULL,
             OptOrIter = "iterate", useLast = getRobAStBaseOption("kStepUseLast"),
             withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
             IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
             withICList = getRobAStBaseOption("withICList"),
             withPICList = getRobAStBaseOption("withPICList"), na.rm = TRUE,
             initial.est.ArgList, ..., withLogScale = TRUE, ..withCheck=FALSE,
             withTimings = FALSE, withMDE = NULL, withEvalAsVar = NULL,
             withMakeIC = FALSE, modifyICwarn = NULL, E.argList = NULL,
             diagnostic = FALSE)
OBREstimator(x, L2Fam, eff=0.95, fsCor = 1, initial.est, neighbor = ContNeighborhood(),
             steps = 1L, distance = CvMDist, startPar = NULL, verbose = NULL,
             OptOrIter = "iterate", useLast = getRobAStBaseOption("kStepUseLast"),
             withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
             IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
             withICList = getRobAStBaseOption("withICList"),
             withPICList = getRobAStBaseOption("withPICList"), na.rm = TRUE,
             initial.est.ArgList, ..., withLogScale = TRUE, ..withCheck=FALSE,
             withTimings = FALSE, withMDE = NULL, withEvalAsVar = NULL,
             withMakeIC = FALSE, modifyICwarn = NULL, E.argList = NULL,
             diagnostic = FALSE)
MBREstimator(x, L2Fam, fsCor = 1, initial.est, neighbor = ContNeighborhood(),
             steps = 1L, distance = CvMDist, startPar = NULL, verbose = NULL,
             OptOrIter = "iterate", useLast = getRobAStBaseOption("kStepUseLast"),
             withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
             IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
             withICList = getRobAStBaseOption("withICList"),
             withPICList = getRobAStBaseOption("withPICList"), na.rm = TRUE,
             initial.est.ArgList, ..., withLogScale = TRUE, ..withCheck=FALSE,
             withTimings = FALSE, withMDE = NULL, withEvalAsVar = NULL,
             withMakeIC = FALSE, modifyICwarn = NULL, E.argList = NULL,
             diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_x">x</code></td>
<td>
<p> sample </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_l2fam">L2Fam</code></td>
<td>
<p> object of class <code>"L2ParamFamily"</code> </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_eff">eff</code></td>
<td>
<p> positive real (0 &lt;= <code>eff</code> &lt;= 1): amount of asymptotic
efficiency loss in the ideal model. See details below. </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_eps">eps</code></td>
<td>
<p> positive real (0 &lt; <code>eps</code> &lt;= 0.5): amount of gross errors.
See details below. </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_fscor">fsCor</code></td>
<td>
<p> positive real: factor used to correct the neighborhood radius;
see details. </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_initial.est">initial.est</code></td>
<td>
<p> initial estimate for unknown parameter. If missing 
minimum distance estimator is computed. </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"UncondNeighborhood"</code> </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_steps">steps</code></td>
<td>
<p> positive integer: number of steps used for k-steps construction </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_distance">distance</code></td>
<td>
<p> distance function used in <code>MDEstimator</code>, which in turn
is used as (default) starting estimator. </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_startpar">startPar</code></td>
<td>
<p> initial information used by <code>optimize</code> resp. <code>optim</code>;
i.e; if (total) parameter is of length 1, <code>startPar</code> is 
a search interval, else it is an initial parameter value; if <code>NULL</code>
slot <code>startPar</code> of <code>ParamFamily</code> is used to produce it;
in the multivariate case, <code>startPar</code> may also be of class <code>Estimate</code>,
in which case slot <code>untransformed.estimate</code> is used.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_uselast">useLast</code></td>
<td>
<p> which parameter estimate (initial estimate or
k-step estimate) shall be used to fill the slots <code>pIC</code>,
<code>asvar</code> and <code>asbias</code> of the return value. </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_optoriter">OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_withupdateinker">withUpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>, shall
the parameter be updated on <code class="reqn">{\rm ker}(D)</code>?</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_ic.updateinker">IC.UpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>,
the IC to be used for this; if <code>NULL</code> the result of <code>getboundedIC(L2Fam,D)</code> is taken;
this IC will then be projected onto <code class="reqn">{\rm ker}(D)</code>.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_withpiclist">withPICList</code></td>
<td>
<p>logical: shall slot <code>pICList</code> of return value
be filled?</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_withiclist">withICList</code></td>
<td>
<p>logical: shall slot <code>ICList</code> of return value
be filled?</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_initial.est.arglist">initial.est.ArgList</code></td>
<td>
<p>a list of arguments to be given to argument <code>start</code> if the latter
is a function; this list by default already starts with two unnamed items,
the sample <code>x</code>, and the model <code>L2Fam</code>.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_...">...</code></td>
<td>
<p> further arguments </p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_withlogscale">withLogScale</code></td>
<td>
<p>logical; shall a scale component (if existing and found
with name <code>scalename</code>) be computed on log-scale and backtransformed
afterwards? This avoids crossing 0.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_..withcheck">..withCheck</code></td>
<td>
<p>logical: if <code>TRUE</code>, debugging info is issued.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_withtimings">withTimings</code></td>
<td>
<p>logical: if <code>TRUE</code>, separate (and aggregate)
timings for the three steps evaluating the starting value, finding
the starting influence curve, and evaluating the k-step estimator is
issued.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_withmde">withMDE</code></td>
<td>
<p> logical or <code>NULL</code>: Shall a minimum distance estimator be used as
starting estimator&mdash;in addition to the function given in slot
<code>startPar</code> of the L2 family? If <code>NULL</code> (default), the content
of slot <code>.withMDE</code> in the L2 family is used instead to take
this decision.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_withevalasvar">withEvalAsVar</code></td>
<td>
<p>logical or <code>NULL</code>: if <code>TRUE</code> (default), tells R
to evaluate the asymptotic variance or if <code>FALSE</code> just to produces a call
to do so. If <code>withEvalAsVar</code> is <code>NULL</code> (default),  the content
of slot <code>.withEvalAsVar</code> in the L2 family is used instead to take
this decision.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_withmakeic">withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_modifyicwarn">modifyICwarn</code></td>
<td>
<p>logical: should a (warning) information be added if
<code>modifyIC</code> is applied and hence some optimality information could
no longer be valid? Defaults to <code>NULL</code> in which case this value
is taken from <code>RobAStBaseOptions</code>.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_e.arglist">E.argList</code></td>
<td>
<p><code>NULL</code> (default) or a list of arguments to be passed
to calls to <code>E</code> from (a) <code>MDEstimator</code>
(here this additional argument is only used if
<code>initial.est</code> is missing), (b) <code>getStartIC</code>,
and (c) <code>kStepEstimator</code>. Potential clashes with
arguments of the same name in <code>...</code> are resolved by inserting
the items of argument list <code>E.argList</code> as named items, so
in case of collisions the item of <code>E.argList</code> overwrites the
existing one from <code>...</code>.</p>
</td></tr>
<tr><td><code id="RMXEOMSEMBREOBRE_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>,
diagnostic information on the performed integrations is gathered and
shipped out as an attribute <code>diagnostic</code> of the return value
of the estimators. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions compute optimally robust estimator for a given L2 differentiable
parametric family; more specifically they are RMXEs, OMSEs, MBREs, and OBREs.
The computation uses a k-step construction with an
appropriate initial estimate; cf. also <code><a href="RobAStBase.html#topic+kStepEstimator">kStepEstimator</a></code>. 
Valid candidates are e.g. Kolmogorov(-Smirnov) or von Mises minimum 
distance estimators (default); cf. Rieder (1994) and Kohl (2005).
</p>
<p>For OMSE, i.e., the asymptotically linear estimator with minimax mean squared
error on this neighborhood of given size, the amount of gross errors
(contamination) is assumed to be known, and is specified by <code>eps</code>.
The radius of the corresponding infinitesimal
contamination neighborhood is obtained by multiplying <code>eps</code> 
by the square root of the sample size. 
</p>
<p>If the amount of gross errors (contamination) is unknown, RMXE should be used,
i.e., the radius-minimax estimator in the sense of
Rieder et al. (2001, 2008), respectively Section 2.2 of Kohl (2005) is returned.
</p>
<p>The OBRE, i.e., the optimal bias-robust (asymptotically linear) estimator;
(terminology due to Hampel et al (1985)), expects an efficiency loss (at the
ideal model) to be specified and then, according to an (asymptotic) Anscombe
criterion computes the the bias bound achieving this efficiency loss.
</p>
<p>The MBRE, i.e., the most bias-robust (asymptotically linear) estimator;
(terminology due to Hampel et al (1985)), uses the influence curve with
minimal possible bias bound, hence minimaxes bias on these neighborhoods
(in an infinitesimal sense)..
</p>
<p>Finite-sample and higher order results suggest that the asymptotically
optimal procedure is to liberal. Using <code>fsCor</code> the radius can be
modified - as a rule enlarged - to obtain a more conservative estimate.
In case of normal location and scale there is function 
<code><a href="RobLox.html#topic+finiteSampleCorrection">finiteSampleCorrection</a></code> which returns a finite-sample 
corrected (enlarged) radius based on the results of large Monte-Carlo
studies.
</p>
<p>The default value of argument <code>useLast</code> is set by the
global option <code>kStepUseLast</code> which by default is set to 
<code>FALSE</code>. In case of general models <code>useLast</code> 
remains unchanged during the computations. However, if 
slot <code>CallL2Fam</code> of <code>IC</code> generates an object of 
class <code>"L2GroupParamFamily"</code> the value of <code>useLast</code> 
is changed to <code>TRUE</code>.
Explicitly setting <code>useLast</code> to <code>TRUE</code> should
be done with care as in this situation the influence curve
is re-computed using the value of the one-step estimate
which may take quite a long time depending on the model.
</p>
<p>If <code>useLast</code> is set to <code>TRUE</code> the computation of <code>asvar</code>, 
<code>asbias</code> and <code>IC</code> is based on the k-step estimate.
</p>
<p>All these estimators are realized as wrappers to function <code>roptest</code>.
</p>
<p>Timings for the steps run through in these estimators are available
in attributes <code>timings</code>, and for the step of the
<code>kStepEstimator</code> in <code>kStepTimings</code>.
</p>
<p>One may also use the arguments <code>startCtrl</code>, <code>startICCtrl</code>, and
<code>kStepCtrl</code> of function <code><a href="#topic+robest">robest</a></code>. This allows for individual
settings of <code>E.argList</code>, <code>withEvalAsVar</code>, and
<code>withMakeIC</code> for the different steps. If any of the three arguments
<code>startCtrl</code>, <code>startICCtrl</code>, and <code>kStepCtrl</code> is used, the
respective attributes set in the correspondig argument are used and, if
colliding with arguments directly passed to the estimator function, the directly
passed ones are ignored.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there are attributes <code>diagnostic</code>
and <code>kStepDiagnostic</code> attached to the return value, which may be inspected
and assessed through <code><a href="distrEx.html#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="distrEx.html#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"kStepEstimate"</code>.  In addition, it has
an attribute <code>"timings"</code> where computation time is stored.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P. (2010): R package distrMod: 
Object-Oriented Implementation of Probability Models. 
J. Statist. Softw.  <b>35</b>(10), 1&ndash;27. <a href="https://doi.org/10.18637/jss.v035.i10">doi:10.18637/jss.v035.i10</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333&ndash;354. 
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2008) The Costs of not Knowing
the Radius. Statistical Methods and Applications <b>17</b>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2001) The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+roptest">roptest</a></code>, <code><a href="#topic+robest">robest</a></code>,
<code><a href="RobLox.html#topic+roblox">roblox</a></code>,
<code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>
<code><a href="RobAStBase.html#topic+UncondNeighborhood-class">UncondNeighborhood-class</a></code>,
<code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################
## 1. Binomial data
#############################
## generate a sample of contaminated data
set.seed(123)
ind &lt;- rbinom(100, size=1, prob=0.05)
x &lt;- rbinom(100, size=25, prob=(1-ind)*0.25 + ind*0.9)

## ML-estimate
MLE.bin &lt;- MLEstimator(x, BinomFamily(size = 25))
## compute optimally robust estimators
OMSE.bin &lt;- OMSEstimator(x, BinomFamily(size = 25), steps = 3)
MBRE.bin &lt;- MBREstimator(x, BinomFamily(size = 25), steps = 3)
estimate(MLE.bin)
estimate(MBRE.bin)
estimate(OMSE.bin)

  ## to reduce time load at CRAN tests
RMXE.bin &lt;- RMXEstimator(x, BinomFamily(size = 25), steps = 3)
OBRE.bin &lt;- OBREstimator(x, BinomFamily(size = 25), steps = 3)
estimate(RMXE.bin)
estimate(OBRE.bin)

  ## to reduce time load at CRAN tests
#############################
## 2. Poisson data
#############################

## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
x &lt;- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532),
       rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27),
       rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))

## ML-estimate
MLE.pois &lt;- MLEstimator(x, PoisFamily())
OBRE.pois &lt;- OBREstimator(x, PoisFamily(), steps = 3)
OMSE.pois &lt;- OMSEstimator(x, PoisFamily(), steps = 3)
MBRE.pois &lt;- MBREstimator(x, PoisFamily(), steps = 3)
RMXE.pois &lt;- RMXEstimator(x, PoisFamily(), steps = 3)
estimate(MLE.pois)
estimate(OBRE.pois)
estimate(RMXE.pois)
estimate(MBRE.pois)
estimate(OMSE.pois)


 ## to reduce time load at CRAN tests
#############################
## 3. Normal (Gaussian) location and scale
#############################
## 24 determinations of copper in wholemeal flour
library(MASS)
data(chem)

MLE.n &lt;- MLEstimator(chem, NormLocationScaleFamily())
MBRE.n &lt;- MBREstimator(chem, NormLocationScaleFamily(), steps = 3)
OMSE.n &lt;- OMSEstimator(chem, NormLocationScaleFamily(), steps = 3)
OBRE.n &lt;- OBREstimator(chem, NormLocationScaleFamily(), steps = 3)
RMXE.n &lt;- RMXEstimator(chem, NormLocationScaleFamily(), steps = 3)

estimate(MLE.n)
estimate(MBRE.n)
estimate(OMSE.n)
estimate(OBRE.n)
estimate(RMXE.n)

</code></pre>

<hr>
<h2 id='robest'> Optimally robust estimation </h2><span id='topic+robest'></span>

<h3>Description</h3>

<p>Function to compute optimally robust estimates for L2-differentiable
parametric families via k-step construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robest(x, L2Fam,  fsCor = 1, risk = asMSE(), steps = 1L,
        verbose = NULL, OptOrIter = "iterate", nbCtrl = gennbCtrl(),
        startCtrl = genstartCtrl(), startICCtrl = genstartICCtrl(),
        kStepCtrl = genkStepCtrl(), na.rm = TRUE, ..., debug = FALSE,
        withTimings = FALSE, diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robest_+3A_x">x</code></td>
<td>
<p> sample </p>
</td></tr>
<tr><td><code id="robest_+3A_l2fam">L2Fam</code></td>
<td>
<p> object of class <code>"L2ParamFamily"</code> </p>
</td></tr>
<tr><td><code id="robest_+3A_fscor">fsCor</code></td>
<td>
<p> positive real: factor used to correct the neighborhood radius;
see details. </p>
</td></tr>
<tr><td><code id="robest_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code> </p>
</td></tr>
<tr><td><code id="robest_+3A_steps">steps</code></td>
<td>
<p> positive integer: number of steps used for k-steps construction </p>
</td></tr>
<tr><td><code id="robest_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td></tr>
<tr><td><code id="robest_+3A_optoriter">OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td></tr>
<tr><td><code id="robest_+3A_nbctrl">nbCtrl</code></td>
<td>
<p>a list specifying input concerning the used neighborhood;
to be generated by a respective call to <code><a href="#topic+gennbCtrl">gennbCtrl</a></code>.</p>
</td></tr>
<tr><td><code id="robest_+3A_startctrl">startCtrl</code></td>
<td>
<p>a list specifying input concerning the used starting estimator;
to be generated by a respective call to <code><a href="#topic+genstartCtrl">genstartCtrl</a></code>.</p>
</td></tr>
<tr><td><code id="robest_+3A_starticctrl">startICCtrl</code></td>
<td>
<p>a list specifying input concerning the call to
<code>getStartIC</code> which returns the starting influence curve;
to be generated by a respective call to <code><a href="#topic+genstartICCtrl">genstartICCtrl</a></code>.</p>
</td></tr>
<tr><td><code id="robest_+3A_kstepctrl">kStepCtrl</code></td>
<td>
<p>a list specifying input concerning the used variant of
a kstepEstimator;
to be generated by a respective call to <code><a href="#topic+genkStepCtrl">genkStepCtrl</a></code>.</p>
</td></tr>
<tr><td><code id="robest_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="robest_+3A_...">...</code></td>
<td>
<p> further arguments </p>
</td></tr>
<tr><td><code id="robest_+3A_debug">debug</code></td>
<td>
<p>logical: if <code>TRUE</code>, only the respective calls within the
function are generated for debugging purposes.</p>
</td></tr>
<tr><td><code id="robest_+3A_withtimings">withTimings</code></td>
<td>
<p>logical: if <code>TRUE</code>, separate (and aggregate)
timings for the three steps evaluating the starting value, finding
the starting influence curve, and evaluating the k-step estimator is
issued.</p>
</td></tr>
<tr><td><code id="robest_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>,
diagnostic information on the performed integrations is gathered and
shipped out as attributes <code>kStepDiagnostic</code> (for the kStepEstimator-step)
and <code>diagnostic</code> for the remaining steps of the return value
of <code>robest</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A new, more structured interface to the former function <code><a href="#topic+roptest">roptest</a></code>.
For details, see this function.
</p>
<p>In some respects this functions allows for more granular arguments,
in the sense that the different steps (a) computation of the inital estimator,
resp. (a') in case <code>initial.est</code> is missing computation of the initial
MDE, (b) computation of the optimal IC and (c) computation of the k-step
estimator each can have individial arguments <code>E.arglist</code> to be
passed on to calls to expectation operator <code>E</code> within each step.
</p>
<p>These different arguments are passed through the input generating functions
<code><a href="#topic+inputGenerators">genstartCtrl</a></code>,
<code><a href="#topic+inputGenerators">genstartICCtrl</a></code>, and
<code><a href="#topic+inputGenerators">kStepCtrl</a></code>
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there are attributes <code>diagnostic</code>
and <code>kStepDiagnostic</code> attached to the return value, which may be inspected
and assessed through <code><a href="distrEx.html#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="distrEx.html#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"kStepEstimate"</code>. In addition, it has
an attribute <code>"timings"</code> where computation time is stored.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P. (2010): R package distrMod: 
Object-Oriented Implementation of Probability Models. 
J. Statist. Softw.  <b>35</b>(10), 1&ndash;27. <a href="https://doi.org/10.18637/jss.v035.i10">doi:10.18637/jss.v035.i10</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333&ndash;354. 
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2008) The Costs of not Knowing
the Radius. Statistical Methods and Applications <b>17</b>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2001) The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>
</p>


<h3>See Also</h3>

 <p><code><a href="RobLox.html#topic+roblox">roblox</a></code>, 
<code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>
<code><a href="RobAStBase.html#topic+UncondNeighborhood-class">UncondNeighborhood-class</a></code>,
<code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Don't test to reduce check time on CRAN

#############################
## 1. Binomial data
#############################
## generate a sample of contaminated data
set.seed(123)
ind &lt;- rbinom(100, size=1, prob=0.05)
x &lt;- rbinom(100, size=25, prob=(1-ind)*0.25 + ind*0.9)

## Family
BF &lt;- BinomFamily(size = 25)
## ML-estimate
MLest &lt;- MLEstimator(x, BF)
estimate(MLest)
confint(MLest)

## compute optimally robust estimator (known contamination)
nb &lt;- gennbCtrl(eps=0.05)
robest1 &lt;- robest(x, BF, nbCtrl = nb, steps = 3)
estimate(robest1)

confint(robest1, method = symmetricBias())
## neglecting bias
confint(robest1)
plot(pIC(robest1))
tmp &lt;- qqplot(x, robest1, cex.pch=1.5, exp.cex2.pch = -.25,
              exp.fadcol.pch = .55, jit.fac=.9)

## compute optimally robust estimator (unknown contamination)
nb2 &lt;- gennbCtrl(eps.lower = 0, eps.upper = 0.2)
robest2 &lt;- robest(x, BF, nbCtrl = nb2, steps = 3)
estimate(robest2)
confint(robest2, method = symmetricBias())
plot(pIC(robest2))

## total variation neighborhoods (known deviation)
nb3 &lt;- gennbCtrl(eps = 0.025, neighbor = TotalVarNeighborhood())
robest3 &lt;- robest(x, BF, nbCtrl = nb3, steps = 3)
estimate(robest3)
confint(robest3, method = symmetricBias())
plot(pIC(robest3))

## total variation neighborhoods (unknown deviation)
nb4 &lt;- gennbCtrl(eps.lower = 0, eps.upper = 0.1,
                 neighbor = TotalVarNeighborhood())
robest3 &lt;- robest(x, BF, nbCtrl = nb4, steps = 3)
robest4 &lt;- robest(x, BinomFamily(size = 25), nbCtrl = nb4, steps = 3)
estimate(robest4)
confint(robest4, method = symmetricBias())
plot(pIC(robest4))


#############################
## 2. Poisson data
#############################
## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
x &lt;- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532), 
       rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27), 
       rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))

## Family
PF &lt;- PoisFamily()

## ML-estimate
MLest &lt;- MLEstimator(x, PF)
estimate(MLest)
confint(MLest)

## compute optimally robust estimator (unknown contamination)
nb1 &lt;- gennbCtrl(eps.upper = 0.1)
robest &lt;- robest(x, PF, nbCtrl = nb1, steps = 3)
estimate(robest)

confint(robest, symmetricBias())
plot(pIC(robest))
tmp &lt;- qqplot(x, robest, cex.pch=1.5, exp.cex2.pch = -.25,
              exp.fadcol.pch = .55, jit.fac=.9)
 
## total variation neighborhoods (unknown deviation)
nb2 &lt;- gennbCtrl(eps.upper = 0.05, neighbor = TotalVarNeighborhood())
robest1 &lt;- robest(x, PF, nbCtrl = nb2, steps = 3)
estimate(robest1)
confint(robest1, symmetricBias())
plot(pIC(robest1))


#############################
## 3. Normal (Gaussian) location and scale
#############################

## this example of a two dimensional parameter
## to be estimated will need more time than 
## 5 seconds to run 
## you can find it in 
## system.file("scripts", "examples_taking_longer.R", 
##              package="ROptEst")

</code></pre>

<hr>
<h2 id='roptest'> Optimally robust estimation </h2><span id='topic+roptest'></span><span id='topic+roptest.old'></span>

<h3>Description</h3>

<p>Function to compute optimally robust estimates for L2-differentiable
parametric families via k-step construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roptest(x, L2Fam, eps, eps.lower, eps.upper, fsCor = 1, initial.est, 
        neighbor = ContNeighborhood(), risk = asMSE(), steps = 1L, 
        distance = CvMDist, startPar = NULL, verbose = NULL,
        OptOrIter = "iterate",
        useLast = getRobAStBaseOption("kStepUseLast"),
        withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
        IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
        withICList = getRobAStBaseOption("withICList"),
        withPICList = getRobAStBaseOption("withPICList"),
        na.rm = TRUE, initial.est.ArgList, ...,
        withLogScale = TRUE, ..withCheck = FALSE, withTimings = FALSE,
        withMDE = NULL, withEvalAsVar = NULL, withMakeIC = FALSE,
        modifyICwarn = NULL, E.argList = NULL, diagnostic = FALSE)
roptest.old(x, L2Fam, eps, eps.lower, eps.upper, fsCor = 1, initial.est,
        neighbor = ContNeighborhood(), risk = asMSE(), steps = 1L,
        distance = CvMDist, startPar = NULL, verbose = NULL,
        OptOrIter = "iterate",
        useLast = getRobAStBaseOption("kStepUseLast"),
        withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
        IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
        withICList = getRobAStBaseOption("withICList"),
        withPICList = getRobAStBaseOption("withPICList"),
        na.rm = TRUE, initial.est.ArgList, ...,
        withLogScale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roptest_+3A_x">x</code></td>
<td>
<p> sample </p>
</td></tr>
<tr><td><code id="roptest_+3A_l2fam">L2Fam</code></td>
<td>
<p> object of class <code>"L2ParamFamily"</code> </p>
</td></tr>
<tr><td><code id="roptest_+3A_eps">eps</code></td>
<td>
<p> positive real (0 &lt; <code>eps</code> &lt;= 0.5): amount of gross errors. 
See details below. </p>
</td></tr>
<tr><td><code id="roptest_+3A_eps.lower">eps.lower</code></td>
<td>
<p> positive real (0 &lt;= <code>eps.lower</code> &lt;= <code>eps.upper</code>): 
lower bound for the amount of gross errors. See details below. </p>
</td></tr>
<tr><td><code id="roptest_+3A_eps.upper">eps.upper</code></td>
<td>
<p> positive real (<code>eps.lower</code> &lt;= <code>eps.upper</code> &lt;= 0.5): 
upper bound for the amount of gross errors. See details below. </p>
</td></tr>
<tr><td><code id="roptest_+3A_fscor">fsCor</code></td>
<td>
<p> positive real: factor used to correct the neighborhood radius;
see details. </p>
</td></tr>
<tr><td><code id="roptest_+3A_initial.est">initial.est</code></td>
<td>
<p> initial estimate for unknown parameter. If missing, a
minimum distance estimator is computed. </p>
</td></tr>
<tr><td><code id="roptest_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"UncondNeighborhood"</code> </p>
</td></tr>
<tr><td><code id="roptest_+3A_risk">risk</code></td>
<td>
<p> object of class <code>"RiskType"</code> </p>
</td></tr>
<tr><td><code id="roptest_+3A_steps">steps</code></td>
<td>
<p> positive integer: number of steps used for k-steps construction </p>
</td></tr>
<tr><td><code id="roptest_+3A_distance">distance</code></td>
<td>
<p> distance function used in <code>MDEstimator</code>, which in turn
is used as (default) starting estimator. </p>
</td></tr>
<tr><td><code id="roptest_+3A_startpar">startPar</code></td>
<td>
<p> initial information used by <code>optimize</code> resp. <code>optim</code>;
i.e; if (total) parameter is of length 1, <code>startPar</code> is 
a search interval, else it is an initial parameter value; if <code>NULL</code>
slot <code>startPar</code> of <code>ParamFamily</code> is used to produce it;
in the multivariate case, <code>startPar</code> may also be of class <code>Estimate</code>,
in which case slot <code>untransformed.estimate</code> is used.</p>
</td></tr>
<tr><td><code id="roptest_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td></tr>
<tr><td><code id="roptest_+3A_uselast">useLast</code></td>
<td>
<p> which parameter estimate (initial estimate or
k-step estimate) shall be used to fill the slots <code>pIC</code>,
<code>asvar</code> and <code>asbias</code> of the return value. </p>
</td></tr>
<tr><td><code id="roptest_+3A_optoriter">OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td></tr>
<tr><td><code id="roptest_+3A_withupdateinker">withUpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>, shall
the parameter be updated on <code class="reqn">{\rm ker}(D)</code>?</p>
</td></tr>
<tr><td><code id="roptest_+3A_ic.updateinker">IC.UpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>,
the IC to be used for this; if <code>NULL</code> the result of <code>getboundedIC(L2Fam,D)</code> is taken;
this IC will then be projected onto <code class="reqn">{\rm ker}(D)</code>.</p>
</td></tr>
<tr><td><code id="roptest_+3A_withpiclist">withPICList</code></td>
<td>
<p>logical: shall slot <code>pICList</code> of return value
be filled?</p>
</td></tr>
<tr><td><code id="roptest_+3A_withiclist">withICList</code></td>
<td>
<p>logical: shall slot <code>ICList</code> of return value
be filled?</p>
</td></tr>
<tr><td><code id="roptest_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
<tr><td><code id="roptest_+3A_initial.est.arglist">initial.est.ArgList</code></td>
<td>
<p>a list of arguments to be given to argument <code>start</code> if the latter
is a function; this list by default already starts with two unnamed items,
the sample <code>x</code>, and the model <code>L2Fam</code>.</p>
</td></tr>
<tr><td><code id="roptest_+3A_...">...</code></td>
<td>
<p> further arguments </p>
</td></tr>
<tr><td><code id="roptest_+3A_withlogscale">withLogScale</code></td>
<td>
<p>logical; shall a scale component (if existing and found
with name <code>scalename</code>) be computed on log-scale and backtransformed
afterwards? This avoids crossing 0.</p>
</td></tr>
<tr><td><code id="roptest_+3A_..withcheck">..withCheck</code></td>
<td>
<p>logical: if <code>TRUE</code>, debugging info is issued.</p>
</td></tr>
<tr><td><code id="roptest_+3A_withtimings">withTimings</code></td>
<td>
<p>logical: if <code>TRUE</code>, separate (and aggregate)
timings for the three steps evaluating the starting value, finding
the starting influence curve, and evaluating the k-step estimator is
issued.</p>
</td></tr>
<tr><td><code id="roptest_+3A_withmde">withMDE</code></td>
<td>
<p> logical or <code>NULL</code>: Shall a minimum distance estimator be used as
starting estimator&mdash;in addition to the function given in slot
<code>startPar</code> of the L2 family? If <code>NULL</code> (default), the content
of slot <code>.withMDE</code> in the L2 family is used instead to take
this decision.</p>
</td></tr>
<tr><td><code id="roptest_+3A_withevalasvar">withEvalAsVar</code></td>
<td>
<p>logical or <code>NULL</code>: if <code>TRUE</code> (default), tells R
to evaluate the asymptotic variance or if <code>FALSE</code> just to produces a call
to do so. If <code>withEvalAsVar</code> is <code>NULL</code> (default),  the content
of slot <code>.withEvalAsVar</code> in the L2 family is used instead to take
this decision.</p>
</td></tr>
<tr><td><code id="roptest_+3A_withmakeic">withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td></tr>
<tr><td><code id="roptest_+3A_modifyicwarn">modifyICwarn</code></td>
<td>
<p>logical: should a (warning) information be added if
<code>modifyIC</code> is applied and hence some optimality information could
no longer be valid? Defaults to <code>NULL</code> in which case this value
is taken from <code>RobAStBaseOptions</code>.</p>
</td></tr>
<tr><td><code id="roptest_+3A_e.arglist">E.argList</code></td>
<td>
<p><code>NULL</code> (default) or a list of arguments to be passed
to calls to <code>E</code> from (a) <code>MDEstimator</code>
(here this additional argument is only used if
<code>initial.est</code> is missing), (b) <code>getStartIC</code>,
and (c) <code>kStepEstimator</code>. Potential clashes with
arguments of the same name in <code>...</code> are resolved by inserting
the items of argument list <code>E.argList</code> as named items, so
in case of collisions the item of <code>E.argList</code> overwrites the
existing one from <code>...</code>.</p>
</td></tr>
<tr><td><code id="roptest_+3A_diagnostic">diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>,
diagnostic information on the performed integrations is gathered and
shipped out as attributes <code>kStepDiagnostic</code> (for the kStepEstimator-step)
and <code>diagnostic</code> for the remaining steps of the return value
of <code>roptest</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the optimally robust estimator for a given L2 differentiable
parametric family. The computation uses a k-step construction with an 
appropriate initial estimate; cf. also <code><a href="RobAStBase.html#topic+kStepEstimator">kStepEstimator</a></code>. 
Valid candidates are e.g. Kolmogorov(-Smirnov) or von Mises minimum 
distance estimators (default); cf. Rieder (1994) and Kohl (2005).
</p>
<p>Before package version 0.9, this computation was done with the code of
function <code>roptest.old</code> (with the same formals). From package version
0.9 on, this function uses the modularized function <code><a href="#topic+robest">robest</a></code>
internally.
</p>
<p>If the amount of gross errors (contamination) is known, it can be 
specified by <code>eps</code>. The radius of the corresponding infinitesimal 
contamination neighborhood is obtained by multiplying <code>eps</code> 
by the square root of the sample size. 
</p>
<p>If the amount of gross errors (contamination) is unknown, try to find a 
rough estimate for the amount of gross errors, such that it lies 
between <code>eps.lower</code> and <code>eps.upper</code>.
</p>
<p>In case <code>eps.lower</code> is specified and <code>eps.upper</code> is missing, 
<code>eps.upper</code> is set to 0.5. In case <code>eps.upper</code> is specified and
<code>eps.lower</code> is missing, <code>eps.lower</code> is set to 0.
</p>
<p>If neither <code>eps</code> nor <code>eps.lower</code> and/or <code>eps.upper</code> is 
specified, <code>eps.lower</code> and <code>eps.upper</code> are set to 0 and 0.5, 
respectively.
</p>
<p>If <code>eps</code> is missing, the radius-minimax estimator in sense of 
Rieder et al. (2001, 2008), respectively Section 2.2 of Kohl (2005) is returned.
</p>
<p>Finite-sample and higher order results suggest that the asymptotically
optimal procedure is to liberal. Using <code>fsCor</code> the radius can be
modified - as a rule enlarged - to obtain a more conservative estimate.
In case of normal location and scale there is function 
<code><a href="RobLox.html#topic+finiteSampleCorrection">finiteSampleCorrection</a></code> which returns a finite-sample 
corrected (enlarged) radius based on the results of large Monte-Carlo
studies.
</p>
<p>The logic in argument <code>initial.est</code> is as follows: It can be
a numeric vector of the length of the unknow parameter or a function or
it can be missing. If it is missing, one consults argument <code>startPar</code>
for a search interval (if a one dimensional unknown parameter) or a starting
value for the search (if the dimension of the unknown parameter is larger
than one). If <code>startPar</code> is missing, too, it takes the value from
the corresponding slot of argument <code>L2Fam</code>. Then, if argument <code>withMDE</code>
is <code>TRUE</code> a Minimum-Distance estimator is computed as initial value
<code>initial.est</code> with distance as specified in argument <code>distance</code>
and possibly further arguments as passed through <code>...</code>.
</p>
<p>In the next step, the value of <code>initial.est</code> (either if not missing
from beginning or as computed through the MDE) is then passed on to
<code>kStepEstimator.start</code> which  then takes out the essential
information for the sequel, i.e., a numeric vector of the estimate.
</p>
<p>At this initial value the optimal influence curve is computed through
interface <code>getStartIC</code>, which in turn, depending on the risk calls
<code>optIC</code>, <code>radiusMinimaxIC</code>, or computes the IC
from precomputed grid values in case of <code>risk</code> being of class
<code>interpolRisk</code>. With the obtained optimal IC, <code>kStepEstimator</code>
is called.
</p>
<p>The default value of argument <code>useLast</code> is set by the
global option <code>kStepUseLast</code> which by default is set to 
<code>FALSE</code>. In case of general models <code>useLast</code> 
remains unchanged during the computations. However, if 
slot <code>CallL2Fam</code> of <code>IC</code> generates an object of 
class <code>"L2GroupParamFamily"</code> the value of <code>useLast</code> 
is changed to <code>TRUE</code>.
Explicitly setting <code>useLast</code> to <code>TRUE</code> should
be done with care as in this situation the influence curve
is re-computed using the value of the one-step estimate
which may take quite a long time depending on the model.
</p>
<p>If <code>useLast</code> is set to <code>TRUE</code> the computation of <code>asvar</code>, 
<code>asbias</code> and <code>IC</code> is based on the k-step estimate.
</p>
<p>Timings for the steps run through in <code>roptest</code> are available
in attributes <code>timings</code>, and for the step of the
<code>kStepEstimator</code> in <code>kStepTimings</code>.
</p>
<p>One may also use the arguments <code>startCtrl</code>, <code>startICCtrl</code>, and
<code>kStepCtrl</code> of function <code><a href="#topic+robest">robest</a></code>. This allows for individual
settings of <code>E.argList</code>, <code>withEvalAsVar</code>, and
<code>withMakeIC</code> for the different steps. If any of the three arguments
<code>startCtrl</code>, <code>startICCtrl</code>, and <code>kStepCtrl</code> is used, the
respective attributes set in the correspondig argument are used and, if
colliding with arguments directly passed to <code>roptest</code>, the directly
passed ones are ignored.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there are attributes <code>diagnostic</code>
and <code>kStepDiagnostic</code> attached to the return value, which may be inspected
and assessed through <code><a href="distrEx.html#topic+distrExIntegrate">showDiagnostic</a></code> and
<code><a href="distrEx.html#topic+distrExIntegrate">getDiagnostic</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"kStepEstimate"</code>.  In addition, it has
an attribute <code>"timings"</code> where computation time is stored.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br />
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P. (2010): R package distrMod: 
Object-Oriented Implementation of Probability Models. 
J. Statist. Softw.  <b>35</b>(10), 1&ndash;27. <a href="https://doi.org/10.18637/jss.v035.i10">doi:10.18637/jss.v035.i10</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333&ndash;354. 
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2008) The Costs of not Knowing
the Radius. Statistical Methods and Applications <b>17</b>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2001) The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>
</p>


<h3>See Also</h3>

 <p><code><a href="RobLox.html#topic+roblox">roblox</a></code>, 
<code><a href="distrMod.html#topic+L2ParamFamily-class">L2ParamFamily-class</a></code>
<code><a href="RobAStBase.html#topic+UncondNeighborhood-class">UncondNeighborhood-class</a></code>,
<code><a href="distrMod.html#topic+RiskType-class">RiskType-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Don't run to reduce check time on CRAN
## Not run: 
#############################
## 1. Binomial data
#############################
## generate a sample of contaminated data
set.seed(123)
ind &lt;- rbinom(100, size=1, prob=0.05)
x &lt;- rbinom(100, size=25, prob=(1-ind)*0.25 + ind*0.9)

## ML-estimate
MLest &lt;- MLEstimator(x, BinomFamily(size = 25))
estimate(MLest)
confint(MLest)

## compute optimally robust estimator (known contamination)
robest1 &lt;- roptest(x, BinomFamily(size = 25), eps = 0.05, steps = 3)
robest1.0 &lt;- roptest.old(x, BinomFamily(size = 25), eps = 0.05, steps = 3)
identical(robest1,robest1.0)
estimate(robest1)
confint(robest1, method = symmetricBias())
## neglecting bias
confint(robest1)
plot(pIC(robest1))
tmp &lt;- qqplot(x, robest1, cex.pch=1.5, exp.cex2.pch = -.25,
              exp.fadcol.pch = .55, jit.fac=.9)

## compute optimally robust estimator (unknown contamination)
robest2 &lt;- roptest(x, BinomFamily(size = 25), eps.lower = 0, eps.upper = 0.2, steps = 3)
estimate(robest2)
confint(robest2, method = symmetricBias())
plot(pIC(robest2))

## total variation neighborhoods (known deviation)
robest3 &lt;- roptest(x, BinomFamily(size = 25), eps = 0.025, 
                   neighbor = TotalVarNeighborhood(), steps = 3)
estimate(robest3)
confint(robest3, method = symmetricBias())
plot(pIC(robest3))

## total variation neighborhoods (unknown deviation)
robest4 &lt;- roptest(x, BinomFamily(size = 25), eps.lower = 0, eps.upper = 0.1, 
                   neighbor = TotalVarNeighborhood(), steps = 3)
estimate(robest4)
confint(robest4, method = symmetricBias())
plot(pIC(robest4))

#############################
## 2. Poisson data
#############################
## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
x &lt;- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532), 
       rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27), 
       rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))

## ML-estimate
MLest &lt;- MLEstimator(x, PoisFamily())
estimate(MLest)
confint(MLest)

## compute optimally robust estimator (unknown contamination)
robest &lt;- roptest(x, PoisFamily(), eps.upper = 0.1, steps = 3)
estimate(robest)
confint(robest, symmetricBias())

plot(pIC(robest))
tmp &lt;- qqplot(x, robest, cex.pch=1.5, exp.cex2.pch = -.25,
              exp.fadcol.pch = .55, jit.fac=.9)
 
## total variation neighborhoods (unknown deviation)
robest1 &lt;- roptest(x, PoisFamily(), eps.upper = 0.05, 
                  neighbor = TotalVarNeighborhood(), steps = 3)
estimate(robest1)
confint(robest1, symmetricBias())
plot(pIC(robest1))

## End(Not run)

#############################
## 3. Normal (Gaussian) location and scale
#############################

## this example of a two dimensional parameter
## to be estimated will need more time than 
## 5 seconds to run 
## you can find it in 
## system.file("scripts", "examples_taking_longer.R", 
##              package="ROptEst")

</code></pre>

<hr>
<h2 id='updateNorm-methods'> Methods for Function updateNorm in Package &lsquo;ROptEst&rsquo; </h2><span id='topic+updateNorm-methods'></span><span id='topic+updateNorm'></span><span id='topic+updateNorm+2CSelfNorm-method'></span>

<h3>Description</h3>

<p>updateNorm-methods to update norm in IC-Algo</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateNorm(normtype, ...)
## S4 method for signature 'SelfNorm'
updateNorm(normtype, L2, neighbor, biastype, Distr, V.comp, 
                                cent, stand,  w)     
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateNorm-methods_+3A_normtype">normtype</code></td>
<td>
<p>normtype of class <code>NormType</code></p>
</td></tr>
<tr><td><code id="updateNorm-methods_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to specific methods.</p>
</td></tr>
<tr><td><code id="updateNorm-methods_+3A_l2">L2</code></td>
<td>
<p>L2derivative</p>
</td></tr>
<tr><td><code id="updateNorm-methods_+3A_neighbor">neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td></tr>
<tr><td><code id="updateNorm-methods_+3A_biastype">biastype</code></td>
<td>
<p> object of class <code>"BiasType"</code> </p>
</td></tr>
<tr><td><code id="updateNorm-methods_+3A_cent">cent</code></td>
<td>
<p> optimal centering constant. </p>
</td></tr>
<tr><td><code id="updateNorm-methods_+3A_stand">stand</code></td>
<td>
<p> standardizing matrix. </p>
</td></tr>
<tr><td><code id="updateNorm-methods_+3A_distr">Distr</code></td>
<td>
<p> standardizing matrix. </p>
</td></tr>
<tr><td><code id="updateNorm-methods_+3A_v.comp">V.comp</code></td>
<td>
<p> matrix: indication which components of the standardizing
matrix have to be computed. </p>
</td></tr>
<tr><td><code id="updateNorm-methods_+3A_w">w</code></td>
<td>
<p>object of class <code>RobWeight</code>; current weight</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code>updateNorm</code> is used internally in the opt-IC-algorithm to be
able to work with a norm that depends on the current covariance 
(<code>SelfNorm</code>)</p>


<h3>Value</h3>

<table>
<tr><td><code>updateNorm</code></td>
<td>
<p>an updated object of class <code>NormType</code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>updateNorm</dt><dd><p><code>signature(normtype = "SelfNorm")</code>:
udates the norm in the self-standardized case; just used
internally in the opt-IC-Algorithm. </p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code><a href="distrMod.html#topic+NormType-class">NormType-class</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
