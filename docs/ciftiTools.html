<!DOCTYPE html><html><head><title>Help for package ciftiTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ciftiTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ciftiTools'><p>ciftiTools: Tools for Reading and Visualizing CIFTI Brain Files</p></a></li>
<li><a href='#.onAttach'><p>Message on attach</p></a></li>
<li><a href='#add_surf'><p>Add surface(s) to a <code>"xifti"</code></p></a></li>
<li><a href='#all_integers'><p>All integers?</p></a></li>
<li><a href='#apply_parc'><p>Apply function over locations in each parcel</p></a></li>
<li><a href='#apply_xifti'><p>Apply a function along the rows or columns of a <code>"xifti"</code></p></a></li>
<li><a href='#area_original_Param'><p>area_original_Param</p></a></li>
<li><a href='#area_target_Param'><p>area_target_Param</p></a></li>
<li><a href='#as.matrix.xifti'><p>Convert a <code>"xifti"</code> to a matrix</p></a></li>
<li><a href='#as.metric_gifti'><p>Format metric data as a <code>"gifti"</code></p></a></li>
<li><a href='#as.surf_gifti'><p>Format surface data as a <code>"gifti"</code></p></a></li>
<li><a href='#as.xifti'><p>Assemble a <code>"xifti"</code> from data</p></a></li>
<li><a href='#assure_parc'><p>Assure this is a parcellation</p></a></li>
<li><a href='#boundary_mask_surf'><p>Boundary region of a mask</p></a></li>
<li><a href='#brainstructures_Param_all'><p>brainstructures</p></a></li>
<li><a href='#brainstructures_Param_LR'><p>brainstructures</p></a></li>
<li><a href='#check_cifti_type'><p>Check CIFTI type</p></a></li>
<li><a href='#cifti_component_suffix'><p>Get CIFTI component suffix default</p></a></li>
<li><a href='#cifti_fname_Param'><p>cifti_fname</p></a></li>
<li><a href='#ciftiTools_msg'><p>Print suppressible message</p></a></li>
<li><a href='#ciftiTools_warn'><p>Print suppressible warning</p></a></li>
<li><a href='#ciftiTools.checkOption'><p>Validate a <code>ciftiTools</code> option and value</p></a></li>
<li><a href='#ciftiTools.files'><p><code>ciftiTools</code> files</p></a></li>
<li><a href='#ciftiTools.getOption'><p>Get a <code>ciftiTools</code> option</p></a></li>
<li><a href='#ciftiTools.listOptions'><p>List <code>ciftiTools</code> options</p></a></li>
<li><a href='#ciftiTools.setOption'><p>Set a <code>ciftiTools</code> option</p></a></li>
<li><a href='#combine_xifti'><p>Combine <code>"xifti"</code>s with non-overlapping brain structures</p></a></li>
<li><a href='#confirm_wb_cmd_path'><p>Confirm the Connectome Workbench command path</p></a></li>
<li><a href='#convert_to_dlabel'><p>Convert the intent of a CIFTI file or <code>"xifti"</code> object</p></a></li>
<li><a href='#coordlist_to_vol'><p>Convert coordinate list to volume</p></a></li>
<li><a href='#crop_image'><p>Crop image</p></a></li>
<li><a href='#crop_vol'><p>Crop a 3D array</p></a></li>
<li><a href='#dim.xifti'><p>Dimensions of a <code>"xifti"</code></p></a></li>
<li><a href='#dist_from_mask_surf'><p>Distance from mask on surface</p></a></li>
<li><a href='#edit_mask_surf'><p>Edit mask on surface</p></a></li>
<li><a href='#even_vert_samp'><p>Evenly sample vertices of mesh</p></a></li>
<li><a href='#expand_color_pal'><p>Interpolates between entries in the input palette to make a larger palette</p>
with COLOR_RES entries.</a></li>
<li><a href='#expect_equal_xifti'><p>Expect these <code>"xifti"</code>s to match</p></a></li>
<li><a href='#faces_Param'><p>faces</p></a></li>
<li><a href='#fix_gifti_mwall'><p>Fix GIFTI medial wall</p></a></li>
<li><a href='#fix_xifti'><p>Fix a <code>"xifti"</code></p></a></li>
<li><a href='#flatten_xifti'><p>Flatten a <code>"xifti"</code></p></a></li>
<li><a href='#format_path'><p>Format a path</p></a></li>
<li><a href='#get_cifti_extn'><p>Get CIFTI file extension</p></a></li>
<li><a href='#get_data_meta_from_cifti_xml'><p>Extract data-related metadata from CIFTI</p></a></li>
<li><a href='#get_intn_meta_from_cifti_xml'><p>Extract intent-specific metadata from CIFTI</p></a></li>
<li><a href='#get_kwargs'><p>Get kwargs</p></a></li>
<li><a href='#get_misc_meta_from_cifti_xml'><p>Extract misc metadata from CIFTI</p></a></li>
<li><a href='#get_wb_cmd_path'><p>Get the Connectome Workbench command path</p></a></li>
<li><a href='#header_cifti'><p>Get NIFTI header (of a CIFTI)</p></a></li>
<li><a href='#idx_Param'><p>idx</p></a></li>
<li><a href='#infer_resolution'><p>Infer resolution from <code>"xifti"</code> and surfaces</p></a></li>
<li><a href='#info_cifti'><p>Get CIFTI metadata</p></a></li>
<li><a href='#is.3D_mask'><p>Validate a 3d binary mask</p></a></li>
<li><a href='#is.cifti'><p>Validate a <code>"xifti"</code> object</p></a></li>
<li><a href='#is.fname'><p>Is this an existing file path?</p></a></li>
<li><a href='#is.nummat'><p>Validate a numeric matrix</p></a></li>
<li><a href='#is.subcort_labs'><p>Validate a factor vector of subcortical labels</p></a></li>
<li><a href='#is.surf'><p>Validate a <code>"surf"</code> object (vertices + faces)</p></a></li>
<li><a href='#is.xifti'><p>Validate a <code>"xifti"</code> object.</p></a></li>
<li><a href='#is.xifti_data'><p>Validate the &quot;data&quot; component of a <code>"xifti"</code> object</p></a></li>
<li><a href='#is.xifti_meta'><p>Validate the <code>"meta"</code> component of a <code>"xifti"</code> object</p></a></li>
<li><a href='#labels_Description'><p>labels</p></a></li>
<li><a href='#load_parc'><p>Load a parcellation included in <code>ciftiTools</code></p></a></li>
<li><a href='#load_sub_parc'><p>Load subcortical parcellation</p></a></li>
<li><a href='#load_surf'><p>Load a <code>"surf"</code> included in <code>ciftiTools</code></p></a></li>
<li><a href='#make_color_pal'><p>Make a color palette.</p></a></li>
<li><a href='#make_cortex'><p>Make the cortical components of a <code>"xifti"</code></p></a></li>
<li><a href='#make_subcort'><p>Make the subcortical components of a <code>"xifti"</code></p></a></li>
<li><a href='#make_trans_mat'><p>Make the subcortical transformation matrix</p></a></li>
<li><a href='#make_xifti'><p>Assemble a <code>"xifti"</code> object</p></a></li>
<li><a href='#mask_Param_vertices'><p>mask: vertices</p></a></li>
<li><a href='#mask_surf'><p>Mask surface</p></a></li>
<li><a href='#mask_with_boundary_surf'><p>Apply Mask With Boundary To Mesh</p></a></li>
<li><a href='#match_exactly'><p>Do these character vectors match exactly?</p></a></li>
<li><a href='#match_input'><p>Match user inputs to expected values</p></a></li>
<li><a href='#merge_kwargs'><p>Merges two kwargs</p></a></li>
<li><a href='#merge_xifti'><p>Concatenate <code>"xifti"</code>s</p></a></li>
<li><a href='#move_from_mwall'><p>Move data locations from medial wall</p></a></li>
<li><a href='#move_to_mwall'><p>Move data locations to the medial wall</p></a></li>
<li><a href='#ncol_xifti'><p>Counts the number of columns in a <code>"xifti"</code>.</p></a></li>
<li><a href='#newdata_xifti'><p>Replace the data in a <code>"xifti"</code></p></a></li>
<li><a href='#nrow_xifti'><p>Counts the number of rows (vertices + voxels) in a <code>"xifti"</code>.</p></a></li>
<li><a href='#original_fnames_Param_remapped'><p>original_fnames: for remapping</p></a></li>
<li><a href='#original_fnames_Param_resampled'><p>original_fnames: for resampling</p></a></li>
<li><a href='#pad_vol'><p>Pad a 3D Array</p></a></li>
<li><a href='#parc_add_subcortex'><p>Add subcortex to cortical parcellation</p></a></li>
<li><a href='#parc_borders'><p>Parcellation borders</p></a></li>
<li><a href='#parc_mean_mat'><p>Make parcellation mean matrix</p></a></li>
<li><a href='#parc_vals_to_xifti'><p>Convert parcellation values to <code>"xifti"</code></p></a></li>
<li><a href='#plot.surf'><p>S3 method: plot surface</p></a></li>
<li><a href='#plot.xifti'><p>S3 method: use <code>view_xifti</code> to plot a <code>"xifti"</code> object</p></a></li>
<li><a href='#radial_order_surf'><p>Order Vertices on Circular Manifold</p></a></li>
<li><a href='#read_cifti'><p>Read a CIFTI file</p></a></li>
<li><a href='#read_cifti_convert'><p>Read a CIFTI file quickly</p></a></li>
<li><a href='#read_cifti_flat'><p>Read only the data matrix in a CIFTI file</p></a></li>
<li><a href='#read_cifti_separate'><p>Read a CIFTI file with optional resampling</p></a></li>
<li><a href='#read_dir_Param_separated'><p>read_dir: separated files</p></a></li>
<li><a href='#read_surf'><p>Get a <code>"surf"</code> object</p></a></li>
<li><a href='#read_xifti2'><p>Read in GIFTI files as a <code>"xifti"</code> object</p></a></li>
<li><a href='#remap_cifti'><p>Remap CIFTI data</p></a></li>
<li><a href='#remap_cifti_wrapper'><p><code>remap_cifti</code> wrapper</p></a></li>
<li><a href='#remap_gifti'><p>Remap GIFTI metric or label data</p></a></li>
<li><a href='#remove_xifti'><p>Remove a component from a <code>"xifti"</code></p></a></li>
<li><a href='#resamp_method_Param'><p>resamp_method</p></a></li>
<li><a href='#resamp_res_Param_optional'><p>resamp_res: optional</p></a></li>
<li><a href='#resamp_res_Param_required'><p>resamp_res: required</p></a></li>
<li><a href='#resample_cifti'><p>Resample CIFTI data</p></a></li>
<li><a href='#resample_cifti_components'><p>Resample a series of GIFTIs related to a CIFTI file</p></a></li>
<li><a href='#resample_cifti_default_fname'><p>Get resampled file name default</p></a></li>
<li><a href='#resample_cifti_from_template'><p>Resample a CIFTI from a template</p></a></li>
<li><a href='#resample_cifti_wrapper'><p><code>resample_cifti</code> wrapper</p></a></li>
<li><a href='#resample_gifti'><p>Resample a GIFTI file (with its ROI)</p></a></li>
<li><a href='#resample_surf'><p>Resample a <code>"surf"</code> object</p></a></li>
<li><a href='#rgl_interactive_plots_Description'><p>Navigating and Embedding the Interactive Plots</p></a></li>
<li><a href='#rgl_static_plots_Description'><p>Embedding the Static Plots</p></a></li>
<li><a href='#ROI_brainstructures_Param_LR'><p>ROI_brainstructures</p></a></li>
<li><a href='#rotate_surf'><p>Rotate a <code>"surf"</code> object</p></a></li>
<li><a href='#ROY_BIG_BL'><p>&quot;ROY_BIG_BL&quot; color palette</p></a></li>
<li><a href='#run_wb_cmd'><p>Wrapper for Connectome Workbench Commands</p></a></li>
<li><a href='#S3_Math'><p><code>"xifti"</code> S3 Math methods</p></a></li>
<li><a href='#S3_Ops'><p><code>"xifti"</code> S3 Ops methods</p></a></li>
<li><a href='#S3_Summary'><p><code>"xifti"</code> S3 Summary methods</p></a></li>
<li><a href='#scale_xifti'><p>Scale CIFTI</p></a></li>
<li><a href='#select_xifti'><p>Select columns of a <code>"xifti"</code></p></a></li>
<li><a href='#separate_cifti'><p>Separate a CIFTI file</p></a></li>
<li><a href='#separate_cifti_files'><p>Separate CIFTI: file names</p></a></li>
<li><a href='#separate_cifti_wrapper'><p><code>separate_cifti</code> wrapper</p></a></li>
<li><a href='#set_names_xifti'><p>Set <code>"xifti"</code> column names</p></a></li>
<li><a href='#smooth_cifti'><p>Smooth CIFTI data</p></a></li>
<li><a href='#smooth_gifti'><p>Smooth a metric GIFTI file</p></a></li>
<li><a href='#substructure_table'><p>Substructure table</p></a></li>
<li><a href='#summary.surf'><p>Summarize a <code>"surf"</code> object</p></a></li>
<li><a href='#summary.xifti'><p>Summarize a <code>"xifti"</code> object</p></a></li>
<li><a href='#supported_intents'><p>The NIFTI intents supported by <code>ciftiTools</code></p></a></li>
<li><a href='#surf_area'><p>Surface area calculation</p></a></li>
<li><a href='#surface_plot_Params'><p>Surface plot</p></a></li>
<li><a href='#surfL_fname_Param'><p>surfL_fname</p></a></li>
<li><a href='#surfL_original_fname_Param'><p>surfL_original_fname</p></a></li>
<li><a href='#surfL_Param_optional'><p>surfL</p></a></li>
<li><a href='#surfL_target_fname_Param'><p>surfL_target_fname</p></a></li>
<li><a href='#surfR_fname_Param'><p>surfR_fname</p></a></li>
<li><a href='#surfR_original_fname_Param'><p>surfR_original_fname</p></a></li>
<li><a href='#surfR_Param_optional'><p>surfR</p></a></li>
<li><a href='#surfR_target_fname_Param'><p>surfR_target_fname</p></a></li>
<li><a href='#sys_path'><p>Format a path for <code>system</code></p></a></li>
<li><a href='#template_xifti'><p>Make a template <code>"xifti"</code> object</p></a></li>
<li><a href='#transform_xifti'><p>Apply a univariate transformation to a <code>"xifti"</code> or pair of <code>"xifti"</code>s.</p></a></li>
<li><a href='#unmask_cortex'><p>Unmask cortex</p></a></li>
<li><a href='#unmask_subcortex'><p>Undo the volumetric mask to the subcortex</p></a></li>
<li><a href='#unvec_vol'><p>Convert vectorized data back to volume</p></a></li>
<li><a href='#use_color_pal'><p>Use a color palette</p></a></li>
<li><a href='#verbose_Param_FALSE'><p>verbose: FALSE</p></a></li>
<li><a href='#verbose_Param_TRUE'><p>verbose: TRUE</p></a></li>
<li><a href='#vert_adjacency'><p>Vertex Adjacency Matrix</p></a></li>
<li><a href='#vertices_Param'><p>vertices</p></a></li>
<li><a href='#view_comp'><p>View composite of images</p></a></li>
<li><a href='#view_surf'><p>View <code>"surf"</code> object(s)</p></a></li>
<li><a href='#view_xifti'><p>View a <code>"xifti"</code> object</p></a></li>
<li><a href='#view_xifti_surface'><p>View cortical surface data in a <code>"xifti"</code></p></a></li>
<li><a href='#view_xifti_surface.color'><p>Get the palettes and data color mapping for <code>view_xifti_surface</code></p></a></li>
<li><a href='#view_xifti_surface.draw_mesh'><p>Draw brain hemisphere mesh in RGL</p></a></li>
<li><a href='#view_xifti_surface.draw_title'><p>Draw title in RGL</p></a></li>
<li><a href='#view_xifti_surface.mesh_val'><p>Get the mesh(es) and data values for <code>view_xifti_surface</code></p></a></li>
<li><a href='#view_xifti_surface.surf_hemi'><p>Sort out surface &amp; hemisphere args for <code>view_xifti_surface</code></p></a></li>
<li><a href='#view_xifti_volume'><p>View subcortical data in a <code>"xifti"</code></p></a></li>
<li><a href='#view_xifti.cbar'><p>Make the colorbar for <code>view_xifti_surface</code></p></a></li>
<li><a href='#view_xifti.cleg'><p>Draw color legend for qualitative mode</p></a></li>
<li><a href='#view_xifti.title'><p>Get title for <code>view_xifti_surface</code> or <code>view_xifti_volume</code></p></a></li>
<li><a href='#vox_locations'><p>Get spatial locations of each voxel</p></a></li>
<li><a href='#wb_path_request'><p>Request <code>"wb_path"</code></p></a></li>
<li><a href='#welcome_msg'><p>Welcome message</p></a></li>
<li><a href='#write_cifti'><p>Write a CIFTI file from a <code>"xifti"</code> object</p></a></li>
<li><a href='#write_cifti_from_separate'><p>Write a CIFTI file from NIFTI and GIFTI files</p></a></li>
<li><a href='#write_dir_Param_generic'><p>write_dir: generic</p></a></li>
<li><a href='#write_label_table'><p>Write label table to text file</p></a></li>
<li><a href='#write_metric_gifti'><p>Write a data matrix to a GIFTI metric file</p></a></li>
<li><a href='#write_spheres'><p>Generate GIFTI sphere surface files</p></a></li>
<li><a href='#write_subcort_nifti'><p>Write subcortical data to NIFTI files</p></a></li>
<li><a href='#write_surf_gifti'><p>Write a <code>"surf"</code> to a GIFTI surface file</p></a></li>
<li><a href='#write_xifti2'><p>Write a <code>"xifti"</code> object to GIFTI and NIFTI files</p></a></li>
<li><a href='#x_Param_xifti'><p>x: xifti</p></a></li>
<li><a href='#xifti_Param'><p>xifti</p></a></li>
<li><a href='#xml_cifti'><p>Get XML of a CIFTI</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Reading, Writing, Viewing and Manipulating CIFTI Files</td>
</tr>
<tr>
<td>Version:</td>
<td>0.14.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Amanda Mejia &lt;mandy.mejia@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>CIFTI files contain brain imaging data in "grayordinates," which 
    represent the gray matter as cortical surface vertices (left and right) and
    subcortical voxels (cerebellum, basal ganglia, and other deep gray matter). 
    'ciftiTools' provides a unified environment for reading, writing, 
    visualizing and manipulating CIFTI-format data. It supports the "dscalar," 
    "dlabel," and "dtseries" intents. Grayordinate data is read in as a "xifti" 
    object, which is structured for convenient access to the data and metadata,
    and includes support for surface geometry files to enable
    spatially-dependent functionality such as static or interactive 
    visualizations and smoothing.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields, gifti (&gt; 0.7.5), grDevices, oro.nifti, RNifti,
RColorBrewer, rgl, viridisLite, xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, ggpubr, grid, gridExtra, htmlwidgets,
manipulateWidget, knitr, rmarkdown, png, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mandymejia/ciftiTools">https://github.com/mandymejia/ciftiTools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mandymejia/ciftiTools/issues">https://github.com/mandymejia/ciftiTools/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-23 17:28:11 UTC; ddpham</td>
</tr>
<tr>
<td>Author:</td>
<td>Amanda Mejia [aut, cre],
  Damon Pham <a href="https://orcid.org/0000-0001-7563-4727"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  John Muschelli <a href="https://orcid.org/0000-0001-6469-1750"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-24 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ciftiTools'>ciftiTools: Tools for Reading and Visualizing CIFTI Brain Files</h2><span id='topic+ciftiTools-package'></span><span id='topic+ciftiTools'></span>

<h3>Description</h3>

<p>Here are groups of commonly-used functions in <code>ciftiTools</code>:
</p>


<h3>Details</h3>

<p>Functions for reading in CIFTI or GIFTI data:
</p>

<dl>
<dt><code>read_xifti</code>:</dt><dd><p>   Read in a CIFTI file as a <code>"xifti"</code></p>
</dd>
<dt><code>read_xifti2</code>:</dt><dd><p>   Read in GIFTI files as a <code>"xifti"</code></p>
</dd>
<dt><code>as.xifti</code>:</dt><dd><p>   Combine numeric data to form a <code>"xifti"</code></p>
</dd>
<dt><code>read_surf</code>:</dt><dd><p>   Read in a surface GIFTI file as a <code>"surf"</code></p>
</dd>
<dt><code>info_cifti</code>:</dt><dd><p>   Read the metadata in a CIFTI file</p>
</dd>
<dt><code>load_surf</code>:</dt><dd><p>   Read in a surface included in <code>ciftiTools</code></p>
</dd>
<dt><code>load_parc</code>:</dt><dd><p>   Read in a parcellation included in <code>ciftiTools</code></p>
</dd>
</dl>

<p>Functions for writing CIFTI or GIFTI data:
</p>

<dl>
<dt><code>write_cifti</code>:</dt><dd><p>   Write a <code>"xifti"</code> to a CIFTI file</p>
</dd>
<dt><code>write_xifti2</code>:</dt><dd><p>   Write a <code>"xifti"</code> to GIFTI and NIFTI files</p>
</dd>
<dt><code>write_metric_gifti</code>:</dt><dd><p>   Write a numeric data matrix to a metric GIFTI file</p>
</dd>
<dt><code>write_surf_gifti</code>:</dt><dd><p>   Write a <code>"surf"</code> to a surface GIFTI file</p>
</dd>
<dt><code>write_subcort_nifti</code>:</dt><dd><p>   Write subcortical data to NIFTI files</p>
</dd>
<dt><code>separate_cifti</code>:</dt><dd><p>   Separate a CIFTI file into GIFTI and NIFTI files</p>
</dd>
</dl>

<p>Functions for manipulating <code>"xifti"</code>s:
</p>

<dl>
<dt><code>apply_xifti</code>:</dt><dd><p>   Apply a function along the rows or columns of the <code>"xifti"</code> data matrix</p>
</dd>
<dt><code>combine_xifti</code>:</dt><dd><p>   Combine multiple <code>"xifti"</code>s with non-overlapping brain structures</p>
</dd>
<dt><code>convert_xifti</code>:</dt><dd><p>   Convert the intent of a <code>"xifti"</code></p>
</dd>
<dt><code>merge_xifti</code>:</dt><dd><p>   Concatenate data matrices from multiple <code>"xifti"</code>s</p>
</dd>
<dt><code>newdata_xifti</code>:</dt><dd><p>   Replace the data matrix in a <code>"xifti"</code></p>
</dd>
<dt><code>remove_xifti</code>:</dt><dd><p>   Remove a brain structure or surface from a <code>"xifti"</code></p>
</dd>
<dt><code>select_xifti</code>:</dt><dd><p>   Select data matrix columns of a <code>"xifti"</code></p>
</dd>
<dt><code>transform_xifti</code>:</dt><dd><p>   Apply a univariate transformation to a <code>"xifti"</code> or pair of <code>"xifti"</code>s</p>
</dd>
<dt><code>add_surf</code>:</dt><dd><p>   Add surfaces to a <code>"xifti"</code></p>
</dd>
<dt><code>move_from_mwall</code>:</dt><dd><p>   Move medial wall vertices back into the <code>"xifti"</code> data matrix</p>
</dd>
<dt><code>move_to_mwall</code>:</dt><dd><p>   Move rows with a certain value into the <code>"xifti"</code> medial wall mask</p>
</dd>
</dl>

<p>S3 methods for <code>"xifti"</code>s:
</p>

<dl>
<dt><code>summary</code> and <code>print</code>:</dt><dd><p>   Summarize the contents.</p>
</dd>
<dt><code>as.matrix</code>:</dt><dd><p>   Convert data to a locations by measurements numeric matrix.</p>
</dd>
<dt><code>dim</code>:</dt><dd><p>    Obtain number of locations and number of measurements.</p>
</dd>
<dt><code>plot</code>:</dt><dd><p>   Visualize the cortical surface and/or subcortical data.</p>
</dd>
<dt><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>%%</code>, <code>%/%</code>:</dt><dd><p>    Operation between a <code>"xifti"</code> and a scalar, or between two <code>"xifti"</code>s.</p>
</dd>
<dt><code>abs</code>, <code>ceiling</code>, <code>exp</code>, <code>floor</code>, <code>log</code>, <code>round</code>, <code>sign</code>, and <code>sqrt</code>:</dt><dd><p>    Univariate transformation of <code>"xifti"</code> data.</p>
</dd>
</dl>

<p>Functions for working with surfaces:
</p>

<dl>
<dt><code>read_surf</code>:</dt><dd><p>   Read in a surface GIFTI file as a <code>"surf"</code></p>
</dd>
<dt><code>is.surf</code>:</dt><dd><p>   Verify a <code>"surf"</code></p>
</dd>
<dt><code>write_surf_gifti</code>:</dt><dd><p>   Write a <code>"surf"</code> to a surface GIFTI file</p>
</dd>
<dt><code>view_surf</code>:</dt><dd><p>   Visualize a <code>"surf"</code></p>
</dd>
<dt><code>resample_surf</code>:</dt><dd><p>   Resample a <code>"surf"</code></p>
</dd>
<dt><code>rotate_surf</code>:</dt><dd><p>   Rotate the geometry of a <code>"surf"</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Amanda Mejia <a href="mailto:mandy.mejia@gmail.com">mandy.mejia@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Damon Pham <a href="mailto:damondpham@gmail.com">damondpham@gmail.com</a> (<a href="https://orcid.org/0000-0001-7563-4727">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> John Muschelli <a href="mailto:muschellij2@gmail.com">muschellij2@gmail.com</a> (<a href="https://orcid.org/0000-0001-6469-1750">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mandymejia/ciftiTools">https://github.com/mandymejia/ciftiTools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mandymejia/ciftiTools/issues">https://github.com/mandymejia/ciftiTools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.onAttach'>Message on attach</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>Direct user to indicate Connectome Workbench path and check gifti package version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='add_surf'>Add surface(s) to a <code>"xifti"</code></h2><span id='topic+add_surf'></span>

<h3>Description</h3>

<p>Add left or right cortical surface geometry to a <code>"xifti"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_surf(xifti, surfL = NULL, surfR = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_surf_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="add_surf_+3A_surfl">surfL</code></td>
<td>
<p>(Optional) Left brain surface model. Can be a file
path to a GIFTI surface geometry file (ends in &quot;*.surf.gii&quot;), a
<code>"gifti"</code> object representing surface geometry, or a <code>"surf"</code>
object.</p>
</td></tr>
<tr><td><code id="add_surf_+3A_surfr">surfR</code></td>
<td>
<p>(Optional) Right brain surface model. Can be a file
path to a GIFTI surface geometry file (ends in &quot;*.surf.gii&quot;), a
<code>"gifti"</code> object representing surface geometry, or a <code>"surf"</code>
object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>surfL</code> will be added to <code>xifti$surf$cortex_left</code> and <code>surfR</code>
will be added to <code>xifti$surf$cortex_right</code>. Any existing surfaces will
be overwritten.
</p>
<p>If the resolutions of the data and surfaces do not match, the surfaces will
be resampled to match the resolution of the data. The barycentric resampling
method, which is recommended for anatomical surfaces, will be used.
</p>


<h3>Value</h3>

<p>the <code>"xifti"</code> object with added surface geometry components.
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>
<p>Other surface-related: 
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='all_integers'>All integers?</h2><span id='topic+all_integers'></span>

<h3>Description</h3>

<p>Check if a data vector or matrix is all integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_integers(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_integers_+3A_x">x</code></td>
<td>
<p>The data vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. Is <code>x</code> all integers?
</p>

<hr>
<h2 id='apply_parc'>Apply function over locations in each parcel</h2><span id='topic+apply_parc'></span>

<h3>Description</h3>

<p>Apply a function across all locations in each parcel, for a pair of data and
parcellation <code>"xifti"</code> objects that are in registration with one
another. By default, the mean value in each parcel is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_parc(
  xii,
  parc,
  FUN = mean,
  mwall_value = NA,
  return_as = c("matrix", "xifti"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_parc_+3A_xii">xii</code></td>
<td>
<p>The <code>"xifti"</code> data to apply the function over, within each
parcel.</p>
</td></tr>
<tr><td><code id="apply_parc_+3A_parc">parc</code></td>
<td>
<p>The <code>"xifti"</code> &quot;dlabel&quot; parcellation. Each parcel is defined
by a unique key in the label table. If there are multiple columns, only the
first column will be used. Alternatively, <code>parc</code> can just be a vector
of keys whose length is the number of data locations in <code>"xii"</code>.</p>
</td></tr>
<tr><td><code id="apply_parc_+3A_fun">FUN</code></td>
<td>
<p>A function that takes as input an <code class="reqn">M \times N</code> matrix (<code class="reqn">M</code>
locations in a given parcel, and <code class="reqn">N</code> measurements/columns in <code>xii</code>)
and outputs a constant-sized (<code class="reqn">Q</code>) numeric vector. Default: <code>mean</code>.
</p>
<p>Use <code>colMeans</code> to obtain the average timeseries of each parcel, such as
in order to compute functional connectivity.</p>
</td></tr>
<tr><td><code id="apply_parc_+3A_mwall_value">mwall_value</code></td>
<td>
<p>If there is a medial wall in <code>xii</code>, what should value
should medial wall locations be replaced with prior to calculation?
Default: <code>NA</code>.</p>
</td></tr>
<tr><td><code id="apply_parc_+3A_return_as">return_as</code></td>
<td>
<p><code>"matrix"</code> (default) where each row corresponds to a
parcel, or a <code>"xifti"</code> object where each location's value is the value
of its corresponding parcel?</p>
</td></tr>
<tr><td><code id="apply_parc_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>FUN</code>, e.g. <code>na.rm=TRUE</code>.
Ignored if <code>FUN=="quick_mean"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">P \times Q</code> matrix, where <code class="reqn">P</code> is the number of parcels and
<code class="reqn">Q</code> is the length of the output of <code>FUN</code>. (For <code>mean</code>,
<code class="reqn">Q = 1</code>).
</p>


<h3>See Also</h3>

<p>Other parcellation-related: 
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+load_sub_parc">load_sub_parc</a>()</code>,
<code><a href="#topic+parc_add_subcortex">parc_add_subcortex</a>()</code>,
<code><a href="#topic+parc_borders">parc_borders</a>()</code>,
<code><a href="#topic+parc_vals_to_xifti">parc_vals_to_xifti</a>()</code>
</p>
<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='apply_xifti'>Apply a function along the rows or columns of a <code>"xifti"</code></h2><span id='topic+apply_xifti'></span>

<h3>Description</h3>

<p>Apply a many-to-N function (e.g. mean) to the rows or columns of a
<code>"xifti"</code>. If applied row-wise, a <code>"xifti"</code> with N data column(s)
is returned. (If the <code>"xifti"</code> had the dlabel intent, and values that
are not labels are created, then it is converted to dscalar.) If applied
column-wise, a numeric matrix with N rows is returned.
</p>
<p>For univariate functions, use <code><a href="#topic+transform_xifti">transform_xifti</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_xifti(xifti, margin = c(1, 2), FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="apply_xifti_+3A_margin">margin</code></td>
<td>
<p>The dimension along which to apply <code>FUN</code>: 1 for rows (default)
and 2 for columns.</p>
</td></tr>
<tr><td><code id="apply_xifti_+3A_fun">FUN</code></td>
<td>
<p>The function. It should take in a numeric vector and return a
length-N numeric vector.</p>
</td></tr>
<tr><td><code id="apply_xifti_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"xifti"</code> if <code>margin == 1</code>, or a numeric matrix if
<code>margin == 2</code>
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='area_original_Param'>area_original_Param</h2><span id='topic+area_original_Param'></span>

<h3>Description</h3>

<p>area_original_Param
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="area_original_Param_+3A_areal_original_fname">areaL_original_fname</code>, <code id="area_original_Param_+3A_arear_original_fname">areaR_original_fname</code></td>
<td>
<p>File paths to the surfaces
to use for vertex area correction during adaptive resampling. (Only used if
resampling with the adaptive method.) <code>area[L/R]_original_fname</code> should
match the current resolution of the data.
</p>
<p>For resampling: the Workbench command for adaptive resampling requires the
target surfaces for area correction too. But to make the workflow easier,
<code>ciftiTools</code> will resample <code>area[L/R]_original_fname</code> with the
barycentric method and use that for the target area.
</p>
<p>For remapping: <code>area[L/R]_target_fname</code> must be directly provided.</p>
</td></tr>
</table>

<hr>
<h2 id='area_target_Param'>area_target_Param</h2><span id='topic+area_target_Param'></span>

<h3>Description</h3>

<p>area_target_Param
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="area_target_Param_+3A_areal_target_fname">areaL_target_fname</code>, <code id="area_target_Param_+3A_arear_target_fname">areaR_target_fname</code></td>
<td>
<p>File paths to the surfaces
to use for vertex area correction during adaptive resampling. (Only used if
resampling with the adaptive method.) <code>area[L/R]_target_fname</code> should
match the target resolution of the data.</p>
</td></tr>
</table>

<hr>
<h2 id='as.matrix.xifti'>Convert a <code>"xifti"</code> to a matrix</h2><span id='topic+as.matrix.xifti'></span>

<h3>Description</h3>

<p>Converts a <code>"xifti"</code> to a matrix by concatenating the data from each
brainstructure along the rows. Surfaces and metadata are discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xifti'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.xifti_+3A_x">x</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="as.matrix.xifti_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input as a matrix. Each brainstructure's data is concatenated.
</p>

<hr>
<h2 id='as.metric_gifti'>Format metric data as a <code>"gifti"</code></h2><span id='topic+as.metric_gifti'></span>

<h3>Description</h3>

<p>Format a <code class="reqn">V \times T</code> numeric matrix (V vertices, T measurements) or a length-T list
of length-V numeric vectors as a <code>"gifti"</code> using a template
<code>"gifti"</code>. The brain hemisphere (left or right) must be indicated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.metric_gifti(
  data,
  hemisphere = c("left", "right"),
  intent = "NONE",
  data_type = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.metric_gifti_+3A_data">data</code></td>
<td>
<p><code class="reqn">V \times T</code> numeric matrix, or length <code class="reqn">T</code> list of length
<code class="reqn">V</code> numeric vectors</p>
</td></tr>
<tr><td><code id="as.metric_gifti_+3A_hemisphere">hemisphere</code></td>
<td>
<p>The side of the brain the data represents: <code>"left"</code>
(default) or <code>"right"</code>. Used to fill the &quot;AnatomicalStructurePrimary&quot;
metadata field.</p>
</td></tr>
<tr><td><code id="as.metric_gifti_+3A_intent">intent</code></td>
<td>
<p>The NIFTI intent, with prefix &quot;NIFTI_INTENT_*&quot;. Default:
<code>"NONE"</code>. For a list of intents see
https://nifti.nimh.nih.gov/nifti-1/documentation/nifti1fields/nifti1fields_pages/group__NIFTI1__INTENT__CODES.html/document_view</p>
</td></tr>
<tr><td><code id="as.metric_gifti_+3A_data_type">data_type</code></td>
<td>
<p>The NIFTI type of <code>data</code>: <code>"NIFTI_TYPE_INT32"</code>
or <code>"NIFTI_TYPE_FLOAT32"</code>. Can also be <code>NULL</code> (default), in which
case the NIFTI type will be inferred from <code>data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data</code> is already a <code>"gifti"</code>, <code>data$data</code> will be
used and any metadata will be overwritten by the template or discarded.
</p>


<h3>Value</h3>

<p>The <code>"gifti"</code>
</p>

<hr>
<h2 id='as.surf_gifti'>Format surface data as a <code>"gifti"</code></h2><span id='topic+as.surf_gifti'></span>

<h3>Description</h3>

<p>Format a <code>"surf"</code> or a list with elements <code>"pointset"</code>
and <code>"triangle"</code> as a <code>"gifti"</code> using a template
<code>"gifti"</code>. The brain hemisphere (left or right) must be indicated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.surf_gifti(surf, hemisphere = c("left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.surf_gifti_+3A_surf">surf</code></td>
<td>
<p>A <code>"surf"</code> or a list with elements
<code>"pointset"</code> and <code>"triangle"</code></p>
</td></tr>
<tr><td><code id="as.surf_gifti_+3A_hemisphere">hemisphere</code></td>
<td>
<p>The side of the brain the surface represents: <code>"left"</code>
(default) or <code>"right"</code>. Used to fill the &quot;AnatomicalStructurePrimary&quot;
metadata field. Only used if <code>surf$hemisphere</code> is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>"gifti"</code>
</p>

<hr>
<h2 id='as.xifti'>Assemble a <code>"xifti"</code> from data</h2><span id='topic+as.xifti'></span><span id='topic+as_xifti'></span><span id='topic+as.cifti'></span><span id='topic+as_cifti'></span>

<h3>Description</h3>

<p>Assembles cortical data, subcortical data, and/or surface geometry to form a
<code>"xifti"</code>. The inputs must be data objects (vectors, matrices or
arrays, depending on the argument).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.xifti(
  cortexL = NULL,
  cortexL_mwall = NULL,
  cortexR = NULL,
  cortexR_mwall = NULL,
  mwall_values = c(NA, NaN),
  subcortVol = NULL,
  subcortLabs = NULL,
  subcortMask = NULL,
  surfL = NULL,
  surfR = NULL,
  col_names = NULL,
  HCP_32k_auto_mwall = TRUE,
  validate = TRUE
)

as_xifti(
  cortexL = NULL,
  cortexL_mwall = NULL,
  cortexR = NULL,
  cortexR_mwall = NULL,
  mwall_values = c(NA, NaN),
  subcortVol = NULL,
  subcortLabs = NULL,
  subcortMask = NULL,
  surfL = NULL,
  surfR = NULL
)

as.cifti(
  cortexL = NULL,
  cortexL_mwall = NULL,
  cortexR = NULL,
  cortexR_mwall = NULL,
  mwall_values = c(NA, NaN),
  subcortVol = NULL,
  subcortLabs = NULL,
  subcortMask = NULL,
  surfL = NULL,
  surfR = NULL
)

as_cifti(
  cortexL = NULL,
  cortexL_mwall = NULL,
  cortexR = NULL,
  cortexR_mwall = NULL,
  mwall_values = c(NA, NaN),
  subcortVol = NULL,
  subcortLabs = NULL,
  subcortMask = NULL,
  surfL = NULL,
  surfR = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.xifti_+3A_cortexl">cortexL</code>, <code id="as.xifti_+3A_cortexl_mwall">cortexL_mwall</code></td>
<td>
<p>Left cortex data and ROI. Each must be a data
matrix or vector.
</p>
<p>If <code>cortexL_mwall</code> is not provided, <code>cortexL</code> should have data for
all vertices on the left cortical surface (<code class="reqn">V_L \times T</code> data matrix). There
will not be a mask for the medial wall. Not providing the medial wall mask
is appropriate for &quot;.dlabels.nii&quot; files where the medial wall may have its
own label and therefore should not be treated as missing data.
</p>
<p>If <code>cortexL_mwall</code> is provided, <code>cortexL</code> should either have data
for all vertices on the left cortical surface (<code class="reqn">V_L \times T</code> data matrix, with
filler values e.g. <code>0</code> or <code>NaN</code> for medial wall vertices), or have data
only for non-medial wall vertices (<code class="reqn">(V_L - mwall_L) \times T</code> data matrix).
The medial wall mask will be the <code>0</code> values in <code>cortexL_mwall</code>.
The medial wall mask should be provided whenever the medial wall should be
treated as missing data.
</p>
<p>Since the unmasked cortices must have the same number of vertices,
<code>V_L</code> should match <code>V_R</code>.</p>
</td></tr>
<tr><td><code id="as.xifti_+3A_cortexr">cortexR</code>, <code id="as.xifti_+3A_cortexr_mwall">cortexR_mwall</code></td>
<td>
<p>Right cortex data and ROI. Each must be a data
matrix or vector.
</p>
<p>If <code>cortexR_mwall</code> is not provided, <code>cortexR</code> should have data for
all vertices on the right cortical surface (<code class="reqn">V_R \times T</code> data mre
will not be a mask for the medial wall. Not providing the medial wall mask
is appropriate for &quot;.dlabels.nii&quot; files where the medial wall may have its
own label and therefore should not be treated as missing data.
</p>
<p>If <code>cortexR_mwall</code> is provided, <code>cortexR</code> should either have data
for all vertices on the right cortical surface (<code class="reqn">V_R \times T</code> data matrix, with
filler values e.g. <code>0</code> or <code>NaN</code> for medial wall vertices), or have data
only for non-medial wall vertices (<code class="reqn">(V_R - mwall_R) \times T</code> data matrix).
The medial wall mask will be the <code>0</code> values in <code>cortexR_mwall</code>.
The medial wall mask should be provided whenever the medial wall should be
treated as missing data.
</p>
<p>Since the unmasked cortices must have the same number of vertices,
<code>V_L</code> should match <code>V_R</code>.</p>
</td></tr>
<tr><td><code id="as.xifti_+3A_mwall_values">mwall_values</code></td>
<td>
<p>If <code>cortex[L/R]_mwall</code> was not provided, or if it
was invalid (i.e. bad length or all <code>TRUE</code>), the medial wall mask will
be inferred from rows in <code>cortex[L/R]</code> that are constantly one of these
values. Default: <code>c(NA, NaN)</code>. If <code>NULL</code>, do not attempt to infer
the medial wall from the data values. <code>NULL</code> should be used if <code>NA</code>
or <code>NaN</code> are legitimate values that non-medial wall vertices might
take on.</p>
</td></tr>
<tr><td><code id="as.xifti_+3A_subcortvol">subcortVol</code>, <code id="as.xifti_+3A_subcortlabs">subcortLabs</code>, <code id="as.xifti_+3A_subcortmask">subcortMask</code></td>
<td>
<p><code>subcortVol</code> represents the
data values of the subcortex. It is either a 3D/4D numeric array
(<code class="reqn">i \times j \times k \times T</code>), or a vectorized matrix (<code class="reqn">V_S</code> voxels by <code class="reqn">T</code>
measurements). If it's vectorized, the voxels should be in spatial order
(<code class="reqn">i</code> index increasing fastest, then <code class="reqn">j</code>, then <code class="reqn">k</code>).
</p>
<p><code>subcortLabs</code> represents the brainstructure labels of each voxel: see
<code><a href="#topic+substructure_table">substructure_table</a></code>. It is either a 3D data array
(<code class="reqn">i \times j \times k</code>) of integer brainstructure indices, or a <code class="reqn">V_S</code> length
vector in spatial order with brainstructure names as factors or integer
indices. The indices should be 3-21 (1 and 2 correspond to left and right
cortex, respectively) or 1-19 (cortex labels omitted), with 0 representing
out-of-mask voxels.
</p>
<p><code>subcortMask</code> is logical 3D data array (<code class="reqn">i \times j \times k</code>) where <code>TRUE</code>
values indicate subcortical voxels (in-mask). If it is not provided, the
mask will be inferred from voxels with labels <code>0</code>, <code>NA</code>, or
<code>NaN</code> in <code>subcortLabs</code>. If <code>subcortLabs</code> are vectorized and
<code>subcortMask</code> is not provided, the mask cannot be inferred so an error
will occur.</p>
</td></tr>
<tr><td><code id="as.xifti_+3A_surfl">surfL</code>, <code id="as.xifti_+3A_surfr">surfR</code></td>
<td>
<p>(Optional) Surface geometries for the left or right cortex.
Can be a surface GIFTI file path or <code>"surf"</code> object; see
<code><a href="#topic+make_surf">make_surf</a></code> for a full description of valid inputs.</p>
</td></tr>
<tr><td><code id="as.xifti_+3A_col_names">col_names</code></td>
<td>
<p>Names of each measurement/column in the data.</p>
</td></tr>
<tr><td><code id="as.xifti_+3A_hcp_32k_auto_mwall">HCP_32k_auto_mwall</code></td>
<td>
<p>If left and/or right cortex data is provided, and
the number of vertices matches that of the HCP 32k mesh (29696 on left, and
29716 on right), should the medial wall masks be added to the <code>"xifti"</code>
if not provided? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="as.xifti_+3A_validate">validate</code></td>
<td>
<p>Validate that the result is a <code>"xifti"</code>? Default:
<code>TRUE</code>. If <code>FALSE</code>, the result may not be properly formatted
if the inputs were invalid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each data or surface component is optional. Metadata components
(<code>cortex[L/R]_mwall</code>, <code>subcortLabs</code>, and <code>subcortMask</code>) will
be ignored if its corresponding data component is not provided. If no data or
surface components are provided, then the <code><a href="#topic+template_xifti">template_xifti</a></code> will
be returned.
</p>
<p>If cortical data are provided without a corresponding medial wall mask, or
if the provided mask is invalid or empty, then the medial wall will be
inferred from data rows that are constantly a value in <code>mwall_values</code>.
But if <code>mwall_values</code> is <code>NULL</code>, no attempt to infer the medial
wall will be made and the medial wall metadata entry will be <code>NULL</code>.
</p>
<p>The total number of grayordinates will be
<code class="reqn">G = (V_L - mwall_L) + (V_R - mwall_R) + V_S</code>: <code class="reqn">V_L - mwall_L</code> left
vertices, <code class="reqn">V_R - mwall_R</code> right vertices and <code class="reqn">V_S</code> subcortical
voxels. <code class="reqn">T</code>, the total number of measurements (columns of data), must be
the same for each brainstructure.
</p>


<h3>Value</h3>

<p>A <code>"xifti"</code>
</p>


<h3>See Also</h3>

<p>Other reading: 
<code><a href="#topic+info_cifti">info_cifti</a>()</code>,
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+read_xifti2">read_xifti2</a>()</code>
</p>

<hr>
<h2 id='assure_parc'>Assure this is a parcellation</h2><span id='topic+assure_parc'></span>

<h3>Description</h3>

<p>Assure an input <code>"xifti"</code> object represents a parcellation. Keep only
the first column if multiple columns are present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assure_parc(parc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assure_parc_+3A_parc">parc</code></td>
<td>
<p>The putative parcellation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parc</code>, if it's a parcellation.
</p>

<hr>
<h2 id='boundary_mask_surf'>Boundary region of a mask</h2><span id='topic+boundary_mask_surf'></span>

<h3>Description</h3>

<p>Identify the vertices within <code>boundary_width</code> edges of a vertex in the
input mask on a triangular mesh. Returns a logical indicating if a vertex
is within <code>boundary_width</code> edges of the mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundary_mask_surf(faces, mask, boundary_width = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundary_mask_surf_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
<tr><td><code id="boundary_mask_surf_+3A_mask">mask</code></td>
<td>
<p>A length <code class="reqn">V</code> logical vector indicating if each vertex is
within the input mask.</p>
</td></tr>
<tr><td><code id="boundary_mask_surf_+3A_boundary_width">boundary_width</code></td>
<td>
<p>A positive integer representing the width of the
boundary to compute. The furthest vertices from the input mask will be this
number of edges away from the closest vertex in the input mask. Default:
<code>10</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-V logical vector. Each entry corresponds to the vertex
with the same index. The value is true if a vertex is within
<code>boundary_width</code> edges of a vertex in the mesh, but is not within the
mesh itself.
</p>


<h3>See Also</h3>

<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='brainstructures_Param_all'>brainstructures</h2><span id='topic+brainstructures_Param_all'></span>

<h3>Description</h3>

<p>brainstructures
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="brainstructures_Param_all_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
to obtain: <code>"left"</code> (left cortex), <code>"right"</code> (right cortex)
and/or <code>"subcortical"</code> (subcortex and cerebellum). Can also be
<code>"all"</code> (obtain all three brain structures). Default: <code>"all"</code>.
</p>
<p>If a brain structure is indicated but is not included, a warning will be
raised and that brain structure will be skipped.</p>
</td></tr>
</table>

<hr>
<h2 id='brainstructures_Param_LR'>brainstructures</h2><span id='topic+brainstructures_Param_LR'></span>

<h3>Description</h3>

<p>brainstructures
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="brainstructures_Param_LR_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
to obtain: <code>"left"</code> (left cortex), <code>"right"</code> (right cortex)
and/or <code>"subcortical"</code> (subcortex and cerebellum). Can also be
<code>"all"</code> (obtain all three brain structures). Default:
<code>c("left","right")</code> (cortex only).
</p>
<p>If a brain structure is indicated but does not exist in the CIFTI file, a
warning will occur and that brain structure will be skipped.</p>
</td></tr>
</table>

<hr>
<h2 id='check_cifti_type'>Check CIFTI type</h2><span id='topic+check_cifti_type'></span>

<h3>Description</h3>

<p>Check that a CIFTI's NIFTI intent matches its file name extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cifti_type(intent, extn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_cifti_type_+3A_intent">intent</code></td>
<td>
<p>The NIFTI <code>intent_code</code>, as a numeric integer</p>
</td></tr>
<tr><td><code id="check_cifti_type_+3A_extn">extn</code></td>
<td>
<p>The file name extension, e.g. &quot;dtseries.nii&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the intent is supported, returns <code>TRUE</code>.
If the intent is not supported, an error is raised.
</p>

<hr>
<h2 id='cifti_component_suffix'>Get CIFTI component suffix default</h2><span id='topic+cifti_component_suffix'></span>

<h3>Description</h3>

<p>Get the default file name suffix for a certain type of GIFTI/NIFTI file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cifti_component_suffix(label, GIFTI_type = "func")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cifti_component_suffix_+3A_label">label</code></td>
<td>
<p>the file type: one of
<code>"cortexL"</code>, <code>"cortexR"</code>,
<code>"subcortVol"</code>, <code>"subcortLabs"</code>,
<code>"ROIcortexL"</code>, <code>"ROIcortexR"</code>,
<code>"ROIsubcortVol"</code>,
<code>"validROIcortexL"</code>, or <code>"validROIcortexR"</code>.</p>
</td></tr>
<tr><td><code id="cifti_component_suffix_+3A_gifti_type">GIFTI_type</code></td>
<td>
<p>Used to make the suffix. Default: <code>"func"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The default file name suffix
</p>

<hr>
<h2 id='cifti_fname_Param'>cifti_fname</h2><span id='topic+cifti_fname_Param'></span>

<h3>Description</h3>

<p>cifti_fname
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cifti_fname_Param_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
</table>

<hr>
<h2 id='ciftiTools_msg'>Print suppressible message</h2><span id='topic+ciftiTools_msg'></span>

<h3>Description</h3>

<p>Print message only if ciftiTools Option &quot;suppress_msgs&quot; is <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciftiTools_msg(msg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ciftiTools_msg_+3A_msg">msg</code></td>
<td>
<p>The message</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='ciftiTools_warn'>Print suppressible warning</h2><span id='topic+ciftiTools_warn'></span>

<h3>Description</h3>

<p>Print warning only if ciftiTools Option &quot;suppress_msgs&quot; is <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciftiTools_warn(warn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ciftiTools_warn_+3A_warn">warn</code></td>
<td>
<p>The warning message</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='ciftiTools.checkOption'>Validate a <code>ciftiTools</code> option and value</h2><span id='topic+ciftiTools.checkOption'></span>

<h3>Description</h3>

<p>Checks if a ciftiTools option and value are valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciftiTools.checkOption(opt, val = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ciftiTools.checkOption_+3A_opt">opt</code></td>
<td>
<p>The option.</p>
</td></tr>
<tr><td><code id="ciftiTools.checkOption_+3A_val">val</code></td>
<td>
<p>The value to set the option as.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (corrected) <code>val</code>
</p>

<hr>
<h2 id='ciftiTools.files'><code>ciftiTools</code> files</h2><span id='topic+ciftiTools.files'></span>

<h3>Description</h3>

<p>CIFTI and surface GIFTI files included in the <code>ciftiTools</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciftiTools.files()
</code></pre>


<h3>Details</h3>

<p>The CIFTI files are from NITRC: cifti-2_test_data-1.2.zip at
https://www.nitrc.org/frs/?group_id=454
</p>
<p>The surfaces are from the HCP and are included according to these data use
terms: Data were provided [in part] by the Human Connectome Project,
WU-Minn Consortium (Principal Investigators: David Van Essen and Kamil
Ugurbil; 1U54MH091657) funded by the 16 NIH Institutes and Centers
that support the NIH Blueprint for Neuroscience Research; and by the
McDonnell Center for Systems Neuroscience at Washington University.
</p>
<p>Only the inflated surfaces are available as GIFTI files. To access the other
surfaces included in the package (very inflated and midthickness), see
<code><a href="#topic+load_surf">load_surf</a></code>.
</p>


<h3>Value</h3>

<p>a list of file paths
</p>

<hr>
<h2 id='ciftiTools.getOption'>Get a <code>ciftiTools</code> option</h2><span id='topic+ciftiTools.getOption'></span>

<h3>Description</h3>

<p>Gets an R option (with prefix &quot;ciftiTools_&quot;) value.
See <code><a href="#topic+ciftiTools.listOptions">ciftiTools.listOptions</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciftiTools.getOption(opt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ciftiTools.getOption_+3A_opt">opt</code></td>
<td>
<p>The option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value, <code>val</code>
</p>

<hr>
<h2 id='ciftiTools.listOptions'>List <code>ciftiTools</code> options</h2><span id='topic+ciftiTools.listOptions'></span>

<h3>Description</h3>

<p>List <code>ciftiTools</code> options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciftiTools.listOptions()
</code></pre>


<h3>Value</h3>

<p><code>data.frame</code> describing the options
</p>

<hr>
<h2 id='ciftiTools.setOption'>Set a <code>ciftiTools</code> option</h2><span id='topic+ciftiTools.setOption'></span>

<h3>Description</h3>

<p>Sets an R option (with prefix &quot;ciftiTools_&quot;).
See <code><a href="#topic+ciftiTools.listOptions">ciftiTools.listOptions</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciftiTools.setOption(opt, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ciftiTools.setOption_+3A_opt">opt</code></td>
<td>
<p>The option.</p>
</td></tr>
<tr><td><code id="ciftiTools.setOption_+3A_val">val</code></td>
<td>
<p>The value to set the option as.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new value, <code>val</code>
</p>

<hr>
<h2 id='combine_xifti'>Combine <code>"xifti"</code>s with non-overlapping brain structures</h2><span id='topic+combine_xifti'></span>

<h3>Description</h3>

<p>Combine two to three <code>"xifti"</code>s with non-overlapping brain structures into
a single <code>"xifti"</code>. The names, intent, and surfaces of the first will be used,
if present. To add more surfaces to the result, use <code><a href="#topic+add_surf">add_surf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_xifti(..., xii_list = NULL, meta = c("first", "all"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_xifti_+3A_...">...</code></td>
<td>
<p>The <code>"xifti"</code> objects</p>
</td></tr>
<tr><td><code id="combine_xifti_+3A_xii_list">xii_list</code></td>
<td>
<p>Alternatively, a list of <code>"xifti"</code> objects. If specified,
will ignore <code>...</code></p>
</td></tr>
<tr><td><code id="combine_xifti_+3A_meta">meta</code></td>
<td>
<p><code>"first"</code> (default) to just use the metadata from the first
argument, or <code>"all"</code> to include the other metadata in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"xifti"</code> with data from the inputs
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='confirm_wb_cmd_path'>Confirm the Connectome Workbench command path</h2><span id='topic+confirm_wb_cmd_path'></span>

<h3>Description</h3>

<p>Confirm that the path to the Connectome Workbench executable is valid.
(For example, if the &quot;wb_path&quot; option was relative and the user changed the
current working directory, the path is no longer valid.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confirm_wb_cmd_path(wb_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confirm_wb_cmd_path_+3A_wb_path">wb_path</code></td>
<td>
<p>(Optional) Path to the Connectome Workbench folder or
executable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='convert_to_dlabel'>Convert the intent of a CIFTI file or <code>"xifti"</code> object</h2><span id='topic+convert_to_dlabel'></span><span id='topic+convert_to_dscalar'></span><span id='topic+convert_to_dtseries'></span><span id='topic+convert_xifti'></span>

<h3>Description</h3>

<p>Convert the intent of a CIFTI file or <code>"xifti"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_dlabel(
  x,
  cifti_target_fname = NULL,
  levels_old = NULL,
  levels = NULL,
  labels = NULL,
  nsig = Inf,
  colors = "Set2",
  add_white = TRUE,
  return_conversion_table = FALSE
)

convert_to_dscalar(x, cifti_target_fname = NULL, names = NULL)

convert_to_dtseries(
  x,
  cifti_target_fname = NULL,
  time_start = 0,
  time_step = 1,
  time_unit = c("second", "hertz", "meter", "radian")
)

convert_xifti(
  x,
  to = c("dscalar", "dtseries", "dlabel"),
  cifti_target_fname = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_dlabel_+3A_x">x</code></td>
<td>
<p>The CIFTI file name or <code>"xifti"</code> object to convert.</p>
</td></tr>
<tr><td><code id="convert_to_dlabel_+3A_cifti_target_fname">cifti_target_fname</code></td>
<td>
<p>File name for the converted CIFTI. Only used if
<code>x</code> is a CIFTI file name. If <code>NULL</code> (default), will use the same
name as <code>x</code> but with the extension updated.</p>
</td></tr>
<tr><td><code id="convert_to_dlabel_+3A_levels_old">levels_old</code>, <code id="convert_to_dlabel_+3A_levels">levels</code>, <code id="convert_to_dlabel_+3A_labels">labels</code></td>
<td>
<p>(Optional) <code>levels_old</code> is a vector of
the original data values. They should all be unique. They may not all occur
in the <code>"xifti"</code> data, but every datapoint in the <code>"xifti"</code> must
occur in <code>levels_old</code>. If <code>levels_old</code> is not provided it will be set to
the vector of all unique values in the data, in ascending order.
</p>
<p>If <code>levels</code> is not provided, the original values will be re-mapped
to integers from $0$ to $N-1$ (the &quot;Keys&quot; of a &quot;dlabel&quot; CIFTI), with $N$
being the length of <code>levels_old</code>. Otherwise, <code>levels</code> can be a
vector the same length as <code>levels_old</code> specifying the corresponding new
integers to use (rather than $0$ to $N-1$). If <code>x</code> is already &quot;dlabel&quot;,
then by setting <code>levels_old</code> to the current label table values and
<code>levels</code> to the desired new values, the data can be re-leveled
(see examples in function documentation). Note that duplicates in
<code>levels_old</code> are allowed, to map multiple existing levels to the same
new level.
</p>
<p>New label names can be set with <code>labels</code>. If provided, it must be a
character vector with the same length as <code>levels</code>. If there are
duplicates in <code>levels</code>, the first label for a given level will be used.
If <code>labels</code> is not provided, the new label names will be set to
<code>levels</code> if it was provided, and <code>levels_old</code> if it was not.
</p>
<p>Note: <code>NA</code> and <code>NaN</code> values are handled a bit differently. Data
locations that are <code>NA</code> or <code>NaN</code> will remain unchanged. <code>NA</code>
and <code>NaN</code> should not be included in <code>levels_old</code> or <code>levels</code>.</p>
</td></tr>
<tr><td><code id="convert_to_dlabel_+3A_nsig">nsig</code></td>
<td>
<p>Take this many significant digits for the data values. If
<code>Inf</code> (default), do not round.</p>
</td></tr>
<tr><td><code id="convert_to_dlabel_+3A_colors">colors</code></td>
<td>
<p>(Optional) &quot;ROY_BIG_BL&quot;, the name of a ColorBrewer palette
(see <code>RColorBrewer::brewer.pal.info</code> and colorbrewer2.org), the name of
a viridisLite palette, or a character vector of colors. Default:
<code>"Set2"</code>.</p>
</td></tr>
<tr><td><code id="convert_to_dlabel_+3A_add_white">add_white</code></td>
<td>
<p>Append white to the beginning of the colors? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="convert_to_dlabel_+3A_return_conversion_table">return_conversion_table</code></td>
<td>
<p>Return the conversion table along with the
converted <code>"xifti"</code>? Default: <code>FALSE</code>. It will give the original
<code>values</code>, the <code>values_new</code> (i.e. the &quot;Keys&quot;), and the new
<code>label</code> names.</p>
</td></tr>
<tr><td><code id="convert_to_dlabel_+3A_names">names</code></td>
<td>
<p>The column names. If <code>NULL</code> (default), will be set to
&quot;Column 1&quot;, &quot;Column 2&quot;, ... .</p>
</td></tr>
<tr><td><code id="convert_to_dlabel_+3A_time_start">time_start</code>, <code id="convert_to_dlabel_+3A_time_step">time_step</code>, <code id="convert_to_dlabel_+3A_time_unit">time_unit</code></td>
<td>
<p>(Optional) metadata for the new dtseries</p>
</td></tr>
<tr><td><code id="convert_to_dlabel_+3A_to">to</code></td>
<td>
<p>The desired intent: <code>"dscalar"</code> (default), <code>"dtseries"</code>,
or <code>"dlabel"</code></p>
</td></tr>
<tr><td><code id="convert_to_dlabel_+3A_...">...</code></td>
<td>
<p>Only used if <code>x</code> is a <code>"xifti"</code> object. Additional
options specific to the target type and intent, e.g. for
<code>convert_to_dlabel</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a CIFTI, the target is a <code>"dlabel"</code> and
<code>return_conversion_table</code>, a length-2 list with the first entry being
the &quot;.dlabel&quot; <code>"xifti"</code> and the second being the conversion table.
Otherwise, the <code>"xifti"</code> or the output CIFTI file name is directly
returned.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>convert_to_dlabel()</code>: Give the &quot;.dlabel&quot; intent (code 3007/ConnDenseLabel) to an input
<code>"xifti"</code>. Will use the same label table for each data column. Can also
be used to re-assign values in the label table, or to change label names.
</p>
</li>
<li> <p><code>convert_to_dscalar()</code>: Give the &quot;.dscalar&quot; intent (code 3006/ConnDenseScalar) to an input
CIFTI file or <code>"xifti"</code> object. Can also be used to set the names for
each column with <code>names</code>.
</p>
</li>
<li> <p><code>convert_to_dtseries()</code>: Give the &quot;.dtseries&quot; intent (code 3002/ConnDenseSeries) to an input
<code>"xifti"</code> object. Can also be used to set the time metadata.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example: change label names
levels_old &lt;- xii$meta$cifti$labels[[1]]$Key
newLabels &lt;- paste0("New Label #", seq(length(levels_old)))
xii &lt;- convert_to_dlabel(xii, levels_old=levels_old, levels=levels_old, labels=newLabels)
# Example: add an empty level
levels_old &lt;- xii$meta$cifti$labels[[1]]$Key
levels_old &lt;- c(levels_old, max(levels_old)+1)
labels &lt;- c(rownames(xii$meta$cifti$labels[[1]]), "Empty")
xii &lt;- convert_to_dlabel(xii, levels_old=levels_old, levels=levels_old, labels=labels)
# Example: set all but the lowest value to the same value &amp; re-label
levels_old &lt;- xii$meta$cifti$labels[[1]]$Key
levels &lt;- ifelse(levels_old==min(levels_old), min(levels_old), min(levels_old)+1)
labels &lt;- ifelse(levels_old==min(levels_old), "Minimum", "Not minimum")
xii &lt;- convert_to_dlabel(xii, levels_old=levels_old, levels=levels, labels=labels)

## End(Not run)

</code></pre>

<hr>
<h2 id='coordlist_to_vol'>Convert coordinate list to volume</h2><span id='topic+coordlist_to_vol'></span>

<h3>Description</h3>

<p>Converts a sparse coordinate list to its non-sparse volumetric representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordlist_to_vol(coords, fill = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordlist_to_vol_+3A_coords">coords</code></td>
<td>
<p>The sparse coordinate list. Should be a data.frame or matrix
with voxels along the rows and three or four columns. The first three
columns should be integers indicating the spatial coordinates of the voxel.
If the fourth column is present, it will be the value used for that voxel.
If it is absent, the value will be <code>TRUE</code> or <code>1</code> if <code>fill</code>
is not those values, and <code>FALSE</code> or <code>0</code> if <code>fill</code> is. The
data type will be the same as that of <code>fill</code>.
<code>fill</code>. The fourth column must be logical or numeric.</p>
</td></tr>
<tr><td><code id="coordlist_to_vol_+3A_fill">fill</code></td>
<td>
<p>Fill value for the volume. Must be logical or numeric. Default:
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The volumetric data
</p>

<hr>
<h2 id='crop_image'>Crop image</h2><span id='topic+crop_image'></span>

<h3>Description</h3>

<p>Crop whitespace from image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_image(x, dims = seq(2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_image_+3A_x">x</code></td>
<td>
<p>An image read by <code>png::readPNG</code>, or file path to that</p>
</td></tr>
<tr><td><code id="crop_image_+3A_dims">dims</code></td>
<td>
<p>The dimensions to crop. Default: <code>seq(2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cropped image
</p>

<hr>
<h2 id='crop_vol'>Crop a 3D array</h2><span id='topic+crop_vol'></span>

<h3>Description</h3>

<p>Remove empty (zero-valued) edge slices from a 3D array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_vol(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_vol_+3A_x">x</code></td>
<td>
<p>The 3D array to crop.</p>
</td></tr>
</table>

<hr>
<h2 id='dim.xifti'>Dimensions of a <code>"xifti"</code></h2><span id='topic+dim.xifti'></span>

<h3>Description</h3>

<p>Returns the number of rows (vertices + voxels) and columns (measurements) in
the <code>"xifti"</code> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xifti'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.xifti_+3A_x">x</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of rows and columns in the <code>"xifti"</code> data.
</p>

<hr>
<h2 id='dist_from_mask_surf'>Distance from mask on surface</h2><span id='topic+dist_from_mask_surf'></span>

<h3>Description</h3>

<p>Identify the vertices within <code>boundary_width</code> edges of a vertex in the
input mask on a triangular mesh. Returns the number of edges a vertex is
away from the closest mask vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_from_mask_surf(faces, mask, boundary_width = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_from_mask_surf_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
<tr><td><code id="dist_from_mask_surf_+3A_mask">mask</code></td>
<td>
<p>A length <code class="reqn">V</code> logical vector indicating if each vertex is
within the input mask.</p>
</td></tr>
<tr><td><code id="dist_from_mask_surf_+3A_boundary_width">boundary_width</code></td>
<td>
<p>A positive integer representing the width of the
boundary to compute. The furthest vertices from the input mask will be this
number of edges away from the closest vertex in the input mask. Default:
<code>10</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-V numeric vector. Each entry corresponds to the vertex
with the same index. For vertices within the boundary, the value will be the
number of vertices away from the closest vertex in the input mask.
Vertices inside the input mask but at the edge of it (i.e. the vertices
that define the boundary) will have value 0. Then, all other vertices will
have value -1.
</p>

<hr>
<h2 id='edit_mask_surf'>Edit mask on surface</h2><span id='topic+edit_mask_surf'></span><span id='topic+erode_mask_surf'></span><span id='topic+dilate_mask_surf'></span>

<h3>Description</h3>

<p>Erode, dilate, or get the borders of a mask along the cortical surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edit_mask_surf(
  x,
  mwall = NULL,
  surf = NULL,
  hemisphere = c("left", "right"),
  do = c("erode", "dilate", "borders"),
  depth = 1
)

erode_mask_surf(
  x,
  mwall = NULL,
  surf = NULL,
  hemisphere = c("left", "right"),
  depth = 1
)

dilate_mask_surf(
  x,
  mwall = NULL,
  surf = NULL,
  hemisphere = c("left", "right"),
  depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edit_mask_surf_+3A_x">x</code>, <code id="edit_mask_surf_+3A_mwall">mwall</code></td>
<td>
<p>Vector of the data mask to edit, and the medial wall mask.
These can be specified in two ways. First, <code>mwall</code> can be a logical vector
with each entry corresponding to a vertex as the cortical surface, and
using <code>FALSE</code> values to indicate medial wall vertices. In this first case,
<code>x</code> should then be a logical vector with each entry corresponding to a
<code>TRUE</code> value in <code>mwall</code>. <code>TRUE</code> values in <code>x</code> should
indicate the mask to be edited.
</p>
<p>Second, <code>mwall</code> can be <code>NULL</code> (default) in which case <code>x</code>
should then be a logical vector with each entry corresponding to a vertex
on the cortical surface. <code>TRUE</code> values in <code>x</code> should indicate the
mask to be edited.
</p>
<p>In either case, <code>xii$data$cortex_left[,1]</code> and
<code>xii$meta$cortex$medial_wall_mask$left</code> should work.</p>
</td></tr>
<tr><td><code id="edit_mask_surf_+3A_surf">surf</code>, <code id="edit_mask_surf_+3A_hemisphere">hemisphere</code></td>
<td>
<p>Provide one: the surface in the same resolution as the
data, or the name of the hemisphere of the surface to resample and use
(default: resample the left surface).</p>
</td></tr>
<tr><td><code id="edit_mask_surf_+3A_do">do</code></td>
<td>
<p><code>"erode"</code> (default), <code>"dilate"</code>, or <code>"borders"</code>.
<code>"erode"</code> removes faces with at least one vertex not inside the mask.
<code>"dilate"</code> adds faces with at least one vertex inside the mask.
<code>"borders"</code> obtains the vertices inside the mask which share a face
with at least one vertex not inside the mask.</p>
</td></tr>
<tr><td><code id="edit_mask_surf_+3A_depth">depth</code></td>
<td>
<p>How many iterations of the edit? Default: <code>1</code>. Does not
apply to <code>"borders"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The depth of the edit is determined by the number of edges between the
vertices. To erode or dilate based on spatial distance (mm), see
<code>-cifti-dilate</code> and <code>-cifti-erode</code>.
</p>


<h3>Value</h3>

<p><code>x</code> after erosion or dilation.
</p>


<h3>See Also</h3>

<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='even_vert_samp'>Evenly sample vertices of mesh</h2><span id='topic+even_vert_samp'></span>

<h3>Description</h3>

<p>Get a subset of the mesh vertices that are spatially evenly-sampled, by
resampling the mesh and choosing the original vertices closest (Euclidian
distance) to the new vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>even_vert_samp(surf, n_vert)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="even_vert_samp_+3A_surf">surf</code></td>
<td>
<p>A <code>"surf"</code> object</p>
</td></tr>
<tr><td><code id="even_vert_samp_+3A_n_vert">n_vert</code></td>
<td>
<p>The desired number of vertices in the evenly-spaced sample.
Note that the actual size of the subset will likely be close to but not
exactly <code>n_vert</code> because it depends on the size of the resampled
surface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector giving the indices of the vertices in the subset.
</p>


<h3>See Also</h3>

<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='expand_color_pal'>Interpolates between entries in the input palette to make a larger palette
with COLOR_RES entries.</h2><span id='topic+expand_color_pal'></span>

<h3>Description</h3>

<p>Interpolates between entries in the input palette to make a larger palette
with COLOR_RES entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_color_pal(pal, COLOR_RES = 255)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_color_pal_+3A_pal">pal</code></td>
<td>
<p>The color palette to expand, as a data.frame with two columns:
<code>"color"</code> (character: color hex codes) and <code>"value"</code> (numeric,
ascending).</p>
</td></tr>
<tr><td><code id="expand_color_pal_+3A_color_res">COLOR_RES</code></td>
<td>
<p>The number of entries to have in the output palette.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with two columns: <code>"color"</code> (character: color hex
codes) and <code>"value"</code> (numeric)
</p>


<h3>See Also</h3>

<p>Other coloring: 
<code><a href="#topic+ROY_BIG_BL">ROY_BIG_BL</a>()</code>,
<code><a href="#topic+make_color_pal">make_color_pal</a>()</code>,
<code><a href="#topic+use_color_pal">use_color_pal</a>()</code>
</p>

<hr>
<h2 id='expect_equal_xifti'>Expect these <code>"xifti"</code>s to match</h2><span id='topic+expect_equal_xifti'></span>

<h3>Description</h3>

<p>Raise an error if the <code>"xifti"</code>s do not match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_equal_xifti(xii1, xii2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_equal_xifti_+3A_xii1">xii1</code></td>
<td>
<p>The first <code>"xifti"</code></p>
</td></tr>
<tr><td><code id="expect_equal_xifti_+3A_xii2">xii2</code></td>
<td>
<p>The second <code>"xifti"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cifti$intent</code> is only compared if it
exists for both files. <code>cifti$brainstructures</code> and <code>cifti$misc</code> are not compared.
</p>


<h3>Value</h3>

<p><code>TRUE</code>, invisibly
</p>

<hr>
<h2 id='faces_Param'>faces</h2><span id='topic+faces_Param'></span>

<h3>Description</h3>

<p>faces
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="faces_Param_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
</table>

<hr>
<h2 id='fix_gifti_mwall'>Fix GIFTI medial wall</h2><span id='topic+fix_gifti_mwall'></span>

<h3>Description</h3>

<p>Replace implicit medial wall values (not indicated in ROI, but are in
<code>mwall_values</code>) with explicit medial wall values (indicated in ROI)
in a metric GIFTI file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_gifti_mwall(
  metric_fname,
  fixed_metric_fname,
  ROI_fname,
  fixed_ROI_fname,
  mwall_values = c(NA, NaN)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_gifti_mwall_+3A_metric_fname">metric_fname</code></td>
<td>
<p>File path to the data GIFTI</p>
</td></tr>
<tr><td><code id="fix_gifti_mwall_+3A_fixed_metric_fname">fixed_metric_fname</code></td>
<td>
<p>File path to the revised data GIFTI</p>
</td></tr>
<tr><td><code id="fix_gifti_mwall_+3A_roi_fname">ROI_fname</code></td>
<td>
<p>File path to the ROI GIFTI</p>
</td></tr>
<tr><td><code id="fix_gifti_mwall_+3A_fixed_roi_fname">fixed_ROI_fname</code></td>
<td>
<p>File path to the revised ROI GIFTI</p>
</td></tr>
<tr><td><code id="fix_gifti_mwall_+3A_mwall_values">mwall_values</code></td>
<td>
<p>The values to use to infer the medial wall. Default:
<code>c(NA, NaN)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='fix_xifti'>Fix a <code>"xifti"</code></h2><span id='topic+fix_xifti'></span>

<h3>Description</h3>

<p>Make adjustments to a putative <code>"xifti"</code> so that it is valid. Each
adjustment is reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_xifti(xifti, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="fix_xifti_+3A_verbose">verbose</code></td>
<td>
<p>Report each adjustment? Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Right now it only coerces the data to numeric matrices.
</p>


<h3>Value</h3>

<p>The fixed <code>"xifti"</code>
</p>

<hr>
<h2 id='flatten_xifti'>Flatten a <code>"xifti"</code></h2><span id='topic+flatten_xifti'></span>

<h3>Description</h3>

<p>Concatenates the data in a <code>"xifti"</code> object row-wise to form a single matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_xifti(xifti, medial_wall = NULL, subcort_order = "alphabetical")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="flatten_xifti_+3A_medial_wall">medial_wall</code></td>
<td>
<p>Should vertices for the medial wall be included with the
cortical data? If <code>NULL</code> (default), do not include them. If any other
value, use that value to fill rows corresponding to the medial wall mask.</p>
</td></tr>
<tr><td><code id="flatten_xifti_+3A_subcort_order">subcort_order</code></td>
<td>
<p>&quot;alphabetical&quot; (default) to match the Connectome
Workbench command <code>-cifti-export-dense-mapping</code>, or &quot;spatial&quot; which is
already the ordering used in the <code>"xifti"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If all brain structures are present, and if
<code>is.null(medial_wall)</code> and <code>subcort_order=="alphabetical"</code>
(the default arguments), then the result will be identical to the matrix
obtained with the Connectome Workbench command
<code>-cifti-export-dense-mapping</code>.
</p>


<h3>Value</h3>

<p>The flattened <code>"xifti"</code>, a data matrix
</p>

<hr>
<h2 id='format_path'>Format a path</h2><span id='topic+format_path'></span>

<h3>Description</h3>

<p>Normalize and validate a path (optionally, within a certain directory).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_path(path, dir = NULL, mode = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_path_+3A_path">path</code></td>
<td>
<p>The path to normalize.</p>
</td></tr>
<tr><td><code id="format_path_+3A_dir">dir</code></td>
<td>
<p>(Optional) the directory to append to the beginning of the path.
<code>NULL</code> (default) to not append any directory, leaving <code>path</code>
unchanged.</p>
</td></tr>
<tr><td><code id="format_path_+3A_mode">mode</code></td>
<td>
<p>The mode for <code><a href="base.html#topic+file.access">file.access</a></code> to verify existence,
writing permission, or reading permission. Use NA (default) to not perform
any is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized path, or <code>NULL</code> if the path was <code>NULL</code>.
</p>

<hr>
<h2 id='get_cifti_extn'>Get CIFTI file extension</h2><span id='topic+get_cifti_extn'></span>

<h3>Description</h3>

<p>Get CIFTI file extension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cifti_extn(cifti_fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cifti_extn_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character file extension of CIFTI file, e.g. &quot;dtseries.nii&quot;, &quot;dscalar.nii&quot;
</p>

<hr>
<h2 id='get_data_meta_from_cifti_xml'>Extract data-related metadata from CIFTI</h2><span id='topic+get_data_meta_from_cifti_xml'></span>

<h3>Description</h3>

<p>Extract data-related metadata from CIFTI header XML (second &quot;MatrixIndicesMap&quot; entry)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data_meta_from_cifti_xml(xml, intent = 3000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_meta_from_cifti_xml_+3A_xml">xml</code></td>
<td>
<p>List representing &quot;MatrixIndicesMap&quot; entry XML
(<code>xifti$CIFTI$Matrix[[3]]</code>)</p>
</td></tr>
<tr><td><code id="get_data_meta_from_cifti_xml_+3A_intent">intent</code></td>
<td>
<p>The CIFTI's NIFTI intent code. Not used right now, but might be
used later. Default: <code>3000</code> (NIFTI_INTENT_UNKNOWN)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The metadata, a list
</p>

<hr>
<h2 id='get_intn_meta_from_cifti_xml'>Extract intent-specific metadata from CIFTI</h2><span id='topic+get_intn_meta_from_cifti_xml'></span>

<h3>Description</h3>

<p>Extract intent-specific Metadata from CIFTI header XML (first &quot;MatrixIndicesMap&quot; entry)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_intn_meta_from_cifti_xml(xml, intent = 3000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_intn_meta_from_cifti_xml_+3A_xml">xml</code></td>
<td>
<p>List representing &quot;MatrixIndicesMap&quot; entry XML
(<code>xifti$CIFTI$Matrix[[2]]</code>)</p>
</td></tr>
<tr><td><code id="get_intn_meta_from_cifti_xml_+3A_intent">intent</code></td>
<td>
<p>The CIFTI's NIFTI intent code</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The metadata, a list
</p>

<hr>
<h2 id='get_kwargs'>Get kwargs</h2><span id='topic+get_kwargs'></span>

<h3>Description</h3>

<p>Get the names of the arguments of a function as a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_kwargs(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_kwargs_+3A_fun">fun</code></td>
<td>
<p>The function to get the argument names for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The names of the arguments of <code>fun</code> as a character vector
</p>

<hr>
<h2 id='get_misc_meta_from_cifti_xml'>Extract misc metadata from CIFTI</h2><span id='topic+get_misc_meta_from_cifti_xml'></span>

<h3>Description</h3>

<p>Extract misc metadata from CIFTI header XML (&quot;Metadata&quot; entry)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_misc_meta_from_cifti_xml(xml, intent = 3000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_misc_meta_from_cifti_xml_+3A_xml">xml</code></td>
<td>
<p>List representing &quot;Metadata&quot; entry XML
(<code>xifti$CIFTI$Matrix$MetaData</code>)</p>
</td></tr>
<tr><td><code id="get_misc_meta_from_cifti_xml_+3A_intent">intent</code></td>
<td>
<p>The CIFTI's NIFTI intent code. Not used right now, but may be later.
Default: <code>3000</code> (NIFTI_INTENT_UNKNOWN)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The metadata, a list
</p>

<hr>
<h2 id='get_wb_cmd_path'>Get the Connectome Workbench command path</h2><span id='topic+get_wb_cmd_path'></span>

<h3>Description</h3>

<p>Retrieves the path to the Connectome Workbench executable from a file path
that may point to the executable itself, or to the Workbench folder which
contains it (i.e., &quot;path/to/workbench/bin_linux64/wb_command&quot; or
&quot;path/to/workbench&quot;.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wb_cmd_path(wb_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wb_cmd_path_+3A_wb_path">wb_path</code></td>
<td>
<p>(Optional) Path to the Connectome Workbench folder or
executable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path to the Connectome Workbench executable
</p>

<hr>
<h2 id='header_cifti'>Get NIFTI header (of a CIFTI)</h2><span id='topic+header_cifti'></span>

<h3>Description</h3>

<p>Wrapper for Connectome Workbench command
<code>-nifti-information [fname] -print-header</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>header_cifti(cifti_fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="header_cifti_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The header, as a character vector
</p>

<hr>
<h2 id='idx_Param'>idx</h2><span id='topic+idx_Param'></span>

<h3>Description</h3>

<p>idx
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="idx_Param_+3A_idx">idx</code></td>
<td>
<p>Numeric vector indicating the data indices (columns) to read. If
<code>NULL</code> (default), read in all the data. Must be a subset of the indices
present in the file, or an error will occur.
</p>
<p>For high-resolution CIFTI files, reading in only a subset of the data saves
memory, but will be slower than reading in the entire file due to the
required intermediate steps.</p>
</td></tr>
</table>

<hr>
<h2 id='infer_resolution'>Infer resolution from <code>"xifti"</code> and surfaces</h2><span id='topic+infer_resolution'></span>

<h3>Description</h3>

<p>Infer the numbers of vertices on each cortex of a <code>"xifti"</code> object.
Also supports the result of <code><a href="#topic+info_cifti">info_cifti</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_resolution(xifti, surfL = NULL, surfR = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_resolution_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="infer_resolution_+3A_surfl">surfL</code></td>
<td>
<p>Left surface</p>
</td></tr>
<tr><td><code id="infer_resolution_+3A_surfr">surfR</code></td>
<td>
<p>Right surface</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inferred resolutions for the left and right cortex.
</p>

<hr>
<h2 id='info_cifti'>Get CIFTI metadata</h2><span id='topic+info_cifti'></span><span id='topic+infoCIfTI'></span><span id='topic+infocii'></span>

<h3>Description</h3>

<p>Get CIFTI metadata from the NIFTI header and XML using the Connectome
Workbench command <code>-nifti-information</code>. The information is formatted as
the <code>meta</code> component in a <code>"xifti"</code> object
(see <code><a href="#topic+template_xifti">template_xifti</a></code>), and includes:
</p>

<ol>
<li><p> medial wall masks for the left and right cortex
</p>
</li>
<li><p> the subcortical labels (ordered spatially)
</p>
</li>
<li><p> the subcortical mask
</p>
</li>
<li><p> other NIFTI intent-specific metadata
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>info_cifti(cifti_fname)

infoCIfTI(cifti_fname)

infocii(cifti_fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info_cifti_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional metadata depends on the type of CIFTI file:
</p>

<dl>
<dt>&quot;dtseries&quot;</dt><dd>

<dl>
<dt>time_start:</dt><dd><p>   Start time</p>
</dd>
<dt>time_step:</dt><dd><p>   The TR</p>
</dd>
<dt>time_unit:</dt><dd><p>   Unit of time</p>
</dd>
</dl>

</dd>
<dt>&quot;dscalar&quot;</dt><dd>

<dl>
<dt>names:</dt><dd><p>   Name of each data column</p>
</dd>
</dl>

</dd>
<dt>&quot;dlabels&quot;</dt><dd>

<dl>
<dt>names:</dt><dd><p>(   Names of each data column.)</p>
</dd>
<dt>labels:</dt><dd><p>(   List of <code class="reqn">L \times 5</code> data.frames. Row names are the label names. Column names are Key, Red, Green, Blue, and Alpha. List entry names are the names of each data column.)</p>
</dd>
</dl>

</dd>
</dl>



<h3>Value</h3>

<p>The metadata component of a <code>"xifti"</code> for the input CIFTI file
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-nifti-information"</code> Workbench command.
</p>


<h3>Label Levels</h3>

<p><code>xifti$meta$subcort$labels</code> is a factor with the following levels:
</p>

<ol>
<li><p>Cortex-L
</p>
</li>
<li><p>Cortex-R
</p>
</li>
<li><p>Accumbens-L
</p>
</li>
<li><p>Accumbens-R
</p>
</li>
<li><p>Amygdala-L
</p>
</li>
<li><p>Amygdala-R
</p>
</li>
<li><p>Brain Stem
</p>
</li>
<li><p>Caudate-L
</p>
</li>
<li><p>Caudate-R
</p>
</li>
<li><p>Cerebellum-L
</p>
</li>
<li><p>Cerebellum-R
</p>
</li>
<li><p>Diencephalon-L
</p>
</li>
<li><p>Diencephalon-R
</p>
</li>
<li><p>Hippocampus-L
</p>
</li>
<li><p>Hippocampus-R
</p>
</li>
<li><p>Pallidum-L
</p>
</li>
<li><p>Pallidum-R
</p>
</li>
<li><p>Putamen-L
</p>
</li>
<li><p>Putamen-R
</p>
</li>
<li><p>Thalamus-L
</p>
</li>
<li><p>Thalamus-R
</p>
</li></ol>

<p>These correspond to the same structures as given by
<code>ft_read_cifti</code> in the <code>cifti-matlab</code> MATLAB toolbox. Note that
the first two levels (left and right cortex) are not used.
</p>


<h3>See Also</h3>

<p>Other reading: 
<code><a href="#topic+as.xifti">as.xifti</a>()</code>,
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+read_xifti2">read_xifti2</a>()</code>
</p>

<hr>
<h2 id='is.3D_mask'>Validate a 3d binary mask</h2><span id='topic+is.3D_mask'></span>

<h3>Description</h3>

<p>Check if object is a 3D binary mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.3D_mask(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.3D_mask_+3A_x">x</code></td>
<td>
<p>The putative subcortical mask.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for <code><a href="#topic+is.xifti">is.xifti</a></code>.
</p>
<p>Requirements: the mask must be a boolean 3D array. <code>TRUE</code> should
indicate voxels included in the mask, whereas <code>FALSE</code>
should indicate voxels outside of it.
</p>


<h3>Value</h3>

<p>Logical. Is <code>x</code> a valid subcortical mask?
</p>

<hr>
<h2 id='is.cifti'>Validate a <code>"xifti"</code> object</h2><span id='topic+is.cifti'></span><span id='topic+is_cifti'></span><span id='topic+isCIfTI'></span>

<h3>Description</h3>

<p>Check if object is valid for a <code>"xifti"</code>. This alias for
<code><a href="#topic+is.xifti">is.xifti</a></code> is offered as a convenience, and a message will warn
the user. We recommend using <code><a href="#topic+is.xifti">is.xifti</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cifti(x, messages = TRUE)

is_cifti(x, messages = TRUE)

isCIfTI(x, messages = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.cifti_+3A_x">x</code></td>
<td>
<p>The putative <code>"xifti"</code>.</p>
</td></tr>
<tr><td><code id="is.cifti_+3A_messages">messages</code></td>
<td>
<p>If <code>x</code> is not a <code>"xifti"</code>, print messages
explaining the problem? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requirements: it is a list with the same structure as
<code><a href="#topic+template_xifti">template_xifti</a></code>. The size of each data entry must be
compatible with its corresponding mask (medial wall for the cortex and
volumetric mask for the subcortex). Metadata should be present if and only
if the corresponding data is also present. The surfaces can be present
whether or not the cortex data are present.
</p>
<p>See the &quot;Label Levels&quot; section for the requirements of
<code>xifti$meta$subcort$labels</code>.
</p>


<h3>Value</h3>

<p>Logical. Is <code>x</code> a valid <code>"xifti"</code>?
</p>


<h3>Label Levels</h3>

<p><code>xifti$meta$subcort$labels</code> is a factor with the following levels:
</p>

<ol>
<li><p>Cortex-L
</p>
</li>
<li><p>Cortex-R
</p>
</li>
<li><p>Accumbens-L
</p>
</li>
<li><p>Accumbens-R
</p>
</li>
<li><p>Amygdala-L
</p>
</li>
<li><p>Amygdala-R
</p>
</li>
<li><p>Brain Stem
</p>
</li>
<li><p>Caudate-L
</p>
</li>
<li><p>Caudate-R
</p>
</li>
<li><p>Cerebellum-L
</p>
</li>
<li><p>Cerebellum-R
</p>
</li>
<li><p>Diencephalon-L
</p>
</li>
<li><p>Diencephalon-R
</p>
</li>
<li><p>Hippocampus-L
</p>
</li>
<li><p>Hippocampus-R
</p>
</li>
<li><p>Pallidum-L
</p>
</li>
<li><p>Pallidum-R
</p>
</li>
<li><p>Putamen-L
</p>
</li>
<li><p>Putamen-R
</p>
</li>
<li><p>Thalamus-L
</p>
</li>
<li><p>Thalamus-R
</p>
</li></ol>

<p>These correspond to the same structures as given by
<code>ft_read_cifti</code> in the <code>cifti-matlab</code> MATLAB toolbox. Note that
the first two levels (left and right cortex) are not used.
</p>


<h3>See Also</h3>

<p>Other common: 
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+view_xifti">view_xifti</a>()</code>,
<code><a href="#topic+write_cifti">write_cifti</a>()</code>
</p>

<hr>
<h2 id='is.fname'>Is this an existing file path?</h2><span id='topic+is.fname'></span>

<h3>Description</h3>

<p>Simple check if something is an existing file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fname(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fname_+3A_x">x</code></td>
<td>
<p>The potential file name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. Is <code>x</code> an existing file?
</p>

<hr>
<h2 id='is.nummat'>Validate a numeric matrix</h2><span id='topic+is.nummat'></span>

<h3>Description</h3>

<p>Check if object is a numeric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.nummat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.nummat_+3A_x">x</code></td>
<td>
<p>The putative numeric matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for <code><a href="#topic+is.xifti">is.xifti</a></code>.
</p>


<h3>Value</h3>

<p>Logical. Is <code>x</code> a valid numeric matrix?
</p>

<hr>
<h2 id='is.subcort_labs'>Validate a factor vector of subcortical labels</h2><span id='topic+is.subcort_labs'></span>

<h3>Description</h3>

<p>Check if object is a factor vector of subcortical structures.This is a helper
function for <code><a href="#topic+is.xifti">is.xifti</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.subcort_labs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.subcort_labs_+3A_x">x</code></td>
<td>
<p>The putative factor vector of brain substructures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requirements: see the &quot;Label Levels&quot; section for the expected factor levels.
</p>


<h3>Value</h3>

<p>Logical. Is <code>x</code> a factor vector of subcortical
structures?
</p>


<h3>Label Levels</h3>

<p><code>xifti$meta$subcort$labels</code> is a factor with the following levels:
</p>

<ol>
<li><p>Cortex-L
</p>
</li>
<li><p>Cortex-R
</p>
</li>
<li><p>Accumbens-L
</p>
</li>
<li><p>Accumbens-R
</p>
</li>
<li><p>Amygdala-L
</p>
</li>
<li><p>Amygdala-R
</p>
</li>
<li><p>Brain Stem
</p>
</li>
<li><p>Caudate-L
</p>
</li>
<li><p>Caudate-R
</p>
</li>
<li><p>Cerebellum-L
</p>
</li>
<li><p>Cerebellum-R
</p>
</li>
<li><p>Diencephalon-L
</p>
</li>
<li><p>Diencephalon-R
</p>
</li>
<li><p>Hippocampus-L
</p>
</li>
<li><p>Hippocampus-R
</p>
</li>
<li><p>Pallidum-L
</p>
</li>
<li><p>Pallidum-R
</p>
</li>
<li><p>Putamen-L
</p>
</li>
<li><p>Putamen-R
</p>
</li>
<li><p>Thalamus-L
</p>
</li>
<li><p>Thalamus-R
</p>
</li></ol>

<p>These correspond to the same structures as given by
<code>ft_read_cifti</code> in the <code>cifti-matlab</code> MATLAB toolbox. Note that
the first two levels (left and right cortex) are not used.
</p>

<hr>
<h2 id='is.surf'>Validate a <code>"surf"</code> object (vertices + faces)</h2><span id='topic+is.surf'></span>

<h3>Description</h3>

<p>Check if object is valid for <code>xifti$surf$cortex_left</code> or
<code>xifti$surf$cortex_right</code>, where <code>xifti</code> is a <code>"xifti"</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.surf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.surf_+3A_x">x</code></td>
<td>
<p>The putative <code>"surf"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for <code><a href="#topic+is.xifti">is.xifti</a></code>.
</p>
<p>Requirements: the <code>"surf"</code> must be a list of three components: &quot;vertices&quot;,
&quot;faces&quot;, and &quot;hemisphere&quot;. The first two should each be a numeric matrix
with three columns. The values in &quot;vertices&quot; represent spatial coordinates
whereas the values in &quot;faces&quot; represent vertex indices defining the face.
Thus, values in &quot;faces&quot; should be integers between 1 and the number of
vertices. The last list entry, &quot;hemisphere&quot;, should be &quot;left&quot;, &quot;right&quot;,
or NULL indicating the brain hemisphere which the surface represents.
</p>


<h3>Value</h3>

<p>Logical. Is <code>x</code> a valid <code>"surf"</code>?
</p>


<h3>See Also</h3>

<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='is.xifti'>Validate a <code>"xifti"</code> object.</h2><span id='topic+is.xifti'></span><span id='topic+is_xifti'></span>

<h3>Description</h3>

<p>Check if object is valid for a <code>"xifti"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.xifti(x, messages = TRUE)

is_xifti(x, messages = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.xifti_+3A_x">x</code></td>
<td>
<p>The putative <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="is.xifti_+3A_messages">messages</code></td>
<td>
<p>If <code>x</code> is not a <code>"xifti"</code> object, print messages
explaining the problem? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requirements: it is a list with the same structure as
<code><a href="#topic+template_xifti">template_xifti</a></code>. The size of each data entry must be
compatible with its corresponding mask (medial wall for the cortex and
volumetric mask for the subcortex). Metadata should be present if and only
if the corresponding data is also present. The surfaces can be present
whether or not the cortex data are present.
</p>
<p>See the &quot;Label Levels&quot; section for the requirements of
<code>xifti$meta$subcort$labels</code>.
</p>


<h3>Value</h3>

<p>Logical. Is <code>x</code> a valid <code>"xifti"</code> object?
</p>


<h3>Label Levels</h3>

<p><code>xifti$meta$subcort$labels</code> is a factor with the following levels:
</p>

<ol>
<li><p>Cortex-L
</p>
</li>
<li><p>Cortex-R
</p>
</li>
<li><p>Accumbens-L
</p>
</li>
<li><p>Accumbens-R
</p>
</li>
<li><p>Amygdala-L
</p>
</li>
<li><p>Amygdala-R
</p>
</li>
<li><p>Brain Stem
</p>
</li>
<li><p>Caudate-L
</p>
</li>
<li><p>Caudate-R
</p>
</li>
<li><p>Cerebellum-L
</p>
</li>
<li><p>Cerebellum-R
</p>
</li>
<li><p>Diencephalon-L
</p>
</li>
<li><p>Diencephalon-R
</p>
</li>
<li><p>Hippocampus-L
</p>
</li>
<li><p>Hippocampus-R
</p>
</li>
<li><p>Pallidum-L
</p>
</li>
<li><p>Pallidum-R
</p>
</li>
<li><p>Putamen-L
</p>
</li>
<li><p>Putamen-R
</p>
</li>
<li><p>Thalamus-L
</p>
</li>
<li><p>Thalamus-R
</p>
</li></ol>

<p>These correspond to the same structures as given by
<code>ft_read_cifti</code> in the <code>cifti-matlab</code> MATLAB toolbox. Note that
the first two levels (left and right cortex) are not used.
</p>

<hr>
<h2 id='is.xifti_data'>Validate the &quot;data&quot; component of a <code>"xifti"</code> object</h2><span id='topic+is.xifti_data'></span>

<h3>Description</h3>

<p>Check if object is valid for <code>xifti$data</code>, where <code>xifti</code> is a
<code>"xifti"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.xifti_data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.xifti_data_+3A_x">x</code></td>
<td>
<p>The putative &quot;data&quot; component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for <code><a href="#topic+is.xifti">is.xifti</a></code>.
</p>
<p>Requirements: a list with entries &quot;cortex_left&quot;, &quot;cortex_right&quot;, and
&quot;subcort&quot;. Each must be either <code>NULL</code> or a numeric matrix with
grayordinates along the rows and measurements along the columns.
The cortical matrices should have the same number of rows (vertices), and
all should have the same number of columns (measurements). At least one data
entry should be present.
</p>


<h3>Value</h3>

<p>Logical. Is <code>x</code> a valid &quot;data&quot; component?
</p>

<hr>
<h2 id='is.xifti_meta'>Validate the <code>"meta"</code> component of a <code>"xifti"</code> object</h2><span id='topic+is.xifti_meta'></span>

<h3>Description</h3>

<p>Check if object is valid for <code>xifti$meta</code>, where <code>xifti</code> is a
<code>"xifti"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.xifti_meta(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.xifti_meta_+3A_x">x</code></td>
<td>
<p>The putative <code>"meta"</code> component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for <code><a href="#topic+is.xifti">is.xifti</a></code>.
</p>
<p>Requirements: the structure must match that of the <code>"meta"</code> component
of <code><a href="#topic+template_xifti">template_xifti</a></code>.
</p>


<h3>Value</h3>

<p>Logical. Is <code>x</code> a valid <code>"meta"</code> component?
</p>

<hr>
<h2 id='labels_Description'>labels</h2><span id='topic+labels_Description'></span>

<h3>Description</h3>

<p>labels
</p>


<h3>Label Levels</h3>

<p><code>xifti$meta$subcort$labels</code> is a factor with the following levels:
</p>

<ol>
<li><p>Cortex-L
</p>
</li>
<li><p>Cortex-R
</p>
</li>
<li><p>Accumbens-L
</p>
</li>
<li><p>Accumbens-R
</p>
</li>
<li><p>Amygdala-L
</p>
</li>
<li><p>Amygdala-R
</p>
</li>
<li><p>Brain Stem
</p>
</li>
<li><p>Caudate-L
</p>
</li>
<li><p>Caudate-R
</p>
</li>
<li><p>Cerebellum-L
</p>
</li>
<li><p>Cerebellum-R
</p>
</li>
<li><p>Diencephalon-L
</p>
</li>
<li><p>Diencephalon-R
</p>
</li>
<li><p>Hippocampus-L
</p>
</li>
<li><p>Hippocampus-R
</p>
</li>
<li><p>Pallidum-L
</p>
</li>
<li><p>Pallidum-R
</p>
</li>
<li><p>Putamen-L
</p>
</li>
<li><p>Putamen-R
</p>
</li>
<li><p>Thalamus-L
</p>
</li>
<li><p>Thalamus-R
</p>
</li></ol>

<p>These correspond to the same structures as given by
<code>ft_read_cifti</code> in the <code>cifti-matlab</code> MATLAB toolbox. Note that
the first two levels (left and right cortex) are not used.
</p>

<hr>
<h2 id='load_parc'>Load a parcellation included in <code>ciftiTools</code></h2><span id='topic+load_parc'></span>

<h3>Description</h3>

<p>Load a parcellation included in <code>ciftiTools</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_parc(
  name = c("Schaefer_100", "Schaefer_400", "Schaefer_1000", "Yeo_7", "Yeo_17")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_parc_+3A_name">name</code></td>
<td>
<p>The name of the parcellation to load:
</p>

<dl>
<dt><code>"Schaefer_100"</code>:</dt><dd><p>   (2018) 100 parcels based on the &quot;local-global&quot; approach.</p>
</dd>
<dt><code>"Schaefer_400"</code>:</dt><dd><p>   (2018) 400 parcels based on the &quot;local-global&quot; approach.</p>
</dd>
<dt><code>"Schaefer_1000"</code>:</dt><dd><p>   (2018) 1000 parcels based on the &quot;local-global&quot; approach.</p>
</dd>
<dt><code>"Yeo_7"</code>:</dt><dd><p>   (2011) 7 networks based on fcMRI clustering. Networks are further divided into 51 components.</p>
</dd>
<dt><code>"Yeo_17"</code>:</dt><dd><p>   (2011) 17 networks based on fcMRI clustering. Networks are further divided into 114 components.</p>
</dd>
</dl>

<p><code>NULL</code> (default) will load the first choice, where applicable. This
argument will affect the indices, colors, and names of each parcel, but not
the parcel boundaries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using these parcellations, please cite the corresponding paper(s):
</p>

<ol>
<li><p>Yeo, B. T. T. et al. The organization of the human cerebral cortex estimated by intrinsic functional connectivity. J Neurophysiol 106, 1125-1165 (2011).
</p>
</li>
<li><p>Schaefer, A. et al. Local-Global Parcellation of the Human Cerebral Cortex from Intrinsic Functional Connectivity MRI. Cereb Cortex 28, 3095-3114 (2018).
</p>
</li>
<li><p>Kong, R. et al. Individual-Specific Areal-Level Parcellations Improve Functional Connectivity Prediction of Behavior. Cerebral Cortex (2021+) doi:10.1093/cercor/bhab101.
</p>
</li></ol>

<p>Note that the Schaefer parcels have been matched to networks from Kong (2021+).
</p>


<h3>Value</h3>

<p>The parcellation as a dlabel <code>"xifti"</code> with one column. Each key
represents one unique parcel.
</p>


<h3>See Also</h3>

<p>Other reading: 
<code><a href="#topic+as.xifti">as.xifti</a>()</code>,
<code><a href="#topic+info_cifti">info_cifti</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+read_xifti2">read_xifti2</a>()</code>
</p>
<p>Other parcellation-related: 
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+load_sub_parc">load_sub_parc</a>()</code>,
<code><a href="#topic+parc_add_subcortex">parc_add_subcortex</a>()</code>,
<code><a href="#topic+parc_borders">parc_borders</a>()</code>,
<code><a href="#topic+parc_vals_to_xifti">parc_vals_to_xifti</a>()</code>
</p>

<hr>
<h2 id='load_sub_parc'>Load subcortical parcellation</h2><span id='topic+load_sub_parc'></span>

<h3>Description</h3>

<p>Load the MNI subcortical parcellation included in <code>ciftiTools</code> as a
&quot;dlabel&quot; <code>"xifti"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_sub_parc()
</code></pre>


<h3>Details</h3>

<p>Colors are based on https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/AnatomicalROI/FreeSurferColorLUT
</p>


<h3>Value</h3>

<p>The subcortical parcellation
</p>


<h3>See Also</h3>

<p>Other parcellation-related: 
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+parc_add_subcortex">parc_add_subcortex</a>()</code>,
<code><a href="#topic+parc_borders">parc_borders</a>()</code>,
<code><a href="#topic+parc_vals_to_xifti">parc_vals_to_xifti</a>()</code>
</p>

<hr>
<h2 id='load_surf'>Load a <code>"surf"</code> included in <code>ciftiTools</code></h2><span id='topic+load_surf'></span>

<h3>Description</h3>

<p>Load a <code>"surf"</code> object from one of the three 32k anatomical surfaces
included in <code>ciftiTools</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_surf(
  hemisphere = c("left", "right"),
  name = c("inflated", "very inflated", "midthickness"),
  resamp_res = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_surf_+3A_hemisphere">hemisphere</code></td>
<td>
<p><code>"left"</code> (default) or <code>"right"</code></p>
</td></tr>
<tr><td><code id="load_surf_+3A_name">name</code></td>
<td>
<p>The name of the surface geometry to load: <code>"inflated"</code>
(default), <code>"very inflated"</code>, and <code>"midthickness"</code>.</p>
</td></tr>
<tr><td><code id="load_surf_+3A_resamp_res">resamp_res</code></td>
<td>
<p>The resolution to resample the surfaces to. If <code>NULL</code>
(default) or 32492, do not resample. Note that the barycentric resampling
method, which is recommended for anatomical surfaces, will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The surfaces are from the HCP and are included according to these data use
terms: Data were provided [in part] by the Human Connectome Project,
WU-Minn Consortium (Principal Investigators: David Van Essen and Kamil
Ugurbil; 1U54MH091657) funded by the 16 NIH Institutes and Centers
that support the NIH Blueprint for Neuroscience Research; and by the
McDonnell Center for Systems Neuroscience at Washington University.
</p>


<h3>Value</h3>

<p>The <code>"surf"</code> object
</p>


<h3>See Also</h3>

<p>Other reading: 
<code><a href="#topic+as.xifti">as.xifti</a>()</code>,
<code><a href="#topic+info_cifti">info_cifti</a>()</code>,
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+read_xifti2">read_xifti2</a>()</code>
</p>
<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='make_color_pal'>Make a color palette.</h2><span id='topic+make_color_pal'></span>

<h3>Description</h3>

<p>Control the mapping of values to colors with <code>colors</code>,
<code>color_mode</code>, and <code>zlim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_color_pal(
  colors = NULL,
  color_mode = c("sequential", "qualitative", "diverging"),
  zlim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_color_pal_+3A_colors">colors</code></td>
<td>
<p>(Optional) &quot;ROY_BIG_BL&quot;, the name of a ColorBrewer palette
(see <code>RColorBrewer::brewer.pal.info</code> and colorbrewer2.org), the name of
a viridisLite palette, or a character vector of colors.
<code>NULL</code> (default) will use <code>"ROY_BIG_BL"</code>
if <code>color_mode</code> is <code>"sequential"</code> or <code>"diverging"</code>, and
<code>"Set2"</code> if <code>color_mode</code> is <code>"qualitative"</code>. See the
description for more details.</p>
</td></tr>
<tr><td><code id="make_color_pal_+3A_color_mode">color_mode</code></td>
<td>
<p>(Optional) <code>"sequential"</code>, <code>"qualitative"</code>, or
<code>"diverging"</code>. Default: <code>"sequential"</code>. See the description for
more details.</p>
</td></tr>
<tr><td><code id="make_color_pal_+3A_zlim">zlim</code></td>
<td>
<p>(Optional) Controls the mapping of values to each color in
<code>colors</code>. See the description for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three kinds of arguments for <code>colors</code>: <code>"ROY_BIG_BL"</code>,
the name of a ColorBrewer palette (see <code>RColorBrewer::brewer.pal.info</code>
and colorbrewer2.org), the name of a viridisLite palette, or a character
vector of color names.
</p>
<p>If <code>colors=="ROY_BIG_BL"</code>, the &quot;ROY_BIG_BL&quot; palette will be used. It is
the same palette as the default for the Connectome Workbench application
(https://github.com/Washington-University/workbench/blob/master/src/Files/PaletteFile.cxx).
The midpoint will be colored
black. From the midpoint toward the upper bound, colors will proceed from
black to red to yellow. From the midpoint toward the lower bound, colors
will proceed from black to blue to purple to green to aqua. Here is how each
color mode behaves if <code>colors=="ROY_BIG_BL"</code>:
</p>

<dl>
<dt><code>color_mode=="sequential"</code></dt><dd><p>Only half of the palette will be
used. If <code>zlim</code> is length 2, the higher value will be the maximum and
the lower value will be the minimum. Set <code>zlim[1] &gt; zlim[2]</code> to
reverse the color scale. (Note that the second half, black &ndash;&gt; red &ndash;&gt;
yellow, is used by default. To use the negative half specify
<code>colors=="ROY_BIG_BL_neg"</code> instead. It will also be used automatically
by <code>xifti_read_surface</code> when the data range is negative.)
<code>zlim</code> can also be length 10, in which case each value corresponds to
the position of an individual color in the half palette.
</p>
</dd>
<dt><code>color_mode=="qualitative"</code></dt><dd><p>&quot;ROY_BIG_BL&quot; is not recommended for
qualitative data, so a warning will be issued. Palette colors will be
selected from the landmark &quot;ROY_BIG_BL&quot; colors, with interpolated colors
added if the number of colors in the palette (18) is less than this range.
<code>zlim</code> should be a single number: the number of unique colors to get.
</p>
</dd>
<dt><code>color_mode=="diverging"</code></dt><dd><p>If <code>zlim</code> is length 2 or 3, the
lowest number will be the lower bound and the highest number will
be the upper bound. If <code>zlim</code> is length 3, the middle number will be the
midpoint (black). The lower and upper bounds will be aqua and yellow,
respectively, except if <code>zlim</code> is in descending order, in which case
the color scale will be reversed (lowest is yellow; highest is aqua).
<code>zlim</code> can also be length 19, in which case each value corresponds to
the position of an individual color in the palette.
</p>
</dd>
</dl>

<p>If <code>colors</code> is the name of an RColorBrewer palette (see
<code>RColorBrewer::brewer.pal.info</code>) or viridisLite palette, the colors in
that palette will be used, and the following behavior applies.
If <code>colors</code> is a character vector of color names (hex codes or standard
R color names), the following behavior applies directly:
</p>

<dl>
<dt><code>color_mode=="sequential"</code></dt><dd><p>If <code>zlim</code> is length 2, the
higher value will be the maximum and the lower value will be the minimum.
Set <code>zlim[1] &gt; zlim[2]</code> to reverse the color scale. <code>zlim</code> can
also be the same length as the palette, in which case each value
corresponds to the position of an individual color in the palette.
</p>
</dd>
<dt><code>color_mode=="qualitative"</code></dt><dd><p><code>zlim</code> should be a single
number: the number of unique colors to get. Color interpolation will be
used if the number of colors in the palette is less than this range. If
<code>length(zlim)==length(colors)</code>, each color will be mapped to each
corresponding value.
</p>
</dd>
<dt><code>color_mode=="diverging"</code></dt><dd><p>If <code>zlim</code> is length 2 or 3, the
lowest number will be the lower bound and the highest number will
be the upper bound. If <code>zlim</code> is length 3, the middle number will be the
midpoint. Set <code>zlim</code> in descending order to reverse the color scale.
<code>zlim</code> can also be the same length as the palette, in which case each
value corresponds to the position of an individual color in the palette.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A data.frame with two columns: <code>"color"</code> (character: color hex
codes) and <code>"value"</code> (numeric)
</p>


<h3>See Also</h3>

<p>Other coloring: 
<code><a href="#topic+ROY_BIG_BL">ROY_BIG_BL</a>()</code>,
<code><a href="#topic+expand_color_pal">expand_color_pal</a>()</code>,
<code><a href="#topic+use_color_pal">use_color_pal</a>()</code>
</p>

<hr>
<h2 id='make_cortex'>Make the cortical components of a <code>"xifti"</code></h2><span id='topic+make_cortex'></span>

<h3>Description</h3>

<p>Coerce a path to a GIFTI file, metric or label <code>"gifti"</code> object,
data matrix or vector to a data matrix representing cortical data
(and optionally a corresponding mask).
That is, entries for <code>xifti$data$cortex_\[left/right\]</code> and
<code>xifti$meta$cortex$medial_wall_mask$\[left/right\]</code>. If <code>cortex</code> is
a path to a GIFTI file or a metric <code>"gifti"</code>, any column names or
a non-empty label table will also be extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_cortex(
  cortex,
  mwall = NULL,
  idx = NULL,
  cortex_is_masked = NULL,
  rm_blank_mwall = TRUE,
  rm_bad_mwall = TRUE,
  mwall_values = NULL,
  side = NULL,
  mwall_source = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_cortex_+3A_cortex">cortex</code></td>
<td>
<p>A path to a metric or label GIFTI file, metric or label
<code>"gifti"</code>, or numeric vector/matrix representing cortical data.
</p>
<p>If <code>cortex</code> is a path to a GIFTI file or <code>"gifti"</code>,
the column names and the label table will also be extracted if they
exist in the GIFTI.</p>
</td></tr>
<tr><td><code id="make_cortex_+3A_mwall">mwall</code></td>
<td>
<p>A path to a metric or label GIFTI file, metric or label <code>"gifti"</code>,
<code class="reqn">V_{[L/R]} x 1</code> logical matrix or length <code class="reqn">V_{[L/R]}</code> logical vector
representing the medial wall mask. <code>FALSE</code> values should indicate
vertices that make up the medial wall. If the medial wall is unknown, use
<code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="make_cortex_+3A_idx">idx</code></td>
<td>
<p>Only applies if <code>cortex</code> is a GIFTI file path. This is
a numeric vector indicating the data indices to read. If <code>NULL</code>
(default), read all the data. Must be a subset of the indices present in the
file, or an error will occur.</p>
</td></tr>
<tr><td><code id="make_cortex_+3A_cortex_is_masked">cortex_is_masked</code></td>
<td>
<p>Has the medial wall been masked from <code>cortex</code>
yet? <code>NULL</code> (default) indicates whether it has been masked or not is
unknown.
</p>
<p>If <code>!cortex_is_masked</code>, <code>cortex</code> should be <code class="reqn">V_{[L/R]} x T</code>.
If <code>cortex_is_masked</code>, <code>cortex</code> should be
<code class="reqn">(V_{[L/R]} - mwall_{[L/R]}) x T</code>. If <code>is.null(cortex_is_masked)</code>,
it may be either or.</p>
</td></tr>
<tr><td><code id="make_cortex_+3A_rm_blank_mwall">rm_blank_mwall</code></td>
<td>
<p>If the medial wall mask is all <code>TRUE</code>
(indicating no medial wall vertices), should it be discarded? Default:
<code>TRUE</code>. If <code>FALSE</code>, keep it.</p>
</td></tr>
<tr><td><code id="make_cortex_+3A_rm_bad_mwall">rm_bad_mwall</code></td>
<td>
<p>If the medial wall mask doesn't match up with the
data (e.g. the vertex count doesn't add up), should it be discarded?
Default: <code>TRUE</code>. If <code>FALSE</code>, raise an error.</p>
</td></tr>
<tr><td><code id="make_cortex_+3A_mwall_values">mwall_values</code></td>
<td>
<p>If the medial wall mask was not provided (or if it was
discarded), infer it from rows in <code>cortex</code> that are constantly one of
these values. Example: <code>c(0, NA, NaN)</code>. If <code>NULL</code> (default),
do not attempt to infer the medial wall mask from the data values.</p>
</td></tr>
<tr><td><code id="make_cortex_+3A_side">side</code></td>
<td>
<p><code>"left"</code> or <code>"right"</code>? Just used to print warnings.</p>
</td></tr>
<tr><td><code id="make_cortex_+3A_mwall_source">mwall_source</code></td>
<td>
<p>Description of where the mwall came from. Just used
to print warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components &quot;data&quot;, &quot;mwall&quot;, &quot;col_names&quot; and &quot;labels&quot;.
</p>

<hr>
<h2 id='make_subcort'>Make the subcortical components of a <code>"xifti"</code></h2><span id='topic+make_subcort'></span>

<h3>Description</h3>

<p>Coerce subcortical data into valid entries for <code>xifti$data$subcort</code>
and <code>xifti$meta$subcort</code>. The data arguments can be matrices/arrays or
NIFTI file paths. If the mask is not provided, it will be inferred from the
labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_subcort(vol, labs, mask = NULL, idx = NULL, validate_mask = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_subcort_+3A_vol">vol</code></td>
<td>
<p>represents the data values of the subcortex. It is either a NIFTI
file path, 3D/4D data array (<code class="reqn">i \times j \times k \times T</code>), or a vectorized data
matrix (<code class="reqn">V_S</code> voxels by <code class="reqn">T</code> measurements). If it's vectorized, the voxels
should be in spatial order.</p>
</td></tr>
<tr><td><code id="make_subcort_+3A_labs">labs</code></td>
<td>
<p>represents the brainstructure labels of each voxel: see
<code><a href="#topic+substructure_table">substructure_table</a></code>. It is either a NIFTI file path, a 3D data array
(<code class="reqn">i \times j \times k</code>) of numeric brainstructure indices, or a <code class="reqn">V_S</code> length
vector in spatial order with brainstructure names as factors or integer
indices. The indices should be 3-21 (2 and 3 correspond to left and right
cortex, respectively) or 1-19 (cortex labels omitted), with 0 representing
out-of-mask voxels.</p>
</td></tr>
<tr><td><code id="make_subcort_+3A_mask">mask</code></td>
<td>
<p>is a NIFTI file path or logical 3D data array (<code class="reqn">i \times j \times k</code>) where <code>TRUE</code>
values indicate subcortical voxels (in-mask). If it is not provided, the
mask will be inferred from voxels with labels <code>0</code> or <code>NA</code> in
<code>subcortLabs</code>. If <code>subcortLabs</code> are vectorized and <code>subcortMask</code>
is not provided, the mask cannot be inferred so an error will occur.</p>
</td></tr>
<tr><td><code id="make_subcort_+3A_idx">idx</code></td>
<td>
<p>Only applies if <code>vol</code> is a NIFTI file path. This is a numeric
vector indicating the data indices to read. If <code>NULL</code> (default), read
all the data. Must be a subset of the indices present in the file, or an
error will occur.</p>
</td></tr>
<tr><td><code id="make_subcort_+3A_validate_mask">validate_mask</code></td>
<td>
<p>If <code>mask</code> is provided, set this to <code>TRUE</code> to
check that the mask only removes voxels with <code>NA</code> and <code>0</code> values
in <code>vol</code> and <code>labs</code>. Default: <code>FALSE</code> (saves time).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To read in the labels as the primary data, use the labels NIFTI for both
<code>vol</code> and <code>labs</code>.
</p>


<h3>Value</h3>

<p>A list with components &quot;data&quot;, &quot;labels&quot;, &quot;mask&quot;, and &quot;trans_mat&quot;. The
first two will be vectorized and ordered spatially.
</p>
<p>The volume can be recovered using:
<code>vol &lt;- unvec_vol(data, mask, fill=NA)</code>
<code>labs &lt;- unvec_vol(labels, mask, fill=0)</code>
</p>


<h3>Label Levels</h3>

<p><code>xifti$meta$subcort$labels</code> is a factor with the following levels:
</p>

<ol>
<li><p>Cortex-L
</p>
</li>
<li><p>Cortex-R
</p>
</li>
<li><p>Accumbens-L
</p>
</li>
<li><p>Accumbens-R
</p>
</li>
<li><p>Amygdala-L
</p>
</li>
<li><p>Amygdala-R
</p>
</li>
<li><p>Brain Stem
</p>
</li>
<li><p>Caudate-L
</p>
</li>
<li><p>Caudate-R
</p>
</li>
<li><p>Cerebellum-L
</p>
</li>
<li><p>Cerebellum-R
</p>
</li>
<li><p>Diencephalon-L
</p>
</li>
<li><p>Diencephalon-R
</p>
</li>
<li><p>Hippocampus-L
</p>
</li>
<li><p>Hippocampus-R
</p>
</li>
<li><p>Pallidum-L
</p>
</li>
<li><p>Pallidum-R
</p>
</li>
<li><p>Putamen-L
</p>
</li>
<li><p>Putamen-R
</p>
</li>
<li><p>Thalamus-L
</p>
</li>
<li><p>Thalamus-R
</p>
</li></ol>

<p>These correspond to the same structures as given by
<code>ft_read_cifti</code> in the <code>cifti-matlab</code> MATLAB toolbox. Note that
the first two levels (left and right cortex) are not used.
</p>

<hr>
<h2 id='make_trans_mat'>Make the subcortical transformation matrix</h2><span id='topic+make_trans_mat'></span>

<h3>Description</h3>

<p>Make the transformation matrix for the subcortical volume from the sform
data in the header.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_trans_mat(nii_fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_trans_mat_+3A_nii_fname">nii_fname</code></td>
<td>
<p>Path to NIFTI file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4x4 matrix representing the transformation matrix. (This includes
the last row, <code>c(0,0,0,1)</code>).
</p>

<hr>
<h2 id='make_xifti'>Assemble a <code>"xifti"</code> object</h2><span id='topic+make_xifti'></span>

<h3>Description</h3>

<p>Assembles cortical data, subcortical data, and/or surface geometry to form a
<code>"xifti"</code> object. The inputs can be file paths, GIFTI or NIFTI files
which have been read in, or data objects (vectors, matrices or arrays,
depending on the argument). See <code>as.xifti</code> for a user-function wrapper
that only works with data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_xifti(
  cortexL = NULL,
  cortexL_mwall = NULL,
  cortexR = NULL,
  cortexR_mwall = NULL,
  subcortVol = NULL,
  subcortLabs = NULL,
  subcortMask = NULL,
  mwall_values = c(NA, NaN),
  cifti_info = NULL,
  surfL = NULL,
  surfR = NULL,
  idx = NULL,
  col_names = NULL,
  HCP_32k_auto_mwall = TRUE,
  read_dir = NULL,
  validate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_xifti_+3A_cortexl">cortexL</code>, <code id="make_xifti_+3A_cortexl_mwall">cortexL_mwall</code></td>
<td>
<p>Left cortex data and ROI. Each must be a path to
a GIFTI file, <code>"gifti"</code> object, data matrix or vector. (GIFTI data
should be metric or label, not surface.)
</p>
<p>If <code>cortexL_mwall</code> is not provided, <code>cortexL</code> should have data for
all vertices on the left cortical surface (<code class="reqn">V_L \times T</code> data matrix). There
will not be a mask for the medial wall. Not providing the medial wall mask
is appropriate for &quot;.dlabels.nii&quot; files where the medial wall may have its
own label and therefore should not be treated as missing data.
</p>
<p>If <code>cortexL_mwall</code> is provided, <code>cortexL</code> should either have data
for all vertices on the left cortical surface (<code class="reqn">V_L \times T</code> data matrix, with
filler values e.g. <code>0</code> or <code>NaN</code> for medial wall vertices), or have data
only for non-medial wall vertices (<code class="reqn">(V_L - mwall_L) \times T</code> data matrix).
The medial wall mask will be the <code>0</code> values in <code>cortexL_mwall</code>.
The medial wall mask should be provided whenever the medial wall should be
treated as missing data.
</p>
<p>Since the unmasked cortices must have the same number of vertices,
<code>V_L</code> should match <code>V_R</code>.</p>
</td></tr>
<tr><td><code id="make_xifti_+3A_cortexr">cortexR</code>, <code id="make_xifti_+3A_cortexr_mwall">cortexR_mwall</code></td>
<td>
<p>Right cortex data and ROI. Each must be a path to
a GIFTI file, <code>"gifti"</code> object, data matrix or vector. (GIFTI data
should be metric or label, not surface.)
</p>
<p>If <code>cortexR_mwall</code> is not provided, <code>cortexR</code> should have data for
all vertices on the right cortical surface (<code class="reqn">V_R \times T</code> data mre
will not be a mask for the medial wall. Not providing the medial wall mask
is appropriate for &quot;.dlabels.nii&quot; files where the medial wall may have its
own label and therefore should not be treated as missing data.
</p>
<p>If <code>cortexR_mwall</code> is provided, <code>cortexR</code> should either have data
for all vertices on the right cortical surface (<code class="reqn">V_R \times T</code> data matrix, with
filler values e.g. <code>0</code> or <code>NaN</code> for medial wall vertices), or have data
only for non-medial wall vertices (<code class="reqn">(V_R - mwall_R) \times T</code> data matrix).
The medial wall mask will be the <code>0</code> values in <code>cortexR_mwall</code>.
The medial wall mask should be provided whenever the medial wall should be
treated as missing data.
</p>
<p>Since the unmasked cortices must have the same number of vertices,
<code>V_L</code> should match <code>V_R</code>.</p>
</td></tr>
<tr><td><code id="make_xifti_+3A_subcortvol">subcortVol</code>, <code id="make_xifti_+3A_subcortlabs">subcortLabs</code>, <code id="make_xifti_+3A_subcortmask">subcortMask</code></td>
<td>
<p><code>subcortVol</code> represents the
data values of the subcortex. It is either a NIFTI file path, 3D/4D data array
(<code class="reqn">i \times j \times k \times T</code>), or a vectorized data matrix (<code class="reqn">V_S</code> voxels by <code class="reqn">T</code>
measurements). If it's vectorized, the voxels should be in spatial order
(<code class="reqn">i</code> index increasing fastest, then <code class="reqn">j</code>, then <code class="reqn">k</code>).
</p>
<p><code>subcortLabs</code> represents the brainstructure labels of each voxel: see
<code><a href="#topic+substructure_table">substructure_table</a></code>. It is either a NIFTI file path, 3D data array
(<code class="reqn">i \times j \times k</code>) of integer brainstructure indices, or a <code class="reqn">V_S</code> length
vector in spatial order with brainstructure names as factors or integer
indices. The indices should be 3-21 (1 and 2 correspond to left and right
cortex, respectively) or 1-19 (cortex labels omitted), with 0 representing
out-of-mask voxels.
</p>
<p><code>subcortMask</code> is NIFTI file path or logical 3D data array (<code class="reqn">i \times j \times k</code>)
where <code>TRUE</code> values indicate subcortical voxels (in-mask). If it is not
provided, the mask will be inferred from voxels with labels <code>0</code>,
<code>NA</code>, or <code>NaN</code> in <code>subcortLabs</code>. If <code>subcortLabs</code> are
vectorized and <code>subcortMask</code> is not provided, the mask cannot be
inferred so an error will occur.</p>
</td></tr>
<tr><td><code id="make_xifti_+3A_mwall_values">mwall_values</code></td>
<td>
<p>If <code>cortex[L/R]_mwall</code> was not provided, or if it
was invalid (i.e. bad length or all <code>TRUE</code>), the medial wall mask will
be inferred from rows in <code>cortex[L/R]</code> that are constantly one of these
values. Default: <code>c(NA, NaN)</code>. If <code>NULL</code>, do not attempt to infer
the medial wall from the data values. <code>NULL</code> should be used if <code>NA</code>
or <code>NaN</code> are legitimate values that non-medial wall vertices might
take on.</p>
</td></tr>
<tr><td><code id="make_xifti_+3A_cifti_info">cifti_info</code></td>
<td>
<p>(Optional) The result of <code><a href="#topic+info_cifti">info_cifti</a></code>. If
GIFTI and/or NIFTI components from a CIFTI are being provided,
providing <code>cifti_info</code> gives metadata information that would otherwise
have to be inferred: the NIFTI intent, brainstructures present in the
original file, and miscellaneous metadata.
</p>
<p>This argument is probably not necessary for end users: reading a CIFTI
should be done by providing <code>cifti_fname</code>, and for reading separate
GIFTI/NIFTI components <code>cifti_info</code> is not applicable.
</p>
<p>Column names from <code>cortexL</code> and <code>cortexR</code> take precedence over column
names from <code>cifti_info</code>.</p>
</td></tr>
<tr><td><code id="make_xifti_+3A_surfl">surfL</code>, <code id="make_xifti_+3A_surfr">surfR</code></td>
<td>
<p>(Optional) Surface geometries for the left or right cortex.
Can be a surface GIFTI file path or <code>"surf"</code> object; see
<code><a href="#topic+make_surf">make_surf</a></code> for a full description of valid inputs.</p>
</td></tr>
<tr><td><code id="make_xifti_+3A_idx">idx</code></td>
<td>
<p>For file paths provided to <code>cortexL</code>, <code>cortexR</code>, and
<code>subcortVol</code>: a numeric matrix indicating the data indices to read. If\
<code>NULL</code> (default), read all the data. Must be a subset of the indices
present in the file, or an error will occur. Note that if these arguments
are data matrices instead of file paths, they are unaffected.</p>
</td></tr>
<tr><td><code id="make_xifti_+3A_col_names">col_names</code></td>
<td>
<p>Names of each measurement/column in the data. Overrides
names indicated in <code>cifti_info</code> or in the data components.</p>
</td></tr>
<tr><td><code id="make_xifti_+3A_hcp_32k_auto_mwall">HCP_32k_auto_mwall</code></td>
<td>
<p>If left and/or right cortex data is provided, and
the number of vertices matches that of the HCP 32k mesh (29696 on left, and
29716 on right), should the medial wall masks be added to the <code>"xifti"</code>
if not provided? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="make_xifti_+3A_read_dir">read_dir</code></td>
<td>
<p>(Optional) Append a directory to all file names in the
arguments. If <code>NULL</code> (default), do not modify file names.</p>
</td></tr>
<tr><td><code id="make_xifti_+3A_validate">validate</code></td>
<td>
<p>Validate that the result is a <code>"xifti"</code> object? Default:
<code>TRUE</code>. If <code>FALSE</code>, the result may not be properly formatted
if the inputs were invalid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each data or surface component is optional. Metadata components
(<code>cortex[L/R]_mwall</code>, <code>subcortLabs</code>, and <code>subcortMask</code>) will
be ignored if its corresponding data component is not provided. If no data or
surface components are provided, then the <code><a href="#topic+template_xifti">template_xifti</a></code> will
be returned.
</p>
<p>If cortical data are provided without a corresponding medial wall mask, or
if the provided mask is invalid or empty, then the medial wall will be
inferred from data rows that are constantly a value in <code>mwall_values</code>.
But if <code>mwall_values</code> is <code>NULL</code>, no attempt to infer the medial
wall will be made and the medial wall metadata entry will be <code>NULL</code>.
</p>
<p>The total number of grayordinates will be
<code class="reqn">G = (V_L - mwall_L) + (V_R - mwall_R) + V_S</code>: <code class="reqn">V_L - mwall_L</code> left
vertices, <code class="reqn">V_R - mwall_R</code> right vertices and <code class="reqn">V_S</code> subcortical
voxels. <code class="reqn">T</code>, the total number of measurements (columns of data), must be
the same for each brainstructure.
</p>


<h3>Value</h3>

<p>A <code>"xifti"</code> object; see <code><a href="#topic+template_xifti">template_xifti</a></code>
</p>


<h3>Label Levels</h3>

<p><code>xifti$meta$subcort$labels</code> is a factor with the following levels:
</p>

<ol>
<li><p>Cortex-L
</p>
</li>
<li><p>Cortex-R
</p>
</li>
<li><p>Accumbens-L
</p>
</li>
<li><p>Accumbens-R
</p>
</li>
<li><p>Amygdala-L
</p>
</li>
<li><p>Amygdala-R
</p>
</li>
<li><p>Brain Stem
</p>
</li>
<li><p>Caudate-L
</p>
</li>
<li><p>Caudate-R
</p>
</li>
<li><p>Cerebellum-L
</p>
</li>
<li><p>Cerebellum-R
</p>
</li>
<li><p>Diencephalon-L
</p>
</li>
<li><p>Diencephalon-R
</p>
</li>
<li><p>Hippocampus-L
</p>
</li>
<li><p>Hippocampus-R
</p>
</li>
<li><p>Pallidum-L
</p>
</li>
<li><p>Pallidum-R
</p>
</li>
<li><p>Putamen-L
</p>
</li>
<li><p>Putamen-R
</p>
</li>
<li><p>Thalamus-L
</p>
</li>
<li><p>Thalamus-R
</p>
</li></ol>

<p>These correspond to the same structures as given by
<code>ft_read_cifti</code> in the <code>cifti-matlab</code> MATLAB toolbox. Note that
the first two levels (left and right cortex) are not used.
</p>

<hr>
<h2 id='mask_Param_vertices'>mask: vertices</h2><span id='topic+mask_Param_vertices'></span>

<h3>Description</h3>

<p>mask: vertices
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_Param_vertices_+3A_mask">mask</code></td>
<td>
<p>A length <code class="reqn">V</code> logical vector indicating if each vertex is
within the input mask.</p>
</td></tr>
</table>

<hr>
<h2 id='mask_surf'>Mask surface</h2><span id='topic+mask_surf'></span>

<h3>Description</h3>

<p>Mask a surface mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_surf(surf, mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_surf_+3A_surf">surf</code></td>
<td>
<p>A <code>"surf"</code> object</p>
</td></tr>
<tr><td><code id="mask_surf_+3A_mask">mask</code></td>
<td>
<p>A length <code class="reqn">V</code> logical vector indicating if each vertex is
within the input mask.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apply a binary mask to a <code>"surf"</code> object (list of vertices and
corresponding faces). Vertices not in the mask are removed, and faces
(triangles) with any vertices not in the mask are removed. Finally,
vertex numbering for the new faces matrix is corrected.
</p>


<h3>Value</h3>

<p>The masked <code>"surf"</code> object.
</p>


<h3>See Also</h3>

<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='mask_with_boundary_surf'>Apply Mask With Boundary To Mesh</h2><span id='topic+mask_with_boundary_surf'></span>

<h3>Description</h3>

<p>Make a boundary around a mask with two levels of decimation, and apply to a mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_with_boundary_surf(
  vertices,
  faces,
  mask,
  width1 = 4,
  k1 = 2,
  width2 = 6,
  k2 = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_with_boundary_surf_+3A_vertices">vertices</code></td>
<td>
<p>A <code class="reqn">V \times 3</code> matrix, where each row contains the Euclidean
coordinates at which a given vertex in the mesh is located. <code class="reqn">V</code> is the
number of vertices in the mesh</p>
</td></tr>
<tr><td><code id="mask_with_boundary_surf_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
<tr><td><code id="mask_with_boundary_surf_+3A_mask">mask</code></td>
<td>
<p>A length <code class="reqn">V</code> logical vector indicating if each vertex is
within the input mask.</p>
</td></tr>
<tr><td><code id="mask_with_boundary_surf_+3A_width1">width1</code>, <code id="mask_with_boundary_surf_+3A_width2">width2</code></td>
<td>
<p>the width of the middle/outer region. All vertices in the middle/outer region
are between 1 and <code>width1</code> edges away from the closest vertex in <code>mask</code>/middle region.</p>
</td></tr>
<tr><td><code id="mask_with_boundary_surf_+3A_k1">k1</code>, <code id="mask_with_boundary_surf_+3A_k2">k2</code></td>
<td>
<p>roughly, the triangle size multiplier. Every <code>k1</code>/<code>k2</code> vertex within
every <code>k1</code>/<code>k2</code> layer (beginning with the innermost layer) will be retained;
the rest will be discarded. If the mesh originally has triangles of regular
size, the sides of the triangles in the middle/outer region will be about
<code>k1</code>/<code>k2</code> as long.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The boundary consists of a <code>width1</code>-vertex-wide middle region and a
<code>width2</code>-vertex-wide outer region, for a total of <code>width1 + width2</code> layers
of vertices surrounding the input mask. In the first layer, every <code>k1</code>
vertex within every <code>k1</code> layer (beginning with the innermost
layer) is retained; the rest are discarded. In the second layer, every
<code>k2</code> vertex within every <code>k2</code> layer (beginning with the innermost
layer) is retained; the rest are discarded. It is recommended to make <code>width1</code>
a multiple of <code>k1</code> and <code>width2</code> a multiple of <code>k2</code>.
</p>
<p>Default boundary: a 4-vertex wide middle region with triangles twice as long,
and a 6-vertex wide outer region with triangles three times as long.
</p>


<h3>Value</h3>

<p>A new mesh (list with components vertices and faces)
</p>

<hr>
<h2 id='match_exactly'>Do these character vectors match exactly?</h2><span id='topic+match_exactly'></span>

<h3>Description</h3>

<p>Checks if a user-defined character vector matches an expected character
vector. That is, they share the same lengths and entries in the same order.
For vectors of the same lengths, the result is <code>all(a == b)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_exactly(
  user,
  expected,
  fail_action = c("message", "warning", "stop", "nothing")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_exactly_+3A_user">user</code></td>
<td>
<p>Character vector of user input.</p>
</td></tr>
<tr><td><code id="match_exactly_+3A_expected">expected</code></td>
<td>
<p>Character vector of expected/allowed values.</p>
</td></tr>
<tr><td><code id="match_exactly_+3A_fail_action">fail_action</code></td>
<td>
<p>If any value in <code>user</code> could not be
matched, or repeated matches occurred, what should happen? Possible values
are <code>"message"</code> (default), <code>"warning"</code>, <code>"stop"</code>, and
<code>"nothing"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attributes are ignored.
</p>


<h3>Value</h3>

<p>Logical. Do <code>user</code> and <code>expected</code> match?
</p>

<hr>
<h2 id='match_input'>Match user inputs to expected values</h2><span id='topic+match_input'></span>

<h3>Description</h3>

<p>Match each user input to an expected/allowed value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_input(
  user,
  expected,
  fail_action = c("stop", "warning", "message", "nothing"),
  user_value_label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_input_+3A_user">user</code></td>
<td>
<p>Character vector of user input. These will be matched to
<code>expected</code> using <code>match.arg()</code>.</p>
</td></tr>
<tr><td><code id="match_input_+3A_expected">expected</code></td>
<td>
<p>Character vector of expected/allowed values.</p>
</td></tr>
<tr><td><code id="match_input_+3A_fail_action">fail_action</code></td>
<td>
<p>If any value in <code>user</code> could not be
matched, or repeated matches occurred, what should happen? Possible values
are <code>"stop"</code> (default; raises an error), <code>"warning"</code>, and
<code>"nothing"</code>.</p>
</td></tr>
<tr><td><code id="match_input_+3A_user_value_label">user_value_label</code></td>
<td>
<p>How to refer to the user input in a stop or warning
message. If <code>NULL</code>, no label is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Raise a warning if either
several user inputs match the same expected value, or at least one could not
be matched to any expected value. <code>ciftiTools</code> uses this function to
match keyword arguments for a function call. Another use is to match
brainstructure labels (&quot;left&quot;, &quot;right&quot;, or &quot;subcortical&quot;).
</p>


<h3>Value</h3>

<p>The matched user inputs
</p>

<hr>
<h2 id='merge_kwargs'>Merges two kwargs</h2><span id='topic+merge_kwargs'></span>

<h3>Description</h3>

<p>Merge two kwarg lists. If a kwarg is present in both lists but with different
values, an error is raised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_kwargs(
  kwargsA,
  kwargsB,
  labelA = "first kwarg(s)",
  labelB = "second kwarg(s)",
  extraMsg = "[DEFAULT]"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_kwargs_+3A_kwargsa">kwargsA</code></td>
<td>
<p>The first list of kwargs.</p>
</td></tr>
<tr><td><code id="merge_kwargs_+3A_kwargsb">kwargsB</code></td>
<td>
<p>The second list of kwargs. If duplicates are present, the default
message recommends the user to remove the kwarg here in favor of placing the
correct one in <code>kwargsA</code>.</p>
</td></tr>
<tr><td><code id="merge_kwargs_+3A_labela">labelA</code></td>
<td>
<p>(Optional) Descriptor of <code>kwargsA</code> for error statement. Default &quot;first kwarg(s)&quot;.</p>
</td></tr>
<tr><td><code id="merge_kwargs_+3A_labelb">labelB</code></td>
<td>
<p>(Optional) Descriptor of <code>kwargsB</code> for error statement. Default &quot;second kwarg(s)&quot;.</p>
</td></tr>
<tr><td><code id="merge_kwargs_+3A_extramsg">extraMsg</code></td>
<td>
<p>(Optional) Extra text for error statement. &quot;[DEFAULT]&quot; (default) will use this message:
&quot;Note that a kwarg only has to be provided to one of these. Place the correct value in the first
location and remove the kwarg from the second location&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the union of <code>kwargsA</code> and <code>kwargsB</code>
</p>

<hr>
<h2 id='merge_xifti'>Concatenate <code>"xifti"</code>s</h2><span id='topic+merge_xifti'></span>

<h3>Description</h3>

<p>Concatenate <code>"xifti"</code> objects along the columns. They must have the same
brainstructures and resolutions. The first <code>"xifti"</code>'s metadata will be
retained, including its intent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_xifti(..., xifti_list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_xifti_+3A_...">...</code>, <code id="merge_xifti_+3A_xifti_list">xifti_list</code></td>
<td>
<p>Provide as arguments the <code>"xifti"</code>s to
concatenate, OR the single argument <code>xifti_list</code> which should be a
list of <code>"xifti"</code>s. (If <code>xifti_list</code> is provided all other
inputs will be ignored.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The concatenated <code>"xifti"</code>
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='move_from_mwall'>Move data locations from medial wall</h2><span id='topic+move_from_mwall'></span>

<h3>Description</h3>

<p>Move all medial wall locations into the cortical data matrices by assigning
them a specific value (e.g. NA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move_from_mwall(xifti, value = NA, name = "Medial_Wall", RGBA = c(1, 1, 1, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move_from_mwall_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="move_from_mwall_+3A_value">value</code></td>
<td>
<p>The value to assign the medial wall locations. Default: <code>NA</code>.</p>
</td></tr>
<tr><td><code id="move_from_mwall_+3A_name">name</code>, <code id="move_from_mwall_+3A_rgba">RGBA</code></td>
<td>
<p>Only used if the <code>"xifti"</code> has the dlabel intent and
<code>value</code> is not an already-existing Key. This is the name to assign to
the new key for the medial wall locations, as well as a length-four numeric
vector indicating the red, green, blue, and alpha values for the color to
assign to the new key. These will be reflected in the updated label table.
Note that RGBA values must all be in [0, 1].
</p>
<p>Currently, only one name and set of RGBA values are supported, meaning that
the medial wall locations will have the same Key, name, and color across
all data columns in the <code>"xifti"</code>. An error will occur if the Key
already exists for some columns but not others.
</p>
<p>Defaults: <code>"Medial_Wall"</code> for <code>"name"</code> and white with 0 alpha for
<code>RGBA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>"xifti"</code> with re-organized data and medial wall masks
</p>


<h3>See Also</h3>

<p>move_to_mwall
</p>
<p>unmask_cortex
</p>

<hr>
<h2 id='move_to_mwall'>Move data locations to the medial wall</h2><span id='topic+move_to_mwall'></span>

<h3>Description</h3>

<p>Move cortical data locations with a specific value(s) to the medial wall mask.
For example, dlabel CIFTIs often have medial wall vertices set to a specific
key value, rather than a medial wall mask. This function can move those data
locations from the data matrix to the medial wall mask in the metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move_to_mwall(xifti, values = c(NA, NaN), drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move_to_mwall_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="move_to_mwall_+3A_values">values</code></td>
<td>
<p>Medial wall values. Default: <code>NA</code> and <code>NaN</code>. Data
locations in the left and right cortex that are one of these values (across
all columns) will be moved to the medial wall mask in the metadata.</p>
</td></tr>
<tr><td><code id="move_to_mwall_+3A_drop">drop</code></td>
<td>
<p>Only used if the <code>"xifti"</code> has the dlabel intent. Drop the
key(s) in <code>values</code> from the label tables, for columns in which they no
longer exist? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>"xifti"</code> with re-organized data and medial wall masks
</p>


<h3>See Also</h3>

<p>move_from_mwall
</p>
<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='ncol_xifti'>Counts the number of columns in a <code>"xifti"</code>.</h2><span id='topic+ncol_xifti'></span>

<h3>Description</h3>

<p>Counts the number of columns in the <code>"xifti"</code> data. Doesn't bother
to validate the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncol_xifti(xifti)
</code></pre>


<h3>Value</h3>

<p>The number of columns in the <code>"xifti"</code> data.
</p>

<hr>
<h2 id='newdata_xifti'>Replace the data in a <code>"xifti"</code></h2><span id='topic+newdata_xifti'></span>

<h3>Description</h3>

<p>Replace the data in a <code>"xifti"</code> with new data from a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newdata_xifti(xifti, newdata, newnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newdata_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="newdata_xifti_+3A_newdata">newdata</code></td>
<td>
<p>The <code class="reqn">V \times T</code> matrix of data values to replace those
in <code>xifti</code> with. The left cortex vertices should be at the top, right
cortex vertices in the middle, and subcortex vertices at the bottom (when
present).
</p>
<p>If <code>newdata</code> is instead a <code class="reqn">V \times Q</code> matrix where <code class="reqn">Q</code> is not
<code class="reqn">T</code>, then any column names or label tables will be removed.
(A &quot;dlabel&quot; will be converted to a &quot;dscalar&quot;.)
</p>
<p>Can also be a length-one vector to set all values equally.</p>
</td></tr>
<tr><td><code id="newdata_xifti_+3A_newnames">newnames</code></td>
<td>
<p>Replaces the names in the <code>xifti</code>. If <code>NULL</code>
(default), keep the original names, except if the number of columns
in <code>newdata</code> doesn't match that of <code>xifti</code>, in which case
no names will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>"xifti"</code> has <code class="reqn">V</code> grayordinates and <code class="reqn">T</code> measurements\,
<code>newdata</code> should be a <code class="reqn">V \times Q</code> matrix. If <code class="reqn">Q</code>
is not equal to <code class="reqn">T</code>, then any column names or label tables will be
removed. (A &quot;dlabel&quot; will be converted to a &quot;dscalar&quot;.)
</p>


<h3>Value</h3>

<p>The new <code>"xifti"</code>
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='nrow_xifti'>Counts the number of rows (vertices + voxels) in a <code>"xifti"</code>.</h2><span id='topic+nrow_xifti'></span>

<h3>Description</h3>

<p>Counts the number of data locations in the <code>"xifti"</code> data. Doesn't bother
to validate the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrow_xifti(xifti)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrow_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of rows in the <code>"xifti"</code> data.
</p>

<hr>
<h2 id='original_fnames_Param_remapped'>original_fnames: for remapping</h2><span id='topic+original_fnames_Param_remapped'></span>

<h3>Description</h3>

<p>original_fnames: for remapping
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="original_fnames_Param_remapped_+3A_original_fnames">original_fnames</code></td>
<td>
<p>The files to remap. This is a named list
where each element's name is a file type label, and each element's value
is a file name. Labels must be one of the following: &quot;cortexL&quot;, &quot;cortexR&quot;,
&quot;ROIcortexL&quot;, &quot;ROIcortexR&quot;. If <code>read_dir</code> is not <code>NULL</code>, then all
these file names should be relative to <code>read_dir</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='original_fnames_Param_resampled'>original_fnames: for resampling</h2><span id='topic+original_fnames_Param_resampled'></span>

<h3>Description</h3>

<p>original_fnames: for resampling
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="original_fnames_Param_resampled_+3A_original_fnames">original_fnames</code></td>
<td>
<p>The files to resample. This is a named list
where each element's name is a file type label, and each element's value
is a file name. Labels must be one of the following: &quot;cortexL&quot;, &quot;cortexR&quot;,
&quot;ROIcortexL&quot;, &quot;ROIcortexR&quot;, &quot;surfL&quot;, or &quot;surfR&quot;. If
<code>read_dir</code> is not <code>NULL</code>, then all these file names should be
relative to <code>read_dir</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='pad_vol'>Pad a 3D Array</h2><span id='topic+pad_vol'></span><span id='topic+uncrop_vol'></span>

<h3>Description</h3>

<p>Pad a 3D array by a certain amount in each direction, along each dimension.
This effectively undoes a crop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_vol(x, padding, fill = NA)

uncrop_vol(x, padding, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_vol_+3A_x">x</code></td>
<td>
<p>A 3D array, e.g. <code>unmask_subcortex(xifti$data$subcort, xifti$meta$subcort$mask)</code>.</p>
</td></tr>
<tr><td><code id="pad_vol_+3A_padding">padding</code></td>
<td>
<p>A <code class="reqn">d \times 2</code> matrix indicating the number of
slices to add at the beginning and end of each of the d dimensions, e.g.
<code>xifti$meta$subcort$mask_padding</code>.</p>
</td></tr>
<tr><td><code id="pad_vol_+3A_fill">fill</code></td>
<td>
<p>Values to pad with. Default: <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The padded array
</p>

<hr>
<h2 id='parc_add_subcortex'>Add subcortex to cortical parcellation</h2><span id='topic+parc_add_subcortex'></span>

<h3>Description</h3>

<p>Add the subcortex, with each brain structure as a separate parcel, to
a &quot;dlabel&quot; cortical parcellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parc_add_subcortex(parc, parc_sub = "MNI")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parc_add_subcortex_+3A_parc">parc</code></td>
<td>
<p>A single-column &quot;dlabel&quot; <code>"xifti"</code> object without
subcortical data.</p>
</td></tr>
<tr><td><code id="parc_add_subcortex_+3A_parc_sub">parc_sub</code></td>
<td>
<p>A single-column <code>"xifti"</code> object with only
subcortical data. Or, <code>"MNI"</code> (default) to read in and use the MNI
subcortex included in <code>ciftiTools</code>. (The Connectome Workbench is
required.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new parcellation with added subcortical data and labels.
</p>


<h3>See Also</h3>

<p>Other parcellation-related: 
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+load_sub_parc">load_sub_parc</a>()</code>,
<code><a href="#topic+parc_borders">parc_borders</a>()</code>,
<code><a href="#topic+parc_vals_to_xifti">parc_vals_to_xifti</a>()</code>
</p>

<hr>
<h2 id='parc_borders'>Parcellation borders</h2><span id='topic+parc_borders'></span>

<h3>Description</h3>

<p>Identify vertices which lie on the border of different parcels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parc_borders(parc, surf = NULL, hemisphere = c("left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parc_borders_+3A_parc">parc</code></td>
<td>
<p>Integer vector the same length as the number of vertices. Each
entry indicates the parcel that vertex belongs to.</p>
</td></tr>
<tr><td><code id="parc_borders_+3A_surf">surf</code></td>
<td>
<p>The surface which the vertices belong to, or just the <code>"faces"</code>
component (<code class="reqn">F \times 3</code> matrix where each row indicates the vertices which
comprise a face). If not provided, the (resampled) default <code>hemisphere</code>
surface included with <code>ciftiTools</code> will be used.</p>
</td></tr>
<tr><td><code id="parc_borders_+3A_hemisphere">hemisphere</code></td>
<td>
<p>Only used to choose which default surface to use if
<code>is.null(surf)</code>. Should be <code>"left"</code> (default) or <code>"right"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector the same length as <code>parc</code> indicating if the
vertex lies on a border.
</p>


<h3>See Also</h3>

<p>Other parcellation-related: 
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+load_sub_parc">load_sub_parc</a>()</code>,
<code><a href="#topic+parc_add_subcortex">parc_add_subcortex</a>()</code>,
<code><a href="#topic+parc_vals_to_xifti">parc_vals_to_xifti</a>()</code>
</p>

<hr>
<h2 id='parc_mean_mat'>Make parcellation mean matrix</h2><span id='topic+parc_mean_mat'></span>

<h3>Description</h3>

<p>Create a matrix that compute the average value for each parcel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parc_mean_mat(parc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parc_mean_mat_+3A_parc">parc</code></td>
<td>
<p>A single-column &quot;dlabel&quot; <code>"xifti"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From a single-column &quot;dlabel&quot; <code>"xifti"</code> object, make a <code class="reqn">K \times V</code>
matrix where row <code class="reqn">k</code> is a vector corresponding to the kth Key value,
with <code class="reqn">1/k_i</code> at locations with that key value, and <code class="reqn">0</code> elsewhere.
<code class="reqn">k_i</code> is the total number of locations inside Key <code class="reqn">k</code>.
So, the sum of each row will be <code class="reqn">1</code>, and each column will only
have exactly one non-zero value (because each location only has one Key
value) except medial wall locations will have all zeroes.
</p>
<p>Multiplying the result of <code>parc_mean_mat</code> with a <code class="reqn">V \times T</code> matrix
of timeseries data, e.g. from <code>as.matrix(dlabel_xii)</code>, will yield the
average value for each Key.
</p>


<h3>Value</h3>

<p>The parcellation matrix
</p>

<hr>
<h2 id='parc_vals_to_xifti'>Convert parcellation values to <code>"xifti"</code></h2><span id='topic+parc_vals_to_xifti'></span>

<h3>Description</h3>

<p>From a parcellation and a corresponding value matrix, make a <code>"xifti"</code>
object that has the value vector of each parcel across its locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parc_vals_to_xifti(parc, vals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parc_vals_to_xifti_+3A_parc">parc</code></td>
<td>
<p>A single-column &quot;dlabel&quot; <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="parc_vals_to_xifti_+3A_vals">vals</code></td>
<td>
<p>A numeric matrix. Rows should correspond to rows in
the color table of <code>parc</code>. Columns will become columns in the output
<code>"xifti"</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"xifti"</code> object
</p>


<h3>See Also</h3>

<p>Other parcellation-related: 
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+load_sub_parc">load_sub_parc</a>()</code>,
<code><a href="#topic+parc_add_subcortex">parc_add_subcortex</a>()</code>,
<code><a href="#topic+parc_borders">parc_borders</a>()</code>
</p>

<hr>
<h2 id='plot.surf'>S3 method: plot surface</h2><span id='topic+plot.surf'></span>

<h3>Description</h3>

<p>Visualize a single surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'surf'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.surf_+3A_x">x</code></td>
<td>
<p>A <code>"surf"</code> object</p>
</td></tr>
<tr><td><code id="plot.surf_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code>. But, the
<code>hemisphere</code> argument behaves differently: it can be either
<code>left</code> or <code>right</code> to indicate which hemisphere <code>x</code>
represents. It is only used if the <code>"hemisphere"</code> metadata entry in
<code>x</code> is <code>NULL</code>. If both the argument and the metadata entry are
<code>NULL</code>, the surface will be treated as the left hemisphere.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.xifti'>S3 method: use <code>view_xifti</code> to plot a <code>"xifti"</code> object</h2><span id='topic+plot.xifti'></span>

<h3>Description</h3>

<p>S3 method: use <code>view_xifti</code> to plot a <code>"xifti"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xifti'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.xifti_+3A_x">x</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="plot.xifti_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+view_xifti">view_xifti</a></code>, except
<code>what</code>, which will be set to <code>NULL</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='radial_order_surf'>Order Vertices on Circular Manifold</h2><span id='topic+radial_order_surf'></span>

<h3>Description</h3>

<p>Order vertices on circular manifold by radians (after 2D CMDS projection).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radial_order_surf(vertices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radial_order_surf_+3A_vertices">vertices</code></td>
<td>
<p>A <code class="reqn">V \times 3</code> matrix, where each row contains the Euclidean
coordinates at which a given vertex in the mesh is located. <code class="reqn">V</code> is the
number of vertices in the mesh</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Index ordering of <code>vertices</code>
</p>

<hr>
<h2 id='read_cifti'>Read a CIFTI file</h2><span id='topic+read_cifti'></span><span id='topic+readCIfTI'></span><span id='topic+readcii'></span><span id='topic+read_xifti'></span>

<h3>Description</h3>

<p>Read in a CIFTI file as a <code>"xifti"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_cifti(
  cifti_fname = NULL,
  surfL_fname = NULL,
  surfR_fname = NULL,
  brainstructures = c("left", "right"),
  idx = NULL,
  resamp_res = NULL,
  resamp_method = c("barycentric", "adaptive"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  flat = FALSE,
  mwall_values = c(NA, NaN),
  verbose = FALSE,
  ...
)

readCIfTI(
  cifti_fname = NULL,
  surfL_fname = NULL,
  surfR_fname = NULL,
  brainstructures = c("left", "right"),
  idx = NULL,
  resamp_res = NULL,
  resamp_method = c("barycentric", "adaptive"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  flat = FALSE,
  mwall_values = c(NA, NaN),
  verbose = FALSE,
  ...
)

readcii(
  cifti_fname = NULL,
  surfL_fname = NULL,
  surfR_fname = NULL,
  brainstructures = c("left", "right"),
  idx = NULL,
  resamp_res = NULL,
  resamp_method = c("barycentric", "adaptive"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  flat = FALSE,
  mwall_values = c(NA, NaN),
  verbose = FALSE,
  ...
)

read_xifti(
  cifti_fname = NULL,
  surfL_fname = NULL,
  surfR_fname = NULL,
  brainstructures = c("left", "right"),
  idx = NULL,
  resamp_res = NULL,
  resamp_method = c("barycentric", "adaptive"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  flat = FALSE,
  mwall_values = c(NA, NaN),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_cifti_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_surfl_fname">surfL_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the left cortex.</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_surfr_fname">surfR_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the right cortex.</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
to obtain: <code>"left"</code> (left cortex), <code>"right"</code> (right cortex)
and/or <code>"subcortical"</code> (subcortex and cerebellum). Can also be
<code>"all"</code> (obtain all three brain structures). Default:
<code>c("left","right")</code> (cortex only).
</p>
<p>If a brain structure is indicated but does not exist in the CIFTI file, a
warning will occur and that brain structure will be skipped.</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_idx">idx</code></td>
<td>
<p>Numeric vector indicating the data indices (columns) to read. If
<code>NULL</code> (default), read in all the data. Must be a subset of the indices
present in the file, or an error will occur.
</p>
<p>For high-resolution CIFTI files, reading in only a subset of the data saves
memory, but will be slower than reading in the entire file due to the
required intermediate steps.</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_resamp_res">resamp_res</code></td>
<td>
<p>Resolution to resample the cortical data and surface to.
Default: <code>NULL</code> (do not resample). If not <code>NULL</code>, the data will
have to be read in with <code>-cifti-separate</code>, which is slower than
<code>-cifti-convert -to-gifti-ext</code>.</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_resamp_method">resamp_method</code></td>
<td>
<p><code>"barycentric"</code> (default) or <code>"adaptive"</code>
resampling for the metric or label data. These options correspond to the
Workbench command options <code>"BARYCENTRIC"</code> and <code>"ADAP_BARY_AREA"</code>,
respectively.
</p>
<p>While adaptive resampling is recommended for metric or label
data, it requires that <code>area[L/R]_original_fname</code> be provided.
</p>
<p>Note that surfaces will resampled using barycentric resampling regardless of
<code>resamp_method</code>, because barycentric resampling rather than adaptive
resampling is recommended for surface data.</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_areal_original_fname">areaL_original_fname</code>, <code id="read_cifti_+3A_arear_original_fname">areaR_original_fname</code></td>
<td>
<p>File paths to the surfaces
to use for vertex area correction during adaptive resampling. (Only used if
resampling with the adaptive method.) <code>area[L/R]_original_fname</code> should
match the current resolution of the data.
</p>
<p>For resampling: the Workbench command for adaptive resampling requires the
target surfaces for area correction too. But to make the workflow easier,
<code>ciftiTools</code> will resample <code>area[L/R]_original_fname</code> with the
barycentric method and use that for the target area.
</p>
<p>For remapping: <code>area[L/R]_target_fname</code> must be directly provided.</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_flat">flat</code></td>
<td>
<p>Should the result be flattened into a single matrix?
</p>
<p>If <code>FALSE</code> (default), the result will be a <code>"xifti"</code> object.
</p>
<p>If <code>TRUE</code>, the result will be a <code class="reqn">T \times G</code> matrix (<code class="reqn">T</code>
measurements, <code class="reqn">G</code> grayordinates not including the medial wall if it's
excluded from the ROI). All below arguments will be ignored because the
brain structures cannot be identified. Surfaces will not be appended.
Resampling is also not possible. <code>flat==TRUE</code> is the fastest way to
read in just the CIFTI data.
</p>
<p>If <code>TRUE</code>, the grayordinates will be ordered by left cortex, right
cortex, and then subcortex. Subcortical voxels will be ordered by alphabetical
label. However, where each brainstructure (and subcortical structure) begins
and ends cannot be determined. The medial wall locations and subcortical
brain mask are also not included. The data matrix will be identical to that
created by <code>-cifti-convert -to-gifti-ext</code>.</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_mwall_values">mwall_values</code></td>
<td>
<p>If the medial wall locations are not indicated in the
CIFTI, use these values to infer the medial wall mask. Default:
<code>c(NA, NaN)</code>. If <code>NULL</code>, do not attempt to infer the medial wall.</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="read_cifti_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+read_cifti_convert">read_cifti_convert</a></code> or
<code><a href="#topic+read_cifti_separate">read_cifti_separate</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, metadata is obtained with <code><a href="#topic+info_cifti">info_cifti</a></code>. Then, if no
resampling is requested, the <code>-cifti-convert -to-gifti-ext</code> Workbench
Command is used to &quot;flatten&quot; the data and save it as a metric or label GIFTI
file, which is read in and separated by brainstructure according to the metadata
(<code><a href="#topic+read_cifti_convert">read_cifti_convert</a></code>). Otherwise, if sampling is requested,
then the CIFTI is separated into its GIFTI and NIFTI components, resampled,
and then re-assembled (<code><a href="#topic+read_cifti_separate">read_cifti_separate</a></code>). The former is
much faster for large CIFTI files, so the latter is only used when necessary
for resampling.
</p>
<p>If <code>cifti_fname</code> is not provided, then only the surfaces are read in.
</p>


<h3>Value</h3>

<p>If <code>!flat</code>, a <code>"xifti"</code> object. Otherwise, a <code class="reqn">T \times G</code>
matrix (<code class="reqn">T</code> measurements, <code class="reqn">G</code> grayordinates).
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-cifti-convert"</code> Workbench command if
resampling is not needed, and the <code>"-cifti-separate"</code> Workbench command
if resampling is needed.
</p>


<h3>Label Levels</h3>

<p><code>xifti$meta$subcort$labels</code> is a factor with the following levels:
</p>

<ol>
<li><p>Cortex-L
</p>
</li>
<li><p>Cortex-R
</p>
</li>
<li><p>Accumbens-L
</p>
</li>
<li><p>Accumbens-R
</p>
</li>
<li><p>Amygdala-L
</p>
</li>
<li><p>Amygdala-R
</p>
</li>
<li><p>Brain Stem
</p>
</li>
<li><p>Caudate-L
</p>
</li>
<li><p>Caudate-R
</p>
</li>
<li><p>Cerebellum-L
</p>
</li>
<li><p>Cerebellum-R
</p>
</li>
<li><p>Diencephalon-L
</p>
</li>
<li><p>Diencephalon-R
</p>
</li>
<li><p>Hippocampus-L
</p>
</li>
<li><p>Hippocampus-R
</p>
</li>
<li><p>Pallidum-L
</p>
</li>
<li><p>Pallidum-R
</p>
</li>
<li><p>Putamen-L
</p>
</li>
<li><p>Putamen-R
</p>
</li>
<li><p>Thalamus-L
</p>
</li>
<li><p>Thalamus-R
</p>
</li></ol>

<p>These correspond to the same structures as given by
<code>ft_read_cifti</code> in the <code>cifti-matlab</code> MATLAB toolbox. Note that
the first two levels (left and right cortex) are not used.
</p>


<h3>See Also</h3>

<p>Other common: 
<code><a href="#topic+is.cifti">is.cifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+view_xifti">view_xifti</a>()</code>,
<code><a href="#topic+write_cifti">write_cifti</a>()</code>
</p>
<p>Other reading: 
<code><a href="#topic+as.xifti">as.xifti</a>()</code>,
<code><a href="#topic+info_cifti">info_cifti</a>()</code>,
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+read_xifti2">read_xifti2</a>()</code>
</p>

<hr>
<h2 id='read_cifti_convert'>Read a CIFTI file quickly</h2><span id='topic+read_cifti_convert'></span>

<h3>Description</h3>

<p>Read a CIFTI file by exporting it as a single GIFTI
using <code>-cifti-convert -to-gifti-ext</code> (<code><a href="#topic+read_cifti_flat">read_cifti_flat</a></code>),
and obtaining the brainordinate mapping using
<code>-cifti-export-dense-mapping</code> (<code><a href="#topic+info_cifti">info_cifti</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_cifti_convert(
  cifti_fname,
  surfL_fname = NULL,
  surfR_fname = NULL,
  brainstructures = c("left", "right"),
  idx = NULL,
  mwall_values = c(NA, NaN),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_cifti_convert_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
<tr><td><code id="read_cifti_convert_+3A_surfl_fname">surfL_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the left cortex.</p>
</td></tr>
<tr><td><code id="read_cifti_convert_+3A_surfr_fname">surfR_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the right cortex.</p>
</td></tr>
<tr><td><code id="read_cifti_convert_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
to obtain: <code>"left"</code> (left cortex), <code>"right"</code> (right cortex)
and/or <code>"subcortical"</code> (subcortex and cerebellum). Can also be
<code>"all"</code> (obtain all three brain structures). Default:
<code>c("left","right")</code> (cortex only).
</p>
<p>If a brain structure is indicated but does not exist in the CIFTI file, a
warning will occur and that brain structure will be skipped.</p>
</td></tr>
<tr><td><code id="read_cifti_convert_+3A_idx">idx</code></td>
<td>
<p>Numeric vector indicating the data indices (columns) to read. If
<code>NULL</code> (default), read in all the data. Must be a subset of the indices
present in the file, or an error will occur.
</p>
<p>For high-resolution CIFTI files, reading in only a subset of the data saves
memory, but will be slower than reading in the entire file due to the
required intermediate steps.</p>
</td></tr>
<tr><td><code id="read_cifti_convert_+3A_mwall_values">mwall_values</code></td>
<td>
<p>If the medial wall mask is not present in the CIFTI,
infer it from these data values. Default: <code>c(NA, NaN)</code>. If <code>NULL</code>,
do not attempt to infer the medial wall mask from the data values.</p>
</td></tr>
<tr><td><code id="read_cifti_convert_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="read_cifti_convert_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>read_cifti_flat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"xifti"</code> object. See <code><a href="#topic+is.xifti">is.xifti</a></code>.
</p>

<hr>
<h2 id='read_cifti_flat'>Read only the data matrix in a CIFTI file</h2><span id='topic+read_cifti_flat'></span>

<h3>Description</h3>

<p>Reads the CIFTI data matrix by converting it to a GIFTI using the
<code>-cifti-convert -to-gifti-ext</code> Connectome Workbench command. The result
will be a <code class="reqn">T \times G</code> matrix (<code class="reqn">T</code> measurements, <code class="reqn">G</code> non-empty
grayordinates). All brainstructures in the CIFTI will be obtained, with no
indication for which brainstructure each brainordinate corresponds to.
Medial wall vertices and voxels outside the subcortical mask will not be
included. No spatial information is included. This is the fastest way to
read in CIFTI data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_cifti_flat(
  cifti_fname,
  keep = FALSE,
  gifti_fname = NULL,
  idx = NULL,
  write_dir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_cifti_flat_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
<tr><td><code id="read_cifti_flat_+3A_keep">keep</code></td>
<td>
<p>This function works by converting the CIFTI file to a GIFTI file
and then reading it in. Should the GIFTI file be kept? If <code>FALSE</code>
(default), write it in a temporary directory regardless of <code>write_dir</code>.</p>
</td></tr>
<tr><td><code id="read_cifti_flat_+3A_gifti_fname">gifti_fname</code></td>
<td>
<p>File path of GIFTI-format data to save the CIFTI as.
Should end with &quot;.func.gii&quot; for dscalar and dtseries CIFTI, and &quot;.label.gii&quot;
for dlabel CIFTI. Default: the CIFTI_fname but with the CIFTI extension
replaced with the appropriate GIFTI extension.</p>
</td></tr>
<tr><td><code id="read_cifti_flat_+3A_idx">idx</code></td>
<td>
<p>Numeric vector indicating the data indices (columns) to read. If
<code>NULL</code> (default), read in all the data. Must be a subset of the indices
present in the file, or an error will occur.
</p>
<p>For high-resolution CIFTI files, reading in only a subset of the data saves
memory, but will be slower than reading in the entire file due to the
required intermediate steps.</p>
</td></tr>
<tr><td><code id="read_cifti_flat_+3A_write_dir">write_dir</code></td>
<td>
<p>The directory in which to save the GIFTI, if it is being
kept. If <code>NULL</code> (default), use the current working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">T \times G</code> matrix, where <code class="reqn">T</code> is the number of measurements
and <code class="reqn">G</code> is the number of grayordinates in the CIFTI file.
</p>

<hr>
<h2 id='read_cifti_separate'>Read a CIFTI file with optional resampling</h2><span id='topic+read_cifti_separate'></span>

<h3>Description</h3>

<p>Read a CIFTI file by writing each component into a GIFTI and NIFTI file
(<code><a href="#topic+separate_cifti">separate_cifti</a></code>), optionally resampling the GIFTIs,
(<code><a href="#topic+resample_gifti">resample_gifti</a></code>), and then reading each separated
component into R (<code><a href="#topic+make_xifti">make_xifti</a></code>). Surfaces can also be provided;
they will be resampled along with the CIFTI for viewing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_cifti_separate(
  cifti_fname,
  surfL_fname = NULL,
  surfR_fname = NULL,
  brainstructures = c("left", "right"),
  idx = NULL,
  resamp_res = NULL,
  resamp_method = c("barycentric", "adaptive"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  mwall_values = c(NA, NaN),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_cifti_separate_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
<tr><td><code id="read_cifti_separate_+3A_surfl_fname">surfL_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the left cortex.</p>
</td></tr>
<tr><td><code id="read_cifti_separate_+3A_surfr_fname">surfR_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the right cortex.</p>
</td></tr>
<tr><td><code id="read_cifti_separate_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
to obtain: <code>"left"</code> (left cortex), <code>"right"</code> (right cortex)
and/or <code>"subcortical"</code> (subcortex and cerebellum). Can also be
<code>"all"</code> (obtain all three brain structures). Default:
<code>c("left","right")</code> (cortex only).
</p>
<p>If a brain structure is indicated but does not exist in the CIFTI file, a
warning will occur and that brain structure will be skipped.</p>
</td></tr>
<tr><td><code id="read_cifti_separate_+3A_idx">idx</code></td>
<td>
<p>Numeric vector indicating the data indices (columns) to read. If
<code>NULL</code> (default), read in all the data. Must be a subset of the indices
present in the file, or an error will occur.
</p>
<p>For high-resolution CIFTI files, reading in only a subset of the data saves
memory, but will be slower than reading in the entire file due to the
required intermediate steps.</p>
</td></tr>
<tr><td><code id="read_cifti_separate_+3A_resamp_res">resamp_res</code></td>
<td>
<p>(Optional) Target resolution for resampling (number of
cortical surface vertices per hemisphere). If <code>NULL</code> (default) or
<code>FALSE</code>, do not perform resampling.</p>
</td></tr>
<tr><td><code id="read_cifti_separate_+3A_resamp_method">resamp_method</code></td>
<td>
<p><code>"barycentric"</code> (default) or <code>"adaptive"</code>
resampling for the metric or label data. These options correspond to the
Workbench command options <code>"BARYCENTRIC"</code> and <code>"ADAP_BARY_AREA"</code>,
respectively.
</p>
<p>While adaptive resampling is recommended for metric or label
data, it requires that <code>area[L/R]_original_fname</code> be provided.
</p>
<p>Note that surfaces will resampled using barycentric resampling regardless of
<code>resamp_method</code>, because barycentric resampling rather than adaptive
resampling is recommended for surface data.</p>
</td></tr>
<tr><td><code id="read_cifti_separate_+3A_areal_original_fname">areaL_original_fname</code>, <code id="read_cifti_separate_+3A_arear_original_fname">areaR_original_fname</code></td>
<td>
<p>File paths to the surfaces
to use for vertex area correction during adaptive resampling. (Only used if
resampling with the adaptive method.) <code>area[L/R]_original_fname</code> should
match the current resolution of the data.
</p>
<p>For resampling: the Workbench command for adaptive resampling requires the
target surfaces for area correction too. But to make the workflow easier,
<code>ciftiTools</code> will resample <code>area[L/R]_original_fname</code> with the
barycentric method and use that for the target area.
</p>
<p>For remapping: <code>area[L/R]_target_fname</code> must be directly provided.</p>
</td></tr>
<tr><td><code id="read_cifti_separate_+3A_mwall_values">mwall_values</code></td>
<td>
<p>If the medial wall locations are not indicated in the
CIFTI, use these values to infer the medial wall mask. Default:
<code>c(NA, NaN)</code>. If <code>NULL</code>, do not attempt to infer the medial wall.</p>
</td></tr>
<tr><td><code id="read_cifti_separate_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subcortical component (NIFTI) is not resampled.
</p>


<h3>Value</h3>

<p>A <code>"xifti"</code> object. See <code><a href="#topic+is.xifti">is.xifti</a></code>.
</p>

<hr>
<h2 id='read_dir_Param_separated'>read_dir: separated files</h2><span id='topic+read_dir_Param_separated'></span>

<h3>Description</h3>

<p>read_dir: separated files
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_dir_Param_separated_+3A_read_dir">read_dir</code></td>
<td>
<p>Directory to append to the path of every file being read,
e.g. <code>cortexL_original_fname</code>. If <code>NULL</code> (default), do not append
any directory to the path.
</p>
<p><code>read_dir</code> must already exist, or an error will be raised.</p>
</td></tr>
</table>

<hr>
<h2 id='read_surf'>Get a <code>"surf"</code> object</h2><span id='topic+read_surf'></span><span id='topic+make_surf'></span>

<h3>Description</h3>

<p>Coerce a file path to a surface GIFTI, a <code>"gifti"</code> object, a list with
entries &quot;pointset&quot; and &quot;triangle&quot;, or a <code>"surf"</code> to a
<code>"surf"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_surf(surf, expected_hemisphere = NULL, resamp_res = NULL)

make_surf(surf, expected_hemisphere = NULL, resamp_res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_surf_+3A_surf">surf</code></td>
<td>
<p>Either a file path to a surface GIFTI; a <code>"gifti"</code>
read by <code><a href="gifti.html#topic+readgii">readgii</a></code>; a list with entries &quot;pointset&quot; and
&quot;triangle&quot;; or, a <code>"surf"</code> object.</p>
</td></tr>
<tr><td><code id="read_surf_+3A_expected_hemisphere">expected_hemisphere</code></td>
<td>
<p>The expected hemisphere (<code>"left"</code> or <code>"right"</code>)
of <code>surf</code>. If the hemisphere indicated in the GIFTI metadata is the
opposite, an error is raised. If <code>NULL</code> (default), use the GIFTI
hemisphere.</p>
</td></tr>
<tr><td><code id="read_surf_+3A_resamp_res">resamp_res</code></td>
<td>
<p>The resolution to resample the surfaces to. If <code>NULL</code>
(default), do not resample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>"surf"</code>: a list with components <code>"vertices"</code>
(3D spatial locations), <code>"faces"</code> (defined by three vertices), and
<code>"hemisphere"</code> (<code>"left"</code>, <code>"right"</code>, or <code>NULL</code> if
unknown).
</p>


<h3>See Also</h3>

<p>Other reading: 
<code><a href="#topic+as.xifti">as.xifti</a>()</code>,
<code><a href="#topic+info_cifti">info_cifti</a>()</code>,
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+read_xifti2">read_xifti2</a>()</code>
</p>
<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='read_xifti2'>Read in GIFTI files as a <code>"xifti"</code> object</h2><span id='topic+read_xifti2'></span>

<h3>Description</h3>

<p>Read in GIFTI metric or label files as a <code>"xifti"</code> object. May also include
surface geometry GIFTI files and perform resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_xifti2(
  cortexL = NULL,
  cortexL_mwall = NULL,
  cortexR = NULL,
  cortexR_mwall = NULL,
  mwall_values = c(NA, NaN),
  surfL = NULL,
  surfR = NULL,
  resamp_res = NULL,
  col_names = NULL,
  HCP_32k_auto_mwall = TRUE,
  read_dir = NULL,
  validate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_xifti2_+3A_cortexl">cortexL</code>, <code id="read_xifti2_+3A_cortexl_mwall">cortexL_mwall</code></td>
<td>
<p>Left cortex data and ROI. Each must be a path to
a metric or label GIFTI file.
</p>
<p>If <code>cortexL_mwall</code> is not provided, <code>cortexL</code> should have data for
all vertices on the left cortical surface (<code class="reqn">V_L \times T</code> data matrix). There
will not be a mask for the medial wall. Not providing the medial wall mask
is appropriate for &quot;.dlabels.nii&quot; files where the medial wall may have its
own label and therefore should not be treated as missing data.
</p>
<p>If <code>cortexL_mwall</code> is provided, <code>cortexL</code> should either have data
for all vertices on the left cortical surface (<code class="reqn">V_L \times T</code> data matrix, with
filler values e.g. <code>0</code> or <code>NaN</code> for medial wall vertices), or have data
only for non-medial wall vertices (<code class="reqn">(V_L - mwall_L) \times T</code> data matrix).
The medial wall mask will be the <code>0</code> values in <code>cortexL_mwall</code>.
The medial wall mask should be provided whenever the medial wall should be
treated as missing data.
</p>
<p>Since the unmasked cortices must have the same number of vertices,
<code>V_L</code> should match <code>V_R</code>, or <code>resamp_res</code> must be set.</p>
</td></tr>
<tr><td><code id="read_xifti2_+3A_cortexr">cortexR</code>, <code id="read_xifti2_+3A_cortexr_mwall">cortexR_mwall</code></td>
<td>
<p>Right cortex data and ROI. Each must be a path to
a metric or label GIFTI file.
</p>
<p>If <code>cortexR_mwall</code> is not provided, <code>cortexR</code> should have data for
all vertices on the right cortical surface (<code class="reqn">V_R \times T</code> data mre
will not be a mask for the medial wall. Not providing the medial wall mask
is appropriate for &quot;.dlabels.nii&quot; files where the medial wall may have its
own label and therefore should not be treated as missing data.
</p>
<p>If <code>cortexR_mwall</code> is provided, <code>cortexR</code> should either have data
for all vertices on the right cortical surface (<code class="reqn">V_R \times T</code> data matrix, with
filler values e.g. <code>0</code> or <code>NaN</code> for medial wall vertices), or have data
only for non-medial wall vertices (<code class="reqn">(V_R - mwall_R) \times T</code> data matrix).
The medial wall mask will be the <code>0</code> values in <code>cortexR_mwall</code>.
The medial wall mask should be provided whenever the medial wall should be
treated as missing data.
</p>
<p>Since the unmasked cortices must have the same number of vertices,
<code>V_L</code> should match <code>V_R</code>, or <code>resamp_res</code> must be set.</p>
</td></tr>
<tr><td><code id="read_xifti2_+3A_mwall_values">mwall_values</code></td>
<td>
<p>If <code>cortex[L/R]_mwall</code> was not provided, or if it
was invalid (i.e. bad length or all <code>TRUE</code>), the medial wall mask will
be inferred from rows in <code>cortex[L/R]</code> that are constantly one of these
values. Default: <code>c(NA, NaN)</code>. If <code>NULL</code>, do not attempt to infer
the medial wall from the data values. <code>NULL</code> should be used if <code>NA</code>
or <code>NaN</code> are legitimate values that non-medial wall vertices might
take on.</p>
</td></tr>
<tr><td><code id="read_xifti2_+3A_surfl">surfL</code>, <code id="read_xifti2_+3A_surfr">surfR</code></td>
<td>
<p>(Optional) File path(s) to surface GIFTI(s) for the left
or right cortex.</p>
</td></tr>
<tr><td><code id="read_xifti2_+3A_resamp_res">resamp_res</code></td>
<td>
<p>Resolution to resample the cortical data and surface to.
Default: <code>NULL</code> (do not resample). If provided, the original resolutions
of the cortex data and surfaces may differ.</p>
</td></tr>
<tr><td><code id="read_xifti2_+3A_col_names">col_names</code></td>
<td>
<p>Names of each measurement/column in the data. Overrides
names indicated in the data components.</p>
</td></tr>
<tr><td><code id="read_xifti2_+3A_hcp_32k_auto_mwall">HCP_32k_auto_mwall</code></td>
<td>
<p>If left and/or right cortex data is provided, and
the number of vertices matches that of the HCP 32k mesh (29696 on left, and
29716 on right), should the medial wall masks be added to the <code>"xifti"</code>
if not provided? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_xifti2_+3A_read_dir">read_dir</code></td>
<td>
<p>(Optional) Append a directory to all file names in the
arguments. If <code>NULL</code> (default), do not modify file names.</p>
</td></tr>
<tr><td><code id="read_xifti2_+3A_validate">validate</code></td>
<td>
<p>Validate that the result is a <code>"xifti"</code> object? Default:
<code>TRUE</code>. If <code>FALSE</code>, the result may not be properly formatted
if the inputs were invalid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>"xifti"</code> object containing all the data in the input giftis.
</p>


<h3>See Also</h3>

<p>Other reading: 
<code><a href="#topic+as.xifti">as.xifti</a>()</code>,
<code><a href="#topic+info_cifti">info_cifti</a>()</code>,
<code><a href="#topic+load_parc">load_parc</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>
</p>

<hr>
<h2 id='remap_cifti'>Remap CIFTI data</h2><span id='topic+remap_cifti'></span><span id='topic+remapCIfTI'></span><span id='topic+remapcii'></span><span id='topic+remap_xifti'></span>

<h3>Description</h3>

<p>Remap CIFTI data between two different spaces, such as between FreeSurfer
fsaverage group data and fs_LR group data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remap_cifti(
  x,
  cifti_target_fname = NULL,
  remap_method = c("adaptive", "barycentric"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  areaL_target_fname = NULL,
  areaR_target_fname = NULL,
  sphereL_original_fname = NULL,
  sphereR_original_fname = NULL,
  sphereL_target_fname = NULL,
  sphereR_target_fname = NULL,
  write_dir = NULL,
  mwall_values = c(NA, NaN),
  verbose = TRUE
)

remapCIfTI(
  x,
  cifti_target_fname = NULL,
  remap_method = c("adaptive", "barycentric"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  areaL_target_fname = NULL,
  areaR_target_fname = NULL,
  sphereL_original_fname = NULL,
  sphereR_original_fname = NULL,
  sphereL_target_fname = NULL,
  sphereR_target_fname = NULL,
  write_dir = NULL,
  mwall_values = c(NA, NaN),
  verbose = TRUE
)

remapcii(
  x,
  cifti_target_fname = NULL,
  remap_method = c("adaptive", "barycentric"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  areaL_target_fname = NULL,
  areaR_target_fname = NULL,
  sphereL_original_fname = NULL,
  sphereR_original_fname = NULL,
  sphereL_target_fname = NULL,
  sphereR_target_fname = NULL,
  write_dir = NULL,
  mwall_values = c(NA, NaN),
  verbose = TRUE
)

remap_xifti(
  x,
  cifti_target_fname = NULL,
  remap_method = c("adaptive", "barycentric"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  areaL_target_fname = NULL,
  areaR_target_fname = NULL,
  sphereL_original_fname = NULL,
  sphereR_original_fname = NULL,
  sphereL_target_fname = NULL,
  sphereR_target_fname = NULL,
  write_dir = NULL,
  mwall_values = c(NA, NaN),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remap_cifti_+3A_x">x</code></td>
<td>
<p>The CIFTI file name or <code>"xifti"</code> object to resample.</p>
</td></tr>
<tr><td><code id="remap_cifti_+3A_cifti_target_fname">cifti_target_fname</code></td>
<td>
<p>File name for the resampled CIFTI. Will be placed
in <code>write_dir</code>. If <code>NULL</code>, will be written to &quot;resampled.d*.nii&quot;.
<code>write_dir</code> will be appended to the beginning of the path.</p>
</td></tr>
<tr><td><code id="remap_cifti_+3A_remap_method">remap_method</code></td>
<td>
<p><code>"adaptive"</code> (default) or <code>"adaptive"</code>
resampling. These options correspond to the Workbench command options
<code>"BARYCENTRIC"</code> and <code>"ADAP_BARY_AREA"</code>, respectively.
</p>
<p>For remapping fs_LR group data to fsaverage, barycentric should be
used. For remapping FreeSurfer fsaverage group data to fs_LR, adaptive
should be used.</p>
</td></tr>
<tr><td><code id="remap_cifti_+3A_areal_original_fname">areaL_original_fname</code>, <code id="remap_cifti_+3A_areal_target_fname">areaL_target_fname</code></td>
<td>
<p>File paths to the left cortex
surfaces to use for vertex area correction during adaptive resampling.
Required if <code>remap_method</code> is <code>"adaptive"</code>.</p>
</td></tr>
<tr><td><code id="remap_cifti_+3A_arear_original_fname">areaR_original_fname</code>, <code id="remap_cifti_+3A_arear_target_fname">areaR_target_fname</code>, <code id="remap_cifti_+3A_spherer_original_fname">sphereR_original_fname</code>, <code id="remap_cifti_+3A_spherer_target_fname">sphereR_target_fname</code></td>
<td>
<p>See the corresponding arguments for the left cortex.</p>
</td></tr>
<tr><td><code id="remap_cifti_+3A_spherel_original_fname">sphereL_original_fname</code>, <code id="remap_cifti_+3A_spherel_target_fname">sphereL_target_fname</code></td>
<td>
<p>File paths to the sphere
surfaces in the original and target spaces, for the left cortex.</p>
</td></tr>
<tr><td><code id="remap_cifti_+3A_write_dir">write_dir</code></td>
<td>
<p>Where to write the resampled CIFTI (and surfaces if present.)
If <code>NULL</code> (default), will use the current working directory if <code>x</code>
was a CIFTI file, and a temporary directory if <code>x</code> was a <code>"xifti"</code>
object.</p>
</td></tr>
<tr><td><code id="remap_cifti_+3A_mwall_values">mwall_values</code></td>
<td>
<p>If the medial wall locations are not indicated in the
CIFTI, and if <code>ROIcortexL/R_original_fname</code> is not provided, then use
these values to infer the medial wall mask. Default: <code>c(NA, NaN)</code>. If
<code>NULL</code>, do not attempt to infer the medial wall.
</p>
<p>Correctly indicating the medial wall locations is important for remapping,
because the medial wall mask is taken into account during remapping
calculations.</p>
</td></tr>
<tr><td><code id="remap_cifti_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can accept a <code>"xifti"</code> object as well as a path to a CIFTI-file. If
the input <code>"xifti"</code> object has surface geometry, it will be removed.
</p>
<p>This function is in active development: its arguments and behavior may
change greatly in future versions of the package.
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='remap_cifti_wrapper'><code>remap_cifti</code> wrapper</h2><span id='topic+remap_cifti_wrapper'></span>

<h3>Description</h3>

<p>Wrapper for <code>remap_cifti</code>. Calls <code>resample_cifti_components</code> using
the original file names listed in the <code>original_fnames</code> argument and
the target file names listed in the <code>remap_fnames</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remap_cifti_wrapper(
  original_fnames,
  remap_fnames = NULL,
  remap_method = c("adaptive", "barycentric"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  areaL_target_fname = NULL,
  areaR_target_fname = NULL,
  sphereL_original_fname = NULL,
  sphereR_original_fname = NULL,
  sphereL_target_fname = NULL,
  sphereR_target_fname = NULL,
  read_dir = NULL,
  write_dir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remap_cifti_wrapper_+3A_original_fnames">original_fnames</code></td>
<td>
<p>The files to remap. This is a named list
where each element's name is a file type label, and each element's value
is a file name. Labels must be one of the following: &quot;cortexL&quot;, &quot;cortexR&quot;,
&quot;ROIcortexL&quot;, &quot;ROIcortexR&quot;. If <code>read_dir</code> is not <code>NULL</code>, then all
these file names should be relative to <code>read_dir</code>.</p>
</td></tr>
<tr><td><code id="remap_cifti_wrapper_+3A_remap_fnames">remap_fnames</code></td>
<td>
<p>Where to write the resampled files. This is a named list
where each entry's name is a file type label, and each entry's value
is a file name indicating where to write the corresponding resampled file.
The recognized file type labels are: &quot;cortexL&quot;, &quot;cortexR&quot;,
&quot;ROIcortexL&quot;, &quot;ROIcortexR&quot;, &quot;validROIcortexL&quot;, and &quot;validROIcortexR&quot;.
</p>
<p>Entry values can be <code>NULL</code>, in which case a default file name will be
used: see <code><a href="#topic+resample_cifti_default_fname">resample_cifti_default_fname</a></code>. Default file names
will also be used for files that need to be resampled/written but without a
corresponding entry in <code>remap_fnames</code>.
</p>
<p>Entries in <code>remap_fnames</code> will be ignored if they are not needed
based on <code>[ROI_]brainstructures</code>. For example, if
<code>brainstructures="left"</code>, then <code>remap_fnames$cortexR</code> will be
ignored if specified.
</p>
<p>The <code>write_dir</code> argument can be used to place each resampled file in
the same directory.</p>
</td></tr>
<tr><td><code id="remap_cifti_wrapper_+3A_remap_method">remap_method</code></td>
<td>
<p><code>"adaptive"</code> (default) or <code>"adaptive"</code>
resampling. These options correspond to the Workbench command options
<code>"BARYCENTRIC"</code> and <code>"ADAP_BARY_AREA"</code>, respectively.
</p>
<p>For remapping between fs_LR group data and FreeSurfer fsaverage group data,
adaptive resampling should be used.</p>
</td></tr>
<tr><td><code id="remap_cifti_wrapper_+3A_areal_original_fname">areaL_original_fname</code>, <code id="remap_cifti_wrapper_+3A_arear_original_fname">areaR_original_fname</code></td>
<td>
<p>File paths to the surfaces
to use for vertex area correction during adaptive resampling. (Only used if
resampling with the adaptive method.) <code>area[L/R]_original_fname</code> should
match the current resolution of the data.
</p>
<p>For resampling: the Workbench command for adaptive resampling requires the
target surfaces for area correction too. But to make the workflow easier,
<code>ciftiTools</code> will resample <code>area[L/R]_original_fname</code> with the
barycentric method and use that for the target area.
</p>
<p>For remapping: <code>area[L/R]_target_fname</code> must be directly provided.</p>
</td></tr>
<tr><td><code id="remap_cifti_wrapper_+3A_areal_target_fname">areaL_target_fname</code>, <code id="remap_cifti_wrapper_+3A_arear_target_fname">areaR_target_fname</code></td>
<td>
<p>File paths to the surfaces
to use for vertex area correction during adaptive resampling. (Only used if
resampling with the adaptive method.) <code>area[L/R]_target_fname</code> should
match the target resolution of the data.</p>
</td></tr>
<tr><td><code id="remap_cifti_wrapper_+3A_read_dir">read_dir</code></td>
<td>
<p>Directory to append to the path of every file being read,
e.g. <code>cortexL_original_fname</code>. If <code>NULL</code> (default), do not append
any directory to the path.
</p>
<p><code>read_dir</code> must already exist, or an error will be raised.</p>
</td></tr>
<tr><td><code id="remap_cifti_wrapper_+3A_write_dir">write_dir</code></td>
<td>
<p>Where should the separate files be placed? <code>NULL</code>
(default) will write them to the current working directory.
</p>
<p><code>write_dir</code> must already exist, or an error will occur.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value of the <code>resample_cifti_components</code> call
</p>

<hr>
<h2 id='remap_gifti'>Remap GIFTI metric or label data</h2><span id='topic+remap_gifti'></span>

<h3>Description</h3>

<p>Remap GIFTI metric or label data between two different spaces, such as
between FreeSurfer fsaverage group data and fs_LR group data. This function
is a wrapper to <code><a href="#topic+resample_gifti">resample_gifti</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remap_gifti(
  original_fname,
  target_fname,
  hemisphere = c("left", "right"),
  remap_method = c("adaptive", "barycentric"),
  area_original_fname,
  area_target_fname,
  ROIcortex_original_fname,
  ROIcortex_target_fname,
  sphere_original_fname,
  sphere_target_fname
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remap_gifti_+3A_original_fname">original_fname</code></td>
<td>
<p>The GIFTI file to remap.</p>
</td></tr>
<tr><td><code id="remap_gifti_+3A_target_fname">target_fname</code></td>
<td>
<p>Where to save the remapped file.</p>
</td></tr>
<tr><td><code id="remap_gifti_+3A_hemisphere">hemisphere</code></td>
<td>
<p><code>"left"</code> (default) or <code>"right"</code>. An error will
occur if the hemisphere indicated in the GIFTI metadata does not match.</p>
</td></tr>
<tr><td><code id="remap_gifti_+3A_remap_method">remap_method</code></td>
<td>
<p><code>"adaptive"</code> (default) or <code>"adaptive"</code>
resampling. These options correspond to the Workbench command options
<code>"BARYCENTRIC"</code> and <code>"ADAP_BARY_AREA"</code>, respectively.
</p>
<p>For remapping between fs_LR group data and FreeSurfer fsaverage group data,
adaptive resampling should be used.</p>
</td></tr>
<tr><td><code id="remap_gifti_+3A_area_original_fname">area_original_fname</code>, <code id="remap_gifti_+3A_area_target_fname">area_target_fname</code></td>
<td>
<p>File paths to the surfaces to
use for vertex area correction during adaptive resampling. Required if
<code>remap_method</code> is <code>"adaptive"</code>.</p>
</td></tr>
<tr><td><code id="remap_gifti_+3A_roicortex_original_fname">ROIcortex_original_fname</code>, <code id="remap_gifti_+3A_roicortex_target_fname">ROIcortex_target_fname</code></td>
<td>
<p><code>ROIcortex_original_fname</code> is the name of the ROI file corresponding to
<code>original_fname</code>. Leave as <code>NULL</code> (default) if not applicable. If
provided, then also provide <code>ROIcortex_target_fname</code> to say where to
write the remapped ROI file.</p>
</td></tr>
<tr><td><code id="remap_gifti_+3A_sphere_original_fname">sphere_original_fname</code>, <code id="remap_gifti_+3A_sphere_target_fname">sphere_target_fname</code></td>
<td>
<p>File paths to the sphere
surfaces in the original and target spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The remapped GIFTI file name, invisibly
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-metric-resample"</code>, <code>"-label-resample"</code>,
and/or <code>"-surface-resample"</code> Workbench commands, depending on the input.
</p>


<h3>See Also</h3>

<p>Other gifting: 
<code><a href="#topic+resample_gifti">resample_gifti</a>()</code>,
<code><a href="#topic+smooth_gifti">smooth_gifti</a>()</code>
</p>

<hr>
<h2 id='remove_xifti'>Remove a component from a <code>"xifti"</code></h2><span id='topic+remove_xifti'></span>

<h3>Description</h3>

<p>Remove a brain structure, surface, or subcortical structure from a
<code>"xifti"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_xifti(xifti, remove = NULL, remove_sub = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="remove_xifti_+3A_remove">remove</code></td>
<td>
<p>A character vector containing one or more of the following:
<code>"cortex_left"</code>, <code>"cortex_right"</code>, <code>"subcortical"</code>,
<code>"surf_left"</code>, and <code>"surf_right"</code>. Each of these components will
be removed from <code>xifti</code>.</p>
</td></tr>
<tr><td><code id="remove_xifti_+3A_remove_sub">remove_sub</code></td>
<td>
<p>A vector containing subcortical structures to be removed
from <code>xifti</code>. Can be specified with names, or with numeric factor
values: see <code><a href="#topic+substructure_table">substructure_table</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new <code>"xifti"</code> with the requested component(s) removed
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='resamp_method_Param'>resamp_method</h2><span id='topic+resamp_method_Param'></span>

<h3>Description</h3>

<p>resamp_method
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="resamp_method_Param_+3A_resamp_method">resamp_method</code></td>
<td>
<p><code>"barycentric"</code> (default) or <code>"adaptive"</code>
resampling for the metric or label data. These options correspond to the
Workbench command options <code>"BARYCENTRIC"</code> and <code>"ADAP_BARY_AREA"</code>,
respectively.
</p>
<p>While adaptive resampling is recommended for metric or label
data, it requires that <code>area[L/R]_original_fname</code> be provided.
</p>
<p>Note that surfaces will resampled using barycentric resampling regardless of
<code>resamp_method</code>, because barycentric resampling rather than adaptive
resampling is recommended for surface data.</p>
</td></tr>
</table>

<hr>
<h2 id='resamp_res_Param_optional'>resamp_res: optional</h2><span id='topic+resamp_res_Param_optional'></span>

<h3>Description</h3>

<p>resamp_res: optional
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="resamp_res_Param_optional_+3A_resamp_res">resamp_res</code></td>
<td>
<p>(Optional) Target resolution for resampling (number of
cortical surface vertices per hemisphere). If <code>NULL</code> (default) or
<code>FALSE</code>, do not perform resampling.</p>
</td></tr>
</table>

<hr>
<h2 id='resamp_res_Param_required'>resamp_res: required</h2><span id='topic+resamp_res_Param_required'></span>

<h3>Description</h3>

<p>resamp_res: required
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="resamp_res_Param_required_+3A_resamp_res">resamp_res</code></td>
<td>
<p>Target resolution for resampling (number of
cortical surface vertices per hemisphere).</p>
</td></tr>
</table>

<hr>
<h2 id='resample_cifti'>Resample CIFTI data</h2><span id='topic+resample_cifti'></span><span id='topic+resampleCIfTI'></span><span id='topic+resamplecii'></span><span id='topic+resample_xifti'></span>

<h3>Description</h3>

<p>Performs spatial resampling of CIFTI data on the cortical surface
by separating it into GIFTI and NIFTI files, resampling the GIFTIs, and then
putting them together. (The subcortex is not resampled.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_cifti(
  x = NULL,
  cifti_target_fname = NULL,
  surfL_original_fname = NULL,
  surfR_original_fname = NULL,
  surfL_target_fname = NULL,
  surfR_target_fname = NULL,
  resamp_res,
  resamp_method = c("barycentric", "adaptive"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  write_dir = NULL,
  mwall_values = c(NA, NaN),
  verbose = TRUE
)

resampleCIfTI(
  x = NULL,
  cifti_target_fname = NULL,
  surfL_original_fname = NULL,
  surfR_original_fname = NULL,
  surfL_target_fname = NULL,
  surfR_target_fname = NULL,
  resamp_res,
  resamp_method = c("barycentric", "adaptive"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  write_dir = NULL,
  mwall_values = c(NA, NaN),
  verbose = TRUE
)

resamplecii(
  x = NULL,
  cifti_target_fname = NULL,
  surfL_original_fname = NULL,
  surfR_original_fname = NULL,
  surfL_target_fname = NULL,
  surfR_target_fname = NULL,
  resamp_res,
  resamp_method = c("barycentric", "adaptive"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  write_dir = NULL,
  mwall_values = c(NA, NaN),
  verbose = TRUE
)

resample_xifti(
  x = NULL,
  cifti_target_fname = NULL,
  surfL_original_fname = NULL,
  surfR_original_fname = NULL,
  surfL_target_fname = NULL,
  surfR_target_fname = NULL,
  resamp_res,
  resamp_method = c("barycentric", "adaptive"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  write_dir = NULL,
  mwall_values = c(NA, NaN),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_cifti_+3A_x">x</code></td>
<td>
<p>The CIFTI file name or <code>"xifti"</code> object to resample. If
<code>NULL</code>, the result will be a <code>"xifti"</code> with resampled surfaces
given by <code>surfL_original_fname</code> and <code>surfR_original_fname</code>.</p>
</td></tr>
<tr><td><code id="resample_cifti_+3A_cifti_target_fname">cifti_target_fname</code></td>
<td>
<p>File name for the resampled CIFTI. Will be placed
in <code>write_dir</code>. If <code>NULL</code>, will be written to &quot;resampled.d*.nii&quot;.
<code>write_dir</code> will be appended to the beginning of the path.</p>
</td></tr>
<tr><td><code id="resample_cifti_+3A_surfl_original_fname">surfL_original_fname</code>, <code id="resample_cifti_+3A_surfr_original_fname">surfR_original_fname</code></td>
<td>
<p>(Optional) Path to a GIFTI
surface geometry file representing the left/right cortex. One or both can be
provided. These will be resampled too, and are convenient for visualizing
the resampled data.
</p>
<p>If <code>x</code> is a <code>"xifti"</code> object with surfaces, these arguments
will override the surfaces in the <code>"xifti"</code>.</p>
</td></tr>
<tr><td><code id="resample_cifti_+3A_surfl_target_fname">surfL_target_fname</code>, <code id="resample_cifti_+3A_surfr_target_fname">surfR_target_fname</code></td>
<td>
<p>(Optional) File names for the
resampled GIFTI surface geometry files. Will be placed in <code>write_dir</code>.
If <code>NULL</code> (default), will use default names created by
<code><a href="#topic+resample_cifti_default_fname">resample_cifti_default_fname</a></code>.</p>
</td></tr>
<tr><td><code id="resample_cifti_+3A_resamp_res">resamp_res</code></td>
<td>
<p>Target resolution for resampling (number of
cortical surface vertices per hemisphere).</p>
</td></tr>
<tr><td><code id="resample_cifti_+3A_resamp_method">resamp_method</code></td>
<td>
<p><code>"barycentric"</code> (default) or <code>"adaptive"</code>
resampling for the metric or label data. These options correspond to the
Workbench command options <code>"BARYCENTRIC"</code> and <code>"ADAP_BARY_AREA"</code>,
respectively.
</p>
<p>While adaptive resampling is recommended for metric or label
data, it requires that <code>area[L/R]_original_fname</code> be provided.
</p>
<p>Note that surfaces will resampled using barycentric resampling regardless of
<code>resamp_method</code>, because barycentric resampling rather than adaptive
resampling is recommended for surface data.</p>
</td></tr>
<tr><td><code id="resample_cifti_+3A_areal_original_fname">areaL_original_fname</code>, <code id="resample_cifti_+3A_arear_original_fname">areaR_original_fname</code></td>
<td>
<p>File paths to the surfaces
to use for vertex area correction during adaptive resampling. (Only used if
resampling with the adaptive method.) <code>area[L/R]_original_fname</code> should
match the current resolution of the data.
</p>
<p>For resampling: the Workbench command for adaptive resampling requires the
target surfaces for area correction too. But to make the workflow easier,
<code>ciftiTools</code> will resample <code>area[L/R]_original_fname</code> with the
barycentric method and use that for the target area.
</p>
<p>For remapping: <code>area[L/R]_target_fname</code> must be directly provided.</p>
</td></tr>
<tr><td><code id="resample_cifti_+3A_write_dir">write_dir</code></td>
<td>
<p>Where to write the resampled CIFTI (and surfaces if present.)
If <code>NULL</code> (default), will use the current working directory if <code>x</code>
was a CIFTI file, and a temporary directory if <code>x</code> was a <code>"xifti"</code>
object.</p>
</td></tr>
<tr><td><code id="resample_cifti_+3A_mwall_values">mwall_values</code></td>
<td>
<p>If the medial wall locations are not indicated in the
CIFTI, use these values to infer the medial wall mask. Default:
<code>c(NA, NaN)</code>. If <code>NULL</code>, do not attempt to infer the medial wall.
</p>
<p>Correctly indicating the medial wall locations is important for resampling,
because the medial wall mask is taken into account during resampling
calculations.</p>
</td></tr>
<tr><td><code id="resample_cifti_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can accept a <code>"xifti"</code> object as well as a path to a CIFTI-file.
</p>
<p>If surface data is included, it will be resampled with the barycentric
method even if <code>resamp_method=="adaptive"</code> because the barycentric
method is recommended for surface geometry data.
</p>


<h3>Value</h3>

<p>A named character vector of written files: <code>"cifti"</code> and
potentially <code>"surfL"</code> (if <code>surfL_original_fname</code> was provided)
and/or <code>"surfR"</code> (if <code>surfR_original_fname</code> was provided).
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-metric-resample"</code>, <code>"-label-resample"</code>,
and/or <code>"-surface-resample"</code> Workbench commands, depending on the input.
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>
<p>Other common: 
<code><a href="#topic+is.cifti">is.cifti</a>()</code>,
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+view_xifti">view_xifti</a>()</code>,
<code><a href="#topic+write_cifti">write_cifti</a>()</code>
</p>

<hr>
<h2 id='resample_cifti_components'>Resample a series of GIFTIs related to a CIFTI file</h2><span id='topic+resample_cifti_components'></span>

<h3>Description</h3>

<p>Performs spatial resampling of various CIFTI file components on
the cortical surface. (The subcortical data is not resampled here.)
GIFTI surface geometry files can additionally be included: see
<code>surfL_original_fname</code> and <code>surfR_original_fname</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_cifti_components(
  original_res = NULL,
  resamp_res = NULL,
  resamp_method = NULL,
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  areaL_target_fname = NULL,
  areaR_target_fname = NULL,
  cortexL_original_fname = NULL,
  cortexR_original_fname = NULL,
  cortexL_target_fname = NULL,
  cortexR_target_fname = NULL,
  ROIcortexL_original_fname = NULL,
  ROIcortexR_original_fname = NULL,
  ROIcortexL_target_fname = NULL,
  ROIcortexR_target_fname = NULL,
  sphereL_original_fname = NULL,
  sphereR_original_fname = NULL,
  sphereL_target_fname = NULL,
  sphereR_target_fname = NULL,
  surfL_original_fname = NULL,
  surfR_original_fname = NULL,
  surfL_target_fname = NULL,
  surfR_target_fname = NULL,
  read_dir = NULL,
  write_dir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_cifti_components_+3A_original_res">original_res</code></td>
<td>
<p>The original resolution(s) of the CIFTI cortical surface(s).</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_resamp_res">resamp_res</code></td>
<td>
<p>Target resolution for resampling (number of
cortical surface vertices per hemisphere).</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_resamp_method">resamp_method</code></td>
<td>
<p><code>"barycentric"</code> (default) or <code>"adaptive"</code>
resampling for the metric or label data. These options correspond to the
Workbench command options <code>"BARYCENTRIC"</code> and <code>"ADAP_BARY_AREA"</code>,
respectively.
</p>
<p>While adaptive resampling is recommended for metric or label
data, it requires that <code>area[L/R]_original_fname</code> be provided.
</p>
<p>Note that surfaces will resampled using barycentric resampling regardless of
<code>resamp_method</code>, because barycentric resampling rather than adaptive
resampling is recommended for surface data.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_areal_original_fname">areaL_original_fname</code>, <code id="resample_cifti_components_+3A_arear_original_fname">areaR_original_fname</code></td>
<td>
<p>File paths to the surfaces
to use for vertex area correction during adaptive resampling. (Only used if
resampling with the adaptive method.) <code>area[L/R]_original_fname</code> should
match the current resolution of the data.
</p>
<p>For resampling: the Workbench command for adaptive resampling requires the
target surfaces for area correction too. But to make the workflow easier,
<code>ciftiTools</code> will resample <code>area[L/R]_original_fname</code> with the
barycentric method and use that for the target area.
</p>
<p>For remapping: <code>area[L/R]_target_fname</code> must be directly provided.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_areal_target_fname">areaL_target_fname</code>, <code id="resample_cifti_components_+3A_arear_target_fname">areaR_target_fname</code></td>
<td>
<p>File paths to the surfaces
to use for vertex area correction during adaptive resampling. (Only used if
resampling with the adaptive method.) <code>area[L/R]_target_fname</code> should
match the target resolution of the data.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_cortexl_original_fname">cortexL_original_fname</code>, <code id="resample_cifti_components_+3A_cortexr_original_fname">cortexR_original_fname</code></td>
<td>
<p>(Optional) File path of
GIFTI data for [left/right] cortex to resample.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_cortexl_target_fname">cortexL_target_fname</code>, <code id="resample_cifti_components_+3A_cortexr_target_fname">cortexR_target_fname</code></td>
<td>
<p>(Optional) File path to
save the resampled GIFTI data for [left/right] cortex as.
If NULL (default) and <code>cortex[L/R]_original_fname</code> was provided, it
will be named by <code><a href="#topic+cifti_component_suffix">cifti_component_suffix</a></code>.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_roicortexl_original_fname">ROIcortexL_original_fname</code>, <code id="resample_cifti_components_+3A_roicortexr_original_fname">ROIcortexR_original_fname</code></td>
<td>
<p>(Optional) File
path of GIFTI ROI corresponding to <code>cortex[L/R]_original_fname</code> to
resample.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_roicortexl_target_fname">ROIcortexL_target_fname</code>, <code id="resample_cifti_components_+3A_roicortexr_target_fname">ROIcortexR_target_fname</code></td>
<td>
<p>(Optional) File path
of to save the resampled GIFTI ROI corresponding to
<code>cortex[L/R]_target_fname</code> as.
If NULL (default) and <code>cortex[L/R]_original_fname</code> was provided, it
will be named by <code><a href="#topic+cifti_component_suffix">cifti_component_suffix</a></code>.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_surfl_original_fname">surfL_original_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the left cortex.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_surfr_original_fname">surfR_original_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the right cortex.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_surfl_target_fname">surfL_target_fname</code></td>
<td>
<p>(Optional) Where to save the resampled GIFTI
surface geometry file representing the left cortex.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_surfr_target_fname">surfR_target_fname</code></td>
<td>
<p>(Optional) Where to save the resampled GIFTI
surface geometry file representing the right cortex.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_read_dir">read_dir</code></td>
<td>
<p>Directory to append to the path of every file being read,
e.g. <code>cortexL_original_fname</code>. If <code>NULL</code> (default), do not append
any directory to the path.
</p>
<p><code>read_dir</code> must already exist, or an error will be raised.</p>
</td></tr>
<tr><td><code id="resample_cifti_components_+3A_write_dir">write_dir</code></td>
<td>
<p>Where should the separate files be placed? <code>NULL</code>
(default) will write them to the current working directory.
</p>
<p><code>write_dir</code> must already exist, or an error will occur.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Step 1: Generate spheres in the original and target resolutions
Step 2: Use -metric-resample to resample surface/cortex files
Step 3: Use -surface-resample to resample gifti files
</p>


<h3>Value</h3>

<p>A named character vector of file paths to each resampled file
</p>

<hr>
<h2 id='resample_cifti_default_fname'>Get resampled file name default</h2><span id='topic+resample_cifti_default_fname'></span>

<h3>Description</h3>

<p>Get the default file name for a resampled file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_cifti_default_fname(original_fname, resamp_res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_cifti_default_fname_+3A_original_fname">original_fname</code></td>
<td>
<p>The original file name</p>
</td></tr>
<tr><td><code id="resample_cifti_default_fname_+3A_resamp_res">resamp_res</code></td>
<td>
<p>Target resolution for resampling (number of
cortical surface vertices per hemisphere).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The default file name
</p>

<hr>
<h2 id='resample_cifti_from_template'>Resample a CIFTI from a template</h2><span id='topic+resample_cifti_from_template'></span>

<h3>Description</h3>

<p>Resample a CIFTI from a template, ensuring the new CIFTI's resolution matches
that of the template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_cifti_from_template(original_fname, template_fname, target_fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_cifti_from_template_+3A_original_fname">original_fname</code></td>
<td>
<p>A CIFTI file to resample.</p>
</td></tr>
<tr><td><code id="resample_cifti_from_template_+3A_template_fname">template_fname</code></td>
<td>
<p>A CIFTI file to use as the template.</p>
</td></tr>
<tr><td><code id="resample_cifti_from_template_+3A_target_fname">target_fname</code></td>
<td>
<p>The file name to save the resampled CIFTI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>target_fname</code>, invisibly
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-cifti-resample"</code> Workbench command.
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='resample_cifti_wrapper'><code>resample_cifti</code> wrapper</h2><span id='topic+resample_cifti_wrapper'></span>

<h3>Description</h3>

<p>Calls <code>resample_cifti_components</code> using the original file names
listed in the <code>original_fnames</code> argument and the target file names
listed in the <code>resamp_fnames</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_cifti_wrapper(
  original_fnames,
  resamp_fnames = NULL,
  original_res,
  resamp_res,
  resamp_method = c("barycentric", "adaptive"),
  areaL_original_fname = NULL,
  areaR_original_fname = NULL,
  surfL_original_fname = NULL,
  surfR_original_fname = NULL,
  surfL_target_fname = NULL,
  surfR_target_fname = NULL,
  read_dir = NULL,
  write_dir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_cifti_wrapper_+3A_original_fnames">original_fnames</code></td>
<td>
<p>The files to resample. This is a named list
where each element's name is a file type label, and each element's value
is a file name. Labels must be one of the following: &quot;cortexL&quot;, &quot;cortexR&quot;,
&quot;ROIcortexL&quot;, &quot;ROIcortexR&quot;, &quot;surfL&quot;, or &quot;surfR&quot;. If
<code>read_dir</code> is not <code>NULL</code>, then all these file names should be
relative to <code>read_dir</code>.</p>
</td></tr>
<tr><td><code id="resample_cifti_wrapper_+3A_resamp_fnames">resamp_fnames</code></td>
<td>
<p>Where to write the resampled files. This is a named list
where each entry's name is a file type label, and each entry's value
is a file name indicating where to write the corresponding resampled file.
The recognized file type labels are: &quot;cortexL&quot;, &quot;cortexR&quot;,
&quot;ROIcortexL&quot;, &quot;ROIcortexR&quot;, &quot;validROIcortexL&quot;, and &quot;validROIcortexR&quot;.
</p>
<p>Entry values can be <code>NULL</code>, in which case a default file name will be
used: see <code><a href="#topic+resample_cifti_default_fname">resample_cifti_default_fname</a></code>. Default file names
will also be used for files that need to be resampled/written but without a
corresponding entry in <code>resamp_fnames</code>.
</p>
<p>Entries in <code>resamp_fnames</code> will be ignored if they are not needed
based on <code>[ROI_]brainstructures</code>. For example, if
<code>brainstructures="left"</code>, then <code>resamp_fnames$cortexR</code> will be
ignored if specified.
</p>
<p>The <code>write_dir</code> argument can be used to place each resampled file in
the same directory.</p>
</td></tr>
<tr><td><code id="resample_cifti_wrapper_+3A_original_res">original_res</code></td>
<td>
<p>The original resolution(s) of the CIFTI cortical surface(s).</p>
</td></tr>
<tr><td><code id="resample_cifti_wrapper_+3A_resamp_res">resamp_res</code></td>
<td>
<p>Target resolution for resampling (number of
cortical surface vertices per hemisphere).</p>
</td></tr>
<tr><td><code id="resample_cifti_wrapper_+3A_surfl_target_fname">surfL_target_fname</code>, <code id="resample_cifti_wrapper_+3A_surfr_target_fname">surfR_target_fname</code></td>
<td>
<p>(Optional) File path for
the resampled GIFTI surface geometry file representing the left/right
cortex. If NULL (default),</p>
</td></tr>
<tr><td><code id="resample_cifti_wrapper_+3A_read_dir">read_dir</code></td>
<td>
<p>Directory to append to the path of every file being read,
e.g. <code>cortexL_original_fname</code>. If <code>NULL</code> (default), do not append
any directory to the path.
</p>
<p><code>read_dir</code> must already exist, or an error will be raised.</p>
</td></tr>
<tr><td><code id="resample_cifti_wrapper_+3A_write_dir">write_dir</code></td>
<td>
<p>Where should the separate files be placed? <code>NULL</code>
(default) will write them to the current working directory.
</p>
<p><code>write_dir</code> must already exist, or an error will occur.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently used by read_cifti and resample_cifti.
</p>


<h3>Value</h3>

<p>The return value of the <code>resample_cifti_components</code> call
</p>

<hr>
<h2 id='resample_gifti'>Resample a GIFTI file (with its ROI)</h2><span id='topic+resample_gifti'></span><span id='topic+resampleGIfTI'></span><span id='topic+resamplegii'></span>

<h3>Description</h3>

<p>Perform spatial resampling of GIFTI data on the cortical surface (metric
and label), or of GIFTI surface geometry data itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_gifti(
  original_fname,
  target_fname,
  hemisphere = c("left", "right"),
  file_type = NULL,
  original_res = NULL,
  resamp_res = NULL,
  resamp_method = c("barycentric", "adaptive"),
  area_original_fname = NULL,
  area_target_fname = NULL,
  ROIcortex_original_fname = NULL,
  ROIcortex_target_fname = NULL,
  sphere_original_fname = NULL,
  sphere_target_fname = NULL,
  read_dir = NULL,
  write_dir = NULL
)

resampleGIfTI(
  original_fname,
  target_fname,
  hemisphere,
  file_type = NULL,
  original_res = NULL,
  resamp_res,
  ROIcortex_original_fname = NULL,
  ROIcortex_target_fname = NULL,
  read_dir = NULL,
  write_dir = NULL
)

resamplegii(
  original_fname,
  target_fname,
  hemisphere,
  file_type = NULL,
  original_res = NULL,
  resamp_res,
  ROIcortex_original_fname = NULL,
  ROIcortex_target_fname = NULL,
  read_dir = NULL,
  write_dir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_gifti_+3A_original_fname">original_fname</code></td>
<td>
<p>The GIFTI file to resample.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_target_fname">target_fname</code></td>
<td>
<p>Where to save the resampled file.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_hemisphere">hemisphere</code></td>
<td>
<p><code>"left"</code> (default) or <code>"right"</code>. An error will
occur if the hemisphere indicated in the GIFTI metadata does not match.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_file_type">file_type</code></td>
<td>
<p><code>"metric"</code>, <code>"label"</code>, <code>"surf"</code>, or <code>NULL</code>
(default) to infer from <code>original_fname</code>.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_original_res">original_res</code></td>
<td>
<p>The resolution of the original file. If <code>NULL</code>
(default), infer from the file. Alternatively, provide
<code>sphere_original_fname</code> which will override <code>original_res</code>.
</p>
<p>In general, <code>original_res</code> should be used when the original file is
in registration with the spheres created by the Workbench command
<code>-surface-create-sphere</code>, and <code>sphere_original_fname</code> should be
used when it is not compatible.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_resamp_res">resamp_res</code></td>
<td>
<p>Target resolution for resampling (number of
cortical surface vertices per hemisphere). Alternatively, provide
<code>sphere_target_fname</code> which will override <code>resamp_res</code>.
</p>
<p>In general, <code>resamp_res</code> should be used when the target file will be
in registration with the spheres created by the Workbench command
<code>-surface-create-sphere</code>, and <code>sphere_target_fname</code> should be
used when it is not compatible.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_resamp_method">resamp_method</code></td>
<td>
<p><code>"barycentric"</code> (default) or <code>"adaptive"</code>
resampling. These options correspond to the Workbench command options
<code>"BARYCENTRIC"</code> and <code>"ADAP_BARY_AREA"</code>, respectively.
</p>
<p>While adaptive resampling is recommended for metric or label
data, it requires that <code>area_original_fname</code> be provided.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_area_original_fname">area_original_fname</code>, <code id="resample_gifti_+3A_area_target_fname">area_target_fname</code></td>
<td>
<p>File paths to the surfaces to
use for vertex area correction during adaptive resampling. (Ignored if
resampling with the barycentric method.) <code>area_original_fname</code> should
match the current resolution of the data, and <code>area_target_fname</code>
should match <code>resamp_res</code>. If <code>area_target_fname</code> is not provided,
<code>area_original_fname</code> will be resampled with the barycentric method,
and the result will be used as <code>area_target_fname</code>.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_roicortex_original_fname">ROIcortex_original_fname</code></td>
<td>
<p>The name of the ROI file corresponding to
<code>original_fname</code>. Leave as <code>NULL</code> (default) if this doesn't exist
or shouldn't be resampled.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_roicortex_target_fname">ROIcortex_target_fname</code></td>
<td>
<p>The name of the resampled ROI file. Only
applicable if <code>ROIcortex_original_fname</code> is provided.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_sphere_original_fname">sphere_original_fname</code>, <code id="resample_gifti_+3A_sphere_target_fname">sphere_target_fname</code></td>
<td>
<p>File paths to the sphere
surfaces in the original and target resolutions. If possible, the simpler
arguments <code>original_res</code> and <code>resamp_res</code> can be used instead. But
those depend on the surface being compatible with that created by
<code>-surface-create-sphere</code>, which isn't always true. Therefore
<code>sphere_original_fname</code> and <code>sphere_target_fname</code> can be used if
needed.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_read_dir">read_dir</code></td>
<td>
<p>Directory to append to the path of every file name in
<code>original_fname</code> and <code>ROIcortex_original_fname</code>. If <code>NULL</code>
(default), do not append any directory to the path.</p>
</td></tr>
<tr><td><code id="resample_gifti_+3A_write_dir">write_dir</code></td>
<td>
<p>Directory to append to the path of every file name in
<code>target_fname</code> and <code>ROIcortex_target_fname</code>. If <code>NULL</code>
(default), do not append any directory to the path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resampled GIFTI file name, invisibly
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-metric-resample"</code>, <code>"-label-resample"</code>,
and/or <code>"-surface-resample"</code> Workbench commands, depending on the input.
</p>


<h3>See Also</h3>

<p>Other gifting: 
<code><a href="#topic+remap_gifti">remap_gifti</a>()</code>,
<code><a href="#topic+smooth_gifti">smooth_gifti</a>()</code>
</p>

<hr>
<h2 id='resample_surf'>Resample a <code>"surf"</code> object</h2><span id='topic+resample_surf'></span>

<h3>Description</h3>

<p>Resample a <code>"surf"</code> object by writing it to a GIFTI, using the Connectome
Workbench to resample it, and then reading the new file. The barycentric
resampling method, which is recommended for anatomical surfaces, will be
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_surf(surf, resamp_res, hemisphere = c("left", "right"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_surf_+3A_surf">surf</code></td>
<td>
<p>A <code>"surf"</code> object</p>
</td></tr>
<tr><td><code id="resample_surf_+3A_resamp_res">resamp_res</code></td>
<td>
<p>The desired resolution</p>
</td></tr>
<tr><td><code id="resample_surf_+3A_hemisphere">hemisphere</code></td>
<td>
<p><code>"left"</code> or <code>"right"</code>. Only used if not indicated by
<code>surf$hemisphere</code>. An error will be raised if it does not match the
hemisphere indicated in the intermediate written GIFTI.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new <code>"surf"</code>
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-surface-resample"</code> Workbench command.
</p>


<h3>See Also</h3>

<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='rgl_interactive_plots_Description'>Navigating and Embedding the Interactive Plots</h2><span id='topic+rgl_interactive_plots_Description'></span>

<h3>Description</h3>

<p>Navigating and Embedding the Interactive Plots
</p>


<h3>Navigating and Embedding the Interactive Plots</h3>

<p>To navigate the interactive Open GL window and html widget, left click and
drag the cursor to rotate the meshes. Use the scroll wheel or right click
and drag to zoom. Press the scroll wheel and drag to change the field-of-view.
For Open GL windows, execute
<code><a href="rgl.html#topic+snapshot">snapshot</a></code> to save the current window as a .png file,
<code><a href="rgl.html#topic+open3d">close3d</a></code> to close the window, and
<code><a href="rgl.html#topic+viewpoint">view3d</a></code> to programmatically control the
perspective.
</p>
<p>To embed an interactive plot in an R Markdown document, first execute
<code>rgl::setupKnitr()</code> to prepare the document for embedding the widget.
Then execute the plot command as you normally would to create a widget (i.e.
without specifying <code>fname</code>, and by requesting more than one <code>idx</code>
or by setting <code>widget</code> to <code>TRUE</code>). When the R Markdown document is
knitted, the interactive widget should be displayed below the chunk in which
the plot command was executed. See the vignette for an example.
</p>

<hr>
<h2 id='rgl_static_plots_Description'>Embedding the Static Plots</h2><span id='topic+rgl_static_plots_Description'></span>

<h3>Description</h3>

<p>Embedding the Static Plots
</p>


<h3>Embedding the Static Plots</h3>

<p>To embed a static plot in an R Markdown document, first execute
<code>rgl::setupKnitr()</code> to prepare the document for embedding the snapshot
of the Open GL window. Then execute the plot command as you normally would
to create an Open GL window (i.e. without specifying <code>fname</code>, and by
requesting only one <code>idx</code>). In the options for the chunk in which the
plot command is executed, set <code>rgl=TRUE, format="png"</code>. You can also
control the image dimensions here e.g. <code>fig.height=3.8, fig.width=5</code>.
When the R Markdown document is knitted, the static plots should be
displayed below the chunk in which the plot command was executed. See the
vignette for an example.
</p>

<hr>
<h2 id='ROI_brainstructures_Param_LR'>ROI_brainstructures</h2><span id='topic+ROI_brainstructures_Param_LR'></span>

<h3>Description</h3>

<p>ROI_brainstructures
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROI_brainstructures_Param_LR_+3A_roi_brainstructures">ROI_brainstructures</code></td>
<td>
<p>Character vector indicating which ROIs should be
obtained. <code>NULL</code> (default) to not get any ROIs. Otherwise, this should
be a subset of the <code>brainstructures</code> argument.
</p>
<p>ROIs are typically the medial wall masks for the left and right cortex, and
the subcortical mask for the subcortex.</p>
</td></tr>
</table>

<hr>
<h2 id='rotate_surf'>Rotate a <code>"surf"</code> object</h2><span id='topic+rotate_surf'></span>

<h3>Description</h3>

<p>Rotate a <code>"surf"</code>. Can be used to adjust the mesh orientation prior
to <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_surf(surf, r1 = 0, r2 = 0, r3 = 0, units = c("radians", "degrees"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_surf_+3A_surf">surf</code></td>
<td>
<p>The <code>"surf"</code> object: see <code><a href="#topic+is.surf">is.surf</a></code>.</p>
</td></tr>
<tr><td><code id="rotate_surf_+3A_r1">r1</code>, <code id="rotate_surf_+3A_r2">r2</code>, <code id="rotate_surf_+3A_r3">r3</code></td>
<td>
<p>Angle to rotate along the first, second, and third column's
axis, in <code>units</code> (e.g. changing <code>r1</code> will change the vertex positions
in the second and third dimensions/columns, since the mesh is being rotated
with respect to the first column's axis). Default: <code>0</code>.
</p>
<p>With <code>view_xifti_surface</code> and other mesh rendering functions that
use <code>rgl</code>, these rotations seem to correspond to yaw, pitch, and
roll, respectively.</p>
</td></tr>
<tr><td><code id="rotate_surf_+3A_units">units</code></td>
<td>
<p><code>"radians"</code> (default) or <code>"degrees"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rotated <code>"surf"</code>
</p>


<h3>See Also</h3>

<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='ROY_BIG_BL'>&quot;ROY_BIG_BL&quot; color palette</h2><span id='topic+ROY_BIG_BL'></span>

<h3>Description</h3>

<p>&quot;ROY_BIG_BL&quot;, the default palette from the Connectome Workbench.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROY_BIG_BL(min = 0, max = 1, mid = NULL, half = NULL, pos_half = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROY_BIG_BL_+3A_min">min</code></td>
<td>
<p>The minimum value for the color mapping. As in the original
palette, the last color (aqua) is actually placed at the bottom .5\
the minimum and maximum. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="ROY_BIG_BL_+3A_max">max</code></td>
<td>
<p>The maximum value for the color mapping. If this value is lower
than the minimum, the color mapping will be reversed. If this is equal to
the minimum, a palette with only the color black will be returned.
Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="ROY_BIG_BL_+3A_mid">mid</code></td>
<td>
<p>(Optional) The midpoint value for the color mapping. If
<code>NULL</code> (default), the true midpoint is used.</p>
</td></tr>
<tr><td><code id="ROY_BIG_BL_+3A_half">half</code></td>
<td>
<p><code>"positive"</code> or <code>"negative"</code> to use the positive half
(black &ndash;&gt; red &ndash;&gt; yellow) or negative half (black &ndash;&gt; blue &ndash;&gt; purple &ndash;&gt;
green &ndash;&gt; aqua) only. <code>NULL</code> (default) or <code>FALSE</code> to use entire
palette.</p>
</td></tr>
<tr><td><code id="ROY_BIG_BL_+3A_pos_half">pos_half</code></td>
<td>
<p>Deprecated. Use <code>half</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Yields the landmark color hex codes and values for the &quot;ROY_BIG_BL&quot; palette.
This is the same color palette as the default Connectome Workbench palette.
Source: https://github.com/Washington-University/workbench/blob/master/src/Files/PaletteFile.cxx
</p>


<h3>Value</h3>

<p>A data.frame with two columns: <code>"color"</code> (character: color hex
codes) and <code>"value"</code> (numeric)
</p>


<h3>See Also</h3>

<p>Other coloring: 
<code><a href="#topic+expand_color_pal">expand_color_pal</a>()</code>,
<code><a href="#topic+make_color_pal">make_color_pal</a>()</code>,
<code><a href="#topic+use_color_pal">use_color_pal</a>()</code>
</p>

<hr>
<h2 id='run_wb_cmd'>Wrapper for Connectome Workbench Commands</h2><span id='topic+run_wb_cmd'></span>

<h3>Description</h3>

<p>Runs a Connectome Workbench command that has already been formatted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_wb_cmd(cmd, intern = TRUE, ignore.stdout = NULL, ignore.stderr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_wb_cmd_+3A_cmd">cmd</code></td>
<td>
<p>The full command, beginning after the workbench path.</p>
</td></tr>
<tr><td><code id="run_wb_cmd_+3A_intern">intern</code></td>
<td>
<p>Return printed output? If <code>FALSE</code>, return
logical indicating success instead. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="run_wb_cmd_+3A_ignore.stdout">ignore.stdout</code>, <code id="run_wb_cmd_+3A_ignore.stderr">ignore.stderr</code></td>
<td>
<p>The &quot;ignore.stdout&quot; and &quot;ignore.stderr&quot;
arguments to <code><a href="base.html#topic+system">system</a></code>. Should be logical or <code>NULL</code>.
If <code>NULL</code> (default), messages will be controlled by
<code>ciftiTools.getOption("suppress_msgs")</code> and errors will not be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>intern==TRUE</code>, the printed output of the command.
If <code>intern==FALSE</code>, a logical indicating if the command finished
successfully.
</p>

<hr>
<h2 id='S3_Math'><code>"xifti"</code> S3 Math methods</h2><span id='topic+S3_Math'></span><span id='topic+Math.xifti'></span>

<h3>Description</h3>

<p>Math methods for <code>"xifti"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xifti'
Math(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S3_Math_+3A_x">x</code></td>
<td>
<p>The <code>"xifti"</code></p>
</td></tr>
<tr><td><code id="S3_Math_+3A_...">...</code></td>
<td>
<p>Additional arguments to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="#topic+transform_xifti">transform_xifti</a></code>.
</p>

<hr>
<h2 id='S3_Ops'><code>"xifti"</code> S3 Ops methods</h2><span id='topic+S3_Ops'></span><span id='topic+Ops.xifti'></span>

<h3>Description</h3>

<p>Ops methods for <code>"xifti"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xifti'
Ops(e1, e2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S3_Ops_+3A_e1">e1</code>, <code id="S3_Ops_+3A_e2">e2</code></td>
<td>
<p>The arguments to the operation. <code>"xifti"</code> objects will be converted to matrices temporarily</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="#topic+transform_xifti">transform_xifti</a></code>.
</p>

<hr>
<h2 id='S3_Summary'><code>"xifti"</code> S3 Summary methods</h2><span id='topic+S3_Summary'></span><span id='topic+Summary.xifti'></span>

<h3>Description</h3>

<p>Summary methods for <code>"xifti"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xifti'
Summary(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S3_Summary_+3A_...">...</code></td>
<td>
<p>The <code>"xifti"</code> and additional numeric arguments will be converted to matrices</p>
</td></tr>
<tr><td><code id="S3_Summary_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove <code>NA</code> values? Default: <code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='scale_xifti'>Scale CIFTI</h2><span id='topic+scale_xifti'></span>

<h3>Description</h3>

<p>Scale CIFTI data. Similar to <code><a href="base.html#topic+scale">scale</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_xifti(xifti, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="scale_xifti_+3A_center">center</code>, <code id="scale_xifti_+3A_scale">scale</code></td>
<td>
<p>Arguments to <code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>"xifti"</code> with scaled columns.
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='select_xifti'>Select columns of a <code>"xifti"</code></h2><span id='topic+select_xifti'></span>

<h3>Description</h3>

<p>Select column indices to keep in a <code>"xifti"</code>. Can also be used to
reorder the columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_xifti(xifti, idx, add_meta = "select")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="select_xifti_+3A_idx">idx</code></td>
<td>
<p>The column indices to keep, in order.</p>
</td></tr>
<tr><td><code id="select_xifti_+3A_add_meta">add_meta</code></td>
<td>
<p>Add <code>idx</code> to <code>xifti$meta$cifti$misc[[add_meta]]</code>
for reference. Default: <code>"select"</code>. If <code>NULL</code> or an empty string,
do not add a metadata entry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>"xifti"</code> with only the selected columns.
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='separate_cifti'>Separate a CIFTI file</h2><span id='topic+separate_cifti'></span><span id='topic+separateCIfTI'></span><span id='topic+separatecii'></span>

<h3>Description</h3>

<p>Separate a CIFTI file into GIFTI files for the cortical data and NIFTI files
for the subcortical data and labels. ROIs can also be written to indicate
the medial wall mask (cortex) and volume mask (subcortex). This uses the
Connectome Workbench command <code>-cifti-separate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_cifti(
  cifti_fname,
  brainstructures = NULL,
  cortexL_fname = NULL,
  cortexR_fname = NULL,
  subcortVol_fname = NULL,
  subcortLabs_fname = NULL,
  ROI_brainstructures = "all",
  ROIcortexL_fname = NULL,
  ROIcortexR_fname = NULL,
  ROIsubcortVol_fname = NULL,
  write_dir = NULL
)

separateCIfTI(
  cifti_fname,
  brainstructures = c("left", "right"),
  cortexL_fname = NULL,
  cortexR_fname = NULL,
  subcortVol_fname = NULL,
  subcortLabs_fname = NULL,
  ROI_brainstructures = "all",
  ROIcortexL_fname = NULL,
  ROIcortexR_fname = NULL,
  ROIsubcortVol_fname = NULL,
  write_dir = NULL
)

separatecii(
  cifti_fname,
  brainstructures = c("left", "right"),
  cortexL_fname = NULL,
  cortexR_fname = NULL,
  subcortVol_fname = NULL,
  subcortLabs_fname = NULL,
  ROI_brainstructures = "all",
  ROIcortexL_fname = NULL,
  ROIcortexR_fname = NULL,
  ROIsubcortVol_fname = NULL,
  write_dir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_cifti_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
<tr><td><code id="separate_cifti_+3A_brainstructures">brainstructures</code></td>
<td>
<p>(Optional) character vector indicating a subset of
brain structure(s) to write: <code>"left"</code> cortex, <code>"right"</code> cortex,
and/or <code>"subcortical"</code> structures. Can also be <code>"all"</code> to write
out all existing brain structures. Default: <code>c("left","right")</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_+3A_cortexl_fname">cortexL_fname</code>, <code id="separate_cifti_+3A_cortexr_fname">cortexR_fname</code></td>
<td>
<p>(Optional) GIFTI file names
(*.[func/label].gii) to save the [left/right] cortex data to.
dtseries and dscalar files should use &quot;func&quot;, whereas dlabel files should
use &quot;label&quot;.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*[L/R].\[func/label\].gii"</code>, where * is the file name component of
<code>cifti_fname</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_+3A_subcortvol_fname">subcortVol_fname</code>, <code id="separate_cifti_+3A_subcortlabs_fname">subcortLabs_fname</code></td>
<td>
<p>(Optional) NIFTI file names to save
the subcortical [volume/labels] to. Provide both or neither.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*[/.labels].nii"</code>, where * is the file name component of
<code>cifti_fname</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_+3A_roi_brainstructures">ROI_brainstructures</code></td>
<td>
<p>Which ROIs should be obtained? <code>"all"</code>
(default) to obtain ROIs for each of the <code>brainstructures</code>. <code>NULL</code>
to not obtain any ROIs. This should be a subset of <code>brainstructures</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_+3A_roicortexl_fname">ROIcortexL_fname</code>, <code id="separate_cifti_+3A_roicortexr_fname">ROIcortexR_fname</code></td>
<td>
<p>(Optional) GIFTI file names
(*.[func/label].gii) to save the [left/right] cortex ROI to.
dtseries and dscalar files should use &quot;func&quot;, whereas dlabel files should
use &quot;label&quot;.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*ROI_[L/R].\[func/label\].gii"</code>, where * is the file name component of
<code>cifti_fname</code>.
</p>
<p>The cortical ROIs typically represent the medial wall
mask, with values of 1 for in-ROI (non-medial wall) vertices and 0 for
out-of-ROI (medial wall) vertices. Will be written in <code>write_dir</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_+3A_roisubcortvol_fname">ROIsubcortVol_fname</code></td>
<td>
<p>(Optional) NIFTI file names to save
the subcortical ROI to.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*ROI.nii"</code>, where * is the file name component of
<code>cifti_fname</code>.
</p>
<p>The subcortical ROI typically represents the volumetric
mask for the entire subcortical structure, with values of 1 for in-ROI
(in subcortex) voxels and 0 for out-of-ROI (not in subcortex) voxels. Will
be written in <code>write_dir</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_+3A_write_dir">write_dir</code></td>
<td>
<p>(Optional) A path to an existing directory. If provided,
every component in the <code>"xifti"</code> will be written to this directory,
using automatically-generated names if their <code>*_fname</code> argument was
not provided. Otherwise if <code>write_dir</code> is <code>NULL</code>, only the
components for which their <code>*_fname</code> was provided will be written.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time unit, start, and step (dtseries files) will not be written to the GIFTI/NIFTIs.
Column names (dscalar files) will not be written to the GIFTIs, as well as label
names and colors (dlabel files). (Haven't checked the NIFTIs yet.)
</p>
<p>ROI/medial wall behavior: If there are 32k vertices in the left cortex with
3k representing the medial wall, then both <code>cortexL_fname</code> and
<code>ROIcortexL_fname</code> will have 32k entries, 3k of which having a value of
0 indicating the medial wall. The non-medial wall entries will have the
data values in <code>cortexL_fname</code> and a value of 1 in
<code>ROIcortexL_fname</code>. Thus, exporting <code>ROIcortexL_fname</code> is vital if
the data values include 0, because 0-valued non-medial wall vertices and
medial wall vertices cannot be distinguished from one another within
<code>cortexL_fname</code> alone.
</p>


<h3>Value</h3>

<p>A named character vector with the file paths to the written
NIFTI and GIFTI files
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-cifti-separate"</code> Workbench command.
</p>


<h3>See Also</h3>

<p>Other writing: 
<code><a href="#topic+write_cifti">write_cifti</a>()</code>,
<code><a href="#topic+write_metric_gifti">write_metric_gifti</a>()</code>,
<code><a href="#topic+write_subcort_nifti">write_subcort_nifti</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>,
<code><a href="#topic+write_xifti2">write_xifti2</a>()</code>
</p>

<hr>
<h2 id='separate_cifti_files'>Separate CIFTI: file names</h2><span id='topic+separate_cifti_files'></span>

<h3>Description</h3>

<p>File paths for writing GIFTI and NIFTI files from a CIFTI or <code>"xifti"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_cifti_files(
  bs_present,
  intent = 3006,
  brainstructures = NULL,
  cortexL_fname = NULL,
  cortexR_fname = NULL,
  subcortVol_fname = NULL,
  subcortLabs_fname = NULL,
  ROI_brainstructures = "all",
  ROIcortexL_fname = NULL,
  ROIcortexR_fname = NULL,
  ROIsubcortVol_fname = NULL,
  write_dir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_cifti_files_+3A_bs_present">bs_present</code></td>
<td>
<p>The brain structures actually present in the CIFTI or
<code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="separate_cifti_files_+3A_intent">intent</code></td>
<td>
<p>3002 (default), 3006, or 3007</p>
</td></tr>
<tr><td><code id="separate_cifti_files_+3A_brainstructures">brainstructures</code></td>
<td>
<p>(Optional) character vector indicating a subset of
brain structure(s) to write: <code>"left"</code> cortex, <code>"right"</code> cortex,
and/or <code>"subcortical"</code> structures. Can also be <code>"all"</code> to write
out all existing brain structures. Default: <code>c("left","right")</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_files_+3A_cortexl_fname">cortexL_fname</code>, <code id="separate_cifti_files_+3A_cortexr_fname">cortexR_fname</code></td>
<td>
<p>(Optional) GIFTI file names
(*.[func/label].gii) to save the [left/right] cortex data to.
dtseries and dscalar files should use &quot;func&quot;, whereas dlabel files should
use &quot;label&quot;.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*[L/R].\[func/label\].gii"</code>, where * is the file name component of
<code>cifti_fname</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_files_+3A_subcortvol_fname">subcortVol_fname</code>, <code id="separate_cifti_files_+3A_subcortlabs_fname">subcortLabs_fname</code></td>
<td>
<p>(Optional) NIFTI file names to save
the subcortical [volume/labels] to. Provide both or neither.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*[/.labels].nii"</code>, where * is the file name component of
<code>cifti_fname</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_files_+3A_roi_brainstructures">ROI_brainstructures</code></td>
<td>
<p>Which ROIs should be obtained? <code>"all"</code>
(default) to obtain ROIs for each of the <code>brainstructures</code>. <code>NULL</code>
to not obtain any ROIs. This should be a subset of <code>brainstructures</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_files_+3A_roicortexl_fname">ROIcortexL_fname</code>, <code id="separate_cifti_files_+3A_roicortexr_fname">ROIcortexR_fname</code></td>
<td>
<p>(Optional) GIFTI file names
(*.[func/label].gii) to save the [left/right] cortex ROI to.
dtseries and dscalar files should use &quot;func&quot;, whereas dlabel files should
use &quot;label&quot;.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*ROI_[L/R].\[func/label\].gii"</code>, where * is the file name component of
<code>cifti_fname</code>.
</p>
<p>The cortical ROIs typically represent the medial wall
mask, with values of 1 for in-ROI (non-medial wall) vertices and 0 for
out-of-ROI (medial wall) vertices. Will be written in <code>write_dir</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_files_+3A_roisubcortvol_fname">ROIsubcortVol_fname</code></td>
<td>
<p>(Optional) NIFTI file names to save
the subcortical ROI to.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*ROI.nii"</code>, where * is the file name component of
<code>cifti_fname</code>.
</p>
<p>The subcortical ROI typically represents the volumetric
mask for the entire subcortical structure, with values of 1 for in-ROI
(in subcortex) voxels and 0 for out-of-ROI (not in subcortex) voxels. Will
be written in <code>write_dir</code>.</p>
</td></tr>
<tr><td><code id="separate_cifti_files_+3A_write_dir">write_dir</code></td>
<td>
<p>(Optional) A path to an existing directory. If provided,
every component in the <code>"xifti"</code> will be written to this directory,
using automatically-generated names if their <code>*_fname</code> argument was
not provided. Otherwise if <code>write_dir</code> is <code>NULL</code>, only the
components for which their <code>*_fname</code> was provided will be written.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>write_dir</code> is <code>NULL</code>, only components with provided file names
will be written. If <code>write_dir</code> is not <code>NULL</code>, files for all
existing brain components will be written to that directory.
</p>


<h3>Value</h3>

<p>List of three: <code>do</code>, <code>ROI_do</code>, and <code>sep_fnames</code>
</p>

<hr>
<h2 id='separate_cifti_wrapper'><code>separate_cifti</code> wrapper</h2><span id='topic+separate_cifti_wrapper'></span>

<h3>Description</h3>

<p>Calls <code>separate_cifti</code> using the file names listed in the
argument <code>sep_fnames</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_cifti_wrapper(
  cifti_fname,
  brainstructures = NULL,
  ROI_brainstructures = NULL,
  sep_fnames = NULL,
  write_dir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_cifti_wrapper_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
<tr><td><code id="separate_cifti_wrapper_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
to obtain: <code>"left"</code> (left cortex), <code>"right"</code> (right cortex)
and/or <code>"subcortical"</code> (subcortex and cerebellum). Can also be
<code>"all"</code> (obtain all three brain structures). Default:
<code>c("left","right")</code> (cortex only).
</p>
<p>If a brain structure is indicated but does not exist in the CIFTI file, a
warning will occur and that brain structure will be skipped.</p>
</td></tr>
<tr><td><code id="separate_cifti_wrapper_+3A_roi_brainstructures">ROI_brainstructures</code></td>
<td>
<p>Character vector indicating which ROIs should be
obtained. <code>NULL</code> (default) to not get any ROIs. Otherwise, this should
be a subset of the <code>brainstructures</code> argument.
</p>
<p>ROIs are typically the medial wall masks for the left and right cortex, and
the subcortical mask for the subcortex.</p>
</td></tr>
<tr><td><code id="separate_cifti_wrapper_+3A_sep_fnames">sep_fnames</code></td>
<td>
<p>Where to write the separated files (override
their default file names). This is a named list
where each entry's name is a file type label, and each entry's value
is a file name indicating where to write the corresponding separated file.
The recognized file type labels are: &quot;cortexL&quot;, &quot;cortexR&quot;,
&quot;ROIcortexL&quot;, &quot;ROIcortexR&quot;, &quot;subcortVol&quot;, and &quot;subcortLabs&quot;.
</p>
<p>Entry values can be <code>NULL</code>, in which case a default file name will be
used: see <code><a href="#topic+cifti_component_suffix">cifti_component_suffix</a></code>. Default file names
will also be used for files that need to be separated/written but without a
corresponding entry in <code>sep_fnames</code>.
</p>
<p>Entries in <code>sep_fnames</code> will be ignored if they are not needed
based on <code>[ROI_]brainstructures</code>. For example, if
<code>brainstructures="left"</code>, then <code>sep_fnames$cortexR</code> will be
ignored if specified.
</p>
<p>The <code>write_dir</code> argument can be used to place each separated file in
the same directory.</p>
</td></tr>
<tr><td><code id="separate_cifti_wrapper_+3A_write_dir">write_dir</code></td>
<td>
<p>Where should the separate files be placed? <code>NULL</code>
(default) will write them to the current working directory.
</p>
<p><code>write_dir</code> must already exist, or an error will occur.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently used by <code>read_cifti</code> and <code>resample_cifti</code>.
</p>


<h3>Value</h3>

<p>The return value of the <code>separate_cifti</code> call
</p>

<hr>
<h2 id='set_names_xifti'>Set <code>"xifti"</code> column names</h2><span id='topic+set_names_xifti'></span>

<h3>Description</h3>

<p>Change the column names of a <code>"dscalar"</code> or <code>"dlabel"</code>
<code>"xifti"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_names_xifti(xifti, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_names_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"dscalar"</code> or <code>"dlabel"</code> <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="set_names_xifti_+3A_names">names</code></td>
<td>
<p>The new column names, as a character vector with length
equal to the same number of columns in <code>xifti</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>xifti</code> with the new column names.
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>

<hr>
<h2 id='smooth_cifti'>Smooth CIFTI data</h2><span id='topic+smooth_cifti'></span><span id='topic+smoothCIfTI'></span><span id='topic+smoothcii'></span><span id='topic+smooth_xifti'></span>

<h3>Description</h3>

<p>Spatially smooth the metric data of a CIFTI file or <code>"xifti"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_cifti(
  x,
  cifti_target_fname = NULL,
  surf_FWHM = 5,
  vol_FWHM = 3,
  surfL_fname = NULL,
  surfR_fname = NULL,
  cerebellum_fname = NULL,
  subcortical_zeroes_as_NA = FALSE,
  cortical_zeroes_as_NA = FALSE,
  subcortical_merged = FALSE
)

smoothCIfTI(
  x,
  cifti_target_fname = NULL,
  surf_FWHM = 5,
  vol_FWHM = 5,
  surfL_fname = NULL,
  surfR_fname = NULL,
  cerebellum_fname = NULL,
  subcortical_zeroes_as_NA = FALSE,
  cortical_zeroes_as_NA = FALSE,
  subcortical_merged = FALSE
)

smoothcii(
  x,
  cifti_target_fname = NULL,
  surf_FWHM = 5,
  vol_FWHM = 5,
  surfL_fname = NULL,
  surfR_fname = NULL,
  cerebellum_fname = NULL,
  subcortical_zeroes_as_NA = FALSE,
  cortical_zeroes_as_NA = FALSE,
  subcortical_merged = FALSE
)

smooth_xifti(
  x,
  cifti_target_fname = NULL,
  surf_FWHM = 5,
  vol_FWHM = 5,
  surfL_fname = NULL,
  surfR_fname = NULL,
  cerebellum_fname = NULL,
  subcortical_zeroes_as_NA = FALSE,
  cortical_zeroes_as_NA = FALSE,
  subcortical_merged = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_cifti_+3A_x">x</code></td>
<td>
<p>The CIFTI file name or <code>"xifti"</code> object to smooth.</p>
</td></tr>
<tr><td><code id="smooth_cifti_+3A_cifti_target_fname">cifti_target_fname</code></td>
<td>
<p>File name for the smoothed CIFTI. If
<code>NULL</code>, will be written to &quot;smoothed.d*.nii&quot; in the current working
directory if <code>x</code> was a CIFTI file, and in a temporary directory if
<code>x</code> was a <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="smooth_cifti_+3A_surf_fwhm">surf_FWHM</code>, <code id="smooth_cifti_+3A_vol_fwhm">vol_FWHM</code></td>
<td>
<p>The full width at half maximum (FWHM) parameter
for the gaussian surface or volume smoothing kernel, in mm. Default: <code>5</code>
for cortex (surface) and <code>3</code> for subcortex (volume).</p>
</td></tr>
<tr><td><code id="smooth_cifti_+3A_surfl_fname">surfL_fname</code>, <code id="smooth_cifti_+3A_surfr_fname">surfR_fname</code></td>
<td>
<p>(Required if the corresponding cortex is
present) Surface GIFTI files for the left and right cortical surfaces. If
not provided, the surfaces in <code>x</code> are used, but if those are also not
present, the default surfaces will be used.</p>
</td></tr>
<tr><td><code id="smooth_cifti_+3A_cerebellum_fname">cerebellum_fname</code></td>
<td>
<p>(Optional) Surface GIFTI file for the cerebellar surface</p>
</td></tr>
<tr><td><code id="smooth_cifti_+3A_subcortical_zeroes_as_na">subcortical_zeroes_as_NA</code>, <code id="smooth_cifti_+3A_cortical_zeroes_as_na">cortical_zeroes_as_NA</code></td>
<td>
<p>Should zero-values in
the subcortical volume or cortex be treated as NA? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="smooth_cifti_+3A_subcortical_merged">subcortical_merged</code></td>
<td>
<p>Smooth across subcortical structure boundaries?
Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the CIFTI is a &quot;.dlabel&quot; file (intent 3007), then it will be converted
to a &quot;.dscalar&quot; file because the values will no longer be integer indices.
Unless the label values were ordinal, this is probably not desired so a
warning will be printed.
</p>
<p>Can accept a <code>"xifti"</code> object as well as a path to a CIFTI-file.
</p>
<p>Surfaces are required for each hemisphere in the CIFTI. If they are not
provided, the default inflated surfaces will be used.
</p>
<p>Conversion for sigma: <code class="reqn">\sigma \times 2 \times \sqrt(2 \times \log(2)) = FWHM</code>
</p>


<h3>Value</h3>

<p>The <code>cifti_target_fname</code>, invisibly, if <code>x</code> was a CIFTI
file name. A <code>"xifti"</code> object if <code>x</code> was a <code>"xifti"</code> object.
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-cifti-smoothing"</code> Workbench command.
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+transform_xifti">transform_xifti</a>()</code>
</p>
<p>Other common: 
<code><a href="#topic+is.cifti">is.cifti</a>()</code>,
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+view_xifti">view_xifti</a>()</code>,
<code><a href="#topic+write_cifti">write_cifti</a>()</code>
</p>

<hr>
<h2 id='smooth_gifti'>Smooth a metric GIFTI file</h2><span id='topic+smooth_gifti'></span><span id='topic+smoothGIfTI'></span><span id='topic+smoothgii'></span>

<h3>Description</h3>

<p>Smooths metric GIFTI data along the cortical surface. The results are written
to a new GIFTI file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_gifti(
  original_fname,
  target_fname,
  surf_fname = NULL,
  surf_FWHM = 5,
  hemisphere = c("left", "right"),
  ROI_fname = NULL,
  zeroes_as_NA = FALSE
)

smoothGIfTI(
  original_fname,
  target_fname,
  surf_fname,
  surf_FWHM = 5,
  zeroes_as_NA = FALSE
)

smoothgii(
  original_fname,
  target_fname,
  surf_fname,
  surf_FWHM = 5,
  zeroes_as_NA = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_gifti_+3A_original_fname">original_fname</code></td>
<td>
<p>The GIFTI file to smooth.</p>
</td></tr>
<tr><td><code id="smooth_gifti_+3A_target_fname">target_fname</code></td>
<td>
<p>Where to save the smoothed file.</p>
</td></tr>
<tr><td><code id="smooth_gifti_+3A_surf_fname">surf_fname</code></td>
<td>
<p>Surface GIFTI files cortical surface along which to smooth.
If not provided, the default inflated surfaces will be used.</p>
</td></tr>
<tr><td><code id="smooth_gifti_+3A_surf_fwhm">surf_FWHM</code></td>
<td>
<p>The full width at half maximum (FWHM) parameter
for the gaussian surface smoothing kernel, in mm. Default: <code>5</code></p>
</td></tr>
<tr><td><code id="smooth_gifti_+3A_hemisphere">hemisphere</code></td>
<td>
<p>The cortex hemisphere: <code>"left"</code> or <code>"right"</code>.
Only used if <code>surf_fname</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="smooth_gifti_+3A_roi_fname">ROI_fname</code></td>
<td>
<p>The ROI to limit smoothing to, as a metric file. This is
used to exclude the medial wall from smoothing. If not provided (default)
all the data is smoothed across the surface.</p>
</td></tr>
<tr><td><code id="smooth_gifti_+3A_zeroes_as_na">zeroes_as_NA</code></td>
<td>
<p>Should zero-values be treated as NA? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The smoothed GIFTI file name, invisibly
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-metric-smoothing"</code> Workbench command.
</p>


<h3>See Also</h3>

<p>Other gifting: 
<code><a href="#topic+remap_gifti">remap_gifti</a>()</code>,
<code><a href="#topic+resample_gifti">resample_gifti</a>()</code>
</p>

<hr>
<h2 id='substructure_table'>Substructure table</h2><span id='topic+substructure_table'></span>

<h3>Description</h3>

<p>Table of labels for cortex hemispheres (left and right) and subcortical
substructures. The names used by the CIFTI format and the names used by
<code>ciftiTools</code> are given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substructure_table()
</code></pre>


<h3>Details</h3>

<p>The names used by <code>ciftiTools</code> are based on those in
<code>FT_READ_CIFTI</code> from the FieldTrip MATLAB toolbox.
</p>


<h3>Value</h3>

<p>A data.frame with each substructure along the rows. The first
column gives the CIFTI format name and the second column gives the
<code>ciftiTools</code> name.
</p>

<hr>
<h2 id='summary.surf'>Summarize a <code>"surf"</code> object</h2><span id='topic+summary.surf'></span><span id='topic+print.summary.surf'></span><span id='topic+print.surf'></span>

<h3>Description</h3>

<p>Summary method for class &quot;surf&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'surf'
summary(object, ...)

## S3 method for class 'summary.surf'
print(x, ...)

## S3 method for class 'surf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.surf_+3A_object">object</code></td>
<td>
<p>Object of class &quot;surf&quot;.
See <code><a href="#topic+is.surf">is.surf</a></code> and <code><a href="#topic+make_surf">make_surf</a></code>.</p>
</td></tr>
<tr><td><code id="summary.surf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.surf_+3A_x">x</code></td>
<td>
<p>Object of class &quot;surf&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.xifti'>Summarize a <code>"xifti"</code> object</h2><span id='topic+summary.xifti'></span><span id='topic+print.summary.xifti'></span><span id='topic+print.xifti'></span>

<h3>Description</h3>

<p>Summary method for class <code>"xifti"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xifti'
summary(object, ...)

## S3 method for class 'summary.xifti'
print(x, ...)

## S3 method for class 'xifti'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.xifti_+3A_object">object</code></td>
<td>
<p>Object of class <code>"xifti"</code>.</p>
</td></tr>
<tr><td><code id="summary.xifti_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.xifti_+3A_x">x</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='supported_intents'>The NIFTI intents supported by <code>ciftiTools</code></h2><span id='topic+supported_intents'></span>

<h3>Description</h3>

<p>Table of CIFTI file types (NIFTI intents) supported by <code>ciftiTools</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supported_intents()
</code></pre>


<h3>Details</h3>

<p>See https://www.nitrc.org/forum/attachment.php?attachid=334&amp;group_id=454&amp;forum_id=1955
for information about the different NIFTI intents.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with each supported file type along the rows, and
column names &quot;extension&quot;, &quot;intent_code&quot;, &quot;value&quot;, and &quot;intent_name&quot;
</p>

<hr>
<h2 id='surf_area'>Surface area calculation</h2><span id='topic+surf_area'></span>

<h3>Description</h3>

<p>Calculate surface area of a <code>"surf"</code> object by vertex or face. Surface
area calculation by vertex matches the Workbench command
&quot;-surface-vertex-areas&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf_area(surf, by = c("vertex", "face"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surf_area_+3A_surf">surf</code></td>
<td>
<p>The <code>"surf"</code> object.</p>
</td></tr>
<tr><td><code id="surf_area_+3A_by">by</code></td>
<td>
<p><code>"vertex"</code> or <code>"face"</code>. For <code>"vertex"</code>, the result
is the area associated with each vertex: the sum the area of each triangular
face it is a part of, divided by three. For <code>"face"</code>, the result is
the surface area of each face.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of surface areas <code>by</code> vertex or face, in the same order
as how the vertices or faces are listed in <code>surf</code>. The units are the
square of the units of <code>surf$vertices</code>.
</p>


<h3>See Also</h3>

<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='surface_plot_Params'>Surface plot</h2><span id='topic+surface_plot_Params'></span>

<h3>Description</h3>

<p>Surface plot
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="surface_plot_Params_+3A_view">view</code></td>
<td>
<p>Which view to display: <code>"lateral"</code>, <code>"medial"</code>, or
<code>"both"</code>. If <code>NULL</code> (default), both views will be shown. Each view
will be plotted in a separate panel row.</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_widget">widget</code></td>
<td>
<p>Display the plot in an htmlwidget? Should be logical or
<code>NULL</code> (default), in which case a widget will be used only if needed
(<code>length(idx)&gt;1 &amp; isFALSE(fname)</code>, <code>fname</code> is a file path to an
.html file, or if <code>rgl.useNULL()</code>).</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_title">title</code></td>
<td>
<p>Optional title(s) for the plot(s). It will be printed at the top
in a separate subplot with 1/4 the height of the brain cortex subplots.
</p>
<p>Default: <code>NULL</code> will not use any title if <code>length(idx)==1</code>.
Otherwise, it will use the time index (&quot;.dtseries&quot;) or name
(.dscalar or .dlabel) of each data column.
</p>
<p>To use a custom title(s), use a length 1 character vector (same title for
each plot) or length <code>length(idx)</code> character vector (different title
for each plot). Set to <code>NULL</code> or an empty character to omit the title.
</p>
<p>If the title is non-empty but does not appear, try lowering <code>cex.title</code>.</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_fname">fname</code></td>
<td>
<p>Save the plot(s) (and color legend if applicable)?
</p>
<p>If <code>isFALSE(fname)</code> (default), no files will be written.
</p>
<p>If <code>fname</code> is a length-1 character vector ending in &quot;.html&quot;, an html
with an interactive widget will be written.
</p>
<p>If neither of the cases above apply, a png image will be written for each
<code>idx</code>. If <code>isTRUE(fname)</code> the files will be named by the
data column names (underscores will replace spaces). Or, set <code>fname</code> to a
length 1 character vector to name files by this suffix followed by the
<code>fname_suffix</code>. Or, set <code>fname</code> to a character vector with the same
length as <code>idx</code> to name the files exactly.</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_fname_suffix">fname_suffix</code></td>
<td>
<p>Either the data column names (<code>"names"</code>) or the
index value (<code>"idx"</code>).</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_cex.title">cex.title</code></td>
<td>
<p>Font size multiplier for the title. <code>NULL</code> (default)
will use <code>2</code> for titles less than 20 characters long, and smaller
sizes for increasingly longer titles.</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_text_color">text_color</code></td>
<td>
<p>Color for text in title and colorbar legend. Default:
<code>"black"</code>.</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_bg">bg</code></td>
<td>
<p>Background color. <code>NULL</code> will use <code>"white"</code>. Does not affect
the color legend or color bar if printed separately: those will always have
white backgrounds.</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_na_color">NA_color</code></td>
<td>
<p>The color for the medial wall and <code>NA</code> values. Default:
<code>"white"</code>. Also used to color the entire surface for <code>view_surf</code>.</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_alpha">alpha</code></td>
<td>
<p>Transparency value for mesh coloring, between 0 and 1. Default:
<code>1.0</code> (no transparency).</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_edge_color">edge_color</code></td>
<td>
<p>Outline each edge in this color. Default: <code>NULL</code> (do
not outline the edges).</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_vertex_color">vertex_color</code></td>
<td>
<p>Draw each vertex in this color. Default:
<code>"black"</code>. Vertices are only drawn if <code>vertex_size &gt; 0</code></p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_vertex_size">vertex_size</code></td>
<td>
<p>Draw each vertex with this size. Default: <code>0</code>
(do not draw the vertices).</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_material">material</code></td>
<td>
<p>A list of materials from <code><a href="rgl.html#topic+material3d">material3d</a></code>
to use. For example, <code>list(lit=FALSE, smooth=FALSE)</code> will use exact colors
from the color scale, rather than adding geometric shading and interpolating
vertex colors. If <code>NULL</code>, use defaults.</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_width">width</code>, <code id="surface_plot_Params_+3A_height">height</code></td>
<td>
<p>The dimensions of the RGL window, in pixels. If both are
<code>NULL</code> (default), these dimensions depend on type of output (Open GL
window or widget) and subplots (<code>hemisphere</code>, <code>view</code>, <code>title</code>,
and <code>slider_title</code>) and are chosen to be the largest plot within a
1500 x 700 area (Open GL window) or 600 x 700 area (widget) that maintains
a brain hemisphere subplot dimensions ratio of 10 x 7. Specifying only one
will set the other to maintain this aspect ratio. Both can be specified to
set the dimensions exactly, but note that the dimensions cannot be larger
than the screen resolution. (These arguments do not affect the size of the
legend, which cannot be controlled.)
</p>
<p>The plot will be taller than <code>height</code> to accommodate a title or color
bar.
</p>
<p>If multiple <code>idx</code> are being composited with <code>together</code>, these
arguments refer to a single <code>idx</code> within the composited plot, and not
the composited plot itself.</p>
</td></tr>
<tr><td><code id="surface_plot_Params_+3A_zoom">zoom</code></td>
<td>
<p>Adjust the sizes of the brain meshes. Default: <code>NULL</code> (will
be set to 0.6 or 160\
widget.)</p>
</td></tr>
</table>

<hr>
<h2 id='surfL_fname_Param'>surfL_fname</h2><span id='topic+surfL_fname_Param'></span>

<h3>Description</h3>

<p>surfL_fname
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfL_fname_Param_+3A_surfl_fname">surfL_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the left cortex.</p>
</td></tr>
</table>

<hr>
<h2 id='surfL_original_fname_Param'>surfL_original_fname</h2><span id='topic+surfL_original_fname_Param'></span>

<h3>Description</h3>

<p>surfL_original_fname
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfL_original_fname_Param_+3A_surfl_original_fname">surfL_original_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the left cortex.</p>
</td></tr>
</table>

<hr>
<h2 id='surfL_Param_optional'>surfL</h2><span id='topic+surfL_Param_optional'></span>

<h3>Description</h3>

<p>surfL
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfL_Param_optional_+3A_surfl">surfL</code></td>
<td>
<p>(Optional) Left brain surface model. Can be a file
path to a GIFTI surface geometry file (ends in &quot;*.surf.gii&quot;), a
<code>"gifti"</code> object representing surface geometry, or a <code>"surf"</code>
object.</p>
</td></tr>
</table>

<hr>
<h2 id='surfL_target_fname_Param'>surfL_target_fname</h2><span id='topic+surfL_target_fname_Param'></span>

<h3>Description</h3>

<p>surfL_target_fname
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfL_target_fname_Param_+3A_surfl_target_fname">surfL_target_fname</code></td>
<td>
<p>(Optional) Where to save the resampled GIFTI
surface geometry file representing the left cortex.</p>
</td></tr>
</table>

<hr>
<h2 id='surfR_fname_Param'>surfR_fname</h2><span id='topic+surfR_fname_Param'></span>

<h3>Description</h3>

<p>surfR_fname
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfR_fname_Param_+3A_surfr_fname">surfR_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the right cortex.</p>
</td></tr>
</table>

<hr>
<h2 id='surfR_original_fname_Param'>surfR_original_fname</h2><span id='topic+surfR_original_fname_Param'></span>

<h3>Description</h3>

<p>surfR_original_fname
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfR_original_fname_Param_+3A_surfr_original_fname">surfR_original_fname</code></td>
<td>
<p>(Optional) File path to a GIFTI surface geometry
file representing the right cortex.</p>
</td></tr>
</table>

<hr>
<h2 id='surfR_Param_optional'>surfR</h2><span id='topic+surfR_Param_optional'></span>

<h3>Description</h3>

<p>surfR
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfR_Param_optional_+3A_surfr">surfR</code></td>
<td>
<p>(Optional) Right brain surface model. Can be a file
path to a GIFTI surface geometry file (ends in &quot;*.surf.gii&quot;), a
<code>"gifti"</code> object representing surface geometry, or a <code>"surf"</code>
object.</p>
</td></tr>
</table>

<hr>
<h2 id='surfR_target_fname_Param'>surfR_target_fname</h2><span id='topic+surfR_target_fname_Param'></span>

<h3>Description</h3>

<p>surfR_target_fname
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfR_target_fname_Param_+3A_surfr_target_fname">surfR_target_fname</code></td>
<td>
<p>(Optional) Where to save the resampled GIFTI
surface geometry file representing the right cortex.</p>
</td></tr>
</table>

<hr>
<h2 id='sys_path'>Format a path for <code><a href="base.html#topic+system">system</a></code></h2><span id='topic+sys_path'></span>

<h3>Description</h3>

<p>Right now, it uses <code>shQuote</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sys_path(R_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sys_path_+3A_r_path">R_path</code></td>
<td>
<p>The name of the file. It should be properly formatted: if it
exists, <code>file.exists(R_path)</code> should be <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the file
</p>

<hr>
<h2 id='template_xifti'>Make a template <code>"xifti"</code> object</h2><span id='topic+template_xifti'></span>

<h3>Description</h3>

<p>Make a <code>"xifti"</code> object with all terminal entries <code>NULL</code>. Useful for
seeing the structure of a <code>"xifti"</code> object or creating a new one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>template_xifti()
</code></pre>


<h3>Details</h3>

<p>Additional metadata depends on the type of CIFTI file:
</p>

<dl>
<dt>&quot;dtseries&quot;</dt><dd>

<dl>
<dt>time_start:</dt><dd><p>   Start time</p>
</dd>
<dt>time_step:</dt><dd><p>   The TR</p>
</dd>
<dt>time_unit:</dt><dd><p>   Unit of time</p>
</dd>
</dl>

</dd>
<dt>&quot;dscalar&quot;</dt><dd>

<dl>
<dt>names:</dt><dd><p>   Name of each data column</p>
</dd>
</dl>

</dd>
<dt>&quot;dlabels&quot;</dt><dd>

<dl>
<dt>names:</dt><dd><p>   Name of each data column</p>
</dd>
<dt>labels:</dt><dd>
<p>Length <code class="reqn">T</code> list of <code class="reqn">L \times 5</code> data.frames. List entry
names are data column names. Row names are label names.
Column names are: Key, Red, Green, Blue, and Alpha.
</p>
</dd>
</dl>

</dd>
</dl>



<h3>Value</h3>

<p>An empty <code>"xifti"</code> object with a valid list structure
</p>

<hr>
<h2 id='transform_xifti'>Apply a univariate transformation to a <code>"xifti"</code> or pair of <code>"xifti"</code>s.</h2><span id='topic+transform_xifti'></span>

<h3>Description</h3>

<p>Apply a univariate transformation to each value in a <code>"xifti"</code> or pair of
<code>"xifti"</code>s. If a pair, they must share the same dimensions (brainstructures)
and number of measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_xifti(xifti, FUN, xifti2 = NULL, idx = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="transform_xifti_+3A_fun">FUN</code></td>
<td>
<p>The function. If <code>xifti2</code> is not provided, it should be
a univariate function like <code>log</code> or <code>sqrt</code>. If
<code>xifti2</code> is provided, it should take in two arguments, like <code>`+`</code>
or <code>pmax</code>.</p>
</td></tr>
<tr><td><code id="transform_xifti_+3A_xifti2">xifti2</code></td>
<td>
<p>The second xifti, if applicable. Otherwise, <code>NULL</code> (default)</p>
</td></tr>
<tr><td><code id="transform_xifti_+3A_idx">idx</code></td>
<td>
<p>The column indices for which to apply the transformation.
If <code>NULL</code> (default), apply to all columns. If two <code>"xifti"</code> objects,
were provided, the values in the first (<code>xifti</code>) will be retained for columns
that are not transformed.</p>
</td></tr>
<tr><td><code id="transform_xifti_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>FUN</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>"xifti"</code> had the dlabel intent, and the transformation creates
any value that is not a label value (e.g. a non-integer), then it is converted
to a dscalar.
</p>
<p>Technically, the function does not have to be univariate: it only has to return the
same number of values as the input. The function will be applied to the matrix
for each brain structure separately. For example, the function
<code>function(q){(q - mean(q)) / sd(q)}</code> will scale each brainstructure, while
<code>scale</code> will scale each column of each brainstructure.
</p>


<h3>Value</h3>

<p>A <code>"xifti"</code> storing the result of applying <code>FUN</code> to the input(s).
The data dimensions will be the same. The metadata of <code>xifti</code> will be retained,
and the metadata of <code>xifti2</code> will be discarded (if provided).
</p>


<h3>See Also</h3>

<p>Other manipulating xifti: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+apply_parc">apply_parc</a>()</code>,
<code><a href="#topic+apply_xifti">apply_xifti</a>()</code>,
<code><a href="#topic+combine_xifti">combine_xifti</a>()</code>,
<code><a href="#topic+convert_to_dlabel">convert_to_dlabel</a>()</code>,
<code><a href="#topic+merge_xifti">merge_xifti</a>()</code>,
<code><a href="#topic+move_to_mwall">move_to_mwall</a>()</code>,
<code><a href="#topic+newdata_xifti">newdata_xifti</a>()</code>,
<code><a href="#topic+remap_cifti">remap_cifti</a>()</code>,
<code><a href="#topic+remove_xifti">remove_xifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+resample_cifti_from_template">resample_cifti_from_template</a>()</code>,
<code><a href="#topic+scale_xifti">scale_xifti</a>()</code>,
<code><a href="#topic+select_xifti">select_xifti</a>()</code>,
<code><a href="#topic+set_names_xifti">set_names_xifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>
</p>

<hr>
<h2 id='unmask_cortex'>Unmask cortex</h2><span id='topic+unmask_cortex'></span>

<h3>Description</h3>

<p>Get cortex data with medial wall vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmask_cortex(cortex, mwall, mwall_fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmask_cortex_+3A_cortex">cortex</code></td>
<td>
<p>V vertices x T measurements matrix</p>
</td></tr>
<tr><td><code id="unmask_cortex_+3A_mwall">mwall</code></td>
<td>
<p>Logical vector with T <code>TRUE</code> values.</p>
</td></tr>
<tr><td><code id="unmask_cortex_+3A_mwall_fill">mwall_fill</code></td>
<td>
<p>The fill value to use for medial wall vertices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unmasked cortex data
</p>

<hr>
<h2 id='unmask_subcortex'>Undo the volumetric mask to the subcortex</h2><span id='topic+unmask_subcortex'></span>

<h3>Description</h3>

<p>Un-applies the mask to the subcortical data in a <code>"xifti"</code> to yield its
volumetric representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmask_subcortex(xifti, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmask_subcortex_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="unmask_subcortex_+3A_fill">fill</code></td>
<td>
<p>The value for locations outside the mask. Default: <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 3D or 4D unflattened volume array
</p>

<hr>
<h2 id='unvec_vol'>Convert vectorized data back to volume</h2><span id='topic+unvec_vol'></span>

<h3>Description</h3>

<p>Un-applies a mask to vectorized data to yield its volumetric representation.
The mask and data should have compatible dimensions: the number of rows in
<code>dat</code> should equal the number of locations within the <code>mask</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unvec_vol(dat, mask, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unvec_vol_+3A_dat">dat</code></td>
<td>
<p>Data matrix with locations along the rows and measurements along
the columns. If only one set of measurements were made, this may be a
vector.</p>
</td></tr>
<tr><td><code id="unvec_vol_+3A_mask">mask</code></td>
<td>
<p>Volumetric binary mask. <code>TRUE</code> indicates voxels inside the
mask.</p>
</td></tr>
<tr><td><code id="unvec_vol_+3A_fill">fill</code></td>
<td>
<p>The value for locations outside the mask. Default: <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 3D or 4D unflattened volume array
</p>

<hr>
<h2 id='use_color_pal'>Use a color palette</h2><span id='topic+use_color_pal'></span>

<h3>Description</h3>

<p>Applies a palette to a data vector to yield a vector of colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_color_pal(data_values, pal, color_NA = "white", indices = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_color_pal_+3A_data_values">data_values</code></td>
<td>
<p>The values to map to colors</p>
</td></tr>
<tr><td><code id="use_color_pal_+3A_pal">pal</code></td>
<td>
<p>The palette to use to map values to colors</p>
</td></tr>
<tr><td><code id="use_color_pal_+3A_color_na">color_NA</code></td>
<td>
<p>The color to use for <code>NA</code> values. Default: <code>"white"</code>.</p>
</td></tr>
<tr><td><code id="use_color_pal_+3A_indices">indices</code></td>
<td>
<p>Return the numeric indices of colors in <code>pal$value</code>
rather than the colors themselves. A value of <code>0</code> will be used for
missing data. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of color names (or integers if <code>indices</code>).
</p>


<h3>See Also</h3>

<p>Other coloring: 
<code><a href="#topic+ROY_BIG_BL">ROY_BIG_BL</a>()</code>,
<code><a href="#topic+expand_color_pal">expand_color_pal</a>()</code>,
<code><a href="#topic+make_color_pal">make_color_pal</a>()</code>
</p>

<hr>
<h2 id='verbose_Param_FALSE'>verbose: FALSE</h2><span id='topic+verbose_Param_FALSE'></span>

<h3>Description</h3>

<p>verbose: FALSE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="verbose_Param_FALSE_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='verbose_Param_TRUE'>verbose: TRUE</h2><span id='topic+verbose_Param_TRUE'></span>

<h3>Description</h3>

<p>verbose: TRUE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="verbose_Param_TRUE_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='vert_adjacency'>Vertex Adjacency Matrix</h2><span id='topic+vert_adjacency'></span>

<h3>Description</h3>

<p>Make adjacency matrix between two sets of vertices on the same mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vert_adjacency(faces, v1, v2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vert_adjacency_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
<tr><td><code id="vert_adjacency_+3A_v1">v1</code>, <code id="vert_adjacency_+3A_v2">v2</code></td>
<td>
<p>The first and second set of vertices. These are logical vectors
the same length as <code>vertices</code> indicating the vertices in each set.
If <code>v2</code> is <code>NULL</code> (default), set <code>v2</code> to <code>v1</code>. Can
alternatively be a vector if integers corresponding to vertex indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjacency matrix
</p>

<hr>
<h2 id='vertices_Param'>vertices</h2><span id='topic+vertices_Param'></span>

<h3>Description</h3>

<p>vertices
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertices_Param_+3A_vertices">vertices</code></td>
<td>
<p>A <code class="reqn">V \times 3</code> matrix, where each row contains the Euclidean
coordinates at which a given vertex in the mesh is located. <code class="reqn">V</code> is the
number of vertices in the mesh</p>
</td></tr>
</table>

<hr>
<h2 id='view_comp'>View composite of images</h2><span id='topic+view_comp'></span>

<h3>Description</h3>

<p>Create a single image which displays multiple image files. Tailored to support
composite layouts of plots from <code><a href="#topic+view_xifti">view_xifti</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_comp(
  img,
  ncol = NULL,
  nrow = NULL,
  legend = NULL,
  title = NULL,
  legend_height = 0.3,
  title_height = 0.1,
  title_fsize = 5,
  newpage = is.null(fname),
  fname = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_comp_+3A_img">img</code></td>
<td>
<p>Character vector of paths to images to include. They will be
arranged by row.</p>
</td></tr>
<tr><td><code id="view_comp_+3A_ncol">ncol</code>, <code id="view_comp_+3A_nrow">nrow</code></td>
<td>
<p>Control the layout of the composite image. <code>NULL</code> (default)
will use approximately same numbers of rows and columns.</p>
</td></tr>
<tr><td><code id="view_comp_+3A_legend">legend</code></td>
<td>
<p>File path to a legend image to add, or <code>NULL</code> (default)
to not add a legend.</p>
</td></tr>
<tr><td><code id="view_comp_+3A_title">title</code></td>
<td>
<p>A length-one character vector to use as the title, or <code>NULL</code>
(default) to not add a title.</p>
</td></tr>
<tr><td><code id="view_comp_+3A_legend_height">legend_height</code>, <code id="view_comp_+3A_title_height">title_height</code></td>
<td>
<p>Heights of the legend and title, if
applicable. Specified relative to all the plots, so <code>.1</code> would
mean the height is a tenth of the height of all the plots. Default:
<code>.1</code> for the title and <code>.3</code> for the legend.</p>
</td></tr>
<tr><td><code id="view_comp_+3A_title_fsize">title_fsize</code></td>
<td>
<p>Multiplier for font size. Default: <code>5</code></p>
</td></tr>
<tr><td><code id="view_comp_+3A_newpage">newpage</code></td>
<td>
<p>Call <code>grid::grid.newpage</code> before rendering?
Default: <code>is.null(fname)</code>.</p>
</td></tr>
<tr><td><code id="view_comp_+3A_fname">fname</code></td>
<td>
<p>If <code>NULL</code> (default), print the result. Otherwise, save to
a PNG file at this location. Will override <code>newpage</code> to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="view_comp_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>gridExtra::arrangeGrob</code>. The
arguments <code>grobs</code> and <code>layout_matrix</code> should be avoided because
they are determined based on <code>img</code>. adjusting <code>widths</code> may be useful,
e.g. to make the subcortex subplot be less wide than the cortex subplot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the following packages: <code>png</code>, <code>grid</code>, <code>gridExtra</code>
</p>
<p>How it works: the non-legend images (plots) are composited in a call to
<code>grid::arrangeGrob</code>. If a title or legend exists, it's added to the top and
bottom, respectively, of the plots after with another call to <code>grid::arangeGrob</code>.
</p>


<h3>Value</h3>

<p>The composite plot
</p>


<h3>See Also</h3>

<p>Other visualizing: 
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+view_xifti">view_xifti</a>()</code>,
<code><a href="#topic+view_xifti_surface">view_xifti_surface</a>()</code>,
<code><a href="#topic+view_xifti_volume">view_xifti_volume</a>()</code>
</p>

<hr>
<h2 id='view_surf'>View <code>"surf"</code> object(s)</h2><span id='topic+view_surf'></span>

<h3>Description</h3>

<p>Visualize one or two <code>"surf"</code> objects(s), or the <code>"surf"</code>
component(s) in a <code>"xifti"</code> using an interactive Open GL window
made with <code>rgl</code>. The <code>rgl</code> package is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_surf(
  ...,
  view = c("both", "lateral", "medial"),
  widget = NULL,
  title = NULL,
  fname = FALSE,
  cex.title = NULL,
  text_color = "black",
  bg = NULL,
  alpha = 1,
  edge_color = NULL,
  vertex_color = NULL,
  vertex_size = 0,
  material = NULL,
  width = NULL,
  height = NULL,
  zoom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_surf_+3A_...">...</code></td>
<td>
<p>One of: A <code>"surf"</code> object; two <code>"surf"</code> objects;
or, a <code>"xifti"</code> object. If a <code>"surf"</code> object has an empty
<code>"hemisphere"</code> metadata entry, it will be set to the opposite side
of the other's if known; otherwise, it will be set to the left side. If both
are unknown, the first will be taken as the left and the second as the
right.</p>
</td></tr>
<tr><td><code id="view_surf_+3A_view">view</code></td>
<td>
<p>Which view to display: <code>"lateral"</code>, <code>"medial"</code>, or
<code>"both"</code>. If <code>NULL</code> (default), both views will be shown. Each view
will be plotted in a separate panel row.</p>
</td></tr>
<tr><td><code id="view_surf_+3A_widget">widget</code></td>
<td>
<p>Display the plot in an htmlwidget? Should be logical or
<code>NULL</code> (default), in which case a widget will be used only if needed
(<code>length(idx)&gt;1 &amp; isFALSE(fname)</code>, <code>fname</code> is a file path to an
.html file, or if <code>rgl.useNULL()</code>).</p>
</td></tr>
<tr><td><code id="view_surf_+3A_title">title</code></td>
<td>
<p>Optional title(s) for the plot(s). It will be printed at the top
in a separate subplot with 1/4 the height of the brain cortex subplots.
</p>
<p>Default: <code>NULL</code> will not use any title if <code>length(idx)==1</code>.
Otherwise, it will use the time index (&quot;.dtseries&quot;) or name
(.dscalar or .dlabel) of each data column.
</p>
<p>To use a custom title(s), use a length 1 character vector (same title for
each plot) or length <code>length(idx)</code> character vector (different title
for each plot). Set to <code>NULL</code> or an empty character to omit the title.
</p>
<p>If the title is non-empty but does not appear, try lowering <code>cex.title</code>.</p>
</td></tr>
<tr><td><code id="view_surf_+3A_fname">fname</code></td>
<td>
<p>Save the plot(s) (and color legend if applicable)?
</p>
<p>If <code>isFALSE(fname)</code> (default), no files will be written.
</p>
<p>If <code>fname</code> is a length-1 character vector ending in &quot;.html&quot;, an html
with an interactive widget will be written.
</p>
<p>If neither of the cases above apply, a png image will be written for each
<code>idx</code>. If <code>isTRUE(fname)</code> the files will be named by the
data column names (underscores will replace spaces). Or, set <code>fname</code> to a
length 1 character vector to name files by this suffix followed by the
<code>fname_suffix</code>. Or, set <code>fname</code> to a character vector with the same
length as <code>idx</code> to name the files exactly.</p>
</td></tr>
<tr><td><code id="view_surf_+3A_cex.title">cex.title</code></td>
<td>
<p>Font size multiplier for the title. <code>NULL</code> (default)
will use <code>2</code> for titles less than 20 characters long, and smaller
sizes for increasingly longer titles.</p>
</td></tr>
<tr><td><code id="view_surf_+3A_text_color">text_color</code></td>
<td>
<p>Color for text in title and colorbar legend. Default:
<code>"black"</code>.</p>
</td></tr>
<tr><td><code id="view_surf_+3A_bg">bg</code></td>
<td>
<p>Background color. <code>NULL</code> will use <code>"white"</code>. Does not affect
the color legend or color bar if printed separately: those will always have
white backgrounds.</p>
</td></tr>
<tr><td><code id="view_surf_+3A_alpha">alpha</code></td>
<td>
<p>Transparency value for mesh coloring, between 0 and 1. Default:
<code>1.0</code> (no transparency).</p>
</td></tr>
<tr><td><code id="view_surf_+3A_edge_color">edge_color</code></td>
<td>
<p>Outline each edge in this color. Default: <code>NULL</code> (do
not outline the edges).</p>
</td></tr>
<tr><td><code id="view_surf_+3A_vertex_color">vertex_color</code></td>
<td>
<p>Draw each vertex in this color. Default:
<code>"black"</code>. Vertices are only drawn if <code>vertex_size &gt; 0</code></p>
</td></tr>
<tr><td><code id="view_surf_+3A_vertex_size">vertex_size</code></td>
<td>
<p>Draw each vertex with this size. Default: <code>0</code>
(do not draw the vertices).</p>
</td></tr>
<tr><td><code id="view_surf_+3A_material">material</code></td>
<td>
<p>A list of materials from <code><a href="rgl.html#topic+material3d">material3d</a></code>
to use. For example, <code>list(lit=FALSE, smooth=FALSE)</code> will use exact colors
from the color scale, rather than adding geometric shading and interpolating
vertex colors. If <code>NULL</code>, use defaults.</p>
</td></tr>
<tr><td><code id="view_surf_+3A_width">width</code>, <code id="view_surf_+3A_height">height</code></td>
<td>
<p>The dimensions of the RGL window, in pixels. If both are
<code>NULL</code> (default), these dimensions depend on type of output (Open GL
window or widget) and subplots (<code>hemisphere</code>, <code>view</code>, <code>title</code>,
and <code>slider_title</code>) and are chosen to be the largest plot within a
1500 x 700 area (Open GL window) or 600 x 700 area (widget) that maintains
a brain hemisphere subplot dimensions ratio of 10 x 7. Specifying only one
will set the other to maintain this aspect ratio. Both can be specified to
set the dimensions exactly, but note that the dimensions cannot be larger
than the screen resolution. (These arguments do not affect the size of the
legend, which cannot be controlled.)
</p>
<p>The plot will be taller than <code>height</code> to accommodate a title or color
bar.
</p>
<p>If multiple <code>idx</code> are being composited with <code>together</code>, these
arguments refer to a single <code>idx</code> within the composited plot, and not
the composited plot itself.</p>
</td></tr>
<tr><td><code id="view_surf_+3A_zoom">zoom</code></td>
<td>
<p>Adjust the sizes of the brain meshes. Default: <code>NULL</code> (will
be set to 0.6 or 160\
widget.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works as a wrapper to <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code>, but
some arguments are not applicable (e.g. color scheme and legend). Also,
instead of using the <code>hemisphere</code> argument, name the surface arguments
<code>surfL</code> or <code>surfR</code> (see description for parameter <code>...</code>).
Finally, the default value for <code>param</code> is <code>"surf"</code>, not
<code>"xifti"</code>.
</p>


<h3>Navigating and Embedding the Interactive Plots</h3>

<p>To navigate the interactive Open GL window and html widget, left click and
drag the cursor to rotate the meshes. Use the scroll wheel or right click
and drag to zoom. Press the scroll wheel and drag to change the field-of-view.
For Open GL windows, execute
<code><a href="rgl.html#topic+snapshot">snapshot</a></code> to save the current window as a .png file,
<code><a href="rgl.html#topic+open3d">close3d</a></code> to close the window, and
<code><a href="rgl.html#topic+viewpoint">view3d</a></code> to programmatically control the
perspective.
</p>
<p>To embed an interactive plot in an R Markdown document, first execute
<code>rgl::setupKnitr()</code> to prepare the document for embedding the widget.
Then execute the plot command as you normally would to create a widget (i.e.
without specifying <code>fname</code>, and by requesting more than one <code>idx</code>
or by setting <code>widget</code> to <code>TRUE</code>). When the R Markdown document is
knitted, the interactive widget should be displayed below the chunk in which
the plot command was executed. See the vignette for an example.
</p>


<h3>Embedding the Static Plots</h3>

<p>To embed a static plot in an R Markdown document, first execute
<code>rgl::setupKnitr()</code> to prepare the document for embedding the snapshot
of the Open GL window. Then execute the plot command as you normally would
to create an Open GL window (i.e. without specifying <code>fname</code>, and by
requesting only one <code>idx</code>). In the options for the chunk in which the
plot command is executed, set <code>rgl=TRUE, format="png"</code>. You can also
control the image dimensions here e.g. <code>fig.height=3.8, fig.width=5</code>.
When the R Markdown document is knitted, the static plots should be
displayed below the chunk in which the plot command was executed. See the
vignette for an example.
</p>


<h3>See Also</h3>

<p>Other visualizing: 
<code><a href="#topic+view_comp">view_comp</a>()</code>,
<code><a href="#topic+view_xifti">view_xifti</a>()</code>,
<code><a href="#topic+view_xifti_surface">view_xifti_surface</a>()</code>,
<code><a href="#topic+view_xifti_volume">view_xifti_volume</a>()</code>
</p>
<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='view_xifti'>View a <code>"xifti"</code> object</h2><span id='topic+view_xifti'></span><span id='topic+view_cifti'></span><span id='topic+viewCIfTI'></span><span id='topic+viewcii'></span>

<h3>Description</h3>

<p>Displays the data in a <code>"xifti"</code> object using <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code>
and/or <code><a href="#topic+view_xifti_volume">view_xifti_volume</a></code>. Compared to calling these two
functions separately on the same data, this function may be more convenient
since the automatic choice of color mode and limits is determined across
the entire data and shared between the two plots. Also, if writing files
the subcortical plots will not overwrite the cortical plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti(xifti, what = NULL, ...)

view_cifti(xifti, ...)

viewCIfTI(xifti, ...)

viewcii(xifti, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="view_xifti_+3A_what">what</code></td>
<td>
<p><code>"surface"</code>, <code>"volume"</code>, or <code>"both"</code>. <code>NULL</code>
will infer based on the contents of the <code>"xifti"</code>: if there is data,
plot the surface cortex data if present, and the volumetric subcortical data
otherwise. If there is no data, plot the surface geometry if present, and
do nothing otherwise.</p>
</td></tr>
<tr><td><code id="view_xifti_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to either view function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value of <code>view_xifti_surface</code> or
<code>view_xifti_volume</code>.
</p>


<h3>See Also</h3>

<p>Other common: 
<code><a href="#topic+is.cifti">is.cifti</a>()</code>,
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+write_cifti">write_cifti</a>()</code>
</p>
<p>Other visualizing: 
<code><a href="#topic+view_comp">view_comp</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+view_xifti_surface">view_xifti_surface</a>()</code>,
<code><a href="#topic+view_xifti_volume">view_xifti_volume</a>()</code>
</p>

<hr>
<h2 id='view_xifti_surface'>View cortical surface data in a <code>"xifti"</code></h2><span id='topic+view_xifti_surface'></span><span id='topic+view_cifti_surface'></span><span id='topic+viewCIfTI_surface'></span><span id='topic+viewcii_surface'></span>

<h3>Description</h3>

<p>Visualize <code>"xifti"</code> cortical data using an interactive Open GL window
or htmlwidget made with <code>rgl</code>. The <code>rmarkdown</code> package is
required for the htmlwidget functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti_surface(
  xifti = NULL,
  surfL = NULL,
  surfR = NULL,
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  idx = NULL,
  hemisphere = NULL,
  together = NULL,
  together_ncol = NULL,
  together_title = NULL,
  view = c("both", "lateral", "medial"),
  widget = NULL,
  title = NULL,
  slider_title = "Index",
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  legend_fname = "[fname]_legend",
  legend_ncol = NULL,
  legend_alllevels = FALSE,
  legend_embed = NULL,
  digits = NULL,
  scientific = NA,
  cex.title = NULL,
  text_color = "black",
  bg = NULL,
  NA_color = "white",
  borders = FALSE,
  alpha = 1,
  edge_color = NULL,
  vertex_color = NULL,
  vertex_size = 0,
  material = NULL,
  shadows = 1,
  width = NULL,
  height = NULL,
  zoom = NULL
)

view_cifti_surface(
  xifti = NULL,
  surfL = NULL,
  surfR = NULL,
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  idx = NULL,
  hemisphere = NULL,
  together = NULL,
  together_ncol = NULL,
  together_title = NULL,
  view = c("both", "lateral", "medial"),
  widget = NULL,
  title = NULL,
  slider_title = "Index",
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  legend_fname = "[fname]_legend",
  legend_ncol = NULL,
  legend_alllevels = FALSE,
  legend_embed = NULL,
  digits = NULL,
  scientific = NA,
  cex.title = NULL,
  text_color = "black",
  bg = NULL,
  NA_color = "white",
  borders = FALSE,
  alpha = 1,
  edge_color = NULL,
  vertex_color = NULL,
  vertex_size = 0,
  material = NULL,
  shadows = 1,
  width = NULL,
  height = NULL,
  zoom = NULL
)

viewCIfTI_surface(
  xifti = NULL,
  surfL = NULL,
  surfR = NULL,
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  idx = NULL,
  hemisphere = NULL,
  together = NULL,
  together_ncol = NULL,
  together_title = NULL,
  view = c("both", "lateral", "medial"),
  widget = NULL,
  title = NULL,
  slider_title = "Index",
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  legend_fname = "[fname]_legend",
  legend_ncol = NULL,
  legend_alllevels = FALSE,
  legend_embed = NULL,
  digits = NULL,
  scientific = NA,
  cex.title = NULL,
  text_color = "black",
  bg = NULL,
  NA_color = "white",
  borders = FALSE,
  alpha = 1,
  edge_color = NULL,
  vertex_color = NULL,
  vertex_size = 0,
  material = NULL,
  shadows = 1,
  width = NULL,
  height = NULL,
  zoom = NULL
)

viewcii_surface(
  xifti = NULL,
  surfL = NULL,
  surfR = NULL,
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  idx = NULL,
  hemisphere = NULL,
  together = NULL,
  together_ncol = NULL,
  together_title = NULL,
  view = c("both", "lateral", "medial"),
  widget = NULL,
  title = NULL,
  slider_title = "Index",
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  legend_fname = "[fname]_legend",
  legend_ncol = NULL,
  legend_alllevels = FALSE,
  legend_embed = NULL,
  digits = NULL,
  scientific = NA,
  cex.title = NULL,
  text_color = "black",
  bg = NULL,
  NA_color = "white",
  borders = FALSE,
  alpha = 1,
  edge_color = NULL,
  vertex_color = NULL,
  vertex_size = 0,
  material = NULL,
  shadows = 1,
  width = NULL,
  height = NULL,
  zoom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti_surface_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_surfl">surfL</code>, <code id="view_xifti_surface_+3A_surfr">surfR</code></td>
<td>
<p>(Optional) The brain surface model to use. Each can be a
<code>"surf"</code> object, any valid argument to <code><a href="#topic+read_surf">read_surf</a></code> , or one
of <code>"very inflated"</code>, <code>"inflated"</code>, or <code>"midthickness"</code>. If
provided, it will override <code>xifti$surf$cortex_left</code> or
<code>xifti$surf$cortex_right</code> if it exists. Leave as <code>NULL</code> (default)
to use <code>xifti$surf$cortex_left</code> or <code>xifti$surf$cortex_right</code> if it
exists, or the default inflated surfaces if it does not exist.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_color_mode">color_mode</code></td>
<td>
<p>(Optional) <code>"sequential"</code>, <code>"qualitative"</code>,
<code>"diverging"</code>, or <code>"auto"</code> (default). Auto mode will use the
qualitative color mode if the <code>"xifti"</code> object represents a .dlabel
CIFTI (intent 3007). Otherwise, it will use the diverging mode if the data
contains both positive and negative values, and the sequential mode if the
data contains &gt;90\
<code><a href="#topic+make_color_pal">make_color_pal</a></code> for more details.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_zlim">zlim</code></td>
<td>
<p>(Optional) Controls the mapping of values to each
color in <code>colors</code>. If the length is longer than
one, using -Inf will set the value to the data minimum, and Inf will set
the value to the data maximum. See <code><a href="#topic+make_color_pal">make_color_pal</a></code>
description for more details.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_colors">colors</code></td>
<td>
<p>(Optional) <code>"ROY_BIG_BL"</code>, vector of colors to use,
the name of a ColorBrewer palette (see <code>RColorBrewer::brewer.pal.info</code>
and colorbrewer2.org), the name of a viridisLite palette, or a data.frame
with columns <code>"color"</code> and <code>"value"</code> (will override <code>zlim</code>).
If <code>NULL</code>
(default), will use the positive half of <code>"ROY_BIG_BL"</code> (sequential),
<code>"Set2"</code> (qualitative), or the full <code>"ROY_BIG_BL"</code> (diverging). An
exception to these defaults is if the <code>"xifti"</code> object represents a
.dlabel CIFTI (intent 3007), in which case the colors in the label table
will be used. See <code><a href="#topic+make_color_pal">make_color_pal</a></code> for more details.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_idx">idx</code></td>
<td>
<p>The time/column index of the data to display. <code>NULL</code> (default)
will display the first column.
</p>
<p>If its length is greater than one, and <code>isFALSE(fname)</code>,
a widget must be used since a single OpenGL window cannot show multiple
indexes. A slider will be added to the widget to control what time/column
is being displayed.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_hemisphere">hemisphere</code></td>
<td>
<p>Which brain cortex to display: &quot;both&quot; (default), &quot;left&quot;,
or &quot;right&quot;. Each will be plotted in a separate panel column.
</p>
<p>If a brain cortex is requested but no surface is available, a default
inflated surface will be used.
</p>
<p>This argument can also be <code>NULL</code> (default). In this case, the default
inflated surface included with <code>ciftiTools</code> will be used for each
cortex with data (i.e. if <code>xifti$data$cortex_left</code> and/or
<code>xifti$data$cortex_right</code> exist).
</p>
<p>Surfaces without data will be colored white.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_together">together</code></td>
<td>
<p>Only applies if saving image files (<code>!isFALSE(fname)</code>).
Use this argument to create and save a composite image which combines
multiple plots. <code>NULL</code> (default) will not combine any plots. Otherwise,
this argument should be a character vector with one or more of the
following entries:
</p>
<p><code>"leg"</code> to combine the color legend with each <code>"xifti"</code> data plot.
Overrides/ignores <code>legend_embed</code>.
</p>
<p><code>"idx"</code> to place all the plots for the different <code>"idx"</code> in a grid.
If the data is not qualitative, a shared color bar will be added to the bottom
of the composite. If the data is qualitative, a shared color legend will be
added to the bottom only if <code>"leg"</code> is in <code>together</code>.
For greater control see <code>view_comp</code> or <code>grid::arrangeGrob</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_together_ncol">together_ncol</code></td>
<td>
<p>If <code>"idx" %in% together</code>, this determines the number
of columns to use in the array of subplots for different indices.
By default, the number of columns and rows will be determined such that they
are about equal.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_together_title">together_title</code></td>
<td>
<p>If a composite image is made based on <code>together</code>,
use this argument to add a grand title to the composite image. Should be
a length-one character vector or <code>NULL</code> (default) to not add a grand title.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_view">view</code></td>
<td>
<p>Which view to display: <code>"lateral"</code>, <code>"medial"</code>, or
<code>"both"</code>. If <code>NULL</code> (default), both views will be shown. Each view
will be plotted in a separate panel row.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_widget">widget</code></td>
<td>
<p>Display the plot in an htmlwidget? Should be logical or
<code>NULL</code> (default), in which case a widget will be used only if needed
(<code>length(idx)&gt;1 &amp; isFALSE(fname)</code>, <code>fname</code> is a file path to an
.html file, or if <code>rgl.useNULL()</code>).</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_title">title</code></td>
<td>
<p>Optional title(s) for the plot(s). It will be printed at the top
in a separate subplot with 1/4 the height of the brain cortex subplots.
</p>
<p>Default: <code>NULL</code> will not use any title if <code>length(idx)==1</code>.
Otherwise, it will use the time index (&quot;.dtseries&quot;) or name
(.dscalar or .dlabel) of each data column.
</p>
<p>To use a custom title(s), use a length 1 character vector (same title for
each plot) or length <code>length(idx)</code> character vector (different title
for each plot). Set to <code>NULL</code> or an empty character to omit the title.
</p>
<p>If the title is non-empty but does not appear, try lowering <code>cex.title</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_slider_title">slider_title</code></td>
<td>
<p>Text at bottom of plot that will be added if a slider
is used, to provide a title for it. Default: <code>"Index"</code>.
If <code>NULL</code> or an empty character, no title will be added.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_fname">fname</code></td>
<td>
<p>Save the plot(s) (and color legend if applicable)?
</p>
<p>If <code>isFALSE(fname)</code> (default), no files will be written.
</p>
<p>If <code>fname</code> is a length-1 character vector ending in &quot;.html&quot;, an html
with an interactive widget will be written.
</p>
<p>If neither of the cases above apply, a png image will be written for each
<code>idx</code>. If <code>isTRUE(fname)</code> the files will be named by the
data column names (underscores will replace spaces). Or, set <code>fname</code> to a
length 1 character vector to name files by this suffix followed by the
<code>fname_suffix</code>. Or, set <code>fname</code> to a character vector with the same
length as <code>idx</code> to name the files exactly.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_fname_suffix">fname_suffix</code></td>
<td>
<p>Either the data column names (<code>"names"</code>) or the
index value (<code>"idx"</code>).</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_legend_fname">legend_fname</code></td>
<td>
<p>Save the color legend? Since the legend is the same
for each <code>idx</code> only one legend is written even if <code>length(idx)&gt;1</code>.
This argument can be <code>NULL</code> to not save the legend, an exact file
path, or a length-one character vector with &quot;[fname]&quot; in it, which will
name the legend based on <code>fname\[1\]</code>. For example, if <code>fname\[1\]</code>
is <code>"plots/my_cifti.png"</code> and <code>legend_fname</code> is <code>"\[fname\]_legend"</code>
(default), then the legend plot will be saved to <code>"plots/my_cifti_legend.png"</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_legend_ncol">legend_ncol</code></td>
<td>
<p>Number of columns in color legend. If
<code>NULL</code> (default), use 10 entries per row. Only applies if the color
legend is used (qualitative data).</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_legend_alllevels">legend_alllevels</code></td>
<td>
<p>Show all label levels in the color legend? If
<code>FALSE</code> (default), just show the levels present in the data being
viewed. Only applies if the color legend is used (qualitative data).</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_legend_embed">legend_embed</code></td>
<td>
<p>Should the colorbar be embedded in the plot?
It will be positioned in the bottom-left corner, in a separate subplot
with 1/4 the height of the brain cortex subplots. Default: <code>TRUE</code>.
If <code>FALSE</code>, print/save it separately instead.
</p>
<p>Only applies if the color bar is used (sequential or diverging data)
or if <code>"leg" %in% together</code>. Otherwise the color legend
(qualitative data) cannot be embedded at the moment.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_digits">digits</code></td>
<td>
<p>The number of digits for the colorbar legend ticks.
If <code>NULL</code> (default), let <code><a href="base.html#topic+format">format</a></code> decide.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_scientific">scientific</code></td>
<td>
<p>Use scientific notation? If <code>NA</code> (default), let
<code><a href="base.html#topic+format">format</a></code> decide.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_cex.title">cex.title</code></td>
<td>
<p>Font size multiplier for the title. <code>NULL</code> (default)
will use <code>2</code> for titles less than 20 characters long, and smaller
sizes for increasingly longer titles.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_text_color">text_color</code></td>
<td>
<p>Color for text in title and colorbar legend. Default:
<code>"black"</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_bg">bg</code></td>
<td>
<p>Background color. <code>NULL</code> will use <code>"white"</code>. Does not affect
the color legend or color bar if printed separately: those will always have
white backgrounds.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_na_color">NA_color</code></td>
<td>
<p>The color for the medial wall and <code>NA</code> values. Default:
<code>"white"</code>. Also used to color the entire surface for <code>view_surf</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_borders">borders</code></td>
<td>
<p>Only applicable if <code>color_mode</code> is <code>"qualitative"</code>.
Border vertices will be identified (those that share a face with at least
one vertex of a different value) and colored over. If this argument is
<code>TRUE</code> borders will be colored in black; provide the name of a different
color to use that instead. If <code>FALSE</code> or <code>NULL</code> (default), do
not draw borders.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_alpha">alpha</code></td>
<td>
<p>Transparency value for mesh coloring, between 0 and 1. Default:
<code>1.0</code> (no transparency).</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_edge_color">edge_color</code></td>
<td>
<p>Outline each edge in this color. Default: <code>NULL</code> (do
not outline the edges).</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_vertex_color">vertex_color</code></td>
<td>
<p>Draw each vertex in this color. Default:
<code>"black"</code>. Vertices are only drawn if <code>vertex_size &gt; 0</code></p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_vertex_size">vertex_size</code></td>
<td>
<p>Draw each vertex with this size. Default: <code>0</code>
(do not draw the vertices).</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_material">material</code></td>
<td>
<p>A list of materials from <code><a href="rgl.html#topic+material3d">material3d</a></code>
to use. For example, <code>list(lit=FALSE, smooth=FALSE)</code> will use exact colors
from the color scale, rather than adding geometric shading and interpolating
vertex colors. If <code>NULL</code>, use defaults.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_shadows">shadows</code></td>
<td>
<p>Number from 0 (maximum added lighting) to 1 (no added
lighting) to control the darkness and extent of shadowing on the 3D surface.
Default: <code>1</code>. Shadows help render the shape of the surface, but can
be distracting if interpretation of the data depends on small differences in
brightness along the color scale.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_width">width</code>, <code id="view_xifti_surface_+3A_height">height</code></td>
<td>
<p>The dimensions of the RGL window, in pixels. If both are
<code>NULL</code> (default), these dimensions depend on type of output (Open GL
window or widget) and subplots (<code>hemisphere</code>, <code>view</code>, <code>title</code>,
and <code>slider_title</code>) and are chosen to be the largest plot within a
1500 x 700 area (Open GL window) or 600 x 700 area (widget) that maintains
a brain hemisphere subplot dimensions ratio of 10 x 7. Specifying only one
will set the other to maintain this aspect ratio. Both can be specified to
set the dimensions exactly, but note that the dimensions cannot be larger
than the screen resolution. (These arguments do not affect the size of the
legend, which cannot be controlled.)
</p>
<p>The plot will be taller than <code>height</code> to accommodate a title or color
bar.
</p>
<p>If multiple <code>idx</code> are being composited with <code>together</code>, these
arguments refer to a single <code>idx</code> within the composited plot, and not
the composited plot itself.</p>
</td></tr>
<tr><td><code id="view_xifti_surface_+3A_zoom">zoom</code></td>
<td>
<p>Adjust the sizes of the brain meshes. Default: <code>NULL</code> (will
be set to 0.6 or 160\
widget.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a png or html file(s) were written, the names of the files for
each index (and color legend if applicable) will be returned. Otherwise,
the widget itself is returned if a widget was used, and the rgl object IDs
are returned if an Open GL window was used. The rgl object IDs are useful
for further programmatic manipulation of the Open GL window.
</p>


<h3>Navigating and Embedding the Interactive Plots</h3>

<p>To navigate the interactive Open GL window and html widget, left click and
drag the cursor to rotate the meshes. Use the scroll wheel or right click
and drag to zoom. Press the scroll wheel and drag to change the field-of-view.
For Open GL windows, execute
<code><a href="rgl.html#topic+snapshot">snapshot</a></code> to save the current window as a .png file,
<code><a href="rgl.html#topic+open3d">close3d</a></code> to close the window, and
<code><a href="rgl.html#topic+viewpoint">view3d</a></code> to programmatically control the
perspective.
</p>
<p>To embed an interactive plot in an R Markdown document, first execute
<code>rgl::setupKnitr()</code> to prepare the document for embedding the widget.
Then execute the plot command as you normally would to create a widget (i.e.
without specifying <code>fname</code>, and by requesting more than one <code>idx</code>
or by setting <code>widget</code> to <code>TRUE</code>). When the R Markdown document is
knitted, the interactive widget should be displayed below the chunk in which
the plot command was executed. See the vignette for an example.
</p>


<h3>Embedding the Static Plots</h3>

<p>To embed a static plot in an R Markdown document, first execute
<code>rgl::setupKnitr()</code> to prepare the document for embedding the snapshot
of the Open GL window. Then execute the plot command as you normally would
to create an Open GL window (i.e. without specifying <code>fname</code>, and by
requesting only one <code>idx</code>). In the options for the chunk in which the
plot command is executed, set <code>rgl=TRUE, format="png"</code>. You can also
control the image dimensions here e.g. <code>fig.height=3.8, fig.width=5</code>.
When the R Markdown document is knitted, the static plots should be
displayed below the chunk in which the plot command was executed. See the
vignette for an example.
</p>


<h3>See Also</h3>

<p>Other visualizing: 
<code><a href="#topic+view_comp">view_comp</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+view_xifti">view_xifti</a>()</code>,
<code><a href="#topic+view_xifti_volume">view_xifti_volume</a>()</code>
</p>

<hr>
<h2 id='view_xifti_surface.color'>Get the palettes and data color mapping for <code>view_xifti_surface</code></h2><span id='topic+view_xifti_surface.color'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti_surface.color(
  hemisphere,
  values,
  idx,
  colors,
  color_mode,
  zlim,
  digits,
  xifti_meta,
  surfL,
  surfR
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti_surface.color_+3A_hemisphere">hemisphere</code>, <code id="view_xifti_surface.color_+3A_values">values</code>, <code id="view_xifti_surface.color_+3A_idx">idx</code></td>
<td>
<p>idx see <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code></p>
</td></tr>
<tr><td><code id="view_xifti_surface.color_+3A_colors">colors</code>, <code id="view_xifti_surface.color_+3A_color_mode">color_mode</code>, <code id="view_xifti_surface.color_+3A_zlim">zlim</code></td>
<td>
<p>digits see
<code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code></p>
</td></tr>
<tr><td><code id="view_xifti_surface.color_+3A_xifti_meta">xifti_meta</code></td>
<td>
<p><code>xifti$meta</code></p>
</td></tr>
<tr><td><code id="view_xifti_surface.color_+3A_surfl">surfL</code>, <code id="view_xifti_surface.color_+3A_surfr">surfR</code></td>
<td>
<p>see <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries &quot;pal_base&quot;, &quot;pal&quot;, &quot;color_vals&quot;, and &quot;unique_vals&quot;
</p>

<hr>
<h2 id='view_xifti_surface.draw_mesh'>Draw brain hemisphere mesh in RGL</h2><span id='topic+view_xifti_surface.draw_mesh'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti_surface.draw_mesh(
  mesh,
  mesh_color,
  alpha,
  vertex_color,
  vertex_size,
  edge_color,
  material
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti_surface.draw_mesh_+3A_mesh">mesh</code></td>
<td>
<p>RGL brain mesh</p>
</td></tr>
<tr><td><code id="view_xifti_surface.draw_mesh_+3A_mesh_color">mesh_color</code></td>
<td>
<p>The color at each vertex</p>
</td></tr>
<tr><td><code id="view_xifti_surface.draw_mesh_+3A_alpha">alpha</code>, <code id="view_xifti_surface.draw_mesh_+3A_vertex_color">vertex_color</code>, <code id="view_xifti_surface.draw_mesh_+3A_vertex_size">vertex_size</code>, <code id="view_xifti_surface.draw_mesh_+3A_edge_color">edge_color</code></td>
<td>
<p>See
<code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly
</p>

<hr>
<h2 id='view_xifti_surface.draw_title'>Draw title in RGL</h2><span id='topic+view_xifti_surface.draw_title'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti_surface.draw_title(
  title,
  xifti_meta,
  this_idx,
  cex.title,
  text_color,
  indiv_panel_width
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti_surface.draw_title_+3A_title">title</code></td>
<td>
<p>Title text or <code>NULL</code></p>
</td></tr>
<tr><td><code id="view_xifti_surface.draw_title_+3A_xifti_meta">xifti_meta</code></td>
<td>
<p><code>xifti$meta</code></p>
</td></tr>
<tr><td><code id="view_xifti_surface.draw_title_+3A_this_idx">this_idx</code></td>
<td>
<p>The index</p>
</td></tr>
<tr><td><code id="view_xifti_surface.draw_title_+3A_cex.title">cex.title</code>, <code id="view_xifti_surface.draw_title_+3A_text_color">text_color</code></td>
<td>
<p>See <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code></p>
</td></tr>
<tr><td><code id="view_xifti_surface.draw_title_+3A_indiv_panel_width">indiv_panel_width</code></td>
<td>
<p>The width of the panel to write the title in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The RGL object ID for the title
</p>

<hr>
<h2 id='view_xifti_surface.mesh_val'>Get the mesh(es) and data values for <code>view_xifti_surface</code></h2><span id='topic+view_xifti_surface.mesh_val'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti_surface.mesh_val(
  xifti,
  surfL,
  surfR,
  hemisphere,
  idx,
  material = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti_surface.mesh_val_+3A_xifti">xifti</code></td>
<td>
<p>The <code>"xifti"</code></p>
</td></tr>
<tr><td><code id="view_xifti_surface.mesh_val_+3A_surfl">surfL</code></td>
<td>
<p>Left surface</p>
</td></tr>
<tr><td><code id="view_xifti_surface.mesh_val_+3A_surfr">surfR</code></td>
<td>
<p>Right surface</p>
</td></tr>
<tr><td><code id="view_xifti_surface.mesh_val_+3A_hemisphere">hemisphere</code></td>
<td>
<p>Hemisphere</p>
</td></tr>
<tr><td><code id="view_xifti_surface.mesh_val_+3A_idx">idx</code></td>
<td>
<p>Index</p>
</td></tr>
<tr><td><code id="view_xifti_surface.mesh_val_+3A_material">material</code></td>
<td>
<p><code>rgl</code> material properties</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries &quot;mesh&quot; and &quot;values&quot;
</p>

<hr>
<h2 id='view_xifti_surface.surf_hemi'>Sort out surface &amp; hemisphere args for <code>view_xifti_surface</code></h2><span id='topic+view_xifti_surface.surf_hemi'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti_surface.surf_hemi(xifti, surfL, surfR, hemisphere)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti_surface.surf_hemi_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="view_xifti_surface.surf_hemi_+3A_surfl">surfL</code></td>
<td>
<p>Left surface</p>
</td></tr>
<tr><td><code id="view_xifti_surface.surf_hemi_+3A_surfr">surfR</code></td>
<td>
<p>Right surface</p>
</td></tr>
<tr><td><code id="view_xifti_surface.surf_hemi_+3A_hemisphere">hemisphere</code></td>
<td>
<p>Hemisphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries &quot;surfL&quot;, &quot;surfR&quot; and &quot;hemisphere&quot;
</p>

<hr>
<h2 id='view_xifti_volume'>View subcortical data in a <code>"xifti"</code></h2><span id='topic+view_xifti_volume'></span><span id='topic+view_cifti_volume'></span><span id='topic+viewCIfTI_volume'></span><span id='topic+viewcii_volume'></span>

<h3>Description</h3>

<p>Visualize the subcortical data in a <code>"xifti"</code> using a series of 2D
slices (based on <code><a href="oro.nifti.html#topic+overlay">overlay</a></code>) or an interactive widget
(based on <code>papayar::papaya</code>). Note: <code>papayar</code> has been removed
from CRAN so the widget is not available. If <code>papayar</code> returns to CRAN
the widget will be made available again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti_volume(
  xifti,
  structural_img = "MNI",
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  structural_img_colors = gray(0:255/280),
  title = NULL,
  idx = NULL,
  plane = c("axial", "sagittal", "coronal"),
  convention = c("neurological", "radiological"),
  n_slices = 9,
  slices = NULL,
  together = NULL,
  together_ncol = NULL,
  together_title = NULL,
  widget = FALSE,
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  fname_sub = FALSE,
  legend_fname = "[fname]_legend",
  legend_ncol = NULL,
  legend_alllevels = FALSE,
  legend_embed = NULL,
  digits = NULL,
  scientific = NA,
  cex.title = NULL,
  ypos.title = 0,
  xpos.title = 0,
  orientation_labels = TRUE,
  crop = TRUE,
  text_color = "white",
  bg = NULL,
  width = NULL,
  height = NULL,
  ...
)

view_cifti_volume(
  xifti,
  structural_img = "MNI",
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  structural_img_colors = gray(0:255/280),
  title = NULL,
  idx = NULL,
  plane = c("axial", "sagittal", "coronal"),
  convention = c("neurological", "radiological"),
  n_slices = 9,
  slices = NULL,
  together = NULL,
  together_ncol = NULL,
  together_title = NULL,
  widget = FALSE,
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  fname_sub = FALSE,
  legend_fname = "[fname]_legend",
  legend_ncol = NULL,
  legend_alllevels = FALSE,
  legend_embed = NULL,
  digits = NULL,
  scientific = NA,
  cex.title = NULL,
  ypos.title = 0,
  xpos.title = 0,
  orientation_labels = TRUE,
  crop = TRUE,
  text_color = "white",
  bg = NULL,
  width = NULL,
  height = NULL,
  ...
)

viewCIfTI_volume(
  xifti,
  structural_img = "MNI",
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  structural_img_colors = gray(0:255/280),
  title = NULL,
  idx = NULL,
  plane = c("axial", "sagittal", "coronal"),
  convention = c("neurological", "radiological"),
  n_slices = 9,
  slices = NULL,
  together = NULL,
  together_ncol = NULL,
  together_title = NULL,
  widget = FALSE,
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  fname_sub = FALSE,
  legend_fname = "[fname]_legend",
  legend_ncol = NULL,
  legend_alllevels = FALSE,
  legend_embed = NULL,
  digits = NULL,
  scientific = NA,
  cex.title = NULL,
  ypos.title = 0,
  xpos.title = 0,
  orientation_labels = TRUE,
  crop = TRUE,
  text_color = "white",
  bg = NULL,
  width = NULL,
  height = NULL,
  ...
)

viewcii_volume(
  xifti,
  structural_img = "MNI",
  color_mode = "auto",
  zlim = NULL,
  colors = NULL,
  structural_img_colors = gray(0:255/280),
  title = NULL,
  idx = NULL,
  plane = c("axial", "sagittal", "coronal"),
  convention = c("neurological", "radiological"),
  n_slices = 9,
  slices = NULL,
  together = NULL,
  together_ncol = NULL,
  together_title = NULL,
  widget = FALSE,
  fname = FALSE,
  fname_suffix = c("names", "idx"),
  fname_sub = FALSE,
  legend_fname = "[fname]_legend",
  legend_ncol = NULL,
  legend_alllevels = FALSE,
  legend_embed = NULL,
  digits = NULL,
  scientific = NA,
  cex.title = NULL,
  ypos.title = 0,
  xpos.title = 0,
  orientation_labels = TRUE,
  crop = TRUE,
  text_color = "white",
  bg = NULL,
  width = NULL,
  height = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti_volume_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_structural_img">structural_img</code></td>
<td>
<p>The structural MRI image on which to overlay the
subcortical plot. Can be a file name, <code>"MNI"</code> (default) to use
the MNI T1-weighted template included in <code>ciftiTools</code>, or <code>NULL</code>
to use a blank image.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_color_mode">color_mode</code></td>
<td>
<p>(Optional) <code>"sequential"</code>, <code>"qualitative"</code>,
<code>"diverging"</code>, or <code>"auto"</code> (default). Auto mode will use the
qualitative color mode if the <code>"xifti"</code> object represents a .dlabel
CIFTI (intent 3007). Otherwise, it will use the diverging mode if the data
contains both positive and negative values, and the sequential mode if the
data contains &gt;90\
<code><a href="#topic+make_color_pal">make_color_pal</a></code> for more details.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_zlim">zlim</code></td>
<td>
<p>(Optional) Controls the mapping of values to each
color in <code>colors</code>. If the length is longer than
one, using -Inf will set the value to the data minimum, and Inf will set
the value to the data maximum. See <code><a href="#topic+make_color_pal">make_color_pal</a></code>
description for more details.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_colors">colors</code></td>
<td>
<p>(Optional) <code>"ROY_BIG_BL"</code>, vector of colors to use,
the name of a ColorBrewer palette (see <code>RColorBrewer::brewer.pal.info</code>
and colorbrewer2.org), the name of a viridisLite palette, or a data.frame
with columns <code>"color"</code> and <code>"value"</code> (will override <code>zlim</code>).
If <code>NULL</code>
(default), will use the positive half of <code>"ROY_BIG_BL"</code> (sequential),
<code>"Set2"</code> (qualitative), or the full <code>"ROY_BIG_BL"</code> (diverging). An
exception to these defaults is if the <code>"xifti"</code> object represents a
.dlabel CIFTI (intent 3007), in which case the colors in the label table
will be used. See <code><a href="#topic+make_color_pal">make_color_pal</a></code> for more details.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_structural_img_colors">structural_img_colors</code></td>
<td>
<p>Colors to use for the background image. These
will be assigned in order from lowest to highest value with equal spacing
between the colors. (<code>color_mode</code>, <code>zlim</code> and <code>colors</code> have
no bearing on the background image colors.) This argument is used as
the <code>col.x</code> argument to <code>oro.nifti::overlay</code> directly. Default:
<code>gray(0:255/280)</code>. To use the <code>oro.nifti::overlay</code> default instead
set this argument to <code>gray(0:64/64)</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_title">title</code></td>
<td>
<p>Optional title(s) for the plot(s). It will be printed at the top.
</p>
<p>Default: <code>NULL</code> will not use any title if <code>length(idx)==1</code>.
Otherwise, it will use the time index (&quot;.dtseries&quot;) or name
(.dscalar or .dlabel) of each data column.
</p>
<p>To use a custom title(s), use a length 1 character vector (same title for
each plot) or length <code>length(idx)</code> character vector (different title
for each plot). Set to <code>NULL</code> or an empty character to omit the title.
</p>
<p>If the title is non-empty but does not appear, try lowering <code>cex.title</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_idx">idx</code></td>
<td>
<p>The time/column index of the data to display. <code>NULL</code> (default)
will display the first column.
</p>
<p>If <code>widget</code>, only one index at a time may be displayed.
</p>
<p>If <code>!widget</code> and the length of <code>idx</code> is greater than one, a new
plot will be created for each <code>idx</code>. These can be toggled between using
the arrows at the top of the display window if working interactively in
<code>RStudio</code>; or, these will be written to separate files if
<code>!isFALSE(fname)</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_plane">plane</code></td>
<td>
<p>The plane to display for the slices:
<code>"axial"</code> (default), <code>"sagittal"</code> or <code>"coronal"</code>.
Ignored if <code>widget</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_convention">convention</code></td>
<td>
<p><code>"neurological"</code> (default) or <code>"radiological"</code>.
Neurological convention will display the left side of the brain on the left
side of axial and coronal images, and in the first few slices of a series of
sagittal images. Radiological convention will display the right side of the
brain on the left side of axial and coronal images, and in the first few
slices of a series of sagittal images.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_n_slices">n_slices</code></td>
<td>
<p>The number of slices to display. Default: <code>9</code>.
The slices will be selected in a way that visualizes as much of the
subcortex as possible. Ignored if <code>widget</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_slices">slices</code></td>
<td>
<p>Which slices to display. If provided, this argument will
override <code>n_slices</code>. Should be a numeric vector with integer values
between one and the number of slices in <code>plane</code>. Ignored if <code>widget</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_together">together</code></td>
<td>
<p>Only applies if saving image files (<code>!isFALSE(fname)</code>).
Use this argument to create and save a composite image which combines
multiple plots. <code>NULL</code> (default) will not combine any plots. Otherwise,
this argument should be a character vector with one or more of the
following entries:
</p>
<p><code>"leg"</code> to combine the color legend with each <code>"xifti"</code> data plot.
Overrides/ignores <code>legend_embed</code>.
</p>
<p><code>"idx"</code> to place all the plots for the different <code>"idx"</code> in a grid.
If the data is not qualitative, a shared color bar will be added to the bottom
of the composite. If the data is qualitative, a shared color legend will be
added to the bottom only if <code>"leg"</code> is in <code>together</code>.
For greater control see <code>view_comp</code> or <code>grid::arrangeGrob</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_together_ncol">together_ncol</code></td>
<td>
<p>If <code>"idx" %in% together</code>, this determines the number
of columns to use in the array of subplots for different indices.
By default, the number of columns and rows will be determined such that they
are about equal.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_together_title">together_title</code></td>
<td>
<p>If a composite image is made based on <code>together</code>,
use this argument to add a grand title to the composite image. Should be
a length-one character vector or <code>NULL</code> (default) to not add a grand title.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_widget">widget</code></td>
<td>
<p>Create an interactive widget using <code>papayar</code>? Otherwise
display static 2D slices. Default: <code>FALSE</code>.
</p>
<p>Note that the widget can only display one <code>idx</code> at a time.
</p>
<p>Note: <code>papayar</code> has been removed
from CRAN so the widget is not available. If <code>papayar</code> returns to CRAN
the widget will be made available again.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_fname">fname</code>, <code id="view_xifti_volume_+3A_fname_suffix">fname_suffix</code></td>
<td>
<p>Save the plot(s) (and color legend if applicable)?
</p>
<p>If <code>isFALSE(fname)</code> (default), no files will be written.
</p>
<p>If <code>widget</code>, these arguments are ignored.
</p>
<p>If neither of the cases above apply, a png image will be written for each
<code>idx</code>. If <code>isTRUE(fname)</code> the files will be named by the
data column names (underscores will replace spaces). Or, set <code>fname</code> to a
length 1 character vector to name files by this suffix followed by the
<code>fname_suffix</code>: either the data column names (<code>"names"</code>) or the
index value (<code>"idx"</code>). Or, set <code>fname</code> to a character vector with the same
length as <code>idx</code> to name the files exactly.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_fname_sub">fname_sub</code></td>
<td>
<p>Add &quot;_sub&quot; to the end of the names of the files being saved?
Default: <code>FALSE</code>. This is useful if cortical plots of the same data are being
saved too.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_legend_fname">legend_fname</code></td>
<td>
<p>Save the color legend? Since the legend is the same
for each <code>idx</code> only one legend is written even if <code>length(idx)&gt;1</code>.
This argument can be <code>NULL</code> to not save the legend, an exact file
path, or a length-one character vector with &quot;[fname]&quot; in it, which will
name the legend based on <code>fname\[1\]</code>. For example, if <code>fname\[1\]</code>
is <code>"plots/my_cifti.png"</code> and <code>legend_fname</code> is <code>"\[fname\]_legend"</code>
(default), then the legend plot will be saved to <code>"plots/my_cifti_legend.png"</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_legend_ncol">legend_ncol</code></td>
<td>
<p>Number of columns in color legend. If
<code>NULL</code> (default), use 10 entries per row. Only applies if the color
legend is used (qualitative data).</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_legend_alllevels">legend_alllevels</code></td>
<td>
<p>Show all label levels in the color legend? If
<code>FALSE</code> (default), just show the levels present in the data being
viewed. Only applies if the color legend is used (qualitative data).</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_legend_embed">legend_embed</code></td>
<td>
<p>Should the colorbar be embedded in the plot?
It will be positioned at the bottom. Default: <code>TRUE</code>.
If <code>FALSE</code>, print/save it separately instead.
</p>
<p>Only applies if the color bar is used (sequential or diverging data).
The color legend (qualitative data) cannot be embedded at the moment.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_digits">digits</code></td>
<td>
<p>The number of digits for the colorbar legend ticks.
If <code>NULL</code> (default), let <code><a href="base.html#topic+format">format</a></code> decide.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_scientific">scientific</code></td>
<td>
<p>Use scientific notation? If <code>NA</code> (default), let
<code><a href="base.html#topic+format">format</a></code> decide.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_cex.title">cex.title</code></td>
<td>
<p>Font size multiplier for the title. <code>NULL</code> (default)
will use <code>1.2</code> for titles less than 20 characters long, and smaller
sizes for increasingly longer titles. If saving a PNG and PDF file, the default
will also scale with <code>width</code> relative to the default value of <code>width</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_ypos.title">ypos.title</code>, <code id="view_xifti_volume_+3A_xpos.title">xpos.title</code></td>
<td>
<p>The positioning of the title can be finicky,
especially when using an R Markdown document interactively in which case it
appears too high in the plot. Use these arguments to nudge the title up
or down (<code>ypos.title</code>) or left or right (<code>xpos.title</code>).</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_orientation_labels">orientation_labels</code></td>
<td>
<p>Show orientation labels at the top left and top
right of the plot? These will indicate the directions along the left-right
axis for each slice image. Default: <code>TRUE</code>. Ignored if <code>widget</code>.
The vertical positioning is controlled by <code>ypos.title</code>, and the font
size is controlled by <code>cex.title</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_crop">crop</code></td>
<td>
<p>Crop the slice subplots to the subcortical structures, instead of
showing the full anatomical image? Default: <code>TRUE</code>.
Ignored if <code>widget</code>.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_text_color">text_color</code></td>
<td>
<p>Color for text in title and colorbar legend. Default:
<code>"white"</code>. If <code>"white"</code>, will use black instead for the color</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_bg">bg</code></td>
<td>
<p>Background color. <code>NULL</code> will use <code>"black"</code>. Does not affect
the color legend or color bar if printed separately: those will always have
white backgrounds.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_width">width</code>, <code id="view_xifti_volume_+3A_height">height</code></td>
<td>
<p>The dimensions of the plot, in pixels. Only affects saved
images (if <code>!isFALSE(fname)</code>). If <code>NULL</code>, file dimensions will be
400 x 600 pixels for PNGs and 4 x 6 in. for PDFs.
</p>
<p>Currently, there is no way to control the
dimensions of the plot if working interactively in RStudio or creating a knitted
R Markdown document. The default appears to be a wide aspect ratio.</p>
</td></tr>
<tr><td><code id="view_xifti_volume_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>papayar::papaya</code> or <code>oro.nifti::overlay</code>.
Note that for <code>oro.nifti::overlay</code> the following additional arguments
should not be provided since they are pre-determined inside this function
or by the arguments listed above:
<code>x</code>, <code>y</code>, <code>plane</code>, <code>col.y</code>, <code>col.x</code>, <code>zlim.y</code>,
<code>oma</code>, <code>plot.type</code>, <code>bg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>color_mode</code>, <code>zlim</code>, and <code>colors</code> only affect the
color scale of the data values whereas <code>structural_img_colors</code> only
affects the color scale of the background image.
</p>
<p>Currently, the color-related arguments only affect the 2D slice view. The
color limits and palette must be edited using the widget controls once it's
rendered.
</p>
<p>Arguments concerning anatomical orientation assume that the subcortical data
is stored in the following way: first dimension is normal to the sagittal
plane, going left to right; second dimension is normal to the coronal plane,
going from the front of the head (anterior) to the back (posterior); third
dimension is normal to the axial plane, going from the top of the head
(superior) to the neck (inferior).
</p>
<p>For non-interactive plots, if <code>n_slices &gt; 1</code> and <code>convention="neurological"</code>,
axial slices are ordered from the neck (inferior) to the top of the head
(superior), sagittal slices are ordered left to right, and coronal slices
are ordered back (posterior) to front (anterior). If
<code>convention="radiological"</code>, sagittal slices are instead ordered right
to left.
</p>


<h3>Value</h3>

<p>If a png or pdf file(s) were written, the names of the files for
each index (and color legend if applicable) will be returned. Otherwise,
<code>NULL</code> is invisibly returned.
</p>


<h3>See Also</h3>

<p>Other visualizing: 
<code><a href="#topic+view_comp">view_comp</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>,
<code><a href="#topic+view_xifti">view_xifti</a>()</code>,
<code><a href="#topic+view_xifti_surface">view_xifti_surface</a>()</code>
</p>

<hr>
<h2 id='view_xifti.cbar'>Make the colorbar for <code>view_xifti_surface</code></h2><span id='topic+view_xifti.cbar'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti.cbar(pal_base, pal, color_mode, text_color, digits, scientific = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti.cbar_+3A_pal_base">pal_base</code></td>
<td>
<p>Base palette</p>
</td></tr>
<tr><td><code id="view_xifti.cbar_+3A_pal">pal</code></td>
<td>
<p>Full palette</p>
</td></tr>
<tr><td><code id="view_xifti.cbar_+3A_color_mode">color_mode</code></td>
<td>
<p>See <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code></p>
</td></tr>
<tr><td><code id="view_xifti.cbar_+3A_text_color">text_color</code></td>
<td>
<p>Color of text</p>
</td></tr>
<tr><td><code id="view_xifti.cbar_+3A_digits">digits</code></td>
<td>
<p>See <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of keyword arguments to <code><a href="fields.html#topic+image.plot">image.plot</a></code>
</p>

<hr>
<h2 id='view_xifti.cleg'>Draw color legend for qualitative mode</h2><span id='topic+view_xifti.cleg'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+view_xifti_surface">view_xifti_surface</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti.cleg(pal_base, leg_ncol, text_color, scale = 1, title_sub = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti.cleg_+3A_pal_base">pal_base</code></td>
<td>
<p>Base palette + labels for each row</p>
</td></tr>
<tr><td><code id="view_xifti.cleg_+3A_leg_ncol">leg_ncol</code></td>
<td>
<p>Number of columns in legend.</p>
</td></tr>
<tr><td><code id="view_xifti.cleg_+3A_text_color">text_color</code></td>
<td>
<p>Color of text</p>
</td></tr>
<tr><td><code id="view_xifti.cleg_+3A_scale">scale</code></td>
<td>
<p>of text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A color legend from ggplot2
</p>

<hr>
<h2 id='view_xifti.title'>Get title for <code>view_xifti_surface</code> or <code>view_xifti_volume</code></h2><span id='topic+view_xifti.title'></span>

<h3>Description</h3>

<p>Determine the title(s) for the cortical surface or subcortical volume plot,
if it was not provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_xifti.title(xifti_meta, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_xifti.title_+3A_xifti_meta">xifti_meta</code></td>
<td>
<p><code>xifti$meta</code></p>
</td></tr>
<tr><td><code id="view_xifti.title_+3A_idx">idx</code></td>
<td>
<p>The index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The RGL object ID for the title
</p>

<hr>
<h2 id='vox_locations'>Get spatial locations of each voxel</h2><span id='topic+vox_locations'></span>

<h3>Description</h3>

<p>Use subcortical metadata (mask, transformation matrix and units) to get
voxel locations in 3D space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vox_locations(mask, trans_mat, trans_units = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vox_locations_+3A_mask">mask</code>, <code id="vox_locations_+3A_trans_mat">trans_mat</code>, <code id="vox_locations_+3A_trans_units">trans_units</code></td>
<td>
<p>The subcortical metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list: <code>coords</code> and <code>units</code>
</p>

<hr>
<h2 id='wb_path_request'>Request <code>"wb_path"</code></h2><span id='topic+wb_path_request'></span>

<h3>Description</h3>

<p>Print a message requesting that the <code>ciftiTools</code> option <code>"wb_path"</code>
be set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wb_path_request()
</code></pre>


<h3>Value</h3>

<p>The message (length 1 character vector)
</p>

<hr>
<h2 id='welcome_msg'>Welcome message</h2><span id='topic+welcome_msg'></span>

<h3>Description</h3>

<p>Print the welcome message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>welcome_msg()
</code></pre>


<h3>Value</h3>

<p>The message (length 1 character vector)
</p>

<hr>
<h2 id='write_cifti'>Write a CIFTI file from a <code>"xifti"</code> object</h2><span id='topic+write_cifti'></span><span id='topic+writeCIfTI'></span><span id='topic+writecii'></span><span id='topic+write_xifti'></span>

<h3>Description</h3>

<p>Write out a <code>"xifti"</code> object as a CIFTI file and (optionally) GIFTI
surface files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_cifti(
  xifti,
  cifti_fname,
  surfL_fname = NULL,
  surfR_fname = NULL,
  verbose = TRUE
)

writeCIfTI(
  xifti,
  cifti_fname,
  surfL_fname = NULL,
  surfR_fname = NULL,
  verbose = TRUE
)

writecii(
  xifti,
  cifti_fname,
  surfL_fname = NULL,
  surfR_fname = NULL,
  verbose = TRUE
)

write_xifti(
  xifti,
  cifti_fname,
  surfL_fname = NULL,
  surfR_fname = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_cifti_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="write_cifti_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
<tr><td><code id="write_cifti_+3A_surfl_fname">surfL_fname</code>, <code id="write_cifti_+3A_surfr_fname">surfR_fname</code></td>
<td>
<p>If the [left/right] surface is present, it
will be a written to a GIFTI file at this file path. If <code>NULL</code>
(default), do not write out the surface.</p>
</td></tr>
<tr><td><code id="write_cifti_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+write_xifti2">write_xifti2</a></code> to write a <code>"xifti"</code> object out as
separate GIFTI and/or NIFTI files instead.
</p>


<h3>Value</h3>

<p>Named character vector of the written files
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-cifti-create-dense-timeseries"</code>,
<code>"-cifti-create-dense-scalar"</code>, or <code>"-cifti-create-label"</code> Workbench
Command, depending on the input.
</p>


<h3>See Also</h3>

<p>Other common: 
<code><a href="#topic+is.cifti">is.cifti</a>()</code>,
<code><a href="#topic+read_cifti">read_cifti</a>()</code>,
<code><a href="#topic+resample_cifti">resample_cifti</a>()</code>,
<code><a href="#topic+smooth_cifti">smooth_cifti</a>()</code>,
<code><a href="#topic+view_xifti">view_xifti</a>()</code>
</p>
<p>Other writing: 
<code><a href="#topic+separate_cifti">separate_cifti</a>()</code>,
<code><a href="#topic+write_metric_gifti">write_metric_gifti</a>()</code>,
<code><a href="#topic+write_subcort_nifti">write_subcort_nifti</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>,
<code><a href="#topic+write_xifti2">write_xifti2</a>()</code>
</p>

<hr>
<h2 id='write_cifti_from_separate'>Write a CIFTI file from NIFTI and GIFTI files</h2><span id='topic+write_cifti_from_separate'></span>

<h3>Description</h3>

<p>Make a CIFTI file from component NIFTI/GIFTI files using the
<code>-cifti-create-...</code> Connectome Workbench commands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_cifti_from_separate(
  cifti_fname,
  cortexL_fname = NULL,
  ROIcortexL_fname = NULL,
  cortexR_fname = NULL,
  ROIcortexR_fname = NULL,
  subcortVol_fname = NULL,
  subcortLabs_fname = NULL,
  timestep = NULL,
  timestart = NULL,
  names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_cifti_from_separate_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>Path to the CIFTI to write.</p>
</td></tr>
<tr><td><code id="write_cifti_from_separate_+3A_cortexl_fname">cortexL_fname</code></td>
<td>
<p>The left cortex file.</p>
</td></tr>
<tr><td><code id="write_cifti_from_separate_+3A_roicortexl_fname">ROIcortexL_fname</code></td>
<td>
<p>The left cortex ROI file.</p>
</td></tr>
<tr><td><code id="write_cifti_from_separate_+3A_cortexr_fname">cortexR_fname</code></td>
<td>
<p>The right cortex file.</p>
</td></tr>
<tr><td><code id="write_cifti_from_separate_+3A_roicortexr_fname">ROIcortexR_fname</code></td>
<td>
<p>The right cortex ROI file.</p>
</td></tr>
<tr><td><code id="write_cifti_from_separate_+3A_subcortvol_fname">subcortVol_fname</code></td>
<td>
<p>The subcortical data file.</p>
</td></tr>
<tr><td><code id="write_cifti_from_separate_+3A_subcortlabs_fname">subcortLabs_fname</code></td>
<td>
<p>The subcortical labels file.</p>
</td></tr>
<tr><td><code id="write_cifti_from_separate_+3A_timestep">timestep</code></td>
<td>
<p>If a dense time series (&quot;dtseries.nii&quot;) file is being written,
this is the time between measurements. If <code>NULL</code>, use the Connectome
Workbench default (1.0).</p>
</td></tr>
<tr><td><code id="write_cifti_from_separate_+3A_timestart">timestart</code></td>
<td>
<p>If a dense time series (&quot;dtseries.nii&quot;) file is being written,
this is starting time. If <code>NULL</code>, use the Connectome Workbench default
(0.0).</p>
</td></tr>
<tr><td><code id="write_cifti_from_separate_+3A_names">names</code></td>
<td>
<p>For &quot;dscalar.nii&quot; or &quot;dlabel.nii&quot;, these are the column names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every provided component will be included. The ROIs are only used if the
corresponding cortex is provided. Either both or none of the subcortical
NIFTIs should be provided.
</p>

<hr>
<h2 id='write_dir_Param_generic'>write_dir: generic</h2><span id='topic+write_dir_Param_generic'></span>

<h3>Description</h3>

<p>write_dir: generic
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_dir_Param_generic_+3A_write_dir">write_dir</code></td>
<td>
<p>Where should the separate files be placed? <code>NULL</code>
(default) will write them to the current working directory.
</p>
<p><code>write_dir</code> must already exist, or an error will occur.</p>
</td></tr>
</table>

<hr>
<h2 id='write_label_table'>Write label table to text file</h2><span id='topic+write_label_table'></span>

<h3>Description</h3>

<p>Write <code>xii$meta$cifti$labels[[idx]]</code> to a text file for use with the
Connectome Workbench command <code>-volume-label-import</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_label_table(label_table, fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_label_table_+3A_label_table">label_table</code></td>
<td>
<p>The label table (one at a time!)</p>
</td></tr>
<tr><td><code id="write_label_table_+3A_fname">fname</code></td>
<td>
<p>Where to write the label table text file</p>
</td></tr>
</table>

<hr>
<h2 id='write_metric_gifti'>Write a data matrix to a GIFTI metric file</h2><span id='topic+write_metric_gifti'></span>

<h3>Description</h3>

<p>Write the data for the left or right cortex to a metric GIFTI file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_metric_gifti(
  x,
  gifti_fname,
  hemisphere = c("left", "right"),
  intent = NULL,
  data_type = NULL,
  encoding = NULL,
  endian = c("LittleEndian", "BigEndian"),
  col_names = NULL,
  label_table = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_metric_gifti_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">V \times T</code> data matrix (V vertices, T measurements). This can also
be an object from <code>gifti::readgii</code>, or a length <code class="reqn">T</code> list of length
<code class="reqn">V</code> vectors.</p>
</td></tr>
<tr><td><code id="write_metric_gifti_+3A_gifti_fname">gifti_fname</code></td>
<td>
<p>Where to write the GIFTI file.</p>
</td></tr>
<tr><td><code id="write_metric_gifti_+3A_hemisphere">hemisphere</code></td>
<td>
<p><code>"left"</code> (default) or <code>"right"</code>. Ignored if
<code>data</code> is already a <code>"gifti"</code> object.</p>
</td></tr>
<tr><td><code id="write_metric_gifti_+3A_intent">intent</code></td>
<td>
<p>&quot;NIFTI_INTENT_*&quot;. <code>NULL</code> (default) will use
metadata if <code>data</code> is a <code>"gifti"</code> object, or &quot;NONE&quot; if it cannot be
inferred. If not <code>NULL</code> and <code>data</code> is a <code>"gifti"</code> object, it will
overwrite the existing intent. See
https://nifti.nimh.nih.gov/nifti-1/documentation/nifti1fields/nifti1fields_pages/group__NIFTI1__INTENT__CODES.html/document_view .</p>
</td></tr>
<tr><td><code id="write_metric_gifti_+3A_data_type">data_type</code></td>
<td>
<p>the type of <code>data</code>:
&quot;NIFTI_TYPE_*&quot; where * is &quot;INT32&quot; or &quot;FLOAT32&quot;. If <code>NULL</code> (default), the
data type will be inferred. If not <code>NULL</code> and <code>data</code> is a
<code>"gifti"</code> object, it will overwrite the existing data type.</p>
</td></tr>
<tr><td><code id="write_metric_gifti_+3A_encoding">encoding</code></td>
<td>
<p>One of &quot;ASCII&quot;, &quot;Base64Binary&quot;, or &quot;GZipBase64Binary&quot;. If
<code>NULL</code> (default), will use the metadata if <code>data</code> is a GIFTI object,
or &quot;ASCII&quot; if the <code>data_type</code> is &quot;NIFTI_TYPE_INT32&quot; and
&quot;GZipBase64Binary&quot; if the <code>data_type</code> is &quot;NIFTI_TYPE_FLOAT32&quot;. If not
<code>NULL</code> and <code>data</code> is a <code>"gifti"</code> object, it will overwrite the
existing data type.</p>
</td></tr>
<tr><td><code id="write_metric_gifti_+3A_endian">endian</code></td>
<td>
<p>&quot;LittleEndian&quot; (default) or &quot;BigEndian&quot;. If <code>data</code> is a
<code>"gifti"</code> object, it will overwrite the existing endian.</p>
</td></tr>
<tr><td><code id="write_metric_gifti_+3A_col_names">col_names</code></td>
<td>
<p>The names of each data column in <code>gii</code> (or entries in
<code>gii$data</code>).</p>
</td></tr>
<tr><td><code id="write_metric_gifti_+3A_label_table">label_table</code></td>
<td>
<p>A data.frame with labels along rows. The row names should
be the label names. The column names should be among: &quot;Key&quot;, &quot;Red&quot;, &quot;Green&quot;,
&quot;Blue&quot;, and &quot;Alpha&quot;. The &quot;Key&quot; column is required whereas the others are
optional (but very often included). Values in the &quot;Key&quot; column should be
non-negative integers, typically beginning with 0. The other columns should
be floating-point numbers between 0 and 1.
</p>
<p>Although CIFTI files support a different label table for each data column,
GIFTI files only support a single label table. So this label table should be
applicable to each data column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Whether the GIFTI was successfully written
</p>


<h3>See Also</h3>

<p>Other writing: 
<code><a href="#topic+separate_cifti">separate_cifti</a>()</code>,
<code><a href="#topic+write_cifti">write_cifti</a>()</code>,
<code><a href="#topic+write_subcort_nifti">write_subcort_nifti</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>,
<code><a href="#topic+write_xifti2">write_xifti2</a>()</code>
</p>

<hr>
<h2 id='write_spheres'>Generate GIFTI sphere surface files</h2><span id='topic+write_spheres'></span>

<h3>Description</h3>

<p>This function generates a pair of GIFTI vertex-matched left and right spheres
in the target resolution. These are required for resampling CIFTI and GIFTI
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_spheres(sphereL_fname, sphereR_fname, resamp_res, write_dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_spheres_+3A_spherel_fname">sphereL_fname</code></td>
<td>
<p>File path to left-hemisphere spherical GIFTI to be
created</p>
</td></tr>
<tr><td><code id="write_spheres_+3A_spherer_fname">sphereR_fname</code></td>
<td>
<p>File path to right-hemisphere spherical GIFTI to be
created</p>
</td></tr>
<tr><td><code id="write_spheres_+3A_resamp_res">resamp_res</code></td>
<td>
<p>Target resolution for resampling (number of
cortical surface vertices per hemisphere).</p>
</td></tr>
<tr><td><code id="write_spheres_+3A_write_dir">write_dir</code></td>
<td>
<p>(Optional) directory to place the sphere files in. If
<code>NULL</code> (default), do not append any directory to the sphere file paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The names of the written sphere files, invisibly
</p>

<hr>
<h2 id='write_subcort_nifti'>Write subcortical data to NIFTI files</h2><span id='topic+write_subcort_nifti'></span>

<h3>Description</h3>

<p>Write subcortical data to NIFTI files representing the data values,
subcortical structure labels, and volumetric mask. The input formats of
<code>subcortVol</code>, <code>subcortLabs</code>, and <code>subcortMask</code>
correspond to the data structures of <code>xifti$data$subcort</code>,
<code>xifti$meta$subcort$labels</code> , and <code>xifti$meta$subcort$mask</code>
respectively. <code>subcortVol</code> and <code>subcortLabs</code> should be vectorized,
so if they are volumes consider using <code>RNifti::writeNIfTI</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_subcort_nifti(
  subcortVol,
  subcortLabs,
  subcortMask,
  trans_mat = NULL,
  trans_units = NULL,
  col_names = NULL,
  label_table = NULL,
  subcortVol_fname,
  subcortLabs_fname,
  ROIsubcortVol_fname = NULL,
  fill = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_subcort_nifti_+3A_subcortvol">subcortVol</code></td>
<td>
<p>A vectorized data matrix: V voxels by T measurements</p>
</td></tr>
<tr><td><code id="write_subcort_nifti_+3A_subcortlabs">subcortLabs</code></td>
<td>
<p>Numeric (0 and 3-21) or factor vector corresponding to
subcortical structure labels. See <code><a href="#topic+substructure_table">substructure_table</a></code>.</p>
</td></tr>
<tr><td><code id="write_subcort_nifti_+3A_subcortmask">subcortMask</code></td>
<td>
<p>Logical volumetric mask. Values of 0 represent out-of-mask
voxels (not subcortical), and values of 1 represent in-mask voxels
(subcortical),</p>
</td></tr>
<tr><td><code id="write_subcort_nifti_+3A_trans_mat">trans_mat</code></td>
<td>
<p>The TransformationMatrixIJKtoXYZ, or equivalently the desired
sform matrix (srow_x, srow_y and srow_z) to write. If <code>NULL</code>, do not
write it (all zeroes).</p>
</td></tr>
<tr><td><code id="write_subcort_nifti_+3A_trans_units">trans_units</code></td>
<td>
<p>The units of <code>trans_mat</code>. Currently not used.</p>
</td></tr>
<tr><td><code id="write_subcort_nifti_+3A_col_names">col_names</code></td>
<td>
<p>(Optional) Column names.</p>
</td></tr>
<tr><td><code id="write_subcort_nifti_+3A_label_table">label_table</code></td>
<td>
<p>(Optional) <code>data.frame</code> of labels and their colors.</p>
</td></tr>
<tr><td><code id="write_subcort_nifti_+3A_subcortvol_fname">subcortVol_fname</code>, <code id="write_subcort_nifti_+3A_subcortlabs_fname">subcortLabs_fname</code>, <code id="write_subcort_nifti_+3A_roisubcortvol_fname">ROIsubcortVol_fname</code></td>
<td>
<p>File path to
a NIFTI to save the corresponding data. <code>ROIsubcortVol_fname</code> is
optional but the rest is required.</p>
</td></tr>
<tr><td><code id="write_subcort_nifti_+3A_fill">fill</code></td>
<td>
<p>Values to use for out-of-mask voxels. Default: <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All file path arguments are required except <code>ROIsubcortVol_fname</code>. If
not provided, the volumetric mask will not be written. (It's redundant with
the 0 values in <code>subcortLabs_fname</code> because valid labels have positive
indexes.)
</p>
<p>Note that for label data (i.e. if <code>label_table</code> is provided) only one
label table can be saved.
</p>


<h3>Value</h3>

<p>Named character vector with the <code>"subcortVol"</code>,
<code>"subcortLabs"</code>, and <code>"ROIsubcortVol"</code> file names (if written)
</p>


<h3>Connectome Workbench</h3>

<p>This function interfaces with the <code>"-volume-label-import"</code> Workbench
Command.
</p>


<h3>See Also</h3>

<p>Other writing: 
<code><a href="#topic+separate_cifti">separate_cifti</a>()</code>,
<code><a href="#topic+write_cifti">write_cifti</a>()</code>,
<code><a href="#topic+write_metric_gifti">write_metric_gifti</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>,
<code><a href="#topic+write_xifti2">write_xifti2</a>()</code>
</p>

<hr>
<h2 id='write_surf_gifti'>Write a <code>"surf"</code> to a GIFTI surface file</h2><span id='topic+write_surf_gifti'></span><span id='topic+write_surf'></span>

<h3>Description</h3>

<p>Write the data for the left or right surface to a surface GIFTI file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_surf_gifti(
  x,
  gifti_fname,
  hemisphere = c("left", "right"),
  encoding = NULL,
  endian = c("LittleEndian", "BigEndian")
)

write_surf(
  x,
  gifti_fname,
  hemisphere = c("left", "right"),
  encoding = NULL,
  endian = c("LittleEndian", "BigEndian")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_surf_gifti_+3A_x">x</code></td>
<td>
<p>A <code>"surf"</code> object, an object from <code>gifti::readgii</code>, or a
list with elements &quot;pointset&quot; and &quot;triangle&quot;.</p>
</td></tr>
<tr><td><code id="write_surf_gifti_+3A_gifti_fname">gifti_fname</code></td>
<td>
<p>Where to write the GIFTI file.</p>
</td></tr>
<tr><td><code id="write_surf_gifti_+3A_hemisphere">hemisphere</code></td>
<td>
<p>&quot;left&quot; (default) or &quot;right&quot;. Ignored if <code>data</code> is already
a &quot;gifti&quot; object, or if it is a <code>"surf"</code> object with the hemisphere metadata
already specified.</p>
</td></tr>
<tr><td><code id="write_surf_gifti_+3A_encoding">encoding</code></td>
<td>
<p>A length-2 vector with elements chosen among &quot;ASCII&quot;,
&quot;Base64Binary&quot;, and &quot;GZipBase64Binary&quot;. If <code>NULL</code> (default), will use
the metadata if <code>data</code> is a &quot;gifti&quot; object, or &quot;GZipBase64Binary&quot; for the
&quot;pointset&quot; and &quot;ASCII&quot; for the &quot;triangles&quot; if <code>data</code> is not already
a GIFTI.</p>
</td></tr>
<tr><td><code id="write_surf_gifti_+3A_endian">endian</code></td>
<td>
<p>&quot;LittleEndian&quot; (default) or &quot;BigEndian&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Whether the GIFTI was successfully written
</p>


<h3>See Also</h3>

<p>Other writing: 
<code><a href="#topic+separate_cifti">separate_cifti</a>()</code>,
<code><a href="#topic+write_cifti">write_cifti</a>()</code>,
<code><a href="#topic+write_metric_gifti">write_metric_gifti</a>()</code>,
<code><a href="#topic+write_subcort_nifti">write_subcort_nifti</a>()</code>,
<code><a href="#topic+write_xifti2">write_xifti2</a>()</code>
</p>
<p>Other surface-related: 
<code><a href="#topic+add_surf">add_surf</a>()</code>,
<code><a href="#topic+boundary_mask_surf">boundary_mask_surf</a>()</code>,
<code><a href="#topic+edit_mask_surf">edit_mask_surf</a>()</code>,
<code><a href="#topic+even_vert_samp">even_vert_samp</a>()</code>,
<code><a href="#topic+is.surf">is.surf</a>()</code>,
<code><a href="#topic+load_surf">load_surf</a>()</code>,
<code><a href="#topic+mask_surf">mask_surf</a>()</code>,
<code><a href="#topic+read_surf">read_surf</a>()</code>,
<code><a href="#topic+resample_surf">resample_surf</a>()</code>,
<code><a href="#topic+rotate_surf">rotate_surf</a>()</code>,
<code><a href="#topic+surf_area">surf_area</a>()</code>,
<code><a href="#topic+view_surf">view_surf</a>()</code>
</p>

<hr>
<h2 id='write_xifti2'>Write a <code>"xifti"</code> object to GIFTI and NIFTI files</h2><span id='topic+write_xifti2'></span>

<h3>Description</h3>

<p>Write metric or label GIFTIs for the cortical surface data and NIFTIs for the
subcortical labels and mask in a <code>"xifti"</code> object. Each present
brainstructure will be written; if a brainstructure is absent the
corresponding file is not written.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_xifti2(
  xifti,
  brainstructures = NULL,
  cortexL_fname = NULL,
  cortexR_fname = NULL,
  subcortVol_fname = NULL,
  subcortLabs_fname = NULL,
  ROI_brainstructures = "all",
  ROIcortexL_fname = NULL,
  ROIcortexR_fname = NULL,
  ROIsubcortVol_fname = NULL,
  write_dir = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_xifti2_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
<tr><td><code id="write_xifti2_+3A_brainstructures">brainstructures</code></td>
<td>
<p>(Optional) character vector indicating a subset of
brain structure(s) to write: <code>"left"</code> cortex, <code>"right"</code> cortex,
and/or <code>"subcortical"</code> structures. Can also be <code>"all"</code> to write
out all existing brain structures. Default: <code>c("left","right")</code>.</p>
</td></tr>
<tr><td><code id="write_xifti2_+3A_cortexl_fname">cortexL_fname</code>, <code id="write_xifti2_+3A_cortexr_fname">cortexR_fname</code></td>
<td>
<p>(Optional) GIFTI file names
(*.[func/label].gii) to save the [left/right] cortex data to.
dtseries and dscalar files should use &quot;func&quot;, whereas dlabel files should
use &quot;label&quot;.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*[L/R].\[func/label\].gii"</code>, where * is the file name component of
<code>cifti_fname</code>.</p>
</td></tr>
<tr><td><code id="write_xifti2_+3A_subcortvol_fname">subcortVol_fname</code>, <code id="write_xifti2_+3A_subcortlabs_fname">subcortLabs_fname</code></td>
<td>
<p>(Optional) NIFTI file names to save
the subcortical [volume/labels] to. Provide both or neither.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*[/.labels].nii"</code>, where * is the file name component of
<code>cifti_fname</code>.</p>
</td></tr>
<tr><td><code id="write_xifti2_+3A_roi_brainstructures">ROI_brainstructures</code></td>
<td>
<p>Which ROIs should be obtained? <code>"all"</code>
(default) to obtain ROIs for each of the <code>brainstructures</code>. <code>NULL</code>
to not obtain any ROIs. This should be a subset of <code>brainstructures</code>.</p>
</td></tr>
<tr><td><code id="write_xifti2_+3A_roicortexl_fname">ROIcortexL_fname</code>, <code id="write_xifti2_+3A_roicortexr_fname">ROIcortexR_fname</code></td>
<td>
<p>(Optional) GIFTI file names
(*.[func/label].gii) to save the [left/right] cortex ROI to.
dtseries and dscalar files should use &quot;func&quot;, whereas dlabel files should
use &quot;label&quot;.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*ROI_[L/R].\[func/label\].gii"</code>, where * is the file name component of
<code>cifti_fname</code>.
</p>
<p>The cortical ROIs typically represent the medial wall
mask, with values of 1 for in-ROI (non-medial wall) vertices and 0 for
out-of-ROI (medial wall) vertices. Will be written in <code>write_dir</code>.</p>
</td></tr>
<tr><td><code id="write_xifti2_+3A_roisubcortvol_fname">ROIsubcortVol_fname</code></td>
<td>
<p>(Optional) NIFTI file names to save
the subcortical ROI to.
</p>
<p>If <code>NULL</code> and <code>write_dir</code> is provided, defaults to
<code>"*ROI.nii"</code>, where * is the file name component of
<code>cifti_fname</code>.
</p>
<p>The subcortical ROI typically represents the volumetric
mask for the entire subcortical structure, with values of 1 for in-ROI
(in subcortex) voxels and 0 for out-of-ROI (not in subcortex) voxels. Will
be written in <code>write_dir</code>.</p>
</td></tr>
<tr><td><code id="write_xifti2_+3A_write_dir">write_dir</code></td>
<td>
<p>(Optional) A path to an existing directory. If provided,
every component in the <code>"xifti"</code> will be written to this directory,
using automatically-generated names if their <code>*_fname</code> argument was
not provided. Otherwise if <code>write_dir</code> is <code>NULL</code>, only the
components for which their <code>*_fname</code> was provided will be written.</p>
</td></tr>
<tr><td><code id="write_xifti2_+3A_verbose">verbose</code></td>
<td>
<p>Should occasional updates be printed? Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of written files
</p>


<h3>See Also</h3>

<p>Other writing: 
<code><a href="#topic+separate_cifti">separate_cifti</a>()</code>,
<code><a href="#topic+write_cifti">write_cifti</a>()</code>,
<code><a href="#topic+write_metric_gifti">write_metric_gifti</a>()</code>,
<code><a href="#topic+write_subcort_nifti">write_subcort_nifti</a>()</code>,
<code><a href="#topic+write_surf_gifti">write_surf_gifti</a>()</code>
</p>

<hr>
<h2 id='x_Param_xifti'>x: xifti</h2><span id='topic+x_Param_xifti'></span>

<h3>Description</h3>

<p>x: xifti
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_Param_xifti_+3A_x">x</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='xifti_Param'>xifti</h2><span id='topic+xifti_Param'></span>

<h3>Description</h3>

<p>xifti
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="xifti_Param_+3A_xifti">xifti</code></td>
<td>
<p>A <code>"xifti"</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='xml_cifti'>Get XML of a CIFTI</h2><span id='topic+xml_cifti'></span>

<h3>Description</h3>

<p>Wrapper for Connectome Workbench command
<code>-nifti-information [fname] -print-xml</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_cifti(cifti_fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_cifti_+3A_cifti_fname">cifti_fname</code></td>
<td>
<p>File path to a CIFTI file (ending in &quot;.d*.nii&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The XML as a list
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
