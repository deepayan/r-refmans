<!DOCTYPE html><html><head><title>Help for package seriation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {seriation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bertinplot'><p>Plot a Bertin Matrix</p></a></li>
<li><a href='#Chameleon'><p>2D Data Sets used for the CHAMELEON Clustering Algorithm</p></a></li>
<li><a href='#create_lines_data'><p>Create Simulated Data for Seriation Evaluation</p></a></li>
<li><a href='#criterion'><p>Criterion for a Loss/Merit Function for Data Given a Permutation</p></a></li>
<li><a href='#dissplot'><p>Dissimilarity Plot</p></a></li>
<li><a href='#get_order'><p>Extracting Order Information from a Permutation Object</p></a></li>
<li><a href='#hmap'><p>Plot Heat Map Reordered Using Seriation</p></a></li>
<li><a href='#Irish'><p>Irish Referendum Data Set</p></a></li>
<li><a href='#is.robinson'><p>Create and Recognize Robinson and Pre-Robinson Matrices</p></a></li>
<li><a href='#lle'><p>Locally Linear Embedding (LLE)</p></a></li>
<li><a href='#LS'><p>Neighborhood functions for Seriation Method SA</p></a></li>
<li><a href='#Munsingen'><p>Hodson's Munsingen Data Set</p></a></li>
<li><a href='#palette'><p>Different Useful Color Palettes</p></a></li>
<li><a href='#permutation_vector2matrix'><p>Conversion Between Permutation Vector and Permutation Matrix</p></a></li>
<li><a href='#permute'><p>Permute the Order in Various Objects</p></a></li>
<li><a href='#pimage'><p>Permutation Image Plot</p></a></li>
<li><a href='#Psych24'><p>Results of 24 Psychological Test for 8th Grade Students</p></a></li>
<li><a href='#register_DendSer'><p>Register Seriation Methods from Package DendSer</p></a></li>
<li><a href='#register_GA'><p>Register a Genetic Algorithm Seriation Method</p></a></li>
<li><a href='#register_optics'><p>Register Seriation Based on OPTICS</p></a></li>
<li><a href='#register_smacof'><p>Register Seriation Methods from Package smacof</p></a></li>
<li><a href='#register_tsne'><p>Register Seriation Based on 1D t-SNE</p></a></li>
<li><a href='#register_umap'><p>Register Seriation Based on 1D UMAP</p></a></li>
<li><a href='#registry_for_criterion_methods'><p>Registry for Criterion Methods</p></a></li>
<li><a href='#registry_for_seriaiton_methods'><p>Registry for Seriation Methods</p></a></li>
<li><a href='#reorder.hclust'><p>Reorder Dendrograms using Optimal Leaf Ordering</p></a></li>
<li><a href='#ser_dist'><p>Dissimilarities and Correlations Between Seriation Orders</p></a></li>
<li><a href='#ser_permutation'><p>Class ser_permutation &ndash; A Collection of Permutation Vectors for Seriation</p></a></li>
<li><a href='#ser_permutation_vector'><p>Class ser_permutation_vector &ndash; A Single Permutation Vector for Seriation</p></a></li>
<li><a href='#seriate'><p>Seriate Dissimilarity Matrices, Matrices or Arrays</p></a></li>
<li><a href='#seriate_best'><p>Best Seriation</p></a></li>
<li><a href='#seriation-package'><p>seriation: Infrastructure for Ordering Objects Using Seriation</p></a></li>
<li><a href='#SupremeCourt'><p>Voting Patterns in the Second Rehnquist U.S. Supreme Court</p></a></li>
<li><a href='#Townships'><p>Bertin's Characteristics of Townships</p></a></li>
<li><a href='#uniscale'><p>Unidimensional Scaling from Seriation Results</p></a></li>
<li><a href='#VAT'><p>Visual Analysis for Cluster Tendency Assessment (VAT/iVAT)</p></a></li>
<li><a href='#Wood'><p>Gene Expression Data for Wood Formation in Poplar Trees</p></a></li>
<li><a href='#Zoo'><p>Zoo Data Set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Infrastructure for Ordering Objects Using Seriation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Infrastructure for ordering objects with an implementation of several
    seriation/sequencing/ordination techniques to reorder matrices, dissimilarity
    matrices, and dendrograms. Also provides (optimally) reordered heatmaps,
    color images and clustering visualizations like dissimilarity plots, and
    visual assessment of cluster tendency plots (VAT and iVAT). Hahsler et al (2008) &lt;<a href="https://doi.org/10.18637%2Fjss.v025.i03">doi:10.18637/jss.v025.i03</a>&gt;.</td>
</tr>
<tr>
<td>Classification/ACM:</td>
<td>G.1.6, G.2.1, G.4</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mhahsler/seriation">https://github.com/mhahsler/seriation</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mhahsler/seriation/issues">https://github.com/mhahsler/seriation/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ca, cluster, colorspace, foreach, gclus, grDevices, grid,
MASS, qap, registry, stats, TSP, vegan</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dbscan, DendSer, dendextend, doParallel, GA, ggplot2, keras,
Rtsne, scales, smacof, tensorflow, testthat, umap</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>The code in src/bea.f is Copyright (C) 1991 F. Murtagh;
src/bbwrcg.f, src/arsa.f and src/bburcg.f are Copyright (C)
2005 M. Brusco, H.F. Koehn, and S. Stahl. All other code is
Copyright (C) Michael Hahsler, Christian Buchta, and Kurt
Hornik.</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AAA_check_installed.R' 'AAA_color_palette.R' 'AAA_defaults.R'
'AAA_map.R' 'AAA_parameters.R' 'AAA_registry_criterion.R'
'AAA_registry_seriate.R' 'AAA_seriation-package.R'
'Chameleon.R' 'Irish.R' 'Munsingen.R' 'Psych24.R'
'SupremeCourt.R' 'Townships.R' 'VAT.R' 'Wood.R' 'Zoo.R' 'bea.R'
'bertinplot.R' 'criterion.R' 'criterion.array.R'
'criterion.dist.R' 'criterion.matrix.R' 'dissplot.R'
'get_order.R' 'ggVAT.R' 'ggbertinplot.R' 'ggdissplot.R'
'hmap.R' 'gghmap.R' 'pimage.R' 'ggpimage.R' 'grid_helpers.R'
'lines_and_ordered_data.R' 'lle.R' 'permute.R'
'register_DendSer.R' 'register_GA.R' 'register_optics.R'
'register_smacof.R' 'register_tsne.R' 'register_umap.R'
'reorder.hclust.R' 'robinson.R' 'ser_dist.R'
'ser_permutation.R' 'ser_permutation_vector.R'
'ser_permutation_vector2matrix.R' 'seriate.R' 'seriate.dist.R'
'seriate.matrix.R' 'seriate.array.R' 'seriate.data.frame.R'
'seriate.table.R' 'seriate_AOE.R' 'seriate_ARSA_Branch-Bound.R'
'seriate_TSP.R' 'seriate_BEA.R' 'seriate_CA.R' 'seriate_GSA.R'
'seriate_HC.R' 'seriate_LLE.R' 'seriate_MDS.R' 'seriate_Mean.R'
'seriate_PCA.R' 'seriate_QAP.R' 'seriate_R2E.R' 'seriate_SGD.R'
'seriate_SPIN.R' 'seriate_VAT.R' 'seriate_best.R'
'seriate_enumerate.R' 'seriate_heatmap.R' 'seriate_identity.R'
'seriate_random.R' 'seriate_reverse.R' 'seriate_spectral.R'
'seriate_vegan.R' 'uniscale.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 00:56:33 UTC; hahsler</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Hahsler <a href="https://orcid.org/0000-0003-2716-1405"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Christian Buchta [aut, cph],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  David Barnett [ctb],
  Michael Brusco [ctb, cph],
  Michael Friendly [ctb],
  Hans-Friedrich Koehn [ctb, cph],
  Fionn Murtagh [ctb, cph],
  Stephanie Stahl [ctb, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Hahsler &lt;mhahsler@lyle.smu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bertinplot'>Plot a Bertin Matrix</h2><span id='topic+bertinplot'></span><span id='topic+panel.bars'></span><span id='topic+panel.circles'></span><span id='topic+panel.rectangles'></span><span id='topic+panel.squares'></span><span id='topic+panel.tiles'></span><span id='topic+panel.blocks'></span><span id='topic+panel.lines'></span><span id='topic+bertin_cut_line'></span><span id='topic+ggbertinplot'></span>

<h3>Description</h3>

<p>Plot a data matrix of cases and variables. Each value is represented by a
symbol. Large values are highlighted. Note that Bertin arranges the cases
horizontally and the variables as rows. The matrix can be rearranged using
seriation techniques to make structure in the data visible (see Falguerolles
et al 1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bertinplot(
  x,
  order = NULL,
  panel.function = panel.bars,
  highlight = TRUE,
  row_labels = TRUE,
  col_labels = TRUE,
  flip_axes = TRUE,
  ...
)

panel.bars(value, spacing, hl)

panel.circles(value, spacing, hl)

panel.rectangles(value, spacing, hl)

panel.squares(value, spacing, hl)

panel.tiles(value, spacing, hl)

panel.blocks(value, spacing, hl)

panel.lines(value, spacing, hl)

bertin_cut_line(x = NULL, y = NULL, col = "red")

ggbertinplot(
  x,
  order = NULL,
  geom = "bar",
  highlight = TRUE,
  row_labels = TRUE,
  col_labels = TRUE,
  flip_axes = TRUE,
  prop = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bertinplot_+3A_x">x</code></td>
<td>
<p>a data matrix. Note that following Bertin, columns are variables
and rows are cases. This behavior can be reversed using <code>reverse = TRUE</code>
in <code>options</code>.</p>
</td></tr>
<tr><td><code id="bertinplot_+3A_order">order</code></td>
<td>
<p>an object of class <code>ser_permutation</code> to rearrange <code>x</code>
before plotting.  If <code>NULL</code>, no rearrangement is performed.</p>
</td></tr>
<tr><td><code id="bertinplot_+3A_panel.function">panel.function</code></td>
<td>
<p>a function to produce the symbols. Currently available
functions are <code>panel.bars</code> (default), <code>panel.circles</code>,
<code>panel.rectangles</code>, <code>panel.tiles</code> and <code>panel.lines</code>. For
circles and squares neg. values are represented by a dashed border. For
blocks all blocks are the same size (can be used with <code>shading = TRUE</code>).</p>
</td></tr>
<tr><td><code id="bertinplot_+3A_highlight">highlight</code></td>
<td>
<p>a logical scalar indicating whether to use highlighting.
If <code>TRUE</code>, all variables with values greater than the variable-wise
mean are highlighted. To control highlighting, also a logical matrix or a
matrix with colors with the same dimensions as <code>x</code> can be supplied.</p>
</td></tr>
<tr><td><code id="bertinplot_+3A_row_labels">row_labels</code>, <code id="bertinplot_+3A_col_labels">col_labels</code></td>
<td>
<p>a logical indicating if row and column labels
in <code>x</code> should be displayed.  If <code>NULL</code> then labels are displayed
if the <code>x</code> contains the appropriate dimname and the number of labels is
25 or less. A character vector of the appropriate length with labels can
also be supplied.</p>
</td></tr>
<tr><td><code id="bertinplot_+3A_flip_axes">flip_axes</code></td>
<td>
<p>logical indicating whether to swap cases and variables in
the plot. The default (<code>TRUE</code>) is to plot cases as columns and
variables as rows.</p>
</td></tr>
<tr><td><code id="bertinplot_+3A_...">...</code></td>
<td>
<p><code>ggbertinplot()</code>: further parameters are passed on to <code><a href="#topic+ggpimage">ggpimage()</a></code>.
</p>
<p><code>bertinplot()</code>: further parameters can include:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;xlab, ylab&#8288;</code> labels (default: use labels from <code>x</code>).
</p>
</li>
<li> <p><code>spacing</code> relative space between symbols (default: 0.2).
</p>
</li>
<li> <p><code>shading</code> use gray shades to encode value instead of
highlighting (default: <code>FALSE</code>).
</p>
</li>
<li> <p><code>shading.function</code> a function that accepts a single argument in range <code class="reqn">[.1, .8]</code>
and returns a valid corresponding color (e.g., using <code><a href="grDevices.html#topic+rgb">rgb()</a></code>).
</p>
</li>
<li> <p><code>frame</code> plot a grid to separate symbols (default: <code>FALSE</code>).
</p>
</li>
<li> <p><code>mar</code> margins (see <code><a href="graphics.html#topic+par">par()</a></code>).
</p>
</li>
<li> <p><code>gp_labels</code> <code>gpar</code> object for labels (see <code><a href="grid.html#topic+gpar">gpar()</a></code>)
</p>
</li>
<li> <p><code>gp_panels</code> <code>gpar</code> object for panels (see <code><a href="grid.html#topic+gpar">gpar()</a></code>).
</p>
</li>
<li> <p><code>newpage</code> a logical indicating whether to start
the plot on a new page (see <code><a href="grid.html#topic+grid.newpage">grid.newpage()</a></code>).
</p>
</li>
<li> <p><code>pop</code> a logical indicating whether to pop the created viewports
(see <code><a href="grid.html#topic+pop.viewport">pop.viewport()</a></code>)?
</p>
</li></ul>
</td></tr>
<tr><td><code id="bertinplot_+3A_value">value</code>, <code id="bertinplot_+3A_spacing">spacing</code>, <code id="bertinplot_+3A_hl">hl</code></td>
<td>
<p>are used internally for the panel functions.</p>
</td></tr>
<tr><td><code id="bertinplot_+3A_col">col</code>, <code id="bertinplot_+3A_y">y</code></td>
<td>
<p>and x in <code>bertin_cut_line()</code> are for adding a line to a <code>bertinplot()</code> (not ggplot2-based).</p>
</td></tr>
<tr><td><code id="bertinplot_+3A_geom">geom</code></td>
<td>
<p>visualization type. Available ggplot2 geometries are: <code>"tile"</code>,
<code>"rectangle"</code>, <code>"circle"</code>, <code>"line"</code>, <code>"bar"</code>, <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="bertinplot_+3A_prop">prop</code></td>
<td>
<p>logical; change the aspect ratio so cells in the image have a
equal width and height.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot is organized as a matrix of symbols. The symbols are drawn by a
panel function, where all symbols of a row are drawn by one call of the
function (using vectorization). The interface for the panel function is
<code>panel.myfunction(value, spacing, hl)</code>. <code>value</code> is the vector of
values for a row scaled between 0 and 1, <code>spacing</code> contains the
relative space between symbols and <code>hl</code> is a logical vector indicating
which symbol should be highlighted.
</p>
<p>Cut lines can be added to an existing Bertin plot using
<code>bertin_cut_line(x = NULL, y = NULL)</code>. <code>x</code>/<code>y</code> is can be a
number indicating where to draw the cut line between two columns/rows. If
both <code>x</code> and <code>y</code> is specified then one can select a row/column and
the other can select a range to draw a line which does only span a part of
the row/column. It is important to call <code>bertinplot()</code> with the option
<code>pop = FALSE</code>.
</p>
<p><code>ggbertinplot()</code> calls <code><a href="#topic+ggpimage">ggpimage()</a></code> and all additional parameters are
passed on.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>de Falguerolles, A., Friedrich, F., Sawitzki, G. (1997): A
Tribute to J. Bertin's Graphical Data Analysis. In: Proceedings of the
SoftStat '97 (Advances in Statistical Software 6), 11&ndash;20.
</p>


<h3>See Also</h3>

<p>Other plots: 
<code><a href="#topic+VAT">VAT</a>()</code>,
<code><a href="#topic+dissplot">dissplot</a>()</code>,
<code><a href="#topic+hmap">hmap</a>()</code>,
<code><a href="#topic+palette">palette</a>()</code>,
<code><a href="#topic+pimage">pimage</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Irish")
scale_by_rank &lt;- function(x) apply(x, 2, rank)
x &lt;- scale_by_rank(Irish[,-6])

# Use the the sum of absolute rank differences
order &lt;- c(
  seriate(dist(x, "minkowski", p = 1)),
  seriate(dist(t(x), "minkowski", p = 1))
)

# Plot
bertinplot(x, order)

# Some alternative displays
bertinplot(x, order, panel = panel.tiles, shading_col = bluered(100), highlight = FALSE)
bertinplot(x, order, panel = panel.circles, spacing = -.2)
bertinplot(x, order, panel = panel.rectangles)
bertinplot(x, order, panel = panel.lines)

# Plot with cut lines (we manually set the order here)
order &lt;- ser_permutation(c(6L, 9L, 29L, 10L, 32L, 22L, 2L, 35L,
  24L, 30L, 33L, 25L, 37L, 36L, 8L, 27L, 4L, 39L, 3L, 40L, 38L,
  1L, 31L, 34L, 28L, 23L, 5L, 11L, 7L, 41L, 13L, 26L, 17L, 15L,
  12L, 20L, 14L, 18L, 19L, 16L, 21L),
    c(4L, 2L, 1L, 6L, 7L, 8L, 5L, 3L))

bertinplot(x, order, pop=FALSE)
bertin_cut_line(, 4) ## horizontal line between rows 4 and 5
bertin_cut_line(, 7) ## separate "Right to Life" from the rest
bertin_cut_line(18, c(0, 4)) ## separate a block of large values (vertically)

# ggplot2-based plots
if (require("ggplot2")) {
  library(ggplot2)

  # Default plot uses bars and highlighting values larger than the mean
  ggbertinplot(x, order)

  # highlight values in the 4th quartile
  ggbertinplot(x, order, highlight = quantile(x, probs = .75))

  # Use different geoms. "none" lets the user specify their own geom.
  # Variables set are row, col and x (for the value).

  ggbertinplot(x, order, geom = "tile", prop = TRUE)
  ggbertinplot(x, order, geom = "rectangle")
  ggbertinplot(x, order, geom = "rectangle", prop = TRUE)
  ggbertinplot(x, order, geom = "circle")
  ggbertinplot(x, order, geom = "line")

  # Tiles with diverging color scale
  ggbertinplot(x, order, geom = "tile", prop = TRUE) +
    scale_fill_gradient2(midpoint = mean(x))

  # Custom geom (geom = "none"). Defined variables are row, col, and x for the value
  ggbertinplot(x, order, geom = "none", prop = FALSE) +
    geom_point(aes(x = col, y = row, size = x, color = x &gt; 30), pch = 15) +
    scale_size(range = c(1, 10))

  # Use a ggplot2 theme with theme_set()
  old_theme &lt;- theme_set(theme_minimal() +
      theme(panel.grid = element_blank())
    )
  ggbertinplot(x, order, geom = "bar")
  theme_set(old_theme)
}
</code></pre>

<hr>
<h2 id='Chameleon'>2D Data Sets used for the CHAMELEON Clustering Algorithm</h2><span id='topic+Chameleon'></span><span id='topic+chameleon'></span><span id='topic+chameleon_ds4'></span><span id='topic+chameleon_ds5'></span><span id='topic+chameleon_ds7'></span><span id='topic+chameleon_ds8'></span>

<h3>Description</h3>

<p>Several 2D data sets created to evaluate the CHAMELEON clustering algorithm in
the paper by Karypis et al (1999).
</p>


<h3>Format</h3>

<p><code>chameleon_ds4</code>: The format is a 8,000 x 2 data.frame.
</p>
<p><code>chameleon_ds5</code>: The format is a 8,000 x 2 data.frame.
</p>
<p><code>chameleon_ds7</code>: The format is a 10,000 x 2 data.frame.
</p>
<p><code>chameleon_ds8</code>: The format is a 8,000 x 2 data.frame.
</p>


<h3>References</h3>

<p>Karypis, G., EH. Han, V. Kumar (1999): CHAMELEON: A Hierarchical
Clustering Algorithm Using Dynamic Modeling, <em>IEEE Computer,</em>
<strong>32</strong>(8): 68&ndash;75.
<a href="https://doi.org/10.1109/2.781637">doi:10.1109/2.781637</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Chameleon)

plot(chameleon_ds4, cex = .1)
plot(chameleon_ds5, cex = .1)
plot(chameleon_ds7, cex = .1)
plot(chameleon_ds8, cex = .1)
</code></pre>

<hr>
<h2 id='create_lines_data'>Create Simulated Data for Seriation Evaluation</h2><span id='topic+create_lines_data'></span><span id='topic+create_ordered_data'></span>

<h3>Description</h3>

<p>Several functions to create simulated data to evaluate different aspects of
seriation algorithms and criterion functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_lines_data(n = 250)

create_ordered_data(
  n = 250,
  k = 2,
  size = NULL,
  spacing = 6,
  path = "linear",
  sd1 = 1,
  sd2 = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_lines_data_+3A_n">n</code></td>
<td>
<p>number of data points to create.</p>
</td></tr>
<tr><td><code id="create_lines_data_+3A_k">k</code></td>
<td>
<p>number of Gaussian components.</p>
</td></tr>
<tr><td><code id="create_lines_data_+3A_size">size</code></td>
<td>
<p>relative size (number of points) of components (length of k).
If <code>NULL</code> then all components have the same size.</p>
</td></tr>
<tr><td><code id="create_lines_data_+3A_spacing">spacing</code></td>
<td>
<p>space between the centers of components. The default of 6
means that the components will barely touch at <code>ds1 = 1</code> (3 standard
deviations for each Gaussian component).</p>
</td></tr>
<tr><td><code id="create_lines_data_+3A_path">path</code></td>
<td>
<p>Are the components arranged along a <code>"linear"</code> or
<code>"circular"</code> path?</p>
</td></tr>
<tr><td><code id="create_lines_data_+3A_sd1">sd1</code></td>
<td>
<p>variation in the direction along the components.  A value greater
than one means the components are mixing.</p>
</td></tr>
<tr><td><code id="create_lines_data_+3A_sd2">sd2</code></td>
<td>
<p>variation perpendicular to the direction along the components.  A
value greater than 0 will introduce anti-Robinson violation events.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>create_lines_data()</code> creates the lines data set used in for <code><a href="#topic+iVAT">iVAT()</a></code> in
Havens and Bezdeck (2012).
</p>
<p><code>create_ordered_data()</code> is a versatile function which creates &quot;orderable&quot;
2D data using Gaussian components along a linear or circular path. The
components are equally spaced (<code>spacing</code>) along the path. The default
spacing of 6 ensures that 2 adjacent components with a standard deviation of
one along the direction of the path will barely touch. The standard
deviation along the path is set by <code>sd1</code>. The standard deviation
perpendicular to the path is set by <code>sd2</code>. A value larger than zero
will result in the data not being perfectly orderable (i.e., the resulting
distance matrix will not be a perfect pre-anti-Robinson matrix and contain
anti-Robinson violation events after seriation). Note that a circular path
always creates anti-Robinson violation since the circle has to be broken at
some point to create a linear order. This function was created for this package
(Hahsler et al, 2021).
</p>


<h3>Value</h3>

<p>a data.frame with the created data.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Havens, T.C. and Bezdek, J.C. (2012): An Efficient Formulation
of the Improved Visual Assessment of Cluster Tendency (iVAT) Algorithm,
<em>IEEE Transactions on Knowledge and Data Engineering,</em> <b>24</b>(5),
813&ndash;822.
</p>
<p>Michael Hahsler, Christian Buchta and Kurt Hornik (2021). seriation: Infrastructure for
Ordering Objects Using Seriation. R package version 1.3.2.
<a href="https://github.com/mhahsler/seriation">https://github.com/mhahsler/seriation</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seriate">seriate()</a></code>, <code><a href="#topic+criterion">criterion()</a></code>, <code><a href="#topic+iVAT">iVAT()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## lines data set from Havens and Bezdek (2011)
x &lt;- create_lines_data(250)
plot(x, xlim = c(-5, 5), ylim = c(-3, 3), cex = .2, col = attr(x, "id"))
d &lt;- dist(x)
pimage(d, seriate(d, "OLO_single"), col = bluered(100, bias = .5), key = TRUE)

## create_ordered_data can produce many types of "orderable" data

## perfect pre-Anti-Robinson matrix (with a single components)
x &lt;- create_ordered_data(250, k = 1)
plot(x, cex = .2, col = attr(x, "id"))
d &lt;- dist(x)
pimage(d, seriate(d, "MDS"), col = bluered(100, bias=.5), key = TRUE)

## separated components
x &lt;- create_ordered_data(250, k = 5)
plot(x, cex =.2, col = attr(x, "id"))
d &lt;- dist(x)
pimage(d, seriate(d, "MDS"), col = bluered(100, bias = .5), key = TRUE)

## overlapping components
x &lt;- create_ordered_data(250, k = 5, sd1 = 2)
plot(x, cex = .2, col = attr(x, "id"))
d &lt;- dist(x)
pimage(d, seriate(d, "MDS"), col = bluered(100, bias = .5), key = TRUE)

## introduce anti-Robinson violations (a non-zero y value)
x &lt;- create_ordered_data(250, k = 5, sd1 = 2, sd2 = 5)
plot(x, cex = .2, col = attr(x, "id"))
d &lt;- dist(x)
pimage(d, seriate(d, "MDS"), col = bluered(100, bias = .5), key = TRUE)

## circular path (has always violations)
x &lt;- create_ordered_data(250, k = 5, path = "circular", sd1 = 2)
plot(x, cex = .2, col = attr(x, "id"))
d &lt;- dist(x)
pimage(d, seriate(d, "OLO"), col = bluered(100, bias = .5), key = TRUE)

## circular path (with more violations violations)
x &lt;- create_ordered_data(250, k = 5, path = "circular", sd1 = 2, sd2 = 1)
plot(x, cex=.2, col = attr(x, "id"))
d &lt;- dist(x)
pimage(d, seriate(d, "OLO"), col = bluered(100, bias = .5), key = TRUE)
</code></pre>

<hr>
<h2 id='criterion'>Criterion for a Loss/Merit Function for Data Given a Permutation</h2><span id='topic+criterion'></span><span id='topic+criterion.array'></span><span id='topic+criterion.dist'></span><span id='topic+criterion.matrix'></span><span id='topic+criterion.data.frame'></span><span id='topic+criterion.table'></span>

<h3>Description</h3>

<p>Compute the value for different loss functions <code class="reqn">L</code> and merit function
<code class="reqn">M</code> for data given a permutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criterion(x, order = NULL, method = NULL, force_loss = FALSE, ...)

## S3 method for class 'array'
criterion(x, order = NULL, method = NULL, force_loss = FALSE, ...)

## S3 method for class 'dist'
criterion(x, order = NULL, method = NULL, force_loss = FALSE, ...)

## S3 method for class 'matrix'
criterion(x, order = NULL, method = NULL, force_loss = FALSE, ...)

## S3 method for class 'data.frame'
criterion(x, order = NULL, method = NULL, force_loss = FALSE, ...)

## S3 method for class 'table'
criterion(x, order = NULL, method = NULL, force_loss = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="criterion_+3A_x">x</code></td>
<td>
<p>an object of class <a href="stats.html#topic+dist">dist</a> or a matrix (currently no functions
are implemented for array).</p>
</td></tr>
<tr><td><code id="criterion_+3A_order">order</code></td>
<td>
<p>an object of class <a href="#topic+ser_permutation">ser_permutation</a> suitable for
<code>x</code>.  If <code>NULL</code>, the identity permutation is used.</p>
</td></tr>
<tr><td><code id="criterion_+3A_method">method</code></td>
<td>
<p>a character vector with the names of the criteria to be
employed (see <code><a href="#topic+list_criterion_methods">list_criterion_methods()</a></code>), or <code>NULL</code> (default) in which case all available criteria are
used.</p>
</td></tr>
<tr><td><code id="criterion_+3A_force_loss">force_loss</code></td>
<td>
<p>logical; should merit function be converted into loss
functions by multiplying with -1?</p>
</td></tr>
<tr><td><code id="criterion_+3A_...">...</code></td>
<td>
<p>additional parameters passed on to the criterion method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Criteria for distance matrices (dist)</strong>
</p>
<p>For a symmetric dissimilarity matrix <code class="reqn">D</code> with elements <code class="reqn">d(i,j)</code>
where <code class="reqn">i, j = 1 \ldots n</code>, the aim is generally to place low distance
values close to the diagonal. The following criteria to judge the quality of
a certain permutation of the objects in a dissimilarity matrix are currently
implemented (for a more detailed description and an experimental comparison
see Hahsler (2017)):
</p>

<ul>
<li> <p><strong>Gradient measures:</strong> <code>"Gradient_raw"</code>, <code>"Gradient_weighted"</code> (Hubert et al, 2001)
</p>
<p>A symmetric dissimilarity matrix where the values in
all rows and columns only increase when moving away from the main diagonal
is called a perfect <em>anti-Robinson matrix</em> (Robinson 1951). A suitable
merit measure which quantifies the divergence of a matrix from the
anti-Robinson form is
</p>
<p style="text-align: center;"><code class="reqn"> M(D) = \sum_{i=1}^n \sum_{i&lt;k&lt;j} f(d_{ij}, d_{ik}) + \sum_{i&lt;k&lt;j}
    f(d_{ij}, d_{kj})</code>
</p>
<p> where <code class="reqn">f(.,.)</code> is a function which defines how a
violation or satisfaction of a gradient condition for an object triple
(<code class="reqn">O_i, O_k, O_j</code>) is counted.
</p>
<p>Hubert et al (2001) suggest two functions. The first function is given by:
</p>
<p style="text-align: center;"><code class="reqn">f(z,y) = sign(y-z) = +1 if z &lt; y; 0 if z = y; and -1 if z &gt; y.</code>
</p>

<p>It results in raw number of triples satisfying the gradient constraints
minus triples which violate the constraints.
</p>
<p>The second function is defined as: </p>
<p style="text-align: center;"><code class="reqn">f(z,y) = |y-z| sign(y-z) = y-z</code>
</p>
<p> It
weights the each satisfaction or violation by the difference by its
magnitude given by the absolute difference between the values.
</p>
</li>
<li> <p><strong>Anti-Robinson events:</strong> <code>"AR_events"</code>, <code>"AR_deviations"</code> (Chen, 2002)
</p>
<p><code>"AR_events"</code> counts the number of violations of the anti-Robinson form.
</p>
<p style="text-align: center;"><code class="reqn"> L(D) = \sum_{i=1}^n \sum_{i&lt;k&lt;j} f(d_{ik}, d_{ij}) + \sum_{i&lt;k&lt;j} f(d_{kj}, d_{ij})</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn"> f(z, y) = I(z, y) = 1 if z &lt; y and 0 otherwise,</code>
</p>

<p>where <code class="reqn">I(.)</code> is an indicator function returning 1 only for violations.
Chen (2002) presented a formulation for an equivalent loss function and
called the violations <em>anti-Robinson events.</em>
</p>
<p><code>"AR_deviations"</code>: Chen (2002) also introduced a
weighted versions of the loss function by using
</p>
<p style="text-align: center;"><code class="reqn"> f(z, y) = |y-z|I(z, y) </code>
</p>
<p> which weights each violation by
the deviation.
</p>
</li>
<li> <p><strong>Relative generalized Anti-Robinson events:</strong> <code>"RGAR"</code>  (Tien et al, 2008)
</p>
<p>Counts Anti-Robinson events in a variable band (window specified
by <code>w</code> defaults to the maximum of <code class="reqn">n-1</code>) around the main diagonal
and normalizes by the maximum of possible events.
</p>
<p style="text-align: center;"><code class="reqn"> L(D) = 1/m \sum_{i=1}^n \sum_{(i-w)\le j&lt;k&lt;i} I(d_{ij} &lt; d_{ik}) +
    \sum_{i&lt;j&lt;k\le(i+w))} I(d_{ij} &gt; d_{ik}) </code>
</p>

<p>where <code class="reqn">m=(2/3-n)w + nw^2 - 2/3 w^3</code>, the maximal number of possible
anti-Robinson events in the window.  The window size <code class="reqn">w</code> represents the
number of neighboring objects (number of entries from the diagonal of the
distance matrix) are considered. The window size is <code class="reqn">2 \le w &lt; n</code>, where
smaller values result in focusing on the local structure while larger values
look at the global structure.
</p>
<p><code>...</code> parameters are:
</p>

<ul>
<li> <p><code>w</code> window size. Default is to use a <code>pct</code> of 100% of <code class="reqn">n</code>.
</p>
</li>
<li> <p><code>pct</code> and alternative specification of w as a percentage of <code class="reqn">n</code> in <code class="reqn">(0, 100]</code>.
</p>
</li>
<li> <p><code>relative</code> logical; can be set to <code>FALSE</code> to get the GAR, i.e., the absolute number of AR
events in the window.
</p>
</li></ul>

</li>
<li> <p><strong>Banded anti-Robinson form criterion:</strong> <code>"BAR"</code>  (Earle and Hurley, 2015)
</p>
<p>Simplified measure for closeness to the anti-Robinson form in a band of size
<code class="reqn">b</code> with <code class="reqn">1 &lt;= b &lt; n</code> around the diagonal.
</p>
<p style="text-align: center;"><code class="reqn"> L(D) = \sum_{|i-j|&lt;=b} (b+1-|i-j|) d_{ij} </code>
</p>

<p>For <code class="reqn">b = 1</code> the measure reduces to the Hamiltonian path length.  For
<code class="reqn">b = n-1</code> the measure is equivalent to ARc defined (Earle and Hurley,
2015). Note that ARc is equivalent to the Linear Seriation criterion (scaled
by 1/2).
</p>
<p><code>...</code> parameter is: <code>b</code> band size defaults to a band of 20% of <code class="reqn">n</code>.
</p>
</li>
<li> <p><strong>Hamiltonian path length:</strong> <code>"Path_length"</code>  (Caraux and Pinloche, 2005)
</p>
<p>The order of the objects in a dissimilarity matrix corresponds to a path
through a graph where each node represents an object and is visited exactly
once, i.e., a Hamilton path. The length of the path is defined as the sum of
the edge weights, i.e., dissimilarities.
</p>
<p style="text-align: center;"><code class="reqn">L(D) = \sum_{i=1}^{n-1} d_{i,i+1}</code>
</p>

<p>The length of the Hamiltonian path is equal to the value of the minimal span
loss function (as used by Chen 2002).  Both notions are related to the
<em>traveling salesperson problem (TSP).</em>
</p>
<p>If <code>order</code> is not unique or there are non-finite distance values
<code>NA</code> is returned.
</p>
</li>
<li> <p><strong>Lazy path length:</strong> <code>"Lazy_path_length"</code> (Earl and Hurley, 2015)
</p>
<p>A weighted version of the Hamiltonian path criterion. This loss function
postpones larger distances to later in the order (i.e., a lazy traveling
sales person).
</p>
<p style="text-align: center;"><code class="reqn">L(D) = \sum_{i=1}^{n-1} (n-i) d_{i,i+1}</code>
</p>

<p>Earl and Hurley (2015) proposed this criterion for reordering in
visualizations to concentrate on closer objects first.
</p>
</li>
<li> <p><strong>Inertia criterion:</strong> <code>"Inertia"</code>  (Caraux and Pinloche, 2005)
</p>
<p>Measures the moment of the inertia of dissimilarity values around the
diagonal as
</p>
<p style="text-align: center;"><code class="reqn">M(D) = \sum_{i=1}^n \sum_{j=1}^n d(i,j)|i-j|^2</code>
</p>

<p><code class="reqn">|i-j|</code> is used as a measure for the distance to the diagonal and
<code class="reqn">d(i,j)</code> gives the weight. This criterion gives higher weight to values
farther away from the diagonal. It increases with quality.
</p>
</li>
<li> <p><strong>Least squares criterion:</strong> <code>"Least_squares"</code> (Caraux and Pinloche, 2005)
</p>
<p>The sum of squares of deviations between the dissimilarities and rank
differences (in the matrix) between two elements: </p>
<p style="text-align: center;"><code class="reqn">L(D) = \sum_{i=1}^n
  \sum_{j=1}^n (d(i,j) - |i-j|)^2,</code>
</p>
<p> where <code class="reqn">d(i,j)</code> is an element of the
dissimilarity matrix <code class="reqn">D</code> and <code class="reqn">|i-j|</code> is the rank difference between
the objects.
</p>
<p>Note that if Euclidean distance is used to calculate <code class="reqn">D</code> from a data
matrix <code class="reqn">X</code>, the order of the elements in <code class="reqn">X</code> by projecting them on
the first principal component of <code class="reqn">X</code> minimizes this criterion.  The
least squares criterion is related to <em>unidimensional scaling.</em>
</p>
</li>
<li> <p><strong>Linear Seriation Criterion:</strong> <code>"LS"</code>  (Hubert and Schultz, 1976)
</p>
<p>Weights the distances with the absolute rank differences.
</p>
<p style="text-align: center;"><code class="reqn">L(D) \sum_{i,j=1}^n d(i,j) (-|i-j|)</code>
</p>

</li>
<li> <p><strong>2-Sum Criterion:</strong> <code>"2SUM"</code>  (Barnard, Pothen and Simon, 1993)
</p>
<p>The 2-Sum loss criterion multiplies the similarity between objects with the
squared rank differences.
</p>
<p style="text-align: center;"><code class="reqn">L(D) \sum_{i,j=1}^n 1/(1+d(i,j)) (i-j)^2,</code>
</p>

<p>where <code class="reqn">s(i,j) = 1/(1+d(i,j))</code> represents the similarity between objects
<code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
</li>
<li> <p><strong>Absolute Spearman Correlation</strong> <code>"Rho"</code>
</p>
<p>The absolute value of the Spearman rank correlation
between the original distances and the rank differences in the order.
</p>
</li>
<li> <p><strong>Matrix measures:</strong> <code>"ME"</code>, <code>"Moore_stress"</code>, <code>"Neumann_stress"</code>
</p>
<p>These criteria are defined on general matrices (see
below for definitions).  The dissimilarity matrix is first converted into a
similarity matrix using <code class="reqn">S = 1/(1+D)</code>. If a different transformation is
required, then perform the transformation first and supply a matrix instead
of a dist object.
</p>
</li></ul>

<p><strong>Criteria for matrices (matrix)</strong>
</p>
<p>For a general matrix <code class="reqn">X = x_{ij}</code>, <code class="reqn">i = 1 \ldots n</code> and
<code class="reqn">j = 1 \ldots m</code>, currently the following loss/merit functions are implemented:
</p>

<ul>
<li> <p><strong>Measure of Effectiveness:</strong> <code>"ME"</code>  (McCormick, 1972).
</p>
<p>The measure of effectiveness (ME) for matrix <code class="reqn">X</code>, is defined as
</p>
<p style="text-align: center;"><code class="reqn">M(X) = 1/2 \sum_{i=1}^{n} \sum_{j=1}^{m}
    x_{i,j}(x_{i,j-1}+x_{i,j+1}+x_{i-1,j}+x_{i+1,j})</code>
</p>

<p>with, by convention
</p>
<p style="text-align: center;"><code class="reqn">x_{0,j}=x_{m+1,j}=x_{i,0}=x_{i,n+1}=0.</code>
</p>

<p>ME is a merit measure, i.e. a higher ME indicates a better arrangement.
Maximizing ME is the objective of the bond energy algorithm (BEA). ME is not
defined for matrices with negative values. <code>NA</code> is returned in this
case.
</p>
</li>
<li> <p><strong>Weighted correlation coefficient:</strong> <code>"Cor_R"</code>  (Deutsch and Martin, 1971)
</p>
<p>Developed as the Measure of Effectiveness for the Moment
Ordering Algorithm.
R is a merit measure normalized so that its value always lies in
<code class="reqn">[-1,1]</code>.  For the special case of a square matrix <code class="reqn">R=1</code> corresponds
to only the main diagonal being filled, <code class="reqn">R=0</code> to a random distribution
of value throughout the array, and <code class="reqn">R=-1</code> to the opposite diagonal only
being filled.
</p>
</li>
<li> <p><strong>Matrix Stress:</strong> <code>"Moore_stress"</code>, <code>"Neumann_stress"</code>  (Niermann, 2005)
</p>
<p>Stress measures the conciseness of the presentation of a matrix/table and
can be seen as a purity function which compares the values in a matrix/table
with its neighbors. The stress measure used here is computed as the sum of
squared distances of each matrix entry from its adjacent entries.
</p>
<p style="text-align: center;"><code class="reqn"> L(X) = \sum_{i=1}^n \sum_{j=1}^m \sigma_{ij} </code>
</p>

<p>The following types of neighborhoods are available:
</p>

<ul>
<li><p> Moore: comprises the eight adjacent entries.
</p>
<p style="text-align: center;"><code class="reqn">
     \sigma_{ij} = \sum_{k=\max(1,i-1)}^{\min(n,i+1)}
     \sum_{l=\max(1,j-1)}^{\min(m,j+1)} (x_{ij} - x_{kl})^2 </code>
</p>

</li>
<li><p> Neumann: comprises the four adjacent entries.  </p>
<p style="text-align: center;"><code class="reqn"> \sigma_{ij} =
     \sum_{k=\max(1,i-1)}^{\min(n,i+1)} (x_{ij} - x_{kj})^2 +
     \sum_{l=\max(1,j-1)}^{\min(m,j+1)} (x_{ij} - x_{il})^2 </code>
</p>

</li></ul>

<p>The major difference between the Moore and the Neumann neighborhood is that
for the later the contribution of row and column permutations to stress are
independent and thus can be optimized independently.
</p>
</li></ul>



<h3>Value</h3>

<p>A named vector of real values.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Barnard, S.T., A. Pothen, and H. D. Simon (1993): A Spectral
Algorithm for Envelope Reduction of Sparse Matrices. <em>In Proceedings of
the 1993 ACM/IEEE Conference on Supercomputing,</em> 493&ndash;502. Supercomputing
'93. New York, NY, USA: ACM.
</p>
<p>Caraux, G. and S. Pinloche (2005): Permutmatrix: A Graphical Environment to
Arrange Gene Expression Profiles in Optimal Linear Order,
<em>Bioinformatics,</em> <b>21</b>(7), 1280&ndash;1281.
</p>
<p>Chen, C.-H. (2002): Generalized association plots: Information visualization
via iteratively generated correlation matrices, <em>Statistica Sinica,</em>
<b>12</b>(1), 7&ndash;29.
</p>
<p>Deutsch, S.B. and J.J. Martin (1971): An ordering algorithm for analysis of
data arrays. <em>Operational Research,</em> <b>19</b>(6), 1350&ndash;1362.
<a href="https://doi.org/10.1287/opre.19.6.1350">doi:10.1287/opre.19.6.1350</a>
</p>
<p>Earle, D. and C.B. Hurley (2015): Advances in Dendrogram Seriation for
Application to Visualization. <em>Journal of Computational and Graphical
Statistics,</em> <b>24</b>(1), 1&ndash;25.
<a href="https://doi.org/10.1080/10618600.2013.874295">doi:10.1080/10618600.2013.874295</a>
</p>
<p>Hahsler, M. (2017): An experimental comparison of seriation methods for
one-mode two-way data. <em>European Journal of Operational Research,</em>
<b>257</b>, 133&ndash;143.
<a href="https://doi.org/10.1016/j.ejor.2016.08.066">doi:10.1016/j.ejor.2016.08.066</a>
</p>
<p>Hubert, L. and J. Schultz (1976): Quadratic Assignment as a General Data
Analysis Strategy. <em>British Journal of Mathematical and Statistical
Psychology,</em> <b>29</b>(2). Blackwell Publishing Ltd. 190&ndash;241.
<a href="https://doi.org/10.1111/j.2044-8317.1976.tb00714.x">doi:10.1111/j.2044-8317.1976.tb00714.x</a>
</p>
<p>Hubert, L., P. Arabie, and J. Meulman (2001): <em>Combinatorial Data
Analysis: Optimization by Dynamic Programming.</em> Society for Industrial
Mathematics.
<a href="https://doi.org/10.1137/1.9780898718553">doi:10.1137/1.9780898718553</a>
</p>
<p>Niermann, S. (2005): Optimizing the Ordering of Tables With Evolutionary
Computation, <em>The American Statistician,</em> <b>59</b>(1), 41&ndash;46.
<a href="https://doi.org/10.1198/000313005X22770">doi:10.1198/000313005X22770</a>
</p>
<p>McCormick, W.T., P.J. Schweitzer and T.W. White (1972): Problem
decomposition and data reorganization by a clustering technique,
<em>Operations Research,</em> <b>20</b>(5), 993-1009.
<a href="https://doi.org/10.1287/opre.20.5.993">doi:10.1287/opre.20.5.993</a>
</p>
<p>Robinson, W.S. (1951): A method for chronologically ordering archaeological
deposits, <em>American Antiquity,</em> <b>16</b>, 293&ndash;301.
<a href="https://doi.org/10.2307/276978">doi:10.2307/276978</a>
</p>
<p>Tien, Y-J., Yun-Shien Lee, Han-Ming Wu and Chun-Houh Chen (2008): Methods
for simultaneously identifying coherent local clusters with smooth global
patterns in gene expression profiles, <em>BMC Bioinformatics,</em>
<b>9</b>(155), 1&ndash;16.
<a href="https://doi.org/10.1186/1471-2105-9-155">doi:10.1186/1471-2105-9-155</a>
</p>


<h3>See Also</h3>

<p>Other criterion: 
<code><a href="#topic+registry_for_criterion_methods">registry_for_criterion_methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create random data and calculate distances
m &lt;- matrix(runif(20),ncol=2)
d &lt;- dist(m)

## get an order for rows (optimal for the least squares criterion)
o &lt;- seriate(d, method = "MDS")
o

## compare the values for all available criteria
rbind(
    unordered = criterion(d),
    ordered = criterion(d, o)
)

## compare RGAR by window size (from local to global)
w &lt;- 2:(nrow(m)-1)
RGAR &lt;- sapply(w, FUN = function (w)
  criterion(d, o, method="RGAR", w = w))
plot(w, RGAR, type = "b", ylim = c(0,1),
  xlab = "Windows size (w)", main = "RGAR by window size")
</code></pre>

<hr>
<h2 id='dissplot'>Dissimilarity Plot</h2><span id='topic+dissplot'></span><span id='topic+plot.reordered_cluster_dissimilarity_matrix'></span><span id='topic+print.reordered_cluster_dissimilarity_matrix'></span><span id='topic+ggdissplot'></span>

<h3>Description</h3>

<p>Visualizes a dissimilarity matrix using seriation and matrix shading using
the method developed by Hahsler and Hornik (2011). Entries with lower
dissimilarities (higher similarity) are plotted darker. Dissimilarity plots
can be used to uncover hidden structure in the data and judge cluster
quality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissplot(
  x,
  labels = NULL,
  method = "spectral",
  control = NULL,
  lower_tri = TRUE,
  upper_tri = "average",
  diag = TRUE,
  cluster_labels = TRUE,
  cluster_lines = TRUE,
  reverse_columns = FALSE,
  options = NULL,
  ...
)

## S3 method for class 'reordered_cluster_dissimilarity_matrix'
plot(
  x,
  lower_tri = TRUE,
  upper_tri = "average",
  diag = TRUE,
  options = NULL,
  ...
)

## S3 method for class 'reordered_cluster_dissimilarity_matrix'
print(x, ...)

ggdissplot(
  x,
  labels = NULL,
  method = "spectral",
  control = NULL,
  lower_tri = TRUE,
  upper_tri = "average",
  diag = TRUE,
  cluster_labels = TRUE,
  cluster_lines = TRUE,
  reverse_columns = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissplot_+3A_x">x</code></td>
<td>
<p>an object of class <a href="stats.html#topic+dist">dist</a>.</p>
</td></tr>
<tr><td><code id="dissplot_+3A_labels">labels</code></td>
<td>
<p><code>NULL</code> or an integer vector of the same length as
rows/columns in <code>x</code> indicating the cluster membership for each object
in <code>x</code> as consecutive integers starting with one. The labels are used
to reorder the matrix.</p>
</td></tr>
<tr><td><code id="dissplot_+3A_method">method</code></td>
<td>
<p>A single character string indicating the seriation method used
to reorder the clusters (inter cluster seriation) as well as the objects
within each cluster (intra cluster seriation).  If different algorithms for
inter and intra cluster seriation are required, <code>method</code> can be a
<code>list</code> of two named elements (<code>inter_cluster</code> and
<code>intra_cluster</code> each containing the name of the respective seriation
method. Use <code><a href="#topic+list_seriation_methods">list_seriation_methods()</a></code> with <code>kind = "dist"</code> to find available algorithms.
</p>
<p>Set method to <code>NA</code> to plot the matrix as is (no or, if cluster labels
are supplied, only coarse seriation). For intra cluster reordering with the
special method <code>"silhouette width"</code> is available (for <code>dissplot()</code>
only). Objects in clusters are then ordered by silhouette width (from
silhouette plots).  If no <code>method</code> is given, the default method of
<code><a href="#topic+seriate.dist">seriate.dist()</a></code> is used.
</p>
<p>A third list element (named <code>aggregation</code>) can be added to control how
inter cluster dissimilarities are computed from from the given dissimilarity
matrix. The choices are <code>"avg"</code> (average pairwise dissimilarities;
average-link), <code>"min"</code> (minimal pairwise dissimilarities; single-link),
<code>"max"</code> (maximal pairwise dissimilarities; complete-link), and
<code>"Hausdorff"</code> (pairs up each point from one cluster with the most
similar point from the other cluster and then uses the largest dissimilarity
of paired up points).</p>
</td></tr>
<tr><td><code id="dissplot_+3A_control">control</code></td>
<td>
<p>a list of control options passed on to the seriation
algorithm.  In case of two different seriation algorithms, <code>control</code>
can contain a list of two named elements (<code>inter_cluster</code> and
<code>intra_cluster</code>) containing each a list with the control options for
the respective algorithm.</p>
</td></tr>
<tr><td><code id="dissplot_+3A_upper_tri">upper_tri</code>, <code id="dissplot_+3A_lower_tri">lower_tri</code>, <code id="dissplot_+3A_diag">diag</code></td>
<td>
<p>a logical indicating whether to show the upper triangle, the
lower triangle or the diagonal of the distance matrix. The string &quot;average&quot; can also be used
to display within and between cluster averages in the two triangles.</p>
</td></tr>
<tr><td><code id="dissplot_+3A_cluster_labels">cluster_labels</code></td>
<td>
<p>a logical indicating whether to display cluster labels
in the plot.</p>
</td></tr>
<tr><td><code id="dissplot_+3A_cluster_lines">cluster_lines</code></td>
<td>
<p>a logical indicating whether to draw lines to separate
clusters.</p>
</td></tr>
<tr><td><code id="dissplot_+3A_reverse_columns">reverse_columns</code></td>
<td>
<p>a logical indicating if the clusters are displayed on
the diagonal from north-west to south-east (<code>FALSE</code>; default) or from
north-east to south-west (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dissplot_+3A_options">options</code></td>
<td>
<p>a list with options for plotting the matrix (<code>dissplot</code>
only).
</p>

<ul>
<li> <p><code>plot</code> a logical indicating if a plot should
be produced.  if <code>FALSE</code>, the returned object can be plotted later
using the function <code>plot</code> which takes as the second argument a list of
plotting options (see <code>options</code> below).
</p>
</li>
<li> <p><code>silhouettes</code> a logical indicating whether to include a silhouette plot
(see Rousseeuw, 1987).
</p>
</li>
<li> <p><code>threshold</code> a numeric. If used, only plot distances
below the threshold are displayed. Consider also using <code>zlim</code> for this
purpose.
</p>
</li>
<li> <p><code>col</code> colors used for the image plot.
</p>
</li>
<li> <p><code>key</code> a logical indicating whether to place a color key below the plot.
</p>
</li>
<li> <p><code>zlim</code> range of values to display (defaults to range <code>x</code>).
</p>
</li>
<li> <p><code>axes</code> <code>"auto"</code> (default; enabled for less than 25 objects), <code>"y"</code> or <code>"none"</code>.
</p>
</li>
<li> <p><code>main</code> title for the plot.
</p>
</li>
<li> <p><code>newpage</code> a logical indicating whether to start plot on a new page
(see <code><a href="grid.html#topic+grid.newpage">grid.newpage()</a></code>.
</p>
</li>
<li> <p><code>pop</code> a logical indicating whether to pop the created viewports?
(see package <span class="pkg">grid</span>)
</p>
</li>
<li> <p><code>gp</code>, <code>gp_lines</code>, <code>gp_labels</code> objects of class <code>gpar</code> containing graphical parameters for the plot
lines and labels (see <code><a href="grid.html#topic+gpar">gpar()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dissplot_+3A_...">...</code></td>
<td>
<p><code>dissplot()</code>: further arguments are added to <code>options</code>.
<code>ggdissplot()</code> further arguments are passed on to <code><a href="#topic+ggpimage">ggpimage()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot can also be used to visualize cluster quality (see Ling 1973).
Objects belonging to the same cluster are displayed in consecutive order.
The placement of clusters and the within cluster order is obtained by a
seriation algorithm which tries to place large similarities/small
dissimilarities close to the diagonal. Compact clusters are visible as dark
squares (low dissimilarity) on the diagonal of the plot. Additionally, a
Silhouette plot (Rousseeuw 1987) is added. This visualization is similar to
CLUSION (see Strehl and Ghosh 2002), however, allows for using arbitrary
seriating algorithms.
</p>
<p><strong>Note:</strong> Since <code><a href="#topic+pimage">pimage()</a></code> uses <span class="pkg">grid</span>, it should not be mixed
with base R primitive plotting functions.
</p>


<h3>Value</h3>

<p><code>dissplot()</code> returns an invisible object of class
<code>cluster_proximity_matrix</code> with the following elements:
</p>
<table>
<tr><td><code>order</code></td>
<td>
<p><code>NULL</code> or integer vector giving the order used to plot <code>x</code>.</p>
</td></tr>
<tr><td><code>cluster_order</code></td>
<td>
 <p><code>NULL</code> or integer vector giving the order of the
clusters as plotted.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> vector of character strings indicating
the seriation methods used for plotting <code>x</code>.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
 <p><code>NULL</code> or integer scalar giving the number of clusters generated.</p>
</td></tr>
<tr><td><code>description</code></td>
<td>
<p> a <code>data.frame</code> containing information (label, size, average
intra-cluster dissimilarity and the average silhouette) for the clusters as
displayed in the plot (from top/left to bottom/right).</p>
</td></tr>
</table>
<p>This object can be used for plotting via <code>plot(x, options = NULL, ...)</code>,
where <code>x</code> is the object and <code>options</code> contains a list with
plotting options (see above).
</p>
<p><code>ggdissplot()</code> returns a ggplot2 object representing the plot.
</p>
<p>The plot description as an object of class <code>reordered_cluster_dissimilarity_matrix</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Hahsler, M. and Hornik, K. (2011): Dissimilarity plots: A visual
exploration tool for partitional clustering. <em>Journal of Computational
and Graphical Statistics,</em> <b>10</b>(2):335&ndash;354.
<a href="https://doi.org/10.1198/jcgs.2010.09139">doi:10.1198/jcgs.2010.09139</a>
</p>
<p>Ling, R.F. (1973): A computer generated aid for cluster analysis.
<em>Communications of the ACM,</em> <b>16</b>(6), 355&ndash;361.
<a href="https://doi.org/10.1145/362248.362263">doi:10.1145/362248.362263</a>
</p>
<p>Rousseeuw, P.J. (1987): Silhouettes: A graphical aid to the interpretation
and validation of cluster analysis. <em>Journal of Computational and
Applied Mathematics,</em> <b>20</b>(1), 53&ndash;65.
<a href="https://doi.org/10.1016/0377-0427%2887%2990125-7">doi:10.1016/0377-0427(87)90125-7</a>
</p>
<p>Strehl, A. and Ghosh, J. (2003): Relationship-based clustering and
visualization for high-dimensional data mining. <em>INFORMS Journal on
Computing,</em> <b>15</b>(2), 208&ndash;230.
<a href="https://doi.org/10.1287/ijoc.15.2.208.14448">doi:10.1287/ijoc.15.2.208.14448</a>
</p>


<h3>See Also</h3>

<p>Other plots: 
<code><a href="#topic+VAT">VAT</a>()</code>,
<code><a href="#topic+bertinplot">bertinplot</a>()</code>,
<code><a href="#topic+hmap">hmap</a>()</code>,
<code><a href="#topic+palette">palette</a>()</code>,
<code><a href="#topic+pimage">pimage</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")

# shuffle rows
x_iris &lt;- iris[sample(seq(nrow(iris))), -5]
d &lt;- dist(x_iris)

# Plot original matrix
dissplot(d, method = NA)

# Plot reordered matrix using the nearest insertion algorithm (from tsp)
dissplot(d, method = "TSP", main = "Seriation (TSP)")

# Cluster iris with k-means and 3 clusters and reorder the dissimality matrix
l &lt;- kmeans(x_iris, centers = 3)$cluster
dissplot(d, labels = l, main = "k-means")

# show only distances as lower triangle
dissplot(d, labels = l, main = "k-means", lower_tri = TRUE, upper_tri = FALSE)

# Use a grid layout to place several plots on a page
library("grid")
grid.newpage()
pushViewport(viewport(layout=grid.layout(nrow = 2, ncol = 2),
    gp = gpar(fontsize = 8)))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))

# Visualize the clustering (using Spectral between clusters and MDS within)
res &lt;- dissplot(d, l, method = list(inter = "Spectral", intra = "MDS"),
  main = "K-Means + Seriation", newpage = FALSE)

popViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))

# More visualization options. Note that we reuse the reordered object res!
# color: use 10 shades red-blue, biased towards small distances
plot(res, main = "K-Means + Seriation (red-blue + biased)",
    col= bluered(10, bias = .5), newpage = FALSE)

popViewport()
pushViewport(viewport(layout.pos.row = 2, layout.pos.col = 1))

# Threshold (using zlim) and cubic scale to highlight differences
plot(res, main = "K-Means + Seriation (cubic + threshold)",
    zlim = c(0, 2), col = grays(100, power = 3), newpage = FALSE)

popViewport()
pushViewport(viewport(layout.pos.row = 2, layout.pos.col = 2))

# Use gray scale with logistic transformation
plot(res, main = "K-Means + Seriation (logistic scale)",
  col = gray(
    plogis(seq(max(res$x_reordered), min(res$x_reordered), length.out = 100),
      location = 2, scale = 1/2, log = FALSE)
    ),
  newpage = FALSE)

popViewport(2)

# The reordered_cluster_dissimilarity_matrix object
res
names(res)

## --------------------------------------------------------------------
## ggplot-based dissplot
if (require("ggplot2")) {

library("ggplot2")

# Plot original matrix
ggdissplot(d, method = NA)

# Plot seriated matrix
ggdissplot(d, method = "TSP") +
  labs(title = "Seriation (TSP)")

# Cluster iris with k-means and 3 clusters
l &lt;- kmeans(x_iris, centers = 3)$cluster

ggdissplot(d, labels = l) +
  labs(title = "K-means + Seriation")

# show only lower triangle
ggdissplot(d, labels = l, lower_tri = TRUE, upper_tri = FALSE) +
  labs(title = "K-means + Seriation")

# No lines or cluster labels and add a label for the color key (fill)
ggdissplot(d, labels = l, cluster_lines = FALSE, cluster_labels = FALSE) +
  labs(title = "K-means + Seriation", fill = "Distances\n(Euclidean)")

# Diverging color palette with manual set midpoint and different seriation methods
ggdissplot(d, l, method = list(inter = "Spectral", intra = "MDS")) +
  labs(title = "K-Means + Seriation", subtitle = "biased color scale") +
  scale_fill_gradient2(midpoint = median(d))

# Use manipulate scale using package scales
library("scales")

# Threshold (using limit and na.value) and cubic scale to highlight differences
cubic_dist_trans &lt;- trans_new(
  name = "cubic",
  # note that we have to do the inverse transformation for distances
  trans = function(x) x^(1/3),
  inverse = function(x) x^3
)

ggdissplot(d, l, method = list(inter = "Spectral", intra = "MDS")) +
  labs(title = "K-Means + Seriation", subtitle = "cubic + biased color scale") +
  scale_fill_gradient(low = "black", high = "white",
    limit = c(0,2), na.value = "white",
    trans = cubic_dist_trans)

# Use gray scale with logistic transformation
logis_2_.5_dist_trans &lt;- trans_new(
  name = "Logistic transform (location, scale)",
  # note that we have to do the inverse transformation for distances
  trans = function(x) plogis(x, location = 2, scale = .5, log = FALSE),
  inverse = function(x) qlogis(x, location = 2, scale = .5, log = FALSE),
)

ggdissplot(d, l, method = list(inter = "Spectral", intra = "MDS")) +
  labs(title = "K-Means + Seriation", subtitle = "logistic color scale") +
  scale_fill_gradient(low = "black", high = "white",
    trans = logis_2_.5_dist_trans,
    breaks = c(0, 1, 2, 3, 4))
}
</code></pre>

<hr>
<h2 id='get_order'>Extracting Order Information from a Permutation Object</h2><span id='topic+get_order'></span><span id='topic+get_order.ser_permutation_vector'></span><span id='topic+get_order.ser_permutation'></span><span id='topic+get_order.hclust'></span><span id='topic+get_order.dendrogram'></span><span id='topic+get_order.integer'></span><span id='topic+get_order.numeric'></span><span id='topic+get_rank'></span><span id='topic+get_permutation_matrix'></span>

<h3>Description</h3>

<p>Method to get the order information from an object of class
<a href="#topic+ser_permutation">ser_permutation</a> or <a href="#topic+ser_permutation_vector">ser_permutation_vector</a>. Order information
can be extracted as a permutation vector, a vector containing each
object's rank or a permutation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_order(x, ...)

## S3 method for class 'ser_permutation_vector'
get_order(x, ...)

## S3 method for class 'ser_permutation'
get_order(x, dim = 1, ...)

## S3 method for class 'hclust'
get_order(x, ...)

## S3 method for class 'dendrogram'
get_order(x, ...)

## S3 method for class 'integer'
get_order(x, ...)

## S3 method for class 'numeric'
get_order(x, ...)

get_rank(x, ...)

get_permutation_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_order_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+ser_permutation">ser_permutation</a> or
<a href="#topic+ser_permutation_vector">ser_permutation_vector</a>.</p>
</td></tr>
<tr><td><code id="get_order_+3A_...">...</code></td>
<td>
<p>further arguments are ignored for <code>get_order()</code>.  For
<code>get_rank()</code> and for <code>get_permutation_matrix()</code> the additional
arguments are passed on to <code>get_order()</code> (e.g., as <code>dim</code>).</p>
</td></tr>
<tr><td><code id="get_order_+3A_dim">dim</code></td>
<td>
<p>order information for which dimension should be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_order()</code> returns the permutation as an integer vector which arranges the
objects in the seriation order. That is, a vector with the index of the first,
second, <code class="reqn">..., n</code>-th object in the order defined by the permutation.
These permutation vectors can directly be
used to reorder objects using subsetting with <code>"["</code>.  <em>Note:</em> In
<span class="pkg">seriation</span> we usually use these order-based permutation vectors.
<strong>Note on names:</strong> While R's <code><a href="base.html#topic+order">order()</a></code> returns an unnamed vector,
<code>get_order()</code> returns names (if available). The names are the object label
corresponding to the index at that position.
Therefore, the names in the order are in the order after
the permutation.
</p>
<p><code>get_rank()</code> returns the seriation as an integer vector containing the
rank/position for each objects after the permutation is applied.
That is, a vector with the position of the first, second,
<code class="reqn">..., n</code>-th object after permutation.  Note: Use
<code>order()</code> to convert ranks back to an order.
</p>
<p><code>get_permutation_matrix()</code> returns a <code class="reqn">n \times n</code> permutation
matrix.
</p>


<h3>Value</h3>

<p>Returns an integer permutation vector/a permutation matrix.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other permutation: 
<code><a href="#topic+permutation_vector2matrix">permutation_vector2matrix</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+ser_dist">ser_dist</a>()</code>,
<code><a href="#topic+ser_permutation_vector">ser_permutation_vector</a>()</code>,
<code><a href="#topic+ser_permutation">ser_permutation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a random ser_permutation_vector
## Note that ser_permutation_vector is a single permutation vector
x &lt;- structure(1:10, names = paste0("X", 1:10))
o &lt;- sample(x)
o

p &lt;- ser_permutation_vector(o)
p

get_order(p)
get_rank(p)
get_permutation_matrix(p)

## reorder objects using subsetting, the provided permute function or by
## multiplying the with the permutation matrix. We use here
x[get_order(p)]
permute(x, p)
drop(get_permutation_matrix(p) %*%  x)

## ser_permutation contains one permutation vector for each dimension
p2 &lt;- ser_permutation(p, sample(5))
p2

get_order(p2, dim = 2)
get_rank(p2, dim = 2)
get_permutation_matrix(p2, dim = 2)
</code></pre>

<hr>
<h2 id='hmap'>Plot Heat Map Reordered Using Seriation</h2><span id='topic+hmap'></span><span id='topic+gghmap'></span>

<h3>Description</h3>

<p>Provides heatmaps reordered using several different seriation methods. This
includes dendrogram based reordering with optimal leaf order and matrix
seriation-based heat maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmap(
  x,
  distfun = stats::dist,
  method = "OLO_complete",
  control = NULL,
  scale = c("none", "row", "column"),
  plot_margins = "auto",
  col = NULL,
  col_dist = grays(power = 2),
  row_labels = NULL,
  col_labels = NULL,
  ...
)

gghmap(
  x,
  distfun = stats::dist,
  method = "OLO",
  control = NULL,
  scale = c("none", "row", "column"),
  prop = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmap_+3A_x">x</code></td>
<td>
<p>a matrix or a dissimilarity matrix of class dist. If a
dissimilarity matrix is used, then the <code>distfun</code> is ignored.</p>
</td></tr>
<tr><td><code id="hmap_+3A_distfun">distfun</code></td>
<td>
<p>function used to compute the distance (dissimilarity) between
both rows and columns. For <code>gghmap()</code>, this
parameter is passed on in <code>control</code>.</p>
</td></tr>
<tr><td><code id="hmap_+3A_method">method</code></td>
<td>
<p>a character strings indicating the used seriation algorithm
(see <code><a href="#topic+seriate.dist">seriate.dist()</a></code>).
If the method results in a dendrogram then
<code><a href="stats.html#topic+heatmap">stats::heatmap()</a></code> is used to show the dendrograms, otherwise
reordered distance matrices are shown instead.</p>
</td></tr>
<tr><td><code id="hmap_+3A_control">control</code></td>
<td>
<p>a list of control options passed on to the seriation
algorithm specified in <code>method</code>.</p>
</td></tr>
<tr><td><code id="hmap_+3A_scale">scale</code></td>
<td>
<p>character indicating if the values should be centered and
scaled in either the row direction or the column direction, or none. Default
is none.</p>
</td></tr>
<tr><td><code id="hmap_+3A_plot_margins">plot_margins</code></td>
<td>
<p>character indicating what to show in the margins. Options are:
<code>"auto"</code>, <code>"dendrogram"</code>, <code>"distances"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="hmap_+3A_col">col</code></td>
<td>
<p>a list of colors used.</p>
</td></tr>
<tr><td><code id="hmap_+3A_col_dist">col_dist</code></td>
<td>
<p>colors used for displaying distances.</p>
</td></tr>
<tr><td><code id="hmap_+3A_row_labels">row_labels</code>, <code id="hmap_+3A_col_labels">col_labels</code></td>
<td>
<p>a logical indicating if row and column labels
in <code>x</code> should be displayed.  If <code>NULL</code> then labels are displayed
if the <code>x</code> contains the appropriate dimname and the number of labels is
25 or less. A character vector of the appropriate length with labels can
also be supplied.</p>
</td></tr>
<tr><td><code id="hmap_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code><a href="stats.html#topic+heatmap">stats::heatmap()</a></code>.</p>
</td></tr>
<tr><td><code id="hmap_+3A_prop">prop</code></td>
<td>
<p>logical; change the aspect ratio so cells in the image have a
equal width and height.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For dendrogram based heat maps, the arguments are passed on to
<code><a href="stats.html#topic+heatmap">stats::heatmap()</a></code> in <span class="pkg">stats</span>. The following arguments for <code>heatmap()</code>
cannot be used: <code>margins</code>, <code>Rowv</code>, <code>Colv</code>, <code>hclustfun</code>, <code>reorderfun</code>.
</p>
<p>For seriation-based heat maps further arguments include:
</p>

<ul>
<li> <p><code>gp</code> an object of class <code>gpar</code> containing graphical
parameters (see <code><a href="grid.html#topic+gpar">gpar()</a></code> in package <span class="pkg">grid</span>).
</p>
</li>
<li> <p><code>newpage</code> a logical indicating whether to start plot on a new
page
</p>
</li>
<li> <p><code>prop</code> a logical indicating whether the height and width of <code>x</code> should
be plotted proportional to its dimensions.
</p>
</li>
<li> <p><code>showdist</code> Display seriated dissimilarity matrices? Values are
<code>"none"</code>, <code>"both"</code>, <code>"rows"</code> or <code>"columns"</code>.
</p>
</li>
<li> <p><code>key</code> logical; show a colorkey?
</p>
</li>
<li> <p><code>key.lab</code> Label plotted next to the color key.
</p>
</li>
<li> <p><code>margins</code> bottom and right-hand-side margins are calculated
automatically or can be specifies as a vector of two numbers (in lines).
</p>
</li>
<li> <p><code>zlim</code> range of values displayed.
</p>
</li>
<li> <p><code>col</code>, <code>col_dist</code> color palettes used.
</p>
</li></ul>



<h3>Value</h3>

<p>An invisible list with elements:
</p>
<table>
<tr><td><code>rowInd</code>, <code>colInd</code></td>
<td>
<p>index permutation vectors.</p>
</td></tr>
<tr><td><code>reorder_method</code></td>
<td>
<p>name of the method used to reorder the matrix.</p>
</td></tr>
</table>
<p>The list may contain additional elements (dendrograms, colors, etc).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other plots: 
<code><a href="#topic+VAT">VAT</a>()</code>,
<code><a href="#topic+bertinplot">bertinplot</a>()</code>,
<code><a href="#topic+dissplot">dissplot</a>()</code>,
<code><a href="#topic+palette">palette</a>()</code>,
<code><a href="#topic+pimage">pimage</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Wood")

# regular heatmap from package stats
heatmap(Wood, main = "Wood (standard heatmap)")

# Default heatmap does Euclidean distance, hierarchical clustering with
# complete-link and optimal leaf ordering. Note that the rows are
# ordered top-down in the seriation order (stats::heatmap orders in reverse)
hmap(Wood, main = "Wood (opt. leaf ordering)")
hmap(Wood, plot_margins = "distances", main = "Wood (opt. leaf ordering)")
hmap(Wood, plot_margins = "none", main = "Wood (opt. leaf ordering)")

# Heatmap with correlation-based distance, green-red color (greenred is
# predefined) and optimal leaf ordering and no row label
dist_cor &lt;- function(x) as.dist(sqrt(1 - cor(t(x))))
hmap(Wood, distfun = dist_cor, col = greenred(100),
  main = "Wood (reorded by corr. between obs.)")

# Heatmap with order based on the angle in two-dimensional MDS space.
hmap(Wood, method = "MDS_angle", col = greenred(100), row_labels = FALSE,
  main = "Wood (reorderd using ange in MDS space)")

# Heatmap for distances
d &lt;- dist(Wood)
hmap(d, main = "Wood (Euclidean distances)")

# order-based with dissimilarity matrices
hmap(Wood, method = "MDS_angle",
  col = greenred(100), col_dist = greens(100, power = 2),
  keylab = "norm. Expression", main = "Wood (reorderd with distances)")

# without the distance matrices
hmap(Wood, method = "MDS_angle", plot_margins = "none",
  col = greenred(100), main = "Wood (reorderd without distances)")

# Manually create a simple heatmap with pimage.
o &lt;- seriate(Wood, method = "heatmap",
   control = list(dist_fun = dist, seriation_method = "OLO_ward"))
o

pimage(Wood, o)

# Note: method heatmap calculates reorderd hclust objects which can be used
#       for many heatmap implementations like the standard implementation in
#       package stats.
heatmap(Wood, Rowv = as.dendrogram(o[[1]]), Colv = as.dendrogram(o[[2]]))

# ggplot 2 version does not support dendrograms in the margin (for now)
if (require("ggplot2")) {
  library("ggplot2")

  gghmap(Wood) + labs(title = "Wood", subtitle = "Optimal leaf ordering")

  # More parameters (see ? ggpimage): reverse column order and flip axes, make a proportional plot
  gghmap(Wood, reverse_columns = TRUE) +
    labs(title = "Wood", subtitle = "Optimal leaf ordering")

  gghmap(Wood, flip_axes = TRUE) +
    labs(title = "Wood", subtitle = "Optimal leaf ordering")

  gghmap(Wood, flip_axes = TRUE, prop = TRUE) +
    labs(title = "Wood", subtitle = "Optimal leaf ordering")

  dist_cor &lt;- function(x) as.dist(sqrt(1 - cor(t(x))))
  gghmap(Wood, distfun = dist_cor) +
    labs(title = "Wood", subtitle = "Reorded by correlation between observations") +
    scale_fill_gradient2(low = "darkgreen", high = "red")

  gghmap(d, prop = TRUE) +
    labs(title = "Wood", subtitle = "Euclidean distances, reordered")

  # Note: the ggplot2-based version currently cannot show distance matrices
  #      in the same plot.

  # Manually seriate and plot as pimage.
  o &lt;- seriate(Wood, method = "heatmap", control = list(dist_fun = dist,
    seriation_method = "OLO_ward"))
  o

  ggpimage(Wood, o)
}
</code></pre>

<hr>
<h2 id='Irish'>Irish Referendum Data Set</h2><span id='topic+Irish'></span>

<h3>Description</h3>

<p>A data matrix containing the results of 8 referenda for 41 Irish communities
used in Falguerolles et al (1997).
</p>


<h3>Format</h3>

<p>The format is a 41 x 9 matrix. Two values are missing.
</p>


<h3>Details</h3>

<p>Column 6 contains the size of the Electorate in 1992.
</p>


<h3>Source</h3>

<p>The data was kindly provided by Guenter Sawitzki.
</p>


<h3>References</h3>

<p>de Falguerolles, A., Friedrich, F., Sawitzki, G. (1997): A
Tribute to J. Bertin's Graphical Data Analysis. In: Proceedings of the
SoftStat '97 (Advances in Statistical Software 6), 11&ndash;20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Irish)

</code></pre>

<hr>
<h2 id='is.robinson'>Create and Recognize Robinson and Pre-Robinson Matrices</h2><span id='topic+is.robinson'></span><span id='topic+Robinson'></span><span id='topic+random.robinson'></span>

<h3>Description</h3>

<p>Provides functions to create and recognize (anti) Robinson and pre-Robinson
matrices. A (anti) Robinson matrix has strictly decreasing (increasing)
values when moving away from the main diagonal. A pre-Robinson matrix is a
matrix which can be transformed into a perfect Robinson matrix using
simultaneous permutations of rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.robinson(x, anti = TRUE, pre = FALSE)

random.robinson(n, anti = TRUE, pre = FALSE, noise = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.robinson_+3A_x">x</code></td>
<td>
<p>a symmetric, positive matrix or a dissimilarity matrix (a
<code>dist</code> object).</p>
</td></tr>
<tr><td><code id="is.robinson_+3A_anti">anti</code></td>
<td>
<p>logical; check for anti Robinson structure? Note that for
distances, anti Robinson structure is appropriate.</p>
</td></tr>
<tr><td><code id="is.robinson_+3A_pre">pre</code></td>
<td>
<p>logical; recognize/create pre-Robinson matrices.</p>
</td></tr>
<tr><td><code id="is.robinson_+3A_n">n</code></td>
<td>
<p>number of objects.</p>
</td></tr>
<tr><td><code id="is.robinson_+3A_noise">noise</code></td>
<td>
<p>noise intensity between 0 and 1. Zero means no noise.  Noise
more than zero results in non-Robinson matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the default matrices are anti Robinson matrices. This is done
because distance matrices (the default in R) are typically anti Robinson
matrices with values increasing when moving away from the diagonal.
</p>
<p>Robinson matrices are recognized using the fact that they have zero anti
Robinson events. For pre-Robinson matrices we use spectral seriation first
since spectral seriation is guaranteed to perfectly reorder pre-Robinson
matrices (see Laurent and Seminaroti, 2015).
</p>
<p>Random pre-Robinson matrices are generated by reversing the process of
unidimensional scaling. We randomly (uniform distribution with range
<code class="reqn">[0,1]</code>) choose <code class="reqn">x</code> coordinates for <code>n</code> points on a straight
line and calculate the pairwise distances. For Robinson matrices, the points
are sorted first according to <code class="reqn">x</code>. For noise, <code class="reqn">y</code> coordinates is
added. The coordinates are chosen uniformly between 0 and <code>noise</code>, with
<code>noise</code> between 0 and 1.
</p>


<h3>Value</h3>

<p>A single logical value.
</p>


<h3>References</h3>

<p>M. Laurent, M. Seminaroti (2015): The quadratic assignment
problem is easy for Robinsonian matrices with Toeplitz structure,
<em>Operations Research Letters</em> 43(1), 103&ndash;109.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create a perfect anti Robinson structure
m &lt;- random.robinson(10)
pimage(m)

is.robinson(m)

## permute the structure to make it not Robinsonian. However,
## it is still pre-Robinson.
o &lt;- sample(10)
m2 &lt;- permute(m, ser_permutation(o,o))
pimage(m2)

is.robinson(m2)
is.robinson(m2, pre = TRUE)

## create a binary random Robinson matrix (not anti Robinson)
m3 &lt;- random.robinson(10, anti = FALSE) &gt; .7
pimage(m3)
is.robinson(m3, anti = FALSE)

## create matrices with noise (as distance matrices)
m4 &lt;- as.dist(random.robinson(50, pre = FALSE, noise = .1))
pimage(m4)
criterion(m4, method = "AR")

m5 &lt;- as.dist(random.robinson(50, pre = FALSE, noise = .5))
pimage(m5)
criterion(m5, method = "AR")
</code></pre>

<hr>
<h2 id='lle'>Locally Linear Embedding (LLE)</h2><span id='topic+lle'></span><span id='topic+LLE'></span>

<h3>Description</h3>

<p>Performs the non linear dimensionality reduction method locally linear embedding
proposed in Roweis and Saul (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lle(x, m, k, reg = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lle_+3A_x">x</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="lle_+3A_m">m</code></td>
<td>
<p>dimensions of the desired embedding.</p>
</td></tr>
<tr><td><code id="lle_+3A_k">k</code></td>
<td>
<p>number of neighbors.</p>
</td></tr>
<tr><td><code id="lle_+3A_reg">reg</code></td>
<td>
<p>regularization method. 1, 2 and 3, by default 2. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>LLE tries to find a lower-dimensional projection which preserves distances
within local neighborhoods. This is done by (1) find for each object the
k nearest neighbors, (2) construct the LLE weight matrix
which represents each point as a linear combination of its neighborhood, and
(2) perform partial eigenvalue decomposition to find the embedding.
</p>
<p>The <code>reg</code> parameter allows the decision between different regularization methods.
As one step of the LLE algorithm, the inverse of the Gram-matrix <code class="reqn">G\in R^{kxk}</code>
has to be calculated. The rank of <code class="reqn">G</code> equals <code class="reqn">m</code> which is mostly smaller
than <code class="reqn">k</code> - this is why a regularization <code class="reqn">G^{(i)}+r\cdot I</code> should be performed.
The calculation of regularization parameter <code class="reqn">r</code> can be done using different methods:
</p>

<ul>
<li> <p><code>reg = 1</code>: standardized sum of eigenvalues of <code class="reqn">G</code> (Roweis and Saul; 2000)
</p>
</li>
<li> <p><code>reg = 2</code> (default): trace of Gram-matrix divided by <code class="reqn">k</code> (Grilli, 2007)
</p>
</li>
<li> <p><code>reg = 3</code>: constant value 3*10e-3
</p>
</li></ul>



<h3>Value</h3>

<p>a matrix of vector with the embedding.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler (based on code by Holger Diedrich and Markus Abel)
</p>


<h3>References</h3>

<p>Roweis, Sam T. and Saul, Lawrence K. (2000), Nonlinear Dimensionality
Reduction by Locally Linear Embedding,
<em>Science,</em> <strong>290</strong>(5500), 2323&ndash;2326. <a href="https://doi.org/10.1126/science.290.5500.2323">doi:10.1126/science.290.5500.2323</a>
</p>
<p>Grilli, Elisa (2007) Automated Local Linear Embedding with an application
to microarray data, Dissertation thesis, University of Bologna.
<a href="https://doi.org/10.6092/unibo/amsdottorato/380">doi:10.6092/unibo/amsdottorato/380</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
x &lt;- iris[, -5]

# project iris on 2 dimensions
conf &lt;- lle(x, m = 2, k = 30)
conf

plot(conf, col = iris[, 5])

# project iris onto a single dimension
conf &lt;- lle(x, m = 1, k = 30)
conf

plot_config(conf, col = iris[, 5], labels = FALSE)
</code></pre>

<hr>
<h2 id='LS'>Neighborhood functions for Seriation Method SA</h2><span id='topic+LS'></span><span id='topic+LS_swap'></span><span id='topic+LS_insert'></span><span id='topic+LS_reverse'></span><span id='topic+LS_mixed'></span>

<h3>Description</h3>

<p>Definition of different local neighborhood functions for the method <code>"SA"</code> for <code><a href="#topic+seriate">seriate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS_swap(o, pos = sample.int(length(o), 2))

LS_insert(o, pos = sample.int(length(o), 2))

LS_reverse(o, pos = sample.int(length(o), 2))

LS_mixed(o, pos = sample.int(length(o), 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LS_+3A_o">o</code></td>
<td>
<p>an integer vector with the order</p>
</td></tr>
<tr><td><code id="LS_+3A_pos">pos</code></td>
<td>
<p>random positions used for the local move.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Local neighborhood functions are <code>LS_insert</code>, <code>LS_swap</code>, <code>LS_reverse</code>, and <code>LS_mix</code>
(1/3 insertion, 1/3 swap and 1/3 reverse). Any neighborhood function can be defined.
</p>


<h3>Value</h3>

<p>returns the new order vector representing the random neighbor.
</p>

<hr>
<h2 id='Munsingen'>Hodson's Munsingen Data Set</h2><span id='topic+Munsingen'></span>

<h3>Description</h3>

<p>This data set contains a grave times artifact incidence matrix for the
Celtic Münsingen-Rain cemetery in Switzerland as provided by Hodson (1968)
and published by Kendall 1971.
</p>


<h3>Format</h3>

<p>A 59 x 70 0-1 matrix. Rows (graves) and columns (artifacts) are in
the order determined by Hodson (1968).
</p>


<h3>References</h3>

<p>Hodson, F.R. (1968): <em>The La Tene Cemetery at
Münsingen-Rain</em>. Stämpfli, Bern.
</p>
<p>Kendall, D.G. (1971): Seriation from abundance matrices. In: Hodson, F.R.,
Kendall, D.G. and Tautu, P., (Editors). <em>Mathematics in the
Archaeological and Historical Sciences,</em> Edinburgh University Press,
Edinburgh, 215&ndash;232.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Munsingen")

## Seriation method after Kendall (1971)
## Kendall's square symmetric matrix S and SoS
S &lt;- function(x, w = 1) {
  sij &lt;- function(i , j) w * sum(pmin(x[i,], x[j,]))
  h &lt;- nrow(x)
  r &lt;- matrix(ncol = h, nrow =h)
  for(i in 1:h) for (j in 1:h)  r[i,j] &lt;- sij(i,j)
  r
}

SoS &lt;- function(x) S(S(x))

## Kendall's horse shoe (Hamiltonian arc)
horse_shoe_plot &lt;- function(mds, sigma, threshold = mean(sigma), ...) {
    plot(mds, main = paste("Kendall's horse shoe with th =", threshold), ...)
    l &lt;- which(sigma &gt; threshold, arr.ind=TRUE)
    for(i in 1:nrow(l))  lines(rbind(mds[l[i,1],], mds[l[i,2],]))
}

## shuffle data
x &lt;- Munsingen[sample(nrow(Munsingen)),]

## calculate matrix and do isoMDS (from package MASS)
sigma &lt;- SoS(x)
library("MASS")
mds &lt;- isoMDS(1/(1+sigma))$points

## plot Kendall's horse shoe
horse_shoe_plot(mds, sigma)

## find order using a TSP
library("TSP")
tour &lt;- solve_TSP(insert_dummy(TSP(dist(mds)), label = "cut"),
    method = "2-opt", control = list(rep = 15))
tour &lt;- cut_tour(tour, "cut")
lines(mds[tour,], col = "red", lwd = 2)

## create and plot order
order &lt;- ser_permutation(tour, 1:ncol(x))
bertinplot(x, order, options= list(panel=panel.circles,
    rev = TRUE))

## compare criterion values
rbind(
    random = criterion(x),
    reordered = criterion(x, order),
    Hodson = criterion(Munsingen)
   )

</code></pre>

<hr>
<h2 id='palette'>Different Useful Color Palettes</h2><span id='topic+palette'></span><span id='topic+bluered'></span><span id='topic+palette+2C'></span><span id='topic+colors'></span><span id='topic+greenred'></span><span id='topic+reds'></span><span id='topic+blues'></span><span id='topic+greens'></span><span id='topic+greys'></span><span id='topic+grays'></span>

<h3>Description</h3>

<p>Defines several color palettes for <code><a href="#topic+pimage">pimage()</a></code>, <code><a href="#topic+dissplot">dissplot()</a></code> and
<code><a href="#topic+hmap">hmap()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bluered(n = 100, bias = 1, power = 1, ...)

greenred(n = 100, bias = 1, power = 1, ...)

reds(n = 100, bias = 1, power = 1, ...)

blues(n = 100, bias = 1, power = 1, ...)

greens(n = 100, bias = 1, power = 1, ...)

greys(n = 100, bias = 1, power = 1, ...)

grays(n = 100, bias = 1, power = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palette_+3A_n">n</code></td>
<td>
<p>number of different colors produces.</p>
</td></tr>
<tr><td><code id="palette_+3A_bias">bias</code></td>
<td>
<p>a positive number. Higher values give more widely spaced colors
at the high end.</p>
</td></tr>
<tr><td><code id="palette_+3A_power">power</code></td>
<td>
<p>used to control how chroma and luminance is increased (1 =
linear, 2 = quadratic, etc.)</p>
</td></tr>
<tr><td><code id="palette_+3A_...">...</code></td>
<td>
<p>further parameters are passed on to <code><a href="colorspace.html#topic+sequential_hcl">sequential_hcl()</a></code>
or <code><a href="colorspace.html#topic+diverging_hcl">diverging_hcl()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The color palettes are created with <code><a href="colorspace.html#topic+sequential_hcl">sequential_hcl()</a></code> and
<code><a href="colorspace.html#topic+diverging_hcl">diverging_hcl()</a></code> from package <span class="pkg">colorspace</span>.
</p>
<p>The two sequential palettes are: <code>reds()</code> and <code>grays()</code> (or
<code>greys()</code>).
</p>
<p>The two diverging palettes are: <code>bluered()</code> and <code>greenred()</code>.
</p>


<h3>Value</h3>

<p>A vector with <code>n</code> colors.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other plots: 
<code><a href="#topic+VAT">VAT</a>()</code>,
<code><a href="#topic+bertinplot">bertinplot</a>()</code>,
<code><a href="#topic+dissplot">dissplot</a>()</code>,
<code><a href="#topic+hmap">hmap</a>()</code>,
<code><a href="#topic+pimage">pimage</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- outer(1:10,1:10)
m

pimage(m)
pimage(m, col = greys(100, power = 2))
pimage(m, col = greys(100, bias = 2))
pimage(m, col = bluered(100))
pimage(m, col = bluered(100, power = .5))
pimage(m, col = bluered(100, bias = 2))
pimage(m - 25, col = greenred(20, bias = 2))

## choose your own color palettes
library(colorspace)
hcl_palettes(plot = TRUE)

## blues (with 20 shades)
pimage(m,
  col = colorspace::sequential_hcl(20, "Blues", rev = TRUE))
## blue to green (aka "Cork")
pimage(m,
  col = colorspace::diverging_hcl(100, "Cork"))
</code></pre>

<hr>
<h2 id='permutation_vector2matrix'>Conversion Between Permutation Vector and Permutation Matrix</h2><span id='topic+permutation_vector2matrix'></span><span id='topic+permutation_matrix2vector'></span>

<h3>Description</h3>

<p>Converts between permutation vectors and matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutation_vector2matrix(x)

permutation_matrix2vector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutation_vector2matrix_+3A_x">x</code></td>
<td>
<p>A permutation vector (any object that can be converted into a
permutation vector, e.g., a integer vector or a <code>hclust</code> object) or a
matrix representing a permutation. Arguments are checked.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>permutation_vector2matrix()</code>: returns a permutation matrix.
</p>
</li>
<li> <p><code>permutation_matrix2vector()</code>: returns the permutation as a integer vector.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other permutation: 
<code><a href="#topic+get_order">get_order</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+ser_dist">ser_dist</a>()</code>,
<code><a href="#topic+ser_permutation_vector">ser_permutation_vector</a>()</code>,
<code><a href="#topic+ser_permutation">ser_permutation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a random permutation vector
pv &lt;- structure(sample(5), names = paste0("X", 1:5))
pv

## convert into a permutation matrix
pm &lt;- permutation_vector2matrix(pv)
pm

## convert back
permutation_matrix2vector(pm)
</code></pre>

<hr>
<h2 id='permute'>Permute the Order in Various Objects</h2><span id='topic+permute'></span><span id='topic+permute.array'></span><span id='topic+permute.matrix'></span><span id='topic+permute.data.frame'></span><span id='topic+permute.table'></span><span id='topic+permute.numeric'></span><span id='topic+permute.character'></span><span id='topic+permute.list'></span><span id='topic+permute.dist'></span><span id='topic+permute.dendrogram'></span><span id='topic+permute.hclust'></span>

<h3>Description</h3>

<p>Provides the generic function and methods for permuting the order of various
objects including vectors, lists, dendrograms (also <code>hclust</code> objects),
the order of observations in a <code>dist</code> object, the rows and columns of a
matrix or data.frame, and all dimensions of an array given a suitable
<a href="#topic+ser_permutation">ser_permutation</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute(x, order, ...)

## S3 method for class 'array'
permute(x, order, margin = NULL, ...)

## S3 method for class 'matrix'
permute(x, order, margin = NULL, ...)

## S3 method for class 'data.frame'
permute(x, order, margin = NULL, ...)

## S3 method for class 'table'
permute(x, order, margin = NULL, ...)

## S3 method for class 'numeric'
permute(x, order, ...)

## S3 method for class 'character'
permute(x, order, ...)

## S3 method for class 'list'
permute(x, order, ...)

## S3 method for class 'dist'
permute(x, order, ...)

## S3 method for class 'dendrogram'
permute(x, order, dist = NULL, ...)

## S3 method for class 'hclust'
permute(x, order, dist = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_+3A_x">x</code></td>
<td>
<p>an object (a list, a vector, a <code>dist</code> object, a matrix, an
array or any other object which provides <code>dim</code> and standard subsetting
with <code>"["</code>).</p>
</td></tr>
<tr><td><code id="permute_+3A_order">order</code></td>
<td>
<p>an object of class <a href="#topic+ser_permutation">ser_permutation</a> which contains
suitable permutation vectors for <code>x</code>. Alternatively, a character string with the
name of a seriation method appropriate for <code>x</code> can be specified (see <code><a href="#topic+seriate">seriate()</a></code>).
This will perform seriation and permute <code>x</code>. The value <code>TRUE</code> will permute using the
default seriation method.</p>
</td></tr>
<tr><td><code id="permute_+3A_...">...</code></td>
<td>
<p>if <code>order</code> is the name of a seriation method, then additional arguments are
passed on to <code><a href="#topic+seriate">seriate()</a></code>.</p>
</td></tr>
<tr><td><code id="permute_+3A_margin">margin</code></td>
<td>
<p>specifies the dimensions to be permuted as a vector with dimension indices.
If <code>NULL</code>, <code>order</code> needs to contain a permutation for all dimensions.
If a single margin is specified, then <code>order</code> can also contain
a single permutation vector.
<code>margin</code> are ignored.</p>
</td></tr>
<tr><td><code id="permute_+3A_dist">dist</code></td>
<td>
<p>the distance matrix used to create the dendrogram. Only needed if
order is the name of a seriation method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The permutation vectors in <a href="#topic+ser_permutation">ser_permutation</a> are suitable if the number
of permutation vectors matches the number of dimensions of <code>x</code> and if
the length of each permutation vector has the same length as the
corresponding dimension of <code>x</code>.
</p>
<p>For 1-dimensional/1-mode data (list, vector, <code>dist</code>), <code>order</code> can
also be a single permutation vector of class <a href="#topic+ser_permutation_vector">ser_permutation_vector</a>
or data which can be automatically coerced to this class (e.g. a numeric
vector).
</p>
<p>For <code>dendrogram</code> and <code>hclust</code>, subtrees are rotated to represent
the order best possible. If the order is not achieved perfectly then the
user is warned. See also <code><a href="#topic+reorder.hclust">reorder.hclust()</a></code> for
reordering <code>hclust</code> objects.
</p>


<h3>Value</h3>

<p>A permuted object of the same class as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other permutation: 
<code><a href="#topic+get_order">get_order</a>()</code>,
<code><a href="#topic+permutation_vector2matrix">permutation_vector2matrix</a>()</code>,
<code><a href="#topic+ser_dist">ser_dist</a>()</code>,
<code><a href="#topic+ser_permutation_vector">ser_permutation_vector</a>()</code>,
<code><a href="#topic+ser_permutation">ser_permutation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List data types for permute
methods("permute")

# Permute matrix
m &lt;- matrix(rnorm(10), 5, 2, dimnames = list(1:5, LETTERS[1:2]))
m

# Permute rows and columns
o &lt;- ser_permutation(5:1, 2:1)
o

permute(m, o)

## permute only columns
permute(m, o, margin = 2)

## permute using PCA seriation
permute(m, "PCA")

## permute only rows using PCA
permute(m, "PCA", margin = 1)

# Permute data.frames using heatmap seration (= hierarchical
#  clustering + optimal leaf ordering)
df &lt;- as.data.frame(m)
permute(df, "Heatmap")

# Permute objects in a dist object
d &lt;- dist(m)
d

permute(d, c(3, 2, 1, 4, 5))

permute(d, "Spectral")

# Permute a list
l &lt;- list(a = 1:5, b = letters[1:3], c = 0)
l

permute(l, c(2, 3, 1))

# Permute to reorder dendrogram (see also reorder.hclust)
hc &lt;- hclust(d)
plot(hc)

plot(permute(hc, 5:1))
plot(permute(hc, 5:1, incompartible = "stop"))

plot(permute(hc, "OLO", dist = d))
plot(permute(hc, "GW", dist = d))
plot(permute(hc, "MDS", dist = d))
plot(permute(hc, "TSP", dist = d))
</code></pre>

<hr>
<h2 id='pimage'>Permutation Image Plot</h2><span id='topic+pimage'></span><span id='topic+pimage.matrix'></span><span id='topic+pimage.table'></span><span id='topic+pimage.data.frame'></span><span id='topic+pimage.dist'></span><span id='topic+ggpimage'></span><span id='topic+ggpimage.matrix'></span><span id='topic+ggpimage.dist'></span>

<h3>Description</h3>

<p>Provides methods for matrix shading, i.e., displaying a color image for
matrix (including correlation matrices and data frames) and <code>dist</code> objects given an
optional permutation. The plot arranges colored rectangles to represent the
values in the matrix. This visualization is also know as a heatmap.
Implementations based on the
<span class="pkg">grid</span> graphics engine and based n <span class="pkg">ggplot2</span> are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pimage(x, order = FALSE, ...)

## S3 method for class 'matrix'
pimage(
  x,
  order = FALSE,
  col = NULL,
  main = "",
  xlab = "",
  ylab = "",
  zlim = NULL,
  key = TRUE,
  keylab = "",
  symkey = TRUE,
  upper_tri = TRUE,
  lower_tri = TRUE,
  diag = TRUE,
  row_labels = NULL,
  col_labels = NULL,
  prop = isSymmetric(x),
  flip_axes = FALSE,
  reverse_columns = FALSE,
  ...,
  newpage = TRUE,
  pop = TRUE,
  gp = NULL
)

## S3 method for class 'table'
pimage(x, order = NULL, ...)

## S3 method for class 'data.frame'
pimage(x, order = NULL, ...)

## S3 method for class 'dist'
pimage(
  x,
  order = NULL,
  col = NULL,
  main = "",
  xlab = "",
  ylab = "",
  zlim = NULL,
  key = TRUE,
  keylab = "",
  symkey = TRUE,
  upper_tri = TRUE,
  lower_tri = TRUE,
  diag = TRUE,
  row_labels = NULL,
  col_labels = NULL,
  prop = TRUE,
  flip_axes = FALSE,
  reverse_columns = FALSE,
  ...,
  newpage = TRUE,
  pop = TRUE,
  gp = NULL
)

ggpimage(x, order = NULL, ...)

## S3 method for class 'matrix'
ggpimage(
  x,
  order = NULL,
  zlim = NULL,
  upper_tri = TRUE,
  lower_tri = TRUE,
  diag = TRUE,
  row_labels = NULL,
  col_labels = NULL,
  prop = isSymmetric(x),
  flip_axes = FALSE,
  reverse_columns = FALSE,
  ...
)

## S3 method for class 'dist'
ggpimage(
  x,
  order = NULL,
  zlim = NULL,
  upper_tri = TRUE,
  lower_tri = TRUE,
  diag = TRUE,
  row_labels = NULL,
  col_labels = NULL,
  prop = TRUE,
  flip_axes = FALSE,
  reverse_columns = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pimage_+3A_x">x</code></td>
<td>
<p>a matrix, a data.frame, or an object of class <code>dist</code>.</p>
</td></tr>
<tr><td><code id="pimage_+3A_order">order</code></td>
<td>
<p>a logical where <code>FALSE</code> means no reordering and <code>TRUE</code> applies
a permutation using the default seriation method for the type of <code>x</code>. Alternatively,
any object that can be coerced to class <code>ser_permutation</code>
can be supplied.</p>
</td></tr>
<tr><td><code id="pimage_+3A_...">...</code></td>
<td>
<p>if <code>order</code> is the name of a seriation method then further arguments are passed
on to the seriation method, otherwise they are ignored.</p>
</td></tr>
<tr><td><code id="pimage_+3A_col">col</code></td>
<td>
<p>a list of colors used. If <code>NULL</code>, a gray scale is used (for
matrix larger values are displayed darker and for <code>dist</code> smaller
distances are darker). For matrices containing logical data, black and white
is used. For matrices containing negative values a symmetric diverging color
palette is used.</p>
</td></tr>
<tr><td><code id="pimage_+3A_main">main</code></td>
<td>
<p>plot title.</p>
</td></tr>
<tr><td><code id="pimage_+3A_xlab">xlab</code>, <code id="pimage_+3A_ylab">ylab</code></td>
<td>
<p>labels for the x and y axes.</p>
</td></tr>
<tr><td><code id="pimage_+3A_zlim">zlim</code></td>
<td>
<p>vector with two elements giving the range (min, max) for
representing the values in the matrix.</p>
</td></tr>
<tr><td><code id="pimage_+3A_key">key</code></td>
<td>
<p>logical; add a color key? No key is available for logical
matrices.</p>
</td></tr>
<tr><td><code id="pimage_+3A_keylab">keylab</code></td>
<td>
<p>string plotted next to the color key.</p>
</td></tr>
<tr><td><code id="pimage_+3A_symkey">symkey</code></td>
<td>
<p>logical; if <code>x</code> contains negative values, should the
color palate be symmetric (zero is in the middle)?</p>
</td></tr>
<tr><td><code id="pimage_+3A_upper_tri">upper_tri</code>, <code id="pimage_+3A_lower_tri">lower_tri</code>, <code id="pimage_+3A_diag">diag</code></td>
<td>
<p>a logical indicating whether to show the
upper triangle, the lower triangle or the diagonal of the (distance) matrix.</p>
</td></tr>
<tr><td><code id="pimage_+3A_row_labels">row_labels</code>, <code id="pimage_+3A_col_labels">col_labels</code></td>
<td>
<p>a logical indicating if row and column labels
in <code>x</code> should be displayed.  If <code>NULL</code> then labels are displayed
if the <code>x</code> contains the appropriate dimname and the number of labels is
25 or less. A character vector of the appropriate length with labels can
also be supplied.</p>
</td></tr>
<tr><td><code id="pimage_+3A_prop">prop</code></td>
<td>
<p>logical; change the aspect ratio so cells in the image have a
equal width and height.</p>
</td></tr>
<tr><td><code id="pimage_+3A_flip_axes">flip_axes</code></td>
<td>
<p>logical; exchange rows and columns for plotting.</p>
</td></tr>
<tr><td><code id="pimage_+3A_reverse_columns">reverse_columns</code></td>
<td>
<p>logical; revers the order of how the columns are
displayed.</p>
</td></tr>
<tr><td><code id="pimage_+3A_newpage">newpage</code>, <code id="pimage_+3A_pop">pop</code>, <code id="pimage_+3A_gp">gp</code></td>
<td>
<p>Start plot on a new page, pop the viewports after
plotting, and use the supplied <code>gpar</code> object (see <span class="pkg">grid</span>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots a matrix in its original row and column orientation (<a href="Matrix.html#topic+image">image</a> in <span class="pkg">stats</span>
reverses the rows). This means, in a
plot the columns become the x-coordinates and the rows the y-coordinates (in
reverse order).
</p>
<p><strong>Grid-based plot:</strong> The viewports used for plotting are called:
<code>"plot"</code>, <code>"image"</code> and <code>"colorkey"</code>.  Use <span class="pkg">grid</span> functions
to manipulate the plots (see Examples section).
</p>
<p><strong>ggplot2-based plot:</strong> A ggplot2 object is returned. Colors, axis limits
and other visual aspects can be added using standard ggplot2 functions
(<code>labs</code>, <code>scale_fill_continuous</code>, <code>labs</code>, etc.).
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta and Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other plots: 
<code><a href="#topic+VAT">VAT</a>()</code>,
<code><a href="#topic+bertinplot">bertinplot</a>()</code>,
<code><a href="#topic+dissplot">dissplot</a>()</code>,
<code><a href="#topic+hmap">hmap</a>()</code>,
<code><a href="#topic+palette">palette</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
data(iris)
x &lt;- as.matrix(iris[sample(nrow(iris), 20) , -5])

pimage(x)

# Show all labels and flip axes, reverse columns, or change colors
pimage(x, prop = TRUE)
pimage(x, flip_axes = TRUE)
pimage(x, reverse_columns = TRUE)
pimage(x, col = grays(100))

# A matrix with positive and negative values
x_scaled &lt;- scale(x)
pimage(x_scaled)

# Use reordering
pimage(x_scaled, order = TRUE)
pimage(x_scaled, order = "Heatmap")

## Example: Distance Matrix
# Show a reordered distance matrix (distances between rows).
# Dark means low distance. The aspect ratio is automatically fixed to 1:1
# using prop = TRUE
d &lt;- dist(x)
pimage(d)
pimage(d, order = TRUE)

# Supress the upper triangle and diagonal
pimage(d, order = TRUE, upper = FALSE, diag = FALSE)

# Show only distances that are smaller than 2 using limits on z.
pimage(d, order = TRUE, zlim = c(0, 3))

## Example: Correlation Matrix
# we calculate correlation between rows and seriate the matrix
# and seriate by converting the correlations into distances.
# pimage reorders then rows and columns with c(o, o).
r &lt;- cor(t(x))
o &lt;- seriate(as.dist(sqrt(1 - r)))
pimage(r, order = c(o, o),
  upper = FALSE, diag = FALSE,
  zlim = c(-1, 1),
  reverse_columns = TRUE,
  main = "Correlation matrix")

# Add to the plot using functions in package grid
# Note: pop = FALSE allows us to manipulate viewports
library("grid")
pimage(x, order = TRUE, pop = FALSE)

# available viewports are: "main", "colorkey", "plot", "image"
current.vpTree()

# Highlight cell 2/2 with a red arrow
# Note: columns are x and rows are y.
downViewport(name = "image")
grid.lines(x = c(1, 2), y = c(-1, 2), arrow = arrow(),
  default.units = "native", gp = gpar(col = "red", lwd = 3))

# add a red box around the first 4 rows of the 2nd column
grid.rect(x = 1 + .5 , y = 4 + .5, width = 1, height = 4,
  hjust = 0, vjust = 1,
  default.units = "native", gp = gpar(col = "red", lwd = 3, fill = NA))

## remove the viewports
popViewport(0)

## put several pimages on a page (use grid viewports and newpage = FALSE)
# set up grid layout
library(grid)
grid.newpage()
top_vp &lt;- viewport(layout = grid.layout(nrow = 1, ncol = 2,
  widths = unit(c(.4, .6), unit = "npc")))
col1_vp &lt;- viewport(layout.pos.row = 1, layout.pos.col = 1, name = "col1_vp")
col2_vp &lt;- viewport(layout.pos.row = 1, layout.pos.col = 2, name = "col2_vp")
splot &lt;- vpTree(top_vp, vpList(col1_vp, col2_vp))
pushViewport(splot)

seekViewport("col1_vp")
o &lt;- seriate(d)
pimage(x, c(o, NA), col_labels = FALSE, main = "Data",
  newpage = FALSE)

seekViewport("col2_vp")
## add the reordered dissimilarity matrix for rows
pimage(d, o, main = "Distances",
  newpage = FALSE)

popViewport(0)

##-------------------------------------------------------------
## ggplot2 Examples
if (require("ggplot2")) {

library("ggplot2")

set.seed(1234)
data(iris)
x &lt;- as.matrix(iris[sample(nrow(iris), 20) , -5])

ggpimage(x)

# Show all labels and flip axes, reverse columns
ggpimage(x, prop = TRUE)
ggpimage(x, flip_axes = TRUE)
ggpimage(x, reverse_columns = TRUE)


# A matrix with positive and negative values
x_scaled &lt;- scale(x)
ggpimage(x_scaled)

# Use reordering
ggpimage(x_scaled, order = TRUE)
ggpimage(x_scaled, order = "Heatmap")

## Example: Distance Matrix
# Show a reordered distance matrix (distances between rows).
# Dark means low distance. The aspect ratio is automatically fixed to 1:1
# using prop = TRUE
d &lt;- dist(x)
ggpimage(d)
ggpimage(d, order = TRUE)

# Supress the upper triangle and diagonal
ggpimage(d, order = TRUE, upper = FALSE, diag = FALSE)

# Show only distances that are smaller than 2 using limits on z.
ggpimage(d, order = TRUE, zlim = c(0, 2))

## Example: Correlation Matrix
# we calculate correlation between rows and seriate the matrix
r &lt;- cor(t(x))
o &lt;- seriate(as.dist(sqrt(1 - r)))
ggpimage(r, order = c(o, o),
  upper = FALSE, diag = FALSE,
  zlim = c(-1, 1),
  reverse_columns = TRUE) + labs(title = "Correlation matrix")

## Example: Custom themes and colors
# Reorder matrix, use custom colors, add a title,
# and hide colorkey.
ggpimage(x) +
  theme(legend.position = "none") +
  labs(title = "Random Data") + xlab("Variables")

# Add lines
ggpimage(x) +
  geom_hline(yintercept = seq(0, nrow(x)) + .5) +
  geom_vline(xintercept = seq(0, ncol(x)) + .5)

# Use ggplot2 themes with theme_set
old_theme &lt;- theme_set(theme_linedraw())
ggpimage(d)
theme_set(old_theme)

# Use custom color palettes: Gray scale, Colorbrewer (provided in ggplot2) and colorspace
ggpimage(d, order = seriate(d), upper_tri = FALSE) +
  scale_fill_gradient(low = "black", high = "white", na.value = "white")

ggpimage(d, order = seriate(d), upper_tri = FALSE) +
  scale_fill_distiller(palette = "Spectral", direction = +1, na.value = "white")

ggpimage(d, order = seriate(d), upper_tri = FALSE) +
  colorspace::scale_fill_continuous_sequential("Reds", rev = FALSE, na.value = "white")
}
</code></pre>

<hr>
<h2 id='Psych24'>Results of 24 Psychological Test for 8th Grade Students</h2><span id='topic+Psych24'></span>

<h3>Description</h3>

<p>A data set collected by Holzinger and Swineford (1939) which consists of the
results of 24 psychological tests given to 145 seventh and eighth grade
students in a Chicago suburb. This data set contains the correlation matrix
for the 24 test results.
The data set was also used as an example for visualization of cluster analysis
by Ling (1973).
</p>


<h3>Format</h3>

<p>A 24 x 24 correlation matrix.
</p>


<h3>References</h3>

<p>Holzinger, K. L., Swineford, F. (1939):
A study in factor analysis: The stability of a bi-factor solution.
<em>Supplementary Educational Monograph,</em> No. <b>48</b>.
Chicago: University of Chicago Press.
</p>
<p>Ling, R. L. (1973): A computer generated aid for cluster analysis.
<em>Communications of the ACM</em>,
<b>16</b>(6), pp. 355&ndash;361.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Psych24")

## create a dist object and also get rid of the one negative entry in the
## correlation matrix
d &lt;- as.dist(1 - abs(Psych24))

pimage(d)

## do hclust as in Ling (1973)
hc &lt;- hclust(d, method = "complete")
plot(hc)

pimage(d, hc)

## use seriation
order &lt;- seriate(d, method = "tsp")
#order &lt;- seriate(d, method = "tsp", control = list(method = "concorde"))
pimage(d, order)
</code></pre>

<hr>
<h2 id='register_DendSer'>Register Seriation Methods from Package DendSer</h2><span id='topic+register_DendSer'></span><span id='topic+DendSer'></span><span id='topic+dendser'></span>

<h3>Description</h3>

<p>Register the DendSer dendrogram seriation method and the ARc criterion
(Earle and Hurley, 2015) for use with <code><a href="#topic+seriate">seriate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_DendSer()
</code></pre>


<h3>Details</h3>

<p>Registers the method <code>"DendSer"</code> for seriate. DendSer is a fast
heuristic for reordering dendrograms developed by Earle and Hurley (2015)
able to use different criteria.
</p>
<p><code>control</code> for <code><a href="#topic+seriate">seriate()</a></code> with
method <code>"DendSer"</code> accepts the following parameters:
</p>

<ul>
<li> <p><code>"h"</code> or <code>"method"</code>: A dendrogram or a method for hierarchical clustering
(see <a href="stats.html#topic+hclust">hclust</a>). Default: complete-link.
</p>
</li>
<li> <p><code>"criterion"</code>: A seriation criterion to optimize (see
<code>list_criterion_methods("dist")</code>. Default: <code>"BAR"</code> (Banded
anti-Robinson from with 20% band width).
</p>
</li>
<li> <p><code>"verbose"</code>: a logical; print progress information?
</p>
</li>
<li> <p><code>"DendSer_args"</code>: additional arguments for <code><a href="DendSer.html#topic+DendSer">DendSer::DendSer()</a></code>.
</p>
</li></ul>

<p>For convenience, the following methods (for different cost functions) are
also provided:
</p>

<ul>
<li> <p><code>"DendSer_ARc"</code> (anti-robinson form),
</p>
</li>
<li> <p><code>"DendSer_BAR"</code> (banded anti-Robinson form),
</p>
</li>
<li> <p><code>"DendSer_LPL"</code> (lazy path length),
</p>
</li>
<li> <p><code>"DendSer_PL"</code> (path length).
</p>
</li></ul>

<p>Note: Package <span class="pkg">DendSer</span> needs to be installed.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler based on code by Catherine B. Hurley and Denise
Earle
</p>


<h3>References</h3>

<p>D. Earle, C. B. Hurley (2015): Advances in dendrogram seriation
for application to visualization. <em>Journal of Computational and
Graphical Statistics,</em> <b>24</b>(1), 1&ndash;25.
</p>


<h3>See Also</h3>

<p>Other seriation: 
<code><a href="#topic+register_GA">register_GA</a>()</code>,
<code><a href="#topic+register_optics">register_optics</a>()</code>,
<code><a href="#topic+register_smacof">register_smacof</a>()</code>,
<code><a href="#topic+register_tsne">register_tsne</a>()</code>,
<code><a href="#topic+register_umap">register_umap</a>()</code>,
<code><a href="#topic+registry_for_seriaiton_methods">registry_for_seriaiton_methods</a></code>,
<code><a href="#topic+seriate_best">seriate_best</a>()</code>,
<code><a href="#topic+seriate">seriate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
register_DendSer()
get_seriation_method("dist", "DendSer")

d &lt;- dist(random.robinson(20, pre=TRUE))

## use Banded AR form with default clustering (complete-link)
o &lt;- seriate(d, "DendSer_BAR")
pimage(d, o)

## use different hclust method (Ward) and AR as the cost function for
## dendrogram reordering
o &lt;- seriate(d, "DendSer", control = list(method = "ward.D2", criterion = "AR"))
pimage(d, o)

## End(Not run)

</code></pre>

<hr>
<h2 id='register_GA'>Register a Genetic Algorithm Seriation Method</h2><span id='topic+register_GA'></span><span id='topic+GA'></span><span id='topic+ga'></span><span id='topic+gaperm_mixedMutation'></span>

<h3>Description</h3>

<p>Register a GA-based seriation metaheuristic for use with <code><a href="#topic+seriate">seriate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_GA()

gaperm_mixedMutation(ismProb = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_GA_+3A_ismprob">ismProb</code></td>
<td>
<p>probability to use <code><a href="GA.html#topic+ga_Mutation">GA::gaperm_ismMutation()</a></code> (inversion) versus <code><a href="GA.html#topic+ga_Mutation">GA::gaperm_simMutation()</a></code> (simple insertion).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Registers the method <code>"GA"</code> for <code><a href="#topic+seriate">seriate()</a></code>. This method can be used
to optimize any criterion in package <span class="pkg">seriation</span>.
</p>
<p>The GA uses by default the ordered cross-over (OX) operator. For mutation,
the GA uses a mixture of simple insertion and simple inversion operators.
This mixed operator is created using
<code>seriation::gaperm_mixedMutation(ismProb = .8)</code>, where <code>ismProb</code>
is the probability that the simple insertion mutation operator is used. See
package <span class="pkg">GA</span> for a description of other available cross-over and
mutation operators for permutations. The appropriate operator functions in
<span class="pkg">GA</span> start with <code>gaperm_</code>.
</p>
<p>We warm start the GA using <code>"suggestions"</code> given by several heuristics.
Set <code>"suggestions"</code> to <code>NA</code> to start with a purely random initial
population.
</p>
<p>See Example section for available control parameters.
</p>
<p><b>Note:</b> Package <span class="pkg">GA</span> needs to be installed.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Luca Scrucca (2013): GA: A Package for Genetic Algorithms in R.
<em>Journal of Statistical Software,</em> <b>53</b>(4), 1&ndash;37. URL
<a href="https://doi.org/10.18637/jss.v053.i04">doi:10.18637/jss.v053.i04</a>.
</p>


<h3>See Also</h3>

<p>Other seriation: 
<code><a href="#topic+register_DendSer">register_DendSer</a>()</code>,
<code><a href="#topic+register_optics">register_optics</a>()</code>,
<code><a href="#topic+register_smacof">register_smacof</a>()</code>,
<code><a href="#topic+register_tsne">register_tsne</a>()</code>,
<code><a href="#topic+register_umap">register_umap</a>()</code>,
<code><a href="#topic+registry_for_seriaiton_methods">registry_for_seriaiton_methods</a></code>,
<code><a href="#topic+seriate_best">seriate_best</a>()</code>,
<code><a href="#topic+seriate">seriate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
register_GA()
get_seriation_method("dist", "GA")

data(SupremeCourt)
d &lt;- as.dist(SupremeCourt)

## optimize for linear seriation criterion (LS)
o &lt;- seriate(d, "GA", criterion = "LS", verbose = TRUE)
pimage(d, o)

## Note that by default the algorithm is already seeded with a LS heuristic.
## This run is no warm start (no suggestions) and increase run to 100
o &lt;- seriate(d, "GA", criterion = "LS", suggestions = NA, run = 100,
  verbose = TRUE)
pimage(d, o)

o &lt;- seriate(d, "GA", criterion = "LS", suggestions = NA, run = 100,
  verbose = TRUE,  )

pimage(d, o)

## End(Not run)
</code></pre>

<hr>
<h2 id='register_optics'>Register Seriation Based on OPTICS</h2><span id='topic+register_optics'></span><span id='topic+optics'></span><span id='topic+OPTICS'></span>

<h3>Description</h3>

<p>Use ordering points to identify the clustering structure (OPTICS) for <code><a href="#topic+seriate">seriate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_optics()
</code></pre>


<h3>Details</h3>

<p>Registers the method <code>"optics"</code> for <code><a href="#topic+seriate">seriate()</a></code>. This method applies
the OPTICS ordering algorithm to create an ordering.
</p>
<p><b>Note:</b> Package <span class="pkg">dbscan</span> needs to be installed.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>References</h3>

<p>Mihael Ankerst, Markus M. Breunig, Hans-Peter Kriegel, Joerg
Sander (1999). OPTICS: Ordering Points To Identify the Clustering Structure.
ACM SIGMOD international conference on Management of data. ACM Press. pp.
49-60. <a href="https://doi.org/10.1145/304181.304187">doi:10.1145/304181.304187</a>
</p>


<h3>See Also</h3>

<p><code><a href="dbscan.html#topic+optics">dbscan::optics()</a></code> in <span class="pkg">dbscan</span>.
</p>
<p>Other seriation: 
<code><a href="#topic+register_DendSer">register_DendSer</a>()</code>,
<code><a href="#topic+register_GA">register_GA</a>()</code>,
<code><a href="#topic+register_smacof">register_smacof</a>()</code>,
<code><a href="#topic+register_tsne">register_tsne</a>()</code>,
<code><a href="#topic+register_umap">register_umap</a>()</code>,
<code><a href="#topic+registry_for_seriaiton_methods">registry_for_seriaiton_methods</a></code>,
<code><a href="#topic+seriate_best">seriate_best</a>()</code>,
<code><a href="#topic+seriate">seriate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
register_optics()
get_seriation_method("dist", "optics")

d &lt;- dist(random.robinson(50, pre=TRUE, noise=.1))

o &lt;- seriate(d, method = "optics")
pimage(d, o)

## End(Not run)

</code></pre>

<hr>
<h2 id='register_smacof'>Register Seriation Methods from Package smacof</h2><span id='topic+register_smacof'></span><span id='topic+registersmacof'></span><span id='topic+smacof'></span>

<h3>Description</h3>

<p>Registers the <code>"MDS_smacof"</code> method for <code><a href="#topic+seriate">seriate()</a></code> based on multidemensional
scaling using stress majorization and the corresponding <code>"smacof_stress0"</code>
criterion implemented in package smacof (de Leeuw &amp; Mair, 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_smacof()
</code></pre>


<h3>Details</h3>

<p>Seriation method <code>"smacof"</code> implements stress majorization with several transformation functions.
These functions are passed on as the type control parameter. We default
to <code>"ratio"</code>, which together with <code>"interval"</code> performs metric MDS.
<code>"ordinal"</code> can be used
for non-metric MDS. See <code><a href="smacof.html#topic+smacofSym">smacof::smacofSym()</a></code> for details on the
control parameters.
</p>
<p>The corresponding criterion calles <code>"smacof_stress0"</code> is also registered.
There additional parameter <code>type</code> is used to specify the used
transformation function. It should agree with the function used for seriation.
See <code><a href="smacof.html#topic+stress0">smacof::stress0()</a></code> for details on the stress calculation.
</p>
<p>Note: Package <span class="pkg">smacof</span> needs to be installed.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>References</h3>

<p>Jan de Leeuw, Patrick Mair (2009). Multidimensional Scaling Using Majorization: SMACOF in R.
<em>Journal of Statistical Software, 31(3),</em> 1-30. <a href="https://doi.org/10.18637/jss.v031.i03">doi:10.18637/jss.v031.i03</a>
</p>


<h3>See Also</h3>

<p>Other seriation: 
<code><a href="#topic+register_DendSer">register_DendSer</a>()</code>,
<code><a href="#topic+register_GA">register_GA</a>()</code>,
<code><a href="#topic+register_optics">register_optics</a>()</code>,
<code><a href="#topic+register_tsne">register_tsne</a>()</code>,
<code><a href="#topic+register_umap">register_umap</a>()</code>,
<code><a href="#topic+registry_for_seriaiton_methods">registry_for_seriaiton_methods</a></code>,
<code><a href="#topic+seriate_best">seriate_best</a>()</code>,
<code><a href="#topic+seriate">seriate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
register_smacof()

get_seriation_method("dist", "MDS_smacof")

d &lt;- dist(random.robinson(20, pre = TRUE))

## use Banded AR form with default clustering (complete-link)
o &lt;- seriate(d, "MDS_smacof", verbose = TRUE)
pimage(d, o)

# recalculate stress for the order
MDS_stress(d, o)

# ordinal MDS. stress needs to be calculated using the correct type with stress0
o &lt;- seriate(d, "MDS_smacof", type = "ordinal", verbose = TRUE)
criterion(d, o, method = "smacof_stress0", type = "ordinal")

## End(Not run)
</code></pre>

<hr>
<h2 id='register_tsne'>Register Seriation Based on 1D t-SNE</h2><span id='topic+register_tsne'></span><span id='topic+tsne'></span><span id='topic+tSNE'></span>

<h3>Description</h3>

<p>Use t-distributed stochastic neighbor embedding (t-SNE) for <code><a href="#topic+seriate">seriate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_tsne()
</code></pre>


<h3>Details</h3>

<p>Registers the method <code>"tsne"</code> for <code><a href="#topic+seriate">seriate()</a></code>. This method applies
1D t-SNE to a data matrix or a distance matrix and extracts the order
from the 1D embedding. To speed up the process, an initial embedding is
created using 1D multi-dimensional scaling (MDS) or principal
comonents analysis (PCA) which is improved by t-SNE.
</p>
<p>The <code>control</code> parameter <code>"mds"</code> or <code>"pca"</code> controls if MDS (for distances)
or PCA (for data matrices) is used to create an
initial embedding. See <code><a href="Rtsne.html#topic+Rtsne">Rtsne::Rtsne()</a></code> to learn about the other
available <code>control</code> parameters.
</p>
<p>Perplexity is automatically set as the minimum between 30 and the number of
observations. It can be also specified using the control parameter
<code>"preplexity"</code>.
</p>
<p><b>Note:</b> Package <span class="pkg">Rtsne</span> needs to be installed.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>References</h3>

<p>van der Maaten, L.J.P. &amp; Hinton, G.E., 2008. Visualizing
High-Dimensional Data Using t-SNE. Journal of Machine Learning Research, 9,
pp.2579-2605.
</p>


<h3>See Also</h3>

<p><code><a href="Rtsne.html#topic+Rtsne">Rtsne::Rtsne()</a></code> in <span class="pkg">Rtsne</span>.
</p>
<p>Other seriation: 
<code><a href="#topic+register_DendSer">register_DendSer</a>()</code>,
<code><a href="#topic+register_GA">register_GA</a>()</code>,
<code><a href="#topic+register_optics">register_optics</a>()</code>,
<code><a href="#topic+register_smacof">register_smacof</a>()</code>,
<code><a href="#topic+register_umap">register_umap</a>()</code>,
<code><a href="#topic+registry_for_seriaiton_methods">registry_for_seriaiton_methods</a></code>,
<code><a href="#topic+seriate_best">seriate_best</a>()</code>,
<code><a href="#topic+seriate">seriate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
register_tsne()

# distances
get_seriation_method("dist", "tsne")

data(SupremeCourt)
d &lt;- as.dist(SupremeCourt)

o &lt;- seriate(d, method = "tsne", verbose = TRUE)
pimage(d, o)

# look at the returned configuration and plot it
attr(o[[1]], "configuration")
plot_config(o)

# the t-SNE results are also available as an attribute (see ? Rtsne::Rtsne)
attr(o[[1]], "model")

## matrix
get_seriation_method("matrix", "tsne")

data("Zoo")
x &lt;- Zoo

x[,"legs"] &lt;- (x[,"legs"] &gt; 0)

# t-SNE does not allow duplicates
x &lt;- x[!duplicated(x), , drop = FALSE]

class &lt;- x$class
label &lt;- rownames(x)
x &lt;- as.matrix(x[,-17])

o &lt;- seriate(x, method = "tsne", eta = 10, verbose = TRUE)
pimage(x, o, prop = FALSE, row_labels = TRUE, col_labels = TRUE)

# look at the row embedding
plot_config(o[[1]], col = class)

## End(Not run)

</code></pre>

<hr>
<h2 id='register_umap'>Register Seriation Based on 1D UMAP</h2><span id='topic+register_umap'></span><span id='topic+umap'></span>

<h3>Description</h3>

<p>Use uniform manifold approximation and projection (UMAP) to embed the data
on the number line and create a order for <code><a href="#topic+seriate">seriate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_umap()
</code></pre>


<h3>Details</h3>

<p>Registers the method <code>"umap"</code> for <code><a href="#topic+seriate">seriate()</a></code>. This method applies
1D UMAP to a data matrix or a distance matrix and extracts the order from
the 1D embedding.
</p>
<p>Control parameter <code>n_epochs</code> can be increased to find a better embedding.
</p>
<p>The returned seriation permutation vector has an attribute named
<code>embedding</code> containing the umap embedding.
</p>
<p><b>Note:</b> Package <span class="pkg">umap</span> needs to be installed.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>References</h3>

<p>McInnes, L, Healy, J, UMAP: Uniform Manifold Approximation and
Projection for Dimension Reduction, ArXiv e-prints 1802.03426, 2018
</p>


<h3>See Also</h3>

<p><code><a href="umap.html#topic+umap">umap::umap()</a></code> in <span class="pkg">umap</span>.
</p>
<p>Other seriation: 
<code><a href="#topic+register_DendSer">register_DendSer</a>()</code>,
<code><a href="#topic+register_GA">register_GA</a>()</code>,
<code><a href="#topic+register_optics">register_optics</a>()</code>,
<code><a href="#topic+register_smacof">register_smacof</a>()</code>,
<code><a href="#topic+register_tsne">register_tsne</a>()</code>,
<code><a href="#topic+registry_for_seriaiton_methods">registry_for_seriaiton_methods</a></code>,
<code><a href="#topic+seriate_best">seriate_best</a>()</code>,
<code><a href="#topic+seriate">seriate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
register_umap()

## distances
get_seriation_method("dist", "umap")

data(SupremeCourt)
d &lt;- as.dist(SupremeCourt)

o &lt;- seriate(d, method = "umap", verbose = TRUE)
pimage(d, o)

# look at the returned embedding and plot it
attr(o[[1]], "configuration")
plot_config(o)

## matrix
get_seriation_method("matrix", "umap")

data("Zoo")
Zoo[,"legs"] &lt;- (Zoo[,"legs"] &gt; 0)
x &lt;- as.matrix(Zoo[,-17])
label &lt;- rownames(Zoo)
class &lt;- Zoo$class

o &lt;- seriate(x, method = "umap", verbose = TRUE)
pimage(x, o)

plot_config(o[[1]], col = class)

## End(Not run)
</code></pre>

<hr>
<h2 id='registry_for_criterion_methods'>Registry for Criterion Methods</h2><span id='topic+registry_for_criterion_methods'></span><span id='topic+registry_criterion'></span><span id='topic+list_criterion_methods'></span><span id='topic+get_criterion_method'></span><span id='topic+set_criterion_method'></span><span id='topic+print.criterion_method'></span>

<h3>Description</h3>

<p>A registry to manage methods used by <code><a href="#topic+criterion">criterion()</a></code> to calculate a criterion value given data and a
permutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registry_criterion

list_criterion_methods(kind, names_only = TRUE)

get_criterion_method(kind, name)

set_criterion_method(
  kind,
  name,
  fun,
  description = NULL,
  merit = NA,
  verbose = FALSE,
  ...
)

## S3 method for class 'criterion_method'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registry_for_criterion_methods_+3A_kind">kind</code></td>
<td>
<p>the data type the method works on. For example, <code>"dist"</code>,
<code>"matrix"</code> or <code>"array"</code>.</p>
</td></tr>
<tr><td><code id="registry_for_criterion_methods_+3A_names_only">names_only</code></td>
<td>
<p>logical; return only the method name. <code>FALSE</code> returns
also the method descriptions.</p>
</td></tr>
<tr><td><code id="registry_for_criterion_methods_+3A_name">name</code></td>
<td>
<p>the name for the method used to refer to the method in the
function <code><a href="#topic+criterion">criterion()</a></code>.</p>
</td></tr>
<tr><td><code id="registry_for_criterion_methods_+3A_fun">fun</code></td>
<td>
<p>a function containing the method's code.</p>
</td></tr>
<tr><td><code id="registry_for_criterion_methods_+3A_description">description</code></td>
<td>
<p>a description of the method. For example, a long name.</p>
</td></tr>
<tr><td><code id="registry_for_criterion_methods_+3A_merit">merit</code></td>
<td>
<p>a boolean indicating if the criterion measure is a merit
(<code>TRUE</code>) or a loss (<code>FALSE</code>) measure.</p>
</td></tr>
<tr><td><code id="registry_for_criterion_methods_+3A_verbose">verbose</code></td>
<td>
<p>logical; print a message when a new method is registered.</p>
</td></tr>
<tr><td><code id="registry_for_criterion_methods_+3A_...">...</code></td>
<td>
<p>further information that is stored for the method in the
registry.</p>
</td></tr>
<tr><td><code id="registry_for_criterion_methods_+3A_x">x</code></td>
<td>
<p>an object of class &quot;criterion_method&quot; to be printed.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>criterion_registry</code> (inherits from <code>registry</code>) of length 21.
</p>


<h3>Details</h3>

<p>All methods below are convenience methods for the registry named
<code>registry_criterion</code>.
</p>
<p><code>list_criterion_method()</code> lists all available methods for a given data
type (<code>kind</code>). The result is a vector of character strings with the
short names of the methods. If <code>kind</code> is missing, then a list of
methods is returned.
</p>
<p><code>get_criterion_method()</code> returns information (including the
implementing function) about a given method in form of an object of class
<code>"criterion_method"</code>.
</p>
<p>With <code>set_criterion_method()</code> new criterion methods can be added by the
user. The implementing function (<code>fun</code>) needs to have the formal
arguments <code style="white-space: pre;">&#8288;x, order, ...&#8288;</code>, where <code>x</code> is the data object, order is
an object of class <a href="#topic+ser_permutation_vector">ser_permutation_vector</a> and <code>...</code> can contain
additional information for the method passed on from <code><a href="#topic+criterion">criterion()</a></code>. The
implementation has to return the criterion value as a scalar.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>list_criterion_method()</code> results is a vector of character strings with the
names of the methods used for <code>criterion()</code>.
</p>
</li>
<li> <p><code>get_criterion_method()</code> returns a given method in form of an object of class
<code>"criterion_method"</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>This registry uses <code><a href="registry.html#topic+registry">registry()</a></code> in package <span class="pkg">registry</span>.
</p>
<p>Other criterion: 
<code><a href="#topic+criterion">criterion</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the registry
registry_criterion

# List all criterion calculation methods by type
list_criterion_methods()

# List methods for matrix
list_criterion_methods("matrix")

# get more description
list_criterion_methods("matrix", names_only = FALSE)

# get a specific method
get_criterion_method(kind = "dist", name = "AR_d")

# Define a new method (sum of the diagonal elements)

## 1. implement a function to calculate the measure
criterion_method_matrix_foo &lt;- function(x, order, ...) {
if(!is.null(order)) x &lt;- permute(x,order)
    sum(diag(x))
}

## 2. Register new method
set_criterion_method("matrix", "DiagSum", criterion_method_matrix_foo,
    description = "Calculated the sum of all diagonal entries", merit = FALSE)

list_criterion_methods("matrix")
get_criterion_method("matrix", "DiagSum")

## 3. use all criterion methods (including the new one)
criterion(matrix(1:9, ncol = 3))
</code></pre>

<hr>
<h2 id='registry_for_seriaiton_methods'>Registry for Seriation Methods</h2><span id='topic+registry_for_seriaiton_methods'></span><span id='topic+registry_seriate'></span><span id='topic+list_seriation_methods'></span><span id='topic+get_seriation_method'></span><span id='topic+set_seriation_method'></span><span id='topic+print.seriation_method'></span>

<h3>Description</h3>

<p>A registry to manage methods used by <code><a href="#topic+seriate">seriate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registry_seriate

list_seriation_methods(kind, names_only = TRUE)

get_seriation_method(kind, name)

set_seriation_method(
  kind,
  name,
  definition,
  description = NULL,
  control = list(),
  randomized = FALSE,
  optimizes = NA_character_,
  verbose = FALSE,
  ...
)

## S3 method for class 'seriation_method'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registry_for_seriaiton_methods_+3A_kind">kind</code></td>
<td>
<p>the data type the method works on. For example, <code>"dist"</code>,
<code>"matrix"</code> or <code>"array"</code>. If missing, then methods for any type are
shown.</p>
</td></tr>
<tr><td><code id="registry_for_seriaiton_methods_+3A_names_only">names_only</code></td>
<td>
<p>logical; return only the method name. <code>FALSE</code> returns
also the method descriptions.</p>
</td></tr>
<tr><td><code id="registry_for_seriaiton_methods_+3A_name">name</code></td>
<td>
<p>the name for the method used to refer to the method in
<code><a href="#topic+seriate">seriate()</a></code>.</p>
</td></tr>
<tr><td><code id="registry_for_seriaiton_methods_+3A_definition">definition</code></td>
<td>
<p>a function containing the method's code.</p>
</td></tr>
<tr><td><code id="registry_for_seriaiton_methods_+3A_description">description</code></td>
<td>
<p>a description of the method. For example, a long name.</p>
</td></tr>
<tr><td><code id="registry_for_seriaiton_methods_+3A_control">control</code></td>
<td>
<p>a list with control arguments and default values.</p>
</td></tr>
<tr><td><code id="registry_for_seriaiton_methods_+3A_randomized">randomized</code></td>
<td>
<p>logical; does the algorithm use randomization and re-running
the algorithm several times will lead to different results (see: <code><a href="#topic+seriate_rep">seriate_rep()</a></code>).</p>
</td></tr>
<tr><td><code id="registry_for_seriaiton_methods_+3A_optimizes">optimizes</code></td>
<td>
<p>what criterion does the algorithm try to optimize
(see: <code><a href="#topic+list_criterion_methods">list_criterion_methods()</a></code>).</p>
</td></tr>
<tr><td><code id="registry_for_seriaiton_methods_+3A_verbose">verbose</code></td>
<td>
<p>logical; print a message when a new method is registered.</p>
</td></tr>
<tr><td><code id="registry_for_seriaiton_methods_+3A_...">...</code></td>
<td>
<p>further information that is stored for the method in the
registry.</p>
</td></tr>
<tr><td><code id="registry_for_seriaiton_methods_+3A_x">x</code></td>
<td>
<p>an object of class  &quot;seriation_method&quot; to be printed.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>seriation_registry</code> (inherits from <code>registry</code>) of length 57.
</p>


<h3>Details</h3>

<p>The functions below are convenience function for the registry
<code>registry_seriate</code>.
</p>
<p><code>list_seriation_method()</code> lists all available methods for a given data
type (<code>kind</code>) (e.g., &quot;dist&quot;, &quot;matrix&quot;).
The result is a vector of character strings with the
method names that can be used in function <code>seriate()</code>.
If <code>kind</code> is missing, then a list of
methods is returned.
</p>
<p><code>get_seriation_method()</code> returns detailed information for a given method in
form of an object of class <code>"seriation_method"</code>.
The information includes a description, parameters and the
implementing function.
</p>
<p>With <code>set_seriation_method()</code> new seriation methods can be added by the
user. The implementing function (<code>definition</code>) needs to have the formal
arguments <code>x, control</code> and, for arrays and matrices <code>margin</code>,
where <code>x</code> is the data object and
<code>control</code> contains a list with additional information for the method
passed on from <code>seriate()</code>, and <code>margin</code> is a vector specifying
what dimensions should be seriated.
The implementation has to return a list of
objects which can be coerced into <code>ser_permutation_vector</code> objects
(e.g., integer vectors). The elements in the list have to be in
corresponding order to the dimensions of <code>x</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>list_seriation_method()</code> result is a vector of character strings with the
names of the methods. These names are used for methods in <code>seriate()</code>.
</p>
</li>
<li> <p><code>get_seriation_method()</code> returns a given method in form of an object of class
<code>"seriation_method"</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>This registry uses <code><a href="registry.html#topic+registry">registry()</a></code> in package <span class="pkg">registry</span>.
</p>
<p>Other seriation: 
<code><a href="#topic+register_DendSer">register_DendSer</a>()</code>,
<code><a href="#topic+register_GA">register_GA</a>()</code>,
<code><a href="#topic+register_optics">register_optics</a>()</code>,
<code><a href="#topic+register_smacof">register_smacof</a>()</code>,
<code><a href="#topic+register_tsne">register_tsne</a>()</code>,
<code><a href="#topic+register_umap">register_umap</a>()</code>,
<code><a href="#topic+seriate_best">seriate_best</a>()</code>,
<code><a href="#topic+seriate">seriate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Registry
registry_seriate

# List all seriation methods by type
list_seriation_methods()

# List methods for matrix seriation
list_seriation_methods("matrix")

get_seriation_method(name = "BEA")

# Example for defining a new seriation method (reverse identity function for matrix)

# 1. Create the seriation method
#    (with margin since it is for arrays; NA means no seriation is applied)
seriation_method_reverse &lt;- function(x, control = NULL,
                                     margin = seq_along(dim(x))) {
 lapply(seq_along(dim(x)), function(i)
   if (i %in% margin) rev(seq(dim(x)[i]))
   else NA)
}

# 2. Register new method
set_seriation_method("matrix", "Reverse", seriation_method_reverse,
    description = "Reverse identity order", control = list())

list_seriation_methods("matrix")
get_seriation_method("matrix", "reverse")

# 3. Use the new seriation methods
seriate(matrix(1:12, ncol=3), "reverse")
</code></pre>

<hr>
<h2 id='reorder.hclust'>Reorder Dendrograms using Optimal Leaf Ordering</h2><span id='topic+reorder.hclust'></span><span id='topic+reorder'></span>

<h3>Description</h3>

<p>Reorder method for dendrograms for optimal leaf ordering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hclust'
reorder(x, dist, method = "OLO", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder.hclust_+3A_x">x</code></td>
<td>
<p>an object of class <code>hclust</code>.</p>
</td></tr>
<tr><td><code id="reorder.hclust_+3A_dist">dist</code></td>
<td>
<p>an object of class <code>dist</code> with dissimilarities between the
objects in <code>x</code>.</p>
</td></tr>
<tr><td><code id="reorder.hclust_+3A_method">method</code></td>
<td>
<p>a character string with the name of the used measure.
Available are:
</p>

<ul>
<li> <p><code>"OLO"</code> (optimal leaf ordering; Bar-Joseph et al., 2001) implemented in this package and
</p>
</li>
<li> <p><code>"GW"</code> (Gruvaeus and Wainer, 1972) from package <span class="pkg">gclus</span>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="reorder.hclust_+3A_...">...</code></td>
<td>
<p>further arguments are currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimizes the distance between neighboring objects (leaf nodes) in the
dendrogram by flipping the order of subtrees. The algorithm by Gruvaeus and
Wainer is implemented in package <span class="pkg">gclus</span> (Hurley 2004).
</p>


<h3>Value</h3>

<p>A reordered <code>hclust</code> object.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Bar-Joseph, Z., E. D. Demaine, D. K. Gifford, and T. Jaakkola.
(2001): Fast Optimal Leaf Ordering for Hierarchical Clustering.
<em>Bioinformatics,</em> <b>17</b>(1), 22&ndash;29.
</p>
<p>Gruvaeus, G. and Wainer, H. (1972): Two Additions to Hierarchical Cluster
Analysis, <em>British Journal of Mathematical and Statistical Psychology,</em>
<b>25</b>, 200&ndash;206.
</p>
<p>Hurley, Catherine B. (2004): Clustering Visualizations of Multidimensional
Data. <em>Journal of Computational and Graphical Statistics,</em>
<b>13</b>(4), 788&ndash;806.
</p>


<h3>See Also</h3>

<p><code><a href="gclus.html#topic+hclust">gclus::reorder.hclust()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## cluster European cities by distance
data("eurodist")
d &lt;- as.dist(eurodist)
hc &lt;- hclust(eurodist)

## plot original dendrogram and the reordered dendrograms
plot(hc)
plot(reorder(hc, d, method = "GW"))
plot(reorder(hc, d, method = "OLO"))
</code></pre>

<hr>
<h2 id='ser_dist'>Dissimilarities and Correlations Between Seriation Orders</h2><span id='topic+ser_dist'></span><span id='topic+ser_cor'></span><span id='topic+ser_align'></span>

<h3>Description</h3>

<p>Calculates dissimilarities/correlations between seriation orders in a list of type
<a href="#topic+ser_permutation_vector">ser_permutation_vector</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ser_dist(x, y = NULL, method = "spearman", reverse = TRUE, ...)

ser_cor(x, y = NULL, method = "spearman", reverse = TRUE, test = FALSE)

ser_align(x, method = "spearman")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ser_dist_+3A_x">x</code></td>
<td>
<p>set of seriation orders as a list with elements which can be
coerced into <a href="#topic+ser_permutation_vector">ser_permutation_vector</a> objects.</p>
</td></tr>
<tr><td><code id="ser_dist_+3A_y">y</code></td>
<td>
<p>if not <code>NULL</code> then a single seriation order can be specified.
In this case <code>x</code> has to be a single seriation order and not a list.</p>
</td></tr>
<tr><td><code id="ser_dist_+3A_method">method</code></td>
<td>
<p>a character string with the name of the used measure.
Available measures are: <code>"kendall"</code>, <code>"spearman"</code>,
<code>"manhattan"</code>, <code>"euclidean"</code>, <code>"hamming"</code>, <code>"ppc"</code>
(positional proximity coefficient), and <code>"aprd"</code> (absolute pairwise
rank differences).</p>
</td></tr>
<tr><td><code id="ser_dist_+3A_reverse">reverse</code></td>
<td>
<p>a logical indicating if the orders should also be checked in
reverse order and the best value (highest correlation, lowest distance) is
reported. This only affect ranking-based measures and not precedence
invariant measures (e.g., ppc, aprd).</p>
</td></tr>
<tr><td><code id="ser_dist_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to the method.</p>
</td></tr>
<tr><td><code id="ser_dist_+3A_test">test</code></td>
<td>
<p>a logical indicating if a correlation test should be performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ser_cor()</code> calculates the correlation between two sequences (orders).
Note that a seriation order and its reverse are identical and purely an
artifact due to the method that creates the order. This is a major
difference to rankings. For ranking-based correlation measures (Spearman and
Kendall) the absolute value of the correlation is returned for
<code>reverse = TRUE</code> (in effect returning the correlation for the reversed order). If
<code>test = TRUE</code> then the appropriate test for association is performed
and a matrix with p-values is returned as the attribute <code>"p-value"</code>.
Note that no correction for multiple testing is performed.
</p>
<p>For <code>ser_dist()</code>, the correlation coefficients (Kendall's tau and
Spearman's rho) are converted into a dissimilarity by taking one minus the
correlation value. Note that Manhattan distance between the ranks in a
linear order is equivalent to Spearman's footrule metric (Diaconis 1988).
<code>reverse = TRUE</code> returns the pairwise minima using also reversed
orders.
</p>
<p>The positional proximity coefficient (ppc) is a precedence invariant measure
based on product of the squared positional distances in two permutations
defined as (see Goulermas et al 2016):
</p>
<p style="text-align: center;"><code class="reqn">d_{ppc}(R, S) = 1/h \sum_{j=2}^n \sum_{i=1}^{j-1}
(\pi_R(i)-\pi_R(j))^2 * (\pi_S(i)-\pi_S(j))^2,</code>
</p>

<p>where <code class="reqn">R</code> and <code class="reqn">S</code> are two seriation orders, <code class="reqn">pi_R</code> and
<code class="reqn">pi_S</code> are the associated permutation vectors and <code class="reqn">h</code> is a
normalization factor. The associated generalized correlation coefficient is
defined as <code class="reqn">1-d_{ppc}</code>. For this precedence invariant measure
<code>reverse</code> is ignored.
</p>
<p>The absolute pairwise rank difference (aprd) is also precedence invariant
and defined as a distance measure:
</p>
<p style="text-align: center;"><code class="reqn">d_{aprd}(R, S) = \sum_{j=2}^n \sum_{i=1}^{j-1} | |\pi_R(i)-\pi_R(j)| -
|\pi_S(i)-\pi_S(j)| |^p,</code>
</p>

<p>where <code class="reqn">p</code> is the power which can be passed on as parameter <code>p</code> and
is by default set to 2. For this precedence invariant measure <code>reverse</code>
is ignored.
</p>
<p><code>ser_align()</code> tries to normalize the direction in a list of seriations
such that ranking-based methods can be used. We add for each permutation
also the reversed order to the set and then use a modified version of Prim's
algorithm for finding a minimum spanning tree (MST) to choose if the
original seriation order or its reverse should be used. We use the orders
first added to the MST. Every time an order is added, its reverse is removed
from the possible remaining orders.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>ser_dist()</code> returns an object of class <a href="stats.html#topic+dist">dist</a>.
</p>
</li>
<li> <p><code>ser_align()</code> returns a new list with elements of class
<a href="#topic+ser_permutation">ser_permutation</a>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>P. Diaconis (1988): Group Representations in Probability and
Statistics. Institute of Mathematical Statistics, Hayward, CA.
</p>
<p>J.Y. Goulermas, A. Kostopoulos, and T. Mu (2016): A New Measure for
Analyzing and Fusing Sequences of Objects. <em>IEEE Transactions on
Pattern Analysis and Machine Intelligence</em> <strong>38</strong>(5):833-48.
<a href="https://doi.org/10.1109/TPAMI.2015.2470671">doi:10.1109/TPAMI.2015.2470671</a>
</p>


<h3>See Also</h3>

<p>Other permutation: 
<code><a href="#topic+get_order">get_order</a>()</code>,
<code><a href="#topic+permutation_vector2matrix">permutation_vector2matrix</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+ser_permutation_vector">ser_permutation_vector</a>()</code>,
<code><a href="#topic+ser_permutation">ser_permutation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
## seriate dist of 50 flowers from the iris data set
data("iris")
x &lt;- as.matrix(iris[-5])
x &lt;- x[sample(1:nrow(x), 50), ]
rownames(x) &lt;- 1:50
d &lt;- dist(x)

## Create a list of different seriations
methods &lt;- c("HC_single", "HC_complete", "OLO", "GW", "R2E", "VAT",
  "TSP", "Spectral", "SPIN", "MDS", "Identity", "Random")

os &lt;- sapply(methods, function(m) {
  cat("Doing", m, "... ")
  tm &lt;- system.time(o &lt;- seriate(d, method = m))
  cat("took", tm[3],"s.\n")
  o
})

## Compare the methods using distances. Default is based on
## Spearman's rank correlation coefficient where reverse orders are
## also considered.
ds &lt;- ser_dist(os)
hmap(ds, margin = c(7,7))

## Compare using correlation between orders. Reversed orders have
## negative correlation!
cs &lt;- ser_cor(os, reverse = FALSE)
hmap(cs, margin = c(7,7))

## Compare orders by allowing orders to be reversed.
## Now all but random and identity are highly positive correlated
cs2 &lt;- ser_cor(os, reverse = TRUE)
hmap(cs2, margin=c(7,7))

## A better approach is to align the direction of the orders first
## and then calculate correlation.
os_aligned &lt;- ser_align(os)
cs3 &lt;- ser_cor(os_aligned, reverse = FALSE)
hmap(cs3, margin = c(7,7))

## Compare the orders using clustering. We use Spearman's foot rule
## (Manhattan distance of ranks). In order to use rank-based method,
## we align the direction of the orders.
os_aligned &lt;- ser_align(os)
ds &lt;- ser_dist(os_aligned, method = "manhattan")
plot(hclust(ds))
</code></pre>

<hr>
<h2 id='ser_permutation'>Class ser_permutation &ndash; A Collection of Permutation Vectors for Seriation</h2><span id='topic+ser_permutation'></span><span id='topic+print.ser_permutation'></span><span id='topic+summary.ser_permutation'></span><span id='topic+c.ser_permutation'></span><span id='topic++5B.ser_permutation'></span>

<h3>Description</h3>

<p>The class <code>ser_permutation</code> is a collection of permutation vectors
(see class <a href="#topic+ser_permutation_vector">ser_permutation_vector</a>), one for each dimension (mode)
of the data to be permuted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ser_permutation(x, ...)

## S3 method for class 'ser_permutation'
print(x, ...)

## S3 method for class 'ser_permutation'
summary(object, ...)

## S3 method for class 'ser_permutation'
c(..., recursive = FALSE)

## S3 method for class 'ser_permutation'
object[i, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ser_permutation_+3A_x">x</code>, <code id="ser_permutation_+3A_object">object</code></td>
<td>
<p>an object of class <code>ser_permutation_vector</code> or
any object which can be converted into
a object of class <code>ser_permutation</code> (e.g. an integer
vector).</p>
</td></tr>
<tr><td><code id="ser_permutation_+3A_...">...</code></td>
<td>
<p>vectors for further dimensions.</p>
</td></tr>
<tr><td><code id="ser_permutation_+3A_recursive">recursive</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="ser_permutation_+3A_i">i</code></td>
<td>
<p>index of the dimension(s) to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ser_permutation</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other permutation: 
<code><a href="#topic+get_order">get_order</a>()</code>,
<code><a href="#topic+permutation_vector2matrix">permutation_vector2matrix</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+ser_dist">ser_dist</a>()</code>,
<code><a href="#topic+ser_permutation_vector">ser_permutation_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o &lt;- ser_permutation(1:5, 10:1)
o

## length (number of dimensions)
length(o)

## get permutation vector for 2nd dimension
get_order(o, 2)

## reverse dimensions
o[2:1]

## combine
o &lt;- c(o, ser_permutation(1:15))
o

## get an individual permutation
o[[2]]

## reverse the order of a permutation
o[[2]] &lt;- rev(o[[2]])
get_order(o,2)
</code></pre>

<hr>
<h2 id='ser_permutation_vector'>Class ser_permutation_vector &ndash; A Single Permutation Vector for Seriation</h2><span id='topic+ser_permutation_vector'></span><span id='topic+c.ser_permutation_vector'></span><span id='topic+rev.ser_permutation_vector'></span><span id='topic+get_method'></span><span id='topic+length.ser_permutation_vector'></span><span id='topic+print.ser_permutation_vector'></span><span id='topic+summary.ser_permutation_vector'></span>

<h3>Description</h3>

<p>The class <code>ser_permutation_vector</code>
represents a single permutation vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ser_permutation_vector(x, method = NULL)

## S3 method for class 'ser_permutation_vector'
c(..., recursive = FALSE)

## S3 method for class 'ser_permutation_vector'
rev(x)

get_method(x, printable = FALSE)

## S3 method for class 'ser_permutation_vector'
length(x)

## S3 method for class 'ser_permutation_vector'
print(x, ...)

## S3 method for class 'ser_permutation_vector'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ser_permutation_vector_+3A_x">x</code>, <code id="ser_permutation_vector_+3A_object">object</code></td>
<td>
<p>an object if class  <code>ser_permutation_vector</code>.
Options for the constructor are:
(1) an integer permutation vector,
(2) an object of class <a href="stats.html#topic+hclust">hclust</a>,
(3) a numeric vector with a MDS configuration, or
(4) <code>NA</code> to indicate a identity permutation.</p>
</td></tr>
<tr><td><code id="ser_permutation_vector_+3A_method">method</code></td>
<td>
<p>a string representing the method used to obtain the
permutation vector.</p>
</td></tr>
<tr><td><code id="ser_permutation_vector_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="ser_permutation_vector_+3A_recursive">recursive</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="ser_permutation_vector_+3A_printable">printable</code></td>
<td>
<p>a logical; prints &quot;unknown&quot; instead of <code>NULL</code> for non-existing methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A permutation vector
maps a set of <code class="reqn">n</code> objects <code class="reqn">\{O_1, O_2, ..., O_n\}</code> onto itself.
</p>
<p><strong>Ordering Representation:</strong>
In <span class="pkg">seriation</span> we represent a permutation <code class="reqn">\pi</code>
as a vector which lists the objects' indices in their permuted order. This can
be seen as replacing the object in position <code class="reqn">i</code> with the object
in position <code class="reqn">\pi(i)</code>.
For example, the permutation vector <code class="reqn">\langle3, 1, 2\rangle</code> indicates that in
first position is the object with index 3 then the object with index 1 and finally
the object with index 2. This representation is often called a (re)arrangement or ordering.
The ordering can be extracted from a permutation vector object
via <code><a href="#topic+get_order">get_order()</a></code>. Such an ordering can be directly used
to subset the list of original objects with <code>"["</code> to apply the permutation.
</p>
<p><strong>Rank Representation:</strong>
An alternative way to specify a permutation is via a list of the ranks
of the objects after permutation. This representation is often called
a map or substitution. Ranks can be extracted from a permutation vector using <code><a href="#topic+get_rank">get_rank()</a></code>.
</p>
<p><strong>Permutation Matrix:</strong>
Another popular representation is a permutation matrix which performs
permutations using matrix multiplication. A permutation matrix can be obtained
using <code><a href="#topic+get_permutation_matrix">get_permutation_matrix()</a></code>.
</p>
<p><code>ser_permutation_vector</code> objects are usually packed into
a <a href="#topic+ser_permutation">ser_permutation</a> object
which is a collection (a <code>list</code>) of <code class="reqn">k</code> permutation vectors for <code class="reqn">k</code>-mode data.
</p>
<p>The constructor <code>ser_permutation_vector()</code>
checks if the permutation vector is valid
(i.e. if all integers occur exactly once).
</p>


<h3>Value</h3>

<p>The constructor <code>ser_permutation_vector()</code> returns an
object a <code>ser_permutation_vector</code>
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other permutation: 
<code><a href="#topic+get_order">get_order</a>()</code>,
<code><a href="#topic+permutation_vector2matrix">permutation_vector2matrix</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+ser_dist">ser_dist</a>()</code>,
<code><a href="#topic+ser_permutation">ser_permutation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o &lt;- structure(sample(10), names = paste0("X", 1:10))
o

p &lt;- ser_permutation_vector(o, "random")
p

## some methods
length(p)
get_method(p)
get_order(p)
get_rank(p)
get_permutation_matrix(p)

r &lt;- rev(p)
r
get_order(r)

## create a symbolic identity permutation vector (with unknown length)
## Note: This can be used to permute an object, but methods
##       like length and get_order are not available.
ip &lt;- ser_permutation_vector(NA)
ip
</code></pre>

<hr>
<h2 id='seriate'>Seriate Dissimilarity Matrices, Matrices or Arrays</h2><span id='topic+seriate'></span><span id='topic+seriate.dist'></span><span id='topic+seriate.matrix'></span><span id='topic+seriate.array'></span><span id='topic+seriate.data.frame'></span><span id='topic+seriate.table'></span>

<h3>Description</h3>

<p>Tries to find a linear order for objects using data in the form of a
dissimilarity matrix (two-way one-mode data), a data matrix (two-way
two-mode data), or a data array (k-way k-mode data). The order can then be
used to reorder the dissimilarity matrix/data matrix using
<code><a href="#topic+permute">permute()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriate(x, ...)

## S3 method for class 'dist'
seriate(x, method = "Spectral", control = NULL, rep = 1L, ...)

## S3 method for class 'matrix'
seriate(x, method = "PCA", control = NULL, margin = c(1L, 2L), rep = 1L, ...)

## S3 method for class 'array'
seriate(
  x,
  method = "PCA",
  control = NULL,
  margin = seq(length(dim(x))),
  rep = 1L,
  ...
)

## S3 method for class 'data.frame'
seriate(
  x,
  method = "Heatmap",
  control = NULL,
  margin = c(1L, 2L),
  rep = 1L,
  ...
)

## S3 method for class 'table'
seriate(x, method = "CA", control = NULL, margin = c(1L, 2L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriate_+3A_x">x</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code id="seriate_+3A_...">...</code></td>
<td>
<p>further arguments are added to the <code>control</code> list.</p>
</td></tr>
<tr><td><code id="seriate_+3A_method">method</code></td>
<td>
<p>a character string with the name of the seriation method
(default: varies by data type).</p>
</td></tr>
<tr><td><code id="seriate_+3A_control">control</code></td>
<td>
<p>a list of control options passed on to the seriation
algorithm.</p>
</td></tr>
<tr><td><code id="seriate_+3A_rep">rep</code></td>
<td>
<p>number of random restarts for randomized methods.
Uses <code><a href="#topic+seriate_rep">seriate_rep()</a></code>.</p>
</td></tr>
<tr><td><code id="seriate_+3A_margin">margin</code></td>
<td>
<p>an integer vector giving the margin indices (dimensions) to be
seriated. For example, for a matrix, <code>1</code> indicates rows, <code>2</code>
indicates columns, <code>c(1 ,2)</code> means rows and columns.
Unseriated margins return the identity seriation order for that margin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Seriation methods are managed via a registry. See
<code><a href="#topic+list_seriation_methods">list_seriation_methods()</a></code> for help. In the following, we focus on
discussing the
built-in methods that are registered automatically by the package <span class="pkg">seriation</span>.
</p>
<p>The available control options, default settings, and
a description for each algorithm
can be retrieved using <code>get_seriation_method(name = "&lt;seriation method&gt;")</code>.
Some control parameters are also described in more detail below.
</p>
<p>Some methods are very slow, and progress can be printed using the control
parameter <code>verbose = TRUE</code>.
</p>
<p>Many seriation methods (heuristically) optimize (minimize or maximize) an
objective function often called seriation criterion.
The value of the seriation criterion for a given order can be
calculated using <code><a href="#topic+criterion">criterion()</a></code>. In this manual page, we
include the criterion, which is optimized by each method using <strong>bold font</strong>.
If no criterion is mentioned, then the method does not directly optimize a criterion.
A definition of the different seriation criteria can be found on the <code><a href="#topic+criterion">criterion()</a></code> manual page.
</p>
<p><strong>Seriation methods for distance matrices (dist)</strong>
</p>
<p>One-mode two-way data must be provided as a dist object (not
a symmetric matrix). Similarities have to be transformed into
dissimilarities.
Seriation algorithms fall into different groups based on the approach.
In the following, we describe the currently implemented methods.
A list with all methods and the available parameters is available
<a href="https://mhahsler.github.io/seriation/seriation_methods.html">here</a>.
<a href="https://michael.hahsler.net/research/paper/EJOR_seriation_2016.pdf">Hahsler (2017)</a>
for a more detailed description and an experimental comparison of the most
popular methods.
</p>
<p><strong>Dendrogram leaf order</strong>
</p>
<p>These methods create a dendrogram using hierarchical clustering and then derive
the seriation order from the leaf order in the dendrogram. Leaf reordering
may be applied.
</p>

<ul>
<li> <p><strong>Hierarchical clustering:</strong> <code>"HC"</code>, <code>"HC_single"</code>, <code>"HC_complete"</code>,
<code>"HC_average"</code>, <code>"HC_ward"</code>
</p>
<p>Uses the order of the leaf nodes in a dendrogram obtained by hierarchical
clustering as a simple seriation technique. This method
applies hierarchical clustering (<code><a href="stats.html#topic+hclust">hclust()</a></code>) to <code>x</code>. The clustering
method can be given using a <code>"linkage"</code> element in the <code>control</code>
list. If omitted, the default <code>"complete"</code> is used.
For convenience, the other methods are provided as shortcuts.
</p>
</li>
<li> <p><strong>Reordered by the Gruvaeus and Wainer heuristic:</strong> <code>"GW"</code>, <code>"GW_single"</code>, <code>"GW_average"</code>,
<code>"GW_complete"</code>, <code>"GW_ward"</code>  (Gruvaeus and Wainer, 1972)
</p>
<p>Method <code>"GW"</code> uses an algorithm developed by Gruvaeus and Wainer (1972)
as implemented <code><a href="gclus.html#topic+hclust">gclus::reorder.hclust()</a></code> (Hurley 2004).  The clusters are
ordered at each level so that the objects at the edge of each cluster are
adjacent to the nearest object outside the cluster. The
method produces a unique order.
</p>
<p>The methods start with a dendrogram created by <code><a href="stats.html#topic+hclust">hclust()</a></code>. As the
<code>"linkage"</code> element in the <code>control</code> list, a clustering method
(default <code>"average"</code>) can be specified. Alternatively, an <a href="stats.html#topic+hclust">hclust</a>
object can be supplied using an element named <code>"hclust"</code>.
</p>
<p>A dendrogram (binary tree) has <code class="reqn">2^{n-1}</code> internal nodes (subtrees) and
the same number of leaf orderings. That is, at each internal node, the left
and right subtree (or leaves) can be swapped or, in terms of a dendrogram,
be flipped. The leaf-node reordering to minimize
</p>
<p>Minimizes the <strong>Hamiltonian path length (restricted by the dendrogram)</strong>.
</p>
</li>
<li> <p><strong>Reordered by optimal leaf ordering:</strong> <code>"OLO"</code>, <code>"OLO_single"</code>,
<code>"OLO_average"</code>, <code>"OLO_complete"</code>, <code>"OLO_ward"</code>  (Bar-Joseph et al., 2001)
</p>
<p>Starts with a dendrogram and
produces an optimal leaf ordering that minimizes the sum of
the distances along the (Hamiltonian) path connecting the leaves in the
given order. The algorithm's time complexity is <code class="reqn">O(n^3)</code>. Note that
non-finite distance values are not allowed.
</p>
<p>Minimizes the <strong>Hamiltonian path length (restricted by the dendrogram)</strong>.
</p>
</li>
<li> <p><strong>Dendrogram seriation:</strong> <code>"DendSer"</code> (Earle and Hurley, 2015)
</p>
<p>Use heuristic dendrogram seriation to optimize for various criteria.
The DendSer code has to be first registered. A
detailed description can be found on the manual page for
<code><a href="#topic+register_DendSer">register_DendSer()</a></code>.
</p>
</li></ul>

<p><strong>Dimensionality reduction</strong>
</p>
<p>Find a seriation order by reducing the dimensionality to 1 dimension. This is typically
done by minimizing a stress measure or the reconstruction error.
Note that dimensionality reduction to a single dimension is a very
difficult discrete optimization problem.
For example, MDS algorithms used for a single dimension
tend to end up in local optima (see Maier and De Leeuw, 2015).
However, generally, ordering along a single component of MDS provides good results
sufficient for applications like visualization.
</p>

<ul>
<li> <p><strong>Classical metric multidimensional scaling:</strong> <code>"MDS"</code>
</p>
<p>Orders along the 1D classical metric multidimensional scaling.
<code>control</code> parameters are passed on to <code><a href="stats.html#topic+cmdscale">stats::cmdscale()</a></code>.
</p>
</li>
<li> <p><strong>Isometric feature mapping:</strong> <code>"isomap"</code> (Tenenbaum, 2000)
</p>
<p>Orders along the 1D isometric feature mapping.
<code>control</code> parameters are passed on to <code><a href="vegan.html#topic+isomap">vegan::isomap()</a></code>
</p>
</li>
<li> <p><strong>Kruskal's non-metric multidimensional scaling:</strong> <code>"isoMDS"</code>, <code>"monoMDS"</code>,
<code>"metaMDS"</code> (Kruskal, 1964)
</p>
<p>Orders along the 1D Kruskal's non-metric multidimensional scaling.
Package <code>vegan</code> implements an alternative implementation called <code>monoMDS</code>
and a version that uses random restarts for stability called <code>metaMDS</code>.
<code>control</code> parameters are passed on to <code><a href="MASS.html#topic+isoMDS">MASS::isoMDS()</a></code>, <code><a href="vegan.html#topic+monoMDS">vegan::monoMDS()</a></code> or <code><a href="vegan.html#topic+metaMDS">vegan::metaMDS()</a></code>.
</p>
</li>
<li> <p><strong>Sammon's non-linear mapping:</strong> <code>"Sammon_mapping"</code> (Sammon, 1969)
</p>
<p>Orders along the 1D Sammon's non-linear mapping.
<code>control</code> parameters are passed on to <code><a href="MASS.html#topic+sammon">MASS::sammon()</a></code>.
</p>
</li>
<li> <p><strong>Angular order of the first two eigenvectors:</strong> <code>"MDS_angle"</code>
</p>
<p>Finds a 2D configuration using MDS (<code><a href="stats.html#topic+cmdscale">cmdscale()</a></code>)
to approximate the eigenvectors of the covariance matrix in the
original data matrix.
Orders by the angle in this space and splits the order by the
larges gap between adjacent angles. A similar method was used by
Friendly (2002) to order variables in correlation matrices
by angles of first two eigenvectors.
</p>
</li>
<li> <p><strong>Smacof:</strong> <code>"MDS_smacof"</code> (de Leeuw and Mair, 2009)
</p>
<p>Perform seriation using stress majorization with several transformation functions.
This method has to be registered first using <code><a href="#topic+register_smacof">register_smacof()</a></code>.
</p>
</li></ul>

<p><strong>Optimization</strong>
</p>
<p>These methods try to optimize a seriation criterion directly, typically using a
heuristic approach.
</p>

<ul>
<li> <p><strong>Anti-Robinson seriation by simulated annealing:</strong> <code>"ARSA"</code> (Brusco et al 2008)
</p>
<p>The algorithm automatically finds a suitable start temperature and calculates
the needed number of iterations. The algorithm gets slow for a large number of
objects. The speed can be improved by lowering the cooling parameter <code>"cool"</code>
or increasing the minimum temperature <code>"tmin"</code>.
However, this will decrease the seriation quality.
</p>
<p>Directly minimizes the <strong>linear seriation criterion (LS).</strong>
</p>
</li>
<li> <p><strong>Complete Enumeration:</strong> <code>"Enumerate"</code>
</p>
<p>This method finds the optimal permutation given a seriation criterion by complete enumeration
of all permutations.
The criterion is specified as the <code>control</code> parameters <code>"criterion"</code>.
Default is the weighted gradient measure. Use <code>"verbose = TRUE"</code> to see
the progress.
</p>
<p>Note: The number of permutations for <code class="reqn">n</code> objects is <code class="reqn">n!</code>.
Complete enumeration is only possible for tiny problems (&lt;10 objects) and is limited on most systems
to a problem size of up to 12 objects.
</p>
</li>
<li> <p><strong>Gradient measure seriation by branch-and-bound:</strong> <code>"BBURCG"</code>, <code>"BBWRCG"</code> (Brusco and Stahl 2005)
</p>
<p>The method uses branch-and-bound to minimize the
<strong>unweighted gradient measure</strong> (<code>"BBURCG"</code>) and the
<strong>weighted gradient measure</strong> (<code>"BBWRCG"</code>).
This type of optimization is only feasible for a small number of objects (&lt; 50 objects).
</p>
<p>For BBURCG, the control parameter <code>"eps"</code> can be used to relax the problem by defining
that a distance needs to be eps larger to count as a violation. This relaxation will improve the speed,
but miss some Robinson events. The default value is 0.
</p>
</li>
<li> <p><strong>Genetic Algorithm:</strong> <code>"GA"</code>
</p>
<p>The GA code has to be first registered. A detailed description can
be found on the manual page for <code><a href="#topic+register_GA">register_GA()</a></code>.
</p>
</li>
<li> <p><strong>Quadratic assignment problem seriation:</strong>
<code>"QAP_LS"</code>, <code>"QAP_2SUM"</code>, <code>"QAP_BAR"</code>, <code>"QAP_Inertia"</code> (Hahsler, 2017)
</p>
<p>Formulates the seriation problem as a quadratic assignment problem and applies a
simulated annealing solver to find a good solution.
These methods minimize the
<strong>Linear Seriation Problem</strong> (LS) formulation (Hubert and Schultz 1976),
the <strong>2-Sum Problem</strong> formulation (Barnard, Pothen, and Simon 1993), the
<strong>banded anti-Robinson form</strong> (BAR), or the <strong>inertia criterion</strong>.
</p>
<p><code>control</code> parameters are passed on to <code><a href="qap.html#topic+qap">qap::qap()</a></code>.
An important parameter is <code>rep</code> to return the best result from the
given number of repetitions with random restarts. The default is 1, but bigger
numbers result in better and more stable results.
</p>
</li>
<li> <p><strong>General Simulated Annealing:</strong> <code>"GSA"</code>
</p>
<p>Implement simulated annealing similar to the ARSA method. However, it
can optimize
for any criterion measure defined in <span class="pkg">seriation</span>. By default, the
algorithm optimizes for the raw gradient measure, and is warm started with the
result of spectral seriation (2-Sum problem) since Hahsler (2017) shows that
2-Sum solutions are similar to solutions for the gradient measure.
Use <code>warmstart = "random"</code> for no warm start.
</p>
<p>The initial temperature <code>t0</code> and minimum temperature <code>tmin</code> can be set. If
<code>t0</code> is not set, then it is estimated by sampling uphill moves and setting
<code>t0</code> such that the median uphill move have a probability
of <code>tinitialaccept</code>.
Using the cooling rate <code>cool</code>, the number of iterations
to go for <code>t0</code> to <code>tmin</code> is calculated.
</p>
<p>Several popular local neighborhood functions are
provided, and new ones can be defined (see <a href="#topic+LS">LS</a>). Local moves are tried in each
iteration <code>nlocal</code> times the number of objects.
</p>
<p>Note that this is an R implementation repeatedly calling the criterion funciton
which is very slow.
</p>
</li>
<li> <p><strong>Stochastic gradient descent:</strong> <code>"SGD"</code>
</p>
<p>Starts with a solution and then performs stochastic gradient descent to find
a close-by local optimum given a specified criterion.
</p>
<p>Important <code>control</code> parameters:
</p>

<ul>
<li> <p><code>"criterion"</code>: the criterion to optimize
</p>
</li>
<li> <p><code>"init"</code>: initial seriation (an order or the name of a seriation method)
</p>
</li>
<li> <p><code>"max_iter"</code>: number of trials
</p>
</li></ul>

</li>
<li> <p><strong>Spectral seriation:</strong> <code>"Spectral"</code>, <code>"Spectral_norm"</code>  (Ding and He, 2004)
</p>
<p>Spectral seriation uses a relaxation to minimize the <strong>2-Sum Problem</strong>
(Barnard, Pothen, and Simon, 1993). It uses the order of the Fiedler vector
of the similarity matrix's (normalized) Laplacian.
</p>
<p>Spectral seriation gives a good trade-off between seriation quality,
and scalability (see Hahsler, 2017).
</p>
</li>
<li> <p><strong>Traveling salesperson problem solver:</strong> <code>"TSP"</code>
</p>
<p>Uses a traveling salesperson problem solver to minimize the
<strong>Hamiltonian path length</strong>. The solvers in <span class="pkg">TSP</span> are used (see
<code><a href="TSP.html#topic+solve_TSP">TSP::solve_TSP()</a></code>). The solver method can be passed on via the <code>control</code>
argument, e.g., <code>control = list(method = "two_opt")</code>. Default is the est
of 10 runs of arbitrary insertion heuristic with 2-opt improvement.
</p>
<p>Since a tour returned by a TSP solver is a connected circle and we are
looking for a path representing a linear order, we need to find the best
cutting point.  Climer and Zhang (2006) suggest adding a dummy city with
equal distance to each other city before generating the tour. The place of
this dummy city in an optimal tour with minimal length is the best cutting
point (it lies between the most distant cities).
</p>
</li></ul>

<p><strong>Other Methods</strong>
</p>

<ul>
<li> <p><strong>Identity permutation:</strong> '&quot;Identity&quot;
</p>
</li>
<li> <p><strong>Reverse Identity permutation:</strong> '&quot;Reverse&quot;
</p>
</li>
<li> <p><strong>Random permutation:</strong> <code>"Random"</code>
</p>
</li>
<li> <p><strong>Rank-two ellipse seriation:</strong> <code>"R2E"</code>  (Chen 2002)
</p>
<p>Rank-two ellipse seriation starts with generating a sequence of correlation matrices
<code class="reqn">R^1, R^2, \ldots</code>. <code class="reqn">R^1</code> is the correlation matrix of the original
distance matrix <code class="reqn">D</code> (supplied to the function as <code>x</code>), and
</p>
<p style="text-align: center;"><code class="reqn">R^{n+1} = \phi R^n,</code>
</p>
<p> where <code class="reqn">\phi</code> calculates the correlation
matrix.
</p>
<p>The rank of the matrix <code class="reqn">R^n</code> falls with increasing <code class="reqn">n</code>. The first
<code class="reqn">R^n</code> in the sequence, which has a rank of 2 is found. Projecting all
points in this matrix on the first two eigenvectors, all points fall on an
ellipse. The order of the points on this ellipse is the resulting order.
</p>
<p>The ellipse can be cut at the two interception points (top or bottom) of the
vertical axis with the ellipse. In this implementation, the topmost cutting
point is used.
</p>
</li>
<li> <p><strong>Sorting Points Into Neighborhoods:</strong> <code>"SPIN_STS"</code>, <code>"SPIN_NH"</code> (Tsafrir, 2005)
</p>
<p>Given a weight matrix <code class="reqn">W</code>, the SPIN algorithms try to
minimize the energy for a permutation (matrix <code class="reqn">P</code>) given by </p>
<p style="text-align: center;"><code class="reqn">F(P) =
  tr(PDP^TW),</code>
</p>
<p> where <code class="reqn">tr</code> denotes the matrix trace.
</p>
<p><code>"SPIN_STS"</code> implements the Side-to-Side algorithm, which tries to push
out large distance values. The default weight matrix suggested in the paper
with <code class="reqn">W=XX^T</code> and <code class="reqn">X_i=i-(n+1)/2</code> is used. We run the algorithm form
<code>step</code> (25) iteration and restart the algorithm <code>nstart</code> (10) with
random initial permutations (default values in parentheses).
</p>
<p><code>"SPIN_NH"</code> implements the neighborhood algorithm (concentrate low
distance values around the diagonal) with a Gaussian weight matrix
<code class="reqn">W_{ij} = exp(-(i-j)^2/n\sigma)</code>, where <code class="reqn">n</code> is the size of the
dissimilarity matrix and <code class="reqn">\sigma</code> is the variance around the diagonal
that control the influence of global (large <code class="reqn">\sigma</code>) or local (small
<code class="reqn">\sigma</code>) structure.
</p>
<p>We use the heuristic suggested in the paper for the linear assignment
problem. We do not terminate as indicated in the algorithm but run all the
iterations since the heuristic does not guarantee that the energy is
strictly decreasing. We also implement the heuristic &quot;annealing&quot; scheme
where <code class="reqn">\sigma</code> is successively reduced. The parameters in <code>control</code>
are <code>sigma</code> which can be a single value or a decreasing sequence
(default: 20 to 1 in 10 steps), and <code>step</code>, which defines how many update
steps are performed before for each value of <code>alpha</code>. Via
<code>W_function</code> a custom function to create <code class="reqn">W</code> with the function
signature <code style="white-space: pre;">&#8288;function(n, sigma, verbose)&#8288;</code> can be specified.
</p>
</li>
<li> <p><strong>Visual Assessment of (Clustering) Tendency:</strong> <code>"VAT"</code> (Bezdek and Hathaway, 2002).
</p>
<p>Creates an order based on Prim's algorithm for finding a minimum spanning
tree (MST) in a weighted connected graph representing the distance matrix.
The order is given by the order in which the nodes (objects) are added to
the MST.
</p>
</li></ul>

<p><strong>Seriation methods for matrices (matrix)</strong>
</p>
<p>Two-mode two-way data are general matrices.
Some methods also require that the matrix is positive.
Data frames and contingency tables (<a href="base.html#topic+table">base::table</a>)
are converted into a matrix. However, the
default methods are different.
</p>
<p>Some methods find the row and column order simultaneously,
while others calculate them independently.
Currently, the
following methods are implemented for <code>matrix</code>:
</p>
<p><strong>Seriating rows and columns simultaneously</strong>
</p>
<p>Row and column order influence each other.
</p>

<ul>
<li> <p><strong>Bond Energy Algorithm:</strong> <code>"BEA"</code>  (McCormick, 1972).
</p>
<p>The algorithm tries to maximize a non-negative matrix's
<strong>Measure of Effectiveness.</strong>
Due to the definition of this measure, the tasks of
ordering rows and columns are separable and can be solved independently.
</p>
<p>A row is arbitrarily placed; then, rows are positioned one by one. When this
is completed, the columns are treated similarly. The overall procedure
amounts to two approximate traveling salesperson problems (TSP), one on the
rows and one on the columns. The so-called &lsquo;best insertion strategy&rsquo; is
used: rows (or columns) are inserted into the current permuted list of rows
(or columns). Several consecutive runs of the algorithm might improve the
energy.
</p>
<p>Arabie and Hubert (1990) question its use with non-binary data if
the objective is to find a seriation or one-dimensional orderings of rows
and columns.
</p>
<p>Fionn Murtagh implemented the BEA code used in this package.
</p>
</li>
<li> <p><strong>TSP to optimize the Measure of Effectiveness</strong>: <code>"BEA_TSP"</code> (Lenstra 1974).
</p>
<p>Distances between rows are calculated for a <code class="reqn">M \times N</code> data matrix as
<code class="reqn">d_{jk} = - \sum_{i=1}^{i=M} x_{ij}x_{ik}\ (j,k=0,1,...,N)</code>. Distances
between columns are calculated the same way from the transposed data matrix.
</p>
<p>Solving the two TSP using these distances optimizes the measure of
effectiveness. BEA can be seen as a simple, suboptimal TSP method.
</p>
<p><code>control</code> parameter:
</p>

<ul>
<li> <p><code>"method"</code>: a TSP solver method (see <code><a href="TSP.html#topic+solve_TSP">TSP::solve_TSP()</a></code>).
</p>
</li></ul>

</li>
<li> <p><strong>Correspondence analysis</strong> <code>"CA"</code>
</p>
<p>This function is designed to help simplify a mosaic plot or other displays of a
matrix of frequencies.  It calculates a correspondence analysis of the matrix and
an order for rows and columns according to the scores on a correspondence analysis dimension.
</p>
<p>This is the default method for contingency tables.
</p>
<p><code>control</code> parameters:
</p>

<ul>
<li> <p><code>"dim"</code>: CA dimension used for reordering.
</p>
</li>
<li> <p><code>"ca_param"</code>: List with parameters for the call to <code><a href="ca.html#topic+ca">ca::ca()</a></code>.
</p>
</li></ul>

</li></ul>

<p><strong>Seriating rows and columns separately using dissimilarities</strong>
</p>

<ul>
<li> <p><strong>Heatmap seriation:</strong> <code>"Heatmap"</code>
</p>
<p>Calculates distances between
rows and between columns and then applies seriation so each. This is
the default method for data frames.
</p>
<p><code>control</code> parameter:
</p>

<ul>
<li> <p><code>"seriation_method"</code>: a list with row and column seriation methods.
The special method <code>"HC_Mean"</code> is available to use hierarchical clustering
with reordering the leaves by the row/column means (see <code><a href="stats.html#topic+heatmap">stats::heatmap()</a></code>).
Defaults to optimal leaf ordering <code>"OLO"</code>.
</p>
</li>
<li> <p><code>"seriation_control"</code>: a list with control parameters for row and column
seriation methods.
</p>
</li>
<li> <p><code>"dist_fun"</code>: specify the distance calculation as a function.
</p>
</li>
<li> <p><code>"scale"</code>: <code>"none"</code>, <code>"row"</code>, or <code>"col"</code>.
</p>
</li></ul>

</li></ul>

<p><strong>Seriate rows using the data matrix</strong>
</p>
<p>These methods need access to the data matrix instead of dissimilarities to
reorder objects (rows). Columns can also be reorderd by applying the same technique
to the transposed data matrix.
</p>

<ul>
<li> <p><strong>Order along the 1D locally linear embedding:</strong> <code>"LLE"</code>
</p>
</li></ul>

<p>Performs 1D the non-linear dimensionality reduction method locally linear embedding
(see <code><a href="#topic+lle">lle()</a></code>).
</p>

<ul>
<li> <p><strong>Order along the first principal component:</strong> <code>"PCA"</code>
</p>
<p>Uses the projection of the data on its first principal component to
determine the order of rows. Performs the same procedure on the transposed
matrix to obtain the column order.
</p>
<p>Note that for a distance matrix calculated from <code>x</code> with Euclidean
distance, this method minimizes the least square criterion.
</p>
</li>
<li> <p><strong>Angular order of the first two PCA components:</strong> <code>"PCA_angle"</code>
</p>
<p>For rows, projects the data on the first two principal components
and then orders by the angle in this space. The order is split by the larges
gap between adjacent angles. A similar method was suggested by
Friendly (2002) to order variables in correlation matrices
by angles of first two eigenvectors. PCA also computes the eigenvectors
of the covariance matrix of the data.
</p>
<p>Performs the same process on the
transposed matrix for the column order.
</p>
</li></ul>

<p><strong>Other methods</strong>
</p>

<ul>
<li> <p><strong>Angular order of the first two eigenvectors:</strong> <code>"AOE"</code> (Friendly 2002)
</p>
<p>This method reordered correlation matrices by the angle in the space
spanned by the two largest eigenvectors of the matrix. The order is split
by the largest angle gap. This is the original method proposed by
Friendly (2002).
</p>
</li>
<li> <p><strong>By row/column mean:</strong> <code>"Mean"</code>
</p>
<p>A transformation can be applied before calculating the means.
The function is specified as control
parameter <code>"transformation"</code>. Any function that takes as an input a
matrix and returns the transformed matrix can be used. Examples
are <code>scale</code> or <code style="white-space: pre;">&#8288;\(x) x^.5&#8288;</code>.
</p>
</li>
<li> <p><strong>Identity permutation:</strong> <code>"Identity"</code>
</p>
</li>
<li> <p><strong>Reverse Identity permutation:</strong> <code>"Reverse"</code>
</p>
</li>
<li> <p><strong>Random permutation:</strong> <code>"Random"</code>
</p>
</li></ul>

<p>For <strong>general arrays</strong> no built-in methods are currently available.
</p>


<h3>Value</h3>

<p>Returns an object of class <a href="#topic+ser_permutation">ser_permutation</a>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Arabie, P. and L.J. Hubert (1990): The bond energy algorithm
revisited, <em>IEEE Transactions on Systems, Man, and Cybernetics,</em>
<b>20</b>(1), 268&ndash;274.
<a href="https://doi.org/10.1109/21.47829">doi:10.1109/21.47829</a>
</p>
<p>Bar-Joseph, Z., E. D. Demaine, D. K. Gifford, and T. Jaakkola. (2001): Fast
Optimal Leaf Ordering for Hierarchical Clustering. <em>Bioinformatics,</em>
<b>17</b>(1), 22&ndash;29.
<a href="https://doi.org/10.1093/bioinformatics/17.suppl_1.S22">doi:10.1093/bioinformatics/17.suppl_1.S22</a>
</p>
<p>Barnard, S. T., A. Pothen, and H. D. Simon (1993): A Spectral Algorithm for
Envelope Reduction of Sparse Matrices. <em>In Proceedings of the 1993
ACM/IEEE Conference on Supercomputing,</em> 493&ndash;502. Supercomputing '93. New
York, NY, USA: ACM. <a href="https://ieeexplore.ieee.org/document/1263497">https://ieeexplore.ieee.org/document/1263497</a>
</p>
<p>Bezdek, J.C. and Hathaway, R.J. (2002): VAT: a tool for visual assessment of
(cluster) tendency. <em>Proceedings of the 2002 International Joint
Conference on Neural Networks (IJCNN '02)</em>, Volume: 3, 2225&ndash;2230.
<a href="https://doi.org/10.1109/IJCNN.2002.1007487">doi:10.1109/IJCNN.2002.1007487</a>
</p>
<p>Brusco, M., Koehn, H.F., and Stahl, S. (2008): Heuristic Implementation of
Dynamic Programming for Matrix Permutation Problems in Combinatorial Data
Analysis. <em>Psychometrika,</em> <b>73</b>(3), 503&ndash;522.
<a href="https://doi.org/10.1007/s11336-007-9049-5">doi:10.1007/s11336-007-9049-5</a>
</p>
<p>Brusco, M., and Stahl, S. (2005): <em>Branch-and-Bound Applications in
Combinatorial Data Analysis.</em> New York: Springer.
<a href="https://doi.org/10.1007/0-387-28810-4">doi:10.1007/0-387-28810-4</a>
</p>
<p>Chen, C. H. (2002): Generalized Association Plots: Information Visualization
via Iteratively Generated Correlation Matrices. <em>Statistica Sinica,</em>
<b>12</b>(1), 7&ndash;29.
</p>
<p>Ding, C. and Xiaofeng He (2004): Linearized cluster assignment via spectral
ordering. <em>Proceedings of the Twenty-first International Conference on
Machine learning (ICML '04)</em>.
<a href="https://doi.org/10.1145/1015330.1015407">doi:10.1145/1015330.1015407</a>
</p>
<p>Climer, S. and Xiongnu Zhang (2006): Rearrangement Clustering: Pitfalls,
Remedies, and Applications, <em>Journal of Machine Learning Research,</em>
<b>7</b>(Jun), 919&ndash;943.
</p>
<p>D. Earle, C. B. Hurley (2015): Advances in dendrogram seriation
for application to visualization.
<em>Journal of Computational and Graphical Statistics,</em> <strong>24</strong>(1), 1&ndash;25.
</p>
<p>Friendly, M. (2002): Corrgrams: Exploratory Displays for Correlation
Matrices. <em>The American Statistician</em>, <b>56</b>(4), 316&ndash;324.
<a href="https://doi.org/10.1198/000313002533">doi:10.1198/000313002533</a>
</p>
<p>Gruvaeus, G. and Wainer, H. (1972): Two Additions to Hierarchical Cluster
Analysis, <em>British Journal of Mathematical and Statistical Psychology,</em>
<b>25</b>, 200&ndash;206.
<a href="https://doi.org/10.1111/j.2044-8317.1972.tb00491.x">doi:10.1111/j.2044-8317.1972.tb00491.x</a>
</p>
<p>Hahsler, M. (2017): An experimental comparison of seriation methods for
one-mode two-way data. <em>European Journal of Operational Research,</em>
<b>257</b>, 133&ndash;143.
<a href="https://doi.org/10.1016/j.ejor.2016.08.066">doi:10.1016/j.ejor.2016.08.066</a>
</p>
<p>Hubert, Lawrence, and James Schultz (1976): Quadratic Assignment as a
General Data Analysis Strategy. <em>British Journal of Mathematical and
Statistical Psychology</em> <b>29</b>(2). Blackwell Publishing Ltd. 190&ndash;241.
<a href="https://doi.org/10.1111/j.2044-8317.1976.tb00714.x">doi:10.1111/j.2044-8317.1976.tb00714.x</a>
</p>
<p>Hurley, Catherine B. (2004): Clustering Visualizations of Multidimensional
Data. <em>Journal of Computational and Graphical Statistics,</em>
<b>13</b>(4), 788&ndash;806.
<a href="https://doi.org/10.1198/106186004X12425">doi:10.1198/106186004X12425</a>
</p>
<p>Kruskal, J.B. (1964). Nonmetric multidimensional scaling: a numerical method.
<em>Psychometrika</em> <strong>29</strong>, 115&ndash;129.
</p>
<p>Lenstra, J.K (1974): Clustering a Data Array and the Traveling-Salesman
Problem, <em>Operations Research,</em> <b>22</b>(2) 413&ndash;414.
<a href="https://doi.org/10.1287/opre.22.2.413">doi:10.1287/opre.22.2.413</a>
</p>
<p>Mair P., De Leeuw J. (2015). Unidimensional scaling. In <em>Wiley
StatsRef: Statistics Reference Online,</em> Wiley, New York.
<a href="https://doi.org/10.1002/9781118445112.stat06462.pub2">doi:10.1002/9781118445112.stat06462.pub2</a>
</p>
<p>McCormick, W.T., P.J. Schweitzer and T.W. White (1972): Problem
decomposition and data reorganization by a clustering technique,
<em>Operations Research,</em> <b>20</b>(5), 993&ndash;1009.
<a href="https://doi.org/10.1287/opre.20.5.993">doi:10.1287/opre.20.5.993</a>
</p>
<p>Tenenbaum, J.B., de Silva, V. &amp; Langford, J.C. (2000)
A global network framework for nonlinear dimensionality reduction.
<em>Science</em> <strong>290</strong>, 2319-2323.
</p>
<p>Tsafrir, D., Tsafrir, I., Ein-Dor, L., Zuk, O., Notterman, D.A. and Domany,
E. (2005): Sorting points into neighborhoods (SPIN): data analysis and
visualization by ordering distance matrices, <em>Bioinformatics,</em>
<b>21</b>(10) 2301&ndash;8.
<a href="https://doi.org/10.1093/bioinformatics/bti329">doi:10.1093/bioinformatics/bti329</a>
</p>
<p>Sammon, J. W. (1969) A non-linear mapping for data structure analysis. <em>IEEE Trans. Comput.</em>, <strong>C-18</strong> 401&ndash;409.
</p>


<h3>See Also</h3>

<p>Other seriation: 
<code><a href="#topic+register_DendSer">register_DendSer</a>()</code>,
<code><a href="#topic+register_GA">register_GA</a>()</code>,
<code><a href="#topic+register_optics">register_optics</a>()</code>,
<code><a href="#topic+register_smacof">register_smacof</a>()</code>,
<code><a href="#topic+register_tsne">register_tsne</a>()</code>,
<code><a href="#topic+register_umap">register_umap</a>()</code>,
<code><a href="#topic+registry_for_seriaiton_methods">registry_for_seriaiton_methods</a></code>,
<code><a href="#topic+seriate_best">seriate_best</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Show available seriation methods (for dist and matrix)
list_seriation_methods()

# show the description for ARSA
get_seriation_method("dist", name = "ARSA")

### Seriate as distance matrix (for the iris dataset)
data("iris")
x &lt;- as.matrix(iris[-5])
x &lt;- x[sample(1:nrow(x)), ]
d &lt;- dist(x)

order &lt;- seriate(d)
order

pimage(d, main = "Distances (Random Order)")
pimage(d, order, main = "Distances (Reordered)")

# Compare seriation quality
rbind(
        random = criterion(d),
        reordered = criterion(d, order)
     )

# Reorder the distance matrix
d_reordered &lt;-  permute(d, order)
pimage(d_reordered, main = "Distances (Reordered)")


### Seriate a matrix
data("iris")
x &lt;- as.matrix(iris[-5])

# To make the variables comparable, we scale the data
x &lt;- scale(x, center = FALSE)

# The iris flowers are ordered by species in the data set
pimage(x, main = "original data", prop = FALSE)
criterion(x)

# Apply some methods
order &lt;- seriate(x, method = "BEA_TSP")
pimage(x, order, main = "TSP to optimize ME", prop = FALSE)
criterion(x, order)

order &lt;- seriate(x, method = "PCA")
pimage(x, order, main = "First principal component", prop = FALSE)
criterion(x, order)

order &lt;- seriate(x, method = "heatmap")
pimage(x, order, main = "Heatmap seriation", prop = FALSE)
criterion(x, order)

# reorder the matrix
x_reordered &lt;- permute(x, order)

# create a heatmap seriation manually by calculating
# distances between rows and between columns
order &lt;- c(
    seriate(dist(x), method = "OLO"),
    seriate(dist(t(x)), method = "OLO")
)
pimage(x, order, main = "Heatmap seriation", prop = FALSE)
criterion(x, order)

### Seriate a correlation matrix
corr &lt;- cor(x)

# plot in original order
pimage(corr, main = "Correlation matrix")

# reorder the correlation matrix using the angle of eigenvectors
pimage(corr, order = "AOE", main = "Correlation matrix (AOE)")

# we can also define a distance (we used d = sqrt(1 - r)) and
# then reorder the matrix (rows and columns) using any seriation method.
d &lt;- as.dist(sqrt(1 - corr))
o &lt;- seriate(d, method = "R2E")
corr_reordered &lt;- permute(corr, order = c(o, o))
pimage(corr_reordered, main = "Correlation matrix (R2E)")
</code></pre>

<hr>
<h2 id='seriate_best'>Best Seriation</h2><span id='topic+seriate_best'></span><span id='topic+seriate_rep'></span><span id='topic+seriate_improve'></span>

<h3>Description</h3>

<p>Often the best seriation method for a particular dataset is not know and
heuristics may produce unstable results.
<code>seriate_best()</code> and <code>seriate_rep()</code> automatically try different seriation methods or
rerun randomized methods several times to find the best and order
given a criterion measure. <code>seriate_improve()</code> uses a local improvement strategy
to imporve an existing solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriate_best(
  x,
  methods = NULL,
  control = NULL,
  criterion = NULL,
  rep = 10L,
  parallel = TRUE,
  verbose = TRUE,
  ...
)

seriate_rep(
  x,
  method = NULL,
  control = NULL,
  criterion = NULL,
  rep = 10L,
  parallel = TRUE,
  verbose = TRUE,
  ...
)

seriate_improve(
  x,
  order,
  criterion = NULL,
  control = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriate_best_+3A_x">x</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code id="seriate_best_+3A_methods">methods</code></td>
<td>
<p>a vector of character string with the name of the seriation
methods to try.</p>
</td></tr>
<tr><td><code id="seriate_best_+3A_control">control</code></td>
<td>
<p>a list of control options passed on to <code><a href="#topic+seriate">seriate()</a></code>.
For <code>seriate_best()</code> control needs to be a named list of control lists
with the names matching the seriation methods.</p>
</td></tr>
<tr><td><code id="seriate_best_+3A_criterion">criterion</code></td>
<td>
<p><code>seriate_rep()</code> chooses the criterion specified for the
method in the registry. A character string with the <a href="#topic+criterion">criterion</a> to optimize
can be specified.</p>
</td></tr>
<tr><td><code id="seriate_best_+3A_rep">rep</code></td>
<td>
<p>number of times to repeat the randomized seriation algorithm.</p>
</td></tr>
<tr><td><code id="seriate_best_+3A_parallel">parallel</code></td>
<td>
<p>logical; perform replications in parallel.
Uses <code style="white-space: pre;">&#8288;[foreach]&#8288;</code> if a
DoPar backend (e.g., <code>doParallel</code>) is rgistered.</p>
</td></tr>
<tr><td><code id="seriate_best_+3A_verbose">verbose</code></td>
<td>
<p>logical; show progress and results for different methods</p>
</td></tr>
<tr><td><code id="seriate_best_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the <code><a href="#topic+seriate">seriate()</a></code>.</p>
</td></tr>
<tr><td><code id="seriate_best_+3A_method">method</code></td>
<td>
<p>a character string with the name of the seriation method
(default: varies by data type).</p>
</td></tr>
<tr><td><code id="seriate_best_+3A_order">order</code></td>
<td>
<p>a <code>ser_permutation</code> object for <code>x</code> or the name of a seriation method to start with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>seriate_rep()</code> rerun a randomized seriation methods to find the best solution
given the criterion specified for the method in the registry.
A specific criterion can also be specified.
Non-stochastic methods are automatically only run once.
</p>
<p><code>seriate_best()</code> runs a set of methods and returns the best result given a
criterion. Stochastic methods are automatically randomly restarted several times.
</p>
<p><code>seriate_improve()</code> improves a seriation order using simulated annealing using
a specified criterion measure. It uses <code><a href="#topic+seriate">seriate()</a></code> with method &quot;<code>GSA</code>&quot;,
a reduced probability to accept bad moves, and a lower minimum temperature. Control
parameters for this method are accepted.
</p>
<p><strong>Criterion</strong>
</p>
<p>If no criterion is specified, ten the criterion specified for the method in
the registry (see <code style="white-space: pre;">&#8288;[get_seriation_method()]&#8288;</code>) is used. For methods with no
criterion in the registry (marked as &quot;other&quot;), a default method is used.
The defaults are:
</p>

<ul>
<li> <p><code>dist</code>: <code>"AR_deviations"</code> - the study in Hahsler (2007) has shown that this
criterion has high similarity with most other criteria.
</p>
</li>
<li> <p><code>matrix</code>: &quot;Moore_stress&quot;
</p>
</li></ul>

<p><strong>Parallel Execution</strong>
</p>
<p>Some methods support for parallel execution is provided using the <code><a href="foreach.html#topic+foreach">foreach</a></code> package. To
use parallel execution, a suitable backend needs to be registered (eee
the Examples section for using the <code>doParallel</code> package).
</p>


<h3>Value</h3>

<p>Returns an object of class <a href="#topic+ser_permutation">ser_permutation</a>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Hahsler, M. (2017): An experimental comparison of seriation methods for
one-mode two-way data. <em>European Journal of Operational Research,</em>
<b>257</b>, 133&ndash;143.
<a href="https://doi.org/10.1016/j.ejor.2016.08.066">doi:10.1016/j.ejor.2016.08.066</a>
</p>


<h3>See Also</h3>

<p>Other seriation: 
<code><a href="#topic+register_DendSer">register_DendSer</a>()</code>,
<code><a href="#topic+register_GA">register_GA</a>()</code>,
<code><a href="#topic+register_optics">register_optics</a>()</code>,
<code><a href="#topic+register_smacof">register_smacof</a>()</code>,
<code><a href="#topic+register_tsne">register_tsne</a>()</code>,
<code><a href="#topic+register_umap">register_umap</a>()</code>,
<code><a href="#topic+registry_for_seriaiton_methods">registry_for_seriaiton_methods</a></code>,
<code><a href="#topic+seriate">seriate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SupremeCourt)
d_supreme &lt;- as.dist(SupremeCourt)

# find best seriation order (tries by by default several fast methods)
o &lt;- seriate_best(d_supreme, criterion = "AR_events")
o
pimage(d_supreme, o)

# run a randomized algorithms several times. It automatically chooses the
# LS criterion. Repetition information is returned as attributes
o &lt;- seriate_rep(d_supreme, "QAP_LS", rep = 5)

attr(o, "criterion")
hist(attr(o, "criterion_distribution"))
pimage(d_supreme, o)

## Not run: 
# Using parallel execution on a larger dataset
data(iris)
m_iris &lt;- as.matrix(iris[sample(seq(nrow(iris))),-5])
d_iris &lt;- dist(m_iris)

library(doParallel)
registerDoParallel(cores = detectCores() - 1L)

# seriate rows of the iris data set
o &lt;- seriate_best(d_iris, criterion = "LS")
o

pimage(d_iris, o)

# improve the order to minimize RGAR instead of LS
o_improved &lt;- seriate_improve(d_iris, o, criterion = "RGAR")
pimage(d_iris, o_improved)

# available control parameters for seriate_improve()
get_seriation_method(name = "GSA")

## End(Not run)
</code></pre>

<hr>
<h2 id='seriation-package'>seriation: Infrastructure for Ordering Objects Using Seriation</h2><span id='topic+seriation-package'></span>

<h3>Description</h3>

<p>Infrastructure for ordering objects with an implementation of several seriation/sequencing/ordination techniques to reorder matrices, dissimilarity matrices, and dendrograms. Also provides (optimally) reordered heatmaps, color images and clustering visualizations like dissimilarity plots, and visual assessment of cluster tendency plots (VAT and iVAT).
</p>


<h3>Key functions</h3>


<ul>
<li><p> Seriation: <code><a href="#topic+seriate">seriate()</a></code>, <code><a href="#topic+criterion">criterion()</a></code>, <code><a href="#topic+get_order">get_order()</a></code>, <code><a href="#topic+permute">permute()</a></code>
</p>
</li>
<li><p> Visualization: <code><a href="#topic+pimage">pimage()</a></code>, <code><a href="#topic+bertinplot">bertinplot()</a></code>, <code><a href="#topic+hmap">hmap()</a></code>, <code><a href="#topic+dissplot">dissplot()</a></code>, <code><a href="#topic+VAT">VAT()</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Michael Hahsler, Kurt Hornik, and Christian Buchta. Getting things in order: An introduction to the R package seriation. Journal of Statistical Software, 25(3):1&ndash;34, March 2008. <a href="https://doi.org/10.18637/jss.v025.i03">doi:10.18637/jss.v025.i03</a>
</p>

<hr>
<h2 id='SupremeCourt'>Voting Patterns in the Second Rehnquist U.S. Supreme Court</h2><span id='topic+SupremeCourt'></span>

<h3>Description</h3>

<p>Contains a (a subset of the) decisions for the stable 8-yr
period 1995-2002 of the second Rehnquist Supreme Court.
Decisions are aggregated to
the joint probability for disagreement between judges.
</p>


<h3>Format</h3>

<p>A square, symmetric 9-by-9 matrix with the joint probability for disagreement.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<div class="sourceCode"><pre>Sirovich, L. (2003). A pattern analysis of the second Rehnquist
U.S. Supreme Court. \emph{Proceedings of the National Academy of Sciences of the United
States of America,} 100, 7432-7437. \doi{10.1073/pnas.1132164100}
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>data("SupremeCourt")

# a matrix with joint probability of disagreement
SupremeCourt

# show judges in original alphabetical order
d &lt;- as.dist(SupremeCourt)
pimage(d, diag = TRUE, upper = TRUE)

# reorder judges using seriation based on similar decisions
o &lt;- seriate(d)
o

pimage(d, o, diag = TRUE, upper = TRUE)

# Use optimal leaf ordering (hierarchical clustering with reordering)
# which uses a dendrogram
o &lt;- seriate(d, method = "OLO")
o

plot(o[[1]])

# Use multi-dimensional scaling and show the configuration
o &lt;- seriate(d, method = "sammon")
o

pimage(d, o, diag = TRUE, upper = TRUE)
plot_config(o[[1]])
</code></pre>

<hr>
<h2 id='Townships'>Bertin's Characteristics of Townships</h2><span id='topic+Townships'></span>

<h3>Description</h3>

<p>This data contains nine characteristics for 16 townships. The data
set was used by Bertin (1981) to illustrate that the conciseness
of presentation can be improved by seriating the rows and columns.
</p>


<h3>Format</h3>

<p>A matrix with 16 0-1 variables (columns) indicating the presence
(<code>1</code>) or absence (<code>0</code>) of characteristics of townships
(rows).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Bertin, J. (1981): <em>Graphics and Graphic Information Processing</em>. Berlin, Walter de Gruyter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Townships")

## original data
pimage(Townships)
criterion(Townships)

## seriated data
order &lt;- seriate(Townships, method = "BEA", control = list(rep = 5))
pimage(Townships, order)
criterion(Townships, order)
</code></pre>

<hr>
<h2 id='uniscale'>Unidimensional Scaling from Seriation Results</h2><span id='topic+uniscale'></span><span id='topic+MDS_stress'></span><span id='topic+get_config'></span><span id='topic+plot_config'></span>

<h3>Description</h3>

<p>Calculates an (approximate) unidimensional scaling configuration given an order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniscale(d, order, accept_reorder = FALSE, warn = TRUE, ...)

MDS_stress(d, order, refit = TRUE, warn = FALSE)

get_config(x, dim = 1L, ...)

plot_config(x, main, pch = 19, labels = TRUE, pos = 1, cex = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniscale_+3A_d">d</code></td>
<td>
<p>a dissimilarity matrix.</p>
</td></tr>
<tr><td><code id="uniscale_+3A_order">order</code></td>
<td>
<p>a precomputed permutation (configuration) order.</p>
</td></tr>
<tr><td><code id="uniscale_+3A_accept_reorder">accept_reorder</code></td>
<td>
<p>logical; accept a configuration that does not preserve
the requested order. If <code>FALSE</code>, the initial configuration stored in <code>order</code>
or, an equally spaced configuration is returned.</p>
</td></tr>
<tr><td><code id="uniscale_+3A_warn">warn</code></td>
<td>
<p>logical; produce a warning if the 1D MDS fit does not preserve the
given order.</p>
</td></tr>
<tr><td><code id="uniscale_+3A_...">...</code></td>
<td>
<p>additional arguments are passed on to the seriation method.</p>
</td></tr>
<tr><td><code id="uniscale_+3A_refit">refit</code></td>
<td>
<p>logical; forces to refit a minimum-stress MDS configuration,
even if <code>order</code> contains a configuration.</p>
</td></tr>
<tr><td><code id="uniscale_+3A_x">x</code></td>
<td>
<p>a scaling returned by <code>uniscale()</code> or a
<code>ser_permutation</code> with a configuration attribute.</p>
</td></tr>
<tr><td><code id="uniscale_+3A_dim">dim</code></td>
<td>
<p>The dimension if <code>x</code> is a <code>ser_permutation</code> object.</p>
</td></tr>
<tr><td><code id="uniscale_+3A_main">main</code></td>
<td>
<p>main plot label</p>
</td></tr>
<tr><td><code id="uniscale_+3A_pch">pch</code></td>
<td>
<p>print character</p>
</td></tr>
<tr><td><code id="uniscale_+3A_labels">labels</code></td>
<td>
<p>add the object names to the plot</p>
</td></tr>
<tr><td><code id="uniscale_+3A_pos">pos</code></td>
<td>
<p>label position for 2D plot (see <code><a href="graphics.html#topic+text">text()</a></code>).</p>
</td></tr>
<tr><td><code id="uniscale_+3A_cex">cex</code></td>
<td>
<p>label expansion factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation uses the method describes in Maier and De Leeuw (2015) to calculate the
minimum stress configuration for a given (seriation) order by performing a 1D MDS fit.
If the 1D MDS fit does not preserve the given order perfectly, then a warning is
produced indicating
for how many positions order could not be preserved.
The seriation method which is consistent to uniscale is <code>"MDS_smacof"</code>
which needs to be registered with <code><a href="#topic+register_smacof">register_smacof()</a></code>.
</p>
<p>The code is similar to <code>uniscale()</code> in <span class="pkg">smacof</span> (de Leeuw, 2090), but scales to larger
datasets since it only uses the permutation given by  <code>order</code>.
</p>
<p><code>MDS_stress</code> calculates the normalized stress of a configuration given by a seriation order.
If the order does not contain a configuration, then a minimum-stress configuration if calculates
for the given order.
</p>
<p>All distances are first normalized to an average distance of close to 1 using
<code class="reqn">d_{ij} \frac{\sqrt{n(n-1)/2}}{\sqrt{\sum_{i&lt;j}{d_{ij}}^2}}</code>.
</p>
<p>Some seriation methods produce a MDS configuration (a 1D or 2D embedding). <code>get_config()</code>
retrieved the configuration attribute from the <code>ser_permutation_vector</code>. <code>NULL</code>
is returned if the seriation did not produce a configuration.
</p>
<p><code>plot_config()</code> plots 1D and 2D configurations. <code>...</code> is passed on
to <code><a href="graphics.html#topic+plot.default">plot.default</a></code> and accepts <code>col</code>, <code>labels</code>, etc.
</p>


<h3>Value</h3>

<p>A vector with the fitted configuration.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler with code from Patrick Mair (from <span class="pkg">smacof</span>).
</p>


<h3>References</h3>

<p>Mair P., De Leeuw J. (2015). Unidimensional scaling. In
<em>Wiley StatsRef: Statistics Reference Online,</em> Wiley, New York.
<a href="https://doi.org/10.1002/9781118445112.stat06462.pub2">doi:10.1002/9781118445112.stat06462.pub2</a>
</p>
<p>Jan de Leeuw, Patrick Mair (2009). Multidimensional Scaling Using Majorization:
SMACOF in R. Journal of Statistical Software, 31(3), 1-30.
<a href="https://doi.org/10.18637/jss.v031.i03">doi:10.18637/jss.v031.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+register_smacof">register_smacof()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SupremeCourt)
d &lt;- as.dist(SupremeCourt)
d

# embedding-based methods return "configuration" attribute
# plot_config visualizes the configuration
o &lt;- seriate(d, method = "sammon")
get_order(o)
plot_config(o)

# the configuration (Note: objects are in the original order in d)
get_config(o)

# angle methods return a 2D configuration
o &lt;- seriate(d, method = "MDS_angle")
get_order(o)
get_config(o)
plot_config(o, )


# calculate a configuration for a seriation method that does not
# create a configuration
o &lt;- seriate(d, method = "ARSA")
get_order(o)
get_config(o)

# find the minimum-stress configuration for the ARSA order
sc &lt;- uniscale(d, o)
sc

plot_config(sc)
</code></pre>

<hr>
<h2 id='VAT'>Visual Analysis for Cluster Tendency Assessment (VAT/iVAT)</h2><span id='topic+VAT'></span><span id='topic+iVAT'></span><span id='topic+path_dist'></span><span id='topic+ggVAT'></span><span id='topic+ggiVAT'></span>

<h3>Description</h3>

<p>Implements Visual Analysis for Cluster Tendency Assessment (VAT; Bezdek and
Hathaway, 2002) and Improved Visual Analysis for Cluster Tendency Assessment
(iVAT; Wang et al, 2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAT(x, upper_tri = TRUE, lower_tri = TRUE, ...)

iVAT(x, upper_tri = TRUE, lower_tri = TRUE, ...)

path_dist(x)

ggVAT(x, upper_tri = TRUE, lower_tri = TRUE, ...)

ggiVAT(x, upper_tri = TRUE, lower_tri = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VAT_+3A_x">x</code></td>
<td>
<p>a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="VAT_+3A_upper_tri">upper_tri</code>, <code id="VAT_+3A_lower_tri">lower_tri</code></td>
<td>
<p>a logical indicating whether to show the upper or
lower triangle of the VAT matrix.</p>
</td></tr>
<tr><td><code id="VAT_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to <code><a href="#topic+pimage">pimage</a></code> for the
regular plots and <code><a href="#topic+ggpimage">ggpimage</a></code> for the ggplot2 plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>path_dist()</code> redefines the distance between two objects as the minimum
over the largest distances in all possible paths between the objects as used
for iVAT.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Bezdek, J.C. and Hathaway, R.J. (2002): VAT: a tool for visual
assessment of (cluster) tendency. <em>Proceedings of the 2002
International Joint Conference on Neural Networks (IJCNN '02)</em>, Volume: 3,
2225&ndash;2230.
</p>
<p>Havens, T.C. and Bezdek, J.C. (2012): An Efficient Formulation of the
Improved Visual Assessment of Cluster Tendency (iVAT) Algorithm, <em>IEEE
Transactions on Knowledge and Data Engineering,</em> <b>24</b>(5), 813&ndash;822.
</p>
<p>Wang L., U.T.V. Nguyen, J.C. Bezdek, C.A. Leckie and K. Ramamohanarao
(2010): iVAT and aVAT: Enhanced Visual Analysis for Cluster Tendency
Assessment, <em>Proceedings of the PAKDD 2010, Part I, LNAI 6118,</em> 16&ndash;27.
</p>


<h3>See Also</h3>

<p>Other plots: 
<code><a href="#topic+bertinplot">bertinplot</a>()</code>,
<code><a href="#topic+dissplot">dissplot</a>()</code>,
<code><a href="#topic+hmap">hmap</a>()</code>,
<code><a href="#topic+palette">palette</a>()</code>,
<code><a href="#topic+pimage">pimage</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## lines data set from Havens and Bezdek (2011)
x &lt;- create_lines_data(250)
plot(x, xlim=c(-5,5), ylim=c(-3,3), cex=.2)
d &lt;- dist(x)

## create regular VAT
VAT(d, main = "VAT for Lines")
## same as: pimage(d, seriate(d, "VAT"))

## ggplot2 version
if (require("ggplot2")) {
  ggVAT(d) + labs(title = "VAT")
}

## create iVAT which shows visually the three lines
iVAT(d, main = "iVAT for Lines")
## same as:
## d_path &lt;- path_dist(d)
## pimage(d_path, seriate(d_path, "VAT for Lines"))

## ggplot2 version
if (require("ggplot2")) {
  ggiVAT(d) + labs(title = "iVAT for Lines")
}

## compare with dissplot (shows banded structures and relationship between
## center line and the two outer lines)
dissplot(d, method = "OLO_single", main = "Dissplot for Lines", col = bluered(100, bias = .5))

## compare with optimally reordered heatmap
hmap(d, method = "OLO_single", main = "Heatmap for Lines (opt. leaf ordering)",
  col = bluered(100, bias = .5))
</code></pre>

<hr>
<h2 id='Wood'>Gene Expression Data for Wood Formation in Poplar Trees</h2><span id='topic+Wood'></span>

<h3>Description</h3>

<p>A data matrix containing a sample of the normalized gene expression data for
6 locations in the stem of Popla trees published in the study by Herzberg et
al (2001). The sample of 136 genes selected by Caraux and Pinloche (2005).
</p>


<h3>Format</h3>

<p>The format is a 136 x 6 matrix.
</p>


<h3>Source</h3>

<p>The data was obtained from
<a href="http://www.atgc-montpellier.fr/permutmatrix/manual/Exemples/Wood/Wood.htm">http://www.atgc-montpellier.fr/permutmatrix/manual/Exemples/Wood/Wood.htm</a>.
</p>


<h3>References</h3>

<p>Hertzberg M., H. Aspeborg, J. Schrader, A. Andersson,
R.Erlandsson, K. Blomqvist, R. Bhalerao, M. Uhlen, T. T. Teeri, J.
Lundeberg, Bjoern Sundberg, P. Nilsson and Goeran Sandberg (2001): A
transcriptional roadmap to wood formation, <em>PNAS,</em> <b>98</b>(25),
14732&ndash;14737.
</p>
<p>Caraux G. and Pinloche S. (2005): PermutMatrix: a graphical environment to
arrange gene expression profiles in optimal linear order,
<em>Bioinformatics,</em> <b>21</b>(7) 1280&ndash;1281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Wood)
head(Wood)

</code></pre>

<hr>
<h2 id='Zoo'>Zoo Data Set</h2><span id='topic+Zoo'></span>

<h3>Description</h3>

<p>A database containing characteristics of different animals. The database was
created and donated by Richard S. Forsyth and is available from the UCI
Machine Learning Repository (Newman et al, 1998).
</p>


<h3>Format</h3>

<p>A data frame with 101 observations on the following 17 variables.
</p>

<dl>
<dt><code>hair</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>feathers</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>eggs</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>milk</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>airborne</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>aquatic</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>predator</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>toothed</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>backbone</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>breathes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>venomous</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fins</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>legs</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>tail</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>domestic</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>catsize</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>class</code></dt><dd><p>a factor with levels <code>amphibian</code> <code>bird</code> <code>fish</code> <code>insect</code> <code>invertebrate</code> <code>mammal</code> <code>reptile</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>David Aha, Patrick Murphy, Christopher Merz, Eamonn Keogh,
Cathy Blake, Seth Hettich, David Newman, Arthur Asuncion, Moshe Lichman,
Dheeru Dua, Casey Graff (2023): UCI Machine Learning Repository,
<a href="https://archive.ics.uci.edu/">https://archive.ics.uci.edu/</a>, University of
California, Irvine.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Zoo")
x &lt;- scale(Zoo[, -17])


d &lt;- dist(x)
pimage(d)

order &lt;- seriate(d, method = "tsp")
pimage(d, order)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
