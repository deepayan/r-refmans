<!DOCTYPE html><html><head><title>Help for package promises</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {promises}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#future_promise_queue'><p><span class="pkg">future</span> promise</p></a></li>
<li><a href='#is.promise'><p>Coerce to a promise</p></a></li>
<li><a href='#pipes'><p>Promise pipe operators</p></a></li>
<li><a href='#promise'><p>Create a new promise object</p></a></li>
<li><a href='#promise_all'><p>Combine multiple promise objects</p></a></li>
<li><a href='#promise_map'><p>Promise-aware lapply/map</p></a></li>
<li><a href='#promise_reduce'><p>Promise-aware version of Reduce</p></a></li>
<li><a href='#promise_resolve'><p>Create a resolved or rejected promise</p></a></li>
<li><a href='#promises-package'><p>promises: Abstractions for Promise-Based Asynchronous Programming</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#resolve'><p>Fulfill a promise</p></a></li>
<li><a href='#then'><p>Access the results of a promise</p></a></li>
<li><a href='#with_promise_domain'><p>Promise domains</p></a></li>
<li><a href='#WorkQueue'><p>Future promise work queue</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Abstractions for Promise-Based Asynchronous Programming</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides fundamental abstractions for doing asynchronous
    programming in R using promises. Asynchronous programming is useful
    for allowing a single R process to orchestrate multiple tasks in the
    background while also attending to something else. Semantics are
    similar to 'JavaScript' promises, but with a syntax that is idiomatic
    R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rstudio.github.io/promises/">https://rstudio.github.io/promises/</a>,
<a href="https://github.com/rstudio/promises">https://github.com/rstudio/promises</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rstudio/promises/issues">https://github.com/rstudio/promises/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>fastmap (&ge; 1.1.0), later, magrittr (&ge; 1.5), R6, Rcpp, rlang,
stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>future (&ge; 1.21.0), knitr, purrr, rmarkdown, spelling,
testthat, vembedr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>later, Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rsconnect</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-09 20:29:25 UTC; garrick</td>
</tr>
<tr>
<td>Author:</td>
<td>Joe Cheng [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joe Cheng &lt;joe@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-10 16:00:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:40:29 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='future_promise_queue'><span class="pkg">future</span> promise</h2><span id='topic+future_promise_queue'></span><span id='topic+future_promise'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_promise_queue()

future_promise(
  expr = NULL,
  envir = parent.frame(),
  substitute = TRUE,
  globals = TRUE,
  packages = NULL,
  ...,
  queue = future_promise_queue()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_promise_queue_+3A_expr">expr</code></td>
<td>
<p>An R expression. While the <code>expr</code> is eventually sent to <code><a href="future.html#topic+future">future::future()</a></code>, please use the same precautions that you would use with regular <code>promises::promise()</code> expressions. <code>future_promise()</code> may have to hold the <code>expr</code> in a <code><a href="base.html#topic+promise">promise()</a></code> while waiting for a <span class="pkg">future</span> worker to become available.</p>
</td></tr>
<tr><td><code id="future_promise_queue_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
<tr><td><code id="future_promise_queue_+3A_substitute">substitute</code></td>
<td>
<p>If TRUE, argument <code>expr</code> is
<code><a href="base.html#topic+substitute">substitute</a>()</code>:ed, otherwise not.</p>
</td></tr>
<tr><td><code id="future_promise_queue_+3A_globals">globals</code></td>
<td>
<p>(optional) a logical, a character vector, or a named list
to control how globals are handled.
For details, see section 'Globals used by future expressions'
in the help for <code><a href="future.html#topic+future">future()</a></code>.</p>
</td></tr>
<tr><td><code id="future_promise_queue_+3A_packages">packages</code></td>
<td>
<p>(optional) a character vector specifying packages
to be attached in the <span class="rlang"><b>R</b></span> environment evaluating the future.</p>
</td></tr>
<tr><td><code id="future_promise_queue_+3A_...">...</code></td>
<td>
<p>extra parameters provided to <code><a href="future.html#topic+future">future::future()</a></code></p>
</td></tr>
<tr><td><code id="future_promise_queue_+3A_queue">queue</code></td>
<td>
<p>A queue that is used to schedule work to be done using <code><a href="future.html#topic+future">future::future()</a></code>.  This queue defaults to <code><a href="promises.html#topic+future_promise_queue">future_promise_queue()</a></code> and requires that method <code>queue$schedule_work(fn)</code> exist.  This method should take in a function that will execute the promised <span class="pkg">future</span> work.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When submitting <span class="pkg">future</span> work, <span class="pkg">future</span> (by design) will block the main R session until a worker becomes available.
This occurs when there is more submitted <span class="pkg">future</span> work than there are available <span class="pkg">future</span> workers.
To counter this situation, we can create a promise to execute work using future (using <code>future_promise()</code>) and only begin the work if a <span class="pkg">future</span> worker is available.
</p>
<p>Using <code>future_promise()</code> is recommended whenever a continuous runtime is used, such as with <span class="pkg">plumber</span> or <span class="pkg">shiny</span>.
</p>
<p>For more details and examples, please see the <a href="https://rstudio.github.io/promises/articles/future_promise.html"><code>vignette("future_promise", "promises")</code></a> vignette.
</p>


<h3>Value</h3>

<p>Unlike <code><a href="future.html#topic+future">future::future()</a></code>, <code>future_promise()</code> returns a <code><a href="base.html#topic+promise">promise()</a></code> object that will eventually resolve the <span class="pkg">future</span> <code>expr</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>future_promise_queue()</code>: Default <code>future_promise()</code> work queue to use. This function returns a <a href="promises.html#topic+WorkQueue">WorkQueue</a> that is cached per R session.
</p>
</li>
<li> <p><code>future_promise()</code>: Creates a <code><a href="base.html#topic+promise">promise()</a></code> that will execute the <code>expr</code> using <code><a href="future.html#topic+future">future::future()</a></code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="promises.html#topic+WorkQueue">WorkQueue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Relative start time
start &lt;- Sys.time()
# Helper to force two `future` workers
with_two_workers &lt;- function(expr) {
  if (!require("future")) {
    message("`future` not installed")
    return()
  }
  old_plan &lt;- future::plan(future::multisession(workers = 2))
  on.exit({future::plan(old_plan)}, add = TRUE)
  start &lt;&lt;- Sys.time()
  force(expr)
  while(!later::loop_empty()) {Sys.sleep(0.1); later::run_now()}
  invisible()
}
# Print a status message. Ex: `"PID: XXX; 2.5s promise done"`
print_msg &lt;- function(pid, msg) {
  message(
    "PID: ", pid, "; ",
    round(difftime(Sys.time(), start, units = "secs"), digits = 1), "s " ,
    msg
  )
}

# `"promise done"` will appear after four workers are done and the main R session is not blocked
# The important thing to note is the first four times will be roughly the same
with_two_workers({
  promise_resolve(Sys.getpid()) %...&gt;% print_msg("promise done")
  for (i in 1:6) future::future({Sys.sleep(1); Sys.getpid()}) %...&gt;% print_msg("future done")
})
{
#&gt; PID: XXX; 2.5s promise done
#&gt; PID: YYY; 2.6s future done
#&gt; PID: ZZZ; 2.6s future done
#&gt; PID: YYY; 2.6s future done
#&gt; PID: ZZZ; 2.6s future done
#&gt; PID: YYY; 3.4s future done
#&gt; PID: ZZZ; 3.6s future done
}

# `"promise done"` will almost immediately, before any workers have completed
# The first two `"future done"` comments appear earlier the example above
with_two_workers({
  promise_resolve(Sys.getpid()) %...&gt;% print_msg("promise")
  for (i in 1:6) future_promise({Sys.sleep(1); Sys.getpid()}) %...&gt;% print_msg("future done")
})
{
#&gt; PID: XXX; 0.2s promise done
#&gt; PID: YYY; 1.3s future done
#&gt; PID: ZZZ; 1.4s future done
#&gt; PID: YYY; 2.5s future done
#&gt; PID: ZZZ; 2.6s future done
#&gt; PID: YYY; 3.4s future done
#&gt; PID: ZZZ; 3.6s future done
}
</code></pre>

<hr>
<h2 id='is.promise'>Coerce to a promise</h2><span id='topic+is.promise'></span><span id='topic+is.promising'></span><span id='topic+as.promise'></span>

<h3>Description</h3>

<p>Use <code>is.promise</code> to determine whether an R object is a promise. Use
<code>as.promise</code> (an S3 generic method) to attempt to coerce an R object to a
promise. This package includes support for converting <a href="future.html#topic+Future-class">future::Future</a>
objects into promises.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.promise(x)

is.promising(x)

as.promise(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.promise_+3A_x">x</code></td>
<td>
<p>An R object to test or coerce.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.promise</code> returns a promise object, or throws an error if the
object cannot be converted.
</p>
<p><code>is.promise</code> returns <code>TRUE</code> if the given value is a promise object, and
<code>FALSE</code> otherwise.
</p>
<p><code>is.promising</code> returns <code>TRUE</code> if the given value is a promise object or
if it can be converted to a promise object using <code>as.promise</code>, and <code>FALSE</code>
otherwise.
</p>

<hr>
<h2 id='pipes'>Promise pipe operators</h2><span id='topic+pipes'></span><span id='topic++25...+3E+25'></span><span id='topic++25...T+3E+25'></span><span id='topic++25...+21+25'></span><span id='topic++25...T+21+25'></span>

<h3>Description</h3>

<p>Promise-aware pipe operators, in the style of <a href="https://CRAN.R-project.org/package=magrittr/vignettes/magrittr.html">magrittr</a>.
Like magrittr pipes, these operators can be used to chain together pipelines
of promise-transforming operations. Unlike magrittr pipes, these pipes wait
for promise resolution and pass the unwrapped value (or error) to the <code>rhs</code>
function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %...&gt;% rhs

lhs %...T&gt;% rhs

lhs %...!% rhs

lhs %...T!% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pipes_+3A_lhs">lhs</code></td>
<td>
<p>A promise object.</p>
</td></tr>
<tr><td><code id="pipes_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics. It can return either
a promise or non-promise value, or throw an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>&gt;</code> variants are for handling successful resolution, the <code>!</code> variants are
for handling errors. The <code>T</code> variants of each return the lhs instead of the
rhs, which is useful for pipeline steps that are used for side effects
(printing, plotting, saving).
</p>

<ol>
<li> <p><code>promise %...&gt;% func()</code> is equivalent to <code>promise %&gt;% then(func)</code>.
</p>
</li>
<li> <p><code>promise %...!% func()</code> is equivalent to <code>promise %&gt;% catch(func)</code>.
</p>
</li>
<li> <p><code>promise %...T&gt;% func()</code> is equivalent to <code>promise %T&gt;% then(func)</code>.
</p>
</li>
<li> <p><code>promise %...T!% func()</code> is equivalent to <code>promise %T&gt;%
catch(func)</code> or <code>promise %&gt;% catch(func, tee = TRUE)</code>.
</p>
</li></ol>

<p>One situation where 3. and 4. above break down is when <code>func()</code> throws an
error, or returns a promise that ultimately fails. In that case, the failure
will be propagated by our pipe operators but not by the
magrittr-plus-function &quot;equivalents&quot;.
</p>
<p>For simplicity of implementation, we do not support the magrittr feature of
using a <code>.</code> at the head of a pipeline to turn the entire pipeline into a
function instead of an expression.
</p>


<h3>Value</h3>

<p>A new promise.
</p>


<h3>See Also</h3>

<p>https://rstudio.github.io/promises/articles/overview.html#using-pipes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(future)
plan(multisession)

future_promise(cars) %...&gt;%
  head(5) %...T&gt;%
  print()

# If the read.csv fails, resolve to NULL instead
future_promise(read.csv("http://example.com/data.csv")) %...!%
  { NULL }

## End(Not run)

</code></pre>

<hr>
<h2 id='promise'>Create a new promise object</h2><span id='topic+promise'></span>

<h3>Description</h3>

<p><code>promise()</code> creates a new promise. A promise is a placeholder object for the
eventual result (or error) of an asynchronous operation. This function is not
generally needed to carry out asynchronous programming tasks; instead, it is
intended to be used mostly by package authors who want to write asynchronous
functions that return promises.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>promise(action)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="promise_+3A_action">action</code></td>
<td>
<p>A function with signature <code style="white-space: pre;">&#8288;function(resolve, reject)&#8288;</code>, or a
one-sided formula. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>action</code> function should be a piece of code that returns quickly, but
initiates a potentially long-running, asynchronous task. If/when the task
successfully completes, call <code>resolve(value)</code> where <code>value</code> is the result of
the computation (like the return value). If the task fails, call
<code>reject(reason)</code>, where <code>reason</code> is either an error object, or a character
string.
</p>
<p>It's important that asynchronous tasks kicked off from <code>action</code> be coded very
carefully&ndash;in particular, all errors must be caught and passed to <code>reject()</code>.
Failure to do so will cause those errors to be lost, at best; and the caller
of the asynchronous task will never receive a response (the asynchronous
equivalent of a function call that never returns, i.e. hangs).
</p>
<p>The return value of <code>action</code> will be ignored.
</p>


<h3>Value</h3>

<p>A promise object (see <code><a href="chromote.html#topic+then">then</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a promise that resolves to a random value after 2 secs
p1 &lt;- promise(function(resolve, reject) {
  later::later(~resolve(runif(1)), delay = 2)
})

p1 %...&gt;% print()

# Create a promise that errors immediately
p2 &lt;- promise(~{
  reject("An error has occurred")
})
then(p2,
  onFulfilled = ~message("Success"),
  onRejected = ~message("Failure")
)

</code></pre>

<hr>
<h2 id='promise_all'>Combine multiple promise objects</h2><span id='topic+promise_all'></span><span id='topic+promise_race'></span>

<h3>Description</h3>

<p>Use <code>promise_all</code> to wait for multiple promise objects to all be successfully
fulfilled. Use <code>promise_race</code> to wait for the first of multiple promise
objects to be either fulfilled or rejected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>promise_all(..., .list = NULL)

promise_race(..., .list = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="promise_all_+3A_...">...</code></td>
<td>
<p>Promise objects. Either all arguments must be named, or all
arguments must be unnamed. If <code>.list</code> is provided, then these arguments are
ignored.</p>
</td></tr>
<tr><td><code id="promise_all_+3A_.list">.list</code></td>
<td>
<p>A list of promise objects&ndash;an alternative to <code>...</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A promise.
</p>
<p>For <code>promise_all</code>, if all of the promises were successful, the returned
promise will resolve to a list of the promises' values; if any promise
fails, the first error to be encountered will be used to reject the
returned promise.
</p>
<p>For <code>promise_race</code>, the first of the promises to either fulfill or reject
will be passed through to the returned promise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- promise(~later::later(~resolve(1), delay = 1))
p2 &lt;- promise(~later::later(~resolve(2), delay = 2))

# Resolves after 1 second, to the value: 1
promise_race(p1, p2) %...&gt;% {
  cat("promise_race:\n")
  str(.)
}

# Resolves after 2 seconds, to the value: list(1, 2)
promise_all(p1, p2) %...&gt;% {
  cat("promise_all:\n")
  str(.)
}

</code></pre>

<hr>
<h2 id='promise_map'>Promise-aware lapply/map</h2><span id='topic+promise_map'></span>

<h3>Description</h3>

<p>Similar to <code><a href="base.html#topic+lapply">base::lapply()</a></code> or <code><a href="purrr.html#topic+map">purrr::map</a></code>, but promise-aware: the <code>.f</code>
function is permitted to return promises, and while <code>lapply</code> returns a list,
<code>promise_map</code> returns a promise that resolves to a similar list (of resolved
values only, no promises).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>promise_map(.x, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="promise_map_+3A_.x">.x</code></td>
<td>
<p>A vector (atomic or list) or an expression object (but not a
promise). Other objects (including classed objects) will be coerced by
base::as.list.</p>
</td></tr>
<tr><td><code id="promise_map_+3A_.f">.f</code></td>
<td>
<p>The function to be applied to each element of <code>.x</code>. The function is
permitted, but not required, to return a promise.</p>
</td></tr>
<tr><td><code id="promise_map_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>.f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>promise_map</code> processes elements of <code>.x</code> serially; that is, if <code>.f(.x[[1]])</code>
returns a promise, then <code>.f(.x[[2]])</code> will not be invoked until that promise
is resolved. If any such promise rejects (errors), then the promise returned
by <code>promise_map</code> immediately rejects with that err.
</p>


<h3>Value</h3>

<p>A promise that resolves to a list (of values, not promises).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Waits x seconds, then returns x*10
wait_this_long &lt;- function(x) {
  promise(~later::later(~{
    resolve(x*10)
  }, delay = x))
}

promise_map(list(A=1, B=2, C=3), wait_this_long) %...&gt;%
  print()

</code></pre>

<hr>
<h2 id='promise_reduce'>Promise-aware version of Reduce</h2><span id='topic+promise_reduce'></span>

<h3>Description</h3>

<p>Similar to <code><a href="purrr.html#topic+reduce">purrr::reduce</a></code> (left fold), but the function <code>.f</code> is permitted
to return a promise. <code>promise_reduce</code> will wait for any returned promise to
resolve before invoking <code>.f</code> with the next element; in other words, execution
is serial. <code>.f</code> can return a promise as output but should never encounter a
promise as input (unless <code>.x</code> itself is a list of promises to begin with, in
which case the second parameter would be a promise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>promise_reduce(.x, .f, ..., .init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="promise_reduce_+3A_.x">.x</code></td>
<td>
<p>A vector or list to reduce. (Not a promise.)</p>
</td></tr>
<tr><td><code id="promise_reduce_+3A_.f">.f</code></td>
<td>
<p>A function that takes two parameters. The first parameter will be
the &quot;result&quot; (initially <code>.init</code>, and then set to the result of the most
recent call to <code>func</code>), and the second parameter will be an element of <code>.x</code>.</p>
</td></tr>
<tr><td><code id="promise_reduce_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code>.f</code></p>
</td></tr>
<tr><td><code id="promise_reduce_+3A_.init">.init</code></td>
<td>
<p>The initial result value of the fold, passed into <code>.f</code> when it
is first executed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A promise that will resolve to the result of calling <code>.f</code> on the last
element (or <code>.init</code> if <code>.x</code> had no elements). If any invocation of <code>.f</code>
results in an error or a rejected promise, then the overall
<code>promise_reduce</code> promise will immediately reject with that error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Returns a promise for the sum of e1 + e2, with a 0.5 sec delay
slowly_add &lt;- function(e1, e2) {
  promise(~later::later(~resolve(e1 + e2), delay = 0.5))
}

# Prints 55 after a little over 5 seconds
promise_reduce(1:10, slowly_add, .init = 0) %...&gt;% print()

</code></pre>

<hr>
<h2 id='promise_resolve'>Create a resolved or rejected promise</h2><span id='topic+promise_resolve'></span><span id='topic+promise_reject'></span>

<h3>Description</h3>

<p>Helper functions to conveniently create a promise that is resolved to the
given value (or rejected with the given reason).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>promise_resolve(value)

promise_reject(reason)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="promise_resolve_+3A_value">value</code></td>
<td>
<p>A value, or promise, that the new promise should be resolved to.
This expression will be lazily evaluated, and if evaluating the expression
raises an error, then the new promise will be rejected with that error as
the reason.</p>
</td></tr>
<tr><td><code id="promise_resolve_+3A_reason">reason</code></td>
<td>
<p>An error message string, or error object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>promise_resolve(mtcars) %...&gt;%
  head() %...&gt;%
  print()

promise_reject("Something went wrong") %...T!%
  { message(conditionMessage(.)) }

</code></pre>

<hr>
<h2 id='promises-package'>promises: Abstractions for Promise-Based Asynchronous Programming</h2><span id='topic+promises'></span><span id='topic+promises-package'></span>

<h3>Description</h3>

<p>Provides fundamental abstractions for doing asynchronous programming in R using promises. Asynchronous programming is useful for allowing a single R process to orchestrate multiple tasks in the background while also attending to something else. Semantics are similar to 'JavaScript' promises, but with a syntax that is idiomatic R.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joe Cheng <a href="mailto:joe@posit.co">joe@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://rstudio.github.io/promises/">https://rstudio.github.io/promises/</a>
</p>
</li>
<li> <p><a href="https://github.com/rstudio/promises">https://github.com/rstudio/promises</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rstudio/promises/issues">https://github.com/rstudio/promises/issues</a>
</p>
</li></ul>


<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic++25T+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code>, <code><a href="magrittr.html#topic+tee">%T&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='resolve'>Fulfill a promise</h2><span id='topic+resolve'></span><span id='topic+reject'></span>

<h3>Description</h3>

<p>Use these functions to satisfy a promise with either success (<code>resolve</code>)
or failure (<code>reject</code>). These functions are not exported, but rather, are
passed as arguments to the <code>action</code> function you pass to a <a href="base.html#topic+promise">promise</a>
constructor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve(value = NULL)

reject(reason)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve_+3A_value">value</code></td>
<td>
<p>The result from a successful calculation.</p>
</td></tr>
<tr><td><code id="resolve_+3A_reason">reason</code></td>
<td>
<p>An error or string that explains why the operation failed.</p>
</td></tr>
</table>

<hr>
<h2 id='then'>Access the results of a promise</h2><span id='topic+then'></span><span id='topic+catch'></span><span id='topic+finally'></span>

<h3>Description</h3>

<p>Use the <code>then</code> function to access the eventual result of a promise (or, if the operation fails, the reason for that failure). Regardless of the state of the promise, the call to <code>then</code> is non-blocking, that is, it returns immediately; so what it does <em>not</em> do is immediately return the result value of the promise. Instead, you pass logic you want to execute to <code>then</code>, in the form of function callbacks (or formulas, see Details). If you provide an <code>onFulfilled</code> callback, it will be called upon the promise's successful resolution, with a single argument <code>value</code>: the result value. If you provide an <code>onRejected</code> callback, it will be called if the operation fails, with a single argument <code>reason</code>: the error that caused the failure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>then(promise, onFulfilled = NULL, onRejected = NULL)

catch(promise, onRejected, tee = FALSE)

finally(promise, onFinally)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="then_+3A_promise">promise</code></td>
<td>
<p>A promise object. The object can be in any state.</p>
</td></tr>
<tr><td><code id="then_+3A_onfulfilled">onFulfilled</code></td>
<td>
<p>A function (or a formula&ndash;see Details) that will be
invoked if the promise value successfully resolves. When invoked, the
function will be called with a single argument: the resolved value.
Optionally, the function can take a second parameter <code>.visible</code> if you care
whether the promise was resolved with a visible or invisible value. The
function can return a value or a promise object, or can throw an error;
these will affect the resolution of the promise object that is returned
by <code>then()</code>.</p>
</td></tr>
<tr><td><code id="then_+3A_onrejected">onRejected</code></td>
<td>
<p>A function taking the argument <code>error</code> (or a formula&ndash;see
Details). The function can return a value or a promise object, or can throw
an error. If <code>onRejected</code> is provided and doesn't throw an error (or return
a promise that fails) then this is the async equivalent of catching an
error.</p>
</td></tr>
<tr><td><code id="then_+3A_tee">tee</code></td>
<td>
<p>If <code>TRUE</code>, ignore the return value of the callback, and use the
original value instead. This is useful for performing operations with
side-effects, particularly logging to the console or a file. If the
callback itself throws an error, and <code>tee</code> is <code>TRUE</code>, that error will still
be used to fulfill the the returned promise (in other words, <code>tee</code> only has
an effect if the callback does not throw).</p>
</td></tr>
<tr><td><code id="then_+3A_onfinally">onFinally</code></td>
<td>
<p>A function with no arguments, to be called when the async
operation either succeeds or fails. Usually used for freeing resources that
were used during async operations.</p>
</td></tr>
</table>


<h3>Formulas</h3>

<p>For convenience, the <code>then()</code>, <code>catch()</code>, and <code>finally()</code> functions use
<code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code> to convert <code>onFulfilled</code>, <code>onRejected</code>, and
<code>onFinally</code> arguments to functions. This means that you can use formulas to
create very compact anonymous functions, using <code>.</code> to access the value (in
the case of <code>onFulfilled</code>) or error (in the case of <code>onRejected</code>).
</p>


<h3>Chaining promises</h3>

<p>The first parameter of <code>then</code> is a promise; given the stated purpose of the
function, this should be no surprise. However, what may be surprising is that
the return value of <code>then</code> is also a (newly created) promise. This new
promise waits for the original promise to be fulfilled or rejected, and for
<code>onFulfilled</code> or <code>onRejected</code> to be called. The result of (or error raised
by) calling <code>onFulfilled</code>/<code>onRejected</code> will be used to fulfill (reject) the
new promise.
</p>
<div class="sourceCode"><pre>promise_a &lt;- get_data_frame_async()
promise_b &lt;- then(promise_a, onFulfilled = head)
</pre></div>
<p>In this example, assuming <code>get_data_frame_async</code> returns a promise that
eventually resolves to a data frame, <code>promise_b</code> will eventually resolve to
the first 10 or fewer rows of that data frame.
</p>
<p>Note that the new promise is considered fulfilled or rejected based on
whether <code>onFulfilled</code>/<code>onRejected</code> returns a value or throws an error, not on
whether the original promise was fulfilled or rejected. In other words, it's
possible to turn failure to success and success to failure. Consider this
example, where we expect <code>some_async_operation</code> to fail, and want to consider
it an error if it doesn't:
</p>
<div class="sourceCode"><pre>promise_c &lt;- some_async_operation()
promise_d &lt;- then(promise_c,
  onFulfilled = function(value) {
    stop("That's strange, the operation didn't fail!")
  },
  onRejected = function(reason) {
    # Great, the operation failed as expected
    NULL
  }
)
</pre></div>
<p>Now, <code>promise_d</code> will be rejected if <code>promise_c</code> is fulfilled, and vice
versa.
</p>
<p><strong>Warning:</strong> Be very careful not to accidentally turn failure into success,
if your error handling code is not the last item in a chain!
</p>
<div class="sourceCode"><pre>some_async_operation() %&gt;%
  catch(function(reason) {
    warning("An error occurred: ", reason)
  }) %&gt;%
  then(function() {
    message("I guess we succeeded...?")  # No!
  })
</pre></div>
<p>In this example, the <code>catch</code> callback does not itself throw an error, so the
subsequent <code>then</code> call will consider its promise fulfilled!
</p>


<h3>Convenience functions</h3>

<p>For readability and convenience, we provide <code>catch</code> and <code>finally</code> functions.
</p>
<p>The <code>catch</code> function is equivalent to <code>then</code>, but without the <code>onFulfilled</code>
argument. It is typically used at the end of a promise chain to perform error
handling/logging.
</p>
<p>The <code>finally</code> function is similar to <code>then</code>, but takes a single no-argument
function (or formula) that will be executed upon completion of the promise,
regardless of whether the result is success or failure. It is typically used
at the end of a promise chain to perform cleanup tasks, like closing file
handles or database connections. Unlike <code>then</code> and <code>catch</code>, the return value
of <code>finally</code> is ignored; however, if an error is thrown in <code>finally</code>, that
error will be propagated forward into the returned promise.
</p>


<h3>Visibility</h3>

<p><code>onFulfilled</code> functions can optionally have a second parameter <code>visible</code>,
which will be <code>FALSE</code> if the result value is <a href="base.html#topic+invisible">invisible</a>.
</p>

<hr>
<h2 id='with_promise_domain'>Promise domains</h2><span id='topic+with_promise_domain'></span><span id='topic+new_promise_domain'></span>

<h3>Description</h3>

<p>Promise domains are used to temporarily set up custom environments that
intercept and influence the registration of callbacks. Create new promise
domain objects using <code>new_promise_domain</code>, and temporarily activate a promise
domain object (for the duration of evaluating a given expression) using
<code>with_promise_domain</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_promise_domain(domain, expr, replace = FALSE)

new_promise_domain(
  wrapOnFulfilled = identity,
  wrapOnRejected = identity,
  wrapSync = force,
  onError = force,
  ...,
  wrapOnFinally = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_promise_domain_+3A_domain">domain</code></td>
<td>
<p>A promise domain object to install while <code>expr</code> is evaluated.</p>
</td></tr>
<tr><td><code id="with_promise_domain_+3A_expr">expr</code></td>
<td>
<p>Any R expression, to be evaluated under the influence of
<code>domain</code>.</p>
</td></tr>
<tr><td><code id="with_promise_domain_+3A_replace">replace</code></td>
<td>
<p>If <code>FALSE</code>, then the effect of the <code>domain</code> will be added
to the effect of any currently active promise domain(s). If <code>TRUE</code>, then
the current promise domain(s) will be ignored for the duration of the
<code>with_promise_domain</code> call.</p>
</td></tr>
<tr><td><code id="with_promise_domain_+3A_wraponfulfilled">wrapOnFulfilled</code></td>
<td>
<p>A function that takes a single argument: a function
that was passed as an <code>onFulfilled</code> argument to <code><a href="chromote.html#topic+then">then()</a></code>. The
<code>wrapOnFulfilled</code> function should return a function that is suitable for
<code>onFulfilled</code> duty.</p>
</td></tr>
<tr><td><code id="with_promise_domain_+3A_wraponrejected">wrapOnRejected</code></td>
<td>
<p>A function that takes a single argument: a function
that was passed as an <code>onRejected</code> argument to <code><a href="chromote.html#topic+then">then()</a></code>. The
<code>wrapOnRejected</code> function should return a function that is suitable for
<code>onRejected</code> duty.</p>
</td></tr>
<tr><td><code id="with_promise_domain_+3A_wrapsync">wrapSync</code></td>
<td>
<p>A function that takes a single argument: a (lazily evaluated)
expression that the function should <code><a href="base.html#topic+force">force()</a></code>. This expression represents
the <code>expr</code> argument passed to <code><a href="promises.html#topic+with_promise_domain">with_promise_domain()</a></code>; <code>wrapSync</code> allows
the domain to manipulate the environment before/after <code>expr</code> is evaluated.</p>
</td></tr>
<tr><td><code id="with_promise_domain_+3A_onerror">onError</code></td>
<td>
<p>A function that takes a single argument: an error. <code>onError</code>
will be called whenever an exception occurs in a domain (that isn't caught
by a <code>tryCatch</code>). Providing an <code>onError</code> callback doesn't cause errors to
be caught, necessarily; instead, <code>onError</code> callbacks behave like calling
handlers.</p>
</td></tr>
<tr><td><code id="with_promise_domain_+3A_...">...</code></td>
<td>
<p>Arbitrary named values that will become elements of the promise
domain object, and can be accessed as items in an environment (i.e. using
<code>[[</code> or <code>$</code>).</p>
</td></tr>
<tr><td><code id="with_promise_domain_+3A_wraponfinally">wrapOnFinally</code></td>
<td>
<p>A function that takes a single argument: a function
that was passed as an <code>onFinally</code> argument to <code><a href="chromote.html#topic+then">then()</a></code>. The
<code>wrapOnFinally</code> function should return a function that is suitable for
<code>onFinally</code> duty. If <code>wrapOnFinally</code> is <code>NULL</code> (the default), then the
domain will use both <code>wrapOnFulfilled</code> and <code>wrapOnRejected</code> to wrap the
<code>onFinally</code>. If it's important to distinguish between normal
fulfillment/rejection handlers and finally handlers, then be sure to
provide <code>wrapOnFinally</code>, even if it's just <code><a href="base.html#topic+identity">base::identity()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code>with_promise_domain</code> is on the call stack, any calls to <code><a href="chromote.html#topic+then">then()</a></code> (or
higher level functions or operators, like <code><a href="chromote.html#topic+catch">catch()</a></code> or the various <a href="promises.html#topic+pipes">pipes</a>)
will belong to the promise domain. In addition, when a <code>then</code> callback that
belongs to a promise domain is invoked, then any new calls to <code>then</code> will
also belong to that promise domain. In other words, a promise domain
&quot;infects&quot; not only the immediate calls to <code>then</code>, but also to &quot;nested&quot; calls
to <code>then</code>.
</p>
<p>For more background, read the
<a href="https://gist.github.com/jcheng5/b1c87bb416f6153643cd0470ac756231">original design doc</a>.
</p>
<p>For examples, see the source code of the Shiny package, which uses promise
domains extensively to manage graphics devices and reactivity.
</p>

<hr>
<h2 id='WorkQueue'>Future promise work queue</h2><span id='topic+WorkQueue'></span>

<h3>Description</h3>

<p>Future promise work queue
</p>
<p>Future promise work queue
</p>


<h3>Details</h3>

<p>#' <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>An <span class="pkg">R6</span> class to help with scheduling work to be completed. <code>WorkQueue</code> will only execute work if the <code>can_proceed()</code> returns <code>TRUE</code>. For the use case of <code>future</code>, <code>can_proceed()</code> defaults to <code>future::nbrOfFreeWorkers() &gt; 0</code> which will not allow for work to be executed if a <span class="pkg">future</span> worker is not available.
</p>
<p><code>WorkQueue</code> will constantly try to start new work once prior work item finishes.  However, if <code>can_proceed()</code> returns <code>FALSE</code> (no future workers are available) and there is more work to be done, then work is attempted later a random amount of time later using exponential backoff.  The exponential backoff will cap out at 10 seconds to prevent unnecessarily large wait times.
</p>
<p>Each time <code>WorkQueue</code> tries to start more work, it will repeat until <code>can_proceed()</code> returns <code>FALSE</code> or there is no more work in the <code>queue</code>.
</p>


<h3>Global event loop</h3>

<p>The global loop is used by default as the internal <code>WorkQueue</code> &quot;delayed check&quot; uses a single delay check for the whole queue, rather than having each item in the queue attempt to process.
This behavior might change in the future, but we are not exactly sure how at this point.
</p>
<p>If a private <code>later</code> loop wants to become synchronous by running until all jobs are completed but is waiting on a <code>future_promise()</code>, the private loop will not complete unless the global loop is allowed to move forward.
</p>
<p>However, it is possible to use a private loop inside a user-defined <code>WorkQueue</code> may work which can be provided directly to <code>future_promise(queue=custom_queue)</code>. Having a concrete example (or need) will help us understand the problem better. If you have an example, please reach out .
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WorkQueue-new"><code>WorkQueue$new()</code></a>
</p>
</li>
<li> <p><a href="#method-WorkQueue-schedule_work"><code>WorkQueue$schedule_work()</code></a>
</p>
</li>
<li> <p><a href="#method-WorkQueue-clone"><code>WorkQueue$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-WorkQueue-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>WorkQueue</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>WorkQueue$new(
  can_proceed = future_worker_is_free,
  queue = fastmap::fastqueue(),
  loop = later::global_loop()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>can_proceed</code></dt><dd><p>Function that should return a logical value. If <code>TRUE</code> is returned, then the next scheduled work will be executed. By default, this function checks if <code><a href="future.html#topic+nbrOfWorkers">future::nbrOfFreeWorkers()</a> &gt; 0</code></p>
</dd>
<dt><code>queue</code></dt><dd><p>Queue object to use to store the scheduled work. By default, this is a &quot;First In, First Out&quot; queue using <code><a href="fastmap.html#topic+fastqueue">fastmap::fastqueue()</a></code>. If using your own queue, it should have the methods <code style="white-space: pre;">&#8288;$add(x)&#8288;</code>, <code style="white-space: pre;">&#8288;$remove()&#8288;</code>, <code style="white-space: pre;">&#8288;$size()&#8288;</code>.</p>
</dd>
<dt><code>loop</code></dt><dd><p><span class="pkg">later</span> loop to use for calculating the next delayed check. Defaults to <code><a href="later.html#topic+create_loop">later::global_loop()</a></code>.
Schedule work</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WorkQueue-schedule_work"></a>



<h4>Method <code>schedule_work()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>WorkQueue$schedule_work(fn)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fn</code></dt><dd><p>function to execute when <code>can_proceed()</code> returns <code>TRUE</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-WorkQueue-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WorkQueue$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="promises.html#topic+future_promise_queue">future_promise_queue()</a></code> which returns a <code>WorkQueue</code> which is cached per R session.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
