<!DOCTYPE html><html><head><title>Help for package xegaGaGene</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xegaGaGene}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Gray2Bin'><p>Map Gray code to binary.</p></a></li>
<li><a href='#lFxegaGaGene'><p>The local function list lFxegaGaGene.</p></a></li>
<li><a href='#without'><p>Returns elements of</p>
vector <code>x</code> without elements in <code>y</code>.</a></li>
<li><a href='#xegaGaCross2Gene'><p>One point crossover of 2 genes.</p></a></li>
<li><a href='#xegaGaCrossGene'><p>One point crossover of 2 genes.</p></a></li>
<li><a href='#xegaGaCrossoverFactory'><p>Configure the crossover function of a genetic algorithm.</p></a></li>
<li><a href='#xegaGaDecodeGene'><p>Decode a gene.</p></a></li>
<li><a href='#xegaGaGene'><p>Package xegaGaGene.</p></a></li>
<li><a href='#xegaGaGeneMap'><p>Map the bit strings of a binary gene to parameters in an interval.</p></a></li>
<li><a href='#xegaGaGeneMapFactory'><p>Configure the gene map function of a genetic algorithm.</p></a></li>
<li><a href='#xegaGaGeneMapGray'><p>Map the bit strings of a gray-coded gene to parameters in an interval.</p></a></li>
<li><a href='#xegaGaGeneMapIdentity'><p>Map the bit strings of a binary gene to an identical bit vector.</p></a></li>
<li><a href='#xegaGaGeneMapPerm'><p>Map the bit strings of a binary gene to a permutation.</p></a></li>
<li><a href='#xegaGaInitGene'><p>Generate a random binary gene.</p></a></li>
<li><a href='#xegaGaIVAdaptiveMutateGene'><p>Individually variable adaptive mutation of a gene.</p></a></li>
<li><a href='#xegaGaMutateGene'><p>Mutate a gene.</p></a></li>
<li><a href='#xegaGaMutationFactory'><p>Configure the mutation function of a genetic algorithm.</p></a></li>
<li><a href='#xegaGaReplicate2Gene'><p>Replicates a gene.</p></a></li>
<li><a href='#xegaGaReplicateGene'><p>Replicates a gene.</p></a></li>
<li><a href='#xegaGaReplicationFactory'><p>Configure the replication function of a genetic algorithm.</p></a></li>
<li><a href='#xegaGaUCross2Gene'><p>Uniform crossover of 2 genes.</p></a></li>
<li><a href='#xegaGaUCrossGene'><p>Uniform crossover of 2 genes.</p></a></li>
<li><a href='#xegaGaUPCross2Gene'><p>Parameterized uniform crossover of 2 genes.</p></a></li>
<li><a href='#xegaGaUPCrossGene'><p>Parameterized uniform crossover of 2 genes.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Binary Gene Operations for Genetic Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Representation-dependent gene level operations of a 
        genetic algorithm with binary coded genes:
        Initialization of random binary genes, several gene maps for 
        binary genes, several mutation operators, several crossover
        operators with 1 and 2 kids, replication 
        pipelines for 1 and 2 kids, and, last but not least, function 
        factories for configuration. 
        See Goldberg, D. E. (1989, ISBN:0-201-15767-5).
        For crossover operators, see 
        Syswerda, G. (1989, ISBN:1-55860-066-3),
        Spears, W. and De Jong, K. (1991, ISBN:1-55860-208-9).
        For mutation operators, see 
        Stanhope, S. A. and Daida, J. M. (1996, ISBN:0-18-201-031-7).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/ageyerschulz/xegaGaGene&amp;gt;">https://github.com/ageyerschulz/xegaGaGene&gt;</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>xegaSelectGene</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 09:12:52 UTC; dj2333</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Geyer-Schulz
    <a href="https://orcid.org/0009-0000-5237-3579"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Geyer-Schulz &lt;Andreas.Geyer-Schulz@kit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-07 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Gray2Bin'>Map Gray code to binary.</h2><span id='topic+Gray2Bin'></span>

<h3>Description</h3>

<p>Map Gray code to binary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gray2Bin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gray2Bin_+3A_x">x</code></td>
<td>
<p>Gray code (boolean vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Start with the highest order bit, and 
<code>r[k-i]&lt;- xor(n[k], n[k-1])</code>.
</p>


<h3>Value</h3>

<p>Binary code (boolean vector).
</p>


<h3>References</h3>

<p>Gray, Frank (1953):
Pulse Code Communication. US Patent 2 632 058.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Gray2Bin(c(1, 0, 0, 0))
 Gray2Bin(c(1, 1, 1, 1))
</code></pre>

<hr>
<h2 id='lFxegaGaGene'>The local function list lFxegaGaGene.</h2><span id='topic+lFxegaGaGene'></span>

<h3>Description</h3>

<p>We enhance the configurability of our code by introducing 
a function factory. The  function factory contains
all the functions that are needed for defining
local functions in genetic operators. The local function  
list keeps the signatures of functions (e.g. mutation functions)
uniform and small. At the same time, variants of functions
can use different local functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lFxegaGaGene
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 28.
</p>


<h3>Details</h3>

<p>We use the local function list for 
</p>

<ol>
<li>
<p>replacing all constants by constant functions.
</p>
<p>Rationale: We need one formal argument (the local function list lF)
and we can dispatch multiple functions. E.g.  <code>lF$verbose()</code>
</p>
</li>
<li>    
<p>dynamically binding a local function with a definition from a
proper function factory. E.g., the selection methods 
<code>lf$SelectGene</code> and <code>SelectMate</code>.
</p>
</li>
<li><p> gene representations which require special functions to handle them:
<code>lf$InitGene</code>, <code>lF$DecodeGene</code>, <code>lf$EvalGene</code>
<code>lf$ReplicateGene</code>, ...
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+xegaGaCrossoverFactory">xegaGaCrossoverFactory</a>()</code>,
<code><a href="#topic+xegaGaGeneMapFactory">xegaGaGeneMapFactory</a>()</code>,
<code><a href="#topic+xegaGaMutationFactory">xegaGaMutationFactory</a>()</code>,
<code><a href="#topic+xegaGaReplicationFactory">xegaGaReplicationFactory</a>()</code>
</p>

<hr>
<h2 id='without'>Returns elements of
vector <code>x</code> without elements in <code>y</code>.</h2><span id='topic+without'></span>

<h3>Description</h3>

<p>Returns elements of
vector <code>x</code> without elements in <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>without(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="without_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="without_+3A_y">y</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-sample(1:15,15, replace=FALSE)
b&lt;-c(1, 3, 5)
without(a, b)
</code></pre>

<hr>
<h2 id='xegaGaCross2Gene'>One point crossover of 2 genes.</h2><span id='topic+xegaGaCross2Gene'></span>

<h3>Description</h3>

<p><code>xegaGaCross2Gene</code> randomly determines a cut point.
It combines the bits before the cut point of the first gene
with the bits after the cut point from the second gene (kid 1).
It combines the bits before the cut point of the second gene
with the bits after the cut point from the first gene (kid 2).
It returns 2  genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaCross2Gene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaCross2Gene_+3A_gg1">gg1</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaCross2Gene_+3A_gg2">gg2</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaCross2Gene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 binary genes.
</p>


<h3>See Also</h3>

<p>Other Crossover (2): 
<code><a href="#topic+xegaGaUCross2Gene">xegaGaUCross2Gene</a>()</code>,
<code><a href="#topic+xegaGaUPCross2Gene">xegaGaUPCross2Gene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGaInitGene(lFxegaGaGene)
gene2&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaDecodeGene(gene1, lFxegaGaGene)
xegaGaDecodeGene(gene2, lFxegaGaGene)
newgenes&lt;-xegaGaCross2Gene(gene1, gene2, lFxegaGaGene)
xegaGaDecodeGene(newgenes[[1]], lFxegaGaGene)
xegaGaDecodeGene(newgenes[[2]], lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaCrossGene'>One point crossover of 2 genes.</h2><span id='topic+xegaGaCrossGene'></span>

<h3>Description</h3>

<p><code>xegaGaCrossGene</code> randomly determines a cut point.
It combines the bits before the cut point of the first gene
with the bits after the cut point from the second gene (kid 1).
It combines the bits before the cut point of the second gene
with the bits after the cut point from the first gene (kid 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaCrossGene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaCrossGene_+3A_gg1">gg1</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaCrossGene_+3A_gg2">gg2</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaCrossGene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of one binary gene.
</p>


<h3>See Also</h3>

<p>Other Crossover (1): 
<code><a href="#topic+xegaGaUCrossGene">xegaGaUCrossGene</a>()</code>,
<code><a href="#topic+xegaGaUPCrossGene">xegaGaUPCrossGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGaInitGene(lFxegaGaGene)
gene2&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaDecodeGene(gene1, lFxegaGaGene)
xegaGaDecodeGene(gene2, lFxegaGaGene)
gene3&lt;-xegaGaCrossGene(gene1, gene2, lFxegaGaGene)
xegaGaDecodeGene(gene3[[1]], lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaCrossoverFactory'>Configure the crossover function of a genetic algorithm.</h2><span id='topic+xegaGaCrossoverFactory'></span>

<h3>Description</h3>

<p><code>xegaGaCrossoverFactory</code> implements the selection
of one of the crossover functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error) if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> Crossover functions with two kids:
</p>

<ol>
<li><p> &quot;Cross2Gene&quot; returns <code>xegaGaCross2Gene</code>.
</p>
</li>
<li><p> &quot;UCross2Gene&quot; returns <code>xegaGaUCross2Gene</code>.
</p>
</li>
<li><p> &quot;PUCross2Gene&quot; returns <code>xegaGaUPCross2Gene</code>.
</p>
</li></ol>

</li>
<li><p> Crossover functions with one kid:
</p>

<ol>
<li><p> &quot;CrossGene&quot; returns <code>xegaGaCrossGene</code>.
</p>
</li>
<li><p> &quot;UCrossGene&quot; returns <code>xegaGaUCrossGene</code>.
</p>
</li>
<li><p> &quot;PUCrossGene&quot; returns <code>xegaGaUPCrossGene</code>.
</p>
</li></ol>

</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaGaCrossoverFactory(method = "Cross2Gene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaCrossoverFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the crossover function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A crossover function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+lFxegaGaGene">lFxegaGaGene</a></code>,
<code><a href="#topic+xegaGaGeneMapFactory">xegaGaGeneMapFactory</a>()</code>,
<code><a href="#topic+xegaGaMutationFactory">xegaGaMutationFactory</a>()</code>,
<code><a href="#topic+xegaGaReplicationFactory">xegaGaReplicationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XGene&lt;-xegaGaCrossoverFactory("Cross2Gene")
gene1&lt;-xegaGaInitGene(lFxegaGaGene)
gene2&lt;-xegaGaInitGene(lFxegaGaGene)
XGene(gene1, gene2, lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaDecodeGene'>Decode a gene.</h2><span id='topic+xegaGaDecodeGene'></span>

<h3>Description</h3>

<p><code>xegaGaDecodeGene</code> decodes a binary gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaDecodeGene(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaDecodeGene_+3A_gene">gene</code></td>
<td>
<p>A binary gene (the genotype).</p>
</td></tr>
<tr><td><code id="xegaGaDecodeGene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The decoded gene (the phenotype).
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+xegaGaGeneMapGray">xegaGaGeneMapGray</a>()</code>,
<code><a href="#topic+xegaGaGeneMapIdentity">xegaGaGeneMapIdentity</a>()</code>,
<code><a href="#topic+xegaGaGeneMapPerm">xegaGaGeneMapPerm</a>()</code>,
<code><a href="#topic+xegaGaGeneMap">xegaGaGeneMap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaDecodeGene(gene, lFxegaGaGene)

</code></pre>

<hr>
<h2 id='xegaGaGene'>Package xegaGaGene.</h2><span id='topic+xegaGaGene'></span>

<h3>Description</h3>

<p>Genetic operations for binary coded genetic algorithms.
</p>


<h3>Details</h3>

<p>For an introduction to this class of algorithms, see Goldberg, D. (1989).
</p>
<p>For binary-coded genes, the <code>xegaGaGene</code> package provides
</p>

<ul>
<li><p> Gene initiatilization.
</p>
</li>
<li><p> Decoding of parameters as well as a function factory for configuration.
</p>
</li>
<li><p> Mutation functions as well as a function factory for configuration.
</p>
</li>
<li><p> Crossover functions as well as a function factory for configuration.
We provide two families of crossover functions:
</p>

<ol>
<li><p> Crossover functions with two kids:
Crossover preserves the genetic information in the gene pool.
</p>
</li>
<li><p> Crossover functions with one kid:
These functions allow the construction of gene evaluation pipelines.
One advantage of this is a simple control structure 
at the population level.
</p>
</li>
<li><p> Gene replication functions as well as a function factory for 
configuration. The replication functions implement control flows
for sequences of gene operations. For <code>xegaReplicateGene</code>, 
an acceptance step has been added. Simulated annealing algorithms
can be configured e.g. by configuring uniform random selection combined
with a Metropolis Acceptance Rule and a suitable cooling schedule.
</p>
</li></ol>

</li></ul>



<h3>Binary Gene Representation</h3>

<p>A binary gene is a named list:
</p>

<ul>
<li><p> $gene1      the gene must be a binary vector.
</p>
</li>
<li><p> $fit        the fitness value of the gene
(for EvalGeneDet and EvalGeneU) or
the mean fitness (for stochastic functions
evaluated with EvalGeneStoch).
</p>
</li>
<li><p> $evaluated  has the gene been evaluated?
</p>
</li>
<li><p> $evalFail   has the evaluation of the gene failed?
</p>
</li>
<li><p> $var        the cumulative variance of the fitness 
of all evaluations of a gene.
(For stochastic functions)
</p>
</li>
<li><p> $sigma      the standard deviation of the fitness of 
all evaluations of a gene.
(For stochastic functions)
</p>
</li>
<li><p> $obs        the number of evaluations of a gene.
(For stochastic functions)
</p>
</li></ul>



<h3>Abstract Interface of Problem Environment</h3>

<p>A problem environment <code>penv</code> must provide:
</p>

<ul>
<li> <p><code>$f(parameters, gene, lF)</code>: 
Function with a real parameter vector as first argument 
which returns a gene 
with evaluated fitness.
</p>
</li>
<li><p> $genelength(): The number of bits of the binary-coded
real parameter vector. Used in <code>InitGene</code>.
</p>
</li>
<li><p> $bitlength(): A vector specifying the number of bits 
used for coding each real parameter.
If <code>penv$bitlength()[1]</code> is <code>20</code>, 
then <code>parameters[1]</code> is coded by 20 bits.
Used in <code>GeneMap</code>.
</p>
</li>
<li><p> $lb(): The lower bound vector of each parameter.
Used in <code>GeneMap</code>.
</p>
</li>
<li><p> $ub(): The upper bound vector of each parameter.
Used in <code>GeneMap</code>.
</p>
</li></ul>



<h3>Abstract Interface of Mutation Functions</h3>

<p>Each mutation function has the following function signature:
</p>
<p>newGene&lt;-Mutate(gene, lF) 
</p>
<p>All local parameters of the mutation function configured are 
expected in the local function list lF.
</p>


<h3>Local Constants of Mutation Functions</h3>

<p>The local constants of a mutation function determine 
the behavior of the function. 
</p>

<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$BitMutationRate1 </td><td style="text-align: center;"> 0.005          </td><td style="text-align: left;"> MutateGene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                    </td><td style="text-align: center;">                </td><td style="text-align: left;"> IVAdaptiveMutateGene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$BitMutationRate2 </td><td style="text-align: center;"> 0.01           </td><td style="text-align: left;"> IVAdaptiveMutateGene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$CutoffFit        </td><td style="text-align: center;"> 0.5            </td><td style="text-align: left;"> IVADaptiveMutateGene </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Abstract Interface of Crossover Functions</h3>

<p>The signatures of the abstract interface to the 2 families 
of crossover functions are:
</p>
<p>ListOfTwoGenes&lt;-Crossover2(gene1, gene2, lF) 
</p>
<p>ListOfOneGene&lt;-Crossover(gene1, gene2, lF) 
</p>
<p>All local parameters of the crossover function configured are 
expected in the local function list lF.
</p>


<h3>Local Constants of Crossover Functions</h3>

<p>The local constants of a crossover function determine the 
the behavior of the function. 
</p>

<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$UCrossSwap     </td><td style="text-align: center;"> 0.2              </td><td style="text-align: left;"> UPCross2Gene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                    </td><td style="text-align: center;">                </td><td style="text-align: left;"> UPCrossGene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>



<h3>Abstract Interface of Gene Replication Functions</h3>

<p>The signatures of the abstract interface to the 2 
gene replication functions are:
</p>
<p>ListOfTwoGenes&lt;-Replicate2Gene(gene1, gene2, lF) 
</p>
<p>ListOfOneGene&lt;-ReplicateGene(gene1, gene2, lF)
</p>


<h3>Configuration and Constants of Replication Functions</h3>

<p><strong>Configuration for ReplicateGene (1 Kid, Default).</strong>
</p>

<table>
<tr>
 <td style="text-align: right;"> 
<strong>Function</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> Configured By </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$SelectGene     </td><td style="text-align: center;"> SelectSUS        </td><td style="text-align: left;"> SelectGeneFactory </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$SelectMate     </td><td style="text-align: center;"> SelectSUS        </td><td style="text-align: left;"> SelectGeneFactory </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$CrossGene      </td><td style="text-align: center;"> CrossGene        </td><td style="text-align: left;"> xegaGaCrossoverFactory </td>
</tr>
<tr>
 <td style="text-align: right;">
lF$MutateGene     </td><td style="text-align: center;"> MutateGene       </td><td style="text-align: left;"> xegaGaMutationFactory </td>
</tr>
<tr>
 <td style="text-align: right;">
lF$Accept         </td><td style="text-align: center;"> AcceptNewGene    </td><td style="text-align: left;"> AcceptFactory </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><strong>Configuration for Replicate2Gene (2 Kids).</strong>
</p>

<table>
<tr>
 <td style="text-align: right;"> 
<strong>Function</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> Configured By </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$SelectGene     </td><td style="text-align: center;"> SelectSUS        </td><td style="text-align: left;"> SelectGeneFactory </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$SelectMate     </td><td style="text-align: center;"> SelectSUS        </td><td style="text-align: left;"> SelectGeneFactory </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$CrossGene      </td><td style="text-align: center;"> CrossGene        </td><td style="text-align: left;"> xegaGaCrossoverFactory </td>
</tr>
<tr>
 <td style="text-align: right;">
lF$MutateGene     </td><td style="text-align: center;"> MutateGene       </td><td style="text-align: left;"> xegaGaMutationFactory </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><strong>Global Constants.</strong>
</p>
<p>Global constants specify the probability that a mutation or
crossover operator is applied to a gene.
In the xega-architecture, these rates can be configured to be 
adaptive.
</p>

<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$MutationRate   </td><td style="text-align: center;"> 1.0 (static)     </td><td style="text-align: left;"> xegaGaReplicateGene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                  </td><td style="text-align: center;">                  </td><td style="text-align: left;"> xegaGaReplicate2Gene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$CrossRate      </td><td style="text-align: center;"> 0.2 (static)     </td><td style="text-align: left;"> xegaGaReplicateGene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                  </td><td style="text-align: center;">                  </td><td style="text-align: left;"> xegaGaReplicate2Gene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>

<p><strong>Local Constants.</strong>
</p>

<table>
<tr>
 <td style="text-align: right;"> 
<strong>Constant</strong> </td><td style="text-align: center;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Used in</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$BitMutationRate1 </td><td style="text-align: center;"> 0.005          </td><td style="text-align: left;"> MutateGene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                    </td><td style="text-align: center;">                </td><td style="text-align: left;"> IVAdaptiveMutateGene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$BitMutationRate2 </td><td style="text-align: center;"> 0.01           </td><td style="text-align: left;"> IVAdaptiveMutateGene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
lF$CutoffFit        </td><td style="text-align: center;"> 0.5            </td><td style="text-align: left;"> IVADaptiveMutateGene </td>
</tr>
<tr>
 <td style="text-align: right;">
lF$UCrossSwap     </td><td style="text-align: center;"> 0.2              </td><td style="text-align: left;"> UPCross2Gene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
                    </td><td style="text-align: center;">                </td><td style="text-align: left;"> UPCrossGene </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>

<p>In the xega-architecture, these rates can be configured to be 
adaptive.
</p>


<h3>The Architecture of the xegaX-Packages</h3>

<p>The xegaX-packages are a family of R-packages which implement 
eXtended Evolutionary and Genetic Algorithms (xega).  
The architecture has 3 layers, 
namely the user interface layer,
the population layer, and the gene layer: 
</p>

<ul>
<li>
<p>The user interface layer (package <code>xega</code>) 
provides a function call interface and configuration support
for several algorithms: genetic algorithms (sga), 
permutation-based genetic algorithms (sgPerm), 
derivation-free algorithms as e.g. differential evolution (sgde), 
grammar-based genetic programming (sgp) and grammatical evolution
(sge). 
</p>
</li>
<li>
<p>The population layer (package <code>xegaPopulation</code>) contains
population-related functionality as well as support for 
population statistics dependent adaptive mechanisms and parallelization.
</p>
</li>
<li> 
<p>The gene layer is split into a representation-independent and 
a representation-dependent part:
</p>

<ol>
<li> 
<p>The representation indendent part (package <code>xegaSelectGene</code>)
is responsible for variants of selection operators, evaluation 
strategies for genes, as well as profiling and timing capabilities.        
</p>
</li>
<li> 
<p>The representation dependent part consists of the following packages: 
</p>

<ul>
<li> <p><code>xegaGaGene</code> for binary coded genetic algorithms.
</p>
</li>
<li> <p><code>xegaPermGene</code> for permutation-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaDfGene</code> for derivation-free algorithms as e.g. 
differential evolution.
</p>
</li>
<li> <p><code>xegaGpGene</code> for grammar-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaGeGene</code> for grammatical evolution algorithms.
</p>
</li></ul>

<p>The packages <code>xegaDerivationTrees</code> and <code>xegaBNF</code> support
the last two packages:
<code>xegaBNF</code> essentially provides a grammar compiler, and 
<code>xegaDerivationTrees</code> is an abstract data type for derivation trees.
</p>
</li></ol>
</li></ul>



<h3>Copyright</h3>

<p>(c) 2023 Andreas Geyer-Schulz
</p>


<h3>License</h3>

<p>MIT
</p>


<h3>URL</h3>

<p>&lt;https://github.com/ageyerschulz/xegaGaGene&gt;
</p>


<h3>Installation</h3>

<p>From CRAN by <code>install.packages('xegaGaGene')</code>
</p>


<h3>Author(s)</h3>

<p>Andreas Geyer-Schulz
</p>


<h3>References</h3>

<p>Goldberg, David E. (1989)
Genetic Algorithms in Search, Optimization and Machine Learning.
Addison-Wesley, Reading. 
(ISBN:0-201-15767-5)
</p>

<hr>
<h2 id='xegaGaGeneMap'>Map the bit strings of a binary gene to parameters in an interval.</h2><span id='topic+xegaGaGeneMap'></span>

<h3>Description</h3>

<p><code>xegaGaGenemap</code> maps the bit strings of a binary string 
to parameters in an interval.
Bit vectors are mapped into equispaced numbers in the interval.
Examples: Optimization of problems with real-valued 
parameter vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaGeneMap(gene, penv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaGeneMap_+3A_gene">gene</code></td>
<td>
<p>A binary gene (the genotype).</p>
</td></tr>
<tr><td><code id="xegaGaGeneMap_+3A_penv">penv</code></td>
<td>
<p>A problem environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The decoded gene (the phenotype).
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+xegaGaDecodeGene">xegaGaDecodeGene</a>()</code>,
<code><a href="#topic+xegaGaGeneMapGray">xegaGaGeneMapGray</a>()</code>,
<code><a href="#topic+xegaGaGeneMapIdentity">xegaGaGeneMapIdentity</a>()</code>,
<code><a href="#topic+xegaGaGeneMapPerm">xegaGaGeneMapPerm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaGeneMap(gene$gene1, lFxegaGaGene$penv)

</code></pre>

<hr>
<h2 id='xegaGaGeneMapFactory'>Configure the gene map function of a genetic algorithm.</h2><span id='topic+xegaGaGeneMapFactory'></span>

<h3>Description</h3>

<p><code>xegaGaGeneMapFactory</code> implements the selection
of one of the GeneMap functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error) if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;Bin2Dec&quot; returns <code>GeneMap</code>. (Default).
</p>
</li>
<li><p> &quot;Gray2Dec&quot; returns <code>GeneMapGray</code>.
</p>
</li>
<li><p> &quot;Identity&quot; returns <code>GeneMapIdentity</code>.
</p>
</li>
<li><p> &quot;Permutation&quot; returns <code>GeneMapPerm</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaGaGeneMapFactory(method = "Bin2Dec")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaGeneMapFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the GeneMap function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gene map function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+lFxegaGaGene">lFxegaGaGene</a></code>,
<code><a href="#topic+xegaGaCrossoverFactory">xegaGaCrossoverFactory</a>()</code>,
<code><a href="#topic+xegaGaMutationFactory">xegaGaMutationFactory</a>()</code>,
<code><a href="#topic+xegaGaReplicationFactory">xegaGaReplicationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XGene&lt;-xegaGaGeneMapFactory("Identity")
gene1&lt;-xegaGaInitGene(lFxegaGaGene)
XGene(gene1, lFxegaGaGene$penv)
</code></pre>

<hr>
<h2 id='xegaGaGeneMapGray'>Map the bit strings of a gray-coded gene to parameters in an interval.</h2><span id='topic+xegaGaGeneMapGray'></span>

<h3>Description</h3>

<p><code>xegaGaGenemapGray</code> maps the bit strings of 
a binary string 
interpreted as Gray codes to parameters in an interval.
Bit vectors are mapped into equispaced numbers in the interval.
Examples: Optimization of problems with real-valued 
parameter vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaGeneMapGray(gene, penv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaGeneMapGray_+3A_gene">gene</code></td>
<td>
<p>A binary gene (the genotype).</p>
</td></tr>
<tr><td><code id="xegaGaGeneMapGray_+3A_penv">penv</code></td>
<td>
<p>A problem environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The decoded gene (the phenotype).
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+xegaGaDecodeGene">xegaGaDecodeGene</a>()</code>,
<code><a href="#topic+xegaGaGeneMapIdentity">xegaGaGeneMapIdentity</a>()</code>,
<code><a href="#topic+xegaGaGeneMapPerm">xegaGaGeneMapPerm</a>()</code>,
<code><a href="#topic+xegaGaGeneMap">xegaGaGeneMap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaGeneMapGray(gene$gene1, lFxegaGaGene$penv)

</code></pre>

<hr>
<h2 id='xegaGaGeneMapIdentity'>Map the bit strings of a binary gene to an identical bit vector.</h2><span id='topic+xegaGaGeneMapIdentity'></span>

<h3>Description</h3>

<p><code>xegaGaGenemapIdentity</code> maps the bit strings 
of a binary vector
to an identical binary vector.
Faster for all problems with single-bit coding.
Examples: Knapsack, Number Partitioning into 2 partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaGeneMapIdentity(gene, penv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaGeneMapIdentity_+3A_gene">gene</code></td>
<td>
<p>A binary gene (the genotype).</p>
</td></tr>
<tr><td><code id="xegaGaGeneMapIdentity_+3A_penv">penv</code></td>
<td>
<p>A problem environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The decoded gene (the phenotype).
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+xegaGaDecodeGene">xegaGaDecodeGene</a>()</code>,
<code><a href="#topic+xegaGaGeneMapGray">xegaGaGeneMapGray</a>()</code>,
<code><a href="#topic+xegaGaGeneMapPerm">xegaGaGeneMapPerm</a>()</code>,
<code><a href="#topic+xegaGaGeneMap">xegaGaGeneMap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaGeneMapIdentity(gene$gene1, lFxegaGaGene$penv)

</code></pre>

<hr>
<h2 id='xegaGaGeneMapPerm'>Map the bit strings of a binary gene to a permutation.</h2><span id='topic+xegaGaGeneMapPerm'></span>

<h3>Description</h3>

<p><code>xegaGaGeneMapPerm</code> maps the bit strings of a binary string 
to a permutation of integers.
Example: Traveling Salesman Problem (TSP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaGeneMapPerm(gene, penv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaGeneMapPerm_+3A_gene">gene</code></td>
<td>
<p>A binary gene (the genotype).</p>
</td></tr>
<tr><td><code id="xegaGaGeneMapPerm_+3A_penv">penv</code></td>
<td>
<p>A problem environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A permutation (the decoded gene (the phenotype))
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+xegaGaDecodeGene">xegaGaDecodeGene</a>()</code>,
<code><a href="#topic+xegaGaGeneMapGray">xegaGaGeneMapGray</a>()</code>,
<code><a href="#topic+xegaGaGeneMapIdentity">xegaGaGeneMapIdentity</a>()</code>,
<code><a href="#topic+xegaGaGeneMap">xegaGaGeneMap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaGeneMapPerm(gene$gene1, lFxegaGaGene$penv)

</code></pre>

<hr>
<h2 id='xegaGaInitGene'>Generate a random binary gene.</h2><span id='topic+xegaGaInitGene'></span>

<h3>Description</h3>

<p><code>xegaGaInitGene</code> generates a random binary gene 
with a given length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaInitGene(lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaInitGene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary gene (a named list):
</p>

<ul>
<li> <p><code>$evaluated</code>: FALSE. See package <code>xegaEvalGene</code>
</p>
</li>
<li> <p><code>$evalFail</code>:  FALSE. Set by the error handler(s)
in package <code>xegaEvalGene</code> 
in the case of failure.
</p>
</li>
<li> <p><code>$fit</code>:       the fitness
</p>
</li>
<li> <p><code>$gene1</code>:      a binary gene 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>xegaGaInitGene(lFxegaGaGene)

</code></pre>

<hr>
<h2 id='xegaGaIVAdaptiveMutateGene'>Individually variable adaptive mutation of a gene.</h2><span id='topic+xegaGaIVAdaptiveMutateGene'></span>

<h3>Description</h3>

<p><code>xegaGaIVAdaptiveMutateGene</code> mutates a binary gene.
Two mutation rates (<code>lF$MutationRate()</code> 
and <code>lF$MutationRate2()</code> which is higher than the first)
are used depending on the relative fitness of the gene.
<code>lF$CutoffFit</code> and <code>lF$CBestFitness</code> are used
to determine the relative fitness of the gene.
The rationale is that mutating genes having a low fitness
with a higher probability rate improves the performance
of a genetic algorithm, because the gene gets a higher 
chance to improve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaIVAdaptiveMutateGene(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaIVAdaptiveMutateGene_+3A_gene">gene</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaIVAdaptiveMutateGene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This principle is a candidate for a more abstract implementation,
because it applies to all variants of evolutionary algorithms.
</p>
<p>The goal is to separate the threshold code and the 
representation-dependent part and 
to combine them in the factory properly.
</p>


<h3>Value</h3>

<p>A binary gene
</p>


<h3>References</h3>

<p>Stanhope, Stephen A. and Daida, Jason M. (1996)
An Individually Variable Mutation-rate Strategy for Genetic Algorithms.
In: Koza, John (Ed.)
Late Breaking Papers at the Genetic Programming 1996 Conference.
Stanford University Bookstore, Stanford, pp. 177-185.
(ISBN:0-18-201-031-7)
</p>


<h3>See Also</h3>

<p>Other Mutation: 
<code><a href="#topic+xegaGaMutateGene">xegaGaMutateGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x) {function() {return(x)}}
  lFxegaGaGene$BitMutationRate1&lt;-parm(1.0)
  lFxegaGaGene$BitMutationRate2&lt;-parm(0.5)
gene1&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaDecodeGene(gene1, lFxegaGaGene)
gene&lt;-xegaGaIVAdaptiveMutateGene(gene1, lFxegaGaGene)
xegaGaDecodeGene(gene, lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaMutateGene'>Mutate a gene.</h2><span id='topic+xegaGaMutateGene'></span>

<h3>Description</h3>

<p><code>xegaGaMutateGene</code> mutates a binary gene.
The per-bit mutation rate is given by MutationRate().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaMutateGene(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaMutateGene_+3A_gene">gene</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaMutateGene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary gene.
</p>


<h3>See Also</h3>

<p>Other Mutation: 
<code><a href="#topic+xegaGaIVAdaptiveMutateGene">xegaGaIVAdaptiveMutateGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x) {function() {return(x)}}
lFxegaGaGene$BitMutationRate1&lt;-parm(1.0)
gene1&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaDecodeGene(gene1, lFxegaGaGene)
lFxegaGaGene$BitMutationRate1()
gene&lt;-xegaGaMutateGene(gene1, lFxegaGaGene)
xegaGaDecodeGene(gene, lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaMutationFactory'>Configure the mutation function of a genetic algorithm.</h2><span id='topic+xegaGaMutationFactory'></span>

<h3>Description</h3>

<p><code>xegaGaMutationFactory</code> implements the selection
of one of the mutation functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error) if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;MutateGene&quot; returns <code>xegaGaMutateGene</code>.
</p>
</li>
<li><p> &quot;IVMGene&quot; returns <code>xegaGaIVAdaptiveMutateGene</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaGaMutationFactory(method = "MutateGene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaMutationFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the mutation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mutation function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+lFxegaGaGene">lFxegaGaGene</a></code>,
<code><a href="#topic+xegaGaCrossoverFactory">xegaGaCrossoverFactory</a>()</code>,
<code><a href="#topic+xegaGaGeneMapFactory">xegaGaGeneMapFactory</a>()</code>,
<code><a href="#topic+xegaGaReplicationFactory">xegaGaReplicationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x) {function() {return(x)}}
lFxegaGaGene$BitMutationRate1&lt;-parm(1.0)
Mutate&lt;-xegaGaMutationFactory("MutateGene")
gene1&lt;-xegaGaInitGene(lFxegaGaGene)
gene1
Mutate(gene1, lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaReplicate2Gene'>Replicates a gene.</h2><span id='topic+xegaGaReplicate2Gene'></span>

<h3>Description</h3>

<p><code>xegaGaReplicate2Gene</code> replicates a gene
by applying a gene reproduction pipeline 
which uses crossover and
mutation. The control flow is as follows:
</p>

<ul>
<li><p> A gene is selected from the population.
Check if the crossover operation should be applied.
(The check is <code>TRUE</code> with a probability of <code>crossrate</code>).
If the check is <code>TRUE</code>:
</p>

<ul>
<li><p> Select a mating gene from the population.
</p>
</li>
<li><p> Perform the crossover operation.
</p>
</li>
<li><p> Apply mutation with a probability of <code>mutrate</code>.
</p>
</li>
<li><p> Return a list with both genes.
</p>
</li></ul>

</li>
<li><p> Apply mutation with a probability of <code>mutrate</code>.
</p>
</li>
<li><p> Return a list with a single gene.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>xegaGaReplicate2Gene(pop, fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaReplicate2Gene_+3A_pop">pop</code></td>
<td>
<p>A population of binary genes.</p>
</td></tr>
<tr><td><code id="xegaGaReplicate2Gene_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="xegaGaReplicate2Gene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of either 1 or 2 binary genes.
</p>


<h3>See Also</h3>

<p>Other Replication: 
<code><a href="#topic+xegaGaReplicateGene">xegaGaReplicateGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lFxegaGaGene$CrossGene&lt;-xegaGaCross2Gene
lFxegaGaGene$MutationRate&lt;-function(fit, lF) {0.001}
names(lFxegaGaGene)
pop10&lt;-lapply(rep(0,10), function(x) xegaGaInitGene(lFxegaGaGene))
epop10&lt;-lapply(pop10, lFxegaGaGene$EvalGene, lF=lFxegaGaGene)
fit10&lt;-unlist(lapply(epop10, function(x) {x$fit}))
newgenes&lt;-xegaGaReplicate2Gene(pop10, fit10, lFxegaGaGene)

</code></pre>

<hr>
<h2 id='xegaGaReplicateGene'>Replicates a gene.</h2><span id='topic+xegaGaReplicateGene'></span>

<h3>Description</h3>

<p><code>xegaGaReplicateGene</code> replicates a gene
by applying a gene reproduction pipeline 
which uses crossover and
mutation. 
The control flow may have the following steps:
</p>

<ul>
<li><p> A gene is selected from the population.
Check if the crossover operation should be applied.
(The check is <code>TRUE</code> with a probability of <code>crossrate</code>).
If the check is <code>TRUE</code>:
</p>

<ul>
<li><p> Select a mating gene from the population.
</p>
</li>
<li><p> Perform the crossover operation.
</p>
</li>
<li><p> Apply mutation with a probability of <code>mutrate</code>.
</p>
</li>
<li><p> Return a list one gene.
</p>
</li></ul>

</li>
<li><p> Apply mutation with a probability of <code>mutrate</code>.
</p>
</li>
<li><p> Accept gene. For genetic algorithms: Identity.
</p>
</li>
<li><p> Return a list with a single gene.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>xegaGaReplicateGene(pop, fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaReplicateGene_+3A_pop">pop</code></td>
<td>
<p>Population of binary genes.</p>
</td></tr>
<tr><td><code id="xegaGaReplicateGene_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="xegaGaReplicateGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xegaGaReplicateGene</code> implements the control flow 
by a dynamic definition of the operator pipeline depending
on the random choices for mutation and crossover:
</p>

<ol>
<li><p> A gene <code>g</code> is selected and the boolean variables <code>mut</code>
and <code>cross</code> are set to <code>runif(1)&lt;rate</code>. 
</p>
</li>
<li><p> The local function for the operator pipeline <code>OPpip(g, lF)</code>
is defined by the truth values of <code>cross</code> and <code>mut</code>:
</p>
      
<ol>
<li> <p><code>(cross==FALSE) &amp; (mut==FALSE)</code>: 
Identity function. 
</p>
</li>
<li> <p><code>(cross==TRUE) &amp; (mut==TRUE)</code>: 
Mate selection,  crossover, mutation. 
</p>
</li>
<li> <p><code>(cross==TRUE) &amp; (mut==FALSE)</code>: 
Mate selection, crossover. 
</p>
</li>
<li> <p><code>(cross==FALSE) &amp; (mut==TRUE)</code>: 
Mutation. 
</p>
</li></ol>

</li>
<li><p>  Perform the operator pipeline and accept the result.
</p>
</li></ol>



<h3>Value</h3>

<p>A list of one gene.
</p>


<h3>See Also</h3>

<p>Other Replication: 
<code><a href="#topic+xegaGaReplicate2Gene">xegaGaReplicate2Gene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lFxegaGaGene$CrossGene&lt;-xegaGaCrossGene
lFxegaGaGene$MutationRate&lt;-function(fit, lF) {0.001}
lFxegaGaGene$Accept&lt;-function(OperatorPipeline, gene, lF) {gene}
pop10&lt;-lapply(rep(0,10), function(x) xegaGaInitGene(lFxegaGaGene))
epop10&lt;-lapply(pop10, lFxegaGaGene$EvalGene, lF=lFxegaGaGene)
fit10&lt;-unlist(lapply(epop10, function(x) {x$fit}))
newgenes&lt;-xegaGaReplicateGene(pop10, fit10, lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaReplicationFactory'>Configure the replication function of a genetic algorithm.</h2><span id='topic+xegaGaReplicationFactory'></span>

<h3>Description</h3>

<p><code>ReplicationFactory</code> implements the selection
of a replication method. 
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;Kid1&quot; returns <code>ReplicateGene</code>.
</p>
</li>
<li><p> &quot;Kid2&quot; returns <code>Replicate2Gene</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaGaReplicationFactory(method = "Kid1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaReplicationFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the replication function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A replication function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+lFxegaGaGene">lFxegaGaGene</a></code>,
<code><a href="#topic+xegaGaCrossoverFactory">xegaGaCrossoverFactory</a>()</code>,
<code><a href="#topic+xegaGaGeneMapFactory">xegaGaGeneMapFactory</a>()</code>,
<code><a href="#topic+xegaGaMutationFactory">xegaGaMutationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lFxegaGaGene$CrossGene&lt;-xegaGaCrossGene
lFxegaGaGene$MutationRate&lt;-function(fit, lF) {0.001}
lFxegaGaGene$Accept&lt;-function(OperatorPipeline, gene, lF) {gene}
Replicate&lt;-xegaGaReplicationFactory("Kid1")
pop10&lt;-lapply(rep(0,10), function(x) xegaGaInitGene(lFxegaGaGene))
epop10&lt;-lapply(pop10, lFxegaGaGene$EvalGene, lF=lFxegaGaGene)
fit10&lt;-unlist(lapply(epop10, function(x) {x$fit}))
newgenes1&lt;-Replicate(pop10, fit10, lFxegaGaGene)
lFxegaGaGene$CrossGene&lt;-xegaGaCross2Gene
Replicate&lt;-xegaGaReplicationFactory("Kid2")
newgenes2&lt;-Replicate(pop10, fit10, lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaUCross2Gene'>Uniform crossover of 2 genes.</h2><span id='topic+xegaGaUCross2Gene'></span>

<h3>Description</h3>

<p><code>xegaGaUCross2Gene</code> swaps alleles of both genes
with a probability of 0.5. It generates a random 
mask which is used to build the new genes.
It returns 2 genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaUCross2Gene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaUCross2Gene_+3A_gg1">gg1</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaUCross2Gene_+3A_gg2">gg2</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaUCross2Gene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 binary genes.
</p>


<h3>References</h3>

<p>Syswerda, Gilbert (1989):
Uniform Crossover in Genetic Algorithms. 
In: Schaffer, J. David (Ed.)
Proceedings of the Third International Conference on Genetic Algorithms,
Morgan Kaufmann Publishers, Los Altos, California, pp. 2-9.
(ISBN:1-55860-066-3)
</p>


<h3>See Also</h3>

<p>Other Crossover (2): 
<code><a href="#topic+xegaGaCross2Gene">xegaGaCross2Gene</a>()</code>,
<code><a href="#topic+xegaGaUPCross2Gene">xegaGaUPCross2Gene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGaInitGene(lFxegaGaGene)
gene2&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaDecodeGene(gene1, lFxegaGaGene)
xegaGaDecodeGene(gene2, lFxegaGaGene)
newgenes&lt;-xegaGaUCross2Gene(gene1, gene2, lFxegaGaGene)
xegaGaDecodeGene(newgenes[[1]], lFxegaGaGene)
xegaGaDecodeGene(newgenes[[2]], lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaUCrossGene'>Uniform crossover of 2 genes.</h2><span id='topic+xegaGaUCrossGene'></span>

<h3>Description</h3>

<p><code>xegaGaUCrossGene</code> swaps alleles of both genes
with a probability of 0.5. It generates a random 
mask which is used to build the new gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaUCrossGene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaUCrossGene_+3A_gg1">gg1</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaUCrossGene_+3A_gg2">gg2</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaUCrossGene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of one binary gene.
</p>


<h3>References</h3>

<p>Syswerda, Gilbert (1989):
Uniform Crossover in Genetic Algorithms. 
In: Schaffer, J. David (Ed.)
Proceedings of the Third International Conference on Genetic Algorithms,
Morgan Kaufmann Publishers, Los Altos, California, pp. 2-9.
(ISBN:1-55860-066-3)
</p>


<h3>See Also</h3>

<p>Other Crossover (1): 
<code><a href="#topic+xegaGaCrossGene">xegaGaCrossGene</a>()</code>,
<code><a href="#topic+xegaGaUPCrossGene">xegaGaUPCrossGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGaInitGene(lFxegaGaGene)
gene2&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaDecodeGene(gene1, lFxegaGaGene)
xegaGaDecodeGene(gene2, lFxegaGaGene)
gene3&lt;-xegaGaUCrossGene(gene1, gene2, lFxegaGaGene)
xegaGaDecodeGene(gene3[[1]], lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaUPCross2Gene'>Parameterized uniform crossover of 2 genes.</h2><span id='topic+xegaGaUPCross2Gene'></span>

<h3>Description</h3>

<p><code>xegaGaUP2CrossGene</code> swaps alleles of both genes
with a probability of <code>lF$UCrossSwap</code>. 
It generates a random 
mask which is used to build the new gene.
It returns 2  genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaUPCross2Gene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaUPCross2Gene_+3A_gg1">gg1</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaUPCross2Gene_+3A_gg2">gg2</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaUPCross2Gene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 binary genes.
</p>


<h3>References</h3>

<p>Spears William and De Jong, Kenneth (1991):
On the Virtues of Parametrized Uniform Crossover. 
In: Belew, Richar K. and Booker, Lashon B. (Ed.)
Proceedings of the Fourth International Conference on Genetic Algorithms,
Morgan Kaufmann Publishers, Los Altos, California, pp. 230-236.
(ISBN:1-55860-208-9)
</p>


<h3>See Also</h3>

<p>Other Crossover (2): 
<code><a href="#topic+xegaGaCross2Gene">xegaGaCross2Gene</a>()</code>,
<code><a href="#topic+xegaGaUCross2Gene">xegaGaUCross2Gene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGaInitGene(lFxegaGaGene)
gene2&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaDecodeGene(gene1, lFxegaGaGene)
xegaGaDecodeGene(gene2, lFxegaGaGene)
newgenes&lt;-xegaGaUPCross2Gene(gene1, gene2, lFxegaGaGene)
xegaGaDecodeGene(newgenes[[1]], lFxegaGaGene)
xegaGaDecodeGene(newgenes[[2]], lFxegaGaGene)
</code></pre>

<hr>
<h2 id='xegaGaUPCrossGene'>Parameterized uniform crossover of 2 genes.</h2><span id='topic+xegaGaUPCrossGene'></span>

<h3>Description</h3>

<p><code>xegaGaUPCrossGene</code> swaps alleles of both genes
with a probability of <code>lF$UCrossSwap</code>. 
It generates a random 
mask which is used to build the new gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaGaUPCrossGene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaGaUPCrossGene_+3A_gg1">gg1</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaUPCrossGene_+3A_gg2">gg2</code></td>
<td>
<p>A binary gene.</p>
</td></tr>
<tr><td><code id="xegaGaUPCrossGene_+3A_lf">lF</code></td>
<td>
<p>The local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of one binary gene.
</p>


<h3>References</h3>

<p>Spears William and De Jong, Kenneth (1991):
On the Virtues of Parametrized Uniform Crossover. 
In: Belew, Richar K. and Booker, Lashon B. (Ed.)
Proceedings of the Fourth International Conference on Genetic Algorithms,
Morgan Kaufmann Publishers, Los Altos, California, pp. 230-236.
(ISBN:1-55860-208-9)
</p>


<h3>See Also</h3>

<p>Other Crossover (1): 
<code><a href="#topic+xegaGaCrossGene">xegaGaCrossGene</a>()</code>,
<code><a href="#topic+xegaGaUCrossGene">xegaGaUCrossGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaGaInitGene(lFxegaGaGene)
gene2&lt;-xegaGaInitGene(lFxegaGaGene)
xegaGaDecodeGene(gene1, lFxegaGaGene)
xegaGaDecodeGene(gene2, lFxegaGaGene)
gene3&lt;-xegaGaUPCrossGene(gene1, gene2, lFxegaGaGene)
xegaGaDecodeGene(gene3[[1]], lFxegaGaGene)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
