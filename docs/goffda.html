<!DOCTYPE html><html><head><title>Help for package goffda</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {goffda}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#goffda-package'><p><span class="pkg">goffda</span> &ndash; Goodness-of-Fit Tests for Functional Data</p></a></li>
<li><a href='#aemet_temp'><p>AEMET daily temperatures during 1974&ndash;2013</p></a></li>
<li><a href='#cv_glmnet'><p>Fitting of regularized linear models</p></a></li>
<li><a href='#elem-flmfr'><p>Covariate, error, and kernel of a functional linear model</p>
with functional response</a></li>
<li><a href='#fda.usc_efic'><p>Auxiliary functions for the <span class="pkg">goffda</span> package</p></a></li>
<li><a href='#flm_est'><p>Estimation of functional linear models</p></a></li>
<li><a href='#flm_stat'><p>Projected Cramér&ndash;von Mises test statistic for the</p>
goodness-of-fit test of functional linear models</a></li>
<li><a href='#flm_term'><p>Functional linear model term with bivariate kernel</p></a></li>
<li><a href='#flm_test'><p>Goodness-of-fit test for functional linear models</p></a></li>
<li><a href='#fpc'><p>Computation of functional principal components</p></a></li>
<li><a href='#fpc_utils'><p>Utilities for functional principal components</p></a></li>
<li><a href='#ontario'><p>Ontario temperature and electricity consumption during 2010&ndash;2014</p></a></li>
<li><a href='#quadrature'><p>Quadrature rules for the <span class="pkg">goffda</span> package</p></a></li>
<li><a href='#r_ou'><p>Simulation of an Ornstein&ndash;Uhlenbeck process</p></a></li>
<li><a href='#sim-frmfr'><p>Sampling functional regression models with functional responses</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Goodness-of-Fit Tests for Functional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of several goodness-of-fit tests for functional
    data. Currently, mostly related with the functional linear model with
    functional/scalar response and functional/scalar predictor. The package
    allows for the replication of the data applications considered in
    García-Portugués, Álvarez-Liébana, Álvarez-Pérez and González-Manteiga
    (2021) &lt;<a href="https://doi.org/10.1111%2Fsjos.12486">doi:10.1111/sjos.12486</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>fda.usc, glmnet, ks</td>
</tr>
<tr>
<td>Suggests:</td>
<td>microbenchmark, knitr, viridisLite, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egarpor/goffda">https://github.com/egarpor/goffda</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/egarpor/goffda">https://github.com/egarpor/goffda</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-14 15:20:17 UTC; Eduardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Eduardo García-Portugués
    <a href="https://orcid.org/0000-0002-9224-4111"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Javier Álvarez-Liébana
    <a href="https://orcid.org/0000-0003-0671-3856"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Gonzalo Álvarez-Pérez [ctb],
  Manuel Febrero-Bande [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo García-Portugués &lt;edgarcia@est-econ.uc3m.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-14 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='goffda-package'><span class="pkg">goffda</span> &ndash; Goodness-of-Fit Tests for Functional Data</h2><span id='topic+goffda-package'></span><span id='topic+goffda'></span>

<h3>Description</h3>

<p>Implementation of several goodness-of-fit tests for functional
data. Currently, mostly related with the functional linear model with
functional/scalar response and functional/scalar predictor. The package
allows for the replication of the data applications considered in
García-Portugués, Álvarez-Liébana, Álvarez-Pérez and González-Manteiga
(2021) &lt;doi:10.1111/sjos.12486&gt;.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués and Javier Álvarez-Liébana.
</p>


<h3>References</h3>

<p>García-Portugués, E., Álvarez-Liébana, J., Álvarez-Pérez, G. and
Gonzalez-Manteiga, W. (2021). A goodness-of-fit test for the functional
linear model with functional response. <em>Scandinavian Journal of
Statistics</em>, 48(2):502&ndash;528. <a href="https://doi.org/10.1111/sjos.12486">doi:10.1111/sjos.12486</a>
</p>
<p>García-Portugués, E., González-Manteiga, W. and Febrero-Bande, M. (2014). A
goodness-of-fit test for the functional linear model with scalar response.
<em>Journal of Computational and Graphical Statistics</em>, 23(3):761&ndash;778.
<a href="https://doi.org/10.1080/10618600.2013.812519">doi:10.1080/10618600.2013.812519</a>
</p>

<hr>
<h2 id='aemet_temp'>AEMET daily temperatures during 1974&ndash;2013</h2><span id='topic+aemet_temp'></span>

<h3>Description</h3>

<p>Series of daily temperatures of 73 Spanish weather stations
during the 40-year period 1974&ndash;2013.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aemet_temp
</code></pre>


<h3>Format</h3>

<p>A list with the following entries:
</p>

<dl>
<dt>temp</dt><dd><p>an <code><a href="fda.usc.html#topic+fdata">fdata</a></code> with 2892 temperature
(in Celsius degrees) curves, discretized on 365 equispaced
grid points (days) on <code class="reqn">[0.5, 364.5]</code>. Each curve corresponds to the
yearly records of a weather station.</p>
</dd>
<dt>df</dt><dd><p>a dataframe with metadata for each curve:
</p>

<ul>
<li><p><code>ind</code>: identifier of the weather station.
</p>
</li>
<li><p><code>name</code>: name of the weather station.
</p>
</li>
<li><p><code>year</code>: year of the observation.
</p>
</li></ul>
</dd>
</dl>



<h3>Details</h3>

<p>For consistency with the <code><a href="fda.usc.html#topic+fda.usc-package">fda.usc-package</a></code>'s
<code><a href="fda.usc.html#topic+aemet">aemet</a></code> dataset, the names and identifiers of the 73
weather stations are the same as in that dataset. Only a minor fix has been
applied to the &quot;A CORUÑA/ALVEDRO&quot; station, whose identifier was the same
as the &quot;A CORUÑA&quot; station, <code>"1387"</code>. The former was set to
<code>"1387A"</code>.
</p>
<p>Information about the province, altitude, longitude, and latitude of
each weather station can be retrieved in <code>df</code> from the
<code><a href="fda.usc.html#topic+fda.usc-package">fda.usc-package</a></code>'s <code><a href="fda.usc.html#topic+aemet">aemet</a></code>
dataset.
</p>
<p>The dataset is a curated version of a larger database of 115 stations. It
excludes stations with inconsistent records or that were relocated, closed,
or opened during the 40-year period. There are 9 stations with missing
years. The total of missing years is 28.
</p>
<p>In leap years, the daily-average temperature is computed as the average of
February 28th and 29th.
</p>


<h3>Author(s)</h3>

<p>Original data processing scripts by Manuel Febrero-Bande and Manuel Oviedo
de la Fuente. Adaptations by Eduardo García-Portugués.
</p>


<h3>Source</h3>

<p>The data was retrieved from the FTP of the
<a href="https://www.aemet.es/es/portada/">Meteorological State Agency of Spain
(AEMET)</a> in 2014 using a processing script by the authors of the
<code><a href="fda.usc.html#topic+fda.usc-package">fda.usc-package</a></code>.
</p>


<h3>References</h3>

<p>Febrero-Bande, M. and Oviedo de la Fuente, M. (2012). Statistical Computing
in Functional Data Analysis: The R Package fda.usc. <em>Journal of
Statistical Software</em>, 51(4):1&ndash;28. <a href="https://doi.org/10.18637/jss.v051.i04">doi:10.18637/jss.v051.i04</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data splitting

# Load raw data
data("aemet_temp")

# Partition the dataset in the first and last 20 years
with(aemet_temp, {
  ind_pred &lt;- which((1974 &lt;= df$year) &amp; (df$year &lt;= 1993))
  ind_resp &lt;- which((1994 &lt;= df$year) &amp; (df$year &lt;= 2013))
  aemet_temp_pred &lt;&lt;- list("df" = df[ind_pred, ], "temp" = temp[ind_pred])
  aemet_temp_resp &lt;&lt;- list("df" = df[ind_resp, ], "temp" = temp[ind_resp])
})

# Average the temperature on each period
mean_aemet &lt;- function(x) {
  m &lt;- tapply(X = 1:nrow(x$temp$data), INDEX = x$df$ind,
              FUN = function(i) colMeans(x$temp$data[i, , drop = FALSE],
                                         na.rm = TRUE))
 x$temp$data &lt;- do.call(rbind, m)
 return(x$temp)
}

# Build predictor and response fdatas
aemet_temp_pred &lt;- mean_aemet(aemet_temp_pred)
aemet_temp_resp &lt;- mean_aemet(aemet_temp_resp)

# Plot
old_par &lt;- par(mfrow = c(1, 2))
plot(aemet_temp_pred)
plot(aemet_temp_resp)
par(old_par)

# Average daily temperatures
day_avg_pred &lt;- func_mean(aemet_temp_pred)
day_avg_resp &lt;- func_mean(aemet_temp_resp)

# Average yearly temperatures
avg_year_pred &lt;- rowMeans(aemet_temp_pred$data)
avg_year_resp &lt;- rowMeans(aemet_temp_resp$data)

## Test the linear model with functional response and predictor

(comp_flmfr &lt;- flm_test(X = aemet_temp_pred, Y = aemet_temp_resp,
                        est_method = "fpcr_l1s"))
beta0 &lt;- diag(rep(1, length(aemet_temp_pred$argvals)))
(simp_flmfr &lt;- flm_test(X = aemet_temp_pred, Y = aemet_temp_resp,
                        beta0 = beta0, est_method = "fpcr_l1s"))

# Visualize estimation
filled.contour(x = aemet_temp_pred$argvals, y = aemet_temp_resp$argvals,
               z = comp_flmfr$fit_flm$Beta_hat,
               color.palette = viridisLite::viridis, nlevels = 20)

## Test the linear model with scalar response and functional predictor

(comp_flmsr &lt;- flm_test(X = aemet_temp_pred, Y = avg_year_resp,
                        est_method = "fpcr_l1s"))
(simp_flmsr &lt;- flm_test(X = aemet_temp_pred, Y = avg_year_resp,
                        beta0 = 1 / 365, est_method = "fpcr_l1s"))

# Visualize estimation
plot(aemet_temp_pred$argvals, comp_flmsr$fit_flm$Beta_hat, type = "l",
     ylim = c(0, 30 / 365))
abline(h = 1 / 365, col = 2)

## Test the linear model with functional response and scalar predictor

(comp_frsp &lt;- flm_test(X = avg_year_pred, Y = aemet_temp_resp))
(simp_frsp &lt;- flm_test(X = avg_year_pred, Y = aemet_temp_resp, beta0 = 1))

## Test the linear model with scalar response and predictor

(comp_srsp &lt;- flm_test(X = avg_year_pred, Y = avg_year_resp))
(simp_srsp &lt;- flm_test(X = avg_year_pred, Y = avg_year_resp, beta0 = 1))

</code></pre>

<hr>
<h2 id='cv_glmnet'>Fitting of regularized linear models</h2><span id='topic+cv_glmnet'></span>

<h3>Description</h3>

<p>Convenience function for fitting multivariate linear models
with multivariate response by relying on <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>
from the <code><a href="glmnet.html#topic+glmnet-package">glmnet-package</a></code>. The function fits the
multivariate linear model
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{Y} = \mathbf{X}\mathbf{B} + \mathbf{E},</code>
</p>

<p>where <code class="reqn">\mathbf{X}</code> is a <code class="reqn">p</code>-dimensional vector,
<code class="reqn">\mathbf{Y}</code> and <code class="reqn">\mathbf{E}</code> are two
<code class="reqn">q</code>-dimensional vectors, and <code class="reqn">\mathbf{B}</code> is a
<code class="reqn">p\times q</code> matrix.
</p>
<p>If <code class="reqn">\mathbf{X}</code> and <code class="reqn">\mathbf{Y}</code> are <em>centered</em>
(i.e., have zero-mean columns), the function estimates <code class="reqn">\mathbf{B}</code>
by solving, for the sample
<code class="reqn">(\mathbf{X}_1, \mathbf{Y}_1), \ldots, (\mathbf{X}_n, \mathbf{Y}_n)</code>, the elastic-net optimization problem
</p>
<p style="text-align: center;"><code class="reqn">
\min_{\mathbf{B}\in R^{q \times p}}
\frac{1}{2n}\sum_{i=1}^n
\|\mathbf{Y}_i-\mathbf{X}_i\mathbf{B}\|^2 +
\lambda\left[(1-\alpha)\|\mathbf{B}\|_\mathrm{F}^2 / 2 +
\alpha \sum_{j=1}^p \|\mathbf{B}_j\|_2\right],
</code>
</p>

<p>where <code class="reqn">\|\mathbf{B}\|_\mathrm{F}</code> stands for
the Frobenious norm of the matrix <code class="reqn">\mathbf{B}</code> and
<code class="reqn">\|\mathbf{B}_j\|_2</code> for the Euclidean norm
of the <code class="reqn">j</code>-th <em>row</em> of <code class="reqn">\mathbf{B}</code>. The choice
<code class="reqn">\alpha = 0</code> in the elastic-net penalization corresponds to ridge
regression, whereas <code class="reqn">\alpha = 1</code> yields a lasso-type estimator.
The unpenalized least-squares estimator is obtained with <code class="reqn">\lambda = 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_glmnet(x, y, alpha = c("lasso", "ridge")[1], lambda = NULL,
  intercept = TRUE, thresh = 1e-10, cv_1se = TRUE, cv_nlambda = 50,
  cv_folds = NULL, cv_grouped = FALSE, cv_lambda = 10^seq(2, -3,
  length.out = cv_nlambda), cv_second = TRUE, cv_tol_second = 0.025,
  cv_log10_exp = c(-0.5, 3), cv_thresh = 1e-05, cv_parallel = FALSE,
  cv_verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_glmnet_+3A_x">x</code></td>
<td>
<p>input matrix of size <code>c(n, p)</code>, or a vector of length
<code>n</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_y">y</code></td>
<td>
<p>response matrix of size <code>c(n, q)</code>, or a vector of
length <code>n</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_alpha">alpha</code></td>
<td>
<p>elastic net mixing argument in <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>,
with <code class="reqn">0 \le \alpha \le 1</code>. Alternatively, a character string indicating
whether the <code>"ridge"</code> (<code class="reqn">\alpha = 0</code>) or <code>"lasso"</code>
(<code class="reqn">\alpha = 1</code>) fit is to be performed.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_lambda">lambda</code></td>
<td>
<p>scalar giving the regularization parameter <code class="reqn">\lambda</code>. If
<code>NULL</code> (default), the optimal <code class="reqn">\lambda</code> is searched by
cross-validation. If <code>lambda</code> is provided, then cross-validation is
skipped and the fit is performed for the given <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_intercept">intercept</code></td>
<td>
<p>flag passed to the <code>intercept</code> argument in
<code><a href="glmnet.html#topic+glmnet">glmnet</a></code> to indicate if the intercept should be fitted
(default; does not assume that the data is centered) or set to zero
(the optimization problem above is solved as-is). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_thresh">thresh</code></td>
<td>
<p>convergence threshold of the coordinate descending algorithm,
passed to the <code>thresh</code> argument in <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>.
Defaults to <code>1e-10</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_1se">cv_1se</code></td>
<td>
<p>shall the <em>optimal</em> lambda be the <code>lambda.1se</code>, as
returned by <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>? This favors sparser fits. If
<code>FALSE</code>, then the optimal lambda is <code>lambda.min</code>, the minimizer
of the cross-validation loss. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_nlambda">cv_nlambda</code></td>
<td>
<p>the length of the sequence of <code class="reqn">\lambda</code> values,
passed to the <code>nlambda</code> argument in <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>
for the cross-validation search. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_folds">cv_folds</code></td>
<td>
<p>number of folds to perform cross-validation. If
<code>NULL</code> (the default), then<br /> <code>cv_folds &lt;- n</code> internally,
that is, leave-one-out cross-validation is performed. Passed to the
<code>nfolds</code> argument in <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_grouped">cv_grouped</code></td>
<td>
<p>passed to the <code>grouped</code> argument in
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_lambda">cv_lambda</code></td>
<td>
<p>passed to the <code>lambda</code> argument in
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>. Defaults to<br />
<code>10^seq(2, -3, length.out = cv_nlambda)</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_second">cv_second</code></td>
<td>
<p>flag to perform a second cross-validation search if the
optimal <code class="reqn">\lambda</code> was found at the extremes of the first <code class="reqn">\lambda</code>
sequence (indicating that the minimum may not be reliable). Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_tol_second">cv_tol_second</code></td>
<td>
<p>tolerance for performing a second search if
<code>second = TRUE</code>. If the minimum is found at the
<code>100 * cv_tol_second</code> lower/upper percentile of search interval, then
the search interval is expanded for a second search. Defaults to
<code>0.025</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_log10_exp">cv_log10_exp</code></td>
<td>
<p>expansion of the <code class="reqn">\lambda</code> sequence if the minimum
is found close to its <em>upper</em> extreme. If that is the case, the
sequence for the is set as <code>10^(log10(lambda_min) + cv_log10_exp)</code>,
where <code>lambda_min</code> is the minimum obtained in the first sequence. If
the minimum is found close to the lower extreme of the sequence, then
<code>-rev(cv_log10_exp)</code> is considered. Defaults to <code>c(-0.5, 5)</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_thresh">cv_thresh</code></td>
<td>
<p>convergence threshold used during cross-validation in
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>. Defaults to <code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_parallel">cv_parallel</code></td>
<td>
<p>passed to the <code>parallel</code> argument in
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_cv_verbose">cv_verbose</code></td>
<td>
<p>flag to display information about the cross-validation
search with plots and messages. More useful if <code>second = TRUE</code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cv_glmnet_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
to perform the final model fit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">\alpha = 1</code>, then the lasso-type fit shrinks to zero,
<em>simultaneously</em>, all the elements of certain rows of
<code class="reqn">\mathbf{B}</code>, thus
helping the selection of the <code class="reqn">p</code> most influential variables in
<code class="reqn">\mathbf{X}</code> for explaining/predicting <code class="reqn">\mathbf{Y}</code>.
</p>
<p>The function first performs a cross-validation search for the optimal
<code class="reqn">\lambda</code> if <code>lambda = NULL</code> (using <code>cv_thresh</code> to control
the convergence threshold). After the optimal penalization parameter is
determined, a second fit (now with convergence threshold <code>thresh</code>)
using the default <code class="reqn">\lambda</code> sequence in <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
is performed. The final estimate is obtained via
<code><a href="glmnet.html#topic+predict.glmnet">predict.glmnet</a></code> from the optimal <code class="reqn">\lambda</code>
determined in the first step.
</p>
<p>Due to its cross-validatory nature, <code>cv_glmnet</code> can be
computationally demanding. Approaches for reducing the computation time
include: considering a smaller number of folds than <code>n</code>, such as
<code>cv_folds = 10</code> (but will lead to random partitions of the
data); decrease the tolerance of the coordinate descending
algorithm by increasing <code>cv_thresh</code>; reducing the number of
candidate <code class="reqn">\lambda</code> values with <code>nlambda</code>; setting
<code>second = FALSE</code> to avoid a second cross-validation; or considering
<code>cv_parallel = TRUE</code> to use a parallel backend (must be registered
before hand; see examples).
</p>
<p>By default, the <code class="reqn">\lambda</code> sequence is used with <em>standardized</em>
<code class="reqn">\mathbf{X}</code> and <code class="reqn">\mathbf{Y}</code> (both divided by their
columnwise variances); see <code><a href="glmnet.html#topic+glmnet">glmnet</a></code> and the
<code>standardized</code> argument. Therefore, the optimal selected <code class="reqn">\lambda</code>
value assumes standardization and must be used with care if the variables
are not standardized. For example, when using the ridge analytical
solution, a prior change of scale that depends on <code class="reqn">q</code> needs to be done.
See the examples for the details.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>
<table>
<tr><td><code>beta_hat</code></td>
<td>
<p>the estimated <code class="reqn">\mathbf{B}</code>,
a matrix of size <code>c(p, q)</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the optimal <code class="reqn">\lambda</code> obtained by cross-validation and
according to <code>cv_1se</code>.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>if <code>lambda = NULL</code>, the result of the cross-validation
search for the optimal <code class="reqn">\lambda</code>. Otherwise, <code>NULL</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the <code>glmnet</code> fit, computed with <code>thresh</code> threshold
and with an automatically chosen <code class="reqn">\lambda</code> sequence.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués. Initial contributions by Gonzalo
Álvarez-Pérez.
</p>


<h3>References</h3>

<p>Friedman, J., Hastie, T. and Tibshirani, R. (2010). Regularization paths for
generalized linear models via coordinate descent. <em>Journal of
Statistical Software</em>, 33(1):1&ndash;22. <a href="https://doi.org/10.18637/jss.v033.i01">doi:10.18637/jss.v033.i01</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Quick example for multivariate linear model with multivariate response

# Simulate data
n &lt;- 100
p &lt;- 10; q &lt;- 5
set.seed(123456)
x &lt;- matrix(rnorm(n * p, sd = rep(1:p, each = n)), nrow = n, ncol = p)
e &lt;- matrix(rnorm(n * q, sd = rep(q:1, each = n)), nrow = n, ncol = q)
beta &lt;- matrix(((1:p - 1) / p)^2, nrow = p, ncol = q)
y &lt;- x %*% beta + e

# Fit lasso (model with intercept, the default)
cv_glmnet(x = x, y = y, alpha = "lasso", cv_verbose = TRUE)$beta_hat

## Multivariate linear model with multivariate response

# Simulate data
n &lt;- 100
p &lt;- 10; q &lt;- 5
set.seed(123456)
x &lt;- matrix(rnorm(n * p, sd = rep(1:p, each = n)), nrow = n, ncol = p)
e &lt;- matrix(rnorm(n * q, sd = rep(q:1, each = n)), nrow = n, ncol = q)
beta &lt;- matrix(((1:p - 1) / p)^2, nrow = p, ncol = q)
y &lt;- x %*% beta + e

# Fit ridge
cv0 &lt;- cv_glmnet(x = x, y = y, alpha = "ridge", intercept = FALSE,
                 cv_verbose = TRUE)
cv0$beta_hat

# Same fit for the chosen lambda
cv_glmnet(x = x, y = y, alpha = "ridge", lambda = cv0$lambda,
          intercept = FALSE)$beta_hat

# Fit lasso (model with intercept, the default)
cv1 &lt;- cv_glmnet(x = x, y = y, alpha = "lasso", cv_verbose = TRUE)
cv1$beta_hat

# Use cv_1se = FALSE
cv1_min &lt;- cv_glmnet(x = x, y = y, alpha = "lasso", cv_verbose = TRUE,
                     cv_1se = FALSE)

# Compare it with ridge analytical solution. Observe the factor in lambda,
# necessary since lambda is searched for the standardized data. Note also
# that, differently to the case q = 1, no standardarization with respect to
# y happens
sd_x &lt;- apply(x, 2, function(x) sd(x)) * sqrt((n - 1) / n)
cv_glmnet(x = x, y = y, alpha = "ridge", lambda = cv0$lambda,
          thresh = 1e-20, intercept = FALSE)$beta_hat
solve(crossprod(x) + diag(cv0$lambda * sd_x^2 * n)) %*% t(x) %*% y

# If x is standardized, the match between glmnet and usual ridge
# analytical expression does not require scaling of lambda
x_std &lt;- scale(x, scale = sd_x, center = TRUE)
cv_glmnet(x = x_std, y = y, alpha = "ridge", lambda = cv0$lambda,
          intercept = FALSE, thresh = 1e-20)$beta_hat
solve(crossprod(x_std) + diag(rep(cv0$lambda * n, p))) %*% t(x_std) %*% y

## Simple linear model

# Simulate data
n &lt;- 100
p &lt;- 1; q &lt;- 1
set.seed(123456)
x &lt;- matrix(rnorm(n * p), nrow = n, ncol = p)
e &lt;- matrix(rnorm(n * q), nrow = n, ncol = q)
beta &lt;- 2
y &lt;- x * beta + e

# Fit by ridge (model with intercept, the default)
cv0 &lt;- cv_glmnet(x = x, y = y, alpha = "ridge", cv_verbose = TRUE)
cv0$beta_hat
cv0$intercept

# Comparison with linear model with intercept
lm(y ~ 1 + x)$coefficients

# Fit by ridge (model without intercept)
cv0 &lt;- cv_glmnet(x = x, y = y, alpha = "ridge", cv_verbose = TRUE,
                 intercept = FALSE)
cv0$beta_hat

# Comparison with linear model without intercept
lm(y ~ 0 + x)$coefficients

# Same fit for the chosen lambda (and without intercept)
cv_glmnet(x = x, y = y, alpha = "ridge", lambda = cv0$lambda,
          intercept = FALSE)$beta_hat

# Same for lasso (model with intercept, the default)
cv1 &lt;- cv_glmnet(x = x, y = y, alpha = "lasso")
cv1$beta_hat

## Multivariate linear model (p = 3, q = 1)

# Simulate data
n &lt;- 50
p &lt;- 10; q &lt;- 1
set.seed(123456)
x &lt;- matrix(rnorm(n * p, mean = 1, sd = rep(1:p, each = n)),
            nrow = n, ncol = p)
e &lt;- matrix(rnorm(n * q), nrow = n, ncol = q)
beta &lt;- ((1:p - 1) / p)^2
y &lt;- x %*% beta + e

# Fit ridge (model without intercept)
cv0 &lt;- cv_glmnet(x = x, y = y, alpha = "ridge", intercept = FALSE,
                 cv_verbose = TRUE)
cv0$beta_hat

# Same fit for the chosen lambda
cv_glmnet(x = x, y = y, alpha = "ridge", lambda = cv0$lambda,
          intercept = FALSE)$beta_hat

# Compare it with ridge analytical solution. Observe the factor in lambda,
# necessary since lambda is searched for the standardized data
sd_x &lt;- apply(x, 2, function(x) sd(x)) * sqrt((n - 1) / n)
sd_y &lt;- sd(y) * sqrt((n - 1) / n)
cv_glmnet(x = x, y = y, alpha = "ridge", lambda = cv0$lambda,
          intercept = FALSE, thresh = 1e-20)$beta_hat
solve(crossprod(x) + diag(cv0$lambda * sd_x^2 / sd_y * n)) %*% t(x) %*% y

# If x and y are standardized, the match between glmnet and usual ridge
# analytical expression does not require scaling of lambda
x_std &lt;- scale(x, scale = sd_x, center = TRUE)
y_std &lt;- scale(y, scale = sd_y, center = TRUE)
cv_glmnet(x = x_std, y = y_std, alpha = "ridge", lambda = cv0$lambda,
          intercept = FALSE, thresh = 1e-20)$beta_hat
solve(crossprod(x_std) + diag(rep(cv0$lambda * n, p))) %*% t(x_std) %*% y_std

# Fit lasso (model with intercept, the default)
cv1 &lt;- cv_glmnet(x = x, y = y, alpha = "lasso", cv_verbose = TRUE)
cv1$beta_hat

# ## Parallelization
#
# # Parallel
# doMC::registerDoMC(cores = 2)
# microbenchmark::microbenchmark(
# cv_glmnet(x = x, y = y, nlambda = 100, cv_parallel = TRUE),
# cv_glmnet(x = x, y = y, nlambda = 100, cv_parallel = FALSE),
# times = 10)

</code></pre>

<hr>
<h2 id='elem-flmfr'>Covariate, error, and kernel of a functional linear model
with functional response</h2><span id='topic+elem-flmfr'></span><span id='topic+r_cm2013_flmfr'></span><span id='topic+r_ik2018_flmfr'></span><span id='topic+r_gof2021_flmfr'></span>

<h3>Description</h3>

<p>Simulation of <code class="reqn">X</code>, a random variable in the Hilbert space
of square-integrable functions in <code class="reqn">[a, b]</code>, <code class="reqn">L^2([a, b])</code>, and
<code class="reqn">\varepsilon</code>, a random variable in <code class="reqn">L^2([c, d])</code>.
Together with the bivariate kernel <code class="reqn">\beta</code>, they are the necessary
elements for sampling a Functional Linear Model with  Functional Response
(FLMFR):
</p>
<p style="text-align: center;"><code class="reqn">Y(t) = \int_a^b X(s) \beta(s,t) ds + \varepsilon(t).</code>
</p>

<p>The next functions sample <code class="reqn">X</code> and <code class="reqn">\varepsilon</code>, and
construct <code class="reqn">\beta</code>, using different proposals in the literature:
</p>

<ul>
<li><p><code>r_cm2013_flmfr</code> is based on the numerical example given in
Section 3 of Crambes and Mas (2013). Termed as S1 in Section 2 of
García-Portugués et al. (2021).
</p>
</li>
<li><p><code>r_ik2018_flmfr</code> is based on the numerical example given in
Section 4 of Imaizumi and Kato (2018), but zeroing the first Functional
Principal Components (FPC) coefficients of <code class="reqn">\beta</code> (so the first FPC
are not adequate for estimation). S3 in Section 2 of
García-Portugués et al. (2021).
</p>
</li>
<li><p><code>r_gof2021_flmfr</code> gives a numerical example in Section 2
of García-Portugués et al. (2021), denoted therein as S2.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>r_cm2013_flmfr(n, s = seq(0, 1, len = 101), t = seq(0, 1, len = 101),
  std_error = 0.15, n_fpc = 50, concurrent = FALSE)

r_ik2018_flmfr(n, s = seq(0, 1, l = 101), t = seq(0, 1, l = 101),
  std_error = 1.5, parameters = c(1.75, 0.8, 2.4, 0.25), n_fpc = 50,
  concurrent = FALSE)

r_gof2021_flmfr(n, s = seq(0, 1, len = 101), t = seq(0, 1, len = 101),
  std_error = 0.35, concurrent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elem-flmfr_+3A_n">n</code></td>
<td>
<p>number of trajectories to sample.</p>
</td></tr>
<tr><td><code id="elem-flmfr_+3A_s">s</code>, <code id="elem-flmfr_+3A_t">t</code></td>
<td>
<p>grid points where functional covariates and responses are valued,
respectively.</p>
</td></tr>
<tr><td><code id="elem-flmfr_+3A_std_error">std_error</code></td>
<td>
<p>standard deviation of the random variables
involved in the generation of the functional error <code>error_fdata</code>.
Defaults to <code>0.15</code>.</p>
</td></tr>
<tr><td><code id="elem-flmfr_+3A_n_fpc">n_fpc</code></td>
<td>
<p>number of FPC to be taken into account for the data generation.
Must be greater than <code>4</code> when <code>r_ik2018_flmfr</code> is applied, since
the first <code class="reqn">4</code> FPC are null. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="elem-flmfr_+3A_concurrent">concurrent</code></td>
<td>
<p>flag to consider a concurrent FLMFR (degenerate case).
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="elem-flmfr_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameters, only required for
<code>r_ik2018_flmfr</code>. Defaults to<br /> <code>c(1.75, 0.8, 2.4, 0.25)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Descriptions of the processes <code class="reqn">X</code> and <code class="reqn">\varepsilon</code>,
and of <code class="reqn">\beta</code> can be seen in the references.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>X_fdata</code></td>
<td>
<p>functional covariates, an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of length <code>n</code>.</p>
</td></tr>
<tr><td><code>error_fdata</code></td>
<td>
<p>functional errors, an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of length <code>n</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>either the matrix with <code class="reqn">\beta(s, t)</code> evaluated at
the <code>argvals</code> of <code>X_fdata</code> and <code>Y_fdata</code> (if
<code>concurrent = FALSE</code>) or a vector with <code class="reqn">\beta(t)</code>
evaluated at the <code>argvals</code> of <code>X_fdata</code> (if
<code>concurrent = TRUE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javier Álvarez-Liébana.
</p>


<h3>References</h3>

<p>Cardot, H. and Mas, A. (2013). Asymptotics of prediction in functional linear
regression with functional outputs. <em>Bernoulli</em>, 19(5B):2627&ndash;2651.
<a href="https://doi.org/10.3150/12-BEJ469">doi:10.3150/12-BEJ469</a>
</p>
<p>Imaizumi, M. and Kato, K. (2018). PCA-based estimation for functional linear
regression with functional responses. <em>Journal of Multivariate
Analysis</em>, 163:15&ndash;36. <a href="https://doi.org/10.1016/j.jmva.2017.10.001">doi:10.1016/j.jmva.2017.10.001</a>
</p>
<p>García-Portugués, E., Álvarez-Liébana, J., Álvarez-Pérez, G. and
Gonzalez-Manteiga, W. (2021). A goodness-of-fit test for the functional
linear model with functional response. <em>Scandinavian Journal of
Statistics</em>, 48(2):502&ndash;528. <a href="https://doi.org/10.1111/sjos.12486">doi:10.1111/sjos.12486</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># FLMFR based on Imaizumi and Kato (2018) adopting different Hilbert spaces
s &lt;- seq(0, 1, l = 201)
t &lt;- seq(2, 4, l = 301)
r_ik2018 &lt;- r_ik2018_flmfr(n = 50, s = s, t = t, std_error = 1.5,
                           parameters = c(1.75, 0.8, 2.4, 0.25), n_fpc = 50)
plot(r_ik2018$X_fdata)
plot(r_ik2018$error_fdata)
image(x = s, y = t, z = r_ik2018$beta, col = viridisLite::viridis(20))

# FLMFR based on Cardot and Mas (2013) adopting different Hilbert spaces
r_cm2013 &lt;- r_cm2013_flmfr(n = 50, s = s, t = t, std_error = 0.15,
                           n_fpc = 50)
plot(r_cm2013$X_fdata)
plot(r_cm2013$error_fdata)
image(x = s, y = t, z = r_cm2013$beta, col = viridisLite::viridis(20))

# FLMFR in García-Portugués et al. (2021) adopting different Hilbert spaces
r_gof2021 &lt;- r_gof2021_flmfr(n = 50, s = s, t = t, std_error = 0.35,
                             concurrent = FALSE)
plot(r_gof2021$X_fdata)
plot(r_gof2021$error_fdata)
image(x = s, y = t, z = r_gof2021$beta, col = viridisLite::viridis(20))

# Concurrent model in García-Portugués et al. (2021)
r_gof2021 &lt;- r_gof2021_flmfr(n = 50, s = s, t = s, std_error = 0.35,
                             concurrent = TRUE)
plot(r_gof2021$X_fdata)
plot(r_gof2021$error_fdata)
plot(r_gof2021$beta)
</code></pre>

<hr>
<h2 id='fda.usc_efic'>Auxiliary functions for the <span class="pkg">goffda</span> package</h2><span id='topic+fda.usc_efic'></span><span id='topic+fdata_cen'></span><span id='topic+func_mean'></span><span id='topic+inprod_fdata'></span>

<h3>Description</h3>

<p>Auxiliary functions required for the methods
implemented in the <span class="pkg">goffda</span> package, as enhancements of the auxiliary
functions <code><a href="fda.usc.html#topic+fdata.cen">fdata.cen</a></code> and
<code><a href="fda.usc.html#topic+Descriptive">func.mean</a></code> from the
<code><a href="fda.usc.html#topic+fda.usc-package">fda.usc-package</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdata_cen(X_fdata, mean_X = func_mean(X_fdata))

func_mean(X_fdata)

inprod_fdata(X_fdata1, X_fdata2 = NULL, int_rule = "trapezoid",
  as_matrix = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fda.usc_efic_+3A_x_fdata">X_fdata</code></td>
<td>
<p>sample of functional data as an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="fda.usc_efic_+3A_mean_x">mean_X</code></td>
<td>
<p>functional mean of <code>X_fdata</code>.</p>
</td></tr>
<tr><td><code id="fda.usc_efic_+3A_x_fdata1">X_fdata1</code>, <code id="fda.usc_efic_+3A_x_fdata2">X_fdata2</code></td>
<td>
<p>samples of functional
data as <code><a href="fda.usc.html#topic+fdata">fdata</a></code> objects of lengths <code class="reqn">n_1</code>
and <code class="reqn">n_2</code>, respectively. Sample sizes can be different.</p>
</td></tr>
<tr><td><code id="fda.usc_efic_+3A_int_rule">int_rule</code></td>
<td>
<p>quadrature rule for approximating the definite
unidimensional integral: trapezoidal rule (<code>int_rule = "trapezoid"</code>)
and extended Simpson rule (<code>int_rule = "Simpson"</code>) are available.
Defaults to <code>"trapezoid"</code>.</p>
</td></tr>
<tr><td><code id="fda.usc_efic_+3A_as_matrix">as_matrix</code></td>
<td>
<p>flag to indicate if <code>inprod_fdata</code> returns a matrix
or the vector of its lower triangular part in column-major order.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fda.usc_efic_+3A_verbose">verbose</code></td>
<td>
<p>whether to show or not information about the
<code>inprod_fdata</code> procedure.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>func_mean</code>: computes the functional mean of
<code>X_fdata</code>.
</p>
</li>
<li><p><code>fdata_cen</code>: centers the
functional data <code>X_fdata</code>.
</p>
</li>
<li><p><code>inprod_fdata(X_fdata1)</code>:  computes as a row vector the
elements of the lower triangular part of the inner products matrix
(<code>X_fdata</code> vs <code>X_fdata</code>). If <code>as_matrix = TRUE</code>, the
matrix of inner products is given.
</p>
</li>
<li><p><code>inprod_fdata(X_fdata1, X_fdata2)</code>: computes the matrix of
inner products (<code>as_matrix = TRUE</code> is forced) between <code>X_fdata1</code>
and <code>X_fdata2</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Code iterated by Eduardo García-Portugués, Gonzalo Álvarez-Pérez,
and Javier Álvarez-Liébana from the <code><a href="fda.usc.html#topic+fda.usc-package">fda.usc-package</a></code>
originals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## fdata_cen() vs fda.usc::fdata_cen()

data(phoneme, package = "fda.usc")
mlearn &lt;- phoneme$learn[1:10, ]
plot(fda.usc::fdata.cen(mlearn)$Xcen)
plot(fdata_cen(mlearn))

## inprod_fdata() vs fda.usc::inprod.fdata()

# inprod_fdata between mlearn and mlearn: as a row vector

A &lt;- fda.usc::inprod.fdata(fdata1 = mlearn)
A[upper.tri(A, diag = TRUE)]
inprod_fdata(X_fdata1 = mlearn, int_rule = "trapezoid", as_matrix = FALSE)

# inprod_fdata between mlearn and mlearn: as a matrix

A &lt;- fda.usc::inprod.fdata(fdata1 = mlearn)
A
inprod_fdata(X_fdata1 = mlearn, int_rule = "trapezoid", as_matrix = TRUE)

# inprod_fdata between mlearn and mlearn2: as a matrix

mlearn2 &lt;- phoneme$learn[11:30, ]
A &lt;- fda.usc::inprod.fdata(fdata1 = mlearn, fdata2 = mlearn2)
A
B &lt;- inprod_fdata(X_fdata1 = mlearn, X_fdata2 = mlearn2,
int_rule = "trapezoid", as_matrix = TRUE)
B

## Efficiency comparisons

microbenchmark::microbenchmark(fda.usc::fdata.cen(mlearn), fdata_cen(mlearn),
                               times = 1e3, control = list(warmup = 20))

microbenchmark::microbenchmark(fda.usc::inprod.fdata(fdata1 = mlearn),
                               inprod_fdata(X_fdata1 = mlearn,
                               as_matrix = FALSE), times = 1e3,
                               control = list(warmup = 20))

</code></pre>

<hr>
<h2 id='flm_est'>Estimation of functional linear models</h2><span id='topic+flm_est'></span>

<h3>Description</h3>

<p>Estimation of the linear operator relating a
functional predictor <code class="reqn">X</code> with a functional response <code class="reqn">Y</code> in the
linear model
</p>
<p style="text-align: center;"><code class="reqn">Y(t) = \int_a^b \beta(s, t) X(s)\,\mathrm{d}s + \varepsilon(t),</code>
</p>

<p>where <code class="reqn">X</code> is a random variable in the Hilbert space of
square-integrable functions in <code class="reqn">[a, b]</code>, <code class="reqn">L^2([a, b])</code>,
<code class="reqn">Y</code> and <code class="reqn">\varepsilon</code> are random variables
in <code class="reqn">L^2([c, d])</code>, and <code class="reqn">s \in [a, b]</code> and <code class="reqn">t \in [c, d]</code>.
</p>
<p>The linear, Hilbert&ndash;Schmidt, integral operator is parametrized by
the bivariate kernel <code class="reqn">\beta \in L^2([a, b]) \otimes
L^2([c, d])</code>. Its estimation is done through the truncated expansion
of <code class="reqn">\beta</code> in the tensor product of the data-driven
bases of the Functional Principal Components (FPC) of
<code class="reqn">X</code> and <code class="reqn">Y</code>, and through the fitting of the resulting multivariate
linear model. The FPC basis for <code class="reqn">X</code> is truncated in <code class="reqn">p</code>
components, while the FPC basis for <code class="reqn">Y</code> is truncated in <code class="reqn">q</code>
components. Automatic selection of <code class="reqn">p</code> and <code class="reqn">q</code> is detailed below.
</p>
<p>The particular cases in which either <code class="reqn">X</code> or <code class="reqn">Y</code> are
<em>constant</em> functions give either a scalar predictor or response.
The simple linear model arises if both <code class="reqn">X</code> and <code class="reqn">Y</code> are scalar,
for which <code class="reqn">\beta</code> is a constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flm_est(X, Y, est_method = "fpcr_l1s", p = NULL, q = NULL,
  thre_p = 0.99, thre_q = 0.99, lambda = NULL, X_fpc = NULL,
  Y_fpc = NULL, compute_residuals = TRUE, centered = FALSE,
  int_rule = "trapezoid", cv_verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flm_est_+3A_x">X</code>, <code id="flm_est_+3A_y">Y</code></td>
<td>
<p>samples of functional/scalar predictors and functional/scalar
response. Either <code><a href="fda.usc.html#topic+fdata">fdata</a></code> objects (for functional
variables) or vectors of length <code>n</code> (for scalar variables).</p>
</td></tr>
<tr><td><code id="flm_est_+3A_est_method">est_method</code></td>
<td>
<p>either <code>"fpcr"</code> (Functional Principal Components
Regression; FPCR), <code>"fpcr_l2"</code> (FPCR with ridge penalty),
<code>"fpcr_l1"</code> (FPCR with lasso penalty) or <code>"fpcr_l1s"</code>
(FPCR with lasso-selected FPC). If <code>X</code> is scalar, <code>flm_est</code>
only considers <code>"fpcr"</code> as estimation method. See details below.
Defaults to <code>"fpcr_l1s"</code>.</p>
</td></tr>
<tr><td><code id="flm_est_+3A_p">p</code>, <code id="flm_est_+3A_q">q</code></td>
<td>
<p>index vectors indicating the specific FPC to be
considered for the truncated bases expansions of <code>X</code> and <code>Y</code>,
respectively. If a single number for <code>p</code> is provided, then
<code>p &lt;- 1:max(p)</code> internally (analogously for <code>q</code>) and the first
<code>max(p)</code> FPC are considered. If <code>NULL</code> (default), then a
data-driven selection of <code>p</code> and <code>q</code> is done. See details below.</p>
</td></tr>
<tr><td><code id="flm_est_+3A_thre_p">thre_p</code>, <code id="flm_est_+3A_thre_q">thre_q</code></td>
<td>
<p>thresholds for the <em>proportion</em> of variance
that is explained, <em>at least</em>, by the first <code class="reqn">p</code> and <code class="reqn">q</code> FPC
of <code>X</code> and <code>Y</code>, respectively. These thresholds are employed
for an (initial) automatic selection of <code class="reqn">p</code> and <code class="reqn">q</code>.
Default to <code>0.99</code>. <code>thre_p</code> (<code>thre_q</code>) is ignored if
<code>p</code> (<code>q</code>) is provided.</p>
</td></tr>
<tr><td><code id="flm_est_+3A_lambda">lambda</code></td>
<td>
<p>regularization parameter <code class="reqn">\lambda</code> for the estimation
methods <code>"fpcr_l2"</code>, <code>"fpcr_l1"</code>, and <code>"fpcr_l1s"</code>. If
<code>NULL</code> (default), it is chosen with <code><a href="#topic+cv_glmnet">cv_glmnet</a></code>.</p>
</td></tr>
<tr><td><code id="flm_est_+3A_x_fpc">X_fpc</code>, <code id="flm_est_+3A_y_fpc">Y_fpc</code></td>
<td>
<p>FPC decompositions of <code>X</code> and <code>Y</code>, as
returned by <code><a href="#topic+fpc">fpc</a></code>. Computed if not provided.</p>
</td></tr>
<tr><td><code id="flm_est_+3A_compute_residuals">compute_residuals</code></td>
<td>
<p>whether to compute the fitted values <code>Y_hat</code>
and its <code>Y_hat_scores</code>, and the <code>residuals</code> of the fit
and its <code>residuals_scores</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="flm_est_+3A_centered">centered</code></td>
<td>
<p>flag to indicate if <code>X</code> and <code>Y</code> have been
centered or not, in order to avoid their recentering. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flm_est_+3A_int_rule">int_rule</code></td>
<td>
<p>quadrature rule for approximating the definite
unidimensional integral: trapezoidal rule (<code>int_rule = "trapezoid"</code>)
and extended Simpson rule (<code>int_rule = "Simpson"</code>) are available.
Defaults to <code>"trapezoid"</code>.</p>
</td></tr>
<tr><td><code id="flm_est_+3A_cv_verbose">cv_verbose</code></td>
<td>
<p>flag to display information about the estimation procedure
(passed to <code><a href="#topic+cv_glmnet">cv_glmnet</a></code>). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flm_est_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to <code><a href="#topic+cv_glmnet">cv_glmnet</a></code>
(and then to <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>) such as <code>cv_1se</code>,
<code>cv_nlambda</code> or <code>cv_parallel</code>, among others.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>flm_est</code> deals seamlessly with either functional or scalar inputs
for the predictor and response. In the case of scalar inputs, the
corresponding dimension-related arguments (<code>p</code>, <code>q</code>,
<code>thre_p</code> or <code>thre_q</code>) will be ignored as in these cases either
<code class="reqn">p = 1</code> or <code class="reqn">q = 1</code>.
</p>
<p>The function translates the functional linear model into a multivariate
model with multivariate response and then estimates the
<code class="reqn">p \times q</code> matrix of coefficients of <code class="reqn">\beta</code> in the
tensor basis of the FPC of <code>X</code> and <code>Y</code>. The following estimation
methods are implemented:
</p>

<ul>
<li> <p><code>"fpcr"</code>: Functional Principal Components Regression (FPCR);
see details in Ramsay and Silverman (2005).
</p>
</li>
<li> <p><code>"fpcr_l2"</code>: FPCR, with ridge penalty on the associated
multivariate linear model.
</p>
</li>
<li> <p><code>"fpcr_l1"</code>: FPCR, with lasso penalty on the associated
multivariate linear model.
</p>
</li>
<li> <p><code>"fpcr_l1s"</code>: FPCR, with FPC selected by lasso regression
on the associated multivariate linear model.
</p>
</li></ul>

<p>The last three methods are explained in García-Portugués et al. (2021).
</p>
<p>The <code class="reqn">p</code> FPC of <code>X</code> and <code class="reqn">q</code> FPC of <code>Y</code> are determined
as follows:
</p>

<ul>
<li><p> If <code>p = NULL</code>, then <code>p</code> is set as
<code>p_thre &lt;- 1:j_thre</code>, where <code>j_thre</code> is the <code class="reqn">j</code>-th FPC of
<code>X</code> for which the cumulated proportion of explained variance is
greater than <code>thre_p</code>. If <code>p != NULL</code>, then <code>p_thre &lt;- p</code>.
</p>
</li>
<li><p> If <code>q = NULL</code>, then the same procedure is followed with
<code>thre_q</code>, resulting <code>q_thre</code>.
</p>
</li></ul>

<p>Once <code>p_thre</code> and <code>q_thre</code> have been obtained, the methods
<code>"fpcr_l1"</code> and <code>"fpcr_l1s"</code> perform a second selection
of the FPC that are effectively considered in the estimation of <code class="reqn">\beta</code>.
This subset of FPC (of <code>p_thre</code>) is encoded in <code>p_hat</code>. No further
selection of FPC is done for the methods <code>"fpcr"</code> and <code>"fpcr_l2"</code>.
</p>
<p>The flag <code>compute_residuals</code> controls if <code>Y_hat</code>,
<code>Y_hat_scores</code>, <code>residuals</code>, and <code>residuals_scores</code> are
computed. If <code>FALSE</code>, they are set to <code>NULL</code>. <code>Y_hat</code> equals
<code class="reqn">\hat Y_i(t) = \int_a^b \hat \beta(s, t) X_i(s) \,\mathrm{d}s</code> and <code>residuals</code>
stands for <code class="reqn">\hat \varepsilon_i(t) = Y_i(t) - \hat Y_i(t)</code>, both for
<code class="reqn">i = 1, \ldots, n</code>. <code>Y_hat_scores</code> and<br /> <code>residuals_scores</code>
are the <code class="reqn">n\times q</code> matrices of coefficients (or scores) of these
functions in the FPC of <code>Y</code>.
</p>
<p>Missing values on <code>X</code> and <code>Y</code> are automatically removed.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>
<table>
<tr><td><code>Beta_hat</code></td>
<td>
<p>estimated <code class="reqn">\beta</code>, a matrix with values
<code class="reqn">\hat\beta(s, t)</code> evaluated at the grid points for <code>X</code>
and <code>Y</code>. Its size is <code>c(length(X$argvals), length(Y$argvals))</code>.</p>
</td></tr>
<tr><td><code>Beta_hat_scores</code></td>
<td>
<p>the matrix of coefficients of <code>Beta_hat</code>
(resulting from projecting it into the tensor basis of <code>X_fpc</code> and
<code>Y_fpc</code>), with dimension <code>c(p_hat, q_thre)</code>.</p>
</td></tr>
<tr><td><code>H_hat</code></td>
<td>
<p>hat matrix of the associated fitted multivariate
linear model, a matrix of size <code>c(n, n)</code>. <code>NULL</code> if
<code>est_method = "fpcr_l1"</code>, since lasso estimation does not provide it
explicitly.</p>
</td></tr>
<tr><td><code>p_thre</code></td>
<td>
<p>index vector indicating the FPC of <code>X</code>
considered for estimating the model. Chosen by <code>thre_p</code> or equal
to <code>p</code> if given.</p>
</td></tr>
<tr><td><code>p_hat</code></td>
<td>
<p>index vector of the FPC considered by the methods
<code>"fpcr_l1"</code> and <code>"fpcr_l1s"</code> methods after further selection
of the FPC considered in <code>p_thre</code>. For methods <code>"fpcr"</code> and
<code>"fpcr_l2"</code>, <code>p_hat</code> equals <code>p_thre</code>.</p>
</td></tr>
<tr><td><code>q_thre</code></td>
<td>
<p>index vector indicating the FPC of <code>Y</code>
considered for estimating the model. Chosen by <code>thre_q</code> or equal
to <code>q</code> if given. Note that zeroing by lasso procedure only affects
in the rows.</p>
</td></tr>
<tr><td><code>est_method</code></td>
<td>
<p>the estimation method employed.</p>
</td></tr>
<tr><td><code>Y_hat</code></td>
<td>
<p>fitted values, either an <code><a href="fda.usc.html#topic+fdata">fdata</a></code>
object or a vector, depending on <code>Y</code>.</p>
</td></tr>
<tr><td><code>Y_hat_scores</code></td>
<td>
<p>the matrix of coefficients of <code>Y_hat</code>, with
dimension <code>c(n, q_thre)</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals of the fitted model, either an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object or a vector, depending on <code>Y</code>.</p>
</td></tr>
<tr><td><code>residuals_scores</code></td>
<td>
<p>the matrix of coefficients of
<code>residuals</code>, with dimension <code>c(n, q_thre)</code>.</p>
</td></tr>
<tr><td><code>X_fpc</code>, <code>Y_fpc</code></td>
<td>
<p>FPC of <code>X</code> and <code>Y</code>, as
returned by <code><a href="#topic+fpc">fpc</a></code> with <code>n_fpc = n</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>regularization parameter <code class="reqn">\lambda</code> used for the
estimation methods <code>"fpcr_l2"</code>, <code>"fpcr_l1"</code>, and
<code>"fpcr_l1s"</code>.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>cross-validation object returned by
<code><a href="#topic+cv_glmnet">cv_glmnet</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués and Javier Álvarez-Liébana.
</p>


<h3>References</h3>

<p>García-Portugués, E., Álvarez-Liébana, J., Álvarez-Pérez, G. and
Gonzalez-Manteiga, W. (2021). A goodness-of-fit test for the functional
linear model with functional response. <em>Scandinavian Journal of
Statistics</em>, 48(2):502&ndash;528. <a href="https://doi.org/10.1111/sjos.12486">doi:10.1111/sjos.12486</a>
</p>
<p>Ramsay, J. and Silverman, B. W. (2005). <em>Functional Data Analysis</em>.
Springer-Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Quick example of functional response and functional predictor

# Generate data
set.seed(12345)
n &lt;- 50
X_fdata &lt;- r_ou(n = n, t = seq(0, 1, l = 201), sigma = 2)
epsilon &lt;- r_ou(n = n, t = seq(0, 1, l = 201), sigma = 0.5)
Y_fdata &lt;- 2 * X_fdata + epsilon

# Lasso-selection FPCR (p and q are estimated)
flm_est(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1s")

## Functional response and functional predictor

# Generate data
set.seed(12345)
n &lt;- 50
X_fdata &lt;- r_ou(n = n, t = seq(0, 1, l = 201), sigma = 2)
epsilon &lt;- r_ou(n = n, t = seq(0, 1, l = 201), sigma = 0.5)
Y_fdata &lt;- 2 * X_fdata + epsilon

# FPCR (p and q are estimated)
fpcr_1 &lt;- flm_est(X = X_fdata, Y = Y_fdata, est_method = "fpcr")
fpcr_1$Beta_hat_scores
fpcr_1$p_thre
fpcr_1$q_thre

# FPCR (p and q are provided)
fpcr_2 &lt;- flm_est(X = X_fdata, Y = Y_fdata, est_method = "fpcr",
                  p = c(1, 5, 2, 7), q = 2:1)
fpcr_2$Beta_hat_scores
fpcr_2$p_thre
fpcr_2$q_thre

# Ridge FPCR (p and q are estimated)
l2_1 &lt;- flm_est(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l2")
l2_1$Beta_hat_scores
l2_1$p_hat

# Ridge FPCR (p and q are provided)
l2_2 &lt;- flm_est(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l2",
                p = c(1, 5, 2, 7), q = 2:1)
l2_2$Beta_hat_scores
l2_2$p_hat

# Lasso FPCR (p and q are estimated)
l1_1 &lt;- flm_est(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1")
l1_1$Beta_hat_scores
l1_1$p_thre
l1_1$p_hat

# Lasso estimator (p and q are provided)
l1_2 &lt;- flm_est(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1",
                p = c(1, 5, 2, 7), q = 2:1)
l1_2$Beta_hat_scores
l1_2$p_thre
l1_2$p_hat

# Lasso-selection FPCR (p and q are estimated)
l1s_1 &lt;- flm_est(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1s")
l1s_1$Beta_hat_scores
l1s_1$p_thre
l1s_1$p_hat

# Lasso-selection FPCR (p and q are provided)
l1s_2 &lt;- flm_est(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1s",
                 p = c(1, 5, 2, 7), q = 1:4)
l1s_2$Beta_hat_scores
l1s_2$p_thre
l1s_2$p_hat

## Scalar response

# Generate data
set.seed(12345)
n &lt;- 50
beta &lt;- r_ou(n = 1, t = seq(0, 1, l = 201), sigma = 0.5, x0 = 3)
X_fdata &lt;- fdata_cen(r_ou(n = n, t = seq(0, 1, l = 201), sigma = 2))
epsilon &lt;- rnorm(n, sd = 0.25)
Y &lt;- drop(inprod_fdata(X_fdata1 = X_fdata, X_fdata2 = beta)) + epsilon

# FPCR
fpcr_4 &lt;- flm_est(X = X_fdata, Y = Y, est_method = "fpcr")
fpcr_4$p_hat

# Ridge FPCR
l2_4 &lt;- flm_est(X = X_fdata, Y = Y, est_method = "fpcr_l2")
l2_4$p_hat

# Lasso FPCR
l1_4 &lt;- flm_est(X = X_fdata, Y = Y, est_method = "fpcr_l1")
l1_4$p_hat

# Lasso-selection FPCR
l1s_4 &lt;- flm_est(X = X_fdata, Y = Y, est_method = "fpcr_l1s")
l1s_4$p_hat

## Scalar predictor

# Generate data
set.seed(12345)
n &lt;- 50
X &lt;- rnorm(n)
epsilon &lt;- r_ou(n = n, t = seq(0, 1, l = 201), sigma = 0.5)
beta &lt;- r_ou(n = 1, t = seq(0, 1, l = 201), sigma = 0.5, x0 = 3)
beta$data &lt;- matrix(beta$data, nrow = n, ncol = ncol(beta$data),
                    byrow = TRUE)
Y_fdata &lt;- beta * X + epsilon

# FPCR
fpcr_4 &lt;- flm_est(X = X, Y = Y_fdata, est_method = "fpcr")
plot(beta, col = 2)
lines(beta$argvals, drop(fpcr_4$Beta_hat))

</code></pre>

<hr>
<h2 id='flm_stat'>Projected Cramér&ndash;von Mises test statistic for the
goodness-of-fit test of functional linear models</h2><span id='topic+flm_stat'></span><span id='topic+Adot'></span>

<h3>Description</h3>

<p>Computation of the Projected Cramér&ndash;von Mises (PCvM) test
statistic and its associated <code class="reqn">\mathbf{A}_\bullet</code> matrix.
For a sample of functional covariates <code class="reqn">X_1, \ldots, X_n</code>, the test
statistic is computed from
<code class="reqn">\mathbf{x}_{1,p}, \ldots, \mathbf{x}_{n,p}</code>,
the coefficients (scores) of the sample in a <code class="reqn">p</code>-truncated basis
expansion, such as Functional Principal Components (FPC).
</p>
<p>The PCvM statistic is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{PCvM}_{n,p,q} = c \cdot \mathrm{tr}(\hat{\mathbf{E}}_q'
\mathbf{A}_\bullet \hat{\mathbf{E}}_q)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">c = 2 \pi^{(p + q) / 2 - 1} / (q \Gamma(p / 2) \Gamma(q / 2) n^2),</code>
</p>

<p><code class="reqn">\hat{\mathbf{E}}_q</code> is the <code class="reqn">n \times q</code>
matrix of multivariate residuals, and
<code class="reqn">\mathbf{A}_\bullet</code> is a <code class="reqn">n \times n</code>
matrix whose <code class="reqn">ij</code>-th element is
<code class="reqn">\sum_{r = 1}^n A_{ijr}</code>, for <code class="reqn">A_{ijr}</code> depending on
<code class="reqn">(\mathbf{x}_{i,p}, \mathbf{x}_{j,p}, \mathbf{x}_{r,p})</code>. Its exact expression can be seen in
Escanciano (2006) and García-Portugués et al. (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flm_stat(E, p, Adot_vec, constant = TRUE)

Adot(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flm_stat_+3A_e">E</code></td>
<td>
<p>the matrix of multivariate residuals, with dimension
<code>c(n, q)</code>. A vector if <code class="reqn">q = 1</code>.</p>
</td></tr>
<tr><td><code id="flm_stat_+3A_p">p</code></td>
<td>
<p>dimension of the covariates space. Must be a positive integer.</p>
</td></tr>
<tr><td><code id="flm_stat_+3A_adot_vec">Adot_vec</code></td>
<td>
<p>output from <code><a href="#topic+Adot">Adot</a></code>. A vector of length
<code>n * (n - 1) / 2 + 1</code>. This corresponds to the most expensive
computation in the test statistic.</p>
</td></tr>
<tr><td><code id="flm_stat_+3A_constant">constant</code></td>
<td>
<p>whether to include the constant of the PCvM test
statistic, <code class="reqn">c</code>, in its computation. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="flm_stat_+3A_x">X</code></td>
<td>
<p>a matrix of size <code>c(n, p)</code> containing the coefficients
(scores) of the functional data in a <code>p</code>-truncated <em>orthonormal</em>
basis expansion, such as FPC. Must not contain repeated rows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Adot</code> assumes that <code>X</code> does not have repeated rows or otherwise
<code>NaN</code>s will be present in the result. If <code>X</code> has repeated rows,
<code>Adot</code> will throw a warning.
</p>
<p>The implementation of the PCvM test statistic for scalar response is
addressed in García-Portugués et al. (2014), whereas García-Portugués et al.
(2021) presents its multivariate extension and shows that
<code class="reqn">\mathbf{A}_\bullet</code> induces a weighted quadratic norm (if
there are no repetitions in the sample). The PCvM statistic is rooted in
the proposal by Escanciano (2006).
</p>
<p>Both <code>flm_stat</code> and <code>A_dot</code> are coded in C++.
</p>


<h3>Value</h3>


<ul>
<li><p><code>flm_stat</code>: the value of the test statistic, a scalar.
</p>
</li>
<li><p><code>A_dot</code>: a vector of length <code>n * (n - 1) / 2 + 1</code>.
The first entry contains the common diagonal element of
<code class="reqn">\mathbf{A}_\bullet</code>. The remaining entries are the upper
triangular matrix (excluding the diagonal) of
<code class="reqn">\mathbf{A}_\bullet</code>, stacked by columns.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eduardo García-Portugués.
</p>


<h3>References</h3>

<p>García-Portugués, E., Álvarez-Liébana, J., Álvarez-Pérez, G. and
Gonzalez-Manteiga, W. (2021). A goodness-of-fit test for the functional
linear model with functional response. <em>Scandinavian Journal of
Statistics</em>, 48(2):502&ndash;528. <a href="https://doi.org/10.1111/sjos.12486">doi:10.1111/sjos.12486</a>
</p>
<p>Escanciano, J. C. (2006) A consistent diagnostic test for regression
models using projections. <em>Econometric Theory</em>, 22(6):1030–-1051.
<a href="https://doi.org/10.1017/S0266466606060506">doi:10.1017/S0266466606060506</a>
</p>
<p>García-Portugués, E., González-Manteiga, W. and Febrero-Bande, M. (2014). A
goodness-of-fit test for the functional linear model with scalar response.
<em>Journal of Computational and Graphical Statistics</em>, 23(3):761&ndash;778.
<a href="https://doi.org/10.1080/10618600.2013.812519">doi:10.1080/10618600.2013.812519</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## flm_stat

# Generate data
n &lt;- 200
q &lt;- 2
p &lt;- 3
E &lt;- matrix(rnorm(n * q), nrow = n, ncol = q)
X_fdata &lt;- r_ou(n = n, t = seq(0, 1, l = 101))

# Compute FPC
X_fpc &lt;- fpc(X_fdata)

# Adot
Adot_vec &lt;- Adot(X = X_fpc[["scores"]])

# Check equality
constant &lt;- n^(-2) * 2 * pi^((p / 2) - 1) / gamma(p / 2)
constant * .Fortran("pcvm_statistic", n = as.integer(n),
                    Adot_vec = Adot_vec, residuals = E[, 2],
                    statistic = 0)$statistic
flm_stat(E = E[, 2, drop = FALSE], p = p, Adot_vec = Adot_vec,
         constant = FALSE)

## Adot

# Generate data
n &lt;- 200
X_fdata &lt;- r_ou(n = n, t = seq(0, 1, l = 101))

# Compute FPC
X_fpc &lt;- fpc(X_fdata)

# Using inprod_fdata and Adot
Adot_vec &lt;- Adot(X = X_fpc[["scores"]])

# Check with fda.usc::Adot with adequate inprod
head(drop(Adot_vec))
head(fda.usc::Adot(X_fdata))

# Obtention of the entire Adot matrix
Ad &lt;- diag(rep(Adot_vec[1], n))
Ad[upper.tri(Ad, diag = FALSE)] &lt;- Adot_vec[-1]
head(Ad &lt;- t(Ad) + Ad - diag(diag(Ad)))

# Positive definite
eigen(Ad)$values

# # Warning if X contains repeated observations
# Adot(X = rbind(1:3, 1:3, 3:5))

# Comparison with .Fortran("adot", PACKAGE = "fda.usc")
n &lt;- as.integer(n)
a &lt;- as.double(rep(0, (n * (n - 1) / 2 + 1)))
inprod &lt;- X_fpc[["scores"]] %*% t(X_fpc[["scores"]])
inprod &lt;- inprod[upper.tri(inprod, diag = TRUE)]
X &lt;- X_fpc[["scores"]]
microbenchmark::microbenchmark(
  .Fortran("adot", n = n, inprod = inprod, Adot_vec = a,
           PACKAGE = "fda.usc"),
  Adot(X = X),
  times = 50, control = list(warmup = 10))

</code></pre>

<hr>
<h2 id='flm_term'>Functional linear model term with bivariate kernel</h2><span id='topic+flm_term'></span>

<h3>Description</h3>

<p>Computation of the functional linear term
</p>
<p style="text-align: center;"><code class="reqn">\int_a^b \beta(s, t) X(s)\,\mathrm{d}s,</code>
</p>

<p>of a Functional Linear Model with Functional Response (FLMFR), where
<code class="reqn">X</code> is a random variable in the Hilbert space of
square-integrable functions in <code class="reqn">[a, b]</code>, <code class="reqn">L^2([a, b])</code>,
<code class="reqn">\beta</code> is the bivariate kernel of the FLMFR, and
<code class="reqn">\varepsilon</code> is a random variable in <code class="reqn">L^2([c, d])</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flm_term(X_fdata, beta, t, int_rule = "trapezoid", equispaced = NULL,
  concurrent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flm_term_+3A_x_fdata">X_fdata</code></td>
<td>
<p>sample of functional data as an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="flm_term_+3A_beta">beta</code></td>
<td>
<p>matrix containing the values  <code class="reqn">\beta(s, t)</code>,
for each grid point <code class="reqn">s</code> in  <code class="reqn">[a, b]</code> and <code class="reqn">t</code> in <code class="reqn">[c, d]</code>. If
<code>concurrent = TRUE</code>, a row/column vector must be introduced, valued in
the same grid as <code>error_fdata</code>, with the same length as
<code>length(X_fdata$argvals)</code>.</p>
</td></tr>
<tr><td><code id="flm_term_+3A_t">t</code></td>
<td>
<p>grid points where responses are valued.</p>
</td></tr>
<tr><td><code id="flm_term_+3A_int_rule">int_rule</code></td>
<td>
<p>quadrature rule for approximating the definite
unidimensional integral: trapezoidal rule (<code>int_rule = "trapezoid"</code>)
and extended Simpson rule (<code>int_rule = "Simpson"</code>) are available.
Defaults to <code>"trapezoid"</code>.</p>
</td></tr>
<tr><td><code id="flm_term_+3A_equispaced">equispaced</code></td>
<td>
<p>flag to indicate if <code>X_fdata$data</code> is valued in
an equispaced grid or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flm_term_+3A_concurrent">concurrent</code></td>
<td>
<p>flag to consider a concurrent FLMFR (degenerate case).
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functional linear model term as the integral (in <code>s</code>) between
<code>X_fdata</code> and <code>beta</code>, as an <code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of
length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Javier Álvarez-Liébana.
</p>


<h3>References</h3>

<p>García-Portugués, E., Álvarez-Liébana, J., Álvarez-Pérez, G. and
Gonzalez-Manteiga, W. (2021). A goodness-of-fit test for the functional
linear model with functional response. <em>Scandinavian Journal of
Statistics</em>, 48(2):502&ndash;528. <a href="https://doi.org/10.1111/sjos.12486">doi:10.1111/sjos.12486</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a sample of functional responses via FLMFR

# Bivariate kernel beta(s,t) as an egg carton shape
s &lt;- seq(0, 1, l = 101)
t &lt;- seq(0, 1, l = 201)
beta &lt;- outer(s, t, FUN = function(s, t) sin(6 * pi * s) + cos(6 * pi * t))

# Functional data as zero-mean Gaussian process with exponential variogram
X_fdata &lt;- fda.usc::rproc2fdata(n = 50, t = s, sigma = "vexponential",
                                list = list(scale = 2.5))

# Functional error as an OU process with variance 0.075
sigma &lt;- sqrt(0.075) * 2
error_fdata &lt;- r_ou(n = 50, t = t, sigma = sigma)
Y_fdata &lt;- flm_term(X_fdata = X_fdata, beta = beta, t = t) + error_fdata
plot(Y_fdata)

## Generate a sample of functional responses via concurrent model

# Function beta(t)
s &lt;- seq(1, 3, l = 201)
t &lt;- seq(2, 5, l = 201)
beta &lt;- sin(pi * t) + cos(pi * t)

# Functional data as zero-mean Gaussian process with exponential variogram
X_fdata &lt;- fda.usc::rproc2fdata(n = 50, t = s, sigma = "vexponential",
                                list = list(scale = 2.5))

# Functional error as an OU process with variance 0.075
sigma &lt;- sqrt(0.075) * 2
error_fdata &lt;- r_ou(n = 50, t = t, sigma = sigma)
Y_fdata &lt;- flm_term(X_fdata = X_fdata, beta = beta, t = t,
                    concurrent = TRUE) + error_fdata
plot(Y_fdata)
</code></pre>

<hr>
<h2 id='flm_test'>Goodness-of-fit test for functional linear models</h2><span id='topic+flm_test'></span>

<h3>Description</h3>

<p>Goodness-of-fit test of a functional linear model with
functional response <code class="reqn">Y \in L^2([c, d])</code> and functional predictor
<code class="reqn">X \in L^2([a, b])</code>, where <code class="reqn">L^2([a, b])</code> is the Hilbert space of
square-integrable functions in <code class="reqn">[a, b]</code>.
</p>
<p>The goodness-of-fit test checks the <em>linearity</em> of the regression model
<code class="reqn">m:L^2([a, b])\rightarrow L^2([c, d])</code> that relates <code class="reqn">Y</code> and <code class="reqn">X</code>
by
</p>
<p style="text-align: center;"><code class="reqn">Y(t) = m(X) + \varepsilon(t),</code>
</p>

<p>where <code class="reqn">\varepsilon</code> is a random variable in
<code class="reqn">L^2([c, d])</code> and <code class="reqn">t \in [c, d]</code>. The check is formalized as the
test of the composite hypothesis
</p>
<p style="text-align: center;"><code class="reqn">H_0: m \in \{m_\beta : \beta \in L^2([a, b]) \otimes L^2([c, d])\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">m_\beta(X(s))(t) = \int_a^b \beta(s, t) X(s)\,\mathrm{d}s</code>
</p>

<p>is the linear, Hilbert&ndash;Schmidt, integral operator parametrized by
the bivariate kernel <code class="reqn">\beta</code>. Its estimation is done by the
truncated expansion of <code class="reqn">\beta</code> in the tensor product of the
data-driven bases of <em>Functional Principal Components</em> (FPC) of
<code class="reqn">X</code> and <code class="reqn">Y</code>. The FPC basis for <code class="reqn">X</code> is truncated in <code class="reqn">p</code>
components, while the FPC basis for <code class="reqn">Y</code> is truncated in <code class="reqn">q</code>
components.
</p>
<p>The particular cases in which either <code class="reqn">X</code> or <code class="reqn">Y</code> are
<em>constant</em> functions give either a scalar predictor or response.
The simple linear model arises if both <code class="reqn">X</code> and <code class="reqn">Y</code> are scalar,
for which <code class="reqn">\beta</code> is a constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flm_test(X, Y, beta0 = NULL, B = 500, est_method = "fpcr", p = NULL,
  q = NULL, thre_p = 0.99, thre_q = 0.99, lambda = NULL,
  boot_scores = TRUE, verbose = TRUE, plot_dens = TRUE,
  plot_proc = TRUE, plot_max_procs = 100, plot_max_p = 2,
  plot_max_q = 2, save_fit_flm = TRUE, save_boot_stats = TRUE,
  int_rule = "trapezoid", refit_lambda = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flm_test_+3A_x">X</code>, <code id="flm_test_+3A_y">Y</code></td>
<td>
<p>samples of functional/scalar predictors and functional/scalar
response. Either <code><a href="fda.usc.html#topic+fdata">fdata</a></code> objects (for functional
variables) or vectors of length <code>n</code> (for scalar variables).</p>
</td></tr>
<tr><td><code id="flm_test_+3A_beta0">beta0</code></td>
<td>
<p>if provided (defaults to <code>NULL</code>), the <em>simple</em> null
hypothesis <code class="reqn">H_0: m = m_{\beta_0}</code> is tested. <code>beta0</code> must be a
matrix of size<br /> <code>c(length(X$argvals), length(Y$argvals))</code>. If <code>X</code>
or <code>Y</code> are scalar, <code>beta0</code> can be also an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object, with the same <code>argvals</code> as
<code>X</code> or <code>Y</code>. Can also be a constant (understood as a shorthand for
a matrix with <em>all</em> its entries equal to the constant).</p>
</td></tr>
<tr><td><code id="flm_test_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates. Defaults to <code>500</code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_est_method">est_method</code></td>
<td>
<p>either <code>"fpcr"</code> (Functional Principal Components
Regression; FPCR), <code>"fpcr_l2"</code> (FPCR with ridge penalty),
<code>"fpcr_l1"</code> (FPCR with lasso penalty) or <code>"fpcr_l1s"</code>
(FPCR with lasso-selected FPC). If <code>X</code> is scalar, <code>flm_est</code>
only considers <code>"fpcr"</code> as estimation method. See details below.
Defaults to <code>"fpcr_l1s"</code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_p">p</code>, <code id="flm_test_+3A_q">q</code></td>
<td>
<p>either index vectors indicating the specific FPC to be
considered for the truncated bases expansions of <code>X</code> and <code>Y</code>,
respectively. If a single number for <code>p</code> is provided, then
<code>p &lt;- 1:max(p)</code> internally (analogously for <code>q</code>) and the first
<code>max(p)</code> FPC are considered. If <code>NULL</code> (default), then a
data-driven selection of <code>p</code> and <code>q</code> is done. See details below.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_thre_p">thre_p</code>, <code id="flm_test_+3A_thre_q">thre_q</code></td>
<td>
<p>thresholds for the <em>proportion</em> of variance
that is explained, <em>at least</em>, by the first <code class="reqn">p</code> and <code class="reqn">q</code> FPC
of <code>X</code> and <code>Y</code>, respectively. These thresholds are employed
for an (initial) automatic selection of <code class="reqn">p</code> and <code class="reqn">q</code>.
Default to <code>0.99</code>. <code>thre_p</code> (<code>thre_q</code>) is ignored if
<code>p</code> (<code>q</code>) is provided.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_lambda">lambda</code></td>
<td>
<p>regularization parameter <code class="reqn">\lambda</code> for the estimation
methods <code>"fpcr_l2"</code>, <code>"fpcr_l1"</code>, and <code>"fpcr_l1s"</code>. If
<code>NULL</code> (default), it is chosen with <code><a href="#topic+cv_glmnet">cv_glmnet</a></code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_boot_scores">boot_scores</code></td>
<td>
<p>flag to indicate if the bootstrap shall be applied to the
scores of the residuals, rather than to the functional residuals. This
improves the computational expediency notably. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_verbose">verbose</code></td>
<td>
<p>flag to show information about the testing progress. Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_plot_dens">plot_dens</code></td>
<td>
<p>flag to indicate if a kernel density estimation of the
bootstrap statistics shall be plotted. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_plot_proc">plot_proc</code></td>
<td>
<p>whether to display a graphical tool to identify the
degree of departure from the null hypothesis. If <code>TRUE</code> (default),
the residual marked empirical process, projected in several FPC directions
of <code>X</code> and <code>Y</code>, is shown, together with bootstrap analogues.
The FPC directions are ones selected at the estimation stage.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_plot_max_procs">plot_max_procs</code></td>
<td>
<p>maximum number of bootstrapped processes to plot in
the graphical tool. Set as the minimum of <code>plot_max_procs</code> and <code>B</code>.
Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_plot_max_p">plot_max_p</code>, <code id="flm_test_+3A_plot_max_q">plot_max_q</code></td>
<td>
<p>maximum number of FPC directions to be
considered in the graphical tool. They limit the resulting plot to be at
most of size <code>c(plot_max_p, plot_max_q)</code>. Default to <code>2</code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_save_fit_flm">save_fit_flm</code>, <code id="flm_test_+3A_save_boot_stats">save_boot_stats</code></td>
<td>
<p>flag to return <code>fit_flm</code> and
<code>boot_*</code>. If <code>FALSE</code>, these memory-expensive objects
are set to <code>NA</code>. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_int_rule">int_rule</code></td>
<td>
<p>quadrature rule for approximating the definite
unidimensional integral: trapezoidal rule (<code>int_rule = "trapezoid"</code>)
and extended Simpson rule (<code>int_rule = "Simpson"</code>) are available.
Defaults to <code>"trapezoid"</code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_refit_lambda">refit_lambda</code></td>
<td>
<p>flag to reselect <code class="reqn">lambda</code> in each bootstrap
replicate, incorporating its variability in the bootstrap calibration.
Much more time consumig. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flm_test_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to <code><a href="#topic+cv_glmnet">cv_glmnet</a></code>
(and then to <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>) such as <code>cv_1se</code>,
<code>cv_nlambda</code> or <code>cv_parallel</code>, among others.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the bootstrap-based goodness-of-fit test for
the functional linear model with functional/scalar response and
functional/scalar predictor, as described in Algorithm 1 in
García-Portugués et al. (2021). The specifics are detailed there.
</p>
<p>By default <code>cv_1se = TRUE</code> for <code><a href="#topic+cv_glmnet">cv_glmnet</a></code> is
considered, unless it is changed via <code>...</code>. This is the recommended
choice for conducting the goodness-of-fit test based on regularized
estimators, as the oversmoothed estimate of the regression model under the
null hypothesis notably facilitates the calibration of the test (see
García-Portugués et al., 2021).
</p>
<p>The graphical tool obtained with <code>plot_proc = TRUE</code> is based on
an extension of the tool described in García-Portugués et al. (2014).
</p>
<p>Repeated observations on <code>X</code> are internally removed, as otherwise they
would cause <code>NaN</code>s in <code>Adot</code>. Missing values on <code>X</code> and
<code>Y</code> are also automatically removed.
</p>


<h3>Value</h3>

<p>An object of the <code>htest</code> class with the following elements:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p><code class="reqn">p</code>-value of the test.</p>
</td></tr>
<tr><td><code>boot_statistics</code></td>
<td>
<p>the bootstrapped test statistics, a vector
of length <code>B</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>information on the type of test performed.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>a vector with the dimensions <code class="reqn">p</code> and <code class="reqn">q</code>
considered in the test statistic. These are the lengths of the outputs
<code>p</code> and <code>q</code>.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the index of the FPC considered for <code>X</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>the index of the FPC considered for <code>Y</code>.</p>
</td></tr>
<tr><td><code>fit_flm</code></td>
<td>
<p>the output resulted from calling <code><a href="#topic+flm_est">flm_est</a></code>.</p>
</td></tr>
<tr><td><code>boot_lambda</code></td>
<td>
<p>bootstrapped <code class="reqn">lambda</code>.</p>
</td></tr>
<tr><td><code>boot_p</code></td>
<td>
<p>a list with the bootstrapped indexes of the FPC considered
for <code>X</code>.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>name of the value of <code>data</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués.
</p>


<h3>References</h3>

<p>García-Portugués, E., Álvarez-Liébana, J., Álvarez-Pérez, G. and
Gonzalez-Manteiga, W. (2021). A goodness-of-fit test for the functional
linear model with functional response. <em>Scandinavian Journal of
Statistics</em>, 48(2):502&ndash;528. <a href="https://doi.org/10.1111/sjos.12486">doi:10.1111/sjos.12486</a>
</p>
<p>García-Portugués, E., González-Manteiga, W. and Febrero-Bande, M. (2014). A
goodness-of-fit test for the functional linear model with scalar response.
<em>Journal of Computational and Graphical Statistics</em>, 23(3):761&ndash;778.
<a href="https://doi.org/10.1080/10618600.2013.812519">doi:10.1080/10618600.2013.812519</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Quick example for functional response and predictor

# Generate data under H0
n &lt;- 100
set.seed(987654321)
X_fdata &lt;- r_ou(n = n, t = seq(0, 1, l = 101), sigma = 2)
epsilon &lt;- r_ou(n = n, t = seq(0, 1, l = 101), sigma = 0.5)
Y_fdata &lt;- epsilon

# Test the FLMFR
flm_test(X = X_fdata, Y = Y_fdata)

# Simple hypothesis
flm_test(X = X_fdata, Y = Y_fdata, beta0 = 0)

# Generate data under H1
n &lt;- 100
set.seed(987654321)
sample_frm_fr &lt;- r_frm_fr(n = n, scenario = 3, s = seq(0, 1, l = 101),
                          t = seq(0, 1, l = 101), nonlinear = "quadratic")
X_fdata &lt;- sample_frm_fr[["X_fdata"]]
Y_fdata &lt;- sample_frm_fr[["Y_fdata"]]

# Test the FLMFR
flm_test(X = X_fdata, Y = Y_fdata)

## Functional response and predictor

# Generate data under H0
n &lt;- 50
B &lt;- 100
set.seed(987654321)
t &lt;- seq(0, 1, l = 201)
X_fdata &lt;- r_ou(n = n, t = t, sigma = 2)
epsilon &lt;- r_ou(n = n, t = t, sigma = 0.5)
Y_fdata &lt;- epsilon

# With boot_scores = TRUE
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr", B = B)
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l2", B = B)
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1s", B = B)

# With boot_scores = FALSE
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l2",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1s",
         boot_scores = FALSE, B = B)

# Simple hypothesis
flm_test(X = X_fdata, Y = Y_fdata, beta0 = 2, est_method = "fpcr", B = B)
flm_test(X = X_fdata, Y = Y_fdata, beta0 = 0, est_method = "fpcr", B = B)
flm_test(X = X_fdata, Y = Y_fdata, beta0 = 0, est_method = "fpcr_l1s", B = B)

# Generate data under H1
n &lt;- 50
B &lt;- 100
set.seed(987654321)
sample_frm_fr &lt;- r_frm_fr(n = n, scenario = 3, s = t, t = t,
                          nonlinear = "quadratic")
X_fdata &lt;- sample_frm_fr$X_fdata
Y_fdata &lt;- sample_frm_fr$Y_fdata

# With boot_scores = TRUE
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr", B = B)
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l2", B = B)
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1s", B = B)

# With boot_scores = FALSE
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l2",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y_fdata, est_method = "fpcr_l1s",
         boot_scores = FALSE, B = B)

## Scalar response and functional predictor

# Generate data under H0
n &lt;- 50
B &lt;- 100
set.seed(987654321)
t &lt;- seq(0, 1, l = 201)
X_fdata &lt;- r_ou(n = n, t = t, sigma = 2)
beta &lt;- r_ou(n = 1, t = t, sigma = 0.5, x0 = 2)
epsilon &lt;- rnorm(n = n)
Y &lt;- drop(inprod_fdata(X_fdata1 = X_fdata, X_fdata2 = beta) + epsilon)

# With boot_scores = TRUE
flm_test(X = X_fdata, Y = Y, est_method = "fpcr", B = B)
flm_test(X = X_fdata, Y = Y, est_method = "fpcr_l2", B = B)
flm_test(X = X_fdata, Y = Y, est_method = "fpcr_l1s", B = B)

# With boot_scores = FALSE
flm_test(X = X_fdata, Y = Y, est_method = "fpcr",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y, est_method = "fpcr_l2",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y, est_method = "fpcr_l1",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y, est_method = "fpcr_l1s",
         boot_scores = FALSE, B = B)

# Simple hypothesis
flm_test(X = X_fdata, Y = Y, beta0 = beta, est_method = "fpcr", B = B)
flm_test(X = X_fdata, Y = Y, beta0 = 0, est_method = "fpcr", B = B)
flm_test(X = X_fdata, Y = Y, beta0 = 0, est_method = "fpcr_l1s", B = B)

# Generate data under H1
n &lt;- 50
B &lt;- 100
set.seed(987654321)
X_fdata &lt;- r_ou(n = n, t = t, sigma = 2)
beta &lt;- r_ou(n = 1, t = t, sigma = 0.5)
epsilon &lt;- rnorm(n = n)
Y &lt;- drop(exp(inprod_fdata(X_fdata1 = X_fdata^2, X_fdata2 = beta)) + epsilon)

# With boot_scores = TRUE
flm_test(X = X_fdata, Y = Y, est_method = "fpcr", B = B)
flm_test(X = X_fdata, Y = Y, est_method = "fpcr_l2", B = B)
flm_test(X = X_fdata, Y = Y, est_method = "fpcr_l1s", B = B)

# With boot_scores = FALSE
flm_test(X = X_fdata, Y = Y, est_method = "fpcr",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y, est_method = "fpcr_l2",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y, est_method = "fpcr_l1",
         boot_scores = FALSE, B = B)
flm_test(X = X_fdata, Y = Y, est_method = "fpcr_l1s",
         boot_scores = FALSE, B = B)

## Functional response and scalar predictor

# Generate data under H0
n &lt;- 50
B &lt;- 100
set.seed(987654321)
X &lt;- rnorm(n)
t &lt;- seq(0, 1, l = 201)
beta &lt;- r_ou(n = 1, t = t, sigma = 0.5, x0 = 3)
beta$data &lt;- matrix(beta$data, nrow = n, ncol = ncol(beta$data),
                    byrow = TRUE)
epsilon &lt;- r_ou(n = n, t = t, sigma = 0.5)
Y_fdata &lt;- X * beta + epsilon

# With boot_scores = TRUE
flm_test(X = X, Y = Y_fdata, est_method = "fpcr", B = B)

# With boot_scores = FALSE
flm_test(X = X, Y = Y_fdata, est_method = "fpcr", boot_scores = FALSE, B = B)

# Simple hypothesis
flm_test(X = X, Y = Y_fdata, beta0 = beta[1], est_method = "fpcr", B = B)
flm_test(X = X, Y = Y_fdata, beta0 = 0, est_method = "fpcr", B = B)

# Generate data under H1
n &lt;- 50
B &lt;- 100
set.seed(987654321)
X &lt;- rexp(n)
beta &lt;- r_ou(n = 1, t = t, sigma = 0.5, x0 = 3)
beta$data &lt;- matrix(beta$data, nrow = n, ncol = ncol(beta$data),
                    byrow = TRUE)
epsilon &lt;- r_ou(n = n, t = t, sigma = 0.5)
Y_fdata &lt;- log(X * beta) + epsilon

# With boot_scores = TRUE
flm_test(X = X, Y = Y_fdata, est_method = "fpcr", B = B)

# With boot_scores = FALSE
flm_test(X = X, Y = Y_fdata, est_method = "fpcr", boot_scores = FALSE, B = B)

</code></pre>

<hr>
<h2 id='fpc'>Computation of functional principal components</h2><span id='topic+fpc'></span>

<h3>Description</h3>

<p>Computation of Functional Principal Components (FPC) for
equispaced and non equispaced functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpc(X_fdata, n_fpc = 3, centered = FALSE, int_rule = "trapezoid",
  equispaced = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpc_+3A_x_fdata">X_fdata</code></td>
<td>
<p>sample of functional data as an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="fpc_+3A_n_fpc">n_fpc</code></td>
<td>
<p>number of FPC to be computed. If <code>n_fpc &gt; n</code>, <code>n_fpc</code>
is set to <code>n</code>. Defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="fpc_+3A_centered">centered</code></td>
<td>
<p>flag to indicate if <code>X_fdata</code> is centered or not.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fpc_+3A_int_rule">int_rule</code></td>
<td>
<p>quadrature rule for approximating the definite
unidimensional integral: trapezoidal rule (<code>int_rule = "trapezoid"</code>)
and extended Simpson rule (<code>int_rule = "Simpson"</code>) are available.
Defaults to <code>"trapezoid"</code>.</p>
</td></tr>
<tr><td><code id="fpc_+3A_equispaced">equispaced</code></td>
<td>
<p>flag to indicate if <code>X_fdata$data</code> is valued in
an equispaced grid or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fpc_+3A_verbose">verbose</code></td>
<td>
<p>whether to show or not information about the <code>fpc</code>
procedure. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FPC are obtained by performing the single value decomposition
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{X} \mathbf{W}^{1/2} =
\mathbf{U} \mathbf{D} (\mathbf{V}' \mathbf{W}^{1/2})</code>
</p>

<p>where <code class="reqn">\mathbf{X}</code> is the matrix of discretized functional data,
<code class="reqn">\mathbf{W}</code> is a diagonal matrix of weights (computed by
<code>w_integral1D</code> according to <code>int_rule</code>), <code class="reqn">\mathbf{D}</code>
is the diagonal matrix with singular values (standard deviations of FPC),
<code class="reqn">\mathbf{U}</code> is a matrix whose columns contain the left singular
vectors, and <code class="reqn">\mathbf{V}</code> is a matrix whose columns contain the
right singular vectors (FPC).
</p>


<h3>Value</h3>

<p>An <code>"fpc"</code> object containing the following elements:
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>standard deviations of the FPC (i.e., square roots of
eigenvalues of the empirical autocovariance estimator).</p>
</td></tr>
<tr><td><code>rotation</code></td>
<td>
<p>orthonormal eigenfunctions (loadings or functional
principal components), as an <code><a href="fda.usc.html#topic+fdata">fdata</a></code> class object.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>rotated samples: inner products.
between <code>X_fdata</code> and eigenfunctions in<br /> <code>rotation</code>.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>vector of index of FPC.</p>
</td></tr>
<tr><td><code>equispaced</code></td>
<td>
<p><code>equispaced</code> flag.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javier Álvarez-Liébana and Gonzalo Álvarez-Pérez.
</p>


<h3>References</h3>

<p>Jolliffe, I. T. (2002). Principal Component Analysis. Springer-Verlag,
New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Computing FPC for equispaced data

# Sample data
X_fdata1 &lt;- r_ou(n = 200, t = seq(2, 4, l = 201))

# FPC with trapezoid rule
X_fpc1 &lt;- fpc(X_fdata = X_fdata1, n_fpc = 50, equispaced = TRUE,
              int_rule = "trapezoid")

# FPC with Simpsons's rule
X_fpc2 &lt;- fpc(X_fdata = X_fdata1, n_fpc = 50, equispaced = TRUE,
               int_rule = "Simpson")

# Check if FPC are orthonormal
norms1 &lt;- rep(0, length(X_fpc1$l))
for (i in X_fpc1$l) {

  norms1[i] &lt;- integral1D(fx = X_fpc1$rotation$data[i, ]^2,
                          t = X_fdata1$argvals)

}
norms2 &lt;- rep(0, length(X_fpc2$l))
for (i in X_fpc2$l) {

  norms2[i] &lt;- integral1D(fx = X_fpc2$rotation$data[i, ]^2,
                          t = X_fdata1$argvals)

}

## Computing FPC for non equispaced data

# Sample data
X_fdata2 &lt;- r_ou(n = 200, t = c(seq(0, 0.5, l = 201), seq(0.51, 1, l = 301)))

# FPC with trapezoid rule
X_fpc3 &lt;- fpc(X_fdata = X_fdata2, n_fpc = 5, int_rule = "trapezoid",
              equispaced = FALSE)

# Check if FPC are orthonormal
norms3 &lt;- rep(0, length(X_fpc3$l))
for (i in X_fpc3$l) {

  norms3[i] &lt;- integral1D(fx = X_fpc3$rotation$data[i, ]^2,
                          t = X_fdata2$argvals)

}

## Efficiency comparisons

# fpc() vs. fda.usc::fdata2pc()
data(phoneme, package = "fda.usc")
mlearn &lt;- phoneme$learn[1:10, ]
res1 &lt;- fda.usc::fdata2pc(mlearn, ncomp = 3)
res2 &lt;- fpc(X_fdata = mlearn, n_fpc = 3)
plot(res1$x[, 1:3], col = 1)
points(res2$scores, col = 2)

microbenchmark::microbenchmark(fda.usc::fdata2pc(mlearn, ncomp = 3),
                               fpc(X_fdata = mlearn, n_fpc = 3), times = 1e3,
                               control = list(warmup = 20))

</code></pre>

<hr>
<h2 id='fpc_utils'>Utilities for functional principal components</h2><span id='topic+fpc_utils'></span><span id='topic+fpc_coefs'></span><span id='topic+beta_fpc_coefs'></span><span id='topic+fpc_to_fdata'></span><span id='topic+fpc_to_beta'></span>

<h3>Description</h3>

<p>Computation of coefficients and reconstructions based on
Functional Principal Components (FPC). The function <code>fpc_coefs</code> allows
to project a functional data sample into a basis of FPC; the reconstruction
of the sample from its projections and the FPC is done with
<code>fpc_to_fdata</code>. The functions <code>beta_fpc_coefs</code> and
<code>fpc_to_beta</code> do analogous operations but for the
<a href="#topic+flm_est">bivariate kernel</a> <code class="reqn">\beta</code> and the tensor product
of two FPC bases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpc_coefs(X_fdata, X_fpc, ind_X_fpc = 1:3, int_rule = "trapezoid")

beta_fpc_coefs(beta, X_fpc, Y_fpc, ind_X_fpc = 1:3, ind_Y_fpc = 1:3,
  int_rule = "trapezoid")

fpc_to_fdata(coefs, X_fpc, ind_coefs = seq_len(ncol(coefs)))

fpc_to_beta(beta_coefs, X_fpc, Y_fpc,
  ind_coefs_X = seq_len(nrow(beta_coefs)),
  ind_coefs_Y = seq_len(ncol(beta_coefs)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpc_utils_+3A_x_fdata">X_fdata</code></td>
<td>
<p>sample of functional data as an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="fpc_utils_+3A_x_fpc">X_fpc</code>, <code id="fpc_utils_+3A_y_fpc">Y_fpc</code></td>
<td>
<p><code>"fpc"</code> objects as resulted from calling
<code><a href="#topic+fpc">fpc</a></code>.</p>
</td></tr>
<tr><td><code id="fpc_utils_+3A_ind_x_fpc">ind_X_fpc</code>, <code id="fpc_utils_+3A_ind_y_fpc">ind_Y_fpc</code></td>
<td>
<p>vectors giving the FPC indexes for whom the
coefficients are computed. Their lengths must be smaller than the number of
FPC in <code>X_fpc</code> and <code>Y_fpc</code>, respectively. Default to <code>1:3</code>.</p>
</td></tr>
<tr><td><code id="fpc_utils_+3A_int_rule">int_rule</code></td>
<td>
<p>quadrature rule for approximating the definite
unidimensional integral: trapezoidal rule (<code>int_rule = "trapezoid"</code>)
and extended Simpson rule (<code>int_rule = "Simpson"</code>) are available.
Defaults to <code>"trapezoid"</code>.</p>
</td></tr>
<tr><td><code id="fpc_utils_+3A_beta">beta</code></td>
<td>
<p>a matrix containing the bivariate kernel <code class="reqn">\beta</code> evaluated
on a grid. Must be of size <code>c(length(X_fpc$rotation$argvals),
length(Y_fpc$rotation$argvals))</code>.</p>
</td></tr>
<tr><td><code id="fpc_utils_+3A_coefs">coefs</code></td>
<td>
<p>a vector of coefficients to combine linearly the FPC. Its
length must be smaller than the number of FPC in <code>X_fpc</code>.</p>
</td></tr>
<tr><td><code id="fpc_utils_+3A_ind_coefs">ind_coefs</code>, <code id="fpc_utils_+3A_ind_coefs_x">ind_coefs_X</code>, <code id="fpc_utils_+3A_ind_coefs_y">ind_coefs_Y</code></td>
<td>
<p>indexes of FPC to associate to the
provided coefficients. By default, from the first FPC to the sizes of
<code>coefs</code> or <code>beta_coefs</code>.</p>
</td></tr>
<tr><td><code id="fpc_utils_+3A_beta_coefs">beta_coefs</code></td>
<td>
<p>a matrix of coefficients to combine linearly the tensor
products of FPC. Its size must be smaller than the number of FPC in
<code>X_fpc</code> and <code>Y_fpc</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>fpc_coefs</code></td>
<td>
<p>a vector of the same length as <code>coefs</code> containing
the coefficients of <code>X_fdata</code> in the FPC of <code>X_fpc</code>.</p>
</td></tr>
<tr><td><code>beta_fpc_coefs</code></td>
<td>
<p>a matrix of the same size as <code>beta_coefs</code>
containing the coefficients of <code class="reqn">\beta</code> in the tensor product of
the FPC in <code>X_fpc</code> and <code>Y_fpc</code>.</p>
</td></tr>
<tr><td><code>fpc_to_fdata</code></td>
<td>
<p>an <code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of the same
type as <code>X_fpc$rotation</code>.</p>
</td></tr>
<tr><td><code>fpc_to_beta</code></td>
<td>
<p>a matrix with the reconstructed kernel and size<br />
<code>c(length(X_fpc$rotation$argvals), length(Y_fpc$rotation$argvals))</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués.
</p>


<h3>References</h3>

<p>Jolliffe, I. T. (2002). Principal Component Analysis. Springer-Verlag,
New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute FPC coefficients and reconstruct data

# Sample data
X_fdata &lt;- r_ou(n = 200, t = seq(2, 4, l = 201))

# Compute FPC
X_fpc &lt;- fpc(X_fdata = X_fdata, n_fpc = 50)

# FPC coefficients are the same if the data is centered
fpc_coefs(X_fdata = fdata_cen(X_fdata), X_fpc = X_fpc)[1:4, ]
X_fpc$scores[1:4, 1:3]

# Reconstruct the first two curves for an increasing number of FPC
plot(X_fdata[1:2, ], col = 1)
n_fpc &lt;- c(2, 5, 10, 25, 50)
for (j in 1:5) {
  lines(fpc_to_fdata(X_fpc = X_fpc,
                     coefs = X_fpc$scores[, 1:n_fpc[j]])[1:2, ], col = j + 1)
}

## Project and reconstruct beta

# Surface
beta_fun &lt;- function(s, t) sin(6 * pi * s) + cos(6 * pi * t)
s &lt;- seq(0, 1, l = 101)
t &lt;- seq(0, 1, l = 201)
beta_surf &lt;- outer(s, t, FUN = beta_fun)

# Functional data as zero-mean Gaussian process with exponential variogram
X_fdata &lt;- fda.usc::rproc2fdata(n = 100, t = s, sigma = "vexponential",
                                list = list(scale = 2.5))
Y_fdata &lt;- flm_term(X_fdata = X_fdata, beta = beta_surf, t = t) +
  r_ou(n = 100, t = t, sigma = sqrt(0.075) * 2)

# FPC
X_fpc &lt;- fpc(X_fdata = X_fdata, n_fpc = 50)
Y_fpc &lt;- fpc(X_fdata = Y_fdata, n_fpc = 50)

# Coefficients
beta_coefs &lt;- beta_fpc_coefs(beta = beta_surf, X_fpc = X_fpc, Y_fpc = Y_fpc,
                             ind_X_fpc = 1:50, ind_Y_fpc = 1:50)

# Reconstruction
beta_surf1 &lt;- fpc_to_beta(beta_coefs = beta_coefs[1:2, 1:5],
                          X_fpc = X_fpc, Y_fpc = Y_fpc)
beta_surf2 &lt;- fpc_to_beta(beta_coefs = beta_coefs[1:15, 1:10],
                          X_fpc = X_fpc, Y_fpc = Y_fpc)
beta_surf3 &lt;- fpc_to_beta(beta_coefs = beta_coefs[1:50, 1:50],
                          X_fpc = X_fpc, Y_fpc = Y_fpc)

# Show reconstructions
old_par &lt;- par(mfrow = c(2, 2))
col &lt;- viridisLite::viridis(20)
image(s, t, beta_surf, col = col, zlim = c(-2.5, 2.5), main = "Original")
image(s, t, beta_surf1, col = col, zlim = c(-2.5, 2.5), main = "2 x 5")
image(s, t, beta_surf2, col = col, zlim = c(-2.5, 2.5), main = "15 x 10")
image(s, t, beta_surf3, col = col, zlim = c(-2.5, 2.5), main = "50 x 50")
par(old_par)
</code></pre>

<hr>
<h2 id='ontario'>Ontario temperature and electricity consumption during 2010&ndash;2014</h2><span id='topic+ontario'></span>

<h3>Description</h3>

<p>Real dataset employed Benatia et al. (2017). Contains the
hourly electricity consumption and air temperature curves in the province
of Ontario (Canada). It features a set of daily curves during the summer
months of 2010&ndash;2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ontario
</code></pre>


<h3>Format</h3>

<p>A list with the following entries:
</p>

<dl>
<dt>temp</dt><dd><p>an <code><a href="fda.usc.html#topic+fdata">fdata</a></code> with 368 smoothed
daily temperature (in Celsius degrees) curves of the Ontario province,
discretized on 73 equispaced grid points on <code class="reqn">[-24, 48]</code>
(see examples).</p>
</dd>
<dt>elec</dt><dd><p>an <code><a href="fda.usc.html#topic+fdata">fdata</a></code> with the daily
electricity consumption (in gigawatts) curves of the Ontario province.
Discretized on 25 equispaced grid points on <code class="reqn">[0, 24]</code>.</p>
</dd>
<dt>df</dt><dd><p>a dataframe with time metadata for each curve:
</p>

<ul>
<li><p><code>date</code>: the date of the observation, a <code><a href="base.html#topic+POSIXct">POSIXct</a></code>
object.
</p>
</li>
<li><p><code>weekday</code>: the weekday of the observation.
</p>
</li></ul>
</dd>
</dl>



<h3>Details</h3>

<p>The summer months correspond to June 1st to September 15th. Weekend days and
holidays are disregarded.
</p>
<p>The smoothed temperature curves are constructed by a weighted average of
the temperatures of 41 Ontarian cities that is afterwards smoothed with
a local polynomial regression. The curves correspond to a 3-days window
of the temperature (see examples). The temperature is standardized such
that its original minimum, 6 ºC, is subtracted.
</p>
<p>The electricity consumption curves are discretized on the interval
<code class="reqn">[0, 24]</code>. That means that the last observation of the
<code class="reqn">i</code>-th curve is the same as the first observation of the
<code class="reqn">(i + 1)</code>-th curve <em>if</em> the curves correspond to consecutive days.
</p>
<p>See more details about the construction of the dataset in Benatia et al.
(2017).
</p>


<h3>Author(s)</h3>

<p>Data gathered and processed by David Benatia, Marine Carrasco, and
Jean-Pierre Florens. Javier Álvarez-Liébana and Eduardo García-Portugués
imported the dataset and added temporal metadata.
</p>


<h3>Source</h3>

<p>The dataset comes from the companion data to Benatia et al. (2017), which
was retrieved from the <a href="https://www.davidbenatia.com/publication/">
first author's website</a>. The source of the electricity consumption data is
the <a href="https://www.ieso.ca/">System operator's website</a>. The source
of the preprocessed temperature values is the
<a href="https://climat.meteo.gc.ca/">Environment Canada's website</a>.
</p>


<h3>References</h3>

<p>Benatia, D., Carrasco, M. and Florens, J. P. (2017) Functional linear
regression with functional response. <em>Journal of Econometrics</em>,
201(2):269&ndash;291. <a href="https://doi.org/10.1016/j.jeconom.2017.08.008">doi:10.1016/j.jeconom.2017.08.008</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Show data

# Load data
data("ontario")

# Plot
old_par &lt;- par(mfrow = c(1, 2))
plot(ontario$temp)
plot(ontario$elec)
par(old_par)

# Observe the 3-day windows for each observation
plot(ontario$temp$argvals, ontario$temp$data[2, ], type = "o",
     xlim = c(-48, 72), ylim = c(7, 13), xlab = "Hours",
     ylab = "Electricity consumption", pch = 16)
points(ontario$temp$argvals - 24, ontario$temp$data[1, ], col = 3, pch = 2)
points(ontario$temp$argvals + 24, ontario$temp$data[3, ], col = 2, cex = 1.5)
abline(v = 24 * -2:3, lty = 2)
legend("top", legend = c("Curve 1", "Curve 2", "Curve 3"), col = c(3, 1, 2),
       pt.cex = c(1, 1, 1.5), pch = c(2, 16, 1))

# If the days are not consecutive, then the electricity consumptions at the
# end of one day and the beginning of the next do not match
head(abs(ontario$elec$data[-368, 25] - ontario$elec$data[-1, 1]))
head(diff(ontario$df$date))

## Test the linear model with functional response and predictor

(comp_flmfr &lt;- flm_test(X = ontario$temp, Y = ontario$elec,
                        est_method = "fpcr_l1s"))
(simp_flmfr &lt;- flm_test(X = ontario$temp, Y = ontario$elec,
                        beta0 = 0, est_method = "fpcr_l1s"))

# Visualize estimation
filled.contour(x = ontario$temp$argvals, y = ontario$elec$argvals,
               z = comp_flmfr$fit_flm$Beta_hat,
               color.palette = viridisLite::viridis, nlevels = 20)

</code></pre>

<hr>
<h2 id='quadrature'>Quadrature rules for the <span class="pkg">goffda</span> package</h2><span id='topic+quadrature'></span><span id='topic+integral1D'></span><span id='topic+integral2D'></span><span id='topic+w_integral1D'></span>

<h3>Description</h3>

<p>Quadrature rules for unidimensional and bidimensional
functions, as enhancements of <code><a href="fda.usc.html#topic+int.simpson">int.simpson</a></code> from the
<code><a href="fda.usc.html#topic+fda.usc-package">fda.usc-package</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integral1D(fx, t, int_rule = "trapezoid", equispaced = FALSE,
  verbose = FALSE)

integral2D(fxy, s, t, int_rule = "trapezoid", equispaced_x = FALSE,
  equispaced_y = FALSE, verbose = FALSE)

w_integral1D(t, int_rule = "trapezoid", equispaced = FALSE,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadrature_+3A_fx">fx</code></td>
<td>
<p>a vector of length <code>length(t)</code> with the evaluation of
a univariate function at <code>t</code>.</p>
</td></tr>
<tr><td><code id="quadrature_+3A_int_rule">int_rule</code></td>
<td>
<p>quadrature rule for approximating the definite
unidimensional integral: trapezoidal rule (<code>int_rule = "trapezoid"</code>)
and extended Simpson rule (<code>int_rule = "Simpson"</code>) are available.
Defaults to <code>"trapezoid"</code>.</p>
</td></tr>
<tr><td><code id="quadrature_+3A_equispaced">equispaced</code></td>
<td>
<p>flag to indicate if <code>X_fdata$data</code> is valued in
an equispaced grid or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="quadrature_+3A_verbose">verbose</code></td>
<td>
<p>flag to show information about the procedures. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="quadrature_+3A_fxy">fxy</code></td>
<td>
<p>a matrix of size <code>c(length(s), length(t))</code> with the
evaluation of a bivariate function at the bivariate grid formed by
<code>s</code> and <code>t</code>.</p>
</td></tr>
<tr><td><code id="quadrature_+3A_s">s</code>, <code id="quadrature_+3A_t">t</code></td>
<td>
<p>vectors with grid points where functions are valued.</p>
</td></tr>
<tr><td><code id="quadrature_+3A_equispaced_x">equispaced_x</code>, <code id="quadrature_+3A_equispaced_y">equispaced_y</code></td>
<td>
<p>flags to indicate if <code>fxy</code> is valued
in equispaced grids or not, at each one of dimensions. Both default to
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>w_integral1D</code>: a vector of length <code>t</code> with the weights
required for the quadrature rule <code>int_rule</code>.
</p>
</li>
<li><p><code>integral1D</code>: a scalar with the approximation of the univariate
integral.
</p>
</li>
<li><p><code>integral2D</code>: a scalar with the approximation of the bivariate
integral.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Code iterated by Javier Álvarez-Liébana and Eduardo García-Portugués
from the <code><a href="fda.usc.html#topic+fda.usc-package">fda.usc-package</a></code> originals.
</p>


<h3>References</h3>

<p>Press, W. H., Teukolsky, S. A., Vetterling, W. T. and Flannery B. P. (1997).
Numerical Recipes in Fortran 77: the art of scientific computing (2nd ed).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Numerical integral of 1-D functions

# Equispaced grid points
t1 &lt;- seq(0, 1, l = 201)
t2 &lt;- seq(pi / 4, 3 * pi / 2, l = 201)
fx1 &lt;- 2 * (t1^3) - t1^2 + 5 * t1 - 2 # True integral is equal to 2/3
fx2 &lt;- sin(sqrt(t2)) # True integral is equal to 3.673555
int_fx1_trap &lt;- integral1D(fx = fx1, t = t1, int_rule = "trapezoid",
                           equispaced = TRUE)
int_fx1_Simp &lt;- integral1D(fx = fx1, t = t1, int_rule = "Simpson",
                           equispaced = TRUE)

int_fx2_trap &lt;- integral1D(fx = fx2, t = t2, int_rule = "trapezoid",
                           equispaced = TRUE)
int_fx2_Simp &lt;- integral1D(fx = fx2, t = t2, int_rule = "Simpson",
                           equispaced = TRUE)

# Check if the true integrals is approximated properly
abs(int_fx1_trap - 2/3) / (2/3)
abs(int_fx1_Simp - 2/3) / (2/3)
abs(int_fx2_trap - 3.673555) / 3.673555
abs(int_fx2_Simp - 3.673555) / 3.673555

# Non equispaced grid points
t &lt;- c(seq(0, 0.3, l = 50), seq(0.31, 0.6, l = 150),
       seq(0.61, 1, l = 100))
fx &lt;- 2 * (t^3) - t^2 + 5 * t - 2
int_fx_trap &lt;- integral1D(fx = fx, t = t, int_rule = "trapezoid",
                          equispaced = FALSE)
int_fx_Simp &lt;- integral1D(fx = fx, t = t, int_rule = "Simpson",
                          equispaced = FALSE)

# Check if the true integral is approximated properly
abs(int_fx_trap - 2/3) / (2/3)
abs(int_fx_Simp - 2/3) / (2/3)

## Numerical integral of 2-dimensional functions

# Equispaced grid points
s &lt;- seq(0, 2, l = 101)
t &lt;- seq(1, 5, l = 151)
fxy &lt;- outer(s^2, t^3) # True integral is equal to 416
int_fxy_trap &lt;- integral2D(fxy = fxy, s = s, t = t, int_rule = "trapezoid",
                           equispaced_x = TRUE, equispaced_y = TRUE)
int_fxy_Simp &lt;- integral2D(fxy = fxy, s = s, t = t, int_rule = "Simpson",
                           equispaced_x = TRUE, equispaced_y = TRUE)

# Check if the true integral is approximated properly
abs(int_fxy_trap - 416) / 416
abs(int_fxy_Simp - 416) / 416

# Non equispaced grid points
s &lt;- c(seq(0, 0.3, l = 150), seq(0.31, 1.6, l = 100),
       seq(1.61, 2, l = 250))
t &lt;- c(seq(1, 2.6, l = 170), seq(2.61, 4, l = 100),
       seq(4.01, 5, l = 140))
fxy &lt;- outer(s^2, t^3)

int_fxy_trap &lt;- integral2D(fxy = fxy, s = s, t = t, int_rule = "trapezoid",
                           equispaced_x = FALSE, equispaced_y = FALSE)

# Check if the true integral is approximated properly
abs(int_fxy_trap - 416) / 416
</code></pre>

<hr>
<h2 id='r_ou'>Simulation of an Ornstein&ndash;Uhlenbeck process</h2><span id='topic+r_ou'></span>

<h3>Description</h3>

<p>Simulation of trajectories of the Ornstein&ndash;Uhlenbeck process
<code class="reqn">\{X_t\}</code>. The process is the solution to the stochastic
differential equation
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{d}X_t = \alpha (X_t - \mu)\mathrm{d}t + \sigma \mathrm{d}W_t,
</code>
</p>

<p>whose stationary distribution is <code class="reqn">N(\mu, \sigma^2 / (2 \alpha))</code>, for
<code class="reqn">\alpha, \sigma &gt; 0</code> and <code class="reqn">\mu \in R</code>.
</p>
<p>Given an initial point <code class="reqn">x_0</code> and the evaluation times
<code class="reqn">t_1, \ldots, t_m</code>, a sample trajectory <code class="reqn">X_{t_1}, \ldots, X_{t_m}</code>
can be obtained by sampling the joint Gaussian distribution of
<code class="reqn">(X_{t_1}, \ldots, X_{t_m})</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_ou(n, t = seq(0, 1, len = 201), mu = 0, alpha = 1, sigma = 1,
  x0 = rnorm(n, mean = mu, sd = sigma/sqrt(2 * alpha)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_ou_+3A_n">n</code></td>
<td>
<p>number of trajectories to sample.</p>
</td></tr>
<tr><td><code id="r_ou_+3A_t">t</code></td>
<td>
<p>evaluation times for the trajectories, a vector.</p>
</td></tr>
<tr><td><code id="r_ou_+3A_mu">mu</code></td>
<td>
<p>mean of the process, a scalar.</p>
</td></tr>
<tr><td><code id="r_ou_+3A_alpha">alpha</code></td>
<td>
<p>strength of the drift, a positive scalar.</p>
</td></tr>
<tr><td><code id="r_ou_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient, a positive scalar.</p>
</td></tr>
<tr><td><code id="r_ou_+3A_x0">x0</code></td>
<td>
<p>a vector of length <code>n</code> giving the initial
values of the Ornstein&ndash;Uhlenbeck trajectories. By default, <code>n</code>
points are sampled from the stationary distribution. If a single scalar
is passed, then the same <code>x0</code> is employed for all the trajectories.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Random trajectories, an <code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of
length <code>n</code> and <code>t</code> as <code>argvals</code>.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Same initial point
plot(r_ou(n = 20, x0 = 5), col = viridisLite::viridis(20))

# Different initial points
plot(r_ou(n = 100, alpha = 2, sigma = 4, x0 = 1:100),
     col = viridisLite::viridis(100))
</code></pre>

<hr>
<h2 id='sim-frmfr'>Sampling functional regression models with functional responses</h2><span id='topic+sim-frmfr'></span><span id='topic+r_frm_fr'></span><span id='topic+nl_dev'></span>

<h3>Description</h3>

<p>Simulation of a Functional Regression Model with Functional
Response (FRMFR) comprised of an additive mix of a linear and nonlinear
terms:
</p>
<p style="text-align: center;"><code class="reqn">Y(t) = \int_a^b X(s) \beta(s,t) ds + \Delta(X)(t) + \varepsilon(t),</code>
</p>

<p>where <code class="reqn">X</code> is a random variable in the Hilbert space of
square-integrable functions in <code class="reqn">[a, b]</code>, <code class="reqn">L^2([a, b])</code>,
<code class="reqn">\beta</code> is the bivariate kernel of the FRMFR,
<code class="reqn">\varepsilon</code> is a random variable in <code class="reqn">L^2([c, d])</code>,
and <code class="reqn">\Delta(X)</code> is a nonlinear term.
</p>
<p>In particular, the scenarios considered in García-Portugués et al. (2021)
can be easily simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_frm_fr(n, scenario = 3, X_fdata = NULL, error_fdata = NULL,
  beta = NULL, s = seq(0, 1, l = 101), t = seq(0, 1, l = 101),
  std_error = 0.15, nonlinear = NULL, concurrent = FALSE,
  int_rule = "trapezoid", n_fpc = 50, verbose = FALSE, ...)

nl_dev(X_fdata, t = seq(0, 1, l = 101), nonlinear = NULL,
  int_rule = "trapezoid", equispaced = equispaced, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim-frmfr_+3A_n">n</code></td>
<td>
<p>sample size, only required when <code>scenario</code> is given.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_scenario">scenario</code></td>
<td>
<p>an index from <code>1</code> to <code>3</code> (default) denoting
one of the scenarios (S1, S2 or S3) simulated in
García-Portugués et al. (2021) (see details below). If
<code>scenario = NULL</code>, <code>X_fdata</code>, <code>error_fdata</code>, and <code>beta</code>
have to be provided. Otherwise, <code>X_fdata</code>, <code>error_fdata</code>, and
<code>beta</code> will be ignored.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_x_fdata">X_fdata</code></td>
<td>
<p>sample of functional covariates <code class="reqn">X(s)</code> as
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> objects of length <code>n</code>, with <code class="reqn">s</code> in
<code class="reqn">[a, b]</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_error_fdata">error_fdata</code></td>
<td>
<p>sample of functional errors <code class="reqn">\varepsilon(t)</code> as
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> objects of length <code>n</code>, with <code class="reqn">t</code> in
<code class="reqn">[c, d]</code>. If <code>concurrent = TRUE</code>, <code>X_fdata</code> and
<code>error_fdata</code> must be valued in the same grid. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_beta">beta</code></td>
<td>
<p>matrix containing the values <code class="reqn">\beta(s, t)</code>, for each grid
point <code class="reqn">s</code> in <code class="reqn">[a, b]</code> and <code class="reqn">t</code> in <code class="reqn">[c, d]</code>. If
<code>concurrent = TRUE</code> (see details below), a row/column vector
must be introduced, valued in the same grid as <code>error_fdata</code>.
If <code>beta = NULL</code> (default), <code>scenario != NULL</code> is required.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_s">s</code>, <code id="sim-frmfr_+3A_t">t</code></td>
<td>
<p>grid points. If <code>X_fdata</code>, <code>error_fdata</code> and
<code>beta</code> are provided, <code>s</code> and <code>t</code> are ignored. Default to
<code>s = seq(0, 1, l = 101)</code> and <code>t = seq(0, 1, l = 101)</code>,
respectively.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_std_error">std_error</code></td>
<td>
<p>standard deviation of the random variables
involved in the generation of the functional error <code>error_fdata</code>.
Defaults to <code>0.15</code>.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_nonlinear">nonlinear</code></td>
<td>
<p>nonlinear term. Either a character string (<code>"exp"</code>,
<code>"quadratic"</code> or <code>"sin"</code>) or an <code><a href="fda.usc.html#topic+fdata">fdata</a></code>
object of length <code>n</code>, valued in the same grid as <code>error_fdata</code>.
If <code>nonlinear = NULL</code> (default), the nonlinear part is set to zero.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_concurrent">concurrent</code></td>
<td>
<p>flag to consider a concurrent FLRFR (degenerate case).
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_int_rule">int_rule</code></td>
<td>
<p>quadrature rule for approximating the definite
unidimensional integral: trapezoidal rule (<code>int_rule = "trapezoid"</code>)
and extended Simpson rule (<code>int_rule = "Simpson"</code>) are available.
Defaults to <code>"trapezoid"</code>.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_n_fpc">n_fpc</code></td>
<td>
<p>number of components to be considered for the generation of
functional variables. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_verbose">verbose</code></td>
<td>
<p>flag to display information about the sampling procedure.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_...">...</code></td>
<td>
<p>further parameters passed to
<code><a href="#topic+elem-flmfr">r_cm2013_flmfr</a></code>,
<code><a href="#topic+elem-flmfr">r_gof2021_flmfr</a></code> and<br />
<code><a href="#topic+elem-flmfr">r_ik2018_flmfr</a></code>, depending on the
chosen <code>scenario</code>.</p>
</td></tr>
<tr><td><code id="sim-frmfr_+3A_equispaced">equispaced</code></td>
<td>
<p>flag to indicate if <code>X_fdata$data</code> is valued in
an equispaced grid or not. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>r_frm_fr</code> samples the above regression model,
where the nonlinear term <code class="reqn">\Delta(X)</code> is computed by <code>nl_dev</code>.
Functional covariates, errors, and <code class="reqn">\beta</code> are generated
automatically from the scenarios in García-Portugués et al. (2021) when
<code>scenario != NULL</code> (see the documentation of
<code><a href="#topic+r_gof2021_flmfr">r_gof2021_flmfr</a></code>). If <code>scenario = NULL</code>,
covariates, errors and <code class="reqn">\beta</code> must be provided.
</p>
<p>When <code>concurrent = TRUE</code>, the concurrent FRMFR
</p>
<p style="text-align: center;"><code class="reqn">Y(t) = X(t) \beta(t) +
  \Delta(X)(t) + \varepsilon(t)</code>
</p>

<p>is considered.
</p>
</li>
<li><p><code>nl_dev</code> computes a nonlinear deviation
<code class="reqn">\Delta(X)</code>:
<code class="reqn">\exp(\sqrt{X(a + (t - c) ((b - a) / (d - c)))})</code>
(for <code>"exp"</code>),
<code class="reqn">(X^2 (a + (t - c) ((b - a) / (d - c))) - 1)</code>
(<code>"quadratic"</code>) or
<code class="reqn">(\sin(2\pi t) - \cos(2 \pi t)) \| X \|^2</code>
(<code>"sin"</code>). Also, <code class="reqn">\Delta(X)</code> can be manually set as an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of length <code>n</code> and valued in
the same grid as <code>error_fdata</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>X_fdata</code></td>
<td>
<p>functional covariates, an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of length <code>n</code>.</p>
</td></tr>
<tr><td><code>Y_fdata</code></td>
<td>
<p>functional responses, an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of length <code>n</code>.</p>
</td></tr>
<tr><td><code>error_fdata</code></td>
<td>
<p>functional errors, an
<code><a href="fda.usc.html#topic+fdata">fdata</a></code> object of length <code>n</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>either the matrix with <code class="reqn">\beta(s, t)</code> evaluated at
the <code>argvals</code> of <code>X_fdata</code> and <code>Y_fdata</code> (if
<code>concurrent = FALSE</code>) or a vector with <code class="reqn">\beta(t)</code>
evaluated at the <code>argvals</code> of <code>X_fdata</code> (if
<code>concurrent = TRUE</code>).</p>
</td></tr>
<tr><td><code>nl_dev</code></td>
<td>
<p>nonlinear term, an <code><a href="fda.usc.html#topic+fdata">fdata</a></code>
object of length <code>n</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Javier Álvarez-Liébana.
</p>


<h3>References</h3>

<p>García-Portugués, E., Álvarez-Liébana, J., Álvarez-Pérez, G. and
Gonzalez-Manteiga, W. (2021). A goodness-of-fit test for the functional
linear model with functional response. <em>Scandinavian Journal of
Statistics</em>, 48(2):502&ndash;528. <a href="https://doi.org/10.1111/sjos.12486">doi:10.1111/sjos.12486</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate samples for the three scenarios

# Equispaced grids and Simpson's rule

s &lt;- seq(0, 1, l = 101)
samp &lt;- list()
old_par &lt;- par(mfrow = c(3, 5))
for (i in 1:3) {
  samp[[i]] &lt;- r_frm_fr(n = 100, scenario = i, s = s, t = s,
                        int_rule = "Simpson")
  plot(samp[[i]]$X_fdata)
  plot(samp[[i]]$error_fdata)
  plot(samp[[i]]$Y_fdata)
  plot(samp[[i]]$nl_dev)
  image(x = s, y = s, z = samp[[i]]$beta, col = viridisLite::viridis(20))
}
par(old_par)

## Linear term as a concurrent model

# The grids must be have the same number of grid points for a given
# nonlinear term and a given beta function

s &lt;- seq(1, 2, l = 101)
t &lt;- seq(0, 1, l = 101)
samp_c_1 &lt;- r_frm_fr(n = 100, scenario = 3, beta = sin(t) - exp(t),
                     s = s, t = t, nonlinear = fda.usc::fdata(mdata =
                       t(matrix(rep(sin(t), 100), nrow = length(t))),
                       argvals = t),
                     concurrent = TRUE)
old_par &lt;- par(mfrow = c(3, 2))
plot(samp_c_1$X_fdata)
plot(samp_c_1$error_fdata)
plot(samp_c_1$Y_fdata)
plot(samp_c_1$nl_dev)
plot(samp_c_1$beta)
par(old_par)

## Sample for given X_fdata, error_fdata, and beta

# Non equispaced grids with sinusoidal nonlinear term and intensity 0.5
s &lt;- c(seq(0, 0.5, l = 50), seq(0.51, 1, l = 101))
t &lt;- seq(2, 4, len = 151)
X_fdata &lt;- r_ou(n = 100, t = s, alpha = 2, sigma = 4, x0 = 1:100)
error_fdata &lt;- r_ou(n = 100, t = t, alpha = 1, sigma = 1, x0 = 1:100)
beta &lt;- r_gof2021_flmfr(n = 100, s = s, t = t)$beta
samp_Xeps &lt;- r_frm_fr(scenario = NULL, X_fdata = X_fdata,
                      error_fdata = error_fdata, beta = beta,
                      nonlinear = "exp", int_rule = "trapezoid")
old_par &lt;- par(mfrow = c(3, 2))
plot(samp_Xeps$X_fdata)
plot(samp_Xeps$error_fdata)
plot(samp_Xeps$Y_fdata)
plot(samp_Xeps$nl_dev)
image(x = s, y = t, z = beta, col = viridisLite::viridis(20))
par(old_par)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
