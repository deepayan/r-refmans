<!DOCTYPE html><html><head><title>Help for package pomp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pomp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abc'><p>Approximate Bayesian computation</p></a></li>
<li><a href='#accumvars'><p>accumulator variables</p></a></li>
<li><a href='#as_pomp'><p>as.pomp</p></a></li>
<li><a href='#as.data.frame'><p>Coerce to data frame</p></a></li>
<li><a href='#basic_components'><p>Basic POMP model components.</p></a></li>
<li><a href='#basic_probes'><p>Useful probes for partially-observed Markov processes</p></a></li>
<li><a href='#betabinomial'><p>Beta-binomial distribution</p></a></li>
<li><a href='#blowflies'><p>Nicholson's blowflies.</p></a></li>
<li><a href='#bsflu'><p>Influenza outbreak in a boarding school</p></a></li>
<li><a href='#bsmc2'><p>The Liu and West Bayesian particle filter</p></a></li>
<li><a href='#bsplines'><p>B-spline bases</p></a></li>
<li><a href='#childhood_disease_data'><p>Historical childhood disease incidence data</p></a></li>
<li><a href='#coef'><p>Extract, set, or alter coefficients</p></a></li>
<li><a href='#compartmental_models'><p>Compartmental epidemiological models</p></a></li>
<li><a href='#conc'><p>Concatenate</p></a></li>
<li><a href='#concat'><p>Concatenate</p></a></li>
<li><a href='#cond_logLik'><p>Conditional log likelihood</p></a></li>
<li><a href='#continue'><p>Continue an iterative calculation</p></a></li>
<li><a href='#covariates'><p>Covariates</p></a></li>
<li><a href='#covmat'><p>Estimate a covariance matrix from algorithm traces</p></a></li>
<li><a href='#Csnippet'><p>C snippets</p></a></li>
<li><a href='#dacca'><p>Model of cholera transmission for historic Bengal.</p></a></li>
<li><a href='#defunct'><p>Defunct functions</p></a></li>
<li><a href='#design'><p>Design matrices for pomp calculations</p></a></li>
<li><a href='#dinit'><p>dinit workhorse</p></a></li>
<li><a href='#dinit_spec'><p>dinit specification</p></a></li>
<li><a href='#dmeasure'><p>dmeasure workhorse</p></a></li>
<li><a href='#dmeasure_spec'><p>dmeasure specification</p></a></li>
<li><a href='#dprior'><p>dprior workhorse</p></a></li>
<li><a href='#dprocess'><p>dprocess workhorse</p></a></li>
<li><a href='#dprocess_spec'><p>dprocess specification</p></a></li>
<li><a href='#ebola'><p>Ebola outbreak, West Africa, 2014-2016</p></a></li>
<li><a href='#eff_sample_size'><p>Effective sample size</p></a></li>
<li><a href='#elementary_algorithms'><p>Elementary computations on POMP models.</p></a></li>
<li><a href='#emeasure'><p>emeasure workhorse</p></a></li>
<li><a href='#emeasure_spec'><p>emeasure specification</p></a></li>
<li><a href='#estimation_algorithms'><p>Parameter estimation algorithms for POMP models.</p></a></li>
<li><a href='#eulermultinom'><p>Eulermultinomial and gamma-whitenoise distributions</p></a></li>
<li><a href='#filter_mean'><p>Filtering mean</p></a></li>
<li><a href='#filter_traj'><p>Filtering trajectories</p></a></li>
<li><a href='#flow'><p>flow workhorse</p></a></li>
<li><a href='#forecast'><p>Forecast mean</p></a></li>
<li><a href='#gompertz'><p>Gompertz model with log-normal observations.</p></a></li>
<li><a href='#hitch'><p>Hitching C snippets and R functions to pomp_fun objects</p></a></li>
<li><a href='#kalman'><p>Ensemble Kalman filters</p></a></li>
<li><a href='#kalmanFilter'><p>Kalman filter</p></a></li>
<li><a href='#listie'><p>listie</p></a></li>
<li><a href='#load'><p>Loading and unloading shared-object libraries</p></a></li>
<li><a href='#logLik'><p>Log likelihood</p></a></li>
<li><a href='#logmeanexp'><p>The log-mean-exp trick</p></a></li>
<li><a href='#lookup'><p>Lookup table</p></a></li>
<li><a href='#mcap'><p>Monte Carlo adjusted profile</p></a></li>
<li><a href='#melt'><p>Melt</p></a></li>
<li><a href='#mif2'><p>Iterated filtering: maximum likelihood by iterated, perturbed Bayes maps</p></a></li>
<li><a href='#nlf'><p>Nonlinear forecasting</p></a></li>
<li><a href='#objfun'><p>Objective functions</p></a></li>
<li><a href='#obs'><p>obs</p></a></li>
<li><a href='#ou2'><p>Two-dimensional discrete-time Ornstein-Uhlenbeck process</p></a></li>
<li><a href='#parameter_trans'><p>parameter transformations</p></a></li>
<li><a href='#parmat'><p>Create a matrix of parameters</p></a></li>
<li><a href='#partrans'><p>partrans workhorse</p></a></li>
<li><a href='#parus'><p>Parus major population dynamics</p></a></li>
<li><a href='#pfilter'><p>Particle filter</p></a></li>
<li><a href='#plot'><p>pomp plotting facilities</p></a></li>
<li><a href='#pmcmc'><p>The particle Markov chain Metropolis-Hastings algorithm</p></a></li>
<li><a href='#pomp_constructor'><p>Constructor of the basic pomp object</p></a></li>
<li><a href='#pomp_examples'><p>pre-built pomp examples</p></a></li>
<li><a href='#pomp_fun'><p>The &quot;pomp_fun&quot; class</p></a></li>
<li><a href='#pomp-class'><p>The basic pomp class</p></a></li>
<li><a href='#pomp-package'><p>Inference for partially observed Markov processes</p></a></li>
<li><a href='#pred_mean'><p>Prediction mean</p></a></li>
<li><a href='#pred_var'><p>Prediction variance</p></a></li>
<li><a href='#print'><p>Print methods</p></a></li>
<li><a href='#prior_spec'><p>prior specification</p></a></li>
<li><a href='#probe'><p>Probes (AKA summary statistics)</p></a></li>
<li><a href='#probe_match'><p>Probe matching</p></a></li>
<li><a href='#proposals'><p>MCMC proposal distributions</p></a></li>
<li><a href='#pStop'><p>pStop, pWarn, pMess</p></a></li>
<li><a href='#reproducibility_tools'><p>Tools for reproducible computations</p></a></li>
<li><a href='#resample'><p>Resample</p></a></li>
<li><a href='#ricker'><p>Ricker model with Poisson observations.</p></a></li>
<li><a href='#rinit'><p>rinit workhorse</p></a></li>
<li><a href='#rinit_spec'><p>rinit specification</p></a></li>
<li><a href='#rmeasure'><p>rmeasure workhorse</p></a></li>
<li><a href='#rmeasure_spec'><p>rmeasure specification</p></a></li>
<li><a href='#rprior'><p>rprior workhorse</p></a></li>
<li><a href='#rprocess'><p>rprocess workhorse</p></a></li>
<li><a href='#rprocess_spec'><p>rprocess specification</p></a></li>
<li><a href='#rw_sd'><p>rw_sd</p></a></li>
<li><a href='#rw2'><p>Two-dimensional random-walk process</p></a></li>
<li><a href='#sannbox'><p>Simulated annealing with box constraints.</p></a></li>
<li><a href='#saved_states'><p>Saved states</p></a></li>
<li><a href='#show'><p>Show methods</p></a></li>
<li><a href='#simulate'><p>Simulations of a partially-observed Markov process</p></a></li>
<li><a href='#skeleton'><p>skeleton workhorse</p></a></li>
<li><a href='#skeleton_spec'><p>skeleton specification</p></a></li>
<li><a href='#spect'><p>Power spectrum</p></a></li>
<li><a href='#spect_match'><p>Spectrum matching</p></a></li>
<li><a href='#spy'><p>Spy</p></a></li>
<li><a href='#states'><p>Latent states</p></a></li>
<li><a href='#summary'><p>Summary methods</p></a></li>
<li><a href='#time'><p>Methods to extract and manipulate the obseration times</p></a></li>
<li><a href='#timezero'><p>The zero time</p></a></li>
<li><a href='#traces'><p>Traces</p></a></li>
<li><a href='#traj_match'><p>Trajectory matching</p></a></li>
<li><a href='#trajectory'><p>Trajectory of a deterministic model</p></a></li>
<li><a href='#transformations'><p>Transformations</p></a></li>
<li><a href='#undefined'><p>Undefined</p></a></li>
<li><a href='#userdata'><p>Facilities for making additional information to basic components</p></a></li>
<li><a href='#verhulst'><p>Verhulst-Pearl model</p></a></li>
<li><a href='#vmeasure'><p>vmeasure workhorse</p></a></li>
<li><a href='#vmeasure_spec'><p>vmeasure specification</p></a></li>
<li><a href='#window'><p>Window</p></a></li>
<li><a href='#workhorses'><p>Workhorse functions for the <span class="pkg">pomp</span> algorithms.</p></a></li>
<li><a href='#wpfilter'><p>Weighted particle filter</p></a></li>
<li><a href='#wquant'><p>Weighted quantile function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Inference for Partially Observed Markov Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>5.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-14</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kingaa.github.io/pomp/">https://kingaa.github.io/pomp/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for data analysis with partially observed Markov process (POMP) models (also known as stochastic dynamical systems, hidden Markov models, and nonlinear, non-Gaussian, state-space models).  The package provides facilities for implementing POMP models, simulating them, and fitting them to time series data by a variety of frequentist and Bayesian methods.  It is also a versatile platform for implementation of inference methods for general POMP models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, graphics, digest, mvtnorm, deSolve, coda,
data.table</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, dplyr, tidyr, subplex, nloptr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>For Windows users, Rtools (see
https://cran.r-project.org/bin/windows/Rtools/).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kingaa/pomp/issues/">https://github.com/kingaa/pomp/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'package.R' 'pstop.R' 'undefined.R' 'csnippet.R' 'pomp_fun.R'
'parameter_trans.R' 'covariate_table.R' 'skeleton_spec.R'
'rprocess_spec.R' 'safecall.R' 'pomp_class.R' 'load.R'
'workhorses.R' 'continue.R' 'summary.R' 'prior_spec.R'
'dmeasure_spec.R' 'dprocess_spec.R' 'rmeasure_spec.R'
'rinit_spec.R' 'dinit_spec.R' 'templates.R' 'builder.R'
'pomp.R' 'probe.R' 'abc.R' 'accumulators.R' 'melt.R' 'kalman.R'
'pfilter.R' 'wpfilter.R' 'proposals.R' 'pmcmc.R' 'mif2.R'
'listie.R' 'simulate.R' 'spect.R' 'plot.R' 'bsmc2.R'
'as_data_frame.R' 'as_pomp.R' 'bake.R' 'basic_components.R'
'basic_probes.R' 'betabinom.R' 'blowflies.R' 'bsflu.R'
'bsplines.R' 'childhood.R' 'coef.R' 'conc.R' 'concat.R'
'cond_logLik.R' 'covmat.R' 'dacca.R' 'defunct.R' 'design.R'
'ebola.R' 'eff_sample_size.R' 'elementary_algorithms.R'
'emeasure_spec.R' 'estimation_algorithms.R' 'eulermultinom.R'
'extract.R' 'filter_mean.R' 'filter_traj.R' 'flow.R'
'forecast.R' 'gompertz.R' 'kf.R' 'probe_match.R'
'spect_match.R' 'nlf.R' 'trajectory.R' 'traj_match.R'
'objfun.R' 'loglik.R' 'logmeanexp.R' 'lookup.R' 'mcap.R'
'obs.R' 'ou2.R' 'parmat.R' 'parus.R' 'pomp_examp.R'
'pred_mean.R' 'pred_var.R' 'show.R' 'print.R'
'profile_design.R' 'resample.R' 'ricker.R' 'runif_design.R'
'rw2.R' 'sannbox.R' 'saved_states.R' 'sir.R' 'slice_design.R'
'sobol_design.R' 'spy.R' 'states.R' 'time.R' 'timezero.R'
'traces.R' 'transformations.R' 'userdata.R' 'verhulst.R'
'vmeasure_spec.R' 'window.R' 'wquant.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 13:37:25 UTC; kingaa</td>
</tr>
<tr>
<td>Author:</td>
<td>Aaron A. King <a href="https://orcid.org/0000-0001-6159-3207"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Edward L. Ionides <a href="https://orcid.org/0000-0002-4190-0174"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Carles Bretó <a href="https://orcid.org/0000-0003-4695-4902"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Stephen P. Ellner <a href="https://orcid.org/0000-0002-8351-9734"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Matthew J. Ferrari [ctb],
  Sebastian Funk <a href="https://orcid.org/0000-0002-2842-3406"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Steven G. Johnson [ctb],
  Bruce E. Kendall <a href="https://orcid.org/0000-0003-1782-8106"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Michael Lavine [ctb],
  Dao Nguyen <a href="https://orcid.org/0000-0003-2215-613X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Eamon B. O'Dea <a href="https://orcid.org/0000-0003-4748-683X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Daniel C. Reuman [ctb],
  Helen Wearing <a href="https://orcid.org/0000-0002-9837-9797"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Simon N. Wood <a href="https://orcid.org/0000-0002-2034-7453"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron A. King &lt;kingaa@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-14 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abc'>Approximate Bayesian computation</h2><span id='topic+abc'></span><span id='topic+abc+2Cmissing-method'></span><span id='topic+abc+2CANY-method'></span><span id='topic+abc+2Cdata.frame-method'></span><span id='topic+abc+2Cpomp-method'></span><span id='topic+abc+2Cprobed_pomp-method'></span><span id='topic+abc+2Cabcd_pomp-method'></span>

<h3>Description</h3>

<p>The approximate Bayesian computation (ABC) algorithm for estimating the parameters of a partially-observed Markov process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
abc(
  data,
  Nabc = 1,
  proposal,
  scale,
  epsilon,
  probes,
  params,
  rinit,
  rprocess,
  rmeasure,
  dprior,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
abc(
  data,
  Nabc = 1,
  proposal,
  scale,
  epsilon,
  probes,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'probed_pomp'
abc(data, probes, ..., verbose = getOption("verbose", FALSE))

## S4 method for signature 'abcd_pomp'
abc(
  data,
  Nabc,
  proposal,
  scale,
  epsilon,
  probes,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abc_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="abc_+3A_nabc">Nabc</code></td>
<td>
<p>the number of ABC iterations to perform.</p>
</td></tr>
<tr><td><code id="abc_+3A_proposal">proposal</code></td>
<td>
<p>optional function that draws from the proposal
distribution.  Currently, the proposal distribution must be symmetric for
proper inference: it is the user's responsibility to ensure that it is.
Several functions that construct appropriate proposal function are
provided: see <a href="#topic+proposals">MCMC proposals</a> for more information.</p>
</td></tr>
<tr><td><code id="abc_+3A_scale">scale</code></td>
<td>
<p>named numeric vector of scales.</p>
</td></tr>
<tr><td><code id="abc_+3A_epsilon">epsilon</code></td>
<td>
<p>ABC tolerance.</p>
</td></tr>
<tr><td><code id="abc_+3A_probes">probes</code></td>
<td>
<p>a single probe or a list of one or more probes.
A probe is simply a scalar- or vector-valued function of one argument that can be applied to the data array of a &lsquo;pomp&rsquo;.
A vector-valued probe must always return a vector of the same size.
A number of useful probes are provided with the package:
see <a href="#topic+basic_probes">basic probes</a>.</p>
</td></tr>
<tr><td><code id="abc_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="abc_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="abc_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="abc_+3A_rmeasure">rmeasure</code></td>
<td>
<p>simulator of the measurement model, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rmeasure=NULL</code> removes the measurement model simulator.
For more information, see <a href="#topic+rmeasure_spec">rmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="abc_+3A_dprior">dprior</code></td>
<td>
<p>optional; prior distribution density evaluator, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
For more information, see <a href="#topic+prior_spec">prior specification</a>.
Setting <code>dprior=NULL</code> resets the prior distribution to its default, which is a flat improper prior.</p>
</td></tr>
<tr><td><code id="abc_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="abc_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Running ABC</h3>

<p><code>abc</code> returns an object of class &lsquo;abcd_pomp&rsquo;.
One or more &lsquo;abcd_pomp&rsquo; objects can be joined to form an &lsquo;abcList&rsquo; object.
</p>


<h3>Re-running ABC iterations</h3>

<p>To re-run a sequence of ABC iterations, one can use the <code>abc</code> method on a &lsquo;abcd_pomp&rsquo; object.
By default, the same parameters used for the original ABC run are re-used (except for <code>verbose</code>, the default of which is shown above).
If one does specify additional arguments, these will override the defaults.
</p>


<h3>Continuing ABC iterations</h3>

<p>One can continue a series of ABC iterations from where one left off using the <code>continue</code> method.
A call to <code>abc</code> to perform <code>Nabc=m</code> iterations followed by a call to <code>continue</code> to perform <code>Nabc=n</code> iterations will produce precisely the same effect as a single call to <code>abc</code> to perform <code>Nabc=m+n</code> iterations.
By default, all the algorithmic parameters are the same as used in the original call to <code>abc</code>.
Additional arguments will override the defaults.
</p>


<h3>Methods</h3>

<p>The following can be applied to the output of an <code>abc</code> operation:
</p>

<dl>
<dt><code>abc</code></dt><dd><p>repeats the calculation, beginning with the last state</p>
</dd>
<dt><code><a href="#topic+continue">continue</a></code></dt><dd><p>continues the <code>abc</code> calculation</p>
</dd>
<dt><code>plot</code></dt><dd><p>produces a series of diagnostic plots</p>
</dd>
<dt><code><a href="#topic+traces">traces</a></code></dt><dd><p>produces an <code><a href="coda.html#topic+mcmc">mcmc</a></code> object, to which the various <span class="pkg">coda</span> convergence diagnostics can be applied</p>
</dd>
</dl>



<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides, Aaron A. King
</p>


<h3>References</h3>

<p>J.-M. Marin, P. Pudlo, C. P. Robert, and R. J. Ryder. Approximate Bayesian computational methods. <em>Statistics and Computing</em> <b>22</b>, 1167&ndash;1180, 2012.
</p>
<p>T. Toni and M. P. H. Stumpf. Simulation-based model selection for dynamical systems in systems and population biology. <em>Bioinformatics</em> <b>26</b>, 104&ndash;110, 2010.
</p>
<p>T. Toni, D. Welch, N. Strelkowa, A. Ipsen, and M. P. H. Stumpf. Approximate Bayesian computation scheme for parameter inference and model selection in dynamical systems. <em>Journal of the Royal Society Interface</em> <b>6</b>, 187&ndash;202, 2009.
</p>


<h3>See Also</h3>

<p>More on methods based on summary statistics: 
<code><a href="#topic+basic_probes">basic_probes</a></code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>
<p>More on <span class="pkg">pomp</span> estimation algorithms:
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+estimation_algorithms">estimation_algorithms</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>
<p>More on Markov chain Monte Carlo methods:
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+proposals">proposals</a></code>
</p>
<p>More on Bayesian methods:
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rprior">rprior</a>()</code>
</p>

<hr>
<h2 id='accumvars'>accumulator variables</h2><span id='topic+accumvars'></span>

<h3>Description</h3>

<p>Latent state variables that accumulate quantities through time.
</p>


<h3>Details</h3>

<p>In formulating models, one sometimes wishes to define a state variable that will accumulate some quantity over the interval between successive observations.
<span class="pkg">pomp</span> provides a facility to make such features more convenient.
Specifically, variables named in the <code>pomp</code>'s <code>accumvars</code> argument will be set to zero immediately following each observation.
See <code><a href="#topic+sir">sir</a></code> and the tutorials on the <a href="https://kingaa.github.io/pomp/">package website</a> for examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sir">sir</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## A simple SIR model.

  ewmeas |&gt;
    subset(time &lt; 1952) |&gt;
    pomp(
      times="time",t0=1948,
      rprocess=euler(
        Csnippet("
        int nrate = 6;
        double rate[nrate];     // transition rates
        double trans[nrate];    // transition numbers
        double dW;

        // gamma noise, mean=dt, variance=(sigma^2 dt)
        dW = rgammawn(sigma,dt);

        // compute the transition rates
        rate[0] = mu*pop;       // birth into susceptible class
        rate[1] = (iota+Beta*I*dW/dt)/pop; // force of infection
        rate[2] = mu;           // death from susceptible class
        rate[3] = gamma;        // recovery
        rate[4] = mu;           // death from infectious class
        rate[5] = mu;           // death from recovered class

        // compute the transition numbers
        trans[0] = rpois(rate[0]*dt);   // births are Poisson
        reulermultinom(2,S,&amp;rate[1],dt,&amp;trans[1]);
        reulermultinom(2,I,&amp;rate[3],dt,&amp;trans[3]);
        reulermultinom(1,R,&amp;rate[5],dt,&amp;trans[5]);

        // balance the equations
        S += trans[0]-trans[1]-trans[2];
        I += trans[1]-trans[3]-trans[4];
        R += trans[3]-trans[5];
      "),
      delta.t=1/52/20
      ),
      rinit=Csnippet("
        double m = pop/(S_0+I_0+R_0);
        S = nearbyint(m*S_0);
        I = nearbyint(m*I_0);
        R = nearbyint(m*R_0);
    "),
    paramnames=c("mu","pop","iota","gamma","Beta","sigma",
      "S_0","I_0","R_0"),
    statenames=c("S","I","R"),
    params=c(mu=1/50,iota=10,pop=50e6,gamma=26,Beta=400,sigma=0.1,
      S_0=0.07,I_0=0.001,R_0=0.93)
    ) -&gt; ew1

  ew1 |&gt;
    simulate() |&gt;
    plot(variables=c("S","I","R"))

  ## A simple SIR model that tracks cumulative incidence.

  ew1 |&gt;
    pomp(
      rprocess=euler(
        Csnippet("
        int nrate = 6;
        double rate[nrate];     // transition rates
        double trans[nrate];    // transition numbers
        double dW;

        // gamma noise, mean=dt, variance=(sigma^2 dt)
        dW = rgammawn(sigma,dt);

        // compute the transition rates
        rate[0] = mu*pop;       // birth into susceptible class
        rate[1] = (iota+Beta*I*dW/dt)/pop; // force of infection
        rate[2] = mu;           // death from susceptible class
        rate[3] = gamma;        // recovery
        rate[4] = mu;           // death from infectious class
        rate[5] = mu;           // death from recovered class

        // compute the transition numbers
        trans[0] = rpois(rate[0]*dt);   // births are Poisson
        reulermultinom(2,S,&amp;rate[1],dt,&amp;trans[1]);
        reulermultinom(2,I,&amp;rate[3],dt,&amp;trans[3]);
        reulermultinom(1,R,&amp;rate[5],dt,&amp;trans[5]);

        // balance the equations
        S += trans[0]-trans[1]-trans[2];
        I += trans[1]-trans[3]-trans[4];
        R += trans[3]-trans[5];
        H += trans[3];          // cumulative incidence
      "),
      delta.t=1/52/20
      ),
      rmeasure=Csnippet("
        double mean = H*rho;
        double size = 1/tau;
        reports = rnbinom_mu(size,mean);
    "),
    rinit=Csnippet("
        double m = pop/(S_0+I_0+R_0);
        S = nearbyint(m*S_0);
        I = nearbyint(m*I_0);
        R = nearbyint(m*R_0);
        H = 0;
    "),
    paramnames=c("mu","pop","iota","gamma","Beta","sigma","tau","rho",
      "S_0","I_0","R_0"),
    statenames=c("S","I","R","H"),
    params=c(mu=1/50,iota=10,pop=50e6,gamma=26,
      Beta=400,sigma=0.1,tau=0.001,rho=0.6,
      S_0=0.07,I_0=0.001,R_0=0.93)
    ) -&gt; ew2

  ew2 |&gt;
    simulate() |&gt;
    plot()

  ## A simple SIR model that tracks weekly incidence.

  ew2 |&gt;
    pomp(accumvars="H") -&gt; ew3

  ew3 |&gt;
    simulate() |&gt;
    plot()


</code></pre>

<hr>
<h2 id='as_pomp'>as.pomp</h2><span id='topic+as_pomp'></span>

<h3>Description</h3>

<p>Coerce to a &lsquo;pomp&rsquo; object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_pomp(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_pomp_+3A_object">object</code></td>
<td>
<p>the object to be coerced</p>
</td></tr>
<tr><td><code id="as_pomp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='as.data.frame'>Coerce to data frame</h2><span id='topic+as.data.frame'></span><span id='topic+as.data.frame.pomp'></span><span id='topic+as.data.frame.pfilterd_pomp'></span><span id='topic+as.data.frame.probed_pomp'></span><span id='topic+as.data.frame.kalmand_pomp'></span><span id='topic+as.data.frame.bsmcd_pomp'></span><span id='topic+as.data.frame.pompList'></span><span id='topic+as.data.frame.pfilterList'></span><span id='topic+as.data.frame.abcList'></span><span id='topic+as.data.frame.mif2List'></span><span id='topic+as.data.frame.pmcmcList'></span><span id='topic+as.data.frame.wpfilterd_pomp'></span>

<h3>Description</h3>

<p>All <span class="pkg">pomp</span> model objects can be recast as data frames.
The contents of the resulting data frame depend on the nature of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pomp'
as.data.frame(x, ...)

## S3 method for class 'pfilterd_pomp'
as.data.frame(x, ...)

## S3 method for class 'probed_pomp'
as.data.frame(x, ...)

## S3 method for class 'kalmand_pomp'
as.data.frame(x, ...)

## S3 method for class 'bsmcd_pomp'
as.data.frame(x, ...)

## S3 method for class 'pompList'
as.data.frame(x, ...)

## S3 method for class 'pfilterList'
as.data.frame(x, ...)

## S3 method for class 'abcList'
as.data.frame(x, ...)

## S3 method for class 'mif2List'
as.data.frame(x, ...)

## S3 method for class 'pmcmcList'
as.data.frame(x, ...)

## S3 method for class 'wpfilterd_pomp'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>object</code> is a simple &lsquo;pomp&rsquo; object,
<code>as(object,"data.frame")</code> or <code>as.data.frame(object)</code> results in a
data frame with the times, observables, states (if known), and
interpolated covariates (if any).
</p>
<p>When <code>object</code> is a &lsquo;pfilterd_pomp&rsquo; object,
coercion to a data frame results in a data frame with the same content as for a simple &lsquo;pomp&rsquo;,
but with conditional log likelihood and effective sample size estimates included, as well as filtering means, prediction means, and prediction variances, if these have been computed.
</p>
<p>When <code>object</code> is a &lsquo;probed_pomp&rsquo; object,
coercion to a data frame results in a data frame with the values of the probes computed on the data and on simulations.
</p>
<p>When <code>object</code> is a &lsquo;kalmand_pomp&rsquo; object,
coercion to a data frame results in a data frame with prediction means, filter means and forecasts, in addition to the data.
</p>
<p>When <code>object</code> is a &lsquo;bsmcd_pomp&rsquo; object,
coercion to a data frame results in a data frame with samples from the prior and posterior distribution.
The <code>.id</code> variable distinguishes them.
</p>
<p>When <code>object</code> is a &lsquo;wpfilterd_pomp&rsquo; object,
coercion to a data frame results in a data frame with the same content as for a simple &lsquo;pomp&rsquo;,
but with conditional log likelihood and effective sample size estimates included.
</p>

<hr>
<h2 id='basic_components'>Basic POMP model components.</h2><span id='topic+basic_components'></span>

<h3>Description</h3>

<p>Mathematically, the parts of a <abbr><span class="acronym">POMP</span></abbr> model include the latent-state process transition distribution, the measurement-process distribution, the initial-state distribution, and possibly a prior parameter distribution.
Algorithmically, each of these corresponds to at least two distinct operations.
In particular, for each of the above parts, one sometimes needs to make a random draw from the distribution and sometimes to evaluate the density function.
Accordingly, for each such component, there are two basic model components, one prefixed by a &lsquo;r&rsquo;, the other by a &lsquo;d&rsquo;, following the usual <span class="rlang"><b>R</b></span> convention.
</p>


<h3>Details</h3>

<p>In addition to the parts listed above, <span class="pkg">pomp</span> includes two additional basic model components: the deterministic skeleton, and parameter transformations that can be used to map the parameter space onto a Euclidean space for estimation purposes.
There are also basic model components for computing the mean and variance of the measurement process conditional on the latent-state process.
</p>
<p>There are thus altogether twelve <b>basic model components</b>:
</p>

<ol>
<li> <p><a href="#topic+rprocess_spec">rprocess</a>, which samples from the latent-state transition distribution,
</p>
</li>
<li> <p><a href="#topic+dprocess_spec">dprocess</a>, which evaluates the latent-state transition density,
</p>
</li>
<li> <p><a href="#topic+rmeasure_spec">rmeasure</a>, which samples from the measurement distribution,
</p>
</li>
<li> <p><a href="#topic+emeasure_spec">emeasure</a>, which computes the conditional expectation of the measurements, given the latent states,
</p>
</li>
<li> <p><a href="#topic+vmeasure_spec">vmeasure</a>, which computes the conditional covariance matrix of the measurements, given the latent states,
</p>
</li>
<li> <p><a href="#topic+dmeasure_spec">dmeasure</a>, which evaluates the measurement density,
</p>
</li>
<li> <p><a href="#topic+prior_spec">rprior</a>, which samples from the prior distribution,
</p>
</li>
<li> <p><a href="#topic+prior_spec">dprior</a>, which evaluates the prior density,
</p>
</li>
<li> <p><a href="#topic+rinit_spec">rinit</a>, which samples from the initial-state distribution,
</p>
</li>
<li> <p><a href="#topic+dinit_spec">dinit</a>, which evaluates the initial-state density,
</p>
</li>
<li> <p><a href="#topic+skeleton_spec">skeleton</a>, which evaluates the deterministic skeleton,
</p>
</li>
<li> <p><a href="#topic+parameter_trans">partrans</a>, which evaluates the forward or inverse parameter transformations.
</p>
</li></ol>

<p>Each of these can be set or modified in the <code>pomp</code> <a href="#topic+pomp">constructor function</a> or in any of the <span class="pkg">pomp</span> <a href="#topic+elementary_algorithms">elementary algorithms</a> or <a href="#topic+estimation_algorithms">estimation algorithms</a> using an argument that matches the basic model component.
A basic model component can be unset by passing <code>NULL</code> in the same way.
</p>
<p>Help pages detailing each basic model component are provided.
</p>


<h3>See Also</h3>

<p><a href="#topic+workhorses">workhorse functions</a>,
<a href="#topic+elementary_algorithms">elementary algorithms</a>,
<a href="#topic+estimation_algorithms">estimation algorithms</a>.
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>

<hr>
<h2 id='basic_probes'>Useful probes for partially-observed Markov processes</h2><span id='topic+basic_probes'></span><span id='topic+probe_mean'></span><span id='topic+probe_median'></span><span id='topic+probe_var'></span><span id='topic+probe_sd'></span><span id='topic+probe_period'></span><span id='topic+probe_quantile'></span><span id='topic+probe_acf'></span><span id='topic+probe_ccf'></span><span id='topic+probe_marginal'></span><span id='topic+probe_nlar'></span>

<h3>Description</h3>

<p>Several simple and configurable probes are provided with in the package.
These can be used directly and as templates for custom probes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probe_mean(var, trim = 0, transform = identity, na.rm = TRUE)

probe_median(var, na.rm = TRUE)

probe_var(var, transform = identity, na.rm = TRUE)

probe_sd(var, transform = identity, na.rm = TRUE)

probe_period(var, kernel.width, transform = identity)

probe_quantile(var, probs, ...)

probe_acf(
  var,
  lags,
  type = c("covariance", "correlation"),
  transform = identity
)

probe_ccf(
  vars,
  lags,
  type = c("covariance", "correlation"),
  transform = identity
)

probe_marginal(var, ref, order = 3, diff = 1, transform = identity)

probe_nlar(var, lags, powers, transform = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basic_probes_+3A_var">var</code>, <code id="basic_probes_+3A_vars">vars</code></td>
<td>
<p>character; the name(s) of the observed variable(s).</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_trim">trim</code></td>
<td>
<p>the fraction of observations to be trimmed (see <code><a href="base.html#topic+mean">mean</a></code>).</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_transform">transform</code></td>
<td>
<p>transformation to be applied to the data before the probe is computed.</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code>, remove all NA observations prior to computing the probe.</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_kernel.width">kernel.width</code></td>
<td>
<p>width of modified Daniell smoothing kernel to be used
in power-spectrum computation: see <code><a href="stats.html#topic+kernel">kernel</a></code>.</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_probs">probs</code></td>
<td>
<p>the quantile or quantiles to compute: see <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the underlying algorithms.</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_lags">lags</code></td>
<td>
<p>In <code>probe_ccf</code>, a vector of lags between time series.
Positive lags correspond to <code>x</code> advanced relative to <code>y</code>;
negative lags, to the reverse.
</p>
<p>In <code>probe_nlar</code>, a vector of lags present in the nonlinear
autoregressive model that will be fit to the actual and simulated data.
See Details, below, for a precise description.</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_type">type</code></td>
<td>
<p>Compute autocorrelation or autocovariance?</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_ref">ref</code></td>
<td>
<p>empirical reference distribution.  Simulated data will be
regressed against the values of <code>ref</code>, sorted and, optionally,
differenced.  The resulting regression coefficients capture information
about the shape of the marginal distribution.  A good choice for <code>ref</code>
is the data itself.</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_order">order</code></td>
<td>
<p>order of polynomial regression.</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_diff">diff</code></td>
<td>
<p>order of differencing to perform.</p>
</td></tr>
<tr><td><code id="basic_probes_+3A_powers">powers</code></td>
<td>
<p>the powers of each term (corresponding to <code>lags</code>) in the
the nonlinear autoregressive model that will be fit to the actual and
simulated data.  See Details, below, for a precise description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A call to any one of these functions returns a probe function,
suitable for use in <code><a href="#topic+probe">probe</a></code> or <code><a href="#topic+probe_objfun">probe_objfun</a></code>.  That
is, the function returned by each of these takes a data array (such as
comes from a call to <code><a href="#topic+obs">obs</a></code>) as input and returns a single
numerical value.
</p>


<h3>Author(s)</h3>

<p>Daniel C. Reuman, Aaron A. King
</p>


<h3>References</h3>

<p>B.E. Kendall, C.J. Briggs, W.W. Murdoch, P. Turchin, S.P. Ellner, E. McCauley, R.M. Nisbet, and S.N. Wood. Why do populations cycle? A synthesis of statistical and mechanistic modeling approaches. <em>Ecology</em> <b>80</b>, 1789&ndash;1805, 1999.
</p>
<p>S. N. Wood Statistical inference for noisy nonlinear ecological dynamic systems. <em>Nature</em> <b>466</b>, 1102&ndash;1104, 2010.
</p>


<h3>See Also</h3>

<p>More on methods based on summary statistics: 
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>

<hr>
<h2 id='betabinomial'>Beta-binomial distribution</h2><span id='topic+betabinomial'></span><span id='topic+rbetabinom'></span><span id='topic+dbetabinom'></span>

<h3>Description</h3>

<p>Density and random generation for the Beta-binomial distribution with parameters <code>size</code>, <code>mu</code>, and <code>theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbetabinom(n = 1, size, prob, theta)

dbetabinom(x, size, prob, theta, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betabinomial_+3A_n">n</code></td>
<td>
<p>integer; number of random variates to generate.</p>
</td></tr>
<tr><td><code id="betabinomial_+3A_size">size</code></td>
<td>
<p><code>size</code> parameter of the binomial distribution</p>
</td></tr>
<tr><td><code id="betabinomial_+3A_prob">prob</code></td>
<td>
<p>mean of the Beta distribution</p>
</td></tr>
<tr><td><code id="betabinomial_+3A_theta">theta</code></td>
<td>
<p>Beta distribution dispersion parameter</p>
</td></tr>
<tr><td><code id="betabinomial_+3A_x">x</code></td>
<td>
<p>vector of non-negative integer quantiles</p>
</td></tr>
<tr><td><code id="betabinomial_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, return logarithm(s) of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A variable <code class="reqn">X</code> is Beta-binomially distributed if
<code class="reqn">X\sim{\mathrm{Binomial}(n,P)}</code> where <code class="reqn">P\sim{\mathrm{Beta}(\mu,\theta)}</code>.
Using the standard <code class="reqn">(a,b)</code> parameterization, <code class="reqn">a=\mu\,\theta</code> and <code class="reqn">b=(1-\mu)\,\theta</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>rbetabinom</code></td>
<td>

<p>Returns a vector of length <code>n</code> containing random variates drawn from the Beta-binomial distribution.
</p>
</td></tr>
<tr><td><code>dbetabinom</code></td>
<td>

<p>Returns a vector (of length equal to the number of columns of <code>x</code>) containing the probabilities of observing each column of <code>x</code> given the specified parameters (<code>size</code>, <code>prob</code>, <code>theta</code>).
</p>
</td></tr>
</table>


<h3>C API</h3>

<p>An interface for C codes using these functions is provided by the package.
Visit the package homepage to view the <a href="https://kingaa.github.io/pomp/C_API.html"><span class="pkg">pomp</span> C API document</a>.
</p>


<h3>See Also</h3>

<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>

<hr>
<h2 id='blowflies'>Nicholson's blowflies.</h2><span id='topic+blowflies'></span><span id='topic+blowflies1'></span><span id='topic+blowflies2'></span>

<h3>Description</h3>

<p><code>blowflies</code> is a data frame containing the data from several of Nicholson's classic experiments with the Australian sheep blowfly, <em>Lucilia cuprina</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blowflies1(
  P = 3.2838,
  delta = 0.16073,
  N0 = 679.94,
  sigma.P = 1.3512,
  sigma.d = 0.74677,
  sigma.y = 0.026649
)

blowflies2(
  P = 2.7319,
  delta = 0.17377,
  N0 = 800.31,
  sigma.P = 1.442,
  sigma.d = 0.76033,
  sigma.y = 0.010846
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blowflies_+3A_p">P</code></td>
<td>
<p>reproduction parameter</p>
</td></tr>
<tr><td><code id="blowflies_+3A_delta">delta</code></td>
<td>
<p>death rate</p>
</td></tr>
<tr><td><code id="blowflies_+3A_n0">N0</code></td>
<td>
<p>population scale factor</p>
</td></tr>
<tr><td><code id="blowflies_+3A_sigma.p">sigma.P</code></td>
<td>
<p>intensity of <code class="reqn">e</code> noise</p>
</td></tr>
<tr><td><code id="blowflies_+3A_sigma.d">sigma.d</code></td>
<td>
<p>intensity of <code class="reqn">eps</code> noise</p>
</td></tr>
<tr><td><code id="blowflies_+3A_sigma.y">sigma.y</code></td>
<td>
<p>measurement error s.d.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>blowflies1()</code> and <code>blowflies2()</code> construct &lsquo;pomp&rsquo; objects encoding stochastic delay-difference equation models.
The data for these come from &quot;population I&quot;, a control culture.
The experiment is described on pp. 163&ndash;4 of Nicholson (1957).
Unlimited quantities of larval food were provided;
the adult food supply (ground liver) was constant at 0.4g per day.
The data were taken from the table provided by Brillinger et al. (1980).
</p>
<p>The models are discrete delay equations:
</p>
<p style="text-align: center;"><code class="reqn">R(t+1) \sim \mathrm{Poisson}(P N(t-\tau) \exp{(-N(t-\tau)/N_{0})} e(t+1) {\Delta}t)</code>
</p>

<p style="text-align: center;"><code class="reqn">S(t+1) \sim \mathrm{Binomial}(N(t),\exp{(-\delta \epsilon(t+1) {\Delta}t)})</code>
</p>

<p style="text-align: center;"><code class="reqn">N(t) = R(t)+S(t)</code>
</p>

<p>where <code class="reqn">e(t)</code> and <code class="reqn">\epsilon(t)</code> are Gamma-distributed i.i.d. random variables
with mean 1 and variances <code class="reqn">{\sigma_P^2}/{{\Delta}t}</code>, <code class="reqn">{\sigma_d^2}/{{\Delta}t}</code>, respectively.
<code>blowflies1</code> has a timestep (<code class="reqn">{\Delta}t</code>) of 1 day; <code>blowflies2</code> has a timestep of 2 days.
The process model in <code>blowflies1</code> thus corresponds exactly to that studied by Wood (2010).
The measurement model in both cases is taken to be
</p>
<p style="text-align: center;"><code class="reqn">y(t) \sim  \mathrm{NegBin}(N(t),1/\sigma_y^2)</code>
</p>

<p>i.e., the observations are assumed to be negative-binomially distributed with
mean <code class="reqn">N(t)</code> and variance <code class="reqn">N(t)+(\sigma_y N(t))^2</code>.
</p>
<p>Default parameter values are the MLEs as estimated by Ionides (2011).
</p>


<h3>Value</h3>

<p><code>blowflies1</code> and <code>blowflies2</code> return &lsquo;pomp&rsquo; objects containing the actual data and two variants of the model.
</p>


<h3>References</h3>

<p>A.J. Nicholson. The self-adjustment of populations to change. <em>Cold Spring Harbor Symposia on Quantitative Biology</em> <b>22</b>, 153&ndash;173, 1957.
</p>
<p>Y. Xia and H. Tong. Feature matching in time series modeling. <em>Statistical Science</em> <b>26</b>, 21&ndash;46, 2011.
</p>
<p>E.L. Ionides. Discussion of &ldquo;Feature matching in time series modeling&rdquo; by Y. Xia and H. Tong. <em>Statistical Science</em> <b>26</b>, 49&ndash;52, 2011.
</p>
<p>S. N. Wood Statistical inference for noisy nonlinear ecological dynamic systems. <em>Nature</em> <b>466</b>, 1102&ndash;1104, 2010.
</p>
<p>W.S.C. Gurney, S.P. Blythe, and R.M. Nisbet. Nicholson's blowflies revisited. <em>Nature</em> <b>287</b>, 17&ndash;21, 1980.
</p>
<p>D.R. Brillinger, J. Guckenheimer, P. Guttorp, and G. Oster. Empirical modelling of population time series: The case of age and density dependent rates. In: G. Oster (ed.), <em>Some Questions in Mathematical Biology</em> vol. 13, pp. 65&ndash;90, American Mathematical Society, Providence, 1980.
</p>


<h3>See Also</h3>

<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+compartmental_models">compartmental_models</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+gompertz">gompertz</a>()</code>,
<code><a href="#topic+ou2">ou2</a>()</code>,
<code><a href="#topic+pomp_examples">pomp_examples</a></code>,
<code><a href="#topic+ricker">ricker</a>()</code>,
<code><a href="#topic+rw2">rw2</a>()</code>,
<code><a href="#topic+verhulst">verhulst</a>()</code>
</p>
<p>More data sets provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+bsflu">bsflu</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+parus">parus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(blowflies1())
plot(blowflies2())

</code></pre>

<hr>
<h2 id='bsflu'>Influenza outbreak in a boarding school</h2><span id='topic+bsflu'></span>

<h3>Description</h3>

<p>An outbreak of influenza in an all-boys boarding school.
</p>


<h3>Details</h3>

<p>Data are recorded from a 1978 flu outbreak in a closed population.
The variable &lsquo;B&rsquo; refers to boys confined to bed on the corresponding day and &lsquo;C&rsquo; to boys in convalescence,
i.e., not yet allowed back to class.
In total, 763 boys were at risk of infection and, over the course of the outbreak, 512 boys spent between 3 and 7 days away from class (either in bed or convalescent).
The index case was a boy who arrived at school from holiday six days before the next case.
</p>


<h3>References</h3>

<p>Anonymous. Influenza in a boarding school. <em>British Medical Journal</em> <b>1</b>, 587, 1978.
</p>


<h3>See Also</h3>

<p><a href="#topic+compartmental_models">compartmental models</a>
</p>
<p>More data sets provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+parus">parus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(tidyr) &amp;&amp; require(ggplot2)) {

  bsflu |&gt;
    gather(variable,value,-date,-day) |&gt;
    ggplot(aes(x=date,y=value,color=variable))+
    geom_line()+
    labs(y="number of boys",title="boarding school flu outbreak")+
    theme_bw()

}
</code></pre>

<hr>
<h2 id='bsmc2'>The Liu and West Bayesian particle filter</h2><span id='topic+bsmc2'></span><span id='topic+bsmc2+2Cmissing-method'></span><span id='topic+bsmc2+2CANY-method'></span><span id='topic+bsmc2+2Cdata.frame-method'></span><span id='topic+bsmc2+2Cpomp-method'></span>

<h3>Description</h3>

<p>Modified version of the Liu &amp; West (2001) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
bsmc2(
  data,
  Np,
  smooth = 0.1,
  params,
  rprior,
  rinit,
  rprocess,
  dmeasure,
  partrans,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
bsmc2(data, Np, smooth = 0.1, ..., verbose = getOption("verbose", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsmc2_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="bsmc2_+3A_np">Np</code></td>
<td>
<p>the number of particles to use.
This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
Alternatively, if one wishes the number of particles to vary across timesteps, one may specify <code>Np</code> either as a vector of positive integers of length </p>
<pre>length(time(object,t0=TRUE))</pre><p> or as a function taking a positive integer argument.
In the latter case, <code>Np(k)</code> must be a single positive integer, representing the number of particles to be used at the <code>k</code>-th timestep:
<code>Np(0)</code> is the number of particles to use going from <code>timezero(object)</code> to <code>time(object)[1]</code>,
<code>Np(1)</code>, from <code>timezero(object)</code> to <code>time(object)[1]</code>,
and so on,
while when <code>T=length(time(object))</code>, <code>Np(T)</code> is the number of particles to sample at the end of the time-series.</p>
</td></tr>
<tr><td><code id="bsmc2_+3A_smooth">smooth</code></td>
<td>
<p>Kernel density smoothing parameter.
The compensating shrinkage factor will be <code>sqrt(1-smooth^2)</code>.
Thus, <code>smooth=0</code> means that no noise will be added to parameters.
The general recommendation is that the value of <code>smooth</code> should be chosen close to 0 (e.g., <code>shrink</code> ~ 0.1).</p>
</td></tr>
<tr><td><code id="bsmc2_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="bsmc2_+3A_rprior">rprior</code></td>
<td>
<p>optional; prior distribution sampler, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
For more information, see <a href="#topic+prior_spec">prior specification</a>.
Setting <code>rprior=NULL</code> removes the prior distribution sampler.</p>
</td></tr>
<tr><td><code id="bsmc2_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="bsmc2_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="bsmc2_+3A_dmeasure">dmeasure</code></td>
<td>
<p>evaluator of the measurement model density, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>dmeasure=NULL</code> removes the measurement density evaluator.
For more information, see <a href="#topic+dmeasure_spec">dmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="bsmc2_+3A_partrans">partrans</code></td>
<td>
<p>optional parameter transformations, constructed using <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
</p>
<p>Many algorithms for parameter estimation search an unconstrained space of parameters.
When working with such an algorithm and a model for which the parameters are constrained, it can be useful to transform parameters.
One should supply the <code>partrans</code> argument via a call to <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
For more information, see <a href="#topic+parameter_trans">parameter_trans</a>.
Setting <code>partrans=NULL</code> removes the parameter transformations, i.e., sets them to the identity transformation.</p>
</td></tr>
<tr><td><code id="bsmc2_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="bsmc2_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bsmc2</code> uses a version of the original algorithm (Liu &amp; West 2001), but discards the auxiliary particle filter.
The modification appears to give superior performance for the same amount of effort.
</p>
<p>Samples from the prior distribution are drawn using the <code>rprior</code> component.
This is allowed to depend on elements of <code>params</code>, i.e., some of the elements of <code>params</code> can be treated as &ldquo;hyperparameters&rdquo;.
<code>Np</code> draws are made from the prior distribution.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;bsmcd_pomp&rsquo;.
The following methods are avaiable:
</p>

<dl>
<dt><code><a href="#topic+plot+2Cbsmcd_pomp-method">plot</a></code></dt><dd><p>produces diagnostic plots</p>
</dd>
<dt><code><a href="#topic+as.data.frame">as.data.frame</a></code></dt><dd><p>puts the prior and posterior samples into a data frame</p>
</dd>
</dl>



<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Michael Lavine, Matthew Ferrari, Aaron A. King, Edward L. Ionides
</p>


<h3>References</h3>

<p>J. Liu and M. West. Combining parameter and state estimation in simulation-based filtering. In A. Doucet, N. de Freitas, and N. J. Gordon, (eds.), <em>Sequential Monte Carlo Methods in Practice</em>, pp. 197&ndash;224. Springer, New York, 2001.
</p>


<h3>See Also</h3>

<p>More on Bayesian methods:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rprior">rprior</a>()</code>
</p>
<p>More on full-information (i.e., likelihood-based) methods:
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on <span class="pkg">pomp</span> estimation algorithms:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+estimation_algorithms">estimation_algorithms</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>

<hr>
<h2 id='bsplines'>B-spline bases</h2><span id='topic+bsplines'></span><span id='topic+bspline_basis'></span><span id='topic+periodic_bspline_basis'></span>

<h3>Description</h3>

<p>These functions generate B-spline basis functions.
<code>bspline_basis</code> gives a basis of spline functions.
<code>periodic_bspline_basis</code> gives a
basis of periodic spline functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bspline_basis(x, nbasis, degree = 3, deriv = 0, names = NULL, rg = range(x))

periodic_bspline_basis(
  x,
  nbasis,
  degree = 3,
  period = 1,
  deriv = 0,
  names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsplines_+3A_x">x</code></td>
<td>
<p>Vector at which the spline functions are to be evaluated.</p>
</td></tr>
<tr><td><code id="bsplines_+3A_nbasis">nbasis</code></td>
<td>
<p>The number of basis functions to return.</p>
</td></tr>
<tr><td><code id="bsplines_+3A_degree">degree</code></td>
<td>
<p>Degree of requested B-splines.</p>
</td></tr>
<tr><td><code id="bsplines_+3A_deriv">deriv</code></td>
<td>
<p>The order of the derivative required.</p>
</td></tr>
<tr><td><code id="bsplines_+3A_names">names</code></td>
<td>
<p>optional; the names to be given to the basis functions.  These
will be the column-names of the matrix returned.  If the names are
specified as a format string (e.g., &quot;basis%d&quot;), <code><a href="base.html#topic+sprintf">sprintf</a></code> will
be used to generate the names from the column number.  If a single
non-format string is specified, the names will be generated by
<code><a href="base.html#topic+paste">paste</a></code>-ing <code>name</code> to the column number.  One can also
specify each column name explicitly by giving a length-<code>nbasis</code> string
vector.  By default, no column-names are given.</p>
</td></tr>
<tr><td><code id="bsplines_+3A_rg">rg</code></td>
<td>
<p>numeric of length 2; range of the B-spline basis.
To be properly specified, we must have <code>rg[1] &lt; rg[2]</code>.</p>
</td></tr>
<tr><td><code id="bsplines_+3A_period">period</code></td>
<td>
<p>The period of the requested periodic B-splines.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>bspline_basis</code></td>
<td>
<p> Returns a matrix with <code>length(x)</code> rows
and <code>nbasis</code> columns.  Each column contains the values one of the
spline basis functions.</p>
</td></tr>
<tr><td><code>periodic_bspline_basis</code></td>
<td>
<p> Returns a matrix with <code>length(x)</code> rows
and <code>nbasis</code> columns.  The basis functions returned are periodic with
period <code>period</code>.</p>
</td></tr>
</table>
<p>If <code>deriv&gt;0</code>, the derivative of that order of each of the corresponding spline basis functions are returned.
</p>


<h3>C API</h3>

<p>Access to the underlying C routines is available: see 
<a href="https://kingaa.github.io/pomp/C_API.html">the <span class="pkg">pomp</span> C API document</a>.
for definition and documentation of the C API.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>See Also</h3>

<p>More on interpolation:
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+lookup">lookup</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(0,2,by=0.01)
y &lt;- bspline_basis(x,degree=3,nbasis=9,names="basis")
matplot(x,y,type='l',ylim=c(0,1.1))
lines(x,apply(y,1,sum),lwd=2)

x &lt;- seq(-1,2,by=0.01)
y &lt;- periodic_bspline_basis(x,nbasis=5,names="spline%d")
matplot(x,y,type='l')

</code></pre>

<hr>
<h2 id='childhood_disease_data'>Historical childhood disease incidence data</h2><span id='topic+childhood_disease_data'></span><span id='topic+LondonYorke'></span><span id='topic+ewmeas'></span><span id='topic+ewcitmeas'></span>

<h3>Description</h3>

<p><code>LondonYorke</code> is a data frame containing the monthly number of reported cases of chickenpox, measles, and mumps from two American cities (Baltimore and New York) in the mid-20th century (1928&ndash;1972).
</p>
<p><code>ewmeas</code> and <code>ewcitmeas</code> are data frames containing weekly reported cases of measles in England and Wales.
<code>ewmeas</code> records the total measles reports for the whole country, 1948&ndash;1966.
One questionable data point has been replaced with an NA.
<code>ewcitmeas</code> records the incidence in seven English cities 1948&ndash;1987.
These data were kindly provided by Ben Bolker, who writes:
&ldquo;Most of these data have been manually entered from published records by various people, and are prone to errors at several levels.
All data are provided as is; use at your own risk.&rdquo;
</p>


<h3>References</h3>

<p>W. P. London and J. A. Yorke, Recurrent outbreaks of measles, chickenpox and mumps: I. Seasonal variation in contact rates. <em>American Journal of Epidemiology</em> <b>98</b>, 453&ndash;468, 1973.
</p>


<h3>See Also</h3>

<p><a href="#topic+compartmental_models">compartmental models</a>, <code><a href="#topic+bsflu">bsflu</a></code>
</p>
<p>More data sets provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+bsflu">bsflu</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+parus">parus</a></code>
</p>
<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+compartmental_models">compartmental_models</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+gompertz">gompertz</a>()</code>,
<code><a href="#topic+ou2">ou2</a>()</code>,
<code><a href="#topic+pomp_examples">pomp_examples</a></code>,
<code><a href="#topic+ricker">ricker</a>()</code>,
<code><a href="#topic+rw2">rw2</a>()</code>,
<code><a href="#topic+verhulst">verhulst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(cases~time,data=LondonYorke,subset=disease=="measles",type='n',main="measles",bty='l')
lines(cases~time,data=LondonYorke,subset=disease=="measles"&amp;town=="Baltimore",col="red")
lines(cases~time,data=LondonYorke,subset=disease=="measles"&amp;town=="New York",col="blue")
legend("topright",legend=c("Baltimore","New York"),lty=1,col=c("red","blue"),bty='n')

plot(
     cases~time,
     data=LondonYorke,
     subset=disease=="chickenpox"&amp;town=="New York",
     type='l',col="blue",main="chickenpox, New York",
     bty='l'
    )

plot(
     cases~time,
     data=LondonYorke,
     subset=disease=="mumps"&amp;town=="New York",
     type='l',col="blue",main="mumps, New York",
     bty='l'
    )

plot(reports~time,data=ewmeas,type='l')

plot(reports~date,data=ewcitmeas,subset=city=="Liverpool",type='l')

</code></pre>

<hr>
<h2 id='coef'>Extract, set, or alter coefficients</h2><span id='topic+coef'></span><span id='topic+coef+3C-'></span><span id='topic+coef+3C-+2Cmissing-method'></span><span id='topic+coef+2Clistie-method'></span><span id='topic+coef+2Cpomp-method'></span><span id='topic+coef+3C-+2Cpomp-method'></span><span id='topic+coef+2Cobjfun-method'></span><span id='topic+coef+3C-+2Cobjfun-method'></span>

<h3>Description</h3>

<p>Extract, set, or modify the estimated parameters from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'listie'
coef(object, ...)

## S4 method for signature 'pomp'
coef(object, pars, transform = FALSE, ...)

## S4 replacement method for signature 'pomp'
coef(object, pars, transform = FALSE, ...) &lt;- value

## S4 method for signature 'objfun'
coef(object, ...)

## S4 replacement method for signature 'objfun'
coef(object, pars, transform = FALSE, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class extending &lsquo;pomp&rsquo;</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>ignored or passed to the more primitive function</p>
</td></tr>
<tr><td><code id="coef_+3A_pars">pars</code></td>
<td>
<p>optional character; names of parameters to be retrieved or set.</p>
</td></tr>
<tr><td><code id="coef_+3A_transform">transform</code></td>
<td>
<p>logical; perform parameter transformation?</p>
</td></tr>
<tr><td><code id="coef_+3A_value">value</code></td>
<td>
<p>numeric vector or list; values to be assigned.
If <code>value = NULL</code>, the parameters are unset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coef</code> allows one to extract the parameters from a fitted model.
</p>
<p><code>coef(object,transform=TRUE)</code> returns the parameters transformed onto
the estimation scale.
</p>
<p><code>coef(object) &lt;- value</code> sets or alters the coefficients of a
&lsquo;pomp&rsquo; object.
</p>
<p><code>coef(object,transform=TRUE) &lt;- value</code> assumes that <code>value</code> is on
the estimation scale, and applies the &ldquo;from estimation scale&rdquo;
parameter transformation from <code>object</code> before altering the
coefficients.
</p>


<h3>See Also</h3>

<p>Other extraction methods: 
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='compartmental_models'>Compartmental epidemiological models</h2><span id='topic+compartmental_models'></span><span id='topic+SIR_models'></span><span id='topic+sir'></span><span id='topic+sir2'></span>

<h3>Description</h3>

<p>Simple SIR-type models implemented in various ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sir(
  gamma = 26,
  mu = 0.02,
  iota = 0.01,
  beta1 = 400,
  beta2 = 480,
  beta3 = 320,
  beta_sd = 0.001,
  rho = 0.6,
  k = 0.1,
  pop = 2100000,
  S_0 = 26/400,
  I_0 = 0.001,
  R_0 = 1 - S_0 - I_0,
  t0 = 0,
  times = seq(from = t0 + 1/52, to = t0 + 4, by = 1/52),
  seed = 329343545,
  delta.t = 1/52/20
)

sir2(
  gamma = 24,
  mu = 1/70,
  iota = 0.1,
  beta1 = 330,
  beta2 = 410,
  beta3 = 490,
  rho = 0.1,
  k = 0.1,
  pop = 1e+06,
  S_0 = 0.05,
  I_0 = 1e-04,
  R_0 = 1 - S_0 - I_0,
  t0 = 0,
  times = seq(from = t0 + 1/12, to = t0 + 10, by = 1/12),
  seed = 1772464524
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compartmental_models_+3A_gamma">gamma</code></td>
<td>
<p>recovery rate</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_mu">mu</code></td>
<td>
<p>death rate (assumed equal to the birth rate)</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_iota">iota</code></td>
<td>
<p>infection import rate</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_beta1">beta1</code>, <code id="compartmental_models_+3A_beta2">beta2</code>, <code id="compartmental_models_+3A_beta3">beta3</code></td>
<td>
<p>seasonal contact rates</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_beta_sd">beta_sd</code></td>
<td>
<p>environmental noise intensity</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_rho">rho</code></td>
<td>
<p>reporting efficiency</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_k">k</code></td>
<td>
<p>reporting overdispersion parameter (reciprocal of the negative-binomial <em>size</em> parameter)</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_pop">pop</code></td>
<td>
<p>overall host population size</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_s_0">S_0</code>, <code id="compartmental_models_+3A_i_0">I_0</code>, <code id="compartmental_models_+3A_r_0">R_0</code></td>
<td>
<p>the fractions of the host population that are susceptible, infectious, and recovered, respectively, at time zero.</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_t0">t0</code></td>
<td>
<p>zero time</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_times">times</code></td>
<td>
<p>observation times</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_seed">seed</code></td>
<td>
<p>seed of the random number generator</p>
</td></tr>
<tr><td><code id="compartmental_models_+3A_delta.t">delta.t</code></td>
<td>
<p>Euler step size</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sir()</code> producees a &lsquo;pomp&rsquo; object encoding a simple seasonal SIR model with simulated data.
Simulation is performed using an Euler multinomial approximation.
</p>
<p><code>sir2()</code> has the same model implemented using Gillespie's algorithm.
</p>
<p>In both cases the measurement model is negative binomial:
<code>reports</code> is distributed as a negative binomial random variable with mean equal to <code>rho*cases</code> and size equal to <code>1/k</code>.
</p>
<p>This and similar examples are discussed and constructed in tutorials
available on the <a href="https://kingaa.github.io/pomp/">package website</a>.
</p>


<h3>Value</h3>

<p>These functions return &lsquo;pomp&rsquo; objects containing simulated data.
</p>


<h3>See Also</h3>

<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+gompertz">gompertz</a>()</code>,
<code><a href="#topic+ou2">ou2</a>()</code>,
<code><a href="#topic+pomp_examples">pomp_examples</a></code>,
<code><a href="#topic+ricker">ricker</a>()</code>,
<code><a href="#topic+rw2">rw2</a>()</code>,
<code><a href="#topic+verhulst">verhulst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  po &lt;- sir()
  plot(po)
  coef(po)
  
  po &lt;- sir2()
  plot(po)
  plot(simulate(window(po,end=3)))
  coef(po)
  
  po |&gt; as.data.frame() |&gt; head()

</code></pre>

<hr>
<h2 id='conc'>Concatenate</h2><span id='topic+conc'></span><span id='topic+conc+2CPomp-method'></span><span id='topic+conc+2CPfilter-method'></span><span id='topic+conc+2CAbc-method'></span><span id='topic+conc+2CMif2-method'></span><span id='topic+conc+2CPmcmc-method'></span>

<h3>Description</h3>

<p>Internal methods to concatenate objects into useful listie.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Pomp'
conc(...)

## S4 method for signature 'Pfilter'
conc(...)

## S4 method for signature 'Abc'
conc(...)

## S4 method for signature 'Mif2'
conc(...)

## S4 method for signature 'Pmcmc'
conc(...)
</code></pre>


<h3>Details</h3>

<p>Not exported.
</p>

<hr>
<h2 id='concat'>Concatenate</h2><span id='topic+concat'></span><span id='topic+c'></span><span id='topic+c.Pomp'></span>

<h3>Description</h3>

<p>Concatenate two or more &lsquo;pomp&rsquo; objects into a list-like &lsquo;listie&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Pomp'
c(...)

concat(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concat_+3A_...">...</code></td>
<td>
<p>elements to be recursively combined into a &lsquo;listie&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>concat</code> applied to one or more &lsquo;pomp&rsquo; objects or lists of &lsquo;pomp&rsquo; objects converts the list into a &lsquo;listie&rsquo;.
In particular, <code>concat(A,B,C)</code> is equivalent to <code>do.call(c,unlist(list(A,B,C)))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gompertz(sigma=2,tau=1) -&gt; g
Np &lt;- c(low=100,med=1000,high=10000)
lapply(
  Np,
  \(np) pfilter(g,Np=np)
) |&gt;
  concat() -&gt; pfs

pfs
coef(pfs)
logLik(pfs)
eff_sample_size(pfs)
cond_logLik(pfs)

pfs |&gt; plot()
</code></pre>

<hr>
<h2 id='cond_logLik'>Conditional log likelihood</h2><span id='topic+cond_logLik'></span><span id='topic+cond_logLik+2Cmissing-method'></span><span id='topic+cond_logLik+2CANY-method'></span><span id='topic+cond_logLik+2Ckalmand_pomp-method'></span><span id='topic+cond_logLik+2Cpfilterd_pomp-method'></span><span id='topic+cond_logLik+2Cwpfilterd_pomp-method'></span><span id='topic+cond_logLik+2Cbsmcd_pomp-method'></span><span id='topic+cond_logLik+2CpfilterList-method'></span>

<h3>Description</h3>

<p>The estimated conditional log likelihood from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'kalmand_pomp'
cond_logLik(object, ..., format = c("numeric", "data.frame"))

## S4 method for signature 'pfilterd_pomp'
cond_logLik(object, ..., format = c("numeric", "data.frame"))

## S4 method for signature 'wpfilterd_pomp'
cond_logLik(object, ..., format = c("numeric", "data.frame"))

## S4 method for signature 'bsmcd_pomp'
cond_logLik(object, ..., format = c("numeric", "data.frame"))

## S4 method for signature 'pfilterList'
cond_logLik(object, ..., format = c("numeric", "data.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_logLik_+3A_object">object</code></td>
<td>
<p>result of a filtering computation</p>
</td></tr>
<tr><td><code id="cond_logLik_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="cond_logLik_+3A_format">format</code></td>
<td>
<p>format of the returned object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional likelihood is defined to be the value of the density
of </p>
<p style="text-align: center;"><code class="reqn">Y(t_k) | Y(t_1),\dots,Y(t_{k-1})</code>
</p>
<p> evaluated at <code class="reqn">Y(t_k) = y^*_k</code>.
Here, <code class="reqn">Y(t_k)</code> is the observable process, and <code class="reqn">y^*_k</code> the data, at time <code class="reqn">t_k</code>.
</p>
<p>Thus the conditional log likelihood at time <code class="reqn">t_k</code> is
</p>
<p style="text-align: center;"><code class="reqn">\ell_k(\theta) = \log f[Y(t_k)=y^*_k \vert Y(t_1)=y^*_1, \dots, Y(t_{k-1})=y^*_{k-1}],</code>
</p>

<p>where <code class="reqn">f</code> is the probability density above.
</p>


<h3>Value</h3>

<p>The numerical value of the conditional log likelihood.
Note that some methods compute not the log likelihood itself but instead a related quantity.
To keep the code simple, the <code>cond_logLik</code> function is nevertheless used to extract this quantity.
</p>
<p>When <code>object</code> is of class &lsquo;bsmcd_pomp&rsquo;
(i.e., the result of a <code>bsmc2</code> computation),
<code>cond_logLik</code> returns the conditional log &ldquo;evidence&rdquo;
(see <code><a href="#topic+bsmc2">bsmc2</a></code>).
</p>


<h3>See Also</h3>

<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='continue'>Continue an iterative calculation</h2><span id='topic+continue'></span><span id='topic+continue+2Cmissing-method'></span><span id='topic+continue+2CANY-method'></span><span id='topic+continue+2Cabcd_pomp-method'></span><span id='topic+continue+2Cpmcmcd_pomp-method'></span><span id='topic+continue+2Cmif2d_pomp-method'></span>

<h3>Description</h3>

<p>Continue an iterative computation where it left off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'abcd_pomp'
continue(object, Nabc = 1, ...)

## S4 method for signature 'pmcmcd_pomp'
continue(object, Nmcmc = 1, ...)

## S4 method for signature 'mif2d_pomp'
continue(object, Nmif = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continue_+3A_object">object</code></td>
<td>
<p>the result of an iterative <span class="pkg">pomp</span> computation</p>
</td></tr>
<tr><td><code id="continue_+3A_nabc">Nabc</code></td>
<td>
<p>positive integer; number of additional ABC iterations to perform</p>
</td></tr>
<tr><td><code id="continue_+3A_...">...</code></td>
<td>
<p>additional arguments will be passed to the underlying method.
This allows one to modify parameters used in the original computations.</p>
</td></tr>
<tr><td><code id="continue_+3A_nmcmc">Nmcmc</code></td>
<td>
<p>positive integer; number of additional PMCMC iterations to perform</p>
</td></tr>
<tr><td><code id="continue_+3A_nmif">Nmif</code></td>
<td>
<p>positive integer; number of additional filtering iterations to perform</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mif2">mif2</a></code> <code><a href="#topic+pmcmc">pmcmc</a></code> <code><a href="#topic+abc">abc</a></code>
</p>

<hr>
<h2 id='covariates'>Covariates</h2><span id='topic+covariates'></span><span id='topic+covariate_table'></span><span id='topic+covariate_table+2Cmissing-method'></span><span id='topic+covariate_table+2CANY-method'></span><span id='topic+covariate_table+2Cnumeric-method'></span><span id='topic+covariate_table+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Incorporating time-varying covariates using lookup tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
covariate_table(..., order = c("linear", "constant"), times)

## S4 method for signature 'character'
covariate_table(..., order = c("linear", "constant"), times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariates_+3A_...">...</code></td>
<td>
<p>numeric vectors or data frames containing time-varying covariates.
It must be possible to bind these into a data frame.</p>
</td></tr>
<tr><td><code id="covariates_+3A_order">order</code></td>
<td>
<p>the order of interpolation to be used.
Options are &ldquo;linear&rdquo; (the default) and &ldquo;constant&rdquo;.
Setting <code>order="linear"</code> treats the covariates as piecewise linear functions of time;
<code>order="constant"</code> treats them as right-continuous piecewise constant functions.</p>
</td></tr>
<tr><td><code id="covariates_+3A_times">times</code></td>
<td>
<p>the times corresponding to the covariates.
This may be given as a vector of (non-decreasing, finite) numerical values.
Alternatively, one can specify by name which of the given variables is the time variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the &lsquo;pomp&rsquo; object contains covariates (specified via the <code>covar</code> argument), then interpolated values of the covariates will be available to each of the model components whenever it is called.
In particular, variables with names as they appear in the <code>covar</code> covariate table will be available to any C snippet.
When a basic component is defined using an <span class="rlang"><b>R</b></span> function, that function will be called with an extra argument, <code>covars</code>, which will be a named numeric vector containing the interpolated values from the covariate table.
</p>
<p>An exception to this rule is the prior (<code>rprior</code> and <code>dprior</code>):
covariate-dependent priors are not allowed.
Nor are parameter transformations permitted to depend upon covariates.
</p>


<h3>See Also</h3>

<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>
<p>More on interpolation:
<code><a href="#topic+bsplines">bsplines</a></code>,
<code><a href="#topic+lookup">lookup</a>()</code>
</p>

<hr>
<h2 id='covmat'>Estimate a covariance matrix from algorithm traces</h2><span id='topic+covmat'></span><span id='topic+covmat+2Cmissing-method'></span><span id='topic+covmat+2CANY-method'></span><span id='topic+covmat+2Cpmcmcd_pomp-method'></span><span id='topic+covmat+2CpmcmcList-method'></span><span id='topic+covmat+2Cabcd_pomp-method'></span><span id='topic+covmat+2CabcList-method'></span><span id='topic+covmat+2Cprobed_pomp-method'></span>

<h3>Description</h3>

<p>A helper function to extract a covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pmcmcd_pomp'
covmat(object, start = 1, thin = 1, expand = 2.38, ...)

## S4 method for signature 'pmcmcList'
covmat(object, start = 1, thin = 1, expand = 2.38, ...)

## S4 method for signature 'abcd_pomp'
covmat(object, start = 1, thin = 1, expand = 2.38, ...)

## S4 method for signature 'abcList'
covmat(object, start = 1, thin = 1, expand = 2.38, ...)

## S4 method for signature 'probed_pomp'
covmat(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covmat_+3A_object">object</code></td>
<td>
<p>an object extending &lsquo;pomp&rsquo;</p>
</td></tr>
<tr><td><code id="covmat_+3A_start">start</code></td>
<td>
<p>the first iteration number to be used in estimating the covariance matrix.
Setting <code>thin &gt; 1</code> allows for a burn-in period.</p>
</td></tr>
<tr><td><code id="covmat_+3A_thin">thin</code></td>
<td>
<p>factor by which the chains are to be thinned</p>
</td></tr>
<tr><td><code id="covmat_+3A_expand">expand</code></td>
<td>
<p>the expansion factor</p>
</td></tr>
<tr><td><code id="covmat_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>object</code> is the result of a <code>pmcmc</code> or <code>abc</code> computation,
<code>covmat(object)</code> gives the covariance matrix of the chains.
This can be useful, for example, in tuning the proposal distribution.
</p>
<p>When <code>object</code> is a &lsquo;probed_pomp&rsquo; object (i.e., the result
of a <code>probe</code> computation), <code>covmat(object)</code> returns the
covariance matrix of the probes, as applied to simulated data.
</p>


<h3>See Also</h3>

<p><a href="#topic+proposals">MCMC proposals</a>.
</p>
<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='Csnippet'>C snippets</h2><span id='topic+Csnippet'></span>

<h3>Description</h3>

<p>Accelerating computations through inline snippets of C code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Csnippet(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Csnippet_+3A_text">text</code></td>
<td>
<p>character; text written in the C language</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">pomp</span> provides a facility whereby users can define their model's components using inline C code.
C snippets are written to a C file, by default located in the <span class="rlang"><b>R</b></span> session's temporary directory, which is then compiled (via <code><a href="utils.html#topic+SHLIB">R CMD SHLIB</a></code>) into a dynamically loadable shared object file.
This is then loaded as needed.
</p>


<h3>Note to Windows and Mac users</h3>

<p>By default, your <span class="rlang"><b>R</b></span> installation may not support <code><a href="utils.html#topic+SHLIB">R CMD SHLIB</a></code>.
The <a href="https://kingaa.github.io/pomp/install.html">package website contains installation instructions</a> that explain how to enable this powerful feature of <span class="rlang"><b>R</b></span>.
</p>


<h3>General rules for writing C snippets</h3>

<p>In writing a C snippet one must bear in mind both the <em>goal</em> of the snippet, i.e., what computation it is intended to perform, and the <em>context</em> in which it will be executed.
These are explained here in the form of general rules.
Additional specific rules apply according to the function of the particular C snippet.
Illustrative examples are given in the tutorials on the <a href="https://kingaa.github.io/pomp/">package website</a>.
</p>

<ol>
<li><p> C snippets must be valid C.
They will embedded verbatim in a template file which will then be compiled by a call to <code><a href="utils.html#topic+SHLIB">R CMD SHLIB</a></code>.
If the resulting file does not compile, an error message will be generated.
Compiler messages will be displayed, but no attempt will be made by <span class="pkg">pomp</span> to interpret them.
Typically, compilation errors are due to either invalid C syntax or undeclared variables.
</p>
</li>
<li><p> State variables, parameters, observables, and covariates must be left undeclared within the snippet.
State variables and parameters are declared via the <code>statenames</code> or <code>paramnames</code> arguments to <code>pomp</code>, respectively.
Compiler errors that complain about undeclared state variables or parameters are usually due to failure to declare these in <code>statenames</code> or <code>paramnames</code>, as appropriate.
</p>
</li>
<li><p> A C snippet can declare local variables.
Be careful not to use names that match those of state variables, observables, or parameters.
One must never declare state variables, observables, covariates, or parameters within a C snippet.
</p>
</li>
<li><p> Names of observables must match the names given given in the data.
They must be referred to in measurement model C snippets (<code>rmeasure</code> and <code>dmeasure</code>) by those names.
</p>
</li>
<li><p> If the &lsquo;pomp&rsquo; object contains a table of covariates (see above), then the variables in the covariate table will be available, by their names, in the context within which the C snippet is executed.
</p>
</li>
<li><p> Because the dot &lsquo;.&rsquo; has syntactic meaning in C, <span class="rlang"><b>R</b></span> variables with names containing dots (&lsquo;.&rsquo;) are replaced in the C codes by variable names in which all dots have been replaced by underscores (&lsquo;_&rsquo;).
</p>
</li>
<li><p> The headers &lsquo;<span class="file">R.h</span>&rsquo; and &lsquo;<span class="file">Rmath.h</span>&rsquo;, provided with <span class="rlang"><b>R</b></span>, will be included in the generated C file, making all of the <a href="https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html#The-R-API"><span class="rlang"><b>R</b></span> C API</a> available for use in the C snippet.
This makes a great many useful functions available, including all of <span class="rlang"><b>R</b></span>'s <a href="https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html#Distribution-functions">statistical distribution functions</a>.
</p>
</li>
<li><p> The header <a href="https://github.com/kingaa/pomp/blob/master/inst/include/pomp.h">&lsquo;<span class="file">pomp.h</span>&rsquo;</a>, provided with <span class="pkg">pomp</span>, will also be included, making all of the <a href="https://kingaa.github.io/pomp/C_API.html"><span class="pkg">pomp</span> C API</a> available for use in every C snippet.
</p>
</li>
<li><p> Snippets of C code passed to the <code>globals</code> argument of <code>pomp</code> will be included at the head of the generated C file.
This can be used to declare global variables, define useful functions, and include arbitrary header files.
</p>
</li></ol>



<h3>Linking to precompiled libraries</h3>

<p>It is straightforward to link C snippets with precompiled C libraries.
To do so, one must make sure the library's header files are included;
the <code>globals</code> argument can be used for this purpose.
The <code>shlib.args</code> argument can then be used to specify additional arguments to be passed to <code><a href="utils.html#topic+SHLIB">R CMD SHLIB</a></code>.
<a href="https://kingaa.github.io/pomp/FAQ.html#linking-C-libraries">FAQ 3.7</a> gives an example.
</p>


<h3>C snippets are salted</h3>

<p>To prevent collisions in parallel computations, a &lsquo;pomp&rsquo; object built using C snippets is &ldquo;salted&rdquo; with the current time and a random number.
A result is that two &lsquo;pomp&rsquo; objects, built on identical codes and data, will <strong>not</strong> be identical as <span class="rlang"><b>R</b></span> objects, though they will be functionally identical in every respect.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p>spy
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>

<hr>
<h2 id='dacca'>Model of cholera transmission for historic Bengal.</h2><span id='topic+dacca'></span>

<h3>Description</h3>

<p><code>dacca</code> constructs a &lsquo;pomp&rsquo; object containing census and cholera
mortality data from the Dacca district of the former British province of
Bengal over the years 1891 to 1940 together with a stochastic differential
equation transmission model.
The model is that of King et al. (2008).
The parameters are the MLE for the SIRS model with seasonal reservoir.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dacca(
  gamma = 20.8,
  eps = 19.1,
  rho = 0,
  delta = 0.02,
  deltaI = 0.06,
  clin = 1,
  alpha = 1,
  beta_trend = -0.00498,
  logbeta = c(0.747, 6.38, -3.44, 4.23, 3.33, 4.55),
  logomega = log(c(0.184, 0.0786, 0.0584, 0.00917, 0.000208, 0.0124)),
  sd_beta = 3.13,
  tau = 0.23,
  S_0 = 0.621,
  I_0 = 0.378,
  Y_0 = 0,
  R1_0 = 0.000843,
  R2_0 = 0.000972,
  R3_0 = 1.16e-07
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dacca_+3A_gamma">gamma</code></td>
<td>
<p>recovery rate</p>
</td></tr>
<tr><td><code id="dacca_+3A_eps">eps</code></td>
<td>
<p>rate of waning of immunity for severe infections</p>
</td></tr>
<tr><td><code id="dacca_+3A_rho">rho</code></td>
<td>
<p>rate of waning of immunity for inapparent infections</p>
</td></tr>
<tr><td><code id="dacca_+3A_delta">delta</code></td>
<td>
<p>baseline mortality rate</p>
</td></tr>
<tr><td><code id="dacca_+3A_deltai">deltaI</code></td>
<td>
<p>cholera mortality rate</p>
</td></tr>
<tr><td><code id="dacca_+3A_clin">clin</code></td>
<td>
<p>fraction of infections that lead to severe infection</p>
</td></tr>
<tr><td><code id="dacca_+3A_alpha">alpha</code></td>
<td>
<p>transmission function exponent</p>
</td></tr>
<tr><td><code id="dacca_+3A_beta_trend">beta_trend</code></td>
<td>
<p>slope of secular trend in transmission</p>
</td></tr>
<tr><td><code id="dacca_+3A_logbeta">logbeta</code></td>
<td>
<p>seasonal transmission rates</p>
</td></tr>
<tr><td><code id="dacca_+3A_logomega">logomega</code></td>
<td>
<p>seasonal environmental reservoir parameters</p>
</td></tr>
<tr><td><code id="dacca_+3A_sd_beta">sd_beta</code></td>
<td>
<p>environmental noise intensity</p>
</td></tr>
<tr><td><code id="dacca_+3A_tau">tau</code></td>
<td>
<p>measurement error s.d.</p>
</td></tr>
<tr><td><code id="dacca_+3A_s_0">S_0</code></td>
<td>
<p>initial susceptible fraction</p>
</td></tr>
<tr><td><code id="dacca_+3A_i_0">I_0</code></td>
<td>
<p>initial fraction of population infected</p>
</td></tr>
<tr><td><code id="dacca_+3A_y_0">Y_0</code></td>
<td>
<p>initial fraction of the population in the Y class</p>
</td></tr>
<tr><td><code id="dacca_+3A_r1_0">R1_0</code>, <code id="dacca_+3A_r2_0">R2_0</code>, <code id="dacca_+3A_r3_0">R3_0</code></td>
<td>
<p>initial fractions in the respective R classes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are provided courtesy of Dr. Menno J. Bouma, London School of Tropical
Medicine and Hygiene.
</p>


<h3>Value</h3>

<p><code>dacca</code> returns a &lsquo;pomp&rsquo; object containing the model, data, and MLE
parameters, as estimated by King et al. (2008).
</p>


<h3>References</h3>

<p>A.A. King, E.L. Ionides, M. Pascual, and M.J. Bouma. Inapparent infections and cholera dynamics. <em>Nature</em> <b>454</b>, 877-880, 2008
</p>


<h3>See Also</h3>

<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+compartmental_models">compartmental_models</a></code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+gompertz">gompertz</a>()</code>,
<code><a href="#topic+ou2">ou2</a>()</code>,
<code><a href="#topic+pomp_examples">pomp_examples</a></code>,
<code><a href="#topic+ricker">ricker</a>()</code>,
<code><a href="#topic+rw2">rw2</a>()</code>,
<code><a href="#topic+verhulst">verhulst</a>()</code>
</p>
<p>More data sets provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+bsflu">bsflu</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+parus">parus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # takes too long for R CMD check
  po &lt;- dacca()
  plot(po)
  ## MLE:
  coef(po)
  plot(simulate(po))

</code></pre>

<hr>
<h2 id='defunct'>Defunct functions</h2><span id='topic+defunct'></span><span id='topic+as.pomp'></span><span id='topic+bspline.basis'></span><span id='topic+cond.logLik'></span><span id='topic+eff.sample.size'></span><span id='topic+mvn.diag.rw'></span><span id='topic+mvn.rw'></span><span id='topic+mvn.rw.adaptive'></span><span id='topic+periodic.bspline.basis'></span><span id='topic+pred.mean'></span><span id='topic+pred.var'></span><span id='topic+probe.acf'></span><span id='topic+probe.ccf'></span><span id='topic+probe.marginal'></span><span id='topic+probe.mean'></span><span id='topic+probe.median'></span><span id='topic+probe.nlar'></span><span id='topic+probe.period'></span><span id='topic+probe.quantile'></span><span id='topic+probe.sd'></span><span id='topic+probe.var'></span><span id='topic+rw.sd'></span><span id='topic+saved.states'></span>

<h3>Description</h3>

<p>These functions are defunct and will be expunged in a future release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.pomp(...)

bspline.basis(...)

cond.logLik(...)

eff.sample.size(...)

mvn.diag.rw(...)

mvn.rw(...)

mvn.rw.adaptive(...)

periodic.bspline.basis(...)

pred.mean(...)

pred.var(...)

probe.acf(...)

probe.ccf(...)

probe.marginal(...)

probe.mean(...)

probe.median(...)

probe.nlar(...)

probe.period(...)

probe.quantile(...)

probe.sd(...)

probe.var(...)

rw.sd(...)

saved.states(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defunct_+3A_...">...</code></td>
<td>
<p>all arguments are ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='design'>Design matrices for pomp calculations</h2><span id='topic+design'></span><span id='topic+profile_design'></span><span id='topic+runif_design'></span><span id='topic+slice_design'></span><span id='topic+sobol_design'></span>

<h3>Description</h3>

<p>These functions are useful for generating designs for the exploration of parameter space.
</p>
<p><code>profile_design</code> generates a data-frame where each row can be used as the starting point for a profile likelihood calculation.
</p>
<p><code>runif_design</code> generates a design based on random samples from a multivariate uniform distribution.
</p>
<p><code>slice_design</code> generates points along slices through a specified point.
</p>
<p><code>sobol_design</code> generates a Latin hypercube design based on the Sobol' low-discrepancy sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile_design(
  ...,
  lower,
  upper,
  nprof,
  type = c("runif", "sobol"),
  stringsAsFactors = getOption("stringsAsFactors", FALSE)
)

runif_design(lower = numeric(0), upper = numeric(0), nseq)

slice_design(center, ...)

sobol_design(lower = numeric(0), upper = numeric(0), nseq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_+3A_...">...</code></td>
<td>
<p>In <code>profile_design</code>, additional arguments specify the parameters over which to profile and the values of these parameters.
In <code>slice_design</code>, additional numeric vector arguments specify the locations of points along the slices.</p>
</td></tr>
<tr><td><code id="design_+3A_lower">lower</code>, <code id="design_+3A_upper">upper</code></td>
<td>
<p>named numeric vectors giving the lower and upper bounds
of the ranges, respectively.</p>
</td></tr>
<tr><td><code id="design_+3A_nprof">nprof</code></td>
<td>
<p>The number of points per profile point.</p>
</td></tr>
<tr><td><code id="design_+3A_type">type</code></td>
<td>
<p>the type of design to use.
<code>type="runif"</code> uses <code><a href="#topic+runif_design">runif_design</a></code>.
<code>type="sobol"</code> uses <code><a href="#topic+sobol_design">sobol_design</a></code>;</p>
</td></tr>
<tr><td><code id="design_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>should character vectors be converted to factors?</p>
</td></tr>
<tr><td><code id="design_+3A_nseq">nseq</code></td>
<td>
<p>Total number of points requested.</p>
</td></tr>
<tr><td><code id="design_+3A_center">center</code></td>
<td>
<p><code>center</code> is a named numeric vector specifying the point
through which the slice(s) is (are) to be taken.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Sobol' sequence generation is performed using codes from the <span class="pkg">NLopt</span> library by S. Johnson.
</p>


<h3>Value</h3>

<p><code>profile_design</code> returns a data frame with <code>nprof</code> points per profile point.
</p>
<p><code>runif_design</code> returns a data frame with <code>nseq</code> rows and one column for each variable named in <code>lower</code> and <code>upper</code>.
</p>
<p><code>slice_design</code> returns a data frame with one row per point.
The &lsquo;slice&rsquo; variable indicates which slice the point belongs to.
</p>
<p><code>sobol_design</code> returns a data frame with <code>nseq</code> rows and one column for each variable named in <code>lower</code> and <code>upper</code>.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>S. Kucherenko and Y. Sytsko. Application of deterministic low-discrepancy sequences in global optimization. <em>Computational Optimization and Applications</em> <b>30</b>, 297&ndash;318, 2005. <a href="https://doi.org/10.1007/s10589-005-4615-1">doi:10.1007/s10589-005-4615-1</a>.
</p>
<p>S.G. Johnson. The <span class="pkg">NLopt</span> nonlinear-optimization package. <a href="https://github.com/stevengj/nlopt/">https://github.com/stevengj/nlopt/</a>.
</p>
<p>P. Bratley and B.L. Fox. Algorithm 659 Implementing Sobol's quasirandom sequence generator. <em>ACM Transactions on Mathematical Software</em> <b>14</b>, 88&ndash;100, 1988.
</p>
<p>S. Joe and F.Y. Kuo. Remark on algorithm 659: Implementing Sobol' quasirandom sequence generator. <em>ACM Transactions on Mathematical Software</em> <b>29</b>, 49&ndash;57, 2003.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sobol' low-discrepancy design
plot(sobol_design(lower=c(a=0,b=100),upper=c(b=200,a=1),nseq=100))

## Uniform random design
plot(runif_design(lower=c(a=0,b=100),upper=c(b=200,a=1),100))

## A one-parameter profile design:
x &lt;- profile_design(p=1:10,lower=c(a=0,b=0),upper=c(a=1,b=5),nprof=20)
dim(x)
plot(x)

## A two-parameter profile design:
x &lt;- profile_design(p=1:10,q=3:5,lower=c(a=0,b=0),upper=c(b=5,a=1),nprof=200)
dim(x)
plot(x)

## A two-parameter profile design with random points:
x &lt;- profile_design(p=1:10,q=3:5,lower=c(a=0,b=0),upper=c(b=5,a=1),nprof=200,type="runif")
dim(x)
plot(x)

## A single 11-point slice through the point c(A=3,B=8,C=0) along the B direction.
x &lt;- slice_design(center=c(A=3,B=8,C=0),B=seq(0,10,by=1))
dim(x)
plot(x)

## Two slices through the same point along the A and C directions.
x &lt;- slice_design(c(A=3,B=8,C=0),A=seq(0,5,by=1),C=seq(0,5,length=11))
dim(x)
plot(x)

</code></pre>

<hr>
<h2 id='dinit'>dinit workhorse</h2><span id='topic+dinit'></span><span id='topic+dinit+2CANY-method'></span><span id='topic+dinit+2Cmissing-method'></span><span id='topic+dinit+2Cpomp-method'></span>

<h3>Description</h3>

<p>Evaluates the initial-state density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
dinit(
  object,
  params = coef(object),
  t0 = timezero(object),
  x,
  log = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dinit_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="dinit_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="dinit_+3A_t0">t0</code></td>
<td>
<p>the initial time, i.e., the time corresponding to the initial-state distribution.</p>
</td></tr>
<tr><td><code id="dinit_+3A_x">x</code></td>
<td>
<p>an array containing states of the unobserved process.
The dimensions of <code>x</code> are <code>nvars</code> x <code>nrep</code> x <code>ntimes</code>,
where <code>nvars</code> is the number of state variables,
<code>nrep</code> is the number of replicates,
and <code>ntimes</code> is the length of <code>times</code>.
One can also pass <code>x</code> as a named numeric vector, which is equivalent to the <code>nrep=1</code>, <code>ntimes=1</code> case.</p>
</td></tr>
<tr><td><code id="dinit_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are returned.</p>
</td></tr>
<tr><td><code id="dinit_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dinit</code> returns a 1-D numerical array containing the likelihoods (or log likelihoods if <code>log=TRUE</code>).
By default, <code>t0</code> is the initial time defined when the &lsquo;pomp&rsquo; object ws constructed.
</p>


<h3>See Also</h3>

<p>Specification of the initial-state distribution: <a href="#topic+dinit_spec">dinit_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>

<hr>
<h2 id='dinit_spec'>dinit specification</h2><span id='topic+dinit_spec'></span>

<h3>Description</h3>

<p>Specification of the initial-state distribution density evaluator, dinit.
</p>


<h3>Details</h3>

<p>To fully specify the unobserved Markov state process, one must give its distribution at the zero-time (<code>t0</code>).
One specifies how to evaluate the log probability density function for this distribution using the <code>dinit</code> argument.
As usual, this can be provided either as a C snippet or as an <span class="rlang"><b>R</b></span> function.
In the former case, bear in mind that:
</p>

<ol>
<li><p> The goal of a this snippet is computation of a log likelihood, to be put into a variable named <code>loglik</code>.
</p>
</li>
<li><p> In addition to the state variables, parameters, and covariates (if any), the variable <code>t</code>, containing the zero-time, will be defined in the context in which the snippet is executed.
</p>
</li></ol>

<p><a href="#topic+Csnippet">General rules for writing C snippets can be found here</a>.
</p>
<p>If an <span class="rlang"><b>R</b></span> function is to be used, pass
</p>
<pre>
   dinit = f
</pre>
<p>to <code>pomp</code>, where <code>f</code> is a function with arguments that can include the time <code>t</code>, any or all of the model state variables, parameters, and covariates.
As usual, <code>f</code> may take additional arguments, provided these are passed along with it in the call to <code>pomp</code>.
<code>f</code> must return a single numeric value, the log likelihood.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dinit">dinit</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>

<hr>
<h2 id='dmeasure'>dmeasure workhorse</h2><span id='topic+dmeasure'></span><span id='topic+dmeasure+2CANY-method'></span><span id='topic+dmeasure+2Cmissing-method'></span><span id='topic+dmeasure+2Cpomp-method'></span>

<h3>Description</h3>

<p><code>dmeasure</code> evaluates the probability density of observations given states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
dmeasure(
  object,
  y = obs(object),
  x = states(object),
  times = time(object),
  params = coef(object),
  ...,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmeasure_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="dmeasure_+3A_y">y</code></td>
<td>
<p>a matrix containing observations.
The dimensions of <code>y</code> are <code>nobs</code> x <code>ntimes</code>, where <code>nobs</code> is the number of observables
and <code>ntimes</code> is the length of <code>times</code>.</p>
</td></tr>
<tr><td><code id="dmeasure_+3A_x">x</code></td>
<td>
<p>an array containing states of the unobserved process.
The dimensions of <code>x</code> are <code>nvars</code> x <code>nrep</code> x <code>ntimes</code>,
where <code>nvars</code> is the number of state variables,
<code>nrep</code> is the number of replicates,
and <code>ntimes</code> is the length of <code>times</code>.
One can also pass <code>x</code> as a named numeric vector, which is equivalent to the <code>nrep=1</code>, <code>ntimes=1</code> case.</p>
</td></tr>
<tr><td><code id="dmeasure_+3A_times">times</code></td>
<td>
<p>a numeric vector (length <code>ntimes</code>) containing times.
These must be in non-decreasing order.</p>
</td></tr>
<tr><td><code id="dmeasure_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="dmeasure_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
<tr><td><code id="dmeasure_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dmeasure</code> returns a matrix of dimensions <code>nreps</code> x <code>ntimes</code>.
If <code>d</code> is the returned matrix, <code>d[j,k]</code> is the likelihood (or log likelihood if <code>log = TRUE</code>) of the observation <code>y[,k]</code> at time <code>times[k]</code> given the state <code>x[,j,k]</code>.
</p>


<h3>See Also</h3>

<p>Specification of the measurement density evaluator: <a href="#topic+dmeasure_spec">dmeasure_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>

<hr>
<h2 id='dmeasure_spec'>dmeasure specification</h2><span id='topic+dmeasure_spec'></span>

<h3>Description</h3>

<p>Specification of the measurement model density function, dmeasure.
</p>


<h3>Details</h3>

<p>The measurement model is the link between the data and the unobserved state process.
It can be specified either by using one or both of the <code>rmeasure</code> and <code>dmeasure</code> arguments.
</p>
<p>Suppose you have a procedure to compute the probability density of an observation given the value of the latent state variables.
Then you can furnish </p>
<pre>
   dmeasure = f</pre>
<p>to <span class="pkg">pomp</span> algorithms,
where <code>f</code> is a C snippet or <span class="rlang"><b>R</b></span> function that implements your procedure.
</p>
<p>Using a C snippet is much preferred, due to its much greater computational efficiency.
See <code><a href="#topic+Csnippet">Csnippet</a></code> for general rules on writing C snippets.
The goal of a <dfn>dmeasure</dfn> C snippet is to fill the variable <code>lik</code> with the either the probability density or the log probability density, depending on the value of the variable <code>give_log</code>.
</p>
<p>In writing a <code>dmeasure</code> C snippet, observe that:
</p>

<ol>
<li><p> In addition to the states, parameters, covariates (if any), and observables, the variable <code>t</code>, containing the time of the observation will be defined in the context in which the snippet is executed.
</p>
</li>
<li><p> Moreover, the Boolean variable <code>give_log</code> will be defined.
</p>
</li>
<li><p> The goal of a dmeasure C snippet is to set the value of the <code>lik</code> variable to the likelihood of the data given the state, if <code>give_log == 0</code>.
If <code>give_log == 1</code>, <code>lik</code> should be set to the log likelihood.
</p>
</li></ol>

<p>If <code>dmeasure</code> is to be provided instead as an <span class="rlang"><b>R</b></span> function, this is accomplished by supplying </p>
<pre>
  dmeasure = f</pre>
<p>to <code>pomp</code>, where <code>f</code> is a function.
The arguments of <code>f</code> should be chosen from among the observables, state variables, parameters, covariates, and time.
It must also have the arguments <code>...</code>, and <code>log</code>.
It can take additional arguments via the <a href="#topic+userdata">userdata facility</a>.
<code>f</code> must return a single numeric value, the probability density (or log probability density if <code>log = TRUE</code>) of <code>y</code> given <code>x</code> at time <code>t</code>.
</p>


<h3>Important note</h3>

<p><strong>It is a common error to fail to account for both <code>log = TRUE</code> and <code>log = FALSE</code> when writing the <code>dmeasure</code> C snippet or function.</strong>
</p>


<h3>Default behavior</h3>

<p>If <code>dmeasure</code> is left unspecified, calls to <code><a href="#topic+dmeasure">dmeasure</a></code> will return missing values (<code>NA</code>).
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmeasure">dmeasure</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## We start with the pre-built Ricker example:
  ricker() -&gt; po

  ## To change the measurement model density, dmeasure,
  ## we use the 'dmeasure' argument in any 'pomp'
  ## elementary or estimation function.
  ## Here, we pass the dmeasure specification to 'pfilter'
  ## as an R function.

  po |&gt;
    pfilter(
      dmeasure=function (y, N, phi, ..., log) {
        dpois(y,lambda=phi*N,log=log)
      },
      Np=100
    ) -&gt; pf

  ## We can also pass it as a C snippet:

  po |&gt;
    pfilter(
      dmeasure=Csnippet("lik = dpois(y,phi*N,give_log);"),
      paramnames="phi",
      statenames="N",
      Np=100
    ) -&gt; pf


</code></pre>

<hr>
<h2 id='dprior'>dprior workhorse</h2><span id='topic+dprior'></span><span id='topic+dprior+2CANY-method'></span><span id='topic+dprior+2Cmissing-method'></span><span id='topic+dprior+2Cpomp-method'></span>

<h3>Description</h3>

<p>Evaluates the prior probability density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
dprior(object, params = coef(object), ..., log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dprior_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="dprior_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="dprior_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
<tr><td><code id="dprior_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The required density (or log density), as a numeric vector.
</p>


<h3>See Also</h3>

<p>Specification of the prior density evaluator: <a href="#topic+prior_spec">prior_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>
<p>More on Bayesian methods:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rprior">rprior</a>()</code>
</p>

<hr>
<h2 id='dprocess'>dprocess workhorse</h2><span id='topic+dprocess'></span><span id='topic+dprocess+2CANY-method'></span><span id='topic+dprocess+2Cmissing-method'></span><span id='topic+dprocess+2Cpomp-method'></span>

<h3>Description</h3>

<p>Evaluates the probability density of a sequence of consecutive state transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
dprocess(
  object,
  x = states(object),
  times = time(object),
  params = coef(object),
  ...,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dprocess_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="dprocess_+3A_x">x</code></td>
<td>
<p>an array containing states of the unobserved process.
The dimensions of <code>x</code> are <code>nvars</code> x <code>nrep</code> x <code>ntimes</code>,
where <code>nvars</code> is the number of state variables,
<code>nrep</code> is the number of replicates,
and <code>ntimes</code> is the length of <code>times</code>.
One can also pass <code>x</code> as a named numeric vector, which is equivalent to the <code>nrep=1</code>, <code>ntimes=1</code> case.</p>
</td></tr>
<tr><td><code id="dprocess_+3A_times">times</code></td>
<td>
<p>a numeric vector (length <code>ntimes</code>) containing times.
These must be in non-decreasing order.</p>
</td></tr>
<tr><td><code id="dprocess_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="dprocess_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
<tr><td><code id="dprocess_+3A_log">log</code></td>
<td>
<p>if TRUE, log probabilities are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dprocess</code> returns a matrix of dimensions <code>nrep</code> x <code>ntimes-1</code>.
If <code>d</code> is the returned matrix, <code>d[j,k]</code> is the likelihood (or the log likelihood if <code>log=TRUE</code>) of the transition from state <code>x[,j,k-1]</code> at time <code>times[k-1]</code> to state <code>x[,j,k]</code> at time <code>times[k]</code>.
</p>


<h3>See Also</h3>

<p>Specification of the process-model density evaluator: <a href="#topic+dprocess_spec">dprocess_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>

<hr>
<h2 id='dprocess_spec'>dprocess specification</h2><span id='topic+dprocess_spec'></span>

<h3>Description</h3>

<p>Specification of the latent state process density function, dprocess.
</p>


<h3>Details</h3>

<p>Suppose you have a procedure that allows you to compute the probability density
of an arbitrary transition from state <code class="reqn">x_1</code> at time <code class="reqn">t_1</code>
to state <code class="reqn">x_2</code> at time <code class="reqn">t_2&gt;t_1</code>
under the assumption that the state remains unchanged
between <code class="reqn">t_1</code> and <code class="reqn">t_2</code>.
Then you can furnish
</p>
<pre>
    dprocess = f
</pre>
<p>to <code>pomp</code>, where <code>f</code> is a C snippet or <span class="rlang"><b>R</b></span> function that implements your procedure.
Specifically, <code>f</code> should compute the <em>log</em> probability density.
</p>
<p>Using a C snippet is much preferred, due to its much greater computational efficiency.
See <code><a href="#topic+Csnippet">Csnippet</a></code> for general rules on writing C snippets.
The goal of a <dfn>dprocess</dfn> C snippet is to fill the variable <code>loglik</code> with the log probability density.
In the context of such a C snippet, the parameters, and covariates will be defined, as will the times <code>t_1</code> and <code>t_2</code>.
The state variables at time <code>t_1</code> will have their usual name (see <code>statenames</code>) with a &ldquo;<code>_1</code>&rdquo; appended.
Likewise, the state variables at time <code>t_2</code> will have a &ldquo;<code>_2</code>&rdquo; appended.
</p>
<p>If <code>f</code> is given as an <span class="rlang"><b>R</b></span> function, it should take as arguments any or all of the state variables, parameter, covariates, and time.
The state-variable and time arguments will have suffices &ldquo;<code>_1</code>&rdquo; and &ldquo;<code>_2</code>&rdquo; appended.
Thus for example, if <code>var</code> is a state variable, when <code>f</code> is called, <code>var_1</code> will value of state variable <code>var</code> at time <code>t_1</code>, <code>var_2</code> will have the value of <code>var</code> at time <code>t_2</code>.
<code>f</code> should return the <em>log</em> likelihood of a transition from <code>x1</code> at time <code>t1</code> to <code>x2</code> at time <code>t2</code>,
assuming that no intervening transitions have occurred.
</p>
<p>To see examples, consult the demos and the tutorials on the <a href="https://kingaa.github.io/pomp/">package website</a>.
</p>


<h3><strong>Note</strong></h3>

<p>It is not typically necessary (or even feasible) to define <code>dprocess</code>.
In fact, no current <span class="pkg">pomp</span> inference algorithm makes use of <code>dprocess</code>.
This functionality is provided only to support future algorithm development.
</p>


<h3>Default behavior</h3>

<p>By default, <code>dprocess</code> returns missing values (<code>NA</code>).
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dprocess">dprocess</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>

<hr>
<h2 id='ebola'>Ebola outbreak, West Africa, 2014-2016</h2><span id='topic+ebola'></span><span id='topic+ebolaWA2014'></span><span id='topic+ebolaModel'></span>

<h3>Description</h3>

<p>Data and models for the 2014&ndash;2016 outbreak of Ebola virus disease in West Africa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebolaModel(
  country = c("GIN", "LBR", "SLE"),
  data = NULL,
  timestep = 1/8,
  nstageE = 3L,
  R0 = 1.4,
  rho = 0.2,
  cfr = 0.7,
  k = 0,
  index_case = 10,
  incubation_period = 11.4,
  infectious_period = 7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebola_+3A_country">country</code></td>
<td>
<p>ISO symbol for the country (GIN=Guinea, LBR=Liberia, SLE=Sierra Leone).</p>
</td></tr>
<tr><td><code id="ebola_+3A_data">data</code></td>
<td>
<p>if NULL, the situation report data (WHO Ebola Response Team 2014) for the appropriate country or region will be used.
Providing a dataset here will override this behavior.</p>
</td></tr>
<tr><td><code id="ebola_+3A_timestep">timestep</code></td>
<td>
<p>duration (in days) of Euler timestep for the simulations.</p>
</td></tr>
<tr><td><code id="ebola_+3A_nstagee">nstageE</code></td>
<td>
<p>integer; number of incubation stages.</p>
</td></tr>
<tr><td><code id="ebola_+3A_r0">R0</code></td>
<td>
<p>basic reproduction ratio</p>
</td></tr>
<tr><td><code id="ebola_+3A_rho">rho</code></td>
<td>
<p>case reporting efficiency</p>
</td></tr>
<tr><td><code id="ebola_+3A_cfr">cfr</code></td>
<td>
<p>case fatality rate</p>
</td></tr>
<tr><td><code id="ebola_+3A_k">k</code></td>
<td>
<p>dispersion parameter (negative binomial <code>size</code> parameter)</p>
</td></tr>
<tr><td><code id="ebola_+3A_index_case">index_case</code></td>
<td>
<p>number of cases on day 0 (2014-04-01)</p>
</td></tr>
<tr><td><code id="ebola_+3A_incubation_period">incubation_period</code>, <code id="ebola_+3A_infectious_period">infectious_period</code></td>
<td>
<p>mean duration (in days) of the incubation and infectious periods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data include monthly case counts and death reports derived from WHO situation reports, as reported by the U.S. CDC.
The models are described in King et al. (2015).
</p>
<p>The data-cleaning script is included in the R source code file &lsquo;<span class="file">ebola.R</span>&rsquo;.
</p>


<h3>Model structure</h3>

<p>The default incubation period is supposed to be Gamma distributed with shape parameter <code>nstageE</code> and mean 11.4 days and the case-fatality ratio ('cfr') is taken to be 0.7 (cf. WHO Ebola Response Team 2014).
The discrete-time formula is used to calculate the corresponding <code>alpha</code> (cf. He et al. 2010).
</p>
<p>The observation model is a hierarchical model for cases and deaths:
</p>
<p style="text-align: center;"><code class="reqn">p(R_t, D_t| C_t) = p(R_t | C_t) p(D_t | C_t, R_t).</code>
</p>

<p>Here, <code class="reqn">p(R_t | C_t)</code> is negative binomial with mean <code class="reqn">\rho C_t</code> and dispersion parameter <code class="reqn">1/k</code>;
<code class="reqn">p(D_t | C_t, R_t)</code> is binomial with size <code class="reqn">R_t</code> and probability equal to the case fatality rate <code>cfr</code>.
</p>


<h3>References</h3>

<p>A.A. King, M. Domenech de Cellès, F.M.G. Magpantay, and P. Rohani. Avoidable errors in the modelling of outbreaks of emerging pathogens, with special reference to Ebola. <em>Proceedings of the Royal Society of London, Series B</em> <b>282</b>, 20150347, 2015.
</p>
<p>WHO Ebola Response Team. Ebola virus disease in West Africa&mdash;the first 9 months of the epidemic and forward projections. <em>New England Journal of Medicine</em> <b>371</b>, 1481&ndash;1495, 2014.
</p>
<p>D. He, E.L. Ionides, and A.A. King. Plug-and-play inference for disease dynamics: measles in large and small populations as a case study.  <em>Journal of the Royal Society Interface</em> <b>7</b>, 271&ndash;283, 2010.
</p>


<h3>See Also</h3>

<p>More data sets provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+bsflu">bsflu</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+parus">parus</a></code>
</p>
<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+compartmental_models">compartmental_models</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+gompertz">gompertz</a>()</code>,
<code><a href="#topic+ou2">ou2</a>()</code>,
<code><a href="#topic+pomp_examples">pomp_examples</a></code>,
<code><a href="#topic+ricker">ricker</a>()</code>,
<code><a href="#topic+rw2">rw2</a>()</code>,
<code><a href="#topic+verhulst">verhulst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # takes too long for R CMD check
  if (require(ggplot2) &amp;&amp; require(tidyr)) {
    
    ebolaWA2014 |&gt;
      pivot_longer(c(cases,deaths)) |&gt;
      ggplot(aes(x=date,y=value,group=name,color=name))+
      geom_line()+
      facet_grid(country~.,scales="free_y")+
      theme_bw()+
      theme(axis.text=element_text(angle=-90))
    
  }
  
  plot(ebolaModel(country="SLE"))
  plot(ebolaModel(country="GIN"))
  plot(ebolaModel(country="LBR"))

</code></pre>

<hr>
<h2 id='eff_sample_size'>Effective sample size</h2><span id='topic+eff_sample_size'></span><span id='topic+eff_sample_size+2Cmissing-method'></span><span id='topic+eff_sample_size+2CANY-method'></span><span id='topic+eff_sample_size+2Cbsmcd_pomp-method'></span><span id='topic+eff_sample_size+2Cpfilterd_pomp-method'></span><span id='topic+eff_sample_size+2Cwpfilterd_pomp-method'></span><span id='topic+eff_sample_size+2CpfilterList-method'></span>

<h3>Description</h3>

<p>Estimate the effective sample size of a Monte Carlo computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'bsmcd_pomp'
eff_sample_size(object, ..., format = c("numeric", "data.frame"))

## S4 method for signature 'pfilterd_pomp'
eff_sample_size(object, ..., format = c("numeric", "data.frame"))

## S4 method for signature 'wpfilterd_pomp'
eff_sample_size(object, ..., format = c("numeric", "data.frame"))

## S4 method for signature 'pfilterList'
eff_sample_size(object, ..., format = c("numeric", "data.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff_sample_size_+3A_object">object</code></td>
<td>
<p>result of a filtering computation</p>
</td></tr>
<tr><td><code id="eff_sample_size_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="eff_sample_size_+3A_format">format</code></td>
<td>
<p>format of the returned object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Effective sample size is computed as
</p>
<p style="text-align: center;"><code class="reqn">\left(\sum_i\!w_{it}^2\right)^{-1},</code>
</p>

<p>where <code class="reqn">w_{it}</code> is the normalized weight of particle <code class="reqn">i</code> at time <code class="reqn">t</code>.
</p>


<h3>See Also</h3>

<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='elementary_algorithms'>Elementary computations on POMP models.</h2><span id='topic+elementary_algorithms'></span>

<h3>Description</h3>

<p>In <span class="pkg">pomp</span>, elementary algorithms perform POMP model operations.
These operations do not themselves estimate parameters, though they may be instrumental in inference methods.
</p>


<h3>Details</h3>

<p>There are six elementary algorithms in <span class="pkg">pomp</span>:
</p>

<ul>
<li> <p><code><a href="#topic+simulate">simulate</a></code> which simulates from the joint distribution of latent and observed variables,
</p>
</li>
<li> <p><code><a href="#topic+pfilter">pfilter</a></code>, which performs a simple particle filter operation,
</p>
</li>
<li> <p><code><a href="#topic+wpfilter">wpfilter</a></code>, which performs a weighted particle filter operation,
</p>
</li>
<li> <p><code><a href="#topic+probe">probe</a></code>, which computes a suite of user-specified summary statistics on actual and simulated data,
</p>
</li>
<li> <p><code><a href="#topic+spect">spect</a></code>, which performs a power-spectral density function computation on actual and simulated data,
</p>
</li>
<li> <p><code><a href="#topic+trajectory">trajectory</a></code>, which iterates or integrates the deterministic skeleton according to whether the latter is a (discrete-time) map or a (continuous-time) vectorfield.
</p>
</li></ul>

<p>Help pages detailing each elementary algorithm component are provided.
</p>


<h3>See Also</h3>

<p><a href="#topic+basic_components">basic model components</a>,
<a href="#topic+workhorses">workhorse functions</a>,
<a href="#topic+estimation_algorithms">estimation algorithms</a>.
</p>
<p>More on <span class="pkg">pomp</span> elementary algorithms: 
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>

<hr>
<h2 id='emeasure'>emeasure workhorse</h2><span id='topic+emeasure'></span><span id='topic+emeasure+2CANY-method'></span><span id='topic+emeasure+2Cmissing-method'></span><span id='topic+emeasure+2Cpomp-method'></span>

<h3>Description</h3>

<p>Return the expected value of the observed variables, given values of the latent states and the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
emeasure(
  object,
  x = states(object),
  times = time(object),
  params = coef(object),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emeasure_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="emeasure_+3A_x">x</code></td>
<td>
<p>an array containing states of the unobserved process.
The dimensions of <code>x</code> are <code>nvars</code> x <code>nrep</code> x <code>ntimes</code>,
where <code>nvars</code> is the number of state variables,
<code>nrep</code> is the number of replicates,
and <code>ntimes</code> is the length of <code>times</code>.
One can also pass <code>x</code> as a named numeric vector, which is equivalent to the <code>nrep=1</code>, <code>ntimes=1</code> case.</p>
</td></tr>
<tr><td><code id="emeasure_+3A_times">times</code></td>
<td>
<p>a numeric vector (length <code>ntimes</code>) containing times.
These must be in non-decreasing order.</p>
</td></tr>
<tr><td><code id="emeasure_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="emeasure_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>emeasure</code> returns a rank-3 array of dimensions
<code>nobs</code> x <code>nrep</code> x <code>ntimes</code>,
where <code>nobs</code> is the number of observed variables.
</p>


<h3>See Also</h3>

<p>Specification of the measurement-model expectation: <a href="#topic+emeasure_spec">emeasure_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>

<hr>
<h2 id='emeasure_spec'>emeasure specification</h2><span id='topic+emeasure_spec'></span>

<h3>Description</h3>

<p>Specification of the measurement-model conditional expectation, emeasure.
</p>


<h3>Details</h3>

<p>The measurement model is the link between the data and the unobserved state process.
Some algorithms require the conditional expectation of the measurement model, given the latent state and parameters.
This is supplied using the <code>emeasure</code> argument.
</p>
<p>Suppose you have a procedure to compute this conditional expectation, given the value of the latent state variables.
Then you can furnish </p>
<pre>
  emeasure = f</pre>
<p>to <span class="pkg">pomp</span> algorithms,
where <code>f</code> is a C snippet or <span class="rlang"><b>R</b></span> function that implements your procedure.
</p>
<p>Using a C snippet is much preferred, due to its much greater computational efficiency.
See <code><a href="#topic+Csnippet">Csnippet</a></code> for general rules on writing C snippets.
</p>
<p>In writing an <code>emeasure</code> C snippet, bear in mind that:
</p>

<ol>
<li><p> The goal of such a snippet is to fill variables named <code>E_y</code> with the conditional expectations of observables <code>y</code>.
Accordingly, there should be one assignment of <code>E_y</code> for each observable <code>y</code>.
</p>
</li>
<li><p> In addition to the states, parameters, and covariates (if any), the variable <code>t</code>, containing the time of the observation, will be defined in the context in which the snippet is executed.
</p>
</li></ol>

<p>The demos and the tutorials on the <a href="https://kingaa.github.io/pomp/">package website</a> give examples.
</p>
<p>It is also possible, though less efficient, to specify <code>emeasure</code> using an <span class="rlang"><b>R</b></span> function.
In this case, specify the measurement model expectation by furnishing </p>
<pre>
  emeasure = f</pre>
<p>to <code>pomp</code>, where <code>f</code> is an <span class="rlang"><b>R</b></span> function.
The arguments of <code>f</code> should be chosen from among the state variables, parameters, covariates, and time.
It must also have the argument <code>...</code>.
<code>f</code> must return a named numeric vector of length equal to the number of observable variables.
The names should match those of the observable variables.
</p>


<h3>Default behavior</h3>

<p>The default <code>emeasure</code> is undefined.
It will yield missing values (<code>NA</code>).
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emeasure">emeasure</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>

<hr>
<h2 id='estimation_algorithms'>Parameter estimation algorithms for POMP models.</h2><span id='topic+estimation_algorithms'></span>

<h3>Description</h3>

<p><span class="pkg">pomp</span> currently implements the following algorithms for estimating model parameters:
</p>

<ul>
<li> <p><a href="#topic+mif2">iterated filtering (IF2)</a>
</p>
</li>
<li> <p><a href="#topic+pmcmc">particle Markov chain Monte Carlo (PMCMC)</a>
</p>
</li>
<li> <p><a href="#topic+abc">approximate Bayesian computation (ABC)</a>
</p>
</li>
<li> <p><a href="#topic+probe_match">probe-matching via synthetic likelihood</a>
</p>
</li>
<li> <p><a href="#topic+nlf">nonlinear forecasting</a>
</p>
</li>
<li> <p><a href="#topic+spect_match">power-spectrum matching</a>
</p>
</li>
<li> <p><a href="#topic+bsmc2">Liu-West Bayesian sequential Monte Carlo</a>
</p>
</li>
<li> <p><a href="#topic+kalman">Ensemble and ensemble-adjusted Kalman filters</a>
</p>
</li></ul>



<h3>Details</h3>

<p>Help pages detailing each estimation algorithm are provided.
</p>


<h3>See Also</h3>

<p><a href="#topic+basic_components">basic model components</a>,
<a href="#topic+workhorses">workhorse functions</a>,
<a href="#topic+elementary_algorithms">elementary algorithms</a>.
</p>
<p>More on <span class="pkg">pomp</span> estimation algorithms:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>

<hr>
<h2 id='eulermultinom'>Eulermultinomial and gamma-whitenoise distributions</h2><span id='topic+eulermultinom'></span><span id='topic+reulermultinom'></span><span id='topic+deulermultinom'></span><span id='topic+rgammawn'></span>

<h3>Description</h3>

<p><span class="pkg">pomp</span> provides a number of probability distributions that have proved useful in modeling partially observed Markov processes.
These include the Euler-multinomial family of distributions and
the the Gamma white-noise processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reulermultinom(n = 1, size, rate, dt)

deulermultinom(x, size, rate, dt, log = FALSE)

rgammawn(n = 1, sigma, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eulermultinom_+3A_n">n</code></td>
<td>
<p>integer; number of random variates to generate.</p>
</td></tr>
<tr><td><code id="eulermultinom_+3A_size">size</code></td>
<td>
<p>scalar integer; number of individuals at risk.</p>
</td></tr>
<tr><td><code id="eulermultinom_+3A_rate">rate</code></td>
<td>
<p>numeric vector of hazard rates.</p>
</td></tr>
<tr><td><code id="eulermultinom_+3A_dt">dt</code></td>
<td>
<p>numeric scalar; duration of Euler step.</p>
</td></tr>
<tr><td><code id="eulermultinom_+3A_x">x</code></td>
<td>
<p>matrix or vector containing number of individuals that have
succumbed to each death process.</p>
</td></tr>
<tr><td><code id="eulermultinom_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, return logarithm(s) of probabilities.</p>
</td></tr>
<tr><td><code id="eulermultinom_+3A_sigma">sigma</code></td>
<td>
<p>numeric scalar; intensity of the Gamma white noise process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">N</code> individuals face constant hazards of death in <code class="reqn">K</code> ways
at rates <code class="reqn">r_1, r_2, \dots, r_K</code>,
then in an interval of duration <code class="reqn">\Delta{t}</code>,
the number of individuals remaining alive and dying in each way is multinomially distributed:
</p>
<p style="text-align: center;"><code class="reqn">(\Delta{n_0}, \Delta{n_1}, \dots, \Delta{n_K}) \sim \mathrm{Multinomial}(N;p_0,p_1,\dots,p_K),</code>
</p>

<p>where <code class="reqn">\Delta{n_0}=N-\sum_{k=1}^K \Delta{n_k}</code> is the number of individuals remaining alive and
<code class="reqn">\Delta{n_k}</code> is the number of individuals dying in way <code class="reqn">k</code> over the interval.
Here, the probability of remaining alive is </p>
<p style="text-align: center;"><code class="reqn">p_0=\exp(-\sum_k r_k \Delta{t})</code>
</p>

<p>and the probability of dying in way <code class="reqn">k</code> is </p>
<p style="text-align: center;"><code class="reqn">p_k=\frac{r_k}{\sum_j r_j} (1-p_0).</code>
</p>

<p>In this case, we say that </p>
<p style="text-align: center;"><code class="reqn">(\Delta{n_1},\dots,\Delta{n_K})\sim\mathrm{Eulermultinom}(N,r,\Delta t),</code>
</p>
<p> where <code class="reqn">r=(r_1,\dots,r_K)</code>.
Draw <code class="reqn">m</code> random samples from this distribution by doing </p>
<pre>
    dn &lt;- reulermultinom(n=m,size=N,rate=r,dt=dt),
</pre><p> where <code>r</code> is the vector of rates.
Evaluate the probability that <code class="reqn">x=(x_1,\dots,x_K)</code> are the numbers of individuals who have died in each of the <code class="reqn">K</code> ways over the interval <code class="reqn">\Delta t=</code><code>dt</code>,
by doing </p>
<pre>
    deulermultinom(x=x,size=N,rate=r,dt=dt).
</pre>
<p>Bretó &amp; Ionides (2011) discuss how an infinitesimally overdispersed death process can be constructed by compounding a multinomial process with a Gamma white noise process.
The Euler approximation of the resulting process can be obtained as follows.
Let the increments of the equidispersed process be given by
</p>
<pre>
    reulermultinom(size=N,rate=r,dt=dt).
</pre>
<p>In this expression, replace the rate <code class="reqn">r</code> with <code class="reqn">r\,{\Delta{W}}/{\Delta t}</code>,
where <code class="reqn">\Delta{W} \sim \mathrm{Gamma}(\Delta{t}/\sigma^2,\sigma^2)</code>
is the increment of an integrated Gamma white noise process with intensity <code class="reqn">\sigma</code>.
That is, <code class="reqn">\Delta{W}</code> has mean <code class="reqn">\Delta{t}</code> and variance <code class="reqn">\sigma^2 \Delta{t}</code>.
The resulting process is overdispersed and converges (as <code class="reqn">\Delta{t}</code> goes to zero) to a well-defined process.
The following lines of code accomplish this:
</p>
<pre>
    dW &lt;- rgammawn(sigma=sigma,dt=dt)
</pre> <pre>
    dn &lt;- reulermultinom(size=N,rate=r,dt=dW)
</pre><p> or
</p>
<pre>
    dn &lt;- reulermultinom(size=N,rate=r*dW/dt,dt=dt).
</pre>
<p>He et al. (2010) use such overdispersed death processes in modeling measles and the <a href="https://kingaa.github.io/sbied/measles/">&quot;Simulation-based Inference&quot; course</a> discusses the value of allowing for overdispersion more generally.
</p>
<p>For all of the functions described here, access to the underlying C routines is available:
see below.
</p>


<h3>Value</h3>

<table>
<tr><td><code>reulermultinom</code></td>
<td>

<p>Returns a <code>length(rate)</code> by <code>n</code> matrix.
Each column is a different random draw.
Each row contains the numbers of individuals that have succumbed to the corresponding process.
</p>
</td></tr>
<tr><td><code>deulermultinom</code></td>
<td>

<p>Returns a vector (of length equal to the number of columns of <code>x</code>) containing
the probabilities of observing each column of <code>x</code> given the specified parameters (<code>size</code>, <code>rate</code>, <code>dt</code>).
</p>
</td></tr>
<tr><td><code>rgammawn</code></td>
<td>

<p>Returns a vector of length <code>n</code> containing random increments of the integrated Gamma white noise process with intensity <code>sigma</code>.
</p>
</td></tr>
</table>


<h3>C API</h3>

<p>An interface for C codes using these functions is provided by the package.
Visit the package homepage to view the <a href="https://kingaa.github.io/pomp/C_API.html"><span class="pkg">pomp</span> C API document</a>.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>C. Bretó and E. L. Ionides. Compound Markov counting processes and their applications to modeling infinitesimally over-dispersed systems. <em>Stochastic Processes and their Applications</em> <b>121</b>, 2571&ndash;2591, 2011.
</p>
<p>D. He, E.L. Ionides, and A.A. King. Plug-and-play inference for disease dynamics: measles in large and small populations as a case study.  <em>Journal of the Royal Society Interface</em> <b>7</b>, 271&ndash;283, 2010.
</p>


<h3>See Also</h3>

<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
print(dn &lt;- reulermultinom(5,size=100,rate=c(a=1,b=2,c=3),dt=0.1))
deulermultinom(x=dn,size=100,rate=c(1,2,3),dt=0.1)
## an Euler-multinomial with overdispersed transitions:
dt &lt;- 0.1
dW &lt;- rgammawn(sigma=0.1,dt=dt)
print(dn &lt;- reulermultinom(5,size=100,rate=c(a=1,b=2,c=3),dt=dW))

</code></pre>

<hr>
<h2 id='filter_mean'>Filtering mean</h2><span id='topic+filter_mean'></span><span id='topic+filter_mean+2CANY-method'></span><span id='topic+filter_mean+2Cmissing-method'></span><span id='topic+filter_mean+2Ckalmand_pomp-method'></span><span id='topic+filter_mean+2Cpfilterd_pomp-method'></span>

<h3>Description</h3>

<p>The mean of the filtering distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'kalmand_pomp'
filter_mean(object, vars, ..., format = c("array", "data.frame"))

## S4 method for signature 'pfilterd_pomp'
filter_mean(object, vars, ..., format = c("array", "data.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_mean_+3A_object">object</code></td>
<td>
<p>result of a filtering computation</p>
</td></tr>
<tr><td><code id="filter_mean_+3A_vars">vars</code></td>
<td>
<p>optional character; names of variables</p>
</td></tr>
<tr><td><code id="filter_mean_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="filter_mean_+3A_format">format</code></td>
<td>
<p>format of the returned object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The filtering distribution is that of
</p>
<p style="text-align: center;"><code class="reqn">X(t_k) \vert Y(t_1)=y^*_1,\dots,Y(t_k)=y^*_k,</code>
</p>

<p>where <code class="reqn">X(t_k)</code>, <code class="reqn">Y(t_k)</code> are the latent state and observable processes, respectively, and <code class="reqn">y^*_t</code> is the data, at time <code class="reqn">t_k</code>.
</p>
<p>The filtering mean is therefore the expectation of this distribution
</p>
<p style="text-align: center;"><code class="reqn">E[X(t_k) \vert Y(t_1)=y^*_1,\dots,Y(t_k)=y^*_k].</code>
</p>



<h3>See Also</h3>

<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='filter_traj'>Filtering trajectories</h2><span id='topic+filter_traj'></span><span id='topic+filter_traj+2CANY-method'></span><span id='topic+filter_traj+2Cmissing-method'></span><span id='topic+filter_traj+2Cpfilterd_pomp-method'></span><span id='topic+filter_traj+2Clistie-method'></span><span id='topic+filter_traj+2Cpmcmcd_pomp-method'></span>

<h3>Description</h3>

<p>Drawing from the smoothing distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pfilterd_pomp'
filter_traj(object, vars, ..., format = c("array", "data.frame"))

## S4 method for signature 'listie'
filter_traj(object, vars, ..., format = c("array", "data.frame"))

## S4 method for signature 'pmcmcd_pomp'
filter_traj(object, vars, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_traj_+3A_object">object</code></td>
<td>
<p>result of a filtering computation</p>
</td></tr>
<tr><td><code id="filter_traj_+3A_vars">vars</code></td>
<td>
<p>optional character; names of variables</p>
</td></tr>
<tr><td><code id="filter_traj_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="filter_traj_+3A_format">format</code></td>
<td>
<p>format of the returned object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The smoothing distribution is the distribution of
</p>
<p style="text-align: center;"><code class="reqn">X(t_k) | Y(t_1)=y^*_1, \dots, Y(t_n)=y^*_n,</code>
</p>

<p>where <code class="reqn">X(t_k)</code> is the latent state process and <code class="reqn">Y(t_k)</code> is the observable process at time <code class="reqn">t_k</code>, and <code class="reqn">n</code> is the number of observations.
</p>
<p>To draw samples from this distribution, one can run a number of independent particle filter (<code><a href="#topic+pfilter">pfilter</a></code>) operations, sampling the full trajectory of <em>one</em> randomly-drawn particle from each one.
One should view these as <em>weighted</em> samples from the smoothing distribution, where the weights are the <em>likelihoods</em> returned by each of the <code><a href="#topic+pfilter">pfilter</a></code> computations.
</p>
<p>One accomplishes this by setting <code>filter.traj = TRUE</code> in each <code><a href="#topic+pfilter">pfilter</a></code> computation and extracting the trajectory using the <code>filter_traj</code> command.
</p>
<p>In particle MCMC (<code><a href="#topic+pmcmc">pmcmc</a></code>), the tracking of an individual trajectory is performed automatically.
</p>


<h3>See Also</h3>

<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='flow'>flow workhorse</h2><span id='topic+flow'></span><span id='topic+flow+2Cmissing-method'></span><span id='topic+flow+2CANY-method'></span><span id='topic+flow+2Cpomp-method'></span>

<h3>Description</h3>

<p>Compute the flow generated by a deterministic vectorfield or map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
flow(
  object,
  x0,
  t0 = timezero(object),
  times = time(object),
  params = coef(object),
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flow_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="flow_+3A_x0">x0</code></td>
<td>
<p>an array with dimensions <code>nvar</code> x <code>nrep</code> giving the initial conditions of the trajectories to be computed.</p>
</td></tr>
<tr><td><code id="flow_+3A_t0">t0</code></td>
<td>
<p>the time at which the initial conditions are assumed to hold.
By default, this is the zero-time (see <code><a href="#topic+timezero">timezero</a></code>).</p>
</td></tr>
<tr><td><code id="flow_+3A_times">times</code></td>
<td>
<p>a numeric vector (length <code>ntimes</code>) containing times at which the itineraries are desired.
These must be in non-decreasing order with <code>times[1]&gt;t0</code>.
By default, this is the full set of observation times (see <code><a href="#topic+time">time</a></code>).</p>
</td></tr>
<tr><td><code id="flow_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="flow_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the ODE integrator (if the skeleton is a vectorfield) and are ignored if it is a map.
See <code><a href="deSolve.html#topic+ode">ode</a></code> for a description of the additional arguments accepted by the ODE integrator.
By default, this is the parameter vector stored in <code>object</code> (see <code><a href="#topic+coef">coef</a></code>).</p>
</td></tr>
<tr><td><code id="flow_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of a discrete-time system (map), <code>flow</code> iterates the map to yield trajectories of the system.
In the case of a continuous-time system (vectorfield), <code>flow</code> uses the numerical solvers in <span class="pkg"><a href="deSolve.html#topic+deSolve">deSolve</a></span> to integrate the vectorfield starting from given initial conditions.
</p>


<h3>Value</h3>

<p><code>flow</code> returns an array of dimensions <code>nvar</code> x <code>nrep</code> x <code>ntimes</code>.
If <code>x</code> is the returned matrix, <code>x[i,j,k]</code> is the i-th component of the state vector at time <code>times[k]</code> given parameters <code>params[,j]</code>.
</p>


<h3>See Also</h3>

<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>
<p>More on methods for deterministic process models: 
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+traj_match">traj_match</a></code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>
</p>

<hr>
<h2 id='forecast'>Forecast mean</h2><span id='topic+forecast'></span><span id='topic+forecast+2Cmissing-method'></span><span id='topic+forecast+2CANY-method'></span><span id='topic+forecast+2Ckalmand_pomp-method'></span><span id='topic+forecast+2Cpfilterd_pomp-method'></span>

<h3>Description</h3>

<p>Mean of the one-step-ahead forecasting distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast(object, ...)

## S4 method for signature 'kalmand_pomp'
forecast(object, vars, ..., format = c("array", "data.frame"))

## S4 method for signature 'pfilterd_pomp'
forecast(object, vars, ..., format = c("array", "data.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_+3A_object">object</code></td>
<td>
<p>result of a filtering computation</p>
</td></tr>
<tr><td><code id="forecast_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="forecast_+3A_vars">vars</code></td>
<td>
<p>optional character; names of variables</p>
</td></tr>
<tr><td><code id="forecast_+3A_format">format</code></td>
<td>
<p>format of the returned object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='gompertz'>Gompertz model with log-normal observations.</h2><span id='topic+gompertz'></span>

<h3>Description</h3>

<p><code>gompertz()</code> constructs a &lsquo;pomp&rsquo; object encoding a stochastic Gompertz population model with log-normal measurement error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gompertz(
  K = 1,
  r = 0.1,
  sigma = 0.1,
  tau = 0.1,
  X_0 = 1,
  times = 1:100,
  t0 = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gompertz_+3A_k">K</code></td>
<td>
<p>carrying capacity</p>
</td></tr>
<tr><td><code id="gompertz_+3A_r">r</code></td>
<td>
<p>growth rate</p>
</td></tr>
<tr><td><code id="gompertz_+3A_sigma">sigma</code></td>
<td>
<p>process noise intensity</p>
</td></tr>
<tr><td><code id="gompertz_+3A_tau">tau</code></td>
<td>
<p>measurement error s.d.</p>
</td></tr>
<tr><td><code id="gompertz_+3A_x_0">X_0</code></td>
<td>
<p>value of the latent state variable <code>X</code> at the zero time</p>
</td></tr>
<tr><td><code id="gompertz_+3A_times">times</code></td>
<td>
<p>observation times</p>
</td></tr>
<tr><td><code id="gompertz_+3A_t0">t0</code></td>
<td>
<p>zero time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state process is
</p>
<p style="text-align: center;"><code class="reqn">X_{t+1} = K^{1-S} X_{t}^S \epsilon_{t},</code>
</p>
<p> where <code class="reqn">S=e^{-r}</code>
and the <code class="reqn">\epsilon_t</code> are i.i.d. lognormal random deviates with
variance <code class="reqn">\sigma^2</code>.
The observed variables <code class="reqn">Y_t</code> are distributed as
</p>
<p style="text-align: center;"><code class="reqn">Y_t\sim\mathrm{Lognormal}(\log{X_t},\tau).</code>
</p>

<p>Parameters include the per-capita growth rate <code class="reqn">r</code>, the carrying
capacity <code class="reqn">K</code>, the process noise s.d. <code class="reqn">\sigma</code>, the
measurement error s.d. <code class="reqn">\tau</code>, and the initial condition
<code class="reqn">X_0</code>.  The &lsquo;pomp&rsquo; object includes parameter
transformations that log-transform the parameters for estimation purposes.
</p>


<h3>Value</h3>

<p>A &lsquo;pomp&rsquo; object with simulated data.
</p>


<h3>See Also</h3>

<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+compartmental_models">compartmental_models</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+ou2">ou2</a>()</code>,
<code><a href="#topic+pomp_examples">pomp_examples</a></code>,
<code><a href="#topic+ricker">ricker</a>()</code>,
<code><a href="#topic+rw2">rw2</a>()</code>,
<code><a href="#topic+verhulst">verhulst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(gompertz())
plot(gompertz(K=2,r=0.01))

</code></pre>

<hr>
<h2 id='hitch'>Hitching C snippets and R functions to pomp_fun objects</h2><span id='topic+hitch'></span>

<h3>Description</h3>

<p>The algorithms in <span class="pkg">pomp</span> are formulated using <span class="rlang"><b>R</b></span> functions that access the <a href="#topic+basic_components">basic model components</a>
(<code>rprocess</code>, <code>dprocess</code>, <code>rmeasure</code>, <code>dmeasure</code>, etc.).
For short, we refer to these elementary functions as &ldquo;<a href="#topic+workhorses">workhorses</a>&rdquo;.
In implementing a model, the user specifies basic model components
using functions, procedures in dynamically-linked libraries, or C snippets.
Each component is then packaged into a &lsquo;pomp_fun&rsquo; objects, which gives a uniform interface.
The construction of &lsquo;pomp_fun&rsquo; objects is handled by the <code>hitch</code> function,
which conceptually &ldquo;hitches&rdquo; the workhorses to the user-defined procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hitch(
  ...,
  templates,
  obsnames,
  statenames,
  paramnames,
  covarnames,
  PACKAGE,
  globals,
  cfile,
  cdir = getOption("pomp_cdir", NULL),
  on_load,
  shlib.args,
  compile = TRUE,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hitch_+3A_...">...</code></td>
<td>
<p>named arguments representing the user procedures to be hitched.
These can be functions, character strings naming routines in external, dynamically-linked libraries, C snippets, or <code>NULL</code>.
The first three are converted by <code>hitch</code> to &lsquo;pomp_fun&rsquo; objects which perform the indicated computations.
<code>NULL</code> arguments are translated to default &lsquo;pomp_fun&rsquo; objects.
If any of these procedures are already &lsquo;pomp_fun&rsquo; objects, they are returned unchanged.</p>
</td></tr>
<tr><td><code id="hitch_+3A_templates">templates</code></td>
<td>
<p>named list of templates.
Each workhorse must have a corresponding template.
See <code>pomp:::workhorse_templates</code> for a list.</p>
</td></tr>
<tr><td><code id="hitch_+3A_obsnames">obsnames</code>, <code id="hitch_+3A_statenames">statenames</code>, <code id="hitch_+3A_paramnames">paramnames</code>, <code id="hitch_+3A_covarnames">covarnames</code></td>
<td>
<p>character vectors
specifying the names of observable variables, latent state variables, parameters, and covariates, respectively.
These are only needed if one or more of the horses are furnished as C snippets.</p>
</td></tr>
<tr><td><code id="hitch_+3A_package">PACKAGE</code></td>
<td>
<p>optional character;
the name (without extension) of the external, dynamically loaded library in which any native routines are to be found.
This is only useful if one or more of the model components has been specified using a precompiled dynamically loaded library;
it is not used for any component specified using C snippets.
<code>PACKAGE</code> can name at most one library.</p>
</td></tr>
<tr><td><code id="hitch_+3A_globals">globals</code></td>
<td>
<p>optional character or C snippet;
arbitrary C code that will be hard-coded into the shared-object library created when C snippets are provided.
If no C snippets are used, <code>globals</code> has no effect.</p>
</td></tr>
<tr><td><code id="hitch_+3A_cfile">cfile</code></td>
<td>
<p>optional character variable.
<code>cfile</code> gives the name of the file (in directory <code>cdir</code>) into which C snippet codes will be written.
By default, a random filename is used.
If the chosen filename would result in over-writing an existing file, an error is generated.</p>
</td></tr>
<tr><td><code id="hitch_+3A_cdir">cdir</code></td>
<td>
<p>optional character variable.
<code>cdir</code> specifies the name of the directory within which C snippet code will be compiled.
By default, this is in a temporary directory specific to the <span class="rlang"><b>R</b></span> session.
One can also set this directory using the <code>pomp_cdir</code> global option.</p>
</td></tr>
<tr><td><code id="hitch_+3A_on_load">on_load</code></td>
<td>
<p>optional character or C snippet:
arbitrary C code that will be executed when the C snippet file is loaded.
If no C snippets are used, <code>on_load</code> has no effect.</p>
</td></tr>
<tr><td><code id="hitch_+3A_shlib.args">shlib.args</code></td>
<td>
<p>optional character variables.
Command-line arguments to the <code>R CMD SHLIB</code> call that compiles the C snippets.
One can, for example, specify libraries against which the C snippets are to be linked.
In doing so, take care to make sure the appropriate header files are available to the C snippets, e.g., using the <code>globals</code> argument.
See <code><a href="#topic+Csnippet">Csnippet</a></code> for more information.</p>
</td></tr>
<tr><td><code id="hitch_+3A_compile">compile</code></td>
<td>
<p>logical;
if <code>FALSE</code>, compilation of the C snippets will be postponed until they are needed.</p>
</td></tr>
<tr><td><code id="hitch_+3A_verbose">verbose</code></td>
<td>
<p>logical.
Setting <code>verbose=TRUE</code> will cause additional information to be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hitch</code> returns a named list of length two.  The element named
&ldquo;funs&rdquo; is itself a named list of &lsquo;pomp_fun&rsquo; objects, each of
which corresponds to one of the horses passed in.  The element named
&ldquo;lib&rdquo; contains information on the shared-object library created
using the C snippets (if any were passed to <code>hitch</code>).  If no C
snippets were passed to <code>hitch</code>, <code>lib</code> is <code>NULL</code>.
Otherwise, it is a length-3 named list with the following elements:
</p>

<dl>
<dt>name</dt><dd><p>The name of the library created.</p>
</dd>
<dt>dir</dt><dd><p> The
directory in which the library was created.  If this is <code>NULL</code>, the
library was created in the session's temporary directory.  </p>
</dd>
<dt>src</dt><dd><p> A
character string with the full contents of the C snippet file.  </p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pomp">pomp</a></code>, <code><a href="#topic+spy">spy</a></code>
</p>

<hr>
<h2 id='kalman'>Ensemble Kalman filters</h2><span id='topic+kalman'></span><span id='topic+enkf+2CANY-method'></span><span id='topic+enkf+2Cmissing-method'></span><span id='topic+eakf+2CANY-method'></span><span id='topic+eakf+2Cmissing-method'></span><span id='topic+enkf+2Cdata.frame-method'></span><span id='topic+enkf'></span><span id='topic+enkf+2Cpomp-method'></span><span id='topic+enkf+2Ckalmand_pomp-method'></span><span id='topic+eakf+2Cdata.frame-method'></span><span id='topic+eakf'></span><span id='topic+eakf+2Cpomp-method'></span>

<h3>Description</h3>

<p>The ensemble Kalman filter and ensemble adjustment Kalman filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
enkf(
  data,
  Np,
  params,
  rinit,
  rprocess,
  emeasure,
  vmeasure,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
enkf(data, Np, ..., verbose = getOption("verbose", FALSE))

## S4 method for signature 'kalmand_pomp'
enkf(data, Np, ..., verbose = getOption("verbose", FALSE))

## S4 method for signature 'data.frame'
eakf(
  data,
  Np,
  params,
  rinit,
  rprocess,
  emeasure,
  vmeasure,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
eakf(data, Np, ..., verbose = getOption("verbose", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kalman_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="kalman_+3A_np">Np</code></td>
<td>
<p>integer; the number of particles to use, i.e., the size of the ensemble.</p>
</td></tr>
<tr><td><code id="kalman_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="kalman_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="kalman_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="kalman_+3A_emeasure">emeasure</code></td>
<td>
<p>the expectation of the measured variables, conditional on the latent state.
This can be specified as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>emeasure=NULL</code> removes the emeasure component.
For more information, see <a href="#topic+emeasure_spec">emeasure specification</a>.</p>
</td></tr>
<tr><td><code id="kalman_+3A_vmeasure">vmeasure</code></td>
<td>
<p>the covariance of the measured variables, conditional on the latent state.
This can be specified as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>vmeasure=NULL</code> removes the vmeasure component.
For more information, see <a href="#topic+vmeasure_spec">vmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="kalman_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="kalman_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;kalmand_pomp&rsquo;.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>G. Evensen. Sequential data assimilation with a nonlinear quasi-geostrophic model using Monte Carlo methods to forecast error statistics. <em>Journal of Geophysical Research: Oceans</em> <b>99</b>, 10143&ndash;10162, 1994.
</p>
<p>J.L. Anderson. An ensemble adjustment Kalman filter for data assimilation. <em>Monthly Weather Review</em> <b>129</b>, 2884&ndash;2903, 2001.
</p>
<p>G. Evensen. <em>Data assimilation: the ensemble Kalman filter</em>. Springer-Verlag, 2009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kalmanFilter">kalmanFilter</a></code>
</p>
<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on <span class="pkg">pomp</span> elementary algorithms: 
<code><a href="#topic+elementary_algorithms">elementary_algorithms</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>

<hr>
<h2 id='kalmanFilter'>Kalman filter</h2><span id='topic+kalmanFilter'></span>

<h3>Description</h3>

<p>The basic Kalman filter for multivariate, linear, Gaussian processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalmanFilter(object, X0 = rinit(object), A, Q, C, R, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kalmanFilter_+3A_object">object</code></td>
<td>
<p>a pomp object containing data;</p>
</td></tr>
<tr><td><code id="kalmanFilter_+3A_x0">X0</code></td>
<td>
<p>length-m vector containing initial state.
This is assumed known without uncertainty.</p>
</td></tr>
<tr><td><code id="kalmanFilter_+3A_a">A</code></td>
<td>
<p><code class="reqn">m\times m</code> latent state-process transition matrix.
<code class="reqn">E[X_{t+1} | X_t] = A.X_t</code>.</p>
</td></tr>
<tr><td><code id="kalmanFilter_+3A_q">Q</code></td>
<td>
<p><code class="reqn">m\times m</code> latent state-process covariance matrix.
<code class="reqn">Var[X_{t+1} | X_t] = Q</code></p>
</td></tr>
<tr><td><code id="kalmanFilter_+3A_c">C</code></td>
<td>
<p><code class="reqn">n\times m</code> link matrix.
<code class="reqn">E[Y_t | X_t] = C.X_t</code>.</p>
</td></tr>
<tr><td><code id="kalmanFilter_+3A_r">R</code></td>
<td>
<p><code class="reqn">n\times n</code> observation process covariance matrix.
<code class="reqn">Var[Y_t | X_t] = R</code></p>
</td></tr>
<tr><td><code id="kalmanFilter_+3A_tol">tol</code></td>
<td>
<p>numeric;
the tolerance to be used in computing matrix pseudoinverses via singular-value decomposition.
Singular values smaller than <code>tol</code> are set to zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the latent state is <code class="reqn">X</code>, the observed variable is <code class="reqn">Y</code>,
<code class="reqn">X_t \in R^m</code>, <code class="reqn">Y_t \in R^n</code>, and
</p>
<p style="text-align: center;"><code class="reqn">X_t \sim \mathrm{MVN}(A X_{t-1}, Q)</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_t \sim \mathrm{MVN}(C X_t, R)</code>
</p>

<p>where <code class="reqn">\mathrm{MVN}(M,V)</code> denotes the multivariate normal distribution with mean <code class="reqn">M</code> and variance <code class="reqn">V</code>.
Then the Kalman filter computes the exact likelihood of <code class="reqn">Y</code>
given <code class="reqn">A</code>, <code class="reqn">C</code>, <code class="reqn">Q</code>, and <code class="reqn">R</code>.
</p>


<h3>Value</h3>

<p>A named list containing the following elements:
</p>

<dl>
<dt>object</dt><dd><p>the &lsquo;pomp&rsquo; object</p>
</dd>
<dt>A, Q, C, R</dt><dd><p>as in the call</p>
</dd>
<dt>filter.mean</dt><dd><p><code class="reqn">E[X_t|y^*_1,\dots,y^*_t]</code></p>
</dd>
<dt>pred.mean</dt><dd><p><code class="reqn">E[X_t|y^*_1,\dots,y^*_{t-1}]</code></p>
</dd>
<dt>forecast</dt><dd><p><code class="reqn">E[Y_t|y^*_1,\dots,y^*_{t-1}]</code></p>
</dd>
<dt>cond.logLik</dt><dd><p><code class="reqn">f(y^*_t|y^*_1,\dots,y^*_{t-1})</code></p>
</dd>
<dt>logLik</dt><dd><p><code class="reqn">f(y^*_1,\dots,y^*_T)</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+enkf">enkf</a></code>, <code><a href="#topic+eakf">eakf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # takes too long for R CMD check

  if (require(dplyr)) {

    gompertz() -&gt; po

    po |&gt;
      as.data.frame() |&gt;
      mutate(
        logY=log(Y)
      ) |&gt;
      select(time,logY) |&gt;
      pomp(times="time",t0=0) |&gt;
      kalmanFilter(
        X0=c(logX=0),
        A=matrix(exp(-0.1),1,1),
        Q=matrix(0.01,1,1),
        C=matrix(1,1,1),
        R=matrix(0.01,1,1)
      ) -&gt; kf

    po |&gt;
      pfilter(Np=1000) -&gt; pf

    kf$logLik
    logLik(pf) + sum(log(obs(pf)))
    
  }

</code></pre>

<hr>
<h2 id='listie'>listie</h2><span id='topic+listie'></span><span id='topic++5B-listie'></span><span id='topic++5B+2Clistie-method'></span>

<h3>Description</h3>

<p>List-like objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'listie'
x[i, j, ..., drop = TRUE]
</code></pre>

<hr>
<h2 id='load'>Loading and unloading shared-object libraries</h2><span id='topic+load'></span><span id='topic+pompLoad'></span><span id='topic+pompUnload'></span><span id='topic+solibs+3C-'></span><span id='topic+pompLoad+2Cpomp-method'></span><span id='topic+pompUnload+2Cpomp-method'></span><span id='topic+solibs+3C-+2Cpomp-method'></span><span id='topic+pompLoad+2Cobjfun-method'></span><span id='topic+pompUnload+2Cobjfun-method'></span>

<h3>Description</h3>

<p><code>pompLoad</code> and <code>pompUnload</code> cause compiled codes associated with <code>object</code> to be dynamically linked or unlinked, respectively.
<code>solibs&lt;-</code> is a helper function for developers of packages that extend <span class="pkg">pomp</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
pompLoad(object, ...)

## S4 method for signature 'pomp'
pompUnload(object, ...)

## S4 replacement method for signature 'pomp'
solibs(object, ...) &lt;- value

## S4 method for signature 'objfun'
pompLoad(object, ...)

## S4 method for signature 'objfun'
pompUnload(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or extending this class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When C snippets are used in the construction of a &lsquo;pomp&rsquo; object, the resulting shared-object library is dynamically loaded (linked) before each use, and unloaded afterward.
</p>
<p><code>solibs&lt;-</code> prepends the &lsquo;lib&rsquo; generated by <code><a href="#topic+hitch">hitch</a></code>
to the &lsquo;solibs&rsquo; slot of a &lsquo;pomp&rsquo; object.
</p>

<hr>
<h2 id='logLik'>Log likelihood</h2><span id='topic+logLik'></span><span id='topic+logLik+2CANY-method'></span><span id='topic+logLik+2Cmissing-method'></span><span id='topic+logLik+2Clistie-method'></span><span id='topic+logLik+2Cpfilterd_pomp-method'></span><span id='topic+logLik+2Cwpfilterd_pomp-method'></span><span id='topic+logLik+2Cprobed_pomp-method'></span><span id='topic+logLik+2Ckalmand_pomp-method'></span><span id='topic+logLik+2Cpmcmcd_pomp-method'></span><span id='topic+logLik+2Cbsmcd_pomp-method'></span><span id='topic+logLik+2Cobjfun-method'></span><span id='topic+logLik+2Cspect_match_objfun-method'></span><span id='topic+logLik+2Cnlf_objfun-method'></span>

<h3>Description</h3>

<p>Extract the estimated log likelihood (or related quantity) from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLik(object, ...)

## S4 method for signature 'listie'
logLik(object, ...)

## S4 method for signature 'pfilterd_pomp'
logLik(object)

## S4 method for signature 'wpfilterd_pomp'
logLik(object)

## S4 method for signature 'probed_pomp'
logLik(object)

## S4 method for signature 'kalmand_pomp'
logLik(object)

## S4 method for signature 'pmcmcd_pomp'
logLik(object)

## S4 method for signature 'bsmcd_pomp'
logLik(object)

## S4 method for signature 'objfun'
logLik(object)

## S4 method for signature 'spect_match_objfun'
logLik(object)

## S4 method for signature 'nlf_objfun'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="logLik_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical value of the log likelihood.
Note that some methods compute not the log likelihood itself but instead a related quantity.
To keep the code simple, the <code>logLik</code> function is nevertheless used to extract this quantity.
</p>
<p>When <code>object</code> is of &lsquo;pfilterd_pomp&rsquo; class (i.e., the result of a <code>wpfilter</code> computation), <code>logLik</code> retrieves the estimated log likelihood.
</p>
<p>When <code>object</code> is of &lsquo;wpfilterd_pomp&rsquo; class (i.e., the result of a <code>wpfilter</code> computation), <code>logLik</code> retrieves the estimated log likelihood.
</p>
<p>When <code>object</code> is of &lsquo;probed_pomp&rsquo; class (i.e., the result of a <code><a href="#topic+probe">probe</a></code> computation), <code>logLik</code> retrieves the &ldquo;synthetic likelihood&rdquo;.
</p>
<p>When <code>object</code> is of &lsquo;kalmand_pomp&rsquo; class (i.e., the result of an <code><a href="#topic+eakf">eakf</a></code> or <code><a href="#topic+enkf">enkf</a></code> computation), <code>logLik</code> retrieves the estimated log likelihood.
</p>
<p>When <code>object</code> is of &lsquo;pmcmcd_pomp&rsquo; class (i.e., the result of a <code><a href="#topic+pmcmc">pmcmc</a></code> computation), <code>logLik</code> retrieves the estimated log likelihood as of the last particle filter operation.
</p>
<p>When <code>object</code> is of &lsquo;bsmcd_pomp&rsquo; class (i.e., the result of a <code><a href="#topic+bsmc2">bsmc2</a></code> computation), <code>logLik</code> retrieves the &ldquo;log evidence&rdquo;.
</p>
<p>When <code>object</code> is of &lsquo;spect_match_objfun&rsquo; class (i.e., an objective function constructed by <code><a href="#topic+spect_objfun">spect_objfun</a></code>), <code>logLik</code> retrieves minus the spectrum mismatch.
</p>
<p>When <code>object</code> is an NLF objective function, i.e., the result of a call to <code><a href="#topic+nlf_objfun">nlf_objfun</a></code>,
<code>logLik</code> retrieves the &ldquo;quasi log likelihood&rdquo;.
</p>


<h3>See Also</h3>

<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='logmeanexp'>The log-mean-exp trick</h2><span id='topic+logmeanexp'></span>

<h3>Description</h3>

<p><code>logmeanexp</code> computes
</p>
<p style="text-align: center;"><code class="reqn">\log\frac{1}{n}\sum_{i=1}^n\!e^{x_i},</code>
</p>

<p>avoiding over- and under-flow in doing so.
It can optionally return an estimate of the standard error in this quantity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logmeanexp(x, se = FALSE, ess = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logmeanexp_+3A_x">x</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="logmeanexp_+3A_se">se</code></td>
<td>
<p>logical; give approximate standard error?</p>
</td></tr>
<tr><td><code id="logmeanexp_+3A_ess">ess</code></td>
<td>
<p>logical; give effective sample size?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>se = TRUE</code>, <code>logmeanexp</code> uses a jackknife estimate of the variance in <code class="reqn">log(x)</code>.
</p>
<p>When <code>ess = TRUE</code>, <code>logmeanexp</code> returns an estimate of the effective sample size.
</p>


<h3>Value</h3>

<p><code>log(mean(exp(x)))</code> computed so as to avoid over- or underflow.
If <code>se = TRUE</code>, the approximate standard error is returned as well.
If <code>ess = TRUE</code>, the effective sample size is returned also.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # takes too long for R CMD check
  ## an estimate of the log likelihood:
  ricker() |&gt;
    pfilter(Np=1000) |&gt;
    logLik() |&gt;
    replicate(n=5) -&gt; ll
  logmeanexp(ll)
  ## with standard error:
  logmeanexp(ll,se=TRUE)
  ## with effective sample size
  logmeanexp(ll,ess=TRUE)

</code></pre>

<hr>
<h2 id='lookup'>Lookup table</h2><span id='topic+lookup'></span>

<h3>Description</h3>

<p>Interpolate values from a lookup table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup(table, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_+3A_table">table</code></td>
<td>
<p>a &lsquo;covartable&rsquo; object created by a call to <code><a href="#topic+covariate_table">covariate_table</a></code></p>
</td></tr>
<tr><td><code id="lookup_+3A_t">t</code></td>
<td>
<p>numeric vector; times at which interpolated values of the covariates in <code>table</code> are required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A warning will be generated if extrapolation is performed.
</p>


<h3>Value</h3>

<p>A numeric vector or matrix of the interpolated values.
</p>


<h3>See Also</h3>

<p>More on interpolation:
<code><a href="#topic+bsplines">bsplines</a></code>,
<code><a href="#topic+covariates">covariates</a></code>
</p>

<hr>
<h2 id='mcap'>Monte Carlo adjusted profile</h2><span id='topic+mcap'></span>

<h3>Description</h3>

<p>Given a collection of points maximizing the likelihood over a range
of fixed values of a focal parameter, this function constructs 
a profile likelihood confidence interval accommodating both
Monte Carlo error in the profile and statistical uncertainty present
in the likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcap(logLik, parameter, level = 0.95, span = 0.75, Ngrid = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcap_+3A_loglik">logLik</code></td>
<td>
<p>numeric; a vector of profile log likelihood evaluations.</p>
</td></tr>
<tr><td><code id="mcap_+3A_parameter">parameter</code></td>
<td>
<p>numeric; the corresponding values of the focal parameter.</p>
</td></tr>
<tr><td><code id="mcap_+3A_level">level</code></td>
<td>
<p>numeric; the confidence level required.</p>
</td></tr>
<tr><td><code id="mcap_+3A_span">span</code></td>
<td>
<p>numeric; the <code><a href="stats.html#topic+loess">loess</a></code> smoothing parameter.</p>
</td></tr>
<tr><td><code id="mcap_+3A_ngrid">Ngrid</code></td>
<td>
<p>integer; the number of points to evaluate the smoothed profile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mcap</code> returns a list including the <code><a href="stats.html#topic+loess">loess</a></code>-smoothed
profile, a quadratic approximation, and the constructed confidence interval.
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>References</h3>

<p>E. L. Ionides, C. Bretó, J. Park, R. A. Smith, and A. A. King. Monte Carlo profile confidence intervals for dynamic systems. <em>Journal of the Royal Society, Interface</em> <b>14</b>, 20170126, 2017.
</p>

<hr>
<h2 id='melt'>Melt</h2><span id='topic+melt'></span><span id='topic+melt+2CANY-method'></span><span id='topic+melt+2Cmissing-method'></span><span id='topic+melt+2Carray-method'></span><span id='topic+melt+2Clist-method'></span>

<h3>Description</h3>

<p>Convert arrays, lists, and other objects to data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
melt(data, ...)

## S4 method for signature 'array'
melt(data, ...)

## S4 method for signature 'list'
melt(data, ..., level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melt_+3A_data">data</code></td>
<td>
<p>object to convert</p>
</td></tr>
<tr><td><code id="melt_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>melt</code> converts its first argument to a data frame.
It is a simplified version of the <code>melt</code> command provided by the no-longer maintained <span class="pkg">reshape2</span> package.
</p>
<p>An array can be melted into a data frame.
In this case, the data frame will have one row per entry in the array.
</p>
<p>A list can be melted into a data frame.
This operation is recursive.
A variable will be appended to distinguish the separate list entries.
</p>

<hr>
<h2 id='mif2'>Iterated filtering: maximum likelihood by iterated, perturbed Bayes maps</h2><span id='topic+mif2'></span><span id='topic+mif2+2Cmissing-method'></span><span id='topic+mif2+2CANY-method'></span><span id='topic+mif2+2Cdata.frame-method'></span><span id='topic+mif2+2Cpomp-method'></span><span id='topic+mif2+2Cpfilterd_pomp-method'></span><span id='topic+mif2+2Cmif2d_pomp-method'></span>

<h3>Description</h3>

<p>An iterated filtering algorithm for estimating the parameters of a partially-observed Markov process.
Running <code>mif2</code> causes the algorithm to perform a specified number of particle-filter iterations.
At each iteration, the particle filter is performed on a perturbed version of the model, in which the parameters to be estimated are subjected to random perturbations at each observation.
This extra variability effectively smooths the likelihood surface and combats particle depletion by introducing diversity into particle population.
As the iterations progress, the magnitude of the perturbations is diminished according to a user-specified cooling schedule.
The algorithm is presented and justified in Ionides et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
mif2(
  data,
  Nmif = 1,
  rw.sd,
  cooling.type = c("geometric", "hyperbolic"),
  cooling.fraction.50,
  Np,
  params,
  rinit,
  rprocess,
  dmeasure,
  partrans,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
mif2(
  data,
  Nmif = 1,
  rw.sd,
  cooling.type = c("geometric", "hyperbolic"),
  cooling.fraction.50,
  Np,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pfilterd_pomp'
mif2(data, Nmif = 1, Np, ..., verbose = getOption("verbose", FALSE))

## S4 method for signature 'mif2d_pomp'
mif2(
  data,
  Nmif,
  rw.sd,
  cooling.type,
  cooling.fraction.50,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mif2_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="mif2_+3A_nmif">Nmif</code></td>
<td>
<p>The number of filtering iterations to perform.</p>
</td></tr>
<tr><td><code id="mif2_+3A_rw.sd">rw.sd</code></td>
<td>
<p>specification of the magnitude of the random-walk perturbations that will be applied to some or all model parameters.
Parameters that are to be estimated should have positive perturbations specified here.
The specification is given using the <code><a href="#topic+rw.sd">rw.sd</a></code> function, which creates a list of unevaluated expressions.
The latter are evaluated in a context where the model time variable is defined (as <code>time</code>).
The expression <code>ivp(s)</code> can be used in this context as shorthand for </p>
<pre>ifelse(time==time[1],s,0).</pre>
<p>Likewise, <code>ivp(s,lag)</code> is equivalent to </p>
<pre>ifelse(time==time[lag],s,0).</pre>
<p>See below for some examples.
</p>
<p>The perturbations that are applied are normally distributed with the specified s.d.
If parameter transformations have been supplied, then the perturbations are applied on the transformed (estimation) scale.</p>
</td></tr>
<tr><td><code id="mif2_+3A_cooling.type">cooling.type</code>, <code id="mif2_+3A_cooling.fraction.50">cooling.fraction.50</code></td>
<td>
<p>specifications for the cooling schedule,
i.e., the manner and rate with which the intensity of the parameter perturbations is reduced with successive filtering iterations.
<code>cooling.type</code> specifies the nature of the cooling schedule.
See below (under &ldquo;Specifying the perturbations&rdquo;) for more detail.</p>
</td></tr>
<tr><td><code id="mif2_+3A_np">Np</code></td>
<td>
<p>the number of particles to use.
This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
Alternatively, if one wishes the number of particles to vary across timesteps, one may specify <code>Np</code> either as a vector of positive integers of length </p>
<pre>length(time(object,t0=TRUE))</pre><p> or as a function taking a positive integer argument.
In the latter case, <code>Np(k)</code> must be a single positive integer, representing the number of particles to be used at the <code>k</code>-th timestep:
<code>Np(0)</code> is the number of particles to use going from <code>timezero(object)</code> to <code>time(object)[1]</code>,
<code>Np(1)</code>, from <code>timezero(object)</code> to <code>time(object)[1]</code>,
and so on,
while when <code>T=length(time(object))</code>, <code>Np(T)</code> is the number of particles to sample at the end of the time-series.</p>
</td></tr>
<tr><td><code id="mif2_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="mif2_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="mif2_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="mif2_+3A_dmeasure">dmeasure</code></td>
<td>
<p>evaluator of the measurement model density, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>dmeasure=NULL</code> removes the measurement density evaluator.
For more information, see <a href="#topic+dmeasure_spec">dmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="mif2_+3A_partrans">partrans</code></td>
<td>
<p>optional parameter transformations, constructed using <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
</p>
<p>Many algorithms for parameter estimation search an unconstrained space of parameters.
When working with such an algorithm and a model for which the parameters are constrained, it can be useful to transform parameters.
One should supply the <code>partrans</code> argument via a call to <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
For more information, see <a href="#topic+parameter_trans">parameter_trans</a>.
Setting <code>partrans=NULL</code> removes the parameter transformations, i.e., sets them to the identity transformation.</p>
</td></tr>
<tr><td><code id="mif2_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="mif2_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upon successful completion, <code>mif2</code> returns an object of class
&lsquo;mif2d_pomp&rsquo;.
</p>


<h3>Number of particles</h3>

<p>If <code>Np</code> is anything other than a constant, the user must take care that the number of particles requested at the end of the time series matches that requested at the beginning.
In particular, if <code>T=length(time(object))</code>, then one should have <code>Np[1]==Np[T+1]</code> when <code>Np</code> is furnished as an integer vector and <code>Np(0)==Np(T)</code> when <code>Np</code> is furnished as a function.
</p>


<h3>Methods</h3>

<p>The following methods are available for such an object:
</p>

<dl>
<dt><code><a href="#topic+continue">continue</a></code></dt><dd><p> picks up where <code>mif2</code> leaves off and performs more filtering iterations. </p>
</dd>
<dt><code><a href="#topic+logLik">logLik</a></code></dt><dd><p> returns the so-called <dfn>mif log likelihood</dfn> which is the log likelihood of the perturbed model, not of the focal model itself.
To obtain the latter, it is advisable to run several <code><a href="#topic+pfilter">pfilter</a></code> operations on the result of a <code>mif2</code> computatation.</p>
</dd>
<dt><code><a href="#topic+coef">coef</a></code></dt><dd><p> extracts the point estimate </p>
</dd>
<dt><code><a href="#topic+eff.sample.size">eff.sample.size</a></code></dt><dd><p> extracts the effective sample size of the final filtering iteration</p>
</dd>
</dl>

<p>Various other methods can be applied, including all the methods applicable to a <code><a href="#topic+pfilter">pfilterd_pomp</a></code> object and all other <span class="pkg">pomp</span> estimation algorithms and diagnostic methods.
</p>


<h3>Specifying the perturbations</h3>

<p>The <code>rw.sd</code> function simply returns a list containing its arguments as unevaluated expressions.
These are then evaluated in a context containing the model <code>time</code> variable.
This allows for easy specification of the structure of the perturbations that are to be applied.
For example,
</p>
<pre>
    rw_sd(a=0.05, b=ifelse(time==time[1],0.2,0),
          c=ivp(0.2), d=ifelse(time==time[13],0.2,0),
          e=ivp(0.2,lag=13), f=ifelse(time&lt;23,0.02,0))
</pre>
<p>results in perturbations of parameter <code>a</code> with s.d. 0.05 at every time step, while parameters <code>b</code> and <code>c</code> both get perturbations of s.d. 0.2 only just before the first observation.
Parameters <code>d</code> and <code>e</code>, by contrast, get perturbations of s.d.  0.2 only just before the thirteenth observation.
Finally, parameter <code>f</code> gets a random perturbation of size 0.02 before every observation falling before <code class="reqn">t=23</code>.
</p>
<p>On the <code class="reqn">m</code>-th IF2 iteration, prior to time-point <code class="reqn">n</code>, the <code class="reqn">d</code>-th parameter is given a random increment normally distributed with mean <code class="reqn">0</code> and standard deviation <code class="reqn">c_{m,n} \sigma_{d,n}</code>, where <code class="reqn">c</code> is the cooling schedule and <code class="reqn">\sigma</code> is specified using <code>rw_sd</code>, as described above.
Let <code class="reqn">N</code> be the length of the time series and <code class="reqn">\alpha=</code><code>cooling.fraction.50</code>.
Then, when <code>cooling.type="geometric"</code>, we have </p>
<p style="text-align: center;"><code class="reqn">c_{m,n}=\alpha^{\frac{n-1+(m-1)N}{50N}}.</code>
</p>

<p>When <code>cooling.type="hyperbolic"</code>, we have </p>
<p style="text-align: center;"><code class="reqn">c_{m,n}=\frac{s+1}{s+n+(m-1)N},</code>
</p>
<p> where <code class="reqn">s</code> satisfies </p>
<p style="text-align: center;"><code class="reqn">\frac{s+1}{s+50N}=\alpha.</code>
</p>

<p>Thus, in either case, the perturbations at the end of 50 IF2 iterations are a fraction <code class="reqn">\alpha</code> smaller than they are at first.
</p>


<h3>Re-running IF2 iterations</h3>

<p>To re-run a sequence of IF2 iterations, one can use the <code>mif2</code> method on a &lsquo;mif2d_pomp&rsquo; object.
By default, the same parameters used for the original IF2 run are re-used (except for <code>verbose</code>, the default of which is shown above).
If one does specify additional arguments, these will override the defaults.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King, Edward L. Ionides, Dao Nguyen
</p>


<h3>References</h3>

<p>E.L. Ionides, D. Nguyen, Y. Atchadé, S. Stoev, and A.A. King. Inference for dynamic and latent variable models via iterated, perturbed Bayes maps. <em>Proceedings of the National Academy of Sciences</em> <b>112</b>, 719&ndash;724, 2015.
</p>


<h3>See Also</h3>

<p>More on full-information (i.e., likelihood-based) methods:
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on <span class="pkg">pomp</span> estimation algorithms:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+estimation_algorithms">estimation_algorithms</a></code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>
<p>More on maximization-based estimation methods:
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>,
<code><a href="#topic+traj_match">traj_match</a></code>
</p>

<hr>
<h2 id='nlf'>Nonlinear forecasting</h2><span id='topic+nlf'></span><span id='topic+nlf_objfun'></span><span id='topic+nlf_objfun+2Cmissing-method'></span><span id='topic+nlf_objfun+2CANY-method'></span><span id='topic+nlf_objfun+2Cdata.frame-method'></span><span id='topic+nlf_objfun+2Cpomp-method'></span><span id='topic+nlf_objfun+2Cnlf_objfun-method'></span>

<h3>Description</h3>

<p>Parameter estimation by maximum simulated quasi-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
nlf_objfun(
  data,
  est = character(0),
  lags,
  nrbf = 4,
  ti,
  tf,
  seed = NULL,
  transform.data = identity,
  period = NA,
  tensor = TRUE,
  fail.value = NA_real_,
  params,
  rinit,
  rprocess,
  rmeasure,
  ...,
  verbose = getOption("verbose")
)

## S4 method for signature 'pomp'
nlf_objfun(
  data,
  est = character(0),
  lags,
  nrbf = 4,
  ti,
  tf,
  seed = NULL,
  transform.data = identity,
  period = NA,
  tensor = TRUE,
  fail.value = NA,
  ...,
  verbose = getOption("verbose")
)

## S4 method for signature 'nlf_objfun'
nlf_objfun(
  data,
  est,
  lags,
  nrbf,
  ti,
  tf,
  seed = NULL,
  period,
  tensor,
  transform.data,
  fail.value,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlf_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="nlf_+3A_est">est</code></td>
<td>
<p>character vector; the names of parameters to be estimated.</p>
</td></tr>
<tr><td><code id="nlf_+3A_lags">lags</code></td>
<td>
<p>A vector specifying the lags to use when constructing the nonlinear autoregressive prediction model.
The first lag is the prediction interval.</p>
</td></tr>
<tr><td><code id="nlf_+3A_nrbf">nrbf</code></td>
<td>
<p>integer scalar;
the number of radial basis functions to be used at each lag.</p>
</td></tr>
<tr><td><code id="nlf_+3A_ti">ti</code>, <code id="nlf_+3A_tf">tf</code></td>
<td>
<p>required numeric values.
NLF works by generating simulating long time series from the model.
The simulated time series will be from <code>ti</code> to <code>tf</code>, with the same sampling frequency as the data.
<code>ti</code> should be chosen large enough so that transient dynamics have died away.
<code>tf</code> should be chosen large enough so that sufficiently many data points are available to estimate the nonlinear forecasting model well.
An error will be generated unless the data-to-parameter ratio exceeds 10 and
a warning will be given if the ratio is smaller than 30.</p>
</td></tr>
<tr><td><code id="nlf_+3A_seed">seed</code></td>
<td>
<p>integer.
When fitting, it is often best to fix the seed of the random-number generator (RNG).
This is accomplished by setting <code>seed</code> to an integer.
By default, <code>seed = NULL</code>, which does not alter the RNG state.</p>
</td></tr>
<tr><td><code id="nlf_+3A_transform.data">transform.data</code></td>
<td>
<p>optional function.
If specified, forecasting is performed using data and model simulations transformed by this function.
By default, <code>transform.data</code> is the identity function,
i.e., no transformation is performed.
The main purpose of <code>transform.data</code> is to achieve approximately multivariate normal forecasting errors.
If the data are univariate, <code>transform.data</code> should take a scalar and return a scalar.
If the data are multivariate, <code>transform.data</code> should assume a vector input and return a vector of the same length.</p>
</td></tr>
<tr><td><code id="nlf_+3A_period">period</code></td>
<td>
<p>numeric; <code>period=NA</code> means the model is nonseasonal.
<code>period &gt; 0</code> is the period of seasonal forcing.
<code>period &lt;= 0</code> is equivalent to <code>period = NA</code>.</p>
</td></tr>
<tr><td><code id="nlf_+3A_tensor">tensor</code></td>
<td>
<p>logical;
if FALSE, the fitted model is a generalized additive model with time mod period as one of the predictors,
i.e., a gam with time-varying intercept.
If TRUE, the fitted model is a gam with lagged state variables as predictors and time-periodic coefficients, constructed using tensor products of basis functions of state variables with basis
functions of time.</p>
</td></tr>
<tr><td><code id="nlf_+3A_fail.value">fail.value</code></td>
<td>
<p>optional numeric scalar;
if non-<code>NA</code>, this value is substituted for non-finite values of the objective function.
It should be a large number (i.e., bigger than any legitimate values the objective function is likely to take).</p>
</td></tr>
<tr><td><code id="nlf_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="nlf_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="nlf_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="nlf_+3A_rmeasure">rmeasure</code></td>
<td>
<p>simulator of the measurement model, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rmeasure=NULL</code> removes the measurement model simulator.
For more information, see <a href="#topic+rmeasure_spec">rmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="nlf_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="nlf_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nonlinear forecasting (NLF) is an &lsquo;indirect inference&rsquo; method.
The NLF approximation to the log likelihood of the data series is computed by simulating data from a model, fitting a nonlinear autoregressive model to the simulated time series, and quantifying the ability of the resulting fitted model to predict the data time series.
The nonlinear autoregressive model is implemented as a generalized additive model (GAM), conditional on lagged values, for each observation variable.
The errors are assumed multivariate normal.
</p>
<p>The NLF objective function constructed by <code>nlf_objfun</code> simulates long time series (<code>nasymp</code> is the number of observations in the simulated times series), perhaps after allowing for a transient period (<code>ntransient</code> steps).
It then fits the GAM for the chosen lags to the simulated time series.
Finally, it computes the quasi-likelihood of the data under the fitted GAM.
</p>
<p>NLF assumes that the observation frequency (equivalently the time between successive observations) is uniform.
</p>


<h3>Value</h3>

<p><code>nlf_objfun</code> constructs a stateful objective function for NLF estimation.
Specfically, <code>nlf_objfun</code> returns an object of class &lsquo;nlf_objfun&rsquo;, which is a function suitable for use in an <code><a href="stats.html#topic+optim">optim</a></code>-like optimizer.
In particular, this function takes a single numeric-vector argument that is assumed to contain the parameters named in <code>est</code>, in that order.
When called, it will return the negative log quasilikelihood.
It is a stateful function:
Each time it is called, it will remember the values of the parameters and its estimate of the log quasilikelihood.
</p>


<h3>Periodically-forced systems (seasonality)</h3>

<p>Unlike other <span class="pkg">pomp</span> estimation methods, NLF cannot accommodate general time-dependence in the model via explicit time-dependence or dependence on time-varying covariates.
However, NLF can accommodate periodic forcing.
It does this by including forcing phase as a predictor in the nonlinear autoregressive model.
To accomplish this, one sets <code>period</code> to the period of the forcing (a positive numerical value).
In this case, if <code>tensor = FALSE</code>, the effect is to add a periodic intercept in the autoregressive model.
If <code>tensor = TRUE</code>, by contrast, the fitted model includes time-periodic coefficients,
constructed using tensor products of basis functions of observables with
basis functions of time.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Important Note</h3>

<p>Since <span class="pkg">pomp</span> cannot guarantee that the <em>final</em> call an optimizer makes to the function is a call <em>at</em> the optimum, it cannot guarantee that the parameters stored in the function are the optimal ones.
Therefore, it is a good idea to evaluate the function on the parameters returned by the optimization routine, which will ensure that these parameters are stored.
</p>


<h3>Warning! Objective functions based on C snippets</h3>

<p>If you use C snippets (see <code><a href="#topic+Csnippet">Csnippet</a></code>), a dynamically loadable library will be built.
As a rule, <span class="pkg">pomp</span> functions load this library as needed and unload it when it is no longer needed.
The stateful objective functions are an exception to this rule.
For efficiency, calls to the objective function do not execute <code><a href="#topic+pompLoad">pompLoad</a></code> or <code><a href="#topic+pompUnload">pompUnload</a></code>:
rather, it is assumed that <code><a href="#topic+pompLoad">pompLoad</a></code> has been called before any call to the objective function.
When a stateful objective function using one or more C snippets is created, <code><a href="#topic+pompLoad">pompLoad</a></code> is called internally to build and load the library:
therefore, within a single <span class="rlang"><b>R</b></span> session, if one creates a stateful objective function, one can freely call that objective function and (more to the point) pass it to an optimizer that calls it freely, without needing to call <code><a href="#topic+pompLoad">pompLoad</a></code>.
On the other hand, if one retrieves a stored objective function from a file, or passes one to another <span class="rlang"><b>R</b></span> session, one must call <code><a href="#topic+pompLoad">pompLoad</a></code> before using it.
<strong>Failure to do this will typically result in a segmentation fault (i.e., it will crash the <span class="rlang"><b>R</b></span> session).</strong>
</p>


<h3>Author(s)</h3>

<p>Stephen P. Ellner, Bruce E. Kendall, Aaron A. King
</p>


<h3>References</h3>

<p>S.P. Ellner, B.A. Bailey, G.V. Bobashev, A.R. Gallant, B.T. Grenfell, and D.W. Nychka. Noise and nonlinearity in measles epidemics: combining mechanistic and statistical approaches to population modeling. <em>American Naturalist</em> <b>151</b>, 425&ndash;440, 1998.
</p>
<p>B.E. Kendall, C.J. Briggs, W.W. Murdoch, P. Turchin, S.P. Ellner, E. McCauley, R.M. Nisbet, and S.N. Wood. Why do populations cycle? A synthesis of statistical and mechanistic modeling approaches. <em>Ecology</em> <b>80</b>, 1789&ndash;1805, 1999.
</p>
<p>B.E. Kendall, S.P. Ellner, E. McCauley, S.N. Wood, C.J. Briggs, W.W. Murdoch, and P. Turchin. Population cycles in the pine looper moth (<em>Bupalus piniarius</em>): dynamical tests of mechanistic hypotheses. <em>Ecological Monographs</em> <b>75</b> 259&ndash;276, 2005.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code> <code><a href="subplex.html#topic+subplex">subplex</a></code> <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>
</p>
<p>More on <span class="pkg">pomp</span> estimation algorithms:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+estimation_algorithms">estimation_algorithms</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>
<p>More on methods based on summary statistics: 
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+basic_probes">basic_probes</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>
<p>More on maximization-based estimation methods:
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>,
<code><a href="#topic+traj_match">traj_match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  if (require(subplex)) {

    ricker() |&gt;
      nlf_objfun(est=c("r","sigma","N_0"),lags=c(4,6),
        partrans=parameter_trans(log=c("r","sigma","N_0")),
        paramnames=c("r","sigma","N_0"),
        ti=100,tf=2000,seed=426094906L) -&gt; m1

    subplex(par=log(c(20,0.5,5)),fn=m1,control=list(reltol=1e-4)) -&gt; out

    m1(out$par)
    coef(m1)
    plot(simulate(m1))

  }

</code></pre>

<hr>
<h2 id='objfun'>Objective functions</h2><span id='topic+objfun'></span>

<h3>Description</h3>

<p>Methods common to <span class="pkg">pomp</span> stateful objective functions
</p>


<h3>Important Note</h3>

<p>Since <span class="pkg">pomp</span> cannot guarantee that the <em>final</em> call an optimizer makes to the function is a call <em>at</em> the optimum, it cannot guarantee that the parameters stored in the function are the optimal ones.
Therefore, it is a good idea to evaluate the function on the parameters returned by the optimization routine, which will ensure that these parameters are stored.
</p>


<h3>Warning! Objective functions based on C snippets</h3>

<p>If you use C snippets (see <code><a href="#topic+Csnippet">Csnippet</a></code>), a dynamically loadable library will be built.
As a rule, <span class="pkg">pomp</span> functions load this library as needed and unload it when it is no longer needed.
The stateful objective functions are an exception to this rule.
For efficiency, calls to the objective function do not execute <code><a href="#topic+pompLoad">pompLoad</a></code> or <code><a href="#topic+pompUnload">pompUnload</a></code>:
rather, it is assumed that <code><a href="#topic+pompLoad">pompLoad</a></code> has been called before any call to the objective function.
When a stateful objective function using one or more C snippets is created, <code><a href="#topic+pompLoad">pompLoad</a></code> is called internally to build and load the library:
therefore, within a single <span class="rlang"><b>R</b></span> session, if one creates a stateful objective function, one can freely call that objective function and (more to the point) pass it to an optimizer that calls it freely, without needing to call <code><a href="#topic+pompLoad">pompLoad</a></code>.
On the other hand, if one retrieves a stored objective function from a file, or passes one to another <span class="rlang"><b>R</b></span> session, one must call <code><a href="#topic+pompLoad">pompLoad</a></code> before using it.
<strong>Failure to do this will typically result in a segmentation fault (i.e., it will crash the <span class="rlang"><b>R</b></span> session).</strong>
</p>

<hr>
<h2 id='obs'>obs</h2><span id='topic+obs'></span><span id='topic+obs+2CANY-method'></span><span id='topic+obs+2Cmissing-method'></span><span id='topic+obs+2Cpomp-method'></span><span id='topic+obs+2Clistie-method'></span>

<h3>Description</h3>

<p>Extract the data array from a &lsquo;pomp&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
obs(object, vars, ..., format = c("array", "data.frame"))

## S4 method for signature 'listie'
obs(object, vars, ..., format = c("array", "data.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obs_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class extending &lsquo;pomp&rsquo;</p>
</td></tr>
<tr><td><code id="obs_+3A_vars">vars</code></td>
<td>
<p>names of variables to retrieve</p>
</td></tr>
<tr><td><code id="obs_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="obs_+3A_format">format</code></td>
<td>
<p>format of the returned object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='ou2'>Two-dimensional discrete-time Ornstein-Uhlenbeck process</h2><span id='topic+ou2'></span>

<h3>Description</h3>

<p><code>ou2()</code> constructs a &lsquo;pomp&rsquo; object encoding a bivariate discrete-time Ornstein-Uhlenbeck process with noisy observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ou2(
  alpha_1 = 0.8,
  alpha_2 = -0.5,
  alpha_3 = 0.3,
  alpha_4 = 0.9,
  sigma_1 = 3,
  sigma_2 = -0.5,
  sigma_3 = 2,
  tau = 1,
  x1_0 = -3,
  x2_0 = 4,
  times = 1:100,
  t0 = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ou2_+3A_alpha_1">alpha_1</code>, <code id="ou2_+3A_alpha_2">alpha_2</code>, <code id="ou2_+3A_alpha_3">alpha_3</code>, <code id="ou2_+3A_alpha_4">alpha_4</code></td>
<td>
<p>entries of the <code class="reqn">\alpha</code> matrix, in column-major order.
That is, <code>alpha_2</code> is in the lower-left position.</p>
</td></tr>
<tr><td><code id="ou2_+3A_sigma_1">sigma_1</code>, <code id="ou2_+3A_sigma_2">sigma_2</code>, <code id="ou2_+3A_sigma_3">sigma_3</code></td>
<td>
<p>entries of the lower-triangular <code class="reqn">\sigma</code> matrix.
<code>sigma_2</code> is the entry in the lower-left position.</p>
</td></tr>
<tr><td><code id="ou2_+3A_tau">tau</code></td>
<td>
<p>measurement error s.d.</p>
</td></tr>
<tr><td><code id="ou2_+3A_x1_0">x1_0</code>, <code id="ou2_+3A_x2_0">x2_0</code></td>
<td>
<p>latent variable values at time <code>t0</code></p>
</td></tr>
<tr><td><code id="ou2_+3A_times">times</code></td>
<td>
<p>vector of observation times</p>
</td></tr>
<tr><td><code id="ou2_+3A_t0">t0</code></td>
<td>
<p>the zero time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the state process is <code class="reqn">X(t) = (X_{1}(t),X_{2}(t))</code>, then
</p>
<p style="text-align: center;"><code class="reqn">X(t+1) = \alpha X(t) + \sigma \epsilon(t),</code>
</p>

<p>where <code class="reqn">\alpha</code> and <code class="reqn">\sigma</code> are 2x2 matrices,
<code class="reqn">\sigma</code> is lower-triangular, and
<code class="reqn">\epsilon(t)</code> is standard bivariate normal.
The observation process is <code class="reqn">Y(t) = (Y_1(t),Y_2(t))</code>, where
<code class="reqn">Y_i(t) \sim \mathrm{normal}(X_i(t),\tau)</code>.
</p>


<h3>Value</h3>

<p>A &lsquo;pomp&rsquo; object with simulated data.
</p>


<h3>See Also</h3>

<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+compartmental_models">compartmental_models</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+gompertz">gompertz</a>()</code>,
<code><a href="#topic+pomp_examples">pomp_examples</a></code>,
<code><a href="#topic+ricker">ricker</a>()</code>,
<code><a href="#topic+rw2">rw2</a>()</code>,
<code><a href="#topic+verhulst">verhulst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>po &lt;- ou2()
plot(po)
coef(po)
x &lt;- simulate(po)
plot(x)
pf &lt;- pfilter(po,Np=1000)
logLik(pf)
</code></pre>

<hr>
<h2 id='parameter_trans'>parameter transformations</h2><span id='topic+parameter_trans'></span><span id='topic+parameter_trans+2Cmissing+2Cmissing-method'></span><span id='topic+parameter_trans+2CANY+2CANY-method'></span><span id='topic+parameter_trans+2CANY+2Cmissing-method'></span><span id='topic+parameter_trans+2CNULL+2CNULL-method'></span><span id='topic+parameter_trans+2Cmissing+2CANY-method'></span><span id='topic+parameter_trans+2Cpomp_fun+2Cpomp_fun-method'></span><span id='topic+parameter_trans+2CCsnippet+2CCsnippet-method'></span><span id='topic+parameter_trans+2Ccharacter+2Ccharacter-method'></span><span id='topic+parameter_trans+2Cfunction+2Cfunction-method'></span>

<h3>Description</h3>

<p>Equipping models with parameter transformations to facilitate searches in constrained parameter spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameter_trans(toEst, fromEst, ...)

## S4 method for signature 'NULL,NULL'
parameter_trans(toEst, fromEst, ...)

## S4 method for signature 'pomp_fun,pomp_fun'
parameter_trans(toEst, fromEst, ...)

## S4 method for signature 'Csnippet,Csnippet'
parameter_trans(toEst, fromEst, ..., log, logit, barycentric)

## S4 method for signature 'character,character'
parameter_trans(toEst, fromEst, ...)

## S4 method for signature 'function,function'
parameter_trans(toEst, fromEst, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameter_trans_+3A_toest">toEst</code>, <code id="parameter_trans_+3A_fromest">fromEst</code></td>
<td>
<p>procedures that perform transformation of model parameters to and from the estimation scale, respectively.
These can be furnished using C snippets, <span class="rlang"><b>R</b></span> functions, or via procedures in an external, dynamically loaded library.</p>
</td></tr>
<tr><td><code id="parameter_trans_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="parameter_trans_+3A_log">log</code></td>
<td>
<p>names of parameters to be log transformed.</p>
</td></tr>
<tr><td><code id="parameter_trans_+3A_logit">logit</code></td>
<td>
<p>names of parameters to be logit transformed.</p>
</td></tr>
<tr><td><code id="parameter_trans_+3A_barycentric">barycentric</code></td>
<td>
<p>names of parameters to be collectively transformed according to the log barycentric transformation.
<strong>Important note:</strong> variables to be log-barycentrically transformed <em>must be adjacent</em> in the parameter vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When parameter transformations are desired, they can be integrated into the &lsquo;pomp&rsquo; object via the <code>partrans</code> arguments using the <code>parameter_trans</code> function.
As with the other <a href="#topic+basic_components">basic model components</a>, these should ordinarily be specified using C snippets.
When doing so, note that:
</p>

<ol>
<li><p> The parameter transformation mapping a parameter vector from the scale used by the model codes to another scale, and the inverse transformation, are specified via a call to </p>
<pre>parameter_trans(toEst,fromEst)</pre><p>.
</p>
</li>
<li><p> The goal of these snippets is the transformation of the parameters from the natural scale to the estimation scale, and vice-versa.
If <code>p</code> is the name of a variable on the natural scale, its value on the estimation scale is <code>T_p</code>.
Thus the <code>toEst</code> snippet computes <code>T_p</code> given <code>p</code> whilst the <code>fromEst</code> snippet computes <code>p</code> given <code>T_p</code>.
</p>
</li>
<li><p> Time-, state-, and covariate-dependent transformations are not allowed.
Therefore, neither the time, nor any state variables, nor any of the covariates will be available in the context within which a parameter transformation snippet is executed.
</p>
</li></ol>

<p>These transformations can also be specified using <span class="rlang"><b>R</b></span> functions with arguments chosen from among the parameters.
Such an <span class="rlang"><b>R</b></span> function must also have the argument &lsquo;<code>...</code>&rsquo;.
In this case, <code>toEst</code> should transform parameters from the scale that the basic components use internally to the scale used in estimation.
<code>fromEst</code> should be the inverse of <code>toEst</code>.
</p>
<p>Note that it is the user's responsibility to make sure that the transformations are mutually inverse.
If <code>obj</code> is the constructed &lsquo;pomp&rsquo; object, and <code>coef(obj)</code> is non-empty, a simple check of this property is </p>
<pre>
  x &lt;- coef(obj, transform = TRUE)
  obj1 &lt;- obj
  coef(obj1, transform = TRUE) &lt;- x
  identical(coef(obj), coef(obj1))
  identical(coef(obj1, transform=TRUE), x)</pre>
<p>One can use the <code>log</code> and <code>logit</code> arguments of <code>parameter_trans</code> to name variables that should be log-transformed or logit-transformed, respectively.
The <code>barycentric</code> argument can name sets of parameters that should be log-barycentric transformed.
</p>
<p>Note that using the <code>log</code>, <code>logit</code>, or <code>barycentric</code> arguments causes C snippets to be generated.
Therefore, you must make sure that variables named in any of these arguments are also mentioned in <code>paramnames</code> at the same time.
</p>
<p>The logit transform is defined by
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{logit}(\theta)=\log\frac{\theta}{1-\theta}.</code>
</p>

<p>The log barycentric transformation of variables <code class="reqn">\theta_1,\dots,\theta_n</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{logbarycentric}(\theta_1,\dots,\theta_n)=\left(\log\frac{\theta_1}{\sum_i \theta_i},\dots,\log\frac{\theta_n}{\sum_i \theta_i}\right).</code>
</p>



<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partrans">partrans</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>

<hr>
<h2 id='parmat'>Create a matrix of parameters</h2><span id='topic+parmat'></span><span id='topic+parmat+2Cmissing-method'></span><span id='topic+parmat+2CANY-method'></span><span id='topic+parmat+2Cnumeric-method'></span><span id='topic+parmat+2Carray-method'></span><span id='topic+parmat+2Cdata.frame-method'></span>

<h3>Description</h3>

<p><code>parmat</code> is a utility that makes a vector of parameters suitable for
use in <span class="pkg">pomp</span> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parmat(params, ...)

## S4 method for signature 'numeric'
parmat(params, nrep = 1, ..., names = NULL)

## S4 method for signature 'array'
parmat(params, nrep = 1, ..., names = NULL)

## S4 method for signature 'data.frame'
parmat(params, nrep = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parmat_+3A_params">params</code></td>
<td>
<p>named numeric vector or matrix of parameters.</p>
</td></tr>
<tr><td><code id="parmat_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored.</p>
</td></tr>
<tr><td><code id="parmat_+3A_nrep">nrep</code></td>
<td>
<p>number of replicates (columns) desired.</p>
</td></tr>
<tr><td><code id="parmat_+3A_names">names</code></td>
<td>
<p>optional character; column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parmat</code> returns a matrix consisting of <code>nrep</code> copies of
<code>params</code>.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # takes too long for R CMD check
  ## generate a bifurcation diagram for the Ricker map
  p &lt;- parmat(coef(ricker()),nrep=500)
  p["r",] &lt;- exp(seq(from=1.5,to=4,length=500))
  trajectory(
    ricker(),
    times=seq(from=1000,to=2000,by=1),
    params=p,
    format="array"
  ) -&gt; x
  matplot(p["r",],x["N",,],pch='.',col='black',
    xlab=expression(log(r)),ylab="N",log='x')

</code></pre>

<hr>
<h2 id='partrans'>partrans workhorse</h2><span id='topic+partrans'></span><span id='topic+partrans+2CANY-method'></span><span id='topic+partrans+2Cmissing-method'></span><span id='topic+partrans+2Cpomp-method'></span><span id='topic+partrans+2Cobjfun-method'></span>

<h3>Description</h3>

<p>Performs parameter transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
partrans(object, params, dir = c("fromEst", "toEst"), ...)

## S4 method for signature 'objfun'
partrans(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partrans_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="partrans_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="partrans_+3A_dir">dir</code></td>
<td>
<p>the direction of the transformation to perform.</p>
</td></tr>
<tr><td><code id="partrans_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>dir=fromEst</code>, the parameters in <code>params</code> are assumed to be on the estimation scale and are transformed onto the natural scale.
If <code>dir=toEst</code>, they are transformed onto the estimation scale.
In both cases, the parameters are returned as a named numeric vector or an array with rownames, as appropriate.
</p>


<h3>See Also</h3>

<p>Specification of parameter transformations: <code><a href="#topic+parameter_trans">parameter_trans</a></code>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>

<hr>
<h2 id='parus'>Parus major population dynamics</h2><span id='topic+parus'></span>

<h3>Description</h3>

<p>Size of a population of great tits (<em>Parus major</em>) from Wytham Wood, near Oxford.
</p>


<h3>Details</h3>

<p>Provenance: Global Population Dynamics Database dataset #10163.
(NERC Centre for Population Biology, Imperial College (2010)
The Global Population Dynamics Database Version 2.
<a href="https://www.imperial.ac.uk/cpb/gpdd2/">https://www.imperial.ac.uk/cpb/gpdd2/</a>).
Original source: McCleer and Perrins (1991).
</p>


<h3>References</h3>

<p>R. McCleery and C. Perrins. Effects of predation on the numbers of Great Tits, <em>Parus major</em>. In: C.M. Perrins, J.-D. Lebreton, and G.J.M. Hirons (eds.), <em>Bird Population Studies</em>, pp. 129&ndash;147, Oxford. Univ. Press, 1991.
</p>


<h3>See Also</h3>

<p>More data sets provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+bsflu">bsflu</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # takes too long for R CMD check
  parus |&gt;
    pfilter(Np=1000,times="year",t0=1960,
      params=c(K=190,r=2.7,sigma=0.2,theta=0.05,N.0=148),
      rprocess=discrete_time(
        function (r, K, sigma, N, ...) {
          e &lt;- rnorm(n=1,mean=0,sd=sigma)
          c(N = exp(log(N)+r*(1-N/K)+e))
        },
        delta.t=1
      ),
      rmeasure=function (N, theta, ...) {
        c(pop=rnbinom(n=1,size=1/theta,mu=N+1e-10))
      },
      dmeasure=function (pop, N, theta, ..., log) {
        dnbinom(x=pop,mu=N+1e-10,size=1/theta,log=log)
      },
      partrans=parameter_trans(log=c("sigma","theta","N_0","r","K")),
      paramnames=c("sigma","theta","N_0","r","K")
    ) -&gt; pf

  pf |&gt; logLik()

  pf |&gt; simulate() |&gt; plot()

</code></pre>

<hr>
<h2 id='pfilter'>Particle filter</h2><span id='topic+pfilter'></span><span id='topic+pfilter+2CANY-method'></span><span id='topic+pfilter+2Cmissing-method'></span><span id='topic+pfilter+2Cdata.frame-method'></span><span id='topic+pfilter+2Cpomp-method'></span><span id='topic+pfilter+2Cpfilterd_pomp-method'></span><span id='topic+pfilter+2Cobjfun-method'></span>

<h3>Description</h3>

<p>A plain vanilla sequential Monte Carlo (particle filter) algorithm.
Resampling is performed at each observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
pfilter(
  data,
  Np,
  params,
  rinit,
  rprocess,
  dmeasure,
  pred.mean = FALSE,
  pred.var = FALSE,
  filter.mean = FALSE,
  filter.traj = FALSE,
  save.states = c("no", "weighted", "unweighted", "FALSE", "TRUE"),
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
pfilter(
  data,
  Np,
  pred.mean = FALSE,
  pred.var = FALSE,
  filter.mean = FALSE,
  filter.traj = FALSE,
  save.states = c("no", "weighted", "unweighted", "FALSE", "TRUE"),
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pfilterd_pomp'
pfilter(data, Np, ..., verbose = getOption("verbose", FALSE))

## S4 method for signature 'objfun'
pfilter(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfilter_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_np">Np</code></td>
<td>
<p>the number of particles to use.
This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
Alternatively, if one wishes the number of particles to vary across timesteps, one may specify <code>Np</code> either as a vector of positive integers of length </p>
<pre>length(time(object,t0=TRUE))</pre><p> or as a function taking a positive integer argument.
In the latter case, <code>Np(k)</code> must be a single positive integer, representing the number of particles to be used at the <code>k</code>-th timestep:
<code>Np(0)</code> is the number of particles to use going from <code>timezero(object)</code> to <code>time(object)[1]</code>,
<code>Np(1)</code>, from <code>timezero(object)</code> to <code>time(object)[1]</code>,
and so on,
while when <code>T=length(time(object))</code>, <code>Np(T)</code> is the number of particles to sample at the end of the time-series.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_dmeasure">dmeasure</code></td>
<td>
<p>evaluator of the measurement model density, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>dmeasure=NULL</code> removes the measurement density evaluator.
For more information, see <a href="#topic+dmeasure_spec">dmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_pred.mean">pred.mean</code></td>
<td>
<p>logical; if <code>TRUE</code>, the prediction means are calculated for the state variables and parameters.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_pred.var">pred.var</code></td>
<td>
<p>logical; if <code>TRUE</code>, the prediction variances are calculated for the state variables and parameters.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_filter.mean">filter.mean</code></td>
<td>
<p>logical; if <code>TRUE</code>, the filtering means are calculated for the state variables and parameters.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_filter.traj">filter.traj</code></td>
<td>
<p>logical; if <code>TRUE</code>, a filtered trajectory is returned for the state variables and parameters.
See <code><a href="#topic+filter_traj">filter_traj</a></code> for more information.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_save.states">save.states</code></td>
<td>
<p>character;
If <code>save.states="unweighted"</code>, the state-vector for each unweighted particle at each time is saved.
If <code>save.states="weighted"</code>, the state-vector for each weighted particle at each time is saved, along with the corresponding weight.
If <code>save.states="no"</code>, information on the latent states is not saved.
<code>"FALSE"</code> is a synonym for <code>"no"</code> and <code>"TRUE"</code> is a synonym for <code>"unweighted"</code>.
To retrieve the saved states, applying <code><a href="#topic+saved.states">saved.states</a></code> to the result of the <code>pfilter</code> computation.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;pfilterd_pomp&rsquo;, which extends class &lsquo;pomp&rsquo;.
Information can be extracted from this object using the methods documented below.
</p>


<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+logLik">logLik</a></code></dt><dd><p> the estimated log likelihood  </p>
</dd>
<dt><code><a href="#topic+cond_logLik">cond_logLik</a></code></dt><dd><p> the estimated conditional log likelihood </p>
</dd>
<dt><code><a href="#topic+eff_sample_size">eff_sample_size</a></code></dt><dd>
<p>the (time-dependent) estimated effective sample size </p>
</dd>
<dt><code><a href="#topic+pred_mean">pred_mean</a></code>, <code><a href="#topic+pred_var">pred_var</a></code></dt><dd><p> the mean and variance of the approximate prediction distribution </p>
</dd>
<dt><code><a href="#topic+filter_mean">filter_mean</a></code></dt><dd><p> the mean of the filtering distribution </p>
</dd>
<dt><code><a href="#topic+filter_traj">filter_traj</a></code></dt><dd>
<p>retrieve one particle trajectory.
Useful for building up the smoothing distribution.
</p>
</dd>
<dt><code><a href="#topic+saved_states">saved_states</a></code></dt><dd><p>retrieve saved states</p>
</dd>
<dt><code><a href="#topic+as.data.frame">as.data.frame</a></code></dt><dd><p>coerce to a data frame</p>
</dd>
<dt><code><a href="#topic+plot">plot</a></code></dt><dd><p>diagnostic plots</p>
</dd>
</dl>



<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>M.S. Arulampalam, S. Maskell, N. Gordon, and T. Clapp. A tutorial on particle filters for online nonlinear, non-Gaussian Bayesian tracking. <em>IEEE Transactions on Signal Processing</em> <b>50</b>, 174&ndash;188, 2002.
</p>
<p>A. Bhadra and E.L. Ionides. Adaptive particle allocation in iterated sequential Monte Carlo via approximating meta-models. <em>Statistics and Computing</em> <b>26</b>, 393&ndash;407, 2016.
</p>


<h3>See Also</h3>

<p>More on <span class="pkg">pomp</span> elementary algorithms: 
<code><a href="#topic+elementary_algorithms">elementary_algorithms</a></code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on full-information (i.e., likelihood-based) methods:
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pf &lt;- pfilter(gompertz(),Np=1000)	## use 1000 particles

plot(pf)
logLik(pf)
cond_logLik(pf)			## conditional log-likelihoods
eff_sample_size(pf)             ## effective sample size
logLik(pfilter(pf))      	## run it again with 1000 particles

## run it again with 2000 particles
pf &lt;- pfilter(pf,Np=2000,filter.mean=TRUE,filter.traj=TRUE,save.states="weighted")
fm &lt;- filter_mean(pf) ## extract the filtering means
ft &lt;- filter_traj(pf) ## one draw from the smoothing distribution
ss &lt;- saved_states(pf,format="d") ## the latent-state portion of each particle

as(pf,"data.frame") |&gt; head()
</code></pre>

<hr>
<h2 id='plot'>pomp plotting facilities</h2><span id='topic+plot'></span><span id='topic+plot+2Cmissing-method'></span><span id='topic+plot+2Cpomp_plottable-method'></span><span id='topic+plot+2Cpomp-method'></span><span id='topic+plot+2CPmcmc-method'></span><span id='topic+plot+2CAbc-method'></span><span id='topic+plot+2CMif2-method'></span><span id='topic+plot+2Cprobed_pomp-method'></span><span id='topic+plot+2Cspectd_pomp-method'></span><span id='topic+plot+2Cbsmcd_pomp-method'></span><span id='topic+plot+2Cprobe_match_objfun-method'></span><span id='topic+plot+2Cspect_match_objfun-method'></span>

<h3>Description</h3>

<p>Diagnostic plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp_plottable'
plot(
  x,
  variables,
  panel = lines,
  nc = NULL,
  yax.flip = FALSE,
  mar = c(0, 5.1, 0, if (yax.flip) 5.1 else 2.1),
  oma = c(6, 0, 5, 0),
  axes = TRUE,
  ...
)

## S4 method for signature 'Pmcmc'
plot(x, ..., pars)

## S4 method for signature 'Abc'
plot(x, ..., pars, scatter = FALSE)

## S4 method for signature 'Mif2'
plot(x, ..., pars, transform = FALSE)

## S4 method for signature 'probed_pomp'
plot(x, y, ...)

## S4 method for signature 'spectd_pomp'
plot(
  x,
  ...,
  max.plots.per.page = 4,
  plot.data = TRUE,
  quantiles = c(0.025, 0.25, 0.5, 0.75, 0.975),
  quantile.styles = list(lwd = 1, lty = 1, col = "gray70"),
  data.styles = list(lwd = 2, lty = 2, col = "black")
)

## S4 method for signature 'bsmcd_pomp'
plot(x, pars, thin, ...)

## S4 method for signature 'probe_match_objfun'
plot(x, y, ...)

## S4 method for signature 'spect_match_objfun'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>the object to plot</p>
</td></tr>
<tr><td><code id="plot_+3A_variables">variables</code></td>
<td>
<p>optional character; names of variables to be displayed</p>
</td></tr>
<tr><td><code id="plot_+3A_panel">panel</code></td>
<td>
<p>function of the form <code>panel(x, col, bg, pch, type, ...)</code> which gives the action to be carried out in each panel of the display.</p>
</td></tr>
<tr><td><code id="plot_+3A_nc">nc</code></td>
<td>
<p>the number of columns to use.
Defaults to 1 for up to 4 series, otherwise to 2.</p>
</td></tr>
<tr><td><code id="plot_+3A_yax.flip">yax.flip</code></td>
<td>
<p>logical;
if TRUE, the y-axis (ticks and numbering) should flip from side 2 (left) to 4 (right) from series to series.</p>
</td></tr>
<tr><td><code id="plot_+3A_mar">mar</code>, <code id="plot_+3A_oma">oma</code></td>
<td>
<p>the <code><a href="graphics.html#topic+par">par</a></code> <code>mar</code> and <code>oma</code> settings.
Modify with care!</p>
</td></tr>
<tr><td><code id="plot_+3A_axes">axes</code></td>
<td>
<p>logical; indicates if x- and y- axes should be drawn</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>ignored or passed to low-level plotting functions</p>
</td></tr>
<tr><td><code id="plot_+3A_pars">pars</code></td>
<td>
<p>names of parameters.</p>
</td></tr>
<tr><td><code id="plot_+3A_scatter">scatter</code></td>
<td>
<p>logical; if <code>FALSE</code>, traces of the parameters named in <code>pars</code> will be plotted against ABC iteration number.
If <code>TRUE</code>, the traces will be displayed or as a scatterplot.</p>
</td></tr>
<tr><td><code id="plot_+3A_transform">transform</code></td>
<td>
<p>logical; should the parameter be transformed onto the estimation scale?</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="plot_+3A_max.plots.per.page">max.plots.per.page</code></td>
<td>
<p>positive integer; maximum number of plots on a page</p>
</td></tr>
<tr><td><code id="plot_+3A_plot.data">plot.data</code></td>
<td>
<p>logical; should the data spectrum be included?</p>
</td></tr>
<tr><td><code id="plot_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric; quantiles to display</p>
</td></tr>
<tr><td><code id="plot_+3A_quantile.styles">quantile.styles</code></td>
<td>
<p>list; plot styles to use for quantiles</p>
</td></tr>
<tr><td><code id="plot_+3A_data.styles">data.styles</code></td>
<td>
<p>list; plot styles to use for data</p>
</td></tr>
<tr><td><code id="plot_+3A_thin">thin</code></td>
<td>
<p>integer; when the number of samples is very large, it can be helpful to plot a random subsample:
<code>thin</code> specifies the size of this subsample.</p>
</td></tr>
</table>

<hr>
<h2 id='pmcmc'>The particle Markov chain Metropolis-Hastings algorithm</h2><span id='topic+pmcmc'></span><span id='topic+pmcmc+2CANY-method'></span><span id='topic+pmcmc+2Cmissing-method'></span><span id='topic+pmcmc+2Cdata.frame-method'></span><span id='topic+pmcmc+2Cpomp-method'></span><span id='topic+pmcmc+2Cpfilterd_pomp-method'></span><span id='topic+pmcmc+2Cpmcmcd_pomp-method'></span>

<h3>Description</h3>

<p>The Particle MCMC algorithm for estimating the parameters of a
partially-observed Markov process.  Running <code>pmcmc</code> causes a particle
random-walk Metropolis-Hastings Markov chain algorithm to run for the
specified number of proposals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
pmcmc(
  data,
  Nmcmc = 1,
  proposal,
  Np,
  params,
  rinit,
  rprocess,
  dmeasure,
  dprior,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
pmcmc(
  data,
  Nmcmc = 1,
  proposal,
  Np,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pfilterd_pomp'
pmcmc(
  data,
  Nmcmc = 1,
  proposal,
  Np,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pmcmcd_pomp'
pmcmc(data, Nmcmc, proposal, ..., verbose = getOption("verbose", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmcmc_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="pmcmc_+3A_nmcmc">Nmcmc</code></td>
<td>
<p>The number of PMCMC iterations to perform.</p>
</td></tr>
<tr><td><code id="pmcmc_+3A_proposal">proposal</code></td>
<td>
<p>optional function that draws from the proposal
distribution.  Currently, the proposal distribution must be symmetric for
proper inference: it is the user's responsibility to ensure that it is.
Several functions that construct appropriate proposal function are
provided: see <a href="#topic+proposals">MCMC proposals</a> for more information.</p>
</td></tr>
<tr><td><code id="pmcmc_+3A_np">Np</code></td>
<td>
<p>the number of particles to use.
This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
Alternatively, if one wishes the number of particles to vary across timesteps, one may specify <code>Np</code> either as a vector of positive integers of length </p>
<pre>length(time(object,t0=TRUE))</pre><p> or as a function taking a positive integer argument.
In the latter case, <code>Np(k)</code> must be a single positive integer, representing the number of particles to be used at the <code>k</code>-th timestep:
<code>Np(0)</code> is the number of particles to use going from <code>timezero(object)</code> to <code>time(object)[1]</code>,
<code>Np(1)</code>, from <code>timezero(object)</code> to <code>time(object)[1]</code>,
and so on,
while when <code>T=length(time(object))</code>, <code>Np(T)</code> is the number of particles to sample at the end of the time-series.</p>
</td></tr>
<tr><td><code id="pmcmc_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="pmcmc_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="pmcmc_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="pmcmc_+3A_dmeasure">dmeasure</code></td>
<td>
<p>evaluator of the measurement model density, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>dmeasure=NULL</code> removes the measurement density evaluator.
For more information, see <a href="#topic+dmeasure_spec">dmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="pmcmc_+3A_dprior">dprior</code></td>
<td>
<p>optional; prior distribution density evaluator, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
For more information, see <a href="#topic+prior_spec">prior specification</a>.
Setting <code>dprior=NULL</code> resets the prior distribution to its default, which is a flat improper prior.</p>
</td></tr>
<tr><td><code id="pmcmc_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="pmcmc_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;pmcmcd_pomp&rsquo;.
</p>


<h3>Methods</h3>

<p>The following can be applied to the output of a <code>pmcmc</code> operation:
</p>

<dl>
<dt><code>pmcmc</code></dt><dd><p>repeats the calculation, beginning with the last state</p>
</dd>
<dt><code><a href="#topic+continue">continue</a></code></dt><dd><p>continues the <code>pmcmc</code> calculation</p>
</dd>
<dt><code>plot</code></dt><dd><p>produces a series of diagnostic plots</p>
</dd>
<dt><code><a href="#topic+filter_traj">filter_traj</a></code></dt><dd><p>extracts a random sample from the smoothing distribution</p>
</dd>
<dt><code><a href="#topic+traces">traces</a></code></dt><dd><p>produces an <code><a href="coda.html#topic+mcmc">mcmc</a></code> object, to which the various <span class="pkg">coda</span> convergence diagnostics can be applied</p>
</dd>
</dl>



<h3>Re-running PMCMC Iterations</h3>

<p>To re-run a sequence of PMCMC
iterations, one can use the <code>pmcmc</code> method on a &lsquo;pmcmc&rsquo; object.
By default, the same parameters used for the original PMCMC run are re-used
(except for <code>verbose</code>, the default of which is shown above).  If one
does specify additional arguments, these will override the defaults.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides, Aaron A. King, Sebastian Funk
</p>


<h3>References</h3>

<p>C. Andrieu, A. Doucet, and R. Holenstein. Particle Markov chain Monte Carlo methods. <em>Journal of the Royal Statistical Society, Series B</em> <b>72</b>, 269&ndash;342, 2010.
</p>


<h3>See Also</h3>

<p>More on <span class="pkg">pomp</span> estimation algorithms:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+estimation_algorithms">estimation_algorithms</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>
<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on full-information (i.e., likelihood-based) methods:
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on Markov chain Monte Carlo methods:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+proposals">proposals</a></code>
</p>
<p>More on Bayesian methods:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rprior">rprior</a>()</code>
</p>

<hr>
<h2 id='pomp_constructor'>Constructor of the basic pomp object</h2><span id='topic+pomp_constructor'></span><span id='topic+pomp'></span>

<h3>Description</h3>

<p>This function constructs a &lsquo;pomp&rsquo; object, encoding a partially-observed Markov process (<abbr><span class="acronym">POMP</span></abbr>) model together with a uni- or multi-variate time series.
As such, it is central to all the package's functionality.
One implements the <abbr><span class="acronym">POMP</span></abbr> model by specifying some or all of its <em>basic components</em>.
These comprise:
</p>

<dl>
<dt>rinit,</dt><dd><p>which samples from the distribution of the state process at the zero-time;</p>
</dd>
<dt>dinit,</dt><dd><p>which evaluates the density of the state process at the zero-time;</p>
</dd>
<dt>rprocess,</dt><dd><p>the simulator of the unobserved Markov state process;</p>
</dd>
<dt>dprocess,</dt><dd><p>the evaluator of the probability density function for transitions of the unobserved Markov state process;</p>
</dd>
<dt>rmeasure,</dt><dd><p>the simulator of the observed process, conditional on the unobserved state;</p>
</dd>
<dt>dmeasure,</dt><dd><p>the evaluator of the measurement model probability density function;</p>
</dd>
<dt>emeasure,</dt><dd><p>the expectation of the measurements, conditional on the latent state;</p>
</dd>
<dt>vmeasure,</dt><dd><p>the covariance matrix of the measurements, conditional on the latent state;</p>
</dd>
<dt>rprior,</dt><dd><p>which samples from a prior probability distribution on the parameters;</p>
</dd>
<dt>dprior,</dt><dd><p>which evaluates the prior probability density function;</p>
</dd>
<dt>skeleton,</dt><dd><p>which computes the deterministic skeleton of the unobserved state process;</p>
</dd>
<dt>partrans,</dt><dd><p>which performs parameter transformations.</p>
</dd>
</dl>

<p>The basic structure and its rationale are described in the <em>Journal of Statistical Software</em> paper, an updated version of which is to be found on the <a href="https://kingaa.github.io/pomp/">package website</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pomp(
  data,
  times,
  t0,
  ...,
  rinit,
  dinit,
  rprocess,
  dprocess,
  rmeasure,
  dmeasure,
  emeasure,
  vmeasure,
  skeleton,
  rprior,
  dprior,
  partrans,
  covar,
  params,
  accumvars,
  obsnames,
  statenames,
  paramnames,
  covarnames,
  nstatevars,
  PACKAGE,
  globals,
  on_load,
  cdir = getOption("pomp_cdir", NULL),
  cfile,
  shlib.args,
  compile = TRUE,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pomp_constructor_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_times">times</code></td>
<td>
<p>the sequence of observation times.
<code>times</code> must indicate the column of observation times by name or index.
The time vector must be numeric and non-decreasing.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_t0">t0</code></td>
<td>
<p>The zero-time, i.e., the time of the initial state.
This must be no later than the time of the first observation, i.e., <code>t0 &lt;= times[1]</code>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_dinit">dinit</code></td>
<td>
<p>evaluator of the initial-state density.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>dinit=NULL</code> removes this basic component.
For more information, see <a href="#topic+dinit_spec">dinit specification</a>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_dprocess">dprocess</code></td>
<td>
<p>evaluator of the probability density of transitions of the unobserved state process.
Setting <code>dprocess=NULL</code> removes the latent-state density evaluator.
For more information, see <a href="#topic+dprocess_spec">dprocess specification</a>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_rmeasure">rmeasure</code></td>
<td>
<p>simulator of the measurement model, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rmeasure=NULL</code> removes the measurement model simulator.
For more information, see <a href="#topic+rmeasure_spec">rmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_dmeasure">dmeasure</code></td>
<td>
<p>evaluator of the measurement model density, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>dmeasure=NULL</code> removes the measurement density evaluator.
For more information, see <a href="#topic+dmeasure_spec">dmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_emeasure">emeasure</code></td>
<td>
<p>the expectation of the measured variables, conditional on the latent state.
This can be specified as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>emeasure=NULL</code> removes the emeasure component.
For more information, see <a href="#topic+emeasure_spec">emeasure specification</a>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_vmeasure">vmeasure</code></td>
<td>
<p>the covariance of the measured variables, conditional on the latent state.
This can be specified as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>vmeasure=NULL</code> removes the vmeasure component.
For more information, see <a href="#topic+vmeasure_spec">vmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_skeleton">skeleton</code></td>
<td>
<p>optional; the deterministic skeleton of the unobserved state process.
Depending on whether the model operates in continuous or discrete time, this is either a vectorfield or a map.
Accordingly, this is supplied using either the <code><a href="#topic+skeleton_spec">vectorfield</a></code> or <code><a href="#topic+skeleton_spec">map</a></code> fnctions.
For more information, see <a href="#topic+skeleton_spec">skeleton specification</a>.
Setting <code>skeleton=NULL</code> removes the deterministic skeleton.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_rprior">rprior</code></td>
<td>
<p>optional; prior distribution sampler, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
For more information, see <a href="#topic+prior_spec">prior specification</a>.
Setting <code>rprior=NULL</code> removes the prior distribution sampler.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_dprior">dprior</code></td>
<td>
<p>optional; prior distribution density evaluator, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
For more information, see <a href="#topic+prior_spec">prior specification</a>.
Setting <code>dprior=NULL</code> resets the prior distribution to its default, which is a flat improper prior.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_partrans">partrans</code></td>
<td>
<p>optional parameter transformations, constructed using <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
</p>
<p>Many algorithms for parameter estimation search an unconstrained space of parameters.
When working with such an algorithm and a model for which the parameters are constrained, it can be useful to transform parameters.
One should supply the <code>partrans</code> argument via a call to <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
For more information, see <a href="#topic+parameter_trans">parameter_trans</a>.
Setting <code>partrans=NULL</code> removes the parameter transformations, i.e., sets them to the identity transformation.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_covar">covar</code></td>
<td>
<p>optional covariate table, constructed using <code><a href="#topic+covariate_table">covariate_table</a></code>.
</p>
<p>If a covariate table is supplied, then the value of each of the covariates is interpolated as needed.
The resulting interpolated values are made available to the appropriate basic components.
See the documentation for <code><a href="#topic+covariate_table">covariate_table</a></code> for details.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_accumvars">accumvars</code></td>
<td>
<p>optional character vector;
contains the names of accumulator variables.
See <a href="#topic+accumvars">accumvars</a> for a definition and discussion of accumulator variables.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_obsnames">obsnames</code></td>
<td>
<p>optional character vector;
names of the observables.
It is not usually necessary to specify <code>obsnames</code> since, by default,
these are read from the names of the data variables.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_statenames">statenames</code></td>
<td>
<p>optional character vector;
names of the latent state variables.
It is typically only necessary to supply <code>statenames</code> when C snippets are in use.
See also <code>nstatevars</code>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_paramnames">paramnames</code></td>
<td>
<p>optional character vector;
names of model parameters.
It is typically only necessary to supply <code>paramnames</code> when C snippets are in use.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_covarnames">covarnames</code></td>
<td>
<p>optional character vector;
names of the covariates.
It is not usually necessary to specify <code>covarnames</code> since, by default,
these are read from the names of the covariates.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_nstatevars">nstatevars</code></td>
<td>
<p>optional integer scalar;
If C snippets or native routines are used, one can specify the number of state variables with this argument.
By default, <code>nstatevars = length(statenames)</code>.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_package">PACKAGE</code></td>
<td>
<p>optional character;
the name (without extension) of the external, dynamically loaded library in which any native routines are to be found.
This is only useful if one or more of the model components has been specified using a precompiled dynamically loaded library;
it is not used for any component specified using C snippets.
<code>PACKAGE</code> can name at most one library.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_globals">globals</code></td>
<td>
<p>optional character or C snippet;
arbitrary C code that will be hard-coded into the shared-object library created when C snippets are provided.
If no C snippets are used, <code>globals</code> has no effect.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_on_load">on_load</code></td>
<td>
<p>optional character or C snippet:
arbitrary C code that will be executed when the C snippet file is loaded.
If no C snippets are used, <code>on_load</code> has no effect.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_cdir">cdir</code></td>
<td>
<p>optional character variable.
<code>cdir</code> specifies the name of the directory within which C snippet code will be compiled.
By default, this is in a temporary directory specific to the <span class="rlang"><b>R</b></span> session.
One can also set this directory using the <code>pomp_cdir</code> global option.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_cfile">cfile</code></td>
<td>
<p>optional character variable.
<code>cfile</code> gives the name of the file (in directory <code>cdir</code>) into which C snippet codes will be written.
By default, a random filename is used.
If the chosen filename would result in over-writing an existing file, an error is generated.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_shlib.args">shlib.args</code></td>
<td>
<p>optional character variables.
Command-line arguments to the <code>R CMD SHLIB</code> call that compiles the C snippets.
One can, for example, specify libraries against which the C snippets are to be linked.
In doing so, take care to make sure the appropriate header files are available to the C snippets, e.g., using the <code>globals</code> argument.
See <code><a href="#topic+Csnippet">Csnippet</a></code> for more information.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_compile">compile</code></td>
<td>
<p>logical;
if <code>FALSE</code>, compilation of the C snippets will be postponed until they are needed.</p>
</td></tr>
<tr><td><code id="pomp_constructor_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each basic component is supplied via an argument of the same name.
These can be given in the call to <code>pomp</code>, or to many of the package's other functions.
In any case, the effect is the same: to add, remove, or modify the basic component.
</p>
<p>Each basic component can be furnished using C snippets, <span class="rlang"><b>R</b></span> functions, or pre-compiled native routine available in user-provided dynamically loaded libraries.
</p>


<h3>Value</h3>

<p>The <code>pomp</code> constructor function returns an object, call it <code>P</code>, of class &lsquo;pomp&rsquo;.
<code>P</code> contains, in addition to the data, any elements of the model that have been specified as arguments to the <code>pomp</code> constructor function.
One can add or modify elements of <code>P</code> by means of further calls to <code>pomp</code>, using <code>P</code> as the first argument in such calls.
One can pass <code>P</code> to most of the <span class="pkg">pomp</span> package methods via their <code>data</code> argument.
</p>


<h3>Note</h3>

<p>It is not typically necessary (or indeed feasible) to define all of the basic components for any given purpose.
However, each <span class="pkg">pomp</span> algorithm makes use of only a subset of these components.
When an algorithm requires a basic component that has not been furnished, an error is generated to let you know that you must provide the needed component to use the algorithm.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>A. A. King, D. Nguyen, and E. L. Ionides. Statistical inference for partially observed Markov processes via the package <span class="pkg">pomp</span>. <em>Journal of Statistical Software</em> <b>69</b>(12), 1&ndash;43, 2016.  An updated version of this paper is available on the <a href="https://kingaa.github.io/pomp/docs.html">package website</a>.
</p>


<h3>See Also</h3>

<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>

<hr>
<h2 id='pomp_examples'>pre-built pomp examples</h2><span id='topic+pomp_examples'></span>

<h3>Description</h3>

<p>Examples of pomp objects containing models and data.
</p>


<h3>Details</h3>

<p><span class="pkg">pomp</span> includes a number of pre-built examples of pomp objects and data that can be analyzed using <span class="pkg">pomp</span> methods.
These include:
</p>

<dl>
<dt><code><a href="#topic+blowflies">blowflies</a></code></dt><dd><p>Data from Nicholson's experiments with sheep blowfly populations</p>
</dd>
<dt><code><a href="#topic+blowflies1">blowflies1</a>()</code></dt><dd><p>A pomp object with some of the blowfly data together with a discrete delay equation model.</p>
</dd>
<dt><code><a href="#topic+blowflies2">blowflies2</a>()</code></dt><dd><p>A variant of <code>blowflies1</code>.</p>
</dd>
<dt><code><a href="#topic+bsflu">bsflu</a></code></dt><dd><p>Data from an outbreak of influenza in a boarding school.</p>
</dd>
<dt><code><a href="#topic+dacca">dacca</a>()</code></dt><dd><p>Fifty years of census and cholera mortality data, together with a stochastic differential equation transmission model (King et al. 2008).</p>
</dd>
<dt><code><a href="#topic+ebolaModel">ebolaModel</a>()</code></dt><dd><p>Data from the 2014 West Africa outbreak of Ebola virus disease, together with simple transmission models (King et al. 2015).</p>
</dd>
<dt><code><a href="#topic+gompertz">gompertz</a>()</code></dt><dd><p>The Gompertz population dynamics model, with simulated data.</p>
</dd>
<dt><code><a href="#topic+LondonYorke">LondonYorke</a></code></dt><dd><p>Data on incidence of several childhood diseases (London and Yorke 1973)</p>
</dd>
<dt><code><a href="#topic+ewmeas">ewmeas</a></code></dt><dd><p>Measles incidence data from England and Wales</p>
</dd>
<dt><code><a href="#topic+ewcitmeas">ewcitmeas</a></code></dt><dd><p>Measles incidence data from 7 English cities</p>
</dd>
<dt><code><a href="#topic+ou2">ou2</a>()</code></dt><dd><p>A 2-D Ornstein-Uhlenbeck process with simulated data</p>
</dd>
<dt><code><a href="#topic+parus">parus</a></code></dt><dd><p>Population censuses of a <em>Parus major</em> population in Wytham Wood, England.</p>
</dd>
<dt><code><a href="#topic+ricker">ricker</a></code></dt><dd><p>The Ricker population dynamics model, with simulated data</p>
</dd>
<dt><code><a href="#topic+rw2">rw2</a></code></dt><dd><p>A 2-D Brownian motion model, with simulated data.</p>
</dd>
<dt><code><a href="#topic+sir">sir</a>()</code></dt><dd><p>A simple continuous-time Markov chain SIR model, coded using Euler-multinomial steps, with simulated data.</p>
</dd>
<dt><code><a href="#topic+sir2">sir2</a>()</code></dt><dd><p>A simple continuous-time Markov chain SIR model, coded using Gillespie's algorithm, with simulated data.</p>
</dd>
<dt><code><a href="#topic+verhulst">verhulst</a>()</code></dt><dd><p>The Verhulst-Pearl (logistic) model, a continuous-time model of population dynamics, with simulated data</p>
</dd>
</dl>

<p>See also the tutorials on the <a href="https://kingaa.github.io/pomp/">package website</a> for more examples.
</p>


<h3>References</h3>

<p>Anonymous. Influenza in a boarding school. <em>British Medical Journal</em> <b>1</b>, 587, 1978.
</p>
<p>A.A. King, E.L. Ionides, M. Pascual, and M.J. Bouma. Inapparent infections and cholera dynamics. <em>Nature</em> <b>454</b>, 877-880, 2008
</p>
<p>A.A. King, M. Domenech de Cellès, F.M.G. Magpantay, and P. Rohani. Avoidable errors in the modelling of outbreaks of emerging pathogens, with special reference to Ebola. <em>Proceedings of the Royal Society of London, Series B</em> <b>282</b>, 20150347, 2015.
</p>
<p>W. P. London and J. A. Yorke, Recurrent outbreaks of measles, chickenpox and mumps: I. Seasonal variation in contact rates. <em>American Journal of Epidemiology</em> <b>98</b>, 453&ndash;468, 1973.
</p>
<p>A.J. Nicholson. The self-adjustment of populations to change. <em>Cold Spring Harbor Symposia on Quantitative Biology</em> <b>22</b>, 153&ndash;173, 1957.
</p>


<h3>See Also</h3>

<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+compartmental_models">compartmental_models</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+gompertz">gompertz</a>()</code>,
<code><a href="#topic+ou2">ou2</a>()</code>,
<code><a href="#topic+ricker">ricker</a>()</code>,
<code><a href="#topic+rw2">rw2</a>()</code>,
<code><a href="#topic+verhulst">verhulst</a>()</code>
</p>

<hr>
<h2 id='pomp_fun'>The &quot;pomp_fun&quot; class</h2><span id='topic+pomp_fun'></span><span id='topic+pomp_fun+2Cmissing-method'></span><span id='topic+pomp_fun+2Cfunction-method'></span><span id='topic+pomp_fun+2Ccharacter-method'></span><span id='topic+pomp_fun+2CCsnippet-method'></span><span id='topic+pomp_fun+2Cpomp_fun-method'></span>

<h3>Description</h3>

<p>Definition and methods of the &lsquo;pomp_fun&rsquo; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
pomp_fun(
  slotname = NULL,
  obsnames = character(0),
  statenames = character(0),
  paramnames = character(0),
  covarnames = character(0),
  ...
)

## S4 method for signature 'function'
pomp_fun(f, proto = NULL, slotname = NULL, ...)

## S4 method for signature 'character'
pomp_fun(
  f,
  PACKAGE = NULL,
  obsnames = character(0),
  statenames = character(0),
  paramnames = character(0),
  covarnames = character(0),
  slotname = NULL,
  ...
)

## S4 method for signature 'Csnippet'
pomp_fun(
  f,
  slotname = NULL,
  libname = NULL,
  obsnames = character(0),
  statenames = character(0),
  paramnames = character(0),
  covarnames = character(0),
  Cname,
  ...
)

## S4 method for signature 'pomp_fun'
pomp_fun(f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pomp_fun_+3A_f">f</code></td>
<td>
<p>A function or the name of a native routine.</p>
</td></tr>
<tr><td><code id="pomp_fun_+3A_proto">proto</code></td>
<td>
<p>optional string; a prototype against which <code>f</code> will be
checked.</p>
</td></tr>
<tr><td><code id="pomp_fun_+3A_package">PACKAGE</code></td>
<td>
<p>optional; the name of the dynamically-loadable library in
which the native function <code>f</code> can be found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;pomp_fun&rsquo; class implements a common interface for user-defined procedures that can be defined in terms of R code or by compiled native routines.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pomp">pomp</a></code>
</p>

<hr>
<h2 id='pomp-class'>The basic pomp class</h2><span id='topic+pomp-class'></span>

<h3>Description</h3>

<p>The basic class implementing a <abbr><span class="acronym">POMP</span></abbr> model with data
</p>


<h3>See Also</h3>

<p><a href="#topic+pomp_constructor">pomp_constructor</a>
</p>

<hr>
<h2 id='pomp-package'>Inference for partially observed Markov processes</h2><span id='topic+pomp-package'></span><span id='topic+pomp+2Cpackage'></span>

<h3>Description</h3>

<p>The <span class="pkg">pomp</span> package provides facilities for inference on time series
data using partially-observed Markov process (<abbr><span class="acronym">POMP</span></abbr>) models.
These models are also known as state-space models, hidden Markov models, or
nonlinear stochastic dynamical systems.  One can use <span class="pkg">pomp</span> to fit
nonlinear, non-Gaussian dynamic models to time-series data.  The package is
both a set of tools for data analysis and a platform upon which statistical
inference methods for <abbr><span class="acronym">POMP</span></abbr> models can be implemented.
</p>


<h3>Data analysis using <span class="pkg">pomp</span></h3>

<p><span class="pkg">pomp</span> provides algorithms for:
</p>

<ol>
<li><p> Simulation of stochastic dynamical systems;
see <code><a href="#topic+simulate">simulate</a></code>.
</p>
</li>
<li><p> Particle filtering (AKA sequential Monte Carlo or sequential importance sampling);
see <code><a href="#topic+pfilter">pfilter</a></code> and <code><a href="#topic+wpfilter">wpfilter</a></code>.
</p>
</li>
<li><p> The iterated filtering methods of Ionides et al. (2006, 2011, 2015);
see <code><a href="#topic+mif2">mif2</a></code>.
</p>
</li>
<li><p> The nonlinear forecasting algorithm of Kendall et al. (2005);
see <a href="#topic+nlf">nlf</a>.
</p>
</li>
<li><p> The particle MCMC approach of Andrieu et al. (2010);
see <code><a href="#topic+pmcmc">pmcmc</a></code>.
</p>
</li>
<li><p> The probe-matching method of Kendall et al. (1999, 2005);
see <a href="#topic+probe_match">probe_match</a>.
</p>
</li>
<li><p> Synthetic likelihood a la Wood (2010);
see <code><a href="#topic+probe">probe</a></code>.
</p>
</li>
<li><p> A spectral probe-matching method (Reuman et al. 2006, 2008);
see <a href="#topic+spect_match">spect_match</a>.
</p>
</li>
<li><p> Approximate Bayesian computation (Toni et al. 2009);
see <code><a href="#topic+abc">abc</a></code>.
</p>
</li>
<li><p> The approximate Bayesian sequential Monte Carlo scheme of Liu &amp; West (2001);
see <code><a href="#topic+bsmc2">bsmc2</a></code>.
</p>
</li>
<li><p> Ensemble and ensemble adjusted Kalman filters;
see <a href="#topic+kalman">kalman</a>.
</p>
</li>
<li><p> Simple trajectory matching;
see <a href="#topic+traj_match">traj_match</a>.
</p>
</li></ol>

<p>The package also provides various tools for plotting and extracting information on models and data.
</p>


<h3>Structure of the package</h3>

<p><span class="pkg">pomp</span> algorithms are arranged into several levels.
At the top level, <a href="#topic+estimation_algorithms">estimation algorithms</a> estimate model parameters and return information needed for other aspects of inference.
<a href="#topic+elementary_algorithms">Elementary algorithms</a> perform common operations on <abbr><span class="acronym">POMP</span></abbr> models, including simulation, filtering, and application of diagnostic probes;
these functions may be useful in inference, but they do not themselves perform estimation.
At the lowest level, <a href="#topic+workhorses">workhorse functions</a> provide the interface to <a href="#topic+basic_components">basic POMP model components</a>.
Beyond these, <span class="pkg">pomp</span> provides a variety of auxiliary functions for manipulating and extracting information from &lsquo;pomp&rsquo; objects, producing diagnostic plots, <a href="#topic+bake">facilitating reproducible computations</a>, and so on.
</p>


<h3>Implementing a model</h3>

<p>The basic structure at the heart of the package is the &lsquo;pomp object&rsquo;.
This is a container holding a time series of data (possibly multivariate) and a model.
The model is specified by specifying some or all of its <a href="#topic+basic_components">basic model components</a>.
One does this using the <a href="#topic+basic_components">basic component arguments</a> to the <code><a href="#topic+pomp">pomp</a></code> constructor.
One can also add, modify, or delete basic model components &ldquo;on the fly&rdquo; in any <span class="pkg">pomp</span> function that accepts them.
</p>


<h3>Documentation and examples</h3>

<p>The package contains a number of examples.
Some of these are included in the help pages.
In addition, <a href="#topic+pomp_examples">several pre-built POMP models</a> are included with the package.
Tutorials and other documentation, including a <a href="https://kingaa.github.io/pomp/FAQ.html">package FAQ</a>, are available from the <a href="https://kingaa.github.io/pomp/">package website</a>.
</p>


<h3>Useful links</h3>


<ul>
<li><p><span class="pkg">pomp</span> homepage: <a href="https://kingaa.github.io/pomp/">https://kingaa.github.io/pomp/</a>
</p>
</li>
<li><p>Report bugs to: <a href="https://github.com/kingaa/pomp/issues">https://github.com/kingaa/pomp/issues</a>
</p>
</li>
<li><p>Frequently asked questions: <a href="https://kingaa.github.io/pomp/FAQ.html">https://kingaa.github.io/pomp/FAQ.html</a>
</p>
</li>
<li><p>User guides and tutorials: <a href="https://kingaa.github.io/pomp/docs.html">https://kingaa.github.io/pomp/docs.html</a>
</p>
</li>
<li><p><span class="pkg">pomp</span> news: <a href="https://kingaa.github.io/pomp/blog.html">https://kingaa.github.io/pomp/blog.html</a>
</p>
</li></ul>



<h3>Citing <span class="pkg">pomp</span></h3>

<p>Execute <code>citation("pomp")</code> to view the correct citation for publications.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>A. A. King, D. Nguyen, and E. L. Ionides. Statistical inference for partially observed Markov processes via the package <span class="pkg">pomp</span>. <em>Journal of Statistical Software</em> <b>69</b>(12), 1&ndash;43, 2016.  An updated version of this paper is available on the <a href="https://kingaa.github.io/pomp/docs.html">package website</a>.
</p>
<p>See <a href="https://kingaa.github.io/pomp/biblio.html">the package website for more references</a>, including many publications that use <span class="pkg">pomp</span>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://kingaa.github.io/pomp/">https://kingaa.github.io/pomp/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/kingaa/pomp/issues/">https://github.com/kingaa/pomp/issues/</a>
</p>
</li></ul>

<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>
<p>More on <span class="pkg">pomp</span> estimation algorithms:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+estimation_algorithms">estimation_algorithms</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>
<p>More on <span class="pkg">pomp</span> elementary algorithms: 
<code><a href="#topic+elementary_algorithms">elementary_algorithms</a></code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>

<hr>
<h2 id='pred_mean'>Prediction mean</h2><span id='topic+pred_mean'></span><span id='topic+pred_mean+2CANY-method'></span><span id='topic+pred_mean+2Cmissing-method'></span><span id='topic+pred_mean+2Ckalmand_pomp-method'></span><span id='topic+pred_mean+2Cpfilterd_pomp-method'></span>

<h3>Description</h3>

<p>The mean of the prediction distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'kalmand_pomp'
pred_mean(object, vars, ..., format = c("array", "data.frame"))

## S4 method for signature 'pfilterd_pomp'
pred_mean(object, vars, ..., format = c("array", "data.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_mean_+3A_object">object</code></td>
<td>
<p>result of a filtering computation</p>
</td></tr>
<tr><td><code id="pred_mean_+3A_vars">vars</code></td>
<td>
<p>optional character; names of variables</p>
</td></tr>
<tr><td><code id="pred_mean_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="pred_mean_+3A_format">format</code></td>
<td>
<p>format of the returned object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prediction distribution is that of
</p>
<p style="text-align: center;"><code class="reqn">X(t_k) \vert Y(t_1)=y^*_1,\dots,Y(t_{k-1})=y^*_{k-1},</code>
</p>

<p>where <code class="reqn">X(t_k)</code>, <code class="reqn">Y(t_k)</code> are the latent state and observable processes, respectively, and <code class="reqn">y^*_k</code> is the data, at time <code class="reqn">t_k</code>.
</p>
<p>The prediction mean is therefore the expectation of this distribution
</p>
<p style="text-align: center;"><code class="reqn">E[X(t_k) \vert Y(t_1)=y^*_1,\dots,Y(t_{k-1})=y^*_{k-1}].</code>
</p>



<h3>See Also</h3>

<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='pred_var'>Prediction variance</h2><span id='topic+pred_var'></span><span id='topic+pred_var+2CANY-method'></span><span id='topic+pred_var+2Cmissing-method'></span><span id='topic+pred_var+2Cpfilterd_pomp-method'></span>

<h3>Description</h3>

<p>The variance of the prediction distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pfilterd_pomp'
pred_var(object, vars, ..., format = c("array", "data.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_var_+3A_object">object</code></td>
<td>
<p>result of a filtering computation</p>
</td></tr>
<tr><td><code id="pred_var_+3A_vars">vars</code></td>
<td>
<p>optional character; names of variables</p>
</td></tr>
<tr><td><code id="pred_var_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="pred_var_+3A_format">format</code></td>
<td>
<p>format of the returned object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prediction distribution is that of
</p>
<p style="text-align: center;"><code class="reqn">X(t_k) \vert Y(t_1)=y^*_1,\dots,Y(t_{k-1})=y^*_{k-1},</code>
</p>

<p>where <code class="reqn">X(t_k)</code>, <code class="reqn">Y(t_k)</code> are the latent state and observable processes, respectively, and <code class="reqn">y^*_k</code> is the data, at time <code class="reqn">t_k</code>.
</p>
<p>The prediction variance is therefore the variance of this distribution
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Var}[X(t_k) \vert Y(t_1)=y^*_1,\dots,Y(t_{k-1})=y^*_{k-1}].</code>
</p>



<h3>See Also</h3>

<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='print'>Print methods</h2><span id='topic+print'></span><span id='topic+print+2Cunshowable-method'></span><span id='topic+print+2Clistie-method'></span><span id='topic+print+2Cpomp_fun-method'></span>

<h3>Description</h3>

<p>These methods print their argument and return it *invisibly*.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unshowable'
print(x, ...)

## S4 method for signature 'listie'
print(x, ...)

## S4 method for signature 'pomp_fun'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>object to print</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='prior_spec'>prior specification</h2><span id='topic+prior_spec'></span><span id='topic+priors'></span>

<h3>Description</h3>

<p>Specification of prior distributions via the rprior and dprior components.
</p>


<h3>Details</h3>

<p>A prior distribution on parameters is specified by means of the <code>rprior</code> and/or <code>dprior</code> arguments to <code>pomp</code>.
As with the other <a href="#topic+basic_components">basic model components</a>, it is preferable to specify these using C snippets.
In writing a C snippet for the prior sampler (<code>rprior</code>), keep in mind that:
</p>

<ol>
<li><p> Within the context in which the snippet will be evaluated, only the parameters will be defined.
</p>
</li>
<li><p> The goal of such a snippet is the replacement of parameters with values drawn from the prior distribution.
</p>
</li>
<li><p> Hyperparameters can be included in the ordinary parameter list.
Obviously, hyperparameters should not be replaced with random draws.
</p>
</li></ol>

<p>In writing a C snippet for the prior density function (<code>dprior</code>), observe that:
</p>

<ol>
<li><p> Within the context in which the snippet will be evaluated, only the parameters and <code>give_log</code> will be defined.
</p>
</li>
<li><p> The goal of such a snippet is computation of the prior probability density, or the log of same, at a given point in parameter space.
This scalar value should be returned in the variable <code>lik</code>.
When <code>give_log == 1</code>, <code>lik</code> should contain the log of the prior probability density.
</p>
</li>
<li><p> Hyperparameters can be included in the ordinary parameter list.
</p>
</li></ol>

<p><a href="#topic+Csnippet">General rules for writing C snippets can be found here</a>.
</p>
<p>Alternatively, one can furnish <span class="rlang"><b>R</b></span> functions for one or both of these arguments.
In this case, <code>rprior</code> must be a function that makes a draw from
the prior distribution of the parameters and returns a named vector
containing all the parameters.
The only required argument of this function is <code>...</code>.
</p>
<p>Similarly, the <code>dprior</code> function must evaluate the prior probability
density (or log density if <code>log == TRUE</code>) and return that single
scalar value.
The only required arguments of this function are <code>...</code> and <code>log</code>.
</p>


<h3>Default behavior</h3>

<p>By default, the prior is assumed flat and improper.
In particular, <code>dprior</code> returns <code>1</code> (<code>0</code> if <code>log = TRUE</code>) for every parameter set.
Since it is impossible to simulate from a flat improper prior, <code>rprocess</code> returns missing values (<code>NA</code>s).
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dprior">dprior</a></code> <code><a href="#topic+rprior">rprior</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>
<p>More on Bayesian methods:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # takes too long for R CMD check
  ## Starting with an existing pomp object:
  verhulst() |&gt; window(end=30) -&gt; po
  
  ## We add or change prior distributions using the two
  ## arguments 'rprior' and 'dprior'. Here, we introduce
  ## a Gamma prior on the 'r' parameter.
  ## We construct 'rprior' and 'dprior' using R functions.

  po |&gt;
    bsmc2(
      rprior=function (n_0, K0, K1, sigma, tau, r0, r1, ...) {
        c(
          n_0 = n_0,
          K = rgamma(n=1,shape=K0,scale=K1),
          r = rgamma(n=1,shape=r0,scale=r1),
          sigma = sigma,
          tau = tau
        )
      },
      dprior=function(K, K0, K1, r, r0, r1, ..., log) {
        p &lt;- dgamma(x=c(K,r),shape=c(K0,r0),scale=c(K1,r1),log=log)
        if (log) sum(p) else prod(p)
      },
      params=c(n_0=10000,K=10000,K0=10,K1=1000,
        r=0.9,r0=0.9,r1=1,sigma=0.5,tau=0.3),
      Np=1000
    ) -&gt; B

  ## We can also pass them as C snippets:

  po |&gt;
    bsmc2(
      rprior=Csnippet("
         K = rgamma(K0,K1);
         r = rgamma(r0,r1);"
      ),
      dprior=Csnippet("
         double lik1 = dgamma(K,K0,K1,give_log);
         double lik2 = dgamma(r,r0,r1,give_log);
         lik = (give_log) ? lik1+lik2 : lik1*lik2;"
      ),
      paramnames=c("K","K0","K1","r","r0","r1"),
      params=c(n_0=10000,K=10000,K0=10,K1=1000,
        r=0.9,r0=0.9,r1=1,sigma=0.5,tau=0.3),
      Np=10000
    ) -&gt; B

  ## The prior is plotted in grey; the posterior, in blue.
  plot(B)

  B |&gt;
    pmcmc(Nmcmc=100,Np=1000,proposal=mvn_diag_rw(c(r=0.01,K=10))) -&gt; Bb

  plot(Bb,pars=c("loglik","log.prior","r","K"))


</code></pre>

<hr>
<h2 id='probe'>Probes (AKA summary statistics)</h2><span id='topic+probe'></span><span id='topic+probe+2Cmissing-method'></span><span id='topic+probe+2CANY-method'></span><span id='topic+probe+2Cdata.frame-method'></span><span id='topic+probe+2Cpomp-method'></span><span id='topic+probe+2Cprobed_pomp-method'></span><span id='topic+probe+2Cprobe_match_objfun-method'></span><span id='topic+probe+2Cobjfun-method'></span>

<h3>Description</h3>

<p>Probe a partially-observed Markov process by computing summary statistics
and the synthetic likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
probe(
  data,
  probes,
  nsim,
  seed = NULL,
  params,
  rinit,
  rprocess,
  rmeasure,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
probe(
  data,
  probes,
  nsim,
  seed = NULL,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'probed_pomp'
probe(
  data,
  probes,
  nsim,
  seed = NULL,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'probe_match_objfun'
probe(data, seed, ..., verbose = getOption("verbose", FALSE))

## S4 method for signature 'objfun'
probe(data, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probe_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="probe_+3A_probes">probes</code></td>
<td>
<p>a single probe or a list of one or more probes.
A probe is simply a scalar- or vector-valued function of one argument that can be applied to the data array of a &lsquo;pomp&rsquo;.
A vector-valued probe must always return a vector of the same size.
A number of useful probes are provided with the package:
see <a href="#topic+basic_probes">basic probes</a>.</p>
</td></tr>
<tr><td><code id="probe_+3A_nsim">nsim</code></td>
<td>
<p>the number of model simulations to be computed.</p>
</td></tr>
<tr><td><code id="probe_+3A_seed">seed</code></td>
<td>
<p>optional integer;
if non-<code>NULL</code>, the random number generator will be initialized with this seed for simulations.
See <code><a href="#topic+simulate">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="probe_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="probe_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="probe_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="probe_+3A_rmeasure">rmeasure</code></td>
<td>
<p>simulator of the measurement model, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rmeasure=NULL</code> removes the measurement model simulator.
For more information, see <a href="#topic+rmeasure_spec">rmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="probe_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="probe_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>probe</code> applies one or more &ldquo;probes&rdquo; to time series data and
model simulations and compares the results.  It can be used to diagnose
goodness of fit and/or as the basis for &ldquo;probe-matching&rdquo;, a
generalized method-of-moments approach to parameter estimation.
</p>
<p>A call to <code>probe</code> results in the evaluation of the probe(s) in
<code>probes</code> on the data.  Additionally, <code>nsim</code> simulated data sets
are generated (via a call to <code><a href="#topic+simulate">simulate</a></code>) and
the probe(s) are applied to each of these.  The results of the probe
computations on real and simulated data are stored in an object of class
&lsquo;probed_pomp&rsquo;.
</p>
<p>When <code>probe</code> operates on a probe-matching objective function (a &lsquo;probe_match_objfun&rsquo; object), by default, the
random-number generator seed is fixed at the value given when the objective function was constructed.
Specifying <code>NULL</code> or an integer for <code>seed</code> overrides this behavior.
</p>


<h3>Value</h3>

<p><code>probe</code> returns an object of class &lsquo;probed_pomp&rsquo;, which contains the data and the model, together with the results of the <code>probe</code> calculation.
</p>


<h3>Methods</h3>

<p>The following methods are available.
</p>

<dl>
<dt><code>plot</code></dt><dd><p> displays diagnostic plots.  </p>
</dd>
<dt><code>summary</code></dt><dd><p> displays summary information.
The summary includes quantiles (fractions of simulations with probe values less than those realized on the data) and the corresponding two-sided p-values.
In addition, the &ldquo;synthetic likelihood&rdquo; (Wood 2010) is computed,
under the assumption that the probe values are multivariate-normally distributed.  </p>
</dd>
<dt><code>logLik</code></dt><dd><p> returns the synthetic likelihood for the probes.
NB: in general, this is not the same as the likelihood.  </p>
</dd>
<dt><code>as.data.frame</code></dt><dd>
<p>coerces a &lsquo;probed_pomp&rsquo; to a &lsquo;data.frame&rsquo;.
The latter contains the realized values of the probes on the data and on the simulations.
The variable <code>.id</code> indicates whether the probes are from the data or simulations.  </p>
</dd>
</dl>



<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Daniel C. Reuman, Aaron A. King
</p>


<h3>References</h3>

<p>B.E. Kendall, C.J. Briggs, W.W. Murdoch, P. Turchin, S.P. Ellner, E. McCauley, R.M. Nisbet, and S.N. Wood. Why do populations cycle? A synthesis of statistical and mechanistic modeling approaches. <em>Ecology</em> <b>80</b>, 1789&ndash;1805, 1999.
</p>
<p>S. N. Wood Statistical inference for noisy nonlinear ecological dynamic systems. <em>Nature</em> <b>466</b>, 1102&ndash;1104, 2010.
</p>


<h3>See Also</h3>

<p>More on <span class="pkg">pomp</span> elementary algorithms: 
<code><a href="#topic+elementary_algorithms">elementary_algorithms</a></code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on methods based on summary statistics: 
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+basic_probes">basic_probes</a></code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>

<hr>
<h2 id='probe_match'>Probe matching</h2><span id='topic+probe_match'></span><span id='topic+probe_objfun'></span><span id='topic+probe_objfun+2Cmissing-method'></span><span id='topic+probe_objfun+2CANY-method'></span><span id='topic+probe_objfun+2Cdata.frame-method'></span><span id='topic+probe_objfun+2Cpomp-method'></span><span id='topic+probe_objfun+2Cprobed_pomp-method'></span><span id='topic+probe_objfun+2Cprobe_match_objfun-method'></span>

<h3>Description</h3>

<p>Estimation of parameters by maximum synthetic likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
probe_objfun(
  data,
  est = character(0),
  fail.value = NA,
  probes,
  nsim,
  seed = NULL,
  params,
  rinit,
  rprocess,
  rmeasure,
  partrans,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
probe_objfun(
  data,
  est = character(0),
  fail.value = NA,
  probes,
  nsim,
  seed = NULL,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'probed_pomp'
probe_objfun(
  data,
  est = character(0),
  fail.value = NA,
  probes,
  nsim,
  seed = NULL,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'probe_match_objfun'
probe_objfun(
  data,
  est,
  fail.value,
  seed = NULL,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probe_match_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_est">est</code></td>
<td>
<p>character vector; the names of parameters to be estimated.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_fail.value">fail.value</code></td>
<td>
<p>optional numeric scalar;
if non-<code>NA</code>, this value is substituted for non-finite values of the objective function.
It should be a large number (i.e., bigger than any legitimate values the objective function is likely to take).</p>
</td></tr>
<tr><td><code id="probe_match_+3A_probes">probes</code></td>
<td>
<p>a single probe or a list of one or more probes.
A probe is simply a scalar- or vector-valued function of one argument that can be applied to the data array of a &lsquo;pomp&rsquo;.
A vector-valued probe must always return a vector of the same size.
A number of useful probes are provided with the package:
see <a href="#topic+basic_probes">basic probes</a>.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_nsim">nsim</code></td>
<td>
<p>the number of model simulations to be computed.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_seed">seed</code></td>
<td>
<p>integer.
When fitting, it is often best to fix the seed of the random-number generator (RNG).
This is accomplished by setting <code>seed</code> to an integer.
By default, <code>seed = NULL</code>, which does not alter the RNG state.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_rmeasure">rmeasure</code></td>
<td>
<p>simulator of the measurement model, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rmeasure=NULL</code> removes the measurement model simulator.
For more information, see <a href="#topic+rmeasure_spec">rmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_partrans">partrans</code></td>
<td>
<p>optional parameter transformations, constructed using <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
</p>
<p>Many algorithms for parameter estimation search an unconstrained space of parameters.
When working with such an algorithm and a model for which the parameters are constrained, it can be useful to transform parameters.
One should supply the <code>partrans</code> argument via a call to <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
For more information, see <a href="#topic+parameter_trans">parameter_trans</a>.
Setting <code>partrans=NULL</code> removes the parameter transformations, i.e., sets them to the identity transformation.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="probe_match_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In probe-matching, one attempts to minimize the discrepancy between simulated and actual data, as measured by a set of summary statistics called <em>probes</em>.
In <span class="pkg">pomp</span>, this discrepancy is measured using the &ldquo;synthetic likelihood&rdquo; as defined by Wood (2010).
</p>


<h3>Value</h3>

<p><code>probe_objfun</code> constructs a stateful objective function for probe matching.
Specifically, <code>probe_objfun</code> returns an object of class &lsquo;probe_match_objfun&rsquo;, which is a function suitable for use in an <code><a href="stats.html#topic+optim">optim</a></code>-like optimizer.
In particular, this function takes a single numeric-vector argument that is assumed to contain the parameters named in <code>est</code>, in that order.
When called, it will return the negative synthetic log likelihood for the probes specified.
It is a stateful function:
Each time it is called, it will remember the values of the parameters and its estimate of the synthetic likelihood.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Important Note</h3>

<p>Since <span class="pkg">pomp</span> cannot guarantee that the <em>final</em> call an optimizer makes to the function is a call <em>at</em> the optimum, it cannot guarantee that the parameters stored in the function are the optimal ones.
Therefore, it is a good idea to evaluate the function on the parameters returned by the optimization routine, which will ensure that these parameters are stored.
</p>


<h3>Warning! Objective functions based on C snippets</h3>

<p>If you use C snippets (see <code><a href="#topic+Csnippet">Csnippet</a></code>), a dynamically loadable library will be built.
As a rule, <span class="pkg">pomp</span> functions load this library as needed and unload it when it is no longer needed.
The stateful objective functions are an exception to this rule.
For efficiency, calls to the objective function do not execute <code><a href="#topic+pompLoad">pompLoad</a></code> or <code><a href="#topic+pompUnload">pompUnload</a></code>:
rather, it is assumed that <code><a href="#topic+pompLoad">pompLoad</a></code> has been called before any call to the objective function.
When a stateful objective function using one or more C snippets is created, <code><a href="#topic+pompLoad">pompLoad</a></code> is called internally to build and load the library:
therefore, within a single <span class="rlang"><b>R</b></span> session, if one creates a stateful objective function, one can freely call that objective function and (more to the point) pass it to an optimizer that calls it freely, without needing to call <code><a href="#topic+pompLoad">pompLoad</a></code>.
On the other hand, if one retrieves a stored objective function from a file, or passes one to another <span class="rlang"><b>R</b></span> session, one must call <code><a href="#topic+pompLoad">pompLoad</a></code> before using it.
<strong>Failure to do this will typically result in a segmentation fault (i.e., it will crash the <span class="rlang"><b>R</b></span> session).</strong>
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code> <code><a href="subplex.html#topic+subplex">subplex</a></code> <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>
</p>
<p>More on methods based on summary statistics: 
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+basic_probes">basic_probes</a></code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>
<p>More on <span class="pkg">pomp</span> estimation algorithms:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+estimation_algorithms">estimation_algorithms</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>
<p>More on maximization-based estimation methods:
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>,
<code><a href="#topic+traj_match">traj_match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  gompertz() -&gt; po
  
  ## A list of probes:
  plist &lt;- list(
    mean=probe_mean("Y",trim=0.1,transform=sqrt),
    sd=probe_sd("Y",transform=sqrt),
    probe_marginal("Y",ref=obs(po)),
    probe_acf("Y",lags=c(1,3,5),type="correlation",transform=sqrt),
    probe_quantile("Y",prob=c(0.25,0.75),na.rm=TRUE)
  )

  ## Construct the probe-matching objective function.
  ## Here, we just want to estimate 'K'.
  po |&gt;
    probe_objfun(probes=plist,nsim=100,seed=5069977,
      est="K") -&gt; f

  ## Any numerical optimizer can be used to minimize 'f'.
  if (require(subplex)) {

    subplex(fn=f,par=0.4,control=list(reltol=1e-5)) -&gt; out

  } else {

    optim(fn=f,par=0.4,control=list(reltol=1e-5)) -&gt; out

  }

  ## Call the objective one last time on the optimal parameters:
  f(out$par)
  coef(f)

  ## There are 'plot' and 'summary' methods:
  f |&gt; as("probed_pomp") |&gt; plot()
  f |&gt; summary()

  ## One can convert an objective function to a data frame:
  f |&gt; as("data.frame") |&gt; head()
  f |&gt; as("probed_pomp") |&gt; as("data.frame") |&gt; head()

  f |&gt; probe() |&gt; plot()

  ## One can modify the objective function with another call
  ## to 'probe_objfun':

  f |&gt; probe_objfun(est=c("r","K")) -&gt; f1
  optim(fn=f1,par=c(0.3,0.3),control=list(reltol=1e-5)) -&gt; out
  f1(out$par)
  coef(f1)

</code></pre>

<hr>
<h2 id='proposals'>MCMC proposal distributions</h2><span id='topic+proposals'></span><span id='topic+mvn_diag_rw'></span><span id='topic+mvn_rw'></span><span id='topic+mvn_rw_adaptive'></span>

<h3>Description</h3>

<p>Functions to construct proposal distributions for use with MCMC methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvn_diag_rw(rw.sd)

mvn_rw(rw.var)

mvn_rw_adaptive(
  rw.sd,
  rw.var,
  scale.start = NA,
  scale.cooling = 0.999,
  shape.start = NA,
  target = 0.234,
  max.scaling = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proposals_+3A_rw.sd">rw.sd</code></td>
<td>
<p>named numeric vector; random-walk SDs for a multivariate
normal random-walk proposal with diagonal variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="proposals_+3A_rw.var">rw.var</code></td>
<td>
<p>square numeric matrix with row- and column-names.  Specifies
the variance-covariance matrix for a multivariate normal random-walk
proposal distribution.</p>
</td></tr>
<tr><td><code id="proposals_+3A_scale.start">scale.start</code>, <code id="proposals_+3A_scale.cooling">scale.cooling</code>, <code id="proposals_+3A_shape.start">shape.start</code>, <code id="proposals_+3A_target">target</code>, <code id="proposals_+3A_max.scaling">max.scaling</code></td>
<td>
<p>parameters
to control the proposal adaptation algorithm.  Beginning with MCMC
iteration <code>scale.start</code>, the scale of the proposal covariance matrix
will be adjusted in an effort to match the <code>target</code> acceptance ratio.
This initial scale adjustment is &ldquo;cooled&rdquo;, i.e., the adjustment
diminishes as the chain moves along.  The parameter <code>scale.cooling</code>
specifies the cooling schedule: at n iterations after <code>scale.start</code>,
the current scaling factor is multiplied with <code>scale.cooling^n</code>.  The
maximum scaling factor allowed at any one iteration is <code>max.scaling</code>.
After <code>shape.start</code> accepted proposals have accumulated, a scaled
empirical covariance matrix will be used for the proposals, following
Roberts and Rosenthal (2009).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each of these calls constructs a function suitable for use as the
<code>proposal</code> argument of <code>pmcmc</code> or <code>abc</code>.  Given a parameter
vector, each such function returns a single draw from the corresponding
proposal distribution.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King, Sebastian Funk
</p>


<h3>References</h3>

<p>G.O. Roberts and J.S. Rosenthal. Examples of adaptive MCMC. <em>Journal of Computational and Graphical Statistics</em> <b>18</b>, 349&ndash;367, 2009.
</p>


<h3>See Also</h3>

<p>More on Markov chain Monte Carlo methods:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>
</p>

<hr>
<h2 id='pStop'>pStop, pWarn, pMess</h2><span id='topic+pStop'></span><span id='topic+pStop_'></span><span id='topic+pWarn'></span><span id='topic+pWarn_'></span><span id='topic+pMess'></span><span id='topic+pMess_'></span>

<h3>Description</h3>

<p>Custom error, warning, and message functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pStop(..., who = -1L)

pStop_(...)

pWarn(..., who = -1L)

pWarn_(...)

pMess(..., who = -1L)

pMess_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pStop_+3A_...">...</code></td>
<td>
<p>message</p>
</td></tr>
<tr><td><code id="pStop_+3A_who">who</code></td>
<td>
<p>integer or character.
If <code>who</code> is an integer, it is passed to <code><a href="base.html#topic+sys.call">sys.call</a></code> to retrieve the name of the calling function.
One can also pass the name of the calling function in <code>who</code>.
In either case, the name of the calling function is included in the message.</p>
</td></tr>
</table>

<hr>
<h2 id='reproducibility_tools'>Tools for reproducible computations</h2><span id='topic+reproducibility_tools'></span><span id='topic+bake'></span><span id='topic+stew'></span><span id='topic+freeze'></span>

<h3>Description</h3>

<p>Archiving of computations and control of the random-number generator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bake(
  file,
  expr,
  seed = NULL,
  kind = NULL,
  normal.kind = NULL,
  dependson = NULL,
  info = FALSE,
  timing = TRUE,
  dir = getOption("pomp_archive_dir", getwd())
)

stew(
  file,
  expr,
  seed = NULL,
  kind = NULL,
  normal.kind = NULL,
  dependson = NULL,
  info = FALSE,
  timing = TRUE,
  dir = getOption("pomp_archive_dir", getwd())
)

freeze(
  expr,
  seed = NULL,
  kind = NULL,
  normal.kind = NULL,
  envir = parent.frame(),
  enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reproducibility_tools_+3A_file">file</code></td>
<td>
<p>Name of the archive file in which the result will be stored or retrieved, as appropriate.
For <code>bake</code>, this will contain a single object and hence be an RDS file (extension &lsquo;rds&rsquo;);
for <code>stew</code>, this will contain one or more named objects and hence be an RDA file (extension &lsquo;rda&rsquo;).</p>
</td></tr>
<tr><td><code id="reproducibility_tools_+3A_expr">expr</code></td>
<td>
<p>Expression to be evaluated.</p>
</td></tr>
<tr><td><code id="reproducibility_tools_+3A_seed">seed</code>, <code id="reproducibility_tools_+3A_kind">kind</code>, <code id="reproducibility_tools_+3A_normal.kind">normal.kind</code></td>
<td>
<p>optional.
To set the state and of the RNG.
The default, <code>seed = NULL</code>, will not change the RNG state.
<code>seed</code> should be a single integer.
See <code><a href="base.html#topic+set.seed">set.seed</a></code> for more information.</p>
</td></tr>
<tr><td><code id="reproducibility_tools_+3A_dependson">dependson</code></td>
<td>
<p>arbitrary <span class="rlang"><b>R</b></span> object (optional).
Variables on which the computation in <code>expr</code> depends.
A hash of these objects will be archived in <code>file</code>, along with the results of evaluation <code>expr</code>.
When <code>bake</code> or <code>stew</code> are called and <code>file</code> exists, the hash of these objects will be compared against the archived hash;
recomputation is forced when these do not match.
The dependencies should be specified as unquoted symbols:
use a list if there are multiple dependencies.
See the note below about avoiding using &lsquo;pomp&rsquo; objects as dependencies.</p>
</td></tr>
<tr><td><code id="reproducibility_tools_+3A_info">info</code></td>
<td>
<p>logical.
If <code>TRUE</code>, the &ldquo;ingredients&rdquo; of the calculation are returned as a list.
In the case of <code>bake</code>, this list is the &ldquo;ingredients&rdquo; attribute of the returned object.
In the case of <code>stew</code>, this list is a hidden object named &ldquo;.ingredients&rdquo;, located in the environment within which <code>stew</code> was called.</p>
</td></tr>
<tr><td><code id="reproducibility_tools_+3A_timing">timing</code></td>
<td>
<p>logical.
If <code>TRUE</code>, the time required for the computation is returned.
This is returned as the &ldquo;system.time&rdquo; attribute of the returned object.</p>
</td></tr>
<tr><td><code id="reproducibility_tools_+3A_dir">dir</code></td>
<td>
<p>Directory holding archive files;
by default, this is the current working directory.
This can also be set using the global option <code>pomp_archive_dir</code>.
If it does not exist, this directory will be created (with a message).</p>
</td></tr>
<tr><td><code id="reproducibility_tools_+3A_envir">envir</code></td>
<td>
<p>the <code><a href="base.html#topic+environment">environment</a></code> in which <code>expr</code> is to
be evaluated.  May also be <code>NULL</code>, a list, a data frame,
a pairlist or an integer as specified to <code><a href="base.html#topic+sys.call">sys.call</a></code>.</p>
</td></tr>
<tr><td><code id="reproducibility_tools_+3A_enclos">enclos</code></td>
<td>
<p>Relevant when <code>envir</code> is a (pair)list or a data frame.
Specifies the enclosure, i.e., where <span class="rlang"><b>R</b></span> looks for objects not found
in <code>envir</code>.  This can be <code>NULL</code> (interpreted as the base
package environment, <code><a href="base.html#topic+baseenv">baseenv</a>()</code>) or an environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On cooking shows, recipes requiring lengthy baking or stewing are prepared beforehand.
The <code>bake</code> and <code>stew</code> functions perform analogously:
an computation is performed and archived in a named file.
If the function is called again and the file is present, the computation is not executed.
Instead, the results are loaded from the archive.
Moreover, via their optional <code>seed</code> argument, <code>bake</code> and <code>stew</code> can control the pseudorandom-number generator (RNG) for greater reproducibility.
After the computation is finished, these functions restore the pre-existing RNG state to avoid side effects.
</p>
<p>The <code>freeze</code> function doesn't save results, but does set the RNG state to the specified value and restore it after the computation is complete.
</p>
<p>Both <code>bake</code> and <code>stew</code> first test to see whether <code>file</code> exists.
If it does, <code>bake</code> reads it using <code><a href="base.html#topic+readRDS">readRDS</a></code> and returns the resulting object.
By contrast, <code>stew</code> loads the file using <code><a href="#topic+load">load</a></code> and copies the objects it contains into the user's workspace (or the environment of the call to <code>stew</code>).
</p>
<p>If <code>file</code> does not exist, then both <code>bake</code> and <code>stew</code> evaluate the expression <code>expr</code>;
they differ in the results that they save.
<code>bake</code> saves the value of the evaluated expression to <code>file</code> as a single object.
The name of that object is not saved.
By contrast, <code>stew</code> creates a local environment within which <code>expr</code> is evaluated; all objects in that environment are saved (by name) in <code>file</code>.
<code>bake</code> and <code>stew</code> also store information about the code executed, the dependencies, and the state of the random-number generator (if the latter is controlled) in the archive file.
Re-computation is triggered if any of these things change.
</p>


<h3>Value</h3>

<p><code>bake</code> returns the value of the evaluated expression <code>expr</code>.
Other objects created in the evaluation of <code>expr</code> are discarded along with the temporary, local environment created for the evaluation.
</p>
<p>The latter behavior differs from that of <code>stew</code>, which returns the names of the objects created during the evaluation of <code>expr</code>.
After <code>stew</code> completes, these objects are copied into the environment in which <code>stew</code> was called.
</p>
<p><code>freeze</code> returns the value of evaluated expression <code>expr</code>.
However, <code>freeze</code> evaluates <code>expr</code> within the parent environment, so other objects created in the evaluation of <code>expr</code> will therefore exist after <code>freeze</code> completes.
</p>
<p><code>bake</code> and <code>stew</code> store information about the code executed, the dependencies, and the state of the random-number generator in the archive file.
In the case of <code>bake</code>, this is recorded in the &ldquo;ingredients&rdquo; attribute (<code>attr(.,"ingredients")</code>);
in the <code>stew</code> case, this is recorded in an object, &ldquo;.ingredients&rdquo;, in the archive.
This information is returned only if <code>info=TRUE</code>.
</p>
<p>The time required for execution is also recorded.
<code>bake</code> stores this in the &ldquo;system.time&rdquo; attribute of the archived <span class="rlang"><b>R</b></span> object;
<code>stew</code> does so in a hidden variable named <code>.system.time</code>.
The timing is obtained using <code><a href="base.html#topic+system.time">system.time</a></code>.
</p>


<h3>Avoid using &lsquo;pomp&rsquo; objects as dependencies</h3>

<p>Note that when a &lsquo;pomp&rsquo; object is built with one or more <a href="#topic+Csnippet">C snippets</a>, the resulting code is &ldquo;salted&rdquo; with a random element to prevent collisions in parallel computations.
As a result, two such &lsquo;pomp&rsquo; objects will never match perfectly, even if the codes and data used to construct them are identical.
Therefore, avoid using &lsquo;pomp&rsquo; objects as dependencies in <code>bake</code> and <code>stew</code>.
</p>


<h3>Compatibility with older versions</h3>

<p>With <span class="pkg">pomp</span> version 3.4.4.2, the behavior of <code>bake</code> and <code>stew</code> changed.
In particular, older versions did no dependency checking, and did not check to see whether <code>expr</code> had changed.
Accordingly, the archive files written by older versions have a format that is not compatible with the newer ones.
When an archive file in the old format is encountered, it will be updated to the new format, with a warning message.
<strong>Note that this will overwrite existing archive files!</strong>
However, there will be no loss of information.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  bake(file="example1.rds",{
    x &lt;- runif(1000)
    mean(x)
  })

  bake(file="example1.rds",{
    x &lt;- runif(1000)
    mean(x)
  })

  bake(file="example1.rds",{
    a &lt;- 3
    x &lt;- runif(1000)
    mean(x)
  })

  a &lt;- 5
  b &lt;- 2

  stew(file="example2.rda",
    dependson=list(a,b),{
      x &lt;- runif(10)
      y &lt;- rnorm(n=10,mean=a*x+b,sd=2)
    })

  plot(x,y)

  set.seed(11)
  runif(2)
  freeze(runif(3),seed=5886730)
  runif(2)
  freeze(runif(3),seed=5886730)
  runif(2)

  set.seed(11)
  runif(2)
  runif(2)
  runif(2)


## End(Not run)
</code></pre>

<hr>
<h2 id='resample'>Resample</h2><span id='topic+resample'></span><span id='topic+systematic_resample'></span>

<h3>Description</h3>

<p>Systematic resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>systematic_resample(weights, Np = length(weights))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_weights">weights</code></td>
<td>
<p>numeric; vector of weights.</p>
</td></tr>
<tr><td><code id="resample_+3A_np">Np</code></td>
<td>
<p>integer scalar; number of samples to draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers containing the indices of the resample.
</p>

<hr>
<h2 id='ricker'>Ricker model with Poisson observations.</h2><span id='topic+ricker'></span>

<h3>Description</h3>

<p><code>ricker</code> is a &lsquo;pomp&rsquo; object encoding a stochastic Ricker model
with Poisson measurement error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ricker(r = exp(3.8), sigma = 0.3, phi = 10, c = 1, N_0 = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ricker_+3A_r">r</code></td>
<td>
<p>intrinsic growth rate</p>
</td></tr>
<tr><td><code id="ricker_+3A_sigma">sigma</code></td>
<td>
<p>environmental process noise s.d.</p>
</td></tr>
<tr><td><code id="ricker_+3A_phi">phi</code></td>
<td>
<p>sampling rate</p>
</td></tr>
<tr><td><code id="ricker_+3A_c">c</code></td>
<td>
<p>density dependence parameter</p>
</td></tr>
<tr><td><code id="ricker_+3A_n_0">N_0</code></td>
<td>
<p>initial condition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state process is <code class="reqn">N_{t+1} = r N_{t} \exp(-c N_{t}+e_{t})</code>, where the <code class="reqn">e_t</code> are i.i.d. normal
random deviates with zero mean and variance <code class="reqn">\sigma^2</code>.  The
observed variables <code class="reqn">y_t</code> are distributed as
<code class="reqn">\mathrm{Poisson}(\phi N_t)</code>.
</p>


<h3>Value</h3>

<p>A &lsquo;pomp&rsquo; object containing the Ricker model and simulated data.
</p>


<h3>See Also</h3>

<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+compartmental_models">compartmental_models</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+gompertz">gompertz</a>()</code>,
<code><a href="#topic+ou2">ou2</a>()</code>,
<code><a href="#topic+pomp_examples">pomp_examples</a></code>,
<code><a href="#topic+rw2">rw2</a>()</code>,
<code><a href="#topic+verhulst">verhulst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>po &lt;- ricker()
plot(po)
coef(po)
simulate(po) |&gt; plot()
 # takes too long for R CMD check
  ## generate a bifurcation diagram for the Ricker map
  p &lt;- parmat(coef(ricker()),nrep=500)
  p["r",] &lt;- exp(seq(from=1.5,to=4,length=500))
  trajectory(
    ricker(),
    times=seq(from=1000,to=2000,by=1),
    params=p,
    format="array"
  ) -&gt; x
  matplot(p["r",],x["N",,],pch='.',col='black',
    xlab=expression(log(r)),ylab="N",log='x')

</code></pre>

<hr>
<h2 id='rinit'>rinit workhorse</h2><span id='topic+rinit'></span><span id='topic+rinit+2CANY-method'></span><span id='topic+rinit+2Cmissing-method'></span><span id='topic+rinit+2Cpomp-method'></span>

<h3>Description</h3>

<p>Samples from the initial-state distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
rinit(object, params = coef(object), t0 = timezero(object), nsim = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rinit_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="rinit_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="rinit_+3A_t0">t0</code></td>
<td>
<p>the initial time, i.e., the time corresponding to the initial-state distribution.</p>
</td></tr>
<tr><td><code id="rinit_+3A_nsim">nsim</code></td>
<td>
<p>optional integer; the number of initial states to simulate per column of <code>params</code>.</p>
</td></tr>
<tr><td><code id="rinit_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rinit</code> returns an <code>nvar</code> x <code>nsim*ncol(params)</code> matrix of state-process initial conditions when given an <code>npar</code> x <code>nsim</code> matrix of parameters, <code>params</code>, and an initial time <code>t0</code>.
By default, <code>t0</code> is the initial time defined when the &lsquo;pomp&rsquo; object ws constructed.
</p>


<h3>See Also</h3>

<p>_spec of the initial-state distribution: <a href="#topic+rinit_spec">rinit_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>

<hr>
<h2 id='rinit_spec'>rinit specification</h2><span id='topic+rinit_spec'></span>

<h3>Description</h3>

<p>Specification of the initial-state distribution simulator, rinit.
</p>


<h3>Details</h3>

<p>To fully specify the unobserved Markov state process, one must give its distribution at the zero-time (<code>t0</code>).
One does this by furnishing a value for the <code>rinit</code> argument.
As usual, this can be provided either as a C snippet or as an <span class="rlang"><b>R</b></span> function.
In the former case, bear in mind that:
</p>

<ol>
<li><p> The goal of a this snippet is the construction of a state vector, i.e., the setting of the dynamical states at time <code class="reqn">t_0</code>.
</p>
</li>
<li><p> In addition to the parameters and covariates (if any), the variable <code>t</code>, containing the zero-time, will be defined in the context in which the snippet is executed.
</p>
</li>
<li> <p><strong>NB:</strong> The <code>statenames</code> argument plays a particularly important role when the rinit is specified using a C snippet.
In particular, every state variable must be named in <code>statenames</code>.
<strong>Failure to follow this rule will result in undefined behavior.</strong>
</p>
</li></ol>

<p><a href="#topic+Csnippet">General rules for writing C snippets can be found here</a>.
</p>
<p>If an <span class="rlang"><b>R</b></span> function is to be used, pass
</p>
<pre>
   rinit = f
</pre>
<p>to <code>pomp</code>, where <code>f</code> is a function with arguments that can include the initial time <code>t0</code>, any of the model parameters, and any covariates.
As usual, <code>f</code> may take additional arguments, provided these are passed along with it in the call to <code>pomp</code>.
<code>f</code> must return a named numeric vector of initial states.
It is of course important that the names of the states match the expectations of the other basic components.
</p>
<p>Note that the state-process <code>rinit</code> can be either deterministic (as in the default) or stochastic.
In the latter case, it samples from the distribution of the state process at the zero-time, <code>t0</code>.
</p>


<h3>Default behavior</h3>

<p>By default, <code>pomp</code> assumes that the initial distribution is concentrated on a single point.
In particular, any parameters in <code>params</code>, the names of which end in &ldquo;<code>_0</code>&rdquo; or &ldquo;<code>.0</code>&rdquo;, are assumed to be initial values of states.
When the state process is initialized, these are simply copied over as initial conditions.
The names of the resulting state variables are obtained by dropping the suffix.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rinit">rinit</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Starting with an existing pomp object

  verhulst() -&gt; po
  
  ## we add or change the initial-state simulator,
  ## rinit, using the 'rinit' argument in any 'pomp'
  ## elementary or estimation function (or in the
  ## 'pomp' constructor itself).
  ## Here, we pass the rinit specification to 'simulate'
  ## as an R function.

  po |&gt;
    simulate(
      rinit=function (n_0, ...) {
        c(n=rpois(n=1,lambda=n_0))
      }
    ) -&gt; sim

  ## We can also pass it as a C snippet:

  po |&gt;
    simulate(
      rinit=Csnippet("n = rpois(n_0);"),
      paramnames="n_0",
      statenames="n"
    ) -&gt; sim


</code></pre>

<hr>
<h2 id='rmeasure'>rmeasure workhorse</h2><span id='topic+rmeasure'></span><span id='topic+rmeasure+2CANY-method'></span><span id='topic+rmeasure+2Cmissing-method'></span><span id='topic+rmeasure+2Cpomp-method'></span>

<h3>Description</h3>

<p>Sample from the measurement model distribution, given values of the latent states and the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
rmeasure(
  object,
  x = states(object),
  times = time(object),
  params = coef(object),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmeasure_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="rmeasure_+3A_x">x</code></td>
<td>
<p>an array containing states of the unobserved process.
The dimensions of <code>x</code> are <code>nvars</code> x <code>nrep</code> x <code>ntimes</code>,
where <code>nvars</code> is the number of state variables,
<code>nrep</code> is the number of replicates,
and <code>ntimes</code> is the length of <code>times</code>.
One can also pass <code>x</code> as a named numeric vector, which is equivalent to the <code>nrep=1</code>, <code>ntimes=1</code> case.</p>
</td></tr>
<tr><td><code id="rmeasure_+3A_times">times</code></td>
<td>
<p>a numeric vector (length <code>ntimes</code>) containing times.
These must be in non-decreasing order.</p>
</td></tr>
<tr><td><code id="rmeasure_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="rmeasure_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rmeasure</code> returns a rank-3 array of dimensions
<code>nobs</code> x <code>nrep</code> x <code>ntimes</code>,
where <code>nobs</code> is the number of observed variables.
</p>


<h3>See Also</h3>

<p>Specification of the measurement-model simulator: <a href="#topic+rmeasure_spec">rmeasure_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>

<hr>
<h2 id='rmeasure_spec'>rmeasure specification</h2><span id='topic+rmeasure_spec'></span>

<h3>Description</h3>

<p>Specification of the measurement-model simulator, rmeasure.
</p>


<h3>Details</h3>

<p>The measurement model is the link between the data and the unobserved state process.
It can be specified either by using one or both of the <code>rmeasure</code> and <code>dmeasure</code> arguments.
</p>
<p>Suppose you have a procedure to simulate observations given the value of the latent state variables.
Then you can furnish </p>
<pre>
  rmeasure = f</pre>
<p>to <span class="pkg">pomp</span> algorithms,
where <code>f</code> is a C snippet or <span class="rlang"><b>R</b></span> function that implements your procedure.
</p>
<p>Using a C snippet is much preferred, due to its much greater computational efficiency.
See <code><a href="#topic+Csnippet">Csnippet</a></code> for general rules on writing C snippets.
</p>
<p>In writing an <code>rmeasure</code> C snippet, bear in mind that:
</p>

<ol>
<li><p> The goal of such a snippet is to fill the observables with random values drawn from the measurement model distribution.
Accordingly, each observable should be assigned a new value.
</p>
</li>
<li><p> In addition to the states, parameters, and covariates (if any), the variable <code>t</code>, containing the time of the observation, will be defined in the context in which the snippet is executed.
</p>
</li></ol>

<p>The demos and the tutorials on the <a href="https://kingaa.github.io/pomp/">package website</a> give examples.
</p>
<p>It is also possible, though far less efficient, to specify <code>rmeasure</code> using an <span class="rlang"><b>R</b></span> function.
In this case, specify the measurement model simulator by furnishing </p>
<pre>
  rmeasure = f</pre>
<p>to <code>pomp</code>, where <code>f</code> is an <span class="rlang"><b>R</b></span> function.
The arguments of <code>f</code> should be chosen from among the state variables, parameters, covariates, and time.
It must also have the argument <code>...</code>.
<code>f</code> must return a named numeric vector of length equal to the number of observable variables.
</p>


<h3>Default behavior</h3>

<p>The default <code>rmeasure</code> is undefined.
It will yield missing values (<code>NA</code>).
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmeasure">rmeasure</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## We start with the pre-built Ricker example:
  
  ricker() -&gt; po

  ## To change the measurement model simulator, rmeasure,
  ## we use the 'rmeasure' argument in any 'pomp'
  ## elementary or estimation function.
  ## Here, we pass the rmeasure specification to 'simulate'
  ## as an R function.

  po |&gt;
    simulate(
      rmeasure=function (N, phi, ...) {
        c(y=rpois(n=1,lambda=phi*N))
      }
    ) -&gt; sim

  ## We can also pass it as a C snippet:

  po |&gt;
    simulate(
      rmeasure=Csnippet("y = rpois(phi*N);"),
      paramnames="phi",
      statenames="N"
    ) -&gt; sim


</code></pre>

<hr>
<h2 id='rprior'>rprior workhorse</h2><span id='topic+rprior'></span><span id='topic+rprior+2CANY-method'></span><span id='topic+rprior+2Cmissing-method'></span><span id='topic+rprior+2Cpomp-method'></span>

<h3>Description</h3>

<p>Sample from the prior probability distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
rprior(object, params = coef(object), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rprior_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="rprior_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="rprior_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing the required samples.
</p>


<h3>See Also</h3>

<p>Specification of the prior distribution simulator: <a href="#topic+prior_spec">prior_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>
<p>More on Bayesian methods:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>
</p>

<hr>
<h2 id='rprocess'>rprocess workhorse</h2><span id='topic+rprocess'></span><span id='topic+rprocess+2CANY-method'></span><span id='topic+rprocess+2Cmissing-method'></span><span id='topic+rprocess+2Cpomp-method'></span>

<h3>Description</h3>

<p><code>rprocess</code> simulates the process-model portion of partially-observed Markov process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
rprocess(
  object,
  x0 = rinit(object),
  t0 = timezero(object),
  times = time(object),
  params = coef(object),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rprocess_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="rprocess_+3A_x0">x0</code></td>
<td>
<p>an <code>nvar</code> x <code>nrep</code> matrix containing the starting state of the system.
Columns of <code>x0</code> correspond to states;
rows to components of the state vector.
One independent simulation will be performed for each column.
Note that in this case, <code>params</code> must also have <code>nrep</code> columns.</p>
</td></tr>
<tr><td><code id="rprocess_+3A_t0">t0</code></td>
<td>
<p>the initial time, i.e., the time corresponding to the state in <code>x0</code>.</p>
</td></tr>
<tr><td><code id="rprocess_+3A_times">times</code></td>
<td>
<p>a numeric vector (length <code>ntimes</code>) containing times.
These must be in non-decreasing order.</p>
</td></tr>
<tr><td><code id="rprocess_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x0</code>.</p>
</td></tr>
<tr><td><code id="rprocess_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>rprocess</code> is called, <code>t0</code> is taken to be the initial time (i.e., that corresponding to <code>x0</code>).
The values in <code>times</code> are the times at which the state of the simulated processes are required.
</p>


<h3>Value</h3>

<p><code>rprocess</code> returns a rank-3 array with rownames.
Suppose <code>x</code> is the array returned.
Then </p>
<pre>dim(x)=c(nvars,nrep,ntimes),</pre>
<p>where <code>nvars</code> is the number of state variables (=<code>nrow(x0)</code>),
<code>nrep</code> is the number of independent realizations simulated (=<code>ncol(x0)</code>), and
<code>ntimes</code> is the length of the vector <code>times</code>.
<code>x[,j,k]</code> is the value of the state process in the <code>j</code>-th realization at time <code>times[k]</code>.
The rownames of <code>x</code> will correspond to those of <code>x0</code>.
</p>


<h3>See Also</h3>

<p>Specification of the process-model simulator: <a href="#topic+rprocess_spec">rprocess_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>

<hr>
<h2 id='rprocess_spec'>rprocess specification</h2><span id='topic+rprocess_spec'></span><span id='topic+onestep'></span><span id='topic+discrete_time'></span><span id='topic+euler'></span><span id='topic+gillespie'></span><span id='topic+gillespie_hl'></span>

<h3>Description</h3>

<p>Specification of the latent state process simulator, rprocess.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onestep(step.fun)

discrete_time(step.fun, delta.t = 1)

euler(step.fun, delta.t)

gillespie(rate.fun, v, hmax = Inf)

gillespie_hl(..., .pre = "", .post = "", hmax = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rprocess_spec_+3A_step.fun">step.fun</code></td>
<td>
<p>a C snippet, an R function, or
the name of a native routine in a shared-object library.
This gives a procedure by which one simulates a single step of the latent state process.</p>
</td></tr>
<tr><td><code id="rprocess_spec_+3A_delta.t">delta.t</code></td>
<td>
<p>positive numerical value; for <code>euler</code> and <code>discrete_time</code>, the size of the step to take</p>
</td></tr>
<tr><td><code id="rprocess_spec_+3A_rate.fun">rate.fun</code></td>
<td>
<p>a C snippet, an R function, or
the name of a native routine in a shared-object library.
This gives a procedure by which one computes the event-rate of the elementary events in the continuous-time latent Markov chain.</p>
</td></tr>
<tr><td><code id="rprocess_spec_+3A_v">v</code></td>
<td>
<p>integer matrix; giving the stoichiometry of the continuous-time latent Markov process.
It should have dimensions <code>nvar</code> x <code>nevent</code>, where <code>nvar</code> is the number of state variables and <code>nevent</code> is the number of elementary events.
<code>v</code> describes the changes that occur in each elementary event:
it will usually comprise the values 1, -1, and 0 according to whether a state variable is incremented, decremented, or unchanged in an elementary event.
The rows of <code>v</code> may be unnamed or named.
If the rows are unnamed, they are assumed to be in the same order as the vector of state variables returned by <code>rinit</code>.
If the rows are named,
the names of the state variables returned by <code>rinit</code> will be matched
to the rows of <code>v</code> to ensure a correct mapping.
If any of the row names of <code>v</code> cannot be found among the state variables or if any row names of <code>v</code> are duplicated, an error will occur.</p>
</td></tr>
<tr><td><code id="rprocess_spec_+3A_hmax">hmax</code></td>
<td>
<p>maximum time step allowed (see below)</p>
</td></tr>
<tr><td><code id="rprocess_spec_+3A_...">...</code></td>
<td>
<p>individual C snippets corresponding to elementary events</p>
</td></tr>
<tr><td><code id="rprocess_spec_+3A_.pre">.pre</code>, <code id="rprocess_spec_+3A_.post">.post</code></td>
<td>
<p>C snippets (see Details)</p>
</td></tr>
</table>


<h3>Discrete-time processes</h3>

<p>If the state process evolves in discrete time, specify <code>rprocess</code> using the <code>discrete_time</code> plug-in.
Specifically, provide
</p>
<pre>
    rprocess = discrete_time(step.fun = f, delta.t),
</pre>
<p>where <code>f</code> is a C snippet or <span class="rlang"><b>R</b></span> function that simulates one step of the state process.
The former is the preferred option, due to its much greater computational efficiency.
The goal of such a C snippet is to replace the state variables with their new random values at the end of the time interval.
Accordingly, each state variable should be over-written with its new value.
In addition to the states, parameters, covariates (if any), and observables, the variables <code>t</code> and <code>dt</code>, containing respectively the time at the beginning of the step and the step's duration, will be defined in the context in which the C snippet is executed.
See <code><a href="#topic+Csnippet">Csnippet</a></code> for general rules on writing C snippets.
Examples are to be found in the tutorials on the <a href="https://kingaa.github.io/pomp/">package website</a>.
</p>
<p>If <code>f</code> is given as an <span class="rlang"><b>R</b></span> function, its arguments should come from the state variables, parameters, covariates, and time.
It may also take the argument &lsquo;<code>delta.t</code>&rsquo;;
when called, the latter will be the timestep.
It must also have the argument &lsquo;<code>...</code>&rsquo;.
It should return a named vector of length equal to the number of state variables, representing a draw from the distribution of the state process at time <code>t+delta.t</code> conditional on its value at time <code>t</code>.
</p>


<h3>Continuous-time processes</h3>

<p>If the state process evolves in continuous time, but you can use an Euler approximation, implement <code>rprocess</code> using the <code>euler</code> plug-in.
Specify
</p>
<pre>
    rprocess = euler(step.fun = f, delta.t)
</pre>
<p>in this case.
As before, <code>f</code> can be provided either as a C snippet or as an <span class="rlang"><b>R</b></span> function, the former resulting in much quicker computations.
The form of <code>f</code> will be the same as above (in the discrete-time case).
</p>
<p>If you have a procedure that allows you, given the value of the state process at any time,
to simulate it at an arbitrary time in the future, use the <code>onestep</code> plug-in.
To do so, specify
</p>
<pre>
    rprocess = onestep(step.fun = f).
</pre>
<p>Again, <code>f</code> can be provided either as a C snippet or as an <span class="rlang"><b>R</b></span> function, the former resulting in much quicker computations.
The form of <code>f</code> should be as above (in the discrete-time or Euler cases).
</p>


<h3>Size of time step</h3>

<p>The simulator plug-ins <code>discrete_time</code>, <code>euler</code>, and <code>onestep</code> all work by taking discrete time steps.
They differ as to how this is done.
Specifically,
</p>

<ol>
<li> <p><code>onestep</code> takes a single step to go from any given time <code>t1</code> to any later time <code>t2</code> (<code>t1 &lt; t2</code>).
Thus, this plug-in is designed for use in situations where a closed-form solution to the process exists.
</p>
</li>
<li><p> To go from <code>t1</code> to <code>t2</code>, <code>euler</code> takes <code>n</code> steps of equal size, where
</p>
<pre>
    n = ceiling((t2-t1)/delta.t).
</pre>
</li>
<li> <p><code>discrete_time</code> assumes that the process evolves in discrete time, where the interval between successive times is <code>delta.t</code>.
Thus, to go from <code>t1</code> to <code>t2</code>, <code>discrete_time</code> takes <code>n</code> steps of size exactly <code>delta.t</code>, where
</p>
<pre>
    n = floor((t2-t1)/delta.t).
</pre>
</li></ol>



<h3>Exact (event-driven) simulations</h3>

<p>If you desire exact simulation of certain continuous-time Markov chains, an implementation of Gillespie's algorithm (Gillespie 1977) is available,
via the <code>gillespie</code> and <code>gillespie_hl</code> plug-ins.
The former allows for the rate function to be provided as an <span class="rlang"><b>R</b></span> function or a single C snippet,
while the latter provides a means of specifying the elementary events via a list of C snippets.
</p>
<p>A high-level interface to the simulator is provided by <code>gillespie_hl</code>.
To use it, supply
</p>
<pre>
    rprocess = gillespie_hl(..., .pre = "", .post = "", hmax = Inf)
</pre>
<p>to <code>pomp</code>.
Each argument in <code>...</code> corresponds to a single elementary event and should be a list containing two elements.
The first should be a string or C snippet;
the second should be a named integer vector.
The variable <code>rate</code> will exist in the context of the C snippet, as will the parameter, state variables, covariates, and the time <code>t</code>.
The C snippet should assign to the variable <code>rate</code> the corresponding elementary event rate.
</p>
<p>The named integer vector specifies the changes to the state variables corresponding to the elementary event.
There should be named value for each of the state variables returned by <code>rinit</code>.
The arguments <code>.pre</code> and <code>.post</code> can be used to provide C code that will run respectively before and after the elementary-event snippets.
These hooks can be useful for avoiding duplication of code that performs calculations needed to obtain several of the different event rates.
</p>
<p>Here's how a simple birth-death model might be specified:
</p>
<pre>
    gillespie_hl(
        birth=list("rate = b*N;",c(N=1)),
        death=list("rate = m*N;",c(N=-1))
    )
</pre>
<p>In the above, the state variable <code>N</code> represents the population size and parameters <code>b</code>, <code>m</code> are the birth and death rates, respectively.
</p>
<p>To use the lower-level <code>gillespie</code> interface, furnish
</p>
<pre>
    rprocess = gillespie(rate.fun = f, v, hmax = Inf)
</pre>
<p>to <code>pomp</code>, where <code>f</code> gives the rates of the elementary events.
Here, <code>f</code> may be an <span class="rlang"><b>R</b></span> function of the form
</p>
<pre>
    f(j, x, t, params, ...)
</pre>
<p>When <code>f</code> is called,
the integer <code>j</code> will be the number of the elementary event (corresponding to the column the matrix <code>v</code>, see below),
<code>x</code> will be a named numeric vector containing the value of the state process at time <code>t</code> and
<code>params</code> is a named numeric vector containing parameters.
<code>f</code> should return a single numerical value, representing the rate of that elementary event at that point in state space and time.
</p>
<p>Here, the stoichiometric matrix <code>v</code> specifies the continuous-time Markov process in terms of its elementary events.
It should have dimensions <code>nvar</code> x <code>nevent</code>, where <code>nvar</code> is the number of state variables and <code>nevent</code> is the number of elementary events.
<code>v</code> describes the changes that occur in each elementary event:
it will usually comprise the values 1, -1, and 0 according to whether a state variable is incremented, decremented, or unchanged in an elementary event.
The rows of <code>v</code> should have names corresponding to the state variables.
If any of the row names of <code>v</code> cannot be found among the state variables or if any row names of <code>v</code> are duplicated, an error will occur.
</p>
<p>It is also possible to provide a C snippet via the <code>rate.fun</code> argument to <code>gillespie</code>.
Such a snippet should assign the correct value to a <code>rate</code> variable depending on the value of <code>j</code>.
The same variables will be available as for the C code provided to <code>gillespie_hl</code>.
This lower-level interface may be preferable if it is easier to write code that calculates the correct rate based on <code>j</code> rather than to write a snippet for each possible value of <code>j</code>.
For example, if the number of possible values of <code>j</code> is large and the rates vary according to a few simple rules, the lower-level interface may provide the easier way of specifying the model.
</p>
<p>When the process is non-autonomous (i.e., the event rates depend explicitly on time), it can be useful to set <code>hmax</code> to the maximum step that will be taken.
By default, the elementary event rates will be recomputed at least once per observation interval.
</p>


<h3>Default behavior</h3>

<p>The default <code>rprocess</code> is undefined.
It will yield missing values (<code>NA</code>) for all state variables.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rprocess">rprocess</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>

<hr>
<h2 id='rw_sd'>rw_sd</h2><span id='topic+rw_sd'></span>

<h3>Description</h3>

<p>Specifying random-walk intensities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rw_sd(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rw_sd_+3A_...">...</code></td>
<td>
<p>Specification of the random-walk intensities (as standard deviations).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+mif2">mif2</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mif2">mif2</a></code>
</p>

<hr>
<h2 id='rw2'>Two-dimensional random-walk process</h2><span id='topic+rw2'></span>

<h3>Description</h3>

<p><code>rw2</code> constructs a &lsquo;pomp&rsquo; object encoding a 2-D Gaussian random walk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rw2(x1_0 = 0, x2_0 = 0, s1 = 1, s2 = 3, tau = 1, times = 1:100, t0 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rw2_+3A_x1_0">x1_0</code>, <code id="rw2_+3A_x2_0">x2_0</code></td>
<td>
<p>initial conditions (i.e., latent state variable values at the zero time <code>t0</code>)</p>
</td></tr>
<tr><td><code id="rw2_+3A_s1">s1</code>, <code id="rw2_+3A_s2">s2</code></td>
<td>
<p>random walk intensities</p>
</td></tr>
<tr><td><code id="rw2_+3A_tau">tau</code></td>
<td>
<p>observation error s.d.</p>
</td></tr>
<tr><td><code id="rw2_+3A_times">times</code></td>
<td>
<p>observation times</p>
</td></tr>
<tr><td><code id="rw2_+3A_t0">t0</code></td>
<td>
<p>zero time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random-walk process is fully but noisily observed.
</p>


<h3>Value</h3>

<p>A &lsquo;pomp&rsquo; object containing simulated data.
</p>


<h3>See Also</h3>

<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+compartmental_models">compartmental_models</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+gompertz">gompertz</a>()</code>,
<code><a href="#topic+ou2">ou2</a>()</code>,
<code><a href="#topic+pomp_examples">pomp_examples</a></code>,
<code><a href="#topic+ricker">ricker</a>()</code>,
<code><a href="#topic+verhulst">verhulst</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  if (require(ggplot2)) {

    rw2() |&gt; plot()

    rw2(s1=1,s2=1,tau=0.1) |&gt;
      simulate(nsim=10,format="d") |&gt;
      ggplot(aes(x=y1,y=y2,group=.id,color=.id))+
      geom_path()+
      guides(color="none")+
      theme_bw()

  }

</code></pre>

<hr>
<h2 id='sannbox'>Simulated annealing with box constraints.</h2><span id='topic+sannbox'></span>

<h3>Description</h3>

<p>A straightforward implementation of simulated annealing with box constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sannbox(par, fn, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sannbox_+3A_par">par</code></td>
<td>
<p>Initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="sannbox_+3A_fn">fn</code></td>
<td>
<p>A function to be minimized, with first argument the vector of
parameters over which minimization is to take place.  It should return a
scalar result.</p>
</td></tr>
<tr><td><code id="sannbox_+3A_control">control</code></td>
<td>
<p>A named list of control parameters.  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="sannbox_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>control</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt>trace</dt><dd><p> Non-negative integer.
If positive, tracing information on the progress of the optimization is
produced.  Higher values may produce more tracing information.  </p>
</dd>
<dt>fnscale</dt><dd><p> An overall scaling to be applied to the value of
<code>fn</code> during optimization.  If negative, turns the problem into a
maximization problem.  Optimization is performed on <code>fn(par)/fnscale</code>.</p>
</dd>
<dt>parscale</dt><dd><p> A vector of scaling values for the parameters.
Optimization is performed on <code>par/parscale</code> and these should be
comparable in the sense that a unit change in any element produces about a
unit change in the scaled value.  </p>
</dd>
<dt>maxit</dt><dd><p> The total number of function evaluations: there is no
other stopping criterion.  Defaults to <code>10000</code>.  </p>
</dd>
<dt>temp</dt><dd><p> starting temperature for the cooling
schedule.  Defaults to <code>1</code>.  </p>
</dd>
<dt>tmax</dt><dd><p> number of function evaluations at each temperature.
Defaults to <code>10</code>.  </p>
</dd>
<dt>candidate.dist</dt><dd><p> function to randomly select a new candidate
parameter vector.  This should be a function with three arguments, the
first being the current parameter vector, the second the temperature, and
the third the parameter scaling.  By default, <code>candidate.dist</code> is
</p>
<pre>function(par,temp,scale)
                rnorm(n=length(par),mean=par,sd=scale*temp).</pre> </dd>
<dt>sched</dt><dd><p> cooling schedule.  A function of a three arguments giving the
temperature as a function of iteration number and the control parameters
<code>temp</code> and <code>tmax</code>.
By default, <code>sched</code> is
</p>
<pre>function(k,temp,tmax) temp/log(((k-1)%/%tmax)*tmax+exp(1)).</pre>
<p>Alternatively, one can supply a numeric vector of temperatures.
This must be of length at least <code>maxit</code>. </p>
</dd>
<dt>lower,upper</dt><dd><p> optional
numeric vectors.  These describe the lower and upper box constraints,
respectively.  Each can be specified either as a single scalar (common to
all parameters) or as a vector of the same length as <code>par</code>.  By
default, <code>lower=-Inf</code> and <code>upper=Inf</code>, i.e., there are no
constraints.</p>
</dd> </dl>



<h3>Value</h3>

<p><code>sannbox</code> returns a list with components:
</p>

<dl>
<dt>counts</dt><dd>
<p>two-element integer vector.
The first number gives the number of calls made to <code>fn</code>.
The second number is provided for compatibility with <code><a href="stats.html#topic+optim">optim</a></code> and will always be NA.
</p>
</dd>
<dt>convergence</dt><dd>
<p>provided for compatibility with <code><a href="stats.html#topic+optim">optim</a></code>;
will always be 0.
</p>
</dd>
<dt>final.params</dt><dd><p>last tried value of <code>par</code>.</p>
</dd>
<dt>final.value</dt><dd><p>value of <code>fn</code> corresponding to
<code>final.params</code>.</p>
</dd>
<dt>par</dt><dd><p>best tried value of <code>par</code>.</p>
</dd>
<dt>value</dt><dd><p>value of <code>fn</code> corresponding to <code>par</code>.</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Daniel Reuman, Aaron A. King
</p>


<h3>See Also</h3>

<p><a href="#topic+traj_match">trajectory matching</a>, <a href="#topic+probe_match">probe matching</a>, <a href="#topic+spect_match">spectrum matching</a>, <a href="#topic+nlf">nonlinear forecasting</a>.
</p>

<hr>
<h2 id='saved_states'>Saved states</h2><span id='topic+saved_states'></span><span id='topic+saved_states+2CANY-method'></span><span id='topic+saved_states+2Cmissing-method'></span><span id='topic+saved_states+2Cpfilterd_pomp-method'></span><span id='topic+saved_states+2CpfilterList-method'></span>

<h3>Description</h3>

<p>Retrieve latent state trajectories from a particle filter calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pfilterd_pomp'
saved_states(object, ..., format = c("list", "data.frame"))

## S4 method for signature 'pfilterList'
saved_states(object, ..., format = c("list", "data.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saved_states_+3A_object">object</code></td>
<td>
<p>result of a filtering computation</p>
</td></tr>
<tr><td><code id="saved_states_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="saved_states_+3A_format">format</code></td>
<td>
<p>character;
format of the returned object (see below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When one calls <code><a href="#topic+pfilter">pfilter</a></code> with <code>save.states=TRUE</code>, the latent state vector associated with each particle is saved.
This can be extracted by calling <code>saved_states</code> on the &lsquo;pfilterd.pomp&rsquo; object.
These are the <em>unweighted</em> particles, saved <em>after</em> resampling.
</p>


<h3>Value</h3>

<p>According to the <code>format</code> argument, the saved states are returned either as a list or a data frame.
</p>
<p>If <code>format="data.frame"</code>, then the returned data frame holds the state variables and (optionally) the unnormalized log weight of each particle at each observation time.
The <code>.id</code> variable distinguishes particles.
</p>
<p>If <code>format="list"</code> and <code><a href="#topic+pfilter">pfilter</a></code> was called with <code>save.states="unweighted"</code> or <code>save.states="TRUE"</code>, the returned list contains one element per observation time.
Each element consists of a matrix, with one row for each state variable and one column for each particle.
If <code><a href="#topic+pfilter">pfilter</a></code> was called with <code>save.states="weighted"</code>, the list itself contains two lists:
the first holds the particles as above, the second holds the corresponding unnormalized log weights.
In particular, it has one element per observation time; each element is the vector of per-particle log weights.
</p>


<h3>See Also</h3>

<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='show'>Show methods</h2><span id='topic+show'></span><span id='topic+show+2Cunshowable-method'></span><span id='topic+show+2Clistie-method'></span><span id='topic+show+2CrprocPlugin-method'></span><span id='topic+show+2ConestepRprocPlugin-method'></span><span id='topic+show+2CdiscreteRprocPlugin-method'></span><span id='topic+show+2CeulerRprocPlugin-method'></span><span id='topic+show+2CgillespieRprocPlugin-method'></span><span id='topic+show+2Cpomp_fun-method'></span><span id='topic+show+2CpartransPlugin-method'></span><span id='topic+show+2Ccovartable-method'></span><span id='topic+show+2CskelPlugin-method'></span><span id='topic+show+2CvectorfieldPlugin-method'></span><span id='topic+show+2CmapPlugin-method'></span>

<h3>Description</h3>

<p>Display the object, according to its class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unshowable'
show(object)

## S4 method for signature 'listie'
show(object)

## S4 method for signature 'rprocPlugin'
show(object)

## S4 method for signature 'onestepRprocPlugin'
show(object)

## S4 method for signature 'discreteRprocPlugin'
show(object)

## S4 method for signature 'eulerRprocPlugin'
show(object)

## S4 method for signature 'gillespieRprocPlugin'
show(object)

## S4 method for signature 'pomp_fun'
show(object)

## S4 method for signature 'partransPlugin'
show(object)

## S4 method for signature 'covartable'
show(object)

## S4 method for signature 'skelPlugin'
show(object)

## S4 method for signature 'vectorfieldPlugin'
show(object)

## S4 method for signature 'mapPlugin'
show(object)
</code></pre>

<hr>
<h2 id='simulate'>Simulations of a partially-observed Markov process</h2><span id='topic+simulate'></span><span id='topic+simulate+2Cmissing-method'></span><span id='topic+simulate+2Cdata.frame-method'></span><span id='topic+simulate+2Cpomp-method'></span><span id='topic+simulate+2Cobjfun-method'></span>

<h3>Description</h3>

<p><code>simulate</code> generates simulations of the state and measurement
processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
simulate(
  nsim = 1,
  seed = NULL,
  times,
  t0,
  params,
  rinit,
  rprocess,
  rmeasure,
  format = c("pomps", "arrays", "data.frame"),
  include.data = FALSE,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'data.frame'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  times,
  t0,
  params,
  rinit,
  rprocess,
  rmeasure,
  format = c("pomps", "arrays", "data.frame"),
  include.data = FALSE,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  format = c("pomps", "arrays", "data.frame"),
  include.data = FALSE,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'objfun'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to perform.
Note that the number of replicates will be <code>nsim</code> times <code>ncol(params)</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_seed">seed</code></td>
<td>
<p>optional;
if set, the pseudorandom number generator (RNG) will be initialized with <code>seed</code>.  the random seed to use.
The RNG will be restored to its original state afterward.</p>
</td></tr>
<tr><td><code id="simulate_+3A_times">times</code></td>
<td>
<p>the sequence of observation times.
<code>times</code> must indicate the column of observation times by name or index.
The time vector must be numeric and non-decreasing.</p>
</td></tr>
<tr><td><code id="simulate_+3A_t0">t0</code></td>
<td>
<p>The zero-time, i.e., the time of the initial state.
This must be no later than the time of the first observation, i.e., <code>t0 &lt;= times[1]</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_params">params</code></td>
<td>
<p>a named numeric vector or a matrix with rownames
containing the parameters at which the simulations are to be performed.</p>
</td></tr>
<tr><td><code id="simulate_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_rmeasure">rmeasure</code></td>
<td>
<p>simulator of the measurement model, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rmeasure=NULL</code> removes the measurement model simulator.
For more information, see <a href="#topic+rmeasure_spec">rmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_format">format</code></td>
<td>
<p>the format in which to return the results.
</p>
<p><code>format = "pomps"</code> causes the results to be returned as a single &ldquo;pomp&rdquo; object,
identical to <code>object</code> except for the latent states and observations,
which have been replaced by the simulated values.
</p>
<p><code>format = "arrays"</code> causes the results to be returned as a list of two arrays.
The &ldquo;states&rdquo; element will contain the simulated state trajectories in a rank-3 array with dimensions
<code>nvar</code> x <code>(ncol(params)*nsim)</code> x <code>ntimes</code>.
Here, <code>nvar</code> is the number of state variables and <code>ntimes</code> the length of the argument <code>times</code>.
The &ldquo;obs&rdquo; element will contain the simulated data, returned as a rank-3 array with dimensions
<code>nobs</code> x <code>(ncol(params)*nsim)</code> x <code>ntimes</code>.
Here, <code>nobs</code> is the number of observables.
</p>
<p><code>format = "data.frame"</code> causes the results to be returned as a single data frame containing
the time, states, and observations.
An ordered factor variable, &lsquo;.id&rsquo;, distinguishes one simulation from another.</p>
</td></tr>
<tr><td><code id="simulate_+3A_include.data">include.data</code></td>
<td>
<p>if <code>TRUE</code>, the original data and covariates (if any) are included (with <code>.id = "data"</code>).
This option is ignored unless <code>format = "data.frame"</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="simulate_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>
<p>optional;
if present, it should be a data frame or a &lsquo;pomp&rsquo; object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single &ldquo;pomp&rdquo; object,
a &ldquo;pompList&rdquo; object,
a named list of two arrays,
or a data frame, according to the <code>format</code> option.
</p>
<p>If <code>params</code> is a matrix, each column is treated as a distinct parameter set.
In this case, if <code>nsim=1</code>,
then <code>simulate</code> will return one simulation for each parameter set.
If <code>nsim&gt;1</code>,
then <code>simulate</code> will yield <code>nsim</code> simulations for each parameter set.
These will be ordered such that
the first <code>ncol(params)</code> simulations represent one simulation
from each of the distinct parameter sets,
the second <code>ncol(params)</code> simulations represent a second simulation from each,
and so on.
</p>
<p>Adding column names to <code>params</code> can be helpful.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>See Also</h3>

<p>More on <span class="pkg">pomp</span> elementary algorithms: 
<code><a href="#topic+elementary_algorithms">elementary_algorithms</a></code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>

<hr>
<h2 id='skeleton'>skeleton workhorse</h2><span id='topic+skeleton'></span><span id='topic+skeleton+2CANY-method'></span><span id='topic+skeleton+2Cmissing-method'></span><span id='topic+skeleton+2Cpomp-method'></span>

<h3>Description</h3>

<p>Evaluates the deterministic skeleton at a point or points in state space, given parameters.
In the case of a discrete-time system, the skeleton is a map.
In the case of a continuous-time system, the skeleton is a vectorfield.
NB: <code>skeleton</code> just evaluates the deterministic skeleton;
it does not iterate or integrate (see <code><a href="#topic+flow">flow</a></code> and <code><a href="#topic+trajectory">trajectory</a></code> for this).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
skeleton(
  object,
  x = states(object),
  times = time(object),
  params = coef(object),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skeleton_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_x">x</code></td>
<td>
<p>an array containing states of the unobserved process.
The dimensions of <code>x</code> are <code>nvars</code> x <code>nrep</code> x <code>ntimes</code>,
where <code>nvars</code> is the number of state variables,
<code>nrep</code> is the number of replicates,
and <code>ntimes</code> is the length of <code>times</code>.
One can also pass <code>x</code> as a named numeric vector, which is equivalent to the <code>nrep=1</code>, <code>ntimes=1</code> case.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_times">times</code></td>
<td>
<p>a numeric vector (length <code>ntimes</code>) containing times.
These must be in non-decreasing order.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>skeleton</code> returns an array of dimensions <code>nvar</code> x <code>nrep</code> x <code>ntimes</code>.
If <code>f</code> is the returned matrix, <code>f[i,j,k]</code> is the i-th component of the deterministic skeleton at time <code>times[k]</code> given the state <code>x[,j,k]</code> and parameters <code>params[,j]</code>.
</p>


<h3>See Also</h3>

<p>Specification of the deterministic skeleton: <a href="#topic+skeleton_spec">skeleton_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>
<p>More on methods for deterministic process models: 
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+traj_match">traj_match</a></code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>
</p>

<hr>
<h2 id='skeleton_spec'>skeleton specification</h2><span id='topic+skeleton_spec'></span><span id='topic+vectorfield'></span><span id='topic+map'></span>

<h3>Description</h3>

<p>Specification of the deterministic skeleton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorfield(f)

map(f, delta.t = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skeleton_spec_+3A_f">f</code></td>
<td>
<p>procedure for evaluating the deterministic skeleton
This can be a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a native routine in a dynamically linked library.</p>
</td></tr>
<tr><td><code id="skeleton_spec_+3A_delta.t">delta.t</code></td>
<td>
<p>positive numerical value; the size of the discrete time step corresponding to an application of the map</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The skeleton is a dynamical system that expresses the central tendency of the unobserved Markov state process.
As such, it is not uniquely defined, but can be both interesting in itself and useful in practice.
In <span class="pkg">pomp</span>, the skeleton is used by <code><a href="#topic+trajectory">trajectory</a></code> and <code><a href="#topic+traj_objfun">traj_objfun</a></code>.
</p>
<p>If the state process is a discrete-time stochastic process, then the skeleton is a discrete-time map.
To specify it, provide </p>
<pre>
  skeleton = map(f, delta.t)</pre>
<p>to <code>pomp</code>, where <code>f</code> implements the map and <code>delta.t</code> is the size of the timestep covered at one map iteration.
</p>
<p>If the state process is a continuous-time stochastic process, then the skeleton is a vectorfield (i.e., a system of ordinary differential equations).
To specify it, supply </p>
<pre>
  skeleton = vectorfield(f)</pre>
<p>to <code>pomp</code>, where <code>f</code> implements the vectorfield, i.e., the right-hand-size of the differential equations.
</p>
<p>In either case, <code>f</code> can be furnished either as a C snippet (the preferred choice), or an <span class="rlang"><b>R</b></span> function.
<a href="#topic+Csnippet">General rules for writing C snippets can be found here</a>.
In writing a <code>skeleton</code> C snippet, be aware that:
</p>

<ol>
<li><p> For each state variable, there is a corresponding component of the deterministic skeleton.
The goal of such a snippet is to compute all the components.
</p>
</li>
<li><p> When the skeleton is a map, the component corresponding to state variable <code>x</code> is named <code>Dx</code> and is the new value of <code>x</code> after one iteration of the map.
</p>
</li>
<li><p> When the skeleton is a vectorfield, the component corresponding to state variable <code>x</code> is named <code>Dx</code> and is the value of <code class="reqn">dx/dt</code>.
</p>
</li>
<li><p> As with the other C snippets, all states, parameters and covariates, as well as the current time, <code>t</code>, will be defined in the context within which the snippet is executed.
</p>
</li>
<li> <p><b>NB:</b> When the skeleton is a map, the duration of the timestep will <b>not</b> be defined in the context within which the snippet is executed.
When the skeleton is a vectorfield, of course, no timestep is defined.
In this regard, C snippets for the skeleton and rprocess components differ.
</p>
</li></ol>

<p>The tutorials on the <a href="https://kingaa.github.io/pomp/">package website</a> give some examples.
</p>
<p>If <code>f</code> is an <span class="rlang"><b>R</b></span> function, its arguments should be taken from among the state variables, parameters, covariates, and time.
It must also take the argument &lsquo;<code>...</code>&rsquo;.
As with the other basic components, <code>f</code> may take additional arguments, provided these are passed along with it in the call to <code>pomp</code>.
The function <code>f</code> must return a numeric vector of the same length as the number of state variables, which contains the value of the map or vectorfield at the required point and time.
</p>


<h3>Masking of <code>map</code></h3>

<p>Other packages (most notably the <span class="pkg">tidyverse</span> package <span class="pkg">purrr</span>) have functions named &lsquo;map&rsquo;.
Beware that, if you load one of these packages after you load <span class="pkg">pomp</span>, the <span class="pkg">pomp</span> function <code>map</code> described here will be masked.
You can always access the <span class="pkg">pomp</span> function by calling <code>pomp::map</code>.
</p>


<h3>Default behavior</h3>

<p>The default <code>skeleton</code> is undefined.
It will yield missing values (<code>NA</code>) for all state variables.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+skeleton">skeleton</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>
<p>More on methods for deterministic process models: 
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+traj_match">traj_match</a></code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Starting with an existing pomp object,
  ## e.g., the continuous-time Verhulst-Pearl model,

  verhulst() -&gt; po
  
  ## we add or change the deterministic skeleton
  ## using the 'skeleton' argument in any 'pomp'
  ## elementary or estimation function
  ## (or in the 'pomp' constructor itself).
  ## Here, we pass the skeleton specification
  ## to 'trajectory' as an R function.
  ## Since this is a continuous-time POMP, the
  ## skeleton is a vectorfield.

  po |&gt;
    trajectory(
      skeleton=vectorfield(
        function(r, K, n, ...) {
          c(n=r*n*(1-n/K))
        }
      ),
      format="data.frame"
    ) -&gt; traj

  ## We can also pass it as a C snippet:

  po |&gt;
    traj_objfun(
      skeleton=vectorfield(Csnippet("Dn=r*n*(1-n/K);")),
      paramnames=c("r","K"),
      statenames="n"
    ) -&gt; ofun

  ofun()

  ## For a discrete-time POMP, the deterministic skeleton
  ## is a map.  For example,

  gompertz() -&gt; po

  po |&gt;
    traj_objfun(
      skeleton=map(
        Csnippet("
          double dt = 1.0;
          double s = exp(-r*dt);
          DX = pow(K,(1-s))*pow(X,s);"
        ), delta.t=1
      ),
      paramnames=c("r","K"),
      statenames=c("X")
    ) -&gt; ofun

  ofun()


</code></pre>

<hr>
<h2 id='spect'>Power spectrum</h2><span id='topic+spect'></span><span id='topic+spect+2Cmissing-method'></span><span id='topic+spect+2CANY-method'></span><span id='topic+spect+2Cdata.frame-method'></span><span id='topic+spect+2Cpomp-method'></span><span id='topic+spect+2Cspectd_pomp-method'></span><span id='topic+spect+2Cspect_match_objfun-method'></span><span id='topic+spect+2Cobjfun-method'></span>

<h3>Description</h3>

<p>Power spectrum computation and spectrum-matching for partially-observed
Markov processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
spect(
  data,
  vars,
  kernel.width,
  nsim,
  seed = NULL,
  transform.data = identity,
  detrend = c("none", "mean", "linear", "quadratic"),
  params,
  rinit,
  rprocess,
  rmeasure,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
spect(
  data,
  vars,
  kernel.width,
  nsim,
  seed = NULL,
  transform.data = identity,
  detrend = c("none", "mean", "linear", "quadratic"),
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'spectd_pomp'
spect(
  data,
  vars,
  kernel.width,
  nsim,
  seed = NULL,
  transform.data,
  detrend,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'spect_match_objfun'
spect(data, seed, ..., verbose = getOption("verbose", FALSE))

## S4 method for signature 'objfun'
spect(data, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spect_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="spect_+3A_vars">vars</code></td>
<td>
<p>optional; names of observed variables for which the power spectrum will be computed.
By default, the spectrum will be computed for all observables.</p>
</td></tr>
<tr><td><code id="spect_+3A_kernel.width">kernel.width</code></td>
<td>
<p>width parameter for the smoothing kernel used for
calculating the estimate of the spectrum.</p>
</td></tr>
<tr><td><code id="spect_+3A_nsim">nsim</code></td>
<td>
<p>number of model simulations to be computed.</p>
</td></tr>
<tr><td><code id="spect_+3A_seed">seed</code></td>
<td>
<p>optional; if non-<code>NULL</code>, the random number generator will
be initialized with this seed for simulations.
See <code><a href="#topic+simulate">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="spect_+3A_transform.data">transform.data</code></td>
<td>
<p>function; this transformation will be applied to the
observables prior to estimation of the spectrum, and prior to any
detrending.</p>
</td></tr>
<tr><td><code id="spect_+3A_detrend">detrend</code></td>
<td>
<p>de-trending operation to perform.  Options include no
detrending, and subtraction of constant, linear, and quadratic trends from
the data.  Detrending is applied to each data series and to each model
simulation independently.</p>
</td></tr>
<tr><td><code id="spect_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="spect_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="spect_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="spect_+3A_rmeasure">rmeasure</code></td>
<td>
<p>simulator of the measurement model, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rmeasure=NULL</code> removes the measurement model simulator.
For more information, see <a href="#topic+rmeasure_spec">rmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="spect_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="spect_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spect</code> estimates the power spectrum of time series data and model
simulations and compares the results.  It can be used to diagnose goodness
of fit and/or as the basis for frequency-domain parameter estimation
(<code>spect.match</code>).
</p>
<p>A call to <code>spect</code> results in the estimation of the power spectrum for
the (transformed, detrended) data and <code>nsim</code> model simulations.  The
results of these computations are stored in an object of class
&lsquo;spectd_pomp&rsquo;.
</p>
<p>When <code>spect</code> operates on a spectrum-matching objective function (a &lsquo;spect_match_objfun&rsquo; object), by default, the
random-number generator seed is fixed at the value given when the objective function was constructed.
Specifying <code>NULL</code> or an integer for <code>seed</code> overrides this behavior.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;spectd_pomp&rsquo;, which contains the model, the data, and the results of the <code>spect</code> computation.
The following methods are available:
</p>

<dl>
<dt>plot</dt><dd><p>produces some diagnostic plots</p>
</dd>
<dt>summary</dt><dd><p>displays a summary</p>
</dd>
<dt>logLik</dt><dd><p>gives a measure of the agreement of the power spectra</p>
</dd>
</dl>



<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Daniel C. Reuman, Cai GoGwilt, Aaron A. King
</p>


<h3>References</h3>

<p>D.C. Reuman, R.A. Desharnais, R.F. Costantino, O. Ahmad, J.E. Cohen. Power spectra reveal the influence of stochasticity on nonlinear population dynamics. <em>Proceedings of the National Academy of Sciences</em> <b>103</b>, 18860-18865, 2006
</p>
<p>D.C. Reuman, R.F. Costantino, R.A. Desharnais, J.E. Cohen. Color of environmental noise affects the nonlinear dynamics of cycling, stage-structured populations. <em>Ecology Letters</em> <b>11</b>, 820-830, 2008.
</p>


<h3>See Also</h3>

<p>More on methods based on summary statistics: 
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+basic_probes">basic_probes</a></code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>
<p>More on <span class="pkg">pomp</span> elementary algorithms: 
<code><a href="#topic+elementary_algorithms">elementary_algorithms</a></code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>

<hr>
<h2 id='spect_match'>Spectrum matching</h2><span id='topic+spect_match'></span><span id='topic+spect_objfun'></span><span id='topic+spect_objfun+2Cmissing-method'></span><span id='topic+spect_objfun+2CANY-method'></span><span id='topic+spect_objfun+2Cdata.frame-method'></span><span id='topic+spect_objfun+2Cpomp-method'></span><span id='topic+spect_objfun+2Cspectd_pomp-method'></span><span id='topic+spect_objfun+2Cspect_match_objfun-method'></span>

<h3>Description</h3>

<p>Estimation of parameters by matching power spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
spect_objfun(
  data,
  est = character(0),
  weights = 1,
  fail.value = NA,
  vars,
  kernel.width,
  nsim,
  seed = NULL,
  transform.data = identity,
  detrend = c("none", "mean", "linear", "quadratic"),
  params,
  rinit,
  rprocess,
  rmeasure,
  partrans,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
spect_objfun(
  data,
  est = character(0),
  weights = 1,
  fail.value = NA,
  vars,
  kernel.width,
  nsim,
  seed = NULL,
  transform.data = identity,
  detrend = c("none", "mean", "linear", "quadratic"),
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'spectd_pomp'
spect_objfun(
  data,
  est = character(0),
  weights = 1,
  fail.value = NA,
  vars,
  kernel.width,
  nsim,
  seed = NULL,
  transform.data = identity,
  detrend,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'spect_match_objfun'
spect_objfun(
  data,
  est,
  weights,
  fail.value,
  seed = NULL,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spect_match_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_est">est</code></td>
<td>
<p>character vector; the names of parameters to be estimated.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_weights">weights</code></td>
<td>
<p>optional numeric or function.
The mismatch between model and data is measured by a weighted average of mismatch at each frequency.
By default, all frequencies are weighted equally.
<code>weights</code> can be specified either as a vector (which must have length equal to the number of frequencies) or as a function of frequency.
If the latter, <code>weights(freq)</code> must return a nonnegative weight for each frequency.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_fail.value">fail.value</code></td>
<td>
<p>optional numeric scalar;
if non-<code>NA</code>, this value is substituted for non-finite values of the objective function.
It should be a large number (i.e., bigger than any legitimate values the objective function is likely to take).</p>
</td></tr>
<tr><td><code id="spect_match_+3A_vars">vars</code></td>
<td>
<p>optional; names of observed variables for which the power spectrum will be computed.
By default, the spectrum will be computed for all observables.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_kernel.width">kernel.width</code></td>
<td>
<p>width parameter for the smoothing kernel used for
calculating the estimate of the spectrum.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_nsim">nsim</code></td>
<td>
<p>the number of model simulations to be computed.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_seed">seed</code></td>
<td>
<p>integer.
When fitting, it is often best to fix the seed of the random-number generator (RNG).
This is accomplished by setting <code>seed</code> to an integer.
By default, <code>seed = NULL</code>, which does not alter the RNG state.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_transform.data">transform.data</code></td>
<td>
<p>function; this transformation will be applied to the
observables prior to estimation of the spectrum, and prior to any
detrending.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_detrend">detrend</code></td>
<td>
<p>de-trending operation to perform.  Options include no
detrending, and subtraction of constant, linear, and quadratic trends from
the data.  Detrending is applied to each data series and to each model
simulation independently.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_rmeasure">rmeasure</code></td>
<td>
<p>simulator of the measurement model, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rmeasure=NULL</code> removes the measurement model simulator.
For more information, see <a href="#topic+rmeasure_spec">rmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_partrans">partrans</code></td>
<td>
<p>optional parameter transformations, constructed using <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
</p>
<p>Many algorithms for parameter estimation search an unconstrained space of parameters.
When working with such an algorithm and a model for which the parameters are constrained, it can be useful to transform parameters.
One should supply the <code>partrans</code> argument via a call to <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
For more information, see <a href="#topic+parameter_trans">parameter_trans</a>.
Setting <code>partrans=NULL</code> removes the parameter transformations, i.e., sets them to the identity transformation.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="spect_match_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In spectrum matching, one attempts to minimize the discrepancy between a <abbr><span class="acronym">POMP</span></abbr> model's predictions and data, as measured in the frequency domain by the power spectrum.
</p>
<p><code>spect_objfun</code> constructs an objective function that measures the discrepancy.
It can be passed to any one of a variety of numerical optimization routines, which will adjust model parameters to minimize the discrepancies between the power spectrum of model simulations and that of the data.
</p>


<h3>Value</h3>

<p><code>spect_objfun</code> constructs a stateful objective function for spectrum matching.
Specifically, <code>spect_objfun</code> returns an object of class &lsquo;spect_match_objfun&rsquo;, which is a function suitable for use in an <code><a href="stats.html#topic+optim">optim</a></code>-like optimizer.
This function takes a single numeric-vector argument that is assumed to contain the parameters named in <code>est</code>, in that order.
When called, it will return the (optionally weighted) <code class="reqn">L^2</code> distance between the data spectrum and simulated spectra.
It is a stateful function:
Each time it is called, it will remember the values of the parameters and the discrepancy measure.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Important Note</h3>

<p>Since <span class="pkg">pomp</span> cannot guarantee that the <em>final</em> call an optimizer makes to the function is a call <em>at</em> the optimum, it cannot guarantee that the parameters stored in the function are the optimal ones.
Therefore, it is a good idea to evaluate the function on the parameters returned by the optimization routine, which will ensure that these parameters are stored.
</p>


<h3>Warning! Objective functions based on C snippets</h3>

<p>If you use C snippets (see <code><a href="#topic+Csnippet">Csnippet</a></code>), a dynamically loadable library will be built.
As a rule, <span class="pkg">pomp</span> functions load this library as needed and unload it when it is no longer needed.
The stateful objective functions are an exception to this rule.
For efficiency, calls to the objective function do not execute <code><a href="#topic+pompLoad">pompLoad</a></code> or <code><a href="#topic+pompUnload">pompUnload</a></code>:
rather, it is assumed that <code><a href="#topic+pompLoad">pompLoad</a></code> has been called before any call to the objective function.
When a stateful objective function using one or more C snippets is created, <code><a href="#topic+pompLoad">pompLoad</a></code> is called internally to build and load the library:
therefore, within a single <span class="rlang"><b>R</b></span> session, if one creates a stateful objective function, one can freely call that objective function and (more to the point) pass it to an optimizer that calls it freely, without needing to call <code><a href="#topic+pompLoad">pompLoad</a></code>.
On the other hand, if one retrieves a stored objective function from a file, or passes one to another <span class="rlang"><b>R</b></span> session, one must call <code><a href="#topic+pompLoad">pompLoad</a></code> before using it.
<strong>Failure to do this will typically result in a segmentation fault (i.e., it will crash the <span class="rlang"><b>R</b></span> session).</strong>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spect">spect</a></code> <code><a href="stats.html#topic+optim">optim</a></code>
<code><a href="subplex.html#topic+subplex">subplex</a></code> <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>
</p>
<p>More on <span class="pkg">pomp</span> estimation algorithms:
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+estimation_algorithms">estimation_algorithms</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>
</p>
<p>More on methods based on summary statistics: 
<code><a href="#topic+abc">abc</a>()</code>,
<code><a href="#topic+basic_probes">basic_probes</a></code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect">spect</a>()</code>
</p>
<p>More on maximization-based estimation methods:
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+traj_match">traj_match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  ricker() |&gt;
    spect_objfun(
      est=c("r","sigma","N_0"),
      partrans=parameter_trans(log=c("r","sigma","N_0")),
      paramnames=c("r","sigma","N_0"),
      kernel.width=3,
      nsim=100,
      seed=5069977
    ) -&gt; f

  f(log(c(20,0.3,10)))
  f |&gt; spect() |&gt; plot()

  if (require(subplex)) {
    subplex(fn=f,par=log(c(20,0.3,10)),control=list(reltol=1e-5)) -&gt; out
  } else {
    optim(fn=f,par=log(c(20,0.3,10)),control=list(reltol=1e-5)) -&gt; out
  }
  f(out$par)

  f |&gt; summary()

  f |&gt; spect() |&gt; plot()


</code></pre>

<hr>
<h2 id='spy'>Spy</h2><span id='topic+spy'></span><span id='topic+spy+2Cmissing-method'></span><span id='topic+spy+2CANY-method'></span><span id='topic+spy+2Cpomp-method'></span>

<h3>Description</h3>

<p>Peek into the inside of one of <span class="pkg">pomp</span>'s objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
spy(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spy_+3A_object">object</code></td>
<td>
<p>the object whose structure we wish to examine</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Csnippet
</p>
<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='states'>Latent states</h2><span id='topic+states'></span><span id='topic+states+2CANY-method'></span><span id='topic+states+2Cmissing-method'></span><span id='topic+states+2Cpomp-method'></span><span id='topic+states+2Clistie-method'></span>

<h3>Description</h3>

<p>Extract the latent states from a &lsquo;pomp&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
states(object, vars, ..., format = c("array", "data.frame"))

## S4 method for signature 'listie'
states(object, vars, ..., format = c("array", "data.frame"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="states_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class extending &lsquo;pomp&rsquo;</p>
</td></tr>
<tr><td><code id="states_+3A_vars">vars</code></td>
<td>
<p>names of variables to retrieve</p>
</td></tr>
<tr><td><code id="states_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="states_+3A_format">format</code></td>
<td>
<p>format of the returned object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='summary'>Summary methods</h2><span id='topic+summary'></span><span id='topic+summary+2Cprobed_pomp-method'></span><span id='topic+summary+2Cspectd_pomp-method'></span><span id='topic+summary+2Cobjfun-method'></span>

<h3>Description</h3>

<p>Display a summary of a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'probed_pomp'
summary(object, ...)

## S4 method for signature 'spectd_pomp'
summary(object, ...)

## S4 method for signature 'objfun'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>a fitted model object</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>ignored or passed to the more primitive function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='time'>Methods to extract and manipulate the obseration times</h2><span id='topic+time'></span><span id='topic+time+3C-'></span><span id='topic+time+2Cmissing-method'></span><span id='topic+time+2Cpomp-method'></span><span id='topic+time+3C-+2Cpomp-method'></span><span id='topic+time+2Clistie-method'></span>

<h3>Description</h3>

<p>Get and set the vector of observation times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
time(x, t0 = FALSE, ...)

## S4 replacement method for signature 'pomp'
time(object, t0 = FALSE, ...) &lt;- value

## S4 method for signature 'listie'
time(x, t0 = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_+3A_x">x</code></td>
<td>
<p>a &lsquo;pomp&rsquo; object</p>
</td></tr>
<tr><td><code id="time_+3A_t0">t0</code></td>
<td>
<p>logical; should the zero time be included?</p>
</td></tr>
<tr><td><code id="time_+3A_...">...</code></td>
<td>
<p>ignored or passed to the more primitive function</p>
</td></tr>
<tr><td><code id="time_+3A_object">object</code></td>
<td>
<p>a &lsquo;pomp&rsquo; object</p>
</td></tr>
<tr><td><code id="time_+3A_value">value</code></td>
<td>
<p>numeric vector; the new vector of times</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time(object)</code> returns the vector of observation times.
<code>time(object,t0=TRUE)</code> returns the vector of observation
times with the zero-time <code>t0</code> prepended.
</p>
<p><code>time(object) &lt;- value</code> replaces the observation times slot (<code>times</code>) of <code>object</code> with <code>value</code>.
<code>time(object,t0=TRUE) &lt;- value</code> has the same effect, but the first element in <code>value</code> is taken to be the initial time.
The second and subsequent elements of <code>value</code> are taken to be the observation times.
Those data and states (if they exist) corresponding to the new times are retained.
</p>


<h3>See Also</h3>

<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='timezero'>The zero time</h2><span id='topic+timezero'></span><span id='topic+timezero+3C-'></span><span id='topic+timezero+2Cmissing-method'></span><span id='topic+timezero+2CANY-method'></span><span id='topic+timezero+3C-+2Cmissing-method'></span><span id='topic+timezero+3C-+2CANY-method'></span><span id='topic+timezero+2Cpomp-method'></span><span id='topic+timezero+3C-+2Cpomp-method'></span>

<h3>Description</h3>

<p>Get and set the zero-time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
timezero(object, ...)

## S4 replacement method for signature 'pomp'
timezero(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timezero_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;</p>
</td></tr>
<tr><td><code id="timezero_+3A_...">...</code></td>
<td>
<p>ignored or passed to the more primitive function</p>
</td></tr>
<tr><td><code id="timezero_+3A_value">value</code></td>
<td>
<p>numeric; the new zero-time value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the zero time
</p>


<h3>See Also</h3>

<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+traces">traces</a>()</code>
</p>

<hr>
<h2 id='traces'>Traces</h2><span id='topic+traces'></span><span id='topic+traces+2Cmissing-method'></span><span id='topic+traces+2CANY-method'></span><span id='topic+traces+2Cmif2d_pomp-method'></span><span id='topic+traces+2Cmif2List-method'></span><span id='topic+traces+2Cabcd_pomp-method'></span><span id='topic+traces+2CabcList-method'></span><span id='topic+traces+2Cpmcmcd_pomp-method'></span><span id='topic+traces+2CpmcmcList-method'></span>

<h3>Description</h3>

<p>Retrieve the history of an iterative calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mif2d_pomp'
traces(object, pars, transform = FALSE, ...)

## S4 method for signature 'mif2List'
traces(object, pars, ...)

## S4 method for signature 'abcd_pomp'
traces(object, pars, ...)

## S4 method for signature 'abcList'
traces(object, pars, ...)

## S4 method for signature 'pmcmcd_pomp'
traces(object, pars, ...)

## S4 method for signature 'pmcmcList'
traces(object, pars, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traces_+3A_object">object</code></td>
<td>
<p>an object of class extending &lsquo;pomp&rsquo;, the result of the application of a parameter estimation algorithm</p>
</td></tr>
<tr><td><code id="traces_+3A_pars">pars</code></td>
<td>
<p>names of parameters</p>
</td></tr>
<tr><td><code id="traces_+3A_transform">transform</code></td>
<td>
<p>logical; should the traces be transformed back onto the natural scale?</p>
</td></tr>
<tr><td><code id="traces_+3A_...">...</code></td>
<td>
<p>ignored or passed to the more primitive function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code><a href="#topic+pmcmc">pmcmc</a></code> does not currently support parameter transformations.
</p>


<h3>Value</h3>

<p>When <code>object</code> is the result of a <code><a href="#topic+mif2">mif2</a></code> calculation,
<code>traces(object, pars)</code> returns the traces of the parameters named in <code>pars</code>.
By default, the traces of all parameters are returned.
If <code>transform=TRUE</code>, the parameters are transformed from the natural scale to the estimation scale.
</p>
<p>When <code>object</code> is a &lsquo;abcd_pomp&rsquo;, <code>traces(object)</code>
extracts the traces as a <code>coda::mcmc</code>.
</p>
<p>When <code>object</code> is a &lsquo;abcList&rsquo;, <code>traces(object)</code>
extracts the traces as a <code>coda::mcmc.list</code>.
</p>
<p>When <code>object</code> is a &lsquo;pmcmcd_pomp&rsquo;, <code>traces(object)</code>
extracts the traces as a <code>coda::mcmc</code>.
</p>
<p>When <code>object</code> is a &lsquo;pmcmcList&rsquo;, <code>traces(object)</code>
extracts the traces as a <code>coda::mcmc.list</code>.
</p>


<h3>See Also</h3>

<p>Other extraction methods: 
<code><a href="#topic+coef">coef</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+covmat">covmat</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+forecast">forecast</a>()</code>,
<code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+obs">obs</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>,
<code><a href="#topic+spy">spy</a>()</code>,
<code><a href="#topic+states">states</a>()</code>,
<code><a href="#topic+summary">summary</a>()</code>,
<code><a href="#topic+time">time</a>()</code>,
<code><a href="#topic+timezero">timezero</a>()</code>
</p>

<hr>
<h2 id='traj_match'>Trajectory matching</h2><span id='topic+traj_match'></span><span id='topic+traj_objfun'></span><span id='topic+traj_objfun+2Cmissing-method'></span><span id='topic+traj_objfun+2CANY-method'></span><span id='topic+traj_objfun+2Cdata.frame-method'></span><span id='topic+traj_objfun+2Cpomp-method'></span><span id='topic+traj_objfun+2Ctraj_match_objfun-method'></span>

<h3>Description</h3>

<p>Estimation of parameters for deterministic <abbr><span class="acronym">POMP</span></abbr> models via trajectory matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
traj_objfun(
  data,
  est = character(0),
  fail.value = NA,
  ode_control = list(),
  params,
  rinit,
  skeleton,
  dmeasure,
  partrans,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
traj_objfun(
  data,
  est = character(0),
  fail.value = NA,
  ode_control = list(),
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'traj_match_objfun'
traj_objfun(
  data,
  est,
  fail.value,
  ode_control,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traj_match_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="traj_match_+3A_est">est</code></td>
<td>
<p>character vector; the names of parameters to be estimated.</p>
</td></tr>
<tr><td><code id="traj_match_+3A_fail.value">fail.value</code></td>
<td>
<p>optional numeric scalar;
if non-<code>NA</code>, this value is substituted for non-finite values of the objective function.
It should be a large number (i.e., bigger than any legitimate values the objective function is likely to take).</p>
</td></tr>
<tr><td><code id="traj_match_+3A_ode_control">ode_control</code></td>
<td>
<p>optional list;
the elements of this list will be passed to <code><a href="deSolve.html#topic+ode">ode</a></code> if the skeleton is a vectorfield, and ignored if it is a map.</p>
</td></tr>
<tr><td><code id="traj_match_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="traj_match_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="traj_match_+3A_skeleton">skeleton</code></td>
<td>
<p>optional; the deterministic skeleton of the unobserved state process.
Depending on whether the model operates in continuous or discrete time, this is either a vectorfield or a map.
Accordingly, this is supplied using either the <code><a href="#topic+skeleton_spec">vectorfield</a></code> or <code><a href="#topic+skeleton_spec">map</a></code> fnctions.
For more information, see <a href="#topic+skeleton_spec">skeleton specification</a>.
Setting <code>skeleton=NULL</code> removes the deterministic skeleton.</p>
</td></tr>
<tr><td><code id="traj_match_+3A_dmeasure">dmeasure</code></td>
<td>
<p>evaluator of the measurement model density, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>dmeasure=NULL</code> removes the measurement density evaluator.
For more information, see <a href="#topic+dmeasure_spec">dmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="traj_match_+3A_partrans">partrans</code></td>
<td>
<p>optional parameter transformations, constructed using <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
</p>
<p>Many algorithms for parameter estimation search an unconstrained space of parameters.
When working with such an algorithm and a model for which the parameters are constrained, it can be useful to transform parameters.
One should supply the <code>partrans</code> argument via a call to <code><a href="#topic+parameter_trans">parameter_trans</a></code>.
For more information, see <a href="#topic+parameter_trans">parameter_trans</a>.
Setting <code>partrans=NULL</code> removes the parameter transformations, i.e., sets them to the identity transformation.</p>
</td></tr>
<tr><td><code id="traj_match_+3A_...">...</code></td>
<td>
<p>additional arguments will modify the model structure</p>
</td></tr>
<tr><td><code id="traj_match_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In trajectory matching, one attempts to minimize the discrepancy between a <abbr><span class="acronym">POMP</span></abbr> model's predictions and data under the assumption that the latent state process is deterministic and all discrepancies between model and data are due to measurement error.
The measurement model likelihood (<code>dmeasure</code>), or rather its negative, is the natural measure of the discrepancy.
</p>
<p>Trajectory matching is a generalization of the traditional nonlinear least squares approach.
In particular, if, on some scale, measurement errors are normal with constant variance, then trajectory matching is equivalent to least squares on that particular scale.
</p>
<p><code>traj_objfun</code> constructs an objective function that evaluates the likelihood function.
It can be passed to any one of a variety of numerical optimization routines, which will adjust model parameters to minimize the discrepancies between the power spectrum of model simulations and that of the data.
</p>


<h3>Value</h3>

<p><code>traj_objfun</code> constructs a stateful objective function for spectrum matching.
Specifically, <code>traj_objfun</code> returns an object of class &lsquo;traj_match_objfun&rsquo;, which is a function suitable for use in an <code><a href="stats.html#topic+optim">optim</a></code>-like optimizer.
In particular, this function takes a single numeric-vector argument that is assumed to contain the parameters named in <code>est</code>, in that order.
When called, it will return the negative log likelihood.
It is a stateful function:
Each time it is called, it will remember the values of the parameters and its estimate of the log likelihood.
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Important Note</h3>

<p>Since <span class="pkg">pomp</span> cannot guarantee that the <em>final</em> call an optimizer makes to the function is a call <em>at</em> the optimum, it cannot guarantee that the parameters stored in the function are the optimal ones.
Therefore, it is a good idea to evaluate the function on the parameters returned by the optimization routine, which will ensure that these parameters are stored.
</p>


<h3>Warning! Objective functions based on C snippets</h3>

<p>If you use C snippets (see <code><a href="#topic+Csnippet">Csnippet</a></code>), a dynamically loadable library will be built.
As a rule, <span class="pkg">pomp</span> functions load this library as needed and unload it when it is no longer needed.
The stateful objective functions are an exception to this rule.
For efficiency, calls to the objective function do not execute <code><a href="#topic+pompLoad">pompLoad</a></code> or <code><a href="#topic+pompUnload">pompUnload</a></code>:
rather, it is assumed that <code><a href="#topic+pompLoad">pompLoad</a></code> has been called before any call to the objective function.
When a stateful objective function using one or more C snippets is created, <code><a href="#topic+pompLoad">pompLoad</a></code> is called internally to build and load the library:
therefore, within a single <span class="rlang"><b>R</b></span> session, if one creates a stateful objective function, one can freely call that objective function and (more to the point) pass it to an optimizer that calls it freely, without needing to call <code><a href="#topic+pompLoad">pompLoad</a></code>.
On the other hand, if one retrieves a stored objective function from a file, or passes one to another <span class="rlang"><b>R</b></span> session, one must call <code><a href="#topic+pompLoad">pompLoad</a></code> before using it.
<strong>Failure to do this will typically result in a segmentation fault (i.e., it will crash the <span class="rlang"><b>R</b></span> session).</strong>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="subplex.html#topic+subplex">subplex</a></code>, <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>
</p>
<p>More on methods for deterministic process models: 
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>
</p>
<p>More on maximization-based estimation methods:
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+nlf">nlf</a></code>,
<code><a href="#topic+probe_match">probe_match</a></code>,
<code><a href="#topic+spect_match">spect_match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  ricker() |&gt;
    traj_objfun(
      est=c("r","sigma","N_0"),
      partrans=parameter_trans(log=c("r","sigma","N_0")),
      paramnames=c("r","sigma","N_0"),
      ) -&gt; f

  f(log(c(20,0.3,10)))

  if (require(subplex)) {
    subplex(fn=f,par=log(c(20,0.3,10)),control=list(reltol=1e-5)) -&gt; out
  } else {
    optim(fn=f,par=log(c(20,0.3,10)),control=list(reltol=1e-5)) -&gt; out
  }

  f(out$par)

  if (require(ggplot2)) {

    f |&gt;
      trajectory(format="data.frame") |&gt;
      ggplot(aes(x=time,y=N))+geom_line()+theme_bw()

  }


</code></pre>

<hr>
<h2 id='trajectory'>Trajectory of a deterministic model</h2><span id='topic+trajectory'></span><span id='topic+trajectory+2Cmissing-method'></span><span id='topic+trajectory+2CANY-method'></span><span id='topic+trajectory+2Cdata.frame-method'></span><span id='topic+trajectory+2Cpomp-method'></span><span id='topic+trajectory+2Ctraj_match_objfun-method'></span>

<h3>Description</h3>

<p>Compute trajectories of the deterministic skeleton of a Markov process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
trajectory(
  t0,
  times,
  params,
  skeleton,
  rinit,
  ...,
  ode_control = list(),
  format = c("pomps", "array", "data.frame"),
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'data.frame'
trajectory(
  object,
  ...,
  t0,
  times,
  params,
  skeleton,
  rinit,
  ode_control = list(),
  format = c("pomps", "array", "data.frame"),
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
trajectory(
  object,
  params,
  ...,
  skeleton,
  rinit,
  ode_control = list(),
  format = c("pomps", "array", "data.frame"),
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'traj_match_objfun'
trajectory(object, ..., verbose = getOption("verbose", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trajectory_+3A_t0">t0</code></td>
<td>
<p>The zero-time, i.e., the time of the initial state.
This must be no later than the time of the first observation, i.e., <code>t0 &lt;= times[1]</code>.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_times">times</code></td>
<td>
<p>the sequence of observation times.
<code>times</code> must indicate the column of observation times by name or index.
The time vector must be numeric and non-decreasing.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_skeleton">skeleton</code></td>
<td>
<p>optional; the deterministic skeleton of the unobserved state process.
Depending on whether the model operates in continuous or discrete time, this is either a vectorfield or a map.
Accordingly, this is supplied using either the <code><a href="#topic+skeleton_spec">vectorfield</a></code> or <code><a href="#topic+skeleton_spec">map</a></code> fnctions.
For more information, see <a href="#topic+skeleton_spec">skeleton specification</a>.
Setting <code>skeleton=NULL</code> removes the deterministic skeleton.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_ode_control">ode_control</code></td>
<td>
<p>optional list;
the elements of this list will be passed to <code><a href="deSolve.html#topic+ode">ode</a></code> if the skeleton is a vectorfield, and ignored if it is a map.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_format">format</code></td>
<td>
<p>the format in which to return the results.
</p>
<p><code>format = "pomps"</code> causes the trajectories to be returned as a single &lsquo;pomp&rsquo; object (if a single parameter vector have been furnished to <code>trajectory</code>) or as a &lsquo;pompList&rsquo; object (if multiple parameters have been furnished).
In each of these, the <code>states</code> slot will have been replaced by the computed trajectory.
Use <code><a href="#topic+states">states</a></code> to view these.
</p>
<p><code>format = "array"</code> causes the trajectories to be returned
in a rank-3 array with dimensions
<code>nvar</code> x <code>ncol(params)</code> x <code>ntimes</code>.
Here, <code>nvar</code> is the number of state variables and <code>ntimes</code> the length of the argument <code>times</code>.
Thus if <code>x</code> is the returned array, <code>x[i,j,k]</code> is the i-th component of the state vector at time <code>times[k]</code> given parameters <code>params[,j]</code>.
</p>
<p><code>format = "data.frame"</code> causes the results to be returned as a single data frame containing the time and states.
An ordered factor variable, &lsquo;.id&rsquo;, distinguishes the trajectories from one another.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
<tr><td><code id="trajectory_+3A_object">object</code></td>
<td>
<p>optional;
if present, it should be a data frame or a &lsquo;pomp&rsquo; object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of a discrete-time system, the deterministic skeleton is a map and a trajectory is obtained by iterating the map.
In the case of a continuous-time system, the deterministic skeleton is a vector-field;
<code>trajectory</code> uses the numerical solvers in <span class="pkg"><a href="deSolve.html#topic+deSolve">deSolve</a></span> to integrate the vectorfield.
</p>


<h3>Value</h3>

<p>The <code>format</code> option controls the nature of the return value of <code>trajectory</code>.
See above for details.
</p>


<h3>See Also</h3>

<p>More on <span class="pkg">pomp</span> elementary algorithms: 
<code><a href="#topic+elementary_algorithms">elementary_algorithms</a></code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+wpfilter">wpfilter</a>()</code>
</p>
<p>More on methods for deterministic process models: 
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+traj_match">traj_match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## The basic components needed to compute trajectories
  ## of a deterministic dynamical system are
  ## rinit and skeleton.

  ## The following specifies these for a simple continuous-time
  ## model: dx/dt = r (1+e cos(t)) x

  trajectory(
    t0 = 0, times = seq(1,30,by=0.1),
    rinit = function (x0, ...) {
      c(x = x0)
    },
    skeleton = vectorfield(
      function (r, e, t, x, ...) {
        c(x=r*(1+e*cos(t))*x)
      }
    ),
    params = c(r=1,e=3,x0=1)
  ) -&gt; po

  plot(po,log='y')

  ## In the case of a discrete-time skeleton,
  ## we use the 'map' function.  For example,
  ## the following computes a trajectory from
  ## the dynamical system with skeleton
  ## x -&gt; x exp(r sin(omega t)).

  trajectory(
    t0 = 0, times=seq(1,100),
    rinit = function (x0, ...) {
      c(x = x0)
    },
    skeleton = map(
      function (r, t, x, omega, ...) {
        c(x=x*exp(r*sin(omega*t)))
      },
      delta.t=1
    ),
    params = c(r=1,x0=1,omega=4)
  ) -&gt; po

  plot(po)


 # takes too long for R CMD check
  ## generate a bifurcation diagram for the Ricker map
  p &lt;- parmat(coef(ricker()),nrep=500)
  p["r",] &lt;- exp(seq(from=1.5,to=4,length=500))
  trajectory(
    ricker(),
    times=seq(from=1000,to=2000,by=1),
    params=p,
    format="array"
  ) -&gt; x
  matplot(p["r",],x["N",,],pch='.',col='black',
    xlab=expression(log(r)),ylab="N",log='x')

</code></pre>

<hr>
<h2 id='transformations'>Transformations</h2><span id='topic+transformations'></span><span id='topic+logit'></span><span id='topic+expit'></span><span id='topic+log_barycentric'></span><span id='topic+inv_log_barycentric'></span>

<h3>Description</h3>

<p>Some useful parameter transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(p)

expit(x)

log_barycentric(X)

inv_log_barycentric(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformations_+3A_p">p</code></td>
<td>
<p>numeric; a quantity in [0,1].</p>
</td></tr>
<tr><td><code id="transformations_+3A_x">x</code></td>
<td>
<p>numeric; the log odds ratio.</p>
</td></tr>
<tr><td><code id="transformations_+3A_x">X</code></td>
<td>
<p>numeric; a vector containing the quantities to be transformed according to the log-barycentric transformation.</p>
</td></tr>
<tr><td><code id="transformations_+3A_y">Y</code></td>
<td>
<p>numeric; a vector containing the log fractions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameter transformations can be used in many cases to recast constrained optimization problems as unconstrained problems.
Although there are no limits to the transformations one can implement using the <code><a href="#topic+parameter_trans">parameter_trans</a></code> facilty, <span class="pkg">pomp</span> provides a few ready-built functions to implement some very commonly useful ones.
</p>
<p>The logit transformation takes a probability <code class="reqn">p</code> to its log odds, <code class="reqn">\log\frac{p}{1-p}</code>.
It maps the unit interval <code class="reqn">[0,1]</code> into the extended real line <code class="reqn">[-\infty,\infty]</code>.
</p>
<p>The inverse of the logit transformation is the expit transformation.
</p>
<p>The log-barycentric transformation takes a vector <code class="reqn">X\in{R^{n}_+}</code>, to a vector <code class="reqn">Y\in{R^n}</code>, where </p>
<p style="text-align: center;"><code class="reqn">Y_i = \log\frac{X_i}{\sum_j X_j}.</code>
</p>

<p>The transformation is not one-to-one.
However, for each <code class="reqn">c&gt;0</code>, it maps the simplex <code class="reqn">\{X\in{R^n_+}:\sum_i X_i = c\}</code> bijectively onto <code class="reqn">n</code>-dimensional Euclidean space <code class="reqn">R^n</code>.
</p>
<p>The inverse of the log-barycentric transformation is implemented as <code>inv_log_barycentric</code>.
Note that it is not a true inverse, in the sense that it takes <code class="reqn">R^n</code> to the <em>unit</em> simplex, <code class="reqn">\{X\in{R^n_+}:\sum_i X_i = 1\}</code>.
Thus, </p>
<pre>
    log_barycentric(inv_log_barycentric(Y)) == Y,
</pre><p> but </p>
<pre>
    inv_log_barycentric(log_barycentric(X)) == X
</pre><p> only if <code>sum(X) == 1</code>.
</p>


<h3>See Also</h3>

<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+userdata">userdata</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>

<hr>
<h2 id='undefined'>Undefined</h2><span id='topic+undefined'></span><span id='topic+undefined+2Cpomp_fun-method'></span><span id='topic+undefined+2CskelPlugin-method'></span><span id='topic+undefined+2CrprocPlugin-method'></span>

<h3>Description</h3>

<p>Check for undefined methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp_fun'
undefined(object, ...)

## S4 method for signature 'skelPlugin'
undefined(object, ...)

## S4 method for signature 'rprocPlugin'
undefined(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="undefined_+3A_object">object</code></td>
<td>
<p>object to test.</p>
</td></tr>
<tr><td><code id="undefined_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the <span class="pkg">pomp</span> workhorse method is undefined,
<code>FALSE</code> if it is defined,
and <code>NA</code> if the question is inapplicable.
</p>

<hr>
<h2 id='userdata'>Facilities for making additional information to basic components</h2><span id='topic+userdata'></span>

<h3>Description</h3>

<p>When <abbr><span class="acronym">POMP</span></abbr> basic components need information they can't get from parameters or covariates.
</p>


<h3>Details</h3>

<p>It can happen that one desires to pass information to one of the <abbr><span class="acronym">POMP</span></abbr> model <dfn>basic components</dfn> (see <a href="#topic+basic_components">here for a definition of this term</a>) outside of the standard routes (i.e., via model parameters or covariates).
<span class="pkg">pomp</span> provides facilities for this purpose.
We refer to the objects one wishes to pass in this way as <dfn>user data</dfn>.
</p>
<p>The following will apply to every <a href="#topic+basic_components">basic model component</a>.
For the sake of definiteness, however, we'll use the <code>rmeasure</code> component as an example.
To be even more specific, the measurement model we wish to implement is
</p>
<pre>
      y1 ~ Poisson(x1+theta),  y2 ~ Poisson(x2+theta),</pre>
<p>where <code>theta</code> is a parameter.
Although it would be very easy (and indeed far preferable) to include <code>theta</code> among the ordinary parameters (by including it in <code>params</code>), we will assume here that we have some reason for not wanting to do so.
</p>
<p>Now, we have the choice of providing <code>rmeasure</code> in one of three ways:
</p>

<ol>
<li><p> as an <span class="rlang"><b>R</b></span> function,
</p>
</li>
<li><p> as a C snippet, or
</p>
</li>
<li><p> as a procedure in an external, dynamically loaded library.
</p>
</li></ol>

<p>We'll deal with these three cases in turn.
</p>


<h3>When the basic component is specified as an <span class="rlang"><b>R</b></span> function</h3>

<p>We can implement a simulator for the aforementioned measurement model so: </p>
<pre>
   f &lt;- function (t, x, params, theta, ...) {
      y &lt;- rpois(n=2,x[c("x1","x2")]+theta)
      setNames(y,c("y1","y2"))
   }</pre>
<p>So far, so good, but how do we get <code>theta</code> to this function?
We simply provide an additional argument to whichever <span class="pkg">pomp</span> algorithm we are employing (e.g., <code><a href="#topic+simulate">simulate</a></code>, <code><a href="#topic+pfilter">pfilter</a></code>, <code><a href="#topic+mif2">mif2</a></code>, <code><a href="#topic+abc">abc</a></code>, etc.).
For example:
</p>
<pre>
    simulate(..., rmeasure = f, theta = 42, ...)
</pre>
<p>where the <code>...</code> represent the other <code>simulate</code> arguments we might want to supply.
When we do so, a message will be generated, informing us that <code>theta</code> is available for use by the <abbr><span class="acronym">POMP</span></abbr> basic components.
This warning helps forestall accidental triggering of this facility due to typographical error.
</p>


<h3>When the basic component is specified via a C snippet</h3>

<p>A C snippet implementation of the aforementioned measurement model is:
</p>
<pre>
    f &lt;- Csnippet(r"{
     double theta = *get_userdata_double("theta");
     y1 = rpois(x1+theta); y2 = rpois(x2+theta);
    }")</pre>
<p>Here, the call to <code>get_userdata_double</code> retrieves a <em>pointer</em> to the stored value of <code>theta</code>.
Note that, by using <span class="rlang"><b>R</b></span> string literals (<code>r"{}"</code>) we avoid the need to escape the quotes in the C snippet text.
</p>
<p>It is possible to store and retrieve integer objects also, using <code>get_userdata_int</code>.
</p>
<p>One must take care that one stores the user data with the appropriate storage type.
For example, it is wise to wrap floating point scalars and vectors with <code>as.double</code> and integers with <code>as.integer</code>.
In the present example, our call to simulate might look like
</p>
<pre>
    simulate(..., rmeasure = f, theta = as.double(42), ...)
</pre>
<p>Since the two functions <code>get_userdata_double</code> and <code>get_userdata_int</code> return pointers, it is trivial to pass vectors of double-precision and integers.
</p>
<p>A simpler and more elegant approach is afforded by the <code>globals</code> argument (see below).
</p>


<h3>When the basic component is specified via an external library</h3>

<p>The rules are essentially the same as for C snippets.
<code>typedef</code> declarations for the <code>get_userdata_double</code> and <code>get_userdata_int</code> are given in the &lsquo;<span class="file">pomp.h</span>&rsquo; header file and these two routines are registered so that they can be retrieved via a call to <code>R_GetCCallable</code>.
See the <a href="https://cran.r-project.org/doc/manuals/R-exts.html">Writing <span class="rlang"><b>R</b></span> extensions manual</a> for more information.
</p>


<h3>Setting <code>globals</code></h3>

<p>The use of the userdata facilities incurs a run-time cost.
It is often more efficient, when using C snippets, to put the needed objects directly into the C snippet library.
The <code>globals</code> argument does this.
See the example below.
</p>


<h3>See Also</h3>

<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+vmeasure_spec">vmeasure_spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## The familiar Ricker example.
  ## Suppose that for some reason we wish to pass 'phi'
  ## via the userdata facility instead of as a parameter.

  ## C snippet approach:

  simulate(times=1:100,t0=0,
    phi=as.double(100),
    params=c(r=3.8,sigma=0.3,N.0=7),
    rprocess=discrete_time(
      step.fun=Csnippet(r"{
      double e = (sigma &gt; 0.0) ? rnorm(0,sigma) : 0.0;
      N = r*N*exp(-N+e);}"
      ),
      delta.t=1
    ),
    rmeasure=Csnippet(r"{
       double phi = *get_userdata_double("phi");
       y = rpois(phi*N);}"
    ),
    paramnames=c("r","sigma"),
    statenames="N",
    obsnames="y"
  ) -&gt; rick1

  ## The same problem solved using 'globals':
  simulate(times=1:100,t0=0,
    globals=Csnippet("static double phi = 100;"),
    params=c(r=3.8,sigma=0.3,N.0=7),
    rprocess=discrete_time(
      step.fun=Csnippet(r"{
      double e = (sigma &gt; 0.0) ? rnorm(0,sigma) : 0.0;
      N = r*N*exp(-N+e);}"
      ),
      delta.t=1
    ),
    rmeasure=Csnippet("
       y = rpois(phi*N);"
    ),
    paramnames=c("r","sigma"),
    statenames="N",
    obsnames="y"
  ) -&gt; rick2

  ## Finally, the R function approach:

  simulate(times=1:100,t0=0,
    phi=100,
    params=c(r=3.8,sigma=0.3,N_0=7),
    rprocess=discrete_time(
      step.fun=function (r, N, sigma, ...) {
        e &lt;- rnorm(n=1,mean=0,sd=sigma)
        c(N=r*N*exp(-N+e))
      },
      delta.t=1
    ),
    rmeasure=function (phi, N, ...) {
      c(y=rpois(n=1,lambda=phi*N))
    }
  ) -&gt; rick3


</code></pre>

<hr>
<h2 id='verhulst'>Verhulst-Pearl model</h2><span id='topic+verhulst'></span>

<h3>Description</h3>

<p>The Verhulst-Pearl (logistic) model of population growth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verhulst(n_0 = 10000, K = 10000, r = 0.9, sigma = 0.4, tau = 0.1, dt = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verhulst_+3A_n_0">n_0</code></td>
<td>
<p>initial condition</p>
</td></tr>
<tr><td><code id="verhulst_+3A_k">K</code></td>
<td>
<p>carrying capacity</p>
</td></tr>
<tr><td><code id="verhulst_+3A_r">r</code></td>
<td>
<p>intrinsic growth rate</p>
</td></tr>
<tr><td><code id="verhulst_+3A_sigma">sigma</code></td>
<td>
<p>environmental process noise s.d.</p>
</td></tr>
<tr><td><code id="verhulst_+3A_tau">tau</code></td>
<td>
<p>measurement error s.d.</p>
</td></tr>
<tr><td><code id="verhulst_+3A_dt">dt</code></td>
<td>
<p>Euler timestep</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A stochastic version of the Verhulst-Pearl logistic model.
This evolves in continuous time, according to the stochastic differential equation
</p>
<p style="text-align: center;"><code class="reqn">dn_t = r\,n_t\,\left(1-\frac{n_t}{K}\right)\,dt+\sigma\,n_t\,dW_t.</code>
</p>

<p>Numerically, we simulate the stochastic dynamics using an Euler approximation.
</p>
<p>The measurements are assumed to be log-normally distributed:
</p>
<p style="text-align: center;"><code class="reqn">N_t \sim \mathrm{Lognormal}\left(\log{n_t},\tau\right).</code>
</p>



<h3>Value</h3>

<p>A &lsquo;pomp&rsquo; object containing the model and simulated data.
The following basic components are included in the &lsquo;pomp&rsquo; object:
&lsquo;rinit&rsquo;, &lsquo;rprocess&rsquo;, &lsquo;rmeasure&rsquo;, &lsquo;dmeasure&rsquo;, and &lsquo;skeleton&rsquo;.
</p>


<h3>See Also</h3>

<p>More examples provided with <span class="pkg">pomp</span>: 
<code><a href="#topic+blowflies">blowflies</a></code>,
<code><a href="#topic+childhood_disease_data">childhood_disease_data</a></code>,
<code><a href="#topic+compartmental_models">compartmental_models</a></code>,
<code><a href="#topic+dacca">dacca</a>()</code>,
<code><a href="#topic+ebola">ebola</a></code>,
<code><a href="#topic+gompertz">gompertz</a>()</code>,
<code><a href="#topic+ou2">ou2</a>()</code>,
<code><a href="#topic+pomp_examples">pomp_examples</a></code>,
<code><a href="#topic+ricker">ricker</a>()</code>,
<code><a href="#topic+rw2">rw2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # takes too long for R CMD check
  verhulst() -&gt; po
  plot(po)
  plot(simulate(po))
  pfilter(po,Np=1000) -&gt; pf
  logLik(pf)
  spy(po)

</code></pre>

<hr>
<h2 id='vmeasure'>vmeasure workhorse</h2><span id='topic+vmeasure'></span><span id='topic+vmeasure+2CANY-method'></span><span id='topic+vmeasure+2Cmissing-method'></span><span id='topic+vmeasure+2Cpomp-method'></span>

<h3>Description</h3>

<p>Return the covariance matrix of the observed variables, given values of the latent states and the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
vmeasure(
  object,
  x = states(object),
  times = time(object),
  params = coef(object),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vmeasure_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;pomp&rsquo;, or of a class that extends &lsquo;pomp&rsquo;.
This will typically be the output of <code>pomp</code>, <code>simulate</code>, or one of the <span class="pkg">pomp</span> inference algorithms.</p>
</td></tr>
<tr><td><code id="vmeasure_+3A_x">x</code></td>
<td>
<p>an array containing states of the unobserved process.
The dimensions of <code>x</code> are <code>nvars</code> x <code>nrep</code> x <code>ntimes</code>,
where <code>nvars</code> is the number of state variables,
<code>nrep</code> is the number of replicates,
and <code>ntimes</code> is the length of <code>times</code>.
One can also pass <code>x</code> as a named numeric vector, which is equivalent to the <code>nrep=1</code>, <code>ntimes=1</code> case.</p>
</td></tr>
<tr><td><code id="vmeasure_+3A_times">times</code></td>
<td>
<p>a numeric vector (length <code>ntimes</code>) containing times.
These must be in non-decreasing order.</p>
</td></tr>
<tr><td><code id="vmeasure_+3A_params">params</code></td>
<td>
<p>a <code>npar</code> x <code>nrep</code> matrix of parameters.
Each column is treated as an independent parameter set, in correspondence with the corresponding column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="vmeasure_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vmeasure</code> returns a rank-4 array of dimensions
<code>nobs</code> x <code>nobs</code> x <code>nrep</code> x <code>ntimes</code>,
where <code>nobs</code> is the number of observed variables.
If <code>v</code> is the returned array, <code>v[,,j,k]</code> contains the
covariance matrix at time <code>times[k]</code> given the state <code>x[,j,k]</code>.
</p>


<h3>See Also</h3>

<p>Specification of the measurement-model covariance matrix: <a href="#topic+vmeasure_spec">vmeasure_spec</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+workhorses">workhorses</a></code>
</p>

<hr>
<h2 id='vmeasure_spec'>vmeasure specification</h2><span id='topic+vmeasure_spec'></span>

<h3>Description</h3>

<p>Specification of the measurement-model covariance  matrix, vmeasure.
</p>


<h3>Details</h3>

<p>The measurement model is the link between the data and the unobserved state process.
Some algorithms require the conditional covariance of the measurement model, given the latent state and parameters.
This is supplied using the <code>vmeasure</code> argument.
</p>
<p>Suppose you have a procedure to compute this conditional covariance matrix, given the value of the latent state variables.
Then you can furnish </p>
<pre>
  vmeasure = f</pre>
<p>to <span class="pkg">pomp</span> algorithms,
where <code>f</code> is a C snippet or <span class="rlang"><b>R</b></span> function that implements your procedure.
</p>
<p>Using a C snippet is much preferred, due to its much greater computational efficiency.
See <code><a href="#topic+Csnippet">Csnippet</a></code> for general rules on writing C snippets.
</p>
<p>In writing a <code>vmeasure</code> C snippet, bear in mind that:
</p>

<ol>
<li><p> The goal of such a snippet is to fill variables named <code>V_y_z</code> with the conditional covariances of observables <code>y</code>, <code>z</code>.
Accordingly, there should be one assignment of <code>V_y_z</code> and one assignment of <code>V_z_y</code> for each pair of observables <code>y</code> and <code>z</code>.
</p>
</li>
<li><p> In addition to the states, parameters, and covariates (if any), the variable <code>t</code>, containing the time of the observation, will be defined in the context in which the snippet is executed.
</p>
</li></ol>

<p>The demos and the tutorials on the <a href="https://kingaa.github.io/pomp/">package website</a> give examples.
</p>
<p>It is also possible, though less efficient, to specify <code>vmeasure</code> using an <span class="rlang"><b>R</b></span> function.
In this case, specify it by furnishing </p>
<pre>
  vmeasure = f</pre>
<p>to <code>pomp</code>, where <code>f</code> is an <span class="rlang"><b>R</b></span> function.
The arguments of <code>f</code> should be chosen from among the state variables, parameters, covariates, and time.
It must also have the argument <code>...</code>.
<code>f</code> must return a square matrix of dimension equal to the number of observable variables.
The row- and column-names of this matrix should match the names of the observable variables.
The matrix should of course be symmetric.
</p>


<h3>Default behavior</h3>

<p>The default <code>vmeasure</code> is undefined.
It will yield missing values (<code>NA</code>).
</p>


<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vmeasure">vmeasure</a></code>
</p>
<p>More on implementing POMP models: 
<code><a href="#topic+Csnippet">Csnippet</a></code>,
<code><a href="#topic+accumvars">accumvars</a></code>,
<code><a href="#topic+basic_components">basic_components</a></code>,
<code><a href="#topic+betabinomial">betabinomial</a></code>,
<code><a href="#topic+covariates">covariates</a></code>,
<code><a href="#topic+dinit_spec">dinit_spec</a></code>,
<code><a href="#topic+dmeasure_spec">dmeasure_spec</a></code>,
<code><a href="#topic+dprocess_spec">dprocess_spec</a></code>,
<code><a href="#topic+emeasure_spec">emeasure_spec</a></code>,
<code><a href="#topic+eulermultinom">eulermultinom</a></code>,
<code><a href="#topic+parameter_trans">parameter_trans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+pomp_constructor">pomp_constructor</a></code>,
<code><a href="#topic+prior_spec">prior_spec</a></code>,
<code><a href="#topic+rinit_spec">rinit_spec</a></code>,
<code><a href="#topic+rmeasure_spec">rmeasure_spec</a></code>,
<code><a href="#topic+rprocess_spec">rprocess_spec</a></code>,
<code><a href="#topic+skeleton_spec">skeleton_spec</a></code>,
<code><a href="#topic+transformations">transformations</a></code>,
<code><a href="#topic+userdata">userdata</a></code>
</p>

<hr>
<h2 id='window'>Window</h2><span id='topic+window'></span><span id='topic+window+2Cpomp-method'></span>

<h3>Description</h3>

<p>Restrict to a portion of a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pomp'
window(x, start, end, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_+3A_x">x</code></td>
<td>
<p>a &lsquo;pomp&rsquo; object or object of class extending &lsquo;pomp&rsquo;</p>
</td></tr>
<tr><td><code id="window_+3A_start">start</code>, <code id="window_+3A_end">end</code></td>
<td>
<p>the left and right ends of the window, in units of time</p>
</td></tr>
<tr><td><code id="window_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='workhorses'>Workhorse functions for the <span class="pkg">pomp</span> algorithms.</h2><span id='topic+workhorses'></span>

<h3>Description</h3>

<p>These functions mediate the interface between the user's model and the package algorithms.
They are low-level functions that do the work needed by the package's inference methods.
</p>


<h3>Details</h3>

<p>They include </p>

<dl>
<dt><code><a href="#topic+rinit">rinit</a></code></dt><dd><p>which samples from the initial-state distribution,</p>
</dd>
<dt><code><a href="#topic+dinit">dinit</a></code></dt><dd><p>which evaluates the initial-state density,</p>
</dd>
<dt><code><a href="#topic+dmeasure">dmeasure</a></code></dt><dd><p>which evaluates the measurement model density,</p>
</dd>
<dt><code><a href="#topic+rmeasure">rmeasure</a></code></dt><dd><p>which samples from the measurement model distribution,</p>
</dd>
<dt><code><a href="#topic+emeasure">emeasure</a></code></dt><dd><p>which computes the expectation of the observed variables conditional on the latent state,</p>
</dd>
<dt><code><a href="#topic+vmeasure">vmeasure</a></code></dt><dd><p>which computes the covariance matrix of the observed variables conditional on the latent state,</p>
</dd>
<dt><code><a href="#topic+dprocess">dprocess</a></code></dt><dd><p>which evaluates the process model density,</p>
</dd>
<dt><code><a href="#topic+rprocess">rprocess</a></code></dt><dd><p>which samples from the process model distribution,</p>
</dd>
<dt><code><a href="#topic+dprior">dprior</a></code></dt><dd><p>which evaluates the prior probability density,</p>
</dd>
<dt><code><a href="#topic+rprior">rprior</a></code></dt><dd><p>which samples from the prior distribution,</p>
</dd>
<dt><code><a href="#topic+skeleton">skeleton</a></code></dt><dd><p>which evaluates the model's deterministic skeleton,</p>
</dd>
<dt><code><a href="#topic+flow">flow</a></code></dt><dd><p>which iterates or integrates the deterministic skeleton to yield trajectories,</p>
</dd>
<dt><code><a href="#topic+partrans">partrans</a></code></dt><dd><p>which performs parameter transformations associated with the model.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>See Also</h3>

<p><a href="#topic+basic_components">basic model components</a>,
<a href="#topic+elementary_algorithms">elementary algorithms</a>,
<a href="#topic+estimation_algorithms">estimation algorithms</a>
</p>
<p>More on <span class="pkg">pomp</span> workhorse functions: 
<code><a href="#topic+dinit">dinit</a>()</code>,
<code><a href="#topic+dmeasure">dmeasure</a>()</code>,
<code><a href="#topic+dprior">dprior</a>()</code>,
<code><a href="#topic+dprocess">dprocess</a>()</code>,
<code><a href="#topic+emeasure">emeasure</a>()</code>,
<code><a href="#topic+flow">flow</a>()</code>,
<code><a href="#topic+partrans">partrans</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+rinit">rinit</a>()</code>,
<code><a href="#topic+rmeasure">rmeasure</a>()</code>,
<code><a href="#topic+rprior">rprior</a>()</code>,
<code><a href="#topic+rprocess">rprocess</a>()</code>,
<code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+vmeasure">vmeasure</a>()</code>
</p>

<hr>
<h2 id='wpfilter'>Weighted particle filter</h2><span id='topic+wpfilter'></span><span id='topic+wpfilter+2CANY-method'></span><span id='topic+wpfilter+2Cmissing-method'></span><span id='topic+wpfilter+2Cdata.frame-method'></span><span id='topic+wpfilter+2Cpomp-method'></span><span id='topic+wpfilter+2Cwpfilterd_pomp-method'></span>

<h3>Description</h3>

<p>A sequential importance sampling (particle filter) algorithm.
Unlike in <code>pfilter</code>, resampling is performed only when triggered by
deficiency in the effective sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame'
wpfilter(
  data,
  Np,
  params,
  rinit,
  rprocess,
  dmeasure,
  trigger = 1,
  target = 0.5,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'pomp'
wpfilter(
  data,
  Np,
  trigger = 1,
  target = 0.5,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'wpfilterd_pomp'
wpfilter(data, Np, trigger, target, ..., verbose = getOption("verbose", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wpfilter_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="wpfilter_+3A_np">Np</code></td>
<td>
<p>the number of particles to use.
This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
Alternatively, if one wishes the number of particles to vary across timesteps, one may specify <code>Np</code> either as a vector of positive integers of length </p>
<pre>length(time(object,t0=TRUE))</pre><p> or as a function taking a positive integer argument.
In the latter case, <code>Np(k)</code> must be a single positive integer, representing the number of particles to be used at the <code>k</code>-th timestep:
<code>Np(0)</code> is the number of particles to use going from <code>timezero(object)</code> to <code>time(object)[1]</code>,
<code>Np(1)</code>, from <code>timezero(object)</code> to <code>time(object)[1]</code>,
and so on,
while when <code>T=length(time(object))</code>, <code>Np(T)</code> is the number of particles to sample at the end of the time-series.</p>
</td></tr>
<tr><td><code id="wpfilter_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="wpfilter_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="wpfilter_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="wpfilter_+3A_dmeasure">dmeasure</code></td>
<td>
<p>evaluator of the measurement model density, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>dmeasure=NULL</code> removes the measurement density evaluator.
For more information, see <a href="#topic+dmeasure_spec">dmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="wpfilter_+3A_trigger">trigger</code></td>
<td>
<p>numeric; if the effective sample size becomes smaller than <code>trigger * Np</code>, resampling is triggered.</p>
</td></tr>
<tr><td><code id="wpfilter_+3A_target">target</code></td>
<td>
<p>numeric; target power.</p>
</td></tr>
<tr><td><code id="wpfilter_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
<tr><td><code id="wpfilter_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>This function is experimental and should be considered in alpha stage.
Both interface and underlying algorithms may change without warning at any time.
Please explore the function and give feedback via the <span class="pkg">pomp</span> Issues page.</b>
</p>


<h3>Value</h3>

<p>An object of class &lsquo;wpfilterd_pomp&rsquo;, which extends class &lsquo;pomp&rsquo;.
Information can be extracted from this object using the methods documented below.
</p>


<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+logLik">logLik</a></code></dt><dd><p> the estimated log likelihood</p>
</dd>
<dt><code><a href="#topic+cond_logLik">cond_logLik</a></code></dt><dd><p> the estimated conditional log likelihood</p>
</dd>
<dt><code><a href="#topic+eff_sample_size">eff_sample_size</a></code></dt><dd><p>the (time-dependent) estimated effective sample size</p>
</dd>
<dt><code><a href="#topic+as.data.frame">as.data.frame</a></code></dt><dd><p> coerce to a data frame</p>
</dd>
<dt><code><a href="#topic+plot">plot</a></code></dt><dd><p>diagnostic plots</p>
</dd>
</dl>



<h3>Note for Windows users</h3>

<p>Some Windows users report problems when using C snippets in parallel computations.
These appear to arise when the temporary files created during the C snippet compilation process are not handled properly by the operating system.
To circumvent this problem, use the <code><a href="#topic+pomp">cdir</a></code> and <code><a href="#topic+pomp">cfile</a></code> options to cause the C snippets to be written to a file of your choice, thus avoiding the use of temporary files altogether.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>M.S. Arulampalam, S. Maskell, N. Gordon, and T. Clapp. A tutorial on particle filters for online nonlinear, non-Gaussian Bayesian tracking. <em>IEEE Transactions on Signal Processing</em> <b>50</b>, 174&ndash;188, 2002.
</p>


<h3>See Also</h3>

<p>More on <span class="pkg">pomp</span> elementary algorithms: 
<code><a href="#topic+elementary_algorithms">elementary_algorithms</a></code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pomp-package">pomp-package</a></code>,
<code><a href="#topic+probe">probe</a>()</code>,
<code><a href="#topic+simulate">simulate</a>()</code>,
<code><a href="#topic+spect">spect</a>()</code>,
<code><a href="#topic+trajectory">trajectory</a>()</code>
</p>
<p>More on sequential Monte Carlo methods: 
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+cond_logLik">cond_logLik</a>()</code>,
<code><a href="#topic+eff_sample_size">eff_sample_size</a>()</code>,
<code><a href="#topic+filter_mean">filter_mean</a>()</code>,
<code><a href="#topic+filter_traj">filter_traj</a>()</code>,
<code><a href="#topic+kalman">kalman</a></code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>,
<code><a href="#topic+pred_mean">pred_mean</a>()</code>,
<code><a href="#topic+pred_var">pred_var</a>()</code>,
<code><a href="#topic+saved_states">saved_states</a>()</code>
</p>
<p>More on full-information (i.e., likelihood-based) methods:
<code><a href="#topic+bsmc2">bsmc2</a>()</code>,
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>,
<code><a href="#topic+pmcmc">pmcmc</a>()</code>
</p>

<hr>
<h2 id='wquant'>Weighted quantile function</h2><span id='topic+wquant'></span>

<h3>Description</h3>

<p>Estimate weighted quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wquant(
  x,
  weights = rep(1, length(x)),
  probs = c(`0%` = 0, `25%` = 0.25, `50%` = 0.5, `75%` = 0.75, `100%` = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wquant_+3A_x">x</code></td>
<td>
<p>numeric; a vector of data.</p>
</td></tr>
<tr><td><code id="wquant_+3A_weights">weights</code></td>
<td>
<p>numeric; vector of weights.</p>
</td></tr>
<tr><td><code id="wquant_+3A_probs">probs</code></td>
<td>
<p>numeric; desired quantiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>wquant</code> estimates quantiles of weighted data using the estimator of Harrell &amp; Davis (1982), with improvements recommended by Andrey Akinshin.
</p>


<h3>Value</h3>

<p><code>wquant</code> returns a vector containing the estimated quantiles.
If <code>probs</code> has names, these are inherited.
</p>


<h3>Author(s)</h3>

<p>Aaron A. King
</p>


<h3>References</h3>

<p>F. E. Harrell and C. E. Davis. A new distribution-free quantile estimator. <em>Biometrika</em> <b>69</b>, 635&ndash;640, 1982.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,1,1,2,2,3,3,3,3,4,5,5,6,6,6)
quantile(x)
wquant(x)
wquant(c(1,2,3,4,5,6),weights=c(3,2,4,1,2,3))
wquant(c(1,2,3,4,5),c(1,0,0,1,1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
