<!DOCTYPE html><html><head><title>Help for package echoice2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {echoice2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#echoice2-package'><p>echoice2: Choice Models with Economic Foundation</p></a></li>
<li><a href='#%.%'><p>Get the attribute of an object</p></a></li>
<li><a href='#dd_dem'><p>Discrete Choice Predictions (HMNL)</p></a></li>
<li><a href='#dd_dem_sr'><p>Discrete Choice Predictions (HMNL with attribute-based screening)</p></a></li>
<li><a href='#dd_est_hmnl'><p>Estimate discrete choice model (HMNL)</p></a></li>
<li><a href='#dd_est_hmnl_screen'><p>Estimate discrete choice model (HMNL, attribute-based screening (not including price))</p></a></li>
<li><a href='#dd_LL'><p>Log-Likelihood for compensatory hmnl model</p></a></li>
<li><a href='#dd_LL_sr'><p>Log-Likelihood for screening hmnl model</p></a></li>
<li><a href='#dummify'><p>Create dummy variables within a tibble</p></a></li>
<li><a href='#dummyvar'><p>Dummy-code a categorical variable</p></a></li>
<li><a href='#ec_boxplot_MU'><p>Generate MU_theta boxplot</p></a></li>
<li><a href='#ec_boxplot_screen'><p>Generate Screening probability boxplot</p></a></li>
<li><a href='#ec_dem_aggregate'><p>Aggregate posterior draws of demand</p></a></li>
<li><a href='#ec_dem_eval'><p>Evaluate (hold-out) demand predictions</p></a></li>
<li><a href='#ec_dem_summarise'><p>Summarize posterior draws of demand</p></a></li>
<li><a href='#ec_demcurve'><p>Create demand curves</p></a></li>
<li><a href='#ec_demcurve_cond_dem'><p>Create demand-incidence curves</p></a></li>
<li><a href='#ec_demcurve_inci'><p>Create demand-incidence curves</p></a></li>
<li><a href='#ec_draws_MU'><p>Obtain MU_theta draws</p></a></li>
<li><a href='#ec_draws_screen'><p>Obtain Screening probability draws</p></a></li>
<li><a href='#ec_estimates_MU'><p>Obtain upper level model estimates</p></a></li>
<li><a href='#ec_estimates_screen'><p>Summarize attribute-based screening parameters</p></a></li>
<li><a href='#ec_estimates_SIGMA'><p>Obtain posterior mean estimates of upper level covariance</p></a></li>
<li><a href='#ec_estimates_SIGMA_corr'><p>Obtain posterior mean estimates of upper level correlations</p></a></li>
<li><a href='#ec_gen_err_ev1'><p>Simulate error realization from EV1 distribution</p></a></li>
<li><a href='#ec_gen_err_normal'><p>Simulate error realization from Normal distribution</p></a></li>
<li><a href='#ec_lmd_NR'><p>Obtain Log Marginal Density from draw objects</p></a></li>
<li><a href='#ec_lol_tidy1'><p>Convert &quot;list of lists&quot; format to long &quot;tidy&quot; format</p></a></li>
<li><a href='#ec_screen_summarise'><p>Summarize posterior draws of screening</p></a></li>
<li><a href='#ec_screenprob_sr'><p>Screening probabilities of choice alternatives</p></a></li>
<li><a href='#ec_summarize_attrlvls'><p>Summarize attributes and levels</p></a></li>
<li><a href='#ec_trace_MU'><p>Generate MU_theta traceplot</p></a></li>
<li><a href='#ec_trace_screen'><p>Generate Screening probability traceplots</p></a></li>
<li><a href='#ec_undummy'><p>Converts a set of dummy variables into a single categorical variable</p></a></li>
<li><a href='#ec_undummy_lowhigh'><p>Convert dummy-coded variables to low/high factor</p></a></li>
<li><a href='#ec_undummy_lowmediumhigh'><p>Convert dummy-coded variables to low/medium/high factor</p></a></li>
<li><a href='#ec_undummy_yesno'><p>Convert dummy-coded variables to yes/no factor</p></a></li>
<li><a href='#ec_util_choice_to_long'><p>Convert a vector of choices to long format</p></a></li>
<li><a href='#ec_util_dummy_mutualeclusive'><p>Find mutually exclusive columns</p></a></li>
<li><a href='#get_attr_lvl'><p>Obtain attributes and levels from tidy choice data with dummies</p></a></li>
<li><a href='#icecream'><p>icecream</p></a></li>
<li><a href='#icecream_discrete'><p>icecream_discrete</p></a></li>
<li><a href='#logMargDenNRu'><p>Log Marginal Density (Newton-Raftery)</p></a></li>
<li><a href='#pizza'><p>pizza</p></a></li>
<li><a href='#prep_newprediction'><p>Match factor levels between two datasets</p></a></li>
<li><a href='#vd_add_prodid'><p>Add product id to demand draws</p></a></li>
<li><a href='#vd_dem_summarise'><p>Summarize posterior draws of demand (volumetric models only)</p></a></li>
<li><a href='#vd_dem_vdm'><p>Demand Prediction (Volumetric Demand Model)</p></a></li>
<li><a href='#vd_dem_vdm_screen'><p>Demand Prediction (Volumetric demand, attribute-based screening)</p></a></li>
<li><a href='#vd_dem_vdm_ss'><p>Demand Prediction (Volumetric demand, accounting for set-size variation, EV1 errors)</p></a></li>
<li><a href='#vd_est_vdm'><p>Estimate volumetric demand model</p></a></li>
<li><a href='#vd_est_vdm_screen'><p>Estimate volumetric demand model with attribute-based conjunctive screening</p></a></li>
<li><a href='#vd_est_vdm_ss'><p>Estimate volumetric demand model accounting for set size variation (1st order)</p></a></li>
<li><a href='#vd_LL_vdm'><p>Log-Likelihood for compensatory volumetric demand model</p></a></li>
<li><a href='#vd_LL_vdm_screen'><p>Log-Likelihood for conjunctive-screening volumetric demand model</p></a></li>
<li><a href='#vd_LL_vdmss'><p>Log-Likelihood for volumetric demand model with set-size variation</p></a></li>
<li><a href='#vd_long_tidy'><p>Generate tidy choice data with dummies from long-format choice data</p></a></li>
<li><a href='#vd_prepare'><p>Prepare choice data for analysis</p></a></li>
<li><a href='#vd_prepare_nox'><p>Prepare choice data for analysis (without x being present)</p></a></li>
<li><a href='#vd_thin_draw'><p>Thin 'echoice2'-vd draw objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Choice Models with Economic Foundation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nino Hardt &lt;me@ninohardt.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements choice models based on economic theory, including estimation using Markov chain Monte Carlo (MCMC), prediction, and more. Its usability is inspired by ideas from 'tidyverse'. Models include versions of the Hierarchical Multinomial Logit and Multiple Discrete-Continous (Volumetric) models with and without screening. The foundations of these models are described in Allenby, Hardt and Rossi (2019)  &lt;<a href="https://doi.org/10.1016%2Fbs.hem.2019.04.002">doi:10.1016/bs.hem.2019.04.002</a>&gt;. Models with conjunctive screening are described in Kim, Hardt, Kim and Allenby (2022) &lt;<a href="https://doi.org/10.1016%2Fj.ijresmar.2022.04.001">doi:10.1016/j.ijresmar.2022.04.001</a>&gt;. Models with set-size variation are described in Hardt and Kurz (2020) &lt;<a href="https://doi.org/10.2139%2Fssrn.3418383">doi:10.2139/ssrn.3418383</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ninohardt/echoice2/issues">https://github.com/ninohardt/echoice2/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ninohardt/echoice2">https://github.com/ninohardt/echoice2</a>,
<a href="http://ninohardt.de/echoice2/">http://ninohardt.de/echoice2/</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, parallel, magrittr, stats, graphics, stringr, purrr,
tibble, tidyselect, tidyr, rlang, forcats</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), dplyr, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, bayesm</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-20 08:34:37 UTC; myself</td>
</tr>
<tr>
<td>Author:</td>
<td>Nino Hardt <a href="https://orcid.org/0000-0001-5215-6216"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-20 08:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='echoice2-package'>echoice2: Choice Models with Economic Foundation</h2><span id='topic+echoice2'></span><span id='topic+echoice2-package'></span>

<h3>Description</h3>

<p>echoice2 lets you use economic models of choice from R.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nino Hardt <a href="mailto:me@ninohardt.com">me@ninohardt.com</a> (<a href="https://orcid.org/0000-0001-5215-6216">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ninohardt/echoice2">https://github.com/ninohardt/echoice2</a>
</p>
</li>
<li> <p><a href="http://ninohardt.de/echoice2/">http://ninohardt.de/echoice2/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ninohardt/echoice2/issues">https://github.com/ninohardt/echoice2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25.+25'>Get the attribute of an object</h2><span id='topic++25.+25'></span>

<h3>Description</h3>

<p>Get the attribute of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj %.% attrname
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25.+2B25_+3A_obj">obj</code></td>
<td>
<p>The object to get the attribute from.</p>
</td></tr>
<tr><td><code id="+2B25.+2B25_+3A_attrname">attrname</code></td>
<td>
<p>The name of the attribute to get.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The attribute of the object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- list(a = 1, b = 2)
attributes(obj)$test="hello"
`%.%`(obj, "test")

</code></pre>

<hr>
<h2 id='dd_dem'>Discrete Choice Predictions (HMNL)</h2><span id='topic+dd_dem'></span>

<h3>Description</h3>

<p>Discrete Choice Predictions (HMNL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dd_dem(dd, est, prob = FALSE, cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dd_dem_+3A_dd">dd</code></td>
<td>
<p>tibble with long-format choice data</p>
</td></tr>
<tr><td><code id="dd_dem_+3A_est">est</code></td>
<td>
<p>estimation object</p>
</td></tr>
<tr><td><code id="dd_dem_+3A_prob">prob</code></td>
<td>
<p>logical, report probabilities instead of demand</p>
</td></tr>
<tr><td><code id="dd_dem_+3A_cores">cores</code></td>
<td>
<p>cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draws of expected choice
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dd_est_hmnl">dd_est_hmnl()</a></code> to generate demand predictions based on this model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream_discrete)
icecream_est &lt;- icecream_discrete %&gt;% filter(id&lt;10) %&gt;% dd_est_hmnl(R=4, cores=2)
#demand prediction
icecream_dempred &lt;- icecream_discrete %&gt;% filter(id&lt;10) %&gt;% 
  dd_dem(icecream_est, cores=2)

</code></pre>

<hr>
<h2 id='dd_dem_sr'>Discrete Choice Predictions (HMNL with attribute-based screening)</h2><span id='topic+dd_dem_sr'></span>

<h3>Description</h3>

<p>Discrete Choice Predictions (HMNL with attribute-based screening)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dd_dem_sr(dd, est, prob = FALSE, cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dd_dem_sr_+3A_dd">dd</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="dd_dem_sr_+3A_est">est</code></td>
<td>
<p>est</p>
</td></tr>
<tr><td><code id="dd_dem_sr_+3A_prob">prob</code></td>
<td>
<p>logical, report probabilities instead of demand</p>
</td></tr>
<tr><td><code id="dd_dem_sr_+3A_cores">cores</code></td>
<td>
<p>cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draws of expected choice
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dd_est_hmnl_screen">dd_est_hmnl_screen()</a></code> to generate demand predictions based on this model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream_discrete)
icecream_est &lt;- icecream_discrete %&gt;% filter(id&lt;20) %&gt;% dd_est_hmnl_screen(R=10, cores=2)
#demand prediction
icecream_dempred &lt;- icecream_discrete %&gt;% filter(id&lt;20) %&gt;% 
 dd_dem_sr(icecream_est, cores=2)
 

</code></pre>

<hr>
<h2 id='dd_est_hmnl'>Estimate discrete choice model (HMNL)</h2><span id='topic+dd_est_hmnl'></span>

<h3>Description</h3>

<p>Estimate discrete choice model (HMNL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dd_est_hmnl(
  dd,
  R = 1e+05,
  keep = 10,
  cores = NULL,
  control = list(include_data = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dd_est_hmnl_+3A_dd">dd</code></td>
<td>
<p>discrete choice data (long format)</p>
</td></tr>
<tr><td><code id="dd_est_hmnl_+3A_r">R</code></td>
<td>
<p>draws</p>
</td></tr>
<tr><td><code id="dd_est_hmnl_+3A_keep">keep</code></td>
<td>
<p>thinning</p>
</td></tr>
<tr><td><code id="dd_est_hmnl_+3A_cores">cores</code></td>
<td>
<p>no of CPU cores to use (default: auto-detect)</p>
</td></tr>
<tr><td><code id="dd_est_hmnl_+3A_control">control</code></td>
<td>
<p>list containing additional settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>est ec-draw object (List)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dd_dem">dd_dem()</a></code> to generate demand predictions based on this model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream_discrete)
icecream_est &lt;- icecream_discrete %&gt;% dd_est_hmnl(R=20, cores=2)

</code></pre>

<hr>
<h2 id='dd_est_hmnl_screen'>Estimate discrete choice model (HMNL, attribute-based screening (not including price))</h2><span id='topic+dd_est_hmnl_screen'></span>

<h3>Description</h3>

<p>Estimate discrete choice model (HMNL, attribute-based screening (not including price))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dd_est_hmnl_screen(
  dd,
  price_screen = TRUE,
  R = 1e+05,
  keep = 10,
  cores = NULL,
  control = list(include_data = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dd_est_hmnl_screen_+3A_dd">dd</code></td>
<td>
<p>discrete choice data (long format)</p>
</td></tr>
<tr><td><code id="dd_est_hmnl_screen_+3A_price_screen">price_screen</code></td>
<td>
<p>A logical, indicating whether price tag screening should be estimated</p>
</td></tr>
<tr><td><code id="dd_est_hmnl_screen_+3A_r">R</code></td>
<td>
<p>draws</p>
</td></tr>
<tr><td><code id="dd_est_hmnl_screen_+3A_keep">keep</code></td>
<td>
<p>thinning</p>
</td></tr>
<tr><td><code id="dd_est_hmnl_screen_+3A_cores">cores</code></td>
<td>
<p>no of CPU cores to use (default: auto-detect)</p>
</td></tr>
<tr><td><code id="dd_est_hmnl_screen_+3A_control">control</code></td>
<td>
<p>list containing additional settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>est ec-draw object (List)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dd_dem_sr">dd_dem_sr()</a></code> to generate demand predictions based on this model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream_discrete)
icecream_est &lt;- icecream_discrete %&gt;% dplyr::filter(id&lt;20) %&gt;% 
  dd_est_hmnl_screen(R=20, cores=2)

</code></pre>

<hr>
<h2 id='dd_LL'>Log-Likelihood for compensatory hmnl model</h2><span id='topic+dd_LL'></span>

<h3>Description</h3>

<p>Log-Likelihood for compensatory hmnl model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dd_LL(draw, dd, fromdraw = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dd_LL_+3A_draw">draw</code></td>
<td>
<p>A list, 'echoice2' draws object</p>
</td></tr>
<tr><td><code id="dd_LL_+3A_dd">dd</code></td>
<td>
<p>A tibble, tidy choice data (before dummy-coding)</p>
</td></tr>
<tr><td><code id="dd_LL_+3A_fromdraw">fromdraw</code></td>
<td>
<p>An integer, from which draw onwards to compute LL (i.e., excl. burnin)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N x Draws Matrix of log-Likelihood values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream_discrete)
#fit model
icecream_est &lt;- icecream_discrete %&gt;% dd_est_hmnl(R=10, keep=1, cores=2)
#compute likelihood for each subject in each draw
loglls&lt;-dd_LL(icecream_est, icecream_discrete, fromdraw = 2)
</code></pre>

<hr>
<h2 id='dd_LL_sr'>Log-Likelihood for screening hmnl model</h2><span id='topic+dd_LL_sr'></span>

<h3>Description</h3>

<p>Log-Likelihood for screening hmnl model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dd_LL_sr(draw, dd, fromdraw = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dd_LL_sr_+3A_draw">draw</code></td>
<td>
<p>A list, 'echoice2' draws object</p>
</td></tr>
<tr><td><code id="dd_LL_sr_+3A_dd">dd</code></td>
<td>
<p>A tibble, tidy choice data (before dummy-coding)</p>
</td></tr>
<tr><td><code id="dd_LL_sr_+3A_fromdraw">fromdraw</code></td>
<td>
<p>An integer, from which draw onwards to compute LL (i.e., excl. burnin)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N x Draws Matrix of log-Likelihood values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream_discrete)
#fit model
icecream_est &lt;- icecream_discrete %&gt;% dd_est_hmnl_screen(R=10, keep=1, cores=2)
#compute likelihood for each subject in each draw
loglls&lt;-dd_LL_sr(icecream_est, icecream_discrete, fromdraw = 2)
</code></pre>

<hr>
<h2 id='dummify'>Create dummy variables within a tibble</h2><span id='topic+dummify'></span>

<h3>Description</h3>

<p>Create dummy variables within a tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummify(dat, sel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummify_+3A_dat">dat</code></td>
<td>
<p>A <code>tibble</code> with the data.</p>
</td></tr>
<tr><td><code id="dummify_+3A_sel">sel</code></td>
<td>
<p>A character vector with the name(s) of the variables to be dummied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with dummy variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mytest=data.frame(A=factor(c('a','a','b','c','c')), B=1:5)
dummify(mytest,"A")

</code></pre>

<hr>
<h2 id='dummyvar'>Dummy-code a categorical variable</h2><span id='topic+dummyvar'></span>

<h3>Description</h3>

<p>Dummy-code a categorical variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummyvar(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummyvar_+3A_data">data</code></td>
<td>
<p>one column of categorical data to be dummy-coded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with dummy variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mytest=data.frame(attribute=factor(c('a','a','b','c','c')))
dummyvar(mytest)
</code></pre>

<hr>
<h2 id='ec_boxplot_MU'>Generate MU_theta boxplot</h2><span id='topic+ec_boxplot_MU'></span>

<h3>Description</h3>

<p>Generate MU_theta boxplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_boxplot_MU(draws, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_boxplot_MU_+3A_draws">draws</code></td>
<td>
<p>A list, 'echoice2' draws object</p>
</td></tr>
<tr><td><code id="ec_boxplot_MU_+3A_burnin">burnin</code></td>
<td>
<p>burn-in to remove</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot containing traceplots of draws
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ec_trace_MU">ec_trace_MU()</a></code> to obtain traceplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(icecream)
#run MCMC sampler (use way more than 50 draws for actual use
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;100) %&gt;% vd_est_vdm(R=20, cores=2)
ec_boxplot_MU(icecream_est, burnin=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='ec_boxplot_screen'>Generate Screening probability boxplot</h2><span id='topic+ec_boxplot_screen'></span>

<h3>Description</h3>

<p>Generate Screening probability boxplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_boxplot_screen(draws, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_boxplot_screen_+3A_draws">draws</code></td>
<td>
<p>A list, 'echoice2' draws object, from a model with attribute-based screening</p>
</td></tr>
<tr><td><code id="ec_boxplot_screen_+3A_burnin">burnin</code></td>
<td>
<p>burn-in to remove</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot containing traceplots of draws
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ec_draws_MU">ec_draws_MU()</a></code> to obtain MU_theta draws,
<code><a href="#topic+ec_trace_screen">ec_trace_screen()</a></code> to generate traceplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
#run MCMC sampler (use way more than 20 draws for actual use
icecream_scr_est &lt;- icecream %&gt;% dplyr::filter(id&lt;20) %&gt;% vd_est_vdm_screen(R=20, cores=2)
ec_boxplot_screen(icecream_scr_est, burnin = 1)


</code></pre>

<hr>
<h2 id='ec_dem_aggregate'>Aggregate posterior draws of demand</h2><span id='topic+ec_dem_aggregate'></span>

<h3>Description</h3>

<p>Aggregate demand draws, e.g. from individual-choice occasion-alternative level to individual level.
(using the new demand draw format)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_dem_aggregate(de,groupby)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_dem_aggregate_+3A_de">de</code></td>
<td>
<p>demand draws</p>
</td></tr>
<tr><td><code id="ec_dem_aggregate_+3A_groupby">groupby</code></td>
<td>
<p>groupby grouping variables (as (vector of) string(s))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Aggregated demand predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
#run MCMC sampler (use way more than 50 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;10) %&gt;% vd_est_vdm(R=4, keep=1, cores=2)
#Generate demand predictions
icecream_predicted_demand=
 icecream %&gt;% dplyr::filter(id&lt;10) %&gt;%   
   vd_dem_vdm(icecream_est)
#aggregate
brand_lvl_pred_demand &lt;-
 icecream_predicted_demand %&gt;% ec_dem_aggregate("Brand")


</code></pre>

<hr>
<h2 id='ec_dem_eval'>Evaluate (hold-out) demand predictions</h2><span id='topic+ec_dem_eval'></span>

<h3>Description</h3>

<p>This function obtains proper posterior fit statistics.
It computes the difference between true demand and each draw from the demand posterior.
Then, fit statistics are obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_dem_eval(de)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_dem_eval_+3A_de">de</code></td>
<td>
<p>demand draws (output from vd_dem_x function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predictive fit statistics (MAE, MSE, RAE, bias, hit-probability)
</p>
<p>data(icecream)
#run MCMC sampler (use way more than 50 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;100) %&gt;% vd_est_vdm(R=20, keep=1, cores=2)
#Generate demand predictions
icecream_predicted_demand=
icecream %&gt;% dplyr::filter(id&lt;100) %&gt;%
vd_dem_vdm(icecream_est)
#evaluate in-sample fit (note: too few draws for good results)
ec_dem_eval(icecream_predicted_demand)
</p>

<hr>
<h2 id='ec_dem_summarise'>Summarize posterior draws of demand</h2><span id='topic+ec_dem_summarise'></span><span id='topic+ec_dem_summarize'></span>

<h3>Description</h3>

<p>Adds summaries of posterior draws of demand to tibble.
(using the new demand draw format)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_dem_summarise(de,quantiles)

ec_dem_summarize(de, quantiles = c(0.05, 0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_dem_summarise_+3A_de">de</code></td>
<td>
<p>demand draws</p>
</td></tr>
<tr><td><code id="ec_dem_summarise_+3A_quantiles">quantiles</code></td>
<td>
<p>Quantiles for Credibility Intervals (default: 90% interval)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary of demand predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
#run MCMC sampler (use way more than 10 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;10) %&gt;% vd_est_vdm(R=10, keep=1, cores=2)
#Generate demand predictions
icecream_predicted_demand=
 icecream %&gt;% dplyr::filter(id&lt;10) %&gt;%   
   vd_dem_vdm(icecream_est)
#aggregate
brand_lvl_pred_demand &lt;-
 icecream_predicted_demand %&gt;% ec_dem_aggregate("Brand")
#summarise
brand_lvl_pred_demand %&gt;% ec_dem_summarise()


</code></pre>

<hr>
<h2 id='ec_demcurve'>Create demand curves</h2><span id='topic+ec_demcurve'></span>

<h3>Description</h3>

<p>This helper function creates demand curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_demcurve(
  ec_long,
  focal_product,
  rel_pricerange,
  dem_fun,
  draws,
  epsilon_not = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_demcurve_+3A_ec_long">ec_long</code></td>
<td>
<p>choice scenario (discrete or volumetric)</p>
</td></tr>
<tr><td><code id="ec_demcurve_+3A_focal_product">focal_product</code></td>
<td>
<p>Logical vector picking the focal product for which to create a demand curve</p>
</td></tr>
<tr><td><code id="ec_demcurve_+3A_rel_pricerange">rel_pricerange</code></td>
<td>
<p>Price range, relative to base case price; this is used to create demand curve</p>
</td></tr>
<tr><td><code id="ec_demcurve_+3A_dem_fun">dem_fun</code></td>
<td>
<p>demand function (e.g., <code>dd_prob</code> for HMNL or <code>vd_dem_vdm</code> for volumetric demand). For discrete choice, use choice probabilities instead of choice predictions.</p>
</td></tr>
<tr><td><code id="ec_demcurve_+3A_draws">draws</code></td>
<td>
<p>ec-draws object (e.g., output from <code>dd_est_hmnl</code> or <code>vd_est_vd</code>)</p>
</td></tr>
<tr><td><code id="ec_demcurve_+3A_epsilon_not">epsilon_not</code></td>
<td>
<p>(optional) error realisatins (this helps make curves look smother for voumetric models)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing aggregate demand quantities for each scenario defined by <code>rel_pricerange</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ec_gen_err_normal">ec_gen_err_normal()</a></code> to generate error realization from Normal distribution,
<code><a href="#topic+ec_gen_err_ev1">ec_gen_err_ev1()</a></code> to generate error realization from EV1 distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
#run MCMC sampler (use way more than 50 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;100) %&gt;% 
vd_est_vdm(R=20, keep=1, cores=2)
#demand at different price points
dem_scenarios&lt;-
ec_demcurve(icecream%&gt;% dplyr::filter(id&lt;100),
 icecream%&gt;% dplyr::filter(id&lt;100) %&gt;% pull('Brand')=="Store",
 c(.75,1,1.25),vd_dem_vdm,icecream_est)
#optional plot
# dem_scenarios %&gt;% 
#   do.call('rbind',.) %&gt;%
#   ggplot(aes(x=scenario,y=`E(demand)`,color=Flavor)) + geom_line()


</code></pre>

<hr>
<h2 id='ec_demcurve_cond_dem'>Create demand-incidence curves</h2><span id='topic+ec_demcurve_cond_dem'></span>

<h3>Description</h3>

<p>This helper function creates demand curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_demcurve_cond_dem(
  ec_long,
  focal_product,
  rel_pricerange,
  dem_fun,
  draws,
  epsilon_not = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_demcurve_cond_dem_+3A_ec_long">ec_long</code></td>
<td>
<p>choice scenario (discrete or volumetric)</p>
</td></tr>
<tr><td><code id="ec_demcurve_cond_dem_+3A_focal_product">focal_product</code></td>
<td>
<p>Logical vector picking the focal product for which to create a demand curve</p>
</td></tr>
<tr><td><code id="ec_demcurve_cond_dem_+3A_rel_pricerange">rel_pricerange</code></td>
<td>
<p>Price range, relative to base case price; this is used to create demand curve</p>
</td></tr>
<tr><td><code id="ec_demcurve_cond_dem_+3A_dem_fun">dem_fun</code></td>
<td>
<p>demand function (e.g., <code>dd_prob</code> for HMNL or <code>vd_dem_vdm</code> for volumetric demand). For discrete choice, use choice probabilities instead of choice predictions.</p>
</td></tr>
<tr><td><code id="ec_demcurve_cond_dem_+3A_draws">draws</code></td>
<td>
<p>ec-draws object (e.g., output from <code>dd_est_hmnl</code> or <code>vd_est_vd</code>)</p>
</td></tr>
<tr><td><code id="ec_demcurve_cond_dem_+3A_epsilon_not">epsilon_not</code></td>
<td>
<p>(optional) error realisatins (this helps make curves look smother for voumetric models)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing aggregate demand quantities for each scenario defined by <code>rel_pricerange</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ec_gen_err_normal">ec_gen_err_normal()</a></code> to generate error realization from Normal distribution,
<code><a href="#topic+ec_gen_err_ev1">ec_gen_err_ev1()</a></code> to generate error realization from EV1 distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
#run MCMC sampler (use way more draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;20) %&gt;% 
vd_est_vdm(R=2, keep=1, cores=2)
#demand at different price points
conddem_scenarios&lt;-
ec_demcurve_cond_dem(icecream%&gt;% dplyr::filter(id&lt;20),
 icecream%&gt;% dplyr::filter(id&lt;20) %&gt;% pull('Brand')=="Store",
 c(.75,1),vd_dem_vdm,icecream_est)


</code></pre>

<hr>
<h2 id='ec_demcurve_inci'>Create demand-incidence curves</h2><span id='topic+ec_demcurve_inci'></span>

<h3>Description</h3>

<p>This helper function creates demand curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_demcurve_inci(
  ec_long,
  focal_product,
  rel_pricerange,
  dem_fun,
  draws,
  epsilon_not = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_demcurve_inci_+3A_ec_long">ec_long</code></td>
<td>
<p>choice scenario (discrete or volumetric)</p>
</td></tr>
<tr><td><code id="ec_demcurve_inci_+3A_focal_product">focal_product</code></td>
<td>
<p>Logical vector picking the focal product for which to create a demand curve</p>
</td></tr>
<tr><td><code id="ec_demcurve_inci_+3A_rel_pricerange">rel_pricerange</code></td>
<td>
<p>Price range, relative to base case price; this is used to create demand curve</p>
</td></tr>
<tr><td><code id="ec_demcurve_inci_+3A_dem_fun">dem_fun</code></td>
<td>
<p>demand function (e.g., <code>dd_prob</code> for HMNL or <code>vd_dem_vdm</code> for volumetric demand). For discrete choice, use choice probabilities instead of choice predictions.</p>
</td></tr>
<tr><td><code id="ec_demcurve_inci_+3A_draws">draws</code></td>
<td>
<p>ec-draws object (e.g., output from <code>dd_est_hmnl</code> or <code>vd_est_vd</code>)</p>
</td></tr>
<tr><td><code id="ec_demcurve_inci_+3A_epsilon_not">epsilon_not</code></td>
<td>
<p>(optional) error realisatins (this helps make curves look smother for voumetric models)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing aggregate demand quantities for each scenario defined by <code>rel_pricerange</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ec_gen_err_normal">ec_gen_err_normal()</a></code> to generate error realization from Normal distribution,
<code><a href="#topic+ec_gen_err_ev1">ec_gen_err_ev1()</a></code> to generate error realization from EV1 distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
#run MCMC sampler (use way more than 50 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;50) %&gt;% 
vd_est_vdm(R=20, keep=1, cores=2)
#demand at different price points
inci_scenarios&lt;-
ec_demcurve_inci(icecream%&gt;% dplyr::filter(id&lt;50),
 icecream%&gt;% dplyr::filter(id&lt;50) %&gt;% pull('Brand')=="Store",
 c(.75,1,1.25),vd_dem_vdm,icecream_est)

</code></pre>

<hr>
<h2 id='ec_draws_MU'>Obtain MU_theta draws</h2><span id='topic+ec_draws_MU'></span>

<h3>Description</h3>

<p>Obtain MU_theta draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_draws_MU(draws)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_draws_MU_+3A_draws">draws</code></td>
<td>
<p>A list, 'echoice2' draws object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, long format, draws of MU
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ec_draws_screen">ec_draws_screen()</a></code> to obtain screening parameter draws (where applicable),
<code><a href="#topic+ec_trace_MU">ec_trace_MU()</a></code> to generate a traceplot of MU_theta draws
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 20 draws for actual use
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;50) %&gt;% vd_est_vdm(R=20, cores=2)
ec_draws_MU(icecream_est)

</code></pre>

<hr>
<h2 id='ec_draws_screen'>Obtain Screening probability draws</h2><span id='topic+ec_draws_screen'></span>

<h3>Description</h3>

<p>Obtain Screening probability draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_draws_screen(draws)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_draws_screen_+3A_draws">draws</code></td>
<td>
<p>A list, 'echoice2' draws object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, long format, draws of MU
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ec_draws_MU">ec_draws_MU()</a></code> to obtain MU_theta draws,
<code><a href="#topic+ec_trace_screen">ec_trace_screen()</a></code> to generate a traceplot of screening draws
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 20 draws for actual use
icecream_scr_est &lt;- icecream %&gt;% dplyr::filter(id&lt;50) %&gt;% vd_est_vdm_screen(R=20, cores=2)
ec_draws_screen(icecream_scr_est)

</code></pre>

<hr>
<h2 id='ec_estimates_MU'>Obtain upper level model estimates</h2><span id='topic+ec_estimates_MU'></span>

<h3>Description</h3>

<p>Obtain upper level model estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_estimates_MU(est, quantiles = c(0.05, 0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_estimates_MU_+3A_est">est</code></td>
<td>
<p>is an 'echoice2' draw object (list)</p>
</td></tr>
<tr><td><code id="ec_estimates_MU_+3A_quantiles">quantiles</code></td>
<td>
<p>quantile for CI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with MU (upper level) summaries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 20 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;20) %&gt;% vd_est_vdm(R=20, cores=2)
#Upper-level summary
icecream_est %&gt;% ec_estimates_MU
</code></pre>

<hr>
<h2 id='ec_estimates_screen'>Summarize attribute-based screening parameters</h2><span id='topic+ec_estimates_screen'></span>

<h3>Description</h3>

<p>Summarize attribute-based screening parameters from an attribute-based screening model in 'echoice2'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_estimates_screen(est, quantiles = c(0.05, 0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_estimates_screen_+3A_est">est</code></td>
<td>
<p>is an 'echoice2' draw object (list) from a model with attribute-based screening</p>
</td></tr>
<tr><td><code id="ec_estimates_screen_+3A_quantiles">quantiles</code></td>
<td>
<p>quantile for CI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with screening summaries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#run MCMC sampler (use way more than 20 draws for actual use)
data(icecream)
est_scr_icecream &lt;- vd_est_vdm_screen(icecream%&gt;%dplyr::filter(id&lt;30), R=20, cores=2)
#summarise draws of screening probabilities
ec_estimates_screen(est_scr_icecream)
#Note: There is no variance in this illustrative example - more draws are needed

</code></pre>

<hr>
<h2 id='ec_estimates_SIGMA'>Obtain posterior mean estimates of upper level covariance</h2><span id='topic+ec_estimates_SIGMA'></span>

<h3>Description</h3>

<p>Obtain posterior mean estimates of upper level covariance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_estimates_SIGMA(est)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_estimates_SIGMA_+3A_est">est</code></td>
<td>
<p>is an 'echoice2' draw object (list)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates of upper level covariance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 20 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;50) %&gt;% vd_est_vdm(R=20, cores=2)
icecream_est %&gt;% ec_estimates_SIGMA %&gt;% round(2)
</code></pre>

<hr>
<h2 id='ec_estimates_SIGMA_corr'>Obtain posterior mean estimates of upper level correlations</h2><span id='topic+ec_estimates_SIGMA_corr'></span>

<h3>Description</h3>

<p>Obtain posterior mean estimates of upper level correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_estimates_SIGMA_corr(est)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_estimates_SIGMA_corr_+3A_est">est</code></td>
<td>
<p>is an 'echoice2' draw object (list)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates of upper level correlations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 20 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;20) %&gt;% vd_est_vdm(R=20, cores=2)
icecream_est %&gt;% ec_estimates_SIGMA_corr %&gt;% round(2)
</code></pre>

<hr>
<h2 id='ec_gen_err_ev1'>Simulate error realization from EV1 distribution</h2><span id='topic+ec_gen_err_ev1'></span>

<h3>Description</h3>

<p>Simulate error realization from EV1 distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_gen_err_ev1(ec_dem, draws, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_gen_err_ev1_+3A_ec_dem">ec_dem</code></td>
<td>
<p>discrete or volumetric choice data, with or without x</p>
</td></tr>
<tr><td><code id="ec_gen_err_ev1_+3A_draws">draws</code></td>
<td>
<p>draws from volumetric demand model</p>
</td></tr>
<tr><td><code id="ec_gen_err_ev1_+3A_seed">seed</code></td>
<td>
<p>seed for reproducible error realisations; seet is automatically reset of running this function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>error realizations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 50 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;100) %&gt;% 
vd_est_vdm(R=100, keep=1, cores=2)
#generate error realizations
errs&lt;- ec_gen_err_ev1(icecream %&gt;% dplyr::filter(id&lt;100), icecream_est, seed=123)
</code></pre>

<hr>
<h2 id='ec_gen_err_normal'>Simulate error realization from Normal distribution</h2><span id='topic+ec_gen_err_normal'></span>

<h3>Description</h3>

<p>Simulate error realization from Normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_gen_err_normal(ec_dem, draws, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_gen_err_normal_+3A_ec_dem">ec_dem</code></td>
<td>
<p>discrete or volumetric choice data, with or without x</p>
</td></tr>
<tr><td><code id="ec_gen_err_normal_+3A_draws">draws</code></td>
<td>
<p>draws from volumetric demand model</p>
</td></tr>
<tr><td><code id="ec_gen_err_normal_+3A_seed">seed</code></td>
<td>
<p>seed for reproducible error realisations; seet is automatically reset of running this function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>error realizations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
#run MCMC sampler (use way more than 50 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;10) %&gt;% 
vd_est_vdm(R=10, keep=1, error_dist = "Normal", cores=2)
#generate error realizations
errs&lt;- ec_gen_err_normal(icecream %&gt;% dplyr::filter(id&lt;10), icecream_est, seed=123)


</code></pre>

<hr>
<h2 id='ec_lmd_NR'>Obtain Log Marginal Density from draw objects</h2><span id='topic+ec_lmd_NR'></span>

<h3>Description</h3>

<p>This is a helper function to quickly obtain log marginal density from a draw object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_lmd_NR(est)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_lmd_NR_+3A_est">est</code></td>
<td>
<p>'echoice2' draw object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws are split in 4 equal parts from start to finish, and LMD
is computed for each part. This helps to double-check convergence.
</p>


<h3>Value</h3>

<p>tibble with LMDs (first 25% of draws, next 25% of draws, ...)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 50 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;100) %&gt;% vd_est_vdm(R=20, cores=2)
#obtain LMD by quartile of draws
ec_lmd_NR(icecream_est)

</code></pre>

<hr>
<h2 id='ec_lol_tidy1'>Convert &quot;list of lists&quot; format to long &quot;tidy&quot; format</h2><span id='topic+ec_lol_tidy1'></span>

<h3>Description</h3>

<p>Convert &quot;list of lists&quot; format to long &quot;tidy&quot; format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_lol_tidy1(data_lol, X = "X", y = "y")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_lol_tidy1_+3A_data_lol">data_lol</code></td>
<td>
<p>A list of data frames containing design matrices and response vectors</p>
</td></tr>
<tr><td><code id="ec_lol_tidy1_+3A_x">X</code></td>
<td>
<p>The column name of the design matrix, default: &quot;X&quot;</p>
</td></tr>
<tr><td><code id="ec_lol_tidy1_+3A_y">y</code></td>
<td>
<p>The column name of the response vector, default: &quot;y&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame with columns for each design matrix column, the response vector,
and an id column indicating which data frame the row came from
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
loldata&lt;-list()
loldata[[1]]=list()
loldata[[1]]$y = c(1,2)
loldata[[1]]$X= data.frame(brand1=c(1,0, 1,0),brand2=c(0,1, 0,1),price=c(1,2))
loldata[[2]]=list()
loldata[[2]]$y = c(1,1)
loldata[[2]]$X= data.frame(brand1=c(1,0, 1,0),brand2=c(0,1, 0,1),price=c(1,2))
ec_lol_tidy1(loldata)


</code></pre>

<hr>
<h2 id='ec_screen_summarise'>Summarize posterior draws of screening</h2><span id='topic+ec_screen_summarise'></span><span id='topic+ec_screen_summarize'></span>

<h3>Description</h3>

<p>Adds summaries of posterior draws of demand to tibble.
(using the new demand draw format)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_screen_summarise(sc, quantiles = c(0.05, 0.95))

ec_screen_summarize(sc, quantiles = c(0.05, 0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_screen_summarise_+3A_sc">sc</code></td>
<td>
<p>tibble containing screening draws in .screendraws</p>
</td></tr>
<tr><td><code id="ec_screen_summarise_+3A_quantiles">quantiles</code></td>
<td>
<p>Quantiles for Credibility Intervals (default: 90% interval)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary of screening probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
icecream_est &lt;- icecream %&gt;% vd_est_vdm_screen(R=20,  price_screen=TRUE, cores=2)
#consideration set by respondent
cons_ss &lt;- 
ec_screenprob_sr(icecream, icecream_est, cores=2) %&gt;%
group_by(id, task)  %&gt;%
  summarise(.screendraws=list(purrr::reduce(.screendraws ,`+`))) %&gt;%
  ec_screen_summarise() %&gt;%
  group_by(id) %&gt;%
  summarise(n_screen=mean(`E(screening)`))
  
</code></pre>

<hr>
<h2 id='ec_screenprob_sr'>Screening probabilities of choice alternatives</h2><span id='topic+ec_screenprob_sr'></span>

<h3>Description</h3>

<p>Obtain draws of screening probabilities of choiec alternatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_screenprob_sr(xd, est, cores=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_screenprob_sr_+3A_xd">xd</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="ec_screenprob_sr_+3A_est">est</code></td>
<td>
<p>ec-model draws</p>
</td></tr>
<tr><td><code id="ec_screenprob_sr_+3A_cores">cores</code></td>
<td>
<p>(optional) cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draws of screening probabilities of choice alternatives
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
icecream_est &lt;- icecream %&gt;% filter(id&lt;10) %&gt;% vd_est_vdm_screen(R=10,  price_screen=TRUE, cores=2)
ec_screenprob_sr(icecream %&gt;% filter(id&lt;10), icecream_est, cores=2) 

</code></pre>

<hr>
<h2 id='ec_summarize_attrlvls'>Summarize attributes and levels</h2><span id='topic+ec_summarize_attrlvls'></span><span id='topic+ec_summarise_attrlvls'></span>

<h3>Description</h3>

<p>Summarize attributes and levels in tidy choice data containing categorical attributes (before dummy-coding)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_summarize_attrlvls(data_in)

ec_summarise_attrlvls(data_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_summarize_attrlvls_+3A_data_in">data_in</code></td>
<td>
<p>A tibble, containing long-format choice data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions looks for categorical attributes and summaries their levels
This is helpful when evaluating a new choice data file.
</p>


<h3>Value</h3>

<p>A tibble with one row per attribute, and a list of the levels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
ec_summarize_attrlvls(icecream)

</code></pre>

<hr>
<h2 id='ec_trace_MU'>Generate MU_theta traceplot</h2><span id='topic+ec_trace_MU'></span>

<h3>Description</h3>

<p>Generate MU_theta traceplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_trace_MU(draws, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_trace_MU_+3A_draws">draws</code></td>
<td>
<p>A list, 'echoice2' draws object</p>
</td></tr>
<tr><td><code id="ec_trace_MU_+3A_burnin">burnin</code></td>
<td>
<p>burn-in to remove</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot containing traceplots of draws
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ec_boxplot_MU">ec_boxplot_MU()</a></code> to obtain boxplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(icecream)
#run MCMC sampler (use way more than 20 draws for actual use
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;10) %&gt;% vd_est_vdm(R=10, cores=2)
ec_trace_MU(icecream_est)

## End(Not run)

</code></pre>

<hr>
<h2 id='ec_trace_screen'>Generate Screening probability traceplots</h2><span id='topic+ec_trace_screen'></span>

<h3>Description</h3>

<p>Generate Screening probability traceplots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_trace_screen(draws, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_trace_screen_+3A_draws">draws</code></td>
<td>
<p>A list, 'echoice2' draws object, from a model with attribute-based screening</p>
</td></tr>
<tr><td><code id="ec_trace_screen_+3A_burnin">burnin</code></td>
<td>
<p>burn-in to remove</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot containing traceplots of draws
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ec_draws_MU">ec_draws_MU()</a></code> to obtain MU_theta draws,
<code><a href="#topic+ec_boxplot_screen">ec_boxplot_screen()</a></code> to generate boxplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(icecream)
#run MCMC sampler (use way more than 20 draws for actual use
icecream_scr_est &lt;- icecream %&gt;% dplyr::filter(id&lt;20) %&gt;% vd_est_vdm_screen(R=20, cores=2)
ec_trace_screen(icecream_scr_est, burnin=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='ec_undummy'>Converts a set of dummy variables into a single categorical variable</h2><span id='topic+ec_undummy'></span>

<h3>Description</h3>

<p>Given a set of dummy variables, this function converts them into a single
categorical variable. The categorical variable is created by determining
which variables are active (i.e. have a value of 1) for each observation and
assigning a category based on the set of active variables. If necessary, a
reference level can be specified to ensure that all possible categories are
represented. Often, all brands of a brand attribute are added as brand
intercepts, while other categorical attributes are coded with respect to a
reference level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_undummy(data_in, set_members, attribute_name, ref_level = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_undummy_+3A_data_in">data_in</code></td>
<td>
<p>a data frame containing the dummy variables</p>
</td></tr>
<tr><td><code id="ec_undummy_+3A_set_members">set_members</code></td>
<td>
<p>a character vector of the names of the dummy variables</p>
</td></tr>
<tr><td><code id="ec_undummy_+3A_attribute_name">attribute_name</code></td>
<td>
<p>a character string representing the name of the new
categorical variable</p>
</td></tr>
<tr><td><code id="ec_undummy_+3A_ref_level">ref_level</code></td>
<td>
<p>a character string representing the name of the reference
level. If specified, a new dummy variable will be created for this level,
and it will be used as the reference category for the categorical variable.
Defaults to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the same columns as <code>data_in</code>, except for the
dummy variables in <code>set_members</code>, which are replaced with the new
categorical variable <code>attribute_name</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>minidata=structure(list(id = c("1", "1", "1", "1", "2", "2", "2", "2"), 
task = c(1L, 1L, 2L, 2L, 3L, 3L, 4L, 4L), 
alt = c(1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L), 
brand1 = c(1, 0, 1, 0, 1, 0, 1, 0), 
brand2 = c(0, 1, 0, 1, 0, 1, 0, 1), 
price = c(1, 2, 1, 2, 1, 2, 1, 2), 
x = c(1, 0, 0, 1, 1, 0, 1, 0)), 
class = c("tbl_df", "tbl", "data.frame"), row.names = c(NA, -8L))

minidata %&gt;% ec_undummy(c('brand1','brand2'),"brand")


</code></pre>

<hr>
<h2 id='ec_undummy_lowhigh'>Convert dummy-coded variables to low/high factor</h2><span id='topic+ec_undummy_lowhigh'></span>

<h3>Description</h3>

<p>Convert dummy-coded variables to low/high factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_undummy_lowhigh(vec_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_undummy_lowhigh_+3A_vec_in">vec_in</code></td>
<td>
<p>A vector of dummy-coded variables (0/1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor vector with levels &quot;low&quot; and &quot;high&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ec_undummy_lowhigh(c(0,1,0,1,1))


</code></pre>

<hr>
<h2 id='ec_undummy_lowmediumhigh'>Convert dummy-coded variables to low/medium/high factor</h2><span id='topic+ec_undummy_lowmediumhigh'></span>

<h3>Description</h3>

<p>Convert dummy-coded variables to low/medium/high factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_undummy_lowmediumhigh(vec_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_undummy_lowmediumhigh_+3A_vec_in">vec_in</code></td>
<td>
<p>A vector of dummy-coded variables (0/1/2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor vector with levels &quot;low&quot;, &quot;medium&quot; and &quot;high&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ec_undummy_lowmediumhigh(c(0,1,2,1,0,2))


</code></pre>

<hr>
<h2 id='ec_undummy_yesno'>Convert dummy-coded variables to yes/no factor</h2><span id='topic+ec_undummy_yesno'></span>

<h3>Description</h3>

<p>Convert dummy-coded variables to yes/no factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_undummy_yesno(vec_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_undummy_yesno_+3A_vec_in">vec_in</code></td>
<td>
<p>A vector of dummy-coded variables (0/1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor vector with levels &quot;no&quot; and &quot;yes&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ec_undummy_yesno(c(0,1,0,1,1))


</code></pre>

<hr>
<h2 id='ec_util_choice_to_long'>Convert a vector of choices to long format</h2><span id='topic+ec_util_choice_to_long'></span>

<h3>Description</h3>

<p>Converts a vector of choices into a long format data frame, where each row represents
a single choice and contains the choice status for each alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_util_choice_to_long(myvec, all_index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_util_choice_to_long_+3A_myvec">myvec</code></td>
<td>
<p>A vector of choices, where each element represents the index of the chosen alternative.</p>
</td></tr>
<tr><td><code id="ec_util_choice_to_long_+3A_all_index">all_index</code></td>
<td>
<p>A vector of all the possible alternative indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns 'x', 'task', and 'alt', where 'x' is a binary indicator of whether
the alternative was chosen or not, 'task' is the task index, and 'alt' is the alternative index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#There are 3 alternatives in this task. 
#Since there are 3 observations in myvec, there are 3 tasks total.
ec_util_choice_to_long(c(1, 2, 1), c(1, 2, 3))

</code></pre>

<hr>
<h2 id='ec_util_dummy_mutualeclusive'>Find mutually exclusive columns</h2><span id='topic+ec_util_dummy_mutualeclusive'></span>

<h3>Description</h3>

<p>This function finds pairs of columns in a data frame that are mutually exclusive, i.e., that never have positive values at the same time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ec_util_dummy_mutualeclusive(data_in, filtered = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ec_util_dummy_mutualeclusive_+3A_data_in">data_in</code></td>
<td>
<p>A data frame containing the data.</p>
</td></tr>
<tr><td><code id="ec_util_dummy_mutualeclusive_+3A_filtered">filtered</code></td>
<td>
<p>A logical value indicating whether to return only the mutually exclusive pairs (TRUE) or all pairs (FALSE). Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing all pairs of mutually exclusive columns in the data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>minidata=structure(list(id = c("1", "1", "1", "1", "2", "2", "2", "2"), 
task = c(1L, 1L, 2L, 2L, 3L, 3L, 4L, 4L), 
alt = c(1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L), 
brand1 = c(1, 0, 1, 0, 1, 0, 1, 0), 
brand2 = c(0, 1, 0, 1, 0, 1, 0, 1), 
price = c(1, 2, 1, 2, 1, 2, 1, 2), 
x = c(1, 0, 0, 1, 1, 0, 1, 0)), 
class = c("tbl_df", "tbl", "data.frame"), row.names = c(NA, -8L))
ec_util_dummy_mutualeclusive(minidata)


</code></pre>

<hr>
<h2 id='get_attr_lvl'>Obtain attributes and levels from tidy choice data with dummies</h2><span id='topic+get_attr_lvl'></span>

<h3>Description</h3>

<p>Obtain attributes and levels from tidy choice data with dummies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_attr_lvl(tdc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_attr_lvl_+3A_tdc">tdc</code></td>
<td>
<p>A tibble with choice data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mytest=data.frame(A=factor(c('a','a','b','c','c')), B=1:5)
dummied_data = dummify(mytest,"A")
get_attr_lvl(dummied_data)

</code></pre>

<hr>
<h2 id='icecream'>icecream</h2><span id='topic+icecream'></span>

<h3>Description</h3>

<p>Volumetric Conjoint data, ice cream category
</p>


<h3>Details</h3>

<p>Data from volumetric conjoint analysis in the ice cream category. 300 respondents total.
Volumetric demand in units of 4 ounces each. Attributes include brand name, flavor, and container size.
</p>

<hr>
<h2 id='icecream_discrete'>icecream_discrete</h2><span id='topic+icecream_discrete'></span>

<h3>Description</h3>

<p>Discrete-Choice Conjoint data, ice cream category
</p>


<h3>Details</h3>

<p>Data from discrete choice conjoint analysis in the ice cream category. 300 respondents total.
Attributes include brand name, flavor, and container size.
</p>

<hr>
<h2 id='logMargDenNRu'>Log Marginal Density (Newton-Raftery)</h2><span id='topic+logMargDenNRu'></span>

<h3>Description</h3>

<p>This function uses the quick-and-dirty Newton-Raftery approximation for log-marginal-density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logMargDenNRu(ll)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logMargDenNRu_+3A_ll">ll</code></td>
<td>
<p>A vector of log-likelihood values (i.e., draws)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Approximation of LMD based on Newton-Raftery.
It is not the most accurate, but a very fast method.
</p>


<h3>Value</h3>

<p>A single numeric value representing the log marginal density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logll_values &lt;- c(-4000, -4001, -4002)
logMargDenNRu(logll_values)
</code></pre>

<hr>
<h2 id='pizza'>pizza</h2><span id='topic+pizza'></span>

<h3>Description</h3>

<p>Volumetric Conjoint data, pizza category
</p>


<h3>Details</h3>

<p>Data from volumetric conjoint analysis in the frozen pizza category.
</p>

<hr>
<h2 id='prep_newprediction'>Match factor levels between two datasets</h2><span id='topic+prep_newprediction'></span>

<h3>Description</h3>

<p>Makes sure the factor levels in <code>data_new</code> are aligned with <code>data_old</code>
This is helpful for demand simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_newprediction(data_new, data_old)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_newprediction_+3A_data_new">data_new</code></td>
<td>
<p>New long-format choice data</p>
</td></tr>
<tr><td><code id="prep_newprediction_+3A_data_old">data_old</code></td>
<td>
<p>Old long-format choice data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>long-format choice data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
prep_newprediction(icecream, icecream)

</code></pre>

<hr>
<h2 id='vd_add_prodid'>Add product id to demand draws</h2><span id='topic+vd_add_prodid'></span>

<h3>Description</h3>

<p>This adds a unique product identifier to  demand draw objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_add_prodid(de)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_add_prodid_+3A_de">de</code></td>
<td>
<p>demand draws</p>
</td></tr>
</table>


<h3>Value</h3>

<p>est
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
#run MCMC sampler (use way more than 10 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;10) %&gt;% vd_est_vdm(R=4, keep=1, cores=2)
#Generate demand predictions
icecream_predicted_demand=
 icecream %&gt;% dplyr::filter(id&lt;10) %&gt;%   
   vd_dem_vdm(icecream_est)
#add prodid
icecream_predicted_demand_w_id&lt;-icecream_predicted_demand %&gt;% vd_add_prodid


</code></pre>

<hr>
<h2 id='vd_dem_summarise'>Summarize posterior draws of demand (volumetric models only)</h2><span id='topic+vd_dem_summarise'></span><span id='topic+vd_dem_summarize'></span>

<h3>Description</h3>

<p>Adds summaries of posterior draws of demand to tibble.
(using the new demand draw format)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_dem_summarise(de, quantiles = c(0.05, 0.95))

vd_dem_summarize(de, quantiles = c(0.05, 0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_dem_summarise_+3A_de">de</code></td>
<td>
<p>demand draws</p>
</td></tr>
<tr><td><code id="vd_dem_summarise_+3A_quantiles">quantiles</code></td>
<td>
<p>Quantiles for Credibility Intervals (default: 90% interval)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary of demand predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
#run MCMC sampler (use way more than 10 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;10) %&gt;% vd_est_vdm(R=10, keep=1, cores=2)
#Generate demand predictions
icecream_predicted_demand=
 icecream %&gt;% dplyr::filter(id&lt;10) %&gt;%   
   vd_dem_vdm(icecream_est)
#aggregate
brand_lvl_pred_demand &lt;-
 icecream_predicted_demand %&gt;% ec_dem_aggregate("Brand")
#summarise
brand_lvl_pred_demand %&gt;% vd_dem_summarise()

</code></pre>

<hr>
<h2 id='vd_dem_vdm'>Demand Prediction (Volumetric Demand Model)</h2><span id='topic+vd_dem_vdm'></span>

<h3>Description</h3>

<p>Generating demand predictions for volumetric demand model.
Reminder: there is no closed-form solution for demand, thus we need to integrate not only over the posterior distribution of parameters and the error distribution.
The function outputs a tibble containing id, task, alt, p, attributes, draws from the posterior of demand.
Error realizations can be pre-supplied to the <code>epsilon_not</code>. This helps create smooth demand curves or conduct optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_dem_vdm(
  vd,
  est,
  epsilon_not = NULL,
  error_dist = NULL,
  tidy = TRUE,
  cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_dem_vdm_+3A_vd">vd</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_+3A_est">est</code></td>
<td>
<p>ec-model draws</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_+3A_epsilon_not">epsilon_not</code></td>
<td>
<p>(optional) error realizations</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_+3A_error_dist">error_dist</code></td>
<td>
<p>(optional) A string defining the error term distribution (default: 'EV1')</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_+3A_tidy">tidy</code></td>
<td>
<p>(optional) apply 'echoice2' tidier (default: TRUE)</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_+3A_cores">cores</code></td>
<td>
<p>(optional) cores (default: auto-detect)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draws of expected demand
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_newprediction">prep_newprediction()</a></code> to match <code>vd</code>'s factor levels,
<code><a href="#topic+ec_gen_err_ev1">ec_gen_err_ev1()</a></code> for pre-generating error realizations and
<code><a href="#topic+vd_est_vdm">vd_est_vdm()</a></code> for estimating the corresponding model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 10 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;20) %&gt;% vd_est_vdm(R=10, keep=1, cores=2)
#Generate demand predictions
icecream_predicted_demand=
 icecream %&gt;% dplyr::filter(id&lt;20) %&gt;%   
   vd_dem_vdm(icecream_est, cores=2)
#column .demdraws contains draws from posterior of predicted demand

</code></pre>

<hr>
<h2 id='vd_dem_vdm_screen'>Demand Prediction (Volumetric demand, attribute-based screening)</h2><span id='topic+vd_dem_vdm_screen'></span>

<h3>Description</h3>

<p>Generating demand predictions for volumetric demand model with attribute-based screening.
Reminder: there is no closed-form solution for demand, thus we need to integrate not only over the posterior distribution of parameters and the error distribution.
The function outputs a tibble containing id, task, alt, p, attributes, draws from the posterior of demand.
Eerror realisations can be pre-supplied to the <code>epsilon_not</code>. This helps create smooth demand curves or conduct optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_dem_vdm_screen(vd, est, epsilon_not = NULL, error_dist = NULL, cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_dem_vdm_screen_+3A_vd">vd</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_screen_+3A_est">est</code></td>
<td>
<p>ec-model draws</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_screen_+3A_epsilon_not">epsilon_not</code></td>
<td>
<p>(optional) error realizations</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_screen_+3A_error_dist">error_dist</code></td>
<td>
<p>(optional) A string defining the error term distribution (default: 'EV1')</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_screen_+3A_cores">cores</code></td>
<td>
<p>(optional) cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draws of expected demand
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_newprediction">prep_newprediction()</a></code> to match <code>vd</code>'s factor levels,
<code><a href="#topic+ec_gen_err_normal">ec_gen_err_normal()</a></code> for pre-generating error realizations and
<code><a href="#topic+vd_est_vdm_screen">vd_est_vdm_screen()</a></code> for estimating the corresponding model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 20 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;20) %&gt;% vd_est_vdm_screen(R=20, keep=1, cores=2)
#Generate demand predictions
icecream_predicted_demand=
 icecream %&gt;% dplyr::filter(id&lt;20) %&gt;%   
   vd_dem_vdm_screen(icecream_est, cores=2)
#column .demdraws contains draws from posterior of predicted demand
</code></pre>

<hr>
<h2 id='vd_dem_vdm_ss'>Demand Prediction (Volumetric demand, accounting for set-size variation, EV1 errors)</h2><span id='topic+vd_dem_vdm_ss'></span>

<h3>Description</h3>

<p>Generating demand predictions for volumetric demand model with set-size adjustment.
Reminder: there is no closed-form solution for demand, thus we need to integrate not only over the posterior distribution of parameters and the error distribution.
The function outputs a tibble containing id, task, alt, p, attributes, draws from the posterior of demand.
Eerror realizations can be pre-supplied to the <code>epsilon_not</code>. This helps create smooth demand curves or conduct optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_dem_vdm_ss(vd, est, epsilon_not = NULL, cores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_dem_vdm_ss_+3A_vd">vd</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_ss_+3A_est">est</code></td>
<td>
<p>ec-model draws</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_ss_+3A_epsilon_not">epsilon_not</code></td>
<td>
<p>(optional) error realizations</p>
</td></tr>
<tr><td><code id="vd_dem_vdm_ss_+3A_cores">cores</code></td>
<td>
<p>(optional) cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draws of expected demand
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_newprediction">prep_newprediction()</a></code> to match <code>vd</code>'s factor levels,
<code><a href="#topic+ec_gen_err_ev1">ec_gen_err_ev1()</a></code> for pre-generating error realizations and
<code><a href="#topic+vd_est_vdm_ss">vd_est_vdm_ss()</a></code> for estimating the corresponding model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 10 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;10) %&gt;% vd_est_vdm_ss(R=10, keep=1, cores=2)
#Generate demand predictions
icecream_predicted_demand=
 icecream %&gt;% dplyr::filter(id&lt;10) %&gt;%   
   vd_dem_vdm_ss(icecream_est, cores=2)
#column .demdraws contains draws from posterior of predicted demand

</code></pre>

<hr>
<h2 id='vd_est_vdm'>Estimate volumetric demand model</h2><span id='topic+vd_est_vdm'></span>

<h3>Description</h3>

<p>Estimate volumetric demand model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_est_vdm(
  vd,
  tidy = TRUE,
  R = 1e+05,
  keep = 10,
  cores = NULL,
  error_dist = "EV1",
  control = list(include_data = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_est_vdm_+3A_vd">vd</code></td>
<td>
<p>A tibble, containing volumetric demand data (long format)</p>
</td></tr>
<tr><td><code id="vd_est_vdm_+3A_tidy">tidy</code></td>
<td>
<p>A logical, whether to apply 'echoice2' tidier function (default: TRUE)</p>
</td></tr>
<tr><td><code id="vd_est_vdm_+3A_r">R</code></td>
<td>
<p>A numeric, no of draws</p>
</td></tr>
<tr><td><code id="vd_est_vdm_+3A_keep">keep</code></td>
<td>
<p>A numeric, thinning factor</p>
</td></tr>
<tr><td><code id="vd_est_vdm_+3A_cores">cores</code></td>
<td>
<p>An integer, no of CPU cores to use (default: auto-detect)</p>
</td></tr>
<tr><td><code id="vd_est_vdm_+3A_error_dist">error_dist</code></td>
<td>
<p>A string defining the error term distribution, 'EV1' or 'Normal'</p>
</td></tr>
<tr><td><code id="vd_est_vdm_+3A_control">control</code></td>
<td>
<p>A list containing additional settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'echoice2' draw object, in the form of a list
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vd_dem_vdm">vd_dem_vdm()</a></code> to generate demand predictions based on this model
</p>
<p><code><a href="#topic+vd_est_vdm_screen">vd_est_vdm_screen()</a></code> to estimate a volumetric demand model with screening
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#run MCMC sampler (use way more than 10 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;50) %&gt;% vd_est_vdm(R=10, cores=2)
</code></pre>

<hr>
<h2 id='vd_est_vdm_screen'>Estimate volumetric demand model with attribute-based conjunctive screening</h2><span id='topic+vd_est_vdm_screen'></span>

<h3>Description</h3>

<p>Estimate volumetric demand model with attribute-based conjunctive screening
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_est_vdm_screen(
  vd,
  R = 1e+05,
  keep = 10,
  cores = NULL,
  error_dist = "EV1",
  price_screen = TRUE,
  control = list(include_data = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_est_vdm_screen_+3A_vd">vd</code></td>
<td>
<p>volumetric demand data (long format)</p>
</td></tr>
<tr><td><code id="vd_est_vdm_screen_+3A_r">R</code></td>
<td>
<p>draws</p>
</td></tr>
<tr><td><code id="vd_est_vdm_screen_+3A_keep">keep</code></td>
<td>
<p>thinning</p>
</td></tr>
<tr><td><code id="vd_est_vdm_screen_+3A_cores">cores</code></td>
<td>
<p>no of CPU cores to use (default: auto-detect)</p>
</td></tr>
<tr><td><code id="vd_est_vdm_screen_+3A_error_dist">error_dist</code></td>
<td>
<p>A string defining the error term distribution, 'EV1' or 'Normal' (default: 'EV1')</p>
</td></tr>
<tr><td><code id="vd_est_vdm_screen_+3A_price_screen">price_screen</code></td>
<td>
<p>A logical, indicating whether price tag screening should be estimated (default: TRUE)</p>
</td></tr>
<tr><td><code id="vd_est_vdm_screen_+3A_control">control</code></td>
<td>
<p>list containing additional settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>est ec-draw object (List)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
icecream_est &lt;- icecream %&gt;% vd_est_vdm_screen(R=10, cores=2)
</code></pre>

<hr>
<h2 id='vd_est_vdm_ss'>Estimate volumetric demand model accounting for set size variation (1st order)</h2><span id='topic+vd_est_vdm_ss'></span>

<h3>Description</h3>

<p>This model REQUIRES variation in choice-set size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_est_vdm_ss(
  vd,
  order = 1,
  R = 1e+05,
  keep = 10,
  cores = NULL,
  control = list(include_data = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_est_vdm_ss_+3A_vd">vd</code></td>
<td>
<p>volumetric demand data (long format) with set size variation</p>
</td></tr>
<tr><td><code id="vd_est_vdm_ss_+3A_order">order</code></td>
<td>
<p>integer, either 1 or 2 (for now), indicating linear or quadratic set-size effect</p>
</td></tr>
<tr><td><code id="vd_est_vdm_ss_+3A_r">R</code></td>
<td>
<p>draws</p>
</td></tr>
<tr><td><code id="vd_est_vdm_ss_+3A_keep">keep</code></td>
<td>
<p>thinning</p>
</td></tr>
<tr><td><code id="vd_est_vdm_ss_+3A_cores">cores</code></td>
<td>
<p>no of CPU cores to use (default: auto-detect)</p>
</td></tr>
<tr><td><code id="vd_est_vdm_ss_+3A_control">control</code></td>
<td>
<p>list containing additional settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>est ec-draw object (List)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#note that for this example dataset, the model is not identified
#because the data lacks variation in set size
icecream_est &lt;- icecream %&gt;% vd_est_vdm_ss(R=10, cores=2)
</code></pre>

<hr>
<h2 id='vd_LL_vdm'>Log-Likelihood for compensatory volumetric demand model</h2><span id='topic+vd_LL_vdm'></span>

<h3>Description</h3>

<p>Log-Likelihood for compensatory volumetric demand model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_LL_vdm(draw, vd, fromdraw = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_LL_vdm_+3A_draw">draw</code></td>
<td>
<p>A list, 'echoice2' draws object</p>
</td></tr>
<tr><td><code id="vd_LL_vdm_+3A_vd">vd</code></td>
<td>
<p>A tibble, tidy choice data (before dummy-coding)</p>
</td></tr>
<tr><td><code id="vd_LL_vdm_+3A_fromdraw">fromdraw</code></td>
<td>
<p>An integer, from which draw onwards to compute LL (i.e., excl. burnin)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N x Draws Matrix of log-Likelihood values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#fit model
icecream_est &lt;- icecream %&gt;% vd_est_vdm(R=10, keep=1, cores=2)
#compute likelihood for each subject in each draw
loglls&lt;-vd_LL_vdm(icecream_est, icecream, fromdraw = 2)
dim(loglls)
</code></pre>

<hr>
<h2 id='vd_LL_vdm_screen'>Log-Likelihood for conjunctive-screening volumetric demand model</h2><span id='topic+vd_LL_vdm_screen'></span>

<h3>Description</h3>

<p>Log-Likelihood for conjunctive-screening volumetric demand model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_LL_vdm_screen(draw, vd, fromdraw = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_LL_vdm_screen_+3A_draw">draw</code></td>
<td>
<p>A list, 'echoice2' draws object</p>
</td></tr>
<tr><td><code id="vd_LL_vdm_screen_+3A_vd">vd</code></td>
<td>
<p>A tibble, tidy choice data (before dummy-coding)</p>
</td></tr>
<tr><td><code id="vd_LL_vdm_screen_+3A_fromdraw">fromdraw</code></td>
<td>
<p>An integer, from which draw onwards to compute LL (i.e., excl. burnin)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N x Draws Matrix of log-Likelihood values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#fit model
icecream_est &lt;- icecream %&gt;% filter(id&lt;20) %&gt;% vd_est_vdm_screen(R=10, keep=1, cores=2)
#compute likelihood for each subject in each draw
loglls&lt;-vd_LL_vdm_screen(icecream_est, icecream%&gt;% filter(id&lt;20), fromdraw = 2)
dim(loglls)
</code></pre>

<hr>
<h2 id='vd_LL_vdmss'>Log-Likelihood for volumetric demand model with set-size variation</h2><span id='topic+vd_LL_vdmss'></span>

<h3>Description</h3>

<p>Log-Likelihood for volumetric demand model with set-size variation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_LL_vdmss(draw, vd, fromdraw = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_LL_vdmss_+3A_draw">draw</code></td>
<td>
<p>A list, 'echoice2' draws object</p>
</td></tr>
<tr><td><code id="vd_LL_vdmss_+3A_vd">vd</code></td>
<td>
<p>A tibble, tidy choice data (before dummy-coding)</p>
</td></tr>
<tr><td><code id="vd_LL_vdmss_+3A_fromdraw">fromdraw</code></td>
<td>
<p>An integer, from which draw onwards to compute LL (i.e., excl. burnin)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N x Draws Matrix of log-Likelihood values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
#fit model
#note: this is just for demo purposes
#on this demo dataset, the model is not identified
#due to a lack of set size variation
icecream_est &lt;- icecream %&gt;% vd_est_vdm_ss(R=10, keep=1, cores=2)
#compute likelihood for each subject in each draw
loglls&lt;-vd_LL_vdmss(icecream_est, icecream, fromdraw = 2)
#300 respondents, 10 draws
dim(loglls)
</code></pre>

<hr>
<h2 id='vd_long_tidy'>Generate tidy choice data with dummies from long-format choice data</h2><span id='topic+vd_long_tidy'></span>

<h3>Description</h3>

<p>Generate tidy choice data with dummies from long-format choice data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_long_tidy(longdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_long_tidy_+3A_longdata">longdata</code></td>
<td>
<p>tibble</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icecream)
vd_long_tidy(icecream)

</code></pre>

<hr>
<h2 id='vd_prepare'>Prepare choice data for analysis</h2><span id='topic+vd_prepare'></span>

<h3>Description</h3>

<p>This utility function prepares tidy choice data for fast MCMC samplers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_prepare(dt, Af = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_prepare_+3A_dt">dt</code></td>
<td>
<p>tidy choice data (columns: id, task, alt, x, p, attributes)</p>
</td></tr>
<tr><td><code id="vd_prepare_+3A_af">Af</code></td>
<td>
<p>(optional) contains a full design matrix (for attribute-based screening), or, more generally, a design matrix used for attribute-based screening</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This function is only exported because it makes it easier to tinker with this package.
This function re-arranges choice data for fast access in highly-optimized MCMC samplers.
It Pre-computes task-wise total expenditures <code>sumpsx</code> and generates indices <code>xfr</code>,<code>xto</code>,<code>lfr</code>,<code>lto</code> for fast data access.
</p>


<h3>Value</h3>

<p>list containing information for estimation functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#minimal data example
dt &lt;- structure(list(id = c(1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 
                            2L, 2L), 
                     task = c(1L, 1L, 1L, 2L, 2L, 2L, 1L, 1L, 1L, 2L, 2L, 2L), 
                     alt = c(1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L), 
                     x = c(1, 0, 2, 1, 0, 1, 2, 3, 1, 1, 0, 1), 
                     p = c(0, 1, 1, 1, 2, 0, 2, 2, 1, 2, 1, 1), 
                     attr2 = c(1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0), 
                     attr1 = c(0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1)), 
                 class = c("tbl_df", "tbl", "data.frame"), row.names = c(NA,-12L))
#run prep function
test &lt;- dt %&gt;% vd_prepare 

</code></pre>

<hr>
<h2 id='vd_prepare_nox'>Prepare choice data for analysis (without x being present)</h2><span id='topic+vd_prepare_nox'></span>

<h3>Description</h3>

<p>This utility function prepares tidy choice data (without x) for fast data access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_prepare_nox(dt, Af = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_prepare_nox_+3A_dt">dt</code></td>
<td>
<p>tidy choice data (columns: id, task, alt, p, attributes)</p>
</td></tr>
<tr><td><code id="vd_prepare_nox_+3A_af">Af</code></td>
<td>
<p>(optional) contains a full design matrix (for attribute-based screening), or, more generally, a design matrix used for attribute-based screening</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This function is only exported because it makes it easier to tinker with this package.
This function re-arranges choice data for fast access, mainly for demand prediction.
</p>


<h3>Value</h3>

<p>list containing information for prediction functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Minimal example:
#One attribute with 3 levels, 2 subjects, 3 alternatives, 2 tasks
dt &lt;- structure(list(id = c(1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 
                            2L, 2L), 
                     task = c(1L, 1L, 1L, 2L, 2L, 2L, 1L, 1L, 1L, 2L, 2L, 2L), 
                     alt = c(1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L), 
                     x = c(1, 0, 2, 1, 0, 1, 2, 3, 1, 1, 0, 1), 
                     p = c(0, 1, 1, 1, 2, 0, 2, 2, 1, 2, 1, 1), 
                     attr2 = c(1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0), 
                     attr1 = c(0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1)), 
                 class = c("tbl_df", "tbl", "data.frame"), row.names = c(NA,-12L))
test &lt;- dt %&gt;% dplyr::select(-all_of("x")) %&gt;% vd_prepare_nox() 

</code></pre>

<hr>
<h2 id='vd_thin_draw'>Thin 'echoice2'-vd draw objects</h2><span id='topic+vd_thin_draw'></span>

<h3>Description</h3>

<p>Thin 'echoice2'-vd draw objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vd_thin_draw(est, burnin_perc = 0.5, total_draws = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vd_thin_draw_+3A_est">est</code></td>
<td>
<p>is an 'echoice2' draw object (list)</p>
</td></tr>
<tr><td><code id="vd_thin_draw_+3A_burnin_perc">burnin_perc</code></td>
<td>
<p>how much burn-in to remove</p>
</td></tr>
<tr><td><code id="vd_thin_draw_+3A_total_draws">total_draws</code></td>
<td>
<p>how many draws to keep after thinning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>thinned 'echoice2' draw object (list)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(icecream)
#run MCMC sampler (use way more than 50 draws for actual use)
icecream_est &lt;- icecream %&gt;% dplyr::filter(id&lt;100) %&gt;% vd_est_vdm(R=10, keep = 1, cores=2)
#without thinning, yields R=50 draWs
dim(icecream_est$MUDraw)
icecream_est_thinned &lt;- vd_thin_draw(icecream_est,.5)
#26 draws left after thinning about half
dim(icecream_est_thinned$MUDraw)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
