<!DOCTYPE html><html><head><title>Help for package npcp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {npcp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bOptEmpProc'><p>Bandwidth Parameter Estimation</p></a></li>
<li><a href='#cpAutocop'><p>Test for Change-Point Detection in Univariate Observations</p>
Sensitive to Changes in the Autocopula</a></li>
<li><a href='#cpBlockMax'><p>Nonparametric Tests for Change-Point Detection in the</p>
Distribution of Independent Block Maxima</a></li>
<li><a href='#cpCopula'><p>Test for Change-Point Detection in Multivariate Observations</p>
Sensitive to Changes in the Copula</a></li>
<li><a href='#cpDist'><p>Test for Change-Point Detection in Possibly Multivariate Observations</p>
Sensitive to Changes in the Distribution Function</a></li>
<li><a href='#cpRho'><p>Test for Change-Point Detection Based on Spearman's Rho</p></a></li>
<li><a href='#cpU'><p>Some CUSUM Tests for Change-Point Detection Based on U-statistics</p></a></li>
<li><a href='#quantiles'><p>Estimated Quantiles for the Open-end Nonparametric Sequential</p>
Change-Point Detection Tests</a></li>
<li><a href='#selectPoints'>
<p>A point selection procedure for multivariate data</p></a></li>
<li><a href='#seqClosedEndCpDist'><p>Closed-end Sequential Test for Change-Point Detection in Possibly</p>
Multivariate Time Series Sensitive to Changes in the Contemporary
Distribution Function</a></li>
<li><a href='#seqOpenEndCpDist'>
<p>Open-end Nonparametric Sequential Change-Point Detection Test</p>
for (Possibly) Multivariate Time Series Sensitive to
Changes in the Distribution Function</a></li>
<li><a href='#seqOpenEndCpMean'><p>Open-end Nonparametric Sequential Change-Point Detection Test</p>
for Univariate Time Series Sensitive to Changes in the Mean</a></li>
<li><a href='#stDistAutocop'><p>Combined Test of Stationarity for Univariate Continuous Time Series Sensitive</p>
to Changes in the Distribution Function and the Autocopula</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Some Nonparametric CUSUM Tests for Change-Point Detection in
Possibly Multivariate Observations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-09</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ivan Kojadinovic &lt;ivan.kojadinovic@univ-pau.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, sandwich</td>
</tr>
<tr>
<td>Suggests:</td>
<td>copula</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides nonparametric CUSUM tests for detecting changes
  in possibly serially dependent univariate or low-dimensional
  multivariate observations. Retrospective tests sensitive to changes
  in the expectation, the variance, the covariance, the
  autocovariance, the distribution function, Spearman's rho, Kendall's
  tau, Gini's mean difference, and the copula are provided, as well as
  a test for detecting changes in the distribution of independent
  block maxima (with environmental studies in mind). The package also
  contains a test sensitive to changes in the autocopula and a
  combined test of stationarity sensitive to changes in the
  distribution function and the autocopula. The latest additions are
  an open-end sequential test based on the retrospective CUSUM
  statistic that can be used for monitoring changes in the mean of
  possibly serially dependent univariate observations, as well as
  closed-end and open-end sequential tests based on empirical
  distribution functions that can be used for monitoring changes in
  the contemporary distribution of possibly serially dependent
  univariate or low-dimensional multivariate observations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENCE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-09 16:00:22 UTC; ikojadin</td>
</tr>
<tr>
<td>Author:</td>
<td>Ivan Kojadinovic <a href="https://orcid.org/0000-0002-2903-1543"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alex Verhoijsen <a href="https://orcid.org/0000-0001-9634-4796"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-09 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bOptEmpProc'>Bandwidth Parameter Estimation</h2><span id='topic+bOpt'></span><span id='topic+bOptEmpProc'></span>

<h3>Description</h3>

<p>In the context of the standard CUSUM test based on the sample mean or
in a particular empirical process setting, the following functions
estimate the bandwidth parameter controlling the serial dependence
when generating dependent multiplier sequences using the 'moving
average approach'; see Section 5 of the third reference. The function
function <code>bOpt()</code> is called in the functions
<code><a href="#topic+cpMean">cpMean</a>()</code>, <code><a href="#topic+cpVar">cpVar</a>()</code>, <code><a href="#topic+cpGini">cpGini</a>()</code>,
<code><a href="#topic+cpAutocov">cpAutocov</a>()</code>, <code><a href="#topic+cpCov">cpCov</a>()</code>,
<code><a href="#topic+cpTau">cpTau</a>()</code> and <code><a href="#topic+detOpenEndCpMean">detOpenEndCpMean</a>()</code> when <code>b</code> is
set to <code>NULL</code>. The function function <code>bOptEmpProc()</code> is
called in the functions <code><a href="#topic+cpDist">cpDist</a>()</code>,
<code><a href="#topic+cpCopula">cpCopula</a>()</code>, <code><a href="#topic+cpAutocop">cpAutocop</a>()</code>,
<code><a href="#topic+stDistAutocop">stDistAutocop</a>()</code> and <code><a href="#topic+simClosedEndCpDist">simClosedEndCpDist</a>()</code> when
<code>b</code> is set to <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bOpt(influ, weights = c("parzen", "bartlett"))

bOptEmpProc(x, m=5, weights = c("parzen", "bartlett"),
            L.method=c("max","median","mean","min"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bOptEmpProc_+3A_influ">influ</code></td>
<td>
<p>a numeric containing the relevant influence coefficients,
which, in the case of the standard CUSUM test based on the
sample mean, are simply the available observations;
see also the last reference.</p>
</td></tr>
<tr><td><code id="bOptEmpProc_+3A_x">x</code></td>
<td>
<p>a data matrix whose rows are continuous observations.</p>
</td></tr>
<tr><td><code id="bOptEmpProc_+3A_weights">weights</code></td>
<td>
<p>a string specifying the kernel for creating the
weights used in the generation of dependent multiplier sequences within the
'moving average approach'; see Section 5 of the third reference.</p>
</td></tr>
<tr><td><code id="bOptEmpProc_+3A_m">m</code></td>
<td>
<p>a strictly positive integer specifying the number of points of the
uniform grid on <code class="reqn">(0,1)^d</code> (where <code class="reqn">d</code> is
<code>ncol(x)</code>) involved in the estimation of the bandwidth
parameter; see Section 5 of the third reference. The number of
points of the grid is given by <code>m^ncol(x)</code> so that <code>m</code> needs to be
decreased as <code class="reqn">d</code> increases.</p>
</td></tr>
<tr><td><code id="bOptEmpProc_+3A_l.method">L.method</code></td>
<td>
<p>a string specifying how the parameter <code>L</code> involved
in the estimation of the bandwidth parameter is computed; see
Section 5 of the third reference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented approach results from an adaptation of the procedure
described in the first two references (see also the references
therein). The use of theses functions in a context different from that
considered in the third or fourth reference may not be meaningful.
</p>
<p>Acknowledgment: Part of the code of the function results from an
adaptation of R code of C. Parmeter and J. Racine, itself an
adaptation of Matlab code by A. Patton.
</p>


<h3>Value</h3>

<p>A strictly positive integer.</p>


<h3>References</h3>

<p>D.N. Politis and H. White (2004), Automatic block-length selection for the
dependent bootstrap, <em>Econometric Reviews</em> <b>23(1)</b>, pages 53-70.
</p>
<p>D.N. Politis, H. White and A.J. Patton (2004), Correction: Automatic
block-length selection for the dependent bootstrap,
<em>Econometric Reviews</em> <b>28(4)</b>, pages 372-375.
</p>
<p>A. Bücher and I. Kojadinovic (2016), A dependent multiplier
bootstrap for the sequential empirical copula process under strong
mixing, <em>Bernoulli</em> <b>22:2</b>, pages 927-968,
<a href="https://arxiv.org/abs/1306.3930">https://arxiv.org/abs/1306.3930</a>.
</p>
<p>A. Bücher and I. Kojadinovic (2016), Dependent multiplier
bootstraps for non-degenerate U-statistics under mixing conditions
with applications, <em>Journal of Statistical Planning and
Inference</em> <b>170</b> pages 83-105, <a href="https://arxiv.org/abs/1412.5875">https://arxiv.org/abs/1412.5875</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpDist">cpDist</a>()</code>, <code><a href="#topic+cpCopula">cpCopula</a>()</code>,
<code><a href="#topic+cpAutocop">cpAutocop</a>()</code>, <code><a href="#topic+stDistAutocop">stDistAutocop</a>()</code>,
<code><a href="#topic+cpMean">cpMean</a>()</code>, <code><a href="#topic+cpVar">cpVar</a>()</code>, <code><a href="#topic+cpGini">cpGini</a>()</code>,
<code><a href="#topic+cpAutocov">cpAutocov</a>()</code>, <code><a href="#topic+cpCov">cpCov</a>()</code>,
<code><a href="#topic+cpTau">cpTau</a>()</code>, <code><a href="#topic+seqOpenEndCpMean">seqOpenEndCpMean</a></code> and
<code><a href="#topic+seqClosedEndCpDist">seqClosedEndCpDist</a></code>.
</p>

<hr>
<h2 id='cpAutocop'>Test for Change-Point Detection in Univariate Observations
Sensitive to Changes in the Autocopula</h2><span id='topic+cpAutocop'></span>

<h3>Description</h3>

<p>Nonparametric test for change-point detection particularly sensitive
to changes in the autocopula of univariate continuous observations.
Approximate p-values for the test statistic are obtained by means of a
<em>multiplier</em> approach. Details can be found in the first reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpAutocop(x, lag = 1, b = NULL, bivariate = FALSE,
          weights = c("parzen", "bartlett"), m = 5,
          N = 1000, init.seq = NULL, include.replicates = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpAutocop_+3A_x">x</code></td>
<td>
<p>a one-column matrix containing continuous observations.</p>
</td></tr>
<tr><td><code id="cpAutocop_+3A_lag">lag</code></td>
<td>
<p>an integer specifying at which lag to consider the
autocopula; the autocopula is a (<code>lag+1</code>)-dimensional copula.</p>
</td></tr>
<tr><td><code id="cpAutocop_+3A_b">b</code></td>
<td>
<p>strictly positive integer specifying the value of the
bandwidth parameter determining the serial dependence when
generating dependent multiplier sequences using the 'moving average
approach'; see Section 5 of the second reference. If set to
<code>NULL</code>, <code>b</code> will be estimated using the
function <code><a href="#topic+bOptEmpProc">bOptEmpProc</a>()</code>; see the first reference.</p>
</td></tr>
<tr><td><code id="cpAutocop_+3A_bivariate">bivariate</code></td>
<td>
<p>a logical specifying whether the test should focus
only on the bivariate margin of the (<code>lag+1</code>)-dimensional autocopula
obtained from the first and the last dimension.</p>
</td></tr>
<tr><td><code id="cpAutocop_+3A_weights">weights</code></td>
<td>
<p>a string specifying the kernel for creating the
weights used in the generation of dependent multiplier sequences within the
'moving average approach'; see Section 5 of the second reference.</p>
</td></tr>
<tr><td><code id="cpAutocop_+3A_m">m</code></td>
<td>
<p>a strictly positive integer specifying the number of points of the
uniform grid on <code class="reqn">(0,1)</code> involved in the estimation of the bandwidth
parameter; see Section 5 of the second reference. </p>
</td></tr>
<tr><td><code id="cpAutocop_+3A_n">N</code></td>
<td>
<p>number of multiplier replications.</p>
</td></tr>
<tr><td><code id="cpAutocop_+3A_init.seq">init.seq</code></td>
<td>
<p>a sequence of independent standard normal variates of
length <code>N * (nrow(x) - lag  + 2 * (b - 1))</code> used to generate dependent
multiplier sequences.</p>
</td></tr>
<tr><td><code id="cpAutocop_+3A_include.replicates">include.replicates</code></td>
<td>
<p>a logical specifying whether the
object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> returned by the function
(see below) will include the multiplier replicates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximate p-value is computed as
</p>
<p style="text-align: center;"><code class="reqn">(0.5 +\sum_{i=1}^N\mathbf{1}_{\{S_i\ge S\}})/(N+1),</code>
</p>

<p>where <code class="reqn">S</code> and <code class="reqn">S_i</code> denote the test statistic and
a multiplier replication, respectively. This ensures that the
approximate p-value is a number strictly between 0 and 1, which is
sometimes necessary for further treatments.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>corresponding approximate p-value.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>the values of the <code>length(x)-lag-1</code> intermediate
Cramér-von Mises change-point statistics; the test
statistic is defined as the maximum of those.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the value of parameter <code>b</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a tests for a continuous univariate time series.
</p>


<h3>References</h3>

<p>A. Bücher, J.-D. Fermanian and I. Kojadinovic (2019),
Combining cumulative sum change-point detection tests for assessing
the stationarity of univariate time series, <em>Journal of Time
Series Analysis</em> <b>40</b>, pages 124-150,
<a href="https://arxiv.org/abs/1709.02673">https://arxiv.org/abs/1709.02673</a>.
</p>
<p>A. Bücher and I. Kojadinovic (2016), A dependent multiplier
bootstrap for the sequential empirical copula process under strong
mixing, <em>Bernoulli</em> <b>22:2</b>, pages 927-968,
<a href="https://arxiv.org/abs/1306.3930">https://arxiv.org/abs/1306.3930</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpAutocov">cpAutocov</a>()</code> for a related test based on
the autocovariance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## AR1 example
n &lt;- 200
k &lt;- n/2 ## the true change-point
x &lt;- matrix(c(arima.sim(list(ar = -0.5), n = k),
              arima.sim(list(ar = 0.5), n = n - k)))
cp &lt;- cpAutocop(x)
cp
## Estimated change-point
which(cp$cvm == max(cp$cvm))

## AR2 example
n &lt;- 200
k &lt;- n/2 ## the true change-point
x &lt;- matrix(c(arima.sim(list(ar = c(0,-0.5)), n = k),
              arima.sim(list(ar = c(0,0.5)), n = n - k)))
cpAutocop(x)
cpAutocop(x, lag = 2)
cpAutocop(x, lag = 2, bivariate = TRUE)
</code></pre>

<hr>
<h2 id='cpBlockMax'>Nonparametric Tests for Change-Point Detection in the
Distribution of Independent Block Maxima</h2><span id='topic+cpBlockMax'></span>

<h3>Description</h3>

<p>Nonparametric tests for change-point detection in the distribution of
independent block maxima based either on the probability weighted
moment method (see the second reference) or on the generalized
probability weighted moment method (see the first reference) for
estimating the parameters of the generalized extreme value (GEV)
distribution. It is assumed that the block maxima are independent and
that their unknown distribution functions (d.f.s) are continuous, but not
necessarily that they are GEV distributed. Three statistics are
computed. Under the assumption that the block maxima are GEV
distributed, these are statistics particularly sensitive to changes in
the location, scale and shape parameters of the GEV. Details can be
found in third reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpBlockMax(x, method = c("pwm", "gpwm"), r = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpBlockMax_+3A_x">x</code></td>
<td>
<p>a numeric vector representing independent block maxima whose
unknown d.f.s are assumed continuous.</p>
</td></tr>
<tr><td><code id="cpBlockMax_+3A_method">method</code></td>
<td>
<p>a string specifying how statistics will be defined; can
be either <code>"pwm"</code> (the probability weighted moment method) or
<code>"gpwm"</code> (the generalized probability weighted moment method).
The method <code>"pwm"</code> is suggested for climate block maxima
that are typically not too heavy tailed, more precisely, whose
distributions are in
the maximum domains of attraction of GEV distributions with shape parameters
smaller than a half. The method <code>"gpwm"</code> should be preferred
otherwise.</p>
</td></tr>
<tr><td><code id="cpBlockMax_+3A_r">r</code></td>
<td>
<p>strictly positive integer specifying the set of breakpoints
that will be tested; more precisely, starting from the initial
sample of block maxima, the tests compare subsamples formed by the
<code>k</code> first maxima and <code>n-k</code> last maxima
for <code>k</code> in the set <code>{r,...,n-r}</code>, where <code>n</code>
is the sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Approximate p-values are computed
from the estimated asymptotic null distributions, which involve the
Kolmogorov distribution. The latter is dealt with reusing code from
the <code><a href="stats.html#topic+ks.test">ks.test</a>()</code> function; credit to RCore.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>value of the three test statistics.</p>
</td></tr>
<tr><td><code>pvalues</code></td>
<td>
<p>corresponding approximate p-values.</p>
</td></tr>
<tr><td><code>stats.loc</code></td>
<td>
<p>the values of the <code>n - (2 * r - 1)</code> intermediate
change-point statistics sensitive to changes in the location;
the first test statistic is defined as the maximum of those.</p>
</td></tr>
<tr><td><code>stats.scale</code></td>
<td>
<p>the values of the <code>n - (2 * r - 1)</code> intermediate
change-point statistics sensitive to changes in the scale;
the second test statistic is defined as the maximum of those.</p>
</td></tr>
<tr><td><code>stats.shape</code></td>
<td>
<p>the values of the <code>n - (2 * r - 1)</code> intermediate
change-point statistics sensitive to changes in the shape;
the third test statistic is defined as the maximum of those.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The tests were derived under the assumption of block maxima with
continuous d.f., which implies that ties
occur with probability zero. A way to deal with ties based on
randomization is proposed in the third reference.
</p>


<h3>References</h3>

<p>J. Diebolt, A. Guillou, P. Naveau and P. Ribereau (2008), Improving
probability-weighted moment methods for the generalized extreme-value
distribution, <em>REVSTAT</em> <b>6</b>, pages 33-50.
</p>
<p>J.R.M. Hosking, J.R. Wallis and E.F. Wood (1985), Estimation of the
generalized extreme-value distribution by the method of
probability-weighted moments, <em>Technometrics</em> <b>27</b>, pages 251-261.
</p>
<p>I. Kojadinovic and P. Naveau (2017), Nonparametric tests for
change-point detection in the distribution of block maxima based on
probability weighted moments, <em>Extremes</em> <b>20:2</b>, pages 417-450,
<a href="https://arxiv.org/abs/1507.06121">https://arxiv.org/abs/1507.06121</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpDist">cpDist</a>()</code> for a related test based on the empirical d.f.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(evd)
n &lt;- 100
k &lt;- 50 ## the true change-point

## Change in the shape parameter of a GEV
x &lt;- rgev(k,loc=0,scale=1,shape=-0.8)
y &lt;- rgev(k,loc=0,scale=1,shape=0.4)
cp &lt;- cpBlockMax(c(x,y))
cp
## Estimated change-point
which(cp$stats.shape == max(cp$stats.shape))

## Change in the scale parameter of a GEV
x &lt;- rgev(k,loc=0,scale=0.5,shape=0)
y &lt;- rgev(k,loc=0,scale=1,shape=0)
cp &lt;- cpBlockMax(c(x,y))
cp
## Estimated change-point
which(cp$stats.scale == max(cp$stats.scale))

## Change in the location parameter of a GEV
x &lt;- rgev(k,loc=0,scale=1,shape=0)
y &lt;- rgev(k,loc=0.5,scale=1,shape=0)
cp &lt;- cpBlockMax(c(x,y))
cp
## Estimated change-point
which(cp$stats.loc == max(cp$stats.loc))
## End(Not run)
</code></pre>

<hr>
<h2 id='cpCopula'>Test for Change-Point Detection in Multivariate Observations
Sensitive to Changes in the Copula</h2><span id='topic+cpCopula'></span>

<h3>Description</h3>

<p>Nonparametric test for change-point detection particularly sensitive
to changes in the copula of multivariate continuous observations. The
observations can be serially independent or dependent (strongly mixing).
Approximate p-values for the test statistic are obtained by means of a
<em>multiplier</em> approach. Details can be found in the first reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpCopula(x, method = c("seq", "nonseq"), b = NULL,
         weights = c("parzen", "bartlett"), m = 5,
         L.method=c("max","median","mean","min"),
         N = 1000, init.seq = NULL, include.replicates = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpCopula_+3A_x">x</code></td>
<td>
<p>a data matrix whose rows are multivariate continuous
observations.</p>
</td></tr>
<tr><td><code id="cpCopula_+3A_method">method</code></td>
<td>
<p>a string specifying the simulation method for
generating multiplier replicates of the test statistic;
can be either <code>"seq"</code> (the 'check' approach
in the first reference) or <code>"nonseq"</code> (the 'hat' approach
in the first reference). The 'check' approach appears to lead to
better behaved tests in the case of samples of moderate size. The
'hat' approach is substantially faster.</p>
</td></tr>
<tr><td><code id="cpCopula_+3A_b">b</code></td>
<td>
<p>strictly positive integer specifying the value of the
bandwidth parameter determining the serial dependence when
generating dependent multiplier sequences using the 'moving average
approach'; see Section 5 of the second reference. The
value 1 will create i.i.d. multiplier
sequences suitable for serially independent observations. If set to
<code>NULL</code>, <code>b</code> will be estimated from <code>x</code> using the
function <code><a href="#topic+bOptEmpProc">bOptEmpProc</a>()</code>; see the procedure described in
Section 5 of the second reference.</p>
</td></tr>
<tr><td><code id="cpCopula_+3A_weights">weights</code></td>
<td>
<p>a string specifying the kernel for creating the
weights used in the generation of dependent multiplier sequences within the
'moving average approach'; see Section 5 of the second reference.</p>
</td></tr>
<tr><td><code id="cpCopula_+3A_m">m</code></td>
<td>
<p>a strictly positive integer specifying the number of points of the
uniform grid on <code class="reqn">(0,1)^d</code> (where <code class="reqn">d</code> is
<code>ncol(x)</code>) involved in the estimation of the bandwidth
parameter; see Section 5 of the third reference. The number of
points of the grid is given by <code>m^ncol(x)</code> so that <code>m</code> needs to be
decreased as <code class="reqn">d</code> increases.</p>
</td></tr>
<tr><td><code id="cpCopula_+3A_l.method">L.method</code></td>
<td>
<p>a string specifying how the parameter <code class="reqn">L</code> involved
in the estimation of the bandwidth parameter is computed; see
Section 5 of the second reference.</p>
</td></tr>
<tr><td><code id="cpCopula_+3A_n">N</code></td>
<td>
<p>number of multiplier replications.</p>
</td></tr>
<tr><td><code id="cpCopula_+3A_init.seq">init.seq</code></td>
<td>
<p>a sequence of independent standard normal variates of
length <code>N * (nrow(x) + 2 * (b - 1))</code> used to generate dependent
multiplier sequences.</p>
</td></tr>
<tr><td><code id="cpCopula_+3A_include.replicates">include.replicates</code></td>
<td>
<p>a logical specifying whether the
object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> returned by the function
(see below) will include the multiplier replicates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximate p-value is computed as
</p>
<p style="text-align: center;"><code class="reqn">(0.5 +\sum_{i=1}^N\mathbf{1}_{\{S_i\ge S\}})/(N+1),</code>
</p>

<p>where <code class="reqn">S</code> and <code class="reqn">S_i</code> denote the test statistic and
a multiplier replication, respectively. This ensures that the
approximate p-value is a number strictly between 0 and 1, which is
sometimes necessary for further treatments.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>corresponding approximate p-value.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>the values of the <code>nrow(x)-1</code> intermediate
Cramér-von Mises change-point statistics; the test
statistic is defined as the maximum of those.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the value of parameter <code>b</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>These tests were derived under the assumption of continuous margins.
</p>


<h3>References</h3>

<p>A. Bücher, I. Kojadinovic, T. Rohmer and J. Segers (2014),
Detecting changes in cross-sectional dependence in multivariate
time series, <em>Journal of Multivariate Analysis</em> <b>132</b>, pages 111-128,
<a href="https://arxiv.org/abs/1206.2557">https://arxiv.org/abs/1206.2557</a>.
</p>
<p>A. Bücher and I. Kojadinovic (2016), A dependent multiplier
bootstrap for the sequential empirical copula process under strong
mixing, <em>Bernoulli</em> <b>22:2</b>, pages 927-968,
<a href="https://arxiv.org/abs/1306.3930">https://arxiv.org/abs/1306.3930</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpRho">cpRho</a>()</code> for a related test based on
Spearman's rho, <code><a href="#topic+cpTau">cpTau</a>()</code> for a related test based on
Kendall's tau, <code><a href="#topic+cpDist">cpDist</a>()</code> for a related test based
on the multivariate empirical d.f., <code><a href="#topic+bOptEmpProc">bOptEmpProc</a>()</code> for the
function used to estimate <code>b</code> from <code>x</code> if <code>b = NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(copula)
n &lt;- 100
k &lt;- 50 ## the true change-point
u &lt;- rCopula(k, gumbelCopula(1.5))
v &lt;- rCopula(n - k, gumbelCopula(3))
x &lt;- rbind(u,v)
cp &lt;- cpCopula(x, b = 1)
cp
## Estimated change-point
which(cp$cvm == max(cp$cvm))
## End(Not run)
</code></pre>

<hr>
<h2 id='cpDist'>Test for Change-Point Detection in Possibly Multivariate Observations
Sensitive to Changes in the Distribution Function</h2><span id='topic+cpDist'></span>

<h3>Description</h3>

<p>Nonparametric test for change-point detection based on the
(multivariate) empirical distribution function. The observations can
be continuous univariate or multivariate, and serially independent or
dependent (strongly mixing).  Approximate p-values for the test
statistics are obtained by means of a <em>multiplier</em>
approach. The first reference treats the serially
independent case while details about the serially
dependent case can be found in second and third references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpDist(x, statistic = c("cvmmax", "cvmmean", "ksmax", "ksmean"),
       method = c("nonseq", "seq"), b = NULL, gamma = 0,
       delta = 1e-4, weights = c("parzen", "bartlett"),
       m = 5, L.method=c("max","median","mean","min"),
       N = 1000, init.seq = NULL, include.replicates = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpDist_+3A_x">x</code></td>
<td>
<p>a data matrix whose rows are continuous observations.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_statistic">statistic</code></td>
<td>
<p>a string specifying the statistic whose value and
p-value will be displayed; can be either <code>"cvmmax"</code> or
<code>"cvmmean"</code> (the maximum or average of the <code>nrow(x)-1</code>
intermediate Cramér-von Mises statistics), or
<code>"ksmax"</code> or <code>"ksmean"</code> (the maximum or average of the
<code>nrow(x)-1</code> intermediate Kolmogorov-Smirnov statistics); see
Section 3 in the first reference. The four statistics and the
corresponding p-values are computed at each execution.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_method">method</code></td>
<td>
<p>a string specifying the simulation method for
generating multiplier replicates of the test statistic;
can be either <code>"nonseq"</code> (the 'check' approach
in the first reference) or <code>"seq"</code> (the 'hat' approach
in the first reference). The 'check' approach appears to lead to
better behaved tests and is recommended.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_b">b</code></td>
<td>
<p>strictly positive integer specifying the value of the
bandwidth parameter determining the serial dependence when
generating dependent multiplier sequences using the 'moving average
approach'; see Section 5 of the second reference. The
value 1 will create i.i.d. multiplier
sequences suitable for serially independent observations. If set to
<code>NULL</code>, <code>b</code> will be estimated from <code>x</code> using the
function <code><a href="#topic+bOptEmpProc">bOptEmpProc</a>()</code>; see the procedure described in
Section 5 of the second reference.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_gamma">gamma</code></td>
<td>
<p>parameter between 0 and 0.5 appearing in the definition
of the weight function used in the detector function.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_delta">delta</code></td>
<td>
<p>parameter between 0 and 1 appearing in the definition
of the weight function used in the detector function.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_weights">weights</code></td>
<td>
<p>a string specifying the kernel for creating the
weights used in the generation of dependent multiplier sequences within the
'moving average approach'; see Section 5 of the second reference.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_m">m</code></td>
<td>
<p>a strictly positive integer specifying the number of points of the
uniform grid on <code class="reqn">(0,1)^d</code> (where <code class="reqn">d</code> is
<code>ncol(x)</code>) involved in the estimation of the bandwidth
parameter; see Section 5 of the third reference. The number of
points of the grid is given by <code>m^ncol(x)</code> so that <code>m</code> needs to be
decreased as <code class="reqn">d</code> increases.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_l.method">L.method</code></td>
<td>
<p>a string specifying how the parameter <code class="reqn">L</code> involved
in the estimation of the bandwidth parameter is computed; see
Section 5 of the second reference.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_n">N</code></td>
<td>
<p>number of multiplier replications.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_init.seq">init.seq</code></td>
<td>
<p>a sequence of independent standard normal variates of
length <code>N * (nrow(x) + 2 * (b - 1))</code> used to generate dependent
multiplier sequences.</p>
</td></tr>
<tr><td><code id="cpDist_+3A_include.replicates">include.replicates</code></td>
<td>
<p>a logical specifying whether the
object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> returned by the function
(see below) will include the multiplier replicates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximate p-value is computed as
</p>
<p style="text-align: center;"><code class="reqn">(0.5 +\sum_{i=1}^N\mathbf{1}_{\{S_i\ge S\}})/(N+1),</code>
</p>

<p>where <code class="reqn">S</code> and <code class="reqn">S_i</code> denote the test statistic and
a multiplier replication, respectively. This ensures that the
approximate p-value is a number strictly between 0 and 1, which is
sometimes necessary for further treatments.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>corresponding approximate p-value.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>the values of the <code>nrow(x)-1</code> intermediate
Cramér-von Mises change-point statistics.</p>
</td></tr>
<tr><td><code>ks</code></td>
<td>
<p>the values of the <code>nrow(x)-1</code> intermediate
Kolmogorov-Smirnov change-point statistics.</p>
</td></tr>
<tr><td><code>all.statistics</code></td>
<td>
<p>the values of all four test statistics.</p>
</td></tr>
<tr><td><code>all.p.values</code></td>
<td>
<p>the corresponding p-values.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the value of parameter <code>b</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that when the observations are continuous univariate and serially
independent, independent realizations of the tests statistics under
the null hypothesis of no change in the distribution can be
obtained by simulation; see Section 4 in the first reference.
</p>


<h3>References</h3>

<p>M. Holmes, I. Kojadinovic and J-F. Quessy (2013), Nonparametric tests
for change-point detection à la Gombay and Horváth,
<em>Journal of Multivariate Analysis</em> <b>115</b>, pages 16-32.
</p>
<p>A. Bücher and I. Kojadinovic (2016), A dependent multiplier
bootstrap for the sequential empirical copula process under strong
mixing, <em>Bernoulli</em> <b>22:2</b>, pages 927-968,
<a href="https://arxiv.org/abs/1306.3930">https://arxiv.org/abs/1306.3930</a>.
</p>
<p>A. Bücher, J.-D. Fermanian and I. Kojadinovic (2019),
Combining cumulative sum change-point detection tests for assessing
the stationarity of univariate time series, <em>Journal of Time
Series Analysis</em> <b>40</b>, pages 124-150,
<a href="https://arxiv.org/abs/1709.02673">https://arxiv.org/abs/1709.02673</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpCopula">cpCopula</a>()</code> for a related test based on the empirical
copula, <code><a href="#topic+cpRho">cpRho</a>()</code> for a related test based on
Spearman's rho, <code><a href="#topic+cpTau">cpTau</a>()</code> for a related test based on
Kendall's tau, <code><a href="#topic+bOptEmpProc">bOptEmpProc</a>()</code> for the function used to
estimate <code>b</code> from <code>x</code> if <code>b = NULL</code>,
<code><a href="#topic+seqClosedEndCpDist">seqClosedEndCpDist</a></code> for the corresponding sequential test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A univariate example
n &lt;- 100
k &lt;- 50 ## the true change-point
y &lt;- rnorm(k)
z &lt;- rexp(n-k)
x &lt;- matrix(c(y,z))
cp &lt;- cpDist(x, b = 1)
cp

## All statistics
cp$all.statistics
## Corresponding p.values
cp$all.p.values

## Estimated change-point
which(cp$cvm == max(cp$cvm))
which(cp$ks == max(cp$ks))

## A very artificial trivariate example
## with a break in the first margin
n &lt;- 100
k &lt;- 50 ## the true change-point
y &lt;- rnorm(k)
z &lt;- rnorm(n-k, mean = 2)
x &lt;- cbind(c(y,z),matrix(rnorm(2*n), n, 2))
cp &lt;- cpDist(x, b = 1)
cp

## All statistics
cp$all.statistics
## Corresponding p.values
cp$all.p.values

## Estimated change-point
which(cp$cvm == max(cp$cvm))
which(cp$ks == max(cp$ks))
</code></pre>

<hr>
<h2 id='cpRho'>Test for Change-Point Detection Based on Spearman's Rho</h2><span id='topic+cpRho'></span>

<h3>Description</h3>

<p>Nonparametric test for change-point detection particularly sensitive
to changes in Spearman's rho in multivariate time series. The
observations can be serially independent or dependent (strongly mixing).
Approximate p-values for the test statistic are obtained by means of a
<em>multiplier</em> approach or by estimating the asymptotic null
distribution. Details can be found in first reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpRho(x, method = c("mult", "asym.var"),
      statistic = c("pairwise", "global"),
      b = NULL, weights = c("parzen", "bartlett"),
      N = 1000, init.seq = NULL, include.replicates = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpRho_+3A_x">x</code></td>
<td>
<p>a data matrix whose rows are multivariate continuous
observations.</p>
</td></tr>
<tr><td><code id="cpRho_+3A_method">method</code></td>
<td>
<p>a string specifying the method for computing the
approximate p-value for the test statistic; can be either
<code>"mult"</code> (the multiplier approach 'tilde' in the first
reference) or <code>"asym.var"</code> (the approach based on the
estimation of the asymptotic null distribution of the test statistic
described in the first reference). The 'mult' approach appears to lead to
better behaved tests.</p>
</td></tr>
<tr><td><code id="cpRho_+3A_statistic">statistic</code></td>
<td>
<p>a string specifying the test statistic; can be either
<code>"pairwise"</code> (the statistic <code class="reqn">S_{n,3}</code> in the first
reference) or <code>"global"</code> (the statistic <code class="reqn">S_{n,1}</code>
in the first reference).</p>
</td></tr>
<tr><td><code id="cpRho_+3A_b">b</code></td>
<td>
<p>strictly positive integer specifying the value of the
bandwidth parameter determining the serial dependence when
generating dependent multiplier sequences using the 'moving average
approach'; see Section 5 of the second reference. The value 1
will create i.i.d. multiplier
sequences suitable for serially independent observations. If set to
<code>NULL</code>, <code>b</code> will be estimated from <code>x</code> using the
procedure described in the first reference.</p>
</td></tr>
<tr><td><code id="cpRho_+3A_weights">weights</code></td>
<td>
<p>a string specifying the kernel for creating the
weights used in the generation of dependent multiplier sequences within the
'moving average approach'; see Section 5 of the second reference.</p>
</td></tr>
<tr><td><code id="cpRho_+3A_n">N</code></td>
<td>
<p>number of multiplier replications.</p>
</td></tr>
<tr><td><code id="cpRho_+3A_init.seq">init.seq</code></td>
<td>
<p>a sequence of independent standard normal variates of
length <code>N * (nrow(x) + 2 * (b - 1))</code> used to generate dependent
multiplier sequences.</p>
</td></tr>
<tr><td><code id="cpRho_+3A_include.replicates">include.replicates</code></td>
<td>
<p>a logical specifying whether the
object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> returned by the function
(see below) will include the multiplier replicates, if generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>method == "mult"</code>, the approximate p-value is computed as
</p>
<p style="text-align: center;"><code class="reqn">(0.5 +\sum_{i=1}^N\mathbf{1}_{\{S_i\ge S\}})/(N+1),</code>
</p>

<p>where <code class="reqn">S</code> and <code class="reqn">S_i</code> denote the test statistic and
a multiplier replication, respectively. This ensures that the
approximate p-value is a number strictly between 0 and 1, which is
sometimes necessary for further treatments.
</p>
<p>When <code>method == "asym.var"</code>, the approximate p-value is computed
from the estimated asymptotic null distribution, which involves the
Kolmogorov distribution. The latter is dealt with reusing code from
the <code><a href="stats.html#topic+ks.test">ks.test</a>()</code> function; credit to RCore.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>corresponding approximate p-value.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>the values of the <code>nrow(x)-1</code> intermediate
change-point statistics; the test statistic is defined as
the maximum of those.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the value of parameter <code>b</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>These tests were derived under the assumption of continuous margins.
</p>


<h3>References</h3>

<p>I. Kojadinovic, J-F. Quessy and T. Rohmer (2016),
Testing the constancy of Spearman's rho in multivariate time series,
<em>Annals of the Institute of Statistical Mathematics</em> <b>68:5</b>,
pages 929-954, <a href="https://arxiv.org/abs/1407.1624">https://arxiv.org/abs/1407.1624</a>.
</p>
<p>A. Bücher and I. Kojadinovic (2016), A dependent multiplier
bootstrap for the sequential empirical copula process under strong
mixing, <em>Bernoulli</em> <b>22:2</b>, pages 927-968,
<a href="https://arxiv.org/abs/1306.3930">https://arxiv.org/abs/1306.3930</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpTau">cpTau</a>()</code> for a related test based on
Kendall's tau, <code><a href="#topic+cpDist">cpDist</a>()</code> for a related test
based on the multivariate
empirical d.f., <code><a href="#topic+cpCopula">cpCopula</a>()</code> for a related test based on
the empirical copula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(copula)
n &lt;- 100
k &lt;- 50 ## the true change-point
u &lt;- rCopula(k,gumbelCopula(1.5))
v &lt;- rCopula(n-k,gumbelCopula(3))
x &lt;- rbind(u,v)
cp &lt;- cpRho(x, b = 1)
cp
## Estimated change-point
which(cp$rho == max(cp$rho))
## End(Not run)
</code></pre>

<hr>
<h2 id='cpU'>Some CUSUM Tests for Change-Point Detection Based on U-statistics</h2><span id='topic+cpMean'></span><span id='topic+cpVar'></span><span id='topic+cpGini'></span><span id='topic+cpAutocov'></span><span id='topic+cpCov'></span><span id='topic+cpTau'></span>

<h3>Description</h3>

<p>Nonparametric CUSUM tests for change-point detection particularly sensitive
to changes in certain quantities that can be estimated using
one-sample U-statistics of order one or two. So far, the quantities under
consideration are the expectation (thus corresponding to the standard
CUSUM test based on the sample mean), the variance, Gini's mean difference, the
autocovariance at a specified lag, the covariance for bivariate data
and Kendall's tau for multivariate data.
The observations can be serially independent or dependent (strongly mixing).
Approximate p-values for the test statistic are obtained by means of a
<em>multiplier</em> approach or by estimating the asymptotic null
distribution. Details can be found in the first reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpMean(x, method = c("nonseq", "seq", "asym.var"),
       b = NULL, weights = c("parzen", "bartlett"),
       N = 1000, init.seq = NULL, include.replicates = FALSE)

cpVar(x, method = c("nonseq", "seq", "asym.var"),
      b = NULL, weights = c("parzen", "bartlett"),
      N = 1000, init.seq = NULL, include.replicates = FALSE)

cpGini(x, method = c("nonseq", "seq", "asym.var"),
       b = NULL, weights = c("parzen", "bartlett"),
       N = 1000, init.seq = NULL, include.replicates = FALSE)

cpAutocov(x, lag = 1, method = c("nonseq", "seq", "asym.var"),
          b = NULL, weights = c("parzen", "bartlett"),
          N = 1000, init.seq = NULL, include.replicates = FALSE)

cpCov(x, method = c("nonseq", "seq", "asym.var"),
      b = NULL, weights = c("parzen", "bartlett"),
      N = 1000, init.seq = NULL, include.replicates = FALSE)

cpTau(x, method = c("seq", "nonseq", "asym.var"),
      b = NULL, weights = c("parzen", "bartlett"),
      N = 1000, init.seq = NULL, include.replicates = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpU_+3A_x">x</code></td>
<td>
<p>a numeric vector or a data matrix containing continuous observations.</p>
</td></tr>
<tr><td><code id="cpU_+3A_lag">lag</code></td>
<td>
<p>an integer specifying at which lag to consider the autocovariance.</p>
</td></tr>
<tr><td><code id="cpU_+3A_method">method</code></td>
<td>
<p>a string specifying the method for computing the
approximate p-value for the test statistic; can be either
<code>"seq"</code> (the 'check' approach in the first reference),
<code>"nonseq"</code> (the 'hat' approach in the first reference), or
<code>"asym.var"</code> (the approach based on the estimation of the
asymptotic null distribution of the test statistic described
in the first reference). The 'seq' approach appears overall to lead to
better behaved tests for <code><a href="#topic+cpTau">cpTau</a>()</code>. More experiments
are necessary for the other functions.</p>
</td></tr>
<tr><td><code id="cpU_+3A_b">b</code></td>
<td>
<p>strictly positive integer specifying the value of the
bandwidth parameter determining the serial dependence when
generating dependent multiplier sequences using the 'moving average
approach'; see Section 5 of the second reference. The value 1
will create i.i.d. multiplier
sequences suitable for serially independent observations. If set to
<code>NULL</code>, <code>b</code> will be estimated from <code>x</code> using the
procedure described in the first reference.</p>
</td></tr>
<tr><td><code id="cpU_+3A_weights">weights</code></td>
<td>
<p>a string specifying the kernel for creating the
weights used in the generation of dependent multiplier sequences within the
'moving average approach'; see Section 5 of the second reference.</p>
</td></tr>
<tr><td><code id="cpU_+3A_n">N</code></td>
<td>
<p>number of multiplier replications.</p>
</td></tr>
<tr><td><code id="cpU_+3A_init.seq">init.seq</code></td>
<td>
<p>a sequence of independent standard normal variates of
length <code>N * (nrow(x) + 2 * (b - 1))</code> used to generate dependent
multiplier sequences.</p>
</td></tr>
<tr><td><code id="cpU_+3A_include.replicates">include.replicates</code></td>
<td>
<p>a logical specifying whether the
object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> returned by the function
(see below) will include the multiplier replicates, if generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>method</code> is either <code>"seq"</code> or <code>"nonseq"</code>,
the approximate p-value is computed as
</p>
<p style="text-align: center;"><code class="reqn">(0.5 +\sum_{i=1}^N\mathbf{1}_{\{S_i\ge S\}})/(N+1),</code>
</p>

<p>where <code class="reqn">S</code> and <code class="reqn">S_i</code> denote the test statistic and
a multiplier replication, respectively. This ensures that the
approximate p-value is a number strictly between 0 and 1, which is
sometimes necessary for further treatments.
</p>
<p>When <code>method = "asym.var"</code>, the approximate p-value is computed
from the estimated asymptotic null distribution, which involves the
Kolmogorov distribution. The latter is dealt with reusing code from
the <code><a href="stats.html#topic+ks.test">ks.test</a>()</code> function; credit to RCore.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>corresponding approximate p-value.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>the values of the <code>nrow(x)-3</code> intermediate
change-point statistics; the test statistic is defined as
the maximum of those.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the value of parameter <code>b</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Bücher and I. Kojadinovic (2016), Dependent multiplier
bootstraps for non-degenerate U-statistics under mixing conditions
with applications, <em>Journal of Statistical Planning and
Inference</em> <b>170</b>, pages 83-105, <a href="https://arxiv.org/abs/1412.5875">https://arxiv.org/abs/1412.5875</a>.
</p>
<p>A. Bücher and I. Kojadinovic (2016), A dependent multiplier
bootstrap for the sequential empirical copula process under strong
mixing, <em>Bernoulli</em> <b>22:2</b>, pages 927-968,
<a href="https://arxiv.org/abs/1306.3930">https://arxiv.org/abs/1306.3930</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpDist">cpDist</a>()</code> for a related test based on the multivariate
empirical d.f., <code><a href="#topic+cpCopula">cpCopula</a>()</code> for a related test based on
the empirical copula, <code><a href="#topic+cpAutocop">cpAutocop</a>()</code> for a related test based on
the empirical autocopula, <code><a href="#topic+cpRho">cpRho</a>()</code> for a related test based on
Spearman's rho, <code><a href="#topic+bOpt">bOpt</a>()</code> for the function used to
estimate <code>b</code> from <code>x</code> if <code>b = NULL</code> and
<code><a href="#topic+seqOpenEndCpMean">seqOpenEndCpMean</a></code> for related sequential tests that can be used
for online monitoring.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The standard CUSUM test based on the sample mean
cp &lt;- cpMean(c(rnorm(50), rnorm(50, mean=1)), b=1)
cp
## Estimated change-point
which(cp$statistics == cp$statistic)

## Testing for changes in the autocovariance
n &lt;- 200
k &lt;- n/2 ## the true change-point
x &lt;- c(arima.sim(list(ar = -0.5), n = k),
       arima.sim(list(ar = 0.5), n = n - k))
cp &lt;- cpAutocov(x)
cp
## Estimated change-point
which(cp$u == cp$statistic)
## Another example
x &lt;- c(arima.sim(list(ar = c(0,-0.5)), n = k),
       arima.sim(list(ar = c(0,0.5)), n = n - k))
cpAutocov(x)
cp &lt;- cpAutocov(x, lag = 2)
cp
## Estimated change-point
which(cp$u == cp$statistic)

## Not run: 
## Testing for changes in Kendall's tau
require(copula)
n &lt;- 100
k &lt;- 50 ## the true change-point
u &lt;- rCopula(k,gumbelCopula(1.5))
v &lt;- rCopula(n-k,gumbelCopula(3))
x &lt;- rbind(u,v)
cp &lt;- cpTau(x)
cp
## Estimated change-point
which(cp$u == cp$statistic)

## Testing for changes in the covariance
cp &lt;- cpCov(x)
cp
## Estimated change-point
which(cp$u == cp$statistic)
## End(Not run)
</code></pre>

<hr>
<h2 id='quantiles'>Estimated Quantiles for the Open-end Nonparametric Sequential
Change-Point Detection Tests</h2><span id='topic+quantiles'></span>

<h3>Description</h3>

<p>Estimated quantiles for the open-end nonparametric sequential
change-point detection tests described in
<code><a href="#topic+seqOpenEndCpMean">seqOpenEndCpMean</a></code> and
<code><a href="#topic+seqOpenEndCpDist">seqOpenEndCpDist</a></code>. More details can be found in the
references below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("quantiles")
</code></pre>


<h3>Format</h3>

<p><code><a href="base.html#topic+list">list</a></code> of 6 elements. The first 5 are arrays containing
the estimated 90%, 95% and 99% quantiles necessary for carrying out
the sequential tests described in <code><a href="#topic+seqOpenEndCpMean">seqOpenEndCpMean</a></code>. The
last element is a list containing the estimated 90%, 95% and 99%
quantiles as well as other estimated parameters necessary for carrying
out the sequential test described in <code><a href="#topic+seqOpenEndCpDist">seqOpenEndCpDist</a></code>.
</p>


<h3>References</h3>

<p>J. Gösmann, T. Kley and H. Dette (2021), A new approach for
open-end sequential change point monitoring, <em>Journal of Time
Series Analysis</em> <b>42:1</b>, pages 63-84,
<a href="https://arxiv.org/abs/1906.03225">https://arxiv.org/abs/1906.03225</a>.
</p>
<p>M. Holmes and I. Kojadinovic (2021), Open-end nonparametric
sequential change-point detection based on the retrospective CUSUM
statistic, <em>Electronic Journal of Statistics</em> <b>15:1</b>, pages
2288-2335, <a href="https://doi.org/10.1214/21-EJS1840">doi:10.1214/21-EJS1840</a>.
</p>
<p>L. Horváth, M. Hušková, P. Kokoszka and
J. Steinebach (2004). Monitoring changes in linear
models. <em>Journal of Statistical Planning and Inference</em>
<b>126</b>, pages 225-251.
</p>
<p>M. Holmes, I. Kojadinovic and A. Verhoijsen (2022), Multi-purpose
open-end monitoring procedures for multivariate observations based on
the empirical distribution function, 45 pages,
<a href="https://arxiv.org/abs/2201.10311">https://arxiv.org/abs/2201.10311</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("quantiles")
str(quantiles)
</code></pre>

<hr>
<h2 id='selectPoints'>
A point selection procedure for multivariate data
</h2><span id='topic+selectPoints'></span>

<h3>Description</h3>

<p>Returns a matrix of &lsquo;representative&rsquo; points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectPoints(x, r, kappa = 1.5, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectPoints_+3A_x">x</code></td>
<td>
<p>a numeric matrix with <code>d</code> columns whose rows represent
multivariate observations.</p>
</td></tr>
<tr><td><code id="selectPoints_+3A_r">r</code></td>
<td>
<p>integer specifying the size of an initial uniformly-spaced
grid &lsquo;on the probability scale&rsquo;; an upper bound for the number of
selected points is <code>r^d</code>.</p>
</td></tr>
<tr><td><code id="selectPoints_+3A_kappa">kappa</code></td>
<td>
<p>numeric constant required to be strictly greater than one
involved in the point selection procedure.</p>
</td></tr>
<tr><td><code id="selectPoints_+3A_plot">plot</code></td>
<td>
<p>logical used only if <code>d = 2</code> specifying whether a plot
should be produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selection procedure is described in detail in Section 3.2 of the
reference below. Set <code>plot = TRUE</code> for visual feedback and
information on the minimum number of &lsquo;surrounding&rsquo; observations
required for a grid point to be selected. The initial grid 'on the
probability scale' is in blue, while the points selected by the procedure
are in red.
</p>


<h3>Value</h3>

<p>a matrix with <code>d</code> columns whose rows are the selected points.
</p>


<h3>References</h3>

<p>M. Holmes, I. Kojadinovic, and A. Verhoijsen, Multi-purpose open-end
monitoring procedures for multivariate observations based on the
empirical distribution function, 45 pages,
<a href="https://arxiv.org/abs/2201.10311">https://arxiv.org/abs/2201.10311</a>.
</p>


<h3>See Also</h3>

<p><code>selectPoints()</code> is used in <code><a href="#topic+detOpenEndCpDist">detOpenEndCpDist</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate data
set.seed(123)
x1 &lt;- rnorm(1000, 0, 1)
x2 &lt;- rnorm(1000, 0.7 * x1, sqrt((1 - 0.7^2)))
x &lt;- cbind(x1, x2)

## Point selection
selectPoints(x, r = 3, kappa = 1.5, plot = TRUE)
selectPoints(x, r = 3, kappa = 4, plot = TRUE)

selectPoints(x, r = 5, kappa = 1.5, plot = TRUE)
selectPoints(x, r = 5, kappa = 4, plot = TRUE)
</code></pre>

<hr>
<h2 id='seqClosedEndCpDist'>Closed-end Sequential Test for Change-Point Detection in Possibly
Multivariate Time Series Sensitive to Changes in the Contemporary
Distribution Function</h2><span id='topic+seqClosedEndCpDist'></span><span id='topic+simClosedEndCpDist'></span><span id='topic+threshClosedEndCpDist'></span><span id='topic+detClosedEndCpDist'></span><span id='topic+monClosedEndCpDist'></span>

<h3>Description</h3>

<p>Closed-end nonparametric sequential test for change-point detection
based on the (multivariate) empirical distribution function. The
observations can be continuous univariate or multivariate, and
serially independent or dependent (strongly mixing). To carry out the
test, four steps are required. The first step consists of simulating
under the null many trajectories of the detector function. The second
step consists of estimating a piecewise constant threshold function
from these trajectories. The third step consists of computing the
detector function from the data to be monitored. The fourth and last
step consists of comparing the detector function with the estimated
threshold function. Each of these steps corresponds to one of the
functions in the usage section below. The current implementation is
preliminary and not optimized for real-time monitoring (but could
still be used for that). If the observations to be monitored are
univariate and can be assumed serially independent, the simulation of
the trajectories of the detector functions can be carried out using
Monte Carlo simulation. In all other cases, the test relies on a
<em>dependent multiplier bootstrap</em>. Details can be found in the
second reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simClosedEndCpDist(x.learn = NULL, m = NULL, n, gamma = 0.25, delta = 1e-4,
                   B = 1000, method = c("sim", "mult"), b = NULL,
                   weights = c("parzen", "bartlett"), g = 5,
                   L.method = c("max","median","mean","min"))

threshClosedEndCpDist(sims, p = 1, alpha = 0.05, type = 7)

detClosedEndCpDist(x.learn, x, gamma = 0.25, delta = 1e-4)

monClosedEndCpDist(det, thresh, statistic = c("mac", "mmc", "mmk", "mk", "mc"),
                   plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqClosedEndCpDist_+3A_x.learn">x.learn</code></td>
<td>
<p>a data matrix whose rows are continuous observations,
representing the learning sample.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_m">m</code></td>
<td>
<p>a strictly positive integer specifying the size of the
learning sample if <code>x.learn</code> is not specified; the latter
implies that the observations are univariate and assumed to be
independent; if <code>m</code> is not specified, it is taken equal to
<code>nrow(x.learn)</code>.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_n">n</code></td>
<td>
<p>a strictly positive integer specifying the monitoring horizon;
the monitoring period is <code>m+1</code>, ..., <code>n</code>.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_gamma">gamma</code></td>
<td>
<p>a real parameter between 0 and 0.5 appearing in the definition
of the weight function used in the detector function.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_delta">delta</code></td>
<td>
<p>a real parameter between 0 and 1 appearing in the definition
of the weight function used in the detector function.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_b">B</code></td>
<td>
<p>the number of trajectories of the detector function to simulate
under the null.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_method">method</code></td>
<td>
<p>a string specifying the trajectory simulation method;
can be either <code>"sim"</code> (Monte Carlo simulation &ndash; only in
the univariate case under the assumption of serial independence)
or <code>"mult"</code> (the dependent multiplier bootstrap).</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_b">b</code></td>
<td>
<p>strictly positive integer specifying the value of the
bandwidth parameter determining the serial dependence when
generating dependent multiplier sequences using the 'moving average
approach'; see Section 5 of the first reference. The value 1 will
create i.i.d. multiplier sequences suitable for serially independent
observations. If set to <code>NULL</code>, <code>b</code> will be estimated from
<code>x.learn</code> using the function <code><a href="#topic+bOptEmpProc">bOptEmpProc</a>()</code>; see
the procedure described in Section 5 of the first reference.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_weights">weights</code></td>
<td>
<p>a string specifying the kernel for creating the
weights used in the generation of dependent multiplier sequences within the
'moving average approach'; see Section 5 of the first reference.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_g">g</code></td>
<td>
<p>a strictly positive integer specifying the number of points of
the uniform grid on <code class="reqn">(0,1)^d</code> (where <code class="reqn">d</code> is
<code>ncol(x)</code>) involved in the estimation of the bandwidth
parameter; see Section 5 of the first reference. The number of points
of the grid is given by <code>g^ncol(x)</code> so that <code>g</code> needs to be
decreased as <code class="reqn">d</code> increases.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_l.method">L.method</code></td>
<td>
<p>a string specifying how the parameter <code class="reqn">L</code> involved
in the estimation of the bandwidth parameter is computed; see
Section 5 of the first reference.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_sims">sims</code></td>
<td>
<p>an object of class <code>sims.cpDist</code> containing simulated
trajectories of the detector function under the null.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_p">p</code></td>
<td>
<p>a strictly positive integer specifying the number of steps of
the piece constant threshold function; <code>p</code> should not be
taken too large (say, smaller than 4) if <code>method = "mult"</code>.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_alpha">alpha</code></td>
<td>
<p>the value of the desired significance level for the
sequential test.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_type">type</code></td>
<td>
<p>an integer between 1 and 9 selecting one of the nine quantile
algorithms detailed in the help of the function <code><a href="stats.html#topic+quantile">quantile</a>()</code>.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_x">x</code></td>
<td>
<p>a data matrix whose rows are continuous observations
corresponding to the new observations to be monitored for a change in
contemporary distribution.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_det">det</code></td>
<td>
<p>an object of class <code>det.cpDist</code> representing a detector
function computed using <code>detClosedEndCpDist()</code>.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_thresh">thresh</code></td>
<td>
<p>an object of class <code>thresh.cpDist</code> representing a threshold
function estimated using <code>threshClosedEndCpDist()</code>.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_statistic">statistic</code></td>
<td>
<p>a string specifying the statistic/detector to be used
for the monitoring; can be either <code>"mac"</code>, <code>"mmc"</code>,
<code>"mmk"</code>, <code>"mc"</code> or <code>"mk"</code>; the last letter
specifies whether it is a Cramér-von Mises-like
statistic (letter <code>"c"</code>) or a Kolmogorov-Smirnov-like
statistic (letter <code>"k"</code>); the letters before specify the
type of aggregation steps used to compute the detectors
(<code>"m"</code> for maximum, <code>"a"</code> for average); <code>"mac"</code> corresponds to the
detector <code class="reqn">T_{m,q}</code> in the second reference,
<code>"mmc"</code> to the detector <code class="reqn">S_{m,q}</code>,
<code>"mmk"</code> to the detector <code class="reqn">R_{m,q}</code>,
<code>"mc"</code> to the detector <code class="reqn">Q_m</code> and <code>"mk"</code> to
the detector <code class="reqn">P_m</code>.</p>
</td></tr>
<tr><td><code id="seqClosedEndCpDist_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether the monitoring should be
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The testing procedure is described in detail in the second reference.
</p>


<h3>Value</h3>

<p>All functions return lists whose components have explicit names. The
function <code>monClosedEndCpDist()</code> in particular returns a list whose
components are
</p>
<table>
<tr><td><code>alarm</code></td>
<td>
<p>a logical indicating whether the detector function has
exceeded the threshold function.</p>
</td></tr>
<tr><td><code>time.alarm</code></td>
<td>
<p>an integer corresponding to the time at
which the detector function has exceeded the threshold function or
<code>NA</code>.</p>
</td></tr>
<tr><td><code>times.max</code></td>
<td>
<p>a vector of times at which the successive detectors
<code>"mmc"</code> (if <code>statistic = "mac"</code> or <code>statistic =
    "mmc"</code>) or <code>"mmk"</code> (if <code>statistic = "mmk"</code>) have reached
their maximum; a vector of <code>NA</code>'s if <code>statistic = "mc"</code> or
<code>statistic = "mk"</code>; this sequence of times can be used to
estimate the time of change from the time of alarm.</p>
</td></tr>
<tr><td><code>time.change</code></td>
<td>
<p>an integer giving the estimated time of change if
<code>alarm</code> is <code>TRUE</code>; the latter is simply the value in
<code>times.max</code> which corresponds to <code>time.alarm</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a test for continuous (multivariate) time series.
</p>


<h3>References</h3>

<p>A. Bücher and I. Kojadinovic (2016), A dependent multiplier
bootstrap for the sequential empirical copula process under strong
mixing, <em>Bernoulli</em> <b>22:2</b>, pages 927-968,
<a href="https://arxiv.org/abs/1306.3930">https://arxiv.org/abs/1306.3930</a>.
</p>
<p>I. Kojadinovic and G. Verdier (2021), Nonparametric sequential
change-point detection for multivariate time series based on empirical
distribution functions, <em>Electronic Journal of Statistics</em>
<b>15(1)</b>, pages 773-829, <a href="https://doi.org/10.1214/21-EJS1798">doi:10.1214/21-EJS1798</a>.
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+cpDist">cpDist</a>()</code> for the corresponding a posteriori (offline) test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example of montoring for the period m+1, ..., n
m &lt;- 100 # size of the learning sample
n &lt;- 150 # monitoring horizon

## The learning sample
set.seed(123)
x.learn &lt;- matrix(rnorm(m))

## New observations with a large change in mean
## to simulate monitoring for the period m+1, ..., n
k &lt;- 125 ## the true change-point
x &lt;- matrix(c(rnorm(k-m), rnorm(n-k, mean = 2)))

## Step 1: Simulation of B trajectories of the detector functions under the null
B &lt;- 1e4

## Under the assumption of serial independence
## (no need to specify the learning sample)
traj.sim &lt;- simClosedEndCpDist(m = m, n = n, B = B, method = "sim")

## Without the assumption of serial independence
## (the learning sample is compulsory; the larger it is, the better;
## the monitoring horizon n should not be too large)
traj.mult &lt;- simClosedEndCpDist(x.learn = x.learn, n = n, B = B, method = "mult")

## Step 2: Compute threshold functions with p steps
p &lt;- 2
tf.sim &lt;- threshClosedEndCpDist(traj.sim, p = p)
# p can be taken large if B is very large

tf.mult &lt;- threshClosedEndCpDist(traj.mult, p = p) # p should not be taken too
                                          # large unless both m and B
                                          # are very large

## Step 3: Compute the detectors for the monitoring period m+1, ... , n
det &lt;- detClosedEndCpDist(x.learn = x.learn, x = x)

## Step 4: Monitoring

## Simulate the monitoring with the first threshold function
monClosedEndCpDist(det, tf.sim)

## Simulate the monitoring with the second threshold function
monClosedEndCpDist(det, tf.mult)

## Simulate the monitoring with the first threshold function
## and another detector function
monClosedEndCpDist(det, tf.sim, statistic = "mmk")

## Alternative steps 3 and 4:

## Compute the detectors for the monitoring period m+1, ... , m+20 only
det &lt;- detClosedEndCpDist(x.learn = x.learn, x = x[1:20,,drop = FALSE])

## Simulate the monitoring with the first threshold function
monClosedEndCpDist(det, tf.sim)

## Simulate the monitoring with the second threshold function
monClosedEndCpDist(det, tf.mult)

## End(Not run)
</code></pre>

<hr>
<h2 id='seqOpenEndCpDist'>
Open-end Nonparametric Sequential Change-Point Detection Test
for (Possibly) Multivariate Time Series Sensitive to
Changes in the Distribution Function
</h2><span id='topic+seqOpenEndCpDist'></span><span id='topic+detOpenEndCpDist'></span><span id='topic+monOpenEndCpDist'></span>

<h3>Description</h3>

<p>Open-end nonparametric sequential test for change-point detection based
on a retrospective CUSUM statistic constructed from differences of
empirical distribution functions. The observations can be univariate
or multivariate (low-dimensional), and serially dependent.  To carry
out the test, two steps are required. The first step consists of
computing a detector function. The second step consists of comparing
the detector function to a suitable constant threshold function. Each
of these steps corresponds to one of the functions in the usage
section below. The current implementation is preliminary and not
optimized for real-time monitoring (but could still be used for
that). Details can be found in the first reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detOpenEndCpDist(x.learn, x, pts = NULL, r = NULL, sigma = NULL, kappa = 1.5, ...)

monOpenEndCpDist(det, alpha = 0.05, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqOpenEndCpDist_+3A_x.learn">x.learn</code></td>
<td>
<p>a numeric matrix representing the learning sample.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpDist_+3A_x">x</code></td>
<td>
<p>a numeric matrix representing the observations collected
after the beginning of the monitoring.</p>
</td></tr>  
<tr><td><code id="seqOpenEndCpDist_+3A_pts">pts</code></td>
<td>
<p>a numeric matrix whose rows represent the evaluation
points; if not provided by user, chosen automatically from
the learning sample using parameter <code>r</code>.</p>
</td></tr>	   
<tr><td><code id="seqOpenEndCpDist_+3A_r">r</code></td>
<td>
<p>integer greater or equal than 2 representing the number of
evaluation points per dimension to be chosen from the learning
sample; used only if <code>pts = NULL</code>.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpDist_+3A_sigma">sigma</code></td>
<td>
<p>a numeric matrix representing the covariance matrix to be
used; if <code>NULL</code>, estimated by <code>sandwich::lrvar()</code>.</p>
</td></tr>  
<tr><td><code id="seqOpenEndCpDist_+3A_kappa">kappa</code></td>
<td>
<p>constant involved in the point selection procedure; used
only if the multivariate case; should be larger than 1.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpDist_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>sandwich::lrvar()</code>.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpDist_+3A_det">det</code></td>
<td>
<p>an object of class <code>det.OpenEndCpDist</code> representing a
detector function computed using <code>detOpenEndCpDist()</code>.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpDist_+3A_alpha">alpha</code></td>
<td>
<p>the value of the desired significance level for the
sequential test.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpDist_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether the monitoring should be
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The testing procedure is described in detail in the first reference.
</p>


<h3>Value</h3>

<p>Both functions return lists whose components have explicit names. The
function <code>monOpenEndCpDist()</code> in particular returns a list whose
components are
</p>
<table>
<tr><td><code>alarm</code></td>
<td>
<p>a logical indicating whether the detector function has
exceeded the threshold function.</p>
</td></tr>
<tr><td><code>time.alarm</code></td>
<td>
<p>an integer corresponding to the time at
which the detector function has exceeded the threshold function or
<code>NA</code>.</p>
</td></tr>
<tr><td><code>times.max</code></td>
<td>
<p>a vector of times at which the successive detectors
have reached their maximum; this sequence of times can be used to
estimate the time of change from the time of alarm.</p>
</td></tr>
<tr><td><code>time.change</code></td>
<td>
<p>an integer giving the estimated time of change if
<code>alarm</code> is <code>TRUE</code>; the latter is simply the value in
<code>times.max</code> which corresponds to <code>time.alarm</code>.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value of <code>statistic</code> in the call of the function.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>the value of <code>eta</code> in the call of the function.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>number of evaluations points of the empirical distribution functions.</p>
</td></tr>
<tr><td><code>pts</code></td>
<td>
<p>evaluation points of the empirical distribution functions.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the value of <code>alpha</code> in the call of the function.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the value of <code>sigma</code> in the call of the function.</p>
</td></tr>
<tr><td><code>detector</code></td>
<td>
<p>the successive values of the detector.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>the value of the constant threshold for the detector.</p>
</td></tr>
</table>


<h3>References</h3>

<p>M. Holmes, I. Kojadinovic and A. Verhoijsen (2022), Multi-purpose
open-end monitoring procedures for multivariate observations based on
the empirical distribution function, 45 pages,
<a href="https://arxiv.org/abs/2201.10311">https://arxiv.org/abs/2201.10311</a>.
</p>
<p>M. Holmes and I. Kojadinovic (2021), Open-end nonparametric sequential
change-point detection based on the retrospective CUSUM statistic,
<em>Electronic Journal of Statistics</em> <b>15:1</b>, pages 2288-2335,
<a href="https://doi.org/10.1214/21-EJS1840">doi:10.1214/21-EJS1840</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+detOpenEndCpMean">detOpenEndCpMean</a>()</code> for the corresponding test
sensitive to changes in the mean, <code><a href="#topic+selectPoints">selectPoints</a>()</code> for the
underlying point selection procedure used in the multivariate case
and <code><a href="sandwich.html#topic+lrvar">lrvar</a>()</code> for information on the estimation
of the underlying long-run covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example of open-end monitoring
m &lt;- 800 # size of the learning sample
nm &lt;- 5000 # number of collected observations after the start
n &lt;- nm + m # total number of observations

set.seed(456)

## Univariate, no change in distribution
r &lt;- 5 # number of evaluation points
x &lt;- rnorm(n)
## Step 1: Compute the detector
det &lt;- detOpenEndCpDist(x.learn = matrix(x[1:m]),
                        x = matrix(x[(m + 1):n]), r = r)
## Step 2: Monitoring
mon &lt;- monOpenEndCpDist(det = det, alpha = 0.05, plot = TRUE)

## Univariate, change in distribution
k &lt;- 2000 # m + k + 1 is the time of change
x[(m + k + 1):n] &lt;- rt(nm - k, df = 3)
det &lt;- detOpenEndCpDist(x.learn = matrix(x[1:m]),
                        x = matrix(x[(m + 1):n]), r = r)
mon &lt;- monOpenEndCpDist(det = det, alpha = 0.05, plot = TRUE)

## Bivariate, no change
d &lt;- 2
r &lt;- 4 # number of evaluation points per dimension
x &lt;- matrix(rnorm(n * d), nrow = n, ncol = d)
det &lt;- detOpenEndCpDist(x.learn = x[1:m, ], x = x[(m + 1):n, ], r = r)
mon &lt;- monOpenEndCpDist(det = det, alpha = 0.05, plot = TRUE)

## Bivariate, change in the mean of the first margin
x[(m + k + 1):n, 1] &lt;- x[(m + k + 1):n, 1] + 0.3
det &lt;- detOpenEndCpDist(x.learn = x[1:m, ], x = x[(m + 1):n, ], r = r)
mon &lt;- monOpenEndCpDist(det = det, alpha = 0.05, plot = TRUE)

## Bivariate, change in the dependence structure
x1 &lt;- rnorm(n)
x2 &lt;- c(rnorm(m + k, 0.2 * x1[1:(m + k)], sqrt((1 - 0.2^2))),
        rnorm(nm - k, 0.7 * x1[(m + k + 1):n], sqrt((1 - 0.7^2))))
x &lt;- cbind(x1, x2)
det &lt;- detOpenEndCpDist(x.learn = x[1:m, ], x = x[(m + 1):n, ], r = r)
mon &lt;- monOpenEndCpDist(det = det, alpha = 0.05, plot = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='seqOpenEndCpMean'>Open-end Nonparametric Sequential Change-Point Detection Test
for Univariate Time Series Sensitive to Changes in the Mean</h2><span id='topic+seqOpenEndCpMean'></span><span id='topic+detOpenEndCpMean'></span><span id='topic+monOpenEndCpMean'></span>

<h3>Description</h3>

<p>Open-end nonparametric sequential test for change-point detection
based on the retrospective CUSUM statistic. The observations need to
be univariate but can be serially dependent. To carry out the test,
two steps are required. The first step consists of computing a
detector function. The second step consists of comparing the detector
function to a suitable constant threshold function. Each of these
steps corresponds to one of the functions in the usage section
below. The current implementation is preliminary and not optimized for
real-time monitoring (but could still be used for that). Details can
be found in the third reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detOpenEndCpMean(x.learn, x, sigma = NULL, b = NULL,
          weights = c("parzen", "bartlett"))

monOpenEndCpMean(det, statistic = c("t", "s", "r", "e", "cs"), eta = 0.001,
          gamma = 0.45, alpha = 0.05, sigma = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqOpenEndCpMean_+3A_x.learn">x.learn</code></td>
<td>
<p>a numeric vector representing the learning sample.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpMean_+3A_x">x</code></td>
<td>
<p>a numeric vector representing the observations collected after the
beginning of the monitoring for a change in mean.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpMean_+3A_sigma">sigma</code></td>
<td>
<p>an estimate of the long-run variance of the time series of
which <code>x.learn</code> is a stretch. If set to <code>NULL</code>,
<code>sigma</code> will be estimated using an approach similar to
those described in the fourth reference.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpMean_+3A_b">b</code></td>
<td>
<p>strictly positive integer specifying the value of the
bandwidth for the estimation of the long-run variance if
<code>sigma</code> is not provided. If set to <code>NULL</code>, <code>b</code> will
be estimated from <code>x.learn</code> using the function
<code><a href="#topic+bOpt">bOpt</a>()</code>.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpMean_+3A_weights">weights</code></td>
<td>
<p>a string specifying the kernel for creating the weights
used for the estimation of the long-run variance if <code>sigma</code> is
not provided; see Section 5 of the first reference.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpMean_+3A_det">det</code></td>
<td>
<p>an object of class <code>det.cpMean</code> representing a detector
function computed using <code>detOpenEndCpMean()</code>.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpMean_+3A_statistic">statistic</code></td>
<td>
<p>a string specifying the statistic/detector to be used
for the monitoring; can be either <code>"t"</code>, <code>"s"</code>,
<code>"r"</code>, <code>"e"</code> or <code>"cs"</code>; <code>"t"</code> corresponds to the
detector <code class="reqn">T_{m}</code> in the third reference, <code>"s"</code> to the
detector <code class="reqn">S_{m}</code>, <code>"r"</code> to the detector <code class="reqn">R_{m}</code>,
<code>"e"</code> to the detector <code class="reqn">E_m</code> and <code>"cs"</code> to
so-called ordinary CUSUM detector denoted by <code class="reqn">Q_m</code> in the
third reference. Note that the detector <code class="reqn">E_m</code>
was proposed in the second reference.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpMean_+3A_eta">eta</code></td>
<td>
<p>a real parameter whose role is described in detail in
the third reference.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpMean_+3A_gamma">gamma</code></td>
<td>
<p>a real parameter that can improve the power of the
sequential test at the beginning of the monitoring; possible values
are 0, 0.1, 0.25, 0.45, 0.65 and 0.85, but not for all statistics; see
the third reference.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpMean_+3A_alpha">alpha</code></td>
<td>
<p>the value of the desired significance level for the
sequential test.</p>
</td></tr>
<tr><td><code id="seqOpenEndCpMean_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether the monitoring should be
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The testing procedure is described in detail in the third
reference. An alternative way of estimating the long-run variance is
to use the function <code><a href="sandwich.html#topic+lrvar">lrvar</a>()</code> of the package
<span class="pkg">sandwich</span> and to pass it through the argument <code>sigma</code>.
</p>


<h3>Value</h3>

<p>Both functions return lists whose components have explicit names. The
function <code>monOpenEndCpMean()</code> in particular returns a list whose
components are
</p>
<table>
<tr><td><code>alarm</code></td>
<td>
<p>a logical indicating whether the detector function has
exceeded the threshold function.</p>
</td></tr>
<tr><td><code>time.alarm</code></td>
<td>
<p>an integer corresponding to the time at
which the detector function has exceeded the threshold function or
<code>NA</code>.</p>
</td></tr>
<tr><td><code>times.max</code></td>
<td>
<p>a vector of times at which the successive detectors
<code>"r"</code> (if <code>statistic = "r"</code>, <code>statistic = "s"</code> or
<code>statistic = "t"</code>) or <code>"e"</code> (if <code>statistic = "e"</code>)
have reached their maximum; a vector of <code>NA</code>'s if
<code>statistic = "cs"</code>; this sequence of times can be used to
estimate the time of change from the time of alarm.</p>
</td></tr>
<tr><td><code>time.change</code></td>
<td>
<p>an integer giving the estimated time of change if
<code>alarm</code> is <code>TRUE</code>; the latter is simply the value in
<code>times.max</code> which corresponds to <code>time.alarm</code>.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value of <code>statistic</code> in the call of the function.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>the value of <code>eta</code> in the call of the function.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>the value of <code>gamma</code> in the call of the function.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>the value of <code>alpha</code> in the call of the function.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the value of <code>sigma</code> in the call of the function.</p>
</td></tr>
<tr><td><code>detector</code></td>
<td>
<p>the successive values of the chosen detector.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>the value of the constant threshold for the chosen detector.</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Bücher and I. Kojadinovic (2016), A dependent multiplier
bootstrap for the sequential empirical copula process under strong
mixing, <em>Bernoulli</em> <b>22:2</b>, pages 927-968,
<a href="https://arxiv.org/abs/1306.3930">https://arxiv.org/abs/1306.3930</a>.
</p>
<p>J. Gösmann, T. Kley and H. Dette (2021), A new approach for
open-end sequential change point monitoring, <em>Journal of Time
Series Analysis</em> <b>42:1</b>, pages 63-84, 
<a href="https://arxiv.org/abs/1906.03225">https://arxiv.org/abs/1906.03225</a>.
</p>
<p>M. Holmes and I. Kojadinovic (2021), Open-end nonparametric
sequential change-point detection based on the retrospective CUSUM
statistic, <em>Electronic Journal of Statistics</em> <b>15:1</b>, pages
2288-2335, <a href="https://doi.org/10.1214/21-EJS1840">doi:10.1214/21-EJS1840</a>.
</p>
<p>D.N. Politis and H. White (2004), Automatic block-length selection for the
dependent bootstrap, <em>Econometric Reviews</em> <b>23(1)</b>, pages 53-70.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+cpMean">cpMean</a>()</code> for the corresponding a posteriori
(offline) test and <code><a href="#topic+detOpenEndCpDist">detOpenEndCpDist</a>()</code> for the corresponding test for
changes in the distribution function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example of open-end monitoring
m &lt;- 100 # size of the learning sample

## The learning sample
set.seed(123)
x.learn &lt;- rnorm(m)

## New observations with a change in mean
## to simulate monitoring for the period m+1, ..., n
n &lt;- 5000
k &lt;- 2500 ## the true change-point
x &lt;- c(rnorm(k-m), rnorm(n-k, mean = 0.2))

## Step 1: Compute the detector
det &lt;- detOpenEndCpMean(x.learn = x.learn, x = x)

## Step 2: Monitoring with the default detector
m1 &lt;- monOpenEndCpMean(det)
str(m1)

## Monitoring with another detector
m2 &lt;- monOpenEndCpMean(det, statistic = "s", gamma = 0.85)
str(m2)

## End(Not run)
</code></pre>

<hr>
<h2 id='stDistAutocop'>Combined Test of Stationarity for Univariate Continuous Time Series Sensitive
to Changes in the Distribution Function and the Autocopula</h2><span id='topic+stDistAutocop'></span>

<h3>Description</h3>

<p>A nonparametric test of stationarity for univariate continuous time
series resulting from a combination à la Fisher of the
change-point test sensitive to changes in the distribution function
implemented in <code><a href="#topic+cpDist">cpDist</a>()</code> and the change-point test
sensitive to changes in the autcopula implemented in
<code><a href="#topic+cpAutocop">cpAutocop</a>()</code>. Approximate p-values are obtained by
combining two <em>multiplier</em> resampling schemes. Details can be
found in the first reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stDistAutocop(x, lag = 1, b = NULL, pairwise = FALSE,
              weights = c("parzen", "bartlett"), m = 5, N = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stDistAutocop_+3A_x">x</code></td>
<td>
<p>a one-column matrix containing continuous observations.</p>
</td></tr>
<tr><td><code id="stDistAutocop_+3A_lag">lag</code></td>
<td>
<p>an integer specifying at which lag to consider the
autocopula; the autcopula is a (<code>lag+1</code>)-dimensional copula.</p>
</td></tr>
<tr><td><code id="stDistAutocop_+3A_b">b</code></td>
<td>
<p>strictly positive integer specifying the value of the
bandwidth parameter determining the serial dependence when
generating dependent multiplier sequences using the 'moving average
approach'; see Section 5 of the second reference. If set to
<code>NULL</code>, <code>b</code> will be estimated using the
function <code><a href="#topic+bOptEmpProc">bOptEmpProc</a>()</code>; see the first reference.</p>
</td></tr>
<tr><td><code id="stDistAutocop_+3A_pairwise">pairwise</code></td>
<td>
<p>a logical specifying whether the test should focus
only on the bivariate margins of the (<code>lag+1</code>)-dimensional
autocopula.</p>
</td></tr>
<tr><td><code id="stDistAutocop_+3A_weights">weights</code></td>
<td>
<p>a string specifying the kernel for creating the
weights used in the generation of dependent multiplier sequences within the
'moving average approach'; see Section 5 of the second reference.</p>
</td></tr>
<tr><td><code id="stDistAutocop_+3A_m">m</code></td>
<td>
<p>a strictly positive integer specifying the number of points of the
uniform grid on <code class="reqn">(0,1)</code> involved in the estimation of the bandwidth
parameter; see Section 5 of the second reference. </p>
</td></tr>
<tr><td><code id="stDistAutocop_+3A_n">N</code></td>
<td>
<p>number of multiplier replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The testing procedure is described in detail in the second section of
the first reference.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>htest</code> which is a list,
some of the components of which are
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>corresponding approximate p-value à Fisher.</p>
</td></tr>
<tr><td><code>component.p.values</code></td>
<td>
<p>p-values of the component tests arising in the combination.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the value of parameter <code>b</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a test for continuous univariate time series.
</p>


<h3>References</h3>

<p>A. Bücher, J.-D. Fermanian and I. Kojadinovic (2019),
Combining cumulative sum change-point detection tests for assessing
the stationarity of univariate time series, <em>Journal of Time
Series Analysis</em> <b>40</b>, pages 124-150,
<a href="https://arxiv.org/abs/1709.02673">https://arxiv.org/abs/1709.02673</a>.
</p>
<p>A. Bücher and I. Kojadinovic (2016), A dependent multiplier
bootstrap for the sequential empirical copula process under strong
mixing, <em>Bernoulli</em> <b>22:2</b>, pages 927-968,
<a href="https://arxiv.org/abs/1306.3930">https://arxiv.org/abs/1306.3930</a>.
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+cpDist">cpDist</a>()</code> and <code><a href="#topic+cpAutocop">cpAutocop</a>()</code> for the
component tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## AR1 example
n &lt;- 200
k &lt;- n/2 ## the true change-point
x &lt;- matrix(c(arima.sim(list(ar = -0.1), n = k),
              arima.sim(list(ar = 0.5), n = n - k)))
stDistAutocop(x)

## AR2 example
n &lt;- 200
k &lt;- n/2 ## the true change-point
x &lt;- matrix(c(arima.sim(list(ar = c(0,-0.1)), n = k),
              arima.sim(list(ar = c(0,0.5)), n = n - k)))
## Not run: 
stDistAutocop(x)
stDistAutocop(x, lag = 2)
## End(Not run)
stDistAutocop(x, lag = 2, pairwise = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
