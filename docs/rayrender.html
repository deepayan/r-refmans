<!DOCTYPE html><html><head><title>Help for package rayrender</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rayrender}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_object'><p>Add Object</p></a></li>
<li><a href='#add_points_polygon'><p>Add Points to Polygon</p></a></li>
<li><a href='#animate_objects'><p>Animate Objects</p></a></li>
<li><a href='#arrow'><p>Arrow Object</p></a></li>
<li><a href='#bezier_curve'><p>Bezier Curve Object</p></a></li>
<li><a href='#calculate_control_points'><p>Calculate Control Points</p></a></li>
<li><a href='#calculate_control_points_straight'><p>Calculate Control Points (straight)</p></a></li>
<li><a href='#calculate_distance_along_bezier_curve'><p>Get Distance Along Bezier Curve</p></a></li>
<li><a href='#calculate_final_path'><p>Linearize and Calculate Final Points (with constant stepsize)</p></a></li>
<li><a href='#calculate_final_twist'><p>Calculate Final Angle</p></a></li>
<li><a href='#clamp'><p>Clamp Values</p></a></li>
<li><a href='#cone'><p>Cone Object</p></a></li>
<li><a href='#convert_color'><p>Convert Color</p></a></li>
<li><a href='#cross_prod'><p>Cross product (vec)</p></a></li>
<li><a href='#csg_box'><p>CSG Box</p></a></li>
<li><a href='#csg_capsule'><p>CSG Capsule</p></a></li>
<li><a href='#csg_combine'><p>CSG Combine</p></a></li>
<li><a href='#csg_cone'><p>CSG Cone</p></a></li>
<li><a href='#csg_cylinder'><p>CSG Cylinder</p></a></li>
<li><a href='#csg_ellipsoid'><p>CSG Ellipsoid</p></a></li>
<li><a href='#csg_elongate'><p>CSG Elongate</p></a></li>
<li><a href='#csg_group'><p>CSG Group</p></a></li>
<li><a href='#csg_object'><p>Constructive Solid Geometry Object</p></a></li>
<li><a href='#csg_onion'><p>CSG Onion</p></a></li>
<li><a href='#csg_plane'><p>CSG Plane</p></a></li>
<li><a href='#csg_pyramid'><p>CSG Pyramid</p></a></li>
<li><a href='#csg_rotate'><p>CSG Rotate</p></a></li>
<li><a href='#csg_round'><p>CSG Round</p></a></li>
<li><a href='#csg_rounded_cone'><p>CSG Rounded Cone</p></a></li>
<li><a href='#csg_scale'><p>CSG Scale</p></a></li>
<li><a href='#csg_sphere'><p>CSG Sphere</p></a></li>
<li><a href='#csg_torus'><p>CSG Torus</p></a></li>
<li><a href='#csg_translate'><p>CSG Translate</p></a></li>
<li><a href='#csg_triangle'><p>CSG Triangle</p></a></li>
<li><a href='#cube'><p>Cube Object</p></a></li>
<li><a href='#cubicInOut'><p>Cubic-in-out</p></a></li>
<li><a href='#cylinder'><p>Cylinder Object</p></a></li>
<li><a href='#dielectric'><p>Dielectric (glass) Material</p></a></li>
<li><a href='#diffuse'><p>Diffuse Material</p></a></li>
<li><a href='#disk'><p>Disk Object</p></a></li>
<li><a href='#ellipsoid'><p>Ellipsoid Object</p></a></li>
<li><a href='#eval_bezier'><p>Evaluate Bezier</p></a></li>
<li><a href='#eval_bezier_2nd_deriv'><p>Evaluate Deriv Bezier</p></a></li>
<li><a href='#eval_bezier_deriv'><p>Evaluate Deriv Bezier</p></a></li>
<li><a href='#expInOut'><p>Cubic-in-out</p></a></li>
<li><a href='#extruded_path'><p>Extruded Path Object</p></a></li>
<li><a href='#extruded_polygon'><p>Extruded Polygon Object</p></a></li>
<li><a href='#fliplr'><p>Flip Left-Right</p></a></li>
<li><a href='#flipud'><p>Flip Up-Down</p></a></li>
<li><a href='#generate_camera_motion'><p>Generate Camera Movement</p></a></li>
<li><a href='#generate_cornell'><p>Generate Cornell Box</p></a></li>
<li><a href='#generate_ground'><p>Generate Ground</p></a></li>
<li><a href='#generate_rotation_matrix'><p>Generate Rotation Matrix (order)</p></a></li>
<li><a href='#generate_studio'><p>Generate Studio</p></a></li>
<li><a href='#generate_translation_matrix'><p>Generate Translation Matrix</p></a></li>
<li><a href='#get_saved_keyframes'><p>Get Saved Keyframes</p></a></li>
<li><a href='#get_time'><p>Get time</p></a></li>
<li><a href='#glossy'><p>Glossy Material</p></a></li>
<li><a href='#group_objects'><p>Group Objects</p></a></li>
<li><a href='#hair'><p>Hair Material</p></a></li>
<li><a href='#init_time'><p>Print time</p></a></li>
<li><a href='#is_rendering_in_knitr'><p>Determines if rendering in knitr</p></a></li>
<li><a href='#lambertian'><p>Lambertian Material (deprecated)</p></a></li>
<li><a href='#lerp'><p>Lerp</p></a></li>
<li><a href='#light'><p>Light Material</p></a></li>
<li><a href='#mesh3d_model'><p>'mesh3d' model</p></a></li>
<li><a href='#metal'><p>Metallic Material</p></a></li>
<li><a href='#microfacet'><p>Microfacet Material</p></a></li>
<li><a href='#new_tibble_row'><p>New Tibble Row</p></a></li>
<li><a href='#obj_model'><p>'obj' File Object</p></a></li>
<li><a href='#path'><p>Path Object</p></a></li>
<li><a href='#pig'><p>Pig Object</p></a></li>
<li><a href='#ply_model'><p>'ply' File Object</p></a></li>
<li><a href='#post_process_frame'><p>Post-process Frame</p></a></li>
<li><a href='#post_process_scene'><p>Post-process the scene</p></a></li>
<li><a href='#prepare_scene_list'><p>Prepare the scene list</p></a></li>
<li><a href='#print_time'><p>Print time</p></a></li>
<li><a href='#process_point_series'><p>Process Points to Control Points</p></a></li>
<li><a href='#process_point_series_1d'><p>Process Points to Control Points</p></a></li>
<li><a href='#process_point_series_2d'><p>Process Points to Control Points</p></a></li>
<li><a href='#quadInOut'><p>Quad-in-out</p></a></li>
<li><a href='#r_obj'><p>R 3D Model</p></a></li>
<li><a href='#ray_animated_transform'><p>Internal vctrs methods</p></a></li>
<li><a href='#ray_material'><p>Internal vctrs methods</p></a></li>
<li><a href='#ray_scene'><p>Constructor for ray_material</p></a></li>
<li><a href='#ray_shape_info'><p>Internal vctrs methods</p></a></li>
<li><a href='#ray_transform'><p>Internal vctrs methods</p></a></li>
<li><a href='#raymesh_model'><p>'raymesh' model</p></a></li>
<li><a href='#render_animation'><p>Render Animation</p></a></li>
<li><a href='#render_ao'><p>Render Ambient Occlusion</p></a></li>
<li><a href='#render_preview'><p>Render Preview</p></a></li>
<li><a href='#render_scene'><p>Render Scene</p></a></li>
<li><a href='#RotateAxis'><p>Generate Rotation Matrix Axis</p></a></li>
<li><a href='#RotateX'><p>Generate Rotation Matrix X</p></a></li>
<li><a href='#RotateY'><p>Generate Rotation Matrix Y</p></a></li>
<li><a href='#RotateZ'><p>Generate Rotation Matrix Z</p></a></li>
<li><a href='#run_documentation'><p>Run Documentation</p></a></li>
<li><a href='#save_png'><p>Save PNG</p></a></li>
<li><a href='#segment'><p>Segment Object</p></a></li>
<li><a href='#slerp'><p>Slerp</p></a></li>
<li><a href='#sphere'><p>Sphere Object</p></a></li>
<li><a href='#text3d'><p>Text Object</p></a></li>
<li><a href='#triangle'><p>Triangle Object</p></a></li>
<li><a href='#tween'><p>Tween</p></a></li>
<li><a href='#xy_rect'><p>Rectangular XY Plane Object</p></a></li>
<li><a href='#xz_rect'><p>Rectangular XZ Plane Object</p></a></li>
<li><a href='#yz_rect'><p>Rectangular YZ Plane Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Build and Raytrace 3D Scenes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.32.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Morgan-Wall &lt;tylermw@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Render scenes using pathtracing. Build 3D scenes out of spheres, cubes, planes, disks, triangles, cones, curves, line segments, cylinders, ellipsoids, and 3D models in the 'Wavefront' OBJ file format or the PLY Polygon File Format. Supports several material types, textures, multicore rendering, and tone-mapping. Based on the "Ray Tracing in One Weekend" book series. Peter Shirley (2018) <a href="https://raytracing.github.io">https://raytracing.github.io</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>file inst/COPYRIGHTS</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), parallel, magrittr, png, raster, decido,
rayimage (&ge; 0.10.0), stats, progress, rayvertex (&ge; 0.10.4),
withr, vctrs, cli, pillar</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sf, spData, dplyr, Rvcg, testthat (&ge; 3.0.0), tibble</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppThread, progress, spacefillr (&ge; 0.3.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rayrender.net">https://www.rayrender.net</a>,
<a href="https://github.com/tylermorganwall/rayrender">https://github.com/tylermorganwall/rayrender</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-20 01:34:39 UTC; tyler</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Morgan-Wall <a href="https://orcid.org/0000-0002-3131-3814"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre],
  Syoyo Fujita [ctb, cph],
  Melissa O'Neill [ctb, cph],
  Vilya Harvey [ctb, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-20 05:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_object'>Add Object</h2><span id='topic+add_object'></span>

<h3>Description</h3>

<p>Add Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_object(scene, objects = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_object_+3A_scene">scene</code></td>
<td>
<p>Tibble of pre-existing object locations and properties.</p>
</td></tr>
<tr><td><code id="add_object_+3A_objects">objects</code></td>
<td>
<p>A tibble row or collection of rows representing each object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of object locations and properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate the ground and add some objects
scene = generate_ground(depth=-0.5,material = diffuse(checkercolor="blue")) %&gt;%
  add_object(cube(x=0.7,
                  material=diffuse(noise=5,noisecolor="purple",color="black",noisephase=45),
                  angle=c(0,-30,0))) %&gt;%
  add_object(sphere(x=-0.7,radius=0.5,material=metal(color="gold")))
if(run_documentation()) {
render_scene(scene,parallel=TRUE)
}
</code></pre>

<hr>
<h2 id='add_points_polygon'>Add Points to Polygon</h2><span id='topic+add_points_polygon'></span>

<h3>Description</h3>

<p>Add Points to Polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_points_polygon(polygon, added_points = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_points_polygon_+3A_polygon">polygon</code></td>
<td>
<p>Polygon</p>
</td></tr>
<tr><td><code id="add_points_polygon_+3A_added_points">added_points</code></td>
<td>
<p>Default '0'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='animate_objects'>Animate Objects</h2><span id='topic+animate_objects'></span>

<h3>Description</h3>

<p>This function animates an object between two states. This animates objects separately from the transformations set
in 'group_objects()' and in the object transformations themselves. This creates motion blur, controlled by the shutter
open/close options in 'render_scene()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate_objects(
  scene,
  start_time = 0,
  end_time = 1,
  start_pivot_point = c(0, 0, 0),
  start_position = c(0, 0, 0),
  start_angle = c(0, 0, 0),
  start_order_rotation = c(1, 2, 3),
  start_scale = c(1, 1, 1),
  start_axis_rotation = NA,
  end_pivot_point = c(0, 0, 0),
  end_position = c(0, 0, 0),
  end_angle = c(0, 0, 0),
  end_order_rotation = c(1, 2, 3),
  end_scale = c(1, 1, 1),
  end_axis_rotation = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animate_objects_+3A_scene">scene</code></td>
<td>
<p>Tibble of pre-existing object locations.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_start_time">start_time</code></td>
<td>
<p>Default '0'. Start time of movement.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_end_time">end_time</code></td>
<td>
<p>Default '1'. End time of movement.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_start_pivot_point">start_pivot_point</code></td>
<td>
<p>Default 'c(0,0,0)'. The point about which to pivot, scale, and move the objects.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_start_position">start_position</code></td>
<td>
<p>Default 'c(0,0,0)'. Vector indicating where to offset the objects.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_start_angle">start_angle</code></td>
<td>
<p>Default 'c(0,0,0)'. Angle of rotation around the x, y, and z axes, 
applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_start_order_rotation">start_order_rotation</code></td>
<td>
<p>Default 'c(1,2,3)'. The order to apply the rotations, 
referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_start_scale">start_scale</code></td>
<td>
<p>Default 'c(1,1,1)'. Scaling factor for x, y, and z directions for all objects.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_start_axis_rotation">start_axis_rotation</code></td>
<td>
<p>Default 'NA'. Provide an axis of rotation and a single angle (via 'angle') of rotation</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_end_pivot_point">end_pivot_point</code></td>
<td>
<p>Default 'c(0,0,0)'. The point about which to pivot, scale, and move the group.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_end_position">end_position</code></td>
<td>
<p>Default 'c(0,0,0)'. Vector indicating where to offset the objects.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_end_angle">end_angle</code></td>
<td>
<p>Default 'c(0,0,0)'. Angle of rotation around the x, y, and z axes, 
applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_end_order_rotation">end_order_rotation</code></td>
<td>
<p>Default 'c(1,2,3)'. The order to apply the rotations, 
referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_end_scale">end_scale</code></td>
<td>
<p>Default 'c(1,1,1)'. Scaling factor for x, y, and z directions for all objects.</p>
</td></tr>
<tr><td><code id="animate_objects_+3A_end_axis_rotation">end_axis_rotation</code></td>
<td>
<p>Default 'NA'. Provide an axis of rotation and a single angle (via 'angle') of rotation
around that axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of animated object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Render a pig
if(run_documentation()) {
generate_studio() %&gt;% 
  add_object(pig(y=-1.2,scale=0.5,angle=c(0,-70,0)))%&gt;% 
  add_object(sphere(y=5,x=5,z=5,radius=2,material=light())) %&gt;% 
  render_scene(samples=128,sample_method = "sobol_blue")
}
if(run_documentation()) {
#Render a moving pig
generate_studio() %&gt;% 
  add_object(
    animate_objects(
      pig(y=-1.2,scale=0.5,angle=c(0,-70,0)),
      start_position = c(-0.1,0,0), end_position = c(0.1,0.2,0))
  ) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,radius=2,material=light())) %&gt;% 
  render_scene(samples=128,sample_method = "sobol_blue",clamp_value = 10)
}
if(run_documentation()) {

#Render a shrinking pig
generate_studio() %&gt;% 
  add_object(
    animate_objects(
      pig(y=-1.2,scale=0.5,angle=c(0,-70,0)),
      start_scale = c(1,1,1), end_scale = c(0.5,0.5,0.5))
  ) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,radius=2,material=light())) %&gt;% 
  render_scene(samples=128,sample_method = "sobol_blue",clamp_value = 10)
}
if(run_documentation()) {
#Render a spinning pig
generate_studio() %&gt;% 
  add_object(
    animate_objects(
      pig(y=-1.2,scale=0.5,angle=c(0,-70,0)),
      start_angle = c(0,-30,0), end_angle = c(0,30,0))
  ) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,radius=2,material=light())) %&gt;% 
  render_scene(samples=128,sample_method = "sobol_blue",clamp_value = 10)
}
if(run_documentation()) {

#Shorten the open shutter time frame
generate_studio() %&gt;% 
  add_object(
    animate_objects(
      pig(y=-1.2,scale=0.5,angle=c(0,-70,0)),
      start_angle = c(0,-30,0), end_angle = c(0,30,0))
  ) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,radius=2,material=light())) %&gt;% 
  render_scene(samples=128,sample_method = "sobol_blue",clamp_value = 10, 
               shutteropen=0.4, shutterclose = 0.6)
}
if(run_documentation()) {
#Change the time frame when the shutter is open
generate_studio() %&gt;% 
  add_object(
    animate_objects(
      pig(y=-1.2,scale=0.5,angle=c(0,-70,0)),
      start_angle = c(0,-30,0), end_angle = c(0,30,0))
  ) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,radius=2,material=light())) %&gt;% 
  render_scene(samples=128,sample_method = "sobol_blue",clamp_value = 10, 
               shutteropen=0, shutterclose = 0.1)
}
if(run_documentation()) {    
#Shorten the time span in which the movement occurs (which, in effect, 
#increases the speed of the transition).
generate_studio() %&gt;% 
  add_object(
    animate_objects(start_time = 0, end_time=0.1,
      pig(y=-1.2,scale=0.5,angle=c(0,-70,0)),
      start_angle = c(0,-30,0), end_angle = c(0,30,0))
  ) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,radius=2,material=light())) %&gt;% 
  render_scene(samples=128,sample_method = "sobol_blue",clamp_value = 10, 
               shutteropen=0, shutterclose = 0.1)
}
</code></pre>

<hr>
<h2 id='arrow'>Arrow Object</h2><span id='topic+arrow'></span>

<h3>Description</h3>

<p>Composite object (cone + segment)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrow(
  start = c(0, 0, 0),
  end = c(0, 1, 0),
  radius_top = 0.2,
  radius_tail = 0.1,
  tail_proportion = 0.5,
  direction = NA,
  from_center = TRUE,
  material = diffuse(),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrow_+3A_start">start</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Base of the arrow, specifying 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="arrow_+3A_end">end</code></td>
<td>
<p>Default 'c(0, 1, 0)'. Tip of the arrow, specifying 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="arrow_+3A_radius_top">radius_top</code></td>
<td>
<p>Default '0.5'. Radius of the top of the arrow.</p>
</td></tr>
<tr><td><code id="arrow_+3A_radius_tail">radius_tail</code></td>
<td>
<p>Default '0.2'.  Radius of the tail of the arrow.</p>
</td></tr>
<tr><td><code id="arrow_+3A_tail_proportion">tail_proportion</code></td>
<td>
<p>Default '0.5'. Proportion of the arrow that is the tail.</p>
</td></tr>
<tr><td><code id="arrow_+3A_direction">direction</code></td>
<td>
<p>Default 'NA'. Alternative to 'start' and 'end', specify the direction (via 
a length-3 vector) of the arrow. Arrow will be centered at 'start', and the length will be
determined by the magnitude of the direction vector.</p>
</td></tr>
<tr><td><code id="arrow_+3A_from_center">from_center</code></td>
<td>
<p>Default 'TRUE'. If orientation specified via 'direction', setting this argument
to 'FALSE' will make 'start' specify the bottom of the cone, instead of the middle.</p>
</td></tr>
<tr><td><code id="arrow_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="arrow_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="arrow_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly. Notes: this will change the stated start/end position of the cone. 
Emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the cone in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Draw a simple arrow from x = -1 to x = 1
if(run_documentation()) {
generate_studio() %&gt;% 
  add_object(arrow(start = c(-1,0,0), end = c(1,0,0), material=glossy(color="red"))) %&gt;% 
  add_object(sphere(y=5,material=light(intensity=20))) %&gt;% 
  render_scene(clamp_value=10,  samples=128)
}
if(run_documentation()) {
#Change the proportion of tail to top
generate_studio(depth=-2) %&gt;% 
  add_object(arrow(start = c(-1,-1,0), end = c(1,-1,0), tail_proportion = 0.5,
                   material=glossy(color="red"))) %&gt;% 
  add_object(arrow(start = c(-1,0,0), end = c(1,0,0), tail_proportion = 0.75,
                   material=glossy(color="red"))) %&gt;% 
  add_object(arrow(start = c(-1,1,0), end = c(1,1,0), tail_proportion = 0.9,
                   material=glossy(color="red"))) %&gt;% 
  add_object(sphere(y=5,z=5,x=2,material=light(intensity=30))) %&gt;% 
  render_scene(clamp_value=10, fov=25,  samples=128)
}
if(run_documentation()) {
#Change the radius of the tail/top segments
generate_studio(depth=-1.5) %&gt;% 
  add_object(arrow(start = c(-1,-1,0), end = c(1,-1,0), tail_proportion = 0.75,
                   radius_top = 0.1, radius_tail=0.03,
                   material=glossy(color="red"))) %&gt;% 
  add_object(arrow(start = c(-1,0,0), end = c(1,0,0), tail_proportion = 0.75,
                   radius_top = 0.2, radius_tail=0.1,
                   material=glossy(color="red"))) %&gt;% 
  add_object(arrow(start = c(-1,1,0), end = c(1,1,0), tail_proportion = 0.75,
                   radius_top = 0.3, radius_tail=0.2,
                   material=glossy(color="red"))) %&gt;% 
  add_object(sphere(y=5,z=5,x=2,material=light(intensity=30))) %&gt;% 
  render_scene(clamp_value=10, samples=128)
}
if(run_documentation()) {
#We can also specify arrows via a midpoint and direction:
generate_studio(depth=-1) %&gt;% 
  add_object(arrow(start = c(-1,-0.5,0), direction = c(0,0,1),
                   material=glossy(color="green"))) %&gt;% 
  add_object(arrow(start = c(1,-0.5,0), direction = c(0,0,-1),
                   material=glossy(color="red"))) %&gt;% 
  add_object(arrow(start = c(0,-0.5,1), direction = c(1,0,0),
                   material=glossy(color="yellow"))) %&gt;% 
  add_object(arrow(start = c(0,-0.5,-1), direction = c(-1,0,0),
                   material=glossy(color="purple"))) %&gt;% 
  add_object(sphere(y=5,z=5,x=2,material=light(intensity=30))) %&gt;% 
  render_scene(clamp_value=10, samples=128, 
               lookfrom=c(0,5,10), lookat=c(0,-0.5,0), fov=16)
}
if(run_documentation()) {
#Plot a 3D vector field for a gravitational well:

r = 1.5
theta_vals = seq(0,2*pi,length.out = 16)[-16]
phi_vals = seq(0,pi,length.out = 16)[-16][-1]
arrow_list = list()
counter = 1
for(theta in theta_vals) {
  for(phi in phi_vals) {
    rval = c(r*sin(phi)*cos(theta),r*cos(phi),r*sin(phi)*sin(theta)) 
    arrow_list[[counter]] = arrow(rval, direction = -1/2*rval/sqrt(sum(rval*rval))^3,
                                  tail_proportion = 0.66, radius_top=0.03, radius_tail=0.01,
                                  material = diffuse(color="red"))
    counter = counter + 1
  }
}
vector_field = do.call(rbind,arrow_list)
sphere(material=diffuse(noise=1,color="blue",noisecolor="darkgreen")) %&gt;% 
  add_object(vector_field) %&gt;% 
  add_object(sphere(y=0,x=10,z=5,material=light(intensity=200))) %&gt;% 
  render_scene(fov=20, ambient=TRUE, samples=128,
               backgroundlow="black",backgroundhigh="white") 
}
</code></pre>

<hr>
<h2 id='bezier_curve'>Bezier Curve Object</h2><span id='topic+bezier_curve'></span>

<h3>Description</h3>

<p>Bezier curve, defined by 4 control points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bezier_curve(
  p1 = c(0, 0, 0),
  p2 = c(-1, 0.33, 0),
  p3 = c(1, 0.66, 0),
  p4 = c(0, 1, 0),
  x = 0,
  y = 0,
  z = 0,
  width = 0.1,
  width_end = NA,
  u_min = 0,
  u_max = 1,
  type = "cylinder",
  normal = c(0, 0, -1),
  normal_end = NA,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bezier_curve_+3A_p1">p1</code></td>
<td>
<p>Default 'c(0,0,0)'. First control point. Can also be a list of 4 length-3 numeric vectors 
or 4x3 matrix/data.frame specifying the x/y/z control points.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_p2">p2</code></td>
<td>
<p>Default 'c(-1,0.33,0)'. Second control point.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_p3">p3</code></td>
<td>
<p>Default 'c(1,0.66,0)'. Third control point.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_p4">p4</code></td>
<td>
<p>Default 'c(0,1,0)'. Fourth control point.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate offset for the curve.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate offset for the curve.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate offset for the curve.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_width">width</code></td>
<td>
<p>Default '0.1'. Curve width.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_width_end">width_end</code></td>
<td>
<p>Default 'NA'. Width at end of path. Same as 'width', unless specified.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_u_min">u_min</code></td>
<td>
<p>Default '0'. Minimum parametric coordinate for the curve.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_u_max">u_max</code></td>
<td>
<p>Default '1'. Maximum parametric coordinate for the curve.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_type">type</code></td>
<td>
<p>Default 'cylinder'. Other options are 'flat' and 'ribbon'.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_normal">normal</code></td>
<td>
<p>Default 'c(0,0,-1)'. Orientation surface normal for the start of ribbon curves.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_normal_end">normal_end</code></td>
<td>
<p>Default 'NA'. Orientation surface normal for the start of ribbon curves. If not
specified, same as 'normal'.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="bezier_curve_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the cube in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate the default curve:
if(run_documentation()) {
generate_studio(depth=-0.2) %&gt;%
  add_object(bezier_curve(material=diffuse(color="red"))) %&gt;%
  add_object(sphere(y=3,z=5,x=2,radius=0.3,
                    material=light(intensity=200, spotlight_focus = c(0,0.5,0)))) %&gt;%
  render_scene(clamp_value = 10, lookat = c(0,0.5,0), fov=13,
               samples=128)
}

if(run_documentation()) {
#Change the control points to change the direction of the curve. Here, we place spheres
#at the control point locations.
generate_studio(depth=-0.2) %&gt;%
  add_object(bezier_curve(material=diffuse(color="red"))) %&gt;%
  add_object(sphere(radius=0.075,material=glossy(color="green"))) %&gt;% 
  add_object(sphere(radius=0.075,x=-1,y=0.33,material=glossy(color="green"))) %&gt;% 
  add_object(sphere(radius=0.075,x=1,y=0.66,material=glossy(color="green"))) %&gt;% 
  add_object(sphere(radius=0.075,y=1,material=glossy(color="green"))) %&gt;% 
  add_object(sphere(y=3,z=5,x=2,radius=0.3,
                    material=light(intensity=200, spotlight_focus = c(0,0.5,0)))) %&gt;%
  render_scene(clamp_value = 10, lookat = c(0,0.5,0), fov=15,
               samples=128)
}
if(run_documentation()) {
#We can make the curve flat (always facing the camera) by setting the type to `flat`
generate_studio(depth=-0.2) %&gt;%
  add_object(bezier_curve(type="flat", material=glossy(color="red"))) %&gt;%
  add_object(sphere(y=3,z=5,x=2,radius=0.3,
                    material=light(intensity=200, spotlight_focus = c(0,0.5,0)))) %&gt;%
  render_scene(clamp_value = 10, lookat = c(0,0.5,0), fov=13,
               samples=128)
}
if(run_documentation()) {
#We can also plot a ribbon, which is further specified by a start and end orientation with
#two surface normals.
generate_studio(depth=-0.2) %&gt;%
  add_object(bezier_curve(type="ribbon", width=0.2,
                   p1 = c(0,0,0), p2 = c(0,0.33,0), p3 = c(0,0.66,0), p4 = c(0.3,1,0),
                   normal_end = c(0,0,1),
                   material=glossy(color="red"))) %&gt;%
  add_object(sphere(y=3,z=5,x=2,radius=0.3,
                    material=light(intensity=200, spotlight_focus = c(0,0.5,0)))) %&gt;%
  render_scene(clamp_value = 10, lookat = c(0,0.5,0), fov=13,
               samples=128)
}
if(run_documentation()) {
#Create a single curve and copy and rotate it around the y-axis to create a wavy fountain effect:
scene_curves = list()
for(i in 1:90) {
  scene_curves[[i]] = bezier_curve(p1 = c(0,0,0),p2 = c(0,5-sinpi(i*16/180),2),
                            p3 = c(0,5-0.5 * sinpi(i*16/180),4),p4 = c(0,0,6),
                            angle=c(0,i*4,0), type="cylinder",
                            width = 0.1, width_end =0.1,material=glossy(color="red"))
}
all_curves = do.call(rbind, scene_curves)
generate_ground(depth=0,material=diffuse(checkercolor="grey20")) %&gt;%
  add_object(all_curves) %&gt;%
  add_object(sphere(y=7,z=0,x=0,material=light(intensity=100))) %&gt;% 
  render_scene(lookfrom = c(12,20,50),samples=100,
               lookat=c(0,1,0), fov=15, clamp_value = 10)

}
</code></pre>

<hr>
<h2 id='calculate_control_points'>Calculate Control Points</h2><span id='topic+calculate_control_points'></span>

<h3>Description</h3>

<p>Calculate Control Points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_control_points(s_mat)
</code></pre>

<hr>
<h2 id='calculate_control_points_straight'>Calculate Control Points (straight)</h2><span id='topic+calculate_control_points_straight'></span>

<h3>Description</h3>

<p>Calculate Control Points (straight)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_control_points_straight(s_mat)
</code></pre>

<hr>
<h2 id='calculate_distance_along_bezier_curve'>Get Distance Along Bezier Curve</h2><span id='topic+calculate_distance_along_bezier_curve'></span>

<h3>Description</h3>

<p>Get Distance Along Bezier Curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_distance_along_bezier_curve(cps, breaks = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_distance_along_bezier_curve_+3A_cps">cps</code></td>
<td>
<p>Control points</p>
</td></tr>
<tr><td><code id="calculate_distance_along_bezier_curve_+3A_breaks">breaks</code></td>
<td>
<p>Number of interpolation breaks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of points along curve, along with distances
</p>

<hr>
<h2 id='calculate_final_path'>Linearize and Calculate Final Points (with constant stepsize)</h2><span id='topic+calculate_final_path'></span>

<h3>Description</h3>

<p>Linearize and Calculate Final Points (with constant stepsize)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_final_path(
  linearized_cp,
  steps,
  constant_step = TRUE,
  curvature_adjust = FALSE,
  curvature_scale = 1,
  offset = 0,
  progress = FALSE,
  string = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_final_path_+3A_linearized_cp">linearized_cp</code></td>
<td>
<p>Matrix (4x3)</p>
</td></tr>
<tr><td><code id="calculate_final_path_+3A_steps">steps</code></td>
<td>
<p>Number of steps</p>
</td></tr>
<tr><td><code id="calculate_final_path_+3A_constant_step">constant_step</code></td>
<td>
<p>Whether to step at constant steps or not</p>
</td></tr>
<tr><td><code id="calculate_final_path_+3A_offset">offset</code></td>
<td>
<p>Offset along curve</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of points along curve
</p>

<hr>
<h2 id='calculate_final_twist'>Calculate Final Angle</h2><span id='topic+calculate_final_twist'></span>

<h3>Description</h3>

<p>Calculate Final Angle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_final_twist(full_control_points, breaks, t_vals, t_vec, s_vec, r_vec)
</code></pre>

<hr>
<h2 id='clamp'>Clamp Values</h2><span id='topic+clamp'></span>

<h3>Description</h3>

<p>Clamp Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clamp(v, min = 0, max = Inf)
</code></pre>

<hr>
<h2 id='cone'>Cone Object</h2><span id='topic+cone'></span>

<h3>Description</h3>

<p>Cone Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cone(
  start = c(0, 0, 0),
  end = c(0, 1, 0),
  radius = 0.5,
  direction = NA,
  from_center = TRUE,
  material = diffuse(),
  angle = c(0, 0, 0),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cone_+3A_start">start</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Base of the cone, specifying 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="cone_+3A_end">end</code></td>
<td>
<p>Default 'c(0, 1, 0)'. Tip of the cone, specifying 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="cone_+3A_radius">radius</code></td>
<td>
<p>Default '1'. Radius of the bottom of the cone.</p>
</td></tr>
<tr><td><code id="cone_+3A_direction">direction</code></td>
<td>
<p>Default 'NA'. Alternative to 'start' and 'end', specify the direction (via 
a length-3 vector) of the cone. Cone will be centered at 'start', and the length will be
determined by the magnitude of the direction vector.</p>
</td></tr>
<tr><td><code id="cone_+3A_from_center">from_center</code></td>
<td>
<p>Default 'TRUE'. If orientation specified via 'direction', setting this argument
to 'FALSE' will make 'start' specify the bottom of the cone, instead of the middle.</p>
</td></tr>
<tr><td><code id="cone_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="cone_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Rotation angle. Note: This will change the 'start' and 'end' coordinates.</p>
</td></tr>
<tr><td><code id="cone_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="cone_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly. Notes: this will change the stated start/end position of the cone. 
Emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the cone in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a cone in a studio, pointing upwards:
if(run_documentation()) {
generate_studio() %&gt;% 
 add_object(cone(start=c(0,-1,0), end=c(0,1,0), radius=1,material=diffuse(color="red"))) %&gt;% 
 add_object(sphere(y=5,x=5,material=light(intensity=40))) %&gt;% 
 render_scene(samples=128,clamp_value=10)
}
if(run_documentation()) {
 #Change the radius, length, and direction
generate_studio() %&gt;% 
 add_object(cone(start=c(0,0,0), end=c(0,-1,0), radius=0.5,material=diffuse(color="red"))) %&gt;% 
 add_object(sphere(y=5,x=5,material=light(intensity=40))) %&gt;% 
 render_scene(samples=128,clamp_value=10)
}
if(run_documentation()) {
#Give custom start and end points (and customize the color/texture)
generate_studio() %&gt;% 
 add_object(cone(start=c(-1,0.5,-1), end=c(0,0,0), radius=0.5,material=diffuse(color="red"))) %&gt;%
 add_object(cone(start=c(1,0.5,-1), end=c(0,0,0), radius=0.5,material=diffuse(color="green"))) %&gt;%
 add_object(cone(start=c(0,1,-1), end=c(0,0,0), radius=0.5,material=diffuse(color="orange"))) %&gt;% 
 add_object(cone(start=c(-1,-0.5,0), end=c(1,-0.5,0), radius=0.25,
   material = diffuse(color="red",gradient_color="green"))) %&gt;% 
 add_object(sphere(y=5,x=5,material=light(intensity=40))) %&gt;% 
 render_scene(samples=128,clamp_value=10)
}
if(run_documentation()) {  
#Specify cone via direction and location, instead of start and end positions
#Length is derived from the magnitude of the direction.
gold_mat = microfacet(roughness=0.1,eta=c(0.216,0.42833,1.3184), kappa=c(3.239,2.4599,1.8661))
generate_studio() %&gt;% 
  add_object(cone(start = c(-1,0,0), direction = c(-0.5,0.5,0), material = gold_mat)) %&gt;% 
  add_object(cone(start = c(1,0,0), direction = c(0.5,0.5,0), material = gold_mat)) %&gt;% 
  add_object(cone(start = c(0,0,-1), direction = c(0,0.5,-0.5), material = gold_mat)) %&gt;% 
  add_object(cone(start = c(0,0,1), direction = c(0,0.5,0.5), material = gold_mat)) %&gt;% 
  add_object(sphere(y=5,material=light())) %&gt;% 
  add_object(sphere(y=3,x=-3,z=-3,material=light(color="red"))) %&gt;% 
  add_object(sphere(y=3,x=3,z=-3,material=light(color="green"))) %&gt;% 
  render_scene(lookfrom=c(0,4,10), clamp_value=10, samples=128)
}
if(run_documentation()) {
 #Render the position from the base, instead of the center of the cone:
 noise_mat = material = glossy(color="purple",noisecolor="blue", noise=5)
 generate_studio() %&gt;% 
  add_object(cone(start = c(0,-1,0), from_center = FALSE, radius=1, direction = c(0,2,0), 
    material = noise_mat)) %&gt;% 
  add_object(cone(start = c(-1.5,-1,0), from_center = FALSE, radius=0.5, direction = c(0,1,0), 
    material = noise_mat)) %&gt;% 
  add_object(cone(start = c(1.5,-1,0), from_center = FALSE, radius=0.5, direction = c(0,1,0), 
    material = noise_mat)) %&gt;% 
  add_object(cone(start = c(0,-1,1.5), from_center = FALSE, radius=0.5, direction = c(0,1,0), 
    material = noise_mat)) %&gt;% 
  add_object(sphere(y=5,x=5,material=light(intensity=40))) %&gt;% 
  render_scene(lookfrom=c(0,4,10), clamp_value=10,fov=25, samples=128)
}
</code></pre>

<hr>
<h2 id='convert_color'>Convert Color</h2><span id='topic+convert_color'></span>

<h3>Description</h3>

<p>Convert Color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_color(color, as_hex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_color_+3A_color">color</code></td>
<td>
<p>The color to convert. Can be either a hexadecimal code, or a numeric rgb 
vector listing three intensities between '0' and '1'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Color vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#none
</code></pre>

<hr>
<h2 id='cross_prod'>Cross product (vec)</h2><span id='topic+cross_prod'></span>

<h3>Description</h3>

<p>Cross product (vec)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_prod(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_prod_+3A_x">x</code></td>
<td>
<p>vec1</p>
</td></tr>
<tr><td><code id="cross_prod_+3A_y">y</code></td>
<td>
<p>vec2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D Numeric value for vector in space
</p>

<hr>
<h2 id='csg_box'>CSG Box</h2><span id='topic+csg_box'></span>

<h3>Description</h3>

<p>CSG Box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_box(x = 0, y = 0, z = 0, width = c(1, 1, 1), corner_radius = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_box_+3A_x">x</code></td>
<td>
<p>Default '0'. An x-coordinate on the box.</p>
</td></tr>
<tr><td><code id="csg_box_+3A_y">y</code></td>
<td>
<p>Default '0'. A y-coordinate on the box.</p>
</td></tr>
<tr><td><code id="csg_box_+3A_z">z</code></td>
<td>
<p>Default '0'. A z-coordinate on the box</p>
</td></tr>
<tr><td><code id="csg_box_+3A_width">width</code></td>
<td>
<p>Default 'c(1,1,1)'. Length-3 vector describing the x/y/z widths of the box</p>
</td></tr>
<tr><td><code id="csg_box_+3A_corner_radius">corner_radius</code></td>
<td>
<p>Default '0'. Radius if rounded box.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the box in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a box
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_box(), material=glossy(color="#FF69B4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=5))) %&gt;%  
  render_scene(clamp_value=10,lookfrom=c(7,3,7))
  }
if(run_documentation()) {
#Change the width
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_box(width = c(2,1,0.5)), material=glossy(color="#FF69B4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=5))) %&gt;%  
  render_scene(clamp_value=10,lookfrom=c(7,3,7))
}
if(run_documentation()) {
#Subtract two boxes to make stairs
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
    csg_box(),
    csg_box(x=0.5,y=0.5,width=c(1,1,1.1)),operation="subtract"),
   material=glossy(color="#FF69B4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=5))) %&gt;%  
  render_scene(clamp_value=10,lookfrom=c(7,3,7),fov=13)
  }
</code></pre>

<hr>
<h2 id='csg_capsule'>CSG Capsule</h2><span id='topic+csg_capsule'></span>

<h3>Description</h3>

<p>CSG Capsule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_capsule(start = c(0, 0, 0), end = c(0, 1, 0), radius = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_capsule_+3A_start">start</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Start point of the capsule, specifying 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="csg_capsule_+3A_end">end</code></td>
<td>
<p>Default 'c(0, 1, 0)'. End point of the capsule, specifying 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="csg_capsule_+3A_radius">radius</code></td>
<td>
<p>Default '1'. Capsule radius.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the capsule in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a basic capsule:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_capsule(radius=0.5),material=glossy(color="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20)
  }
if(run_documentation()) {
#Change the orientation by specifying a start and end
generate_ground(material=diffuse(color="dodgerblue4",checkercolor="grey10")) %&gt;% 
  add_object(csg_object(csg_capsule(start = c(-1,0.5,-2), end = c(1,0.5,-2),
  radius=0.5),material=glossy(checkercolor="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20,
               lookat=c(0,0.5,-2),lookfrom=c(3,3,10))
 }
if(run_documentation()) {
#Show the effect of changing the radius
generate_ground(material=diffuse(color="dodgerblue4",checkercolor="grey10")) %&gt;% 
  add_object(csg_object(
    csg_combine(
    csg_capsule(start = c(-1,0.5,-2), end = c(1,0.5,-2), radius=0.5),
    csg_capsule(start = c(-0.5,1.5,-2), end = c(0.5,1.5,-2), radius=0.25)),
    material=glossy(checkercolor="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20,
               lookat=c(0,0.5,-2),lookfrom=c(-3,3,10))
   }
if(run_documentation()) {            
#Render a capsule in a Cornell box
generate_cornell() %&gt;% 
  add_object(csg_object(
    csg_capsule(start = c(555/2-100,555/2,555/2), end = c(555/2+100,555/2,555/2), radius=100),
    material=glossy(color="dodgerblue4"))) %&gt;% 
  render_scene(clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_combine'>CSG Combine</h2><span id='topic+csg_combine'></span>

<h3>Description</h3>

<p>Note: Subtract operations aren't commutative: the second object is subtracted from the first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_combine(object1, object2, operation = "union", radius = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_combine_+3A_object1">object1</code></td>
<td>
<p>First CSG object</p>
</td></tr>
<tr><td><code id="csg_combine_+3A_object2">object2</code></td>
<td>
<p>Second CSG object</p>
</td></tr>
<tr><td><code id="csg_combine_+3A_operation">operation</code></td>
<td>
<p>Default 'union'. Can be 'union', 'subtract', 'intersection', 'blend', 'subtractblend', or 'mix'.</p>
</td></tr>
<tr><td><code id="csg_combine_+3A_radius">radius</code></td>
<td>
<p>Default '0.5'. Blending radius.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the combined csg object in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Combine two spheres:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
     csg_sphere(x=-0.4,z=-0.4),
     csg_sphere(x=0.4,z=0.4), operation="union"),
  material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,fov=20,lookfrom=c(-3,5,10))
  }
if(run_documentation()) {
#Subtract one sphere from another:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
     csg_sphere(x=-0.4,z=-0.4),
     csg_sphere(x=0.4,z=0.4), operation="subtract"),
  material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,fov=20,lookfrom=c(-3,5,10))
  }
if(run_documentation()) {
#Get the intersection of two spheres:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
     csg_sphere(x=-0.4,z=-0.4),
     csg_sphere(x=0.4,z=0.4), operation="intersection"),
  material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,fov=20,lookfrom=c(-3,5,10))
  }
if(run_documentation()) {
#Get the blended union of two spheres:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
     csg_sphere(x=-0.4,z=-0.4),
     csg_sphere(x=0.4,z=0.4), operation="blend"),
  material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,fov=20,lookfrom=c(-3,5,10))
  }
if(run_documentation()) {
#Get the blended subtraction of two spheres:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
     csg_sphere(x=-0.4,z=-0.4),
     csg_sphere(x=0.4,z=0.4), operation="subtractblend"),
  material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,fov=20,lookfrom=c(-3,5,10))
  }
if(run_documentation()) {
#Change the blending radius:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
     csg_sphere(x=-0.4,z=-0.4),
     csg_sphere(x=0.4,z=0.4), operation="blend", radius=0.2),
  material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,fov=20,lookfrom=c(-3,5,10))
  }
if(run_documentation()) {
#Change the subtract blending radius:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
     csg_sphere(x=-0.4,z=-0.4),
     csg_sphere(x=0.4,z=0.4), operation="subtractblend", radius=0.2),
  material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,fov=20,lookfrom=c(-3,5,10))
  }
if(run_documentation()) {
#Get the mixture of various objects:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
     csg_sphere(),
     csg_box(), operation="mix"),
  material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(csg_object(csg_translate(csg_combine(
     csg_box(),
     csg_torus(), operation="mix"),z=-2.5),
  material=glossy(color="red"))) %&gt;%
  add_object(csg_object(csg_translate(csg_combine(
     csg_pyramid(),
     csg_box(), operation="mix"),z=2.5),
  material=glossy(color="green"))) %&gt;%
  add_object(sphere(y=10,x=-5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,fov=20,lookfrom=c(-15,10,10))
}
</code></pre>

<hr>
<h2 id='csg_cone'>CSG Cone</h2><span id='topic+csg_cone'></span>

<h3>Description</h3>

<p>CSG Cone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_cone(start = c(0, 0, 0), end = c(0, 1, 0), radius = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_cone_+3A_start">start</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Start point of the cone, specifing 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="csg_cone_+3A_end">end</code></td>
<td>
<p>Default 'c(0, 1, 0)'. End point of the cone, specifing 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="csg_cone_+3A_radius">radius</code></td>
<td>
<p>Default '1'. Radius of the bottom of the cone.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the box in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a basic cone:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_cone(),material=glossy(color="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20)
  }
if(run_documentation()) {
#Change the orientation by specifying a start and end
generate_ground(material=diffuse(color="dodgerblue4",checkercolor="grey10")) %&gt;% 
  add_object(csg_object(csg_cone(start = c(-1,0.5,-2), end = c(1,0.5,-2),
  radius=0.5),material=glossy(checkercolor="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20,
               lookat=c(0,0.5,-2),lookfrom=c(3,3,10))
 }
if(run_documentation()) {
#Show the effect of changing the radius
generate_ground(material=diffuse(color="dodgerblue4",checkercolor="grey10")) %&gt;% 
  add_object(csg_object(
    csg_combine(
    csg_cone(start = c(-1,0.5,-2), end = c(1,0.5,-2), radius=0.5),
    csg_cone(start = c(-0.5,1.5,-2), end = c(0.5,1.5,-2), radius=0.2)),
    material=glossy(checkercolor="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20,
               lookat=c(0,0.5,-2),lookfrom=c(-3,3,10))
    }
if(run_documentation()) {           
#Render a glass cone in a Cornell box
generate_cornell() %&gt;% 
  add_object(csg_object(
    csg_cone(start = c(555/2,0,555/2), end = c(555/2,555/2+100,555/2), radius=100),
    material=dielectric(attenuation=c(1,1,0.3)/100))) %&gt;% 
  render_scene(clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_cylinder'>CSG Cylinder</h2><span id='topic+csg_cylinder'></span>

<h3>Description</h3>

<p>CSG Cylinder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_cylinder(
  start = c(0, 0, 0),
  end = c(0, 1, 0),
  radius = 1,
  corner_radius = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_cylinder_+3A_start">start</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Start point of the cylinder, specifing 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="csg_cylinder_+3A_end">end</code></td>
<td>
<p>Default 'c(0, 1, 0)'. End point of the cylinder, specifing 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="csg_cylinder_+3A_radius">radius</code></td>
<td>
<p>Default '1'. Cylinder radius.</p>
</td></tr>
<tr><td><code id="csg_cylinder_+3A_corner_radius">corner_radius</code></td>
<td>
<p>Default '0'. Radius if rounded cylinder.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the cylinder in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a basic cylinder:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_cylinder(radius=0.25),material=glossy(color="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20)
  }
if(run_documentation()) {
#Change the orientation by specifying a start and end
generate_ground(material=diffuse(color="dodgerblue4",checkercolor="grey10")) %&gt;% 
  add_object(csg_object(csg_cylinder(start = c(-1,0.5,-2), end = c(1,0.5,-2),
    radius=0.5),material=glossy(checkercolor="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20,
               lookat=c(0,0.5,-2),lookfrom=c(3,3,10))
 }
if(run_documentation()) {
#Show the effect of changing the radius
generate_ground(material=diffuse(color="dodgerblue4",checkercolor="grey10")) %&gt;% 
  add_object(csg_object(
    csg_combine(
    csg_cylinder(start = c(-1,0.5,-2), end = c(1,0.5,-2), radius=0.5),
    csg_cylinder(start = c(-0.5,1.5,-2), end = c(0.5,1.5,-2), radius=0.25)),
    material=glossy(checkercolor="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20,
               lookat=c(0,0.5,-2),lookfrom=c(-3,3,10))
    }
if(run_documentation()) {           
#Render a red marble cylinder in a Cornell box
generate_cornell(light=FALSE) %&gt;% 
  add_object(csg_object(
    csg_cylinder(start = c(555/2,0,555/2), end = c(555/2,350,555/2), radius=100),
    material=glossy(color="darkred",noisecolor="white",noise=0.03))) %&gt;% 
    add_object(sphere(y=555,x=5,z=5, radius=5,
               material=light(intensity=10000,
                              spotlight_focus = c(555/2,555/2,555/2),spotlight_width = 45))) %&gt;% 
  render_scene(clamp_value=4)
}
</code></pre>

<hr>
<h2 id='csg_ellipsoid'>CSG Ellipsoid</h2><span id='topic+csg_ellipsoid'></span>

<h3>Description</h3>

<p>CSG Ellipsoid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_ellipsoid(x = 0, y = 0, z = 0, axes = c(0.5, 1, 0.5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_ellipsoid_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate on the ellipsoid.</p>
</td></tr>
<tr><td><code id="csg_ellipsoid_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate on the ellipsoid.</p>
</td></tr>
<tr><td><code id="csg_ellipsoid_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate on the ellipsoid.</p>
</td></tr>
<tr><td><code id="csg_ellipsoid_+3A_axes">axes</code></td>
<td>
<p>Default 'c(0.5,1,0.5)'. Ellipsoid principle axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the ellipsoid in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a basic ellipsoid:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_ellipsoid(),material=glossy(color="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20)
  }
if(run_documentation()) {
#Three different ellipsoids:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
 add_object(csg_object(csg_group(list(
   csg_ellipsoid(x=-1.2, axes = c(0.2,0.5,0.5)),
   csg_ellipsoid(x=0, axes = c(0.5,0.2,0.5)),
   csg_ellipsoid(x=1.2, axes = c(0.5,0.5,0.2)))),
   material=glossy(color="red"))) %&gt;% 
 render_scene(clamp_value=10,fov=20,lookfrom=c(0,5,10))
 }
if(run_documentation()) {
#Generate a glass ellipsoid:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_ellipsoid(),material=dielectric(attenuation = c(1,1,0.3)))) %&gt;% 
  render_scene(clamp_value=10,fov=20)
  }
if(run_documentation()) {
#Generate a glass ellipsoid in a Cornell box:
generate_cornell() %&gt;% 
  add_object(csg_object(csg_ellipsoid(x=555/2,y=555/2,z=555/2,axes=c(100,150,200)),
    material=dielectric(attenuation = c(1,0.3,1)/200))) %&gt;% 
  render_scene(clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_elongate'>CSG Elongate</h2><span id='topic+csg_elongate'></span>

<h3>Description</h3>

<p>This operation elongates an existing CSG object in a direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_elongate(object, x = 0, y = 0, z = 0, elongate = c(0, 0, 0), robust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_elongate_+3A_object">object</code></td>
<td>
<p>CSG object.</p>
</td></tr>
<tr><td><code id="csg_elongate_+3A_x">x</code></td>
<td>
<p>Default '0'. Center of x-elongation.</p>
</td></tr>
<tr><td><code id="csg_elongate_+3A_y">y</code></td>
<td>
<p>Default '0'. Center of y-elongation.</p>
</td></tr>
<tr><td><code id="csg_elongate_+3A_z">z</code></td>
<td>
<p>Default '0'. Center of z-elongation.</p>
</td></tr>
<tr><td><code id="csg_elongate_+3A_elongate">elongate</code></td>
<td>
<p>Default 'c(0,0,0)' (no elongation). Elongation amount.</p>
</td></tr>
<tr><td><code id="csg_elongate_+3A_robust">robust</code></td>
<td>
<p>Default 'TRUE'. 'FALSE' switches to a faster (but less robust in 2D) method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the triangle in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Elongate a sphere to create a capsule in 1D or a rounded rectangle in 2D:
generate_ground(material=diffuse(checkercolor="grey20",color="dodgerblue4")) %&gt;% 
 add_object(csg_object(csg_sphere(z=-3,x=-3),
                        material=glossy(color="purple"))) %&gt;% 
 add_object(csg_object(csg_elongate(csg_sphere(z=-3,x=3),x=3,z=-3, elongate = c(0.8,0,0)),
                        material=glossy(color="red"))) %&gt;% 
 add_object(csg_object(csg_elongate(csg_sphere(z=2),z=2, elongate = c(0.8,0,0.8)),
                        material=glossy(color="white"))) %&gt;% 
 add_object(sphere(y=10,radius=3,material=light(intensity=8))) %&gt;% 
 render_scene(clamp_value=10,fov=40,lookfrom=c(0,10,10))
  }
if(run_documentation()) {
#Elongate a torus:
generate_ground(material=diffuse(checkercolor="grey20",color="dodgerblue4")) %&gt;% 
 add_object(csg_object(csg_torus(z=-3,x=-3),
                        material=glossy(color="purple"))) %&gt;% 
 add_object(csg_object(csg_elongate(csg_torus(z=-3,x=3),x=3,z=-3, elongate = c(0.8,0,0)),
                        material=glossy(color="red"))) %&gt;% 
 add_object(csg_object(csg_elongate(csg_torus(z=2),z=2, elongate = c(0.8,0,0.8)),
                        material=glossy(color="white"))) %&gt;% 
 add_object(sphere(y=10,radius=3,material=light(intensity=8))) %&gt;% 
 render_scene(clamp_value=10,fov=40,lookfrom=c(0,10,10))
 }
if(run_documentation()) {
#Elongate a cylinder:
generate_ground(material=diffuse(checkercolor="grey20",color="dodgerblue4")) %&gt;% 
 add_object(csg_object(csg_cylinder(start=c(-3,0,-3), end = c(-3,1,-3)),
                        material=glossy(color="purple"))) %&gt;% 
 add_object(csg_object(csg_elongate(csg_cylinder(start=c(3,0,-3), end = c(3,1,-3)), x=3, z=-3, 
                       elongate = c(0.8,0,0)),
                       material=glossy(color="red"))) %&gt;% 
 add_object(csg_object(csg_elongate(csg_cylinder(start=c(0,0,3), end = c(0,1,3)), z=3, 
                       elongate = c(0.8,0,0.8)),
                       material=glossy(color="white"))) %&gt;% 
 add_object(sphere(y=10,radius=3,material=light(intensity=8))) %&gt;% 
 render_scene(clamp_value=10,fov=40,lookfrom=c(0,10,10))
 }
if(run_documentation()) {
#Elongate a pyramid:
generate_ground(material=diffuse(checkercolor="grey20",color="dodgerblue4")) %&gt;% 
 add_object(csg_object(csg_pyramid(z=-3,x=-3),
                        material=glossy(color="purple"))) %&gt;% 
 add_object(csg_object(csg_elongate(csg_pyramid(z=-3,x=3),x=3,z=-3, elongate = c(0.8,0,0)),
                        material=glossy(color="red"))) %&gt;% 
 add_object(csg_object(csg_elongate(csg_pyramid(z=2),z=2, elongate = c(0.8,0,0.8)),
                        material=glossy(color="white"))) %&gt;% 
 add_object(sphere(y=10,radius=3,material=light(intensity=8))) %&gt;% 
 render_scene(clamp_value=10,fov=40,lookfrom=c(0,10,10))
}
if(run_documentation()) {
#Change the elongation point to start the elongation on the side of the pyramid:
generate_ground(material=diffuse(checkercolor="grey20",color="dodgerblue4")) %&gt;% 
 add_object(csg_object(csg_pyramid(z=-3,x=-3),
                        material=glossy(color="purple"))) %&gt;% 
 add_object(csg_object(csg_elongate(csg_pyramid(z=-3,x=3),x=2.75,z=-2.75, elongate = c(0.8,0,0)),
                        material=glossy(color="red"))) %&gt;% 
 add_object(csg_object(csg_elongate(csg_pyramid(z=2),z=2.25, elongate = c(0.8,0,0.8)),
                        material=glossy(color="white"))) %&gt;% 
 add_object(sphere(y=10,radius=3,material=light(intensity=8))) %&gt;% 
 render_scene(clamp_value=10,fov=40,
              lookfrom=c(5,5,10),lookat=c(0,0,-1.5))
}
</code></pre>

<hr>
<h2 id='csg_group'>CSG Group</h2><span id='topic+csg_group'></span>

<h3>Description</h3>

<p>CSG Group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_group(object_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_group_+3A_object_list">object_list</code></td>
<td>
<p>List of objects created with the csg_* functions. This will make all further operations
be applied to this object as a group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the group in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Group four spheres together and merge them with a box:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
  csg_group(list(csg_sphere(x=1,z=1, radius=0.5),csg_sphere(x=-1,z=1, radius=0.5),
                 csg_sphere(x=1,z=-1, radius=0.5),csg_sphere(x=-1,z=-1, radius=0.5))),
  csg_box(y=0.5, width=c(2,0.2,2)), operation="blend"), material=glossy(color="red"))) %&gt;%
  add_object(sphere(y=10,x=-5,radius=3,material=light(intensity=10))) %&gt;% 
  render_scene(clamp_value=10,lookfrom=c(5,5,10)) 
}
</code></pre>

<hr>
<h2 id='csg_object'>Constructive Solid Geometry Object</h2><span id='topic+csg_object'></span>

<h3>Description</h3>

<p>This object takes an object constructed using the 'csg_*' functions. The object is drawn using
ray marching/sphere tracing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_object(
  object,
  x = 0,
  y = 0,
  z = 0,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_object_+3A_object">object</code></td>
<td>
<p>Object created with CSG interface.</p>
</td></tr>
<tr><td><code id="csg_object_+3A_x">x</code></td>
<td>
<p>Default '0'. x-offset of the center of the object.</p>
</td></tr>
<tr><td><code id="csg_object_+3A_y">y</code></td>
<td>
<p>Default '0'. y-offset of the center of the object.</p>
</td></tr>
<tr><td><code id="csg_object_+3A_z">z</code></td>
<td>
<p>Default '0'. z-offset of the center of the object.</p>
</td></tr>
<tr><td><code id="csg_object_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>. The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="csg_object_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="csg_object_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="csg_object_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="csg_object_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: For dielectric objects, any other objects not included in the CSG object and
nested inside will be ignored.
</p>


<h3>Value</h3>

<p>Single row of a tibble describing the sphere in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#We will combine these three objects:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;%
  add_object(csg_object(csg_box(), material=glossy(color="red"))) %&gt;% 
  add_object(csg_object(csg_sphere(radius=0.707), material=glossy(color="green"))) %&gt;% 
  add_object(csg_object(csg_group(list(csg_cylinder(start=c(-1,0,0), end=c(1,0,0), radius=0.4),
                   csg_cylinder(start=c(0,-1,0), end=c(0,1,0), radius=0.4),
                   csg_cylinder(start=c(0,0,-1), end=c(0,0,1), radius=0.4))),
                   material=glossy(color="blue"))) %&gt;% 
  add_object(sphere(y=5,x=3,radius=1,material=light(intensity=30))) %&gt;%
  render_scene(clamp_value=10, fov=15,lookfrom=c(5,5,10), 
               samples=128, sample_method="sobol_blue")
}
if(run_documentation()) {
#Standard CSG sphere + box - crossed cylinder combination:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;%
  add_object(csg_object(csg_combine(
    csg_combine(
      csg_box(),
      csg_sphere(radius=0.707),
      operation="intersection"),
    csg_group(list(csg_cylinder(start=c(-1,0,0), end=c(1,0,0), radius=0.4),
                   csg_cylinder(start=c(0,-1,0), end=c(0,1,0), radius=0.4),
                   csg_cylinder(start=c(0,0,-1), end=c(0,0,1), radius=0.4))),
    operation="subtract"),
    material=glossy(color="red"))) %&gt;%
  add_object(sphere(y=5,x=3,radius=1,material=light(intensity=30))) %&gt;%
  render_scene(clamp_value=10, fov=10,lookfrom=c(5,5,10),
               samples=128, sample_method="sobol_blue")
  }
if(run_documentation()) {
#Blend them all instead:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;%
  add_object(csg_object(csg_combine(
    csg_combine(
      csg_box(),
      csg_sphere(radius=0.707),
      operation="blend"),
    csg_group(list(csg_cylinder(start=c(-1,0,0), end=c(1,0,0), radius=0.4),
                   csg_cylinder(start=c(0,-1,0), end=c(0,1,0), radius=0.4),
                   csg_cylinder(start=c(0,0,-1), end=c(0,0,1), radius=0.4))),
    operation="blend"),
    material=glossy(color="purple"))) %&gt;%
  add_object(sphere(y=5,x=3,radius=1,material=light(intensity=30))) %&gt;%
  render_scene(clamp_value=10, fov=15,lookfrom=c(5,5,10), 
               samples=128, sample_method="sobol_blue")
}
</code></pre>

<hr>
<h2 id='csg_onion'>CSG Onion</h2><span id='topic+csg_onion'></span>

<h3>Description</h3>

<p>Note: This operation has no overt effect on the external appearance of an object&ndash;it carves
regions on the interior. Thus, you will only see an effect with a transparent material or when
you carve into the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_onion(object, thickness = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_onion_+3A_object">object</code></td>
<td>
<p>CSG object.</p>
</td></tr>
<tr><td><code id="csg_onion_+3A_thickness">thickness</code></td>
<td>
<p>Default '0.1'. Onioning distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the triangle in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Cut and onion a sphere:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;%
  add_object(csg_object(csg_combine(
    csg_onion(csg_sphere(z=2,x=2,radius=1), thickness = 0.2),
    csg_box(y=1,width=c(10,2,10)), operation = "subtract"),
    material=glossy(color="red"))) %&gt;%
    add_object(csg_object(csg_combine(
      csg_onion(csg_sphere(radius=1), thickness = 0.4),
      csg_box(y=1,width=c(10,2,10)), operation = "subtract"),
      material=glossy(color="purple"))) %&gt;%
    add_object(csg_object(csg_combine(
      csg_onion(csg_sphere(z=-2.5,x=-2.5,radius=1), thickness = 0.6),
      csg_box(y=1,width=c(10,2,10)), operation = "subtract"),
      material=glossy(color="green"))) %&gt;%
 add_object(sphere(y=5,x=5,radius=2,material=light())) %&gt;% 
 render_scene(clamp_value=10,lookat=c(0,-0.5,0),
              lookfrom=c(3,5,10),fov=35)
}
if(run_documentation()) {
#Multiple onion layers:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;%
  add_object(csg_object(csg_combine(
    csg_onion(csg_onion(csg_onion(csg_sphere(radius=1), 0.4), 0.2),0.1),
    csg_box(y=1,width=c(10,2,10)), operation = "subtract"),
    material=glossy(color="purple"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=2,material=light())) %&gt;% 
  render_scene(clamp_value=10,lookat=c(0,-0.5,0),
               lookfrom=c(3,5,10),fov=20)
  }
if(run_documentation()) {
#Onion with dielectric sphere to make a bubble:
generate_cornell() %&gt;%
  add_object(csg_object(
    csg_onion(csg_sphere(x=555/2,y=555/2,z=555/2, radius=150), 5),
    material=dielectric(attenuation=c(1,1,0.3)/100))) %&gt;%
  render_scene(clamp_value=10)
  }
if(run_documentation()) {
#Multiple onion operations to make a bubble within a bubble:
generate_cornell() %&gt;%
  add_object(csg_object(
    csg_onion(csg_onion(csg_sphere(x=555/2,y=555/2,z=555/2, radius=150), 10),5),
    material=dielectric(attenuation=c(1,1,0.3)/100))) %&gt;%
  render_scene(clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_plane'>CSG Plane</h2><span id='topic+csg_plane'></span>

<h3>Description</h3>

<p>Note: This shape isn't closed, so there may be odd lighting issues if it's oriented the wrong
way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_plane(x = 0, y = 0, z = 0, normal = c(0, 1, 0), width_x = 4, width_z = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_plane_+3A_x">x</code></td>
<td>
<p>Default '0'. An x-coordinate on the plane.</p>
</td></tr>
<tr><td><code id="csg_plane_+3A_y">y</code></td>
<td>
<p>Default '0'. A y-coordinate on the plane.</p>
</td></tr>
<tr><td><code id="csg_plane_+3A_z">z</code></td>
<td>
<p>Default '0'. A z-coordinate on the plane.</p>
</td></tr>
<tr><td><code id="csg_plane_+3A_normal">normal</code></td>
<td>
<p>Default 'c(0,1,0)'. Surface normal of the plane.</p>
</td></tr>
<tr><td><code id="csg_plane_+3A_width_x">width_x</code></td>
<td>
<p>Default '10'.</p>
</td></tr>
<tr><td><code id="csg_plane_+3A_width_z">width_z</code></td>
<td>
<p>Default '10'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the plane in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a plane
csg_object(csg_plane(width_x=4, width_z=4), material=diffuse(checkercolor="purple")) %&gt;% 
  add_object(sphere(y=5,x=5,material=light(intensity=40))) %&gt;% 
  render_scene(clamp_value=10)
 }
if(run_documentation()) {
#Combine the plane with a sphere
csg_object(csg_combine(
    csg_sphere(radius=0.5),
    csg_plane(width_x=4, width_z=4,y=-0.5), 
    operation="blend"),material=diffuse(checkercolor="purple")) %&gt;% 
  add_object(sphere(y=5,x=5,material=light(intensity=40))) %&gt;% 
  render_scene(clamp_value=10)
  }
if(run_documentation()) {
#Re-orient the plane using the normal and 
csg_object(csg_combine(
    csg_sphere(radius=0.5),
    csg_plane(normal = c(1,1,0),width_x=4, width_z=4,y=-0.5), 
    operation="blend"),material=diffuse(checkercolor="purple")) %&gt;% 
  add_object(sphere(y=5,x=5,material=light(intensity=40))) %&gt;% 
  render_scene(clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_pyramid'>CSG Pyramid</h2><span id='topic+csg_pyramid'></span>

<h3>Description</h3>

<p>Note: This primitive slows down immensely for large values of base and height. Try using csg_scale()
with this object for large pyramids instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_pyramid(x = 0, y = 0, z = 0, height = 1, base = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_pyramid_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate on the pyramid.</p>
</td></tr>
<tr><td><code id="csg_pyramid_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate on the pyramid.</p>
</td></tr>
<tr><td><code id="csg_pyramid_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate on the pyramid.</p>
</td></tr>
<tr><td><code id="csg_pyramid_+3A_height">height</code></td>
<td>
<p>Default '1'. Pyramid height.</p>
</td></tr>
<tr><td><code id="csg_pyramid_+3A_base">base</code></td>
<td>
<p>Default '1'. Pyramid base width.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the box in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a simple pyramid:
generate_ground() %&gt;% 
  add_object(csg_object(csg_pyramid(y=-0.99),
                        material=glossy(color="red"))) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,material=light(intensity=20))) %&gt;% 
  render_scene(clamp_value=10,lookfrom=c(-3,1,10), 
               fov=15, lookat=c(0,-0.5,0))
}
if(run_documentation()) {
#Make a taller pyramid
generate_ground() %&gt;% 
  add_object(csg_object(csg_pyramid(y=-0.95, height=1.5),
                        material=glossy(color="red"))) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,material=light(intensity=20))) %&gt;% 
  render_scene(clamp_value=10,lookfrom=c(-3,1,10), 
               fov=15, lookat=c(0,-0.5,0))
  }
if(run_documentation()) {
#Make a wider pyramid
generate_ground() %&gt;% 
  add_object(csg_object(csg_pyramid(y=-0.95, base=1.5),
                        material=glossy(color="red"))) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,material=light(intensity=20))) %&gt;% 
  render_scene(clamp_value=10,lookfrom=c(-3,1,10), 
               fov=15, lookat=c(0,-0.5,0))
}
</code></pre>

<hr>
<h2 id='csg_rotate'>CSG Rotate</h2><span id='topic+csg_rotate'></span>

<h3>Description</h3>

<p>CSG Rotate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_rotate(
  object,
  pivot_point = c(0, 0, 0),
  angles = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  up = c(0, 1, 0),
  axis_x = NULL,
  axis_z = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_rotate_+3A_object">object</code></td>
<td>
<p>CSG object.</p>
</td></tr>
<tr><td><code id="csg_rotate_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default 'c(0,0,0)'. Pivot point for the rotation.</p>
</td></tr>
<tr><td><code id="csg_rotate_+3A_angles">angles</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="csg_rotate_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="csg_rotate_+3A_up">up</code></td>
<td>
<p>Default 'c(0,1,0). Alternative method for specifying rotation&ndash;change the new &quot;up&quot; vector.</p>
</td></tr>
<tr><td><code id="csg_rotate_+3A_axis_x">axis_x</code></td>
<td>
<p>Default 'NULL', computed automatically if not passed. Given the 'up' vector as the y-axis, this is the x vector.</p>
</td></tr>
<tr><td><code id="csg_rotate_+3A_axis_z">axis_z</code></td>
<td>
<p>Default 'NULL', computed automatically if not passed. Given the 'up' vector as the y-axis, this is the z vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the triangle in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Rotate a pyramid (translating it upwards because the object is scaled from the center):
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_pyramid(z=1,y=-0.99),
                        material=glossy(color="red"))) %&gt;% 
  add_object(csg_object(csg_rotate(csg_pyramid(z=-1.5,y=-0.99),
                        pivot_point = c(0,-0.99,-1.5),angle=c(0,45,0)),
                        material=glossy(color="green"))) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,material=light(intensity=40))) %&gt;% 
  render_scene(lookfrom=c(-3,4,10), fov=15, 
               lookat=c(0,-0.5,0),clamp_value=10)
  }
if(run_documentation()) {
#Rotate by specifying a new up vector:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_pyramid(z=1,y=-0.99),
                        material=glossy(color="red"))) %&gt;% 
  add_object(csg_object(csg_rotate(csg_pyramid(z=-1.5,y=-0.49),
                        pivot_point = c(0,-0.49,-1.5), up =c(1,1,0)),
                        material=glossy(color="green"))) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,material=light(intensity=40))) %&gt;% 
  render_scene(lookfrom=c(-3,4,10), fov=15, 
               lookat=c(0,-0.5,0),clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_round'>CSG Round</h2><span id='topic+csg_round'></span>

<h3>Description</h3>

<p>CSG Round
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_round(object, radius = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_round_+3A_object">object</code></td>
<td>
<p>CSG object.</p>
</td></tr>
<tr><td><code id="csg_round_+3A_radius">radius</code></td>
<td>
<p>Default '0.1'. Rounding distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the triangle in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a rounded pyramid:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_pyramid(x=-1,y=-0.99,z=1),
                        material=glossy(color="red"))) %&gt;% 
  add_object(csg_object(csg_round(csg_pyramid(x=1,y=-0.89)),
                        material=glossy(color="blue"))) %&gt;% 
  add_object(csg_object(csg_round(csg_pyramid(x=0,z=-2,y=-0.5), radius=0.5),
                        material=glossy(color="green"))) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,radius=1,material=light(intensity=50))) %&gt;% 
  render_scene(lookfrom=c(-3,4,10), fov=22, 
               lookat=c(0,-0.5,0),clamp_value=10)
}
if(run_documentation()) {
#Round a blend of two objects
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_round(csg_combine(
    csg_pyramid(x=-0.5,y=-0.99,z=1.5),
    csg_pyramid(x=0.5,y=-0.99,z=2), operation="blend"), radius=0),
                        material=glossy(color="red"))) %&gt;% 
  add_object(csg_object(csg_round(csg_combine(
    csg_pyramid(x=-0.5,y=-0.79,z=-1.5),
    csg_pyramid(x=0.5,y=-0.79,z=-1), operation="blend"), radius=0.2),
                        material=glossy(color="green"))) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,radius=1,material=light(intensity=50))) %&gt;% 
  render_scene(lookfrom=c(-3,5,10), fov=22, 
               lookat=c(0,-0.5,0),clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_rounded_cone'>CSG Rounded Cone</h2><span id='topic+csg_rounded_cone'></span>

<h3>Description</h3>

<p>CSG Rounded Cone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_rounded_cone(
  start = c(0, 0, 0),
  end = c(0, 1, 0),
  radius = 0.5,
  upper_radius = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_rounded_cone_+3A_start">start</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Start point of the cone, specifing 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="csg_rounded_cone_+3A_end">end</code></td>
<td>
<p>Default 'c(0, 1, 0)'. End point of the cone, specifing 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="csg_rounded_cone_+3A_radius">radius</code></td>
<td>
<p>Default '0.5'. Radius of the bottom of the cone.</p>
</td></tr>
<tr><td><code id="csg_rounded_cone_+3A_upper_radius">upper_radius</code></td>
<td>
<p>Default '0.2'. Radius from the top of the cone.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the box in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a basic rounded cone:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_rounded_cone(),material=glossy(color="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20)
  }
if(run_documentation()) {
#Change the orientation by specifying a start and end
generate_ground(material=diffuse(color="dodgerblue4",checkercolor="grey10")) %&gt;% 
  add_object(csg_object(csg_rounded_cone(start = c(-1,0.5,-2), end = c(1,0.5,-2),
  radius=0.5),material=glossy(checkercolor="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20,
               lookat=c(0,0.5,-2),lookfrom=c(3,3,10))
 }
if(run_documentation()) {
#Show the effect of changing the radius
generate_ground(material=diffuse(color="dodgerblue4",checkercolor="grey10")) %&gt;% 
  add_object(csg_object(
    csg_combine(
    csg_rounded_cone(start = c(-1,0.5,-2), end = c(1,0.5,-2), radius=0.5),
    csg_rounded_cone(start = c(-0.5,1.5,-2), end = c(0.5,1.5,-2), radius=0.2,upper_radius = 0.5)),
    material=glossy(checkercolor="red"))) %&gt;% 
  render_scene(clamp_value=10,fov=20,
               lookat=c(0,0.5,-2),lookfrom=c(-3,3,10))
}
if(run_documentation()) {         
#Render a glass rounded cone in a Cornell box
generate_cornell() %&gt;% 
  add_object(csg_object(
    csg_rounded_cone(start = c(555/2,555/2-100,555/2), end = c(555/2,555/2+100,555/2), radius=100),
    material=dielectric(attenuation=c(1,1,0.3)/100))) %&gt;% 
  render_scene(clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_scale'>CSG Scale</h2><span id='topic+csg_scale'></span>

<h3>Description</h3>

<p>CSG Scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_scale(object, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_scale_+3A_object">object</code></td>
<td>
<p>CSG object.</p>
</td></tr>
<tr><td><code id="csg_scale_+3A_scale">scale</code></td>
<td>
<p>Default '1'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the triangle in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Scale a pyramid (translating it upwards because the object is scaled from the center):
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_pyramid(z=1,y=-0.99),
                        material=glossy(color="red"))) %&gt;% 
  add_object(csg_object(csg_scale(csg_pyramid(z=-1,y=-0.5),2),
                        material=glossy(color="green"))) %&gt;% 
  add_object(sphere(y=5,x=5,z=5,material=light(intensity=40))) %&gt;% 
  render_scene(lookfrom=c(-3,4,10), fov=20, 
               lookat=c(0,-0.5,-0.5),clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_sphere'>CSG Sphere</h2><span id='topic+csg_sphere'></span>

<h3>Description</h3>

<p>CSG Sphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_sphere(x = 0, y = 0, z = 0, radius = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_sphere_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the sphere.</p>
</td></tr>
<tr><td><code id="csg_sphere_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate of the center of the sphere.</p>
</td></tr>
<tr><td><code id="csg_sphere_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the sphere.</p>
</td></tr>
<tr><td><code id="csg_sphere_+3A_radius">radius</code></td>
<td>
<p>Default '1'. Radius of the sphere.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the sphere in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a simple sphere:
generate_ground() %&gt;% 
  add_object(csg_object(csg_sphere(),
                        material=glossy(color="purple"))) %&gt;% 
  render_scene(clamp_value=10)
}
if(run_documentation()) {
#Generate a bigger sphere in the cornell box.
generate_cornell() %&gt;% 
  add_object(csg_object(csg_sphere(x=555/2,y=555/2,z=555/2,radius=100),
                        material=glossy(checkercolor="purple", checkerperiod=100))) %&gt;% 
  render_scene(clamp_value=10)
}
if(run_documentation()) {
#Combine two spheres of different sizes
generate_cornell() %&gt;% 
  add_object(csg_object(
    csg_combine(
      csg_sphere(x=555/2,y=555/2-50,z=555/2,radius=100),
      csg_sphere(x=555/2,y=555/2+50,z=555/2,radius=80)),
    material=glossy(color="purple"))) %&gt;% 
  render_scene(clamp_value=10)
}
if(run_documentation()) {
#Subtract two spheres to create an indented region
generate_cornell() %&gt;% 
  add_object(csg_object(
    csg_combine(
      csg_sphere(x=555/2,y=555/2-50,z=555/2,radius=100),
      csg_sphere(x=555/2+30,y=555/2+20,z=555/2-90,radius=40),
      operation="subtract"),
    material=glossy(color="grey20"))) %&gt;% 
  render_scene(clamp_value=10)
}
if(run_documentation()) {
#Use csg_combine(operation="blend") to melt the two together
generate_cornell() %&gt;% 
  add_object(csg_object(
    csg_combine(
      csg_sphere(x=555/2,y=555/2-50,z=555/2,radius=100),
      csg_sphere(x=555/2,y=555/2+50,z=555/2,radius=80),
      operation="blend", radius=20),
    material=glossy(color="purple"))) %&gt;% 
  render_scene(clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_torus'>CSG Torus</h2><span id='topic+csg_torus'></span>

<h3>Description</h3>

<p>CSG Torus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_torus(x = 0, y = 0, z = 0, radius = 1, minor_radius = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_torus_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate on the torus.</p>
</td></tr>
<tr><td><code id="csg_torus_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate on the torus.</p>
</td></tr>
<tr><td><code id="csg_torus_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate on the torus.</p>
</td></tr>
<tr><td><code id="csg_torus_+3A_radius">radius</code></td>
<td>
<p>Default '1'. Torus radius.</p>
</td></tr>
<tr><td><code id="csg_torus_+3A_minor_radius">minor_radius</code></td>
<td>
<p>Default '0.5'. Cross section radius of the torus.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the torus in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a torus:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_torus(), material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,lookfrom=c(0,5,10),fov=30)
}
if(run_documentation()) {
#Change the radius of the torus:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_torus(radius=2), material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,lookfrom=c(0,5,10),fov=30)
}
if(run_documentation()) {
#Change the minor radius of the torus:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_torus(radius=2, minor_radius=0.25), 
                        material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,lookfrom=c(0,5,10),fov=30)
  }
if(run_documentation()) {
#Generate a rotated torus in the Cornell Box
generate_cornell() %&gt;% 
  add_object(csg_object(csg_rotate(
    csg_torus(x=555/2,y=555/2,z=555/2,radius=100, minor_radius=50), 
    pivot_point = c(555/2,555/2,555/2), up =c(0,1,-1)), 
                        material=glossy(color="dodgerblue4"))) %&gt;%
  render_scene(clamp_value=10)
}
</code></pre>

<hr>
<h2 id='csg_translate'>CSG Translate</h2><span id='topic+csg_translate'></span>

<h3>Description</h3>

<p>CSG Translate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_translate(object, x = 0, y = 0, z = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_translate_+3A_object">object</code></td>
<td>
<p>CSG object.</p>
</td></tr>
<tr><td><code id="csg_translate_+3A_x">x</code></td>
<td>
<p>Default '0'. x translation.</p>
</td></tr>
<tr><td><code id="csg_translate_+3A_y">y</code></td>
<td>
<p>Default '0'. y translation.</p>
</td></tr>
<tr><td><code id="csg_translate_+3A_z">z</code></td>
<td>
<p>Default '0'. z translation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the triangle in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Translate a simple object:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_torus(), material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(csg_object(csg_translate(csg_torus(),x=-2,y=1,z=-2), 
                        material=glossy(color="red"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,lookfrom=c(0,5,10),fov=30,
               lookat=c(-1,0.5,-1))
}
if(run_documentation()) {
#Translate a blended object:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_combine(
    csg_torus(),
    csg_torus(y=1, radius=0.8), operation="blend"), material=glossy(color="dodgerblue4"))) %&gt;%
  add_object(csg_object(csg_translate(
    csg_combine(
      csg_torus(),
      csg_torus(y=1, radius=0.8), operation="blend"),
    x=-3,y=1,z=-3),
    material=glossy(color="red"))) %&gt;%
  add_object(sphere(y=5,x=5,radius=3,material=light(intensity=10))) %&gt;%  
  render_scene(clamp_value=10,lookfrom=c(0,5,10),fov=30,
               lookat=c(-1.5,0.5,-1.5))
}
</code></pre>

<hr>
<h2 id='csg_triangle'>CSG Triangle</h2><span id='topic+csg_triangle'></span>

<h3>Description</h3>

<p>CSG Triangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csg_triangle(v1 = c(0, 1, 0), v2 = c(1, 0, 0), v3 = c(-1, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csg_triangle_+3A_v1">v1</code></td>
<td>
<p>Default 'c(0,1,0)'. First vertex.</p>
</td></tr>
<tr><td><code id="csg_triangle_+3A_v2">v2</code></td>
<td>
<p>Default 'c(1,0,0)'. Second vertex.</p>
</td></tr>
<tr><td><code id="csg_triangle_+3A_v3">v3</code></td>
<td>
<p>Default 'c(-1,0,0)'. Third vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List describing the triangle in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a basic triangle:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_triangle(),material=diffuse(color="red"))) %&gt;% 
  add_object(sphere(y=5,z=3,material=light(intensity=30))) %&gt;% 
  render_scene(clamp_value=10,fov=20)
  }
if(run_documentation()) {
#Change a vertex:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_triangle(v1 = c(1,1,0)),material=diffuse(color="green"))) %&gt;% 
  add_object(sphere(y=5,z=3,material=light(intensity=30))) %&gt;% 
  render_scene(clamp_value=10,fov=20)
  }
if(run_documentation()) {
#Change all three vertices:
generate_ground(material=diffuse(checkercolor="grey20")) %&gt;% 
  add_object(csg_object(csg_triangle(v1 = c(0.5,1,0), v2 = c(1,-0.5,0), v3 = c(-1,0.5,0)),
                        material=diffuse(color="blue"))) %&gt;% 
  add_object(sphere(y=5,z=3,material=light(intensity=30))) %&gt;% 
  render_scene(clamp_value=10,fov=20,lookfrom=c(0,5,10))
}
</code></pre>

<hr>
<h2 id='cube'>Cube Object</h2><span id='topic+cube'></span>

<h3>Description</h3>

<p>Cube Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cube(
  x = 0,
  y = 0,
  z = 0,
  width = 1,
  xwidth = 1,
  ywidth = 1,
  zwidth = 1,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cube_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the cube</p>
</td></tr>
<tr><td><code id="cube_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate of the center of the cube</p>
</td></tr>
<tr><td><code id="cube_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the cube</p>
</td></tr>
<tr><td><code id="cube_+3A_width">width</code></td>
<td>
<p>Default '1'. Cube width.</p>
</td></tr>
<tr><td><code id="cube_+3A_xwidth">xwidth</code></td>
<td>
<p>Default '1'. x-width of the cube. Overrides 'width' argument for x-axis.</p>
</td></tr>
<tr><td><code id="cube_+3A_ywidth">ywidth</code></td>
<td>
<p>Default '1'. y-width of the cube. Overrides 'width' argument for y-axis.</p>
</td></tr>
<tr><td><code id="cube_+3A_zwidth">zwidth</code></td>
<td>
<p>Default '1'. z-width of the cube. Overrides 'width' argument for z-axis.</p>
</td></tr>
<tr><td><code id="cube_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="cube_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="cube_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="cube_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="cube_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the cube in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a cube in the cornell box.
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(cube(x = 555/2, y = 100, z = 555/2, 
                  xwidth = 200, ywidth = 200, zwidth = 200, angle = c(0, 30, 0))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
#Generate a gold cube in the cornell box
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(cube(x = 555/2, y = 100, z = 555/2, 
                  xwidth = 200, ywidth = 200, zwidth = 200, angle = c(0, 30, 0),
                  material = metal(color = "gold", fuzz = 0.2))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

#Generate a rotated dielectric box in the cornell box
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(cube(x = 555/2, y = 200, z = 555/2, 
                  xwidth = 200, ywidth = 100, zwidth = 200, angle = c(-30, 30, -30),
                  material = dielectric())) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40,  
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5) 
}
</code></pre>

<hr>
<h2 id='cubicInOut'>Cubic-in-out</h2><span id='topic+cubicInOut'></span>

<h3>Description</h3>

<p>Cubic-in-out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubicInOut(t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubicInOut_+3A_t">t</code></td>
<td>
<p>Value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>

<hr>
<h2 id='cylinder'>Cylinder Object</h2><span id='topic+cylinder'></span>

<h3>Description</h3>

<p>Cylinder Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cylinder(
  x = 0,
  y = 0,
  z = 0,
  radius = 1,
  length = 1,
  phi_min = 0,
  phi_max = 360,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1),
  capped = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cylinder_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the cylinder</p>
</td></tr>
<tr><td><code id="cylinder_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate of the center of the cylinder</p>
</td></tr>
<tr><td><code id="cylinder_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the cylinder</p>
</td></tr>
<tr><td><code id="cylinder_+3A_radius">radius</code></td>
<td>
<p>Default '1'. Radius of the cylinder.</p>
</td></tr>
<tr><td><code id="cylinder_+3A_length">length</code></td>
<td>
<p>Default '1'. Length of the cylinder.</p>
</td></tr>
<tr><td><code id="cylinder_+3A_phi_min">phi_min</code></td>
<td>
<p>Default '0'. Minimum angle around the segment.</p>
</td></tr>
<tr><td><code id="cylinder_+3A_phi_max">phi_max</code></td>
<td>
<p>Default '360'. Maximum angle around the segment.</p>
</td></tr>
<tr><td><code id="cylinder_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="cylinder_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="cylinder_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="cylinder_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="cylinder_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.</p>
</td></tr>
<tr><td><code id="cylinder_+3A_capped">capped</code></td>
<td>
<p>Default 'TRUE'. Whether to add caps to the segment. Turned off when using the 'light()' material.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the cylinder in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a cylinder in the cornell box. Add a cap to both ends.

if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(cylinder(x = 555/2, y = 250, z = 555/2, 
                      length = 300, radius = 100, material = metal())) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
#Rotate the cylinder
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(cylinder(x = 555/2, y = 250, z = 555/2, 
                      length = 300, radius = 100, angle = c(0, 0, 45),
                      material = diffuse())) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

# Only render a subtended arc of the cylinder, flipping the normals.
if(run_documentation()) {
generate_cornell(lightintensity=3) %&gt;%
  add_object(cylinder(x = 555/2, y = 250, z = 555/2, capped = FALSE,
                      length = 300, radius = 100, angle = c(45, 0, 0), phi_min = 0, phi_max = 180,
                      material = diffuse(), flipped = TRUE)) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
</code></pre>

<hr>
<h2 id='dielectric'>Dielectric (glass) Material</h2><span id='topic+dielectric'></span>

<h3>Description</h3>

<p>Dielectric (glass) Material
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dielectric(
  color = "white",
  refraction = 1.5,
  attenuation = c(0, 0, 0),
  attenuation_intensity = 1,
  priority = 0,
  importance_sample = FALSE,
  bump_texture = NA,
  bump_intensity = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dielectric_+3A_color">color</code></td>
<td>
<p>Default 'white'. The color of the surface. Can be either
a hexadecimal code, R color string, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="dielectric_+3A_refraction">refraction</code></td>
<td>
<p>Default '1.5'. The index of refraction.</p>
</td></tr>
<tr><td><code id="dielectric_+3A_attenuation">attenuation</code></td>
<td>
<p>Default 'c(0,0,0)'. The Beer-Lambert color-channel specific exponential attenuation 
through the material. Higher numbers will result in less of that color making it through the material. If a character string
is provided (either as a named R color or a hex string), this will be converted to a length-3 vector equal to one minus the RGB
color vector, which should approximate the color being passed.
Note: This assumes the object has a closed surface.</p>
</td></tr>
<tr><td><code id="dielectric_+3A_attenuation_intensity">attenuation_intensity</code></td>
<td>
<p>Default '1'. Changes the attenuation by a multiplicative factor. Values lower than one will make the 
dielectric more transparent, while values greater than one will make the glass more opaque.</p>
</td></tr>
<tr><td><code id="dielectric_+3A_priority">priority</code></td>
<td>
<p>Default '0'. When two dielectric materials overlap, the one with the lower priority value
is used for intersection. NOTE: If the camera is placed inside a dielectric object, its priority value
will not be taken into account when determining hits to other objects also inside the object.</p>
</td></tr>
<tr><td><code id="dielectric_+3A_importance_sample">importance_sample</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the object will be sampled explicitly during 
the rendering process. If the object is particularly important in contributing to the light paths
in the image (e.g. light sources, refracting glass ball with caustics, metal objects concentrating light),
this will help with the convergence of the image.</p>
</td></tr>
<tr><td><code id="dielectric_+3A_bump_texture">bump_texture</code></td>
<td>
<p>Default 'NA'. A matrix, array, or filename (specifying a greyscale image) to 
be used to specify a bump map for the surface.</p>
</td></tr>
<tr><td><code id="dielectric_+3A_bump_intensity">bump_intensity</code></td>
<td>
<p>Default '1'. Intensity of the bump map. High values may lead to unphysical results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the dielectric material.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a checkered ground
scene = generate_ground(depth=-0.5, material = diffuse(checkercolor="grey30",checkerperiod=2))
if(run_documentation()) {
render_scene(scene,parallel=TRUE)
}

#Add a glass sphere
if(run_documentation()) {
scene %&gt;%
  add_object(sphere(x=-0.5,radius=0.5,material=dielectric())) %&gt;%
  render_scene(parallel=TRUE,samples=128)
}

#Add a rotated colored glass cube
if(run_documentation()) {
scene %&gt;%
  add_object(sphere(x=-0.5,radius=0.5,material=dielectric())) %&gt;%
  add_object(cube(x=0.5,xwidth=0.5,material=dielectric(color="darkgreen"),angle=c(0,-45,0))) %&gt;%
  render_scene(parallel=TRUE,samples=128)
}

#Add an area light behind and at an angle and turn off the ambient lighting
if(run_documentation()) {
scene %&gt;%
  add_object(sphere(x=-0.5,radius=0.5,material=dielectric())) %&gt;%
  add_object(cube(x=0.5,xwidth=0.5,material=dielectric(color="darkgreen"),angle=c(0,-45,0))) %&gt;%
  add_object(yz_rect(z=-3,y=1,x=0,zwidth=3,ywidth=1.5,
                     material=light(intensity=15),
                     angle=c(0,-90,45), order_rotation = c(3,2,1))) %&gt;%
  render_scene(parallel=TRUE,aperture=0, ambient_light=FALSE,samples=1000)
}

#Color glass using Beer-Lambert attenuation, which attenuates light on a per-channel
#basis as it travels through the material. This effect is what gives some types of glass
#a green glow at the edges. We will get this effect by setting a lower attenuation value 
#for the `green` (second) channel in the dielectric `attenuation` argument.
if(run_documentation()) {
generate_ground(depth=-0.5,material=diffuse(checkercolor="grey30",checkerperiod=2)) %&gt;%
  add_object(sphere(z=-5,x=-0.5,y=1,material=light(intensity=10))) %&gt;%
  add_object(cube(y=0.3,ywidth=0.1,xwidth=2,zwidth=2,
                  material=dielectric(attenuation=c(1.2,0.2,1.2)),angle=c(45,110,0))) %&gt;%
  render_scene(parallel=TRUE, samples = 1000)
}

#If you have overlapping dielectrics, the `priority` value can help disambiguate what 
#object wins. Here, I place a bubble inside a cube by setting a lower priority value and
#making the inner sphere have a index of refraction of 1. I also place spheres at the corners.
if(run_documentation()) {
generate_ground(depth=-0.51,material=diffuse(checkercolor="grey30",checkerperiod=2)) %&gt;%
  add_object(cube(material = dielectric(priority=2, attenuation = c(10,3,10)))) %&gt;%
  add_object(sphere(radius=0.49,material = dielectric(priority=1, refraction=1))) %&gt;%
  add_object(sphere(radius=0.25,x=0.5,z=-0.5,y=0.5, 
                    material = dielectric(priority=0,attenuation = c(10,3,10) ))) %&gt;%
  add_object(sphere(radius=0.25,x=-0.5,z=0.5,y=0.5,
                    material = dielectric(priority=0,attenuation = c(10,3,10)))) %&gt;%
  render_scene(parallel=TRUE, samples = 128,lookfrom=c(5,1,5)) 
}

# We can also use this as a basic Constructive Solid Geometry interface by setting 
# the index of refraction equal to empty space, 1. This will subtract out those regions.
# Here I make a concave lens by subtracting two spheres from a cube.
if(run_documentation()) {
generate_ground(depth=-0.51,material=diffuse(checkercolor="grey30",checkerperiod=2,sigma=90)) %&gt;%
  add_object(cube(material = dielectric(attenuation = c(3,3,1),priority=1))) %&gt;%
  add_object(sphere(radius=1,x=1.01,
                    material = dielectric(priority=0,refraction=1))) %&gt;%
  add_object(sphere(radius=1,x=-1.01, 
                    material = dielectric(priority=0,refraction=1))) %&gt;%
  add_object(sphere(y=10,x=3,material=light(intensit=150))) %&gt;%
  render_scene(parallel=TRUE, samples = 128,lookfrom=c(5,3,5))
}
</code></pre>

<hr>
<h2 id='diffuse'>Diffuse Material</h2><span id='topic+diffuse'></span>

<h3>Description</h3>

<p>Diffuse Material
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffuse(
  color = "#ffffff",
  checkercolor = NA,
  checkerperiod = 3,
  noise = 0,
  noisephase = 0,
  noiseintensity = 10,
  noisecolor = "#000000",
  gradient_color = NA,
  gradient_transpose = FALSE,
  gradient_point_start = NA,
  gradient_point_end = NA,
  gradient_type = "hsv",
  image_texture = NA_character_,
  image_repeat = 1,
  alpha_texture = NA,
  bump_texture = NA,
  bump_intensity = 1,
  fog = FALSE,
  fogdensity = 0.01,
  sigma = NULL,
  importance_sample = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffuse_+3A_color">color</code></td>
<td>
<p>Default 'white'. The color of the surface. Can be either
a hexadecimal code, R color string, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_checkercolor">checkercolor</code></td>
<td>
<p>Default 'NA'. If not 'NA', determines the secondary color of the checkered surface. 
Can be either a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_checkerperiod">checkerperiod</code></td>
<td>
<p>Default '3'. The period of the checker pattern. Increasing this value makes the checker 
pattern bigger, and decreasing it makes it smaller</p>
</td></tr>
<tr><td><code id="diffuse_+3A_noise">noise</code></td>
<td>
<p>Default '0'. If not '0', covers the surface in a turbulent marble pattern. This value will determine
the amount of turbulence in the texture.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_noisephase">noisephase</code></td>
<td>
<p>Default '0'. The phase of the noise. The noise will repeat at '360'.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_noiseintensity">noiseintensity</code></td>
<td>
<p>Default '10'. Intensity of the noise.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_noisecolor">noisecolor</code></td>
<td>
<p>Default '#000000'. The secondary color of the noise pattern.
Can be either a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_gradient_color">gradient_color</code></td>
<td>
<p>Default 'NA'. If not 'NA', creates a secondary color for a linear gradient 
between the this color and color specified in 'color'. Direction is determined by 'gradient_transpose'.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_gradient_transpose">gradient_transpose</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will use the 'v' coordinate texture instead
of the 'u' coordinate texture to map the gradient.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_gradient_point_start">gradient_point_start</code></td>
<td>
<p>Default 'NA'. If not 'NA', this changes the behavior from mapping texture coordinates to 
mapping to world space coordinates. This should be a length-3 vector specifying the x,y, and z points where the gradient
begins with value 'color'.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_gradient_point_end">gradient_point_end</code></td>
<td>
<p>Default 'NA'. If not 'NA', this changes the behavior from mapping texture coordinates to 
mapping to world space coordinates. This should be a length-3 vector specifying the x,y, and z points where the gradient
begins with value 'gradient_color'.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_gradient_type">gradient_type</code></td>
<td>
<p>Default 'hsv'. Colorspace to calculate the gradient. Alternative 'rgb'.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_image_texture">image_texture</code></td>
<td>
<p>Default 'NA'. A 3-layer RGB array or filename to be used as the texture on the surface of the object.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_image_repeat">image_repeat</code></td>
<td>
<p>Default '1'. Number of times to repeat the image across the surface.
'u' and 'v' repeat amount can be set independently if user passes in a length-2 vector.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_alpha_texture">alpha_texture</code></td>
<td>
<p>Default 'NA'. A matrix or filename (specifying a greyscale image) to 
be used to specify the transparency.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_bump_texture">bump_texture</code></td>
<td>
<p>Default 'NA'. A matrix, array, or filename (specifying a greyscale image) to 
be used to specify a bump map for the surface.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_bump_intensity">bump_intensity</code></td>
<td>
<p>Default '1'. Intensity of the bump map. High values may lead to unphysical results.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_fog">fog</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the object will be a volumetric scatterer.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_fogdensity">fogdensity</code></td>
<td>
<p>Default '0.01'. The density of the fog. Higher values will produce more opaque objects.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_sigma">sigma</code></td>
<td>
<p>Default 'NULL'. A number between 0 and Infinity specifying the roughness of the surface using the Oren-Nayar microfacet model.
Higher numbers indicate a roughed surface, where sigma is the standard deviation of the microfacet orientation angle. When 0, this reverts
to the default lambertian behavior.</p>
</td></tr>
<tr><td><code id="diffuse_+3A_importance_sample">importance_sample</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the object will be sampled explicitly during 
the rendering process. If the object is particularly important in contributing to the light paths
in the image (e.g. light sources, refracting glass ball with caustics, metal objects concentrating light),
this will help with the convergence of the image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the diffuse material.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate the cornell box and add a single white sphere to the center
scene = generate_cornell() %&gt;%
  add_object(sphere(x=555/2,y=555/2,z=555/2,radius=555/8,material=diffuse()))
if(run_documentation()) {
render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}

#Add a checkered rectangular cube below             
scene = scene %&gt;%
  add_object(cube(x=555/2,y=555/8,z=555/2,xwidth=555/2,ywidth=555/4,zwidth=555/2,
  material = diffuse(checkercolor="purple",checkerperiod=20)))
if(run_documentation()) {
render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}
  
#Add a marbled sphere           
scene = scene %&gt;%
  add_object(sphere(x=555/2+555/4,y=555/2,z=555/2,radius=555/8,
  material = diffuse(noise=1/20)))
if(run_documentation()) {
render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}

#Add an orange volumetric (fog) cube           
scene = scene %&gt;%
  add_object(cube(x=555/2-555/4,y=555/2,z=555/2,xwidth=555/4,ywidth=555/4,zwidth=555/4,
  material = diffuse(fog=TRUE, fogdensity=0.05,color="orange")))
if(run_documentation()) {
render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}

#' #Add an line segment with a color gradient        
scene = scene %&gt;%
  add_object(segment(start = c(555,450,450),end=c(0,450,450),radius = 50, 
                     material = diffuse(color="#1f7326", gradient_color = "#a60d0d")))
if(run_documentation()) {
render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}
</code></pre>

<hr>
<h2 id='disk'>Disk Object</h2><span id='topic+disk'></span>

<h3>Description</h3>

<p>Disk Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disk(
  x = 0,
  y = 0,
  z = 0,
  radius = 1,
  inner_radius = 0,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disk_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the disk</p>
</td></tr>
<tr><td><code id="disk_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate of the center of the disk</p>
</td></tr>
<tr><td><code id="disk_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the disk</p>
</td></tr>
<tr><td><code id="disk_+3A_radius">radius</code></td>
<td>
<p>Default '1'. Radius of the disk.</p>
</td></tr>
<tr><td><code id="disk_+3A_inner_radius">inner_radius</code></td>
<td>
<p>Default '0'. Inner radius of the disk.</p>
</td></tr>
<tr><td><code id="disk_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="disk_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="disk_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="disk_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="disk_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the disk in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a disk in the cornell box.
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(disk(x = 555/2, y = 50, z = 555/2, radius = 150, 
                  material = diffuse(color = "orange"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
#Rotate the disk.
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(disk(x = 555/2, y = 555/2, z = 555/2, radius = 150, angle = c(-45, 0, 0), 
                  material = diffuse(color = "orange"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) , lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
#Pass a value for the inner radius.
if(run_documentation()) {
generate_cornell() %&gt;% 
  add_object(disk(x = 555/2, y = 555/2, z = 555/2, 
                  radius = 150, inner_radius = 75, angle = c(-45, 0, 0), 
                  material = diffuse(color = "orange"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
</code></pre>

<hr>
<h2 id='ellipsoid'>Ellipsoid Object</h2><span id='topic+ellipsoid'></span>

<h3>Description</h3>

<p>Note: light importance sampling for this shape is currently approximated by a sphere. This will fail
for ellipsoids with large differences between axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipsoid(
  x = 0,
  y = 0,
  z = 0,
  a = 1,
  b = 1,
  c = 1,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipsoid_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the ellipsoid.</p>
</td></tr>
<tr><td><code id="ellipsoid_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate of the center of the ellipsoid.</p>
</td></tr>
<tr><td><code id="ellipsoid_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the ellipsoid.</p>
</td></tr>
<tr><td><code id="ellipsoid_+3A_a">a</code></td>
<td>
<p>Default '1'. Principal x-axis of the ellipsoid.</p>
</td></tr>
<tr><td><code id="ellipsoid_+3A_b">b</code></td>
<td>
<p>Default '1'. Principal y-axis of the ellipsoid.</p>
</td></tr>
<tr><td><code id="ellipsoid_+3A_c">c</code></td>
<td>
<p>Default '1'. Principal z-axis of the ellipsoid.</p>
</td></tr>
<tr><td><code id="ellipsoid_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="ellipsoid_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="ellipsoid_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="ellipsoid_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="ellipsoid_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly. Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the ellipsoid in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate an ellipsoid in a Cornell box
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(ellipsoid(x = 555/2, y = 555/2, z = 555/2, 
                       a = 100, b = 50, c = 50)) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

#Change the axes to make it taller rather than wide:
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(ellipsoid(x = 555/2, y = 555/2, z = 555/2, 
                       a = 100, b = 200, c = 100, material = metal())) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

#Rotate it and make it dielectric:
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(ellipsoid(x = 555/2, y = 555/2, z = 555/2, 
                       a = 100, b = 200, c = 100, angle = c(0, 0, 45),
                       material = dielectric())) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
</code></pre>

<hr>
<h2 id='eval_bezier'>Evaluate Bezier</h2><span id='topic+eval_bezier'></span>

<h3>Description</h3>

<p>Evaluate Bezier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_bezier(cp, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_bezier_+3A_cp">cp</code></td>
<td>
<p>Control point matrix (4x3)</p>
</td></tr>
<tr><td><code id="eval_bezier_+3A_t">t</code></td>
<td>
<p>Interpolation distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D Numeric value for point in space
</p>

<hr>
<h2 id='eval_bezier_2nd_deriv'>Evaluate Deriv Bezier</h2><span id='topic+eval_bezier_2nd_deriv'></span>

<h3>Description</h3>

<p>Evaluate Deriv Bezier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_bezier_2nd_deriv(cp, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_bezier_2nd_deriv_+3A_cp">cp</code></td>
<td>
<p>Control point matrix (4x3)</p>
</td></tr>
<tr><td><code id="eval_bezier_2nd_deriv_+3A_t">t</code></td>
<td>
<p>Interpolation distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D Numeric value for point in space
</p>

<hr>
<h2 id='eval_bezier_deriv'>Evaluate Deriv Bezier</h2><span id='topic+eval_bezier_deriv'></span>

<h3>Description</h3>

<p>Evaluate Deriv Bezier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_bezier_deriv(cp, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_bezier_deriv_+3A_cp">cp</code></td>
<td>
<p>Control point matrix (4x3)</p>
</td></tr>
<tr><td><code id="eval_bezier_deriv_+3A_t">t</code></td>
<td>
<p>Interpolation distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D Numeric value for point in space
</p>

<hr>
<h2 id='expInOut'>Cubic-in-out</h2><span id='topic+expInOut'></span>

<h3>Description</h3>

<p>Cubic-in-out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expInOut(t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expInOut_+3A_t">t</code></td>
<td>
<p>Value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>

<hr>
<h2 id='extruded_path'>Extruded Path Object</h2><span id='topic+extruded_path'></span>

<h3>Description</h3>

<p>Note: Bump mapping with non-diffuse materials does not work correctly, and smoothed normals will be flat when
using a bump map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extruded_path(
  points,
  x = 0,
  y = 0,
  z = 0,
  polygon = NA,
  polygon_end = NA,
  breaks = NA,
  closed = FALSE,
  closed_smooth = TRUE,
  polygon_add_points = 0,
  twists = 0,
  texture_repeats = 1,
  straight = FALSE,
  precomputed_control_points = FALSE,
  width = 1,
  width_end = NA,
  width_ease = "spline",
  smooth_normals = FALSE,
  u_min = 0,
  u_max = 1,
  linear_step = FALSE,
  end_caps = c(TRUE, TRUE),
  material = diffuse(),
  material_caps = NA,
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extruded_path_+3A_points">points</code></td>
<td>
<p>Either a list of length-3 numeric vectors or 3-column matrix/data.frame specifying
the x/y/z points that the path should go through.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate offset for the path.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate offset for the path.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate offset for the path.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_polygon">polygon</code></td>
<td>
<p>Defaults to a circle. A polygon with no holes, specified by a data.frame() parsable by 'xy.coords()'. Vertices
are taken as sequential rows. If the polygon isn't closed (the last vertex equal to the first), it will be closed automatically.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_polygon_end">polygon_end</code></td>
<td>
<p>Defaults to 'polygon'. If specified, the number of vertices should equal the to the number of vertices 
of the polygon set in &lsquo;polygon'. Vertices are taken as sequential rows. If the polygon isn&rsquo;t closed (the last vertex equal to the first), it will be closed automatically.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_breaks">breaks</code></td>
<td>
<p>Defaults to '20' times the number of control points in the bezier curve.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_closed">closed</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the path will be closed by smoothly connecting the first
and last points, also ensuring the final polygon is aligned to the first.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_closed_smooth">closed_smooth</code></td>
<td>
<p>Default 'TRUE'. If 'closed = TRUE', this will ensure C2 (second derivative) 
continuity between the ends. If 'closed = FALSE', the curve will only have C1 (first derivative)
continuity between the ends.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_polygon_add_points">polygon_add_points</code></td>
<td>
<p>Default '0'. Positive integer specifying the number of points to fill in between polygon
vertices. Higher numbers can give smoother results (especially when combined with 'smooth_normals = TRUE'.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_twists">twists</code></td>
<td>
<p>Default '0'. Number of twists in the polygon from one end to another.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_texture_repeats">texture_repeats</code></td>
<td>
<p>Default '1'. Number of times to repeat the texture along the length of the path.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_straight">straight</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', straight lines will be used to connect the points instead
of bezier curves.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_precomputed_control_points">precomputed_control_points</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', 'points' argument will expect
a list of control points calculated with the internal rayrender function 'rayrender:::calculate_control_points()'.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_width">width</code></td>
<td>
<p>Default '0.1'. Curve width. If 'width_ease == &quot;spline&quot;', 'width' is specified in a format that can be read by 
'xy.coords()' (with 'y' as the width), and the 'x' coordinate is between '0' and '1', this can also specify the exact 
positions along the curve for the corresponding width values. If a numeric vector, specifies the different values of the width evenly along the curve.
If not a single value, 'width_end' will be ignored.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_width_end">width_end</code></td>
<td>
<p>Default 'NA'. Width at end of path. Same as 'width', unless specified. Ignored if multiple width values 
specified in 'width'.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_width_ease">width_ease</code></td>
<td>
<p>Default 'spline'. Ease function between width values. Other options: 'linear', 'quad', 'cubic', 'exp'.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_smooth_normals">smooth_normals</code></td>
<td>
<p>Default 'FALSE'. Whether to smooth the normals of the polygon to remove sharp angles.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_u_min">u_min</code></td>
<td>
<p>Default '0'. Minimum parametric coordinate for the path. If 'closed = TRUE', values greater than one will refer to the beginning 
of the loop (but the path will be generated as two objects).</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_u_max">u_max</code></td>
<td>
<p>Default '1'. Maximum parametric coordinate for the path. If 'closed = TRUE', values greater than one will refer to the beginning 
of the loop (but the path will be generated as two objects).</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_linear_step">linear_step</code></td>
<td>
<p>Default 'FALSE'. Whether the polygon intervals should be set at linear intervals,
rather than intervals based on the underlying bezier curve parameterization.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_end_caps">end_caps</code></td>
<td>
<p>Default 'c(TRUE, TRUE)'. Specifies whether to add an end cap to the beginning and end of a path.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>. The material, called from one of the material 
functions.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_material_caps">material_caps</code></td>
<td>
<p>Defaults to the same material set in 'material'.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="extruded_path_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the cube in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Specify the points for the path to travel though and the ground material
points = list(c(0,0,1),c(-0.5,0,-1),c(0,1,-1),c(1,0.5,0),c(0.6,0.3,1))
ground_mat = material=diffuse(color="grey50",
                              checkercolor = "grey20",checkerperiod = 1.5)
}
if(run_documentation()) {
#Default path shape is a circle
generate_studio(depth=-0.4,material=ground_mat) %&gt;%
  add_object(extruded_path(points = points, width=0.25, 
                           material=diffuse(color="red"))) %&gt;% 
  add_object(sphere(y=3,z=5,x=2,material=light(intensity=15))) %&gt;% 
  render_scene(lookat=c(0.3,0.5,0.5),fov=12, width=800,height=800, clamp_value = 10,
               aperture=0.025, samples=128, sample_method="sobol_blue")
}
if(run_documentation()) {
#Change the width evenly along the tube
generate_studio(depth=-0.4,material=ground_mat) %&gt;%
  add_object(extruded_path(points = points, width=0.25, 
                           width_end = 0.5,
                           material=diffuse(color="red"))) %&gt;% 
  add_object(sphere(y=3,z=5,x=2,material=light(intensity=15))) %&gt;% 
  render_scene(lookat=c(0.3,0.5,0.5),fov=12, width=800,height=800, clamp_value = 10,
               aperture=0.025, samples=128, sample_method="sobol_blue")
}
if(run_documentation()) {
#Change the width along the full length of the tube
generate_studio(depth=-0.4,material=ground_mat) %&gt;%
  add_object(extruded_path(points = points, 
                           width=0.25*sinpi(0:72*20/180),
                           material=diffuse(color="red"))) %&gt;% 
  add_object(sphere(y=3,z=5,x=2,material=light(intensity=15))) %&gt;% 
  render_scene(lookat=c(0.3,0.5,0.5),fov=12, width=800,height=800, clamp_value = 10,
               aperture=0.025, samples=128, sample_method="sobol_blue")
}
if(run_documentation()) {
#Specify the exact parametric x positions for the width values:
custom_width = data.frame(x=c(0,0.2,0.5,0.8,1), y=c(0.25,0.5,0,0.5,0.25))
generate_studio(depth=-0.4,material=ground_mat) %&gt;%
  add_object(extruded_path(points = points, 
                           width=custom_width,
                           material=diffuse(color="red"))) %&gt;% 
  add_object(sphere(y=3,z=5,x=2,material=light(intensity=15))) %&gt;% 
  render_scene(lookat=c(0.3,0.5,0.5),fov=12, width=800,height=800, clamp_value = 10,
               aperture=0.025, samples=128, sample_method="sobol_blue")
}
if(run_documentation()) {
#Generate a star polygon
angles = seq(360,0,length.out=21)
xx = c(rep(c(1,0.75,0.5,0.75),5),1) * sinpi(angles/180)/4
yy = c(rep(c(1,0.75,0.5,0.75),5),1) * cospi(angles/180)/4
star_polygon = data.frame(x=xx,y=yy)

#Extrude a path using a star polygon
generate_studio(depth=-0.4,material=ground_mat) %&gt;%
  add_object(extruded_path(points = points, width=0.5, 
                           polygon = star_polygon,
                           material=diffuse(color="red"))) %&gt;% 
  add_object(sphere(y=3,z=5,x=2,material=light(intensity=15))) %&gt;% 
  render_scene(lookat=c(0.3,0.5,1),fov=12, width=800,height=800, clamp_value = 10,
               aperture=0.025, samples=128, sample_method="sobol_blue")
}
if(run_documentation()) {
#Specify a circle polygon
angles = seq(360,0,length.out=21)
xx = sinpi(angles/180)/4
yy = cospi(angles/180)/4
circ_polygon = data.frame(x=xx,y=yy)

#Transform from the circle polygon to the star polygon and change the end cap material
generate_studio(depth=-0.4,material=ground_mat) %&gt;%
  add_object(extruded_path(points = points, width=0.5, 
                           polygon=circ_polygon, polygon_end = star_polygon,
                           material_cap  = diffuse(color="white"),
                           material=diffuse(color="red"))) %&gt;% 
  add_object(sphere(y=3,z=5,x=2,material=light(intensity=15))) %&gt;% 
  render_scene(lookat=c(0.3,0.5,0.5),fov=12, width=800,height=800, clamp_value = 10,
               aperture=0.025, samples=128, sample_method="sobol_blue")
}
if(run_documentation()) {
#Add three and a half twists along the path, and make sure the breaks are evenly spaced
generate_studio(depth=-0.4,material=ground_mat) %&gt;%
  add_object(extruded_path(points = points, width=0.5, twists = 3.5,
                           polygon=star_polygon, linear_step = TRUE, breaks=360,
                           material_cap  = diffuse(color="white"),
                           material=diffuse(color="red"))) %&gt;% 
  add_object(sphere(y=3,z=5,x=2,material=light(intensity=15))) %&gt;% 
  render_scene(lookat=c(0.3,0.5,0),fov=12, width=800,height=800, clamp_value = 10,
               aperture=0.025, samples=128, sample_method="sobol_blue")
}
if(run_documentation()) {
#Smooth the normals for a less sharp appearance:
generate_studio(depth=-0.4,material=ground_mat) %&gt;%
  add_object(extruded_path(points = points, width=0.5, twists = 3.5,
                           polygon=star_polygon, 
                           linear_step = TRUE, breaks=360,
                           smooth_normals = TRUE,
                           material_cap  = diffuse(color="white"),
                           material=diffuse(color="red"))) %&gt;% 
  add_object(sphere(y=3,z=5,x=2,material=light(intensity=15))) %&gt;% 
  render_scene(lookat=c(0.3,0.5,0),fov=12, width=800,height=800, clamp_value = 10,
               aperture=0.025, samples=128, sample_method="sobol_blue")
}
if(run_documentation()) {
#Only generate part of the curve, specified by the u_min and u_max arguments
generate_studio(depth=-0.4,material=ground_mat) %&gt;%
  add_object(extruded_path(points = points, width=0.5, twists = 3.5,
                           u_min = 0.2, u_max = 0.8,
                           polygon=star_polygon, linear_step = TRUE, breaks=360,
                           material_cap  = diffuse(color="white"),
                           material=diffuse(color="red"))) %&gt;% 
  add_object(sphere(y=3,z=5,x=2,material=light(intensity=15))) %&gt;% 
  render_scene(lookat=c(0.3,0.5,0),fov=12, width=800,height=800, clamp_value = 10,
               aperture=0.025, samples=128, sample_method="sobol_blue")
}
if(run_documentation()) {
#Render a Mobius strip with 1.5 turns 
points = list(c(0,0,0),c(0.5,0.5,0),c(0,1,0),c(-0.5,0.5,0))
square_polygon = matrix(c(-1, -0.1, 0,
                           1, -0.1, 0,
                           1,  0.1, 0,
                          -1,  0.1, 0)/10, ncol=3,byrow = T)

generate_studio(depth=-0.2,
               material=diffuse(color = "dodgerblue4", checkercolor = "#002a61",
                                checkerperiod = 1)) %&gt;%
 add_object(extruded_path(points = points,  polygon=square_polygon, closed = TRUE,
                          linear_step = TRUE, twists = 1.5, breaks = 720, 
                          material = diffuse(noisecolor = "black", noise = 10, 
                                             noiseintensity = 10))) %&gt;%
 add_object(sphere(y=20,x=0,z=21,material=light(intensity = 1000))) %&gt;% 
 render_scene(lookat=c(0,0.5,0), fov=10, samples=128, sample_method = "sobol_blue",
              width = 800, height=800)
}
if(run_documentation()) {
#Create a green glass tube with the dielectric priority interface
#and fill it with a purple neon tube light
generate_ground(depth=-0.4,material=diffuse(color="grey50",
                                            checkercolor = "grey20",checkerperiod = 1.5)) %&gt;%
  add_object(extruded_path(points = points, width=0.7, linear_step = TRUE, 
                           polygon = star_polygon, twists = 2, closed = TRUE,
                           polygon_end = star_polygon, breaks=500,
                           material=dielectric(priority = 1, refraction = 1.2, 
                                               attenuation=c(1,0.3,1),
                                               attenuation_intensity=20))) %&gt;% 
  add_object(extruded_path(points = points, width=0.4, linear_step = TRUE,
                           polygon = star_polygon,twists = 2, closed = TRUE,
                           polygon_end = star_polygon, breaks=500,
                           material=dielectric(priority = 0,refraction = 1))) %&gt;%  
  add_object(extruded_path(points = points, width=0.05, closed = TRUE,
                           material=light(color="purple", intensity = 5,
                                          importance_sample = FALSE))) %&gt;%
  add_object(sphere(y=10,z=-5,x=0,radius=5,material=light(color = "white",intensity = 5))) %&gt;%
  render_scene(lookat=c(0,0.5,1),fov=10, 
               width=800,height=800, clamp_value = 10,
               aperture=0.025, samples=128, sample_method="sobol_blue")
}
</code></pre>

<hr>
<h2 id='extruded_polygon'>Extruded Polygon Object</h2><span id='topic+extruded_polygon'></span>

<h3>Description</h3>

<p>Extruded Polygon Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extruded_polygon(
  polygon = NULL,
  x = 0,
  y = 0,
  z = 0,
  plane = "xz",
  top = 1,
  bottom = 0,
  holes = NULL,
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  material = diffuse(),
  center = FALSE,
  flip_horizontal = FALSE,
  flip_vertical = FALSE,
  data_column_top = NULL,
  data_column_bottom = NULL,
  scale_data = 1,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extruded_polygon_+3A_polygon">polygon</code></td>
<td>
<p>'sf' object, &quot;SpatialPolygon&quot; 'sp' object,  or xy coordinates
of polygon represented in a way that can be processed by 'xy.coords()'.  If
xy-coordinate based polygons are open, they will be closed by adding an
edge from the last point to the first. If the 'sf' object contains MULTIPOLYGONZ data, it will
flattened.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate to offset the extruded model.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate to offset the extruded model.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate to offset the extruded model.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_plane">plane</code></td>
<td>
<p>Default 'xz'. The plane the polygon is drawn in. All possibile orientations
are 'xz', 'zx', 'xy', 'yx', 'yz', and 'zy'.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_top">top</code></td>
<td>
<p>Default '1'. Extruded top distance. If this equals 'bottom', the polygon will not be
extruded and just the one side will be rendered.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_bottom">bottom</code></td>
<td>
<p>Default '0'. Extruded bottom distance. If this equals 'top', the polygon will not be
extruded and just the one side will be rendered.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_holes">holes</code></td>
<td>
<p>Default '0'. If passing in a polygon directly, this specifies which index represents
the holes in the polygon. See the 'earcut' function in the 'decido' package for more information.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_center">center</code></td>
<td>
<p>Default 'FALSE'. Whether to center the polygon at the origin.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_flip_horizontal">flip_horizontal</code></td>
<td>
<p>Default 'FALSE'. Flip polygon horizontally in the plane defined by 'plane'.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_flip_vertical">flip_vertical</code></td>
<td>
<p>Default 'FALSE'. Flip polygon vertically in the plane defined by 'plane'.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_data_column_top">data_column_top</code></td>
<td>
<p>Default 'NULL'. A string indicating the column in the 'sf' object to use 
to specify the top of the extruded polygon.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_data_column_bottom">data_column_bottom</code></td>
<td>
<p>Default 'NULL'. A string indicating the column in the 'sf' object to use 
to specify the bottom of the extruded polygon.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_scale_data">scale_data</code></td>
<td>
<p>Default '1'. If specifying 'data_column_top' or 'data_column_bottom', how
much to scale that value when rendering.</p>
</td></tr>
<tr><td><code id="extruded_polygon_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiple row tibble describing the extruded polygon in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Manually create a polygon object, here a star:

if(run_documentation()) {
angles = seq(0,360,by=36)
xx = rev(c(rep(c(1,0.5),5),1) * sinpi(angles/180))
yy = rev(c(rep(c(1,0.5),5),1) * cospi(angles/180))
star_polygon = data.frame(x=xx,y=yy)
}

if(run_documentation()) {
generate_ground(depth=0,
                material = diffuse(color="grey50",checkercolor="grey20")) %&gt;%
  add_object(extruded_polygon(star_polygon,top=0.5,bottom=0,
                              material=diffuse(color="red",sigma=90))) %&gt;%
  add_object(sphere(y=4,x=-3,z=-3,material=light(intensity=30))) %&gt;%
  render_scene(parallel=TRUE,lookfrom = c(0,2,3),samples=128,lookat=c(0,0.5,0),fov=60)
}

#Now, let's add a hole to the center of the polygon. We'll make the polygon
#hollow by shrinking it, combining it with the normal size polygon,
#and specify with the `holes` argument that everything after `nrow(star_polygon)`
#in the following should be used to draw a hole:

if(run_documentation()) {
hollow_star = rbind(star_polygon,0.8*star_polygon)
}

if(run_documentation()) {
generate_ground(depth=-0.01,
                material = diffuse(color="grey50",checkercolor="grey20")) %&gt;%
  add_object(extruded_polygon(hollow_star,top=0.25,bottom=0, holes = nrow(star_polygon) + 1,
                              material=diffuse(color="red",sigma=90))) %&gt;%
  add_object(sphere(y=4,x=-3,z=-3,material=light(intensity=30))) %&gt;%
  render_scene(parallel=TRUE,lookfrom = c(0,2,4),samples=128,lookat=c(0,0,0),fov=30)
}

# Render one in the y-x plane as well by changing the `plane` argument,
# as well as offset it slightly.
if(run_documentation()) {
generate_ground(depth=-0.01,
                material = diffuse(color="grey50",checkercolor="grey20")) %&gt;%
  add_object(extruded_polygon(hollow_star,top=0.25,bottom=0, holes = nrow(star_polygon),
                              material=diffuse(color="red",sigma=90))) %&gt;%
  add_object(extruded_polygon(hollow_star,top=0.25,bottom=0, y=1.2, z=-1.2, 
                              holes = nrow(star_polygon) + 1, plane = "yx", 
                              material=diffuse(color="green",sigma=90))) %&gt;%
  add_object(sphere(y=4,x=-3,material=light(intensity=30))) %&gt;%
  render_scene(parallel=TRUE,lookfrom = c(0,2,4),samples=128,lookat=c(0,0.9,0),fov=40)
}

# Now add the zy plane:
if(run_documentation()) {
generate_ground(depth=-0.01,
                material = diffuse(color="grey50",checkercolor="grey20")) %&gt;%
  add_object(extruded_polygon(hollow_star,top=0.25,bottom=0, holes = nrow(star_polygon) + 1,
                              material=diffuse(color="red",sigma=90))) %&gt;%
  add_object(extruded_polygon(hollow_star,top=0.25,bottom=0, y=1.2, z=-1.2, 
                              holes = nrow(star_polygon) + 1, plane = "yx", 
                              material=diffuse(color="green",sigma=90))) %&gt;%
  add_object(extruded_polygon(hollow_star,top=0.25,bottom=0, y=1.2, x=1.2, 
                              holes = nrow(star_polygon) + 1, plane = "zy", 
                              material=diffuse(color="blue",sigma=90))) %&gt;%
  add_object(sphere(y=4,x=-3,material=light(intensity=30))) %&gt;%
  render_scene(parallel=TRUE,lookfrom = c(-4,2,4),samples=128,lookat=c(0,0.9,0),fov=40)
}

#We can also directly pass in sf polygons:
if(run_documentation()) {
if(length(find.package("spData",quiet=TRUE)) &gt; 0) {
  us_states = spData::us_states
  texas = us_states[us_states$NAME == "Texas",]
  #Fix no sfc class in us_states geometry data
  class(texas$geometry) = c("list","sfc")
}
}

#This uses the raw coordinates, unless `center = TRUE`, which centers the bounding box
#of the polygon at the origin.
if(run_documentation()) {
generate_ground(depth=-0.01,
                material = diffuse(color="grey50",checkercolor="grey20")) %&gt;%
  add_object(extruded_polygon(texas, center = TRUE,
                              material=diffuse(color="#ff2222",sigma=90))) %&gt;%
  add_object(sphere(y=30,x=-30,radius=10,
                    material=light(color="lightblue",intensity=40))) %&gt;%
  render_scene(parallel=TRUE,lookfrom = c(0,10,-10),samples=128,fov=60)
}

#Here we use the raw coordinates, but offset the polygon manually.
if(run_documentation()) {
generate_ground(depth=-0.01,
                material = diffuse(color="grey50",checkercolor="grey20")) %&gt;%
  add_object(extruded_polygon(us_states, x=-96,z=-40, top=2,
                              material=diffuse(color="#ff2222",sigma=90))) %&gt;%
  add_object(sphere(y=30,x=-100,radius=10,
                    material=light(color="lightblue",intensity=200))) %&gt;%
  add_object(sphere(y=30,x=100,radius=10,
                    material=light(color="orange",intensity=200))) %&gt;%
  render_scene(parallel=TRUE,lookfrom = c(0,120,-120),samples=128,fov=20)
}

#We can also set the map the height of each polygon to a column in the sf object,
#scaling it down by the maximum population state.

if(run_documentation()) {
generate_ground(depth=0,
                material = diffuse(color="grey50",checkercolor="grey20",sigma=90)) %&gt;%
  add_object(extruded_polygon(us_states, x=-96,z=-45, data_column_top = "total_pop_15",
                              scale_data = 1/max(us_states$total_pop_15)*5,
                              material=diffuse(color="#ff2222",sigma=90))) %&gt;%
  add_object(sphere(y=30,x=-100,z=60,radius=10,
                    material=light(color="lightblue",intensity=250))) %&gt;%
  add_object(sphere(y=30,x=100,z=-60,radius=10,
                    material=light(color="orange",intensity=250))) %&gt;%
  render_scene(parallel=TRUE,lookfrom = c(-60,50,-40),lookat=c(0,-5,0),samples=128,fov=30)
}

</code></pre>

<hr>
<h2 id='fliplr'>Flip Left-Right</h2><span id='topic+fliplr'></span>

<h3>Description</h3>

<p>Flip Left-Right
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fliplr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fliplr_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='flipud'>Flip Up-Down</h2><span id='topic+flipud'></span>

<h3>Description</h3>

<p>Flip Up-Down
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipud(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipud_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='generate_camera_motion'>Generate Camera Movement</h2><span id='topic+generate_camera_motion'></span>

<h3>Description</h3>

<p>Takes a series of key frame camera positions and smoothly interpolates between them. Generates
a data.frame that can be passed to 'render_animation()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_camera_motion(
  positions,
  lookats = NULL,
  apertures = 0,
  fovs = 40,
  focal_distances = NULL,
  ortho_dims = NULL,
  camera_ups = NULL,
  type = "cubic",
  frames = 30,
  closed = FALSE,
  aperture_linear = TRUE,
  fov_linear = TRUE,
  focal_linear = TRUE,
  ortho_linear = TRUE,
  constant_step = TRUE,
  curvature_adjust = "none",
  curvature_scale = 30,
  offset_lookat = 0,
  damp_motion = FALSE,
  damp_magnitude = 0.1,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_camera_motion_+3A_positions">positions</code></td>
<td>
<p>A list or 3-column XYZ matrix of camera positions. 
These will serve as key frames for the camera position. Alternatively, this can also be the a 
dataframe of the keyframe output from an interactive rayrender session ('ray_keyframes').</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_lookats">lookats</code></td>
<td>
<p>Default 'NULL', which sets the camera lookat to the origin 'c(0,0,0)' 
for the animation. A list or 3-column XYZ matrix
of 'lookat' points. Must be the same number of points as 'positions'.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_apertures">apertures</code></td>
<td>
<p>Default '0'. A numeric vector of aperture values.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_fovs">fovs</code></td>
<td>
<p>Default '40'. A numeric vector of field of view values.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_focal_distances">focal_distances</code></td>
<td>
<p>Default 'NULL', automatically the distance between positions and lookats. 
Numeric vector of focal distances.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_ortho_dims">ortho_dims</code></td>
<td>
<p>Default 'NULL', which results in 'c(1,1)' orthographic dimensions.  A list or 2-column matrix
of orthographic dimensions.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_camera_ups">camera_ups</code></td>
<td>
<p>Default 'NULL', which gives at up vector of 'c(0,1,0)'. Camera up orientation.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_type">type</code></td>
<td>
<p>Default 'cubic'. Type of transition between keyframes. 
Other options are 'linear', 'quad', 'bezier', 'exp', and 'manual'. 'manual' just returns the values 
passed in, properly formatted to be passed to 'render_animation()'.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_frames">frames</code></td>
<td>
<p>Default '30'. Total number of frames.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_closed">closed</code></td>
<td>
<p>Default 'FALSE'. Whether to close the camera curve so the first position matches the last. Set this to 'TRUE' for perfect loops.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_aperture_linear">aperture_linear</code></td>
<td>
<p>Default 'TRUE'. This linearly interpolates focal distances, rather than using a smooth Bezier curve  or easing function.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_fov_linear">fov_linear</code></td>
<td>
<p>Default 'TRUE'. This linearly interpolates focal distances, rather than using a smooth Bezier curve  or easing function.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_focal_linear">focal_linear</code></td>
<td>
<p>Default 'TRUE'. This linearly interpolates focal distances, rather than using a smooth Bezier curve or easing function.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_ortho_linear">ortho_linear</code></td>
<td>
<p>Default 'TRUE'. This linearly interpolates orthographic dimensions, rather than using a smooth Bezier curve or easing function.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_constant_step">constant_step</code></td>
<td>
<p>Default 'TRUE'. This will make the camera travel at a constant speed.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_curvature_adjust">curvature_adjust</code></td>
<td>
<p>Default 'none'. Other options are 'position', 'lookat', and 'both'. Whether to slow down the camera at areas of high curvature
to prevent fast swings. Only used for curve 'type = bezier'. This does not preserve key frame positions.
Note: This feature will likely result in the 'lookat' and 'position' diverging if they do not 
have similar curvatures at each point. This feature is best used when passing the same set of points to 'positions' and 'lookats' 
and providing an 'offset_lookat' value, which ensures the curvature will be the same.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_curvature_scale">curvature_scale</code></td>
<td>
<p>Default '30'. Constant dividing factor for curvature. Higher values will subdivide the
path more, potentially finding a smoother path, but increasing the calculation time. Only used for curve 'type = bezier'.
Increasing this value after a certain point will not increase the quality of the path, but it is scene-dependent.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_offset_lookat">offset_lookat</code></td>
<td>
<p>Default '0'. Amount to offset the lookat position, either along the path (if 'constant_step = TRUE')
or towards the derivative of the Bezier curve.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_damp_motion">damp_motion</code></td>
<td>
<p>Default 'FALSE'. Whether to damp the motion of the camera, so that quick movements are damped
and don't result in shakey motion. This function tracks the current position, and linearly interpolates between
that point and the next point using value 'damp_magnitude'. 
The equation for the position is 'cam_current = cam_current * damp_magnitude + cam_next_point * (1 - damp_magnitude)'.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_damp_magnitude">damp_magnitude</code></td>
<td>
<p>Default '0.1'. Amount to damp the motion, a numeric value greater than '0' (no damping) and
less than '1'.</p>
</td></tr>
<tr><td><code id="generate_camera_motion_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE'. Whether to display a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of camera positions, orientations, apertures, focal distances, and field of views
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create and animate flying through a scene on a simulated roller coaster
if(run_documentation()) {
set.seed(3)
elliplist = list()
ellip_colors = rainbow(8)
for(i in 1:1200) {
  elliplist[[i]] = ellipsoid(x=10*runif(1)-5,y=10*runif(1)-5,z=10*runif(1)-5,
                             angle = 360*runif(3), a=0.1,b=0.05,c=0.1,
                             material=glossy(color=sample(ellip_colors,1)))
}
ellip_scene = do.call(rbind, elliplist)

camera_pos = list(c(0,1,15),c(5,-5,5),c(-5,5,-5),c(0,1,-15))

#Plot the camera path and render from above using the path object:
generate_ground(material=diffuse(checkercolor="grey20"),depth=-10) %&gt;% 
  add_object(ellip_scene) %&gt;% 
  add_object(sphere(y=50,radius=10,material=light(intensity=30))) %&gt;% 
  add_object(path(camera_pos, material=diffuse(color="red"))) %&gt;% 
  render_scene(lookfrom=c(0,20,0), width=800,height=800,samples=32,
               camera_up = c(0,0,1),
               fov=80)
}
if(run_documentation()) { 
#Side view     
generate_ground(material=diffuse(checkercolor="grey20"),depth=-10) %&gt;% 
  add_object(ellip_scene) %&gt;% 
  add_object(sphere(y=50,radius=10,material=light(intensity=30))) %&gt;% 
  add_object(path(camera_pos, material=diffuse(color="red"))) %&gt;% 
  render_scene(lookfrom=c(20,0,0),width=800,height=800,samples=32,
                 fov=80)
 }
if(run_documentation()) {
#View from the start        
generate_ground(material=diffuse(checkercolor="grey20"),depth=-10) %&gt;% 
  add_object(ellip_scene) %&gt;% 
  add_object(sphere(y=50,radius=10,material=light(intensity=30))) %&gt;% 
  add_object(path(camera_pos, material=diffuse(color="red"))) %&gt;% 
  render_scene(lookfrom=c(0,1.5,16),width=800,height=800,samples=32,
                 fov=80)
 }
if(run_documentation()) {  
#Generate Camera movement, setting the lookat position to be same as camera position, but offset
#slightly in front. We'll render 12 frames, but you'd likely want more in a real animation.

camera_motion =  generate_camera_motion(positions = camera_pos, lookats = camera_pos, 
                                        offset_lookat = 1, fovs=80, frames=12,
                                        type="bezier") 
                                        
#This returns a data frame of individual camera positions, interpolated by cubic bezier curves.
camera_motion

#Pass NA filename to plot to the device. We'll keep the path and offset it slightly to see
#where we're going. This results in a "roller coaster" effect.
generate_ground(material=diffuse(checkercolor="grey20"),depth=-10) %&gt;% 
  add_object(ellip_scene) %&gt;% 
  add_object(sphere(y=50,radius=10,material=light(intensity=30))) %&gt;% 
  add_object(obj_model(r_obj(),x=10,y=-10,scale_obj=3, angle=c(0,-45,0),
                       material=dielectric(attenuation=c(1,1,0.3)))) %&gt;% 
  add_object(pig(x=-7,y=10,z=-5,scale=1,angle=c(0,-45,80),emotion="angry")) %&gt;% 
  add_object(pig(x=0,y=-0.25,z=-15,scale=1,angle=c(0,225,-20),
                 emotion="angry", spider=TRUE)) %&gt;% 
  add_object(path(camera_pos, y=-0.2,material=diffuse(color="red"))) %&gt;% 
  render_animation(filename = NA, camera_motion = camera_motion, samples=100,
                   sample_method="sobol_blue",  
                   clamp_value=10, width=400, height=400)

}
</code></pre>

<hr>
<h2 id='generate_cornell'>Generate Cornell Box</h2><span id='topic+generate_cornell'></span>

<h3>Description</h3>

<p>Generate Cornell Box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_cornell(
  light = TRUE,
  lightintensity = 5,
  lightcolor = "white",
  lightwidth = 332,
  lightdepth = 343,
  sigma = 0,
  leftcolor = "#1f7326",
  rightcolor = "#a60d0d",
  roomcolor = "#bababa",
  importance_sample = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_cornell_+3A_light">light</code></td>
<td>
<p>Default 'TRUE'. Whether to include a light on the ceiling of the box.</p>
</td></tr>
<tr><td><code id="generate_cornell_+3A_lightintensity">lightintensity</code></td>
<td>
<p>Default '5'. The intensity of the light.</p>
</td></tr>
<tr><td><code id="generate_cornell_+3A_lightcolor">lightcolor</code></td>
<td>
<p>Default 'white'. The color the of the light.</p>
</td></tr>
<tr><td><code id="generate_cornell_+3A_lightwidth">lightwidth</code></td>
<td>
<p>Default '332'. Width (z) of the light.</p>
</td></tr>
<tr><td><code id="generate_cornell_+3A_lightdepth">lightdepth</code></td>
<td>
<p>Default '343'. Depth (x) of the light.</p>
</td></tr>
<tr><td><code id="generate_cornell_+3A_sigma">sigma</code></td>
<td>
<p>Default '0'. Oren-Nayar microfacet angle.</p>
</td></tr>
<tr><td><code id="generate_cornell_+3A_leftcolor">leftcolor</code></td>
<td>
<p>Default '#1f7326' (green).</p>
</td></tr>
<tr><td><code id="generate_cornell_+3A_rightcolor">rightcolor</code></td>
<td>
<p>Default '#a60d0d' (red).</p>
</td></tr>
<tr><td><code id="generate_cornell_+3A_roomcolor">roomcolor</code></td>
<td>
<p>Default '#bababa' (light grey).</p>
</td></tr>
<tr><td><code id="generate_cornell_+3A_importance_sample">importance_sample</code></td>
<td>
<p>Default 'TRUE'. Importance sample the light in the room.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble containing the scene description of the Cornell box.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate and render the default Cornell box.
scene = generate_cornell()
if(run_documentation()) {
render_scene(scene, samples=128,aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}
if(run_documentation()) {
#Make a much smaller light in the center of the room.
scene = generate_cornell(lightwidth=200,lightdepth=200)
render_scene(scene, samples=128,aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}
if(run_documentation()) {
#Place a sphere in the middle of the box.
scene = scene %&gt;%
  add_object(sphere(x=555/2,y=555/2,z=555/2,radius=555/4))
render_scene(scene, samples=128,aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}
if(run_documentation()) {
#Reduce "fireflies" by setting a clamp_value in render_scene()
render_scene(scene, samples=128,aperture=0, fov=40, ambient_light=FALSE, 
             parallel=TRUE,clamp_value=3)
}
if(run_documentation()) {
# Change the color scheme of the cornell box
new_cornell = generate_cornell(leftcolor="purple", rightcolor="yellow")
render_scene(new_cornell, samples=128,aperture=0, fov=40, ambient_light=FALSE, 
             parallel=TRUE,clamp_value=3)
}
</code></pre>

<hr>
<h2 id='generate_ground'>Generate Ground</h2><span id='topic+generate_ground'></span>

<h3>Description</h3>

<p>Generates a large sphere that can be used as the ground for a scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_ground(
  depth = -1,
  spheresize = 1000,
  material = diffuse(color = "#ccff00")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_ground_+3A_depth">depth</code></td>
<td>
<p>Default '-1'. Depth of the surface.</p>
</td></tr>
<tr><td><code id="generate_ground_+3A_spheresize">spheresize</code></td>
<td>
<p>Default '1000'. Radius of the sphere representing the surface.</p>
</td></tr>
<tr><td><code id="generate_ground_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code> with 'color= &quot;#ccff00&quot;'.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="generate_ground_+3A_color">color</code></td>
<td>
<p>Default '#ccff00'. The color of the sphere. Can be either
a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the ground.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate the ground and add some objects
scene = generate_ground(depth=-0.5,
                        material = diffuse(noise=1,noisecolor="blue",noisephase=10)) %&gt;%
  add_object(cube(x=0.7,material=diffuse(color="red"),angle=c(0,-15,0))) %&gt;%
  add_object(sphere(x=-0.7,radius=0.5,material=dielectric(color="white")))
if(run_documentation()) {
render_scene(scene, parallel=TRUE,lookfrom=c(0,2,10))
}

# Make the sphere representing the ground larger and make it a checkered surface.
scene = generate_ground(depth=-0.5, spheresize=10000,
                        material = diffuse(checkercolor="grey50")) %&gt;%
  add_object(cube(x=0.7,material=diffuse(color="red"),angle=c(0,-15,0))) %&gt;%
  add_object(sphere(x=-0.7,radius=0.5,material=dielectric(color="white")))
if(run_documentation()) {
render_scene(scene, parallel=TRUE,lookfrom=c(0,1,10))
}
</code></pre>

<hr>
<h2 id='generate_rotation_matrix'>Generate Rotation Matrix (order)</h2><span id='topic+generate_rotation_matrix'></span>

<h3>Description</h3>

<p>Generate Rotation Matrix (order)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_rotation_matrix(angles, order_rotation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_rotation_matrix_+3A_angles">angles</code></td>
<td>
<p>Angles</p>
</td></tr>
<tr><td><code id="generate_rotation_matrix_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Order of Rotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>

<hr>
<h2 id='generate_studio'>Generate Studio</h2><span id='topic+generate_studio'></span>

<h3>Description</h3>

<p>Generates a curved studio backdrop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_studio(
  depth = -1,
  distance = -10,
  width = 100,
  height = 100,
  curvature = 8,
  material = diffuse()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_studio_+3A_depth">depth</code></td>
<td>
<p>Default '-1'. Depth of the ground in the scene.</p>
</td></tr>
<tr><td><code id="generate_studio_+3A_distance">distance</code></td>
<td>
<p>Default '-10'. Distance to the backdrop in the scene from the origin, on the z-axis.</p>
</td></tr>
<tr><td><code id="generate_studio_+3A_width">width</code></td>
<td>
<p>Default '100'. Width of the backdrop.</p>
</td></tr>
<tr><td><code id="generate_studio_+3A_height">height</code></td>
<td>
<p>Default '100'. height of the backdrop.</p>
</td></tr>
<tr><td><code id="generate_studio_+3A_curvature">curvature</code></td>
<td>
<p>Default '2'. Radius of the curvature connecting the bottom plane to the vertical
backdrop.</p>
</td></tr>
<tr><td><code id="generate_studio_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code> with 'color= &quot;#ccff00&quot;'.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble representing the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate the ground and add some objects
scene = generate_studio(depth=-1, material = diffuse(color="white")) %&gt;%
  add_object(obj_model(r_obj(),y=-1,x=0.7,material=glossy(color="darkred"),angle=c(0,-20,0))) %&gt;%
  add_object(sphere(x=-0.7,radius=0.5,material=dielectric())) %&gt;% 
  add_object(sphere(y=3,x=-2,z=20,material=light(intensity=600)))
if(run_documentation()) {
render_scene(scene, parallel=TRUE,lookfrom=c(0,2,10),fov=20,clamp_value=10,samples=128)
}

#Zooming out to show the full default scene
if(run_documentation()) {
render_scene(scene, parallel=TRUE,lookfrom=c(0,200,400),clamp_value=10,samples=128)
}
</code></pre>

<hr>
<h2 id='generate_translation_matrix'>Generate Translation Matrix</h2><span id='topic+generate_translation_matrix'></span>

<h3>Description</h3>

<p>Generate Translation Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_translation_matrix(delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_translation_matrix_+3A_delta">delta</code></td>
<td>
<p>Distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>

<hr>
<h2 id='get_saved_keyframes'>Get Saved Keyframes</h2><span id='topic+get_saved_keyframes'></span>

<h3>Description</h3>

<p>Get a dataframe of the saved keyframes (using the interactive renderer) to pass to 'generate_camera_motion()'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_saved_keyframes()
</code></pre>


<h3>Value</h3>

<p>Data frame of keyframes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This will return an empty data frame if no keyframes have been set.
get_saved_keyframes()
</code></pre>

<hr>
<h2 id='get_time'>Get time</h2><span id='topic+get_time'></span>

<h3>Description</h3>

<p>Get time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_time(init = TRUE)
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='glossy'>Glossy Material</h2><span id='topic+glossy'></span>

<h3>Description</h3>

<p>Glossy Material
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glossy(
  color = "white",
  gloss = 1,
  reflectance = 0.05,
  microfacet = "tbr",
  checkercolor = NA,
  checkerperiod = 3,
  noise = 0,
  noisephase = 0,
  noiseintensity = 10,
  noisecolor = "#000000",
  gradient_color = NA,
  gradient_transpose = FALSE,
  gradient_point_start = NA_real_,
  gradient_point_end = NA_real_,
  gradient_type = "hsv",
  image_texture = NA_character_,
  image_repeat = 1,
  alpha_texture = NA_character_,
  bump_texture = NA_character_,
  roughness_texture = NA_character_,
  bump_intensity = 1,
  roughness_range = c(1e-04, 0.2),
  roughness_flip = FALSE,
  importance_sample = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glossy_+3A_color">color</code></td>
<td>
<p>Default 'white'. The color of the surface. Can be either
a hexadecimal code, R color string, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="glossy_+3A_gloss">gloss</code></td>
<td>
<p>Default '0.8'. Gloss of the surface, between '1' (completely glossy) and '0' (rough glossy). 
Can be either a single number, or two numbers indicating an anisotropic distribution of normals (as in 'microfacet()').</p>
</td></tr>
<tr><td><code id="glossy_+3A_reflectance">reflectance</code></td>
<td>
<p>Default '0.03'. The reflectivity of the surface. '1' is a full mirror, '0' is diffuse with a glossy highlight.</p>
</td></tr>
<tr><td><code id="glossy_+3A_microfacet">microfacet</code></td>
<td>
<p>Default 'tbr'.  Type of microfacet distribution. Alternative option 'beckmann'.</p>
</td></tr>
<tr><td><code id="glossy_+3A_checkercolor">checkercolor</code></td>
<td>
<p>Default 'NA'. If not 'NA', determines the secondary color of the checkered surface. 
Can be either a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="glossy_+3A_checkerperiod">checkerperiod</code></td>
<td>
<p>Default '3'. The period of the checker pattern. Increasing this value makes the checker 
pattern bigger, and decreasing it makes it smaller</p>
</td></tr>
<tr><td><code id="glossy_+3A_noise">noise</code></td>
<td>
<p>Default '0'. If not '0', covers the surface in a turbulent marble pattern. This value will determine
the amount of turbulence in the texture.</p>
</td></tr>
<tr><td><code id="glossy_+3A_noisephase">noisephase</code></td>
<td>
<p>Default '0'. The phase of the noise. The noise will repeat at '360'.</p>
</td></tr>
<tr><td><code id="glossy_+3A_noiseintensity">noiseintensity</code></td>
<td>
<p>Default '10'. Intensity of the noise.</p>
</td></tr>
<tr><td><code id="glossy_+3A_noisecolor">noisecolor</code></td>
<td>
<p>Default '#000000'. The secondary color of the noise pattern.
Can be either a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="glossy_+3A_gradient_color">gradient_color</code></td>
<td>
<p>Default 'NA'. If not 'NA', creates a secondary color for a linear gradient 
between the this color and color specified in 'color'. Direction is determined by 'gradient_transpose'.</p>
</td></tr>
<tr><td><code id="glossy_+3A_gradient_transpose">gradient_transpose</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will use the 'v' coordinate texture instead
of the 'u' coordinate texture to map the gradient.</p>
</td></tr>
<tr><td><code id="glossy_+3A_gradient_point_start">gradient_point_start</code></td>
<td>
<p>Default 'NA'. If not 'NA', this changes the behavior from mapping texture coordinates to 
mapping to world space coordinates. This should be a length-3 vector specifying the x,y, and z points where the gradient
begins with value 'color'.</p>
</td></tr>
<tr><td><code id="glossy_+3A_gradient_point_end">gradient_point_end</code></td>
<td>
<p>Default 'NA'. If not 'NA', this changes the behavior from mapping texture coordinates to 
mapping to world space coordinates. This should be a length-3 vector specifying the x,y, and z points where the gradient
begins with value 'gradient_color'.</p>
</td></tr>
<tr><td><code id="glossy_+3A_gradient_type">gradient_type</code></td>
<td>
<p>Default 'hsv'. Colorspace to calculate the gradient. Alternative 'rgb'.</p>
</td></tr>
<tr><td><code id="glossy_+3A_image_texture">image_texture</code></td>
<td>
<p>Default 'NA'. A 3-layer RGB array or filename to be used as the texture on the surface of the object.</p>
</td></tr>
<tr><td><code id="glossy_+3A_image_repeat">image_repeat</code></td>
<td>
<p>Default '1'. Number of times to repeat the image across the surface.
'u' and 'v' repeat amount can be set independently if user passes in a length-2 vector.</p>
</td></tr>
<tr><td><code id="glossy_+3A_alpha_texture">alpha_texture</code></td>
<td>
<p>Default 'NA'. A matrix or filename (specifying a greyscale image) to be used to specify the transparency.</p>
</td></tr>
<tr><td><code id="glossy_+3A_bump_texture">bump_texture</code></td>
<td>
<p>Default 'NA'. A matrix, array, or filename (specifying a greyscale image) to 
be used to specify a bump map for the surface.</p>
</td></tr>
<tr><td><code id="glossy_+3A_roughness_texture">roughness_texture</code></td>
<td>
<p>Default 'NA'. A matrix, array, or filename (specifying a greyscale image) to 
be used to specify a roughness map for the surface.</p>
</td></tr>
<tr><td><code id="glossy_+3A_bump_intensity">bump_intensity</code></td>
<td>
<p>Default '1'. Intensity of the bump map. High values may lead to unphysical results.</p>
</td></tr>
<tr><td><code id="glossy_+3A_roughness_range">roughness_range</code></td>
<td>
<p>Default ' c(0.0001, 0.2)'. This is a length-2 vector that specifies the range of roughness values 
that the 'roughness_texture' can take.</p>
</td></tr>
<tr><td><code id="glossy_+3A_roughness_flip">roughness_flip</code></td>
<td>
<p>Default 'FALSE'. Setting this to 'TRUE' flips the roughness values specified in the 'roughness_texture'
so high values are now low values and vice versa.</p>
</td></tr>
<tr><td><code id="glossy_+3A_importance_sample">importance_sample</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the object will be sampled explicitly during 
the rendering process. If the object is particularly important in contributing to the light paths
in the image (e.g. light sources, refracting glass ball with caustics, metal objects concentrating light),
this will help with the convergence of the image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the glossy material.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a glossy sphere
generate_ground(material=diffuse(sigma=90)) %&gt;%
  add_object(sphere(y=0.2,material=glossy(color="#2b6eff"))) %&gt;% 
  add_object(sphere(y=2.8,material=light())) %&gt;%
  render_scene(parallel=TRUE,clamp_value=10,samples=128,sample_method="sobol_blue")
 }
if(run_documentation()) {
#Change the color of the underlying diffuse layer
generate_ground(material=diffuse(sigma=90)) %&gt;%
  add_object(sphere(y=0.2,x=-2.1,material=glossy(color="#fc3d03"))) %&gt;% 
  add_object(sphere(y=0.2,material=glossy(color="#2b6eff"))) %&gt;% 
  add_object(sphere(y=0.2,x=2.1,material=glossy(color="#2fed4f"))) %&gt;% 
  add_object(sphere(y=8,z=-5,radius=3,material=light(intensity=20))) %&gt;%
  render_scene(parallel=TRUE,clamp_value=10,samples=128,fov=40,sample_method="sobol_blue")
 }
if(run_documentation()) {
#Change the amount of gloss 
generate_ground(material=diffuse(sigma=90)) %&gt;%
  add_object(sphere(y=0.2,x=-2.1,material=glossy(gloss=1,color="#fc3d03"))) %&gt;% 
  add_object(sphere(y=0.2,material=glossy(gloss=0.5,color="#2b6eff"))) %&gt;% 
  add_object(sphere(y=0.2,x=2.1,material=glossy(gloss=0,color="#2fed4f"))) %&gt;% 
  add_object(sphere(y=8,z=-5,radius=3,material=light(intensity=20))) %&gt;%
  render_scene(parallel=TRUE,clamp_value=10,samples=128,fov=40,sample_method="sobol_blue")
 }
if(run_documentation()) {
#Add gloss to a pattern 
generate_ground(material=diffuse(sigma=90)) %&gt;%
  add_object(sphere(y=0.2,x=-2.1,material=glossy(noise=2,noisecolor="black"))) %&gt;% 
  add_object(sphere(y=0.2,material=glossy(color="#ff365a",checkercolor="#2b6eff"))) %&gt;% 
  add_object(sphere(y=0.2,x=2.1,material=glossy(color="blue",gradient_color="#2fed4f"))) %&gt;% 
  add_object(sphere(y=8,z=-5,radius=3,material=light(intensity=20))) %&gt;%
  render_scene(parallel=TRUE,clamp_value=10,samples=128,fov=40,sample_method="sobol_blue")
 }
if(run_documentation()) {
#Add an R and a fill light (this may look familiar)
generate_ground(material=diffuse()) %&gt;%
  add_object(sphere(y=0.2,material=glossy(color="#2b6eff",reflectance=0.05))) %&gt;% 
  add_object(obj_model(r_obj(),z=1,y=-0.05,scale=0.45,material=diffuse())) %&gt;%
  add_object(sphere(y=6,z=1,radius=4,material=light(intensity=3))) %&gt;%
  add_object(sphere(z=15,material=light(intensity=50))) %&gt;%
  render_scene(parallel=TRUE,clamp_value=10,samples=128,sample_method="sobol_blue")
}
</code></pre>

<hr>
<h2 id='group_objects'>Group Objects</h2><span id='topic+group_objects'></span>

<h3>Description</h3>

<p>Group and transform objects together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_objects(
  scene,
  pivot_point = c(0, 0, 0),
  translate = c(0, 0, 0),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  scale = c(1, 1, 1),
  axis_rotation = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_objects_+3A_scene">scene</code></td>
<td>
<p>Tibble of pre-existing object locations and properties to group together.</p>
</td></tr>
<tr><td><code id="group_objects_+3A_pivot_point">pivot_point</code></td>
<td>
<p>Default 'c(0,0,0)'. The point about which to pivot, scale, and move the group.</p>
</td></tr>
<tr><td><code id="group_objects_+3A_translate">translate</code></td>
<td>
<p>Default 'c(0,0,0)'. Vector indicating where to offset the group.</p>
</td></tr>
<tr><td><code id="group_objects_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0,0,0)'. Angle of rotation around the x, y, and z axes, 
applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="group_objects_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1,2,3)'. The order to apply the rotations, 
referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="group_objects_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1,1,1)'. Scaling factor for x, y, and z directions for all objects in group.</p>
</td></tr>
<tr><td><code id="group_objects_+3A_axis_rotation">axis_rotation</code></td>
<td>
<p>Default 'NA'. Provide an axis of rotation and a single angle (via 'angle') of rotation
around that axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of grouped object locations and properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate the ground and add some objects
if(run_documentation()) {
scene = generate_cornell() %&gt;%
        add_object(cube(x=555/2,y=555/8,z=555/2,width=555/4)) %&gt;%
        add_object(cube(x=555/2,y=555/4+555/16,z=555/2,width=555/8))
render_scene(scene,lookfrom=c(278,278,-800),lookat = c(278,278,0), aperture=0,
             samples=128, fov=50, parallel=TRUE, clamp_value=5)
}
if(run_documentation()) {

#Group the entire room and rotate around its center, but keep the cubes in the same place.
scene2 = group_objects(generate_cornell(), 
                       pivot_point=c(555/2,555/2,555/2),
                       angle=c(0,30,0)) %&gt;%
         add_object(cube(x=555/2,y=555/8,z=555/2,width=555/4)) %&gt;%
        add_object(cube(x=555/2,y=555/4+555/16,z=555/2,width=555/8))
                       
render_scene(scene2,lookfrom=c(278,278,-800),lookat = c(278,278,0), aperture=0,
             samples=128, fov=50, parallel=TRUE, clamp_value=5)
}
if(run_documentation()) {
#Now group the cubes instead of the Cornell box, and rotate/translate them together
twocubes = cube(x=555/2,y=555/8,z=555/2,width=555/4) %&gt;%
           add_object(cube(x=555/2, y=555/4 + 555/16, z=555/2, width=555/8))
scene3 = generate_cornell() %&gt;%
         add_object(group_objects(twocubes, translate = c(0,50,0),angle = c(0,45,0), 
         pivot_point = c(555/2,0,555/2)))
         
render_scene(scene3,lookfrom=c(278,278,-800),lookat = c(278,278,0), aperture=0,
             samples=128, fov=50, parallel=TRUE, clamp_value=5)
}
if(run_documentation()) {
#Flatten and stretch the cubes together on two axes
scene4 = generate_cornell() %&gt;%
         add_object(group_objects(twocubes, translate = c(0,-40,0), 
                                  angle = c(0,45,0), scale = c(2,0.5,1), 
                                  pivot_point = c(555/2,0,555/2)))
                                  
render_scene(scene4,lookfrom=c(278,278,-800),lookat = c(278,278,0), aperture=0,
             samples=128, fov=50, parallel=TRUE, clamp_value=5)
}
if(run_documentation()) {
#Add another layer of grouping, including the Cornell box
scene4 %&gt;% 
  group_objects(pivot_point = c(555/2,555/2,555/2),scale=c(1.5,0.5,0.3), angle=c(-20,0,20)) %&gt;% 
  render_scene(lookfrom=c(278,278,-800),lookat = c(278,278,0), aperture=0,
             samples=509, fov=50, parallel=TRUE, clamp_value=5)
}
</code></pre>

<hr>
<h2 id='hair'>Hair Material</h2><span id='topic+hair'></span>

<h3>Description</h3>

<p>Hair Material
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hair(
  pigment = 1.3,
  red_pigment = 0,
  color = NA,
  sigma_a = NA,
  eta = 1.55,
  beta_m = 0.3,
  beta_n = 0.3,
  alpha = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hair_+3A_pigment">pigment</code></td>
<td>
<p>Default '1.3'. Concentration of the eumelanin pigment in the hair. Blonde hair has concentrations around 0.3, brown around 1.3, and black around 8.</p>
</td></tr>
<tr><td><code id="hair_+3A_red_pigment">red_pigment</code></td>
<td>
<p>Default '0'.Concentration of the pheomelanin pigment in the hair. Pheomelanin makes red hair red.</p>
</td></tr>
<tr><td><code id="hair_+3A_color">color</code></td>
<td>
<p>Default 'NA'. Approximate color. Overrides 'pigment'/'redness' arguments.</p>
</td></tr>
<tr><td><code id="hair_+3A_sigma_a">sigma_a</code></td>
<td>
<p>Default 'NA'. Attenuation. Overrides 'color' and 'pigment'/'redness' arguments.</p>
</td></tr>
<tr><td><code id="hair_+3A_eta">eta</code></td>
<td>
<p>Default '1.55'. Index of refraction of the hair medium.</p>
</td></tr>
<tr><td><code id="hair_+3A_beta_m">beta_m</code></td>
<td>
<p>Default '0.3'. Longitudinal roughness of the hair. Should be between 0 and 1. This roughness controls the size and shape of the hair highlight.</p>
</td></tr>
<tr><td><code id="hair_+3A_beta_n">beta_n</code></td>
<td>
<p>Default '0.3'. Azimuthal roughness of the hair. Should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="hair_+3A_alpha">alpha</code></td>
<td>
<p>Default '2'. Angle of scales on the hair surface, in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the hair material.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a hairball
if(run_documentation()) {
#Generate rendom points on a sphere
lengthval = 0.5
theta = acos(2*runif(10000)-1.0);
phi = 2*pi*(runif(10000))
bezier_list = list()

#Grow the hairs
for(i in 1:length(phi)) {
  pointval = c(sin(theta[i]) * sin(phi[i]),
               cos(theta[i]),
               sin(theta[i]) * cos(phi[i]))
  bezier_list[[i]] = bezier_curve(width=0.01, width_end=0.008,
                                  p1 = pointval,
                                  p2 = (1+(lengthval*0.33))*pointval, 
                                  p3 = (1+(lengthval*0.66))*pointval,
                                  p4 = (1+(lengthval)) * pointval,
                                  material=hair(pigment = 0.3, red_pigment = 1.3,
                                                beta_m = 0.3, beta_n= 0.3),
                                  type="flat")
}
hairball = dplyr::bind_rows(bezier_list)

generate_ground(depth=-2,material=diffuse(color="grey20")) %&gt;%
  add_object(sphere()) %&gt;%
  add_object(hairball) %&gt;%
  add_object(sphere(y=20,z=20,radius=5,material=light(color="white",intensity = 100))) %&gt;%
  render_scene(samples=64, lookfrom=c(0,3,10),clamp_value = 10,
               fov=20)
}
if(run_documentation()) {         
               
#Specify the color directly and increase hair roughness
for(i in 1:length(phi)) {
  pointval = c(sin(theta[i]) * sin(phi[i]),
               cos(theta[i]),
               sin(theta[i]) * cos(phi[i]))
  bezier_list[[i]] = bezier_curve(width=0.01, width_end=0.008,
                                  p1 = pointval,
                                  p2 = (1+(lengthval*0.33))*pointval, 
                                  p3 = (1+(lengthval*0.66))*pointval,
                                  p4 = (1+(lengthval)) * pointval,
                                  material=hair(color="purple",
                                                beta_m = 0.5, beta_n= 0.5),
                                  type="flat")
}
hairball = dplyr::bind_rows(bezier_list)
generate_ground(depth=-2,material=diffuse(color="grey20")) %&gt;%
  add_object(sphere()) %&gt;%
  add_object(hairball) %&gt;%
  add_object(sphere(y=20,z=20,radius=5,material=light(color="white",intensity = 100))) %&gt;%
  render_scene(samples=64, lookfrom=c(0,3,10),clamp_value = 10,
               fov=20)
}
</code></pre>

<hr>
<h2 id='init_time'>Print time</h2><span id='topic+init_time'></span>

<h3>Description</h3>

<p>Print time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_time()
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='is_rendering_in_knitr'>Determines if rendering in knitr</h2><span id='topic+is_rendering_in_knitr'></span>

<h3>Description</h3>

<p>Determines if rendering in knitr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rendering_in_knitr()
</code></pre>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='lambertian'>Lambertian Material (deprecated)</h2><span id='topic+lambertian'></span>

<h3>Description</h3>

<p>Lambertian Material (deprecated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambertian(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambertian_+3A_...">...</code></td>
<td>
<p>Arguments to pass to diffuse() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the diffuse material.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Deprecated lambertian material. Will display a warning.
if(run_documentation()) {
scene = generate_cornell() %&gt;%
  add_object(sphere(x=555/2,y=555/2,z=555/2,radius=555/8,material=lambertian()))
  render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=10,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}
</code></pre>

<hr>
<h2 id='lerp'>Lerp</h2><span id='topic+lerp'></span>

<h3>Description</h3>

<p>Lerp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lerp(t, v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lerp_+3A_t">t</code></td>
<td>
<p>Interpolation distance</p>
</td></tr>
<tr><td><code id="lerp_+3A_v1">v1</code></td>
<td>
<p>Value 1</p>
</td></tr>
<tr><td><code id="lerp_+3A_v2">v2</code></td>
<td>
<p>Value 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Linearly interpolated value
</p>

<hr>
<h2 id='light'>Light Material</h2><span id='topic+light'></span>

<h3>Description</h3>

<p>Light Material
</p>


<h3>Usage</h3>

<pre><code class='language-R'>light(
  color = "#ffffff",
  intensity = 10,
  importance_sample = TRUE,
  spotlight_focus = NA,
  spotlight_width = 30,
  spotlight_start_falloff = 15,
  invisible = FALSE,
  image_texture = NA_character_,
  image_repeat = 1,
  gradient_color = NA,
  gradient_transpose = FALSE,
  gradient_point_start = NA,
  gradient_point_end = NA,
  gradient_type = "hsv"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="light_+3A_color">color</code></td>
<td>
<p>Default 'white'. The color of the light Can be either
a hexadecimal code, R color string, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="light_+3A_intensity">intensity</code></td>
<td>
<p>Default '10'. If a positive value, this will turn this object into a light emitting the value specified
in 'color' (ignoring other properties). Higher values will produce a brighter light.</p>
</td></tr>
<tr><td><code id="light_+3A_importance_sample">importance_sample</code></td>
<td>
<p>Default 'TRUE'. Keeping this on for lights improves the convergence of the rendering 
algorithm, in most cases. If the object is particularly important in contributing to the light paths
in the image (e.g. light sources, refracting glass ball with caustics, metal objects concentrating light),
this will help with the convergence of the image.</p>
</td></tr>
<tr><td><code id="light_+3A_spotlight_focus">spotlight_focus</code></td>
<td>
<p>Default 'NA', no spotlight. Otherwise, a length-3 numeric vector specifying
the x/y/z coordinates that the spotlight should be focused on. Only works for spheres and rectangles.</p>
</td></tr>
<tr><td><code id="light_+3A_spotlight_width">spotlight_width</code></td>
<td>
<p>Default '30'. Angular width of the spotlight.</p>
</td></tr>
<tr><td><code id="light_+3A_spotlight_start_falloff">spotlight_start_falloff</code></td>
<td>
<p>Default '15'. Angle at which the light starts fading in intensity.</p>
</td></tr>
<tr><td><code id="light_+3A_invisible">invisible</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the light itself will be invisible.</p>
</td></tr>
<tr><td><code id="light_+3A_image_texture">image_texture</code></td>
<td>
<p>Default 'NA'. A 3-layer RGB array or filename to be used as the texture on the surface of the object.</p>
</td></tr>
<tr><td><code id="light_+3A_image_repeat">image_repeat</code></td>
<td>
<p>Default '1'. Number of times to repeat the image across the surface.
'u' and 'v' repeat amount can be set independently if user passes in a length-2 vector.</p>
</td></tr>
<tr><td><code id="light_+3A_gradient_color">gradient_color</code></td>
<td>
<p>Default 'NA'. If not 'NA', creates a secondary color for a linear gradient 
between the this color and color specified in 'color'. Direction is determined by 'gradient_transpose'.</p>
</td></tr>
<tr><td><code id="light_+3A_gradient_transpose">gradient_transpose</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will use the 'v' coordinate texture instead
of the 'u' coordinate texture to map the gradient.</p>
</td></tr>
<tr><td><code id="light_+3A_gradient_point_start">gradient_point_start</code></td>
<td>
<p>Default 'NA'. If not 'NA', this changes the behavior from mapping texture coordinates to 
mapping to world space coordinates. This should be a length-3 vector specifying the x,y, and z points where the gradient
begins with value 'color'.</p>
</td></tr>
<tr><td><code id="light_+3A_gradient_point_end">gradient_point_end</code></td>
<td>
<p>Default 'NA'. If not 'NA', this changes the behavior from mapping texture coordinates to 
mapping to world space coordinates. This should be a length-3 vector specifying the x,y, and z points where the gradient
begins with value 'gradient_color'.</p>
</td></tr>
<tr><td><code id="light_+3A_gradient_type">gradient_type</code></td>
<td>
<p>Default 'hsv'. Colorspace to calculate the gradient. Alternative 'rgb'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the light material.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate the cornell box without a light and add a single white sphere to the center
scene = generate_cornell(light=FALSE) %&gt;%
  add_object(sphere(x=555/2,y=555/2,z=555/2,radius=555/8,material=light()))
if(run_documentation()) {
render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}

#Remove the light for direct camera rays, but keep the lighting
scene = generate_cornell(light=FALSE) %&gt;%
  add_object(sphere(x=555/2,y=555/2,z=555/2,radius=555/8,
             material=light(intensity=15,invisible=TRUE)))
if(run_documentation()) {
render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}

#All gather around the orb
scene = generate_ground(material = diffuse(checkercolor="grey50")) %&gt;%
  add_object(sphere(radius=0.5,material=light(intensity=5,color="red"))) %&gt;%
  add_object(obj_model(r_obj(), z=-3,x=-1.5,y=-1, angle=c(0,45,0))) %&gt;%
  add_object(pig(scale=0.3, x=1.5,z=-2,y=-1.5,angle=c(0,-135,0)))
if(run_documentation()) {
render_scene(scene, samples=128, parallel=TRUE, clamp_value=10)
}
</code></pre>

<hr>
<h2 id='mesh3d_model'>'mesh3d' model</h2><span id='topic+mesh3d_model'></span>

<h3>Description</h3>

<p>Load an 'mesh3d' (or 'shapelist3d') object, as specified in the 'rgl' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh3d_model(
  mesh,
  x = 0,
  y = 0,
  z = 0,
  swap_yz = FALSE,
  reverse = FALSE,
  scale_mesh = 1,
  verbose = FALSE,
  override_material = FALSE,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh3d_model_+3A_mesh">mesh</code></td>
<td>
<p>A 'mesh3d' or 'shapelist3d' object. Pulls the vertex, index, texture coordinates, 
normals, and material information. If the material references an image texture, the 
'mesh$material$texture' argument should be set to the image filename. The 'mesh3d' format
only supports one image texture per mesh. All quads will be triangulated.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_swap_yz">swap_yz</code></td>
<td>
<p>Default 'FALSE'. Swap the Y and Z coordinates.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_reverse">reverse</code></td>
<td>
<p>Default 'FALSE'. Reverse the orientation of the indices, flipping their normals.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_scale_mesh">scale_mesh</code></td>
<td>
<p>Default '1'. Amount to scale the size of the mesh in all directions.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_verbose">verbose</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', prints information about the mesh to the console.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_override_material">override_material</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', overrides the material specified in the 
'mesh3d' object with the one specified in 'material'.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="mesh3d_model_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the mesh3d model in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load a mesh3d object (from the Rvcg) and render it:
if(length(find.package("Rcvg", quiet=TRUE)) &gt; 0) {
  library(Rvcg)
  data(humface)
  
  generate_studio() %&gt;% 
    add_object(mesh3d_model(humface,y=-0.3,x=0,z=0,
                          material=glossy(color="dodgerblue4"), scale_mesh = 1/70)) %&gt;%
    add_object(sphere(y=5,x=5,z=5,material=light(intensity=50))) %&gt;% 
    render_scene(samples=128,width=800,height=800,
                 lookat = c(0,0.5,1), aperture=0.0)
}
</code></pre>

<hr>
<h2 id='metal'>Metallic Material</h2><span id='topic+metal'></span>

<h3>Description</h3>

<p>Metallic Material
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metal(
  color = "#ffffff",
  eta = 0,
  kappa = 0,
  fuzz = 0,
  checkercolor = NA,
  checkerperiod = 3,
  noise = 0,
  noisephase = 0,
  noiseintensity = 10,
  noisecolor = "#000000",
  gradient_color = NA,
  gradient_transpose = FALSE,
  gradient_point_start = NA,
  gradient_point_end = NA,
  gradient_type = "hsv",
  image_texture = NA_character_,
  image_repeat = 1,
  alpha_texture = NA,
  bump_texture = NA,
  bump_intensity = 1,
  importance_sample = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metal_+3A_color">color</code></td>
<td>
<p>Default 'white'. The color of the sphere. Can be either
a hexadecimal code, R color string, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="metal_+3A_eta">eta</code></td>
<td>
<p>Default '0'. Wavelength dependent refractivity of the material (red, green, and blue channels).
If single number, will be repeated across all three channels.</p>
</td></tr>
<tr><td><code id="metal_+3A_kappa">kappa</code></td>
<td>
<p>Default '0'. Wavelength dependent absorption of the material (red, green, and blue channels).
If single number, will be repeated across all three channels.</p>
</td></tr>
<tr><td><code id="metal_+3A_fuzz">fuzz</code></td>
<td>
<p>Default '0'. Deprecated&ndash;Use the microfacet material instead, as it is designed for rough metals. 
The roughness of the metallic surface. Maximum '1'.</p>
</td></tr>
<tr><td><code id="metal_+3A_checkercolor">checkercolor</code></td>
<td>
<p>Default 'NA'. If not 'NA', determines the secondary color of the checkered surface. 
Can be either a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="metal_+3A_checkerperiod">checkerperiod</code></td>
<td>
<p>Default '3'. The period of the checker pattern. Increasing this value makes the checker 
pattern bigger, and decreasing it makes it smaller</p>
</td></tr>
<tr><td><code id="metal_+3A_noise">noise</code></td>
<td>
<p>Default '0'. If not '0', covers the surface in a turbulent marble pattern. This value will determine
the amount of turbulence in the texture.</p>
</td></tr>
<tr><td><code id="metal_+3A_noisephase">noisephase</code></td>
<td>
<p>Default '0'. The phase of the noise. The noise will repeat at '360'.</p>
</td></tr>
<tr><td><code id="metal_+3A_noiseintensity">noiseintensity</code></td>
<td>
<p>Default '10'. Intensity of the noise.</p>
</td></tr>
<tr><td><code id="metal_+3A_noisecolor">noisecolor</code></td>
<td>
<p>Default '#000000'. The secondary color of the noise pattern.
Can be either a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="metal_+3A_gradient_color">gradient_color</code></td>
<td>
<p>Default 'NA'. If not 'NA', creates a secondary color for a linear gradient 
between the this color and color specified in 'color'. Direction is determined by 'gradient_transpose'.</p>
</td></tr>
<tr><td><code id="metal_+3A_gradient_transpose">gradient_transpose</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will use the 'v' coordinate texture instead
of the 'u' coordinate texture to map the gradient.</p>
</td></tr>
<tr><td><code id="metal_+3A_gradient_point_start">gradient_point_start</code></td>
<td>
<p>Default 'NA'. If not 'NA', this changes the behavior from mapping texture coordinates to 
mapping to world space coordinates. This should be a length-3 vector specifying the x,y, and z points where the gradient
begins with value 'color'.</p>
</td></tr>
<tr><td><code id="metal_+3A_gradient_point_end">gradient_point_end</code></td>
<td>
<p>Default 'NA'. If not 'NA', this changes the behavior from mapping texture coordinates to 
mapping to world space coordinates. This should be a length-3 vector specifying the x,y, and z points where the gradient
begins with value 'gradient_color'.</p>
</td></tr>
<tr><td><code id="metal_+3A_gradient_type">gradient_type</code></td>
<td>
<p>Default 'hsv'. Colorspace to calculate the gradient. Alternative 'rgb'.</p>
</td></tr>
<tr><td><code id="metal_+3A_image_texture">image_texture</code></td>
<td>
<p>Default 'NA'. A 3-layer RGB array or filename to be used as the texture on the surface of the object.</p>
</td></tr>
<tr><td><code id="metal_+3A_image_repeat">image_repeat</code></td>
<td>
<p>Default '1'. Number of times to repeat the image across the surface.
'u' and 'v' repeat amount can be set independently if user passes in a length-2 vector.</p>
</td></tr>
<tr><td><code id="metal_+3A_alpha_texture">alpha_texture</code></td>
<td>
<p>Default 'NA'. A matrix or filename (specifying a greyscale image) to be used to specify the transparency.</p>
</td></tr>
<tr><td><code id="metal_+3A_bump_texture">bump_texture</code></td>
<td>
<p>Default 'NA'. A matrix, array, or filename (specifying a greyscale image) to 
be used to specify a bump map for the surface.</p>
</td></tr>
<tr><td><code id="metal_+3A_bump_intensity">bump_intensity</code></td>
<td>
<p>Default '1'. Intensity of the bump map. High values may lead to unphysical results.</p>
</td></tr>
<tr><td><code id="metal_+3A_importance_sample">importance_sample</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the object will be sampled explicitly during 
the rendering process. If the object is particularly important in contributing to the light paths
in the image (e.g. light sources, refracting glass ball with caustics, metal objects concentrating light),
this will help with the convergence of the image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the metallic material.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate the cornell box with a single chrome sphere in the center. For other metals,
# See the website refractiveindex.info for eta and k data, use wavelengths 5
# 80nm (R), 530nm (G), and 430nm (B).
scene = generate_cornell() %&gt;%
  add_object(sphere(x=555/2,y=555/2,z=555/2,radius=555/8,
  material=metal(eta=c(3.2176,3.1029,2.1839), k = c(3.3018,3.33,3.0339))))
if(run_documentation()) {
render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=50,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}
#Add an aluminum rotated shiny metal block     
scene = scene %&gt;%
  add_object(cube(x=380,y=150/2,z=200,xwidth=150,ywidth=150,zwidth=150,
  material = metal(eta = c(1.07,0.8946,0.523), k = c(6.7144,6.188,4.95)),angle=c(0,45,0)))
if(run_documentation()) {
render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}
#Add a copper metal cube      
scene = scene %&gt;%
  add_object(cube(x=150,y=150/2,z=300,xwidth=150,ywidth=150,zwidth=150,
                  material = metal(eta = c(0.497,0.8231,1.338), 
                                   k = c(2.898,2.476,2.298)),
                  angle=c(0,-30,0)))
if(run_documentation()) {
render_scene(scene, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}

#Finally, let's add a lead pipe
scene2 = scene %&gt;%
  add_object(cylinder(x=450,y=200,z=400,length=400,radius=30,
                  material = metal(eta = c(1.44,1.78,1.9), 
                                   k = c(3.18,3.36,3.43)),
                  angle=c(0,-30,0)))
if(run_documentation()) {
render_scene(scene2, lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, ambient_light=FALSE, parallel=TRUE)
}
</code></pre>

<hr>
<h2 id='microfacet'>Microfacet Material</h2><span id='topic+microfacet'></span>

<h3>Description</h3>

<p>Microfacet Material
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microfacet(
  color = "white",
  roughness = 1e-04,
  transmission = FALSE,
  eta = 0,
  kappa = 0,
  microfacet = "tbr",
  checkercolor = NA,
  checkerperiod = 3,
  noise = 0,
  noisephase = 0,
  noiseintensity = 10,
  noisecolor = "#000000",
  gradient_color = NA,
  gradient_transpose = FALSE,
  gradient_point_start = NA_real_,
  gradient_point_end = NA_real_,
  gradient_type = "hsv",
  image_texture = NA_character_,
  image_repeat = 1,
  alpha_texture = NA_character_,
  bump_texture = NA_character_,
  bump_intensity = 1,
  roughness_texture = NA_character_,
  roughness_range = c(1e-04, 0.2),
  roughness_flip = FALSE,
  importance_sample = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="microfacet_+3A_color">color</code></td>
<td>
<p>Default 'white'. The color of the surface. Can be either
a hexadecimal code, R color string, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_roughness">roughness</code></td>
<td>
<p>Default '0.0001'. Roughness of the surface, between '0' (smooth) and '1' (diffuse). 
Can be either a single number, or two numbers indicating an anisotropic distribution of normals. '0' is a smooth surface, while
'1' is extremely rough. This can be used to create a wide-variety of materials (e.g. '0-0.01' is specular 
metal, '0.02'-'0.1' is brushed metal, '0.1'-'0.3' is a rough metallic surface , '0.3'-'0.5' is diffuse, and 
above that is a rough satin-like material). 
Two numbers will specify the x and y roughness separately (e.g. 'roughness = c(0.01, 0.001)' gives an 
etched metal effect). If '0', this defaults to the 'metal()' material for faster evaluation.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_transmission">transmission</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this material will be a rough dielectric instead of a rough metallic surface.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_eta">eta</code></td>
<td>
<p>Default '0'. Wavelength dependent refractivity of the material (red, green, and blue channels).
If single number, will be repeated across all three channels. If 'transmission = TRUE', this is a single value representing the
index of refraction of the material.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_kappa">kappa</code></td>
<td>
<p>Default '0'. Wavelength dependent absorption of the material (red, green, and blue channels).
If single number, will be repeated across all three channels. If 'transmission = TRUE', this length-3 vector specifies 
the attenuation of the dielectric (analogous to the dielectric 'attenuation' argument).</p>
</td></tr>
<tr><td><code id="microfacet_+3A_microfacet">microfacet</code></td>
<td>
<p>Default 'tbr'.  Type of microfacet distribution. Alternative option 'beckmann'.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_checkercolor">checkercolor</code></td>
<td>
<p>Default 'NA'. If not 'NA', determines the secondary color of the checkered surface. 
Can be either a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_checkerperiod">checkerperiod</code></td>
<td>
<p>Default '3'. The period of the checker pattern. Increasing this value makes the checker 
pattern bigger, and decreasing it makes it smaller</p>
</td></tr>
<tr><td><code id="microfacet_+3A_noise">noise</code></td>
<td>
<p>Default '0'. If not '0', covers the surface in a turbulent marble pattern. This value will determine
the amount of turbulence in the texture.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_noisephase">noisephase</code></td>
<td>
<p>Default '0'. The phase of the noise. The noise will repeat at '360'.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_noiseintensity">noiseintensity</code></td>
<td>
<p>Default '10'. Intensity of the noise.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_noisecolor">noisecolor</code></td>
<td>
<p>Default '#000000'. The secondary color of the noise pattern.
Can be either a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_gradient_color">gradient_color</code></td>
<td>
<p>Default 'NA'. If not 'NA', creates a secondary color for a linear gradient 
between the this color and color specified in 'color'. Direction is determined by 'gradient_transpose'.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_gradient_transpose">gradient_transpose</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will use the 'v' coordinate texture instead
of the 'u' coordinate texture to map the gradient.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_gradient_point_start">gradient_point_start</code></td>
<td>
<p>Default 'NA'. If not 'NA', this changes the behavior from mapping texture coordinates to 
mapping to world space coordinates. This should be a length-3 vector specifying the x,y, and z points where the gradient
begins with value 'color'.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_gradient_point_end">gradient_point_end</code></td>
<td>
<p>Default 'NA'. If not 'NA', this changes the behavior from mapping texture coordinates to 
mapping to world space coordinates. This should be a length-3 vector specifying the x,y, and z points where the gradient
begins with value 'gradient_color'.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_gradient_type">gradient_type</code></td>
<td>
<p>Default 'hsv'. Colorspace to calculate the gradient. Alternative 'rgb'.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_image_texture">image_texture</code></td>
<td>
<p>Default 'NA'. A 3-layer RGB array or filename to be used as the texture on the surface of the object.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_image_repeat">image_repeat</code></td>
<td>
<p>Default '1'. Number of times to repeat the image across the surface.
'u' and 'v' repeat amount can be set independently if user passes in a length-2 vector.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_alpha_texture">alpha_texture</code></td>
<td>
<p>Default 'NA'. A matrix or filename (specifying a greyscale image) to be used to specify the transparency.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_bump_texture">bump_texture</code></td>
<td>
<p>Default 'NA'. A matrix, array, or filename (specifying a greyscale image) to 
be used to specify a bump map for the surface.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_bump_intensity">bump_intensity</code></td>
<td>
<p>Default '1'. Intensity of the bump map. High values may lead to unphysical results.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_roughness_texture">roughness_texture</code></td>
<td>
<p>Default 'NA'. A matrix, array, or filename (specifying a greyscale image) to 
be used to specify a roughness map for the surface.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_roughness_range">roughness_range</code></td>
<td>
<p>Default ' c(0.0001, 0.2)'. This is a length-2 vector that specifies the range of roughness values 
that the 'roughness_texture' can take.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_roughness_flip">roughness_flip</code></td>
<td>
<p>Default 'FALSE'. Setting this to 'TRUE' flips the roughness values specified in the 'roughness_texture'
so high values are now low values and vice versa.</p>
</td></tr>
<tr><td><code id="microfacet_+3A_importance_sample">importance_sample</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the object will be sampled explicitly during 
the rendering process. If the object is particularly important in contributing to the light paths
in the image (e.g. light sources, refracting glass ball with caustics, metal objects concentrating light),
this will help with the convergence of the image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the microfacet material.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a golden egg, using eta and kappa taken from physical measurements
# See the website refractiveindex.info for eta and k data, use 
# wavelengths 580nm (R), 530nm (G), and 430nm (B).
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(ellipsoid(x=555/2,555/2,y=150, a=100,b=150,c=100,
             material=microfacet(roughness=0.1,
                                 eta=c(0.216,0.42833,1.3184), kappa=c(3.239,2.4599,1.8661)))) %&gt;% 
 render_scene(lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, parallel=TRUE,clamp_value=10)
 }
if(run_documentation()) {
#Make the roughness anisotropic (either horizontal or vertical), adding an extra light in front
#to show off the different microfacet orientations
generate_cornell() %&gt;%
  add_object(sphere(x=555/2,z=50,y=75,radius=20,material=light())) %&gt;% 
  add_object(ellipsoid(x=555-150,555/2,y=150, a=100,b=150,c=100,
             material=microfacet(roughness=c(0.3,0.1),
                                 eta=c(0.216,0.42833,1.3184), kappa=c(3.239,2.4599,1.8661)))) %&gt;% 
 add_object(ellipsoid(x=150,555/2,y=150, a=100,b=150,c=100,
             material=microfacet(roughness=c(0.1,0.3),
                                 eta=c(0.216,0.42833,1.3184), kappa=c(3.239,2.4599,1.8661)))) %&gt;%  
 render_scene(lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40,  parallel=TRUE,clamp_value=10)
}
if(run_documentation()) {
#Render a rough silver R with a smaller golden egg in front
generate_cornell() %&gt;%
  add_object(obj_model(r_obj(),x=555/2,z=350,y=0, scale_obj = 200, angle=c(0,200,0),
             material=microfacet(roughness=0.2,
                                 eta=c(1.1583,0.9302,0.5996), kappa=c(6.9650,6.396,5.332)))) %&gt;% 
 add_object(ellipsoid(x=200,z=200,y=80, a=50,b=80,c=50,
             material=microfacet(roughness=0.1,
                                 eta=c(0.216,0.42833,1.3184), kappa=c(3.239,2.4599,1.8661)))) %&gt;% 
 render_scene(lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, parallel=TRUE,clamp_value=10)
 }
if(run_documentation()) {
#Increase the roughness
generate_cornell() %&gt;%
  add_object(obj_model(r_obj(),x=555/2,z=350,y=0, scale_obj = 200, angle=c(0,200,0),
             material=microfacet(roughness=0.5,
                                 eta=c(1.1583,0.9302,0.5996), kappa=c(6.9650,6.396,5.332)))) %&gt;% 
 add_object(ellipsoid(x=200,z=200,y=80, a=50,b=80,c=50,
             material=microfacet(roughness=0.3,
                                 eta=c(0.216,0.42833,1.3184), kappa=c(3.239,2.4599,1.8661)))) %&gt;% 
 render_scene(lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, parallel=TRUE,clamp_value=10)
 }
if(run_documentation()) {
 #Use transmission for a rough dielectric
generate_cornell() %&gt;%
  add_object(obj_model(r_obj(),x=555/2,z=350,y=0, scale_obj = 200, angle=c(0,200,0),
             material=microfacet(roughness=0.3, transmission=T, eta=1.6))) %&gt;% 
 add_object(ellipsoid(x=200,z=200,y=80, a=50,b=80,c=50,
             material=microfacet(roughness=0.3, transmission=T, eta=1.6))) %&gt;% 
 render_scene(lookfrom=c(278,278,-800),lookat = c(278,278,0), samples=128,
             aperture=0, fov=40, parallel=TRUE,clamp_value=10, min_variance=1e-6)
}
</code></pre>

<hr>
<h2 id='new_tibble_row'>New Tibble Row</h2><span id='topic+new_tibble_row'></span>

<h3>Description</h3>

<p>Creates a row of a tibble, without the parsing and checks in tibble::new_tibble(). Internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_tibble_row(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_tibble_row_+3A_x">x</code></td>
<td>
<p>Named list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#none
</code></pre>

<hr>
<h2 id='obj_model'>'obj' File Object</h2><span id='topic+obj_model'></span>

<h3>Description</h3>

<p>Load an obj file via a filepath. Currently only supports the diffuse texture with the 'texture' argument. 
Note: light importance sampling currently not supported for this shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_model(
  filename,
  x = 0,
  y = 0,
  z = 0,
  scale_obj = 1,
  load_material = TRUE,
  load_textures = TRUE,
  load_normals = TRUE,
  vertex_colors = FALSE,
  calculate_consistent_normals = TRUE,
  importance_sample_lights = TRUE,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj_model_+3A_filename">filename</code></td>
<td>
<p>Filename and path to the &lsquo;obj' file. Can also be a 'txt' file, if it&rsquo;s in the correct 'obj' internally.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_scale_obj">scale_obj</code></td>
<td>
<p>Default '1'. Amount to scale the model. Use this to scale the object up or down on all axes, as it is
more robust to numerical precision errors than the generic scale option.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_load_material">load_material</code></td>
<td>
<p>Default 'TRUE'. Whether to load the obj file material (MTL file). If material for faces
aren't specified, the default material will be used (specified by the user in 'material').</p>
</td></tr>
<tr><td><code id="obj_model_+3A_load_textures">load_textures</code></td>
<td>
<p>Default 'TRUE'. If 'load_material = TRUE', whether to load textures in the MTL file (versus
just using the colors specified for each material).</p>
</td></tr>
<tr><td><code id="obj_model_+3A_load_normals">load_normals</code></td>
<td>
<p>Default 'TRUE'. Whether to load the vertex normals if they exist in the OBJ file.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_vertex_colors">vertex_colors</code></td>
<td>
<p>Default 'FALSE'. Set to 'TRUE' if the OBJ file has vertex colors to apply them
to the model.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_calculate_consistent_normals">calculate_consistent_normals</code></td>
<td>
<p>Default 'TRUE'. Whether to calculate consistent vertex normals to prevent energy 
loss at edges.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_importance_sample_lights">importance_sample_lights</code></td>
<td>
<p>Default 'TRUE'. Whether to importance sample lights specified in the OBJ material
(objects with a non-zero Ke MTL material).</p>
</td></tr>
<tr><td><code id="obj_model_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="obj_model_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the obj model in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the included example R object file, by calling the r_obj() function. This
#returns the local file path to the `r.txt` obj file. The file extension is "txt" 
#due to package constraints, but the file contents are identical and it does not 
#affect the function.

if(run_documentation()) {
generate_ground(material = diffuse(checkercolor = "grey50")) %&gt;%
  add_object(obj_model(y = -0.8, filename = r_obj(),
                       material = microfacet(color = "gold", roughness = 0.05))) %&gt;%
  add_object(obj_model(x = 1.8, y = -0.8, filename = r_obj(), 
                       material = diffuse(color = "dodgerblue"))) %&gt;%
  add_object(obj_model(x = -1.8, y = -0.8, filename = r_obj() , 
                       material = dielectric(attenuation = c(1,0.3,1)*2))) %&gt;%
  add_object(sphere(z = 20, x = 20, y = 20, radius = 10,
                    material = light(intensity = 10))) %&gt;%
  render_scene(parallel = TRUE, samples = 128, aperture = 0.05, 
               fov = 32, lookfrom = c(0, 2, 10))

}

#Use scale_obj to make objects bigger--this is more robust than the generic scale argument.
if(run_documentation()) {
generate_ground(material = diffuse(checkercolor = "grey50")) %&gt;%
  add_object(obj_model(y = -0.8, filename = r_obj(), scale_obj = 2,
                       material = diffuse(noise = TRUE, noiseintensity = 10,noisephase=45))) %&gt;%
  add_object(sphere(z = 20, x = 20, y = 20, radius = 10,
                    material = light(intensity = 10))) %&gt;%
  render_scene(parallel = TRUE, samples = 128, ambient = TRUE, 
               backgroundhigh="blue", backgroundlow="red",
               aperture = 0.05, fov = 32, lookfrom = c(0, 2, 10),
               lookat = c(0,1,0)) 
}
</code></pre>

<hr>
<h2 id='path'>Path Object</h2><span id='topic+path'></span>

<h3>Description</h3>

<p>Either a closed or open path made up of bezier curves that go through the specified points 
(with continuous first and second derivatives), or straight line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path(
  points,
  x = 0,
  y = 0,
  z = 0,
  closed = FALSE,
  closed_smooth = TRUE,
  straight = FALSE,
  precomputed_control_points = FALSE,
  width = 0.1,
  width_end = NA,
  u_min = 0,
  u_max = 1,
  type = "cylinder",
  normal = c(0, 0, -1),
  normal_end = NA,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_+3A_points">points</code></td>
<td>
<p>Either a list of length-3 numeric vectors or 3-column matrix/data.frame specifying
the x/y/z points that the path should go through.</p>
</td></tr>
<tr><td><code id="path_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate offset for the path.</p>
</td></tr>
<tr><td><code id="path_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate offset for the path.</p>
</td></tr>
<tr><td><code id="path_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate offset for the path.</p>
</td></tr>
<tr><td><code id="path_+3A_closed">closed</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the path will be closed by smoothly connecting the first
and last points.</p>
</td></tr>
<tr><td><code id="path_+3A_closed_smooth">closed_smooth</code></td>
<td>
<p>Default 'TRUE'. If 'closed = TRUE', this will ensure C2 (second derivative) 
continuity between the ends. If 'closed = FALSE', the curve will only have C1 (first derivative)
continuity between the ends.</p>
</td></tr>
<tr><td><code id="path_+3A_straight">straight</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', straight lines will be used to connect the points instead
of bezier curves.</p>
</td></tr>
<tr><td><code id="path_+3A_precomputed_control_points">precomputed_control_points</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', 'points' argument will expect
a list of control points calculated with the internal rayrender function 'rayrender:::calculate_control_points()'.</p>
</td></tr>
<tr><td><code id="path_+3A_width">width</code></td>
<td>
<p>Default '0.1'. Curve width.</p>
</td></tr>
<tr><td><code id="path_+3A_width_end">width_end</code></td>
<td>
<p>Default 'NA'. Width at end of path. Same as 'width', unless specified.</p>
</td></tr>
<tr><td><code id="path_+3A_u_min">u_min</code></td>
<td>
<p>Default '0'. Minimum parametric coordinate for the path.</p>
</td></tr>
<tr><td><code id="path_+3A_u_max">u_max</code></td>
<td>
<p>Default '1'. Maximum parametric coordinate for the path.</p>
</td></tr>
<tr><td><code id="path_+3A_type">type</code></td>
<td>
<p>Default 'cylinder'. Other options are 'flat' and 'ribbon'.</p>
</td></tr>
<tr><td><code id="path_+3A_normal">normal</code></td>
<td>
<p>Default 'c(0,0,-1)'. Orientation surface normal for the start of ribbon curves.</p>
</td></tr>
<tr><td><code id="path_+3A_normal_end">normal_end</code></td>
<td>
<p>Default 'NA'. Orientation surface normal for the start of ribbon curves. If not
specified, same as 'normal'.</p>
</td></tr>
<tr><td><code id="path_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="path_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="path_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="path_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="path_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the cube in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
#Generate a wavy line, showing the line goes through the specified points:
wave = list(c(-2,1,0),c(-1,-1,0),c(0,1,0),c(1,-1,0),c(2,1,0))
point_mat = glossy(color="green")
generate_studio(depth=-1.5) %&gt;% 
  add_object(path(points = wave,material=glossy(color="red"))) %&gt;% 
  add_object(sphere(x=-2,y=1,radius=0.1,material=point_mat)) %&gt;% 
  add_object(sphere(x=-1,y=-1,radius=0.1,material=point_mat)) %&gt;% 
  add_object(sphere(x=0,y=1,radius=0.1,material=point_mat)) %&gt;% 
  add_object(sphere(x=1,y=-1,radius=0.1,material=point_mat)) %&gt;% 
  add_object(sphere(x=2,y=1,radius=0.1,material=point_mat)) %&gt;% 
  add_object(sphere(z=5,x=5,y=5,radius=2,material=light(intensity=15))) %&gt;% 
  render_scene(samples=128, clamp_value=10,fov=30)
}
if(run_documentation()) {
#Here we use straight lines by setting `straight = TRUE`:
generate_studio(depth=-1.5) %&gt;% 
  add_object(path(points = wave,straight = TRUE, material=glossy(color="red"))) %&gt;% 
  add_object(sphere(z=5,x=5,y=5,radius=2,material=light(intensity=15))) %&gt;% 
  render_scene(samples=128, clamp_value=10,fov=30)
}
if(run_documentation()) {
#We can also pass a matrix of values, specifying the x/y/z coordinates. Here,
#we'll create a random curve:
set.seed(21)
random_mat = matrix(runif(3*9)*2-1, ncol=3)
generate_studio(depth=-1.5) %&gt;% 
  add_object(path(points=random_mat, material=glossy(color="red"))) %&gt;% 
  add_object(sphere(y=5,radius=1,material=light(intensity=30))) %&gt;% 
  render_scene(samples=128, clamp_value=10)
}
if(run_documentation()) {
#We can ensure the curve is closed by setting `closed = TRUE`
generate_studio(depth=-1.5) %&gt;% 
  add_object(path(points=random_mat, closed = TRUE, material=glossy(color="red"))) %&gt;% 
  add_object(sphere(y=5,radius=1,material=light(intensity=30))) %&gt;% 
  render_scene(samples=128, clamp_value=10)
}
if(run_documentation()) {
#Finally, let's render a pretzel to show how you can render just a subset of the curve:
pretzel = list(c(-0.8,-0.5,0.1),c(0,-0.2,-0.1),c(0,0.3,0.1),c(-0.5,0.5,0.1), c(-0.6,-0.5,-0.1),
               c(0,-0.8,-0.1),
               c(0.6,-0.5,-0.1),c(0.5,0.5,-0.1), c(0,0.3,-0.1),c(-0,-0.2,0.1), c(0.8,-0.5,0.1))
               
#Render the full pretzel:
generate_studio(depth = -1.1) %&gt;% 
  add_object(path(pretzel, width=0.17,  material = glossy(color="#db5b00"))) %&gt;% 
  add_object(sphere(y=5,x=2,z=4,material=light(intensity=20,spotlight_focus = c(0,0,0)))) %&gt;% 
  render_scene(samples=128, clamp_value=10)
}
if(run_documentation()) {
#Here, we'll render only the first third of the pretzel by setting `u_max = 0.33`
generate_studio(depth = -1.1) %&gt;% 
  add_object(path(pretzel, width=0.17, u_max=0.33, material = glossy(color="#db5b00"))) %&gt;% 
  add_object(sphere(y=5,x=2,z=4,material=light(intensity=20,spotlight_focus = c(0,0,0)))) %&gt;% 
  render_scene(samples=128, clamp_value=10)
}
if(run_documentation()) {
#Here's the last third, by setting `u_min = 0.66`
generate_studio(depth = -1.1) %&gt;% 
  add_object(path(pretzel, width=0.17, u_min=0.66, material = glossy(color="#db5b00"))) %&gt;% 
  add_object(sphere(y=5,x=2,z=4,material=light(intensity=20,spotlight_focus = c(0,0,0)))) %&gt;% 
  render_scene(samples=128, clamp_value=10)
}
if(run_documentation()) {
#Here's the full pretzel, decomposed into thirds using the u_min and u_max coordinates
generate_studio(depth = -1.1) %&gt;% 
  add_object(path(pretzel, width=0.17, u_max=0.33, x = -0.8, y =0.6,
                  material = glossy(color="#db5b00"))) %&gt;% 
  add_object(path(pretzel, width=0.17, u_min=0.66, x = 0.8, y =0.6,
                  material = glossy(color="#db5b00"))) %&gt;% 
  add_object(path(pretzel, width=0.17, u_min=0.33, u_max=0.66, x=0,
                  material = glossy(color="#db5b00"))) %&gt;% 
  add_object(sphere(y=5,x=2,z=4,material=light(intensity=20,spotlight_focus = c(0,0,0)))) %&gt;% 
  render_scene(samples=128, clamp_value=10, lookfrom=c(0,3,10))
}
</code></pre>

<hr>
<h2 id='pig'>Pig Object</h2><span id='topic+pig'></span>

<h3>Description</h3>

<p>Pig Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pig(
  x = 0,
  y = 0,
  z = 0,
  emotion = "neutral",
  spider = FALSE,
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  scale = c(1, 1, 1),
  diffuse_sigma = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pig_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the pig.</p>
</td></tr>
<tr><td><code id="pig_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate of the center of the pig.</p>
</td></tr>
<tr><td><code id="pig_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the pig.</p>
</td></tr>
<tr><td><code id="pig_+3A_emotion">emotion</code></td>
<td>
<p>Default 'neutral'. Other options include 'skeptical', 'worried', and 'angry'.</p>
</td></tr>
<tr><td><code id="pig_+3A_spider">spider</code></td>
<td>
<p>Default 'FALSE'. Spiderpig.</p>
</td></tr>
<tr><td><code id="pig_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="pig_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="pig_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.</p>
</td></tr>
<tr><td><code id="pig_+3A_diffuse_sigma">diffuse_sigma</code></td>
<td>
<p>Default &lsquo;0'. Controls the Oren-Nayar sigma parameter for the pig&rsquo;s diffuse material.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the pig in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a pig in the cornell box.

if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(pig(x=555/2,z=555/2,y=120,
  scale=c(80,80,80), angle = c(0,135,0))) %&gt;%
  render_scene(parallel=TRUE, samples=128,clamp_value=10)
}
if(run_documentation()) {
# Show the pig staring into a mirror, worried 
generate_cornell() %&gt;%
  add_object(pig(x=555/2-70,z=555/2+50,y=120,scale=c(80,80,80),
                 angle = c(0,-40,0), emotion = "worried")) %&gt;%
  add_object(cube(x=450,z=450,y=250, ywidth=500, xwidth=200,
                  angle = c(0,45,0), material = metal())) %&gt;%
  render_scene(parallel=TRUE, samples=128,clamp_value=10)
}
if(run_documentation()) {
# Render many small pigs facing random directions, with an evil pig overlord
set.seed(1)
lots_of_pigs = list() 
for(i in 1:10) {
  lots_of_pigs[[i]] = pig(x=50 + 450 * runif(1), z = 50 + 450 * runif(1), y=50, 
                             scale = c(30,30,30), angle = c(0,360*runif(1),0), emotion = "worried")
}

many_pigs_scene = do.call(rbind, lots_of_pigs) %&gt;%
 add_object(generate_cornell(lightintensity=30, lightwidth=100)) %&gt;%
 add_object(pig(z=500,x=555/2,y=350, emotion = "angry",
            scale=c(100,100,100),angle=c(-30,90,0), order_rotation=c(3,2,1)))
            
render_scene(many_pigs_scene,parallel=TRUE,clamp_value=10, samples=128)
}
if(run_documentation()) {
#Render spiderpig
generate_studio() %&gt;%  
  add_object(pig(y=-1,angle=c(0,-100,0), scale=1/2,spider=TRUE)) %&gt;% 
  add_object(sphere(y=5,z=5,x=5,material=light(intensity=100))) %&gt;% 
  render_scene(samples=128,lookfrom=c(0,2,10),clamp_value=10)
}
</code></pre>

<hr>
<h2 id='ply_model'>'ply' File Object</h2><span id='topic+ply_model'></span>

<h3>Description</h3>

<p>Load an PLY file via a filepath. 
Note: light importance sampling currently not supported for this shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ply_model(
  filename,
  x = 0,
  y = 0,
  z = 0,
  scale_ply = 1,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ply_model_+3A_filename">filename</code></td>
<td>
<p>Filename and path to the &lsquo;ply' file. Can also be a 'txt' file, if it&rsquo;s in the correct 'ply' internally.</p>
</td></tr>
<tr><td><code id="ply_model_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="ply_model_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="ply_model_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="ply_model_+3A_scale_ply">scale_ply</code></td>
<td>
<p>Default '1'. Amount to scale the model. Use this to scale the object up or down on all axes, as it is
more robust to numerical precision errors than the generic scale option.</p>
</td></tr>
<tr><td><code id="ply_model_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="ply_model_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="ply_model_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="ply_model_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="ply_model_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the obj model in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See the documentation for `obj_model()`--no example PLY models are included with this package,
#but the process of loading a model is the same (without support for vertex colors).
</code></pre>

<hr>
<h2 id='post_process_frame'>Post-process Frame</h2><span id='topic+post_process_frame'></span>

<h3>Description</h3>

<p>Post-process Frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_process_frame(
  rgb_mat,
  debug_channel,
  filename,
  toneval,
  bloom = TRUE,
  transparent_background = FALSE,
  write_file = TRUE
)
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='post_process_scene'>Post-process the scene</h2><span id='topic+post_process_scene'></span>

<h3>Description</h3>

<p>Post-process the scene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_process_scene(
  rgb_mat,
  iso,
  tonemap,
  debug_channel,
  filename,
  return_raw_array,
  bloom,
  new_page = TRUE,
  transparent_background = FALSE
)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>#internal
</code></pre>

<hr>
<h2 id='prepare_scene_list'>Prepare the scene list</h2><span id='topic+prepare_scene_list'></span>

<h3>Description</h3>

<p>Prepare the scene list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_scene_list(
  scene,
  width = 400,
  height = 400,
  fov = 20,
  lookfrom = c(0, 1, 10),
  lookat = c(0, 0, 0),
  camera_up = c(0, 1, 0),
  samples = 100,
  camera_description_file = NA,
  camera_scale = 1,
  iso = 100,
  film_size = 22,
  min_variance = 5e-05,
  min_adaptive_size = 8,
  sample_method = "sobol",
  max_depth = NA,
  roulette_active_depth = 100,
  ambient_light = FALSE,
  aperture = 0.1,
  clamp_value = Inf,
  filename = NULL,
  backgroundhigh = "#80b4ff",
  backgroundlow = "#ffffff",
  shutteropen = 0,
  shutterclose = 1,
  focal_distance = NULL,
  ortho_dimensions = c(1, 1),
  tonemap = "gamma",
  bloom = TRUE,
  parallel = TRUE,
  bvh_type = "sah",
  environment_light = NULL,
  rotate_env = 0,
  intensity_env = 1,
  debug_channel = "none",
  return_raw_array = FALSE,
  progress = interactive(),
  verbose = FALSE,
  sample_dist = Inf,
  keep_colors = FALSE
)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>#internal
</code></pre>

<hr>
<h2 id='print_time'>Print time</h2><span id='topic+print_time'></span>

<h3>Description</h3>

<p>Print time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_time(verbose = FALSE, message_text = "")
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='process_point_series'>Process Points to Control Points</h2><span id='topic+process_point_series'></span>

<h3>Description</h3>

<p>Process Points to Control Points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_point_series(points, closed = FALSE, straight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_point_series_+3A_points">points</code></td>
<td>
<p>Points</p>
</td></tr>
<tr><td><code id="process_point_series_+3A_closed">closed</code></td>
<td>
<p>Whether to be closed</p>
</td></tr>
<tr><td><code id="process_point_series_+3A_straight">straight</code></td>
<td>
<p>Whether to be straight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of control points
</p>

<hr>
<h2 id='process_point_series_1d'>Process Points to Control Points</h2><span id='topic+process_point_series_1d'></span>

<h3>Description</h3>

<p>Process Points to Control Points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_point_series_1d(values, closed = FALSE, straight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_point_series_1d_+3A_values">values</code></td>
<td>
<p>Points</p>
</td></tr>
<tr><td><code id="process_point_series_1d_+3A_closed">closed</code></td>
<td>
<p>Whether to be closed</p>
</td></tr>
<tr><td><code id="process_point_series_1d_+3A_straight">straight</code></td>
<td>
<p>Whether to be straight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of control points
</p>

<hr>
<h2 id='process_point_series_2d'>Process Points to Control Points</h2><span id='topic+process_point_series_2d'></span>

<h3>Description</h3>

<p>Process Points to Control Points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_point_series_2d(values, closed = FALSE, straight = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_point_series_2d_+3A_values">values</code></td>
<td>
<p>Points</p>
</td></tr>
<tr><td><code id="process_point_series_2d_+3A_closed">closed</code></td>
<td>
<p>Whether to be closed</p>
</td></tr>
<tr><td><code id="process_point_series_2d_+3A_straight">straight</code></td>
<td>
<p>Whether to be straight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of control points
</p>

<hr>
<h2 id='quadInOut'>Quad-in-out</h2><span id='topic+quadInOut'></span>

<h3>Description</h3>

<p>Quad-in-out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadInOut(t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadInOut_+3A_t">t</code></td>
<td>
<p>Value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>

<hr>
<h2 id='r_obj'>R 3D Model</h2><span id='topic+r_obj'></span>

<h3>Description</h3>

<p>3D obj model of the letter R, to be used with 'obj_model()'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_obj()
</code></pre>


<h3>Value</h3>

<p>File location of the R.obj file (saved with a .txt extension)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load and render the included example R object file.
if(run_documentation()) {
generate_ground(material = diffuse(noise = TRUE, noisecolor = "grey20")) %&gt;%
  add_object(sphere(x = 2, y = 3, z = 2, radius = 1,
                    material = light(intensity = 10))) %&gt;%
  add_object(obj_model(r_obj(), y = -1, material = diffuse(color="red"))) %&gt;%
  render_scene(parallel=TRUE, lookfrom = c(0, 1, 10), clamp_value = 5, samples = 200)
}
</code></pre>

<hr>
<h2 id='ray_animated_transform'>Internal vctrs methods</h2><span id='topic+ray_animated_transform'></span>

<h3>Description</h3>

<p>list(start_transform_animation = list(matrix(4x4) OR ..NA_real..),
end_transform_animation = list(matrix(4x4 OR ..NA_real..)),
start_time  = numeric(1),
end_time = numeric(1))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_animated_transform(...)
</code></pre>


<h3>Value</h3>

<p>ray_animated_transform
</p>

<hr>
<h2 id='ray_material'>Internal vctrs methods</h2><span id='topic+ray_material'></span>

<h3>Description</h3>

<p>Internal vctrs methods
</p>
<p>Constructor for ray_material
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_material(...)
</code></pre>


<h3>Value</h3>

<p>ray_material
</p>

<hr>
<h2 id='ray_scene'>Constructor for ray_material</h2><span id='topic+ray_scene'></span>

<h3>Description</h3>

<p>Constructor for ray_material
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_scene(...)
</code></pre>


<h3>Value</h3>

<p>ray
</p>

<hr>
<h2 id='ray_shape_info'>Internal vctrs methods</h2><span id='topic+ray_shape_info'></span>

<h3>Description</h3>

<p>list(angle = list(numeric(3)),
order_rotation = list(numeric(3)),
scale_factor  = list(numeric(3)),
group_transform = list(matrix(4x4) ..OR.. NA_real))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_shape_info(...)
</code></pre>


<h3>Value</h3>

<p>ray_transform
</p>

<hr>
<h2 id='ray_transform'>Internal vctrs methods</h2><span id='topic+ray_transform'></span>

<h3>Description</h3>

<p>list(angle = list(numeric(3)),
order_rotation = list(numeric(3)),
scale_factor  = list(numeric(3)),
group_transform = list(matrix(4x4) ..OR.. NA_real))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_transform(...)
</code></pre>


<h3>Value</h3>

<p>ray_transform
</p>

<hr>
<h2 id='raymesh_model'>'raymesh' model</h2><span id='topic+raymesh_model'></span>

<h3>Description</h3>

<p>Load an 'raymesh' object, as specified in the 'rayvertex' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raymesh_model(
  mesh,
  x = 0,
  y = 0,
  z = 0,
  flip_transmittance = TRUE,
  verbose = FALSE,
  importance_sample_lights = FALSE,
  calculate_consistent_normals = TRUE,
  override_material = TRUE,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1),
  validate_mesh = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raymesh_model_+3A_mesh">mesh</code></td>
<td>
<p>A 'raymesh' object. Pulls the vertex, index, texture coordinates, 
normals, and material information.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate to offset the model.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_flip_transmittance">flip_transmittance</code></td>
<td>
<p>Default 'TRUE'. Flips '(1-t)' the transmittance values to match the way the colors
would be interpreted in a rasterizer (where it specifies the transmitted color). Turn off to specify
the attenuation values directly.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_verbose">verbose</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', prints information about the mesh to the console.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_importance_sample_lights">importance_sample_lights</code></td>
<td>
<p>Default 'TRUE'. Whether to importance sample lights specified in the OBJ material
(objects with a non-zero Ke MTL material).</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_calculate_consistent_normals">calculate_consistent_normals</code></td>
<td>
<p>Default 'TRUE'. Whether to calculate consistent vertex normals to prevent energy 
loss at edges.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_override_material">override_material</code></td>
<td>
<p>Default 'TRUE'. If 'TRUE', overrides the material specified in the 
'raymesh' object with the one specified in 'material'.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>, but ignored unless 'override_material = TRUE'. The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
<tr><td><code id="raymesh_model_+3A_validate_mesh">validate_mesh</code></td>
<td>
<p>Default 'TRUE'. Validates the 'raymesh' object using 'rayvertex::validate_mesh()' 
before parsing to ensure correct parsing. Set to 'FALSE' to speed up scene construction if 'raymesh_model()' 
is taking a long time (Note: this does not affect rendering time).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the raymesh model in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Render a simple raymesh object
library(rayvertex)
if(run_documentation()) {
raymesh_model(sphere_mesh(position = c(-1, 0, 0),
              material = material_list(transmittance = "red"))) %&gt;%
  add_object(generate_ground(material = diffuse(checkercolor="grey20"))) %&gt;%
  render_scene(fov = 30, samples=128, sample_method="sobol_blue")
}

# We create a complex rayvertex mesh, using the `rayvertex::add_shape` function which
# creates a new `raymesh` object out of individual `raymesh` objects
rm_scene = sphere_mesh(position = c(-1, 0, 0),
            material = material_list(transmittance = "red")) %&gt;% 
    add_shape(sphere_mesh(position = c(1, 0, 0),
            material = material_list(transmittance = "green", ior = 1.5)))

# Pass the single raymesh object to `raymesh_model()`
# `raymesh_model()`
if(run_documentation()) {
raymesh_model(rm_scene) %&gt;%
  add_object(generate_ground(material = diffuse(checkercolor="grey20"))) %&gt;%
  render_scene(fov = 30, samples=128, sample_method="sobol_blue")
}

# Set `flip_transmittance = FALSE` argument to specify attenuation coefficients directly
# (as specified in the `dielectric()` material). We change the material's numerical attenuation
# constants using `rayvertex::change_material`
rm_scene_new= change_material(rm_scene, transmittance = c(1,2,0.3), id = 1) %&gt;% 
  change_material(transmittance = c(3,1,2), id = 2)
if(run_documentation()) {
raymesh_model(rm_scene_new, flip_transmittance = FALSE) %&gt;%
  add_object(generate_ground(material = diffuse(checkercolor="grey20"))) %&gt;%
  render_scene(fov = 30, samples=128, sample_method="sobol_blue")
}

# Override the material specified in the `raymesh` object and render the scene
if(run_documentation()) {
raymesh_model(rm_scene,
              material = dielectric(attenuation = "dodgerblue2", attenuation_intensity = 4), 
  override_material = TRUE) %&gt;%
  add_object(generate_ground(material = diffuse(checkercolor="grey20"))) %&gt;%
  render_scene(fov = 30, samples=128, sample_method="sobol_blue")
}

# Adjusting the scale, position, and rotation parameters of the `raymesh` model
if(run_documentation()) {
raymesh_model(rm_scene,
              x = 0, y = 0.5, z = -1, angle = c(0, 0, 20)) %&gt;%
  add_object(generate_ground(material = diffuse(checkercolor="grey20"))) %&gt;%
  render_scene(fov = 30,lookat=c(0,0.5,0), samples=128, sample_method="sobol_blue")
}
</code></pre>

<hr>
<h2 id='render_animation'>Render Animation</h2><span id='topic+render_animation'></span>

<h3>Description</h3>

<p>Takes the scene description and renders an image, either to the device or to a filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_animation(
  scene,
  camera_motion,
  start_frame = 1,
  end_frame = NA,
  width = 400,
  height = 400,
  preview = interactive(),
  camera_description_file = NA,
  camera_scale = 1,
  iso = 100,
  film_size = 22,
  samples = 100,
  min_variance = 5e-05,
  min_adaptive_size = 8,
  sample_method = "sobol",
  ambient_occlusion = FALSE,
  keep_colors = FALSE,
  sample_dist = 10,
  max_depth = 50,
  roulette_active_depth = 10,
  ambient_light = FALSE,
  clamp_value = Inf,
  filename = NA,
  backgroundhigh = "#80b4ff",
  backgroundlow = "#ffffff",
  shutteropen = 0,
  shutterclose = 1,
  focal_distance = NULL,
  ortho_dimensions = c(1, 1),
  tonemap = "gamma",
  bloom = TRUE,
  parallel = TRUE,
  bvh_type = "sah",
  environment_light = NULL,
  rotate_env = 0,
  intensity_env = 1,
  debug_channel = "none",
  return_raw_array = FALSE,
  progress = interactive(),
  verbose = FALSE,
  transparent_background = FALSE,
  preview_light_direction = c(0, -1, 0),
  preview_exponent = 6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_animation_+3A_scene">scene</code></td>
<td>
<p>Tibble of object locations and properties.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_camera_motion">camera_motion</code></td>
<td>
<p>Data frame of camera motion vectors, calculated with 'generate_camera_motion()'.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_start_frame">start_frame</code></td>
<td>
<p>Default '1'. Frame to start the animation.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_end_frame">end_frame</code></td>
<td>
<p>Default 'NA'. By default, this is set to 'nrow(camera_motion)', the full number of frames.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_width">width</code></td>
<td>
<p>Default '400'. Width of the render, in pixels.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_height">height</code></td>
<td>
<p>Default '400'. Height of the render, in pixels.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_preview">preview</code></td>
<td>
<p>Default 'interactive()'. Whether to display a realtime progressive preview of the render. Press ESC to cancel the render.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_camera_description_file">camera_description_file</code></td>
<td>
<p>Default 'NA'. Filename of a camera description file for rendering with
a realistic camera. Several camera files are built-in: '&quot;50mm&quot;','&quot;wide&quot;','&quot;fisheye&quot;', and '&quot;telephoto&quot;'.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_camera_scale">camera_scale</code></td>
<td>
<p>Default '1'. Amount to scale the camera up or down in size. Use this rather than scaling a 
scene.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_iso">iso</code></td>
<td>
<p>Default '100'. Camera exposure.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_film_size">film_size</code></td>
<td>
<p>Default '22', in 'mm' (scene units in 'm'. Size of the film if using a realistic camera, otherwise
ignored.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_samples">samples</code></td>
<td>
<p>Default '100'. The maximum number of samples for each pixel. If this is a length-2
vector and the 'sample_method' is 'stratified', this will control the number of strata in each dimension.
The total number of samples in this case will be the product of the two numbers.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_min_variance">min_variance</code></td>
<td>
<p>Default '0.00005'. Minimum acceptable variance for a block of pixels for the 
adaptive sampler. Smaller numbers give higher quality images, at the expense of longer rendering times.
If this is set to zero, the adaptive sampler will be turned off and the renderer
will use the maximum number of samples everywhere.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_min_adaptive_size">min_adaptive_size</code></td>
<td>
<p>Default '8'. Width of the minimum block size in the adaptive sampler.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_sample_method">sample_method</code></td>
<td>
<p>Default 'sobol'. The type of sampling method used to generate
random numbers. The other options are 'random' (worst quality but simple), 
'stratified' (only implemented for completion), 
and 'sobol_blue' (best option for sample counts below 256).</p>
</td></tr>
<tr><td><code id="render_animation_+3A_ambient_occlusion">ambient_occlusion</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the animation will be rendered with the ambient
occlusion renderer. This uses the background color specified in 'backgroundhigh'</p>
</td></tr>
<tr><td><code id="render_animation_+3A_keep_colors">keep_colors</code></td>
<td>
<p>Default 'FALSE'. Whether to keep the diffuse material colors.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_sample_dist">sample_dist</code></td>
<td>
<p>Default '10'. Sample distance if 'debug_channel = &quot;ao&quot;'.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_max_depth">max_depth</code></td>
<td>
<p>Default '50'. Maximum number of bounces a ray can make in a scene.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_roulette_active_depth">roulette_active_depth</code></td>
<td>
<p>Default '10'. Number of ray bounces until a ray can stop bouncing via
Russian roulette.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_ambient_light">ambient_light</code></td>
<td>
<p>Default 'FALSE', unless there are no emitting objects in the scene. 
If 'TRUE', the background will be a gradient varying from 'backgroundhigh' directly up (+y) to 
'backgroundlow' directly down (-y).</p>
</td></tr>
<tr><td><code id="render_animation_+3A_clamp_value">clamp_value</code></td>
<td>
<p>Default 'Inf'. If a bright light or a reflective material is in the scene, occasionally
there will be bright spots that will not go away even with a large number of samples. These 
can be removed (at the cost of slightly darkening the image) by setting this to a small number greater than 1.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_filename">filename</code></td>
<td>
<p>Default 'NULL'. If present, the renderer will write to the filename instead
of the current device.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_backgroundhigh">backgroundhigh</code></td>
<td>
<p>Default '#ffffff'. The &quot;high&quot; color in the background gradient. Can be either
a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_backgroundlow">backgroundlow</code></td>
<td>
<p>Default '#ffffff'. The &quot;low&quot; color in the background gradient. Can be either
a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_shutteropen">shutteropen</code></td>
<td>
<p>Default '0'. Time at which the shutter is open. Only affects moving objects.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_shutterclose">shutterclose</code></td>
<td>
<p>Default '1'. Time at which the shutter is open. Only affects moving objects.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_focal_distance">focal_distance</code></td>
<td>
<p>Default 'NULL', automatically set to the 'lookfrom-lookat' distance unless
otherwise specified.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_ortho_dimensions">ortho_dimensions</code></td>
<td>
<p>Default 'c(1,1)'. Width and height of the orthographic camera. Will only be used if 'fov = 0'.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_tonemap">tonemap</code></td>
<td>
<p>Default 'gamma'. Choose the tone mapping function,
Default 'gamma' solely adjusts for gamma and clamps values greater than 1 to 1. 
'reinhold' scales values by their individual color channels 'color/(1+color)' and then performs the 
gamma adjustment. 'uncharted' uses the mapping developed for Uncharted 2 by John Hable. 'hbd' uses an
optimized formula by Jim Hejl and Richard Burgess-Dawson. Note: If set to anything other than 'gamma',
objects with material 'light()' may not be anti-aliased. If 'raw', the raw array of HDR values will be
returned, rather than an image or a plot.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_bloom">bloom</code></td>
<td>
<p>Default 'TRUE'. Set to 'FALSE' to get the raw, pathtraced image. Otherwise,
this performs a convolution of the HDR image of the scene with a sharp, long-tailed
exponential kernel, which does not visibly affect dimly pixels, but does result in emitters light
slightly bleeding into adjacent pixels. This provides an antialiasing effect for lights, even when
tonemapping the image. Pass in a matrix to specify the convolution kernel manually, or a positive number
to control the intensity of the bloom (higher number = more bloom).</p>
</td></tr>
<tr><td><code id="render_animation_+3A_parallel">parallel</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will use all available cores to render the image
(or the number specified in 'options(&quot;cores&quot;)' if that option is not 'NULL').</p>
</td></tr>
<tr><td><code id="render_animation_+3A_bvh_type">bvh_type</code></td>
<td>
<p>Default '&quot;sah&quot;', &quot;surface area heuristic&quot;. Method of building the bounding volume
hierarchy structure used when rendering. Other option is &quot;equal&quot;, which splits tree into groups
of equal size.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_environment_light">environment_light</code></td>
<td>
<p>Default 'NULL'. An image to be used for the background for rays that escape
the scene. Supports both HDR ('.hdr') and low-dynamic range ('.png', '.jpg') images.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_rotate_env">rotate_env</code></td>
<td>
<p>Default '0'. The number of degrees to rotate the environment map around the scene.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_intensity_env">intensity_env</code></td>
<td>
<p>Default '1'. The amount to increase the intensity of the environment lighting. Useful
if using a LDR (JPEG or PNG) image as an environment map.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_debug_channel">debug_channel</code></td>
<td>
<p>Default 'none'. If 'depth', function will return a depth map of rays into the scene 
instead of an image. If 'normals', function will return an image of scene normals, mapped from 0 to 1.
If 'uv', function will return an image of the uv coords. If 'variance', function will return an image 
showing the number of samples needed to take for each block to converge. If 'dpdu' or 'dpdv', function will return
an image showing the differential 'u' and 'u' coordinates. If 'color', function will return the raw albedo
values (with white for 'metal' and 'dielectric' materials). If 'preview', an image rendered with 'render_preview()' 
will be returned. Can set to 'ao' to render an animation with the ambient occlusion renderer.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_return_raw_array">return_raw_array</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', function will return raw array with RGB intensity
information.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE' if interactive session, 'FALSE' otherwise.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_verbose">verbose</code></td>
<td>
<p>Default 'FALSE'. Prints information and timing information about scene
construction and raytracing progress.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_transparent_background">transparent_background</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', any initial camera rays that escape the scene
will be marked as transparent in the final image. If for a pixel some rays escape and others hit a surface,
those pixels will be partially transparent.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_preview_light_direction">preview_light_direction</code></td>
<td>
<p>Default 'c(0,-1,0)'. Vector specifying the orientation for the global light using for phong shading.</p>
</td></tr>
<tr><td><code id="render_animation_+3A_preview_exponent">preview_exponent</code></td>
<td>
<p>Default '6'. Phong exponent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raytraced plot to current device, or an image saved to a file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create and animate flying through a scene on a simulated roller coaster
if(run_documentation()) {
set.seed(3)
elliplist = list()
ellip_colors = rainbow(8)
for(i in 1:1200) {
  elliplist[[i]] = ellipsoid(x=10*runif(1)-5,y=10*runif(1)-5,z=10*runif(1)-5,
                             angle = 360*runif(3), a=0.1,b=0.05,c=0.1,
                             material=glossy(color=sample(ellip_colors,1)))
}
ellip_scene = do.call(rbind, elliplist)

camera_pos = list(c(0,1,15),c(5,-5,5),c(-5,5,-5),c(0,1,-15))

#Plot the camera path and render from above using the path object:
generate_ground(material=diffuse(checkercolor="grey20"),depth=-10) %&gt;% 
  add_object(ellip_scene) %&gt;% 
  add_object(sphere(y=50,radius=10,material=light(intensity=30))) %&gt;% 
  add_object(path(camera_pos, material=diffuse(color="red"))) %&gt;% 
  render_scene(lookfrom=c(0,20,0), width=800,height=800,samples=32,
               camera_up = c(0,0,1),
               fov=80)
}
if(run_documentation()) {
#Side view     
generate_ground(material=diffuse(checkercolor="grey20"),depth=-10) %&gt;% 
  add_object(ellip_scene) %&gt;% 
  add_object(sphere(y=50,radius=10,material=light(intensity=30))) %&gt;% 
  add_object(path(camera_pos, material=diffuse(color="red"))) %&gt;% 
  render_scene(lookfrom=c(20,0,0),width=800,height=800,samples=32,
                 fov=80)
 }
if(run_documentation()) {
#View from the start        
generate_ground(material=diffuse(checkercolor="grey20"),depth=-10) %&gt;% 
  add_object(ellip_scene) %&gt;% 
  add_object(sphere(y=50,radius=10,material=light(intensity=30))) %&gt;% 
  add_object(path(camera_pos, material=diffuse(color="red"))) %&gt;% 
  render_scene(lookfrom=c(0,1.5,16),width=800,height=800,samples=32,
                 fov=80)
 }
if(run_documentation()) {             
#Generate Camera movement, setting the lookat position to be same as camera position, but offset
#slightly in front. We'll render 12 frames, but you'd likely want more in a real animation.

camera_motion =  generate_camera_motion(positions = camera_pos, lookats = camera_pos, 
                                        offset_lookat = 1, fovs=80, frames=12,
                                        type="bezier") 
                                        
#This returns a data frame of individual camera positions, interpolated by cubic bezier curves.
camera_motion

#Pass NA filename to plot to the device. We'll keep the path and offset it slightly to see
#where we're going. This results in a "roller coaster" effect.
generate_ground(material=diffuse(checkercolor="grey20"),depth=-10) %&gt;% 
  add_object(ellip_scene) %&gt;% 
  add_object(sphere(y=50,radius=10,material=light(intensity=30))) %&gt;% 
  add_object(obj_model(r_obj(),x=10,y=-10,scale_obj=3, angle=c(0,-45,0),
                       material=dielectric(attenuation=c(1,1,0.3)))) %&gt;% 
  add_object(pig(x=-7,y=10,z=-5,scale=1,angle=c(0,-45,80),emotion="angry")) %&gt;% 
  add_object(pig(x=0,y=-0.25,z=-15,scale=1,angle=c(30,225,30),
                 emotion="angry", spider=TRUE)) %&gt;% 
  add_object(path(camera_pos, y=-0.2,material=diffuse(color="red"))) %&gt;% 
  render_animation(filename = NA, camera_motion = camera_motion, samples=100,
                   sample_method="sobol_blue", 
                   clamp_value=10, width=400, height=400)

}
</code></pre>

<hr>
<h2 id='render_ao'>Render Ambient Occlusion</h2><span id='topic+render_ao'></span>

<h3>Description</h3>

<p>Takes the scene description and renders an image using ambient occlusion, 
either to the device or to a filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_ao(
  scene,
  width = 400,
  height = 400,
  fov = 20,
  sample_dist = 10,
  keep_colors = FALSE,
  samples = 100,
  camera_description_file = NA,
  camera_scale = 1,
  iso = 100,
  film_size = 22,
  min_variance = 0,
  min_adaptive_size = 8,
  sample_method = "sobol",
  background_color = "white",
  lookfrom = c(0, 1, 10),
  lookat = c(0, 0, 0),
  camera_up = c(0, 1, 0),
  aperture = 0.1,
  clamp_value = Inf,
  filename = NULL,
  shutteropen = 0,
  shutterclose = 1,
  focal_distance = NULL,
  ortho_dimensions = c(1, 1),
  parallel = TRUE,
  bvh_type = "sah",
  progress = interactive(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_ao_+3A_scene">scene</code></td>
<td>
<p>Tibble of object locations and properties.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_width">width</code></td>
<td>
<p>Default '400'. Width of the render, in pixels.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_height">height</code></td>
<td>
<p>Default '400'. Height of the render, in pixels.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_fov">fov</code></td>
<td>
<p>Default '20'. Field of view, in degrees. If this is '0', the camera will use an orthographic projection. The size of the plane
used to create the orthographic projection is given in argument 'ortho_dimensions'. From '0' to '180', this uses a perspective
projections. If this value is '360', a 360 degree environment image will be rendered.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_sample_dist">sample_dist</code></td>
<td>
<p>Default '10'. Ambient occlusion sampling distance.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_keep_colors">keep_colors</code></td>
<td>
<p>Default 'FALSE'. Whether to keep the diffuse material colors.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_samples">samples</code></td>
<td>
<p>Default '100'. The maximum number of samples for each pixel. If this is a length-2
vector and the 'sample_method' is 'stratified', this will control the number of strata in each dimension.
The total number of samples in this case will be the product of the two numbers.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_camera_description_file">camera_description_file</code></td>
<td>
<p>Default 'NA'. Filename of a camera description file for rendering with
a realistic camera. Several camera files are built-in: '&quot;50mm&quot;','&quot;wide&quot;','&quot;fisheye&quot;', and '&quot;telephoto&quot;'.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_camera_scale">camera_scale</code></td>
<td>
<p>Default '1'. Amount to scale the camera up or down in size. Use this rather than scaling a 
scene.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_iso">iso</code></td>
<td>
<p>Default '100'. Camera exposure.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_film_size">film_size</code></td>
<td>
<p>Default '22', in 'mm' (scene units in 'm'. Size of the film if using a realistic camera, otherwise
ignored.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_min_variance">min_variance</code></td>
<td>
<p>Default '0.00005'. Minimum acceptable variance for a block of pixels for the 
adaptive sampler. Smaller numbers give higher quality images, at the expense of longer rendering times.
If this is set to zero, the adaptive sampler will be turned off and the renderer
will use the maximum number of samples everywhere.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_min_adaptive_size">min_adaptive_size</code></td>
<td>
<p>Default '8'. Width of the minimum block size in the adaptive sampler.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_sample_method">sample_method</code></td>
<td>
<p>Default 'sobol'. The type of sampling method used to generate
random numbers. The other options are 'random' (worst quality but fastest), 
'stratified' (only implemented for completion), 'sobol_blue' (best option for sample counts below 256), 
and 'sobol' (slowest but best quality, better than 'sobol_blue' for sample counts greater than 256).</p>
</td></tr>
<tr><td><code id="render_ao_+3A_background_color">background_color</code></td>
<td>
<p>Default '&quot;white&quot;'. Background color.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_lookfrom">lookfrom</code></td>
<td>
<p>Default 'c(0,1,10)'. Location of the camera.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_lookat">lookat</code></td>
<td>
<p>Default 'c(0,0,0)'. Location where the camera is pointed.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_camera_up">camera_up</code></td>
<td>
<p>Default 'c(0,1,0)'. Vector indicating the &quot;up&quot; position of the camera.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_aperture">aperture</code></td>
<td>
<p>Default '0.1'. Aperture of the camera. Smaller numbers will increase depth of field, causing
less blurring in areas not in focus.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_clamp_value">clamp_value</code></td>
<td>
<p>Default 'Inf'. If a bright light or a reflective material is in the scene, occasionally
there will be bright spots that will not go away even with a large number of samples. These 
can be removed (at the cost of slightly darkening the image) by setting this to a small number greater than 1.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_filename">filename</code></td>
<td>
<p>Default 'NULL'. If present, the renderer will write to the filename instead
of the current device.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_shutteropen">shutteropen</code></td>
<td>
<p>Default '0'. Time at which the shutter is open. Only affects moving objects.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_shutterclose">shutterclose</code></td>
<td>
<p>Default '1'. Time at which the shutter is open. Only affects moving objects.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_focal_distance">focal_distance</code></td>
<td>
<p>Default 'NULL', automatically set to the 'lookfrom-lookat' distance unless
otherwise specified.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_ortho_dimensions">ortho_dimensions</code></td>
<td>
<p>Default 'c(1,1)'. Width and height of the orthographic camera. Will only be used if 'fov = 0'.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_parallel">parallel</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', it will use all available cores to render the image
(or the number specified in 'options(&quot;cores&quot;)' if that option is not 'NULL').</p>
</td></tr>
<tr><td><code id="render_ao_+3A_bvh_type">bvh_type</code></td>
<td>
<p>Default '&quot;sah&quot;', &quot;surface area heuristic&quot;. Method of building the bounding volume
hierarchy structure used when rendering. Other option is &quot;equal&quot;, which splits tree into groups
of equal size.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE' if interactive session, 'FALSE' otherwise.</p>
</td></tr>
<tr><td><code id="render_ao_+3A_verbose">verbose</code></td>
<td>
<p>Default 'FALSE'. Prints information and timing information about scene
construction and raytracing progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raytraced plot to current device, or an image saved to a file. Invisibly returns the
array (containing either debug data or the RGB)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate and render a regular scene and an ambient occlusion version of that scene
if(run_documentation()) {
angles = seq(0,360,by=36)
xx = rev(c(rep(c(1,0.5),5),1) * sinpi(angles/180))
yy = rev(c(rep(c(1,0.5),5),1) * cospi(angles/180))
star_polygon = data.frame(x=xx,y=yy)
hollow_star = rbind(star_polygon,0.8*star_polygon)

generate_ground(material = diffuse(color="grey20", checkercolor = "grey50",sigma=90)) %&gt;%
 add_object(sphere(material=metal())) %&gt;%
 add_object(obj_model(y=-1,x=-1.8,r_obj(), angle=c(0,135,0),material = diffuse(sigma=90))) %&gt;%
 add_object(pig(x=1.8,y=-1.2,scale=0.5,angle=c(0,90,0),diffuse_sigma = 90)) %&gt;%
 add_object(extruded_polygon(hollow_star,top=-0.5,bottom=-1, z=-2,
                             hole = nrow(star_polygon),
                             material=diffuse(color="red",sigma=90))) %&gt;%
 render_scene(parallel = TRUE,width=800,height=800,
              fov=70,clamp_value=10,samples=128, aperture=0.1,
              lookfrom=c(-0.9,1.2,-4.5),lookat=c(0,-1,0))
}
if(run_documentation()) {

#Render the scene with ambient occlusion
generate_ground(material = diffuse(color="grey20", checkercolor = "grey50",sigma=90)) %&gt;%
 add_object(sphere(material=metal())) %&gt;%
 add_object(obj_model(y=-1,x=-1.8,r_obj(), angle=c(0,135,0),material = diffuse(sigma=90))) %&gt;%
 add_object(pig(x=1.8,y=-1.2,scale=0.5,angle=c(0,90,0),diffuse_sigma = 90)) %&gt;%
 add_object(extruded_polygon(hollow_star,top=-0.5,bottom=-1, z=-2,
                             hole = nrow(star_polygon),
                             material=diffuse(color="red",sigma=90))) %&gt;%
 render_ao(parallel = TRUE,width=800,height=800, sample_dist=10,
           fov=70,samples=128, aperture=0.1,
           lookfrom=c(-0.9,1.2,-4.5),lookat=c(0,-1,0))
 }
if(run_documentation()) {
#Decrease the ray occlusion search distance
generate_ground(material = diffuse(color="grey20", checkercolor = "grey50",sigma=90)) %&gt;%
 add_object(sphere(material=metal())) %&gt;%
 add_object(obj_model(y=-1,x=-1.8,r_obj(), angle=c(0,135,0),material = diffuse(sigma=90))) %&gt;%
 add_object(pig(x=1.8,y=-1.2,scale=0.5,angle=c(0,90,0),diffuse_sigma = 90)) %&gt;%
 add_object(extruded_polygon(hollow_star,top=-0.5,bottom=-1, z=-2,
                             hole = nrow(star_polygon),
                             material=diffuse(color="red",sigma=90))) %&gt;%
 render_ao(parallel = TRUE,width=800,height=800, sample_dist=1,
           fov=70,samples=128, aperture=0.1,
           lookfrom=c(-0.9,1.2,-4.5),lookat=c(0,-1,0))
}
if(run_documentation()) {
#Turn on colors
generate_ground(material = diffuse(color="grey20", checkercolor = "grey50",sigma=90)) %&gt;%
 add_object(sphere(material=metal())) %&gt;%
 add_object(obj_model(y=-1,x=-1.8,r_obj(), angle=c(0,135,0),material = diffuse(sigma=90))) %&gt;%
 add_object(pig(x=1.8,y=-1.2,scale=0.5,angle=c(0,90,0),diffuse_sigma = 90)) %&gt;%
 add_object(extruded_polygon(hollow_star,top=-0.5,bottom=-1, z=-2,
                             hole = nrow(star_polygon),
                             material=diffuse(color="red",sigma=90))) %&gt;%
 render_ao(parallel = TRUE,width=800,height=800, sample_dist=1,
           fov=70,samples=128, aperture=0.1, keep_colors = TRUE,
           lookfrom=c(-0.9,1.2,-4.5),lookat=c(0,-1,0))

}
</code></pre>

<hr>
<h2 id='render_preview'>Render Preview</h2><span id='topic+render_preview'></span>

<h3>Description</h3>

<p>Takes the scene description and renders an image, either to the device or to a filename.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_preview(..., light_direction = c(0, -1, 0), exponent = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_preview_+3A_...">...</code></td>
<td>
<p>All arguments that would be passed to 'render_scene()'.</p>
</td></tr>
<tr><td><code id="render_preview_+3A_light_direction">light_direction</code></td>
<td>
<p>Default 'c(0,-1,0)'. Vector specifying the orientation for the global light using for phong shading.</p>
</td></tr>
<tr><td><code id="render_preview_+3A_exponent">exponent</code></td>
<td>
<p>Default '6'. Phong exponent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raytraced plot to current device, or an image saved to a file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()) {
generate_ground(material=diffuse(color="darkgreen")) %&gt;% 
  add_object(sphere(material=diffuse(checkercolor="red"))) %&gt;% 
  render_preview()
  }
if(run_documentation()) {
#Change the light direction
generate_ground(material=diffuse(color="darkgreen")) %&gt;% 
  add_object(sphere(material=diffuse(checkercolor="red"))) %&gt;% 
  render_preview(light_direction = c(-1,-1,0))
}
if(run_documentation()) {
#Change the Phong exponent
generate_ground(material=diffuse(color="darkgreen")) %&gt;% 
  add_object(sphere(material=diffuse(checkercolor="red"))) %&gt;% 
  render_preview(light_direction = c(-1,-1,0), exponent=100)
}
</code></pre>

<hr>
<h2 id='render_scene'>Render Scene</h2><span id='topic+render_scene'></span>

<h3>Description</h3>

<p>Takes the scene description and renders an image, either to the device or to a filename. The
user can also interactively fly around the 3D scene if they have X11 support on their system
or are on Windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_scene(
  scene,
  width = 400,
  height = 400,
  fov = 20,
  samples = 100,
  camera_description_file = NA,
  preview = interactive(),
  interactive = TRUE,
  camera_scale = 1,
  iso = 100,
  film_size = 22,
  min_variance = 5e-05,
  min_adaptive_size = 8,
  sample_method = "sobol_blue",
  max_depth = NA,
  roulette_active_depth = 100,
  ambient_light = NULL,
  lookfrom = c(0, 1, 10),
  lookat = c(0, 0, 0),
  camera_up = c(0, 1, 0),
  aperture = 0.1,
  clamp_value = Inf,
  filename = NULL,
  backgroundhigh = "#80b4ff",
  backgroundlow = "#ffffff",
  shutteropen = 0,
  shutterclose = 1,
  focal_distance = NULL,
  ortho_dimensions = c(1, 1),
  tonemap = "gamma",
  bloom = TRUE,
  parallel = TRUE,
  bvh_type = "sah",
  environment_light = NULL,
  rotate_env = 0,
  intensity_env = 1,
  transparent_background = FALSE,
  debug_channel = "none",
  return_raw_array = FALSE,
  progress = interactive(),
  verbose = FALSE,
  new_page = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_scene_+3A_scene">scene</code></td>
<td>
<p>Tibble of object locations and properties.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_width">width</code></td>
<td>
<p>Default '400'. Width of the render, in pixels.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_height">height</code></td>
<td>
<p>Default '400'. Height of the render, in pixels.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_fov">fov</code></td>
<td>
<p>Default '20'. Field of view, in degrees. If this is '0', the camera will use an orthographic projection. The size of the plane
used to create the orthographic projection is given in argument 'ortho_dimensions'. From '0' to '180', this uses a perspective
projections. If this value is '360', a 360 degree environment image will be rendered.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_samples">samples</code></td>
<td>
<p>Default '100'. The maximum number of samples for each pixel. If this is a length-2
vector and the 'sample_method' is 'stratified', this will control the number of strata in each dimension.
The total number of samples in this case will be the product of the two numbers.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_camera_description_file">camera_description_file</code></td>
<td>
<p>Default 'NA'. Filename of a camera description file for rendering with
a realistic camera. Several camera files are built-in: '&quot;50mm&quot;','&quot;wide&quot;','&quot;fisheye&quot;', and '&quot;telephoto&quot;'.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_preview">preview</code></td>
<td>
<p>Default 'TRUE'. Whether to display a real-time progressive preview of the render. Press ESC to cancel the render.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_interactive">interactive</code></td>
<td>
<p>Default 'interactive()'. Whether the scene preview should be interactive. Camera movement orbits around the 
lookat point (unless the mode is switched to free flying), with the following control mapping:
W = Forward, S = Backward, A = Left, D = Right, Q = Up, Z = Down, 
E = 2x Step Distance (max 128), C = 0.5x Step Distance, Up Key = Zoom In (decrease FOV), Down Key = Zoom Out (increase FOV),
Left Key = Decrease Aperture, Right Key = Increase Aperture, 1 = Decrease Focal Distance, 2 = Increase Focal Distance,
3/4 = Rotate Environment Light, 
R = Reset Camera, TAB: Toggle Orbit Mode, Left Mouse Click: Change Look Direction, Right Mouse Click: Change Look At 
K: Save Keyframe (at the conclusion of the render, this will create the 'ray_keyframes'
data.frame in the global environment, which can be passed to 'generate_camera_motion()' to tween between those saved positions.
L: Reset Camera to Last Keyframe (if set) F: Toggle Fast Travel Mode
</p>
<p>Initial step size is 1/20th of the distance from 'lookat' to 'lookfrom'.
</p>
<p>Note: Clicking on the environment image will only redirect the view direction, not change the orbit point.
Some options aren't available all cameras. When using a realistic camera,
the aperture and field of view cannot be changed from their initial settings. Additionally,
clicking to direct the camera at the background environment image while using a realistic camera will
not always point to the exact position selected.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_camera_scale">camera_scale</code></td>
<td>
<p>Default '1'. Amount to scale the camera up or down in size. Use this rather than scaling a 
scene.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_iso">iso</code></td>
<td>
<p>Default '100'. Camera exposure.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_film_size">film_size</code></td>
<td>
<p>Default '22', in 'mm' (scene units in 'm'. Size of the film if using a realistic camera, otherwise
ignored.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_min_variance">min_variance</code></td>
<td>
<p>Default '0.00005'. Minimum acceptable variance for a block of pixels for the 
adaptive sampler. Smaller numbers give higher quality images, at the expense of longer rendering times.
If this is set to zero, the adaptive sampler will be turned off and the renderer
will use the maximum number of samples everywhere.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_min_adaptive_size">min_adaptive_size</code></td>
<td>
<p>Default '8'. Width of the minimum block size in the adaptive sampler.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_sample_method">sample_method</code></td>
<td>
<p>Default 'sobol'. The type of sampling method used to generate
random numbers. The other options are 'random' (worst quality but fastest), 
'stratified' (only implemented for completion), 'sobol_blue' (best option for sample counts below 256), 
and 'sobol' (slowest but best quality, better than 'sobol_blue' for sample counts greater than 256). If 
'samples &gt; 256' and 'sobol_blue' is selected, the method will automatically switch to 'sample_method = &quot;sobol&quot;'.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_max_depth">max_depth</code></td>
<td>
<p>Default 'NA', automatically sets to 50. Maximum number of bounces a ray can make in a scene. Alternatively,
if a debugging option is chosen, this sets the bounce to query the debugging parameter (only for some options).</p>
</td></tr>
<tr><td><code id="render_scene_+3A_roulette_active_depth">roulette_active_depth</code></td>
<td>
<p>Default '100'. Number of ray bounces until a ray can stop bouncing via
Russian roulette.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_ambient_light">ambient_light</code></td>
<td>
<p>Default 'FALSE', unless there are no emitting objects in the scene. 
If 'TRUE', the background will be a gradient varying from 'backgroundhigh' directly up (+y) to 
'backgroundlow' directly down (-y).</p>
</td></tr>
<tr><td><code id="render_scene_+3A_lookfrom">lookfrom</code></td>
<td>
<p>Default 'c(0,1,10)'. Location of the camera.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_lookat">lookat</code></td>
<td>
<p>Default 'c(0,0,0)'. Location where the camera is pointed.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_camera_up">camera_up</code></td>
<td>
<p>Default 'c(0,1,0)'. Vector indicating the &quot;up&quot; position of the camera.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_aperture">aperture</code></td>
<td>
<p>Default '0.1'. Aperture of the camera. Smaller numbers will increase depth of field, causing
less blurring in areas not in focus.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_clamp_value">clamp_value</code></td>
<td>
<p>Default 'Inf'. If a bright light or a reflective material is in the scene, occasionally
there will be bright spots that will not go away even with a large number of samples. These 
can be removed (at the cost of slightly darkening the image) by setting this to a small number greater than 1.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_filename">filename</code></td>
<td>
<p>Default 'NULL'. If present, the renderer will write to the filename instead
of the current device.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_backgroundhigh">backgroundhigh</code></td>
<td>
<p>Default '#80b4ff'. The &quot;high&quot; color in the background gradient. Can be either
a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_backgroundlow">backgroundlow</code></td>
<td>
<p>Default '#ffffff'. The &quot;low&quot; color in the background gradient. Can be either
a hexadecimal code, or a numeric rgb vector listing three intensities between '0' and '1'.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_shutteropen">shutteropen</code></td>
<td>
<p>Default '0'. Time at which the shutter is open. Only affects moving objects.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_shutterclose">shutterclose</code></td>
<td>
<p>Default '1'. Time at which the shutter is open. Only affects moving objects.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_focal_distance">focal_distance</code></td>
<td>
<p>Default 'NULL', automatically set to the 'lookfrom-lookat' distance unless
otherwise specified.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_ortho_dimensions">ortho_dimensions</code></td>
<td>
<p>Default 'c(1,1)'. Width and height of the orthographic camera. Will only be used if 'fov = 0'.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_tonemap">tonemap</code></td>
<td>
<p>Default 'gamma'. Choose the tone mapping function,
Default 'gamma' solely adjusts for gamma and clamps values greater than 1 to 1. 
'reinhold' scales values by their individual color channels 'color/(1+color)' and then performs the 
gamma adjustment. 'uncharted' uses the mapping developed for Uncharted 2 by John Hable. 'hbd' uses an
optimized formula by Jim Hejl and Richard Burgess-Dawson. If 'raw', the raw array of HDR values will be
returned, rather than an image or a plot.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_bloom">bloom</code></td>
<td>
<p>Default 'TRUE'. Set to 'FALSE' to get the raw, pathtraced image. Otherwise,
this performs a convolution of the HDR image of the scene with a sharp, long-tailed
exponential kernel, which does not visibly affect dimly pixels, but does result in emitters light
slightly bleeding into adjacent pixels. This provides an antialiasing effect for lights, even when
tonemapping the image. Pass in a matrix to specify the convolution kernel manually, or a positive number
to control the intensity of the bloom (higher number = more bloom).</p>
</td></tr>
<tr><td><code id="render_scene_+3A_parallel">parallel</code></td>
<td>
<p>Default 'TRUE'. If 'FALSE', it will use all available cores to render the image
(or the number specified in 'options(&quot;cores&quot;)' or 'options(&quot;Ncpus&quot;)' if that option is not 'NULL').</p>
</td></tr>
<tr><td><code id="render_scene_+3A_bvh_type">bvh_type</code></td>
<td>
<p>Default '&quot;sah&quot;', &quot;surface area heuristic&quot;. Method of building the bounding volume
hierarchy structure used when rendering. Other option is &quot;equal&quot;, which splits tree into groups
of equal size.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_environment_light">environment_light</code></td>
<td>
<p>Default 'NULL'. An image to be used for the background for rays that escape
the scene. Supports both HDR ('.hdr') and low-dynamic range ('.png', '.jpg') images.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_rotate_env">rotate_env</code></td>
<td>
<p>Default '0'. The number of degrees to rotate the environment map around the scene.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_intensity_env">intensity_env</code></td>
<td>
<p>Default '1'. The amount to increase the intensity of the environment lighting. Useful
if using a LDR (JPEG or PNG) image as an environment map.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_transparent_background">transparent_background</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', any initial camera rays that escape the scene
will be marked as transparent in the final image. If for a pixel some rays escape and others hit a surface,
those pixels will be partially transparent.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_debug_channel">debug_channel</code></td>
<td>
<p>Default 'none'. If 'depth', function will return a depth map of rays into the scene 
instead of an image. If 'normals', function will return an image of scene normals, mapped from 0 to 1.
If 'uv', function will return an image of the uv coords. If 'variance', function will return an image 
showing the number of samples needed to take for each block to converge. If 'dpdu' or 'dpdv', function will return
an image showing the differential 'u' and 'u' coordinates. If 'color', function will return the raw albedo
values (with white for 'metal' and 'dielectric' materials).</p>
</td></tr>
<tr><td><code id="render_scene_+3A_return_raw_array">return_raw_array</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', function will return raw array with RGB intensity
information.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE' if interactive session, 'FALSE' otherwise.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_verbose">verbose</code></td>
<td>
<p>Default 'FALSE'. Prints information and timing information about scene
construction and raytracing progress.</p>
</td></tr>
<tr><td><code id="render_scene_+3A_new_page">new_page</code></td>
<td>
<p>Default 'TRUE'. Whether to call 'grid::grid.newpage()' when plotting the image (if
no filename specified). Set to 'FALSE' for faster plotting (does not affect render time).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pathtraced image to the current device, or an image saved to a file. Invisibly returns the
array (containing either debug data or the RGB).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a large checkered sphere as the ground
if (run_documentation()) {
  scene = generate_ground(depth = -0.5, 
                          material = diffuse(color = "white", checkercolor = "darkgreen"))
  render_scene(scene, parallel = TRUE, samples = 128, sample_method = "sobol")
}
if (run_documentation()) {
  # Add a sphere to the center
  scene = scene %&gt;%
    add_object(sphere(x = 0, y = 0, z = 0, radius = 0.5, material = diffuse(color = c(1, 0, 1))))
  render_scene(scene, fov = 20, parallel = TRUE, samples = 128)
}
if (run_documentation()) {
  # Add a marbled cube
  scene = scene %&gt;%
    add_object(cube(x = 1.1, y = 0, z = 0, material = diffuse(noise = 3)))
  render_scene(scene, fov = 20, parallel = TRUE, samples = 128)
}
if (run_documentation()) {
  # Add a metallic gold sphere, using stratified sampling for a higher quality render
  # We also add a light, which turns off the default ambient lighting
  scene = scene %&gt;%
    add_object(sphere(x = -1.1, y = 0, z = 0, radius = 0.5, 
                      material = metal(color = "gold", fuzz = 0.1))) %&gt;%
    add_object(sphere(y=10,z=13,radius=2,material=light(intensity=40)))
  render_scene(scene, fov = 20, parallel = TRUE, samples = 128)
}
if (run_documentation()) {
  # Lower the number of samples to render more quickly (here, we also use only one core).
  render_scene(scene, samples = 4, parallel = FALSE)
}
if (run_documentation()) {
  # Add a floating R plot using the iris dataset as a png onto a floating 2D rectangle
  tempfileplot = tempfile()
  png(filename = tempfileplot, height = 400, width = 800)
  plot(iris$Petal.Length, iris$Sepal.Width, col = iris$Species, pch = 18, cex = 4)
  dev.off()
  image_array = aperm(png::readPNG(tempfileplot), c(2, 1, 3))
  scene = scene %&gt;%
    add_object(xy_rect(x = 0, y = 1.1, z = 0, xwidth = 2, angle = c(0, 0, 0), 
                       material = diffuse(image_texture = image_array)))
  render_scene(scene, fov = 20, parallel = TRUE, samples = 128)
}
if (run_documentation()) {
  # Move the camera
  render_scene(scene, lookfrom = c(7, 1.5, 10), lookat = c(0, 0.5, 0), fov = 15, parallel = TRUE)
}
if (run_documentation()) {
  # Change the background gradient to a firey sky
  render_scene(scene, lookfrom = c(7, 1.5, 10), lookat = c(0, 0.5, 0), fov = 15,
               backgroundhigh = "orange", backgroundlow = "red", parallel = TRUE,
               ambient = TRUE,
               samples = 128)
}
if (run_documentation()) {    
  # Increase the aperture to blur objects that are further from the focal plane.
  render_scene(scene, lookfrom = c(7, 1.5, 10), lookat = c(0, 0.5, 0), fov = 15,
               aperture = 1, parallel = TRUE, samples = 128)
}
if (run_documentation()) {
  # We can also capture a 360 environment image by setting `fov = 360` (can be used for VR)
  generate_cornell() %&gt;%
    add_object(ellipsoid(x = 555 / 2, y = 100, z = 555 / 2, a = 50, b = 100, c = 50, 
                          material = metal(color = "lightblue"))) %&gt;%
    add_object(cube(x = 100, y = 130 / 2, z = 200, xwidth = 130, ywidth = 130, zwidth = 130,
                     material = diffuse(checkercolor = "purple", 
                                        checkerperiod = 30), angle = c(0, 10, 0))) %&gt;%
    add_object(pig(x = 100, y = 190, z = 200, scale = 40, angle = c(0, 30, 0))) %&gt;%
    add_object(sphere(x = 420, y = 555 / 8, z = 100, radius = 555 / 8,
                       material = dielectric(color = "orange"))) %&gt;%
    add_object(xz_rect(x = 555 / 2, z = 555 / 2, y = 1, xwidth = 555, zwidth = 555,
                       material = glossy(checkercolor = "white",
                                         checkerperiod = 10, color = "dodgerblue"))) %&gt;%
    render_scene(lookfrom = c(278, 278, 30), lookat = c(278, 278, 500), clamp_value = 10,
                 fov = 360,  samples = 128, width = 800, height = 800)
}
if (run_documentation()) {            
  # Spin the camera around the scene, decreasing the number of samples to render faster. To make 
  # an animation, specify the a filename in `render_scene` for each frame and use the `av` package
  # or ffmpeg to combine them all into a movie.
  t = 1:30 
  xpos = 10 * sin(t * 12 * pi / 180 + pi / 2)
  zpos = 10 * cos(t * 12 * pi / 180 + pi / 2)
  # Save old par() settings
  old.par = par(no.readonly = TRUE)
  on.exit(par(old.par))
  par(mfrow = c(5, 6))
  for (i in 1:30) {
    render_scene(scene, samples = 16, 
                 lookfrom = c(xpos[i], 1.5, zpos[i]), lookat = c(0, 0.5, 0), parallel = TRUE)
  }
}
</code></pre>

<hr>
<h2 id='RotateAxis'>Generate Rotation Matrix Axis</h2><span id='topic+RotateAxis'></span>

<h3>Description</h3>

<p>Generate Rotation Matrix Axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RotateAxis(theta, axis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RotateAxis_+3A_theta">theta</code></td>
<td>
<p>Angle</p>
</td></tr>
<tr><td><code id="RotateAxis_+3A_axis">axis</code></td>
<td>
<p>The rotation axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='RotateX'>Generate Rotation Matrix X</h2><span id='topic+RotateX'></span>

<h3>Description</h3>

<p>Generate Rotation Matrix X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RotateX(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RotateX_+3A_theta">theta</code></td>
<td>
<p>Angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>

<hr>
<h2 id='RotateY'>Generate Rotation Matrix Y</h2><span id='topic+RotateY'></span>

<h3>Description</h3>

<p>Generate Rotation Matrix Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RotateY(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RotateY_+3A_theta">theta</code></td>
<td>
<p>Angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>

<hr>
<h2 id='RotateZ'>Generate Rotation Matrix Z</h2><span id='topic+RotateZ'></span>

<h3>Description</h3>

<p>Generate Rotation Matrix Z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RotateZ(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RotateZ_+3A_theta">theta</code></td>
<td>
<p>Angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>

<hr>
<h2 id='run_documentation'>Run Documentation</h2><span id='topic+run_documentation'></span>

<h3>Description</h3>

<p>This function determines if the examples are being run in pkgdown. It is not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_documentation()
</code></pre>


<h3>Value</h3>

<p>Boolean value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See if the documentation should be run.
run_documentation()
</code></pre>

<hr>
<h2 id='save_png'>Save PNG</h2><span id='topic+save_png'></span>

<h3>Description</h3>

<p>Writes the hillshaded map to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_png(hillshade, filename, rotate = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_png_+3A_hillshade">hillshade</code></td>
<td>
<p>Array (or matrix) of hillshade to be written.</p>
</td></tr>
<tr><td><code id="save_png_+3A_filename">filename</code></td>
<td>
<p>String with the filename. If '.png' is not at the end of the string, it will be appended automatically.</p>
</td></tr>
<tr><td><code id="save_png_+3A_rotate">rotate</code></td>
<td>
<p>Default 0. Rotates the output. Possible values: 0, 90, 180, 270.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#internal
</code></pre>

<hr>
<h2 id='segment'>Segment Object</h2><span id='topic+segment'></span>

<h3>Description</h3>

<p>Similar to the cylinder object, but specified by start and end points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment(
  start = c(0, -1, 0),
  end = c(0, 1, 0),
  radius = 0.1,
  phi_min = 0,
  phi_max = 360,
  from_center = TRUE,
  direction = NA,
  material = diffuse(),
  capped = TRUE,
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment_+3A_start">start</code></td>
<td>
<p>Default 'c(0, -1, 0)'. Start point of the cylinder segment, specifing 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="segment_+3A_end">end</code></td>
<td>
<p>Default 'c(0, 1, 0)'. End point of the cylinder segment, specifing 'x', 'y', 'z'.</p>
</td></tr>
<tr><td><code id="segment_+3A_radius">radius</code></td>
<td>
<p>Default '1'. Radius of the segment.</p>
</td></tr>
<tr><td><code id="segment_+3A_phi_min">phi_min</code></td>
<td>
<p>Default '0'. Minimum angle around the segment.</p>
</td></tr>
<tr><td><code id="segment_+3A_phi_max">phi_max</code></td>
<td>
<p>Default '360'. Maximum angle around the segment.</p>
</td></tr>
<tr><td><code id="segment_+3A_from_center">from_center</code></td>
<td>
<p>Default 'TRUE'. If orientation specified via 'direction', setting this argument
to 'FALSE' will make 'start' specify the bottom of the segment, instead of the middle.</p>
</td></tr>
<tr><td><code id="segment_+3A_direction">direction</code></td>
<td>
<p>Default 'NA'. Alternative to 'start' and 'end', specify the direction (via 
a length-3 vector) of the segment. Segment will be centered at 'start', and the length will be
determined by the magnitude of the direction vector.</p>
</td></tr>
<tr><td><code id="segment_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="segment_+3A_capped">capped</code></td>
<td>
<p>Default 'TRUE'. Whether to add caps to the segment. Turned off when using the 'light()' material.</p>
</td></tr>
<tr><td><code id="segment_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="segment_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly. Notes: this will change the stated start/end position of the segment. 
Emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the segment in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a segment in the cornell box. 
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(segment(start = c(100, 100, 100), end = c(455, 455, 455), radius = 50)) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

# Draw a line graph representing a normal distribution, but with metal:
xvals = seq(-3, 3, length.out = 30)
yvals = dnorm(xvals)

scene_list = list()
for(i in 1:(length(xvals) - 1)) {
  scene_list[[i]] = segment(start = c(555/2 + xvals[i] * 80, yvals[i] * 800, 555/2),
                            end = c(555/2 + xvals[i + 1] * 80, yvals[i + 1] * 800, 555/2),
                            radius = 10,
                            material = metal())
}
scene_segments = do.call(rbind,scene_list)
if(run_documentation()) {
generate_cornell() %&gt;% 
  add_object(scene_segments) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

#Draw the outline of a cube:

cube_outline = segment(start = c(100, 100, 100), end = c(100, 100, 455), radius = 10) %&gt;%
  add_object(segment(start = c(100, 100, 100), end = c(100, 455, 100), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 100, 100), end = c(455, 100, 100), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 100, 455), end = c(100, 455, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 100, 455), end = c(455, 100, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 455, 455), end = c(100, 455, 100), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 455, 455), end = c(455, 455, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(455, 455, 100), end = c(455, 100, 100), radius = 10)) %&gt;%
  add_object(segment(start = c(455, 455, 100), end = c(455, 455, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(455, 100, 100), end = c(455, 100, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(455, 100, 455), end = c(455, 455, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 455, 100), end = c(455, 455, 100), radius = 10))

if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(cube_outline) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

#Shrink and rotate the cube
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(group_objects(cube_outline, pivot_point = c(555/2, 555/2, 555/2),
                           angle = c(45,45,45), scale = c(0.5,0.5,0.5))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
</code></pre>

<hr>
<h2 id='slerp'>Slerp</h2><span id='topic+slerp'></span>

<h3>Description</h3>

<p>Slerp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slerp(vec1, vec2, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slerp_+3A_vec1">vec1</code></td>
<td>
<p>Value</p>
</td></tr>
<tr><td><code id="slerp_+3A_vec2">vec2</code></td>
<td>
<p>Value</p>
</td></tr>
<tr><td><code id="slerp_+3A_n">n</code></td>
<td>
<p>Value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>

<hr>
<h2 id='sphere'>Sphere Object</h2><span id='topic+sphere'></span>

<h3>Description</h3>

<p>Sphere Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere(
  x = 0,
  y = 0,
  z = 0,
  radius = 1,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphere_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the sphere.</p>
</td></tr>
<tr><td><code id="sphere_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate of the center of the sphere.</p>
</td></tr>
<tr><td><code id="sphere_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the sphere.</p>
</td></tr>
<tr><td><code id="sphere_+3A_radius">radius</code></td>
<td>
<p>Default '1'. Radius of the sphere.</p>
</td></tr>
<tr><td><code id="sphere_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>. The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="sphere_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="sphere_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="sphere_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="sphere_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the sphere in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a sphere in the cornell box.
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(sphere(x = 555/2, y = 555/2, z = 555/2, radius = 100)) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, clamp_value = 5)
}

#Generate a gold sphere in the cornell box
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(sphere(x = 555/2, y = 100, z = 555/2, radius = 100, 
                    material = microfacet(color = "gold"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, clamp_value = 5)
}
</code></pre>

<hr>
<h2 id='text3d'>Text Object</h2><span id='topic+text3d'></span>

<h3>Description</h3>

<p>Text Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text3d(
  label,
  x = 0,
  y = 0,
  z = 0,
  text_height = 1,
  orientation = "xy",
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text3d_+3A_label">label</code></td>
<td>
<p>Text string.</p>
</td></tr>
<tr><td><code id="text3d_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the label.</p>
</td></tr>
<tr><td><code id="text3d_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate of the center of the label.</p>
</td></tr>
<tr><td><code id="text3d_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the label.</p>
</td></tr>
<tr><td><code id="text3d_+3A_text_height">text_height</code></td>
<td>
<p>Default '1'. Height of the text.</p>
</td></tr>
<tr><td><code id="text3d_+3A_orientation">orientation</code></td>
<td>
<p>Default 'xy'. Orientation of the plane. Other options are 'yz' and 'xz'.</p>
</td></tr>
<tr><td><code id="text3d_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>. The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="text3d_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="text3d_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="text3d_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="text3d_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the text in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a label in the cornell box.
if(run_documentation()) {
generate_cornell() %&gt;% 
  add_object(text3d(label="Cornell Box", x=555/2,y=555/2,z=555/2,text_height=60,
                    material=diffuse(color="grey10"), angle=c(0,180,0))) %&gt;% 
  render_scene(samples=128, clamp_value=10)
}
if(run_documentation()) {
#Change the orientation
generate_cornell() %&gt;% 
  add_object(text3d(label="YZ Plane", x=550,y=555/2,z=555/2,text_height=100,
                    orientation = "yz",
                    material=diffuse(color="grey10"), angle=c(0,180,0))) %&gt;% 
 add_object(text3d(label="XY Plane", z=550,y=555/2,x=555/2,text_height=100,
                    orientation = "xy",
                    material=diffuse(color="grey10"), angle=c(0,180,0))) %&gt;% 
 add_object(text3d(label="XZ Plane", z=555/2,y=5,x=555/2,text_height=100,
                    orientation = "xz",
                    material=diffuse(color="grey10"))) %&gt;% 
  render_scene(samples=128, clamp_value=10)
}
if(run_documentation()) {
#Add an label in front of a sphere
generate_cornell() %&gt;% 
  add_object(text3d(label="Cornell Box", x=555/2,y=555/2,z=555/2,text_height=60,
                    material=diffuse(color="grey10"), angle=c(0,180,0))) %&gt;% 
  add_object(text3d(label="Sphere", x=555/2,y=100,z=100,text_height=30,
                    material=diffuse(color="white"), angle=c(0,180,0))) %&gt;% 
  add_object(sphere(y=100,radius=100,z=555/2,x=555/2,
                    material=glossy(color="purple"))) %&gt;% 
  add_object(sphere(y=555,radius=100,z=-1000,x=555/2,
                    material=light(intensity=100,
                                   spotlight_focus=c(555/2,100,100)))) %&gt;%                   
  render_scene(samples=128, clamp_value=10)
}
  
if(run_documentation()) {
#A room full of bees
bee_list = list()
for(i in 1:100) {
bee_list[[i]] = text3d("B", x=20+runif(1)*525, y=20+runif(1)*525, z=20+runif(1)*525, 
                       text_height = 50, angle=c(0,180,0))
}
bees = do.call(rbind,bee_list)
generate_cornell() %&gt;% 
  add_object(bees) %&gt;%                   
  render_scene(samples=128, clamp_value=10)
}
</code></pre>

<hr>
<h2 id='triangle'>Triangle Object</h2><span id='topic+triangle'></span>

<h3>Description</h3>

<p>Triangle Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle(
  v1 = c(1, 0, 0),
  v2 = c(0, 1, 0),
  v3 = c(-1, 0, 0),
  n1 = rep(NA, 3),
  n2 = rep(NA, 3),
  n3 = rep(NA, 3),
  color1 = rep(NA, 3),
  color2 = rep(NA, 3),
  color3 = rep(NA, 3),
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  reversed = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle_+3A_v1">v1</code></td>
<td>
<p>Default 'c(1, 0, 0)'. Length-3 vector indicating the x, y, and z coordinate of the first triangle vertex.</p>
</td></tr>
<tr><td><code id="triangle_+3A_v2">v2</code></td>
<td>
<p>Default 'c(0, 1, 0)'. Length-3 vector indicating the x, y, and z coordinate of the second triangle vertex.</p>
</td></tr>
<tr><td><code id="triangle_+3A_v3">v3</code></td>
<td>
<p>Default 'c(-1, 0, 0)'. Length-3 vector indicating the x, y, and z coordinate of the third triangle vertex.</p>
</td></tr>
<tr><td><code id="triangle_+3A_n1">n1</code></td>
<td>
<p>Default 'NA'. Length-3 vector indicating the normal vector associated with the first triangle vertex.</p>
</td></tr>
<tr><td><code id="triangle_+3A_n2">n2</code></td>
<td>
<p>Default 'NA'. Length-3 vector indicating the normal vector associated with the second triangle vertex.</p>
</td></tr>
<tr><td><code id="triangle_+3A_n3">n3</code></td>
<td>
<p>Default 'NA'. Length-3 vector indicating the normal vector associated with the third triangle vertex.</p>
</td></tr>
<tr><td><code id="triangle_+3A_color1">color1</code></td>
<td>
<p>Default 'NA'. Length-3 vector or string indicating the color associated with the first triangle vertex. 
If NA but other vertices specified, color inherits from material.</p>
</td></tr>
<tr><td><code id="triangle_+3A_color2">color2</code></td>
<td>
<p>Default 'NA'. Length-3 vector or string indicating the color associated with the second triangle vertex.
If NA but other vertices specified, color inherits from material.</p>
</td></tr>
<tr><td><code id="triangle_+3A_color3">color3</code></td>
<td>
<p>Default 'NA'. Length-3 vector or string indicating the color associated with the third triangle vertex.
If NA but other vertices specified, color inherits from material.</p>
</td></tr>
<tr><td><code id="triangle_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="triangle_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="triangle_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="triangle_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="triangle_+3A_reversed">reversed</code></td>
<td>
<p>Default 'FALSE'. Similar to the 'flipped' argument, but this reverses the handedness of the 
triangle so it will be oriented in the opposite direction.</p>
</td></tr>
<tr><td><code id="triangle_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the XZ plane in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a triangle in the Cornell box.
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(triangle(v1 = c(100, 100, 100), v2 = c(555/2, 455, 455), v3 = c(455, 100, 100),
                      material = diffuse(color = "purple"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
#Pass individual colors to each vertex: 
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(triangle(v1 = c(100, 100, 100), v2 = c(555/2, 455, 455), v3 = c(455, 100, 100),
                      color1 = "green", color2 = "yellow", color3 = "red")) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
</code></pre>

<hr>
<h2 id='tween'>Tween</h2><span id='topic+tween'></span>

<h3>Description</h3>

<p>Tween
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tween(vals, n, ease = "cubic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tween_+3A_vals">vals</code></td>
<td>
<p>Numeric values</p>
</td></tr>
<tr><td><code id="tween_+3A_n">n</code></td>
<td>
<p>Frames</p>
</td></tr>
<tr><td><code id="tween_+3A_ease">ease</code></td>
<td>
<p>type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number
</p>

<hr>
<h2 id='xy_rect'>Rectangular XY Plane Object</h2><span id='topic+xy_rect'></span>

<h3>Description</h3>

<p>Rectangular XY Plane Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy_rect(
  x = 0,
  y = 0,
  z = 0,
  xwidth = 1,
  ywidth = 1,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xy_rect_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the rectangle.</p>
</td></tr>
<tr><td><code id="xy_rect_+3A_y">y</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the rectangle.</p>
</td></tr>
<tr><td><code id="xy_rect_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the rectangle.</p>
</td></tr>
<tr><td><code id="xy_rect_+3A_xwidth">xwidth</code></td>
<td>
<p>Default '1'. x-width of the rectangle.</p>
</td></tr>
<tr><td><code id="xy_rect_+3A_ywidth">ywidth</code></td>
<td>
<p>Default '1'. y-width of the rectangle.</p>
</td></tr>
<tr><td><code id="xy_rect_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="xy_rect_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="xy_rect_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="xy_rect_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="xy_rect_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the XY plane in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a purple rectangle in the cornell box.
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(xy_rect(x = 555/2, y = 100, z = 555/2, xwidth = 200, ywidth = 200,
             material = diffuse(color = "purple"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800), lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

#Generate a gold plane in the cornell box
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(xy_rect(x = 555/2, y = 100, z = 555/2, 
                     xwidth = 200, ywidth = 200, angle = c(0, 30, 0),
                     material = metal(color = "gold"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
</code></pre>

<hr>
<h2 id='xz_rect'>Rectangular XZ Plane Object</h2><span id='topic+xz_rect'></span>

<h3>Description</h3>

<p>Rectangular XZ Plane Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xz_rect(
  x = 0,
  xwidth = 1,
  z = 0,
  zwidth = 1,
  y = 0,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xz_rect_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the rectangle.</p>
</td></tr>
<tr><td><code id="xz_rect_+3A_xwidth">xwidth</code></td>
<td>
<p>Default '1'. x-width of the rectangle.</p>
</td></tr>
<tr><td><code id="xz_rect_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the rectangle.</p>
</td></tr>
<tr><td><code id="xz_rect_+3A_zwidth">zwidth</code></td>
<td>
<p>Default '1'. z-width of the rectangle.</p>
</td></tr>
<tr><td><code id="xz_rect_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate of the center of the rectangle.</p>
</td></tr>
<tr><td><code id="xz_rect_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="xz_rect_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="xz_rect_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="xz_rect_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="xz_rect_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the XZ plane in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a purple rectangle in the cornell box.
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(xz_rect(x = 555/2, y = 100, z = 555/2, xwidth = 200, zwidth = 200,
             material = diffuse(color = "purple"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

#Generate a gold plane in the cornell box
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(xz_rect(x = 555/2, y = 100, z = 555/2, 
             xwidth = 200, zwidth = 200, angle = c(0, 30, 0),
             material = metal(color = "gold"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
</code></pre>

<hr>
<h2 id='yz_rect'>Rectangular YZ Plane Object</h2><span id='topic+yz_rect'></span>

<h3>Description</h3>

<p>Rectangular YZ Plane Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yz_rect(
  x = 0,
  y = 0,
  z = 0,
  ywidth = 1,
  zwidth = 1,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yz_rect_+3A_x">x</code></td>
<td>
<p>Default '0'. x-coordinate of the center of the rectangle.</p>
</td></tr>
<tr><td><code id="yz_rect_+3A_y">y</code></td>
<td>
<p>Default '0'. y-coordinate of the center of the rectangle.</p>
</td></tr>
<tr><td><code id="yz_rect_+3A_z">z</code></td>
<td>
<p>Default '0'. z-coordinate of the center of the rectangle.</p>
</td></tr>
<tr><td><code id="yz_rect_+3A_ywidth">ywidth</code></td>
<td>
<p>Default '1'. y-width of the rectangle.</p>
</td></tr>
<tr><td><code id="yz_rect_+3A_zwidth">zwidth</code></td>
<td>
<p>Default '1'. z-width of the rectangle.</p>
</td></tr>
<tr><td><code id="yz_rect_+3A_material">material</code></td>
<td>
<p>Default  <code><a href="#topic+diffuse">diffuse</a></code>.The material, called from one of the material 
functions <code><a href="#topic+diffuse">diffuse</a></code>, <code><a href="#topic+metal">metal</a></code>, or <code><a href="#topic+dielectric">dielectric</a></code>.</p>
</td></tr>
<tr><td><code id="yz_rect_+3A_angle">angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td></tr>
<tr><td><code id="yz_rect_+3A_order_rotation">order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to &quot;x&quot;, &quot;y&quot;, and &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="yz_rect_+3A_flipped">flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td></tr>
<tr><td><code id="yz_rect_+3A_scale">scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single row of a tibble describing the YZ plane in the scene.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a purple rectangle in the cornell box.
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(yz_rect(x = 100, y = 100, z = 555/2, ywidth = 200, zwidth = 200,
                     material = diffuse(color = "purple"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
#Generate a gold plane in the cornell box
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(yz_rect(x = 100, y = 100, z = 555/2, 
                     ywidth = 200, zwidth = 200, angle = c(0, 30, 0),
                     material = metal(color = "gold"))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
