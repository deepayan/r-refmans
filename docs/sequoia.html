<!DOCTYPE html><html><head><title>Help for package sequoia</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sequoia}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CalcBYprobs'><p>Birth year probabilities</p></a></li>
<li><a href='#CalcCorners'><p>Corner coordinates</p></a></li>
<li><a href='#CalcMaxMismatch'><p>Maximum Number of Mismatches</p></a></li>
<li><a href='#CalcOHLLR'><p>Calculate OH and LLR for a pedigree</p></a></li>
<li><a href='#CalcPairLL'><p>Calculate Likelihoods for Alternative Relationships</p></a></li>
<li><a href='#CalcRped'><p>Calculate Pedigree Relatedness</p></a></li>
<li><a href='#CheckAP'><p>check AgePrior</p></a></li>
<li><a href='#CheckGeno'><p>Check Genotype Matrix</p></a></li>
<li><a href='#CheckLH'><p>Check LifeHistData</p></a></li>
<li><a href='#CheckParams'><p>Check if input parameters are valid</p></a></li>
<li><a href='#ComparePairs'><p>Compare Pairwise Relationships</p></a></li>
<li><a href='#Conf_griffin'><p>Example output from estimating confidence probabilities: griffins</p></a></li>
<li><a href='#CountAgeDif'><p>Tabulate Age Differences</p></a></li>
<li><a href='#DoErrors'><p>Fortran Simulate Genotyping Errors</p></a></li>
<li><a href='#DuplicateCheck'><p>Check Data for Duplicates.</p></a></li>
<li><a href='#DyadCompare'><p>Compare Dyads (DEPRECATED)</p></a></li>
<li><a href='#ErrToM'><p>Generate Genotyping Error Matrix</p></a></li>
<li><a href='#EstConf'><p>Confidence Probabilities</p></a></li>
<li><a href='#EstEr'><p>Estimate genotyping error rate (REMOVED; will be re-implemented)</p></a></li>
<li><a href='#FieldMums_griffin'><p>Example field-observed mothers: griffins</p></a></li>
<li><a href='#FindFamilies'><p>Assign Family IDs</p></a></li>
<li><a href='#FoldSibGPs'><p>Fold IDs of Sibship Grandparents</p></a></li>
<li><a href='#FortifyPairs'><p>Make Pairs Fortran Compatible</p></a></li>
<li><a href='#Geno_griffin'><p>Example genotype file: Griffins</p></a></li>
<li><a href='#Geno_HSg5'><p>Example genotype file: 'HSg5'</p></a></li>
<li><a href='#GenoConvert'><p>Convert Genotype Data</p></a></li>
<li><a href='#GetAncestors'><p>Get ancestors</p></a></li>
<li><a href='#getAssignCat'><p>Assignability of Reference Pedigree</p></a></li>
<li><a href='#GetDescendants'><p>Get descendants</p></a></li>
<li><a href='#GetDummifiable'><p>Dummifiable IDs</p></a></li>
<li><a href='#getGenerations'><p>Count Generations</p></a></li>
<li><a href='#GetLLRAge'><p>LLR-age from Ageprior Matrix</p></a></li>
<li><a href='#GetMaybeRel'><p>Find Putative Relatives</p></a></li>
<li><a href='#GetRelA'><p>Array with Pairwise Relationships</p></a></li>
<li><a href='#GetRelM'><p>Matrix with Pairwise Relationships</p></a></li>
<li><a href='#Inherit_patterns'><p>Inheritance patterns</p></a></li>
<li><a href='#LH_griffin'><p>Example life history data: griffins</p></a></li>
<li><a href='#LH_HSg5'><p>Example life history file: 'HSg5'</p></a></li>
<li><a href='#LHConvert'><p>Extract Sex and Birth Year from PLINK File</p></a></li>
<li><a href='#LLRplot'><p>Scatter Plot of Pair LLRs</p></a></li>
<li><a href='#MakeAgePrior'><p>Age Priors</p></a></li>
<li><a href='#MaybeRel_griffin'><p>Example output from check for relatives: griffins</p></a></li>
<li><a href='#MergeFill'><p>Special Merge</p></a></li>
<li><a href='#MkAPdefault'><p>Make default 1/0 ageprior</p></a></li>
<li><a href='#MkFortParams'><p>PARAM to FortPARAM</p></a></li>
<li><a href='#MkGenoErrors'><p>Simulate Genotyping Errors</p></a></li>
<li><a href='#mtSame2Dif'><p>Check and recode mtSame matrix</p></a></li>
<li><a href='#NumToID'><p>Change Numeric Pedigree back to Character Pedigree</p></a></li>
<li><a href='#OHperSNP'><p>Estimate Genotyping Error Rate</p></a></li>
<li><a href='#orderLH'><p>Order Lifehistory Data</p></a></li>
<li><a href='#ParamToSpecs'><p>PARAM to Specs</p></a></li>
<li><a href='#Ped_griffin'><p>Example pedigree: griffins</p></a></li>
<li><a href='#Ped_HSg5'><p>Example pedigree: 'HSg5'</p></a></li>
<li><a href='#PedCompare'><p>Compare Two Pedigrees</p></a></li>
<li><a href='#PedPolish'><p>Fix Pedigree</p></a></li>
<li><a href='#PedStripFID'><p>Back-transform IDs</p></a></li>
<li><a href='#PedToNum'><p>Turn Character Pedigree into Numeric Pedigree</p></a></li>
<li><a href='#PlotAgePrior'><p>Plot Age Priors</p></a></li>
<li><a href='#PlotPairLL'><p>Plot Pair Log10-Likelihoods</p></a></li>
<li><a href='#PlotPedComp'><p>Visualise PedCompare Output</p></a></li>
<li><a href='#PlotRelPairs'><p>Plot Pairwise Relationships</p></a></li>
<li><a href='#PlotSeqSum'><p>Plot Summary Overview of sequoia Output</p></a></li>
<li><a href='#PlotSnpStats'><p>plot SnpStats results</p></a></li>
<li><a href='#rc'><p>Find siblings</p></a></li>
<li><a href='#SelectNotSampled'><p>select non-genotyped parents</p></a></li>
<li><a href='#SeqOUT_griffin'><p>Example output from pedigree inference: griffins</p></a></li>
<li><a href='#SeqOUT_HSg5'><p>Example output from pedigree inference: 'HSg5'</p></a></li>
<li><a href='#SeqParSib'><p>Fortran Wrapper for Pedigree Reconstruction</p></a></li>
<li><a href='#sequoia'><p>Pedigree Reconstruction</p></a></li>
<li><a href='#SibMatch'><p>Find the closest matching inferred sibship to a true sibship</p></a></li>
<li><a href='#SimGeno'><p>Simulate Genotypes</p></a></li>
<li><a href='#SimGeno_example'><p>Example genotype file: 'HSg5'</p></a></li>
<li><a href='#SmoothAP'><p>Smooth out dips in ageprior matrix</p></a></li>
<li><a href='#SnpStats'><p>SNP Summary Statistics</p></a></li>
<li><a href='#SpecsToParam'><p>Specs to PARAM</p></a></li>
<li><a href='#SummarySeq'><p>Summarise Sequoia Output or Pedigree</p></a></li>
<li><a href='#tryCatch.W.E'><p>tryCatch both warnings (with value) and errors</p></a></li>
<li><a href='#Vcomp'><p>Compare two vectors</p></a></li>
<li><a href='#VennSquares'><p>Square Venn diagram</p></a></li>
<li><a href='#writeColumns'><p>Write Data to a File Column-wise</p></a></li>
<li><a href='#writeSeq'><p>Write Sequoia Output to File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pedigree Inference from SNPs</td>
</tr>
<tr>
<td>Version:</td>
<td>2.11.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Jisca Huisman [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jisca Huisman &lt;jisca.huisman@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multi-generational pedigree inference from incomplete data on
    hundreds of SNPs, including parentage assignment and sibship clustering.
    See Huisman (2017) (&lt;<a href="https://doi.org/10.1111%2F1755-0998.12665">doi:10.1111/1755-0998.12665</a>&gt;) for more information.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jiscah.github.io/">https://jiscah.github.io/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr (&ge; 1.8.0), stats, utils, graphics, cli</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>openxlsx, knitr, rmarkdown, bookdown, kinship2, R.rsp,
hexbin, data.table, vcfR, adegenet</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Fortran95</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-28 06:46:46 UTC; jisca</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-28 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CalcBYprobs'>Birth year probabilities</h2><span id='topic+CalcBYprobs'></span>

<h3>Description</h3>

<p>Estimate the probability that an individual with unknown birth
year is born in year <code>y</code>, based on <code>BirthYears</code> or <code>BY.min</code>
and/or <code>BY.max</code> of its parents, offspring, and siblings, combined with
<code>AgePrior</code> (the age distribution of other parent-offspring pairs),
and/or <code>Year.last</code> of its parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcBYprobs(Pedigree = NULL, LifeHistData = NULL, AgePrior = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcBYprobs_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with columns id-dam-sire.</p>
</td></tr>
<tr><td><code id="CalcBYprobs_+3A_lifehistdata">LifeHistData</code></td>
<td>
<p>data.frame with up to 6 columns:
</p>

<dl>
<dt>ID</dt><dd><p>max. 30 characters long</p>
</dd>
<dt>Sex</dt><dd><p>1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,
other numbers or NA = unknown</p>
</dd>
<dt>BirthYear </dt><dd><p>birth or hatching year, integer, with missing values as NA
or any negative number.</p>
</dd>
<dt>BY.min</dt><dd><p>minimum birth year, only used if BirthYear is missing</p>
</dd>
<dt>BY.max</dt><dd><p>maximum birth year, only used if BirthYear is missing</p>
</dd>
<dt>Year.last</dt><dd><p>Last year in which individual could have had offspring. Can
e.g. in mammals be the year before death for females, and year after death
for males. </p>
</dd> </dl>

<p>&quot;Birth year&quot; may be in any arbitrary discrete time unit relevant to the
species (day, month, decade), as long as parents are never born in the same
time unit as their offspring, and only integers are used. Individuals do not
need to be in the same order as in &lsquo;GenoM&rsquo;, nor do all genotyped individuals
need to be included.</p>
</td></tr>
<tr><td><code id="CalcBYprobs_+3A_ageprior">AgePrior</code></td>
<td>
<p>a matrix with probability ratios for individuals with age
difference A to have relationship R, as generated by
<code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code>. If <code>NULL</code>, <code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code> is
called using its default values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assists in estimating birth years of individuals for
which these are unknown, provided they have at least one parent or one
offspring in the pedigree. It is not a substitute for field-based estimates
of age, only a method to summarise the pedigree + birth year based
information.
</p>


<h3>Value</h3>

<p>A matrix with for each individual (rows) in the pedigree that has a missing
birth year in <code>LifeHistData</code>, or that is not included in
<code>LifeHistData</code>, the probability that it is born in <code>y</code> (columns).
Probabilities are rounded to 3 decimal points and may therefore not sum
exactly to 1.
</p>


<h3>WARNING</h3>

<p>Any errors in the pedigree or lifehistory data will cause errors in the
birth year probabilities of their parents and offspring, and putatively also
of more distant ancestors and descendants. If the ageprior is based on the
same erroneous pedigree and lifehistory data, all birth year probabilities
will be affected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code> to estimate effect of age on
relationships.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BYprobs &lt;- CalcBYprobs(Pedigree = SeqOUT_griffin$Pedigree,
                       LifeHistData = SeqOUT_griffin$LifeHist)
## Not run: 
# heatmap
lattice::levelplot(t(BYprobs), aspect="fill", col.regions=hcl.colors)

## End(Not run)

</code></pre>

<hr>
<h2 id='CalcCorners'>Corner coordinates</h2><span id='topic+CalcCorners'></span>

<h3>Description</h3>

<p>Calculate corner coordinates for each of the four rectangles in
a square Venn diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcCorners(count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcCorners_+3A_count">count</code></td>
<td>
<p>a length 5 named vector: 'Total', 'Match', 'Mismatch',
'P1only', and 'P2only'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the bottom-left corner of the Ped1 square is (0,0); offset is done
by <code><a href="#topic+VennSquares">VennSquares</a></code>. The size of the Ped1 and Ped2 squares is
proportional to their count, i.e. N1 = count[&quot;Total&quot;] -
count[&quot;P2only&quot;], and the length of each size thus proportional to the
<code>sqrt</code> of that.
</p>
<p>The x-location of the Ped2 square is a function of the amount of overlap
(Match + Mismatch): if 0
coco[&quot;Ped1&quot;, &quot;xright&quot;], if 100
coco[&quot;Ped1&quot;, &quot;xright&quot;]; and proportional in-between these two extremes.
</p>
<p>The overlap area between Ped1 and Ped2 is split into Mismatch (bottom) and
Match (top).
</p>


<h3>Value</h3>

<p>a 4x4 matrix with columns &quot;xleft&quot;, &quot;xright&quot;, &quot;ybottom&quot;, &quot;ytop&quot; (as
used by <code><a href="graphics.html#topic+rect">rect</a></code>) and rows &quot;Ped1&quot;, &quot;Ped2&quot;, &quot;Mismatch&quot;, &quot;Match&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PlotPedComp">PlotPedComp</a>, <a href="#topic+VennSquares">VennSquares</a></code>
</p>

<hr>
<h2 id='CalcMaxMismatch'>Maximum Number of Mismatches</h2><span id='topic+CalcMaxMismatch'></span>

<h3>Description</h3>

<p>Calculate the maximum expected number of mismatches for
duplicate samples, parent-offspring pairs, and parent-parent-offspring
trios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcMaxMismatch(Err, MAF, ErrFlavour = "version2.9", qntl = 1 - 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcMaxMismatch_+3A_err">Err</code></td>
<td>
<p>estimated genotyping error rate, as a single number or 3x3 matrix
(averaged value(s) across SNPs), or a vector with the same length as MAF,
or a nSnp x 3 x 3 array. If a matrix, this should be the probability of
observed genotype (columns) conditional on actual genotype (rows). Each row
must therefore sum to 1. If an array, each 3x3 slice should abide this rule.</p>
</td></tr>
<tr><td><code id="CalcMaxMismatch_+3A_maf">MAF</code></td>
<td>
<p>vector with minor allele frequency at each SNP.</p>
</td></tr>
<tr><td><code id="CalcMaxMismatch_+3A_errflavour">ErrFlavour</code></td>
<td>
<p>function that takes <code>Err</code> as input, and returns a 3x3
matrix of observed (columns) conditional on actual (rows) genotypes, or
choose from inbuilt ones as used in sequoia 'version2.0', 'version1.3', or
'version1.1'. Ignored if <code>Err</code> is a matrix. See <code><a href="#topic+ErrToM">ErrToM</a></code>.</p>
</td></tr>
<tr><td><code id="CalcMaxMismatch_+3A_qntl">qntl</code></td>
<td>
<p>quantile of binomial distribution to be used as the maximum, of
individual-level probability. For a desired dataset-level probability
quantile <code class="reqn">Q</code>, use <code>qntl</code><code class="reqn">= Q^{(1/N)}</code>, where <code class="reqn">N</code> is
the number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The thresholds for maximum number of mismatches calculated here aim
to minimise false negatives, i.e. to minimise the chance that any true
duplicates or true parent-offspring pairs are already excluded during the
filtering steps where these <code>MaxMismatch</code> values are used.
Consequently, there is a high probability of false positives, i.e. it is
likely that some sample pairs with fewer mismatches than the
<code>MaxMismatch</code> threshold, are in fact not duplicate samples or
parent-offspring pairs. Use of these <code>MaxMismatch</code> thresholds is
therefore only the first step of pedigree reconstruction by
<code><a href="#topic+sequoia">sequoia</a></code>.
</p>


<h3>Value</h3>

<p>A vector with three integers:
</p>
<table>
<tr><td><code>DUP</code></td>
<td>
<p>Maximum number of differences between 2 samples from the
same individual</p>
</td></tr>
<tr><td><code>OH</code></td>
<td>
<p>Maximum number of Opposing Homozygous SNPs between a true
parent-offspring pair</p>
</td></tr>
<tr><td><code>ME</code></td>
<td>
<p>Maximum number of Mendelian Errors among a true parent-parent-
offspring trio</p>
</td></tr></table>
<p>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SnpStats">SnpStats</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CalcMaxMismatch(Err = 0.05, MAF = runif(n=100, min=0.3, max=0.5))
## Not run: 
CalcMaxMismatch(Err = 0.02, MAF = SnpStats(MyGenoMatrix, Plot=FALSE)[,"AF"])

## End(Not run)

</code></pre>

<hr>
<h2 id='CalcOHLLR'>Calculate OH and LLR for a pedigree</h2><span id='topic+CalcOHLLR'></span>

<h3>Description</h3>

<p>Count opposite homozygous (OH) loci between parent-offspring
pairs and Mendelian errors (ME) between parent-parent-offspring trios, and
calculate the parental log-likelihood ratios (LLR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcOHLLR(
  Pedigree = NULL,
  GenoM = NULL,
  CalcLLR = TRUE,
  LifeHistData = NULL,
  AgePrior = FALSE,
  SeqList = NULL,
  Err = 1e-04,
  ErrFlavour = "version2.9",
  Tassign = 0.5,
  Tfilter = -2,
  Complex = "full",
  Herm = "no",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcOHLLR_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with columns id-dam-sire. May include
non-genotyped individuals, which will be treated as dummy individuals. If
provided, any pedigree in <code>SeqList</code> is ignored.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_genom">GenoM</code></td>
<td>
<p>numeric matrix with genotype data: One row per individual,
one column per SNP, coded as 0, 1, 2, missing values as a negative number
or NA. You can reformat data with <code><a href="#topic+GenoConvert">GenoConvert</a></code>, or use other
packages to get it into a genlight object and then use <code>as.matrix</code>.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_calcllr">CalcLLR</code></td>
<td>
<p>calculate log-likelihood ratios for all assigned parents
(genotyped + dummy/non-genotyped; parent vs. otherwise related). If
<strong><code>FALSE</code></strong>, only number of mismatching SNPs are counted (OH &amp;
ME), and parameters <code>LifeHistData</code>, <code>AgePrior</code>, <code>Err</code>,
<code>Tassign</code>, and <code>Complex</code> are <strong>ignored</strong>. Note also that
calculating likelihood ratios is much more time consuming than counting OH
&amp; ME.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_lifehistdata">LifeHistData</code></td>
<td>
<p>data.frame with up to 6 columns:
</p>

<dl>
<dt>ID</dt><dd><p>max. 30 characters long</p>
</dd>
<dt>Sex</dt><dd><p>1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,
other numbers or NA = unknown</p>
</dd>
<dt>BirthYear </dt><dd><p>birth or hatching year, integer, with missing values as NA
or any negative number.</p>
</dd>
<dt>BY.min</dt><dd><p>minimum birth year, only used if BirthYear is missing</p>
</dd>
<dt>BY.max</dt><dd><p>maximum birth year, only used if BirthYear is missing</p>
</dd>
<dt>Year.last</dt><dd><p>Last year in which individual could have had offspring. Can
e.g. in mammals be the year before death for females, and year after death
for males. </p>
</dd> </dl>

<p>&quot;Birth year&quot; may be in any arbitrary discrete time unit relevant to the
species (day, month, decade), as long as parents are never born in the same
time unit as their offspring, and only integers are used. Individuals do not
need to be in the same order as in &lsquo;GenoM&rsquo;, nor do all genotyped individuals
need to be included.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_ageprior">AgePrior</code></td>
<td>
<p>logical (<code>TRUE/FALSE</code>) whether to estimate the ageprior
from <code>Pedigree</code> and <code>LifeHistData</code>, or a matrix as generated by
<code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code> and included in the <code><a href="#topic+sequoia">sequoia</a></code>
output. The <code>AgePrior</code> affects which relationships are considered
possible: only those where <code class="reqn">P(A|R) / P(A) &gt; 0</code>.  When <code>TRUE</code>,
<code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code> is called using its default values. When
<code>FALSE</code>, all relationships are considered possible for all age
differences, except that parent-offspring pairs cannot have age difference
zero, and grand-parental pairs have an age difference of at least two.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_seqlist">SeqList</code></td>
<td>
<p>list with output from <code><a href="#topic+sequoia">sequoia</a></code>. If input
parameter <code>Pedigree=NULL</code>, <code>SeqList$Pedigree</code> will be used if
present, and <code>SeqList$PedigreePar</code> otherwise. If <code>SeqList$Specs</code>
is present, input parameters with the same name as its items are ignored,
except 'CalcLLR' and 'AgePriors=FALSE'. The list elements  &lsquo;LifeHist&rsquo;,
&lsquo;AgePriors&rsquo;, and &lsquo;ErrM&rsquo; are also used if present, and override the
corresponding input parameters.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_err">Err</code></td>
<td>
<p>estimated genotyping error rate, as a single number, or a length 3
vector with P(hom|hom), P(het|hom), P(hom|het), or a 3x3 matrix. See
details below. The error rate is presumed constant across SNPs, and
missingness is presumed random with respect to actual genotype. Using
<code>Err</code> &gt;5% is not recommended, and <code>Err</code> &gt;10% strongly
discouraged.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_errflavour">ErrFlavour</code></td>
<td>
<p>function that takes <code>Err</code> (single number) as input,
and returns a length 3 vector or 3x3 matrix, or choose from inbuilt options
'version2.9', 'version2.0', 'version1.3', or 'version1.1', referring to the
sequoia version in which they were the default. Ignored if <code>Err</code> is a
vector or matrix. See <code><a href="#topic+ErrToM">ErrToM</a></code> for details.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_tassign">Tassign</code></td>
<td>
<p>minimum LLR required for acceptance of proposed relationship,
relative to next most likely relationship. Higher values result in more
conservative assignments. Must be zero or positive.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_tfilter">Tfilter</code></td>
<td>
<p>threshold log10-likelihood ratio (LLR) between a proposed
relationship versus unrelated, to select candidate relatives. Typically a
negative value, related to the fact that unconditional likelihoods are
calculated during the filtering steps. More negative values may decrease
non-assignment, but will increase computational time.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_complex">Complex</code></td>
<td>
<p>Breeding system complexity. Either &quot;full&quot; (default), &quot;simp&quot;
(simplified, no explicit consideration of inbred relationships), &quot;mono&quot;
(monogamous).</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_herm">Herm</code></td>
<td>
<p>Hermaphrodites, either &quot;no&quot;, &quot;A&quot; (distinguish between dam and
sire role, default if at least 1 individual with sex=4), or &quot;B&quot; (no
distinction between dam and sire role). Both of the latter deal with
selfing.</p>
</td></tr>
<tr><td><code id="CalcOHLLR_+3A_quiet">quiet</code></td>
<td>
<p>logical, suppress messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any individual in <code>Pedigree</code> that does not occur in
<code>GenoM</code> is substituted by a dummy individual; these can be recognised
by the value 0' in columns 'SNPd.id.dam' and 'SNPd.id.sire' in the output.
For non-genotyped individuals the parental log-likelihood ratio can be
calculated if they have at least one genotyped offspring (see also
<code><a href="#topic+getAssignCat">getAssignCat</a></code>).
</p>
<p>The birth years in <code>LifeHistData</code> and the <code>AgePrior</code> are not used
in the calculation and do not affect the value of the likelihoods for the
various relationships, but they _are_ used during some filtering steps, and
may therefore affect the likelihood _ratio_. The default
(<code>AgePrior=FALSE</code>) assumes all age-relationship combinations are
possible, which may mean that some additional alternatives are considered
compared to the <code><a href="#topic+sequoia">sequoia</a></code> default, resulting in somewhat lower
<code>LLR</code> values.
</p>
<p>A negative LLR for A's parent B indicates either that B is not truely the
parent of A, or that B's parents are incorrect. The latter may cause B's
presumed true, unobserved genotype to divert from its observed genotype,
with downstream consequences for its offspring. In rare cases it may also
be due to 'weird', non-implemented double or triple relationships between A
and B.
</p>


<h3>Value</h3>

<p>The <code>Pedigree</code> dataframe with additional columns:
</p>
<table>
<tr><td><code>LLRdam</code></td>
<td>
<p>Log10-Likelihood Ratio (LLR) of this female being the mother,
versus the next most likely relationship between the focal individual and
this female (see Details for relationships considered)</p>
</td></tr>
<tr><td><code>LLRsire</code></td>
<td>
<p>idem, for male parent</p>
</td></tr>
<tr><td><code>LLRpair</code></td>
<td>
<p>LLR for the parental pair, versus the next most likely
configuration between the three individuals (with one or neither parent
assigned)</p>
</td></tr>
<tr><td><code>OHdam</code></td>
<td>
<p>Number of loci at which the offspring and mother are
opposite homozygotes</p>
</td></tr>
<tr><td><code>OHsire</code></td>
<td>
<p>idem, for father</p>
</td></tr>
<tr><td><code>MEpair</code></td>
<td>
<p>Number of Mendelian errors between the offspring and the
parent pair, includes OH as well as e.g. parents being opposing
homozygotes, but the offspring not being a heterozygote. The offspring
being OH with both parents is counted as 2 errors.</p>
</td></tr>
<tr><td><code>SNPd.id</code></td>
<td>
<p>Number of SNPs scored (non-missing) for the focal individual</p>
</td></tr>
<tr><td><code>SNPd.id.dam</code></td>
<td>
<p>Number of SNPs scored (non-missing) for both individual
and dam</p>
</td></tr>
<tr><td><code>SNPd.id.sire</code></td>
<td>
<p>Number of SNPs scored for both individual and sire</p>
</td></tr>
<tr><td><code>Sexx</code></td>
<td>
<p>Sex in LifeHistData, or inferred Sex when assigned as part of
parent-pair</p>
</td></tr>
<tr><td><code>BY.est</code></td>
<td>
<p>mode of birth year probability distribution</p>
</td></tr>
<tr><td><code>BY.lo</code></td>
<td>
<p>lower limit of 95% highest density region of birth year
probability distribution</p>
</td></tr>
<tr><td><code>BY.hi</code></td>
<td>
<p>higher limit</p>
</td></tr>
</table>
<p>The columns 'LLRdam', 'LLRsire' and 'LLRpair' are only included when
<code>CalcLLR=TRUE</code>. When a parent or parent-pair is incompatible with the
lifehistory data or presumed genotyping error rate, the error value '777' may
be given.
</p>
<p>The columns 'Sexx', 'BY.est', 'BY.lo' and 'BY.hi' are only included when
<code>LifeHistData</code> is provided, and at least one genotyped individual has an
unknown birth year or unknown sex.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SummarySeq">SummarySeq</a></code> for visualisation of OH &amp; LLR
distributions; <code><a href="#topic+CalcPairLL">CalcPairLL</a></code> for the likelihoods underlying the
LLR, <code><a href="#topic+GenoConvert">GenoConvert</a></code> to read in various genotype data formats,
<code><a href="#topic+CheckGeno">CheckGeno</a></code>; <code><a href="#topic+PedPolish">PedPolish</a></code> to check and 'polish' the
pedigree; <code><a href="#topic+getAssignCat">getAssignCat</a></code> to find which id-parent pairs are both
genotyped or can be substituted by dummy individuals; <code><a href="#topic+sequoia">sequoia</a></code>
for pedigree reconstruction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># count Mendelian errors in an existing pedigree
Ped.OH &lt;- CalcOHLLR(Pedigree = Ped_HSg5, GenoM = SimGeno_example,
                    CalcLLR = FALSE)
Ped.OH[50:55,]
# view histograms
SummarySeq(Ped.OH, Panels="OH")

# Parent likelihood ratios in an existing pedigree, including for
# non-genotyped parents
Ped.LLR &lt;- CalcOHLLR(Pedigree = Ped_HSg5, GenoM = SimGeno_example,
                    CalcLLR = TRUE, LifeHistData=LH_HSg5, AgePrior=TRUE)
SummarySeq(Ped.LLR, Panels="LLR")

## Not run: 
# likelihood ratios change with presumed genotyping error rate:
Ped.LLR.B &lt;- CalcOHLLR(Pedigree = Ped_HSg5, GenoM = SimGeno_example,
                    CalcLLR = TRUE, LifeHistData=LH_HSg5, AgePrior=TRUE,
                    Err = 0.005)
SummarySeq(Ped.LLR.B, Panels="LLR")

# run sequoia with CalcLLR=FALSE, and add OH + LLR later:
SeqOUT &lt;- sequoia(Geno_griffin, LH_griffin, CalcLLR=FALSE,quiet=TRUE,Plot=FALSE)
PedA &lt;- CalcOHLLR(Pedigree = SeqOUT[["Pedigree"]][, 1:3], GenoM = Genotypes,
  LifeHistData = LH_griffin, AgePrior = TRUE, Complex = "full")
SummarySeq(PedA, Panels=c("LLR", "OH"))

## End(Not run)

</code></pre>

<hr>
<h2 id='CalcPairLL'>Calculate Likelihoods for Alternative Relationships</h2><span id='topic+CalcPairLL'></span>

<h3>Description</h3>

<p>For each specified pair of individuals, calculate the
log10-likelihoods of being PO, FS, HS, GP, FA, HA, U (see Details).
Individuals must be genotyped or have at least one genotyped offspring.
</p>
<p><strong>NOTE</strong> values <code class="reqn">&gt;0</code> are various <code>NA</code> types, see 'Likelihood
special codes' in 'Value' section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcPairLL(
  Pairs = NULL,
  GenoM = NULL,
  Pedigree = NULL,
  LifeHistData = NULL,
  AgePrior = TRUE,
  SeqList = NULL,
  Complex = "full",
  Herm = "no",
  Err = 1e-04,
  ErrFlavour = "version2.9",
  Tassign = 0.5,
  Tfilter = -2,
  quiet = FALSE,
  Plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcPairLL_+3A_pairs">Pairs</code></td>
<td>
<p>dataframe with columns <code>ID1</code> and <code>ID2</code>, and
optionally
</p>

<dl>
<dt>Sex1</dt><dd><p>Sex of ID1, 1=female, 2=male, 3=unknown, or <code>NA</code> to take
from <code>LifeHistData</code>. The sex of individuals occurring as parent in
<code>Pedigree</code> cannot be altered.</p>
</dd>
<dt>Sex2</dt><dd><p>Sex of ID2</p>
</dd>
<dt>AgeDif</dt><dd><p>Age difference in whole time units, BirthYear1 - BirthYear2
(i.e. positive if ID2 is born before ID1). If <code>NA</code>, calculated from
<code>LifeHistData</code>. Use '999' to explicitly specify 'unknown'.</p>
</dd>
<dt>focal</dt><dd><p>relationship character abbreviation; PO, FS, HS, GP or U. See
Details for its effect and explanation of abbreviations. Default: U</p>
</dd>
<dt>patmat</dt><dd><p>1=maternal relatives, 2=paternal relatives. Only relevant for
HS &amp; GP, for which it defaults to Sex1, or 1 if Sex1=3, but is currently
only predictably implemented for pairs of two genotyped individuals.
Always equal to Sex2 for PO pairs when Sex2 is known.</p>
</dd>
<dt>dropPar1</dt><dd><p>Drop the parents of <code>ID1</code> before calculating the pair
likelihood, rather than conditioning on them; choose from 'none', 'dam',
'sire', or 'both'. See example. If e.g. the pair shares a common mother,
'none' and 'sire' will condition on this shared mother and not calculate the
likelihood that they are maternal siblings, while dropPar1='dam' or 'both'
will calculate that likelihood, and the other likelihoods as if the mother
of ID1 were unknown.</p>
</dd>
<dt>dropPar2</dt><dd><p>as <code>dropPar1</code>, for <code>ID2</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_genom">GenoM</code></td>
<td>
<p>numeric matrix with genotype data: One row per individual,
one column per SNP, coded as 0, 1, 2, missing values as a negative number
or NA. You can reformat data with <code><a href="#topic+GenoConvert">GenoConvert</a></code>, or use other
packages to get it into a genlight object and then use <code>as.matrix</code>.</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with columns id-dam-sire; likelihoods will be
calculated conditional on the pedigree. May include non-genotyped
individuals, which will be treated as dummy individuals.</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_lifehistdata">LifeHistData</code></td>
<td>
<p>data.frame with up to 6 columns:
</p>

<dl>
<dt>ID</dt><dd><p>max. 30 characters long</p>
</dd>
<dt>Sex</dt><dd><p>1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,
other numbers or NA = unknown</p>
</dd>
<dt>BirthYear </dt><dd><p>birth or hatching year, integer, with missing values as NA
or any negative number.</p>
</dd>
<dt>BY.min</dt><dd><p>minimum birth year, only used if BirthYear is missing</p>
</dd>
<dt>BY.max</dt><dd><p>maximum birth year, only used if BirthYear is missing</p>
</dd>
<dt>Year.last</dt><dd><p>Last year in which individual could have had offspring. Can
e.g. in mammals be the year before death for females, and year after death
for males. </p>
</dd> </dl>

<p>&quot;Birth year&quot; may be in any arbitrary discrete time unit relevant to the
species (day, month, decade), as long as parents are never born in the same
time unit as their offspring, and only integers are used. Individuals do not
need to be in the same order as in &lsquo;GenoM&rsquo;, nor do all genotyped individuals
need to be included.</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_ageprior">AgePrior</code></td>
<td>
<p>logical (<code>TRUE/FALSE</code>) whether to estimate the ageprior
from <code>Pedigree</code> and <code>LifeHistData</code>, or a matrix as generated by
<code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code> and included in the <code><a href="#topic+sequoia">sequoia</a></code>
output. The <code>AgePrior</code> affects which relationships are considered
possible: only those where <code class="reqn">P(A|R) / P(A) &gt; 0</code>.  When <code>TRUE</code>,
<code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code> is called using its default values. When
<code>FALSE</code>, all relationships are considered possible for all age
differences, except that parent-offspring pairs cannot have age difference
zero, and grand-parental pairs have an age difference of at least two.</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_seqlist">SeqList</code></td>
<td>
<p>list with output from <code><a href="#topic+sequoia">sequoia</a></code>. If input
parameter <code>Pedigree=NULL</code>, <code>SeqList$Pedigree</code> will be used if
present, and <code>SeqList$PedigreePar</code> otherwise. If <code>SeqList$Specs</code>
is present, input parameters with the same name as its items are ignored.
The list elements 'LifeHist', 'AgePriors', and 'ErrM' are also used if
present, and override the corresponding input parameters.</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_complex">Complex</code></td>
<td>
<p>Breeding system complexity. Either &quot;full&quot; (default), &quot;simp&quot;
(simplified, no explicit consideration of inbred relationships), &quot;mono&quot;
(monogamous).</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_herm">Herm</code></td>
<td>
<p>Hermaphrodites, either &quot;no&quot;, &quot;A&quot; (distinguish between dam and
sire role, default if at least 1 individual with sex=4), or &quot;B&quot; (no
distinction between dam and sire role). Both of the latter deal with
selfing.</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_err">Err</code></td>
<td>
<p>estimated genotyping error rate, as a single number, or a length 3
vector with P(hom|hom), P(het|hom), P(hom|het), or a 3x3 matrix. See
details below. The error rate is presumed constant across SNPs, and
missingness is presumed random with respect to actual genotype. Using
<code>Err</code> &gt;5% is not recommended, and <code>Err</code> &gt;10% strongly
discouraged.</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_errflavour">ErrFlavour</code></td>
<td>
<p>function that takes <code>Err</code> (single number) as input,
and returns a length 3 vector or 3x3 matrix, or choose from inbuilt options
'version2.9', 'version2.0', 'version1.3', or 'version1.1', referring to the
sequoia version in which they were the default. Ignored if <code>Err</code> is a
vector or matrix. See <code><a href="#topic+ErrToM">ErrToM</a></code> for details.</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_tassign">Tassign</code></td>
<td>
<p>minimum LLR required for acceptance of proposed relationship,
relative to next most likely relationship. Higher values result in more
conservative assignments. Must be zero or positive.</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_tfilter">Tfilter</code></td>
<td>
<p>threshold log10-likelihood ratio (LLR) between a proposed
relationship versus unrelated, to select candidate relatives. Typically a
negative value, related to the fact that unconditional likelihoods are
calculated during the filtering steps. More negative values may decrease
non-assignment, but will increase computational time.</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_quiet">quiet</code></td>
<td>
<p>logical, suppress messages</p>
</td></tr>
<tr><td><code id="CalcPairLL_+3A_plot">Plot</code></td>
<td>
<p>logical, display scatter plots by <code><a href="#topic+PlotPairLL">PlotPairLL</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The same pair may be included multiple times, e.g. with different
sex, age difference, or focal relationship, to explore their effect on the
likelihoods. Likelihoods are only calculated for relationships that are
possible given the age difference, e.g. PO (parent-offspring) is not
calculated for pairs with an age difference of 0.
</p>
<p>Non-genotyped individuals can be included if they have at least one
genotyped offspring and can be turned into a dummy (see
<code><a href="#topic+getAssignCat">getAssignCat</a></code>); to establish this a pedigree must be provided.
</p>
<p><strong>Warning 1</strong>: There is no check whether the input pedigree is genetically
sensible, it is simply conditioned upon. Checking whether a pedigree is
compatible with the SNP data can be done with <code><a href="#topic+CalcOHLLR">CalcOHLLR</a></code>.
</p>
<p><strong>Warning 2</strong>: Conditioning on a <code>Pedigree</code> can make computation
orders of magnitude slower.
</p>


<h3>Value</h3>

<p>The <code>Pairs</code> dataframe including all optional columns listed
above, plus the additional columns:
</p>
<table>
<tr><td><code>xx</code></td>
<td>
<p>Log10-Likelihood of this pair having relationship xx, with xx
being the relationship abbreviations listed below.</p>
</td></tr>
<tr><td><code>TopRel</code></td>
<td>
<p>Abbreviation of most likely relationship</p>
</td></tr>
<tr><td><code>LLR</code></td>
<td>
<p>Log10-Likelihood ratio between most-likely and second most likely
relationships. Other LLRs, e.g. between most-likely and unrelated, can
easily be computed.</p>
</td></tr>
</table>
<p><strong>Relationship abbreviations:</strong>
</p>
<table>
<tr><td><code>PO</code></td>
<td>
<p>Parent - offspring</p>
</td></tr>
<tr><td><code>FS</code></td>
<td>
<p>Full siblings</p>
</td></tr>
<tr><td><code>HS</code></td>
<td>
<p>Half siblings</p>
</td></tr>
<tr><td><code>GP</code></td>
<td>
<p>Grandparent</p>
</td></tr>
<tr><td><code>FA</code></td>
<td>
<p>Full avuncular</p>
</td></tr>
<tr><td><code>HA</code></td>
<td>
<p>Half avuncular and other 3rd degree relationships</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Unrelated</p>
</td></tr>
<tr><td><code>2nd</code></td>
<td>
<p>Unclear which type of 2nd degree relatives
(HS, GP, or FA)</p>
</td></tr>
<tr><td><code>??</code></td>
<td>
<p>Unclear which type of 1st, 2nd or 3rd degree
relatives</p>
</td></tr>
</table>
<p><strong>Likelihood special codes:</strong>
</p>
<table>
<tr><td><code>222</code></td>
<td>
<p>Maybe (via) other parent (e.g. focal=&quot;GP&quot;, but as likely to be
maternal as paternal grandparent, and therefore not assignable)</p>
</td></tr>
<tr><td><code>333</code></td>
<td>
<p>Excluded from comparison (shouldn't occur)</p>
</td></tr>
<tr><td><code>444</code></td>
<td>
<p>Not implemented (e.g. would create an odd double/triple
relationship in combination with the provided pedigree)</p>
</td></tr>
<tr><td><code>777</code></td>
<td>
<p>Impossible (e.g. cannot be both full sibling and grandparent)</p>
</td></tr>
<tr><td><code>888</code></td>
<td>
<p>Already assigned in the provided pedigree (see <code>dropPar</code>
arguments)</p>
</td></tr>
<tr><td><code>999</code></td>
<td>
<p>NA</p>
</td></tr>
</table>


<h3>Why does it say 777 (impossible)?</h3>

<p>This function uses the same machinery as <code>sequoia</code>, which will to save
time not calculate the likelihood when it is quickly obvious that the pair
cannot be related in the specified manner.
</p>
<p>For PO (putative parent-offspring pairs) this is the case when:
</p>

<ul>
<li><p> the sex of the candidate parent, via <code>Pairs$Sex2</code> or
<code>LifeHistData</code>, does not match <code>Pairs$patmat</code>, which defaults
to 1 (maternal relatives, i.e. dam)
</p>
</li>
<li><p> a dam is already assigned via <code>Pedigree</code> and <code>Pairs$dropPar1
    ='none'</code>, and <code>Pairs$patmat = 1</code>
</p>
</li>
<li> <p><code>Pairs$focal</code> is not 'U' (the default), and the OH count between the
two individuals exceeds MaxMismatchOH. This value can be found in
<code>SeqList$Specs</code>), and is calculated by <code><a href="#topic+CalcMaxMismatch">CalcMaxMismatch</a></code>
</p>
</li>
<li><p> the age difference, either calculated from <code>LifeHistData</code> or
specified via <code>Pairs$AgeDif</code>, is impossible for a parent-offspring
pair according to the age prior. The latter can be specified via
<code>AgePrior</code>, or is taken from <code>SeqList</code>, or is calculated when
both <code>Pedigree</code> and <code>LifeHistData</code> are provided.
</p>
</li></ul>

<p>For FS (putative full siblings) this happens when e.g. ID1 has a dam
assigned which is not dropped (<code>Pairs$dropPar1='none'</code> or
<code>'sire'</code>), and the OH count between ID1's dam and ID2 exceeds
MaxMismatchOH. The easiest way to 'fix' this is by increasing the presumed
genotyping error rate.
</p>


<h3>Double relationships &amp; focal relationship</h3>

<p>Especially when Complex='full', not only the seven relationship
alternatives listed above are considered, but a whole range of possible
double and even triple relationships. For example, mother A and offspring B
(PO) may also be paternal half-siblings (HS, A and A's mother mated with
same male), grandmother and grand-offspring (GP, B's father is A's son), or
paternal aunt (B's father is a full or half sib of A).
</p>
<p>The likelihood reported as 'LL_PO' is the most-likely one of the possible
alternatives, among those that are not impossible due to age differences or
due to the pedigree (as reconstructed up to that point). Whether e.g. the
likelihood to be both PO &amp; HS is counted as PO or as HS, depends on the
situation and is determined by the variable 'focal': During parentage
assignment, it is counted as PO but not HS, while during sibship
clustering, it is counted as HS but not PO &ndash; not omitting from the
alternative relationship would result in a deadlock.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PlotPairLL">PlotPairLL</a></code> to plot alternative relationship pairs from
the output; <code><a href="#topic+CalcOHLLR">CalcOHLLR</a></code> to calculate LLR for parents &amp;
parent-pairs in a pedigree; <code><a href="#topic+GetRelM">GetRelM</a></code> to find all pairwise
relatives according to the pedigree; <code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code> to get
likely relative pairs not in the pedigree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CalcPairLL(Pairs = data.frame(ID1='i116_2006_M', ID2='i119_2006_M'),
           GenoM = Geno_griffin, Err = 1e-04, Plot=FALSE)

## likelihoods underlying parent LLR in pedigree:
# Example: dams for bottom 3 individuals
tail(SeqOUT_griffin$PedigreePar, n=3)
# set up dataframe with these pairs. LLRdam &amp; LLRsire ignore any co-parent
Pairs_d &lt;- data.frame(ID1 = SeqOUT_griffin$PedigreePar$id[140:142],
                      ID2 = SeqOUT_griffin$PedigreePar$dam[140:142],
                      focal = "PO",
                      dropPar1 = 'both')

# Calculate LL's, conditional on the rest of the pedigree + age differences
CalcPairLL(Pairs_d, GenoM = Geno_griffin, Err = 1e-04,
           LifeHistData = LH_griffin, Pedigree = SeqOUT_griffin$PedigreePar)

# LLR changes when ignoring age and/or pedigree, as different relationships
# become (im)possible
CalcPairLL(Pairs_d, GenoM = Geno_griffin, Err = 1e-04)

# LLRpair is calculated conditional on co-parent, and min. of dam &amp; sire LLR
Pairs_d$dropPar1 &lt;- 'dam'
Pairs_s &lt;- data.frame(ID1 = SeqOUT_griffin$PedigreePar$id[141:142],
                      ID2 = SeqOUT_griffin$PedigreePar$sire[141:142],
                      focal = "PO",
                      dropPar1 = 'sire')
CalcPairLL(rbind(Pairs_d, Pairs_s), GenoM = Geno_griffin, Err = 1e-04,
           LifeHistData = LH_griffin, Pedigree = SeqOUT_griffin$PedigreePar)


## likelihoods underlying LLR in getMaybeRel output:
MaybeRel_griffin$MaybePar[1:5, ]
FivePairs &lt;- MaybeRel_griffin$MaybePar[1:5, c("ID1", "ID2", "Sex1", "Sex2")]
PairLL &lt;- CalcPairLL(Pairs = rbind( cbind(FivePairs, focal = "PO"),
                                    cbind(FivePairs, focal = "HS"),
                                    cbind(FivePairs, focal = "GP")),
                     GenoM = Geno_griffin, Plot=FALSE)
PairLL[PairLL$ID1=="i121_2007_M", ]
# LL(FS)==222 : HSHA, HSGP, FAHA more likely than FS
# LL(GP) higher when focal=HS: GP via 'other' parent also considered
# LL(FA) higher when focal=PO: FAHA, or FS of 'other' parent

</code></pre>

<hr>
<h2 id='CalcRped'>Calculate Pedigree Relatedness</h2><span id='topic+CalcRped'></span>

<h3>Description</h3>

<p>Morph pedigree into a <span class="pkg">kinship2</span> compatible format and use
<code><a href="kinship2.html#topic+kinship">kinship</a></code> to calculate kinship coefficients;
relatedness = 2*kinship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcRped(Pedigree, OUT = "DF")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcRped_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with columns id-dam-sire.</p>
</td></tr>
<tr><td><code id="CalcRped_+3A_out">OUT</code></td>
<td>
<p>desired output format, 'M' for matrix or 'DF' for dataframe with
columns IID1 - IID2 - R.ped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or dataframe.
</p>

<hr>
<h2 id='CheckAP'>check AgePrior</h2><span id='topic+CheckAP'></span>

<h3>Description</h3>

<p>Check that the provided AgePrior is in the correct format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckAP(AgePrior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CheckAP_+3A_ageprior">AgePrior</code></td>
<td>
<p>matrix with 'MaxAgeParent' rows and columns M-P-FS-MHS-PHS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AgePrior in corrected format, if necessary
</p>

<hr>
<h2 id='CheckGeno'>Check Genotype Matrix</h2><span id='topic+CheckGeno'></span>

<h3>Description</h3>

<p>Check that the provided genotype matrix is in the correct
format, and check for low call rate samples and SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckGeno(
  GenoM,
  quiet = FALSE,
  Plot = FALSE,
  Return = "GenoM",
  Strict = TRUE,
  DumPrefix = c("F0", "M0")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CheckGeno_+3A_genom">GenoM</code></td>
<td>
<p>the genotype matrix.</p>
</td></tr>
<tr><td><code id="CheckGeno_+3A_quiet">quiet</code></td>
<td>
<p>suppress messages.</p>
</td></tr>
<tr><td><code id="CheckGeno_+3A_plot">Plot</code></td>
<td>
<p>display the plots of <code><a href="#topic+SnpStats">SnpStats</a></code>.</p>
</td></tr>
<tr><td><code id="CheckGeno_+3A_return">Return</code></td>
<td>
<p>either 'GenoM' to return the cleaned-up genotype matrix, or
'excl' to return a list with excluded SNPs and individuals (see Value).</p>
</td></tr>
<tr><td><code id="CheckGeno_+3A_strict">Strict</code></td>
<td>
<p>Exclude any individuals genotyped for &lt;5
genotyped for &lt;5
up to version 2.4.1. Otherwise only excluded are (very nearly) monomorphic
SNPs, SNPs scored for fewer than 2 individuals, and individuals scored for
fewer than 2 SNPs.</p>
</td></tr>
<tr><td><code id="CheckGeno_+3A_dumprefix">DumPrefix</code></td>
<td>
<p>length 2 vector, to check if these don't occur among
genotyped individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>Return='excl'</code> a list with, if any are found:
</p>
<table>
<tr><td><code>ExcludedSNPs</code></td>
<td>
<p>SNPs scored for &lt;10
excluded when running <code><a href="#topic+sequoia">sequoia</a></code></p>
</td></tr>
<tr><td><code>ExcludedSnps-mono</code></td>
<td>
<p>monomorphic (fixed) SNPs; automatically excluded
when running <code><a href="#topic+sequoia">sequoia</a></code>. This includes nearly-fixed SNPs with
MAF <code class="reqn">= 1/2N</code>. Column numbers are *after* removal of
<code>ExcludedSNPs</code>, if any.</p>
</td></tr>
<tr><td><code>ExcludedIndiv</code></td>
<td>
<p>Individuals scored for &lt;5
reliably included during pedigree reconstruction. Individual call rate is
calculated after removal of 'Excluded SNPs'</p>
</td></tr>
<tr><td><code>Snps-LowCallRate</code></td>
<td>
<p>SNPs scored for 10
recommended to be filtered out</p>
</td></tr>
<tr><td><code>Indiv-LowCallRate</code></td>
<td>
<p>individuals scored for &lt;50
recommended to be filtered out</p>
</td></tr>
</table>
<p>When <code>Return='excl'</code> the return is <code><a href="base.html#topic+invisible">invisible</a></code>, i.e. a check
is run and warnings or errors are always displayed, but nothing may be
returned.
</p>


<h3>Thresholds</h3>

<p>Appropriate call rate thresholds for SNPs and
individuals depend on the total number of SNPs, distribution of call rates,
genotyping errors, and the proportion of candidate parents that are SNPd
(sibship clustering is more prone to false positives). Note that filtering
first on SNP call rate tends to keep more individuals in.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SnpStats">SnpStats</a></code> to calculate SNP call rates;
<code><a href="#topic+CalcOHLLR">CalcOHLLR</a></code> to count the number of SNPs scored in both focal
individual and parent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenoM &lt;- SimGeno(Ped_HSg5, nSnp=400, CallRate = runif(400, 0.2, 0.8))
# the quick way:
GenoM.checked &lt;- CheckGeno(GenoM, Return="GenoM")

# the user supervised way:
Excl &lt;- CheckGeno(GenoM, Return = "excl")
GenoM.orig &lt;- GenoM   # make a 'backup' copy
if ("ExcludedSnps" %in% names(Excl))
  GenoM &lt;- GenoM[, -Excl[["ExcludedSnps"]]]
if ("ExcludedSnps-mono" %in% names(Excl))
  GenoM &lt;- GenoM[, -Excl[["ExcludedSnps-mono"]]]
if ("ExcludedIndiv" %in% names(Excl))
  GenoM &lt;- GenoM[!rownames(GenoM) %in% Excl[["ExcludedIndiv"]], ]

# warning about  SNPs scored for &lt;50% of individuals ?
# note: this is not necessarily a problem, and sometimes unavoidable.
SnpCallRate &lt;- apply(GenoM, MARGIN=2,
                     FUN = function(x) sum(x!=-9)) / nrow(GenoM)
hist(SnpCallRate, breaks=50, col="grey")
GenoM &lt;- GenoM[, SnpCallRate &gt; 0.6]

# to filter out low call rate individuals: (also not necessarily a problem)
IndivCallRate &lt;- apply(GenoM, MARGIN=1,
                       FUN = function(x) sum(x!=-9)) / ncol(GenoM)
hist(IndivCallRate, breaks=50, col="grey")
GoodSamples &lt;- rownames(GenoM)[ IndivCallRate &gt; 0.8]

</code></pre>

<hr>
<h2 id='CheckLH'>Check LifeHistData</h2><span id='topic+CheckLH'></span>

<h3>Description</h3>

<p>Check that the provided LifeHistData is in the correct format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckLH(LifeHistData, gID = NA, sorted = TRUE, returnDups = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CheckLH_+3A_lifehistdata">LifeHistData</code></td>
<td>
<p>the dataframe with ID - Sex - Birth year, and optionally
BY.min - BY.max - YearLast.</p>
</td></tr>
<tr><td><code id="CheckLH_+3A_gid">gID</code></td>
<td>
<p>character vector with names of genotyped individuals, i.e.
rownames(GenoM).</p>
</td></tr>
<tr><td><code id="CheckLH_+3A_sorted">sorted</code></td>
<td>
<p>logical, return lifehistdata for genotyped individuals only,
in strictly the same order. Will including padding with 'empty' rows if an
individual in gID was not in the input-LH.</p>
</td></tr>
<tr><td><code id="CheckLH_+3A_returndups">returnDups</code></td>
<td>
<p>logical, instead of just the (sorted) LifeHistData, return
a list that also includes a dataframe with duplicate entries and/or a
character vector with genotyped IDs not occuring in LifeHistData (as
formerly returned by <code>DuplicateCheck</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with LifeHistData formatted for use by the Fortran
part of the program, or a list with duplicate and missing entries.
</p>

<hr>
<h2 id='CheckParams'>Check if input parameters are valid</h2><span id='topic+CheckParams'></span>

<h3>Description</h3>

<p>Check if input parameter value is of the proper kind and value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckParams(PARAM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CheckParams_+3A_param">PARAM</code></td>
<td>
<p>list with input parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing except errors, warnings, and messages
</p>

<hr>
<h2 id='ComparePairs'>Compare Pairwise Relationships</h2><span id='topic+ComparePairs'></span>

<h3>Description</h3>

<p>Compare, count and identify different types of relative pairs
between two pedigrees, or within one pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComparePairs(
  Ped1 = NULL,
  Ped2 = NULL,
  Pairs2 = NULL,
  GenBack = 1,
  patmat = FALSE,
  ExcludeDummies = TRUE,
  DumPrefix = c("F0", "M0"),
  Return = "Counts"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComparePairs_+3A_ped1">Ped1</code></td>
<td>
<p>first (e.g. original/reference) pedigree, dataframe with 3
columns: id-dam-sire.</p>
</td></tr>
<tr><td><code id="ComparePairs_+3A_ped2">Ped2</code></td>
<td>
<p>optional second (e.g. inferred) pedigree.</p>
</td></tr>
<tr><td><code id="ComparePairs_+3A_pairs2">Pairs2</code></td>
<td>
<p>optional dataframe with as first three columns: ID1-ID2-
relationship, e.g. as returned by <code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code>. Column names
and any additional columns are ignored. May be provided in addition to, or
instead of <code>Ped2</code>.</p>
</td></tr>
<tr><td><code id="ComparePairs_+3A_genback">GenBack</code></td>
<td>
<p>number of generations back to consider; 1 returns
parent-offspring and sibling relationships, 2 also returns grandparental,
avuncular and first cousins. GenBack &gt;2 is not implemented.</p>
</td></tr>
<tr><td><code id="ComparePairs_+3A_patmat">patmat</code></td>
<td>
<p>logical, distinguish between paternal versus maternal relative
pairs?</p>
</td></tr>
<tr><td><code id="ComparePairs_+3A_excludedummies">ExcludeDummies</code></td>
<td>
<p>logical, exclude dummy IDs from output? Individuals
with e.g. the same dummy father will still be counted as paternal halfsibs.
No attempt is made to match dummies in one pedigree to individuals in the
other pedigree; for that use <code><a href="#topic+PedCompare">PedCompare</a></code>.</p>
</td></tr>
<tr><td><code id="ComparePairs_+3A_dumprefix">DumPrefix</code></td>
<td>
<p>character vector with the prefixes identifying dummy
individuals. Use 'F0' ('M0') to avoid matching to regular individuals with
IDs starting with 'F' ('M'), provided <code>Ped2</code> has fewer than 999 dummy
females (males).</p>
</td></tr>
<tr><td><code id="ComparePairs_+3A_return">Return</code></td>
<td>
<p>return a matrix with <code>Counts</code> or a <code>Summary</code> of the
number of identical relationships and mismatches per relationship, or
detailed results as a 2xNxN <code>Array</code> or as a <code>Dataframe</code>.
<code>All</code> returns a list with all four.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>Pairs2</code> is as returned by <code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code>
(identified by the additional column names 'LLR' and 'OH'), these
relationship categories are appended with an '?' in the output, to
distinguish them from those derived from <code>Ped2</code>.
</p>
<p>When <code>Pairs2$TopRel</code> contains values other than the ones listed among
the return values for the combination of <code>patmat</code> and <code>GenBack</code>,
they are prioritised in decreasing order of factor levels, or in decreasing
alphabetical order, and before the default (<code>ped2</code> derived) levels.
</p>
<p>The matrix returned by <code><a href="#topic+DyadCompare">DyadCompare</a></code> [Deprecated] is a subset
of the matrix returned here using default settings.
</p>


<h3>Value</h3>

<p>Depending on <code>Return</code>, one of the following, or a list with all:
</p>
<table>
<tr><td><code>Counts</code></td>
<td>
<p>(the default), a matrix with counts, with the classification in
<code>Ped1</code> on rows and that in <code>Ped2</code> in columns. Counts for
'symmetrical' pairs (&quot;FS&quot;, &quot;HS&quot;, &quot;MHS&quot;, &quot;PHS&quot;, &quot;FC1&quot;, &quot;DFC1&quot;, &quot;U&quot;,&quot;X&quot;) are
divided by two.</p>
</td></tr>
<tr><td><code>Summary</code></td>
<td>
<p>a matrix with one row per relationship type and four columns
, named as if <code>Ped1</code> is the true pedigree:
</p>

<dl>
<dt>n</dt><dd><p>total number of pairs with that relationship in <code>Ped1</code>,
and occurring in <code>Ped2</code></p>
</dd>
<dt>OK</dt><dd><p>Number of pairs with same relationship in <code>Ped2</code> as in
<code>Ped1</code></p>
</dd>
<dt>hi</dt><dd><p>Number of pairs with 'higher' relationship in <code>Ped2</code> as
in <code>Ped1</code> (e.g. FS instead of HS; ranking is the order given
below)</p>
</dd>
<dt>lo</dt><dd><p>Number of pairs with 'lower' relationship in <code>Ped2</code> as in
<code>Ped1</code>, but not unrelated in <code>Ped2</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code>Array</code></td>
<td>
<p>a 2xNxN array (if <code>Ped2</code> or <code>Pairs2</code> is specified)
or a NxN matrix , where N is the total number of individuals occurring in
<code>Ped1</code> and/or <code>Ped2</code>.</p>
</td></tr>
<tr><td><code>Dataframe</code></td>
<td>
<p>a dataframe with <code class="reqn">N^2</code> rows and four columns:
</p>

<dl>
<dt>id.A</dt><dd><p>First individual of the pair</p>
</dd>
<dt>id.B</dt><dd><p>Second individual of the pair</p>
</dd>
<dt>RC1</dt><dd><p>the relationship category in <code>Ped1</code>, as a factor with all
considered categories as levels, including those with 0 count</p>
</dd>
<dt>RC2</dt><dd><p>the relationship category in <code>Ped2</code></p>
</dd>
</dl>

<p>Each pair is listed twice, e.g. once as P and once as O, or twice as FS.</p>
</td></tr>
</table>


<h3>Relationship abbreviations and ranking</h3>

<p>By default (<code>GenBack=1, patmat=FALSE</code>) the following 7 relationships are
distinguished:
</p>

<ul>
<li> <p><strong>S</strong>: Self (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>MP</strong>: Parent
</p>
</li>
<li> <p><strong>O</strong>: Offspring (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>FS</strong>: Full sibling
</p>
</li>
<li> <p><strong>HS</strong>: Half sibling
</p>
</li>
<li> <p><strong>U</strong>: Unrelated, or otherwise related
</p>
</li>
<li> <p><strong>X</strong>: Either or both individuals not occurring in both
pedigrees
</p>
</li></ul>

<p>In the array and dataframe, 'MP' indicates that the second (column)
individual is the parent of the first (row) individual, and 'O' indicates the
reverse.
</p>
<p>When <code>GenBack=1, patmat=TRUE</code> the categories are (S)-M-P-(O)-FS-MHS-PHS-
U-X.
</p>
<p>When <code>GenBack=2, patmat=TRUE</code>, the following relationships are
distinguished:
</p>

<ul>
<li> <p><strong>S</strong>: Self (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>M</strong>: Mother
</p>
</li>
<li> <p><strong>P</strong>: Father
</p>
</li>
<li> <p><strong>O</strong>: Offspring (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>FS</strong>: Full sibling
</p>
</li>
<li> <p><strong>MHS</strong>: Maternal half-sibling
</p>
</li>
<li> <p><strong>PHS</strong>: Paternal half-sibling
</p>
</li>
<li> <p><strong>MGM</strong>: Maternal grandmother
</p>
</li>
<li> <p><strong>MGF</strong>: Maternal grandfather
</p>
</li>
<li> <p><strong>PGM</strong>: Paternal grandmother
</p>
</li>
<li> <p><strong>PGF</strong>: Paternal grandfather
</p>
</li>
<li> <p><strong>GO</strong>: Grand-offspring (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>FA</strong>: Full avuncular; maternal or paternal aunt or uncle
</p>
</li>
<li> <p><strong>HA</strong>: Half avuncular
</p>
</li>
<li> <p><strong>FN</strong>: Full nephew/niece (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>HN</strong>: Half nephew/niece (not included in <code>Counts</code>)
</p>
</li>
<li> <p><strong>FC1</strong>: Full first cousin
</p>
</li>
<li> <p><strong>DFC1</strong>: Double full first cousin
</p>
</li>
<li> <p><strong>U</strong>: Unrelated, or otherwise related
</p>
</li>
<li> <p><strong>X</strong>: Either or both individuals not occurring in both pedigrees
</p>
</li></ul>

<p>Note that for avuncular and cousin relationships no distinction is made
between paternal versus maternal, as this may differ between the two
individuals and would generate a large number of sub-classes. When a pair is
related via multiple paths, the first-listed relationship is returned. To get
all the different paths between a pair, use <code><a href="#topic+GetRelM">GetRelM</a></code> with
<code>Return='Array'</code>.
</p>
<p>When <code>GenBack=2, patmat=FALSE</code>, MGM, MGF, PGM and PGF are combined
into GP, with the rest of the categories analogous to the above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PedCompare">PedCompare</a></code> for individual-based comparison;
<code><a href="#topic+GetRelM">GetRelM</a></code> for a pairwise relationships matrix of a single
pedigree; <code><a href="#topic+PlotRelPairs">PlotRelPairs</a></code> for visualisation of relationships
within each pedigree.
</p>
<p>To estimate P(actual relationship (Ped1) | inferred relationship (Ped2)),
see examples at <code><a href="#topic+EstConf">EstConf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PairsG &lt;- ComparePairs(Ped_griffin, SeqOUT_griffin[["Pedigree"]],
                       patmat = TRUE, ExcludeDummies = TRUE, Return = "All")
PairsG$Counts

# pairwise correct assignment rate:
PairsG$Summary[,"OK"] / PairsG$Summary[,"n"]

# check specific pair:
PairsG$Array[, "i190_2010_M", "i168_2009_F"]
# or
RelDF &lt;- PairsG$Dataframe   # for brevity
RelDF[RelDF$id.A=="i190_2010_M" &amp; RelDF$id.B=="i168_2009_F", ]

# Colony-style lists of full sib dyads &amp; half sib dyads:
FullSibDyads &lt;- with(RelDF, RelDF[Ped1 == "FS" &amp; id.A &lt; id.B, ])
HalfSibDyads &lt;- with(RelDF, RelDF[Ped1 == "HS" &amp; id.A &lt; id.B, ])
# Use 'id.A &lt; id.B' because each pair is listed 2x

</code></pre>

<hr>
<h2 id='Conf_griffin'>Example output from estimating confidence probabilities: griffins</h2><span id='topic+Conf_griffin'></span>

<h3>Description</h3>

<p>Example output of <code><a href="#topic+EstConf">EstConf</a></code>, with the inferred
pedigree in <code><a href="#topic+SeqOUT_griffin">SeqOUT_griffin</a></code> used as reference pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Conf_griffin)
</code></pre>


<h3>Format</h3>

<p>a list, see <code><a href="#topic+sequoia">sequoia</a></code>
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ped_griffin">Ped_griffin</a></code>, <code><a href="#topic+Geno_griffin">Geno_griffin</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Conf_griffin &lt;- EstConf(Pedigree = SeqOUT_griffin$Pedigree,
                        LifeHistData = LH_griffin,
                        args.sim = list(nSnp = 400, SnpError = 0.001,
                                        ParMis=0.4),
                        args.seq = list(Module = 'ped', Err=0.001),
                        nSim = 20,
                        nCores = 5,
                        quiet = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='CountAgeDif'>Tabulate Age Differences</h2><span id='topic+CountAgeDif'></span>

<h3>Description</h3>

<p>Count no. pairs per age difference from birth years. Quicker
than <code>table(outer())</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountAgeDif(BirthYear, BYrange = range(BirthYear))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CountAgeDif_+3A_birthyear">BirthYear</code></td>
<td>
<p>numeric vector with birth years.</p>
</td></tr>
<tr><td><code id="CountAgeDif_+3A_byrange">BYrange</code></td>
<td>
<p>range to limit counts to.</p>
</td></tr>
</table>

<hr>
<h2 id='DoErrors'>Fortran Simulate Genotyping Errors</h2><span id='topic+DoErrors'></span>

<h3>Description</h3>

<p>Wrapper for Fortran function to simulate genotyping errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DoErrors(SGeno, Act2Obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DoErrors_+3A_sgeno">SGeno</code></td>
<td>
<p>matrix with genotype data, size nInd x nSnp.</p>
</td></tr>
<tr><td><code id="DoErrors_+3A_act2obs">Act2Obs</code></td>
<td>
<p>array with conditional probability of observing genotype i
conditional on actual genotype j, size nSnp x 3 x 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SGeno</code> with errors.
</p>

<hr>
<h2 id='DuplicateCheck'>Check Data for Duplicates.</h2><span id='topic+DuplicateCheck'></span>

<h3>Description</h3>

<p>Check the genotype and life history data for duplicate IDs (not
permitted) and duplicated genotypes (not advised), and count how many
individuals in the genotype data are not included in the life history data
(permitted). The order of IDs in the genotype and life history data is not
required to be identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DuplicateCheck(GenoM = NULL, FortPARAM.dup, quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DuplicateCheck_+3A_genom">GenoM</code></td>
<td>
<p>matrix with genotype data, size nInd x nSnp.</p>
</td></tr>
<tr><td><code id="DuplicateCheck_+3A_fortparam.dup">FortPARAM.dup</code></td>
<td>
<p>list with Fortran-ready parameter values, as generated by
<code><a href="#topic+MkFortParams">MkFortParams</a></code>.</p>
</td></tr>
<tr><td><code id="DuplicateCheck_+3A_quiet">quiet</code></td>
<td>
<p>suppress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one or more of the following elements:
</p>
<table>
<tr><td><code>DupGenoID</code></td>
<td>
<p>Dataframe, row numbers of duplicated IDs in genotype data.
Please do remove or relabel these to avoid downstream confusion.</p>
</td></tr>
<tr><td><code>DupGenotype</code></td>
<td>
<p>Dataframe, duplicated genotypes (with or without identical
IDs). The specified number of maximum mismatches is allowed, and this
dataframe may include pairs of closely related individuals. Mismatch =
number of SNPs at which genotypes differ, LLR = likelihood ratio between
'self' and most likely non-self.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+CheckLH">CheckLH</a></code>, which performs the check for duplicated IDs
in the life history data, as well as for IDs (in genotype data) for which
no life history data is provided.
</p>

<hr>
<h2 id='DyadCompare'>Compare Dyads (DEPRECATED)</h2><span id='topic+DyadCompare'></span>

<h3>Description</h3>

<p>Count the number of half and full sibling pairs correctly and
incorrectly assigned. DEPRECATED - PLEASE USE <code><a href="#topic+ComparePairs">ComparePairs</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DyadCompare(Ped1 = NULL, Ped2 = NULL, na1 = c(NA, "0"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DyadCompare_+3A_ped1">Ped1</code></td>
<td>
<p>original pedigree, dataframe with 3 columns: id-dam-sire.</p>
</td></tr>
<tr><td><code id="DyadCompare_+3A_ped2">Ped2</code></td>
<td>
<p>second (inferred) pedigree.</p>
</td></tr>
<tr><td><code id="DyadCompare_+3A_na1">na1</code></td>
<td>
<p>the value for missing parents in Ped1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3x3 table with the number of pairs assigned as full siblings (FS),
half siblings (HS) or unrelated (U, including otherwise related) in the two
pedigrees, with the classification in Ped1 on rows and that in Ped2 in
columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComparePairs">ComparePairs</a></code> which supersedes this function;
<code><a href="#topic+PedCompare">PedCompare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
DyadCompare(Ped1=Ped_HSg5, Ped2=SeqOUT_HSg5$Pedigree)

## End(Not run)
</code></pre>

<hr>
<h2 id='ErrToM'>Generate Genotyping Error Matrix</h2><span id='topic+ErrToM'></span>

<h3>Description</h3>

<p>Make a vector or matrix specifying the genotyping error
pattern, or a function to generate such a vector/matrix from a single
value Err.
</p>
<p>with the probabilities of observed genotypes
(columns) conditional on actual genotypes (rows), or return a function to
generate such matrices (using a single value Err as input to that
function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ErrToM(Err = NA, flavour = "version2.9", Return = "matrix")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ErrToM_+3A_err">Err</code></td>
<td>
<p>estimated genotyping error rate, as a single number, or 3x3 or 4x4
matrix, or length 3 vector. If a single number, an error model is used that
aims to deal with scoring errors typical for SNP arrays. If a matrix, this
should be the probability of observed genotype (columns) conditional on
actual genotype (rows). Each row must therefore sum to 1. If
<code>Return='function'</code>, this may be <code>NA</code>. If a vector, these are the
probabilities (observed given actual) hom|other hom, het|hom, and hom|het.</p>
</td></tr>
<tr><td><code id="ErrToM_+3A_flavour">flavour</code></td>
<td>
<p>vector-generating or matrix-generating function, or one of
'version2.9', 'version2.0', 'version1.3' (='SNPchip'), 'version1.1'
(='version111'), referring to the sequoia version in which it was used as
default. Only used if <code>Err</code> is a single number.</p>
</td></tr>
<tr><td><code id="ErrToM_+3A_return">Return</code></td>
<td>
<p>output, 'matrix' (default), 'vector', 'function'
(matrix-generating), or 'v_function' (vector-generating)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default (<code>flavour</code> = &quot;version2.9&quot;), <code>Err</code> is
interpreted as a locus-level error rate (rather than allele-level), and
equals the probability that an actual heterozygote is observed as either
homozygote (i.e., the probability that it is observed as AA = probability
that observed as aa = <code>Err</code>/2). The probability that one homozygote is
observed as the other is (<code>Err</code>/2<code class="reqn">)^2</code>.
</p>
<p>The inbuilt 'flavours' correspond to the presumed and simulated error
structures, which have changed with sequoia versions. The most appropriate
error structure will depend on the genotyping platform; 'version0.9' and
'version1.1' were inspired by SNP array genotyping while 'version1.3' and
'version2.0' are intended to be more general.
</p>
<p>This function, and throughout the package, it is assumed that the two alleles
<code class="reqn">A</code> and <code class="reqn">a</code> are equivalent. Thus, using notation <code class="reqn">P</code>(observed
genotype |actual genotype), that <code class="reqn">P(AA|aa) = P(aa|AA)</code>,
<code class="reqn">P(aa|Aa)=P(AA|Aa)</code>, and <code class="reqn">P(aA|aa)=P(aA|AA)</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
 <strong>version</strong> </td><td style="text-align: center;"> <strong>hom|hom</strong> </td><td style="text-align: center;"> <strong>het|hom</strong> </td><td style="text-align: center;">
<strong>hom|het</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>2.9</strong>  </td><td style="text-align: center;"> <code class="reqn">(E/2)^2</code> </td><td style="text-align: center;"> <code class="reqn">E-(E/2)^2</code> </td><td style="text-align: center;"> <code class="reqn">E/2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>2.0</strong>  </td><td style="text-align: center;"> <code class="reqn">(E/2)^2</code> </td><td style="text-align: center;"> <code class="reqn">E(1-E/2)</code>  </td><td style="text-align: center;"> <code class="reqn">E/2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>1.3</strong>  </td><td style="text-align: center;"> <code class="reqn">(E/2)^2</code> </td><td style="text-align: center;"> <code class="reqn">E</code>   </td><td style="text-align: center;"> <code class="reqn">E/2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>1.1</strong>  </td><td style="text-align: center;"> <code class="reqn">E/2</code>     </td><td style="text-align: center;"> <code class="reqn">E/2</code> </td><td style="text-align: center;"> <code class="reqn">E/2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>0.9</strong>  </td><td style="text-align: center;"> <code class="reqn">0</code>       </td><td style="text-align: center;"> <code class="reqn">E</code>   </td><td style="text-align: center;"> <code class="reqn">E/2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>or in matrix form, Pr(observed genotype (columns) | actual genotype (rows)):
</p>
<p><em>version2.9:</em>
</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: center;"> <strong>0</strong> </td><td style="text-align: center;"> <strong>1</strong> </td><td style="text-align: center;"> <strong>2</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>0</strong>  </td><td style="text-align: center;"> <code class="reqn">1-E</code> </td><td style="text-align: center;"> <code class="reqn">E -(E/2)^2</code> </td><td style="text-align: center;"> <code class="reqn">(E/2)^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>1</strong>  </td><td style="text-align: center;"> <code class="reqn">E/2</code>       </td><td style="text-align: center;"> <code class="reqn">1-E</code>      </td><td style="text-align: center;"> <code class="reqn">E/2</code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>2</strong>  </td><td style="text-align: center;"> <code class="reqn">(E/2)^2</code>   </td><td style="text-align: center;"> <code class="reqn">E -(E/2)^2</code> </td><td style="text-align: center;"> <code class="reqn">1-E</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><em>version2.0:</em>
</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: center;"> <strong>0</strong> </td><td style="text-align: center;"> <strong>1</strong> </td><td style="text-align: center;"> <strong>2</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>0</strong>  </td><td style="text-align: center;"> <code class="reqn">(1-E/2)^2</code> </td><td style="text-align: center;"> <code class="reqn">E(1-E/2)</code> </td><td style="text-align: center;"> <code class="reqn">(E/2)^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>1</strong>  </td><td style="text-align: center;"> <code class="reqn">E/2</code>       </td><td style="text-align: center;"> <code class="reqn">1-E</code>      </td><td style="text-align: center;"> <code class="reqn">E/2</code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>2</strong>  </td><td style="text-align: center;"> <code class="reqn">(E/2)^2</code>   </td><td style="text-align: center;"> <code class="reqn">E(1-E/2)</code> </td><td style="text-align: center;"> <code class="reqn">(1-E/2)^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><em>version1.3</em>
</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: center;"> <strong>0</strong> </td><td style="text-align: center;"> <strong>1</strong> </td><td style="text-align: center;"> <strong>2</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>0</strong>  </td><td style="text-align: center;"> <code class="reqn">1-E-(E/2)^2</code> </td><td style="text-align: center;"> <code class="reqn">E</code> </td><td style="text-align: center;"> <code class="reqn">(E/2)^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>1</strong>  </td><td style="text-align: center;"> <code class="reqn">E/2</code>       </td><td style="text-align: center;"> <code class="reqn">1-E</code>      </td><td style="text-align: center;"> <code class="reqn">E/2</code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>2</strong>  </td><td style="text-align: center;"> <code class="reqn">(E/2)^2</code>   </td><td style="text-align: center;"> <code class="reqn">E</code> </td><td style="text-align: center;"> <code class="reqn">1-E-(E/2)^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><em>version1.1</em>
</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: center;"> <strong>0</strong> </td><td style="text-align: center;"> <strong>1</strong> </td><td style="text-align: center;"> <strong>2</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>0</strong>  </td><td style="text-align: center;"> <code class="reqn">1-E</code> </td><td style="text-align: center;"> <code class="reqn">E/2</code> </td><td style="text-align: center;"> <code class="reqn">E/2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>1</strong>  </td><td style="text-align: center;"> <code class="reqn">E/2</code>       </td><td style="text-align: center;"> <code class="reqn">1-E</code>      </td><td style="text-align: center;"> <code class="reqn">E/2</code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>2</strong>  </td><td style="text-align: center;"> <code class="reqn">E/2</code>   </td><td style="text-align: center;"> <code class="reqn">E/2</code> </td><td style="text-align: center;"> <code class="reqn">1-E</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><em>version0.9</em> (not recommended)
</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: center;"> <strong>0</strong> </td><td style="text-align: center;"> <strong>1</strong> </td><td style="text-align: center;"> <strong>2</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>0</strong>  </td><td style="text-align: center;"> <code class="reqn">1-E</code> </td><td style="text-align: center;"> <code class="reqn">E</code> </td><td style="text-align: center;"> <code class="reqn">0</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>1</strong>  </td><td style="text-align: center;"> <code class="reqn">E/2</code>       </td><td style="text-align: center;"> <code class="reqn">1-E</code>      </td><td style="text-align: center;"> <code class="reqn">E/2</code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>2</strong>  </td><td style="text-align: center;"> <code class="reqn">0</code>   </td><td style="text-align: center;"> <code class="reqn">E</code> </td><td style="text-align: center;"> <code class="reqn">1-E</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When <code>Err</code> is a length 3 vector, or if <code>Return = 'vector'</code> these
are the following probabilities:
</p>

<ul>
<li><p> hom|hom: an actual homozygote is observed as the other homozygote
(<code class="reqn">E_1</code>)
</p>
</li>
<li><p> het|hom: an actual homozygote is observed as heterozygote (<code class="reqn">E_2</code>)
</p>
</li>
<li><p> hom|het: an actual heterozygote is observed as homozygote (<code class="reqn">E_3</code>)
</p>
</li></ul>

<p>and Pr(observed genotype (columns) | actual genotype (rows)) is then:
</p>

<table>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: center;"> <strong>0</strong>       </td><td style="text-align: center;"> <strong>1</strong>   </td><td style="text-align: center;"> <strong>2</strong>  </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>0</strong> </td><td style="text-align: center;"> <code class="reqn">1-E_1-E_2</code> </td><td style="text-align: center;"> <code class="reqn">E_2</code>    </td><td style="text-align: center;"> <code class="reqn">E_1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>1</strong> </td><td style="text-align: center;"> <code class="reqn">E_3</code>        </td><td style="text-align: center;"> <code class="reqn">1-2E_3</code> </td><td style="text-align: center;"> <code class="reqn">E_3</code>   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>2</strong> </td><td style="text-align: center;"> <code class="reqn">E_1</code>       </td><td style="text-align: center;"> <code class="reqn">E_2</code>    </td><td style="text-align: center;"> <code class="reqn">1-E_1-E_2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When the SNPs are scored via sequencing (e.g. RADseq or DArTseq), the 3rd
error rate (hom|het) is typically considerably higher than the other two,
while for SNP arrays it tends to be similar to P(het|hom).
</p>


<h3>Value</h3>

<p>Depending on <code>Return</code>, either:
</p>

<ul>
<li> <p><code>'matrix'</code>: a 3x3 matrix, with probabilities of observed genotypes
(columns) conditional on actual (rows)
</p>
</li>
<li> <p><code>'function'</code>: a function taking a single value <code>Err</code> as input, and
generating a 3x3 matrix
</p>
</li>
<li> <p><code>'vector'</code>: a length 3 vector, with the probabilities (observed given
actual) hom|other hom, het|hom, and hom|het.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ErM &lt;- ErrToM(Err = 0.05)
ErM
ErrToM(ErM, Return = 'vector')


# use error matrix from Whalen, Gorjanc &amp; Hickey 2018
funE &lt;- function(E) {
 matrix(c(1-E*3/4, E/2, E/4,
          E/4, 1-2*E/4, E/4,
          E/4, E/2, 1-E*3/4),
          3,3, byrow=TRUE)  }
ErrToM(Err = 0.05, flavour = funE)
# equivalent to:
ErrToM(Err = c(0.05/4, 0.05/2, 0.05/4))

</code></pre>

<hr>
<h2 id='EstConf'>Confidence Probabilities</h2><span id='topic+EstConf'></span>

<h3>Description</h3>

<p>Estimate confidence probabilities ('backward') and assignment
error rates ('forward') per category (genotyped/dummy) by repeatedly
simulating genotype data from a reference pedigree using
<code><a href="#topic+SimGeno">SimGeno</a></code>, reconstruction a pedigree from this using
<code><a href="#topic+sequoia">sequoia</a></code>, and counting the number of mismatches using
<code><a href="#topic+PedCompare">PedCompare</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstConf(
  Pedigree = NULL,
  LifeHistData = NULL,
  args.sim = list(nSnp = 400, SnpError = 0.001, ParMis = c(0.4, 0.4)),
  args.seq = list(Module = "ped", Err = 0.001, Tassign = 0.5, CalcLLR = FALSE),
  nSim = 10,
  nCores = 1,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstConf_+3A_pedigree">Pedigree</code></td>
<td>
<p>reference pedigree from which to simulate, dataframe with
columns id-dam-sire. Additional columns are ignored.</p>
</td></tr>
<tr><td><code id="EstConf_+3A_lifehistdata">LifeHistData</code></td>
<td>
<p>dataframe with id, sex (1=female, 2=male, 3=unknown),
birth year, and optionally BY.min - BY.max - YearLast.</p>
</td></tr>
<tr><td><code id="EstConf_+3A_args.sim">args.sim</code></td>
<td>
<p>list of arguments to pass to <code><a href="#topic+SimGeno">SimGeno</a></code>, such as
<code>nSnp</code> (number of SNPs), <code>SnpError</code> (genotyping error rate) and
<code>ParMis</code> (proportion of non-genotyped parents). Set to <code>NULL</code> to
use all default values.</p>
</td></tr>
<tr><td><code id="EstConf_+3A_args.seq">args.seq</code></td>
<td>
<p>list of arguments to pass to <code><a href="#topic+sequoia">sequoia</a></code>, such as
<code>Module</code> ('par' or 'ped'), <code>Err</code> (assumed genotyping error rate),
and <code>Complex</code>. May include (part of) <code>SeqList</code>, a list of sequoia
output (i.e. as a list-within-a-list). Set to <code>NULL</code> to use all
default values.</p>
</td></tr>
<tr><td><code id="EstConf_+3A_nsim">nSim</code></td>
<td>
<p>number of iterations of simulate - reconstruct - compare to
perform, i.e. number of simulated datasets.</p>
</td></tr>
<tr><td><code id="EstConf_+3A_ncores">nCores</code></td>
<td>
<p>number of computer cores to use. If <code>&gt;1</code>, package
<span class="pkg">parallel</span> is used. Set to NULL to use all but one of the available
cores, as detected by <code>parallel::detectCores()</code> (using all cores tends
to freeze up your computer). With large datasets, the amount of computer
memory may be the limiting factor for the number of cores you can use.</p>
</td></tr>
<tr><td><code id="EstConf_+3A_quiet">quiet</code></td>
<td>
<p>suppress messages. <code>TRUE</code> runs <code>SimGeno</code> and
<code>sequoia</code> quietly, <code>'very'</code> also suppresses other messages and
the iteration counter when <code>nCores=1</code> (there is no iteration counter
when <code>nCores&gt;1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence probability is taken as the number of correct
(matching) assignments, divided by all assignments made in the
<em>observed</em> (inferred-from-simulated) pedigree. In contrast, the false
negative &amp; false positive assignment rates are proportions of the number of
parents in the <em>true</em> (reference) pedigree. Each rate is calculated
separatedly for dams &amp; sires, and separately for each category
(<strong>G</strong>enotyped/<strong>D</strong>ummy(fiable)/<strong>X</strong> (none)) of
individual, parent and co-parent.
</p>
<p>This function does not know which individuals in the actual <code>Pedigree</code>
are genotyped, so the confidence probabilities need to be added to the
<code>Pedigree</code> as shown in the example at the bottom.
</p>
<p>A confidence of <code class="reqn">1</code> means all assignments on simulated data were correct for
that category-combination. It should be interpreted as (and perhaps modified
to) <code class="reqn">&gt; 1 - 1/N</code>, where sample size <code>N</code> is given in the last column
of the <code>ConfProb</code> and <code>PedErrors</code> dataframes in the output. The
same applies for a false negative/positive rate of <code class="reqn">0</code> (i.e. to be
interpreted as <code class="reqn">&lt; 1/N</code>).
</p>


<h3>Value</h3>

<p>A list, with elements:
</p>
<table>
<tr><td><code>ConfProb</code></td>
<td>
<p>See below</p>
</td></tr>
<tr><td><code>PedErrors</code></td>
<td>
<p>See below</p>
</td></tr>
<tr><td><code>Pedigree.reference</code></td>
<td>
<p>the pedigree from which data was simulated</p>
</td></tr>
<tr><td><code>LifeHistData</code></td>
<td>
</td></tr>
<tr><td><code>Pedigree.inferred</code></td>
<td>
<p>a list with for each iteration the inferred
pedigree based on the simulated data</p>
</td></tr>
<tr><td><code>SimSNPd</code></td>
<td>
<p>a list with for each iteration the IDs of the individuals
simulated to have been genotyped</p>
</td></tr>
<tr><td><code>PedComp.fwd</code></td>
<td>
<p>array with <code>Counts</code> from the 'forward'
<code>PedCompare</code>, from which <code>PedErrors</code> is calculated</p>
</td></tr>
<tr><td><code>RunParams</code></td>
<td>
<p>a list with the call to <code>EstConf</code> as a semi-nested
list (args.sim, args.seq, nSim, nCores), as well as the default parameter
values for <code>SimGeno</code> and <code>sequoia</code>.</p>
</td></tr>
<tr><td><code>RunTime</code></td>
<td>
<p><code>sequoia</code> runtime per simulation in seconds, as
measured by <code><a href="base.html#topic+system.time">system.time</a>()['elapsed']</code>.</p>
</td></tr>
</table>
<p>Dataframe <code>ConfProb</code> has 7 columns:
</p>
<table>
<tr><td><code>id.cat</code>, <code>dam.cat</code>, <code>sire.cat</code></td>
<td>
<p>Category of the focal individual, dam, and
sire, in the pedigree inferred based on the simulated data. Coded as
G=genotyped, D=dummy, X=none</p>
</td></tr>
<tr><td><code>dam.conf</code></td>
<td>
<p>Probability that the dam is correct, given the categories of
the assigned dam and sire (ignoring whether or not the sire is correct)</p>
</td></tr>
<tr><td><code>sire.conf</code></td>
<td>
<p>as <code>dam.conf</code>, for the sire</p>
</td></tr>
<tr><td><code>pair.conf</code></td>
<td>
<p>Probability that both dam and sire are correct, given their
categories</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of individuals per category-combination, across all
<code>nSim</code> iterations</p>
</td></tr>
</table>
<p>Array <code>PedErrors</code> has three dimensions:
</p>
<table>
<tr><td><code>class</code></td>
<td>

<ul>
<li> <p><code>FalseNeg</code>(atives): could have been assigned but was not
(individual + parent both genotyped or dummyfiable; P1only in
<code>PedCompare</code>).
</p>
</li>
<li> <p><code>FalsePos</code>(itives): no parent in reference pedigree, but
one was assigned based on the simulated data (P2only)
</p>
</li>
<li> <p><code>Mismatch</code>: different parents between the pedigrees
</p>
</li></ul>
</td></tr>
<tr><td><code>cat</code></td>
<td>
<p>Category of individual + parent, as a two-letter code where the
first letter indicates the focal individual and the second the parent;
G=Genotyped, D=Dummy, T=Total</p>
</td></tr>
<tr><td><code>parent</code></td>
<td>
<p>dam or sire</p>
</td></tr>
</table>


<h3>Assumptions</h3>

<p>Because the actual true pedigree is (typically) unknown, the provided
reference pedigree is used as a stand-in and assumed to be the true
pedigree, with unrelated founders. It is also assumed that the probability
to be genotyped is equal for all parents; in each iteration, a new random
set of parents (proportion set by <code>ParMis</code>) is mimicked to be
non-genotyped. In addition, SNPs are assumed to segregate independently.
</p>
<p>An experimental version offering more fine-grained control is available at
https://github.com/JiscaH/sequoiaExtra .
</p>


<h3>Object size</h3>

<p>The size in Kb of the returned list can become pretty big, as each of the
inferred pedigrees is included. When running <code>EstConf</code> many times for
a range of parameter values, it may be prudent to save the required summary
statistics for each run rather than the full output.
</p>


<h3>Errors</h3>

<p>If you have a large pedigree and try to run this function on multiple
cores, you may run into &quot;Cannot allocate vector of size ...&quot; errors or even
unexpected crashes: there is not enough computer memory for each separate
run. Try reducing 'nCores'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimGeno">SimGeno</a>, <a href="#topic+sequoia">sequoia</a>, <a href="#topic+PedCompare">PedCompare</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># estimate proportion of parents that are genotyped (= 1 - ParMis)
sumry_grif &lt;- SummarySeq(SeqOUT_griffin, Plot=FALSE)
tmp &lt;- apply(sumry_grif$ParentCount['Genotyped',,,],
             MARGIN = c('parentSex', 'parentCat'), FUN = sum)
props &lt;- sweep(tmp, MARGIN='parentCat', STATS = rowSums(tmp), FUN = '/')
1 - props[,'Genotyped'] / (props[,'Genotyped'] + props[,'Dummy'])

# Example for parentage assignment only
conf_grif &lt;- EstConf(Pedigree = SeqOUT_griffin$Pedigree,
               LifeHistData = SeqOUT_griffin$LifeHist,
               args.sim = list(nSnp = 150,   # no. in actual data, or what-if
                               SnpError = 5e-3,  # best estimate, or what-if
                               CallRate=0.9,     # from SnpStats()
                               ParMis=c(0.39, 0.20)),  # calc'd above
               args.seq = list(Err=5e-3, Module="par"),  # as in real run
               nSim = 1,   # try-out, proper run &gt;=20 (10 if huge pedigree)
               nCores=1)

# parent-pair confidence, per category (Genotyped/Dummy/None)
conf_grif$ConfProb

# Proportion of true parents that was correctly assigned
1 - apply(conf_grif$PedErrors, MARGIN=c('cat','parent'), FUN=sum, na.rm=TRUE)

# add columns with confidence probabilities to pedigree
# first add columns with category (G/D/X)
Ped.withConf &lt;- getAssignCat(Pedigree = SeqOUT_griffin$Pedigree,
                             SNPd = SeqOUT_griffin$PedigreePar$id)
Ped.withConf &lt;- merge(Ped.withConf, conf_grif$ConfProb, all.x=TRUE,
                      sort=FALSE)  # (note: merge() messes up column order)
head(Ped.withConf[Ped.withConf$dam.cat=="G", ])

# save output summary
## Not run: 
conf_griff[['Note']] &lt;- 'You could add a note'
saveRDS(conf_grif[c('ConfProb','PedComp.fwd','RunParams','RunTime','Note')],
   file = 'conf_200SNPs_Err005_Callrate80.RDS')

## End(Not run)

## P(actual FS | inferred as FS) etc.
## Not run: 
PairL &lt;- list()
for (i in 1:length(conf_grif$Pedigree.inferred)) {  # nSim
  cat(i, "\t")
  PairL[[i]] &lt;- ComparePairs(conf_grif$Pedigree.reference,
                             conf_grif$Pedigree.inferred[[i]],
                             GenBack=1, patmat=TRUE, ExcludeDummies = TRUE,
                             Return="Counts")
}
# P(actual relationship (Ped1) | inferred relationship (Ped2))
PairRel.prop.A &lt;- plyr::laply(PairL, function(M)
                     sweep(M, MARGIN='Ped2', STATS=colSums(M), FUN="/"))
PairRel.prop &lt;- apply(PairRel.prop.A, 2:3, mean, na.rm=TRUE) #avg across sims
round(PairRel.prop, 3)
# or: P(inferred relationship | actual relationship)
PairRel.prop2 &lt;- plyr::laply(PairL, function(M)
   sweep(M, MARGIN='Ped1', STATS=rowSums(M), FUN="/"))

## End(Not run)

## Not run: 
# confidence probability vs. sibship size
source('https://raw.githubusercontent.com/JiscaH/sequoiaExtra/main/conf_vs_sibsize.R')
conf_grif_nOff &lt;- Conf_by_nOff(conf_grif)
conf_grif_nOff['conf',,'GD',]
conf_grif_nOff['N',,'GD',]

## End(Not run)

</code></pre>

<hr>
<h2 id='EstEr'>Estimate genotyping error rate (REMOVED; will be re-implemented)</h2><span id='topic+EstEr'></span>

<h3>Description</h3>

<p>Estimate the genotyping error rates in SNP data, based on a
pedigree and/or duplicates. Estimates probabilities (observed given
actual) hom|other hom, het|hom, and hom|het. THESE ARE APPROXIMATE VALUES!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstEr(
  GenoM,
  Pedigree,
  Duplicates = NULL,
  Er_start = c(0.05, 0.05, 0.05),
  perSNP = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstEr_+3A_genom">GenoM</code></td>
<td>
<p>Genotype matrix</p>
</td></tr>
<tr><td><code id="EstEr_+3A_pedigree">Pedigree</code></td>
<td>
<p>data.frame with columns id - dam - sire</p>
</td></tr>
<tr><td><code id="EstEr_+3A_duplicates">Duplicates</code></td>
<td>
<p>matrix or data.frame with 2 columns, id1 &amp; id2</p>
</td></tr>
<tr><td><code id="EstEr_+3A_er_start">Er_start</code></td>
<td>
<p>vector of length 3 with starting values for <code>optim</code>.</p>
</td></tr>
<tr><td><code id="EstEr_+3A_persnp">perSNP</code></td>
<td>
<p>logical, estimate error rate per SNP. WARNING not very
precise, use only as an approximate indicator! Try on simulated data first,
e.g. with <code><a href="#topic+SimGeno">SimGeno</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result should be interpreted as approximate, ballpark estimates!
The estimated error rates from a pedigree will not be as accurate as from
duplicate samples. Errors in individuals without parents or offspring will
not be counted, and errors in individuals with only few offspring may not be
noted either. Deviation of genotype frequencies among founders from
Hardy-Weinberg equilibrium may wrongly be attributed to genotyping errors.
Last but not least, any pedigree errors will result in higher estimated
genotyping errors.
</p>


<h3>Value</h3>

<p>vector of length 3 with estimated genotyping error rates: the
probabilities that
</p>

<ul>
<li><p> hom|hom: an actual homozygote is observed as the other homozygote
</p>
</li>
<li><p> het|hom: an actual homozygote is observed as heterozygote
</p>
</li>
<li><p> hom|het: an actual heterozygote is observed as homozygote
</p>
</li></ul>

<p>These are three independent parameters, that define the genotyping error
matrix (see <code><a href="#topic+ErrToM">ErrToM</a></code>) as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: center;"> <strong>0</strong>       </td><td style="text-align: center;"> <strong>1</strong>   </td><td style="text-align: center;"> <strong>2</strong>  </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>0</strong> </td><td style="text-align: center;"> <code class="reqn">1-E_1-E_2</code> </td><td style="text-align: center;"> <code class="reqn">E_2</code>    </td><td style="text-align: center;"> <code class="reqn">E_1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>1</strong> </td><td style="text-align: center;"> <code class="reqn">E_3</code>        </td><td style="text-align: center;"> <code class="reqn">1-2E_3</code> </td><td style="text-align: center;"> <code class="reqn">E_3</code>   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <strong>2</strong> </td><td style="text-align: center;"> <code class="reqn">E_1</code>       </td><td style="text-align: center;"> <code class="reqn">E_2</code>    </td><td style="text-align: center;"> <code class="reqn">1-E_1-E_2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that for <code>optim</code> a lower bound of 1e-6 and upper bound of 0.499
are used; if these values are returned this should be interpreted as
'inestimably small' and 'inestimably large', respectively. PLEASE DO NOT USE
THESE VALUES AS INPUT IN SUBSEQUENT ANALYSIS BUT SUBSITUTE BY A SENSIBLE
VALUE!!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenoX &lt;- SimGeno(Ped_griffin, nSnp=400, SnpError=c(0.01,0.07, 0.1),
                ParMis=0.1, CallRate=0.9)
# EstEr(GenoM=GenoX, Pedigree=Ped_griffin)

</code></pre>

<hr>
<h2 id='FieldMums_griffin'>Example field-observed mothers: griffins</h2><span id='topic+FieldMums_griffin'></span>

<h3>Description</h3>

<p>Example field pedigree used in vignette for
<code><a href="#topic+PedCompare">PedCompare</a></code> example. Non-genotyped females have IDs 'BlueRed',
'YellowPink', etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FieldMums_griffin)
</code></pre>


<h3>Format</h3>

<p>A data frame with 144 rows and 2 variables (id, mum)
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SeqOUT_griffin">SeqOUT_griffin</a></code> for a sequoia run on simulated genotype
data, <code><a href="#topic+Ped_griffin">Ped_griffin</a></code> for the 'true' pedigree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
PC_griffin &lt;- PedCompare(Ped1 = cbind(FieldMums_griffin, sire=NA),
                         Ped2 = SeqOUT_griffin$Pedigree)

## End(Not run)
</code></pre>

<hr>
<h2 id='FindFamilies'>Assign Family IDs</h2><span id='topic+FindFamilies'></span>

<h3>Description</h3>

<p>Find clusters of connected individuals in a pedigree, and assign
each cluster a unique family ID (FID).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindFamilies(Pedigree = NULL, SeqList = NULL, MaybeRel = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindFamilies_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with columns id - parent1 - parent2; only the
first 3 columns will be used.</p>
</td></tr>
<tr><td><code id="FindFamilies_+3A_seqlist">SeqList</code></td>
<td>
<p>list as returned by <code><a href="#topic+sequoia">sequoia</a></code>. If <code>Pedigree</code>
is not provided, the element <code>Pedigree</code> from this list will be used if
present, and element <code>Pedigreepar</code> otherwise.</p>
</td></tr>
<tr><td><code id="FindFamilies_+3A_mayberel">MaybeRel</code></td>
<td>
<p>Output from <code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code>, a dataframe with
probable but non-assigned relatives.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function repeatedly finds all ancestors and all descendants of
each individual in turn, and ensures they all have the same Family ID. Not
all connected individuals are related, e.g. all grandparents of an
individual will have the same FID, but will typically be unrelated.
</p>
<p>When <code>UseMaybeRel = TRUE</code>, probable relatives are added to existing
family clusters, or existing family clusters may be linked together.
Currently no additional family clusters are created.
</p>


<h3>Value</h3>

<p>A numeric vector with length equal to the number of unique
individuals in the pedigree (i.e. number of rows in pedigree after running
<code><a href="#topic+PedPolish">PedPolish</a></code> on <code>Pedigree</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetAncestors">GetAncestors</a>, <a href="#topic+GetDescendants">GetDescendants</a>,
  <a href="#topic+getGenerations">getGenerations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PedG &lt;- SeqOUT_griffin$PedigreePar[,1:3]
FID_G &lt;- FindFamilies(PedG)
PedG[FID_G==4,]
</code></pre>

<hr>
<h2 id='FoldSibGPs'>Fold IDs of Sibship Grandparents</h2><span id='topic+FoldSibGPs'></span>

<h3>Description</h3>

<p>Fold IDs of sibship grandparents into a 2 x nInd/2 x 2 array, as
they are stored in Fortran, and then stretch this into a vector that can be
passed to Fortran and easily be transformed back into said 3D array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FoldSibGPs(PedNum, Ng, Nd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FoldSibGPs_+3A_pednum">PedNum</code></td>
<td>
<p>pedigree, ids replaced by numbers, dummies negative.</p>
</td></tr>
<tr><td><code id="FoldSibGPs_+3A_ng">Ng</code></td>
<td>
<p>no. genotyped indivs.</p>
</td></tr>
<tr><td><code id="FoldSibGPs_+3A_nd">Nd</code></td>
<td>
<p>length 2 vector, no. female &amp; male dummies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector, with missing values as 0.
</p>

<hr>
<h2 id='FortifyPairs'>Make Pairs Fortran Compatible</h2><span id='topic+FortifyPairs'></span>

<h3>Description</h3>

<p>Convert dataframe <code>Pairs</code> into a list of integer vectors.
Called only by <code><a href="#topic+CalcPairLL">CalcPairLL</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FortifyPairs(Pairs, gID, Renamed, LH)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FortifyPairs_+3A_pairs">Pairs</code></td>
<td>
<p>dataframe with columns ID1 - ID2 - Sex1 - Sex2 - AgeDif - focal
- k.</p>
</td></tr>
<tr><td><code id="FortifyPairs_+3A_gid">gID</code></td>
<td>
<p>character vector with IDs of genotyped individuals.</p>
</td></tr>
<tr><td><code id="FortifyPairs_+3A_renamed">Renamed</code></td>
<td>
<p>length-2 list (dams, sires) each with a 2-column dataframe.
matching character IDs to negative numbers, for dummified individuals.
Element of the list returned by <code><a href="#topic+PedToNum">PedToNum</a></code>.</p>
</td></tr>
<tr><td><code id="FortifyPairs_+3A_lh">LH</code></td>
<td>
<p>lifehistory dataframe, ID - Sex - BirthYear.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list, with elements ID - Sex - AgeDif - focal. The first two
are per individual and thus each have length 2*nrow(Pairs), while the last
two have length 1*nrow(Pairs).
</p>

<hr>
<h2 id='Geno_griffin'>Example genotype file: Griffins</h2><span id='topic+Geno_griffin'></span>

<h3>Description</h3>

<p>Simulated genotype data from Pedigree <code><a href="#topic+Ped_griffin">Ped_griffin</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Geno_griffin)
</code></pre>


<h3>Format</h3>

<p>A genotype matrix with 142 rows (individuals) and 200 columns (SNPs).
Each SNP is coded as 0/1/2 copies of the reference allele, with -9 for
missing values. Ids are stored as rownames.
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimGeno">SimGeno</a></code>
</p>

<hr>
<h2 id='Geno_HSg5'>Example genotype file: 'HSg5'</h2><span id='topic+Geno_HSg5'></span>

<h3>Description</h3>

<p>Simulated genotype data for all* individuals in Pedigree
<code><a href="#topic+Ped_HSg5">Ped_HSg5</a></code> (*: with 40
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Geno_HSg5)
</code></pre>


<h3>Format</h3>

<p>A genotype matrix with 920 rows (ids) and 200 columns (SNPs). Each
SNP is coded as 0/1/2 copies of the reference allele, with -9 for missing
values. Ids are stored as rownames.
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LH_HSg5">LH_HSg5</a>, <a href="#topic+SimGeno">SimGeno</a>, <a href="#topic+SeqOUT_HSg5">SeqOUT_HSg5</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# this output was created as follows:
Geno_HSg5 &lt;- SimGeno(Ped = Ped_HSg5, nSnp = 200, ParMis=0.4,
                     CallRate = 0.9, SnpError = 0.005)

## End(Not run)
</code></pre>

<hr>
<h2 id='GenoConvert'>Convert Genotype Data</h2><span id='topic+GenoConvert'></span>

<h3>Description</h3>

<p>Convert genotype data in various formats to sequoia's
1-column-per-marker format, PLINK's ped format, or Colony's
2-columns-per-marker format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenoConvert(
  InData = NULL,
  InFile = NULL,
  InFormat = "raw",
  OutFile = NA,
  OutFormat = "seq",
  Missing = c("-9", "NA", "??", "?", "NULL", "-1", c("0")[InFormat %in% c("col",
    "ped")]),
  sep = c(" ", "\t", ",", ";"),
  header = NA,
  IDcol = NA,
  FIDcol = NA,
  FIDsep = "__",
  dropcol = NA,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenoConvert_+3A_indata">InData</code></td>
<td>
<p>dataframe, matrix or
<code><a href="adegenet.html#topic+genlight-class">genlight</a></code> object with genotypes to be
converted.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_infile">InFile</code></td>
<td>
<p>character string with name of genotype file to be converted.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_informat">InFormat</code></td>
<td>
<p>One of 'seq' (sequoia), 'ped' (PLINK .ped file), 'col'
(COLONY), 'raw' (PLINK &ndash;recodeA), 'vcf' (requires library <code>{vcfR}</code>),
'single' (1 column per SNP), or 'double' (2 columns per SNP); see Details.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_outfile">OutFile</code></td>
<td>
<p>character string with name of converted file. If NA, return
matrix with genotypes in console (default); if NULL, write to
'GenoForSequoia.txt' in current working directory.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_outformat">OutFormat</code></td>
<td>
<p>as <code>InFormat</code>; only 'seq', 'col', and 'ped' are
implemented. For 'ped' also a sham .map file is created, so that the file
can be read by PLINK. Only for 'ped' are extensions .ped &amp; .map added to
the specified OutFile filename.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_missing">Missing</code></td>
<td>
<p>vector with symbols interpreted as missing data. '0' is
missing data for <code>InFormat</code>s 'col' and 'ped' only.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_sep">sep</code></td>
<td>
<p>vector with field separator strings that will be tried on
<code>InFile</code>. Ignored if package <span class="pkg">data.table</span> is present or if
<code>InFormat='vcf'</code>. The <code>OutFile</code> separator uses the
<code><a href="utils.html#topic+write.table">write.table</a></code> default, i.e. one blank space.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the file contains a header
as its first line. If NA (default), set to TRUE for 'raw', and FALSE
otherwise.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_idcol">IDcol</code></td>
<td>
<p>number giving the column with individual IDs; 0 indicates the
rownames (for InData only). If NA (default), set to 2 for InFormat 'raw'
and 'ped', and otherwise to 1 for InFile and 0 (rownames) for InData,
except when InData has a column labeled 'ID'.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_fidcol">FIDcol</code></td>
<td>
<p>column with the family IDs, if any are wished to
be used. This is column 1 for InFormat 'raw' and 'seq', but those are by
default not used.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_fidsep">FIDsep</code></td>
<td>
<p>string used to paste FID and IID together into a composite-ID
(value passed to <code><a href="base.html#topic+paste">paste</a></code>'s <code>collapse</code>). This joining can
be reversed using <code><a href="#topic+PedStripFID">PedStripFID</a></code>.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_dropcol">dropcol</code></td>
<td>
<p>columns to exclude from the output data, on top of IDcol and
FIDcol (which become rownames). When NA, defaults to columns 3-6 for
InFormat 'raw' and 'seq'. Can also be used to drop some SNPs, see example
below on how to do this for the 2-columns-per-SNP input formats.</p>
</td></tr>
<tr><td><code id="GenoConvert_+3A_quiet">quiet</code></td>
<td>
<p>suppress messages and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two arguments are interchangeable, and can be given
unnamed. The first argument is assumed to be a file name if it is of class
'character' and length 1, and to be the genetic data if it is a matrix or
dataframe.
</p>
<p>If package <span class="pkg">data.table</span> is detected, <code><a href="data.table.html#topic+fread">fread</a></code>
is used to read in the data from file. Otherwise, a combination of
<code><a href="base.html#topic+readLines">readLines</a></code> and <code><a href="base.html#topic+strsplit">strsplit</a></code> is used.
</p>


<h3>Value</h3>

<p>A genotype matrix in the specified output format; the default sequoia
format ('seq') has 1 column per SNP coded in 0/1/2 format (major homozygote
/heterozygote /minor homozygote) with -9 for missing values, sample IDs in
row names and SNP names in column names. If 'OutFile' is specified, the
matrix is written to this file and nothing is returned inside R.
</p>


<h3>Input formats</h3>

<p>The following formats can be specified by <code>InFormat</code>:
</p>

<dl>
<dt>seq</dt><dd><p>(sequoia) genotypes are coded as 0, 1, 2, missing as <code class="reqn">-9</code> (in input
any negative number or NA are OK),
in 1 column per marker. Column 1 contains IDs, there is no header row.</p>
</dd>
<dt>ped</dt><dd><p>(PLINK) genotypes are coded as A, C, T, G, missing as 0, in 2
columns per marker. The first 6 columns are descriptive (1:FID, 2:IID, 3 to
6 ignored). If an associated .map file exists, SNP names will be read from
there.</p>
</dd>
<dt>raw</dt><dd><p>(PLINK) genotypes are coded as 0, 1, 2, missing as NA, in 1
column per marker. The first 6 columns are descriptive (1:FID, 2:IID, 3 to
6 ignored), and there is a header row. This is produced by PLINK's option
&ndash;recodeA</p>
</dd>
<dt>col</dt><dd><p>(Colony) genotypes are coded as numeric values, missing as 0, in
2 columns per marker. Column 1 contains IDs.</p>
</dd>
<dt>vcf</dt><dd><p>(VCF) genotypes are coded as '0/0','0/1','1/1', variable number
of header rows followed by 1 row per SNP, with various columns of
metadata followed by 1 column per individual. Requires package
<span class="pkg">vcfR</span>.</p>
</dd>
<dt>single</dt><dd><p>1 column per marker, otherwise unspecified</p>
</dd>
<dt>double</dt><dd><p>2 columns per marker, otherwise unspecified</p>
</dd>
</dl>

<p>For each <code>InFormat</code>, its default values for <code>Missing, header,
 IDcol, FIDcol</code>, and <code>dropcol</code> can be overruled by specifying the
corresponding input parameters.
</p>


<h3>Error messages</h3>

<p>Occasionally when reading in a file <code>GenoConvert</code> may give an error
that 'rows have unequal length'. <code>GenoConvert</code> makes use of
<code><a href="base.html#topic+readLines">readLines</a></code> and <code><a href="base.html#topic+strsplit">strsplit</a></code>, which is much faster
than <code><a href="utils.html#topic+read.table">read.table</a></code> for large datafiles, but also more sensitive
to unusual line endings, unusual end-of-file characters, or invisible
characters (spaces or tabs) after the end of some lines. In these cases,
try to read the data from file using read.table or read.csv, and then use
<code>GenoConvert</code> on this dataframe or matrix, see example.
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CheckGeno">CheckGeno</a>, <a href="#topic+SnpStats">SnpStats</a>, <a href="#topic+LHConvert">LHConvert</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Requires PLINK installed &amp; in system PATH:

# tinker with window size, window overlap and VIF to get a set of
# 400 - 800 markers (100-200 enough for just parentage):
system("cmd", input = "plink --file mydata --indep 50 5 2")
system("cmd", input = "plink --file mydata --extract plink.prune.in
  --recodeA --out PlinkOUT")

GenoM &lt;- GenoConvert(InFile = "PlinkOUT.raw", InFormat='raw')
# which is the same as
GenoM &lt;- GenoConvert(PlinkOUT.raw, InFormat='single',
                    IDcol=2, dropcol=c(1,3:6), header=TRUE)
# (but it will complain that InFormat='single' is not consistent with .raw
# file extension)

# save time on file conversion next time:
write.table(GenoM, file="Geno_sequoia.txt", quote=FALSE, col.names=FALSE)
GenoM &lt;- as.matrix(read.table("Geno_sequoia.txt", row.names=1, header=FALSE))

# drop some SNPs, e.g. after a warning of &gt;2 alleles:
dropSNP &lt;- c(5,68,101,128)
GenoM &lt;- GenoConvert(ColonyFile, InFormat = "col",
                     dropcol = 1 + c(2*dropSNP-1, 2*dropSNP) )

# circumvent a 'rows have unequal length' error:
GenoTmp &lt;- as.matrix(read.table("mydata.txt", header=TRUE, row.names=1))
GenoM &lt;- GenoConvert(InData=GenoTmp, InFormat="single", IDcol=0)

## End(Not run)

</code></pre>

<hr>
<h2 id='GetAncestors'>Get ancestors</h2><span id='topic+GetAncestors'></span>

<h3>Description</h3>

<p>get all ancestors of an individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetAncestors(id, Pedigree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetAncestors_+3A_id">id</code></td>
<td>
<p>id of the individual</p>
</td></tr>
<tr><td><code id="GetAncestors_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with columns id - parent1 - parent2; only the
first 3 columns will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with as first element <code>id</code>, second parents, third
grandparents, etc.. Each element is a vector with ids, the first three
elements are named, the rest numbered. Ancestors are unsorted within each
list element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Anc_i200  &lt;- GetAncestors('i200_2010_F', Ped_griffin)


</code></pre>

<hr>
<h2 id='getAssignCat'>Assignability of Reference Pedigree</h2><span id='topic+getAssignCat'></span>

<h3>Description</h3>

<p>Identify which individuals are SNP genotyped, and which can
potentially be substituted by a dummy individual ('Dummifiable').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAssignCat(Pedigree, SNPd, minSibSize = "1sib1GP")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAssignCat_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with columns id-dam-sire. Reference pedigree.</p>
</td></tr>
<tr><td><code id="getAssignCat_+3A_snpd">SNPd</code></td>
<td>
<p>character vector with ids of genotyped individuals.</p>
</td></tr>
<tr><td><code id="getAssignCat_+3A_minsibsize">minSibSize</code></td>
<td>
<p>minimum requirements to be considered 'dummifiable':
</p>

<ul>
<li><p> '1sib' : sibship of size 1, i.e. the non-genotyped individual has
at least 1 genotyped offspring. If there is no sibship-grandparent
this isn't really a sibship, but can be useful in some situations.
Used by <code><a href="#topic+CalcOHLLR">CalcOHLLR</a></code>.
</p>
</li>
<li><p> '1sib1GP': sibship of size 1 with at least 1 genotyped
grandparent. The minimum to be potentially assignable by
<code><a href="#topic+sequoia">sequoia</a></code>.
</p>
</li>
<li><p> '2sib': at least 2 siblings, with or without grandparents. Used
by <code><a href="#topic+PedCompare">PedCompare</a></code>.
</p>
</li></ul>
<p>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that all individuals in <code>SNPd</code> have been
genotyped for a sufficient number of SNPs. To identify samples with a
too-low call rate, use <code><a href="#topic+CheckGeno">CheckGeno</a></code>. To calculate the call rate
for all samples, see the examples below.
</p>
<p>Some parents indicated here as assignable may never be assigned by sequoia,
for example parent-offspring pairs where it cannot be determined which is
the older of the two, or grandparents that are indistinguishable from full
avuncular (i.e. genetics inconclusive because the candidate has no parent
assigned, and ageprior inconclusive).
</p>


<h3>Value</h3>

<p>The <code>Pedigree</code> dataframe with 3 additional columns,
<code>id.cat</code>, <code>dam.cat</code> and <code>sire.cat</code>, with coding similar to
that used by <code><a href="#topic+PedCompare">PedCompare</a></code>:
</p>
<table>
<tr><td><code>G</code></td>
<td>
<p>Genotyped</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dummy or 'dummifiable'</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Not genotyped and not dummifiable, or no parent in pedigree</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>PedA &lt;- getAssignCat(Ped_HSg5, rownames(SimGeno_example))
tail(PedA)
table(PedA$dam.cat, PedA$sire.cat, useNA="ifany")

# calculate call rate
## Not run: 
CallRates &lt;- apply(MyGenotypes, MARGIN=1,
                   FUN = function(x) sum(x!=-9)) / ncol(MyGenotypes)
hist(CallRates, breaks=50, col="grey")
GoodSamples &lt;- rownames(MyGenotypes)[ CallRates &gt; 0.8]
# threshold depends on total number of SNPs, genotyping errors, proportion
# of candidate parents that are SNPd (sibship clustering is more prone to
# false positives).
PedA &lt;- getAssignCat(MyOldPedigree, rownames(GoodSamples))

## End(Not run)
</code></pre>

<hr>
<h2 id='GetDescendants'>Get descendants</h2><span id='topic+GetDescendants'></span>

<h3>Description</h3>

<p>get all descendants of an individual
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetDescendants(id, Pedigree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetDescendants_+3A_id">id</code></td>
<td>
<p>id of the individual</p>
</td></tr>
<tr><td><code id="GetDescendants_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with columns id - parent1 - parent2; only the
first 3 columns will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with as first element <code>id</code>, second offspring, third
grand-offspring, etc.. Each element is a vector with ids, the first three
elements are named, the rest numbered.
</p>

<hr>
<h2 id='GetDummifiable'>Dummifiable IDs</h2><span id='topic+GetDummifiable'></span>

<h3>Description</h3>

<p>Get the dummifiable individuals, using various possible
criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetDummifiable(Pedigree, gID, minSibSize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetDummifiable_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with id - dam - sire.</p>
</td></tr>
<tr><td><code id="GetDummifiable_+3A_gid">gID</code></td>
<td>
<p>vector with IDs of SNP-genotyped individuals.</p>
</td></tr>
<tr><td><code id="GetDummifiable_+3A_minsibsize">minSibSize</code></td>
<td>
<p>minimum requirements to be considered dummifiable:
</p>

<ul>
<li><p> '1sib' : sibship of size 1, with or without grandparents. The
latter aren't really a sibship, but can be useful in some situations.
</p>
</li>
<li><p> '1sib1GP': sibship of size 1 with at least 1 grandparent
</p>
</li>
<li><p> '2sib': at least 2 siblings, with or without grandparents. Used
by <code><a href="#topic+PedCompare">PedCompare</a></code>
</p>
</li></ul>
<p>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>values of minSibSize used by calling functions
</p>

<dl>
<dt>1sib</dt><dd><p>CalcOHLLR, CalcPairLL</p>
</dd>
<dt>1sib1GP</dt><dd><p>getAssignCat (default when user called)</p>
</dd>
<dt>2sib</dt><dd><p>PedCompare</p>
</dd>
</dl>



<h3>Value</h3>

<p>A length-2 list (dams, sires) with each element a vector with
dummifiable ids
</p>

<hr>
<h2 id='getGenerations'>Count Generations</h2><span id='topic+getGenerations'></span>

<h3>Description</h3>

<p>For each individual in a pedigree, count the number of
generations since its most distant pedigree founder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGenerations(Ped, StopIfInvalid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGenerations_+3A_ped">Ped</code></td>
<td>
<p>dataframe, pedigree with the first three columns being id - dam -
sire. Column names are ignored, as are additional columns.</p>
</td></tr>
<tr><td><code id="getGenerations_+3A_stopifinvalid">StopIfInvalid</code></td>
<td>
<p>if a pedigree loop is detected, stop with an error
(TRUE, default) or return the Pedigree, to see where the problem(s) occur.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the generation number for each individual, starting at
0 for founders. Offspring of G0 X G0 are G1, offspring of G0 X G1 or G1 x
G1 are G2, etc. <code>NA</code> indicates a pedigree loop where an individual is
its own ancestor (or that the pedigree has &gt;1000 generations).
</p>
<p>If no output name is specified, no results are returned, only an error
message when the pedigree contains a loop.
</p>
<p>To get more details about a pedigree loop, you can use
https://github.com/JiscaH/sequoiaExtra/blob/main/find_pedigree_loop.R
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetAncestors">GetAncestors</a>, <a href="#topic+GetDescendants">GetDescendants</a></code> to get all
ancestors resp. descendants of a specific individual (with a warning if it
is its own ancestor); <a href="#topic+FindFamilies">FindFamilies</a> to find connected sub-pedigrees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># returns nothing if OK, else error:
getGenerations(SeqOUT_griffin$Pedigree)

# returns vector with generation numbers:
G &lt;- getGenerations(SeqOUT_griffin$Pedigree, StopIfInvalid=FALSE)
table(G, useNA='ifany')
Ped_plus_G &lt;- cbind(SeqOUT_griffin$Pedigree, G)

</code></pre>

<hr>
<h2 id='GetLLRAge'>LLR-age from Ageprior Matrix</h2><span id='topic+GetLLRAge'></span>

<h3>Description</h3>

<p>Get log10-likelihood ratios for a specific age difference from
matrix <code>AgePriorExtra</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetLLRAge(AgePriorExtra, agedif, patmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetLLRAge_+3A_agepriorextra">AgePriorExtra</code></td>
<td>
<p>matrix in <code><a href="#topic+sequoia">sequoia</a></code> output</p>
</td></tr>
<tr><td><code id="GetLLRAge_+3A_agedif">agedif</code></td>
<td>
<p>vector with age differences, in whole numbers. Must occur in
rownames of <code>AgePriorExtra</code>.</p>
</td></tr>
<tr><td><code id="GetLLRAge_+3A_patmat">patmat</code></td>
<td>
<p>numeric vector; choose maternal (1), paternal (2) relatives, or
for each relationship the most-likely alternative (3).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>nrow</code> equal to the length of <code>agedif</code>, and 7
columns: PO-FS-HS-GP-FA-HA-U.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PairsG &lt;- data.frame(ID1="i122_2007_M",
                     ID2 = c("i124_2007_M", "i042_2003_F", "i083_2005_M"),
                     AgeDif = c(0,4,2))
cbind(PairsG,
      GetLLRAge(SeqOUT_griffin$AgePriorExtra,
                agedif = PairsG$AgeDif, patmat=rep(2,3)))

</code></pre>

<hr>
<h2 id='GetMaybeRel'>Find Putative Relatives</h2><span id='topic+GetMaybeRel'></span>

<h3>Description</h3>

<p>Identify pairs of individuals likely to be related, but not
assigned as such in the provided pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMaybeRel(
  GenoM = NULL,
  SeqList = NULL,
  Pedigree = NULL,
  LifeHistData = NULL,
  AgePrior = NULL,
  Module = "par",
  Complex = "full",
  Herm = "no",
  Err = 1e-04,
  ErrFlavour = "version2.9",
  Tassign = 0.5,
  Tfilter = -2,
  MaxPairs = 7 * nrow(GenoM),
  quiet = FALSE,
  ParSib = NULL,
  MaxMismatch = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetMaybeRel_+3A_genom">GenoM</code></td>
<td>
<p>numeric matrix with genotype data: One row per individual,
one column per SNP, coded as 0, 1, 2, missing values as a negative number
or NA. You can reformat data with <code><a href="#topic+GenoConvert">GenoConvert</a></code>, or use other
packages to get it into a genlight object and then use <code>as.matrix</code>.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_seqlist">SeqList</code></td>
<td>
<p>list with output from <code><a href="#topic+sequoia">sequoia</a></code>.
<code>SeqList$Pedigree</code> is used if present, and <code>SeqList$PedigreePar</code>
otherwise, and overrides the input parameter <code>Pedigree</code>. If 'Specs' is
present, its elements override all input parameters with the same name. The
list elements  &lsquo;LifeHist&rsquo;, &lsquo;AgePriors&rsquo;, and &lsquo;ErrM&rsquo; are also used if
present, and similarly override the corresponding input parameters.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with id - dam - sire in columns 1-3. May include
non-genotyped individuals, which will be treated as dummy individuals. When
provided, all likelihoods (and thus all maybe-relatives) are conditional on
this pedigree. Note: <code>SeqList$Pedigree</code> or <code>SeqList$PedigreePar</code> take
precedent (for this function only).</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_lifehistdata">LifeHistData</code></td>
<td>
<p>data.frame with up to 6 columns:
</p>

<dl>
<dt>ID</dt><dd><p>max. 30 characters long</p>
</dd>
<dt>Sex</dt><dd><p>1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,
other numbers or NA = unknown</p>
</dd>
<dt>BirthYear </dt><dd><p>birth or hatching year, integer, with missing values as NA
or any negative number.</p>
</dd>
<dt>BY.min</dt><dd><p>minimum birth year, only used if BirthYear is missing</p>
</dd>
<dt>BY.max</dt><dd><p>maximum birth year, only used if BirthYear is missing</p>
</dd>
<dt>Year.last</dt><dd><p>Last year in which individual could have had offspring. Can
e.g. in mammals be the year before death for females, and year after death
for males. </p>
</dd> </dl>

<p>&quot;Birth year&quot; may be in any arbitrary discrete time unit relevant to the
species (day, month, decade), as long as parents are never born in the same
time unit as their offspring, and only integers are used. Individuals do not
need to be in the same order as in &lsquo;GenoM&rsquo;, nor do all genotyped individuals
need to be included.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_ageprior">AgePrior</code></td>
<td>
<p>Agepriors matrix, as generated by <code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code>
and included in the <code><a href="#topic+sequoia">sequoia</a></code> output. Affects which
relationships are considered possible (only those where <code class="reqn">P(A|R) / P(A)
&gt; 0</code>).</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_module">Module</code></td>
<td>
<p>type of relatives to check for. One of
</p>

<dl>
<dt>par</dt><dd><p>parent - offspring pairs</p>
</dd>
<dt>ped</dt><dd><p>all first and second degree relatives</p>
</dd>
</dl>

<p>When 'par', all pairs are returned that are more likely parent-offspring
than unrelated, potentially including pairs that are even more likely to
be otherwise related.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_complex">Complex</code></td>
<td>
<p>Breeding system complexity. Either &quot;full&quot; (default), &quot;simp&quot;
(simplified, no explicit consideration of inbred relationships), &quot;mono&quot;
(monogamous).</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_herm">Herm</code></td>
<td>
<p>Hermaphrodites, either &quot;no&quot;, &quot;A&quot; (distinguish between dam and
sire role, default if at least 1 individual with sex=4), or &quot;B&quot; (no
distinction between dam and sire role). Both of the latter deal with
selfing.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_err">Err</code></td>
<td>
<p>estimated genotyping error rate, as a single number, or a length 3
vector with P(hom|hom), P(het|hom), P(hom|het), or a 3x3 matrix. See
details below. The error rate is presumed constant across SNPs, and
missingness is presumed random with respect to actual genotype. Using
<code>Err</code> &gt;5% is not recommended, and <code>Err</code> &gt;10% strongly
discouraged.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_errflavour">ErrFlavour</code></td>
<td>
<p>function that takes <code>Err</code> (single number) as input,
and returns a length 3 vector or 3x3 matrix, or choose from inbuilt options
'version2.9', 'version2.0', 'version1.3', or 'version1.1', referring to the
sequoia version in which they were the default. Ignored if <code>Err</code> is a
vector or matrix. See <code><a href="#topic+ErrToM">ErrToM</a></code> for details.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_tassign">Tassign</code></td>
<td>
<p>minimum LLR required for acceptance of proposed relationship,
relative to next most likely relationship. Higher values result in more
conservative assignments. Must be zero or positive.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_tfilter">Tfilter</code></td>
<td>
<p>threshold log10-likelihood ratio (LLR) between a proposed
relationship versus unrelated, to select candidate relatives. Typically a
negative value, related to the fact that unconditional likelihoods are
calculated during the filtering steps. More negative values may decrease
non-assignment, but will increase computational time.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_maxpairs">MaxPairs</code></td>
<td>
<p>the maximum number of putative pairs to return.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_quiet">quiet</code></td>
<td>
<p>logical, suppress messages.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_parsib">ParSib</code></td>
<td>
<p><strong>DEPRECATED, use <code>Module</code></strong> either 'par' to check
for putative parent-offspring pairs only, or 'sib' to check for all types
of first and second degree relatives.</p>
</td></tr>
<tr><td><code id="GetMaybeRel_+3A_maxmismatch">MaxMismatch</code></td>
<td>
<p><strong>DEPRECATED AND IGNORED</strong>. Now calculated
automatically using <code><a href="#topic+CalcMaxMismatch">CalcMaxMismatch</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>Module="par"</code>, the age difference of the putative pair is
temporarily set to NA so that genetic parent-offspring pairs declared to be
born in the same year may be discovered. When <code>Module="ped"</code>, only
relationships possible given the age difference, if known from the
LifeHistData, are considered.
</p>


<h3>Value</h3>

<p>A list with
</p>
<table>
<tr><td><code>MaybePar</code></td>
<td>
<p>A dataframe with non-assigned likely parent-offspring pairs,
with columns:
</p>

<ul>
<li><p> ID1
</p>
</li>
<li><p> ID2
</p>
</li>
<li><p> TopRel: the most likely relationship, using abbreviations listed
below
</p>
</li>
<li><p> LLR: Log10-Likelihood Ratio between most likely and next most
likely relationship
</p>
</li>
<li><p> OH: Number of loci at which the two individuals are opposite
homozygotes
</p>
</li>
<li><p> BirthYear1: Birth year of ID1 (copied from LifeHistData)
</p>
</li>
<li><p> BirthYear2
</p>
</li>
<li><p> AgeDif: Age difference; BirthYear1 - BirthYear2
</p>
</li>
<li><p> Sex1: Sex of ID1 (copied from LifeHistData)
</p>
</li>
<li><p> Sex2
</p>
</li>
<li><p> SnpdBoth: Number of loci at which the two individuals are both
successfully genotyped
</p>
</li></ul>
</td></tr>
<tr><td><code>MaybeRel</code></td>
<td>
<p>A dataframe with non-assigned likely pairs of relatives,
with columns identical to <code>MaybePar</code></p>
</td></tr>
<tr><td><code>MaybeTrio</code></td>
<td>
<p>A dataframe with non-assigned parent-parent-offspring
trios, with columns:
</p>

<ul>
<li><p> ID
</p>
</li>
<li><p> parent1
</p>
</li>
<li><p> parent2
</p>
</li>
<li><p> TopRel: the most likely relationship, using abbreviations listed
below
</p>
</li>
<li><p> LLRparent1: Log10-Likelihood Ratio between parent1 being a
parent of ID vs the next most likely relationship between the pair,
ignoring parent2
</p>
</li>
<li><p> LLRparent2: as LLRparent1
</p>
</li>
<li><p> LLRpair: LLR for the parental pair, versus the next most likely
configuration between the three individuals (with one or neither
parent assigned)
</p>
</li>
<li><p> OHparent1: Number of loci at which ID and parent1 are opposite
homozygotes
</p>
</li>
<li><p> OHparent2: as OHparent1
</p>
</li>
<li><p> MEpair: Number of Mendelian errors between the offspring and the
parent pair, includes OH as well as e.g. parents being opposing
homozygotes, but the offspring not being a heterozygote. The offspring
being OH with both parents is counted as 2 errors.
</p>
</li>
<li><p> SNPd.id.parent1: Number of loci at which ID and parent1 are both
successfully genotyped
</p>
</li>
<li><p> SNPd.id.parent2: as SNPd.id.parent1
</p>
</li></ul>
</td></tr>
</table>
<p>The following categories are used in column 'TopRel', indicating the most
likely relationship category:
</p>
<table>
<tr><td><code>PO</code></td>
<td>
<p>Parent-Offspring</p>
</td></tr>
<tr><td><code>FS</code></td>
<td>
<p>Full Siblings</p>
</td></tr>
<tr><td><code>HS</code></td>
<td>
<p>Half Siblings</p>
</td></tr>
<tr><td><code>GP</code></td>
<td>
<p>GrandParent - grand-offspring</p>
</td></tr>
<tr><td><code>FA</code></td>
<td>
<p>Full Avuncular (aunt/uncle)</p>
</td></tr>
<tr><td><code>2nd</code></td>
<td>
<p>2nd degree relatives, not enough information to distinguish
between HS,GP and FA</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>Unclear, but probably 1st, 2nd or 3rd degree relatives</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sequoia">sequoia</a></code> to identify likely pairs of duplicate
genotypes and for pedigree reconstruction; <code><a href="#topic+GetRelM">GetRelM</a></code> to
identify all pairs of relatives in a pedigree; <code><a href="#topic+CalcPairLL">CalcPairLL</a></code> for
the likelihoods underlying the LLR.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# without conditioning on pedigree
MaybeRel_griffin &lt;- GetMaybeRel(GenoM=Geno_griffin, Err=0.001, Module='par')

## End(Not run)
names(MaybeRel_griffin)

# conditioning on pedigree
MaybePO &lt;- GetMaybeRel(GenoM = Geno_griffin, SeqList = SeqOUT_griffin,
                      Module = 'par')
head(MaybePO$MaybePar)

# instead of providing the entire SeqList, one may specify the relevant
# elements separately
Maybe &lt;- GetMaybeRel(GenoM = Geno_griffin,
                     Pedigree = SeqOUT_griffin$PedigreePar,
                     LifeHistData = LH_griffin,
                     Err=0.0001, Complex = "full",
                     Module = "ped")
head(Maybe$MaybeRel)

# visualise results, turn dataframe into matrix first:
MaybeM &lt;- GetRelM(Pairs = Maybe$MaybeRel)
PlotRelPairs(MaybeM)
# or combine with pedigree (note suffix '?')
RelM &lt;- GetRelM(Pedigree =SeqOUT_griffin$PedigreePar, Pairs = Maybe$MaybeRel)
PlotRelPairs(RelM)

</code></pre>

<hr>
<h2 id='GetRelA'>Array with Pairwise Relationships</h2><span id='topic+GetRelA'></span>

<h3>Description</h3>

<p>Generate an array indicating the relationship(s) between all
pairs of individuals according to the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetRelA(Ped = NULL, GenBack = 1, patmat = TRUE, directed = TRUE, List = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetRelA_+3A_ped">Ped</code></td>
<td>
<p>dataframe with columns id - dam - sire.</p>
</td></tr>
<tr><td><code id="GetRelA_+3A_genback">GenBack</code></td>
<td>
<p>number of generations back to consider; 1 returns
parent-offspring and sibling relationships, 2 also returns grand-parental,
avuncular and first cousins.</p>
</td></tr>
<tr><td><code id="GetRelA_+3A_patmat">patmat</code></td>
<td>
<p>logical, distinguish between paternal versus maternal relative
pairs? For avuncular pairs, the distinction is never made.</p>
</td></tr>
<tr><td><code id="GetRelA_+3A_directed">directed</code></td>
<td>
<p>logical, distinguish between 'O' vs 'P' or group into 'PO' ?</p>
</td></tr>
<tr><td><code id="GetRelA_+3A_list">List</code></td>
<td>
<p>logical, return a list instead of the default array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3D array indicating if the pair has the specified relationship (1)
or not (0). The various relationship considered are in the 3rd dimension:
</p>
<table>
<tr><td><code>M</code></td>
<td>
</td></tr>
<tr><td><code>P</code></td>
<td>
</td></tr>
<tr><td><code>FS</code></td>
<td>
<p>full siblings, including double 'other half sibs'</p>
</td></tr>
<tr><td><code>MS</code></td>
<td>
</td></tr>
<tr><td><code>PS</code></td>
<td>
</td></tr>
<tr><td><code>XS</code></td>
<td>
<p>other sibs: mother of A is father of B, or vv</p>
</td></tr>
</table>
<p>etc.
</p>

<hr>
<h2 id='GetRelM'>Matrix with Pairwise Relationships</h2><span id='topic+GetRelM'></span>

<h3>Description</h3>

<p>Generate a matrix or 3D array with all pairwise relationships
from a pedigree or dataframe with pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetRelM(
  Pedigree = NULL,
  Pairs = NULL,
  GenBack = 1,
  patmat = FALSE,
  directed = TRUE,
  Return = "Matrix",
  Pairs_suffix = "?"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetRelM_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with columns id - dam - sire.</p>
</td></tr>
<tr><td><code id="GetRelM_+3A_pairs">Pairs</code></td>
<td>
<p>dataframe with columns ID1 - ID2 - Rel, e.g. as returned by
<code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code>. Combining <code>Pedigree</code> and <code>Pairs</code> works
best if the relationships are coded as listed below.</p>
</td></tr>
<tr><td><code id="GetRelM_+3A_genback">GenBack</code></td>
<td>
<p>number of generations back to consider; 1 returns
parent-offspring and sibling relationships, 2 also returns grand-parental,
avuncular and first cousins.</p>
</td></tr>
<tr><td><code id="GetRelM_+3A_patmat">patmat</code></td>
<td>
<p>logical, distinguish between paternal versus maternal relative
pairs? For avuncular pairs, the distinction is never made.</p>
</td></tr>
<tr><td><code id="GetRelM_+3A_directed">directed</code></td>
<td>
<p>logical, distinguish between e.g. ID1=offspring, ID2=mother
('M') and ID1=mother, ID2=offspring ('O')? Defaults to TRUE; if FALSE both
are are scored as 'PO', as are father-offspring pairs, and all
grandparent&ndash; grand-offspring pairs are scored as 'GPO', and avuncular
pairs as 'FNA' and 'HNA'. Not (currently) compatible with <code>patmat</code>.
When <code>Return</code>='List', each pair is included twice (as ID1-ID2 &amp;
ID2-ID1)</p>
</td></tr>
<tr><td><code id="GetRelM_+3A_return">Return</code></td>
<td>
<p>'Matrix', 'Array', or 'List'. 'Matrix' returns an N x N matrix
with the closest relationship between each pair. 'Array' returns an N x N x
R array with for each of the R considered relationships whether it exists
between the pair (1) or not (0). See Details below. 'List' returns a list
with for each of the R considered relationships a 2-column matrix with the
IDs of the pairs having such a relationship. The size of the list (in Mb)
is much smaller than for the matrix or array, and this is therefore the
only format suitable for pedigrees with many thousands of individuals. If
<code>Pairs</code> is specified, the only possible return type is 'Matrix'.</p>
</td></tr>
<tr><td><code id="GetRelM_+3A_pairs_suffix">Pairs_suffix</code></td>
<td>
<p>symbol added to the relationship abbreviations derived
from <code>Pairs</code>, when both <code>Pedigree</code> and <code>Pairs</code> are
provided. Can be an empty string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Double relationships are ignored when <code>Return='Matrix'</code>, but
not when <code>Return='Array'</code>. For example, when A and B are both
mother-offspring and paternal siblings (A mated with her father to produce
B), only the mother-offspring relationship will be indicated when
<code>Return='Matrix'</code>.
</p>
<p>Note that full siblings are the exception to this rule: in the <code>Array</code>
they will be indicated as 'FS' only, and not as 'MHS' or 'PHS'. Similarly,
full avuncular pairs are not indicated as 'HA'. Double half-avuncular
relationships are indicated as both FA and HA.
</p>
<p>When <code>Pairs</code> is provided, <code>GenBack</code> and <code>patmat</code> are
ignored, and no check is performed if the abbreviations are compatible with
other functions.
</p>


<h3>Value</h3>

<p>If <code>Return='Matrix'</code>, an N x N square matrix, with N equal to
the number of rows in <code>Pedigree</code> (after running
<code><a href="#topic+PedPolish">PedPolish</a></code>) or the number of unique individuals in
<code>Pairs</code>. If <code>Return='Array'</code>, an N x N x R array is returned,
with R, the number of different relationships, determined by <code>GenBack</code>
and <code>patmat</code>.
</p>
<p>The following abbreviations are used within the returned <code>Matrix</code>, or
as names of the 3rd dimension in the <code>Array</code> or of the <code>List</code>:
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>Self</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Mother</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>Father</p>
</td></tr>
<tr><td><code>MP</code></td>
<td>
<p>Mother or Father (<code>patmat=FALSE</code>)</p>
</td></tr>
<tr><td><code>O</code></td>
<td>
<p>Offspring</p>
</td></tr>
<tr><td><code>FS</code></td>
<td>
<p>Full sibling</p>
</td></tr>
<tr><td><code>MHS</code></td>
<td>
<p>Maternal half-sibling</p>
</td></tr>
<tr><td><code>PHS</code></td>
<td>
<p>Paternal half-sibling</p>
</td></tr>
<tr><td><code>XHS</code></td>
<td>
<p>other half-sibling (hermaphrodites)</p>
</td></tr>
<tr><td><code>HS</code></td>
<td>
<p>half-sibling (<code>patmat=FALSE</code>)</p>
</td></tr>
<tr><td><code>MGM</code></td>
<td>
<p>Maternal grandmother</p>
</td></tr>
<tr><td><code>MGF</code></td>
<td>
<p>Maternal grandfather</p>
</td></tr>
<tr><td><code>PGM</code></td>
<td>
<p>Paternal grandmother</p>
</td></tr>
<tr><td><code>PGF</code></td>
<td>
<p>Paternal grandfather</p>
</td></tr>
<tr><td><code>GP</code></td>
<td>
<p>Grandparent (<code>patmat=FALSE</code>)</p>
</td></tr>
<tr><td><code>GO</code></td>
<td>
<p>Grand-offspring</p>
</td></tr>
<tr><td><code>FA</code></td>
<td>
<p>Full avuncular; maternal or paternal aunt or uncle.</p>
</td></tr>
<tr><td><code>FN</code></td>
<td>
<p>Full nephew/niece</p>
</td></tr>
<tr><td><code>HA</code></td>
<td>
<p>Half avuncular</p>
</td></tr>
<tr><td><code>HN</code></td>
<td>
<p>Half nephew/niece</p>
</td></tr>
<tr><td><code>DFC1</code></td>
<td>
<p>Double full first cousin</p>
</td></tr>
<tr><td><code>FC1</code></td>
<td>
<p>Full first cousin</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Unrelated (or otherwise related)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ComparePairs">ComparePairs</a></code> for comparing pairwise relationships
between two pedigrees; <code><a href="#topic+PlotRelPairs">PlotRelPairs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rel.griffin &lt;- GetRelM(Ped_griffin, directed=FALSE)  # few categories
Rel.griffin &lt;- GetRelM(Ped_griffin, patmat=TRUE, GenBack=2)  # many cat.
table(as.vector(Rel.griffin))
# turning matrix into vector first makes table() much faster
PlotRelPairs(Rel.griffin)

</code></pre>

<hr>
<h2 id='Inherit_patterns'>Inheritance patterns</h2><span id='topic+Inherit_patterns'></span>

<h3>Description</h3>

<p>Inheritance patterns used by SimGeno for non-autosomal SNPs,
identical to those in Inherit.xlsx
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Inherit_patterns)
</code></pre>


<h3>Format</h3>

<p>An array with the following dimensions:
</p>

<dl>
<dt>d1</dt><dd><p>type: autosomal, x-chromosome, y-chromosome, or mtDNA</p>
</dd>
<dt>d2</dt><dd><p>offspring sex: female, male, or unknown</p>
</dd>
<dt>d3</dt><dd><p>offspring genotype: aa (0), aA (1), Aa (1), or AA (2)</p>
</dd>
<dt>d4</dt><dd><p>mother genotype</p>
</dd>
<dt>d5</dt><dd><p>father genotype</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimGeno">SimGeno</a></code>
</p>

<hr>
<h2 id='LH_griffin'>Example life history data: griffins</h2><span id='topic+LH_griffin'></span>

<h3>Description</h3>

<p>Example life history data associated with the griffin pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LH_griffin)
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 3 variables (ID, Sex, BirthYear)
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ped_griffin">Ped_griffin</a></code>, <code><a href="#topic+SeqOUT_griffin">SeqOUT_griffin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
BY &lt;- rep(c(2001:2010), each=20)
Sex &lt;- sample.int(n=2, size=200, replace=TRUE)
ID &lt;- paste0("i", formatC(1:200, width=3, flag="0"), "_", BY, "_",
             ifelse(Sex==1, "F", "M"))
LH_griffin &lt;- data.frame(ID, Sex, BirthYear = BY)

## End(Not run)
</code></pre>

<hr>
<h2 id='LH_HSg5'>Example life history file: 'HSg5'</h2><span id='topic+LH_HSg5'></span>

<h3>Description</h3>

<p>This is the life history file associated with
<code><a href="#topic+Ped_HSg5">Ped_HSg5</a></code>, which is <strong>Pedigree II</strong> in the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LH_HSg5)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 3 variables:
</p>

<dl>
<dt>ID</dt><dd><p>Female IDs start with 'a', males with 'b'; the next 2 numbers give
the generation number (00 &ndash; 05), the last 3 numbers the individual ID
number (runs continuously across all generations)</p>
</dd>
<dt>Sex</dt><dd><p>1 = female, 2 = male</p>
</dd>
<dt>BirthYear</dt><dd><p>from 2000 (generation 0, founders) to 2005</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>References</h3>

<p>Huisman, J. (2017) Pedigree reconstruction from SNP data:
Parentage assignment, sibship clustering, and beyond. Molecular Ecology
Resources 17:1009&ndash;1024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ped_HSg5">Ped_HSg5</a> <a href="#topic+sequoia">sequoia</a></code>
</p>

<hr>
<h2 id='LHConvert'>Extract Sex and Birth Year from PLINK File</h2><span id='topic+LHConvert'></span>

<h3>Description</h3>

<p>Convert the first six columns of a PLINK .fam, .ped or
.raw file into a three-column lifehistory file for sequoia. Optionally
FID and IID are combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LHConvert(
  PlinkFile = NULL,
  UseFID = FALSE,
  SwapSex = TRUE,
  FIDsep = "__",
  LifeHistData = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LHConvert_+3A_plinkfile">PlinkFile</code></td>
<td>
<p>character string with name of genotype file to be converted.</p>
</td></tr>
<tr><td><code id="LHConvert_+3A_usefid">UseFID</code></td>
<td>
<p>use the family ID column. The resulting ids (rownames of GenoM)
will be in the form FID__IID.</p>
</td></tr>
<tr><td><code id="LHConvert_+3A_swapsex">SwapSex</code></td>
<td>
<p>change the coding from PLINK default (1=male, 2=female) to
sequoia default (1=female, 2=male); any other numbers are set to NA.</p>
</td></tr>
<tr><td><code id="LHConvert_+3A_fidsep">FIDsep</code></td>
<td>
<p>characters inbetween FID and IID in composite-ID. By default a
double underscore is used, to avoid problems when some IIDs contain an
underscore. Only used when UseFID=TRUE.</p>
</td></tr>
<tr><td><code id="LHConvert_+3A_lifehistdata">LifeHistData</code></td>
<td>
<p>dataframe with additional sex and birth year info. In
case of conflicts, LifeHistData takes priority, with a warning. If
UseFID=TRUE, IDs in LifeHistData are assumed to be already as FID__IID.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first 6 columns of PLINK .fam, .ped and .raw files are by
default FID - IID - father ID (ignored) - mother ID (ignored) - sex -
phenotype.
</p>


<h3>Value</h3>

<p>A dataframe with id, sex and birth year, which can be used as input
for <code><a href="#topic+sequoia">sequoia</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenoConvert">GenoConvert</a></code>, <code><a href="#topic+PedStripFID">PedStripFID</a></code> to reverse
<code>UseFID</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# combine FID and IID in dataframe with additional sex &amp; birth years
ExtraLH$FID_IID &lt;- paste(ExtraLH$FID, ExtraLH$IID, sep = "__")
LH.new &lt;- LHConvert(PlinkFile, UseFID = TRUE, FIDsep = "__",
                    LifeHistData = ExtraLH)

## End(Not run)

</code></pre>

<hr>
<h2 id='LLRplot'>Scatter Plot of Pair LLRs</h2><span id='topic+LLRplot'></span>

<h3>Description</h3>

<p>Plot LLR(rely/U) against LLR(relx/U), for one combination of
relationships, colour coded by fcl &amp; top.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LLRplot(relx, rely, LLRU, fcl, top, RelCol, bgcol, Tassign = 0.5, Tfilter = -2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LLRplot_+3A_relx">relx</code></td>
<td>
<p>relationship to plot on the x-axis. One of 'PO', 'FS', 'HS',
'GP', 'FA', or 'HA'.</p>
</td></tr>
<tr><td><code id="LLRplot_+3A_rely">rely</code></td>
<td>
<p>relationship to plot on the y-axis; as <code>relx</code>.</p>
</td></tr>
<tr><td><code id="LLRplot_+3A_llru">LLRU</code></td>
<td>
<p>matrix with log10-likelihoods, already scaled by LL(U) for each
pair.</p>
</td></tr>
<tr><td><code id="LLRplot_+3A_fcl">fcl</code></td>
<td>
<p>focal relationship, sets outer circle colour of points.</p>
</td></tr>
<tr><td><code id="LLRplot_+3A_top">top</code></td>
<td>
<p>most likely relationship, sets inner filling colour of points.</p>
</td></tr>
<tr><td><code id="LLRplot_+3A_relcol">RelCol</code></td>
<td>
<p>named character vector with colours to use per relationship.</p>
</td></tr>
<tr><td><code id="LLRplot_+3A_bgcol">bgcol</code></td>
<td>
<p>do background colour TRUE/FALSE.</p>
</td></tr>
<tr><td><code id="LLRplot_+3A_tassign">Tassign</code></td>
<td>
<p>assignment threshold, shown as grey square in bottom-left
corner and band along the diagonal.</p>
</td></tr>
<tr><td><code id="LLRplot_+3A_tfilter">Tfilter</code></td>
<td>
<p>filter threshold, shown as dark grey square in bottom-left.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The background of the plot is coloured to match <code>relx</code> (bottom
triangle) and <code>rely</code> (upper triangle).
</p>

<hr>
<h2 id='MakeAgePrior'>Age Priors</h2><span id='topic+MakeAgePrior'></span>

<h3>Description</h3>

<p>Estimate probability ratios <code class="reqn">P(R|A) / P(R)</code> for age
differences A and five categories of parent-offspring and sibling
relationships R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeAgePrior(
  Pedigree = NULL,
  LifeHistData = NULL,
  MinAgeParent = NULL,
  MaxAgeParent = NULL,
  Discrete = NULL,
  Flatten = NULL,
  lambdaNW = -log(0.5)/100,
  Smooth = TRUE,
  Plot = TRUE,
  Return = "LR",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeAgePrior_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with id - dam - sire in columns 1-3, and optional
column with birth years. Other columns are ignored.</p>
</td></tr>
<tr><td><code id="MakeAgePrior_+3A_lifehistdata">LifeHistData</code></td>
<td>
<p>dataframe with 3 or 5 columns: id - sex (not used) -
birthyear (optional columns BY.min - BY.max - YearLast not used), with
unknown birth years coded as negative numbers or NA. &quot;Birth year&quot; may be in
any arbitrary discrete time unit relevant to the species (day, month,
decade), as long as parents are never born in the same time unit as their
offspring. It may include individuals not in the pedigree, and not all
individuals in the pedigree need to be in LifeHistData.</p>
</td></tr>
<tr><td><code id="MakeAgePrior_+3A_minageparent">MinAgeParent</code></td>
<td>
<p>minimum age of a parent, a single number (min across
dams and sires) or a vector of length two (dams, sires). Defaults to 1.
When there is a conflict with the minimum age in the pedigree, the pedigree
takes precedent.</p>
</td></tr>
<tr><td><code id="MakeAgePrior_+3A_maxageparent">MaxAgeParent</code></td>
<td>
<p>maximum age of a parent, a single number (max across
dams and sires) or a vector of length two (dams, sires). If NULL, it will
be set to latest - earliest birth year in <code>LifeHistData</code>, or estimated
from the pedigree if one is provided. See details below.</p>
</td></tr>
<tr><td><code id="MakeAgePrior_+3A_discrete">Discrete</code></td>
<td>
<p>discrete generations? By default (NULL), discrete
generations are assumed if all parent-offspring pairs have an age
difference of 1, and all siblings an age difference of 0, and there are at
least 20 pairs of each category (mother, father, maternal sibling, paternal
sibling). Otherwise, overlapping generations are presumed. When
<code>Discrete=TRUE</code> (explicitly or deduced), <code>Smooth</code> and
<code>Flatten</code> are always automatically set to <code>FALSE</code>. Use
<code>Discrete=FALSE</code> to enforce (potential for) overlapping generations.</p>
</td></tr>
<tr><td><code id="MakeAgePrior_+3A_flatten">Flatten</code></td>
<td>
<p>logical. To deal with small sample sizes for some or all
relationships, calculate weighed average between the observed age
difference distribution among relatives and a flat (0/1) distribution. When
<code>Flatten=NULL</code> (the default) automatically set to TRUE when there are
fewer than 20 parents with known age of either sex assigned, or fewer than
20 maternal or paternal siblings with known age difference. Also advisable
if the sampled relative pairs with known age difference are non-typical of
the pedigree as a whole.</p>
</td></tr>
<tr><td><code id="MakeAgePrior_+3A_lambdanw">lambdaNW</code></td>
<td>
<p>control weighing factors when <code>Flatten=TRUE</code>. Weights
are calculated as <code class="reqn">W(R) = 1 - exp(-lambdaNW * N(R))</code>, where <code class="reqn">N(R)</code>
is the number of pairs with relationship R for which the age difference is
known. Large values (&gt;0.2) put strong emphasis on the pedigree, small
values (&lt;0.0001) cause the pedigree to be ignored. Default results in
<code class="reqn">W=0.5</code> for <code class="reqn">N=100</code>.</p>
</td></tr>
<tr><td><code id="MakeAgePrior_+3A_smooth">Smooth</code></td>
<td>
<p>smooth the tails of and any dips in the distribution? Sets dips
(&lt;10% of average of neighbouring ages) to the average of the neighbouring
ages, sets the age after the end (oldest observed age) to LR(end)/2, and
assigns a small value (0.001) to the ages before the front (youngest
observed age) and after the new end. Peaks are not smoothed out, as these
are less likely to cause problems than dips, and are more likely to be
genuine characteristics of the species. Is set to <code>FALSE</code> when
generations do not overlap (<code>Discrete=TRUE</code>).</p>
</td></tr>
<tr><td><code id="MakeAgePrior_+3A_plot">Plot</code></td>
<td>
<p>plot a heatmap of the results?</p>
</td></tr>
<tr><td><code id="MakeAgePrior_+3A_return">Return</code></td>
<td>
<p>return only a matrix with the likelihood-ratio <code class="reqn">P(A|R) /
P(A)</code> (<code>"LR"</code>) or a list including also various intermediate
statistics (<code>"all"</code>) ?</p>
</td></tr>
<tr><td><code id="MakeAgePrior_+3A_quiet">quiet</code></td>
<td>
<p>suppress messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\alpha_{A,R}</code> is the ratio between the observed
counts of pairs with age difference A and relationship R (<code class="reqn">N_{A,R}</code>),
and the expected counts if age and relationship were independent
(<code class="reqn">N_{.,.}*p_A*p_R</code>).
</p>
<p>During pedigree reconstruction, <code class="reqn">\alpha_{A,R}</code> are multiplied by the
genetic-only <code class="reqn">P(R|G)</code> to obtain a probability that the
pair are relatives of type R conditional on both their age difference and
their genotypes.
</p>
<p>The age-difference prior is used for pairs of genotyped individuals, as
well as for dummy individuals. This assumes that the propensity for a pair
with a given age difference to both be sampled does not depend on their
relationship, so that the ratio <code class="reqn">P(A|R) / P(A)</code> does not differ between
sampled and unsampled pairs.
</p>
<p>For further details, see the vignette.
</p>


<h3>Value</h3>

<p>A matrix with the probability ratio of the age difference between two
individuals conditional on them being a certain type of relative
(<code class="reqn">P(A|R)</code>) versus being a random draw from the sample (<code class="reqn">P(A)</code>).
Assuming conditional independence, this equals the probability ratio of
being a certain type of relative conditional on the age difference, versus
being a random draw.
</p>
<p>The matrix has one row per age difference (0 - nAgeClasses) and five
columns, one for each relationship type, with abbreviations:
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>Mothers</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>Fathers</p>
</td></tr>
<tr><td><code>FS</code></td>
<td>
<p>Full siblings</p>
</td></tr>
<tr><td><code>MS</code></td>
<td>
<p>Maternal half-siblings</p>
</td></tr>
<tr><td><code>PS</code></td>
<td>
<p>Paternal half-siblings</p>
</td></tr>
</table>
<p>When <code>Return</code>='all', a list is returned with the following elements:
</p>
<table>
<tr><td><code>BirthYearRange</code></td>
<td>
<p>vector length 2</p>
</td></tr>
<tr><td><code>MaxAgeParent</code></td>
<td>
<p>vector length 2, see details</p>
</td></tr>
<tr><td><code>tblA.R</code></td>
<td>
<p>matrix with the counts per age difference (rows) /
relationship (columns) combination, plus a column 'X' with age
differences across all pairs of individuals</p>
</td></tr>
<tr><td><code>PA.R</code></td>
<td>
<p>Proportions, i.e. <code>tblA.R</code> divided by its <code>colSums</code>,
with full-sibling correction applied if necessary (see vignette).</p>
</td></tr>
<tr><td><code>LR.RU.A.raw</code></td>
<td>
<p>Proportions <code>PA.R</code> standardised by global age
difference distribution (column 'X'); <code>LR.RU.A</code> prior to flattening
and smoothing</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>vector length 4, the weights used to flatten the
distributions</p>
</td></tr>
<tr><td><code>LR.RU.A</code></td>
<td>
<p>the ageprior, flattend and/or smoothed</p>
</td></tr>
<tr><td><code>Specs.AP</code></td>
<td>
<p>the names of the input <code>Pedigree</code> and
<code>LifeHistData</code> (or <code>NULL</code>), <code>lambdaNW</code>, and the 'effective'
settings (i.e. after any automatic update) of <code>Discrete</code>,
<code>Smooth</code>, and <code>Flatten</code>.</p>
</td></tr>
</table>


<h3>CAUTION</h3>

<p>The small sample correction with <code>Smooth</code> and/or <code>Flatten</code>
prevents errors in one dataset, but may introduce errors in another; a
single solution that fits to the wide variety of life histories and
datasets is impossible. Please do inspect the matrix, e.g. with
<code>PlotAgePrior</code>, and adjust the input parameters and/or the output
matrix as necessary.
</p>


<h3>Single cohort</h3>

<p>When all individuals in <code>LifeHistData</code> have the same birth year, it is
assumed that <code>Discrete=TRUE</code> and <code>MaxAgeParent=1</code>. Consequently,
it is assumed there are no avuncular pairs present in the sample; cousins
are considered as alternative. To enforce overlapping generations, and
thereby the consideration of full- and half- avuncular relationships, set
<code>MaxAgeParent</code> to some value greater than <code class="reqn">1</code>.
</p>
<p>When no birth year information is given at all, a single cohort is assumed,
and the same rules apply.
</p>


<h3>Other time units</h3>

<p>&quot;Birth year&quot; may be in any arbitrary time unit relevant to the species
(day, month, decade), as long as parents are always born before their
putative offspring, and never in the same time unit (e.g. parent's
BirthYear= 1 (or 2001) and offspring BirthYear=5 (or 2005)). Negative
numbers and NA's are interpreted as unknown, and fractional numbers are not
allowed.
</p>


<h3>MaxAgeParent</h3>

<p>The maximum parental age for each sex equals the maximum of:
</p>

<ul>
<li><p> the maximum age of parents in <code>Pedigree</code>,
</p>
</li>
<li><p> the input parameter <code>MaxAgeParent</code>,
</p>
</li>
<li><p> the maximum range of birth years in <code>LifeHistData</code> (including
BY.min and BY.max). Only used if both of the previous are <code>NA</code>, or
if there are fewer than 20 parents of either sex assigned.
</p>
</li>
<li><p> 1, if <code>Discrete=TRUE</code> or the previous three are all <code>NA</code>
</p>
</li></ul>

<p>If the age distribution of assigned parents does not capture the maximum
possible age of parents, it is advised to specify <code>MaxAgeParent</code> for
one or both sexes. Not doing so may hinder subsequent assignment of both
dummy parents and grandparents. Not compatible with <code>Smooth</code>. If the
largest age difference in the pedigree is larger than the specified
<code>MaxAgeParent</code>, the pedigree takes precedent (i.e. the largest of the
two is used).
</p>
<p>@section grandparents &amp; avuncular
The agepriors for grand-parental and avuncular pairs is calculated from
these by <code><a href="#topic+sequoia">sequoia</a></code>, and included in its output as
'AgePriorExtra'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sequoia">sequoia</a></code> and its argument <code>args.AP</code>,
<code><a href="#topic+PlotAgePrior">PlotAgePrior</a></code> for visualisation. The age vignette gives
further details, mathematical justification, and some examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># without pedigree or lifehistdata:
MakeAgePrior(MaxAgeParent = c(2,3))
MakeAgePrior(Discrete=TRUE)

# single cohort:
MakeAgePrior(LifeHistData = data.frame(ID = letters[1:5], Sex=3,
  BirthYear=1984))

# overlapping generations:
# without pedigree: MaxAgeParent = max age difference between any pair +1
MakeAgePrior(LifeHistData = SeqOUT_griffin$LifeHist)
# with pedigree:
MakeAgePrior(Pedigree=Ped_griffin,
             LifeHistData=SeqOUT_griffin$LifeHist,
             Smooth=FALSE, Flatten=FALSE)
# with small-sample correction:
MakeAgePrior(Pedigree=Ped_griffin,
             LifeHistData=SeqOUT_griffin$LifeHist,
             Smooth=TRUE, Flatten=TRUE)

# Call from sequoia() via args.AP:
Seq_HSg5 &lt;- sequoia(SimGeno_example, LH_HSg5, Module="par",
                args.AP=list(Discrete = TRUE),  # non-overlapping generations
                CalcLLR = FALSE,   # skip time-consuming calculation of LLR's
                Plot = FALSE)      # no summary plots when finished

</code></pre>

<hr>
<h2 id='MaybeRel_griffin'>Example output from check for relatives: griffins</h2><span id='topic+MaybeRel_griffin'></span>

<h3>Description</h3>

<p>Example output of a check for parent-offspring pairs and
parent-parent-offspring trios with <code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code>, with
<code><a href="#topic+Geno_griffin">Geno_griffin</a></code> as input (simulated from
<code><a href="#topic+Ped_griffin">Ped_griffin</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MaybeRel_griffin)
</code></pre>


<h3>Format</h3>

<p>a list with 2 dataframes, 'MaybePar' and 'MaybeTrio'. See
<code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code> for further details.
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SeqOUT_griffin">SeqOUT_griffin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MaybeRel_griffin &lt;- GetMaybeRel(GenoM = Geno_griffin, Err=0.001,
                                Module = 'par')

## End(Not run)
</code></pre>

<hr>
<h2 id='MergeFill'>Special Merge</h2><span id='topic+MergeFill'></span>

<h3>Description</h3>

<p>As regular merge, but combine data from columns with the same
name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MergeFill(df1, df2, by, overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MergeFill_+3A_df1">df1</code></td>
<td>
<p>first dataframe (lowest priority if <code>overwrite=TRUE</code>).</p>
</td></tr>
<tr><td><code id="MergeFill_+3A_df2">df2</code></td>
<td>
<p>second dataframe (highest priority if <code>overwrite=TRUE</code>).</p>
</td></tr>
<tr><td><code id="MergeFill_+3A_by">by</code></td>
<td>
<p>columns used for merging, required.</p>
</td></tr>
<tr><td><code id="MergeFill_+3A_overwrite">overwrite</code></td>
<td>
<p>If FALSE (the default), NA's in df1 are replaced by values
from df2. If TRUE, all values in df1 are overwritten by values from df2,
except where df2 has NA.</p>
</td></tr>
<tr><td><code id="MergeFill_+3A_...">...</code></td>
<td>
<p>additional arguments to merge, such as <code>all</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='MkAPdefault'>Make default 1/0 ageprior</h2><span id='topic+MkAPdefault'></span>

<h3>Description</h3>

<p>Create ageprior matrix based on min and max age of parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MkAPdefault(MinP, MaxP, Disc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MkAPdefault_+3A_minp">MinP</code></td>
<td>
<p>Minimum age of dams, sires</p>
</td></tr>
<tr><td><code id="MkAPdefault_+3A_maxp">MaxP</code></td>
<td>
<p>Maximum age of dams, sires</p>
</td></tr>
<tr><td><code id="MkAPdefault_+3A_disc">Disc</code></td>
<td>
<p>Discrete generations? TRUE/FALSE/NULL</p>
</td></tr>
</table>

<hr>
<h2 id='MkFortParams'>PARAM to FortPARAM</h2><span id='topic+MkFortParams'></span>

<h3>Description</h3>

<p>Convert list <code>PARAM</code> into a list with integer-only and
double-only vectors, to be passed to Fortran.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MkFortParams(PARAM, fun = "main")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MkFortParams_+3A_param">PARAM</code></td>
<td>
<p>list with input parameters.</p>
</td></tr>
<tr><td><code id="MkFortParams_+3A_fun">fun</code></td>
<td>
<p>function from which <code><a href="#topic+MkFortParams">MkFortParams</a></code> is called,
determines which elements are included in the output list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>Ng</code></td>
<td>
<p>Integer, number of individuals</p>
</td></tr>
<tr><td><code>SpecsInt</code></td>
<td>
<p>8 integers:
</p>

<ul>
<li><p> nSnp
</p>
</li>
<li><p> MaxMismatchV; DUP - OH - ME
</p>
</li>
<li><p> MaxSibshipSize
</p>
</li>
<li><p> Complx, 0=mono, 1=simp, 2=full
</p>
</li>
<li><p> quiet, -1=verbose, 0=FALSE, 1=TRUE
</p>
</li>
<li><p> nAgeCl, nrow(AgePriors)
</p>
</li></ul>

</td></tr>
<tr><td><code>SpecsDbl</code></td>
<td>
<p>2 double precision numbers:
</p>

<ul>
<li><p> Tfilter  (&lt; 0)
</p>
</li>
<li><p> Tassign  (&gt; 0)
</p>
</li></ul>

</td></tr>
<tr><td><code>ErrM</code></td>
<td>
<p>double, 3x3 matrix passed as length-9 vector</p>
</td></tr>
<tr><td><code>SpecsIntMkPed</code></td>
<td>
<p><code>fun='main'</code> only
</p>

<ul>
<li><p> MaxSibIter
</p>
</li>
<li><p> AgeEffect, 0=no, 1=yes, 2=extra
</p>
</li>
<li><p> CalcLLR, 0=FALSE, 1=TRUE
</p>
</li>
<li><p> Herm, 0=no, 1= dam/sire distinction, 2=no dam/sire distinction
</p>
</li></ul>

</td></tr>
<tr><td><code>SpecsIntAmb</code></td>
<td>
<p><code>fun='mayberel'</code> only
</p>

<ul>
<li><p> ParSib  1=par, 2=ped
</p>
</li>
<li><p> nAmbMax
</p>
</li></ul>

</td></tr>
</table>

<hr>
<h2 id='MkGenoErrors'>Simulate Genotyping Errors</h2><span id='topic+MkGenoErrors'></span>

<h3>Description</h3>

<p>Generate errors and missing values in a (simulated) genotype
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MkGenoErrors(
  SGeno,
  CallRate = 0.99,
  SnpError = 5e-04,
  ErrorFV = function(E) c((E/2)^2, E - (E/2)^2, E/2),
  ErrorFM = NULL,
  Error.shape = 0.5,
  CallRate.shape = 1,
  WithLog = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MkGenoErrors_+3A_sgeno">SGeno</code></td>
<td>
<p>matrix with genotype data in Sequoia's format: 1 row per
individual, 1 column per SNP, and genotypes coded as 0/1/2.</p>
</td></tr>
<tr><td><code id="MkGenoErrors_+3A_callrate">CallRate</code></td>
<td>
<p>either a single number for the mean call rate (genotyping
success), OR a vector with the call rate at each SNP, OR a named vector
with the call rate for each individual. In the third case, ParMis is
ignored, and individuals in the pedigree (as id or as parent) not included
in this vector are presumed non-genotyped.</p>
</td></tr>
<tr><td><code id="MkGenoErrors_+3A_snperror">SnpError</code></td>
<td>
<p>either a single value which will be combined with
<code>ErrorFV</code>, or a length 3 vector with probabilities (observed given
actual) hom|other hom, het|hom, and hom|het; OR a vector or 3XnSnp matrix
with the genotyping error rate(s) for each SNP.</p>
</td></tr>
<tr><td><code id="MkGenoErrors_+3A_errorfv">ErrorFV</code></td>
<td>
<p>function taking the error rate (scalar) as argument and
returning a length 3 vector with hom-&gt;other hom, hom-&gt;het, het-&gt;hom. May be
an 'ErrFlavour', e.g. 'version2.9'.</p>
</td></tr>
<tr><td><code id="MkGenoErrors_+3A_errorfm">ErrorFM</code></td>
<td>
<p>function taking the error rate (scalar) as argument and
returning a 3x3 matrix with probabilities that actual genotype i (rows) is
observed as genotype j (columns). See below for details. To use, set
<code>ErrorFV = NULL</code></p>
</td></tr>
<tr><td><code id="MkGenoErrors_+3A_error.shape">Error.shape</code></td>
<td>
<p>first shape parameter (alpha) of beta-distribution of
per-SNP error rates. A higher value results in a flatter distribution.</p>
</td></tr>
<tr><td><code id="MkGenoErrors_+3A_callrate.shape">CallRate.shape</code></td>
<td>
<p>as Error.shape, for per-SNP call rates.</p>
</td></tr>
<tr><td><code id="MkGenoErrors_+3A_withlog">WithLog</code></td>
<td>
<p>Include dataframe in output with which datapoints have been
edited, with columns id - SNP - actual (original, input) - observed
(edited, output).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input genotype matrix, with some genotypes replaced, and some
set to missing (-9). If <code>WithLog=TRUE</code>, a list with 3 elements: GenoM,
Log, and Counts_actual (genotype counts in input, to allow double checking
of simulated genotyping error rate).
</p>

<hr>
<h2 id='mtSame2Dif'>Check and recode mtSame matrix</h2><span id='topic+mtSame2Dif'></span>

<h3>Description</h3>

<p>Recode to 1=different, 0=same
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtSame2Dif(mtSame = NULL, gID = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtSame2Dif_+3A_mtsame">mtSame</code></td>
<td>
<p>matrix indicating whether individuals (might) have the same
mitochondrial haplotype (1),  or definitely not (0). Not all individuals
need to be included and order is not important, may not be square.</p>
</td></tr>
<tr><td><code id="mtSame2Dif_+3A_gid">gID</code></td>
<td>
<p>rownames of 'GenoM'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>square gID x gID matrix indicating whether individuals have
definitely a different mitochondrial haplotype (1), or (possibly) the same
(0).
</p>

<hr>
<h2 id='NumToID'>Change Numeric Pedigree back to Character Pedigree</h2><span id='topic+NumToID'></span>

<h3>Description</h3>

<p>Reverse <code><a href="#topic+PedToNum">PedToNum</a></code>, 1 column at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NumToID(x, k = 0, gID = NULL, DumPrefix = c("F", "M"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NumToID_+3A_x">x</code></td>
<td>
<p>vector with numbers.</p>
</td></tr>
<tr><td><code id="NumToID_+3A_k">k</code></td>
<td>
<p>1=dam, 2=sire, needed to distinguish dummy females from dummy males.</p>
</td></tr>
<tr><td><code id="NumToID_+3A_gid">gID</code></td>
<td>
<p>vector with IDs of SNP-genotyped individuals; rownames of
genotype matrix in the exact order.</p>
</td></tr>
<tr><td><code id="NumToID_+3A_dumprefix">DumPrefix</code></td>
<td>
<p>length-2 character vector to make dummy IDs; length-3 in
case of hermaphrodites.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with IDs.
</p>

<hr>
<h2 id='OHperSNP'>Estimate Genotyping Error Rate</h2><span id='topic+OHperSNP'></span>

<h3>Description</h3>

<p>Estimate genotyping error rate from Mendelian errors per SNP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OHperSNP(GenoM, Par, Dups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OHperSNP_+3A_genom">GenoM</code></td>
<td>
<p>genotype matrix, in sequoia's format: 1 column per SNP, 1 row
per individual, genotypes coded as 0/1/2/-9, and rownames giving individual
IDs.</p>
</td></tr>
<tr><td><code id="OHperSNP_+3A_par">Par</code></td>
<td>
<p>pedigree dataframe, only genotyped parents are used.</p>
</td></tr>
<tr><td><code id="OHperSNP_+3A_dups">Dups</code></td>
<td>
<p>pairs of duplicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with columns:
</p>
<table>
<tr><td><code>n.dam</code>, <code>n.sire</code>, <code>n.pair</code></td>
<td>
<p>Number of dams, sires, parent-pairs successfully
genotyped for the SNP</p>
</td></tr>
<tr><td><code>OHdam</code>, <code>OHsire</code></td>
<td>
<p>Count of number of opposing homozygous cases</p>
</td></tr>
<tr><td><code>MEpair</code></td>
<td>
<p>Count of Mendelian errors, includes opposing homozygous cases</p>
</td></tr>
<tr><td><code>n.dups</code>, <code>n.diff</code></td>
<td>
<p>Number of duplicate pairs successfully genotyped for
the SNP; number of differences</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+SnpStats">SnpStats</a></code>.
</p>

<hr>
<h2 id='orderLH'>Order Lifehistory Data</h2><span id='topic+orderLH'></span>

<h3>Description</h3>

<p>Order lifehistory data to match order of IDs in genotype data,
filling in gaps with missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderLH(LH = NULL, gID = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderLH_+3A_lh">LH</code></td>
<td>
<p>dataframe with lifehistory information:
</p>

<dl>
<dt>ID</dt><dd><p>max. 30 characters long,</p>
</dd>
<dt>Sex</dt><dd><p>1 = females, 2 = males, other numbers = unknown,</p>
</dd>
<dt>Birth Year</dt><dd><p>(or hatching year) Use negative numbers to denote
missing values.</p>
</dd>
<dt>BY.min</dt><dd><p>minimum birth year (optional)</p>
</dd>
<dt>BY.max</dt><dd><p>maximum birth year (optional)</p>
</dd></dl>
</td></tr>
<tr><td><code id="orderLH_+3A_gid">gID</code></td>
<td>
<p>character vector with IDs in genotype data, in order of
occurrence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the same 5 columns, but with individuals in exactly
the same order as gID, including padding with 'empty' rows if an individual
in gID was not in the input-LH. Missing values are recoded to 3 for the
'Sex' column, and -999 for the birth year columns.
</p>

<hr>
<h2 id='ParamToSpecs'>PARAM to Specs</h2><span id='topic+ParamToSpecs'></span>

<h3>Description</h3>

<p>Convert list <code>PARAM</code> into 1-row dataframe <code>Specs</code>.
Only to be called by <code><a href="#topic+sequoia">sequoia</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ParamToSpecs(PARAM, TimeStart, ErrFlavour)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ParamToSpecs_+3A_param">PARAM</code></td>
<td>
<p>list with input parameters.</p>
</td></tr>
<tr><td><code id="ParamToSpecs_+3A_timestart">TimeStart</code></td>
<td>
<p>time at which <code><a href="#topic+sequoia">sequoia</a></code> run was started.</p>
</td></tr>
<tr><td><code id="ParamToSpecs_+3A_errflavour">ErrFlavour</code></td>
<td>
<p>character name or function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 1-row <code>Specs</code> dataframe.
</p>

<hr>
<h2 id='Ped_griffin'>Example pedigree: griffins</h2><span id='topic+Ped_griffin'></span>

<h3>Description</h3>

<p>Example pedigree with overlapping generations and polygamy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Ped_griffin)
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 4 variables (id, dam, sire, birthyear)
</p>


<h3>Code</h3>

<p>The R code used to create this pedigree can be found in /data-raw.
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LH_griffin">LH_griffin</a></code>; <code><a href="#topic+SeqOUT_griffin">SeqOUT_griffin</a></code> for a
sequoia run on simulated genotype data based on this pedigree;
<code><a href="#topic+Ped_HSg5">Ped_HSg5</a></code> for another pedigree; <code><a href="#topic+sequoia">sequoia</a></code>.
</p>

<hr>
<h2 id='Ped_HSg5'>Example pedigree: 'HSg5'</h2><span id='topic+Ped_HSg5'></span>

<h3>Description</h3>

<p>A pedigree with five non-overlapping generations and considerable
inbreeding. Each female mated with two random males and each male with three
random females, producing four full-sib offspring per mating. This is
<strong>Pedigree II</strong> in the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Ped_HSg5)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 3 variables (id, dam, sire)
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>References</h3>

<p>Huisman, J. (2017) Pedigree reconstruction from SNP data:
Parentage assignment, sibship clustering, and beyond. Molecular Ecology
Resources 17:1009&ndash;1024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LH_HSg5">LH_HSg5</a> <a href="#topic+SimGeno_example">SimGeno_example</a> <a href="#topic+sequoia">sequoia</a></code>
</p>

<hr>
<h2 id='PedCompare'>Compare Two Pedigrees</h2><span id='topic+PedCompare'></span>

<h3>Description</h3>

<p>Compare an inferred pedigree (Ped2) to a previous or simulated
pedigree (Ped1), including comparison of sibship clusters and sibship
grandparents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PedCompare(
  Ped1 = NULL,
  Ped2 = NULL,
  DumPrefix = c("F0", "M0"),
  SNPd = NULL,
  Symmetrical = TRUE,
  minSibSize = "1sib1GP",
  Plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PedCompare_+3A_ped1">Ped1</code></td>
<td>
<p>first (e.g. original) pedigree, dataframe with columns
id-dam-sire; only the first 3 columns will be used.</p>
</td></tr>
<tr><td><code id="PedCompare_+3A_ped2">Ped2</code></td>
<td>
<p>second pedigree, e.g. newly inferred <code>SeqOUT$Pedigree</code> or
<code>SeqOUT$PedigreePar</code>, with columns id-dam-sire.</p>
</td></tr>
<tr><td><code id="PedCompare_+3A_dumprefix">DumPrefix</code></td>
<td>
<p>character vector with the prefixes identifying dummy
individuals in <code>Ped2</code>. Use 'F0' ('M0') to avoid matching to regular
individuals with IDs starting with 'F' ('M'), provided <code>Ped2</code> has
fewer than 999 dummy females (males).</p>
</td></tr>
<tr><td><code id="PedCompare_+3A_snpd">SNPd</code></td>
<td>
<p>character vector with IDs of genotyped individuals. If
<code>NULL</code>, defaults to the IDs occurring in both <code>Ped1</code> and
<code>Ped2</code> and not starting with any of the prefixes in <code>DumPrefix</code>.</p>
</td></tr>
<tr><td><code id="PedCompare_+3A_symmetrical">Symmetrical</code></td>
<td>
<p>when determining the category of individuals
(Genotyped/Dummy/X), use the 'highest' category across the two pedigrees
(<code>TRUE</code>, default) or only consider <code>Ped1</code> (<code>Symmetrical =
FALSE</code>).</p>
</td></tr>
<tr><td><code id="PedCompare_+3A_minsibsize">minSibSize</code></td>
<td>
<p>minimum requirements to be considered 'dummifiable',
passed to <code><a href="#topic+getAssignCat">getAssignCat</a></code>:
</p>

<ul>
<li><p> '1sib' : sibship of size 1, with or without grandparents. The
latter aren't really a sibship, but can be useful in some situations.
</p>
</li>
<li><p> '1sib1GP': sibship of size 1 with at least 1 grandparent (default)
</p>
</li>
<li><p> '2sib': at least 2 siblings, with or without grandparents
(default prior to version 2.4)
</p>
</li></ul>
</td></tr>
<tr><td><code id="PedCompare_+3A_plot">Plot</code></td>
<td>
<p>show square Venn diagrams of counts?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The comparison is divided into different classes of &lsquo;assignable&rsquo;
parents (<code><a href="#topic+getAssignCat">getAssignCat</a></code>). This includes cases where the focal
individual and parent according to Ped1 are both Genotyped (G-G), as well
as cases where the non-genotyped parent according to Ped1 can be lined up
with a sibship Dummy parent in Ped2 (G-D), or where the non-genotyped focal
individual in Ped1 can be matched to a dummy individual in Ped2 (D-G and
D-D). If SNPd is NULL (the default), and DumPrefix is set to NULL, the
intersect between the IDs in Pedigrees 1 and 2 is taken as the vector of
genotyped individuals.
</p>


<h3>Value</h3>

<p>A list with
</p>
<table>
<tr><td><code>Counts</code></td>
<td>
<p>A 7 x 5 x 2 named numeric array with the
number of matches and mismatches, see below</p>
</td></tr>
<tr><td><code>Counts.detail</code></td>
<td>
<p>a large numeric array with number of matches and
mismatches, with more detail for all possible combination of categories</p>
</td></tr>
<tr><td><code>MergedPed</code></td>
<td>
<p>A dataframe with side-by-side comparison of the two
pedigrees</p>
</td></tr>
<tr><td><code>ConsensusPed</code></td>
<td>
<p>A consensus pedigree, with Pedigree 2 taking priority
over Pedigree 1</p>
</td></tr>
<tr><td><code>DummyMatch</code></td>
<td>
<p>Dataframe with all dummy IDs in Pedigree 2 (id.2), and the
best-matching individual in Pedigree 1 (id.1). Also includes the class of the
dam &amp; sire, as well as counts of offspring per outcome class (off.Match,
off.Mismatch, etc.)</p>
</td></tr>
<tr><td><code>Mismatch</code></td>
<td>
<p>A subset of MergedPed with mismatches between Ped1 and Ped2,
as defined below</p>
</td></tr>
<tr><td><code>Ped1only</code></td>
<td>
<p>as Mismatches, with parents in Ped1 that were not assigned
in Ped2</p>
</td></tr>
<tr><td><code>Ped2only</code></td>
<td>
<p>as Mismatches, with parents in Ped2 that were missing in
Ped1</p>
</td></tr>
</table>
<p>'MergedPed', 'Mismatch', 'Ped1only' and 'Ped2only' provide the following
columns:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>All ids in both Pedigree 1 and 2. For dummy individuals, this is
the id <em>in pedigree 2</em></p>
</td></tr>
<tr><td><code>dam.1</code>, <code>sire.1</code></td>
<td>
<p>parents in Pedigree 1</p>
</td></tr>
<tr><td><code>dam.2</code>, <code>sire.2</code></td>
<td>
<p>parents in Pedigree 2</p>
</td></tr>
<tr><td><code>id.r</code>, <code>dam.r</code>, <code>sire.r</code></td>
<td>
<p>The <em>real</em> id of dummy individuals or parents
in Pedigree 2, i.e. the best-matching non-genotyped individual in Pedigree 1,
or &quot;nomatch&quot;. If a sibship in Pedigree 1 is divided over 2 sibships in
Pedigree 2, the smaller one will be denoted as &quot;nomatch&quot;</p>
</td></tr>
<tr><td><code>id.dam.cat</code>, <code>id.sire.cat</code></td>
<td>
<p>the category of the individual (first letter)
and <em>highest category</em> of the dam (sire) in Pedigree 1 or 2:
G=Genotyped, D=(potential) dummy, X=none. Individual, one-letter categories
are generated by <code><a href="#topic+getAssignCat">getAssignCat</a></code>. Using the 'best' category from
both pedigrees makes comparison between two inferred pedigrees symmetrical
and more intuitive.</p>
</td></tr>
<tr><td><code>dam.class</code>, <code>sire.class</code></td>
<td>
<p>classification of dam and sire: Match, Mismatch,
P1only, P2only, or '_' when no parent is assigned in either pedigree</p>
</td></tr>
</table>
<p>The first dimension of <code>Counts</code> denotes the following categories:
</p>
<table>
<tr><td><code>GG</code></td>
<td>
<p>Genotyped individual, assigned a genotyped parent in either
pedigree</p>
</td></tr>
<tr><td><code>GD</code></td>
<td>
<p>Genotyped individual, assigned a dummy parent, or at least 1
genotyped sibling or a genotyped grandparent in Pedigree 1)</p>
</td></tr>
<tr><td><code>GT</code></td>
<td>
<p>Genotyped individual, total</p>
</td></tr>
<tr><td><code>DG</code></td>
<td>
<p>Dummy individual, assigned a genotyped parent (i.e., grandparent
of the sibship in Pedigree 2)</p>
</td></tr>
<tr><td><code>DD</code></td>
<td>
<p>Dummy individual, assigned a dummy parent (i.e., avuncular
relationship between sibships in Pedigree 2)</p>
</td></tr>
<tr><td><code>DT</code></td>
<td>
<p>Dummy total</p>
</td></tr>
<tr><td><code>TT</code></td>
<td>
<p>Total total, includes all genotyped individuals, plus
non-genotyped individuals in Pedigree 1, plus non-replaced dummy
individuals (see below) in Pedigree 2</p>
</td></tr>
</table>
<p>The second dimension of <code>Counts</code> gives the outcomes:
</p>
<table>
<tr><td><code>Total</code></td>
<td>
<p>The total number of individuals with a parent assigned in
either or both pedigrees</p>
</td></tr>
<tr><td><code>Match</code></td>
<td>
<p>The same parent is assigned in both pedigrees (non-missing).
For dummy parents, it is considered a match if the inferred sibship
which contains the most offspring of a non-genotyped parent, consists
for more than half of this individual's offspring.</p>
</td></tr>
<tr><td><code>Mismatch</code></td>
<td>
<p>Different parents assigned in the two pedigrees. When
a sibship according to Pedigree 1 is split over two sibships in Pedigree
2, the smaller fraction is included in the count here.</p>
</td></tr>
<tr><td><code>P1only</code></td>
<td>
<p>Parent in Pedigree 1 but not 2; includes non-assignable
parents (e.g. not genotyped and no genotyped offspring).</p>
</td></tr>
<tr><td><code>P2only</code></td>
<td>
<p>Parent in Pedigree 2 but not 1.</p>
</td></tr>
</table>
<p>The third dimension <code>Counts</code> separates between maternal and paternal
assignments, where e.g. paternal 'DT' is the assignment of fathers to both
maternal and paternal sibships (i.e., to dummies of both sexes).
</p>
<p>In 'ConsensusPed', the priority used is parent.r (if not &quot;nomatch&quot;) &gt;
parent.2 &gt; parent.1. The columns 'id.cat', dam.cat' and 'sire.cat' have two
additional levels compared to 'MergedPed':
</p>
<table>
<tr><td><code>G</code></td>
<td>
<p>Genotyped</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dummy individual (in Pedigree 2)</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Dummy individual in pedigree 2 replaced by best matching
non-genotyped individual in pedigree 1</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Ungenotyped, Unconfirmed (parent in Pedigree 1, with no dummy
match in Pedigree 2)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>No parent in either pedigree</p>
</td></tr>
</table>


<h3>Assignable</h3>

<p>Note that 'assignable' may be overly optimistic. Some parents from
<code>Ped1</code> indicated as assignable may never be assigned by sequoia, for
example parent-offspring pairs where it cannot be determined which is the
older of the two, or grandparents that are indistinguishable from full
avuncular (i.e. genetics inconclusive because the candidate has no parent
assigned, and ageprior inconclusive).
</p>


<h3>Dummifiable</h3>

<p>Considered as potential dummy individuals are all non-genotyped individuals
in Pedigree 1 who have, according to either pedigree, at least 2 genotyped
offspring, or at least one genotyped offspring and a genotyped parent.
</p>


<h3>Mismatches</h3>

<p>Perhaps unexpectedly, cases where all siblings are correct but a dummy
parent rather than the genotyped Ped1-parent are assigned, are classified
as a mismatch (for each of the siblings). These are typically due to a too
low assumed genotyping error rate, a wrong parental birth year, or some
other issue that requires user inspection. To identify these cases,
<code><a href="#topic+ComparePairs">ComparePairs</a></code> may be of help.
</p>


<h3>Genotyped 'mystery samples'</h3>

<p>If Pedigree 2 includes samples for which the ID is unknown, the behaviour of
<code>PedCompare</code> depends on whether the temporary IDs for these samples are
included in <code>SNPd</code>. If they are included, matching (actual) IDs in
Pedigree 1 will be flagged as mismatches (because the IDs differ). If they
are not included in <code>SNPd</code>, or <code>SNPd</code> is not explicitly provided,
matches are accepted, as the situation is indistinguishable from comparing
dummy parents across pedigrees.
</p>
<p>This is of course all conditional on relatives of the mystery sample being
assigned in Pedigree 2.
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComparePairs">ComparePairs</a></code> for comparison of all pairwise
relationships in 2 pedigrees; <code><a href="#topic+EstConf">EstConf</a></code> for repeated
simulate-reconstruct-compare; <code><a href="#topic+getAssignCat">getAssignCat</a></code> for all parents in
the reference pedigree that could have been assigned;
<code><a href="#topic+CalcOHLLR">CalcOHLLR</a></code> to check how well an 'old' pedigree fits with the
SNP data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compare &lt;- PedCompare(Ped_griffin, SeqOUT_griffin$Pedigree)
compare$Counts["TT",,]  # totals only; 45 dams &amp; 47 sires non-assigned
compare$Counts[,,"dam"]  # dams only

# inspect non-assigned in Ped2, id genotyped, dam might-be-dummy
PedM &lt;- compare$MergedPed  # for brevity
PedM[PedM$id.dam.cat=='GD' &amp; PedM$dam.class=='P1only',]
# zoom in on specific dam
PedM[which(PedM$dam.1=="i011_2001_F"), ]
# no sire for 'i034_2002_F' -&gt; impossible to tell if half-sibs or avuncular

# overview of all non-genotyped -- dummy matches
head(compare$DummyMatch)

# success of paternity assignment, if genotyped mother correctly assigned
dimnames(compare$Counts.detail)
compare$Counts.detail["G","G",,"Match",]

# default before version 3.5: minSibSize = '2sib'
compare_2s &lt;- PedCompare(Ped_griffin, SeqOUT_griffin$Pedigree,
                         minSibSize = '2sib')
compare_2s$Counts[,,"dam"]  # note decrease in Total 'dummies
with(compare_2s$MergedPed, table(id.dam.cat, dam.class))
# some with id.cat = 'X' or dam.cat='X' are nonetheless dam.class='Match'
</code></pre>

<hr>
<h2 id='PedPolish'>Fix Pedigree</h2><span id='topic+PedPolish'></span>

<h3>Description</h3>

<p>Ensure all parents &amp; all genotyped individuals are included,
remove duplicates, rename columns, and replace 0 by NA or v.v..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PedPolish(
  Pedigree,
  gID = NULL,
  ZeroToNA = TRUE,
  NAToZero = FALSE,
  DropNonSNPd = TRUE,
  FillParents = FALSE,
  KeepAllColumns = TRUE,
  KeepAllRows = FALSE,
  NullOK = FALSE,
  LoopCheck = TRUE,
  StopIfInvalid = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PedPolish_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe where the first 3 columns are id, dam, sire.</p>
</td></tr>
<tr><td><code id="PedPolish_+3A_gid">gID</code></td>
<td>
<p>character vector with ids of genotyped individuals
(rownames of genotype matrix).</p>
</td></tr>
<tr><td><code id="PedPolish_+3A_zerotona">ZeroToNA</code></td>
<td>
<p>logical, replace 0's for missing values by NA's (defaults to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="PedPolish_+3A_natozero">NAToZero</code></td>
<td>
<p>logical, replace NA's for missing values by 0's. If
<code>TRUE</code>, ZeroToNA is automatically set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="PedPolish_+3A_dropnonsnpd">DropNonSNPd</code></td>
<td>
<p>logical, remove any non-genotyped individuals (but keep
non-genotyped parents), &amp; sort pedigree in order of <code>gID</code>.</p>
</td></tr>
<tr><td><code id="PedPolish_+3A_fillparents">FillParents</code></td>
<td>
<p>logical, for individuals with only 1 parent assigned, set
the other parent to a dummy (without assigning siblings or grandparents).
Makes the pedigree compatible with R packages and software that requires
individuals to have either 2 or 0 parents, such as
<code><a href="kinship2.html#topic+kinship">kinship</a></code>.</p>
</td></tr>
<tr><td><code id="PedPolish_+3A_keepallcolumns">KeepAllColumns</code></td>
<td>
<p>Keep all columns in <code>Pedigree</code> (TRUE, default), or
only id - dam - sire (FALSE).</p>
</td></tr>
<tr><td><code id="PedPolish_+3A_keepallrows">KeepAllRows</code></td>
<td>
<p>Keep all rows in <code>Pedigree</code> (TRUE), or drop rows
where id = <code>NA</code> (FALSE, default). Duplicated rows are always removed.</p>
</td></tr>
<tr><td><code id="PedPolish_+3A_nullok">NullOK</code></td>
<td>
<p>logical, is it OK for Ped to be NULL? Then NULL will be
returned.</p>
</td></tr>
<tr><td><code id="PedPolish_+3A_loopcheck">LoopCheck</code></td>
<td>
<p>logical, check for invalid pedigree loops by calling
<code><a href="#topic+getGenerations">getGenerations</a></code>.</p>
</td></tr>
<tr><td><code id="PedPolish_+3A_stopifinvalid">StopIfInvalid</code></td>
<td>
<p>if a pedigree loop is detected, stop with an error
(TRUE, default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recognized column names are an exact or partial match with (case is
ignored):
</p>

<dl>
<dt>id</dt><dd><p>&quot;id&quot;, &quot;iid&quot;, &quot;off&quot;</p>
</dd>
<dt>dam</dt><dd><p>&quot;dam&quot;, &quot;mother&quot;, &quot;mot&quot;, &quot;mom&quot;, &quot;mum&quot;, &quot;mat&quot;</p>
</dd>
<dt>sire</dt><dd><p>&quot;sire&quot;, &quot;father&quot;, &quot;fat&quot;, &quot;dad&quot;, &quot;pat&quot;</p>
</dd></dl>

<p><code>sequoia</code> requires the column order id - dam - sire; columns 2 and 3 are
swapped by this function if necessary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To get the output pedigree into kinship2 compatible format:
PedP &lt;- sequoia::PedPolish(SeqOUT$Pedigree, DropNonSNPd=FALSE,
                           FillParents = TRUE)
PedP$Sex &lt;- with(PedP, ifelse(id %in% dam, "female",  "male"))
# default to 'male' to avoid warning: "More than 25% of the gender values are
#  'unknown'"

Ped.fix &lt;- with(PedP, kinship2::fixParents(id=id, dadid=sire, momid=dam,
                                           sex=Sex))
Ped.k &lt;- with(Ped.fix, kinship2::pedigree(id, dadid, momid, sex, missid=0))

## End(Not run)

</code></pre>

<hr>
<h2 id='PedStripFID'>Back-transform IDs</h2><span id='topic+PedStripFID'></span>

<h3>Description</h3>

<p>Reverse the joining of FID and IID in
<code><a href="#topic+GenoConvert">GenoConvert</a></code> and <code><a href="#topic+LHConvert">LHConvert</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PedStripFID(Ped, FIDsep = "__")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PedStripFID_+3A_ped">Ped</code></td>
<td>
<p>pedigree as returned by sequoia (e.g. <code>SeqOUT$Pedigree</code>).</p>
</td></tr>
<tr><td><code id="PedStripFID_+3A_fidsep">FIDsep</code></td>
<td>
<p>characters inbetween FID and IID in composite-ID.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the family IDs are the ones provided, and not
automatically updated. New, numeric ones can be obtained with
<code><a href="#topic+FindFamilies">FindFamilies</a></code>.
</p>


<h3>Value</h3>

<p>A pedigree with 6 columns
</p>
<table>
<tr><td><code>FID</code></td>
<td>
<p>family ID of focal individual (offspring).</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>within-family of focal individual</p>
</td></tr>
<tr><td><code>dam.FID</code></td>
<td>
<p>original family ID of assigned dam</p>
</td></tr>
<tr><td><code>dam</code></td>
<td>
<p>within-family of dam</p>
</td></tr>
<tr><td><code>sire.FID</code></td>
<td>
<p>original family ID of assigned sire</p>
</td></tr>
<tr><td><code>sire</code></td>
<td>
<p>within-family of sire</p>
</td></tr>
</table>

<hr>
<h2 id='PedToNum'>Turn Character Pedigree into Numeric Pedigree</h2><span id='topic+PedToNum'></span>

<h3>Description</h3>

<p>Genotyped individuals get rownumber in genotype matrix,
non-genotyped individuals either all get an arbitrary negative number
(<code>DoDummies = 'new'</code>) or only individuals with a dummy ID get the
corresponding negative number (<code>DoDummies = 'old'</code>). Note that the
number series will overlap for dummy males and dummy females.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PedToNum(
  Pedigree = NULL,
  gID = NULL,
  DoDummies = "new",
  DumPrefix = c("F0", "M0")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PedToNum_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with id - dam - sire. It is assumed
<code><a href="#topic+PedPolish">PedPolish</a></code> has been called beforehand so that column names are
correct and all columns are as.character.</p>
</td></tr>
<tr><td><code id="PedToNum_+3A_gid">gID</code></td>
<td>
<p>vector with IDs of SNP-genotyped individuals.</p>
</td></tr>
<tr><td><code id="PedToNum_+3A_dodummies">DoDummies</code></td>
<td>
<p>'new', 'old', or 'no' (ignore all non-genotyped
individuals).</p>
</td></tr>
<tr><td><code id="PedToNum_+3A_dumprefix">DumPrefix</code></td>
<td>
<p>Prefix to identify dummies when <code>DoDummies = 'old'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>DoDummies='new'</code>, <code><a href="#topic+GetDummifiable">GetDummifiable</a></code> is used
with <code>minSibSize = "1sib"</code>, and any existing dummy coding is ignored
(F0001, F0002 may become -3, -6). If <code>DoDummies='old'</code>, the existing
dummy coding is respected (F0001, F0002 will become -1, -2), but other
non-genotyped individuals are ignored.
</p>


<h3>Value</h3>

<p>a list with
</p>
<table>
<tr><td><code>PedPar</code></td>
<td>
<p>An nInd x 2 matrix with the numeric IDs of parents of
genotyped individuals</p>
</td></tr>
<tr><td><code>DumPar</code></td>
<td>
<p>A matrix with parents of dummies, see
<code><a href="#topic+FoldSibGPs">FoldSibGPs</a></code></p>
</td></tr>
<tr><td><code>Renamed</code></td>
<td>
<p>a length-2 list (dams, sires) with each element a dataframe
with columns: 'name' (original character ID), 'num' (number ID, negative)
for each dummified individual</p>
</td></tr>
<tr><td><code>Nd</code></td>
<td>
<p>a length 2 vector, no. dummies found/created for dams and sires</p>
</td></tr>
</table>

<hr>
<h2 id='PlotAgePrior'>Plot Age Priors</h2><span id='topic+PlotAgePrior'></span>

<h3>Description</h3>

<p>Visualise the age-difference based prior probability ratios as a
heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotAgePrior(AP = NULL, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotAgePrior_+3A_ap">AP</code></td>
<td>
<p>matrix with age priors (<code class="reqn">P(A|R)/P(A)</code>) with age differences in
rows and relationships in columns; by default M: maternal parent (mother),
P: paternal parent (father), FS: full siblings, MS: maternal siblings (full
+ half), PS: paternal siblings.</p>
</td></tr>
<tr><td><code id="PlotAgePrior_+3A_legend">legend</code></td>
<td>
<p>if <code>TRUE</code>, a new plotting window is started and
<code><a href="graphics.html#topic+layout">layout</a></code> is used to plot a legend next to the main plot. Set to
<code>FALSE</code> if you want to add it as panel to an existing plot (e.g. with
<code>par(mfcol=c(2,2))</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code>, <code><a href="#topic+SummarySeq">SummarySeq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PlotAgePrior(SeqOUT_griffin$AgePriors)
PlotAgePrior(SeqOUT_griffin$AgePriorExtra)

</code></pre>

<hr>
<h2 id='PlotPairLL'>Plot Pair Log10-Likelihoods</h2><span id='topic+PlotPairLL'></span>

<h3>Description</h3>

<p>Colour-coded scatter plots of e.g. LLR(PO/U) against LLR(FS/U),
for various relationship combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPairLL(
  PairLL,
  combo = list(c("FS", "PO"), c("HS", "FS"), c("GP", "HS"), c("FA", "HS")),
  nrows = NULL,
  ncols = NULL,
  bgcol = TRUE,
  Tassign = 0.5,
  Tfilter = -2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotPairLL_+3A_pairll">PairLL</code></td>
<td>
<p>dataframe, output from <code><a href="#topic+CalcPairLL">CalcPairLL</a></code>.</p>
</td></tr>
<tr><td><code id="PlotPairLL_+3A_combo">combo</code></td>
<td>
<p>list with length-2 character vectors, specifying which
likelihoods to plot against each other. Choose from 'PO', 'FS', 'HS', 'GP',
'FA', and 'HA'. The first one gets plotted on the x-axis, the second on the
y-axis. Subsequent figures will be drawn row-wise.</p>
</td></tr>
<tr><td><code id="PlotPairLL_+3A_nrows">nrows</code></td>
<td>
<p>number of rows in the figure layout. If <code>NULL</code>, set to
<code>ceiling(length(combo)/ncols)</code>.</p>
</td></tr>
<tr><td><code id="PlotPairLL_+3A_ncols">ncols</code></td>
<td>
<p>number of columns in the figure layout. If both <code>nrows</code> and
<code>ncols</code> are NULL, <code>ncols</code> is set to
<code>ceiling(sqrt(length(combo)))</code>, and <code>nrows</code> will be equal to
<code>ncols</code> or one less.</p>
</td></tr>
<tr><td><code id="PlotPairLL_+3A_bgcol">bgcol</code></td>
<td>
<p>logical, colour the upper and lower triangle background of each
figure to match the specified relationship combo.</p>
</td></tr>
<tr><td><code id="PlotPairLL_+3A_tassign">Tassign</code></td>
<td>
<p>assignment threshold, shown as grey square in bottom-left
corner and a band along the diagonal.</p>
</td></tr>
<tr><td><code id="PlotPairLL_+3A_tfilter">Tfilter</code></td>
<td>
<p>filter threshold, shown as dark grey square in bottom-left.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The colour of each point is determined by columns <code>focal</code>
(outer circle) and <code>TopRel</code> (inner filling) of <code>PairLL</code>.
</p>
<p>Impossible relationships (LL &gt; 0 in <code>PairLL</code>) are shown as <code>-Inf</code>
on the axes, if any are present.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalcPairLL">CalcPairLL</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Pairs &lt;- data.frame(ID1 = "a01005",
                    ID2 = c("a00013", "a00008", "a00011", "b00001",
                            "b01006", "b01007", "b01013", "b01014"),
                    focal = rep(c("PO", "HS"), each=4))
PLL &lt;- CalcPairLL(Pairs, GenoM=SimGeno_example, Plot=FALSE)
PlotPairLL(PLL,
           combo = list(c("FS", "PO"), c("HS", "FS"), c("GP", "HS"),
                        c("FA", "HS"), c("HA", "FA"), c("FA", "GP")),
           nrows = 3)

</code></pre>

<hr>
<h2 id='PlotPedComp'>Visualise PedCompare Output</h2><span id='topic+PlotPedComp'></span>

<h3>Description</h3>

<p>square Venn diagrams with <code><a href="#topic+PedCompare">PedCompare</a></code>
<code>Counts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPedComp(Counts, sameSize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotPedComp_+3A_counts">Counts</code></td>
<td>
<p>a 7x5x2 array with counts of matches and mismatches per
category (genotyped vs dummy), as returned by <code><a href="#topic+PedCompare">PedCompare</a></code>.</p>
</td></tr>
<tr><td><code id="PlotPedComp_+3A_samesize">sameSize</code></td>
<td>
<p>logical, make all per-category Venn diagrams the same size
<code>TRUE</code>, or make their size proportional to the counts (<code>FALSE</code>,
the default). If <code>TRUE</code>, a warning is printed at the bottom.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+PedCompare">PedCompare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PC.g &lt;- PedCompare(Ped1 = cbind(FieldMums_griffin, sire=NA),
                   Ped2 = SeqOUT_griffin$Pedigree)
PlotPedComp(PC.g$Counts)

</code></pre>

<hr>
<h2 id='PlotRelPairs'>Plot Pairwise Relationships</h2><span id='topic+PlotRelPairs'></span>

<h3>Description</h3>

<p>Plot pairwise 1st and 2nd degree relationships between
individuals, similar to Colony's dyad plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotRelPairs(
  RelM = NULL,
  subset.x = NULL,
  subset.y = NULL,
  drop.U = TRUE,
  pch.symbols = FALSE,
  cex.axis = 0.7,
  mar = c(5, 5, 1, 8)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotRelPairs_+3A_relm">RelM</code></td>
<td>
<p>square matrix with relationships between all pairs of
individuals, as generated by <code><a href="#topic+GetRelM">GetRelM</a></code>. Row and column names
should be individual IDs.</p>
</td></tr>
<tr><td><code id="PlotRelPairs_+3A_subset.x">subset.x</code></td>
<td>
<p>vector with IDs to show on the x-axis; the y-axis will
include all siblings, parents and grandparents of these individuals.</p>
</td></tr>
<tr><td><code id="PlotRelPairs_+3A_subset.y">subset.y</code></td>
<td>
<p>vector with IDs to show on the y-axis; the x-axis will
include all siblings, offspring and grandoffspring of these individuals.
Specify either <code>subset.x</code> or <code>subset.y</code> (or neither), not both.</p>
</td></tr>
<tr><td><code id="PlotRelPairs_+3A_drop.u">drop.U</code></td>
<td>
<p>logical: omit individuals without relatives from the plot, and
omit individuals without parents from the x-axis. Ignored if
<code>subset.x</code> or <code>subset.y</code> is specified.</p>
</td></tr>
<tr><td><code id="PlotRelPairs_+3A_pch.symbols">pch.symbols</code></td>
<td>
<p>logical: use different symbols for the different
relationships (TRUE) or only colours in a heatmap-like fashion (FALSE).
Question marks in the plot indicate that one or more of the symbols are not
supported on your machine.</p>
</td></tr>
<tr><td><code id="PlotRelPairs_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the magnification to be used for axis annotation. Decrease
this value if R is dropping axis labels to prevent them from overlapping.</p>
</td></tr>
<tr><td><code id="PlotRelPairs_+3A_mar">mar</code></td>
<td>
<p>A numerical vector of the form c(bottom, left, top, right) which
gives the number of lines of margin to be specified on the four sides of
the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parents are shown above the diagonal (y-axis is parent of x-axis),
siblings below the diagonal. If present, grandparents and full aunts/uncles
are also shown above the diagonal. Individuals are sorted by dam ID and
sire ID so that siblings are grouped together, and then by generation
(<code><a href="#topic+getGenerations">getGenerations</a></code>) so that later generations are closer to the
origin.
</p>
<p>If <code>RelM</code> is based on a dataframe with pairs rather than a pedigree,
parents and grandparents are similarly only displayed above the diagonal,
but the order of individuals is arbitrary and the ID on the x-axis is as
likely to be the grandparent of the one on the y-axis as vice versa. Second
degree relatives of unknown classification ('2nd', may be HS, GP or FA) are
only shown below the diagonal. The switch between pedigree-based versus
pairs-based is made on whether parent-offspring pairs are coded as 'M','P',
'MP', 'O' (unidirectional, from pedigree) or as 'PO' (bidirectional, from
pairs).
</p>
<p>Note that half-avuncular and (double) full cousin pairs are ignored.
</p>


<h3>Value</h3>

<p>The subsetted, rearranged <code>RelM</code> is returned
<code><a href="base.html#topic+invisible">invisible</a></code>.
</p>
<p>The numbers of unique pairs of each relationship type are given in the
figure legend. The number of 'self' pairs refers to the number of
individuals on the x-axis, not all of whom may occur on the y-axis when
<code>drop.U=TRUE</code> or a <code>subset</code> is specified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetRelM">GetRelM</a></code>; <code><a href="#topic+SummarySeq">SummarySeq</a></code> for individual-wise
graphical pedigree summaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rel.griffin &lt;- GetRelM(Ped_griffin, patmat=TRUE, GenBack=2)
PlotRelPairs(Rel.griffin)

## Not run: 
PlotRelPairs(Rel.griffin, pch.symbols = TRUE)
# plot with unicode symbols not supported on all platforms

## End(Not run)

# parents &amp; grandparents of 2008 cohort:
PlotRelPairs(Rel.griffin,
             subset.x = Ped_griffin$id[Ped_griffin$birthyear ==2008])
# offspring &amp; grand-offspring of 2002 cohort:
PlotRelPairs(Rel.griffin,
             subset.y = Ped_griffin$id[Ped_griffin$birthyear ==2002])

</code></pre>

<hr>
<h2 id='PlotSeqSum'>Plot Summary Overview of sequoia Output</h2><span id='topic+PlotSeqSum'></span>

<h3>Description</h3>

<p>visualise the numbers of assigned parents, sibship sizes, and
parental LLRs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSeqSum(SeqSum, Pedigree = NULL, Panels = "all", ask = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotSeqSum_+3A_seqsum">SeqSum</code></td>
<td>
<p>list output from <code><a href="#topic+SummarySeq">SummarySeq</a></code>.</p>
</td></tr>
<tr><td><code id="PlotSeqSum_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with at least id, dam and sire in columns 1-3,
respectively. If columns with parental LLRs and/or Mendelian errors are
present, these will be plotted as well.</p>
</td></tr>
<tr><td><code id="PlotSeqSum_+3A_panels">Panels</code></td>
<td>
<p>character vector with panel(s) to plot. Choose from 'all',
'G.parents' (parents of genotyped individuals), 'D.parents' (parents of
dummies), 'O.parents' (parents of non-genotyped non-dummies), sibships',
'LLR', 'OH'.</p>
</td></tr>
<tr><td><code id="PlotSeqSum_+3A_ask">ask</code></td>
<td>
<p>ask for user key stroke before proceeding to next plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sumry &lt;- SummarySeq(SeqOUT_griffin, Plot=FALSE)
PlotSeqSum(sumry, SeqOUT_griffin$Pedigree, Panels='all', ask=FALSE)

</code></pre>

<hr>
<h2 id='PlotSnpStats'>plot SnpStats results</h2><span id='topic+PlotSnpStats'></span>

<h3>Description</h3>

<p>scatter plots and histograms of allele frequency, missingness,
and estimated genotyping error, across SNPs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSnpStats(OUT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotSnpStats_+3A_out">OUT</code></td>
<td>
<p>output from <code>SnpStats</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots
</p>

<hr>
<h2 id='rc'>Find siblings</h2><span id='topic+rc'></span>

<h3>Description</h3>

<p>Find siblings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc(x, Ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc_+3A_x">x</code></td>
<td>
<p>an ID</p>
</td></tr>
<tr><td><code id="rc_+3A_ped">Ped</code></td>
<td>
<p>a pedigree with columns id - dam - sire</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The individuals which are full or half siblings to x, as a
three-column matrix with column names id1 (x), id2 (the siblings), and
RC (the relatedness category, 'FS' or 'HS').
</p>

<hr>
<h2 id='SelectNotSampled'>select non-genotyped parents</h2><span id='topic+SelectNotSampled'></span>

<h3>Description</h3>

<p>select non-genotyped parents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectNotSampled(Ped, ParMis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectNotSampled_+3A_ped">Ped</code></td>
<td>
<p>pedigree, after PedPolish()</p>
</td></tr>
<tr><td><code id="SelectNotSampled_+3A_parmis">ParMis</code></td>
<td>
<p>single number or vector length two with proportion of parents
with fully missing genotype</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with genotype matrix row numbers of non-sampled individuals
</p>

<hr>
<h2 id='SeqOUT_griffin'>Example output from pedigree inference: griffins</h2><span id='topic+SeqOUT_griffin'></span>

<h3>Description</h3>

<p>Example output of a sequoia run including sibship clustering,
with <code><a href="#topic+Geno_griffin">Geno_griffin</a></code> as input (simulated from
<code><a href="#topic+Ped_griffin">Ped_griffin</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SeqOUT_griffin)
</code></pre>


<h3>Format</h3>

<p>a list, see <code><a href="#topic+sequoia">sequoia</a></code>
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sequoia">sequoia</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
SeqOUT_griffin &lt;- sequoia(GenoM = Geno_griffin,
                          LifeHistData = LH_griffin,
                          Module = 'ped')

## End(Not run)
</code></pre>

<hr>
<h2 id='SeqOUT_HSg5'>Example output from pedigree inference: 'HSg5'</h2><span id='topic+SeqOUT_HSg5'></span>

<h3>Description</h3>

<p>Example output of a <code><a href="#topic+sequoia">sequoia</a></code> run including sibship
clustering, based on Pedigree <code><a href="#topic+Geno_HSg5">Geno_HSg5</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SeqOUT_HSg5)
</code></pre>


<h3>Format</h3>

<p>a list, see <code><a href="#topic+sequoia">sequoia</a></code>
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ped_HSg5">Ped_HSg5</a>, <a href="#topic+LH_HSg5">LH_HSg5</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# this output was created as follows:
Geno &lt;- SimGeno(Ped = Ped_HSg5, nSnp = 200)
SeqOUT_HSg5 &lt;- sequoia(GenoM = Geno, LifeHistData = LH_HSg5, Module = "ped",
                       Err = 0.005)

## End(Not run)
# some ways to inspect the output; see vignette for more info:
names(SeqOUT_HSg5)
SeqOUT_HSg5$Specs
SummarySeq(SeqOUT_HSg5)
</code></pre>

<hr>
<h2 id='SeqParSib'>Fortran Wrapper for Pedigree Reconstruction</h2><span id='topic+SeqParSib'></span>

<h3>Description</h3>

<p>Call main Fortran part of sequoia, and convert its output to a
list with dataframes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeqParSib(
  ParSib,
  FortPARAM,
  GenoM,
  LhIN,
  AgePriors,
  Parents,
  mtDif,
  DumPfx,
  quiet
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeqParSib_+3A_parsib">ParSib</code></td>
<td>
<p>either &quot;par&quot; to call parentage assignment, or &quot;sib&quot; to call the
rest of the algorithm.</p>
</td></tr>
<tr><td><code id="SeqParSib_+3A_fortparam">FortPARAM</code></td>
<td>
<p>a named vector with parameter values, as generated by
<code>ParamToSpecs</code>.</p>
</td></tr>
<tr><td><code id="SeqParSib_+3A_genom">GenoM</code></td>
<td>
<p>matrix with genotype data, size nInd x nSnp.</p>
</td></tr>
<tr><td><code id="SeqParSib_+3A_lhin">LhIN</code></td>
<td>
<p>life history data: ID - sex - birth year.</p>
</td></tr>
<tr><td><code id="SeqParSib_+3A_agepriors">AgePriors</code></td>
<td>
<p>matrix with agepriors, size 'FortPARAM[&quot;nAgeClasses&quot;]' by 8.</p>
</td></tr>
<tr><td><code id="SeqParSib_+3A_parents">Parents</code></td>
<td>
<p>matrix with rownumbers of assigned parents, size nInd by 2.</p>
</td></tr>
<tr><td><code id="SeqParSib_+3A_mtdif">mtDif</code></td>
<td>
<p>matrix indicating whether individuals have definitely a
different mitochondrial haplotype (1), or (possibly) the same (0). Size
nInd x nInd.</p>
</td></tr>
<tr><td><code id="SeqParSib_+3A_dumpfx">DumPfx</code></td>
<td>
<p>dummy prefixes</p>
</td></tr>
<tr><td><code id="SeqParSib_+3A_quiet">quiet</code></td>
<td>
<p>suppress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with
</p>
<table>
<tr><td><code>PedigreePar or Pedigree</code></td>
<td>
<p>the pedigree</p>
</td></tr>
<tr><td><code>DummyIDs</code></td>
<td>
<p>Info on dummies (not included if parentage-only)</p>
</td></tr>
<tr><td><code>TotLikParents or TotLikSib</code></td>
<td>
<p>Total log-likelihood per iteration</p>
</td></tr>
<tr><td><code>AgePriorExtra</code></td>
<td>
<p>Ageprior including columns for grandparental and
avuncular relationships</p>
</td></tr>
<tr><td><code>LifeHistPar or LifeHistSib</code></td>
<td>
<p>Includes sex and birthyear estimate
inferred from the pedigree for individuals with initially unknown sex
and/or birthyear</p>
</td></tr></table>
<p>.
</p>
<p>For a detailed description of the output see <code><a href="#topic+sequoia">sequoia</a></code>.
</p>

<hr>
<h2 id='sequoia'>Pedigree Reconstruction</h2><span id='topic+sequoia'></span>

<h3>Description</h3>

<p>Perform pedigree reconstruction based on SNP data, including
parentage assignment and sibship clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequoia(
  GenoM = NULL,
  LifeHistData = NULL,
  SeqList = NULL,
  Module = "ped",
  Err = 1e-04,
  Tfilter = -2,
  Tassign = 0.5,
  MaxSibshipSize = 100,
  DummyPrefix = c("F", "M"),
  Complex = "full",
  Herm = "no",
  UseAge = "yes",
  args.AP = list(Flatten = NULL, Smooth = TRUE),
  mtSame = NULL,
  CalcLLR = TRUE,
  quiet = FALSE,
  Plot = NULL,
  StrictGenoCheck = TRUE,
  ErrFlavour = "version2.9",
  MaxSibIter = 42,
  MaxMismatch = NA,
  FindMaybeRel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequoia_+3A_genom">GenoM</code></td>
<td>
<p>numeric matrix with genotype data: One row per individual,
one column per SNP, coded as 0, 1, 2, missing values as a negative number
or NA. You can reformat data with <code><a href="#topic+GenoConvert">GenoConvert</a></code>, or use other
packages to get it into a genlight object and then use <code>as.matrix</code>.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_lifehistdata">LifeHistData</code></td>
<td>
<p>data.frame with up to 6 columns:
</p>

<dl>
<dt>ID</dt><dd><p>max. 30 characters long</p>
</dd>
<dt>Sex</dt><dd><p>1 = female, 2 = male, 3 = unknown, 4 = hermaphrodite,
other numbers or NA = unknown</p>
</dd>
<dt>BirthYear </dt><dd><p>birth or hatching year, integer, with missing values as NA
or any negative number.</p>
</dd>
<dt>BY.min</dt><dd><p>minimum birth year, only used if BirthYear is missing</p>
</dd>
<dt>BY.max</dt><dd><p>maximum birth year, only used if BirthYear is missing</p>
</dd>
<dt>Year.last</dt><dd><p>Last year in which individual could have had offspring. Can
e.g. in mammals be the year before death for females, and year after death
for males. </p>
</dd> </dl>

<p>&quot;Birth year&quot; may be in any arbitrary discrete time unit relevant to the
species (day, month, decade), as long as parents are never born in the same
time unit as their offspring, and only integers are used. Individuals do not
need to be in the same order as in &lsquo;GenoM&rsquo;, nor do all genotyped individuals
need to be included.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_seqlist">SeqList</code></td>
<td>
<p>list with output from a previous run, to be re-used in the
current run. Used are elements &lsquo;PedigreePar&rsquo;, &lsquo;LifeHist&rsquo;, &lsquo;AgePriors&rsquo;,
&lsquo;Specs&rsquo;, and &lsquo;ErrM&rsquo;, and these override the corresponding input parameters.
Not all of these elements need to be present, and all other elements are
ignored. If <code>SeqList$Specs</code> is provided, all  input parameters with
the same name as its items are ignored, except
<code>Module</code>/<code>MaxSibIter</code>.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_module">Module</code></td>
<td>
<p>one of
</p>

<dl>
<dt>pre</dt><dd><p>Only input check, return <code>SeqList$Specs</code></p>
</dd>
<dt>dup</dt><dd><p>Also check for duplicate genotypes</p>
</dd>
<dt>par</dt><dd><p>Also perform parentage assignment (genotyped parents to
genotyped offspring)</p>
</dd>
<dt>ped</dt><dd><p>(Also) perform full pedigree reconstruction, including
sibship clustering and grandparent assignment. By far the most time
consuming, and may take several hours for large datasets.</p>
</dd>
</dl>

<p>NOTE: <em>Until 'MaxSibIter' is fully deprecated: if 'MaxSibIter' differs
from the default (<code>42</code>), and 'Module' equals the default
(<code>'ped'</code>), MaxSibIter overrides 'Module'.</em></p>
</td></tr>
<tr><td><code id="sequoia_+3A_err">Err</code></td>
<td>
<p>estimated genotyping error rate, as a single number, or a length 3
vector with P(hom|hom), P(het|hom), P(hom|het), or a 3x3 matrix. See
details below. The error rate is presumed constant across SNPs, and
missingness is presumed random with respect to actual genotype. Using
<code>Err</code> &gt;5% is not recommended, and <code>Err</code> &gt;10% strongly
discouraged.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_tfilter">Tfilter</code></td>
<td>
<p>threshold log10-likelihood ratio (LLR) between a proposed
relationship versus unrelated, to select candidate relatives. Typically a
negative value, related to the fact that unconditional likelihoods are
calculated during the filtering steps. More negative values may decrease
non-assignment, but will increase computational time.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_tassign">Tassign</code></td>
<td>
<p>minimum LLR required for acceptance of proposed relationship,
relative to next most likely relationship. Higher values result in more
conservative assignments. Must be zero or positive.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_maxsibshipsize">MaxSibshipSize</code></td>
<td>
<p>maximum number of offspring for a single individual (a
generous safety margin is advised).</p>
</td></tr>
<tr><td><code id="sequoia_+3A_dummyprefix">DummyPrefix</code></td>
<td>
<p>character vector of length 2 with prefixes for dummy dams
(mothers) and sires (fathers); maximum 20 characters each. Length 3 vector
in case of hermaphrodites (or default prefix 'H').</p>
</td></tr>
<tr><td><code id="sequoia_+3A_complex">Complex</code></td>
<td>
<p>Breeding system complexity. Either &quot;full&quot; (default), &quot;simp&quot;
(simplified, no explicit consideration of inbred relationships), &quot;mono&quot;
(monogamous).</p>
</td></tr>
<tr><td><code id="sequoia_+3A_herm">Herm</code></td>
<td>
<p>Hermaphrodites, either &quot;no&quot;, &quot;A&quot; (distinguish between dam and
sire role, default if at least 1 individual with sex=4), or &quot;B&quot; (no
distinction between dam and sire role). Both of the latter deal with
selfing.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_useage">UseAge</code></td>
<td>
<p>either &quot;yes&quot; (default), &quot;no&quot; (only use age differences for
filtering), or &quot;extra&quot; (additional rounds with extra reliance on ageprior,
may boost assignments but increased risk of erroneous assignments). Used
during full reconstruction only.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_args.ap">args.AP</code></td>
<td>
<p>list with arguments to be passed on to
<code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code>, e.g. 'Discrete' (non-overlapping generations),
'MinAgeParent', 'MaxAgeParent'.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_mtsame">mtSame</code></td>
<td>
<p><strong>NEW</strong> matrix indicating whether individuals (might)
have the same mitochondrial haplotype (1), and may thus be matrilineal
relatives, or not (0). Row names and column names should match IDs in
'GenoM'. Not all individuals need to be included and order is not
important. Please report any issues. For details see the mtDNA vignette.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_calcllr">CalcLLR</code></td>
<td>
<p>TRUE/FALSE; calculate log-likelihood ratios for all assigned
parents (genotyped + dummy; parent vs. otherwise related). Time-consuming
in large datasets. Can be done separately with <code><a href="#topic+CalcOHLLR">CalcOHLLR</a></code>.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_quiet">quiet</code></td>
<td>
<p>suppress messages: TRUE/FALSE/&quot;verbose&quot;.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_plot">Plot</code></td>
<td>
<p>display plots from <code><a href="#topic+SnpStats">SnpStats</a>, <a href="#topic+MakeAgePrior">MakeAgePrior</a></code>,
and <code><a href="#topic+SummarySeq">SummarySeq</a></code>. Defaults (NULL) to TRUE when quiet=FALSE or
&quot;verbose&quot;, and FALSE when quiet=TRUE. If you get error 'figure margins too
large', enlarge the plotting area (drag with mouse). Error 'invalid
graphics state' can be dealt with by clearing the plotting area with
dev.off().</p>
</td></tr>
<tr><td><code id="sequoia_+3A_strictgenocheck">StrictGenoCheck</code></td>
<td>
<p>Automatically exclude any individuals genotyped for
&lt;5
the unavoidable default up to version 2.4.1. Otherwise only excluded are
(very nearly) monomorphic SNPs, SNPs scored for fewer than 2 individuals,
and individuals scored for fewer than 2 SNPs.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_errflavour">ErrFlavour</code></td>
<td>
<p>function that takes <code>Err</code> (single number) as input,
and returns a length 3 vector or 3x3 matrix, or choose from inbuilt options
'version2.9', 'version2.0', 'version1.3', or 'version1.1', referring to the
sequoia version in which they were the default. Ignored if <code>Err</code> is a
vector or matrix. See <code><a href="#topic+ErrToM">ErrToM</a></code> for details.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_maxsibiter">MaxSibIter</code></td>
<td>
<p><strong>DEPRECATED, use <code>Module</code></strong> number of iterations
of sibship clustering, including assignment of grandparents to sibships and
avuncular relationships between sibships. Clustering continues until
convergence or until MaxSibIter is reached. Set to 0 for parentage
assignment only.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_maxmismatch">MaxMismatch</code></td>
<td>
<p><strong>DEPRECATED AND IGNORED</strong>. Now calculated
automatically using <code><a href="#topic+CalcMaxMismatch">CalcMaxMismatch</a></code>.</p>
</td></tr>
<tr><td><code id="sequoia_+3A_findmayberel">FindMaybeRel</code></td>
<td>
<p><strong>DEPRECATED AND IGNORED</strong>, advised to run
<code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code> separately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of candidate relatives, the likelihoods are calculated
of them being parent-offspring (PO), full siblings (FS), half siblings
(HS), grandparent-grandoffspring (GG), full avuncular (niece/nephew -
aunt/uncle; FA), half avuncular/great-grandparental/cousins (HA), or
unrelated (U). Assignments are made if the likelihood ratio (LLR) between
the focal relationship and the most likely alternative exceed the threshold
Tassign.
</p>
<p>Dummy parents of sibships are denoted by F0001, F0002, ... (mothers)
and M0001, M0002, ... (fathers), are appended to the bottom of the
pedigree, and may have been assigned real or dummy parents themselves (i.e.
sibship-grandparents). A dummy parent is not assigned to singletons.
</p>
<p>Full explanation of the various options and interpretation of the output is
provided in the vignettes and on the package website,
https://jiscah.github.io/index.html .
</p>


<h3>Value</h3>

<p>A list with some or all of the following components, depending on
<code>Module</code>. All input except <code>GenoM</code> is included in the output.
</p>
<table>
<tr><td><code>AgePriors</code></td>
<td>
<p>Matrix with age-difference based probability ratios for
each relationship, used for full pedigree reconstruction; see
<code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code> for details. When running only parentage
assignment (<code>Module="par"</code>) the returned AgePriors has been updated to
incorporate the information of the assigned parents, and is ready for use
during full pedigree reconstruction.</p>
</td></tr>
<tr><td><code>args.AP</code></td>
<td>
<p>(input) arguments used to specify age prior matrix. If a
custom ageprior was provided via <code>SeqList$AgePrior</code>, this matrix is
returned instead</p>
</td></tr>
<tr><td><code>DummyIDs</code></td>
<td>
<p>Dataframe with pedigree for dummy individuals, as well as
their sex, estimated birth year (point estimate, upper and lower bound of
95% confidence interval; see also <code><a href="#topic+CalcBYprobs">CalcBYprobs</a></code>), number of
offspring, and offspring IDs. From version 2.1 onwards, this includes dummy
offspring.</p>
</td></tr>
<tr><td><code>DupGenotype</code></td>
<td>
<p>Dataframe, duplicated genotypes (with different IDs,
duplicate IDs are not allowed). The specified number of maximum mismatches
is used here too. Note that this dataframe may include pairs of closely
related individuals, and monozygotic twins.</p>
</td></tr>
<tr><td><code>DupLifeHistID</code></td>
<td>
<p>Dataframe, row numbers of duplicated IDs in life
history dataframe. For convenience only, but may signal a problem. The
first entry is used.</p>
</td></tr>
<tr><td><code>ErrM</code></td>
<td>
<p>(input) Error matrix; probability of observed genotype (columns)
conditional on actual genotype (rows)</p>
</td></tr>
<tr><td><code>ExcludedInd</code></td>
<td>
<p>Individuals in GenoM which were excluded because of a
too low genotyping success rate (&lt;50%).</p>
</td></tr>
<tr><td><code>ExcludedSNPs</code></td>
<td>
<p>Column numbers of SNPs in GenoM which were excluded
because of a too low genotyping success rate (&lt;10%).</p>
</td></tr>
<tr><td><code>LifeHist</code></td>
<td>
<p>(input) Dataframe with sex and birth year data. All missing
birth years are coded as '-999', all missing sex as '3'.</p>
</td></tr>
<tr><td><code>LifeHistPar</code></td>
<td>
<p>LifeHist with additional columns 'Sexx' (inferred Sex when
assigned as part of parent-pair), 'BY.est' (mode of birth year probability
distribution), 'BY.lo' (lower limit of 95% highest density region), 'BY.hi'
(higher limit), inferred after parentage assignment. 'BY.est' is NA when the
probability distribution is flat between 'BY.lo' and 'BY.hi'.</p>
</td></tr>
<tr><td><code>LifeHistSib</code></td>
<td>
<p>as LifeHistPar, but estimated after full pedigree
reconstruction</p>
</td></tr>
<tr><td><code>NoLH</code></td>
<td>
<p>Vector, IDs in genotype data for which no life history data is
provided.</p>
</td></tr>
<tr><td><code>Pedigree</code></td>
<td>
<p>Dataframe with assigned genotyped and dummy parents from
Sibship step; entries for dummy individuals are added at the bottom.</p>
</td></tr>
<tr><td><code>PedigreePar</code></td>
<td>
<p>Dataframe with assigned parents from Parentage step.</p>
</td></tr>
<tr><td><code>Specs</code></td>
<td>
<p>Named vector with parameter values.</p>
</td></tr>
<tr><td><code>TotLikParents</code></td>
<td>
<p>Numeric vector, Total likelihood of the genotype data
at initiation and after each iteration during Parentage.</p>
</td></tr>
<tr><td><code>TotLikSib</code></td>
<td>
<p>Numeric vector, Total likelihood of the genotype data
at initiation and after each iteration during Sibship clustering.</p>
</td></tr>
<tr><td><code>AgePriorExtra</code></td>
<td>
<p>As AgePriors, but including columns for grandparents
and avuncular pairs. NOT updated after parentage assignment, but returned
as used during the run.</p>
</td></tr>
<tr><td><code>DummyClones</code></td>
<td>
<p>Hermaphrodites only: female-male dummy ID pairs that refer
to the same non-genotyped individual</p>
</td></tr>
</table>
<p>List elements PedigreePar and Pedigree both have the following columns:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Individual ID</p>
</td></tr>
<tr><td><code>dam</code></td>
<td>
<p>Assigned mother, or NA</p>
</td></tr>
<tr><td><code>sire</code></td>
<td>
<p>Assigned father, or NA</p>
</td></tr>
<tr><td><code>LLRdam</code></td>
<td>
<p>Log10-Likelihood Ratio (LLR) of this female being the mother,
versus the next most likely relationship between the focal individual and
this female. See Details below for relationships considered, and see
<code><a href="#topic+CalcPairLL">CalcPairLL</a></code> for underlying likelihood values and further
details)</p>
</td></tr>
<tr><td><code>LLRsire</code></td>
<td>
<p>idem, for male parent</p>
</td></tr>
<tr><td><code>LLRpair</code></td>
<td>
<p>LLR for the parental pair, versus the next most likely
configuration between the three individuals (with one or neither parent
assigned)</p>
</td></tr>
<tr><td><code>OHdam</code></td>
<td>
<p>Number of loci at which the offspring and mother are
opposite homozygotes</p>
</td></tr>
<tr><td><code>OHsire</code></td>
<td>
<p>idem, for father</p>
</td></tr>
<tr><td><code>MEpair</code></td>
<td>
<p>Number of Mendelian errors between the offspring and the
parent pair, includes OH as well as e.g. parents being opposing
homozygotes, but the offspring not being a heterozygote. The offspring
being OH with both parents is counted as 2 errors.</p>
</td></tr>
</table>


<h3>Genotyping error rate</h3>

<p>The genotyping error rate <code>Err</code> can be specified three different ways:
</p>

<ul>
<li><p> A single number, which is combined with <code>ErrFlavour</code> by
<code><a href="#topic+ErrToM">ErrToM</a></code> to create a length 3 vector (next item). By
default (<code>ErrFlavour</code> = 'version2.9'), P(hom|hom)=$(E/2)^2$,
P(het|hom)=$E-(E/2)^2$, P(hom|het)=$E/2$.
</p>
</li>
<li><p> a length 3 vector (NEW from version 2.6), with the probabilities to
observe a actual homozygote as the other homozygote (hom|hom), to observe
a homozygote as heterozygote (het|hom), and to observe an actual
heterozygote as homozygote (hom|het). This assumes that the two alleles
are equivalent with respect to genotyping errors, i.e. $P(AA|aa) =
P(aa|AA)$, $P(aa|Aa)=P(AA|Aa)$, and $P(aA|aa)=P(aA|AA)$.
</p>
</li>
<li><p> a 3x3 matrix, with the probabilities of observed genotype (columns)
conditional on actual genotype (rows). Only needed when the assumption
in the previous item does not hold. See <code><a href="#topic+ErrToM">ErrToM</a></code> for details.
</p>
</li></ul>



<h3>(Too) Few Assignments?</h3>

<p>Possibly <code>Err</code> is much lower than the actual genotyping error rate.
</p>
<p>Alternatively, a true parent will not be assigned when it is:
</p>

<ul>
<li><p> unclear who is the parent and who the offspring, due to unknown birth
year for one or both individuals
</p>
</li>
<li><p> unclear whether the parent is the father or mother
</p>
</li>
<li><p> unclear if it is a parent or e.g. full sibling or grandparent, due to
insufficient genetic data
</p>
</li></ul>

<p>And true half-siblings will not be clustered when it is:
</p>

<ul>
<li><p> unclear if they are maternal or paternal half-siblings
</p>
</li>
<li><p> unclear if they are half-siblings, full avuncular, or grand-parental
</p>
</li>
<li><p> unclear what type of relatives they are due to insufficient genetic
data
</p>
</li></ul>

<p>All pairs of non-assigned but likely/definitely relatives can be found with
<code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code>. For a method to do pairwise 'assignments', see
https://jiscah.github.io/articles/pairLL_classification.html ; for further
information, see the vignette.
</p>


<h3>Disclaimer</h3>

<p>While every effort has been made to ensure that sequoia provides what it
claims to do, there is absolutely no guarantee that the results provided are
correct. Use of sequoia is entirely at your own risk.
</p>


<h3>Website</h3>

<p>https://jiscah.github.io/
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>References</h3>

<p>Huisman, J. (2017) Pedigree reconstruction from SNP data:
Parentage assignment, sibship clustering, and beyond. Molecular Ecology
Resources 17:1009&ndash;1024.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+GenoConvert">GenoConvert</a></code> to read in various data formats,
</p>
</li>
<li> <p><code><a href="#topic+CheckGeno">CheckGeno</a></code>, <code><a href="#topic+SnpStats">SnpStats</a></code> to calculate
missingness and allele frequencies,
</p>
</li>
<li> <p><code><a href="#topic+SimGeno">SimGeno</a></code>  to simulate SNP data from a pedigree,
</p>
</li>
<li> <p><code><a href="#topic+MakeAgePrior">MakeAgePrior</a></code> to estimate effect of age on relationships,
</p>
</li>
<li> <p><code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code> to find pairs of potential relatives,
</p>
</li>
<li> <p><code><a href="#topic+SummarySeq">SummarySeq</a></code> and <code><a href="#topic+PlotAgePrior">PlotAgePrior</a></code> to visualise
results,
</p>
</li>
<li> <p><code><a href="#topic+GetRelM">GetRelM</a></code> to turn a pedigree into pairwise relationships,
</p>
</li>
<li> <p><code><a href="#topic+CalcOHLLR">CalcOHLLR</a></code> to calculate Mendelian errors and LLR for any
pedigree,
</p>
</li>
<li> <p><code><a href="#topic+CalcPairLL">CalcPairLL</a></code> for likelihoods of various relationships
between specific pairs,
</p>
</li>
<li> <p><code><a href="#topic+CalcBYprobs">CalcBYprobs</a></code> to estimate birth years,
</p>
</li>
<li> <p><code><a href="#topic+PedCompare">PedCompare</a></code> and <code><a href="#topic+ComparePairs">ComparePairs</a></code> to compare to
two pedigrees,
</p>
</li>
<li> <p><code><a href="#topic+EstConf">EstConf</a></code> to estimate assignment errors,
</p>
</li>
<li> <p><code><a href="#topic+writeSeq">writeSeq</a></code> to save results,
</p>
</li>
<li> <p><code>vignette("sequoia")</code> for detailed manual &amp; FAQ.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># ===  EXAMPLE 1: simulated data  ===
head(SimGeno_example[,1:10])
head(LH_HSg5)
# parentage assignment:
SeqOUT &lt;- sequoia(GenoM = SimGeno_example, Err = 0.005,
                  LifeHistData = LH_HSg5, Module="par", Plot=TRUE)
names(SeqOUT)
SeqOUT$PedigreePar[34:42, ]

# compare to true (or old) pedigree:
PC &lt;- PedCompare(Ped_HSg5, SeqOUT$PedigreePar)
PC$Counts["GG",,]


# parentage assignment + full pedigree reconstruction:
# (note: this can be rather time consuming)
SeqOUT2 &lt;- sequoia(GenoM = SimGeno_example, Err = 0.005,
                  LifeHistData = LH_HSg5, Module="ped", quiet="verbose")
SeqOUT2$Pedigree[34:42, ]

PC2 &lt;- PedCompare(Ped_HSg5, SeqOUT2$Pedigree)
PC2$Counts["GT",,]
PC2$Counts[,,"dam"]

# different kind of pedigree comparison:
ComparePairs(Ped1=Ped_HSg5, Ped2=SeqOUT$PedigreePar, patmat=TRUE)

# results overview:
SummarySeq(SeqOUT2)

# important to run with approx. correct genotyping error rate:
SeqOUT2.b &lt;- sequoia(GenoM = SimGeno_example, #  Err = 1e-4 by default
                  LifeHistData = LH_HSg5, Module="ped", Plot=FALSE)
PC2.b &lt;- PedCompare(Ped_HSg5, SeqOUT2.b$Pedigree)
PC2.b$Counts["GT",,]


## Not run: 
# ===  EXAMPLE 2: real data  ===
# ideally, select 400-700 SNPs: high MAF &amp; low LD
# save in 0/1/2/NA format (PLINK's --recodeA)
GenoM &lt;- GenoConvert(InFile = "inputfile_for_sequoia.raw",
                     InFormat = "raw")  # can also do Colony format
SNPSTATS &lt;- SnpStats(GenoM)
# perhaps after some data-cleaning:
write.table(GenoM, file="MyGenoData.txt", row.names=T, col.names=F)

# later:
GenoM &lt;- as.matrix(read.table("MyGenoData.txt", row.names=1, header=F))
LHdata &lt;- read.table("LifeHistoryData.txt", header=T) # ID-Sex-birthyear
SeqOUT &lt;- sequoia(GenoM, LHdata, Err=0.005)
SummarySeq(SeqOUT)

SeqOUT$notes &lt;- "Trial run on cleaned data"  # add notes for future reference
saveRDS(SeqOUT, file="sequoia_output_42.RDS")  # save to R-specific file
writeSeq(SeqOUT, folder="sequoia_output")  # save to several plain text files

# runtime:
SeqOUT$Specs$TimeEnd - SeqOUT$Specs$TimeStart

## End(Not run)

</code></pre>

<hr>
<h2 id='SibMatch'>Find the closest matching inferred sibship to a true sibship</h2><span id='topic+SibMatch'></span>

<h3>Description</h3>

<p>Find the closest matching inferred sibship to a true sibship
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SibMatch(SimX, Infrd, SNPd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SibMatch_+3A_simx">SimX</code></td>
<td>
<p>a vector with the IDs in the true (Ped1) sibship</p>
</td></tr>
<tr><td><code id="SibMatch_+3A_infrd">Infrd</code></td>
<td>
<p>a list of vectors with the IDs in the inferred (Ped2) sibships</p>
</td></tr>
<tr><td><code id="SibMatch_+3A_snpd">SNPd</code></td>
<td>
<p>character vector with IDs of genotyped individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numeric vector with the number of matches ('NumMatch'),
the position of the best match ('Best'), the inferred sibship size of
this best match ('Tot'), the number of matching IDs ('OK'), and the
number of mismatches ('err').
</p>

<hr>
<h2 id='SimGeno'>Simulate Genotypes</h2><span id='topic+SimGeno'></span>

<h3>Description</h3>

<p>Simulate SNP genotype data from a pedigree, with optional
missingness, genotyping errors, and non-genotyped parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimGeno(
  Pedigree,
  nSnp = 400,
  ParMis = c(0, 0),
  MAF = 0.3,
  CallRate = 0.99,
  SnpError = 5e-04,
  ErrorFV = function(E) c((E/2)^2, E - (E/2)^2, E/2),
  ErrorFM = NULL,
  ReturnStats = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimGeno_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe, pedigree with the first three columns being id -
dam - sire, additional columns are ignored.</p>
</td></tr>
<tr><td><code id="SimGeno_+3A_nsnp">nSnp</code></td>
<td>
<p>number of SNPs to simulate.</p>
</td></tr>
<tr><td><code id="SimGeno_+3A_parmis">ParMis</code></td>
<td>
<p>single number or vector length two with proportion of parents
with fully missing genotype. Ignored if CallRate is a named vector. NOTE:
default changed from 0.4 (up to version 2.8.5) to 0 (from version 2.9).</p>
</td></tr>
<tr><td><code id="SimGeno_+3A_maf">MAF</code></td>
<td>
<p>either a single number with minimum minor allele frequency, and
allele frequencies will be sampled uniformly between this minimum and 0.5,
OR a vector with minor allele frequency at each locus. In both cases, this
is the MAF among pedigree founders, the MAF in the sample will deviate due
to drift.</p>
</td></tr>
<tr><td><code id="SimGeno_+3A_callrate">CallRate</code></td>
<td>
<p>either a single number for the mean call rate (genotyping
success), OR a vector with the call rate at each SNP, OR a named vector
with the call rate for each individual. In the third case, ParMis is
ignored, and individuals in the pedigree (as id or as parent) not included
in this vector are presumed non-genotyped.</p>
</td></tr>
<tr><td><code id="SimGeno_+3A_snperror">SnpError</code></td>
<td>
<p>either a single value which will be combined with
<code>ErrorFV</code>, or a length 3 vector with probabilities (observed given
actual) hom|other hom, het|hom, and hom|het; OR a vector or 3XnSnp matrix
with the genotyping error rate(s) for each SNP.</p>
</td></tr>
<tr><td><code id="SimGeno_+3A_errorfv">ErrorFV</code></td>
<td>
<p>function taking the error rate (scalar) as argument and
returning a length 3 vector with hom-&gt;other hom, hom-&gt;het, het-&gt;hom. May be
an 'ErrFlavour', e.g. 'version2.9'.</p>
</td></tr>
<tr><td><code id="SimGeno_+3A_errorfm">ErrorFM</code></td>
<td>
<p>function taking the error rate (scalar) as argument and
returning a 3x3 matrix with probabilities that actual genotype i (rows) is
observed as genotype j (columns). See below for details. To use, set
<code>ErrorFV = NULL</code></p>
</td></tr>
<tr><td><code id="SimGeno_+3A_returnstats">ReturnStats</code></td>
<td>
<p>in addition to the genotype matrix, return the input
parameters and mean &amp; quantiles of MAF, error rate and call rates.</p>
</td></tr>
<tr><td><code id="SimGeno_+3A_quiet">quiet</code></td>
<td>
<p>suppress messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For founders, i.e. individuals with no
known parents, genotypes are drawn according to the provided MAF and
assuming Hardy-Weinberg equilibrium. Offspring genotypes are generated
following Mendelian inheritance, assuming all loci are completely
independent. Individuals with one known parent are allowed: at each locus,
one allele is inherited from the known parent, and the other drawn from the
genepool according to the provided MAF.
</p>


<h3>Value</h3>

<p>If <code>ReturnStats=FALSE</code> (the default), a matrix with genotype
data in sequoia's input format, encoded as 0/1/2/-9.
</p>
<p>If <code>ReturnStats=TRUE</code>, a named list with three elements: list
'ParamsIN', matrix 'SGeno', and list 'StatsOUT':
</p>
<table>
<tr><td><code>AF</code></td>
<td>
<p>Frequency in 'observed' genotypes of '1' allele</p>
</td></tr>
<tr><td><code>AF.act</code></td>
<td>
<p>Allele frequency in 'actual' (without genotyping errors &amp;
missingness)</p>
</td></tr>
<tr><td><code>SnpError</code></td>
<td>
<p>Error rate per SNP (actual /= observed AND observed /=
missing)</p>
</td></tr>
<tr><td><code>SnpCallRate</code></td>
<td>
<p>Non-missing per SNP</p>
</td></tr>
<tr><td><code>IndivError</code></td>
<td>
<p>Error rate per individual</p>
</td></tr>
<tr><td><code>IndivCallRate</code></td>
<td>
<p>Non-missing per individual</p>
</td></tr>
</table>


<h3>Genotyping errors</h3>

<p>If <code>SnpError</code> is a length 3 vector, genotyping errors are generated
following a length 3 vector with probabilities that 1) an actual homozygote
is observed as the other homozygote, 2) an actual homozygote is observed as
a heterozygote, and 3) an heterozygote is observed as an homozygote. The
only assumption made is that the two alleles can be treated equally, i.e.
observing actual allele $A$ as $a$ is as likely as observing actual $a$ as
$A$.
</p>
<p>If <code>SnpError</code> is a single value, by default this is interpreted as a
locus-level error rate (rather than allele-level), and equals the
probability that a homozygote is observed as heterozygote, and the
probability that a heterozygote is observed as either homozygote (i.e., the
probability that it is observed as AA = probability that observed as aa =
<code>SnpError</code>/2). The probability that one homozygote is observed as the
other is (<code>SnpError</code>/2<code class="reqn">)^2</code>. How this single value is rendered
into a 3x3 error matrix is fully flexible and specified via <code>ErrorFM</code>;
see <code>link{ErrToM}</code> for details.
</p>
<p>The default values of <code>SnpError=5e-4</code> and <code>ErrorFM='version2.9'</code>
correspond to the length 3 vector <code>c((5e-4/2)^2, 5e-4*(1-5e-4/2),
  5e-4/2)</code>.
</p>
<p>A beta-distribution is used to simulate variation in the error rate between
SNPs, the shape parameter of this distribution can be specified via
<code><a href="#topic+MkGenoErrors">MkGenoErrors</a></code>. It is also possible to specify the error rate
per SNP.
</p>


<h3>Call Rate</h3>

<p>Variation in call rates across SNPs is assumed to follow a highly skewed
(beta) distribution, with many SNPs having call rates close to 1, and a
narrowing tail of lower call rates. The first shape parameter defaults to 1
(but see <code><a href="#topic+MkGenoErrors">MkGenoErrors</a></code>), and the second shape parameter is
defined via the mean as <code>CallRate</code>. For 99.9% of SNPs to have a call
rate of 0.8 (0.9; 0.95) or higher, use a mean call rate of 0.969 (0.985;
0.993).
</p>
<p>Variation in call rate between samples can be specified by providing a
named vector to <code>CallRate</code>. Otherwise, variation in call rate and
error rate between samples occurs only as side-effect of the random nature
of which individuals are hit by per-SNP errors and drop-outs. Finer control
is possible by first generating an error-free genotype matrix, and then
calling <code><a href="#topic+MkGenoErrors">MkGenoErrors</a></code> directly on (subsets of) the matrix.
</p>


<h3>Disclaimer</h3>

<p>This simulation is highly simplistic and assumes that
all SNPs segregate completely independently, that the SNPs are in
Hardy-Weinberg equilibrium in the pedigree founders. It assumes that
genotyping errors are not due to heritable mutations of the SNPs, and that
missingness is random and not e.g. due to heritable mutations of SNP
flanking regions. Results based on this simulated data will provide an
minimum estimate of the number of SNPs required, and an optimistic estimate
of pedigree reconstruction performance.
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p>The wrapper <code><a href="#topic+EstConf">EstConf</a></code> for repeated simulation and
pedigree reconstruction; <code><a href="#topic+MkGenoErrors">MkGenoErrors</a></code> for fine control over
the distribution of genotyping errors in simulated data;
<code><a href="#topic+ErrToM">ErrToM</a></code> for more information about genotyping error patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Geno_A &lt;- SimGeno(Pedigree = Ped_griffin, nSnp=200, ParMis=c(0.1, 0.6),
                  MAF = 0.25, SnpError = 0.001)

Geno_B &lt;- SimGeno(Pedigree = Ped_HSg5, nSnp = 100, ParMis = 0.2,
                 SnpError = c(0.01, 0.04, 0.1))

Geno_C &lt;- SimGeno(Pedigree = Ped_griffin, nSnp=200, ParMis=0, CallRate=0.6,
                  SnpError = 0.05, ErrorFV=function(E) c(E/10, E/10, E))

# genotype matrix with duplicated samples:
Dups_grif &lt;- data.frame(ID1 = c('i006_2001_M', 'i021_2002_M', 'i064_2004_F'))
Dups_grif$ID2 &lt;- paste0(Dups_grif$ID1, '_2')
Err &lt;- c(0.01, 0.04, 0.1)
Geno_act &lt;- SimGeno(Ped_griffin, nSnp=500, ParMis=0, CallRate=1, SnpError=0)
Geno_sim &lt;- MkGenoErrors(Geno_act, SnpError=Err, CallRate=0.99)
Geno_dups &lt;- MkGenoErrors(Geno_act[Dups_grif$ID1, ], SnpError=Err,
                          CallRate=0.99)
rownames(Geno_dups) &lt;- Dups_grif$ID2
Geno_sim &lt;- rbind(Geno_sim, Geno_dups)


</code></pre>

<hr>
<h2 id='SimGeno_example'>Example genotype file: 'HSg5'</h2><span id='topic+SimGeno_example'></span>

<h3>Description</h3>

<p>Simulated genotype data for cohorts 1+2 in Pedigree
<code><a href="#topic+Ped_HSg5">Ped_HSg5</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SimGeno_example)
</code></pre>


<h3>Format</h3>

<p>A genotype matrix with 214 rows (ids) and 200 columns (SNPs). Each
SNP is coded as 0/1/2 copies of the reference allele, with -9 for missing
values. Ids are stored as rownames.
</p>


<h3>Author(s)</h3>

<p>Jisca Huisman, <a href="mailto:jisca.huisman@gmail.com">jisca.huisman@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LH_HSg5">LH_HSg5</a>, <a href="#topic+SimGeno">SimGeno</a></code>
</p>

<hr>
<h2 id='SmoothAP'>Smooth out dips in ageprior matrix</h2><span id='topic+SmoothAP'></span>

<h3>Description</h3>

<p>...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SmoothAP(V, tiny = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SmoothAP_+3A_v">V</code></td>
<td>
<p>column in ageprior matrix (vector); strictly positive</p>
</td></tr>
<tr><td><code id="SmoothAP_+3A_tiny">tiny</code></td>
<td>
<p>smallest non-zero value in V</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets dips (&lt;10% of average of neighbouring ages) to the average of
the neighbouring ages, sets the age after the end (oldest observed age) to
LR(end)/2, and assigns a small value (0.001) to the ages before the front
(youngest observed age) and after the new end. Peaks are not smoothed out,
as these are less likely to cause problems than dips, and are more likely
to be genuine characteristics of the species.
</p>

<hr>
<h2 id='SnpStats'>SNP Summary Statistics</h2><span id='topic+SnpStats'></span>

<h3>Description</h3>

<p>Estimate allele frequency (AF), missingness and Mendelian
errors per SNP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SnpStats(
  GenoM,
  Pedigree = NULL,
  Duplicates = NULL,
  Plot = TRUE,
  quiet = TRUE,
  ErrFlavour
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SnpStats_+3A_genom">GenoM</code></td>
<td>
<p>genotype matrix, in sequoia's format: 1 column per SNP, 1 row
per individual, genotypes coded as 0/1/2/-9, and row names giving individual
IDs.</p>
</td></tr>
<tr><td><code id="SnpStats_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe with 3 columns: ID - parent1 - parent2.
Additional columns and non-genotyped individuals are ignored. Used to count
Mendelian errors per SNP and (poorly) estimate the error rate.</p>
</td></tr>
<tr><td><code id="SnpStats_+3A_duplicates">Duplicates</code></td>
<td>
<p>dataframe with pairs of duplicated samples</p>
</td></tr>
<tr><td><code id="SnpStats_+3A_plot">Plot</code></td>
<td>
<p>show histograms of the results?</p>
</td></tr>
<tr><td><code id="SnpStats_+3A_quiet">quiet</code></td>
<td>
<p>suppress messages</p>
</td></tr>
<tr><td><code id="SnpStats_+3A_errflavour">ErrFlavour</code></td>
<td>
<p>DEPRECATED AND IGNORED. Was used to estimate <code>Err.hat</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of these summary statistics can be done in PLINK, and
SNPs with low minor allele frequency or high missingness should be filtered
out prior to pedigree reconstruction. This function is provided as an aid
to inspect the relationship between AF, missingness and genotyping error to
find a suitable combination of SNP filtering thresholds to use.
</p>
<p>For pedigree reconstruction, SNPs with zero or one copies of the alternate
allele in the dataset (MAF <code class="reqn">\le 1/2N</code>) are considered fixed, and
excluded.
</p>


<h3>Value</h3>

<p>A matrix with a number of rows equal to the number of SNPs
(=number of columns of GenoM), and when no Pedigree is provided 2 columns:
</p>
<table>
<tr><td><code>AF</code></td>
<td>
<p>Allele frequency of the 'second allele' (the one for which the
homozygote is coded 2)</p>
</td></tr>
<tr><td><code>Mis</code></td>
<td>
<p>Proportion of missing calls</p>
</td></tr>
<tr><td><code>HWE.p</code></td>
<td>
<p>p-value from chi-square test for Hardy-Weinberg equilibrium</p>
</td></tr>
</table>
<p>When a Pedigree is provided, there are 8 additional columns:
</p>
<table>
<tr><td><code>n.dam</code>, <code>n.sire</code>, <code>n.pair</code></td>
<td>
<p>Number of dams, sires, parent-pairs successfully
genotyped for the SNP</p>
</td></tr>
<tr><td><code>OHdam</code>, <code>OHsire</code></td>
<td>
<p>Count of number of opposing homozygous cases</p>
</td></tr>
<tr><td><code>MEpair</code></td>
<td>
<p>Count of Mendelian errors, includes opposing homozygous cases
when only one parent is genotyped</p>
</td></tr>
<tr><td><code>n.dups</code>, <code>n.diff</code></td>
<td>
<p>Number of duplicate pairs successfully genotyped for
the SNP; number of differences. The latter does not count cases where one
duplicate is not successfully genotyped at the SNP</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GenoConvert">GenoConvert</a></code> to convert from various data formats;
<code><a href="#topic+CheckGeno">CheckGeno</a></code> to check the data is in valid format for sequoia
and exclude monomorphic SNPs etc., <code><a href="#topic+CalcOHLLR">CalcOHLLR</a></code> to calculate OH
&amp; ME per individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Genotypes &lt;- SimGeno(Ped_HSg5, nSnp=100, CallRate = runif(100, 0.5, 0.8),
                     SnpError = 0.05)
SnpStats(Genotypes)   # only plots; data is returned invisibly
SNPstats &lt;- SnpStats(Genotypes, Pedigree=Ped_HSg5)

</code></pre>

<hr>
<h2 id='SpecsToParam'>Specs to PARAM</h2><span id='topic+SpecsToParam'></span>

<h3>Description</h3>

<p>Convert 1-row dataframe <code>Specs</code> into list <code>PARAM</code>,
optionally including various other objects in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpecsToParam(Specs, ErrM = NULL, ErrFlavour = NULL, dimGeno = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpecsToParam_+3A_specs">Specs</code></td>
<td>
<p>1-row dataframe, element of <code><a href="#topic+sequoia">sequoia</a></code> output list.</p>
</td></tr>
<tr><td><code id="SpecsToParam_+3A_...">...</code></td>
<td>
<p>other objects to append to the list, such as <code>ErrM</code> and
<code>quiet</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>

<hr>
<h2 id='SummarySeq'>Summarise Sequoia Output or Pedigree</h2><span id='topic+SummarySeq'></span>

<h3>Description</h3>

<p>Number of assigned parents and grandparents and sibship sizes,
split by genotyped, dummy, and 'observed'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SummarySeq(
  SeqList = NULL,
  Pedigree = NULL,
  DumPrefix = c("F0", "M0"),
  SNPd = NULL,
  Plot = TRUE,
  Panels = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SummarySeq_+3A_seqlist">SeqList</code></td>
<td>
<p>the list returned by <code><a href="#topic+sequoia">sequoia</a></code>. Only elements
'Pedigree' or 'PedigreePar' and 'AgePriors' are used. All ids in
'PedigreePar', and only those, are presumed genotyped.</p>
</td></tr>
<tr><td><code id="SummarySeq_+3A_pedigree">Pedigree</code></td>
<td>
<p>dataframe, pedigree with the first three columns being id -
dam - sire. Column names are ignored, as are additional columns, except for
columns OHdam, OHsire, MEpair, LLRdam, LLRsire, LLRpair (plotting only).</p>
</td></tr>
<tr><td><code id="SummarySeq_+3A_dumprefix">DumPrefix</code></td>
<td>
<p>character vector of length 2 with prefixes for dummy dams
(mothers) and sires (fathers). Will be read from <code>SeqList</code>'s 'Specs'
if provided. Used to distinguish between dummies and non-dummies. Length 3
in case of hermaphrodites.</p>
</td></tr>
<tr><td><code id="SummarySeq_+3A_snpd">SNPd</code></td>
<td>
<p>character vector with ids of SNP genotyped individuals. Only used
when <code>Pedigree</code> is provided instead of <code>SeqList</code>, to distinguish
between genetically assigned parents and 'observed' parents (e.g. observed
in the field, or assigned previously using microsatellites). If <code>NULL</code>
(the default), all parents are presumed observed.</p>
</td></tr>
<tr><td><code id="SummarySeq_+3A_plot">Plot</code></td>
<td>
<p>show barplots and histograms of the results, as well as of the
parental LLRs, Mendelian errors, and agepriors, if present.</p>
</td></tr>
<tr><td><code id="SummarySeq_+3A_panels">Panels</code></td>
<td>
<p>character vector with panel(s) to plot. Choose from 'all',
'G.parents' (parents of genotyped individuals), 'D.parents' (parents of
dummy individuals), 'sibships' (distribution of sibship sizes), 'LLR'
(log10-likelihood ratio parent/otherwise related), 'OH' (count of opposite
homozygote SNPs).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>PedSummary</code></td>
<td>
<p>a 2-column matrix with basic summary statistics, similar
to what used to be returned by <span class="pkg">Pedantics</span>' <code>pedStatSummary</code> (now
archived on CRAN). First column refers to the complete pedigree, second
column to SNP-genotyped individuals only. Maternal siblings sharing a dummy
parent are counted in the 2nd column if both sibs are genotyped, but not if
one of the sibs is a dummy individual.</p>
</td></tr>
<tr><td><code>ParentCount</code></td>
<td>
<p>an array with the number of assigned parents,
split by:
</p>

<ul>
<li><p> offspringCat: Genotyped, Dummy, or Observed* (*: only when
<code>Pedigree</code> is provided rather than <code>SeqList</code>, for ids which
are not listed in <code>SNPd</code> and do not conform to <code>DumPrefix</code> +
number (i.e. (almost) al individuals when <code>SNPd = NULL</code>, the
default).
</p>
</li>
<li><p> offspringSex: Female, Male, Unknown, or Herm* (*: hermaphrodite,
only if any individuals occur as both dam and sire). Based only on
whether an individual occurs as Dam or Sire.
</p>
</li>
<li><p> parentSex: Dam or Sire
</p>
</li>
<li><p> parentCat: Genotyped, Dummy, Observed*, or None (*: as for
offspringCat)
</p>
</li></ul>
</td></tr>
<tr><td><code>GPCount</code></td>
<td>
<p>an array with the number of assigned grandparents,
split by:
</p>

<ul>
<li><p> offspringCat: Genotyped, Dummy, Observed*, or All
</p>
</li>
<li><p> grandparent kind: maternal grandmothers (MGM),
maternal grandfathers (MGF), paternal grandmothers (PGM), paternal
grandfathers (PGF)
</p>
</li>
<li><p> grandparentCat: Genotyped, Dummy, Observed*, or None
</p>
</li></ul>
</td></tr>
<tr><td><code>SibSize</code></td>
<td>
<p>a list with elements 'mat' (maternal half + full siblings),
'pat' (paternal half + full siblings), and 'full' (full siblings). Each
is a matrix with a number of rows equal to the maximum sibship size, and 3
columns, splitting by the type of parent: Genotyped, Dummy, or Observed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+PlotSeqSum">PlotSeqSum</a></code> to plot the output of this function;
<code><a href="#topic+sequoia">sequoia</a></code> for pedigree reconstruction and links to other
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SummarySeq(Ped_griffin)
sumry_grif &lt;- SummarySeq(SeqOUT_griffin, Panels=c("G.parents", "OH"))
sumry_grif$PedSummary

</code></pre>

<hr>
<h2 id='tryCatch.W.E'>tryCatch both warnings (with value) and errors</h2><span id='topic+tryCatch.W.E'></span>

<h3>Description</h3>

<p>Catch *and* save both errors and warnings, and in the case of
a warning, also keep the computed result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryCatch.W.E(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tryCatch.W.E_+3A_expr">expr</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> expression to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 'value' and 'warning', where
'value' may be an error caught.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler;
Copyright (C) 2010-2012  The R Core Team
</p>

<hr>
<h2 id='Vcomp'>Compare two vectors</h2><span id='topic+Vcomp'></span>

<h3>Description</h3>

<p>Compare a vector with inferred sibs to a vector of &lsquo;true&rsquo; sibs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vcomp(Infrd, Simld, SNPd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Vcomp_+3A_infrd">Infrd</code></td>
<td>
<p>vector of inferred sibs</p>
</td></tr>
<tr><td><code id="Vcomp_+3A_simld">Simld</code></td>
<td>
<p>vector of true sibs</p>
</td></tr>
<tr><td><code id="Vcomp_+3A_snpd">SNPd</code></td>
<td>
<p>character vector with IDs of genotyped individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numeric vector of length 4, with the total length of Simld,
the length of the intersect of the two vectors, the number occurring in
Infrd but not Simld ('err'), and the number occuring in Simld but not
Infrd ('missed').
</p>

<hr>
<h2 id='VennSquares'>Square Venn diagram</h2><span id='topic+VennSquares'></span>

<h3>Description</h3>

<p>Draw Venn diagram with squares, with match/mismatch in
overlapping area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VennSquares(count, BL = c(0, 0), COL, withText = TRUE, withLegend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VennSquares_+3A_count">count</code></td>
<td>
<p>a length 5 named vector: 'Total', 'Match', 'Mismatch',
'P1only', and 'P2only'.</p>
</td></tr>
<tr><td><code id="VennSquares_+3A_bl">BL</code></td>
<td>
<p>a length 2 vector with coordinates of bottom-mid of Ped1 square.</p>
</td></tr>
<tr><td><code id="VennSquares_+3A_col">COL</code></td>
<td>
<p>a length 4 character vector with colours, named 'Match',
'Mismatch', 'Ped1', 'Ped2'.</p>
</td></tr>
<tr><td><code id="VennSquares_+3A_withtext">withText</code></td>
<td>
<p>logical, add count to each rectangle.</p>
</td></tr>
<tr><td><code id="VennSquares_+3A_withlegend">withLegend</code></td>
<td>
<p>logical, add legend at the bottom of the plot.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+PlotPedComp">PlotPedComp</a></code>
</p>

<hr>
<h2 id='writeColumns'>Write Data to a File Column-wise</h2><span id='topic+writeColumns'></span>

<h3>Description</h3>

<p>Write data.frame or matrix to a text file, using white
space padding to keep columns aligned as in <code>print</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeColumns(x, file = "", row.names = TRUE, col.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeColumns_+3A_x">x</code></td>
<td>
<p>the object to be written, preferably a matrix or data frame.
If not, it is attempted to coerce x to a matrix.</p>
</td></tr>
<tr><td><code id="writeColumns_+3A_file">file</code></td>
<td>
<p>a character string naming a file.</p>
</td></tr>
<tr><td><code id="writeColumns_+3A_row.names">row.names</code></td>
<td>
<p>a logical value indicating whether the row names of x are
to be written along with x.</p>
</td></tr>
<tr><td><code id="writeColumns_+3A_col.names">col.names</code></td>
<td>
<p>a logical value indicating whether the column names of x
are to be written along with x.</p>
</td></tr>
</table>

<hr>
<h2 id='writeSeq'>Write Sequoia Output to File</h2><span id='topic+writeSeq'></span>

<h3>Description</h3>

<p>The various list elements returned by <code>sequoia</code> are each
written to text files in the specified folder, or to separate sheets in a
single excel file (requires library <span class="pkg">openxlsx</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeSeq(
  SeqList,
  GenoM = NULL,
  MaybeRel = NULL,
  PedComp = NULL,
  OutFormat = "txt",
  folder = "Sequoia-OUT",
  file = "Sequoia-OUT.xlsx",
  ForVersion = 2,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeSeq_+3A_seqlist">SeqList</code></td>
<td>
<p>list returned by <code><a href="#topic+sequoia">sequoia</a></code>, to be written out.</p>
</td></tr>
<tr><td><code id="writeSeq_+3A_genom">GenoM</code></td>
<td>
<p>matrix with genetic data (optional). Ignored if
OutFormat='xls', as the resulting file could become too large for excel.</p>
</td></tr>
<tr><td><code id="writeSeq_+3A_mayberel">MaybeRel</code></td>
<td>
<p>list with results from <code><a href="#topic+GetMaybeRel">GetMaybeRel</a></code> (optional).</p>
</td></tr>
<tr><td><code id="writeSeq_+3A_pedcomp">PedComp</code></td>
<td>
<p>list with results from <code><a href="#topic+PedCompare">PedCompare</a></code> (optional).
<code>SeqList$DummyIDs</code> is combined with <code>PedComp$DummyMatch</code> if both
are provided.</p>
</td></tr>
<tr><td><code id="writeSeq_+3A_outformat">OutFormat</code></td>
<td>
<p>'xls' or 'txt'.</p>
</td></tr>
<tr><td><code id="writeSeq_+3A_folder">folder</code></td>
<td>
<p>the directory where the text files will be written; will be
created if it does not already exists. Relative to the current working
directory, or NULL for current working directory. Ignored if
<code>OutFormat='xls'</code>.</p>
</td></tr>
<tr><td><code id="writeSeq_+3A_file">file</code></td>
<td>
<p>the name of the excel file to write to, ignored if
<code>OutFormat='txt'</code>.</p>
</td></tr>
<tr><td><code id="writeSeq_+3A_forversion">ForVersion</code></td>
<td>
<p>choose '1' for back-compatibility with stand-alone sequoia
versions 1.x</p>
</td></tr>
<tr><td><code id="writeSeq_+3A_quiet">quiet</code></td>
<td>
<p>suppress messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The text files can be used as input for the stand-alone Fortran
version of sequoia, e.g. when the genotype data is too large for R. See
<code>vignette('sequoia')</code> for further details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+writeColumns">writeColumns</a></code> to write to a text file, using white
space padding to keep columns aligned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
writeSeq(SeqList, OutFormat="xls", file="MyFile.xlsx")

# add additional sheet to the excel file:
library(openxlsx)
wb &lt;- loadWorkbook("MyFile.xlsx")
addWorksheet(wb, sheetName = "ExtraData")
writeData(wb, sheet = "ExtraData", MyData, rowNames=FALSE)
saveWorkbook(wb, "MyFile.xlsx", overwrite=TRUE, returnValue=TRUE)

# or: (package requires java &amp; is trickier to install)
xlsx::write.xlsx(MyData, file = "MyFile.xlsx", sheetName="ExtraData",
      col.names=TRUE, row.names=FALSE, append=TRUE, showNA=FALSE)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
