<!DOCTYPE html><html><head><title>Help for package GSNA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GSNA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bai_data'><p>Bai et al. Data Sets.</p></a></li>
<li><a href='#buildGeneSetNetworkGeneric'><p>buildGeneSetNetworkGeneric</p></a></li>
<li><a href='#buildGeneSetNetworkJaccard'><p>buildGeneSetNetworkJaccard</p></a></li>
<li><a href='#buildGeneSetNetworkLF'><p>buildGeneSetNetworkLF, buildGeneSetNetworkLFFast-deprecated</p></a></li>
<li><a href='#buildGeneSetNetworkOC'><p>buildGeneSetNetworkOC</p></a></li>
<li><a href='#buildGeneSetNetworkSTLF'><p>buildGeneSetNetworkSTLF</p></a></li>
<li><a href='#color2IntV'><p>color2IntV</p></a></li>
<li><a href='#combineRGBMatrices'><p>combineRGBMatrices</p></a></li>
<li><a href='#complement'><p>complement</p></a></li>
<li><a href='#contrasting_color'><p>contrasting_color</p></a></li>
<li><a href='#distMat2Rank'><p>distMat2Rank</p></a></li>
<li><a href='#distMat2UnitNormRank'><p>distMat2UnitNormRank negDistMat2UnitNormRank</p></a></li>
<li><a href='#extract_david_GSC'><p>extract_david_GSC</p></a></li>
<li><a href='#gsc2tmod'><p>gsc2tmod</p></a></li>
<li><a href='#gsIntersect'><p>gsIntersect</p></a></li>
<li><a href='#gsIntersectCounts'><p>gsIntersectCounts</p></a></li>
<li><a href='#gsn_default_distance'><p>gsn_default_distance, gsn_distances, pw_id_col, pw_stat_col, pw_sig_order, pw_stat_col_2, pw_sig_order_2, pw_n_col, pw_type</p></a></li>
<li><a href='#gsnAddPathwaysData'><p>gsnAddPathwaysData</p></a></li>
<li><a href='#gsnAssignSubnets'><p>gsnAssignSubnets</p></a></li>
<li><a href='#GSNData'><p>GSNData</p></a></li>
<li><a href='#gsnDendroSubnetColors'><p>gsnDendroSubnetColors, gsnDendroSubnetColors_dark</p></a></li>
<li><a href='#gsnDistanceHistogram'><p>gsnDistanceHistogram</p></a></li>
<li><a href='#gsnFilterGeneSetCollectionList'><p>gsnFilterGeneSetCollectionList</p></a></li>
<li><a href='#gsnHierarchicalDendrogram'><p>gsnHierarchicalDendrogram</p></a></li>
<li><a href='#gsnImportCERNO'><p>gsnImportCERNO</p></a></li>
<li><a href='#gsnImportDAVID'><p>gsnImportDAVID</p></a></li>
<li><a href='#gsnImportGenericPathways'><p>gsnImportGenericPathways</p></a></li>
<li><a href='#gsnImportGSEA'><p>gsnImportGSEA</p></a></li>
<li><a href='#gsnImportGSNORA'><p>gsnImportGSNORA</p></a></li>
<li><a href='#gsnMergePathways'><p>gsnMergePathways</p></a></li>
<li><a href='#gsnORAtest'><p>gsnORAtest</p></a></li>
<li><a href='#gsnORAtest_cpp'><p>gsnORAtest_cpp</p></a></li>
<li><a href='#gsnParedVsRawDistancePlot'><p>gsnParedVsRawDistancePlot</p></a></li>
<li><a href='#gsnPareNetGenericHierarchic'><p>gsnPareNetGenericHierarchic</p></a></li>
<li><a href='#gsnPareNetGenericToNearestNNeighbors'><p>gsnPareNetGenericToNearestNNeighbors</p></a></li>
<li><a href='#gsnPlotNetwork'><p>gsnPlotNetwork</p></a></li>
<li><a href='#gsnSubnetSummary'><p>gsnSubnetSummary</p></a></li>
<li><a href='#gsnSubset'><p>gsnSubset</p></a></li>
<li><a href='#gsnToIgraph'><p>gsnToIgraph</p></a></li>
<li><a href='#intV2Color'><p>intV2Color</p></a></li>
<li><a href='#lfisher_cpp'><p>lfisher_cpp</p></a></li>
<li><a href='#lse'><p>lse</p></a></li>
<li><a href='#makeFilteredGenePresenceAbsenceMatrix'><p>makeFilteredGenePresenceAbsenceMatrix</p></a></li>
<li><a href='#makeLinearNColorGradientFunction'><p>makeLinearNColorGradientFunction</p></a></li>
<li><a href='#makeOneColorEncodeFunction'><p>makeOneColorEncodeFunction</p></a></li>
<li><a href='#makeSymmetricDist'><p>makeSymmetricDist</p></a></li>
<li><a href='#makeTwoColorEncodeFunction'><p>makeTwoColorEncodeFunction</p></a></li>
<li><a href='#negative'><p>negative</p></a></li>
<li><a href='#nzLog10'><p>nzLog10</p></a></li>
<li><a href='#nzLog10.old'><p>nzLog10.old</p></a></li>
<li><a href='#pick_MappedGeneSymbol'><p>pick_MappedGeneSymbol</p></a></li>
<li><a href='#plot.GSNData'><p>plot plot.GSNData</p></a></li>
<li><a href='#print.GSNData'><p>print.GSNData</p></a></li>
<li><a href='#read_david_data_file'><p>read_david_data_file</p></a></li>
<li><a href='#read_gmt'><p>read_gmt</p></a></li>
<li><a href='#scoreJaccardMatrix_C'><p>scoreJaccardMatrix_C</p></a></li>
<li><a href='#scoreLFMatrix_C'><p>scoreLFMatrix_C</p></a></li>
<li><a href='#scoreOCMatrix_C'><p>scoreOCMatrix_C</p></a></li>
<li><a href='#tmod2gsc'><p>tmod2gsc</p></a></li>
<li><a href='#write_gmt'><p>write_gmt</p></a></li>
<li><a href='#yassifyPathways'><p>yassifyPathways</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gene Set Networking Analysis Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Create networks of gene sets, infer clusters of functionally-related gene sets based
  on similarity statistics, and visualize the results. This package simplifies and accelerates
  interpretation of pathways analysis data sets. It is designed to work in tandem with standard
  pathways analysis methods, such as the 'GSEA' program (Gene Set Enrichment Analysis), CERNO
  (Coincident Extreme Ranks in Numerical Observations, implemented in the 'tmod' package) and others.
  Inputs to 'GSNA' are the outputs of pathways analysis methods: a list of gene sets (or "modules"),
  pathways or GO-terms with associated p-values. Since pathways analysis methods may be used to
  analyze many different types of data including transcriptomic, epigenetic, and high-throughput
  screen data sets, the 'GSNA' pipeline is applicable to these data as well. The use of 'GSNA' has
  been described in the following papers: 
  Collins DR, Urbach JM, Racenet ZJ, Arshad U, Power KA, Newman RM, et al. (2021) &lt;<a href="https://doi.org/10.1016%2Fj.immuni.2021.08.007">doi:10.1016/j.immuni.2021.08.007</a>&gt;,
  Collins DR, Hitschfel J, Urbach JM, Mylvaganam GH, Ly NL, Arshad U, et al. (2023) &lt;<a href="https://doi.org/10.1126%2Fsciimmunol.ade5872">doi:10.1126/sciimmunol.ade5872</a>&gt;.</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>circlize, DT, dendextend, dplyr, ggplot2, graphics, grDevices,
igraph, Matrix, methods, psych, raster, stringr, stringi,
stats, tibble, tidyr, tmod, utils, withr, Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gplots, GEOquery, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-18 20:52:54 UTC; jonathan</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan M Urbach <a href="https://orcid.org/0000-0003-0597-2848"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan M Urbach &lt;jurbach@mgh.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-18 22:50:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bai_data'>Bai et al. Data Sets.</h2><span id='topic+Bai_data'></span><span id='topic+Bai_CiHep_DN.cerno'></span><span id='topic+Bai_CiKrt_DN.cerno'></span><span id='topic+Bai_CiHep_dorothea_UP.Gsea'></span><span id='topic+Bai_CiHep_dorothea_DN.Gsea'></span><span id='topic+Bai_CiHep_v_Fib2.de'></span><span id='topic+Bai_CiKrt_v_Fib2.de'></span><span id='topic+Bai_empty_expr_mat'></span><span id='topic+Bai_gsc.tmod'></span>

<h3>Description</h3>

<p>These data are derived from the work of Bai and coworkers(1), who treated mouse fibroblasts with a chemical cocktail
to induce differentiation into hepatocyte-like cells. The authors performed single-cell RNA-seq on the treated cells and, on the basis
of marker gene expression, identified numerous clusters including fibroblasts, hepatocyte-like cells (CiHep), keratinocyte-like cells
(CiKrt) and several other fibroblast-derived cell types.
</p>
<p>Recapitulating the computational approach of the original authors, the SRA data set <a href="https://www.ncbi.nlm.nih.gov/sra/?term=GSM6435750">GSM6435750</a>
containing a sparse matrix of counts was downloaded. Using the <code>Seurat</code> package(2), the data were normalized and clusters were
identified using <code>Seurat</code>'s <code>FindCluster()</code> function and visualized using its <code>RunUMAP()</code> and <code>RunPCA()</code> functions.
On the basis of marker genes and comparison with the originally assigned clusters described in the original publication(1). Differential
expression was performed comparing gene expression in CiHep cells with Fibroblast 2 cells, as well as CiKrt cells with Fibroblast 2 cells.
In this way, the <code>Bai_CiHep_v_Fib2.de</code> and <code>Bai_CiKrt_v_Fib2.de</code> data sets respectively were generated.
</p>
<p>Using query gene lists of differentially expressed genes from CiHep vs. Fibroblast 2 and CiKrt vs. Fibroblast 2 comparisons
ordered by descending <code class="reqn">\pi</code>-value(3) and the <code>tmod</code> package's <code>tmodCERNOtest()</code> function, CERNO(4) was performed
against the  with the <strong>C3</strong> (regulatory gene sets) subset of MSigDB v7.5.1(5) as the gene set collection. In this way, the
<code>Bai_CiHep_DN.cerno</code> and <code>Bai_CiKrt_DN.cerno</code> data sets, were generated representing pathways downregulated in CiHep
cells vs Fibroblast 2 cells and in CiKrt cells vs Fibroblast 2 cells, respectively.
</p>
<p>A gene set collection (GSC) derived from <code>dorothea</code> package(6) version 1.8.0. To generate this GSC, transcription factor to
target associations were extracted from the <code>dorothea::dorothea_hs</code> table with confidence ratings of A, B, or C, and 1 (UP
or positively regulated) or -1 (negatively regulated) associations. Gene sets were generated for transcription factors consisting
of positively (UP) or negatively (DN) associated target genes. Using the Bai count matrix including putative CiHep, and Fibroblast 2
cells as assigned above, GSEA was performed against this dorothea-derived GSC, generating the <code>Bai_CiHep_dorothea_UP.Gsea</code>
and <code>Bai_CiHep_dorothea_DN.Gsea</code> data sets including gene sets that were positively and negatively regulated respectively in
response to chemical induction. The empty expression matrix (<code>Bai_empty_expr_mat</code>) containing only gene symbols in rows but
no columns containing counts was generated from the Bai count matrix.
</p>
<p>The <code>Bai_gsc.tmod</code> object was generated by extracting gene sets from the MSigDB C3 subset with <code>adj.P.Val &lt;= 0.05</code> in
<code>Bai_CiHep_DN.cerno</code> and <code>Bai_CiKrt_DN.cerno</code> data sets, and from the dorothea-derived gene set collection in the
<code>Bai_CiHep_dorothea_UP.Gsea</code> and <code>Bai_CiHep_dorothea_DN.Gsea</code> data sets with <code>`FDR q-val` &lt;= 0.05</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bai_CiHep_DN.cerno

Bai_CiKrt_DN.cerno

Bai_CiHep_dorothea_UP.Gsea

Bai_CiHep_dorothea_DN.Gsea

Bai_CiHep_v_Fib2.de

Bai_CiKrt_v_Fib2.de

Bai_empty_expr_mat

Bai_gsc.tmod
</code></pre>


<h3>Format</h3>

<p><strong>Bai_CiHep_DN.cerno:</strong> An object of class <code>data.frame</code> with 2895 rows and 8 columns.
</p>

<ul>
<li> <p><strong>ID</strong> Gene set ID.
</p>
</li>
<li> <p><strong>Title</strong> Human-interpretable gene set title.
</p>
</li>
<li> <p><strong>cerno</strong> CERNO statistic used in calculating significance.
</p>
</li>
<li> <p><strong>N1</strong> The number of observable genes in the expression dataset that are also in a given gene set.
</p>
</li>
<li> <p><strong>AUC</strong> AUC value for that gene set.
</p>
</li>
<li> <p><strong>cES</strong> CERNO enrichment score.
</p>
</li>
<li> <p><strong>P.Value</strong> <em>P</em>-value calculated from the cerno statistic using the Fisher method.
</p>
</li>
<li> <p><strong>adj.P.Val</strong> FDR-adjusted.
</p>
</li></ul>

<p><strong>Bai_CiKrt_DN.cerno:</strong> An object of class <code>data.frame</code> with 2895 rows and 8 columns.
Same data format as <code>Bai_CiHep_DN.cerno</code>, above.
</p>
<p><strong>Bai_CiHep_dorothea_UP.Gsea:</strong> An object of class <code>data.frame</code> with 84 rows and 12 columns.
</p>

<ul>
<li> <p><strong>NAME</strong> Gene set name/ID.
</p>
</li>
<li> <p><strong>GS<br> follow link to MSigDB</strong> Same as NAME.
</p>
</li>
<li> <p><strong>GS DETAILS</strong> (Column used only in the HTML version of the data set.)
</p>
</li>
<li> <p><strong>SIZE</strong> The number of genes in the gene set observed in the input data set.
</p>
</li>
<li> <p><strong>ES</strong> GSEA enrichment score.
</p>
</li>
<li> <p><strong>NES</strong> GSEA normalized enrichment score.
</p>
</li>
<li> <p><strong>NOM p-val</strong> GSEA nominal <em>p</em>-value calculated via a permutation test.
</p>
</li>
<li> <p><strong>FDR q-val</strong> GSEA FDR-adjusted <em>q</em>-value.
</p>
</li>
<li> <p><strong>FWER p-val</strong> GSEA FWER-adjusted <em>q</em>-value.
</p>
</li>
<li> <p><strong>RANK AT MAX</strong> Position in the ranked list where maximum enrichment score is found.
</p>
</li>
<li> <p><strong>LEADING EDGE</strong> Three statistics defining &quot;leading edge&quot; subset.
</p>
</li>
<li> <p><strong>&quot;&quot;</strong> Blank column.
</p>
</li></ul>

<p><strong>Bai_CiHep_dorothea_DN.Gsea:</strong> An object of class <code>data.frame</code> with 180 rows and 12 columns.
Same data format as <code>Bai_CiHep_dorothea_UP.Gsea</code>.
</p>
<p><strong>Bai_CiHep_v_Fib2.de:</strong> An object of class <code>data.frame</code> with 8769 rows and 5 columns.
</p>

<ul>
<li> <p><strong>(row names)</strong> Gene name.
</p>
</li>
<li> <p><strong>p_val</strong> The calculated <em>p</em>-value for differential expression in Seurat.
</p>
</li>
<li> <p><strong>avg_log2FC</strong> Average log fold change of gene expression.
</p>
</li>
<li> <p><strong>pct.1</strong> The percentage of cells where the feature is detected in the first group.
</p>
</li>
<li> <p><strong>pct.2</strong> The percentage of cells where the feature is detected in the second group.
</p>
</li>
<li> <p><strong>p_val_adj</strong> Adjusted <em>p</em>-value.
</p>
</li></ul>

<p><strong>Bai_CiKrt_v_Fib2.de:</strong> An object of class <code>data.frame</code> with 8166 rows and 5 columns.
Same data format as <code>Bai_CiHep_v_Fib2.de</code>.
</p>
<p><strong>Bai_empty_expr_mat:</strong> An object of class <code>matrix</code> (inherits from <code>array</code>) with 20035 rows and 0 columns.
</p>

<ul>
<li> <p><strong>(row name)</strong> The gene names in the expression data set.
</p>
</li></ul>

<p><strong>Bai_gsc.tmod:</strong> A tmod class object containing 94 gene sets.
</p>


<h3>Licensing</h3>


<ul>
<li><p> Gene sets included herein derived from the the C3 subset of GSEA are protected by copyright (c) 2004-2023 Broad Institute, Inc.,
Massachusetts Institute of Technology, and Regents of the University of California, and are included here under the terms and
conditions of the Creative Commons Attribution 4.0 International License.
</p>
</li>
<li><p> Gene sets included herein derived from the <code>dorothea</code> package are included herein under the terms and conditions of the
GPL 3+ license.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jonathan M. Urbach
</p>


<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE210710">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE210710</a>
</p>


<h3>References</h3>


<ol>
<li><p>Bai Y, Yang Z, Xu X, Ding W, Qi J, Liu F, et al. Direct chemical induction of hepatocyte‐like cells
with capacity for liver repopulation. <em>Hepatology</em>. 2023;<strong>77</strong>: 1550–1565. doi:10.1002/hep.32686
</p>
</li>
<li><p>Butler A, Hoffman P, Smibert P, Papalexi E, Satija R. Integrating single-cell transcriptomic
data across different conditions, technologies, and species. <em>Nat Biotechnol</em>. 2018;<strong>36</strong>: 411–420. doi:10.1038/nbt.4096
</p>
</li>
<li><p>Xiao Y, Hsiao T-H, Suresh U, Chen H-IH, Wu X, Wolf SE, et al. A novel significance score for gene
selection and ranking. <em>Bioinformatics</em>. 2014;<strong>30</strong>: 801–807. doi:10.1093/bioinformatics/btr671
</p>
</li>
<li><p>Zyla J, Marczyk M, Domaszewska T, Kaufmann SHE, Polanska J, Weiner J. Gene set enrichment for
reproducible science: comparison of CERNO and eight other algorithms. <em>Bioinformatics</em>. 2019;<strong>35</strong>:
5146–5154. doi:10.1093/bioinformatics/btz447
</p>
</li>
<li><p>Subramanian A, Tamayo P, Mootha VK, Mukherjee S, Ebert BL, Gillette MA, et al. Gene set enrichment
analysis: A knowledge-based approach for interpreting genome-wide expression profiles.
<em>Proc Natl Acad Sci U S A.</em> 2005;<strong>102</strong>: 15545–15550. doi:10.1073/pnas.0506580102
</p>
</li>
<li><p>Garcia-Alonso L, Holland CH, Ibrahim MM, Turei D, Saez-Rodriguez J. Benchmark and integration of
resources for the estimation of human transcription factor activities. <em>Genome Res.</em> 2019;<strong>29</strong>:
1363–1375. doi:10.1101/gr.240663.118
</p>
</li></ol>


<hr>
<h2 id='buildGeneSetNetworkGeneric'>buildGeneSetNetworkGeneric</h2><span id='topic+buildGeneSetNetworkGeneric'></span>

<h3>Description</h3>

<p>General function to create a <code>GSNData</code> object and calculate a distance matrix within.
Employed by <code>buildGeneSetNetworkSTLF()</code>, <code>buildGeneSetNetworkLF()</code>, <code>buildGeneSetNetworkJaccard()</code>
and <code>buildGeneSetNetworkJaccard()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildGeneSetNetworkGeneric(
  object = NULL,
  ref.background = NULL,
  geneSetCollection = NULL,
  distMatrixFun,
  distance,
  optimal_extreme
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildGeneSetNetworkGeneric_+3A_object">object</code></td>
<td>
<p>An object of type GSNData. If NULL, a new one is instantiated.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkGeneric_+3A_ref.background">ref.background</code></td>
<td>
<p>(required) A character vector corresponding to the genes observable in a differential
expression, ATAC-Seq or other dataset. This corresponds to the background used in tools like DAVID.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkGeneric_+3A_genesetcollection">geneSetCollection</code></td>
<td>
<p>(required) A gene set collection either in the form of a tmod object, or a list of
gene sets / modules as character vectors containing gene symbols and names corresponding to the
gene module identifier.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkGeneric_+3A_distmatrixfun">distMatrixFun</code></td>
<td>
<p>(required) Function for calculating the distance matrix. Functions used for this purpose
are expected to return a square numeric matrix corresponding to the distances between all gene sets. (see
<code><a href="#topic+scoreLFMatrix_C">scoreLFMatrix_C</a></code>,  <code><a href="#topic+scoreJaccardMatrix_C">scoreJaccardMatrix_C</a></code>, <code><a href="#topic+scoreOCMatrix_C">scoreOCMatrix_C</a></code> )</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkGeneric_+3A_distance">distance</code></td>
<td>
<p>(required) Name of the distance matrix being calculated.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkGeneric_+3A_optimal_extreme">optimal_extreme</code></td>
<td>
<p>(required) Indicates whether max or min values are most significant in the specified distance
matrix. Can be <code>'max'</code> or <code>'min'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases, users will want to run the specific
<code>buildGeneSetNetworkSTLF()</code>,
<code>buildGeneSetNetworkLF()</code>,
<code>buildGeneSetNetworkJaccard()</code>
or <code>buildGeneSetNetworkJaccard()</code> functions instead of this, but this function can be used for
adding support for new distance metrics.
</p>


<h3>Value</h3>

<p>This function returns a GSNData object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildGeneSetNetworkJaccard">buildGeneSetNetworkJaccard</a></code>
</p>
<p><code><a href="#topic+buildGeneSetNetworkOC">buildGeneSetNetworkOC</a></code>
</p>
<p><code><a href="#topic+buildGeneSetNetworkLF">buildGeneSetNetworkLF</a></code>
</p>
<p><code><a href="#topic+buildGeneSetNetworkSTLF">buildGeneSetNetworkSTLF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network. This does the same thing as
# buildGeneSetNetworkSTLF(), but can be adapted to novel distance
# metrics by providing a different matrix scoring function, distance
# name, and optimal_extreme:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkGeneric( geneSetCollection = sig_pathways.tmod,
                               ref.background = background_genes,
                               distMatrixFun = scoreLFMatrix_C,
                               distance = 'stlf',
                               optimal_extreme = "min"
                                )

</code></pre>

<hr>
<h2 id='buildGeneSetNetworkJaccard'>buildGeneSetNetworkJaccard</h2><span id='topic+buildGeneSetNetworkJaccard'></span>

<h3>Description</h3>

<p>Using a gene set collection and a background of observable genes, calculate a matrix of Jaccard
similarity indices and return a GSNData object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildGeneSetNetworkJaccard(
  object = NULL,
  ref.background = NULL,
  geneSetCollection = NULL,
  distMatrixFun = scoreJaccardMatrix_C
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildGeneSetNetworkJaccard_+3A_object">object</code></td>
<td>
<p>An object of type GSNData. If NULL, a new one is instantiated.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkJaccard_+3A_ref.background">ref.background</code></td>
<td>
<p>(required) A character vector corresponding to the genes observable in a differential
expression, ATAC-Seq or other dataset. This corresponds to the background used in tools like DAVID.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkJaccard_+3A_genesetcollection">geneSetCollection</code></td>
<td>
<p>(required) A gene set collection either in the form of a tmod object, or a list of
gene sets / modules as character vectors containing gene symbols and names corresponding to the
gene module identifier.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkJaccard_+3A_distmatrixfun">distMatrixFun</code></td>
<td>
<p>(optional) Function for calculating the distance matrix. Defaults to
<code>scoreJaccardMatrix_C</code>. Functions used for this purpose are expected to return a square
numeric matrix corresponding to the distances between all gene sets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps the process of creating a GSNData object and calculating a Jaccard similarity
matrix. The Jaccard index matrix is calculated using <code>scoreJaccardMatrix()</code>, which is implemented in C++.
</p>
<p><strong>Note:</strong> Because with Jaccard similarity indices, higher values indicate a closer match between sets, they
are unlike standard metrics of distance. Therefore the optimal_extreme is <code>"max"</code>, and for certain
operations, such as construction of a hierarchical tree, they may require transformation for use in clustering.
</p>


<h3>Value</h3>

<p>This function returns a GSNData object with the <code>$default_distance</code> field set as
<code>'jaccard'</code> and <code>$distances$lf$optimal_extreme</code> set to <code>'max'</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scoreJaccardMatrix_C">scoreJaccardMatrix_C</a></code>
<code><a href="#topic+buildGeneSetNetworkLFFast">buildGeneSetNetworkLFFast</a></code>
<code><a href="#topic+buildGeneSetNetworkSTLF">buildGeneSetNetworkSTLF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)
library(tmod)

# With tmod version &gt;= 0.50.11, convert exported Bai_gsc.tmod **tmod** object to **tmodGS**:
if( utils::packageVersion( 'tmod' ) &gt;= '0.50.11' )
  Bai_gsc.tmod &lt;- tmod::tmod2tmodGS( GSNA::Bai_gsc.tmod )

# Get list of observable genes from expression data:
observable_genes &lt;- toupper( rownames( Bai_empty_expr_mat ) )

# Subset GSEA data for significant results.
significant.Gsea &lt;- subset( Bai_CiHep_dorothea_DN.Gsea, `FDR q-val` &lt;= 0.05 )

# Subset tmod object for
gsc_subset.tmod &lt;- Bai_gsc.tmod[ significant.Gsea$NAME ]

# Now, create a GSN object with Jaccard indices:
GSN &lt;- buildGeneSetNetworkJaccard( ref.background = observable_genes,
                                   geneSetCollection = gsc_subset.tmod )

</code></pre>

<hr>
<h2 id='buildGeneSetNetworkLF'>buildGeneSetNetworkLF, buildGeneSetNetworkLFFast-deprecated</h2><span id='topic+buildGeneSetNetworkLF'></span><span id='topic+buildGeneSetNetworkLFFast'></span>

<h3>Description</h3>

<p>Using a gene set collection and a background of observable genes, calculate log partial
Fisher <em>p</em>-value distances and return the results as a GSNData object. For a 2x2 contingency matrix
of the form:
</p>
<p style="text-align: center;"><code class="reqn">\biggl[\begin{matrix}a &amp; b \\ c &amp; d\end{matrix}\biggr]</code>
</p>

<p>the log Fisher <em>p</em>-value is equal to:
</p>
<p style="text-align: center;"><code class="reqn">log(P) = log\biggl(\dfrac{(a+b)!(c+d)!(a+c)!(b+d)!}{a!b!c!d!(a+b+c+d)!}\biggr)</code>
</p>

<p>This differs from the <code>buildGeneSetNetworkSTLF</code> in that only the one value of P is summed, whereas in
<code>buildGeneSetNetworkSTLF</code>, all more extreme values are summed (prior to log-transformation), generating an
actual single-sided <em>p</em>-value.
</p>
<p>This statistic behaves approximately like a 2-sided Fisher exact test, but may not be appropriate for
most purposes. It is also somewhat faster to calculate than STLF (single tailed log-Fisher). Unless speed is an issue,
we recommend using <code>buildGeneSetNetworkSTLF</code> Note: <code>buildGeneSetNetworkLFFast</code> is deprecated. Please use
<code>buildGeneSetNetworkLF</code>() instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildGeneSetNetworkLF(
  object = NULL,
  ref.background = NULL,
  geneSetCollection = NULL,
  distMatrixFun = function(geneSetCollection) scoreLFMatrix_C(geneSetCollection,
    alternative = 4)
)

buildGeneSetNetworkLFFast(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildGeneSetNetworkLF_+3A_object">object</code></td>
<td>
<p>An object of type GSNData. If NULL, a new one is instantiated.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkLF_+3A_ref.background">ref.background</code></td>
<td>
<p>(required) A character vector corresponding to the genes observable in a
differential expression, ATAC-Seq or other dataset. This corresponds to the background used in
tools like DAVID. This is <strong>required</strong>, unless object already exists and contains a
genePresenceAbsence matrix field.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkLF_+3A_genesetcollection">geneSetCollection</code></td>
<td>
<p>(required) A gene set collection either in the form of a tmod object,
or a list of gene sets / modules as character vectors containing gene symbols and names
corresponding to the gene module identifier. This is <strong>required</strong>, unless object already exists
and contains a genePresenceAbsence matrix field.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkLF_+3A_distmatrixfun">distMatrixFun</code></td>
<td>
<p>Function used to calculate distances. Takes a genePresenceAbsence matrix and
returns a distance matrix. (defaults to scoreLFMatrix_C)</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkLF_+3A_...">...</code></td>
<td>
<p>: Arguments passed to <code><a href="#topic+buildGeneSetNetworkLF">buildGeneSetNetworkLF</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps the process of creating a GSNData object and calculating a log Fisher
<em>p</em>-value distance matrix. The distance matrix is calculated using <code>scoreLFMatrix_C()</code>.
</p>


<h3>Value</h3>

<p>This function returns a GSNData object with the <code>$default_distance</code> field set as
<code>'lf'</code> and <code>$distances$lf$optimal_extreme</code> set to <code>'min'</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>buildGeneSetNetworkLFFast()</code>: Deprecated, use <code><a href="#topic+buildGeneSetNetworkLF">buildGeneSetNetworkLF</a>()</code>.
</p>
</li></ul>


<h3><code>buildGeneSetNetworkLFFast</code></h3>

<p>For <code>buildGeneSetNetworkLFFast()</code>, use <code><a href="#topic+buildGeneSetNetworkLF">buildGeneSetNetworkLF</a>()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scoreLFMatrix_C">scoreLFMatrix_C</a></code>
<code><a href="#topic+scoreJaccardMatrix_C">scoreJaccardMatrix_C</a></code>
<code><a href="#topic+scoreOCMatrix_C">scoreOCMatrix_C</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)
library(tmod)

# With tmod version &gt;= 0.50.11, convert exported Bai_gsc.tmod **tmod** object to **tmodGS**:
if( utils::packageVersion( 'tmod' ) &gt;= '0.50.11' )
  Bai_gsc.tmod &lt;- tmod::tmod2tmodGS( GSNA::Bai_gsc.tmod )

# Get list of observable genes from expression data:
observable_genes &lt;- toupper( rownames( Bai_empty_expr_mat ) )

# Subset GSEA data for significant results.
significant.Gsea &lt;- subset( Bai_CiHep_dorothea_DN.Gsea, `FDR q-val` &lt;= 0.05 )

# Subset tmod object for
gsc_subset.tmod &lt;- Bai_gsc.tmod[ significant.Gsea$NAME ]

# Now, create a GSN object with partial log Fisher values:
GSN &lt;- buildGeneSetNetworkLF( ref.background = observable_genes,
                              geneSetCollection = gsc_subset.tmod )


</code></pre>

<hr>
<h2 id='buildGeneSetNetworkOC'>buildGeneSetNetworkOC</h2><span id='topic+buildGeneSetNetworkOC'></span>

<h3>Description</h3>

<p>Using a gene set collection and a background of observable genes, calculate a matrix of
Szymkiewicz–Simpson overlap coefficients and return a GSNData object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildGeneSetNetworkOC(
  object = NULL,
  ref.background = NULL,
  geneSetCollection = NULL,
  distMatrixFun = scoreOCMatrix_C
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildGeneSetNetworkOC_+3A_object">object</code></td>
<td>
<p>An object of type GSNData. If NULL, a new one is instantiated.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkOC_+3A_ref.background">ref.background</code></td>
<td>
<p>(required) A character vector corresponding to the genes observable in a differential
expression, ATAC-Seq or other dataset. This corresponds to the background used in tools like DAVID.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkOC_+3A_genesetcollection">geneSetCollection</code></td>
<td>
<p>(required) A gene set collection either in the form of a tmod object, or a list of
gene sets / modules as character vectors containing gene symbols and names corresponding to the
gene module identifier.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkOC_+3A_distmatrixfun">distMatrixFun</code></td>
<td>
<p>(optional) Function for calculating the distance matrix. Defaults to
<code>scoreOCMatrix_C</code>. Functions used for this purpose are expected to return a square
numeric matrix corresponding to the distances between all gene sets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps the process of creating a GSNData object and calculating a Szymkiewicz–Simpson overlap
coefficient matrix. The Szymkiewicz–Simpson overlap coefficient matrix is calculated using <code>scoreOCMatrix()</code>,
which is implemented in C++.
</p>
<p><strong>Note:</strong> Because with Szymkiewicz–Simpson overlap coefficients, higher values indicate a closer match between sets,
they are unlike standard metrics of distance. Therefore the optimal_extreme is <code>"max"</code>, and for certain
operations, such as construction of a hierarchical tree, they may require transformation for use in clustering.
Secondly, since the Szymkiewicz–Simpson method often produces a large number of tie values in a distance matrix,
we recommend paring using hierarchical clustering (with <code><a href="#topic+gsnPareNetGenericHierarchic">gsnPareNetGenericHierarchic</a></code>) instead of
nearest neighbor clustering.
</p>


<h3>Value</h3>

<p>This function returns a GSNData object with the <code>$default_distance</code> field set as
<code>'oc'</code> and <code>$distances$lf$optimal_extreme</code> set to <code>'max'</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scoreOCMatrix_C">scoreOCMatrix_C</a></code>
<code><a href="#topic+buildGeneSetNetworkJaccard">buildGeneSetNetworkJaccard</a></code>
<code><a href="#topic+buildGeneSetNetworkLFFast">buildGeneSetNetworkLFFast</a></code>
<code><a href="#topic+buildGeneSetNetworkSTLF">buildGeneSetNetworkSTLF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)
library(tmod)

# With tmod version &gt;= 0.50.11, convert exported Bai_gsc.tmod **tmod** object to **tmodGS**:
if( utils::packageVersion( 'tmod' ) &gt;= '0.50.11' )
  Bai_gsc.tmod &lt;- tmod::tmod2tmodGS( GSNA::Bai_gsc.tmod )

# Get list of observable genes from expression data:
observable_genes &lt;- toupper( rownames( Bai_empty_expr_mat ) )

# Subset GSEA data for significant results.
significant.Gsea &lt;- subset( Bai_CiHep_dorothea_DN.Gsea, `FDR q-val` &lt;= 0.05 )

# Subset tmod object for
gsc_subset.tmod &lt;- Bai_gsc.tmod[ significant.Gsea$NAME ]

# Now, create a GSN object with overlap coefficients:
GSN &lt;- buildGeneSetNetworkOC( ref.background = observable_genes,
                              geneSetCollection = gsc_subset.tmod )

</code></pre>

<hr>
<h2 id='buildGeneSetNetworkSTLF'>buildGeneSetNetworkSTLF</h2><span id='topic+buildGeneSetNetworkSTLF'></span>

<h3>Description</h3>

<p>Using a gene set collection and a background of observable genes, calculate single-tailed
log Fisher <em>p</em>-value distances and return the results as a GSNData object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildGeneSetNetworkSTLF(
  object = NULL,
  ref.background = NULL,
  geneSetCollection = NULL,
  distMatrixFun = scoreLFMatrix_C
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildGeneSetNetworkSTLF_+3A_object">object</code></td>
<td>
<p>An object of type GSNData. If NULL, a new one is instantiated.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkSTLF_+3A_ref.background">ref.background</code></td>
<td>
<p>A character vector corresponding to the genes observable in a differential
expression, ATAC-Seq or other dataset. This corresponds to the background used in tools like DAVID.
This is <strong>required</strong>, unless object already exists and contains a genePresenceAbsence matrix field.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkSTLF_+3A_genesetcollection">geneSetCollection</code></td>
<td>
<p>(required) A gene set collection either in the form of a tmod object, or a list of
gene sets / modules as character vectors containing gene symbols and names corresponding to the
gene module identifier.
This is <strong>required</strong>, unless object already exists and contains a genePresenceAbsence matrix field.</p>
</td></tr>
<tr><td><code id="buildGeneSetNetworkSTLF_+3A_distmatrixfun">distMatrixFun</code></td>
<td>
<p>Function used to calculate distances. Takes a genePresenceAbsence matrix and
returns a distance matrix. (defaults to scoreLFMatrix_C )</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps the process of creating a GSNData object and calculating a log Fisher
<em>p</em>-value distance matrix. The distance matrix is calculated using <code>scoreLFMatrix_C ()</code>, which
is currently implemented in R and about eight- to tenfold slower than <code>buildGeneSetNetworkLFFast()</code>.
</p>


<h3>Value</h3>

<p>This function returns a GSNData object with the <code>$default_distance</code> field set as
<code>'stlf'</code> and <code>$distances$lf$optimal_extreme</code> set to <code>'min'</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scoreLFMatrix_C">scoreLFMatrix_C</a></code>
<code><a href="#topic+buildGeneSetNetworkLFFast">buildGeneSetNetworkLFFast</a></code>,
<code><a href="#topic+buildGeneSetNetworkJaccard">buildGeneSetNetworkJaccard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)
library(tmod)

# With tmod version &gt;= 0.50.11, convert exported Bai_gsc.tmod **tmod** object to **tmodGS**:
if( utils::packageVersion( 'tmod' ) &gt;= '0.50.11' )
  Bai_gsc.tmod &lt;- tmod::tmod2tmodGS( GSNA::Bai_gsc.tmod )

# Get list of observable genes from expression data:
observable_genes &lt;- toupper( rownames( Bai_empty_expr_mat ) )

# Subset GSEA data for significant results.
significant.Gsea &lt;- subset( Bai_CiHep_dorothea_DN.Gsea, `FDR q-val` &lt;= 0.05 )

# Subset tmod object for
gsc_subset.tmod &lt;- Bai_gsc.tmod[ significant.Gsea$NAME ]

# Now, create a GSN object with single tail log Fisher values:
GSN &lt;- buildGeneSetNetworkSTLF( ref.background = observable_genes,
                                geneSetCollection = gsc_subset.tmod )

</code></pre>

<hr>
<h2 id='color2IntV'>color2IntV</h2><span id='topic+color2IntV'></span>

<h3>Description</h3>

<p>Convert a color, either as a name or as a RGB hexadecimal value to an integer vector containing
the RGB specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color2IntV(color)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color2IntV_+3A_color">color</code></td>
<td>
<p>A color specified either by name (e.g. &quot;red&quot;) or as a RGB hexadecimal value (e.g. &quot;#FF0000&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A integer vector containing the RGB specification.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intV2Color">intV2Color()</a></code>
</p>

<hr>
<h2 id='combineRGBMatrices'>combineRGBMatrices</h2><span id='topic+combineRGBMatrices'></span>

<h3>Description</h3>

<p>Given 2 different matrices of colors, combine the colors numerically. This is used in <code>makeTwoColorEncodeFunction()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineRGBMatrices(
  c1.mat,
  c2.mat,
  combine_method = "scaled_geomean",
  max_per_channel = 255
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineRGBMatrices_+3A_c1.mat">c1.mat</code></td>
<td>
<p>A numeric matrix with three columns corresponding to red, green, blue, with numerical
values ranging from 0 to 255 to be combined numerically with <code>c2.mat</code>.</p>
</td></tr>
<tr><td><code id="combineRGBMatrices_+3A_c2.mat">c2.mat</code></td>
<td>
<p>A numeric matrix with three columns corresponding to red, green, blue, with numerical
values ranging from 0 to 255 to be combined numerically with <code>c1.mat</code>.</p>
</td></tr>
<tr><td><code id="combineRGBMatrices_+3A_combine_method">combine_method</code></td>
<td>
<p>Method of combining colors, can be <code>'scaled_geomean'</code>,
<code>'standard'</code>/<code>'euclidean'</code>, <code>'negative_euclidean'</code>, <code>'mean'</code>, <code>'scaled_geomean'</code>
(default = <code>'scaled_geomean'</code>)</p>
</td></tr>
<tr><td><code id="combineRGBMatrices_+3A_max_per_channel">max_per_channel</code></td>
<td>
<p>Maximal color value per RGB channel (default 255).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-column RGB matrix of combined colors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeTwoColorEncodeFunction">makeTwoColorEncodeFunction()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1.mat &lt;- matrix( c(255, 100, 0 ), ncol = 3 )
c2.mat &lt;- matrix( c( 0, 50, 255 ), ncol = 3 )
c12.mat &lt;- combineRGBMatrices( c1.mat, c2.mat, "euclidean" )

</code></pre>

<hr>
<h2 id='complement'>complement</h2><span id='topic+complement'></span>

<h3>Description</h3>

<p>This function returns the complement of a numeric or integer vector or matrix. This may be suitable as the
<code>matrix_scaling_fun()</code> argument for <code>gsnPareNetGenericHierarchic()</code> when being used with such distance metrics
as the Jaccard Index or Szymkiewicz–Simpson Overlap Coefficients to transform them into something more approximating a
distance in behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complement(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complement_+3A_x">x</code></td>
<td>
<p>A numeric vector or matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function also sets matrix or vector attributes appropriately for negation of the input.
</p>


<h3>Value</h3>

<p>The complement of the x argument, equal to <code class="reqn">1 - x</code>.
</p>

<hr>
<h2 id='contrasting_color'>contrasting_color</h2><span id='topic+contrasting_color'></span>

<h3>Description</h3>

<p>Function picks colors to contrast with the colors given as the <code>'col'</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contrasting_color(
  col,
  type = "complement",
  threshold = 127,
  low = "#000000",
  high = "#FFFFFF"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contrasting_color_+3A_col">col</code></td>
<td>
<p>A character vector of colors.</p>
</td></tr>
<tr><td><code id="contrasting_color_+3A_type">type</code></td>
<td>
<p>(optional) Type of contrasting color, i.e. the method of generating the contrasting color.
Valid values are <code>'complement'</code>, <code>'rotate'</code>, <code>'yellow'</code>, <code>'gray'</code>, <code>'binary'</code>
and <code>'blackyellow'</code>.</p>
</td></tr>
<tr><td><code id="contrasting_color_+3A_threshold">threshold</code></td>
<td>
<p>(optional, used only for <code>type='binary'</code>) The &quot;binary&quot; method works by assessing
the mean value of the RGB channels. If the value is above a threshold, the low color is returned, if it
is below the threshold, the high color is returned.</p>
</td></tr>
<tr><td><code id="contrasting_color_+3A_low">low</code></td>
<td>
<p>(optional, used only for <code>type='binary'</code>) Low color (see <code>threshold</code> argument).</p>
</td></tr>
<tr><td><code id="contrasting_color_+3A_high">high</code></td>
<td>
<p>(optional, used only for <code>type='binary'</code>) High color (see <code>threshold</code> argument).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrasting color.
</p>

<hr>
<h2 id='distMat2Rank'>distMat2Rank</h2><span id='topic+distMat2Rank'></span>

<h3>Description</h3>

<p>Convert a symmetrical numerical matrix of distances to a matrix of ranks. Note: Only the lower
side of the matrix is used. Data on the upper right are assumed to be redundant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distMat2Rank(mat, lower_is_closer = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distMat2Rank_+3A_mat">mat</code></td>
<td>
<p>A numerical matrix containing distances.</p>
</td></tr>
<tr><td><code id="distMat2Rank_+3A_lower_is_closer">lower_is_closer</code></td>
<td>
<p>Logical indicating that lower is closer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used by default by gsnPareNetGenericHierarchic.
</p>


<h3>Value</h3>

<p>A symmetric matrix of scaled ranks (quantiles). The matrix has the attribute 'lower_is_closer' set to
'TRUE'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distMat2UnitNormRank">distMat2UnitNormRank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Start with a matrix of distances:
mat.dist &lt;-  matrix( c( NA, -400, -600, NA, NA, -120, NA, NA, NA ), nrow = 3, ncol = 3 )
# Get the ranks as a matrix:
mat.ranks &lt;- distMat2Rank(mat.dist)

# If, for this given metric, higher numbers are closer
# or more similar, do this instead:
mat.ranks2 &lt;- distMat2Rank(mat.dist, lower_is_closer = FALSE)

</code></pre>

<hr>
<h2 id='distMat2UnitNormRank'>distMat2UnitNormRank negDistMat2UnitNormRank</h2><span id='topic+distMat2UnitNormRank'></span><span id='topic+negDistMat2UnitNormRank'></span>

<h3>Description</h3>

<p>Convert a symmetrical numerical matrix of distances to a matrix of scaled ranks (from 0 to 1).
Note: Only the lower side of the matrix is used. Data on the upper right are assumed to be redundant. These
functions are intended to convert a matrix of distance or similarity values into a proper form for applying
hierarchical clustering with the <code>gsnPareNetGenericHierarchic()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distMat2UnitNormRank(mat, lower_is_closer = TRUE)

negDistMat2UnitNormRank(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distMat2UnitNormRank_+3A_mat">mat</code></td>
<td>
<p>A numerical matrix containing distances.</p>
</td></tr>
<tr><td><code id="distMat2UnitNormRank_+3A_lower_is_closer">lower_is_closer</code></td>
<td>
<p>Logical indicating that lower is closer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference between <code>distMat2UnitNormRank()</code> and <code>negDistMat2UnitNormRank()</code> is that
<code>negDistMat2UnitNormRank()</code> takes only the <code>mat</code> argument, and negates it prior to calling
<code>distMat2UnitNormRank()</code>.
</p>


<h3>Value</h3>

<p>A symmetric matrix of ranks. The matrix has the attribute 'lower_is_closer' set to
'TRUE'.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>negDistMat2UnitNormRank()</code>: Takes the same parameter distMat2UnitNormRank, but multiplies the distance by -1 first.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+distMat2Rank">distMat2Rank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For log Fisher values, lower is closer and more significant.
mat.dist &lt;- matrix( c( NA, -400, -600, NA, NA, -120, NA, NA, NA ), nrow = 3, ncol = 3 )
mat.scaledranks &lt;- distMat2UnitNormRank(mat.dist)

# With metrics for which higher is closer/more similar, use
# negDistMat2UnitNormRank():
mat.jaccard &lt;- matrix( c( NA, 0.2, 0.3, NA, NA, 0.1, NA, NA, NA ), nrow = 3, ncol = 3 )
mat.srjaccard &lt;- negDistMat2UnitNormRank(mat.jaccard)

# This also works:
mat.srjaccard &lt;- distMat2UnitNormRank(mat.jaccard, lower_is_closer=FALSE)

</code></pre>

<hr>
<h2 id='extract_david_GSC'>extract_david_GSC</h2><span id='topic+extract_david_GSC'></span>

<h3>Description</h3>

<p>extract_david_GSC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_david_GSC(
  data,
  genes.field = "Genes",
  term.field = "Term",
  del = "\\s*,\\s*"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_david_GSC_+3A_data">data</code></td>
<td>
<p>A data.frame containing DAVID pathways data (without duplicates).</p>
</td></tr>
<tr><td><code id="extract_david_GSC_+3A_genes.field">genes.field</code></td>
<td>
<p>The name of the field containing the lists of genes for each gene set (default: <code>"Genes"</code>).</p>
</td></tr>
<tr><td><code id="extract_david_GSC_+3A_term.field">term.field</code></td>
<td>
<p>The name of the field containing the ID for each gene set (default: <code>"Term"</code>).</p>
</td></tr>
<tr><td><code id="extract_david_GSC_+3A_del">del</code></td>
<td>
<p>A pattern specifying the delimiter for the genes in <code>genes.field</code>. (default: <code>"\\s*,\\s*"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gene set collection as a list of gene set vectors, where the gene set names correspond to Terms and
the vectors contain gene symbols corresponding to the genes listed in <code>genes.field</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+gsnAddPathwaysData">gsnAddPathwaysData</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+read_david_data_file">read_david_data_file</a>()</code>
</p>
</li></ul>


<hr>
<h2 id='gsc2tmod'>gsc2tmod</h2><span id='topic+gsc2tmod'></span>

<h3>Description</h3>

<p>Function to convert a GSC in the form of a named list of vectors containing gene symbols
to a object of class <code>tmod</code> which was used by the tmod prior to version <code>0.50.11</code>. This is
a wrapper for <code><a href="tmod.html#topic+makeTmod">makeTmod</a>()</code> from the <code>tmod</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsc2tmod(MODULES2GENES, MODULES = NULL, GENES = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsc2tmod_+3A_modules2genes">MODULES2GENES</code></td>
<td>
<p>A named list of character vectors in which the vectors correspond to gene sets
and contain gene symbols (or other gene identifiers) and the names are the corresponding gene set
identifiers.</p>
</td></tr>
<tr><td><code id="gsc2tmod_+3A_modules">MODULES</code></td>
<td>
<p>(optional) A data.frame containing an <code>ID</code> and a <code>Title</code> field
in the same order as the gene sets in <code>MODULES2GENES</code>. Furthermore, the row names should
(apparently) correspond to the IDs in the corresponding rows. If not provided, this will be generated
automatically.</p>
</td></tr>
<tr><td><code id="gsc2tmod_+3A_genes">GENES</code></td>
<td>
<p>(optional) A data frame with gene metadata. Must contain an ID column. If not provided,
this will be generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>tmod</code> object if the <code>tmod</code> package version <code>'0.46.2'</code> or earlier is
installed. If the <code>tmod</code> package version '0.50.11' or later is installed, it returns a
<code>tmodGS</code> object instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_gmt">read_gmt()</a></code> <code><a href="#topic+tmod2gsc">tmod2gsc()</a></code>
</p>

<hr>
<h2 id='gsIntersect'>gsIntersect</h2><span id='topic+gsIntersect'></span>

<h3>Description</h3>

<p>For two character vectors, returns the set of shared elements. This is used by GSNA to find shared genes
in two gene sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsIntersect(gs1, gs2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsIntersect_+3A_gs1">gs1</code></td>
<td>
<p>A character vector representing gene symbols in a gene set.</p>
</td></tr>
<tr><td><code id="gsIntersect_+3A_gs2">gs2</code></td>
<td>
<p>A character vector representing gene symbols in a second gene set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version of the function is used in gsnORAtest_cpp. (In another version of the function, used in
<code>gsnFilterGeneSetCollectionList()</code> and accessible only from C++ the first argument is gs1Set, a set of strings
of type <code>std::set&lt;std::string&gt;</code>.)
</p>
<p>This function does essentially what R's base::intersect does, so it is not necessarily useful to export.
</p>


<h3>Value</h3>

<p>A character vector consisting of the overlap of the two gene sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# We can extract 2 gene sets from the sample data:
Bai.gsc &lt;- tmod2gsc( Bai_gsc.tmod )
M29994.gs = Bai.gsc[['M29994']]
M40825.gs = Bai.gsc[['M40825']]

# Find the intersection:
intersect.gs &lt;- gsIntersect( gs1 = M29994.gs, gs2 = M40825.gs )

</code></pre>

<hr>
<h2 id='gsIntersectCounts'>gsIntersectCounts</h2><span id='topic+gsIntersectCounts'></span>

<h3>Description</h3>

<p>For two character vectors representing two gene sets (gs1 and gs2) and a total number of background
observable genes (that may also be present in gs1 and or gs2 or neither), this function calculates the counts in a
2x2 contingency table for presence and absence of genes in one or both sets or neither. The output of this function
is used as the input for a Fisher test calculation by the GSNA package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsIntersectCounts(gs1, gs2, bg_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsIntersectCounts_+3A_gs1">gs1</code></td>
<td>
<p>A character vector representing gene symbols in a gene set.</p>
</td></tr>
<tr><td><code id="gsIntersectCounts_+3A_gs2">gs2</code></td>
<td>
<p>A character vector representing gene symbols in a second gene set.</p>
</td></tr>
<tr><td><code id="gsIntersectCounts_+3A_bg_size">bg_size</code></td>
<td>
<p>An integer representing the size of the background, i.e. the total number of observable genes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version of the function may not be retained since it's not currently used. Two alternative versions of the
function in C++ that find the overlap between a <code>std::set&lt;std::string&gt;</code> and a character vector are used since those versions
are much faster.
</p>
<p>NOTE: This function assumes that all genes in gs1 and gs2 are present in the background, so to use this properly, gs1
and gs2 must be filtered to include only genes present in the background.
</p>


<h3>Value</h3>

<p>A numeric vector of length 4 containing the following 4 elements:
</p>

<ul>
<li><p><code>a</code>: The number of genes in the background that are absent in gs1 and gs2.
</p>
</li>
<li><p><code>b</code>: The number of background genes in gs1 but not gs2.
</p>
</li>
<li><p><code>c</code>: The number of background genes in gs2 but not gs1.
</p>
</li>
<li><p><code>d</code>: The number of background genes in in both gs1 and gs2.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library( GSNA )

# We can extract 2 gene sets from the sample data:
Bai.gsc &lt;- tmod2gsc( Bai_gsc.tmod )
M29994.gs = Bai.gsc[['M29994']]
M40825.gs = Bai.gsc[['M40825']]

# Get background gene cout:
bg_gene_count &lt;- nrow( Bai_empty_expr_mat )

# Generate a vector containing the number of contents of
# the 2x2 contingency table:
counts.v &lt;- gsIntersectCounts( gs1 = M29994.gs,
                               gs2 = M40825.gs,
                               bg_size = bg_gene_count )

</code></pre>

<hr>
<h2 id='gsn_default_distance'>gsn_default_distance, gsn_distances, pw_id_col, pw_stat_col, pw_sig_order, pw_stat_col_2, pw_sig_order_2, pw_n_col, pw_type</h2><span id='topic+gsn_default_distance'></span><span id='topic+gsn_default_distance+3C-'></span><span id='topic+gsn_distances'></span><span id='topic+pw_id_col'></span><span id='topic+pw_id_col+3C-'></span><span id='topic+pw_stat_col'></span><span id='topic+pw_stat_col+3C-'></span><span id='topic+pw_stat_col_2'></span><span id='topic+pw_stat_col_2+3C-'></span><span id='topic+pw_sig_order'></span><span id='topic+pw_sig_order+3C-'></span><span id='topic+pw_sig_order_2'></span><span id='topic+pw_sig_order_2+3C-'></span><span id='topic+pw_n_col'></span><span id='topic+pw_n_col+3C-'></span><span id='topic+pw_type'></span><span id='topic+pw_type+3C-'></span>

<h3>Description</h3>

<p>Get and set values for GSNData internal fields. When evaluated directly or on
the right side of an <code>&lt;-</code> assignment, these functions retrieve stored values. When
evaluated on the left side of a <code>&lt;-</code> assignment, they set the relevant field values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsn_default_distance(object)

gsn_default_distance(object) &lt;- value

gsn_distances(object)

pw_id_col(object)

pw_id_col(object) &lt;- value

pw_stat_col(object)

pw_stat_col(object) &lt;- value

pw_stat_col_2(object)

pw_stat_col_2(object) &lt;- value

pw_sig_order(object)

pw_sig_order(object) &lt;- value

pw_sig_order_2(object)

pw_sig_order_2(object) &lt;- value

pw_n_col(object)

pw_n_col(object) &lt;- value

pw_type(object)

pw_type(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsn_default_distance_+3A_object">object</code></td>
<td>
<p>A GSNData object.</p>
</td></tr>
<tr><td><code id="gsn_default_distance_+3A_value">value</code></td>
<td>
<p>A valid value for the field to be set. (see <em>Details</em>.).</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><strong>gsn_default_distance()</strong></dt><dd><p>Gets and sets the value stored in the <code>obect$default_distance</code>
field of a <code>GSNData</code> object. When a <code>GSNData</code> object contains distance matrices of
multiple types (e.g. single-tail log fisher &amp; Jaccard, the <code>defailt_distance</code> field tells
<code>GSNA</code> which distance to use for network paring, subnet assignment, plotting, etc.
When setting the value, it must be a character vector of length 1 that contains the name of
a valid distance metric for which there exists a distance matrix in the GSNData object, or
else an error will be raised.</p>
</dd>
<dt><strong>gsn_distances()</strong></dt><dd><p>Returns a character vector containing the names of the distances for which
there are distance matrices in a <code>GSNData</code> object.</p>
</dd>
<dt><strong>pw_id_col()</strong></dt><dd><p>Gets and sets the value stored in the <code>obect$pathways$id_col</code> field. This
is the field that determines which column in a pathways data.frame corresponds to a gene set
identifier used in a gene set collection list of vectors, or a <code>tmod</code> or <code>tmodGS</code>
object. When setting the value, this the function checks that the value is a valid column in
<code>obect$pathways$data</code>.</p>
</dd>
<dt><strong>pw_stat_col()</strong></dt><dd><p>Gets and sets the value stored in the <code>obect$pathways$stat_col</code> field.
This is the field that determines which column in a pathways data.frame corresponds to a
significance statistic of interest. When setting the value, this the function checks that the
value is a valid column in <code>obect$pathways$data</code>.</p>
</dd>
<dt><strong>pw_sig_order()</strong></dt><dd><p>Gets and sets the value stored in the <code>obect$pathways$sig_order</code> field.
This is the field that states the behavior of the significance value in the
<code>obect$pathways$sig_order</code> field, specifically whether low or high values are significant.
This may be either <code>'loToHi'</code> or <code>'hiToLo'</code>. (Other types of statistics are possible,
for example statistics with significant of high or low <em>absolute</em> values. We hope to add
support for such statistics in the future.)</p>
</dd>
<dt><strong>pw_stat_col_2()</strong></dt><dd><p>Gets and sets the value stored in the <code>obect$pathways$stat_col_2</code> field.
For two-channel GSNA analysis, this is the field that determines which column in a pathways
data.frame corresponds to the second significance statistic of interest. When setting the value,
this the function checks that the value is a valid column in <code>obect$pathways$data</code>.</p>
</dd>
<dt><strong>pw_sig_order_2()</strong></dt><dd><p>Gets and sets the value stored in the <code>obect$pathways$sig_order_2</code> field.
For a two-channel GSNA analysis, this is the field that states the behavior of the significance
value in the <code>obect$pathways$sig_order_2</code> field, specifically whether low or high values
are significant. This may be either <code>'loToHi'</code> or <code>'hiToLo'</code>. (Other types of
statistics are possible, for example statistics with significant of high or low <em>absolute</em>
values. We hope to add support for such statistics in the future.)</p>
</dd>
<dt><strong>pw_n_col()</strong></dt><dd><p>Gets and sets the value stored in the <code>obect$pathways$n_col</code> field.
This is the field that determines which column in a pathways data.frame corresponds to a
gene set size or gene set effective size. When setting the value, this the function checks
that the value is a valid column in <code>obect$pathways$data</code>.</p>
</dd>
<dt><strong>pw_type()</strong></dt><dd><p>Gets and sets the value stored in the <code>obect$pathways$type</code> field.
This is the field that describes what kind of pathways data are stored in the object,
e.g. <code>'gsea'</code> or <code>'cerno'</code>. If there is no current pathways data in the object
an error will be raised.</p>
</dd>
</dl>



<h3>Value</h3>

<p>For get versions of the functions, evaluated alone or on the right side of a <code>&lt;-</code>
assignment, the values stored in the relevant fields are returned, generally as character vectors
of length 1 (or NULL), except for gsn_distances which may return character vectors of varying length.
For set versions of the functions, for which the function call is on the left side of a <code>&lt;-</code>
assignment, a copy of the <code>GSNData</code> object with the specified field set is returned. See
<em>Details</em>.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These examples require some setup.
#
# First, we will generate a gene set network from CERNO example
# data, containing multiple distance metrics, as well as pathways
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Create a GSNData object containing Jaccard indices:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Within the same object, add an 'stlf' (Single Tail Log Fisher)
# distance matrix:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkSTLF( object = sig_pathways.GSN )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnAddPathwaysData( sig_pathways.GSN,
                                        pathways_data = sig_pathways.cerno )

# Use gsn_distances() to see what distances are stored in the
# GSNData object:
gsn_distances( sig_pathways.GSN )
# Should return: "jaccard" "stlf"

# See what the default distance is:
gsn_default_distance( sig_pathways.GSN )
# Returns: "stlf". Let's change the default distannce
# to "jaccard":
gsn_default_distance( sig_pathways.GSN ) &lt;- "jaccard"

# Let's examine what the ID column is:
pw_id_col( sig_pathways.GSN )
# Returns: "ID"
pw_id_col( sig_pathways.GSN ) &lt;- "ID"
# This is equivalent to the following code. When
# invoked on the left side of an assignment, R uses
# *syntactic sugar* to comvert the call to:
sig_pathways.GSN &lt;- `pw_id_col&lt;-`( object = sig_pathways.GSN,
                                   value = "ID" )

# On the other hand, the following returns an error
# because there is no column in the pathways dataframe
# named "invalid.name":
 class( try( pw_id_col( sig_pathways.GSN ) &lt;- "invalid.name" ) )
 # "try-error"



# Likewise we can get and set the value of stat_col
# and sig_order:
pw_stat_col(sig_pathways.GSN )
# Returns "adj.P.Val". Let's set it to "AUC"
pw_stat_col(sig_pathways.GSN) &lt;- "AUC"
# And likewise, sig_order:
pw_sig_order(sig_pathways.GSN) # "loToHi"
pw_sig_order(sig_pathways.GSN) &lt;- "hiToLo"


# For 2-channel GSNA analyses, we can set the values
# of stat_col_2 and sig_order_2:
pw_stat_col_2(sig_pathways.GSN )
# Returns NULL. Let's set it to "P.Value"
pw_stat_col_2(sig_pathways.GSN) &lt;- "P.Value"
# And likewise, sig_order:
pw_sig_order_2(sig_pathways.GSN) # NULL
pw_sig_order(sig_pathways.GSN) &lt;- "loToHi"

# pw_n_col() works the same way to set n_col:
pw_n_col(sig_pathways.GSN) # "N1"
pw_n_col(sig_pathways.GSN) &lt;- "N1"

# And also, pw_type()
pw_type(sig_pathways.GSN) # "cerno"
# For setting via pw_type, the value is not
# currently checked, since pathways data may
# be of many types:
pw_type(sig_pathways.GSN) &lt;- "other"

pw_type(sig_pathways.GSN) # "other"


</code></pre>

<hr>
<h2 id='gsnAddPathwaysData'>gsnAddPathwaysData</h2><span id='topic+gsnAddPathwaysData'></span><span id='topic+gsnAddPathwayData'></span>

<h3>Description</h3>

<p>Add pathways search data to a GSNData object.
</p>
<p><code>gsnAddPathwayData()</code> is a synonym of <code><a href="#topic+gsnAddPathwaysData">gsnAddPathwaysData</a>()</code>, included to support
old code. Use <code><a href="#topic+gsnAddPathwaysData">gsnAddPathwaysData</a>()</code> for new code. <code>gsnAddPathwayData()</code> will be deprecated in]
a future version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnAddPathwaysData(
  object,
  pathways_data,
  type = NULL,
  id_col = NULL,
  stat_col = NULL,
  sig_order = NULL,
  stat_col_2 = NULL,
  sig_order_2 = NULL,
  n_col = NULL
)

gsnAddPathwayData(
  object,
  pathways_data,
  type = NULL,
  id_col = NULL,
  stat_col = NULL,
  sig_order = NULL,
  stat_col_2 = NULL,
  sig_order_2 = NULL,
  n_col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnAddPathwaysData_+3A_object">object</code></td>
<td>
<p>A GSNData object.</p>
</td></tr>
<tr><td><code id="gsnAddPathwaysData_+3A_pathways_data">pathways_data</code></td>
<td>
<p>A data.frame containing the results of pathways analysis.</p>
</td></tr>
<tr><td><code id="gsnAddPathwaysData_+3A_type">type</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the type of pathways data being added to the
GSNData object. This can be <code>'cerno'</code>, <code>'gsea'</code>, <code>'gsnora'</code>, or other arbitrary types. If not
explicitly indicated, the method attempts to examine the column names of the data.frame in order to determine
what kind of import to perform, then calls other methods for the actual import. For <code>'cerno'</code>, <code>'gsea'</code>,
and <code>'gsnora'</code>, the actual import is performed by methods specifically designed for CERNO and GSEA import.
Otherwise a method for generic import is used.</p>
</td></tr>
<tr><td><code id="gsnAddPathwaysData_+3A_id_col">id_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a key for gene
sets/modules. This corresponds to the ID field of <code>tmod</code> objects, or the names of vectors in a list vectors
gene sets/modules, both of which can be used as a geneSetCollection argument in building gene set networks. In
the case of CERNO and GSEA data sets, there are preset values for <code>id_col</code>, but in the case of generic
import, the import method attempts to guess. If an ID cannot be inferred, then an error is thrown.</p>
</td></tr>
<tr><td><code id="gsnAddPathwaysData_+3A_stat_col">stat_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a statistic
to evaluate the quality of pathways results. This is generally a <em>p</em>-value of some sort. In the case of CERNO
and GSEA data sets, there are preset values for <code>stat</code>, but in the case of generic import, the import
method attempts to guess.</p>
</td></tr>
<tr><td><code id="gsnAddPathwaysData_+3A_sig_order">sig_order</code></td>
<td>
<p>(optional) Either <code>'loToHi'</code> or <code>'hiToLo'</code> depending on the statistic used to
evaluate pathways results. For <em>p</em>-values, this should be <code>'loToHi'</code>.</p>
</td></tr>
<tr><td><code id="gsnAddPathwaysData_+3A_stat_col_2">stat_col_2</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a second
statistic to evaluate pathway result quality. Used in 2-color networks.</p>
</td></tr>
<tr><td><code id="gsnAddPathwaysData_+3A_sig_order_2">sig_order_2</code></td>
<td>
<p>(optional) Either <code>'loToHi'</code> or <code>'hiToLo'</code> depending on <code>stat_col_2</code>. Used
in 2-color networks.</p>
</td></tr>
<tr><td><code id="gsnAddPathwaysData_+3A_n_col">n_col</code></td>
<td>
<p>(optional) Specifies the column containing the number of genes in the gene set. Generally, this is the number
of genes in the gene set that are attested in an expression data set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pathways data are used by the <code>assignSubnets()</code> function, which organizes subnets on the basis
of this statistic. If <code>sig_order</code> is <code>'loToHi'</code>, and the evaluation statistic (<code>'stat'</code>) is a
<em>p</em>-value, then the first node in each subnet will be the node with the lowest <em>p</em>-value, for example. This
ordering is not an absolute requirement.
</p>
<p>This is provided to simplify workflows and facilitate imports that can identify and handle multiple types of
pathways data, but also the CERNO, GSEA, GSNORA, and generic import methods can be used directly
( <code><a href="#topic+gsnImportCERNO">gsnImportCERNO</a></code>, <code><a href="#topic+gsnImportGSEA">gsnImportGSEA</a></code>, <code><a href="#topic+gsnImportGSNORA">gsnImportGSNORA</a></code>,
and <code><a href="#topic+gsnImportGenericPathways">gsnImportGenericPathways</a></code>).
</p>
<p>Notes: These import handlers perform checks on the provided pathways data to verify that
all gene set IDs in the genePresenceAbsence matrix are present in the ID column of the pathways data. An error
is thrown if all gene set IDs in the genePresenceAbsense are not present in the pathways ID column. On the other
hand, if there are gene set IDs present in the pathways data that are absent from the genePresenceAbsence matrix,
then these methods emit a warning.
</p>


<h3>Value</h3>

<p>This returns a GSNData object containing imported pathways data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnImportCERNO">gsnImportCERNO</a></code>
<code><a href="#topic+gsnImportGSEA">gsnImportGSEA</a></code>
<code><a href="#topic+gsnImportGSNORA">gsnImportGSNORA</a></code>
<code><a href="#topic+gsnImportGenericPathways">gsnImportGenericPathways</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnAddPathwaysData( sig_pathways.GSN,
                                        pathways_data = sig_pathways.cerno )

</code></pre>

<hr>
<h2 id='gsnAssignSubnets'>gsnAssignSubnets</h2><span id='topic+gsnAssignSubnets'></span>

<h3>Description</h3>

<p>Main wrapper method for assigning subnets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnAssignSubnets(object, distance = NULL, scoreCol = NULL, highToLow = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnAssignSubnets_+3A_object">object</code></td>
<td>
<p>An object of type <code>GSNData</code> containing pathways data and a pared distance matrix.</p>
</td></tr>
<tr><td><code id="gsnAssignSubnets_+3A_distance">distance</code></td>
<td>
<p>(optional) character vector of length 1 indicating which pared distance matrix is to be used for assigning
subnets. This defaults to the 'default_distance'.</p>
</td></tr>
<tr><td><code id="gsnAssignSubnets_+3A_scorecol">scoreCol</code></td>
<td>
<p>(optional) A score column used for ordering edges. See explanation below. If there are 3 or more columns
the last one is presumed to be the score column and used for ordering. The score is usually derived from a pathways
score but may also be derived the pared distance matrix.</p>
</td></tr>
<tr><td><code id="gsnAssignSubnets_+3A_hightolow">highToLow</code></td>
<td>
<p>(optional) A boolean indicating how scores are to be ordered based on significance, low to high, or
high to low.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls the private <code>assignSubnets</code> function using scores derived from pathways data, starting with the most significant
edge scores in a subnet, and subsequently joining additional vertices in order of the best score.
</p>


<h3>Value</h3>

<p>The method returns a GSNData object containing the following data for the indicated distance matrix:
</p>

<dl>
<dt><code>edges</code></dt><dd><p>The edges data.frame, but with a subnet column added.</p>
</dd>
<dt><code>subnets</code></dt><dd><p>A list of vectors such that the names of the vectors are the names of subnets, and the contents
of each vector are the gene sets making up that vector.</p>
</dd>
<dt><code>vertex_subnets</code></dt><dd><p>A data.frame containing the name of a vertex and its assigned subnet.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnImportCERNO( sig_pathways.GSN,
                                    pathways_data = sig_pathways.cerno )

# Now we can pare the network. By default, the distances are complemented
# and converted into ranks for the sake of generating a network.
sig_pathways.GSN &lt;- gsnPareNetGenericHierarchic( object = sig_pathways.GSN )

# Once the network has been pared, gsnAssignSubnets() can be called:
sig_pathways.GSN &lt;- gsnAssignSubnets( object = sig_pathways.GSN )


</code></pre>

<hr>
<h2 id='GSNData'>GSNData</h2><span id='topic+GSNData'></span>

<h3>Description</h3>

<p>GSNData object constructor, used to generate new GSNData objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GSNData(distances = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GSNData_+3A_distances">distances</code></td>
<td>
<p>Optional parameter containing a list of module-module distance metric data organized by the name of the
distance metric used, e.g. lf, jaccard, stlf.</p>
</td></tr>
<tr><td><code id="GSNData_+3A_...">...</code></td>
<td>
<p>Additional arguments. Object fields can be set as named arguments this way using name = value pairs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is called by <code>buildGeneSetNetworkLFFFast()</code>, <code>buildGeneSetNetworkLFFast()</code> and <code>buildGeneSetNetworkSTLF()</code>.
For most users there will be little reason to call this method except when tying to implement support for new distance metrics or
utility functions.
</p>


<h3>Value</h3>

<p>A new GSNAData object.
</p>


<h3>Structure of the GSNData object:</h3>

<p>The GSNData object can contain multiple distance matrices including log Fisher (lf) and Jaccard (jaccard). These distances,
along with associated pared-distances, and significance order parameters are stored in named sublists within the <code>$distances</code>
lists, the sublists are named after their respective distance metric (lf, jaccard, etc.) as <code>$distances[[DIST]]</code>. These sublists
contain a distance matrix <code>$distances[[DIST]]$matrix</code>, a significance order <code>$distances[[DIST]]$optimal_extreme</code> (e.g. &quot;loToHi&quot; for lf,
and &quot;hiToLo&quot; for jaccard), and after paring a <code>$distances[[DIST]]$pared</code>.
</p>


<h3>Fields:</h3>


<dl>
<dt><code>$GSNA_version</code></dt><dd><p>A character vector of length 1 indicating the version of GSNA used to generate this GSNData object.</p>
</dd>
<dt><code>$genePresenceAbsence</code></dt><dd><p>A sparse logical Matrix containing presence(TRUE) or absence (FALSE) calls for genes (rows) in gene sets (columns).</p>
</dd>
<dt><code>$distances</code></dt><dd><p>a named list(). Names indicate a distance metric 'lf', 'jaccard', etc. indicated as <code>DIST</code> below.</p>
</dd>
<dt><code>$distances[[DIST]]$matrix</code></dt><dd><p>A matrix of raw distances</p>
</dd>
<dt><code>$distances[[DIST]]$optimal_extreme</code></dt><dd><p> Significance order where &quot;min&quot; indicates that low values are optimal/
closer than high values as with log Fisher (lf), and &quot;max&quot; indicates that high
values are closer, as with Jaccard (jaccard) distance.</p>
</dd>
<dt><code>$distances[[DIST]]$pared_optimal_extreme</code></dt><dd><p> Significance order for the pared, scaled distance matrix.
This may differ from <code>$distances[[DIST]]$optimal_extreme</code> if scaling flips high
distance values to low ones, as may be necessary for handling distance matrices such
as the Jaccard for which higher values are closer. (See
<code>$distances[[DIST]]$optimal_extreme</code>, above.)</p>
</dd>
<dt><code>$distances[[DIST]]$pared</code></dt><dd><p>A pared distance matrix.</p>
</dd>
<dt><code>$distances[[DIST]]$edges</code></dt><dd><p>A data.frame containing a gathered set of network edges derived from <code>$distances[[DIST]]$pared</code></p>
</dd>
<dt><code>$distances[[DIST]]$vertices</code></dt><dd><p>A complete list of gene set IDs in the network.</p>
</dd>
<dt><code>$default_distance</code></dt><dd><p>The default distance used for network construction.</p>
</dd>
<dt><code>$ordered_genes</code></dt><dd><p>A character vector containing the ordered list of genes in the data set (most important first).
This list is also used as the background of observable genes for creating the
filteredGeneSetCollection.</p>
</dd>
<dt><code>$filteredGeneSetCollection</code></dt><dd><p>A filtered set of gene lists (a list of character vectors) containing only the genes
present in the differential expression data set. This is the 'background' of all genes
observable in the differential expression data.</p>
</dd>
<dt><code>$pathways</code></dt><dd><p>A named list containing pathways results data, as follows:</p>
</dd>
<dt><code>$pathways$data</code></dt><dd><p>A data.frame containing a pathways results set.</p>
</dd>
<dt><code>$pathways$type</code></dt><dd><p>A character vector of length=1 indicating the type of pathways analysis performed, e.g. CERNO, GSEA, ORA.</p>
</dd>
<dt><code>$pathways$id_col</code></dt><dd><p>Indicates the name of the column in $pathways$data that contains the gene set ID.</p>
</dd>
<dt><code>$pathways$stat_col</code></dt><dd><p>A character vector of length 1 indicating the statistic used for assessing significance,
generally a p-value.</p>
</dd>
<dt><code>$pathways$stat_col_2</code></dt><dd><p>A character vector of length 1 indicating the statistic used for assessing significance,
generally a p-value.</p>
</dd>
<dt><code>$pathways$sig_order</code></dt><dd><p>Indicates whether low of high values of $pathways$statistic are most significant with
&quot;loToHi&quot; indicating that low values are optimal/most significant (as with typical p-values)
and &quot;hiToLo&quot; indicating high values are optimal/most significant.</p>
</dd>
<dt><code>$pathways$sig_order_2</code></dt><dd><p>Indicates whether low of high values of $pathways$statistic are most significant with
&quot;loToHi&quot; indicating that low values are optimal/most significant (as with typical p-values)
and &quot;hiToLo&quot; indicating high values are optimal/most significant.</p>
</dd>
<dt><code>$pathways$n_col</code></dt><dd><p>Indicates the name of the pathways column used to indicate effective gene set size, based on
genes actually observable in an experimental data set.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> library(GSNA)
 gsn_obj &lt;- GSNData()

</code></pre>

<hr>
<h2 id='gsnDendroSubnetColors'>gsnDendroSubnetColors, gsnDendroSubnetColors_dark</h2><span id='topic+gsnDendroSubnetColors'></span><span id='topic+gsnDendroSubnetColors_dark'></span>

<h3>Description</h3>

<p>Given a list of vectors of gene set IDs corresponding to subnets, returns a vector of colors.
with each color corresponding to a subnet (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnDendroSubnetColors(subnets)

gsnDendroSubnetColors_dark(subnets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnDendroSubnetColors_+3A_subnets">subnets</code></td>
<td>
<p>A list of vectors containing, as elements, vectors corresponding to subnets and containing
gene set IDs as subnet members. List element names are the names of the subnets. This corresponds to the set
of subnets stored in the <code>$distances[[distance]]$subnets</code> field of a pared <code>GSNData</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a list of vectors in which each vector contains a set of gene set IDs corresponding to a
subnet, with list element names being the subnet names, this function generates a vector of colors in
which subnets with a single member are colored black and subnets with multiple members are given associated
distinct colors. In the returned vector of names, the names are the subnets and the elements are the associated
colors. This function is primarily for generating colors for hierarchical dendrograms.
</p>
<p>The <code>gsnDendroSubnetColors()</code> and <code>gsnDendroSubnetColors_dark()</code> do approximately the same thing,
but <code>gsnDendroSubnetColors_dark()</code> returns a darker palette of colors.
</p>


<h3>Value</h3>

<p>A vector of colors with names corresponding to subnet names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library( GSNA )

# After gsnAssignSubnets() has been called, a list containing subnet
# assignments is stored in GSNData objects at
# object$distances[[distance]]$subnets

# It has this structure:
subnets &lt;- list( `1` = c( "M30131", "M40742", "M29968", "M29984", "M29922",
                          "M30190", "M40775", "M30171", "M30154", "M30186" ),
                 `2` = c( "M40770" ),
                 `3` = c( "M30055", "M30117" ),
                 `4` = c( "M40804" ),
                 `5` = c( "M40776" ),
                 `6` = c( "M40846" ) )

# Based on this, singltons, subnets/clusters with single membership
# are assigned black, and subnets with multiple members are assigned
# colors using a color wheel:
colors_v &lt;- gsnDendroSubnetColors( subnets )

# gsnDendroSubnetColors_dark does the same thing as
# gsnDendroSubnetColors, but picks darker colors.
dark_colors_v &lt;- gsnDendroSubnetColors_dark( subnets )

</code></pre>

<hr>
<h2 id='gsnDistanceHistogram'>gsnDistanceHistogram</h2><span id='topic+gsnDistanceHistogram'></span>

<h3>Description</h3>

<p>Generate a Histogram of Distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnDistanceHistogram(
  object,
  distance = NULL,
  dist.matrix = c("raw", "pared", "edges"),
  stat = "percent",
  colors = NULL,
  bins = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnDistanceHistogram_+3A_object">object</code></td>
<td>
<p>A GSNData object</p>
</td></tr>
<tr><td><code id="gsnDistanceHistogram_+3A_distance">distance</code></td>
<td>
<p>A distance, or even a character vector of distances, e.g. c(&quot;lf&quot;, &quot;jaccard&quot;, &quot;stlf&quot;).</p>
</td></tr>
<tr><td><code id="gsnDistanceHistogram_+3A_dist.matrix">dist.matrix</code></td>
<td>
<p>The names of distance matrices, which can be &quot;raw&quot; for the distance stored in &quot;matrix&quot;,
&quot;pared&quot; for the distances stored in &quot;pared&quot;, and &quot;edges&quot; for the distances stored in &quot;edges&quot;. In general,
the distances in &quot;edges&quot; will be the same as those in &quot;pared&quot;, but this may not always be true.</p>
</td></tr>
<tr><td><code id="gsnDistanceHistogram_+3A_stat">stat</code></td>
<td>
<p>Can be &quot;percent&quot;, &quot;count&quot;, &quot;density&quot;, or &quot;cumulative&quot;. This determines how the data are visualized.</p>
</td></tr>
<tr><td><code id="gsnDistanceHistogram_+3A_colors">colors</code></td>
<td>
<p>Currently, this does nothing, but will eventually allow the user to specify custom colors. Stay
tuned.</p>
</td></tr>
<tr><td><code id="gsnDistanceHistogram_+3A_bins">bins</code></td>
<td>
<p>The number of bins, for histograms (&quot;percent&quot; or &quot;count&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for such purposes as assessing the effects of paring on the distribution of
distances.
</p>


<h3>Value</h3>

<p>A ggplot2 graphical object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.GSNData">plot.GSNData</a></code>
<code><a href="#topic+gsnPlotNetwork">gsnPlotNetwork</a></code>
<code><a href="#topic+gsnHierarchicalDendrogram">gsnHierarchicalDendrogram</a></code>
</p>

<hr>
<h2 id='gsnFilterGeneSetCollectionList'>gsnFilterGeneSetCollectionList</h2><span id='topic+gsnFilterGeneSetCollectionList'></span>

<h3>Description</h3>

<p>Given a vector of gene symbols and a gene set collection, filter the gene set collection to include
only gene symbols present in the background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnFilterGeneSetCollectionList(bg, geneSetCollection)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnFilterGeneSetCollectionList_+3A_bg">bg</code></td>
<td>
<p>A character vector representing gene symbols in a background of observable genes.</p>
</td></tr>
<tr><td><code id="gsnFilterGeneSetCollectionList_+3A_genesetcollection">geneSetCollection</code></td>
<td>
<p>A list of gene sets, in which the gene sets are character vectors containing
gene symbols, and the list names are the corresponding gene set identifiers. NOTE: This must be a list, not a
<code>tmod</code> object. It is trivial to extract such a list from a <code>tmod</code> object, however. The
<code>$MODULES2GENES</code> field of the <code>tmod</code> object contains a suitable list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in gsnORAtest_cpp to automatically filter the gene set provided. It may be used
manually during GSNA analysis.
</p>


<h3>Value</h3>

<p>A filtered gene set as a list of vectors of gene symbols in which the list names correspond to gene
set IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# Get the background of observable genes set from
# expression data:
gene_background &lt;- toupper(rownames( Bai_empty_expr_mat ))

# Generate a gene set collection as a list of vectors from
# **Bai_gsc.tmod**, included in sample data:
Bai.gsc &lt;- tmod2gsc( Bai_gsc.tmod )

# Using the sample gene set collection **Bai_gsc.tmod**,
# generate a gene set collection filtered for the bg of
# observable genes:
Bai.filt.gsc &lt;- gsnFilterGeneSetCollectionList( bg = gene_background,
                                         geneSetCollection = Bai.gsc )

</code></pre>

<hr>
<h2 id='gsnHierarchicalDendrogram'>gsnHierarchicalDendrogram</h2><span id='topic+gsnHierarchicalDendrogram'></span>

<h3>Description</h3>

<p>Generate a dendrogram plot of a hierarchical clustered set of GSNA distances. This requires an embedded
hierarchical cluster object of type <code>'hclust'</code> associated with the default or specified distance metric. Such
an object may be generated by running <code>gsnPareNetGenericHierarchic()</code> on a <code>GSNData</code> object prior to
running this function.
</p>
<p>The graphical output of this function can be a horizontal or circular dendrogram. When <code>show.leaves</code>, <code>stat_col</code>
and optionally <code>stat_col_2</code>, the function will output a dendrogram image with leaves colored by the significance
indicated in <code>stat_col</code> and optionally <code>stat_col_2</code> (with a 1 or 2 dimensional color scale). If <code>n_col</code>
is specified, the leaf sizes will be scaled by the column indicated therein.
</p>
<p>The function has many optional arguments, but only a few should be necessary to get a decent plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnHierarchicalDendrogram(
  object,
  distance = NULL,
  subnet_colors = NULL,
  filename = NULL,
  file = NULL,
  out_format = NULL,
  width = NULL,
  height = NULL,
  .mai.plot = NULL,
  cex = par("cex"),
  subnetColorsFunction = gsnDendroSubnetColors_dark,
  id_col = NULL,
  id_nchar = NULL,
  pathways_title_col = c("Title", "Name", "NAME", "STANDARD_NAME"),
  substitute_id_col = NULL,
  font_face = NULL,
  color_labels_by = "subnet",
  show.leaves = FALSE,
  show.legend = TRUE,
  pathways_dat = NULL,
  stat_col = NULL,
  stat_col_2 = NULL,
  sig_order = NULL,
  sig_order_2 = NULL,
  n_col = NULL,
  transform_function = nzLog10,
  leaf_colors = c("white", "yellow", "red"),
  leaf_colors.1 = c("#FFFFFF", "red"),
  leaf_colors.2 = c("#FFFFFF", "blue"),
  leaf_border_color = "#666666",
  legend.leaf.col = "#CCCCCC",
  combine_method = "scaled_geomean",
  use_leaf_border = TRUE,
  render.plot = TRUE,
  c1.fun = NULL,
  c2.fun = NULL,
  geometry = "horizontal",
  .plt.plot = NULL,
  leaves_pch = NULL,
  leaf_char_shift = 1,
  na.color = "#CCCCCC",
  leaf_cex = NULL,
  leaf_cex_range = c(0.5, 2.1),
  lab.cex = NULL,
  tree_x_size.in = 2,
  legend_x_size.in = 2,
  left_margin.in = 0,
  right_margin.in = NULL,
  top_margin.in = NULL,
  bottom_margin.in = 0,
  legend.downshift.in = NULL,
  bkt_lmargin_chars = 4,
  legend_spacing.x.in = 2 * par("cin")[1],
  legend_spacing.y.in = par("cin")[2],
  legend.lab.cex = NULL,
  legend.axis.cex = NULL,
  legend.free.cex.bool = FALSE,
  main = NULL,
  cex.main = NULL,
  mar.main = 3.2,
  lines.main = 1.5,
  colors.n = 100,
  legend.bg = par("bg"),
  legend.fg = par("fg"),
  resolution = 72,
  draw.legend.box.bool = TRUE,
  DO_BROWSER = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_object">object</code></td>
<td>
<p>An object of the class <code>GSNData</code></p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_distance">distance</code></td>
<td>
<p>(optional) A character vector of length one to indicate the desired distance metric to be used for
generating a hierarchical dendrogram, e.g. 'lf', 'jaccard', 'stlf', etc. Defaults to the value of objects
<code>default_distance</code>.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_subnet_colors">subnet_colors</code></td>
<td>
<p>(optional) A character vector of color codes matching the desired colors for subnets. If null
then the colors are set automatically.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_filename">filename</code></td>
<td>
<p>(optional) A file for outputting a graphical image to a file as opposed to the current graphical device.
Output format is automatically detected from the file suffix, but can be overridden using the out_format argument.
(See details.)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_file">file</code></td>
<td>
<p>(optional) Synonym of filename, but deprecated. (Generates a warning.)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_out_format">out_format</code></td>
<td>
<p>(optional) File format of the output, either <code>'svg'</code>, <code>'png'</code>, <code>'pdf'</code>, or <code>'plot'</code>
(default if filename is not specified). For more information, see Details.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_width">width</code></td>
<td>
<p>(optional) Used to specify the width of the output in inches. If not specified, defaults to the current figure width.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_height">height</code></td>
<td>
<p>(optional) Used to specify the height of the output in inches. If not specified, defaults to the current figure height.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_.mai.plot">.mai.plot</code></td>
<td>
<p>(optional) A parameter specifying the margins of the plot, excluding legends as inches. This is calculated
automatically and for most purposes, will not need to be specified.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_cex">cex</code></td>
<td>
<p>(optional) Font size in cex units. This parameter is used as a basis for setting the various other font sizes
including those of leaf/node labels, cluster/subnet labels, and legend text sizes.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_subnetcolorsfunction">subnetColorsFunction</code></td>
<td>
<p>(optional) Function for assigning colors to subnets. Only used when
<code>color_labels_by == 'subnet'</code>. The default value is <code>gsnDendroSubnetColors_dark</code>.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_id_col">id_col</code></td>
<td>
<p>(optional) Character vector of length 1 indicating the name of the column to be used
as an ID key in the pathways dataframe (or modules data if that is used, see below). This column should contain
the same values as the names of the gene sets. This defaults to the value of the pathways id_col field.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_id_nchar">id_nchar</code></td>
<td>
<p>(optional) Integer indicating the number of characters to reserve in the dendrogram plot for the
ID. If unspecified, it is equal to the maximal nchar of the specified ID (<code>id_col</code> or <code>substitute_id_col</code>).</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_pathways_title_col">pathways_title_col</code></td>
<td>
<p>(optional) Character vector of length 1 indicating the name of the column in the pathways or
modules data.frame to be used as a Title or descriptor in the plot. If not set the function looks for the
following names: &quot;Title&quot;, &quot;Name&quot;, &quot;NAME&quot;, &quot;STANDARD_NAME&quot;, and takes the first that it finds. If set to NA,
the title part of the label is suppressed.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_substitute_id_col">substitute_id_col</code></td>
<td>
<p>(optional) Character vector of length 1 indicating a column used to substitute an alternative
ID for the labeling gene sets in data set. If set to <code>NA</code>, the ID in the plot is disabled.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_font_face">font_face</code></td>
<td>
<p>(optional) The font used for plot text, including leaf labels. For best results, this should be a
monospaced font. If not specified, the system attempts to pick a suitable default: <code>'Andale Mono'</code> on Mac OS X,
<code>'Lucida Sans Typewriter'</code> for Windows, and <code>'mono'</code> for all other systems.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_color_labels_by">color_labels_by</code></td>
<td>
<p>(optional) This parameter tells the plotting function to assign colors to dendrogram
leaf labels on on the basis of this argument. Currently, only 'subnets' and NULL are supported arguments.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_show.leaves">show.leaves</code></td>
<td>
<p>(optional) Logical to tell the function to display leaves representing gene sets. When <code>stat_col</code>
and optionally <code>stat_col_2</code> are specified, naming parameters from the <code>pathways_dat</code> data.table, a single or
two-color color scale is used to represent the value of the corresponding pathways statistics.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_show.legend">show.legend</code></td>
<td>
<p>(optional) A logical value telling the plotting function to include legends.(default: TRUE)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_pathways_dat">pathways_dat</code></td>
<td>
<p>(optional) data.frame containing associated pathways data. This defaults to whatever pathways
data has already been imported into this GSNData object in <code>object$pathways$data</code>.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_stat_col">stat_col</code></td>
<td>
<p>(optional) This is the name of the column in the pathways data.frame that contains a significance
value for coloring network vertices. The default value is specified by <code>object$pathways$stat_col</code>.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_stat_col_2">stat_col_2</code></td>
<td>
<p>(optional) This is the name of an optional second column in the pathways data.frame that
contains a significance value for coloring network vertices in a 2-color network. The default value is specified
by <code>object$pathways$stat_col_2</code>. When specified, a 2-color network is generated. To force a 2-color network
to plot as a standard 1-color network using <code>stat_col</code> alone, use <code>stat_col_2 = NA</code>.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_sig_order">sig_order</code></td>
<td>
<p>(optional) This indicates the behavior of <code>stat_col</code>, whether low values (<code>'loToHi'</code>) or
high values (<code>'hiToLo'</code>) are most significant. The default value is specified in <code>object$pathways$sig_order</code>.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_sig_order_2">sig_order_2</code></td>
<td>
<p>(optional) This indicates the behavior of <code>stat_col</code>, whether low values (<code>'loToHi'</code>) or
high values (<code>'hiToLo'</code>) are most significant. The default value is specified in <code>object$pathways$sig_order</code>.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_n_col">n_col</code></td>
<td>
<p>(optional) This is the name of the column in the pathways data.frame that contains a value for gene set
size, or any other value intended to be the bases of leaf scaling. When specified, leaf sizes will be scaled by this
value. (default is the value in <code>object$pathways$n_col</code>). An <code>NA</code> value can be used to override the
the value in <code>object$pathways$n_col</code> and suppress leaf scaling.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_transform_function">transform_function</code></td>
<td>
<p>(optional) Function to transform significance values for conversion to a color scale.
Normally, significance values are <em>p</em>-values, and need log transformation. If there are significance values of 0,
these are converted to <code>-Inf</code> by log-transformation, so the function <code>nzLog10()</code> adds a small pseudocount
to the values to mitigate this problem, prior to log10 transformation, but for other types of data, other transformations
or even 'identity' may be more suitable. (default, <code>nzLog10</code>)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_leaf_colors">leaf_colors</code></td>
<td>
<p>(optional) A vector containing at least 2 colors for generating a color gradient in single channel
visualizations. (default: c(&quot;white&quot;,&quot;yellow&quot;,&quot;red&quot;), see details)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_leaf_colors.1">leaf_colors.1</code></td>
<td>
<p>(optional) A vector containing at least 2 colors for generating a color gradient in dual channel
visualizations. (default: c(&quot;white&quot;, &quot;red&quot;), see details)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_leaf_colors.2">leaf_colors.2</code></td>
<td>
<p>(optional) A vector containing at least 2 colors for generating a color gradient in dual channel
visualizations. (default: c(&quot;white&quot;, &quot;blue&quot;), see details)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_leaf_border_color">leaf_border_color</code></td>
<td>
<p>(optional) For R's open plot symbols <code>pch </code><code class="reqn">\in</code><code> ( 21, 22, 23, 24, 25 )</code>, supporting fill
with a 'bg' color, leaf border may be specified with this option. (default: &quot;#666666&quot;)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_legend.leaf.col">legend.leaf.col</code></td>
<td>
<p>(optional) Leaf fill color for the legend. (default: &quot;#CCCCCC&quot;)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_combine_method">combine_method</code></td>
<td>
<p>(optional) For dual channel plots this is a string used to indicate how colors are combined to
generate a two dimensional color scale. Options are &quot;scaled_geomean&quot; (same as &quot;default&quot;), &quot;standard&quot; (same as &quot;euclidean&quot; ),
&quot;negative_euclidean&quot;, &quot;mean&quot;, and &quot;additive&quot;. See details.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_use_leaf_border">use_leaf_border</code></td>
<td>
<p>(optional) When automatically choosing a leaf symbol (leaves_pch), this option determines whether
a solid or an open symbol is used (see details).</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_render.plot">render.plot</code></td>
<td>
<p>(option) Logical value indicating whether to actually render the plot, or simply return a dendrogram.
This may be useful if graphical parameters need to be calculated but rendering is not desired. (see value)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_c1.fun">c1.fun</code></td>
<td>
<p>(optional) Function to convert the vector of numeric values represented by <code>stat_col</code> to a character
vector corresponding to colors. For dual channel plots, these colors may be combined with a second array of colors using
by the method specified using the <code>combine_method</code> parameter. If not specified, <code>c1.fun</code> calculated automatically
as a linear function.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_c2.fun">c2.fun</code></td>
<td>
<p>(optional) Same as c1.fun but for <code>stat_col_2</code>.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_geometry">geometry</code></td>
<td>
<p>(optional) Specifies either &quot;horizontal&quot; or &quot;circular&quot; type dendrogram plots. (default: horizontal)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_.plt.plot">.plt.plot</code></td>
<td>
<p>(optional) Specifies the plot region of the output using <code>figure</code> coordinates, and excluding the
legends. This can provide a greater degree of control for plotting, but most users will not need to adjust this. See
the <code>plt</code> argument of the par graphics function for more information.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_leaves_pch">leaves_pch</code></td>
<td>
<p>(optional) Used to specify the pch symbol used to represent dendrogram leaves. (default: 22 (open square),
for horizontal dendrograms and dendextend version &gt;= '1.16.0'; 15 (solid square) for horizontal dendrograms with dendextend
version &lt; '1.16.0', and for circular dendrograms, 16 (solid circle))</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_leaf_char_shift">leaf_char_shift</code></td>
<td>
<p>(optional) A parameter telling the function by how many character widths to shift the leaf labels.
(default: 1)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_na.color">na.color</code></td>
<td>
<p>(optional) The color used for NA values. (default: &quot;#CCCCCC&quot;)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_leaf_cex">leaf_cex</code></td>
<td>
<p>(optional) The cex size of the leaf symbols. This is used when <code>n_col</code> is not specified, i.e. there
is no leaf size scaling. (default: 1.5 * lab.cex)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_leaf_cex_range">leaf_cex_range</code></td>
<td>
<p>(optional) The range of leaf sizes used in plots, from low to high. This is used when <code>n_col</code>
is specified and leaf sizes are to be scaled. This may need to be reduced if leaves overlap or are clipped on one size.
(default: c(0.5, 2.1))</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_lab.cex">lab.cex</code></td>
<td>
<p>(optional) The cex size of dendrogram leaf labels (default: 0.9 * cex).</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_tree_x_size.in">tree_x_size.in</code></td>
<td>
<p>(optional) For horizontal dendrograms, this is the width of the dendrogram in inches, not including
leaf labels, cluster brackets, or legends. (default: 2)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_legend_x_size.in">legend_x_size.in</code></td>
<td>
<p>(optional) The width of legends in inches. (default: 2)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_left_margin.in">left_margin.in</code></td>
<td>
<p>(optional) The width of the left margin in inches. Ignored if .plt.plot or .mai.plot is specified.
(default: 0)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_right_margin.in">right_margin.in</code></td>
<td>
<p>(optional) The width of the right margin of the dendrogram in inches. Ignored if .plt.plot or
.mai.plot is specified. If unspecified, this is calculated automatically as <code>width - tree_x_size.in</code>.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_top_margin.in">top_margin.in</code></td>
<td>
<p>(optional) The width of the top margin of the dendrogram in inches. Ignored if .plt.plot or
.mai.plot is specified. (default: if no <code>main</code> argument is specified, 0. If a <code>main</code> argument is specified,
then it is calculated as <code>cex.main * par('cin')[2] * mar.main</code>)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_bottom_margin.in">bottom_margin.in</code></td>
<td>
<p>(optional) (optional) The width of the bottom margin in inches. Ignored if .plt.plot or
.mai.plot is specified. (default: 0)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_legend.downshift.in">legend.downshift.in</code></td>
<td>
<p>(optional) Argument shifting the legend downward, in inches. This is useful for adjusting
the alignment of the legend(s) with the top of the plot. (default: for horizontal dendrograms, 0; for circular
dendrograms, 0.42)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_bkt_lmargin_chars">bkt_lmargin_chars</code></td>
<td>
<p>(optional) Width in character widths of the space between the leaf labels and the brackets
indicating cluster/subnet groups. If the leaf labels need more space, this can be increased. (default: 4)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_legend_spacing.x.in">legend_spacing.x.in</code></td>
<td>
<p>(optional) Space between plot and legend in inches. With some plot configurations, it may be
useful to use negative values to bring the legends closer to the plot region. (default: 2 character widths)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_legend_spacing.y.in">legend_spacing.y.in</code></td>
<td>
<p>(optional) Space between legends in inches. (default: 1 character height)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_legend.lab.cex">legend.lab.cex</code></td>
<td>
<p>(optional) Legend x and y label size in cex. If unspecified, the function tries to pick a reasonable
value based on available space.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_legend.axis.cex">legend.axis.cex</code></td>
<td>
<p>(optional) Legend axis label size in cex. If unspecified, the function tries to pick a reasonable
value based on available space.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_legend.free.cex.bool">legend.free.cex.bool</code></td>
<td>
<p>(optional) Logical allowing independent optimized sizing of legend label font sizes if TRUE.
(default: FALSE)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_main">main</code></td>
<td>
<p>(optional) Legend main title. (default: NULL)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_cex.main">cex.main</code></td>
<td>
<p>(optional) Font size in cex units for the main title. (default: <code>1.35 * cex</code>)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_mar.main">mar.main</code></td>
<td>
<p>(optional) Tells the function to reserve this many line heights for the main title. (default: 3.2)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_lines.main">lines.main</code></td>
<td>
<p>(optional) Tells the function to place the main title this many lines away from the plot edge.
(default: 1.5)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_colors.n">colors.n</code></td>
<td>
<p>(optional) The number of colors per dimension of the color scale. For single channel plots, this will be
equal to the number of colors in the color scale. For 2 channel plots, the number of colors is the square of this number.
(default 100).</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_legend.bg">legend.bg</code></td>
<td>
<p>(option) The color of the legend background. (default: <code>par('bg')</code>)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_legend.fg">legend.fg</code></td>
<td>
<p>(option) The color of the legend foreground. (default: <code>par('fg')</code>)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_resolution">resolution</code></td>
<td>
<p>Image resolution in pixels per inch, only for bitmap image output formats (currently
png only). (default: 72)</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_draw.legend.box.bool">draw.legend.box.bool</code></td>
<td>
<p>(option) Logical indicating whether bounding boxes should be drawn for the legends.</p>
</td></tr>
<tr><td><code id="gsnHierarchicalDendrogram_+3A_do_browser">DO_BROWSER</code></td>
<td>
<p>(option) Logical indicating whether browser() should be run for this function. (For debugging
purposes, will probably remove.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Outputs of type pdf, png, and svg are supported for file outputs. File type is automatically detected
from the file suffix, but can be overridden using the <code>out_format</code> argument.
</p>
<p>Open symbols (with border and a fill color, <code>pch </code><code class="reqn">\in</code><code> ( 21, 22, 23, 24, 25 )</code>) are
used by default on dendextend versions &lt; '1.16.0' for horizontal dendrograms. For earlier versions, and with circular
dendrograms, open symbols are currently unsupported.
</p>


<h3>Value</h3>

<p>An object of type 'dendrogram', with the attribute &quot;GSNA_plot_params&quot; containing a list of plot parameters.
This list is useful for retrieving plot parameters set by the function, so that they might be optimized. Likewise,
the dendrogram object itself can be replotted or analyzed by other means.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnPareNetGenericHierarchic">gsnPareNetGenericHierarchic</a></code>
<code><a href="#topic+gsnPlotNetwork">gsnPlotNetwork</a></code>
</p>

<hr>
<h2 id='gsnImportCERNO'>gsnImportCERNO</h2><span id='topic+gsnImportCERNO'></span>

<h3>Description</h3>

<p>Add a CERNO^1 analysis pathways result set to a GSNData object. The data set can be either in the
form of a data.frame or specified as import from a delimited text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnImportCERNO(
  object,
  pathways_data = NULL,
  filename = NULL,
  id_col = NULL,
  stat_col = NULL,
  sig_order = NULL,
  n_col = NULL,
  sep = "\t"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnImportCERNO_+3A_object">object</code></td>
<td>
<p>A GSNData object.</p>
</td></tr>
<tr><td><code id="gsnImportCERNO_+3A_pathways_data">pathways_data</code></td>
<td>
<p>An (optional) data.frame containing the results of CERNO analysis. (Either this or the
<code>filename</code> argument must be set.</p>
</td></tr>
<tr><td><code id="gsnImportCERNO_+3A_filename">filename</code></td>
<td>
<p>An (optional) filename for data sets read from a text file containing CERNO results. This is ignored
if the <code>pathways_data</code> argument is set.</p>
</td></tr>
<tr><td><code id="gsnImportCERNO_+3A_id_col">id_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a key for gene
sets or modules. This is normally the <code>ID</code> field of CERNO data, which must be the same as the names of gene sets
specified in the tmod object or in the list of gene set vectors specified with the <code>geneSetCollection</code> argument
used when building the gene set network. By default this value is <code>'ID'</code>, however if the user has added additional
IDs to a CERNO results set, such as GO_ACCESSION, that can be specified here. The IDs must correspond to the names of
the gene sets provided, or an error will be thrown.</p>
</td></tr>
<tr><td><code id="gsnImportCERNO_+3A_stat_col">stat_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a statistic
to evaluate the quality of pathways results. By default, this is 'adj.P.val' for CERNO.</p>
</td></tr>
<tr><td><code id="gsnImportCERNO_+3A_sig_order">sig_order</code></td>
<td>
<p>(optional) Either <code>'loToHi'</code> (default) or <code>'hiToLo'</code> depending on the statistic used to
evaluate pathways results.</p>
</td></tr>
<tr><td><code id="gsnImportCERNO_+3A_n_col">n_col</code></td>
<td>
<p>(optional) Specifies the column containing the number of genes in the gene set. Generally, this is the number
of genes in the gene set that are attested in an expression data set (Defaults to 'N1').</p>
</td></tr>
<tr><td><code id="gsnImportCERNO_+3A_sep">sep</code></td>
<td>
<p>A separator for text file import, defaults to &quot;\t&quot;. Ignored if the <code>filename</code> argument is not specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method imports a CERNO^1 data set created by the tmod^2 package into a GSNData object.
</p>
<p>Note: An error is thrown if all gene set IDs in the genePresenceAbsense are not present in the CERNO ID column.
On the other hand, if there are gene set IDs present in the pathways data that are absent from the genePresenceAbsence
matrix, then these methods emit a warning. It also checks for the standard CERNO data set column names, and if some are
missing, it will throw an error. They can still be imported via <code>gsnImportGenericPathways</code>.
</p>


<h3>Value</h3>

<p>This returns a GSNData object containing imported pathways data.
</p>


<h3>References</h3>


<ol>
<li><p> Zyla J, Marczyk M, Domaszewska T, Kaufmann SHE, Polanska J, Weiner J. Gene set enrichment for reproducible science: comparison of CERNO and eight other algorithms. <em>Bioinformatics</em>. 2019;<strong>35</strong>: 5146–5154. doi:10.1093/bioinformatics/btz447
</p>
</li>
<li><p> Weiner 3rd J, Domaszewska T. tmod: an R package for general and multivariate enrichment analysis. <em>PeerJ Preprints</em>; 2016 Sep. doi:10.7287/peerj.preprints.2420v1
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+gsnAddPathwaysData">gsnAddPathwaysData</a></code>
<code><a href="#topic+gsnImportGSEA">gsnImportGSEA</a></code>
<code><a href="#topic+gsnImportGSNORA">gsnImportGSNORA</a></code>
<code><a href="#topic+gsnImportGenericPathways">gsnImportGenericPathways</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnImportCERNO( sig_pathways.GSN,
                                    pathways_data = sig_pathways.cerno )

</code></pre>

<hr>
<h2 id='gsnImportDAVID'>gsnImportDAVID</h2><span id='topic+gsnImportDAVID'></span>

<h3>Description</h3>

<p>Add DAVID search data to a GSNData object, as generated by the the DAVID web application
(<a href="https://david.ncifcrf.gov/">https://david.ncifcrf.gov/</a>) output using either the
&quot;Functional Annotation Chart&quot; or &quot;Functional Annotation Cluster&quot; results output options. The data set
can be either in the form of a data.frame or specified as import from an output text file. (See Details below)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnImportDAVID(
  object,
  pathways_data = NULL,
  filename = NULL,
  id_col = NULL,
  stat_col = NULL,
  sig_order = NULL,
  n_col = NULL,
  sep = "\t"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnImportDAVID_+3A_object">object</code></td>
<td>
<p>A GSNData object.</p>
</td></tr>
<tr><td><code id="gsnImportDAVID_+3A_pathways_data">pathways_data</code></td>
<td>
<p>An (optional) data.frame containing the results of DAVID analysis. (Either this or the
<code>filename</code> argument must be set. Such a data.frame can be obtained by using the <code>read_david_data_file()</code>
function to parse a DAVID &quot;Functional Annotation Chart&quot; or &quot;Functional Annotation Cluster&quot; results text file with
the default options (output = &quot;flat&quot;, redundant = FALSE, sep = &quot;\t&quot;).</p>
</td></tr>
<tr><td><code id="gsnImportDAVID_+3A_filename">filename</code></td>
<td>
<p>An (optional) filename for data sets read from a text file containing DAVID results. This is ignored
if the <code>pathways_data</code> argument is set.</p>
</td></tr>
<tr><td><code id="gsnImportDAVID_+3A_id_col">id_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a key for gene
sets or modules. This is normally the <code>Term</code> field of DAVID data, which must be the same as the names of gene
sets in the gene set collection specified with the <code>geneSetCollection</code> argument used when building the gene
set network. By default this value is <code>'Term'</code>. The IDs must correspond to the names of the gene sets provided,
or an error will be thrown.</p>
</td></tr>
<tr><td><code id="gsnImportDAVID_+3A_stat_col">stat_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a statistic
to evaluate the quality of pathways results. The function scans through possible <code>stat_col</code> values
(&quot;FDR&quot;, &quot;Bonferroni&quot;, &quot;Benjamini&quot;, &quot;PValue&quot; ), and uses the first one it finds.</p>
</td></tr>
<tr><td><code id="gsnImportDAVID_+3A_sig_order">sig_order</code></td>
<td>
<p>(optional) Either <code>'loToHi'</code> (default) or <code>'hiToLo'</code> depending on the statistic used to
evaluate pathways results.</p>
</td></tr>
<tr><td><code id="gsnImportDAVID_+3A_n_col">n_col</code></td>
<td>
<p>(optional) Specifies the column containing the number of genes in the gene set. Generally, this is the number
of genes in the gene set that are attested in an expression data set (Defaults to 'Count', if that is present, otherwise</p>
</td></tr>
<tr><td><code id="gsnImportDAVID_+3A_sep">sep</code></td>
<td>
<p>A separator for text file import, defaults to &quot;\t&quot;. Ignored if <code>filename</code> is not specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: An error is thrown if all gene set IDs in the genePresenceAbsense are not present in the GSEA <code>NAME</code> column.
However, if there are gene set IDs present in the pathways data that are absent from the <code>$genePresenceAbsence</code>
matrix, then this method emits a warning. It also checks for the standard GSEA data set column names, and if some are
missing, it will emit a warning.
</p>


<h3>Value</h3>

<p>This returns a GSNData object containing imported pathways data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnAddPathwaysData">gsnAddPathwaysData</a></code>
<code><a href="#topic+gsnImportCERNO">gsnImportCERNO</a></code>
<code><a href="#topic+gsnImportGSNORA">gsnImportGSNORA</a></code>
<code><a href="#topic+gsnImportGenericPathways">gsnImportGenericPathways</a></code>
</p>

<hr>
<h2 id='gsnImportGenericPathways'>gsnImportGenericPathways</h2><span id='topic+gsnImportGenericPathways'></span>

<h3>Description</h3>

<p>Import a data.frame or text file containing a pathways result set to a GSNData object.
The <code>id_col</code> and <code>stat_col</code> should be specified, but if they are not, the function attempts to guess.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnImportGenericPathways(
  object,
  pathways_data = NULL,
  filename = NULL,
  type = "generic",
  id_col = NULL,
  stat_col = NULL,
  stat_col_2 = NULL,
  sig_order = NULL,
  sig_order_2 = NULL,
  n_col = NULL,
  sep = "\t"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnImportGenericPathways_+3A_object">object</code></td>
<td>
<p>A GSNData object.</p>
</td></tr>
<tr><td><code id="gsnImportGenericPathways_+3A_pathways_data">pathways_data</code></td>
<td>
<p>An (optional) data.frame containing the pathways analysis. (Either this or the
<code>filename</code> argument must be set.</p>
</td></tr>
<tr><td><code id="gsnImportGenericPathways_+3A_filename">filename</code></td>
<td>
<p>An (optional) filename for data sets read from a text file containing pathways results. This is ignored
if the <code>pathways_data</code> argument is set.</p>
</td></tr>
<tr><td><code id="gsnImportGenericPathways_+3A_type">type</code></td>
<td>
<p>A character vector of length 1 indicating the type of result set. This defaults to <code>'generic'</code>.</p>
</td></tr>
<tr><td><code id="gsnImportGenericPathways_+3A_id_col">id_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a key for gene
sets or modules. This should be the same as the set of names of gene sets in the gene set collection specified by the
<code>geneSetCollection</code> argument used in building gene set networks. If not specified, the function will search for
<code>"ID"</code>, <code>"id"</code>, <code>"NAME"</code> &amp; <code>"Term"</code> in the data set's column names, in that order, taking the first
one it finds. The values in the column must correspond to the names of the gene sets provided, or an error will be thrown.</p>
</td></tr>
<tr><td><code id="gsnImportGenericPathways_+3A_stat_col">stat_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a statistic
to evaluate the quality of pathways results. If unspecified, the function uses regular expressions to search for
a column that is labeled as a p-value or p-adj.</p>
</td></tr>
<tr><td><code id="gsnImportGenericPathways_+3A_stat_col_2">stat_col_2</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as an optional
second statistic to evaluate the quality of pathways results. If unspecified, the value is NULL.</p>
</td></tr>
<tr><td><code id="gsnImportGenericPathways_+3A_sig_order">sig_order</code></td>
<td>
<p>(optional) Either <code>'loToHi'</code> (default) or <code>'hiToLo'</code> depending on the statistic used to
evaluate pathways results.</p>
</td></tr>
<tr><td><code id="gsnImportGenericPathways_+3A_sig_order_2">sig_order_2</code></td>
<td>
<p>(optional) Either <code>'loToHi'</code> (default) or <code>'hiToLo'</code> depending on the <code>stat_col_2</code>
statistic used to evaluate pathways results.</p>
</td></tr>
<tr><td><code id="gsnImportGenericPathways_+3A_n_col">n_col</code></td>
<td>
<p>(optional) The name of a pathways data column that contains gene set size information. If unset, the
function will scan for the strings <code>'N1'</code>, <code>'N'</code>, <code>'SIZE'</code>, and <code>'Count'</code>, taking the fist one it finds.</p>
</td></tr>
<tr><td><code id="gsnImportGenericPathways_+3A_sep">sep</code></td>
<td>
<p>A separator for text file import, defaults to &quot;\t&quot;. Ignored if the <code>filename</code> argument is not specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a GSNData object containing imported pathways data.
</p>
<p>Note: An error is thrown if all gene set IDs in the <code>$genePresenceAbsence</code> field are not present in the GSNORA ID
column. On the other hand, if there are gene set IDs present in the pathways data that are absent from the
genePresenceAbsence matrix, then these methods emit a warning. It also checks for the standard GSNORA data set column
names, and if some are missing, it will throw an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnAddPathwaysData">gsnAddPathwaysData</a></code>
<code><a href="#topic+gsnImportCERNO">gsnImportCERNO</a></code>
<code><a href="#topic+gsnImportGSEA">gsnImportGSEA</a></code>
<code><a href="#topic+gsnImportGenericPathways">gsnImportGenericPathways</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data. Generic import can work with most types of data,
# and we can manually specify id_col, stat_col, n_col:
sig_pathways.GSN &lt;- gsnImportGenericPathways( sig_pathways.GSN,
                                              pathways_data = sig_pathways.cerno,
                                              id_col = 'ID',
                                              stat_col = 'adj.P.Val',
                                              sig_order = 'loToHi',
                                              n_col = 'N1'
                                               )

</code></pre>

<hr>
<h2 id='gsnImportGSEA'>gsnImportGSEA</h2><span id='topic+gsnImportGSEA'></span>

<h3>Description</h3>

<p>Add GSEA search data to a GSNData object, as generated by the the GSEA package. The data set can be
either in the form of a data.frame or specified as import from a delimited text file. (See Details below)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnImportGSEA(
  object,
  pathways_data = NULL,
  filename = NULL,
  id_col = NULL,
  stat_col = NULL,
  sig_order = NULL,
  n_col = NULL,
  sep = "\t"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnImportGSEA_+3A_object">object</code></td>
<td>
<p>A GSNData object.</p>
</td></tr>
<tr><td><code id="gsnImportGSEA_+3A_pathways_data">pathways_data</code></td>
<td>
<p>An (optional) data.frame containing the results of GSEA analysis. (Either this or the
<code>filename</code> argument must be set.</p>
</td></tr>
<tr><td><code id="gsnImportGSEA_+3A_filename">filename</code></td>
<td>
<p>An (optional) filename for data sets read from a text file containing GSEA results. This is ignored
if the <code>pathways_data</code> argument is set.</p>
</td></tr>
<tr><td><code id="gsnImportGSEA_+3A_id_col">id_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a key for gene
sets or modules. This is normally the <code>NAME</code> field of GSEA data, which must be the same as the names of gene
sets specified in the tmod object or in the list of gene set vectors specified with the <code>geneSetCollection</code>
argument used when building the gene set network. By default this value is <code>'NAME'</code>. The IDs must correspond
to the names of the gene sets provided, or an error will be thrown. <strong>NOTE:</strong> In the tmod::tmodImportMSigDB function
provided by the tmod package, the default ID is an MSigDB accession, but GSEA data sets do not use this accession.
The <code>NAME</code> column used in GSEA results set corresponds instead to the <code>STANDARD_NAME</code> field in the MSigDB
XML database file. This <code>STANDARD_NAME</code> field is not preserved by the standard <code>tmod::tmodImportMSigDB</code>
utility function, but instead reformatted converting underscores to spaces and non-initial letters to lower case.
Therefore, when using GSEA data sets with an MSigDB gene set collection imported using <code>tmod::tmodImportMSigDB</code>
the <code>NAME</code> fields need to be mapped to the <code>ID</code> or vice versa.</p>
</td></tr>
<tr><td><code id="gsnImportGSEA_+3A_stat_col">stat_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a statistic
to evaluate the quality of pathways results. The function scans through possible <code>stat_col</code> values
(<code>"FDR q-val"</code>, <code>"FDR.q.val"</code>, <code>"FWER p-val"</code>, <code>"FWER.p.val"</code>, <code>"NOM p-val"</code>,
<code>"NOM.p.val"</code>), and uses the first one it finds. (The presence of spaces and hyphens in the column names
necessitates flexibility here. Depending on how GSEA results sets are read in, spaces and hyphens may be substituted
with periods.)</p>
</td></tr>
<tr><td><code id="gsnImportGSEA_+3A_sig_order">sig_order</code></td>
<td>
<p>(optional) Either <code>'loToHi'</code> (default) or <code>'hiToLo'</code> depending on the statistic used to
evaluate pathways results.</p>
</td></tr>
<tr><td><code id="gsnImportGSEA_+3A_n_col">n_col</code></td>
<td>
<p>(optional) Specifies the column containing the number of genes in the gene set. Generally, this is the number
of genes in the gene set that are attested in an expression data set (Defaults to 'SIZE').</p>
</td></tr>
<tr><td><code id="gsnImportGSEA_+3A_sep">sep</code></td>
<td>
<p>A separator for text file import, defaults to &quot;\t&quot;. Ignored if <code>filename</code> is not specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GSEA results directories generally contain files with names beginning with <code>gsea_report_for_</code> and with
the <code>.xls</code> suffix. This method is designed to handle such data sets.
</p>
<p>Note: An error is thrown if all gene set IDs in the genePresenceAbsense are not present in the GSEA <code>NAME</code> column.
However, if there are gene set IDs present in the pathways data that are absent from the <code>$genePresenceAbsence</code>
matrix, then this method emits a warning. It also checks for the standard GSEA data set column names, and if some are
missing, it will emit a warning.
</p>


<h3>Value</h3>

<p>This returns a GSNData object containing imported pathways data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnAddPathwaysData">gsnAddPathwaysData</a></code>
<code><a href="#topic+gsnImportCERNO">gsnImportCERNO</a></code>
<code><a href="#topic+gsnImportGSNORA">gsnImportGSNORA</a></code>
<code><a href="#topic+gsnImportGenericPathways">gsnImportGenericPathways</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# In this example, we generate a gene set network from GSEA example
# data. We begin by subsetting the GSEA data for significant results:
sig_pathways.gsea &lt;- subset( Bai_CiHep_dorothea_DN.Gsea, `FDR q-val` &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant GSEA results, by subsetting Bai_gsc.tmod using
# the gene set NAME as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.gsea$NAME]

# And obtain a background gene set from the expression data used
# to generate the gsea results:
background_genes &lt;- toupper( rownames( Bai_empty_expr_mat ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkSTLF(geneSetCollection = sig_pathways.tmod,
                           ref.background = background_genes )

# Now import the GSEA data.
sig_pathways.GSN &lt;- gsnImportGSEA( sig_pathways.GSN,
                                   pathways_data = sig_pathways.gsea )

</code></pre>

<hr>
<h2 id='gsnImportGSNORA'>gsnImportGSNORA</h2><span id='topic+gsnImportGSNORA'></span>

<h3>Description</h3>

<p>Add GSNORA search data to a GSNData object, as generated by the <code>gsnORAtest</code> function in this package.
The data set can be either in the form of a data.frame or specified as import from a delimited text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnImportGSNORA(
  object,
  pathways_data = NULL,
  filename = NULL,
  id_col = NULL,
  stat_col = NULL,
  sig_order = NULL,
  n_col = NULL,
  sep = "\t"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnImportGSNORA_+3A_object">object</code></td>
<td>
<p>A GSNData object.</p>
</td></tr>
<tr><td><code id="gsnImportGSNORA_+3A_pathways_data">pathways_data</code></td>
<td>
<p>An (optional) data.frame containing the results of GSNORA analysis. (Either this or the
<code>filename</code> argument must be set.</p>
</td></tr>
<tr><td><code id="gsnImportGSNORA_+3A_filename">filename</code></td>
<td>
<p>An (optional) filename for data sets read from a text file containing GSNORA results. This is ignored
if the <code>pathways_data</code> argument is set.</p>
</td></tr>
<tr><td><code id="gsnImportGSNORA_+3A_id_col">id_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a key for gene
sets or modules. This is normally the <code>ID</code> field of GSNORA data, which must be the same as the names of gene sets
specified in the tmod object or in the list of gene set vectors specified with the <code>geneSetCollection</code> argument
used when building the gene set network. By default this value is <code>'ID'</code>, however if the user has added additional
IDs to a CERNO results set, such as <code>GO_ACCESSION</code>, that can be specified here. The IDs must correspond to the names
of the gene sets provided, or an error will be thrown.</p>
</td></tr>
<tr><td><code id="gsnImportGSNORA_+3A_stat_col">stat_col</code></td>
<td>
<p>(optional) A character vector of length 1 indicating the name of the column used as a statistic
to evaluate the quality of pathways results. By default, this is <code>'adj.P.1S'</code> for GSNORA.</p>
</td></tr>
<tr><td><code id="gsnImportGSNORA_+3A_sig_order">sig_order</code></td>
<td>
<p>(optional) Either <code>'loToHi'</code> (default) or <code>'hiToLo'</code> depending on the statistic used to
evaluate pathways results.</p>
</td></tr>
<tr><td><code id="gsnImportGSNORA_+3A_n_col">n_col</code></td>
<td>
<p>(optional) Specifies the column containing the number of genes in the gene set. Generally, this is the number
of genes in the gene set that are attested in an expression data set (Defaults to 'N').</p>
</td></tr>
<tr><td><code id="gsnImportGSNORA_+3A_sep">sep</code></td>
<td>
<p>A separator for text file import, defaults to &quot;\t&quot;. Ignored if the <code>filename</code> argument is not specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a GSNData object containing imported pathways data.
</p>
<p>Note: An error is thrown if all gene set IDs in the genePresenceAbsense are not present in the GSNORA ID column.
On the other hand, if there are gene set IDs present in the pathways data that are absent from the genePresenceAbsence
matrix, then these methods emit a warning. It also checks for the standard GSNORA data set column names, and if some are
missing, it will throw an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnAddPathwaysData">gsnAddPathwaysData</a></code>
<code><a href="#topic+gsnImportCERNO">gsnImportCERNO</a></code>
<code><a href="#topic+gsnImportGSEA">gsnImportGSEA</a></code>
<code><a href="#topic+gsnImportGenericPathways">gsnImportGenericPathways</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# In this example, we run gsnORAtest() to generate a list of significant
# pathways, which we use to construct a gene set network.

library(GSNA)

# From a differential expression data set, we can generate a subset of genes
# with significant differential expression, up or down. Here we will extract
# genes with significant negative differential expression with
# avg_log2FC &lt; 0 and p_val_adj &lt;= 0.05 from **Seurat** data:

sig_DN.genes &lt;-
   toupper( rownames(subset( Bai_CiHep_v_Fib2.de,
                             avg_log2FC &lt; 0  &amp; p_val_adj &lt; 0.05 )) )

# Using all the genes in the differential expression data set, we can obtain
# a suitable background:
bg &lt;- toupper(rownames( Bai_CiHep_v_Fib2.de ))

# Now, we can do a overrepresentation analysis search on this data using the
# Bai_gsc.tmod gene set collection included in the sample data:
sig_DN.gsnora &lt;- gsnORAtest( l = sig_DN.genes,
                             bg = bg,
                             geneSetCollection = Bai_gsc.tmod )

# Generate a GSC (gene set collection) from the significant gene sets:
sig.gsnora.tmod &lt;- Bai_gsc.tmod[sig_DN.gsnora$ID]

bg &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build gene set network from the GSC
sig.gsnora.GSN &lt;- buildGeneSetNetworkSTLF( ref.background =  bg,
                                           geneSetCollection = sig.gsnora.tmod )

sig.gsnora.GSN &lt;- gsnImportGSNORA( sig.gsnora.GSN, sig_DN.gsnora )


</code></pre>

<hr>
<h2 id='gsnMergePathways'>gsnMergePathways</h2><span id='topic+gsnMergePathways'></span>

<h3>Description</h3>

<p>Merge pathways data and subnets into a data.frame that includes subnet assignment and intra-subnet rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnMergePathways(
  object,
  pathways.data = NULL,
  distance = NULL,
  id_col = NULL,
  stat_col = NULL,
  sig_order = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnMergePathways_+3A_object">object</code></td>
<td>
<p>A GSNData object upon which <code>gsnAssignSubnets()</code> has been called.</p>
</td></tr>
<tr><td><code id="gsnMergePathways_+3A_pathways.data">pathways.data</code></td>
<td>
<p>(optional) data.frame containing a pathways results. Not necessary if pathways data have already
been imported.</p>
</td></tr>
<tr><td><code id="gsnMergePathways_+3A_distance">distance</code></td>
<td>
<p>(optional) character vector of length 1 indicating which set of subnets to be used if the GSNData object
contains subnets derived from more than one distance matrix.</p>
</td></tr>
<tr><td><code id="gsnMergePathways_+3A_id_col">id_col</code></td>
<td>
<p>(optional) ID column to be used for merging subnets. Defaults to the value of <code>id_col</code> already set
during import of pathways data, if that has already been done.</p>
</td></tr>
<tr><td><code id="gsnMergePathways_+3A_stat_col">stat_col</code></td>
<td>
<p>(optional) The name of the column column containing the statistic to be used for ordering subnets
and performing intra-subnet ranking. Defaults to the value of <code>stat_col</code> already set during import of pathways
data, if that has already been done.</p>
</td></tr>
<tr><td><code id="gsnMergePathways_+3A_sig_order">sig_order</code></td>
<td>
<p>(optional) Character vector of length 1 indicating the whether low values of the statistic are most
significant (&quot;loToHi&quot;, the default) or high values (&quot;hiToLo&quot;) for ordering subnets and performing. Defaults to the
value of <code>sig_order</code> already set during import of pathways data, if that has already been done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the standard workflow, just the object parameter is generally necessary. If subnets have been calculated for
multiple distance matrices and the subnets desired are not associated with the current default distance, then the
<code>distance</code> parameter can be specified.
</p>


<h3>Value</h3>

<p>A data.frame containing pathways data with merged subnet assignments and subnetRank values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnAddPathwaysData">gsnAddPathwaysData</a>()</code>
<code><a href="#topic+gsnImportCERNO">gsnImportCERNO</a>()</code>
<code><a href="#topic+gsnImportGSNORA">gsnImportGSNORA</a>()</code>,
<code><a href="#topic+gsnImportGSEA">gsnImportGSEA</a>()</code>
<code><a href="#topic+gsnImportGenericPathways">gsnImportGenericPathways</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnImportCERNO( sig_pathways.GSN,
                                    pathways_data = sig_pathways.cerno )

# Now we can pare the network and assign subnets:
sig_pathways.GSN &lt;- gsnPareNetGenericHierarchic( object = sig_pathways.GSN )
sig_pathways.GSN &lt;- gsnAssignSubnets(  object = sig_pathways.GSN )

# Now, we can use gsnMergePathways to output a table of pathway data
# with merged subnets:
gsnMergePathways( sig_pathways.GSN )


</code></pre>

<hr>
<h2 id='gsnORAtest'>gsnORAtest</h2><span id='topic+gsnORAtest'></span>

<h3>Description</h3>

<p>Perform an ORA test using an experimentally-derived gene set to query a gene set collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnORAtest(l, bg, geneSetCollection, Alpha = 0.05, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnORAtest_+3A_l">l</code></td>
<td>
<p>A vector containing an experimentally-derived set of genes. These may be significantly differentially
expressed genes, genes with differential chromatin accessibility or positives from a screen.</p>
</td></tr>
<tr><td><code id="gsnORAtest_+3A_bg">bg</code></td>
<td>
<p>A vector containing a background of observable genes.</p>
</td></tr>
<tr><td><code id="gsnORAtest_+3A_genesetcollection">geneSetCollection</code></td>
<td>
<p>A gene set collection to query, either a tmod object or a list of character vectors containing
gene sets for which the list element names are the gene set IDs.</p>
</td></tr>
<tr><td><code id="gsnORAtest_+3A_alpha">Alpha</code></td>
<td>
<p>The alpha value setting the significance cutoff adjusted p-value.</p>
</td></tr>
<tr><td><code id="gsnORAtest_+3A_full">full</code></td>
<td>
<p>This gives additional data in the results set, specifically the contingency table values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is provided to allow rapid and easy overrepresentation analysis using an unordered experimental
gene set to query a gene set collection that may be either an arbitrary list of gene-sets, or an <code>tmod</code> class
gene set collection. The statistical tests provided include both the standard two-sided Fisher and a 1-sided Fisher
test, similar to what is provided by the DAVID pathways analysis web application(2).
</p>
<p>If a list of gene sets is provided as the <code>geneSetCollection</code> argument, it must be structured as a list of
character vectors containing gene symbols (or whatever identifiers are used for the supplied experimental gene set),
</p>


<h3>Value</h3>

<p>Returns a data.frame with an ORA (overrepresentation analysis) results set containing the following columns:
</p>

<ul>
<li><p><em>ID</em>: the gene set identifiers.
</p>
</li>
<li><p><em>Title</em>: The &quot;Title&quot; field from <code>tmod</code> class gene set collection objects, corresponding to the reformatted
<code>STANDARD_NAME</code> field in an MSigDB xml file, with spaces substituted for underscores and initial only
uppercase. <strong>NOTE:</strong> If the search is done using a list of gene sets rather than a <code>tmod</code> object, this
column will contain NA.
</p>
</li>
<li><p><em>a</em>: the number of genes observed in the background but not in <em>l</em> or the queried gene set. (present
only if <code>full == TRUE</code>)
</p>
</li>
<li><p><em>b</em>: the number of observed genes in <em>l</em> but not the queried gene set. (present only if <code>full == TRUE</code>)
</p>
</li>
<li><p><em>c</em>: the number of observed genes in the queried gene set but not <em>l</em>. (present only if <code>full == TRUE</code>)
</p>
</li>
<li><p><em>d</em>: the number of observed genes in both <em>l</em> and the queried gene set, i.e. the overlap.  (present only
if <code>full == TRUE</code>)
</p>
</li>
<li><p><em>N</em>: the number of observed genes the queried gene set.
</p>
</li>
<li><p><em>Enrichment</em>: The fold overrepresentation of genes in the overlap set <em>d</em> calculated as:
</p>
<p style="text-align: center;"><code class="reqn">E = (d / (c+d)) / ((b+d)/(a+b+c+d))</code>
</p>


</li>
<li><p><em>P_2S</em>: 2-sided Fisher <em>p</em>-value. (<em>NOT</em> log-transformed, present only if <code>full == TRUE</code>)
</p>
</li>
<li><p><em>adj.P.2S</em>: 2-sided Fisher <em>p</em>-value corrected using the method of Benjamini &amp; Hochberg(1) and implemented in
the <code>stats</code> package. (present only if <code>full == TRUE</code>)
</p>
</li>
<li><p><em>P_1S</em>: 1-sided Fisher <em>p</em>-value. (<em>NOT</em> log-transformed.)
</p>
</li>
<li><p><em>adj.P.1S</em>: 1-sided Fisher <em>p</em>-value corrected using the method of Benjamini &amp; Hochberg(1) and implemented in
the <code>stats</code> package. (present only if <code>full == TRUE</code>)
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> Benjamini, Y., and Hochberg, Y. (1995). Controlling the false discovery rate: a practical and powerful approach to multiple testing. <em>Journal of the Royal Statistical Society Series B</em>, <strong>57</strong>, 289–300. &lt;<a href="http://www.jstor.org/stable/2346101">http://www.jstor.org/stable/2346101</a>&gt;.
</p>
</li>
<li><p> Dennis G Jr, Sherman BT, Hosack DA, Yang J, Gao W, Lane HC, Lempicki RA. (2003). DAVID: Database for Annotation, Visualization, and Integrated Discovery. <em>Genome Biol.</em>, <strong>4</strong>(5):P3. Epub 2003 Apr 3.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+gsnORAtest_cpp">gsnORAtest_cpp</a></code>
<code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# From a differential expression data set, we can generate a
# subset of genes with significant differential expression,
# up or down. Here we will extract genes with significant
# negative differential expression with
# avg_log2FC &lt; 0 and p_val_adj &lt;= 0.05 from **Seurat** data:

sig_DN.genes &lt;-
   toupper( rownames(subset( Bai_CiHep_v_Fib2.de,
                       avg_log2FC &lt; 0  &amp; p_val_adj &lt; 0.05 )))

# Using all the genes in the differential expression data set,
# we can obtain a suitable background:
bg &lt;- toupper(rownames( Bai_CiHep_v_Fib2.de ))

# Now, we can do a overrepresentation analysis search on this
# data using the Bai_gsc.tmod gene set collection included in
# the sample data:
sig_DN.gsnora &lt;- gsnORAtest( l = sig_DN.genes,
                             bg = bg,
                             geneSetCollection = Bai_gsc.tmod )

</code></pre>

<hr>
<h2 id='gsnORAtest_cpp'>gsnORAtest_cpp</h2><span id='topic+gsnORAtest_cpp'></span>

<h3>Description</h3>

<p>This function performs ORA analysis and returns a data.frame containing various statistics including
fold enrichment, and 1 and 2-tailed p-values. (see details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnORAtest_cpp(l, bg, geneSetCollection)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnORAtest_cpp_+3A_l">l</code></td>
<td>
<p>(required) A character vector containing a list of gene identifiers. These are generally differentially
expressed genes either genes significantly up or significantly down, but they can also be a list of genes that came
out of a genetic screen, gene loci with differential chromatin accessibility generated by ATAC-Seq data, lists of genes
from GWAS, etc. The order of the genes is unimportant.</p>
</td></tr>
<tr><td><code id="gsnORAtest_cpp_+3A_bg">bg</code></td>
<td>
<p>(required) A character vector containing a list of gene identifiers corresponding to the total background of
observable genes.</p>
</td></tr>
<tr><td><code id="gsnORAtest_cpp_+3A_genesetcollection">geneSetCollection</code></td>
<td>
<p>(required) A list of gene sets, in which the gene sets are character vectors containing
gene symbols, and the list names are the corresponding gene set identifiers. NOTE: This must be a list, not a
<code>tmod</code> object. It is trivial to extract such a list from a <code>tmod</code> object, however. The
<code>$MODULES2GENES</code> field of the <code>tmod</code> object contains a suitable list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main workhorse function for the ORA test in the <code>GSNA</code> package, however, it performs
no filtering of the output data set, nor <em>p</em>-value adjustment, and most users of the package will want to use
<code>gsnORAtest()</code> function instead, which calculates adjusted <em>p</em>-values, filters the output data for
significance, and can include a <code>Title</code> field in the output data.frame.
</p>


<h3>Value</h3>

<p>A data frame containing the results of overrepresentation analysis.
</p>

<ul>
<li><p><em>ID</em>: the gene set identifiers.
</p>
</li>
<li><p><em>a</em>: the number of genes observed in the background but not in <em>l</em> or the queried gene set.
</p>
</li>
<li><p><em>b</em>: the number of observed genes in <em>l</em> but not the queried gene set.
</p>
</li>
<li><p><em>c</em>: the number of observed genes in the queried gene set but not <em>l</em> and
</p>
</li>
<li><p><em>d</em>: the number of observed genes in both <em>l</em> and the queried gene set, i.e. the overlap.
</p>
</li>
<li><p><em>N</em>: the number of observed genes the queried gene set.
</p>
</li>
<li><p><em>Enrichment</em>: The fold overrepresentation of genes in the overlap set <em>d</em> calculated as:
</p>
<p style="text-align: center;"><code class="reqn">E = (d / (c+d)) / ((b+d)/(a+b+c+d))</code>
</p>


</li>
<li><p><em>P_2S</em>: 2-sided Fisher <em>p</em>-value. (<em>NOT</em> log-transformed.)
</p>
</li>
<li><p><em>P_1S</em>: 1-sided Fisher <em>p</em>-value. (<em>NOT</em> log-transformed.)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+gsnORAtest">gsnORAtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# From a differential expression data set, we can generate a
# subset of genes with significant differential expression,
# up or down. Here we will extract genes with significant
# negative differential expression with
# avg_log2FC &lt; 0 and p_val_adj &lt;= 0.05 from **Seurat** data:

sig_DN.genes &lt;-
   toupper( rownames(subset( Bai_CiHep_v_Fib2.de,
                      avg_log2FC &lt; 0  &amp; p_val_adj &lt; 0.05 )) )

# Using all the genes in the differential expression data set,
# we can obtain a suitable background:
bg &lt;- rownames( Bai_CiHep_v_Fib2.de )

# Next we need a gene set collection in the form of a list of
# character vectors. We can convert the **Bai_gsc.tmod** object
# included in the sample data to such a list:
Bai.gsc &lt;- tmod2gsc( Bai_gsc.tmod )

# Now, we can do a overrepresentation analysis search on this
# data using **Bai.gsc**:
sig_DN.gsnora &lt;- gsnORAtest_cpp( l = sig_DN.genes,
                                 bg = bg,
                                 geneSetCollection = Bai.gsc )

</code></pre>

<hr>
<h2 id='gsnParedVsRawDistancePlot'>gsnParedVsRawDistancePlot</h2><span id='topic+gsnParedVsRawDistancePlot'></span>

<h3>Description</h3>

<p>A method for generating a bivariate plot of pared/scaled distances vs. raw distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnParedVsRawDistancePlot(object, distance = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnParedVsRawDistancePlot_+3A_object">object</code></td>
<td>
<p>An object of type <code>GSNData</code> containing a distance matrix.</p>
</td></tr>
<tr><td><code id="gsnParedVsRawDistancePlot_+3A_distance">distance</code></td>
<td>
<p>(optional) character vector of length 1 indicating which pared distance matrix is to be used for assigning
subnets. This defaults to the 'default_distance'.</p>
</td></tr>
<tr><td><code id="gsnParedVsRawDistancePlot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters to be passed to <code>plot.default()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A NULL value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnPareNetGenericHierarchic">gsnPareNetGenericHierarchic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now we can pare the network and assign subnets:
sig_pathways.GSN &lt;- gsnPareNetGenericHierarchic( object = sig_pathways.GSN )

# Create a pared vs raw distance plot to examine the relationship between the
# raw and pared distances:
gsnParedVsRawDistancePlot( sig_pathways.GSN )

</code></pre>

<hr>
<h2 id='gsnPareNetGenericHierarchic'>gsnPareNetGenericHierarchic</h2><span id='topic+gsnPareNetGenericHierarchic'></span>

<h3>Description</h3>

<p>Method to perform hierarchical clustering and paring of gene set networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnPareNetGenericHierarchic(
  object,
  distance = NULL,
  extreme = NULL,
  cutoff = NULL,
  keepOrphans = TRUE,
  matrix_scaling_fun = NULL,
  lower_is_closer = NULL,
  k = NULL,
  h = NULL,
  method = "average"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnPareNetGenericHierarchic_+3A_object">object</code></td>
<td>
<p>An object of type <code>GSNData</code> containing a distance matrix.</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericHierarchic_+3A_distance">distance</code></td>
<td>
<p>(optional) character vector of length 1 indicating which pared distance matrix is to be used for assigning
subnets. This defaults to the 'default_distance'.</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericHierarchic_+3A_extreme">extreme</code></td>
<td>
<p>(optional) Either <code>min</code> or <code>max</code> indicating whether low or high values are most significant,
i.e. to be interpreted as the shortest distance for nearest neighbor paring. This defaults to the value set for the
<code>optimal_extreme</code> field of the specified <code>distance</code> matrix.</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericHierarchic_+3A_cutoff">cutoff</code></td>
<td>
<p>(optional) A cutoff specifying a maximal of minimal value that will be retained, dependent on the distance
metric being used. This is not usually necessary to specify for hierarchical clustering. (see details)</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericHierarchic_+3A_keeporphans">keepOrphans</code></td>
<td>
<p>A boolean indicating whether 'orphan' gene sets that have no nearest neighbors should be retained in
the final network. (default <code>TRUE</code> )</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericHierarchic_+3A_matrix_scaling_fun">matrix_scaling_fun</code></td>
<td>
<p>A function to perform transformation and scaling of the distance matrix. The default,
<code>distMat2UnitNormRank</code> converts the distance matrix to ranks and scales the resulting numbers to a range between 0 and 1.
If set to NULL, the distances are not scaled or transformed. (see details)</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericHierarchic_+3A_lower_is_closer">lower_is_closer</code></td>
<td>
<p>Boolean indicating that lower values should be treated as closer for the sake of hierarchical
clustering.</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericHierarchic_+3A_k">k</code></td>
<td>
<p>(optional) Parameter passed to cutree to determine the number of desired clusters. If both k and h are NULL,
a value for k will be chosen. (see details)</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericHierarchic_+3A_h">h</code></td>
<td>
<p>(optional) Parameter passed to cutree to determine the cutting height for breaking the clusters into groups.
(see details)</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericHierarchic_+3A_method">method</code></td>
<td>
<p>(optional) Parameter passed to <code>hclust()</code> to specify the hierarchical clustering method used.
(default &quot;average&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method performs hierarchical clustering, then joins the members of each cluster. This joining occurs as
follows:
</p>

<ol>
<li><p> First, only the edges between gene sets belonging to the same hierarchical cluster are considered, and the
edges within each cluster are ordered by distance.
</p>
</li>
<li><p> The first edge is the edge defined by the shortest distance.
</p>
</li>
<li><p> Subsequent edges are added to the subnet by selecting the shortest from the edges shared by one joined  and
one unjoined gene set.
</p>
</li>
<li><p> This process is repeated until all gene sets in a cluster are joined as a subnet.
</p>
</li></ol>

<p>This joining method differs from nearest neighbor joining in that unjoined nodes are initially joined, not to their
nearest neighbor necessarily, but to their nearest neighbor from among the nodes already joined together in a subnet.
This method avoids bifurcation of subnets that could occur by regular nearest neighbor joining.
</p>
<p>NOTE: The <code>matrix_scaling_fun</code> argument is a function that takes the distance matrix and transforms
it into scaled data appropriate for hierarchical clustering. (As such, it should return data with low values
indicating closer gene sets, as opposed to a Jaccard index where high values are closest.) Because this
function may transform the data from a scale where high values are close to one where low values are close,
such functions should return a matrix with a <code>lower_is_closer</code> attribute set as <code>TRUE</code> to indicate
that. If the <code>lower_is_closer</code> attribute is not set by <code>matrix_scaling_fun</code>, then it will be assumed
to be the same as the raw distance matrix, which may generate an error if the <code>optimal_extreme</code> of the
distance matrix is not <code>'min'</code>. This value will be used to set the corresponding
<code>$distances[[distance]]$pared_optimal_extreme</code> field in the GSNData object. In general, a scaling
transformation is necessary because some potential distance metrics are in log-space and have skewed
distributions and negative values (like log Fisher) or are actually similarity metrics, with higher values
being closer. In this way they differ from standard distances, and require transformation to be suitable for
hierarchical clustering. The default, <code>matrix_scaling_fun</code> argument, <code><a href="#topic+distMat2UnitNormRank">distMat2UnitNormRank</a>()</code>
scales the data to a range between 0 and 1, and converts it to a uniform distribution. This may be a bit
extreme for some purposes, but it allows the hierarchical clustering method to work simply with default values
for most users obviating the need to transform the data or adjust default parameters in many cases. Other
values for this argument are <code><a href="base.html#topic+identity">identity</a>()</code> (which can be used when a transformation is not
desired) and <code><a href="#topic+complement">complement</a>()</code> which for an input value <code class="reqn">x</code> returns <code class="reqn">1 - x</code>, useful for
transforming Jaccard indices and Szymkiewicz–Simpson overlap coefficients. To produce a plot of the relationship
between the raw and transformed/scaled pared distances, use <code><a href="#topic+gsnParedVsRawDistancePlot">gsnParedVsRawDistancePlot</a>()</code>.
</p>


<h3>Value</h3>

<p>A <code>GSNData</code> copy of the original <code>object</code> argument containing a pared distance matrix for the
specified distance metric.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnPareNetGenericToNearestNNeighbors">gsnPareNetGenericToNearestNNeighbors</a></code>
<code><a href="#topic+distMat2UnitNormRank">distMat2UnitNormRank</a></code>
<code><a href="#topic+gsnParedVsRawDistancePlot">gsnParedVsRawDistancePlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnImportCERNO( sig_pathways.GSN,
                                    pathways_data = sig_pathways.cerno )

# Now we can pare the network. By default, the distances are complemented
# and converted into ranks for the sake of generating a network.
sig_pathways.GSN &lt;- gsnPareNetGenericHierarchic( object = sig_pathways.GSN )

# However, for similarity metrics such as the Jaccard index or Simkiewicz-
# Simpson overlap coefficient, with a domain of 0 to 1, in which higher
# values are "closer", \code{\link{complement}()} might be a good
# transformation as well.
sig_pathways.GSN &lt;- gsnPareNetGenericHierarchic( object = sig_pathways.GSN,
                                           matrix_scaling_fun = complement )


</code></pre>

<hr>
<h2 id='gsnPareNetGenericToNearestNNeighbors'>gsnPareNetGenericToNearestNNeighbors</h2><span id='topic+gsnPareNetGenericToNearestNNeighbors'></span>

<h3>Description</h3>

<p>General method to pare GSNData distance matrices to nearest neighbor subset, applying any low or high value
cutoffs that may be required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnPareNetGenericToNearestNNeighbors(
  object,
  distance = NULL,
  extreme = NULL,
  cutoff = 0,
  keepOrphans = TRUE,
  N = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnPareNetGenericToNearestNNeighbors_+3A_object">object</code></td>
<td>
<p>An object of type <code>GSNData</code> containing a distance matrix.</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericToNearestNNeighbors_+3A_distance">distance</code></td>
<td>
<p>(optional) character vector of length 1 indicating which pared distance matrix is to be used for assigning
subnets. This defaults to the 'default_distance'.</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericToNearestNNeighbors_+3A_extreme">extreme</code></td>
<td>
<p>(optional) Either <code>min</code> or <code>max</code> indicating whether low or high values are most significant,
i.e. to be interpreted as the shortest distance for nearest neighbor paring. This defaults to the value set for the
<code>optimal_extreme</code> field of the specified <code>distance</code> matrix.</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericToNearestNNeighbors_+3A_cutoff">cutoff</code></td>
<td>
<p>(optional) A cutoff specifying a maximal of minimal value that will be retained, dependent on the distance
metric being used. The default value is 0, but this is likely incorrect for most purposes. For 'lf' and 'stlf' distances,
we recommend a value of -90. For 'jaccard' distances, we recommend 0.3-0.4. (see details)</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericToNearestNNeighbors_+3A_keeporphans">keepOrphans</code></td>
<td>
<p>A boolean indicating whether 'orphan' gene sets that have no nearest neighbors should be retained in
the final network. (default <code>TRUE</code> )</p>
</td></tr>
<tr><td><code id="gsnPareNetGenericToNearestNNeighbors_+3A_n">N</code></td>
<td>
<p>Integer indicating the number of nearest neighbors to retain. (default 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method pares the GSN networks down to N nearest neighbors, with several tunable parameters. It is generally
useful to include a cutoff for this method to remove weak associations between gene sets, but this is heavily dependent on
the distance metric being used. A histogram or density plot showing the distribution of <code>raw</code> distances
may be useful for determining a suitable value, since inflection points can guide selection of this cutoff. Such a plot
may be generated using the <code>gsnDistanceHistogram()</code> method.
</p>
<p>An alternative to this paring method is hierarchical clustering implemented in the <code><a href="#topic+gsnPareNetGenericHierarchic">gsnPareNetGenericHierarchic</a></code>
method.
</p>


<h3>Value</h3>

<p>A GSNData object containing a pared distance matrix for the specified <code>distance</code> metric.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnPareNetGenericHierarchic">gsnPareNetGenericHierarchic</a></code>
<code><a href="#topic+gsnDistanceHistogram">gsnDistanceHistogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnImportCERNO( sig_pathways.GSN,
                                    pathways_data = sig_pathways.cerno )

# Now we can pare the network. By default, the distances are complemented
# and converted into ranks for the sake of generating a network.
sig_pathways.GSN &lt;- gsnPareNetGenericToNearestNNeighbors( object = sig_pathways.GSN )


</code></pre>

<hr>
<h2 id='gsnPlotNetwork'>gsnPlotNetwork</h2><span id='topic+gsnPlotNetwork'></span>

<h3>Description</h3>

<p>Function for plotting the networks within GSNData objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnPlotNetwork(
  object,
  pathways_dat = NULL,
  distance = NULL,
  id_col = NULL,
  substitute_id_col = NULL,
  stat_col = NULL,
  stat_col_2 = NULL,
  sig_order = NULL,
  sig_order_2 = NULL,
  n_col = NULL,
  optimal_extreme = NULL,
  transform_function = nzLog10,
  pathways_title_col = c("Title", "Name", "NAME", "STANDARD_NAME"),
  edge_colors = c("black", "purple", "blue", "green", "yellow4", "orange", "red"),
  vertex_colors = c("white", "yellow", "red"),
  vertex_colors.1 = c("white", "red"),
  vertex_colors.2 = c("white", "blue"),
  combine_method = "scaled_geomean",
  na.color = "#CCCCCC",
  filename = NULL,
  out_format = NULL,
  width = NULL,
  height = NULL,
  vertex.shape = "circle",
  vertex.size = NULL,
  vertex.size.range = NULL,
  vertex.label.cex = NULL,
  vertex.label.col = NULL,
  vertex.frame.color = par("fg"),
  contrasting_color.fun = NULL,
  scale_labels_by_vertex = TRUE,
  max_edge_width = NULL,
  scale.edges.by.distance = FALSE,
  color.edges.by.distance = FALSE,
  edge_arrow_size = NULL,
  seed = 29189892,
  layout = function(x) {
     igraph::layout_with_fr(x, grid = "nogrid")
 },
  .plot = igraph::plot.igraph,
  show.legend = TRUE,
  legend.lab.cex = NULL,
  legend.axis.cex = NULL,
  legend.fg = par("fg"),
  legend.bg = "#DDDDDD",
  legend.vertex.fg = NULL,
  legend.vertex.bg = "#DDDDDD",
  font_face = par("family"),
  main = NULL,
  cex.main = NULL,
  mar.main = 3.2,
  lines.main = 0.9,
  .mar.plot = NULL,
  draw.legend.box.bool = FALSE,
  legend.free.cex.bool = FALSE,
  legend_x_size.in = NULL,
  colors.n = 100,
  new = FALSE,
  legend_spacing.x.in = 2 * par("cin")[1],
  legend_spacing.y.in = par("cin")[2],
  resolution = 72,
  DO_BROWSER = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnPlotNetwork_+3A_object">object</code></td>
<td>
<p>A GSNData object containing a pared distance matrix with <code>edges</code>. NOTE: when calling as
<code>plot.GSNData</code>, use the argument <code>x</code> instead.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_pathways_dat">pathways_dat</code></td>
<td>
<p>(optional) data.frame containing associated pathways data. This defaults to whatever pathways
data has already been imported into this GSNData object in <code>object$pathways$data</code>.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_distance">distance</code></td>
<td>
<p>(optional) The name of a distance metric used, defaults to whatever <code>default_distance</code> is.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_id_col">id_col</code></td>
<td>
<p>(optional) This is the name of the column in the pathways data.frame that corresponds to the names of
gene sets. The default value is specified by <code>object$pathways$id_col</code>. (See details.)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_substitute_id_col">substitute_id_col</code></td>
<td>
<p>(optional) This is the name of the column that is to be substituted for the <code>id_col</code>
column when labeling network vertices. (See details.)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_stat_col">stat_col</code></td>
<td>
<p>(optional) This is the name of the column in the pathways data.frame that contains a significance
value for coloring network vertices. The default value is specified by <code>object$pathways$stat_col</code>.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_stat_col_2">stat_col_2</code></td>
<td>
<p>(optional) This is the name of an optional second column in the pathways data.frame that
contains a significance value for coloring network vertices in a 2-color network. The default value is specified
by <code>object$pathways$stat_col_2</code>. When specified, a 2-color network is generated. To force a 2-color network
to plot as a standard 1-color network using <code>stat_col</code> alone, use <code>stat_col_2 = NA</code>.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_sig_order">sig_order</code></td>
<td>
<p>(optional) This indicates the behavior of <code>stat_col</code>, whether low values (<code>'loToHi'</code>) or
high values (<code>'hiToLo'</code>) are most significant. The default value is specified in <code>object$pathways$sig_order</code>.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_sig_order_2">sig_order_2</code></td>
<td>
<p>(optional) This indicates the behavior of <code>stat_col_2</code>, whether low values (<code>'loToHi'</code>) or
high values (<code>'hiToLo'</code>) are most significant. The default value is specified in <code>object$pathways$sig_order_2</code>.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_n_col">n_col</code></td>
<td>
<p>(optional) This is the name of the column in the pathways data.frame that contains a value for gene set
size, or any other value intended to be the bases of leaf scaling. When specified, leaf sizes will be scaled by this
value, either as a function argument, or in the <code>object$pathways$n_col</code> field. An <code>NA</code> value can be used
to override the the value in <code>object$pathways$n_col</code> and suppress leaf scaling when <code>n_col</code> has been
set in the object. (default is the value in <code>object$pathways$n_col</code>).</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_optimal_extreme">optimal_extreme</code></td>
<td>
<p>(optional) This indicates the behavior of the statistic used to generate the distance metric,
specifically whether low values (<code>'min'</code>) or high values <code>'max'</code> are to be regarded as close. This is used
for scaling the width and the color of the edges connecting vertices. See <code>scale.edges.by.distance</code>, below:
(default: object$distances[<a href="analogue.html#topic+distance">distance</a>]$pared_optimal_extreme or if that's NULL,
object$distances[<a href="analogue.html#topic+distance">distance</a>]$optimal_extreme)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_transform_function">transform_function</code></td>
<td>
<p>(optional) This is a function to transform the values in <code>stat_col</code> so that they
are suitable for amenable to color-scaling. For <em>p</em>-values, a log transformation is often useful, but can produce
negative infinities if the transformation is applied to zero. By default the function is the <code>nzLog10</code>
(non-zero log10) function, provided by this package, which adds a small pseudocount to p-values when log10 transforming
values equal to zero. If values in <code>stat_col</code> are less than zero, then log10 transformation is inappropriate and
will introduce NAs, and therefore some other method should be used. (default: <code>nzLog10</code>)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_pathways_title_col">pathways_title_col</code></td>
<td>
<p>(optional) Indicates a column to be used as the 'Title' column for network vertices.
If unset, the function attempts to search for a title column from the following values: c(&quot;Title&quot;, &quot;Name&quot;, &quot;NAME&quot;,
&quot;STANDARD_NAME&quot; ) (See details.)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_edge_colors">edge_colors</code></td>
<td>
<p>(optional) A vector of colors included to generate a scale represent the numerical value of the
edge distances. By default, the colors are arranged as a rainbow with black and purple representing the greatest
distances, and orange and red the nearest distances. This feature (and argument) will likely be deprecated in
future versions. (default: edge_colors = c(&quot;black&quot;, &quot;purple&quot;, &quot;blue&quot;, &quot;green&quot;,&quot;yellow4&quot;, &quot;orange&quot;,&quot;red&quot;))</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_vertex_colors">vertex_colors</code></td>
<td>
<p>(optional) This is the standard set of colors used for a standard single color network.
By default, c(&quot;white&quot;,&quot;yellow&quot;,&quot;red&quot;) is used, coloring low values white, high values red, and intermediate values
yellow if <code>sig_order</code> is &quot;loToHi&quot; and vice versa if sig_order is &quot;hiToLo&quot;.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_vertex_colors.1">vertex_colors.1</code></td>
<td>
<p>(optional) This is the range of colors used for a 2-color network corresponding to
values of <code>stat_col</code>. Up to 2 colors can be used, and should correspond to a color contrasting with
<code>vertex_colors.2</code>. The default is c(&quot;white&quot;,&quot;red&quot;), coloring high values red and low values white if
<code>sig_order</code> is <code>"loToHi"</code> and vice versa if <code>sig_order</code> is <code>"hiToLo"</code>.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_vertex_colors.2">vertex_colors.2</code></td>
<td>
<p>(optional) This is the range of colors used for a 2-color network corresponding to
values of <code>stat_col_2</code>. Up to 2 colors can be used, and should correspond to a color contrasting with
<code>vertex_colors.2</code>. The default is <code>c("white","blue")</code>, coloring high values blue and low values white
if <code>sig_order_2</code> is <code>"loToHi"</code> and vice versa if <code>sig_order</code> is <code>"hiToLo"</code>.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_combine_method">combine_method</code></td>
<td>
<p>(optional) For dual channel plots this is a string used to indicate how colors are combined to
generate a two dimensional color scale. Options are &quot;scaled_geomean&quot; (same as &quot;default&quot;), &quot;standard&quot; (same as &quot;euclidean&quot; ),
&quot;negative_euclidean&quot;, &quot;mean&quot;, and &quot;additive&quot;. See details.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_na.color">na.color</code></td>
<td>
<p>(optional) This color is assigned to vertices for which there is an <code>NA</code> value. (default: &quot;#CCCCCC&quot;)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_filename">filename</code></td>
<td>
<p>(optional) An output file name for the plot. If 'out_format' is not set (see below), the output
file type will be determined by the file suffix, which can be <code>'.svg'</code>, <code>'.pdf'</code>, or <code>'.png'</code>. If
the <code>out_format</code> cannot be determined from the file name, than it may be manually set with <code>out_format</code>.
If the output file type cannot be determined from the <code>filename</code> or <code>out_format</code> arguments, an error will
be thrown.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_out_format">out_format</code></td>
<td>
<p>(optional) Output filetype when <code>filename</code> is specified, either <code>'svg'</code>, <code>'png'</code>,
<code>'pdf'</code>, or <code>'plot'</code> (default if filename is not specified). For more information, see Details.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_width">width</code></td>
<td>
<p>(optional) Sets the width of the output canvas in inches. Defaults to the width of the present
graphical device.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_height">height</code></td>
<td>
<p>(optional) Sets the height of the output canvas in inches. Defaults to the height of the present
graphical device.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_vertex.shape">vertex.shape</code></td>
<td>
<p>(optional) Shape of the vertex, passed to <code>igraph::plot.igraph</code>. By default, the value is
<code>'circle'</code>.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_vertex.size">vertex.size</code></td>
<td>
<p>(optional) Size of vertices, passed to <code>igraph::plot.igraph</code>. By default, the value is
NULL, and the function attempts to pick a reasonable value based on the canvas size and the number of gene sets.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_vertex.size.range">vertex.size.range</code></td>
<td>
<p>(optional) The range of vertex sizes used in plots, from low to high. This is used when
<code>n_col</code> is specified and vertex sizes are intended to be scaled. If this is not specified, then the function
attempts to select appropriate values based on size of the figure being generated.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>
<p>(optional) Size of vertex labels, passed to <code>igraph::plot.igraph</code>. As with vertex.size,
by default, the value is NULL, and the function attempts to pick a reasonable value based on the canvas size and
the number of gene sets.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_vertex.label.col">vertex.label.col</code></td>
<td>
<p>(optional) Color of vertex labels, passed to <code>igraph::plot.igraph</code>. If not specified,
the function attempts to pick a contrasting color for vertex label text using the <code>contrasting_color.fun</code>
argument. (default: NULL)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_vertex.frame.color">vertex.frame.color</code></td>
<td>
<p>(optional) Color of the vertex border. (default par('fg'))</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_contrasting_color.fun">contrasting_color.fun</code></td>
<td>
<p>(optional) A function to pick a color for vertex labels that contrasts with the vertex
fill color. If unspecified, the function attempts to pick a suitable function for generating suitable set of contrasting
colors, based on the <code>contrasting_color()</code> function. (default: For single channel plots using color scales defined
with <code>vertex_colors</code>, or dual channel color scales defined with <code>vertex_colors.1</code>, or <code>vertex_colors.2</code>
using yellow or orange, <code>contrasting_color(type="binary")</code> is used, and otherwise
<code>contrasting_color(type="blackyellow")</code> is used.)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_scale_labels_by_vertex">scale_labels_by_vertex</code></td>
<td>
<p>(optional) Logical that tells the function to scale the text in vertex labels by the size
of the vertex. (default: TRUE)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_max_edge_width">max_edge_width</code></td>
<td>
<p>(optional) Size of vertex labels, passed to <code>igraph::plot.igraph</code>. By default, the value
is NULL, and the function attempts to pick a reasonable value based on the canvas size and the number of gene sets.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_scale.edges.by.distance">scale.edges.by.distance</code></td>
<td>
<p>(optional) A logical telling the function to scale edges between vertices on the basis
of distance. NOTE: If <code>optimal_extreme == "max"</code>, then smaller numbers are treated as more distant, and conversely
if <code>optimal_extreme == "min"</code>, larger numbers are treated as more distant. (default: FALSE)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_color.edges.by.distance">color.edges.by.distance</code></td>
<td>
<p>(optional)  A logical telling the function to color edges between vertices on the basis
of distance. This functionality will likely be deprecated. (default: FALSE)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_edge_arrow_size">edge_arrow_size</code></td>
<td>
<p>(optional) Size of vertex labels, passed to <code>igraph::plot.igraph</code>. By default, the value
is NULL, and the function attempts to pick a reasonable value based on the canvas size and the number of gene sets.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_seed">seed</code></td>
<td>
<p>(optional) This is a seed that the function uses to generate a plot layout. By default it is 29189892,
and this results in a repeatable behavior for plots. However, to randomize the plot layout behavior, this value may
be set to NULL, or if some other repeatable layout is desired, another seed may be used.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_layout">layout</code></td>
<td>
<p>(optional) Either a function that generates a layout or a numerical matrix containing a vertex layout
with two columns corresponding to <em>x</em> and <em>y</em> coordinates. This argument is passed to the <code>igraph</code> plot method
that is subsequently called by <code>gsnPlotNetwork()</code> (see <code>.plot</code>, below). The default <code>layout</code> is
the anonymous function <code>function(x){igraph::layout_with_fr(x, grid = "nogrid" )}</code>, which calls
<code>igraph::layout_with_fr()</code> (implementing Fruchterman-Reingold layout) with the <code>grid="nogrid"</code> option,
enabling proper layout of networks with &gt;= 1000 gene set vertices. Other useful layouts for <code>igraph</code> networks
include <code>igraph::layout_with_fr</code> (default Fruchterman-Reingold), <code>igraph::layout_with_dh</code> (implementing
Davidson-Harel layout), <code>igraph::layout_as_tree</code>, <code>igraph::layout_nicely</code>, and others.
For more details about layouts, see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_.plot">.plot</code></td>
<td>
<p>(optional) A plot function used to render the internally generated <code>igraph</code> object. By default
<code>igraph::plot.igraph</code> is used, but for interactive plotting, <code>igraph::tkplot</code> may be used. For more
details about plotting, see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_show.legend">show.legend</code></td>
<td>
<p>(optional) A logical value telling the function whether or not to show legends. Legends for vertex
size and node color are currently supported. (default: TRUE)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_legend.lab.cex">legend.lab.cex</code></td>
<td>
<p>(optional) The font size of legend label text as cex units. If not specified, the function will
attempt to pick an appropriate value based on the figure layout.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_legend.axis.cex">legend.axis.cex</code></td>
<td>
<p>(optional) The font size of legend axis text as cex units. If not specified, the function will
attempt to pick an appropriate value based on the figure layout.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_legend.fg">legend.fg</code></td>
<td>
<p>(optional) The foreground color of the legend that controls the color of text, axes, axis labels,
ticks, and legend border. (default: par('fg'))</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_legend.bg">legend.bg</code></td>
<td>
<p>(optional) The background color of the legend. This argument doesn't currently work, and may be
removed in the future. (default: &quot;#CCCCCC&quot; )</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_legend.vertex.fg">legend.vertex.fg</code></td>
<td>
<p>(optional) The border color of vertices for vertex size legends. This argument allows the
legend vertex frame color to be set separately from vertex.frame.color. (default: vertex.frame.color)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_legend.vertex.bg">legend.vertex.bg</code></td>
<td>
<p>(optional) The fill color of vertices for vertex size legends. (default: &quot;#DDDDDD&quot;)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_font_face">font_face</code></td>
<td>
<p>(optional) The font face used for the figure. (default: par(&quot;family&quot;))</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_main">main</code></td>
<td>
<p>(optional) The plot title. (default: NULL)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_cex.main">cex.main</code></td>
<td>
<p>(optional) The font size in cex units of the main title. (default: 1.5 * par( 'cex' ))</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_mar.main">mar.main</code></td>
<td>
<p>(optional) The number of lines set aside for a main title when main is used. (default: 3.2)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_lines.main">lines.main</code></td>
<td>
<p>(optional) The distance of the main title in lines from the top of the plot. (default: 0.9)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_.mar.plot">.mar.plot</code></td>
<td>
<p>(optional) The margins of the plot itself. If unspecified, the function will attempt to reserve
enough room to the right of the plot for the legend or legends.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_draw.legend.box.bool">draw.legend.box.bool</code></td>
<td>
<p>(option) Logical indicating whether bounding boxes should be drawn for the legends.</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_legend.free.cex.bool">legend.free.cex.bool</code></td>
<td>
<p>(optional) Logical allowing independent optimized sizing of legend label font sizes if TRUE.
(default: FALSE)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_legend_x_size.in">legend_x_size.in</code></td>
<td>
<p>(optional) The width of the legend in inches. If not set, the function attempts to choose an
appropriate value. (default: <code>min(2,max(width*2/5,width-height))</code>)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_colors.n">colors.n</code></td>
<td>
<p>(optional) The number of colors in for each channel in 1 or 2 channel plots. For single channel plots
the number of colors is simply equal to this number. For dual channel plots the total number of colors in the legend
is equal to the square of this number. (default: 100)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_new">new</code></td>
<td>
<p>(optional) Logical telling the function (if true) that a new plot should be added to an existing device (if
TRUE) or that the current device should be cleared and written over (if FALSE). (default: FALSE)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_legend_spacing.x.in">legend_spacing.x.in</code></td>
<td>
<p>(optional) Space between plot and legend in inches. This can be used to adjust the horizontal
position and move the legend closer to or farther away from the plot region. Since the network plot may not fill the
entire plotting region, it may be useful to use negative values to move the legends closer to the plot.
(default: 2 character widths)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_legend_spacing.y.in">legend_spacing.y.in</code></td>
<td>
<p>(optional) Space between legends in inches. (default: 1 character height)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_resolution">resolution</code></td>
<td>
<p>Image resolution in pixels per inch, only for bitmap image output formats (currently
png only). (default: 72)</p>
</td></tr>
<tr><td><code id="gsnPlotNetwork_+3A_do_browser">DO_BROWSER</code></td>
<td>
<p>(option) Logical indicating whether browser() should be run for this function. (For debugging
purposes, will probably remove.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily for taking <code>GSNData</code> object containing a distance matrix, an associated
<code>edges</code> edge-list and pathways data, and generating and rendering a corresponding <code>igraph</code> object. The
function attempts to plot the corresponding network with vertices labeled with a gene set <code>ID</code> and corresponding
<code>Title</code>, and colored according to the significance values represented in <code>stat_col</code> using <code>sig_order</code>
as an indicator of whether high or low values are more significant. Edges are scaled by the value of the value of the
distance statistic in the pared distance matrix.
</p>
<p>When the parameters <code>vertex.shape</code>, <code>vertex.size</code>, <code>vertex.label.cex</code>, <code>max_edge_width</code>, and
<code>edge_arrow_size</code> are not specified, the function attempts to pick reasonable values. These parameters are
assembled into a list and attached to the returned <code>igraph</code> object as an attribute named <code>GSNA_plot_params</code>.
To optimize plots, the user can examine these parameters by calling the following on the output of the function:
</p>
<p><code>attr( x = nw.igraph, which = "GSNA_plot_params" )</code>
</p>


<h3>Value</h3>

<p>An <code>igraph</code> network object is returned, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.GSNData">plot.GSNData</a></code>
<code><a href="#topic+gsnToIgraph">gsnToIgraph</a></code>
<code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# This example can take &gt;10 seconds to run on some platforms,
# so we won't test it here.

library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnImportCERNO( sig_pathways.GSN,
                                    pathways_data = sig_pathways.cerno )

# Now we can pare the network and assign subnets:
sig_pathways.GSN &lt;- gsnPareNetGenericHierarchic( object = sig_pathways.GSN )
sig_pathways.GSN &lt;- gsnAssignSubnets( sig_pathways.GSN )

# Now, produce a network plot:
gsnPlotNetwork( object  = sig_pathways.GSN )


</code></pre>

<hr>
<h2 id='gsnSubnetSummary'>gsnSubnetSummary</h2><span id='topic+gsnSubnetSummary'></span>

<h3>Description</h3>

<p>Generates a table summarizing subnets that incorporates subnets and pathways data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnSubnetSummary(
  object,
  pathways.data = NULL,
  distance = NULL,
  id_col = NULL,
  stat_col = NULL,
  sig_order = NULL,
  stat_col_2 = NULL,
  sig_order_2 = NULL,
  summary_statistics = c("hm", "min_max"),
  seed_gs_fields = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnSubnetSummary_+3A_object">object</code></td>
<td>
<p>A GSNData data object containing a distance matrix and subnets data. If pathways
data is not specified by the pathways.data argument (described below), the object must contain
imported pathways data as well.</p>
</td></tr>
<tr><td><code id="gsnSubnetSummary_+3A_pathways.data">pathways.data</code></td>
<td>
<p>An (optional) data.frame containing pathways data (GSEA, CERNO, GSNORA, etc.)
with 1 or 2 associated statistical columns, typically <em>P</em>-values, specified by stat_col and
stat_col_2 below.</p>
</td></tr>
<tr><td><code id="gsnSubnetSummary_+3A_distance">distance</code></td>
<td>
<p>A distance metric with associated subnets data.</p>
</td></tr>
<tr><td><code id="gsnSubnetSummary_+3A_id_col">id_col</code></td>
<td>
<p>(optional) This is the name of the column in the pathways data.frame that corresponds
to the names of gene sets. The default value is specified by <code>object$pathways$id_col</code>.
(See details.)</p>
</td></tr>
<tr><td><code id="gsnSubnetSummary_+3A_stat_col">stat_col</code></td>
<td>
<p>(optional) Specifies the name of the first statistical column, if not specified,
defaults to the value in <code>object$pathways$stat_col</code>.</p>
</td></tr>
<tr><td><code id="gsnSubnetSummary_+3A_sig_order">sig_order</code></td>
<td>
<p>(optional) This indicates the behavior of <code>stat_col</code>, whether low values
(<code>'loToHi'</code>) or high values (<code>'hiToLo'</code>) are most significant. The default value is
specified in <code>object$pathways$sig_order</code>.</p>
</td></tr>
<tr><td><code id="gsnSubnetSummary_+3A_stat_col_2">stat_col_2</code></td>
<td>
<p>(optional) Specifies the name of the second statistical column, if not specified,
defaults to the value in <code>object$pathways$stat_col_2</code>.</p>
</td></tr>
<tr><td><code id="gsnSubnetSummary_+3A_sig_order_2">sig_order_2</code></td>
<td>
<p>(optional) This indicates the behavior of <code>stat_col_2</code>, whether low values
(<code>'loToHi'</code>) or high values (<code>'hiToLo'</code>) are most significant. The default value is
specified in <code>object$pathways$sig_order_2</code>.</p>
</td></tr>
<tr><td><code id="gsnSubnetSummary_+3A_summary_statistics">summary_statistics</code></td>
<td>
<p>(optional) A character vector specifying which summary statistics are
to be calculated from the 'stat_col'. Acceptable values include 'hm' specifying harmonic mean,
'min_max', specifying either minimum or maximum depending on <code>sig_order</code>, or the name of
a function. (default: <code>c('hm', 'min_max')</code>)</p>
</td></tr>
<tr><td><code id="gsnSubnetSummary_+3A_seed_gs_fields">seed_gs_fields</code></td>
<td>
<p>(optional) A character vector specifying the names of additional seed gene
set fields to retain from pathways data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output data.frame contains a list of subnets, each with an associated list of gene
set IDs. For each subnet, summary statistics are calculated, including the harmonic mean of
<code>stat_col</code> and (if specified) <code>stat_col_2</code>. In addition, the minimum or maximum of the
<code>stat_col</code> and <code>stat_col_2</code> is calculated, depending on the <code>sig_order</code> and
<code>sig_order_2</code>. For <code>loToHi</code>, the minimum is calculated, and for <code>hiToLo</code>, the
maximum.
</p>


<h3>Value</h3>

<p>A data.frame with a statistical summary of subnets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnImportCERNO( sig_pathways.GSN,
                                    pathways_data = sig_pathways.cerno )

# Now we can pare the network and assign subnets:
sig_pathways.GSN &lt;- gsnPareNetGenericHierarchic( object = sig_pathways.GSN )
sig_pathways.GSN &lt;- gsnAssignSubnets(  object = sig_pathways.GSN )

# Now, get a statistacal summary of the subnets:
gsnSubnetSummary( sig_pathways.GSN )

</code></pre>

<hr>
<h2 id='gsnSubset'>gsnSubset</h2><span id='topic+gsnSubset'></span>

<h3>Description</h3>

<p>Create a subset GSNData object, containing only a subset of vertices or subnets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnSubset(object, distance = NULL, vertex_names = c(), subnet_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnSubset_+3A_object">object</code></td>
<td>
<p>A <code>GSNData</code> object.</p>
</td></tr>
<tr><td><code id="gsnSubset_+3A_distance">distance</code></td>
<td>
<p>Specifies a distance metric to use for subsetting. Defaults to the <code>default_distance</code>.</p>
</td></tr>
<tr><td><code id="gsnSubset_+3A_vertex_names">vertex_names</code></td>
<td>
<p>A character vector specifying the vertex names/gene sets to include in the <code>GSNData</code>
subset object.</p>
</td></tr>
<tr><td><code id="gsnSubset_+3A_subnet_names">subnet_names</code></td>
<td>
<p>A character vector specifying the names of the subnets to include in the <code>GSNData</code>
subset object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for subsetting a single subnet, or a small set of subnets for the purpose of
plotting just that subnet.
</p>


<h3>Value</h3>

<p>A new <code>GSNData</code> object is returned containing a subset of the vertices and subnets from the original
<code>GSNData</code> object. For a given distance, the following data are subsetted for the included vertices and
copied:
</p>
<table>
<tr><td><code>$distances[[distance]]$matrix</code></td>
<td>
<p>The raw distance matrix, subsetted.</p>
</td></tr>
<tr><td><code>$distances[[distance]]$pared</code></td>
<td>
<p>The pared distance matrix, subsetted.</p>
</td></tr>
<tr><td><code>$distances[[distance]]$edges</code></td>
<td>
<p>The edge list, subsetted</p>
</td></tr>
<tr><td><code>$distances[[distance]]$vertex_subnets</code></td>
<td>
<p>The vertex assignments for each subnet, subsetted.</p>
</td></tr>
<tr><td><code>$distances[[distance]]$clusters</code></td>
<td>
<p>The cluster assignments for each subnet, subsetted (for
hierarchical clustering).</p>
</td></tr>
<tr><td><code>$distances[[distance]]$optimal_extreme</code></td>
<td>
<p>Character vector of length 1 indicating whether min or max distances
are close in the raw distance matrix.</p>
</td></tr>
<tr><td><code>$distances[[distance]]$pared_optimal_extreme</code></td>
<td>
<p>Character vector of length 1  indicating whether min
or max distances are close in the pared distance matrix.</p>
</td></tr>
</table>
<p>The hclust object generated by hierarchical clustering is not currently subsetted or copied.
</p>
<p>The <code>default_distance</code> is set as whichever distance matrix is copied. Currently, this function only supports
copying a single distance matrix.
</p>
<p>The following pathways data are copied:
</p>
<table>
<tr><td><code>$pathways$data</code></td>
<td>
<p>Pathways results, subsetted.</p>
</td></tr>
<tr><td><code>$pathways$type</code></td>
<td>
<p>The type of pathways results, copied.</p>
</td></tr>
<tr><td><code>$pathways$id_col</code></td>
<td>
<p>The identifier, copied.</p>
</td></tr>
<tr><td><code>$pathways$stat_col</code></td>
<td>
<p>Statistical column name, copied.</p>
</td></tr>
<tr><td><code>$pathways$sig_order</code></td>
<td>
<p>The significance order of the pathways results, based on the stat_column; are
the pathways results to be sorted by significance from 'loToHi' (most significant values are low) or 'hiToLo'
(most significant values high)?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+GSNData">GSNData</a>()</code>
</p>

<hr>
<h2 id='gsnToIgraph'>gsnToIgraph</h2><span id='topic+gsnToIgraph'></span>

<h3>Description</h3>

<p>For a <code>GSNData</code> object containing an edge list, generate an igraph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsnToIgraph(object, distance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsnToIgraph_+3A_object">object</code></td>
<td>
<p>A <code>GSNData</code> object containing a pared distance matrix and an edge list.</p>
</td></tr>
<tr><td><code id="gsnToIgraph_+3A_distance">distance</code></td>
<td>
<p>(optional) A character vector specifying a distance to use. If no <code>distance</code> is
specified, the value of the <code>default_distance</code> will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used by gsnPlotNetwork to generate an <code>igraph</code>. Users will probably not need to call
gsnToIgraph, for most cases. If edges are not found, it will emit an error.
</p>


<h3>Value</h3>

<p>Returns an <code>igraph</code> object corresponding to the edges and vertices in the <code>GSNData</code>
object's edge-list data.frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnPlotNetwork">gsnPlotNetwork</a>()</code>
<code><a href="#topic+plot.GSNData">plot.GSNData</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnImportCERNO( sig_pathways.GSN,
                                    pathways_data = sig_pathways.cerno )

# Now we can pare the network and assign subnets:
sig_pathways.GSN &lt;- gsnPareNetGenericHierarchic( object = sig_pathways.GSN )
sig_pathways.GSN &lt;- gsnAssignSubnets( sig_pathways.GSN )

# Now, create an igraph version of the network:
sig_pathways.igraph &lt;- gsnToIgraph( object  = sig_pathways.GSN )

# This can be plotted via igraph::plot.igraph:
plot( sig_pathways.igraph )


</code></pre>

<hr>
<h2 id='intV2Color'>intV2Color</h2><span id='topic+intV2Color'></span>

<h3>Description</h3>

<p>Converts a numeric or integer vector of length 3 containing
RGB values in the range of 0 to 255 to 24 bit color specifications in the
form &quot;#FFFFFF&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intV2Color(rgb_v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intV2Color_+3A_rgb_v">rgb_v</code></td>
<td>
<p>An integer or numeric vector of length 3 containing RGB channel
intensities from 0 to 255.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 24-bit color specification in the form &quot;#FFFFFF&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+color2IntV">color2IntV()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
col_v &lt;- c( 255, 100, 240)
col &lt;- intV2Color( col_v )

</code></pre>

<hr>
<h2 id='lfisher_cpp'>lfisher_cpp</h2><span id='topic+lfisher_cpp'></span>

<h3>Description</h3>

<p>Takes a four integers corresponding to a 2x2 contingency matrix and calculates a natural-log transformed
Fisher <em>p</em>-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfisher_cpp(a, b, c, d, e_precision = 12, alternative = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfisher_cpp_+3A_a">a</code></td>
<td>
<p>(required) This corresponds to cell 1 of the contingency matrix. In the context of GSNA, assuming two gene
sets, this is used as the number of observable genes in the background that are not present either gene set.</p>
</td></tr>
<tr><td><code id="lfisher_cpp_+3A_b">b</code></td>
<td>
<p>(required) This corresponds to cell 2 of the contingency matrix. For GSNA this is the number of observable
genes present in gene set 1, but not gene set 2.</p>
</td></tr>
<tr><td><code id="lfisher_cpp_+3A_c">c</code></td>
<td>
<p>(required) This corresponds to cell 3 of the contingency matrix. For GSNA this is the number of observable
genes present in gene set 2, but not gene set 1.</p>
</td></tr>
<tr><td><code id="lfisher_cpp_+3A_d">d</code></td>
<td>
<p>(required) This corresponds to cell 4 of the contingency matrix. For GSNA this is the number of observable
genes present in both gene sets 1 and 2.</p>
</td></tr>
<tr><td><code id="lfisher_cpp_+3A_e_precision">e_precision</code></td>
<td>
<p>(optional) Numeric value that determines the precision of summation of partial <em>p</em>-values. For
the less-than, greater-than and two-sided options in calculating the log-Fisher <em>p</em>-value, log-space summation of
partial <em>p</em>-values must be accomplished using the so-called <em>Log-Sum-Exponent</em> trick. Due to limitations of precision
in C++, however, numbers that differ by more than about 11 powers of <em>e</em> cannot be summed. By specifying a value less
than 12, slightly less precise p-values can be calculated slightly faster. This option was included as way to
accelerate calculation of <em>p</em>-values, but has not proven to significantly improve performance, so it may be removed
in the future. Defaults to 12.</p>
</td></tr>
<tr><td><code id="lfisher_cpp_+3A_alternative">alternative</code></td>
<td>
<p>(optional) Integer corresponding to 4 options:
</p>

<dl>
<dt><code>1</code></dt><dd><p>single-sided, greater-than. Sums <em>p</em>-values for intersections greater than and equal to <code>d</code>.</p>
</dd>
<dt><code>2</code></dt><dd><p>single-sided, less-than. Sums <em>p</em>-values for intersections less than and equal to <code>d</code>.</p>
</dd>
<dt><code>3</code></dt><dd><p>two-sided, sums all partial <em>p</em>-values less than or equal to the partial <em>p</em>-value for intersections
equal to <code>d</code>.</p>
</dd>
<dt><code>4</code></dt><dd><p>partial. Calculates single <em>p</em>-value for intersections equal to <code>d</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of Fisher <em>p</em>-values is discussed in detail elsewhere, but partial natural-log
transformed <em>p</em>-values are calculated as follows:
</p>
<p>Given a 2x2 contingency matrix of the form:
</p>
<p style="text-align: center;"><code class="reqn">\biggl[\begin{matrix}a &amp; b \\ c &amp; d\end{matrix}\biggr]</code>
</p>

<p>The natural log of the partial <em>p</em>-values is given by:
</p>
<p style="text-align: center;"><code class="reqn">ln(p)  = ln((a+b)!) + ln((c+d)!) +
               ln((a+c)!) + ln((b+d)!) -
               ln(a!) - ln(b!) - ln(c!) -
               ln(d!) - ln((a + b + c + d)!)</code>
</p>

<p>For the single and two-tailed alternatives, partial <em>p</em>-values are summed using the so-called 'log-sum-exponent' method.
</p>


<h3>Value</h3>

<p>This function returns a numeric (double in C++) natural log-Fisher p-value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsIntersectCounts">gsIntersectCounts</a></code>
<code><a href="#topic+scoreLFMatrix_C">scoreLFMatrix_C</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# Calculate a single natural log Fisher_p value:
log_fisher_p &lt;- lfisher_cpp( a = 16000,
                             b = 200,
                             c = 170,
                             d = 100,
                             alternative = 3 )


</code></pre>

<hr>
<h2 id='lse'>lse</h2><span id='topic+lse'></span>

<h3>Description</h3>

<p>Implements the &quot;Log-Sum-Exponential trick&quot; for calculating the log of the sums of
exponents without arithmetic underflows. This allows very small numbers to be
summed in log space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lse(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lse_+3A_a">a</code></td>
<td>
<p>A numeric log value.</p>
</td></tr>
<tr><td><code id="lse_+3A_b">b</code></td>
<td>
<p>Another numeric log value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the sum of the exponents of a and b.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- 1E-40
B &lt;- 3E-41

log_AB &lt;- lse( log(A), log(B) )

# exp( log_AB ) == A + B


</code></pre>

<hr>
<h2 id='makeFilteredGenePresenceAbsenceMatrix'>makeFilteredGenePresenceAbsenceMatrix</h2><span id='topic+makeFilteredGenePresenceAbsenceMatrix'></span>

<h3>Description</h3>

<p>Take character vector containing the set of observable genes in a data set and a gene set
collection and generate a presence/absence matrix of observable genes in each gene set/module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFilteredGenePresenceAbsenceMatrix(ref.background, geneSetCollection)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFilteredGenePresenceAbsenceMatrix_+3A_ref.background">ref.background</code></td>
<td>
<p>(required) A character vector corresponding to the genes observable in a differential
expression, ATAC-Seq or other dataset. This corresponds to the background used in tools like DAVID.</p>
</td></tr>
<tr><td><code id="makeFilteredGenePresenceAbsenceMatrix_+3A_genesetcollection">geneSetCollection</code></td>
<td>
<p>(required) A gene set collection either in the form of a tmod object, or a list of
gene sets / modules as character vectors containing gene symbols and names corresponding to the
gene module identifier.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a gene presence/absence matrix with genes corresponding to rows, gene sets/modules
corresponding to columns, and TRUE or FALSE values corresponding to presence or absence of a particular
gene in a particular gene set/module. This matrix has been filtered to only include genes observable in
a data set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildGeneSetNetworkLFFast">buildGeneSetNetworkLFFast</a></code>
<code><a href="#topic+buildGeneSetNetworkSTLF">buildGeneSetNetworkSTLF</a></code>
<code><a href="#topic+buildGeneSetNetworkJaccard">buildGeneSetNetworkJaccard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# And obtain a background of observable genes from differential
# expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Using Bai_gsc.tmod, the tmod format gene set collection in the
# sample data, we can now generate a filtered gene presence
# absence matrix. The columns of the matrix correspond to gene
# sets, whereas the rows are genes.
filteredGenePresenceAbsence_Matrix &lt;-
          makeFilteredGenePresenceAbsenceMatrix( ref.background = background_genes,
                                                 geneSetCollection = Bai_gsc.tmod )

</code></pre>

<hr>
<h2 id='makeLinearNColorGradientFunction'>makeLinearNColorGradientFunction</h2><span id='topic+makeLinearNColorGradientFunction'></span>

<h3>Description</h3>

<p>Given a set of colors and a range of values, generate a function to encode numbers in
the specified range of colors. This serves as a backend for <code>makeOneColorEncodeFunction()</code>
<code>makeTwoColorEncodeFunction()</code> allowing more than 2 color intervals can be specified, so
that color encodings consisting of 3 or more colors per color-dimension/channel can be created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeLinearNColorGradientFunction(
  colors = c("#000000", "#CCCC00", "#FF0000"),
  x.min = 0,
  x.max = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeLinearNColorGradientFunction_+3A_colors">colors</code></td>
<td>
<p>A vector of colors, either by name or as hexadecimal colors.</p>
</td></tr>
<tr><td><code id="makeLinearNColorGradientFunction_+3A_x.min">x.min</code></td>
<td>
<p>The minimal value for the range of numbers to be encoded.</p>
</td></tr>
<tr><td><code id="makeLinearNColorGradientFunction_+3A_x.max">x.max</code></td>
<td>
<p>The maximal value for the range of numbers to be encoded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given n colors, where n &gt;=1 and a range of numbers from x.min to x.max, the function breaks
down the range of numbers into n-1 ranges, and then maps numerical values linearly to numbers in each
range bounded by successive colors. This is used by the functions <code><a href="#topic+makeOneColorEncodeFunction">makeOneColorEncodeFunction</a>()</code>
and <code><a href="#topic+makeTwoColorEncodeFunction">makeTwoColorEncodeFunction</a>()</code>.
</p>


<h3>Value</h3>

<p>Returns a function encoding a single numerical value as a numerical vector of length 3 containing
RGB values from 0 to 255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeOneColorEncodeFunction">makeOneColorEncodeFunction</a>()</code>,
<code><a href="#topic+makeTwoColorEncodeFunction">makeTwoColorEncodeFunction</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
three_col_fun &lt;- makeLinearNColorGradientFunction( colors = c("blue", "white", "red"),
                                                    x.min = 0,
                                                     x.max = 100 )

three_col_mat &lt;- t( sapply( c(0, 25, 50, 75, 100 ) ,three_col_fun ) )

</code></pre>

<hr>
<h2 id='makeOneColorEncodeFunction'>makeOneColorEncodeFunction</h2><span id='topic+makeOneColorEncodeFunction'></span>

<h3>Description</h3>

<p>Generate a function to take a numerical vector and return a color, either as a vector of hexadecimal encoded
colors, or as a three column matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeOneColorEncodeFunction(
  numbers,
  colors = c("#FFFFFF", "#FFFF00", "#FF0000"),
  c.fun = NULL,
  na.color = "#CCCCCC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeOneColorEncodeFunction_+3A_numbers">numbers</code></td>
<td>
<p>A set of numbers to define the range of numerical values for which the color encode function will be defined.
Only the extreme min and max values are necessary.</p>
</td></tr>
<tr><td><code id="makeOneColorEncodeFunction_+3A_colors">colors</code></td>
<td>
<p>The range of colors to be returned by the function function. (default: c(&quot;#FFFFFF&quot;, &quot;#FF0000&quot;))</p>
</td></tr>
<tr><td><code id="makeOneColorEncodeFunction_+3A_c.fun">c.fun</code></td>
<td>
<p>(optional) A function to convert numerical values into colors. If not specified, this is generated based on
<code>numbers</code> and <code>colors</code> using <code>makeLinearNColorGradientFunction()</code>.</p>
</td></tr>
<tr><td><code id="makeOneColorEncodeFunction_+3A_na.color">na.color</code></td>
<td>
<p>(optional) The color returned from the function for NA values (default: &quot;#CCCCCC&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a function that takes 3 arguments and returns either a vector of hexadecimal colors or a
3-column matrix of columns. The arguments:
</p>
<table>
<tr><td><code>numbers</code></td>
<td>
<p>A vector of numbers to be encoded as a color value.</p>
</td></tr>
<tr><td><code>numbers.2</code></td>
<td>
<p>This argument is ignored, and is only included to be compatible with functions generated by the 2-color
encoding functions that take three arguments.</p>
</td></tr>
<tr><td><code>output_as</code></td>
<td>
<p>Specifies the type of return value. If <code>'vector'</code> or <code>'rgb'</code>, the function returns a vector
of hexadecimal colors (e.g.&quot;#FFCCAA&quot;), if 'matrix','array', a three column numeric matrix is returned (Columns are &quot;R&quot;, &quot;G&quot;, or &quot;B&quot;).
Currently, <code>'vector'</code> are synonyms <code>'rgb'</code>, as are <code>'matrix'</code> and <code>'array'</code></p>
</td></tr></table>
<p>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Prepare the function:
oneColorEnc.fun &lt;- makeOneColorEncodeFunction( numbers = c( 0.4, 6 ),
                                               colors = c("white", "yellow", "red"),
                                             )

# Encode a vector of numbers as a vector of colors:
colors_as_vector &lt;- oneColorEnc.fun( numbers = c( 0.4, 1.2, 5, 6 ),
                                     output_as = 'vector' )

</code></pre>

<hr>
<h2 id='makeSymmetricDist'>makeSymmetricDist</h2><span id='topic+makeSymmetricDist'></span>

<h3>Description</h3>

<p>Utility function to convert a matrix of non-symmetrical distances (A-&gt;B != B-&gt;A) into a symmetrical one.
A method of aggregating the non-symmetrical distances can be specified. The default aggregation method is
<code>mean</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSymmetricDist(mat, FUN = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSymmetricDist_+3A_mat">mat</code></td>
<td>
<p>A non-symmetrical matrix of distances.</p>
</td></tr>
<tr><td><code id="makeSymmetricDist_+3A_fun">FUN</code></td>
<td>
<p>function applied to the non-symmetrical distance pairs to aggregate into a symmetrical distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetrical distance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Start with a non-symmetrical distance matrix.
ns_dist.mat &lt;- matrix( nrow = 3, ncol = 3,
                       data = c( NA, -70, -47,
                                 -63, NA, -10,
                                 -53, -17, NA ) )

# Calculate a symmetric distance matrix using 'mean'
mean_dist.mat &lt;- makeSymmetricDist( ns_dist.mat, FUN = mean )

# minimum or max can also be used:
min_dist.mat &lt;- makeSymmetricDist( ns_dist.mat, FUN = min )

</code></pre>

<hr>
<h2 id='makeTwoColorEncodeFunction'>makeTwoColorEncodeFunction</h2><span id='topic+makeTwoColorEncodeFunction'></span>

<h3>Description</h3>

<p>Generate a function to take two numerical vector arguments and return a color, either as a vector of
hexadecimal encoded colors, or as a three column matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTwoColorEncodeFunction(
  numbers.1,
  numbers.2,
  colors.1 = c("#FFFFFF", "#FF0000"),
  colors.2 = c("#FFFFFF", "#0000FF"),
  combine_method = "mean",
  c1.fun = NULL,
  c2.fun = NULL,
  na.color = "#CCCCCC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTwoColorEncodeFunction_+3A_numbers.1">numbers.1</code></td>
<td>
<p>A set of numbers to define the range of channel 1 numerical values for which the color encode
function will be defined. Only the extreme min and max values are necessary.</p>
</td></tr>
<tr><td><code id="makeTwoColorEncodeFunction_+3A_numbers.2">numbers.2</code></td>
<td>
<p>A set of numbers to define the range of channel 2 numerical values for which the color encode
function will be defined. Only the extreme min and max values are necessary.</p>
</td></tr>
<tr><td><code id="makeTwoColorEncodeFunction_+3A_colors.1">colors.1</code></td>
<td>
<p>The range of channel 1 colors to be returned by the function function. (default: c(&quot;#FFFFFF&quot;, &quot;#FF0000&quot;))</p>
</td></tr>
<tr><td><code id="makeTwoColorEncodeFunction_+3A_colors.2">colors.2</code></td>
<td>
<p>The range of channel 2 colors to be returned by the function function. (default: c(&quot;#FFFFFF&quot;, &quot;#0000FF&quot;))</p>
</td></tr>
<tr><td><code id="makeTwoColorEncodeFunction_+3A_combine_method">combine_method</code></td>
<td>
<p>(optional) For dual channel plots this is a string used to indicate how colors are combined to
generate a two dimensional color scale. Options are &quot;scaled_geomean&quot; (same as &quot;default&quot;), &quot;standard&quot; (same as &quot;euclidean&quot; ),
&quot;negative_euclidean&quot;, &quot;mean&quot;, and &quot;additive&quot;. See details.</p>
</td></tr>
<tr><td><code id="makeTwoColorEncodeFunction_+3A_c1.fun">c1.fun</code></td>
<td>
<p>(optional) A function to convert the numerical in channel 1 into colors. If not specified, this is
generated based on <code>numbers.1</code> and <code>colors.1</code>.</p>
</td></tr>
<tr><td><code id="makeTwoColorEncodeFunction_+3A_c2.fun">c2.fun</code></td>
<td>
<p>(optional) A function to convert the numerical in channel 2 into colors. If not specified, this is
generated based on <code>numbers.2</code> and <code>colors.2</code>.</p>
</td></tr>
<tr><td><code id="makeTwoColorEncodeFunction_+3A_na.color">na.color</code></td>
<td>
<p>(optional) The color returned from the function for NA values (default: &quot;#CCCCCC&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>makeTwoColorEncodeFunction()</code> returns a function that takes 3 arguments and returns either a vector of
hexadecimal colors or a 3-column matrix of columns. The arguments:
</p>
<table>
<tr><td><code>numbers.1</code></td>
<td>
<p>A vector of numbers for channel 1, to be encoded as a color value.</p>
</td></tr>
<tr><td><code>numbers.2</code></td>
<td>
<p>A vector of numbers for channel 2, to be encoded as a color value.</p>
</td></tr>
<tr><td><code>output_as</code></td>
<td>
<p>Specifies the type of return value. If <code>'vector'</code> or <code>'rgb'</code>, the function returns a vector
of hexadecimal colors (e.g.&quot;#FFCCAA&quot;), if 'matrix','array', a three column numeric matrix is returned (Columns are &quot;R&quot;, &quot;G&quot;, or &quot;B&quot;).
Currently, <code>'vector'</code> are synonyms <code>'rgb'</code>, as are <code>'matrix'</code> and <code>'array'</code></p>
</td></tr></table>
<p>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Prepare the function:
twoColorEnc.fun &lt;- makeTwoColorEncodeFunction( numbers.1 = c( 0.4, 6 ),
                                               numbers.2 = c(0.6, 20),
                                               colors.1 = c("white", "red"),
                                               colors.2 = c("white", "green" ),
                                               combine_method = "mean" )
# Encode two vectors of numbers as a single vector of colors:
colors_as_vector &lt;- twoColorEnc.fun( numbers.1 = c( 0.4, 1.2, 5, 6 ),
                                     numbers.2 = c( 0.6, 6, 9, 20 ),
                                     output_as = 'vector' )

</code></pre>

<hr>
<h2 id='negative'>negative</h2><span id='topic+negative'></span>

<h3>Description</h3>

<p>This function returns the negative of a numeric or integer vector or matrix. This may be suitable as the
<code>matrix_scaling_fun()</code> argument for <code>gsnPareNetGenericHierarchic()</code> when being used with such distance metrics
as the Jaccard Index or Szymkiewicz–Simpson Overlap Coefficients to transform them into something more approximating a
distance in behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negative(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negative_+3A_x">x</code></td>
<td>
<p>A numeric vector or matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function also sets matrix or vector attributes appropriately for negation of the input.
</p>


<h3>Value</h3>

<p>The negative of the x argument, equal to <code class="reqn">- x</code>.
</p>

<hr>
<h2 id='nzLog10'>nzLog10</h2><span id='topic+nzLog10'></span>

<h3>Description</h3>

<p>Utility function to safely (non-zero) log10 transform p-values that are bounded at
0, and may be zero or may be rounded to zero in certain contexts. To get around this, prior to
applying a log10 transformation the function adds a very small pseudocount to all the values if
any are detected to be zero. This avoids the generation of negative infinities. (See details, below.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nzLog10(x, quiet = FALSE, pseudocount_frxn = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nzLog10_+3A_x">x</code></td>
<td>
<p>A numerical vector containing non-negative values.</p>
</td></tr>
<tr><td><code id="nzLog10_+3A_quiet">quiet</code></td>
<td>
<p>A boolean that tells the script to suppress warning messages. (default: FALSE. This
does not suppress errors, however.)</p>
</td></tr>
<tr><td><code id="nzLog10_+3A_pseudocount_frxn">pseudocount_frxn</code></td>
<td>
<p>A numerical value that sets the added pseudocount as a fraction of the
minimum non-zero value. (default: 0.5)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prior to log10 transformation, this function first scans for any zeros in the input vector.
If it finds any, it warns that zeros have been detected in the raw statistic, and that a pseudocount
will be added. To do this the function adds a fraction of the minimum non-zero value to the values
in x. (The old version of this function, <code>nzLog10.old()</code> determined the value of the pseudocount
in a much more complex way. This is a simplification here.)
</p>


<h3>Value</h3>

<p>A vector containing transformed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p_vals &lt;- c( 0.5, 0.001, 0.00001, 5e-19, 6.24e-23, 0 )
nzLog10( p_vals )

</code></pre>

<hr>
<h2 id='nzLog10.old'>nzLog10.old</h2><span id='topic+nzLog10.old'></span>

<h3>Description</h3>

<p>Utility function to safely (non-zero) log10 transform p-values that are bounded at 0, and may be zero or
may be rounded to zero in certain contexts. To get around this, prior to applying a log10 transformation the function
adds a very small pseudocount to all the values if any are detected to be zero. This avoids the generation of negative
infinities. (See details, below.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nzLog10.old(x, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nzLog10.old_+3A_x">x</code></td>
<td>
<p>A numerical vector containing non-negative values.</p>
</td></tr>
<tr><td><code id="nzLog10.old_+3A_quiet">quiet</code></td>
<td>
<p>A boolean that tells the script to suppress warning messages. (This does not suppress errors, however.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prior to log10 transformation, this function first scans for any zeros in the input vector. If it
finds any, it warns that zeros have been detected in the raw statistic, and that a pseudocount will be added.
To do this the function assesses the precision of the numbers in the numerical vector by counting decimal
places and determining the minimal non-zero number represented in the vector. It then takes whichever is the
lesser of those numbers and adds a pseudocount equal to the lesser of 1/2 the precision, or 1/2 the lowest
non-zero number.
</p>


<h3>Value</h3>

<p>A vector containing transformed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p_vals &lt;- c( 0.5, 0.001, 0.00001, 5e-19, 6.24e-23, 0 )
nzLog10( p_vals )

</code></pre>

<hr>
<h2 id='pick_MappedGeneSymbol'>pick_MappedGeneSymbol</h2><span id='topic+pick_MappedGeneSymbol'></span>

<h3>Description</h3>

<p>Function for matching values in <code>.from</code> vector derived from <code>Gene symbol</code> field
from GEO feature data (e.g. &quot;LOC101055758///LOC100041903///Gm2666///Gm7609///Csprs&quot;) with the first
match in <code>.to</code> vector. The point of this is for a given differentially expressed feature, match
the corresponding gene symbols to gene symbols present in a gene set collection. This (hopefully)
leads to mapping more features in a GEO dataset to more gene symbols in a gene set collection to be
searched. Symbol matches are done in a case independent way, and the value returned is the value in
the .to vector (with its particular capitalization), such that pathways analysis can be easily performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_MappedGeneSymbol(.from, .to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_MappedGeneSymbol_+3A_.from">.from</code></td>
<td>
<p>Character vector containing concatenated, triple-slash delimited gene symbols/identifiers
(e.g. &quot;LOC101055758///LOC100041903///Gm2666///Gm7609///Csprs&quot;)</p>
</td></tr>
<tr><td><code id="pick_MappedGeneSymbol_+3A_.to">.to</code></td>
<td>
<p>Character vector containing gene symbols to be matched (e.g. &quot;Gm2666&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the matched symbols.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GSNA)
# These gene symbols correspond to the `Gene Symbol` field from a GEO dataset:
gene_symbols.from &lt;- c( "BNS///CSMH///DDS1///THC8///BKRNS///BRWS1///PS1TP5BP1///ACTB",
                        "IP3R///IP3R1///ITPR1",
                        "FOS///p55///AP-1///C-FOS",
                        "MYC///LMYC///MYCL1///bHLHe38///L-Myc///v-myc"
                        )

# Extract unique genes from the \code{Bai_gsc.tmod} gene set:
gene_symbols.to &lt;- unique( unlist( tmod2gsc( Bai_gsc.tmod ) ) )

mapped_symbols &lt;- pick_MappedGeneSymbol( .from = gene_symbols.from,
                                         .to = gene_symbols.to )

# mapped_symbols returns: "ACTB", "ITPR1", "FOS", "MYC"


 # This example requires a web-based download of a GEO data set
 # and takes &gt; 20 seconds to run on some platforms.

 # This function is particularly useful with when mapping
 # the \code{`Gene symbol`} field of GEO feature data to
 # gene symbols in a GSC:

 library(GSNA)
 library(GEOquery)
 library(tmod)

 gset &lt;- getGEO("GSE75203", GSEMatrix =TRUE, AnnotGPL=TRUE)
 GSE75203.fdata &lt;- fData(gset$GSE75203_series_matrix.txt.gz)

 # We can match the gene gene symbols in GSE75203.fdata with
 # those in the provided Bai_gsc.tmod object, and add the
 # mapped gene symbol to a new column in GSE75203.fdata,
 # 'MappedGeneSymbol':
 GSE75203.fdata$MappedGeneSymbol &lt;-
   pick_MappedGeneSymbol( .from = GSE75203.fdata$`Gene symbol`,
                          .to = Bai_gsc.tmod$GENES$ID )
 # NOTE, if you were using a tmodGS object, the above
 # would be this instead:
 # GSE75203.fdata$MappedGeneSymbol &lt;-
 #   pick_MappedGeneSymbol( .from = GSE75203.fdata$`Gene symbol`,
 #                          .to = Bai_gsc.tmodGS$gv )



</code></pre>

<hr>
<h2 id='plot.GSNData'>plot plot.GSNData</h2><span id='topic+plot.GSNData'></span>

<h3>Description</h3>

<p>Plot method for the networks within GSNData objects, implemented with <code><a href="#topic+gsnPlotNetwork">gsnPlotNetwork</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GSNData'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.GSNData_+3A_x">x</code></td>
<td>
<p>A GSNData object containing a pared distance matrix with <code>edges</code>.</p>
</td></tr>
<tr><td><code id="plot.GSNData_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+gsnPlotNetwork">gsnPlotNetwork</a></code>
</p>

<dl>
<dt><code>object</code></dt><dd><p>A GSNData object containing a pared distance matrix with <code>edges</code>. NOTE: when calling as
<code>plot.GSNData</code>, use the argument <code>x</code> instead.</p>
</dd>
<dt><code>pathways_dat</code></dt><dd><p>(optional) data.frame containing associated pathways data. This defaults to whatever pathways
data has already been imported into this GSNData object in <code>object$pathways$data</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>(optional) The name of a distance metric used, defaults to whatever <code>default_distance</code> is.</p>
</dd>
<dt><code>id_col</code></dt><dd><p>(optional) This is the name of the column in the pathways data.frame that corresponds to the names of
gene sets. The default value is specified by <code>object$pathways$id_col</code>. (See details.)</p>
</dd>
<dt><code>substitute_id_col</code></dt><dd><p>(optional) This is the name of the column that is to be substituted for the <code>id_col</code>
column when labeling network vertices. (See details.)</p>
</dd>
<dt><code>stat_col</code></dt><dd><p>(optional) This is the name of the column in the pathways data.frame that contains a significance
value for coloring network vertices. The default value is specified by <code>object$pathways$stat_col</code>.</p>
</dd>
<dt><code>stat_col_2</code></dt><dd><p>(optional) This is the name of an optional second column in the pathways data.frame that
contains a significance value for coloring network vertices in a 2-color network. The default value is specified
by <code>object$pathways$stat_col_2</code>. When specified, a 2-color network is generated. To force a 2-color network
to plot as a standard 1-color network using <code>stat_col</code> alone, use <code>stat_col_2 = NA</code>.</p>
</dd>
<dt><code>sig_order</code></dt><dd><p>(optional) This indicates the behavior of <code>stat_col</code>, whether low values (<code>'loToHi'</code>) or
high values (<code>'hiToLo'</code>) are most significant. The default value is specified in <code>object$pathways$sig_order</code>.</p>
</dd>
<dt><code>sig_order_2</code></dt><dd><p>(optional) This indicates the behavior of <code>stat_col_2</code>, whether low values (<code>'loToHi'</code>) or
high values (<code>'hiToLo'</code>) are most significant. The default value is specified in <code>object$pathways$sig_order_2</code>.</p>
</dd>
<dt><code>n_col</code></dt><dd><p>(optional) This is the name of the column in the pathways data.frame that contains a value for gene set
size, or any other value intended to be the bases of leaf scaling. When specified, leaf sizes will be scaled by this
value, either as a function argument, or in the <code>object$pathways$n_col</code> field. An <code>NA</code> value can be used
to override the the value in <code>object$pathways$n_col</code> and suppress leaf scaling when <code>n_col</code> has been
set in the object. (default is the value in <code>object$pathways$n_col</code>).</p>
</dd>
<dt><code>optimal_extreme</code></dt><dd><p>(optional) This indicates the behavior of the statistic used to generate the distance metric,
specifically whether low values (<code>'min'</code>) or high values <code>'max'</code> are to be regarded as close. This is used
for scaling the width and the color of the edges connecting vertices. See <code>scale.edges.by.distance</code>, below:
(default: object$distances[<a href="analogue.html#topic+distance">distance</a>]$pared_optimal_extreme or if that's NULL,
object$distances[<a href="analogue.html#topic+distance">distance</a>]$optimal_extreme)</p>
</dd>
<dt><code>transform_function</code></dt><dd><p>(optional) This is a function to transform the values in <code>stat_col</code> so that they
are suitable for amenable to color-scaling. For <em>p</em>-values, a log transformation is often useful, but can produce
negative infinities if the transformation is applied to zero. By default the function is the <code>nzLog10</code>
(non-zero log10) function, provided by this package, which adds a small pseudocount to p-values when log10 transforming
values equal to zero. If values in <code>stat_col</code> are less than zero, then log10 transformation is inappropriate and
will introduce NAs, and therefore some other method should be used. (default: <code>nzLog10</code>)</p>
</dd>
<dt><code>pathways_title_col</code></dt><dd><p>(optional) Indicates a column to be used as the 'Title' column for network vertices.
If unset, the function attempts to search for a title column from the following values: c(&quot;Title&quot;, &quot;Name&quot;, &quot;NAME&quot;,
&quot;STANDARD_NAME&quot; ) (See details.)</p>
</dd>
<dt><code>edge_colors</code></dt><dd><p>(optional) A vector of colors included to generate a scale represent the numerical value of the
edge distances. By default, the colors are arranged as a rainbow with black and purple representing the greatest
distances, and orange and red the nearest distances. This feature (and argument) will likely be deprecated in
future versions. (default: edge_colors = c(&quot;black&quot;, &quot;purple&quot;, &quot;blue&quot;, &quot;green&quot;,&quot;yellow4&quot;, &quot;orange&quot;,&quot;red&quot;))</p>
</dd>
<dt><code>vertex_colors</code></dt><dd><p>(optional) This is the standard set of colors used for a standard single color network.
By default, c(&quot;white&quot;,&quot;yellow&quot;,&quot;red&quot;) is used, coloring low values white, high values red, and intermediate values
yellow if <code>sig_order</code> is &quot;loToHi&quot; and vice versa if sig_order is &quot;hiToLo&quot;.</p>
</dd>
<dt><code>vertex_colors.1</code></dt><dd><p>(optional) This is the range of colors used for a 2-color network corresponding to
values of <code>stat_col</code>. Up to 2 colors can be used, and should correspond to a color contrasting with
<code>vertex_colors.2</code>. The default is c(&quot;white&quot;,&quot;red&quot;), coloring high values red and low values white if
<code>sig_order</code> is <code>"loToHi"</code> and vice versa if <code>sig_order</code> is <code>"hiToLo"</code>.</p>
</dd>
<dt><code>vertex_colors.2</code></dt><dd><p>(optional) This is the range of colors used for a 2-color network corresponding to
values of <code>stat_col_2</code>. Up to 2 colors can be used, and should correspond to a color contrasting with
<code>vertex_colors.2</code>. The default is <code>c("white","blue")</code>, coloring high values blue and low values white
if <code>sig_order_2</code> is <code>"loToHi"</code> and vice versa if <code>sig_order</code> is <code>"hiToLo"</code>.</p>
</dd>
<dt><code>combine_method</code></dt><dd><p>(optional) For dual channel plots this is a string used to indicate how colors are combined to
generate a two dimensional color scale. Options are &quot;scaled_geomean&quot; (same as &quot;default&quot;), &quot;standard&quot; (same as &quot;euclidean&quot; ),
&quot;negative_euclidean&quot;, &quot;mean&quot;, and &quot;additive&quot;. See details.</p>
</dd>
<dt><code>na.color</code></dt><dd><p>(optional) This color is assigned to vertices for which there is an <code>NA</code> value. (default: &quot;#CCCCCC&quot;)</p>
</dd>
<dt><code>filename</code></dt><dd><p>(optional) An output file name for the plot. If 'out_format' is not set (see below), the output
file type will be determined by the file suffix, which can be <code>'.svg'</code>, <code>'.pdf'</code>, or <code>'.png'</code>. If
the <code>out_format</code> cannot be determined from the file name, than it may be manually set with <code>out_format</code>.
If the output file type cannot be determined from the <code>filename</code> or <code>out_format</code> arguments, an error will
be thrown.</p>
</dd>
<dt><code>out_format</code></dt><dd><p>(optional) Output filetype when <code>filename</code> is specified, either <code>'svg'</code>, <code>'png'</code>,
<code>'pdf'</code>, or <code>'plot'</code> (default if filename is not specified). For more information, see Details.</p>
</dd>
<dt><code>width</code></dt><dd><p>(optional) Sets the width of the output canvas in inches. Defaults to the width of the present
graphical device.</p>
</dd>
<dt><code>height</code></dt><dd><p>(optional) Sets the height of the output canvas in inches. Defaults to the height of the present
graphical device.</p>
</dd>
<dt><code>vertex.shape</code></dt><dd><p>(optional) Shape of the vertex, passed to <code>igraph::plot.igraph</code>. By default, the value is
<code>'circle'</code>.</p>
</dd>
<dt><code>vertex.size</code></dt><dd><p>(optional) Size of vertices, passed to <code>igraph::plot.igraph</code>. By default, the value is
NULL, and the function attempts to pick a reasonable value based on the canvas size and the number of gene sets.</p>
</dd>
<dt><code>vertex.size.range</code></dt><dd><p>(optional) The range of vertex sizes used in plots, from low to high. This is used when
<code>n_col</code> is specified and vertex sizes are intended to be scaled. If this is not specified, then the function
attempts to select appropriate values based on size of the figure being generated.</p>
</dd>
<dt><code>vertex.label.cex</code></dt><dd><p>(optional) Size of vertex labels, passed to <code>igraph::plot.igraph</code>. As with vertex.size,
by default, the value is NULL, and the function attempts to pick a reasonable value based on the canvas size and
the number of gene sets.</p>
</dd>
<dt><code>vertex.label.col</code></dt><dd><p>(optional) Color of vertex labels, passed to <code>igraph::plot.igraph</code>. If not specified,
the function attempts to pick a contrasting color for vertex label text using the <code>contrasting_color.fun</code>
argument. (default: NULL)</p>
</dd>
<dt><code>vertex.frame.color</code></dt><dd><p>(optional) Color of the vertex border. (default par('fg'))</p>
</dd>
<dt><code>contrasting_color.fun</code></dt><dd><p>(optional) A function to pick a color for vertex labels that contrasts with the vertex
fill color. If unspecified, the function attempts to pick a suitable function for generating suitable set of contrasting
colors, based on the <code>contrasting_color()</code> function. (default: For single channel plots using color scales defined
with <code>vertex_colors</code>, or dual channel color scales defined with <code>vertex_colors.1</code>, or <code>vertex_colors.2</code>
using yellow or orange, <code>contrasting_color(type="binary")</code> is used, and otherwise
<code>contrasting_color(type="blackyellow")</code> is used.)</p>
</dd>
<dt><code>scale_labels_by_vertex</code></dt><dd><p>(optional) Logical that tells the function to scale the text in vertex labels by the size
of the vertex. (default: TRUE)</p>
</dd>
<dt><code>max_edge_width</code></dt><dd><p>(optional) Size of vertex labels, passed to <code>igraph::plot.igraph</code>. By default, the value
is NULL, and the function attempts to pick a reasonable value based on the canvas size and the number of gene sets.</p>
</dd>
<dt><code>scale.edges.by.distance</code></dt><dd><p>(optional) A logical telling the function to scale edges between vertices on the basis
of distance. NOTE: If <code>optimal_extreme == "max"</code>, then smaller numbers are treated as more distant, and conversely
if <code>optimal_extreme == "min"</code>, larger numbers are treated as more distant. (default: FALSE)</p>
</dd>
<dt><code>color.edges.by.distance</code></dt><dd><p>(optional)  A logical telling the function to color edges between vertices on the basis
of distance. This functionality will likely be deprecated. (default: FALSE)</p>
</dd>
<dt><code>edge_arrow_size</code></dt><dd><p>(optional) Size of vertex labels, passed to <code>igraph::plot.igraph</code>. By default, the value
is NULL, and the function attempts to pick a reasonable value based on the canvas size and the number of gene sets.</p>
</dd>
<dt><code>seed</code></dt><dd><p>(optional) This is a seed that the function uses to generate a plot layout. By default it is 29189892,
and this results in a repeatable behavior for plots. However, to randomize the plot layout behavior, this value may
be set to NULL, or if some other repeatable layout is desired, another seed may be used.</p>
</dd>
<dt><code>layout</code></dt><dd><p>(optional) Either a function that generates a layout or a numerical matrix containing a vertex layout
with two columns corresponding to <em>x</em> and <em>y</em> coordinates. This argument is passed to the <code>igraph</code> plot method
that is subsequently called by <code>gsnPlotNetwork()</code> (see <code>.plot</code>, below). The default <code>layout</code> is
the anonymous function <code>function(x){igraph::layout_with_fr(x, grid = "nogrid" )}</code>, which calls
<code>igraph::layout_with_fr()</code> (implementing Fruchterman-Reingold layout) with the <code>grid="nogrid"</code> option,
enabling proper layout of networks with &gt;= 1000 gene set vertices. Other useful layouts for <code>igraph</code> networks
include <code>igraph::layout_with_fr</code> (default Fruchterman-Reingold), <code>igraph::layout_with_dh</code> (implementing
Davidson-Harel layout), <code>igraph::layout_as_tree</code>, <code>igraph::layout_nicely</code>, and others.
For more details about layouts, see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>.</p>
</dd>
<dt><code>.plot</code></dt><dd><p>(optional) A plot function used to render the internally generated <code>igraph</code> object. By default
<code>igraph::plot.igraph</code> is used, but for interactive plotting, <code>igraph::tkplot</code> may be used. For more
details about plotting, see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>.</p>
</dd>
<dt><code>show.legend</code></dt><dd><p>(optional) A logical value telling the function whether or not to show legends. Legends for vertex
size and node color are currently supported. (default: TRUE)</p>
</dd>
<dt><code>legend.lab.cex</code></dt><dd><p>(optional) The font size of legend label text as cex units. If not specified, the function will
attempt to pick an appropriate value based on the figure layout.</p>
</dd>
<dt><code>legend.axis.cex</code></dt><dd><p>(optional) The font size of legend axis text as cex units. If not specified, the function will
attempt to pick an appropriate value based on the figure layout.</p>
</dd>
<dt><code>legend.fg</code></dt><dd><p>(optional) The foreground color of the legend that controls the color of text, axes, axis labels,
ticks, and legend border. (default: par('fg'))</p>
</dd>
<dt><code>legend.bg</code></dt><dd><p>(optional) The background color of the legend. This argument doesn't currently work, and may be
removed in the future. (default: &quot;#CCCCCC&quot; )</p>
</dd>
<dt><code>legend.vertex.fg</code></dt><dd><p>(optional) The border color of vertices for vertex size legends. This argument allows the
legend vertex frame color to be set separately from vertex.frame.color. (default: vertex.frame.color)</p>
</dd>
<dt><code>legend.vertex.bg</code></dt><dd><p>(optional) The fill color of vertices for vertex size legends. (default: &quot;#DDDDDD&quot;)</p>
</dd>
<dt><code>font_face</code></dt><dd><p>(optional) The font face used for the figure. (default: par(&quot;family&quot;))</p>
</dd>
<dt><code>main</code></dt><dd><p>(optional) The plot title. (default: NULL)</p>
</dd>
<dt><code>cex.main</code></dt><dd><p>(optional) The font size in cex units of the main title. (default: 1.5 * par( 'cex' ))</p>
</dd>
<dt><code>mar.main</code></dt><dd><p>(optional) The number of lines set aside for a main title when main is used. (default: 3.2)</p>
</dd>
<dt><code>lines.main</code></dt><dd><p>(optional) The distance of the main title in lines from the top of the plot. (default: 0.9)</p>
</dd>
<dt><code>.mar.plot</code></dt><dd><p>(optional) The margins of the plot itself. If unspecified, the function will attempt to reserve
enough room to the right of the plot for the legend or legends.</p>
</dd>
<dt><code>draw.legend.box.bool</code></dt><dd><p>(option) Logical indicating whether bounding boxes should be drawn for the legends.</p>
</dd>
<dt><code>legend.free.cex.bool</code></dt><dd><p>(optional) Logical allowing independent optimized sizing of legend label font sizes if TRUE.
(default: FALSE)</p>
</dd>
<dt><code>legend_x_size.in</code></dt><dd><p>(optional) The width of the legend in inches. If not set, the function attempts to choose an
appropriate value. (default: <code>min(2,max(width*2/5,width-height))</code>)</p>
</dd>
<dt><code>colors.n</code></dt><dd><p>(optional) The number of colors in for each channel in 1 or 2 channel plots. For single channel plots
the number of colors is simply equal to this number. For dual channel plots the total number of colors in the legend
is equal to the square of this number. (default: 100)</p>
</dd>
<dt><code>new</code></dt><dd><p>(optional) Logical telling the function (if true) that a new plot should be added to an existing device (if
TRUE) or that the current device should be cleared and written over (if FALSE). (default: FALSE)</p>
</dd>
<dt><code>legend_spacing.x.in</code></dt><dd><p>(optional) Space between plot and legend in inches. This can be used to adjust the horizontal
position and move the legend closer to or farther away from the plot region. Since the network plot may not fill the
entire plotting region, it may be useful to use negative values to move the legends closer to the plot.
(default: 2 character widths)</p>
</dd>
<dt><code>legend_spacing.y.in</code></dt><dd><p>(optional) Space between legends in inches. (default: 1 character height)</p>
</dd>
<dt><code>resolution</code></dt><dd><p>Image resolution in pixels per inch, only for bitmap image output formats (currently
png only). (default: 72)</p>
</dd>
<dt><code>DO_BROWSER</code></dt><dd><p>(option) Logical indicating whether browser() should be run for this function. (For debugging
purposes, will probably remove.)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily for taking <code>GSNData</code> object containing a distance matrix, an associated
<code>edges</code> edge-list and pathways data, and generating and rendering a corresponding <code>igraph</code> object. The
function attempts to plot the corresponding network with vertices labeled with a gene set <code>ID</code> and corresponding
<code>Title</code>, and colored according to the significance values represented in <code>stat_col</code> using <code>sig_order</code>
as an indicator of whether high or low values are more significant. Edges are scaled by the value of the value of the
distance statistic in the pared distance matrix.
</p>
<p>When the parameters <code>vertex.shape</code>, <code>vertex.size</code>, <code>vertex.label.cex</code>, <code>max_edge_width</code>, and
<code>edge_arrow_size</code> are not specified, the function attempts to pick reasonable values. These parameters are
assembled into a list and attached to the returned <code>igraph</code> object as an attribute named <code>GSNA_plot_params</code>.
To optimize plots, the user can examine these parameters by calling the following on the output of the function:
</p>
<p><code>attr( x = nw.igraph, which = "GSNA_plot_params" )</code>
</p>


<h3>Value</h3>

<p>An <code>igraph</code> network object is returned, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnPlotNetwork">gsnPlotNetwork</a></code>
<code><a href="#topic+gsnToIgraph">gsnToIgraph</a></code>
<code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# This example can take &gt;10 seconds to run on some platforms,
# so we won't test it here.

library(GSNA)

# In this example, we generate a gene set network from CERNO example
# data. We begin by subsetting the CERNO data for significant results:
sig_pathways.cerno &lt;- subset( Bai_CiHep_DN.cerno, adj.P.Val &lt;= 0.05 )

# Now create a gene set collection containing just the gene sets
# with significant CERNO results, by subsetting Bai_gsc.tmod using
# the gene set IDs as keys:
sig_pathways.tmod &lt;- Bai_gsc.tmod[sig_pathways.cerno$ID]

# And obtain a background gene set from differential expression data:
background_genes &lt;- toupper( rownames( Bai_CiHep_v_Fib2.de ) )

# Build a gene set network:
sig_pathways.GSN &lt;-
   buildGeneSetNetworkJaccard(geneSetCollection = sig_pathways.tmod,
                              ref.background = background_genes )

# Now import the CERNO data:
sig_pathways.GSN &lt;- gsnImportCERNO( sig_pathways.GSN,
                                    pathways_data = sig_pathways.cerno )

# Now we can pare the network and assign subnets:
sig_pathways.GSN &lt;- gsnPareNetGenericHierarchic( object = sig_pathways.GSN )
sig_pathways.GSN &lt;- gsnAssignSubnets( sig_pathways.GSN )

# Now, produce a network plot:
gsnPlotNetwork( object  = sig_pathways.GSN )


</code></pre>

<hr>
<h2 id='print.GSNData'>print.GSNData</h2><span id='topic+print.GSNData'></span>

<h3>Description</h3>

<p>Print a short description of a <code>GSNData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GSNData'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.GSNData_+3A_x">x</code></td>
<td>
<p>A GSNData object.</p>
</td></tr>
<tr><td><code id="print.GSNData_+3A_...">...</code></td>
<td>
<p>Additional parameters currently ignored, but included for consistency with generic print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the GSNData object.
</p>

<hr>
<h2 id='read_david_data_file'>read_david_data_file</h2><span id='topic+read_david_data_file'></span>

<h3>Description</h3>

<p>Parses a text file output by the DAVID web application (<a href="https://david.ncifcrf.gov/">https://david.ncifcrf.gov/</a>)
(see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_david_data_file(file, output = "flat", redundant = FALSE, sep = "\t")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_david_data_file_+3A_file">file</code></td>
<td>
<p>A file path pointing to a DAVID &quot;Functional Annotation Cluster&quot; or &quot;Functional Annotation Chart&quot; text file.</p>
</td></tr>
<tr><td><code id="read_david_data_file_+3A_output">output</code></td>
<td>
<p>(optional) Specifies the type of output. (default &quot;flat&quot;) This parameter can take one of three values:
</p>

<dl>
<dt>&quot;flat&quot;:</dt><dd><p> If &quot;flat&quot; is specified, a single data.frame containing the standard DAVID output fields is returned.
For &quot;Functional Annnotation Cluster&quot; data, an additional column named <code>`Cluster (ES)`</code> is included,
containing for each gene set, comma-separated DAVID <code>`Annotation Cluster`</code> assignments and in parentheses,
DAVID Enrichment Scores.</p>
</dd>
<dt>&quot;hierarchic&quot;:</dt><dd><p> For &quot;hierarchic&quot; output, a list containing a set of data.frames for each <code>`Annotation Cluster`</code> is
returned. This only works with &quot;Functional Annotation Cluster&quot; output.</p>
</dd>
<dt>&quot;GSC&quot;:</dt><dd><p> DAVID data sets contain nested gene sets in their <code>`Genes`</code> column. The gene sets can be extracted as a
list of gene set vectors by specifying this option.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="read_david_data_file_+3A_redundant">redundant</code></td>
<td>
<p>(optional) The &quot;Functional Annotation Cluster&quot; output of DAVID contains fuzzy DAVID clusters in which
a given gene set may be assigned to multiple clusters. As a result, some gene sets can have multiple lines in a
&quot;Functional Annotation Cluster&quot; output file, resulting in redundant data.frame rows. If this value is <code>FALSE</code>,
the returned &quot;flat&quot; data.frame will have gene set duplicates removed and the DAVID <code>`Annotation Cluster`</code> identities
of each gene set listed as comma separated values in the <code>`Cluster (ES)`</code> column. If <code>TRUE</code> than the redundancies
are tolerated and replicate gene set rows are not collapsed. (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="read_david_data_file_+3A_sep">sep</code></td>
<td>
<p>(optional) Specifies the separator used in the DAVID output file. This probably does not need to be specified.
(default &quot;\t&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function parses tab-separated text files from the DAVID web application
(<a href="https://david.ncifcrf.gov/">https://david.ncifcrf.gov/</a>). Two variants of DAVID output are supported,
specifically the data format generated by selecting &quot;Functional Annotation Chart&quot; or &quot;Functional Annotation Cluster&quot;
and downloading the resulting data as a text file.
</p>
<p>The parser expects the following fields in the data: &quot;Category&quot;, &quot;Term&quot;, &quot;Count&quot;, &quot;%&quot;, &quot;PValue&quot;,
&quot;Genes&quot;, &quot;List Total&quot;, &quot;Pop Hits&quot;, &quot;Pop Total&quot;, &quot;Fold Enrichment&quot;, &quot;Bonferroni&quot;, &quot;Benjamini&quot;, and &quot;FDR&quot;.
</p>
<p>To create a data.frame suitable for use with <code><a href="#topic+gsnAddPathwaysData">gsnAddPathwaysData</a>()</code>, the default options are required,
particularly <code>output = "flat"</code> and <code>redundant = FALSE</code>.
</p>


<h3>Value</h3>

<p>The function returns either a data.frame containing DAVID data, a list of data.frames, or a list of gene sets.
(see documentation for the <code>output</code> parameter above).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsnImportDAVID">gsnImportDAVID()</a></code>
</p>

<hr>
<h2 id='read_gmt'>read_gmt</h2><span id='topic+read_gmt'></span>

<h3>Description</h3>

<p>This function parses a GMT file, documented
<a href="https://software.broadinstitute.org/cancer/software/gsea/wiki/index.php/Data_formats#GMT:%5Cemph%7BGene_Matrix_Transposed_file_format%7D.28.2A.gmt.29">here</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_gmt(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_gmt_+3A_file">file</code></td>
<td>
<p>The path to GMT file to parse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a GSC (gene set collection) as a name list of vectors, where the names correspond to gene set
identifiers and the vectors are gene symbols.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsc2tmod">gsc2tmod()</a></code>
</p>

<hr>
<h2 id='scoreJaccardMatrix_C'>scoreJaccardMatrix_C</h2><span id='topic+scoreJaccardMatrix_C'></span>

<h3>Description</h3>

<p>Takes a presence/absence matrix with genes as the rows and modules as columns and calculates
a matrix of Jaccard index values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreJaccardMatrix_C(geneSetCollection_m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoreJaccardMatrix_C_+3A_genesetcollection_m">geneSetCollection_m</code></td>
<td>
<p>(required) A logical presence/absence matrix representation of a gene set collection
in which columns correspond to gene sets, rows correspond to genes and values are <code>TRUE</code> if a gene is present
in a gene set and <code>FALSE</code> otherwise. Row and column names correspond to gene symbols and gene set
identifiers, respectively. NOTE: for a typical GSNA analysis, this matrix would include only observed filtered
genes and significant gene set hits from pathways analysis. Using a matrix version of the full MSigDB without filtering
genes, for example, would likely be unworkably slow and memory intensive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jaccard index J for two sets A and B is defined as:
</p>
<p style="text-align: center;"><code class="reqn"> J(A,B) = \dfrac{\lvert A \cap B \rvert}{\lvert A \cup B \rvert} </code>
</p>



<h3>Value</h3>

<p>This function returns a matrix of Jaccard index values between gene modules. Values on the diagonal
corresponding to self-Jaccard indices are returned as NA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildGeneSetNetworkJaccard">buildGeneSetNetworkJaccard</a>()</code>
<code><a href="#topic+scoreLFMatrix_C">scoreLFMatrix_C</a>()</code>
</p>
<p>@import Rcpp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# Get the background of observable genes set from
# expression data:
gene_background &lt;- toupper(rownames( Bai_empty_expr_mat ))

# Using the sample gene set collection **Bai_gsc.tmod**,
# generate a gene presence-absence matrix filtered for the
# ref.background of observable genes:
presence_absence.mat &lt;-
 makeFilteredGenePresenceAbsenceMatrix( ref.background = gene_background,
                                        geneSetCollection = Bai_gsc.tmod )

jaccard.mat &lt;- scoreJaccardMatrix_C( presence_absence.mat )

</code></pre>

<hr>
<h2 id='scoreLFMatrix_C'>scoreLFMatrix_C</h2><span id='topic+scoreLFMatrix_C'></span>

<h3>Description</h3>

<p>Takes a presence/absence matrix with genes as the rows and modules as columns and calculates
a matrix of log-transformed Fisher <em>p</em>-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreLFMatrix_C( geneSetCollection_m,
                  e_precision = as.numeric(c(12)),
                  alternative = as.integer(c(1)))

# # NOTE: The following also works and may be preferable for
# # many users:
# scoreLFMatrix_C( geneSetCollection_m,
#                  e_precision = 12,
#                  alternative = 1 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoreLFMatrix_C_+3A_genesetcollection_m">geneSetCollection_m</code></td>
<td>
<p>(required) A logical presence/absence matrix representation of a gene set collection
in which columns correspond to gene sets, rows correspond to genes and values are <code>TRUE</code> if a gene is present
in a gene set and <code>FALSE</code> otherwise. Row and column names correspond to gene symbols and gene set
identifiers, respectively. NOTE: for a typical GSNA analysis, this matrix would include only observed filtered
genes and significant gene set hits from pathways analysis. Using a matrix version of the full MSigDB without filtering
genes, for example, would likely be unworkably slow and memory intensive.</p>
</td></tr>
<tr><td><code id="scoreLFMatrix_C_+3A_e_precision">e_precision</code></td>
<td>
<p>(optional, default 12) Numeric to control the precision of the log p-value calculated.
Due to precision limits inherent in C++ double precision numbers, log p-values for which the corresponding
untransformed p-values differ by more than a certain magnitude cannot effectively be added. This feature
was introduced as a way to accelerate summation of p-values so as to allow summation to be cut off
when the acceptable level of precision had been reached, but it was found that it also seems to prevent
artifacts caused by arithmetic underflow.</p>
</td></tr>
<tr><td><code id="scoreLFMatrix_C_+3A_alternative">alternative</code></td>
<td>
<p>(optional, default 1) An integer value specifying one of 4 alternative p-value calculations
where <code>1</code> specifies single, upper tail log Fisher p-value, <code>2</code> signifies single, lower-tail Fisher
p-value, <code>3</code> signifies 2-tailed Fisher p-value, and <code>4</code> signifies partial Fisher p-value (see below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fisher <em>p</em>-values have long been used to assess the statistical significance of over- or underrepresentation
of a component of a mixture to assess whether a sample is drawn from a particular mixture. The test has also
long been used in pathways analysis as a way to assess whether an experimentally derived list of genes
contains a statistical overrepresentation of genes from predefined gene sets or modules. Such experimental gene
lists may include differentially expressed genes from a transcriptomic experiment, genes possessing promoters
with differential chromatin accessibility from an ATAC-Seq experiments, genes that were positive in screens of
mutants, genes that were identified from GWAS experiments, and genes from other analyses. Likewise, the gene
sets or modules are generally drawn from databases of experimentally characterized pathways, sets of genes
over- or under-expressed in particular conditions, or associated with particular biological processes,
chromosome regions, etc.
</p>
<p>In the case of GSNA, we use the Fisher test to assess the overlap of genes not between an experimentally
derived gene list and predefined gene sets from a database, but between the predefined gene sets themselves
given their observability in a particular experiment.
</p>


<h3>Value</h3>

<p>A numerical matrix containing the specified log Fisher <em>p</em>-values for all non-self pairs. Values on the
diagonal (which would correspond to self-self comparison <em>p</em>-values) are NA. The <code>'lower_is_closer'</code>
attribute on the matrix is set to <code>TRUE</code>, except in the case of <code>alternative=2</code> where it is set
to <code>FALSE</code>.
</p>
<p>The <code>distance</code> attribute in the output matrix is set to <code>'stlf'</code> for option 1 (single, upper tail),
<code>'ltlf'</code> for option 2 (lower tail), <code>'ttlf'</code> for option 3 (two-tailed), and <code>'lf'</code> for option 4
(log partial Fisher <em>p</em>-value).
</p>


<h3>Implementation</h3>

<p>We use the Fisher test to assess the statistical significance of the overlap of two gene sets. For our purposes
the test determines whether two gene sets share a greater (or in some cases less) than expected number of common
members, assuming a null hypothesis of random membership. The two sets need not necessarily be of the same size,
but are for the purposes of the test assumed to have set sizes.
</p>
<p>Consider a 2x2 contingency matrix of the following form:
</p>
<p style="text-align: center;"><code class="reqn">\biggl[\begin{matrix}a &amp; b \\ c &amp; d\end{matrix}\biggr]</code>
</p>

<p>Given a background of observable genes and two gene sets, <em>i</em> and <em>j</em> that may overlap, this contingency
table is used to represent four numbers:
</p>

<ul>
<li><p><em>a</em>: the number of genes observed in the background but not in <em>i</em> or <em>j</em>
</p>
</li>
<li><p><em>b</em>: the number of observed genes in <em>i</em> but not <em>j</em>
</p>
</li>
<li><p><em>c</em>: the number of observed genes in <em>j</em> but not <em>i</em> and
</p>
</li>
<li><p><em>d</em>: the number of observed genes in both <em>j</em> and <em>i</em>, i.e. the overlap.
</p>
</li></ul>

<p>The <em>partial</em>-Fisher <em>p</em>-value, signifying the likelihood of that particular contingency
table is given by:
</p>
<p style="text-align: center;"><code class="reqn">p = \dfrac{(a + b)! (c + d)! (a + c)! (b + d)!}{a! b! c! d! (a+b+c+d)!}</code>
</p>

<p>This partial <em>p</em>-value is what is returned in the distance matrix when the argument <code>alternative = 4</code>
and it is less than, though tracks closely with, the two-tailed p-value, in most cases.
</p>
<p>The actual single- and two-tailed <em>p</em>-values are derived from this number by summation, keeping the sum of
each row and column of the 2x2 contingency matrix constant, as per the assumptions of the Fisher test.
For the single-tailed alternative representing the upper-tail 'greater-than' expected overlap of the two gene
sets (<code>alternative = 1</code>), the terms start with <em>d</em> as the observed number of shared members between set
<em>i</em> and set <em>j</em>. Then <em>d</em> is incremented toward the maximal number possible shared genes (the lesser of the
number of genes in sets <em>i</em> and <em>j</em>). <em>a</em>, <em>b</em>, and <em>c</em> adjusted accordingly to keep constant row and
column sums, and the partial <em>p</em>-values are thus summed.
</p>
<p>For the lower-tail ('less-than') alternative (<code>alternative = 2</code>), the summation starts with <em>d</em> as the
number of shared members of sets between <em>i</em> and <em>j</em>, (as with the upper-tail calculation) but then decrements
that to 0.
</p>
<p>For the 2-tailed alternative, the function sums all the terms with values equal to or less than the the
partial <em>p</em>-value defined above.
</p>
<p>All calculations are done on log-transformed values to avoid arithmetic underflow:
</p>
<p style="text-align: center;"><code class="reqn">
 ln(p) = ln(( a + b )!) + ln(( c + d )!) +
         ln(( a + c )!) + ln(( b + d )!) -
         ln(a!) - ln(b!) - ln(c!) - ln(d!) -
         ln(( a + b + c + d )!)
</code>
</p>

<p>Since log-transformed <em>p</em>-values cannot be directly added, the so-called log-sum-exponential trick is used to
combine them.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildGeneSetNetworkLFFast">buildGeneSetNetworkLFFast</a></code>
<code><a href="#topic+scoreJaccardMatrix_C">scoreJaccardMatrix_C</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library( GSNA )

# Get the background of observable genes set from
# expression data:
gene_background &lt;- toupper(rownames( Bai_empty_expr_mat ))

# Using the sample gene set collection **Bai_gsc.tmod**,
# generate a gene presence-absence matrix filtered for the
# ref.background of observable genes:
presence_absence.mat &lt;-
  makeFilteredGenePresenceAbsenceMatrix( ref.background = gene_background,
                                         geneSetCollection = Bai_gsc.tmod )

lf.mat &lt;- scoreLFMatrix_C( presence_absence.mat,  1 )

</code></pre>

<hr>
<h2 id='scoreOCMatrix_C'>scoreOCMatrix_C</h2><span id='topic+scoreOCMatrix_C'></span>

<h3>Description</h3>

<p>Takes a presence/absence matrix with genes as the rows and modules as columns and calculates
a matrix of overlap coefficient values (also known as Szymkiewicz–Simpson coefficients^1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreOCMatrix_C(geneSetCollection_m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoreOCMatrix_C_+3A_genesetcollection_m">geneSetCollection_m</code></td>
<td>
<p>(required) A logical presence/absence matrix representation of a gene set collection
in which columns correspond to gene sets, rows correspond to genes and values are <code>TRUE</code> if a gene is present
in a gene set and <code>FALSE</code> otherwise. Row and column names correspond to gene symbols and gene set
identifiers, respectively. NOTE: for a typical GSNA analysis, this matrix would include only observed filtered
genes and significant gene set hits from pathways analysis. Using a matrix version of the full MSigDB without filtering
genes, for example, would likely be unworkably slow and memory intensive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The overlap (or Szymkiewicz–Simpson) coefficient for two sets A and B is defined as:
</p>
<p style="text-align: center;"><code class="reqn"> OC(A,B) = \dfrac{\lvert A \cap B \rvert}{min(\lvert A \rvert, \lvert B \rvert)} </code>
</p>



<h3>Value</h3>

<p>This function returns a matrix of overlap coefficient values between gene modules. Values on the diagonal
corresponding to self-overlap coefficients are returned as NA.
</p>


<h3>References</h3>


<ol>
<li><p> M.K V, K K. A Survey on Similarity Measures in Text Mining. MLAIJ. 2016;3: 19–28. doi:10.5121/mlaij.2016.3103
</p>
</li></ol>

<p>@import Rcpp
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildGeneSetNetworkOC">buildGeneSetNetworkOC</a></code>
<code><a href="#topic+scoreLFMatrix_C">scoreLFMatrix_C</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GSNA)

# Get the background of observable genes set from
# expression data:
gene_background &lt;- toupper(rownames( Bai_empty_expr_mat ))

# Using the sample gene set collection **Bai_gsc.tmod**,
# generate a gene presence-absence matrix filtered for the
# ref.background of observable genes:
presence_absence.mat &lt;-
  makeFilteredGenePresenceAbsenceMatrix( ref.background = gene_background,
                                         geneSetCollection = Bai_gsc.tmod )

# Now generate an overlap coefficient matrix.
oc.mat &lt;- scoreOCMatrix_C( presence_absence.mat )


</code></pre>

<hr>
<h2 id='tmod2gsc'>tmod2gsc</h2><span id='topic+tmod2gsc'></span>

<h3>Description</h3>

<p>Function takes a tmod or tmodGS object and converts it to a gene set collection. In the case of a
tmod object, the function merely extracts the <code>$MODULES2GENES</code> list of character vectors. In the case of
tmodGS objects, the list of vectors of numeric gene identifiers in <code>$gs2gv</code> is converted to a named list
of character vectors of gene names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmod2gsc(tmod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmod2gsc_+3A_tmod">tmod</code></td>
<td>
<p>: a tmod or tmodGS object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a gene set collection as a named list of character vectors containing gene names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsc2tmod">gsc2tmod()</a></code>
</p>

<hr>
<h2 id='write_gmt'>write_gmt</h2><span id='topic+write_gmt'></span>

<h3>Description</h3>

<p>Takes a gene set collection (as a named list of vectors of genes), and a filename, and writes GMT format.
Right now, keeping this private.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_gmt(gsc, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_gmt_+3A_gsc">gsc</code></td>
<td>
<p>A GSC (gene set collection) as a named list of character vectors of gene symbols, where
the names of the list items correspond to gene set identifiers.</p>
</td></tr>
<tr><td><code id="write_gmt_+3A_filename">filename</code></td>
<td>
<p>An output file name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks to see that the gsc argument is in fact a list of character vectors. If not,
it fails.
</p>


<h3>Value</h3>

<p>Currently returns a NULL value, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GSNA)
gmtfile &lt;- tempfile()
Bai_gsc.GSC &lt;- tmod2gsc( Bai_gsc.tmod )
write_gmt( gsc = Bai_gsc.GSC, filename = gmtfile )

</code></pre>

<hr>
<h2 id='yassifyPathways'>yassifyPathways</h2><span id='topic+yassifyPathways'></span>

<h3>Description</h3>

<p>Takes a data.frame and outputs an attractively formatted HTML table widget for reports via the
using the DT and data.table package. Optionally, the user can specify, via the <code>n</code> parameter, the number
of rows to display in the HTML table. Optionally, IDs in specific columns can be mapped to URLs as links.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yassifyPathways(
  pathways,
  n = NULL,
  url_map_list = list(),
  url_map_by_words_list = list(),
  min_decimal = 5e-04,
  quiet = TRUE,
  table_row_colors = c(`1` = "#EEF", `2` = "#FFD"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yassifyPathways_+3A_pathways">pathways</code></td>
<td>
<p>A data.frame containing pathways data.</p>
</td></tr>
<tr><td><code id="yassifyPathways_+3A_n">n</code></td>
<td>
<p>(optional) The number of rows that the user wishes to display. This defaults to the total number of rows.</p>
</td></tr>
<tr><td><code id="yassifyPathways_+3A_url_map_list">url_map_list</code></td>
<td>
<p>(optional) A list of vectors containing unique IDs and their corresponding URLs as name:value pairs. In the
enclosing list, the element names are the names of the columns in the data.frame containing the fields needing to be
converted to URL links.</p>
</td></tr>
<tr><td><code id="yassifyPathways_+3A_url_map_by_words_list">url_map_by_words_list</code></td>
<td>
<p>(optional) Similar to url_map_list, except that instead of mapping the full value of a text
field, the function looks for occurrences of key values within the text using <code>gsub()</code> to substitute a URL link tag.
This allows fields containing multiple IDs to be converted to a group of URL links.</p>
</td></tr>
<tr><td><code id="yassifyPathways_+3A_min_decimal">min_decimal</code></td>
<td>
<p>(optional) The minimal value for decimal format. Below this, scientific notation is used (default 0.0005).</p>
</td></tr>
<tr><td><code id="yassifyPathways_+3A_quiet">quiet</code></td>
<td>
<p>(optional) If <code>FALSE</code>, this tells the function to emit warnings when an identifier term has no matching
URL. By default, this value is <code>TRUE</code>, suppressing this behavior.</p>
</td></tr>
<tr><td><code id="yassifyPathways_+3A_table_row_colors">table_row_colors</code></td>
<td>
<p>(optional) This argument specifies the row background colors used to contrast different subnets.
(default: c(&quot;1&quot;=&quot;#EEF&quot;,&quot;2&quot;=&quot;#FFD&quot;), pale blue and pale yellow)</p>
</td></tr>
<tr><td><code id="yassifyPathways_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>DT::datatable</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An attractive HTML table widget, optionally with unique IDs represented as links.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The sample data object Bai_CiKrt_DN.cerno contains MSigDB
# systematic names as gene set identifiers in its ID column
# that we can map to URLs on MSigDB's website using the
# 'systematicName' URL parameter:
msig_url &lt;- "http://www.gsea-msigdb.org/gsea/msigdb/geneset_page.jsp"
id2url &lt;- with( Bai_CiKrt_DN.cerno,
                structure(paste0( msig_url, "?systematicName=", ID),
                          names = ID
                         )
              )

# NOTE: In GSEA data sets against MSigDB,
# MSigDB STANDARD_NAMES (e.g. "GO_RESPONSE_TO_GLUCAGON")
# are often present in the pathways data instead of
# systematic name identifiers. They can be linked to URLs
# using the 'geneSetName' parameter, as follows:
#  sn2url &lt;-
#   with( Bai_CiKrt_DN.gsea,
#       structure( paste0(msig_url, "?geneSetName=", STANDARD_NAME),
#                  names = STANDARD_NAME
#                )
#       )

# The named vector id2url now contains URLs for MSigDB
# gene sets, names with the gene set ID. By passing a
# list containing the id2url named as the column we
# wish to map to a URL, we can have yassifyPathways
# generate an HTML table with links for the gene set IDs.
yassifyPathways( Bai_CiKrt_DN.cerno,
                 n = 200,
                 url_map_list = list(ID = id2url) )
# Here the 'n = 200' argument tells the function to
# generate an HTML table with just the first 200 results,
# and the 'url_map_list = list(ID=id2url)' tells the
# function to link the ID column of Bai_CiKrt_DN.cerno
# to the mapped URLs in the 'id2url' vector. In this case
# the entire ID field is mapped, but if we want to map
# in a word-based fashion, for example when a column
# may contain multiple IDs per row (eg "M40804, M40775" ),
# then the 'url_map_by_words_list = list(ID = id2url)'
# argument works:
yassifyPathways( Bai_CiKrt_DN.cerno,
                 n = 200,
                 url_map_by_words_list = list(ID = id2url) )
# The url_map_list_by_words argument will work in mos
# cases where url_map_list does, so may be fine to use
# generally, but it is less efficient and my sometimes be
# slower.

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
