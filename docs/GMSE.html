<!DOCTYPE html><html><head><title>Help for package GMSE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GMSE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#age_land'><p>Age landscape</p></a></li>
<li><a href='#anecdotal'><p>Anecdotal model</p></a></li>
<li><a href='#be_hunter'><p>Become a hunter on the landscape</p></a></li>
<li><a href='#case01plot'><p>Plot results for density-based or mark-recapture sampling</p></a></li>
<li><a href='#case23plot'><p>Plot results for transect-based sampling</p></a></li>
<li><a href='#chapman_est'><p>Chapman estimator of mark-recapture</p></a></li>
<li><a href='#count_agent_cells'><p>Count the number of owned cells of each agent</p></a></li>
<li><a href='#dens_est'><p>Density estimator of resource abundance</p></a></li>
<li><a href='#gmse'><p>GMSE simulation</p></a></li>
<li><a href='#gmse_apply'><p>GMSE apply function</p></a></li>
<li><a href='#gmse_apply_summary'><p>gmse_apply results summary</p></a></li>
<li><a href='#gmse_gui'><p>GMSE GUI function</p></a></li>
<li><a href='#gmse_replicates'><p>gmse replicate simulations</p></a></li>
<li><a href='#gmse_summary'><p>gmse results summary</p></a></li>
<li><a href='#gmse_table'><p>GMSE table results</p></a></li>
<li><a href='#ind_to_land'><p>Plot resource position on a landscape image output</p></a></li>
<li><a href='#make_agents'><p>Agent initialisation</p></a></li>
<li><a href='#make_costs'><p>COST initialisation</p></a></li>
<li><a href='#make_interaction_array'><p>Initialise array of resource and landscape-level interactions.</p></a></li>
<li><a href='#make_interaction_table'><p>Initialise array of resource and landscape-level interactions.</p></a></li>
<li><a href='#make_landscape'><p>Landscape initialisation</p></a></li>
<li><a href='#make_resource'><p>Resource initialisation</p></a></li>
<li><a href='#make_utilities'><p>Utility initialisation</p></a></li>
<li><a href='#manager'><p>Manager model</p></a></li>
<li><a href='#manager_user_budgets'><p>Manager and user budgets</p></a></li>
<li><a href='#observation'><p>Observation model</p></a></li>
<li><a href='#owner_land_ssa'><p>Owner land SSA</p></a></li>
<li><a href='#plot_gmse_effort'><p>Plot the effort made by each user for each action</p></a></li>
<li><a href='#plot_gmse_results'><p>Plot the results of a gmse simulation</p></a></li>
<li><a href='#rec.n'><p>R data for recruitment used in SI4 vignette</p></a></li>
<li><a href='#resource'><p>Resource model</p></a></li>
<li><a href='#ssb.n'><p>R data for spawning stock biomass used in SI4 vignette</p></a></li>
<li><a href='#user'><p>User model</p></a></li>
<li><a href='#utility_layer'><p>Utility layer for initialisation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalised Management Strategy Evaluation Simulator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices (&ge; 4.0.0), graphics (&ge; 4.0.0), stats(&ge; 4.0.0),
shiny, shinydashboard, shinyjs, shinycssloaders</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>A. Bradley Duthie &lt;brad.duthie@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Integrates game theory and ecological theory to construct 
    social-ecological models that simulate the management of populations and 
    stakeholder actions. These models build off of a previously developed 
    management strategy evaluation (MSE) framework to simulate all aspects of 
    management: population dynamics, manager observation of populations, manager
    decision making, and stakeholder responses to management decisions. The 
    newly developed generalised management strategy evaluation (GMSE) 
    framework uses genetic algorithms to mimic the decision-making process of 
    managers and stakeholders under conditions of change, uncertainty, and 
    conflict. Simulations can be run using gmse(), gmse_apply(), and
    gmse_gui() functions.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://confoobio.github.io/gmse/">https://confoobio.github.io/gmse/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/confoobio/gmse/issues">https://github.com/confoobio/gmse/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-15 09:12:05 UTC; brad</td>
</tr>
<tr>
<td>Author:</td>
<td>A. Bradley Duthie <a href="https://orcid.org/0000-0001-8343-4995"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Adrian Bach [aut],
  Jeremy Cusack <a href="https://orcid.org/0000-0003-3004-1586"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Isabel Jones <a href="https://orcid.org/0000-0002-8361-1370"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jeroen Minderman <a href="https://orcid.org/0000-0002-8451-5540"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Erlend Nilsen <a href="https://orcid.org/0000-0002-5119-8331"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ochoa Gabriela <a href="https://orcid.org/0000-0001-7649-5669"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Rocio Pozo <a href="https://orcid.org/0000-0002-7546-8076"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Sarobidy Rakotonarivo
    <a href="https://orcid.org/0000-0002-8032-1431"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Bram Van Moorter <a href="https://orcid.org/0000-0002-3196-1993"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Nils Bunnefeld <a href="https://orcid.org/0000-0002-1349-4463"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-16 06:20:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='age_land'>Age landscape</h2><span id='topic+age_land'></span>

<h3>Description</h3>

<p>Determines how the landscape will change over the course of one time step.
For now, simply reverts a specified layer back to its original values
In other words, e.g., crops are annual and regrow undamaged each year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_land(LAND, landscape_ini, layer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age_land_+3A_land">LAND</code></td>
<td>
<p>The name of the landscape being changed</p>
</td></tr>
<tr><td><code id="age_land_+3A_landscape_ini">landscape_ini</code></td>
<td>
<p>The name of the original landscape replacing</p>
</td></tr>
<tr><td><code id="age_land_+3A_layer">layer</code></td>
<td>
<p>The layer that is being affected on the landscape</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the_land with one layer reset to its original cell values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
LANDSCAPE_r &lt;- age_land(LAND = LANDSCAPE_r, landscape_ini = LANDSCAPE_INI, 
layer = 2);

## End(Not run)
</code></pre>

<hr>
<h2 id='anecdotal'>Anecdotal model</h2><span id='topic+anecdotal'></span>

<h3>Description</h3>

<p>A simulation of how many resources of a particular type are in the vicinity 
of each agent &ndash; this produces a kind of anecdotal evidence for each agent 
around their circle of view. It also potentially moves the agents during a 
time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anecdotal(
  RESOURCES = NULL,
  LAND = NULL,
  PARAS = NULL,
  AGENTS = NULL,
  res_type = 1,
  samp_age = 1,
  agent_type = 0,
  type_cat = 1,
  move_agents = FALSE,
  model = "IBM"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anecdotal_+3A_resources">RESOURCES</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="anecdotal_+3A_land">LAND</code></td>
<td>
<p>The landscape array on which interactions between resources and agents occur</p>
</td></tr>
<tr><td><code id="anecdotal_+3A_paras">PARAS</code></td>
<td>
<p>The vector of parameters that hold global and dynamic parameter values used by GMSE</p>
</td></tr>
<tr><td><code id="anecdotal_+3A_agents">AGENTS</code></td>
<td>
<p>The array of agents produced in the main gmse() function</p>
</td></tr>
<tr><td><code id="anecdotal_+3A_res_type">res_type</code></td>
<td>
<p>The type of resources being observed (default = 1)</p>
</td></tr>
<tr><td><code id="anecdotal_+3A_samp_age">samp_age</code></td>
<td>
<p>Minimum age of the resource being sampled (default = 1)</p>
</td></tr>
<tr><td><code id="anecdotal_+3A_agent_type">agent_type</code></td>
<td>
<p>The type of agent doing the observing (default = 0)</p>
</td></tr>
<tr><td><code id="anecdotal_+3A_type_cat">type_cat</code></td>
<td>
<p>The category of agent type (first 4 columns) doing observing; this will almost always be 1, so type 0 agents (managers, of which there is always one by default) will be affected</p>
</td></tr>
<tr><td><code id="anecdotal_+3A_move_agents">move_agents</code></td>
<td>
<p>Whether or not agents are moved during the run of anecodtal</p>
</td></tr>
<tr><td><code id="anecdotal_+3A_model">model</code></td>
<td>
<p>The type of model being applied (Currently only individual-based
&ndash; i.e., 'agent-based' &ndash; models are allowed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The anecdotal function outputs an R list that includes two separate arrays, including (1) a new AGENTS array and (3) a new PARAS array, each of which might be affected by the anecdotal function.  The new arrays can then be read back into the broader GMSE function, thereby affecting the input into the management, user, resource, and observation models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
AGENTS_NEW &lt;- anecdotal(RESOURCES = RESOURCES, LAND = LANDSCAPE_r, 
PARAS = paras, AGENTS = AGENTS, res_type = 1, samp_age = rma, agent_type = -1,
type_cat = 1, move_agents = mva);

## End(Not run)
</code></pre>

<hr>
<h2 id='be_hunter'>Become a hunter on the landscape</h2><span id='topic+be_hunter'></span>

<h3>Description</h3>

<p>This function allows the user of the GMSE software to insert themselves as a hunter in the simulation, allowing them to cull some number of resources in a time step as observed by the agent whose ID is 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>be_hunter(OBSERVATION, AGENT, RESOURCES, LAND, PARAS, view, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="be_hunter_+3A_observation">OBSERVATION</code></td>
<td>
<p>The observation array produced by the observation function within GMSE</p>
</td></tr>
<tr><td><code id="be_hunter_+3A_agent">AGENT</code></td>
<td>
<p>The array of agents produced in the main gmse() function</p>
</td></tr>
<tr><td><code id="be_hunter_+3A_resources">RESOURCES</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="be_hunter_+3A_land">LAND</code></td>
<td>
<p>The landscape array on which interactions between resources and agents occur</p>
</td></tr>
<tr><td><code id="be_hunter_+3A_paras">PARAS</code></td>
<td>
<p>The vector of parameters that hold global and dynamic parameter values used by GMSE</p>
</td></tr>
<tr><td><code id="be_hunter_+3A_view">view</code></td>
<td>
<p>The distance within which agents are able to observe resources on the landscape</p>
</td></tr>
<tr><td><code id="be_hunter_+3A_times">times</code></td>
<td>
<p>The number of times that resources are observed in the observation model of GMSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the_land A cols by rows landscape with randomly distributed cell types
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
HUNT_OUTCOME &lt;- be_hunter(OBSERVATION_r, AGENTS, RESOURCES, LANDSCAPE_r, 
paras, agent_view, times_observe);

## End(Not run)
</code></pre>

<hr>
<h2 id='case01plot'>Plot results for density-based or mark-recapture sampling</h2><span id='topic+case01plot'></span>

<h3>Description</h3>

<p>Produce six panels on a plot showing resource distribution, owned land, resource dynamics and estimates, stake-holder yield, and action costs and actions made. This plot is run internally within the gmse function, and should not be used to plot results stored after running the gmse function (for this, use plot_gmse_results).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case01plot(
  res,
  obs,
  land1,
  land2,
  land3,
  agents,
  paras,
  ACTION,
  COST,
  view = NULL,
  times = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case01plot_+3A_res">res</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="case01plot_+3A_obs">obs</code></td>
<td>
<p>The array of resource observations from the observation model, used to estimate abundance of resources</p>
</td></tr>
<tr><td><code id="case01plot_+3A_land1">land1</code></td>
<td>
<p>The first layer of the 3D landscape array, which indicates values of terrain for plotting (as of now, terrain values have no effect on the simulation and only exist for display purposes)</p>
</td></tr>
<tr><td><code id="case01plot_+3A_land2">land2</code></td>
<td>
<p>The full list showing all layers of the landscape in each time step of GMSE</p>
</td></tr>
<tr><td><code id="case01plot_+3A_land3">land3</code></td>
<td>
<p>The third layer of the 3D landscape array, which indicates agent ownership of the land</p>
</td></tr>
<tr><td><code id="case01plot_+3A_agents">agents</code></td>
<td>
<p>The array of agents produced in the main gmse() function</p>
</td></tr>
<tr><td><code id="case01plot_+3A_paras">paras</code></td>
<td>
<p>The vector of parameters that hold global and dynamic parameter values used by GMSE</p>
</td></tr>
<tr><td><code id="case01plot_+3A_action">ACTION</code></td>
<td>
<p>A three dimensional array of agent (manager and stakeholder) actions</p>
</td></tr>
<tr><td><code id="case01plot_+3A_cost">COST</code></td>
<td>
<p>A three dimensional array of cost values for agent (manager and stakeholder) actions</p>
</td></tr>
<tr><td><code id="case01plot_+3A_view">view</code></td>
<td>
<p>The distance that an agent can see on a landscape</p>
</td></tr>
<tr><td><code id="case01plot_+3A_times">times</code></td>
<td>
<p>The number of times that resources are sampled per time step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function plots the dynamics of GMSE resource, observation, managemer, and user models in six separate sub-panels. (1) Upper left panel: Shows the locations of resources on the landscape (black dots); landscape terrain is also shown in brown, but at the moment, this is only cosmetic and does not reflect anything occurring in the model. (2) Upper right panel: Shows ownership of land by agents; land is divided proportional based on parameters set in gmse() and colours correspond with other subplots. If agent utilities and actions are restricted to land ('land_ownership' in the gmse() function), then this gives some idea of where actions are being performed and where resources are affecting the landscape. (3) Middle left panel: Shows the actual population abundance (black solid line) and the population abundance estimated by the manager (blue solid line; shading indicates 95 percent confidence intervals) over time. The dotted red line shows the resource carrying capacity (death-based) and the dotted blue line shows the target for resource abundance as set in the gmse() function; the orange line shows the total percent yield of the landscape (i.e., 100 percent means that resources have not decreased yield at all, 0 percent means that resources have completely destroyed all yield). (4) Middle right panel: Shows the raw landscape yield for each stakeholder (can be ignored if 'land_ownership' is FALSE) over time; colours correspond to land ownership shown in the upper right panel. (5) Lower left panel: The cost of stakeholders performing actions over time, as set by the manager. (6) Lower right panel: The total number of actions performed by all stakeholders over time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
case01plot(res = RESOURCE_REC, obs = OBSERVATION_REC, 
land1 = LANDSCAPE_r[,,1], land2  = LANDSCAPE_REC, land3  = LANDSCAPE_r[,,3], 
agents = AGENT_REC, paras = paras, ACTION = ACTION_REC, COST = COST_REC, 
view = agent_view, times = times_observe);

## End(Not run)
</code></pre>

<hr>
<h2 id='case23plot'>Plot results for transect-based sampling</h2><span id='topic+case23plot'></span>

<h3>Description</h3>

<p>Produce six panels on a plot showing resource distribution, owned land, resource dynamics and estimates, stake-holder yield, and action costs and actions made. This plot is run internally within the gmse function, and should not be used to plot results stored after running the gmse function (for this, use plot_gmse_results).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case23plot(res, obs, land1, land2, land3, agents, paras, COST, ACTION)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case23plot_+3A_res">res</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="case23plot_+3A_obs">obs</code></td>
<td>
<p>The array of resource observations from the observation model, used to estimate abundance of resources</p>
</td></tr>
<tr><td><code id="case23plot_+3A_land1">land1</code></td>
<td>
<p>The first layer of the 3D landscape array, which indicates values of terrain for plotting (as of now, terrain values have no effect on the simulation and only exist for display purposes)</p>
</td></tr>
<tr><td><code id="case23plot_+3A_land2">land2</code></td>
<td>
<p>The full list showing all layers of the landscape in each time step of GMSE</p>
</td></tr>
<tr><td><code id="case23plot_+3A_land3">land3</code></td>
<td>
<p>The third layer of the 3D landscape array, which indicates agent ownership of the land</p>
</td></tr>
<tr><td><code id="case23plot_+3A_agents">agents</code></td>
<td>
<p>The array of agents produced in the main gmse() function</p>
</td></tr>
<tr><td><code id="case23plot_+3A_paras">paras</code></td>
<td>
<p>The vector of parameters that hold global and dynamic parameter values used by GMSE</p>
</td></tr>
<tr><td><code id="case23plot_+3A_cost">COST</code></td>
<td>
<p>A three dimensional array of cost values for agent (manager and stakeholder) actions</p>
</td></tr>
<tr><td><code id="case23plot_+3A_action">ACTION</code></td>
<td>
<p>A three dimensional array of agent (manager and stakeholder) actions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function plots the dynamics of GMSE resource, observation, managemer, and user models in six separate sub-panels. (1) Upper left panel: Shows the locations of resources on the landscape (black dots); landscape terrain is also shown in brown, but at the moment, this is only cosmetic and does not reflect anything occurring in the model. (2) Upper right panel: Shows ownership of land by agents; land is divided proportional based on parameters set in gmse() and colours correspond with other subplots. If agent utilities and actions are restricted to land ('land_ownership' in the gmse() function), then this gives some idea of where actions are being performed and where resources are affecting the landscape. (3) Middle left panel: Shows the actual population abundance (black solid line) and the population abundance estimated by the manager (blue solid line) over time. The dotted red line shows the resource carrying capacity (death-based) and the dotted blue line shows the target for resource abundance as set in the gmse() function; the orange line shows the total percent yield of the landscape (i.e., 100 percent means that resources have not decreased yield at all, 0 percent means that resources have completely destroyed all yield). (4) Middle right panel: Shows the raw landscape yield for each stakeholder (can be ignored if 'land_ownership' is FALSE) over time; colours correspond to land ownership shown in the upper right panel. (5) Lower left panel: The cost of stakeholders performing actions over time, as set by the manager. (6) Lower right panel: The total number of actions performed by all stakeholders over time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
case23plot(res = RESOURCE_REC, obs = OBSERVATION_REC, 
land1 = LANDSCAPE_r[,,1], land2 = LANDSCAPE_REC, land3  = LANDSCAPE_r[,,3], 
agents = AGENT_REC, COST = COST_REC, ACTION = ACTION_REC, paras  = paras);

## End(Not run)
</code></pre>

<hr>
<h2 id='chapman_est'>Chapman estimator of mark-recapture</h2><span id='topic+chapman_est'></span>

<h3>Description</h3>

<p>Estimates population size using simulated mark-recapture data produced by the
observation model of GMSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chapman_est(observation, paras)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chapman_est_+3A_observation">observation</code></td>
<td>
<p>The array of resource observations from the observation model, used to estimate abundance of resources</p>
</td></tr>
<tr><td><code id="chapman_est_+3A_paras">paras</code></td>
<td>
<p>The vector of parameters that hold global and dynamic parameter values used by GMSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Chapman estimator (which is also performed GMSE in the manager function) returns a list that includes resource population size estimates along with 95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
analysis &lt;- chapman_est(observation=obs_t, paras = paras);

## End(Not run)
</code></pre>

<hr>
<h2 id='count_agent_cells'>Count the number of owned cells of each agent</h2><span id='topic+count_agent_cells'></span>

<h3>Description</h3>

<p>Counts the total number of cells on a landscape owned by each agent and
inserts that total number into a column of the agents array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_agent_cells(AGENTS, LAND = NULL, tot = 14, own = 3, ID = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_agent_cells_+3A_agents">AGENTS</code></td>
<td>
<p>The agents array holding agents' information</p>
</td></tr>
<tr><td><code id="count_agent_cells_+3A_land">LAND</code></td>
<td>
<p>The landscape on which some cells are owned</p>
</td></tr>
<tr><td><code id="count_agent_cells_+3A_tot">tot</code></td>
<td>
<p>Column in which the total number of owned cells in AGENTS is added</p>
</td></tr>
<tr><td><code id="count_agent_cells_+3A_own">own</code></td>
<td>
<p>Layer of the landscape array where ownership information is held</p>
</td></tr>
<tr><td><code id="count_agent_cells_+3A_id">ID</code></td>
<td>
<p>Column in which the ID of an agent is held in the AGENTS array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The AGENTS array with the column of total cell count filled in.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
agents     &lt;- make_agents(agent_number = 3, type_counts = c(1, 2))
land       &lt;- make_landscape(rows = 10, cols = 10, model = "IBM", 
ownership = 2:3)
new_agents &lt;- count_agent_cells(AGENTS = agents, LAND = land);

## End(Not run)
</code></pre>

<hr>
<h2 id='dens_est'>Density estimator of resource abundance</h2><span id='topic+dens_est'></span>

<h3>Description</h3>

<p>Estimates population size using simulated data produced by the
observation model of GMSE &ndash; it assumes that the density of resources
observed on the subset of the landscape sampled equals the density on the 
whole landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens_est(observation, paras, view = view, land = land)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens_est_+3A_observation">observation</code></td>
<td>
<p>The array of resource observations from the observation model, used to estimate abundance of resources</p>
</td></tr>
<tr><td><code id="dens_est_+3A_paras">paras</code></td>
<td>
<p>The vector of parameters that hold global and dynamic parameter values used by GMSE</p>
</td></tr>
<tr><td><code id="dens_est_+3A_view">view</code></td>
<td>
<p>This parameter determines the distance around an agent's location within which it can observe resources.</p>
</td></tr>
<tr><td><code id="dens_est_+3A_land">land</code></td>
<td>
<p>The landscape array on which interactions between resources and agents occur</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The density estimator (which is also performed GMSE in the manager function) returns a list that includes resource population size estimates along with 95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
analysis &lt;- dens_est(observation = obs_t, paras = paras, view = view,
land = land1);

## End(Not run)
</code></pre>

<hr>
<h2 id='gmse'>GMSE simulation</h2><span id='topic+gmse'></span>

<h3>Description</h3>

<p>The gmse function is the the primary function to call to run a simulation.
It calls other functions that run resource, observation, management, and user
models in each time step. Hence while individual models can be used on their
own, gmse() is really all that is needed to run a simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmse(
  time_max = 40,
  land_dim_1 = 100,
  land_dim_2 = 100,
  res_movement = 20,
  remove_pr = 0,
  lambda = 0.3,
  agent_view = 10,
  agent_move = 50,
  res_birth_K = 1e+05,
  res_death_K = 2000,
  edge_effect = 1,
  res_move_type = 1,
  res_birth_type = 2,
  res_death_type = 2,
  observe_type = 0,
  fixed_mark = 100,
  fixed_recapt = 500,
  times_observe = 1,
  obs_move_type = 1,
  res_min_age = 0,
  res_move_obs = FALSE,
  Euclidean_dist = FALSE,
  plotting = TRUE,
  hunt = FALSE,
  start_hunting = 95,
  res_consume = 0.5,
  ga_popsize = 100,
  ga_mingen = 40,
  ga_seedrep = 20,
  ga_sampleK = 20,
  ga_chooseK = 2,
  ga_mutation = 0.1,
  ga_crossover = 0.1,
  move_agents = TRUE,
  max_ages = 5,
  minimum_cost = 10,
  user_budget = 1000,
  manager_budget = 1000,
  manage_target = 1000,
  RESOURCE_ini = 1000,
  scaring = FALSE,
  culling = TRUE,
  castration = FALSE,
  feeding = FALSE,
  help_offspring = FALSE,
  tend_crops = FALSE,
  tend_crop_yld = 0.2,
  kill_crops = FALSE,
  stakeholders = 4,
  manage_caution = 1,
  land_ownership = FALSE,
  manage_freq = 1,
  converge_crit = 0.1,
  manager_sense = 0.9,
  public_land = 0,
  group_think = FALSE,
  age_repr = 1,
  usr_budget_rng = 0,
  action_thres = 0,
  budget_bonus = 0,
  consume_surv = 0,
  consume_repr = 0,
  times_feeding = 1,
  ownership_var = 0,
  perceive_scare = NA,
  perceive_cull = NA,
  perceive_cast = NA,
  perceive_feed = NA,
  perceive_help = NA,
  perceive_tend = NA,
  perceive_kill = NA,
  usr_yld_budget = 0,
  man_yld_budget = 0,
  mem_prv_observ = FALSE,
  bgt_bonus_reset = TRUE,
  traj_pred = FALSE,
  user_annealing = FALSE,
  mana_annealing = FALSE,
  kmax_annealing = 1000,
  mu_magnitude = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmse_+3A_time_max">time_max</code></td>
<td>
<p>This value sets the maximum number of time steps for a simulation. There are no constraints for length of time that a simulation can run. The default is 40 time steps.</p>
</td></tr>
<tr><td><code id="gmse_+3A_land_dim_1">land_dim_1</code></td>
<td>
<p>This value sets the number of cells on the x dimension of the landscape (i.e., the number of columns in the landscape array; this can also be thought of as the x-axis when the landscape image is plotted). There is no maximum, but the minimum dimension of a landscape is 2 cells. The default is 100 cells.</p>
</td></tr>
<tr><td><code id="gmse_+3A_land_dim_2">land_dim_2</code></td>
<td>
<p>This value sets the number of cells on the y dimension of the landscape (i.e., the number of columns in the landscape array; this can also be thought of as the y-axis when the landscape image is plotted). There is no maximum, but the minimum dimension of a landscape is 2 cells. The default is 100 cells.</p>
</td></tr>
<tr><td><code id="gmse_+3A_res_movement">res_movement</code></td>
<td>
<p>This value determines how far resources move during a time step. Exact movement is probabilistic and partly affected by 'res_move_type' settings. Under default settings, during each time step, resources move from zero to res_movement cells away from their starting cell in any direction. Hence res_movement is the maximum distance away from a resources starting cell that it can move in a time step; other types of resource movement, however, interpret res_movement differently to get the raw distance moved (see res_move_type). The default value is 20.</p>
</td></tr>
<tr><td><code id="gmse_+3A_remove_pr">remove_pr</code></td>
<td>
<p>This value is the density-independent and user-independent probability of a resource being removed (e.g., dying) during a time step in the resource model. Under default settings, this value is set to zero, with resource removal being determined entirely by carrying capacity on resource survival, and by user actions.</p>
</td></tr>
<tr><td><code id="gmse_+3A_lambda">lambda</code></td>
<td>
<p>This value is the baseline population growth rate of resources. Each resource in the simulation produces Poisson(lambda) offspring in one time step within the resource model. The value of lambda might be increased or decreased by user actions, and juvenile survival can potentially be decreased by a carrying capacity placed on birth. The default value is 0.3, meaning that the average resource produces one offspring every three time steps.</p>
</td></tr>
<tr><td><code id="gmse_+3A_agent_view">agent_view</code></td>
<td>
<p>This value determines how far agents (managers and stakeholders) can see on the landscape. At the moment, this affects only the sampling ability of managers in the observation model for density-based and transect-based estimates of resource abundance. In these types of estimates, when managers have a higher agent_view, they are capable of observing a larger area of landscape and therefore of getting a larger (in the case of density-based estimation) or more efficient (in the case of transect-based estimation) sample of resources from which to estimate total resource abundance. The default value of agent_view is 10, so agents can see 10 cells away from their current cell in any direction.</p>
</td></tr>
<tr><td><code id="gmse_+3A_agent_move">agent_move</code></td>
<td>
<p>This value determines how far agents can move. At the moment, this does not affect much in the simulation because agent movement does not affect agent actions (interactions with resources can be limited to stakeholder's owned land, but do not currently depend on where an agent is on the landscape &ndash; effectively assuming that agents are mobile enough to do what they want to do to resources). The one exception is for density-based estimation, which can be biased by low values of agent_move by causing the manager to sample the same (or nearby) landscape cells to estimate total resource abundance; if resources are spatially autocorrelated, then managers might over or under-estimate total abundance. Therefore, as a default, this value is set to 50 so that managers can move to any cell on a (torus) landscape in a time step, removing any bias for density sampling.</p>
</td></tr>
<tr><td><code id="gmse_+3A_res_birth_k">res_birth_K</code></td>
<td>
<p>This value is the carrying capacity on new resources added per time step (e.g., birth). If more offspring are born in a time step than res_birth_K, then offspring are randomly removed from the population until offspring born equals res_birth_K. By default, carrying capacity is effectively applied to death instead of birth, so the default value of res_birth_K is set to 100000 (and hence not enacted because the number of births is never this high).</p>
</td></tr>
<tr><td><code id="gmse_+3A_res_death_k">res_death_K</code></td>
<td>
<p>This value is the carrying capacity on resources in the population. Carrying capacity is realised by an increase in mortality probability as resource abundance approaches res_death_K. In each time step, realised mortality probability equals the number of resources over carrying capacity divided by the number of resources (i.e., [resource count - carrying capacity] / resource count). Hence, as the resource abundance increases above carrying capcity, mortality probability also increases in proportion, generating some stochasticity in resource survival. Note that carrying capacity is independent of user actions; if a user culls a resource this culling is applied after mortality probability due to carrying capacity has already been calculated. The default value for res_death_K is 2000.</p>
</td></tr>
<tr><td><code id="gmse_+3A_edge_effect">edge_effect</code></td>
<td>
<p>This determines what happens at the edge of the landscape. Currently there is only one option (value 1), which causes the landscape to wrap around as a torus (effectively removing the edge); resources that leave off of one side of the landscape will reappear on the other side of the landscape.</p>
</td></tr>
<tr><td><code id="gmse_+3A_res_move_type">res_move_type</code></td>
<td>
<p>This determines the type of movement that resources do. There are four different movement options: (0) No movement &ndash; resources are sessile, (1) Uniform movement in any direction up to 'res_movement' cells away during a time step. Movement direction is random and the cell distance moved is randomly selected from zero to 'res_movement'. (2) Poisson selected movement in the x and y dimensions where distance in each direction is determined by Poisson(res_movement) and direction (e.g., left versus right) is randomly selected for each dimension. This type of movement tends to look a bit odd with low 'res_movement' values because it results in very little diagonal movement. It also is not especially biologically realistic, so should probably not be used without a good reason. (3) Uniform movement in any direction up to 'res_movement' cells away during a a time step 'res_movement' times. In other words, the 'res_movement' variable of each resource is acting to determine the times that a resource moves in a time step and the maximum distance it travels each time it moves. This type of movement has been simulated in ecological models, particularly plant-pollinator systems. The default movement type is (1).</p>
</td></tr>
<tr><td><code id="gmse_+3A_res_birth_type">res_birth_type</code></td>
<td>
<p>The type of resource addition (birth) that occurs. Currently, the only value allowed is 2, which causes all resources to produce Poisson(lambda) offspring each time step, where 'lambda' is the population growth rate also set as an argument in gmse simulations.</p>
</td></tr>
<tr><td><code id="gmse_+3A_res_death_type">res_death_type</code></td>
<td>
<p>The type of resource removal (death) that occurs. A value of (1) causes death to be entirely density-independent and with a probability of 'removal_pr' for each resource (which may be further affected by agent actions or interactions with landscape cells). A value of (2) causes death to be entirely density-dependent (though potentially independently affected by agents and landscape), with mortality probability calculated based on the carrying capacity 'res_death_K' set in as an argument in gmse simulations. A value of (3) allows for both density-dependent (affected by 'res_death_K') and density-independent (affected by 'removal_pr') effects on resource removal. The default 'res_death_type' is (2); values of (1) must be used carefully because it can result in exponential growth that leads to massive population sizes that slow down simulations.</p>
</td></tr>
<tr><td><code id="gmse_+3A_observe_type">observe_type</code></td>
<td>
<p>The type of observation sampling of resources being done by managers in the observation model. There are currently four options for sampling. (0) Density-based sampling, in which managers sample all resources within some subset of the landscape; the size of this subset is all of the resources within a distance of 'agent_view' from the cell of the manager. Managers sample 'times_observe' subsets, where 'times_observe' is a parameter value set in the gmse simulation. Managers then extrapolate the density of resources in the subset to estimate the total number of resources on a landscape. (1) Mark-recapture estimate of the popluation, in which managers randomly sample 'fixed_mark' resources (without replacement) in the population without any spatial bias (if there are fewer than 'fixed_mark' resources, managers sample all resources). The manager then randomly samples 'fixed_recapt' resources (without replacement), again without any spatial bias. A Chapman estimate is then used in the manager model to estimate population size from these mark-recapture data. (2) Transect-based sampling (linear), in which a manager samples an entire row of the landscape and counts the resources on the row, then moves onto the next row of the landscape until the entire landscape has been covered. The number of cells in each row (i.e., the height) equals 'agent_view', so fewer transects are needed if agents can see farther. If 'res_move_obs == TRUE', then resources can move on the landscape between each transect sampling, potentially causing observation error if some resources are double counted or not counted at all due to movement. If 'res_move_obs == FALSE', then this type of observation should produce no error, and resource estimation will be exact. (3) Transect-based sampling (block), in which a manager samples a block of the landscape and counts the resources in the block, then moves on to the next (equally sized) block until the entire landscape has been covered. Blocks are square, with the length of each side equaling 'agent_view', so fewer blocks are needed if agents can see farther. If 'res_move_obs == TRUE', then resources can move on the landscape between each block sampling, potentially causing observation error if some resources are double counted or not counted at all due to movement. If 'res_move_obs == FALSE', then this type of observation should produce no error, and resource estimation will be exact. The default observation type is 0 for density-based sampling.</p>
</td></tr>
<tr><td><code id="gmse_+3A_fixed_mark">fixed_mark</code></td>
<td>
<p>This parameter affects mark-recapture observation (i.e., applies only when observe_type == 1). Its value defines how many resources will be marked in each time step as part of a mark-recapture population size estimate.</p>
</td></tr>
<tr><td><code id="gmse_+3A_fixed_recapt">fixed_recapt</code></td>
<td>
<p>This parameter affects mark-recapture observation (i.e., applies only when observe_type == 1). Its value defines how many resources will be (re)captured in each time step as part of a mark-recapture population size estimate.</p>
</td></tr>
<tr><td><code id="gmse_+3A_times_observe">times_observe</code></td>
<td>
<p>This parameter defines how many times a manager will make observations within the observation model; it applies only to density-based sampling ('observe_type = 0') and mark-recapture sampling ('observe_type = 1'). In the former case, the value determines how many times the manager goes out to sample resources from a subset of the landscape. In the latter case, the value determines how many times the manager goes out to attempt to find new resources to mark or recapture (hence its value must be greater than 'fixed_observe').</p>
</td></tr>
<tr><td><code id="gmse_+3A_obs_move_type">obs_move_type</code></td>
<td>
<p>This determines the type of movement that agents do. The four different movement types of agents are identical to those of resources: : (0) No movement &ndash; agents are sessile, (1) Uniform movement in any direction up to 'agent_move' cells away during a time step. Movement direction is random and the cell distance moved is randomly selected from zero to 'agent_move'. (2) Poisson selected movement in the x and y dimensions where distance in each direction is determined by Poisson(agent_move) and direction (e.g., left versus right) is randomly selected for each dimension. This type of movement tends to look a bit odd with low 'agent_move' values because it results in very little diagonal movement. It also is not especially realistic, so should probably not be used without a good reason. (3) Uniform movement in any direction up to 'agent_move' cells away during a a time step 'agent_move' times. In other words, the 'agent_move' variable of each agent is acting to determine the times that an agent moves in a time step and the maximum distance it travels each time it moves. This type of movement has been simulated in ecological models, particularly plant-pollinator systems. The default movement type is (1).</p>
</td></tr>
<tr><td><code id="gmse_+3A_res_min_age">res_min_age</code></td>
<td>
<p>This value defines the minimum age at which resources are recorded and acted upon by agents; below this age, resources are ignored. The default value of this parameter is 0. Note that the population might appear to go over carrying capacity regularly because carrying capacity is not realised until the next resource model if it applies to the death of resource (this is not a problem for the simulation itself, it just needs to be noted). If the value is set to 1, then offspring just produced during a time step (age = 0) are not observed or acted upon by agents.</p>
</td></tr>
<tr><td><code id="gmse_+3A_res_move_obs">res_move_obs</code></td>
<td>
<p>This is a TRUE or FALSE value that defines whether or not resources are to move between 'times_observe' times being observed. The default value is TRUE, but if the option is set to FALSE then it shuts down all resource movement during sampling (making 'observe_type = 2' and 'observe_type = 3' error free).</p>
</td></tr>
<tr><td><code id="gmse_+3A_euclidean_dist">Euclidean_dist</code></td>
<td>
<p>This is a TRUE or FALSE value that defines whether distance in the simulation should be judged as number of cells away or the actual Euclidean distance between points (e.g., if the landscape were interpreted as a map). The default is set to FALSE, and until GMSE is capable of reading in real-world maps, I don't think there is any good reason to set it to TRUE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_plotting">plotting</code></td>
<td>
<p>This is a TRUE or FALSE value that determines whether or not the simulation results will be plotted. The default is TRUE. If plotted, then a function is called to show the dynamics of resources and agent actinos over time. The plotted function plots the dynamics of GMSE resource, observation, managemer, and user models in six separate sub-panels. (1) Upper left panel: Shows the locations of resources on the landscape (black dots); landscape terrain is also shown in brown, but at the moment, this is only cosmetic and does not reflect anything occurring in the model. (2) Upper right panel: Shows ownership of land by agents; land is divided proportional based on parameters set in gmse() and colours correspond with other subplots. If agent utilities and actions are restricted to land ('land_ownership' in the gmse() function), then this gives some idea of where actions are being performed and where resources are affecting the landscape. (3) Middle left panel: Shows the actual population abundance (black solid line) and the population abundance estimated by the manager (blue solid line) over time. The dotted red line shows the resource carrying capacity (death-based) and the dotted blue line shows the target for resource abundance as set in the gmse() function; the orange line shows the total percent yield of the landscape (i.e., 100 percent means that resources have not decreased yield at all, 0 percent means that resources have completely destroyed all yield). (4) Middle right panel: Shows the raw landscape yield for each stakeholder (can be ignored if 'land_ownership' is FALSE) over time; colours correspond to land ownership shown in the upper right panel. (5) Lower left panel: The cost of stakeholders performing actions over time, as set by the manager. (6) Lower right panel: The total number of actions performed by all stakeholders over time.</p>
</td></tr>
<tr><td><code id="gmse_+3A_hunt">hunt</code></td>
<td>
<p>This is a TRUE or FALSE value that determines whether the simulation will be halted each time step after 'start_hunting' time steps to ask the user how many resources they want to hunt (some management information is given to help make this choice). This feature will be expanded upon in later versions. Right now, the human is playing the role of agent number 2, the first stake-holder in the simulation. By default, this value is set to FALSE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_start_hunting">start_hunting</code></td>
<td>
<p>The time step in which the human (*not* the simulated agent) is allowed to start hunting if 'hunt = TRUE'. The default value is 95.</p>
</td></tr>
<tr><td><code id="gmse_+3A_res_consume">res_consume</code></td>
<td>
<p>The fraction of remaining biomass (e.g. crop production) that a resource consumes while occupying a landscape cell. The default value is 0.5, so if one resource occupies the cell, then landscape production is halved, if two resources occupy the cell, then landscape production drops to 0.25; if three, then production drops to 0.125, etc.</p>
</td></tr>
<tr><td><code id="gmse_+3A_ga_popsize">ga_popsize</code></td>
<td>
<p>The size of populations of agents in the genetic algorithm (not resources in the simulation). The actions of each agent in the simulation are duplicated 'ga_popsize' times, and this population of individual agent actions undergoes a process of natural selection to find an adaptive strategy. Selection is naturally stronger in larger populations, but a default population size of 100 is more than sufficient to find adaptive strategies.</p>
</td></tr>
<tr><td><code id="gmse_+3A_ga_mingen">ga_mingen</code></td>
<td>
<p>The minimum number of generations in the genetic algorithms of the simulation (*not* the number of time steps in the simulation itself). The actions of each agent in the simulation are duplicated 'ga_popsize' times, and this population of individual agent actions undergoes a process of natural selection at least 'ga_mingen' times to find an adaptive strategy. If convergence criteria 'converge_crit' is set to a default value of 100, then the genetic algorithm will almost always continue for exactly 'ga_mingen' generations. The default value is 40, which is usually plenty for finding adaptive agent strategies &ndash; the objective is not to find optimal strategies, but strategies that are strongly in line with agent interests.</p>
</td></tr>
<tr><td><code id="gmse_+3A_ga_seedrep">ga_seedrep</code></td>
<td>
<p>At the start of each genetic algorithm, 'ga_popsize' replicate agents are produced; 'ga_seedrep' of these replicates are *exact* replicates, while the rest have random actions to introduce variation into the population. Because adaptive agent strategies are not likely to change wildly from one generation to the next, it is highly recommended to use some value of 'ga_seedrep' greater than zero; the default value is 20, which does a good job of finding adaptive strategies.</p>
</td></tr>
<tr><td><code id="gmse_+3A_ga_samplek">ga_sampleK</code></td>
<td>
<p>In the genetic algorithm, fitnesses are assigned to different agent strategies and compete in a tournament to be selected into the next generation. The tournament samples 'ga_sampleK' strategies at random and with replacement from the population of 'ga_popsize' to be included in the tournament. The default value is 20.</p>
</td></tr>
<tr><td><code id="gmse_+3A_ga_choosek">ga_chooseK</code></td>
<td>
<p>In the genetic algorithm, fitnesses are assigned to different agent strategies and compete in a tournament to be selected into the next generation. The tournament samples 'ga_sampleK' strategies at random and with replacement from the population of 'ga_popsize' to be included in the tournament, and from these randomly selected strategies, the top 'ga_chooseK' strategies are selected. The default value is 2, so the top 10 percent of the random sample in a tournament makes it into the next generation (note that multiple tournaments are run until 'ga_popsize' strategies are selected for the next generation).</p>
</td></tr>
<tr><td><code id="gmse_+3A_ga_mutation">ga_mutation</code></td>
<td>
<p>In the genetic algorithm, this is the mutation rate of any action within an agent's strategy. When a mutation occurs, the action is either increased or decreased by a value of 1. If the action drops below zero, then the value after mutation is multiplied by -1.</p>
</td></tr>
<tr><td><code id="gmse_+3A_ga_crossover">ga_crossover</code></td>
<td>
<p>In the genetic algorithm, this is the crossover rate of any action within an agent's strategy with a randomly selected different strategy in the population of size 'ga_popsize'.</p>
</td></tr>
<tr><td><code id="gmse_+3A_move_agents">move_agents</code></td>
<td>
<p>This is a TRUE or FALSE value that defines whether or not agents should move at the end of each time step. The default value is TRUE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_max_ages">max_ages</code></td>
<td>
<p>This is the maximum age of resources. If resources reach this age, then they are removed in the resource model with a probability of 1. The default 'max_ages' is 5.</p>
</td></tr>
<tr><td><code id="gmse_+3A_minimum_cost">minimum_cost</code></td>
<td>
<p>This is the mimimum cost of any action in the manager and user models. Higher values allow managers to have greater precision when setting policy. For example, managers believe (typically correctly) that they will double culling number by setting the cost of culling at 1 instead of 2. If actions always cost at least some minium value, then some increment just above that value is always available to more precisely affect user actions. Hence it is generally better to simply give everyone a bigger budget and set a minimum cost, giving more precision to managers to fine tune policy. The default value of minimum_cost is therefore set to 10.</p>
</td></tr>
<tr><td><code id="gmse_+3A_user_budget">user_budget</code></td>
<td>
<p>This is the total budget of each stakeholder for performing actions. The cost of performing an action is determined by the 'miminimum_cost' of actions, and the policy set by the manager. The default 'user_budget' is 1000. The maximum budget is 100000.</p>
</td></tr>
<tr><td><code id="gmse_+3A_manager_budget">manager_budget</code></td>
<td>
<p>This is the total budget for the manager when setting policy. Higher budgets make it easier to restrict the actions of stakeholders; lower budgets make it more difficult for managers to limit the actions of stakeholders by setting policy. The default 'manager_budget' is 1000. The maximum budget is 10000.</p>
</td></tr>
<tr><td><code id="gmse_+3A_manage_target">manage_target</code></td>
<td>
<p>This is the target resource abundance that the manager attempts to keep the population at; the default value is 1000.</p>
</td></tr>
<tr><td><code id="gmse_+3A_resource_ini">RESOURCE_ini</code></td>
<td>
<p>This is the initial abundance of resources at the start of the simulation; the default is 1000.</p>
</td></tr>
<tr><td><code id="gmse_+3A_scaring">scaring</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not scaring is an option for managers and stakeholders. If so, then stakeholders that scare cause resources to be moved from their current landscape cell to a random cell on the landscape (note, it is possible that the resource could be scared back onto the stakeholder's own land again). The default value of this is FALSE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_culling">culling</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not culling is an option for managers and stakeholders. If so, then stakeholders that cull cause the resource to be removed from the simulation permanently (i.e., killing the resource). The default value of this is TRUE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_castration">castration</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not castration is an option for managers and stakeholders. If so, then stakeholders that castrate do not remove the resource from the simulation, but prohibit the resource from reproducing by setting its 'lambda' value to zero. The default value of this is FALSE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_feeding">feeding</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not feeding is an option for managers and stakeholders. If so, then stakeholders that feed increase a resource's growth rate (lambda) for one time step by 100 percent. The default value of this is FALSE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_help_offspring">help_offspring</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not feeding is an option for managers and stakeholders. If so, then stakeholders that help_offspring increase a resource's offspring production for one time step by one (i.e., one more offspring is produced). The default value of this is FALSE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_tend_crops">tend_crops</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not tending crops on the landscape is allowed for stakeholders. If so, then stakeholders can increase one cells yield by 50 percent for each action to 'tend_crops'. Actions on the landscape cannot be regulated by managers, so the cost of this action is always 'minimum_cost'. The default value of this is FALSE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_tend_crop_yld">tend_crop_yld</code></td>
<td>
<p>The per landscape cell proportional increase in crop yield when stakeholders take one action to increase yield on their landscape. The default value is set to 0.5 (i.e., a 50 percent increase in yield on a cell).</p>
</td></tr>
<tr><td><code id="gmse_+3A_kill_crops">kill_crops</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not killing crops on the landscape is allowed for stakeholders. If so, then stakeholders can remove the crop yield on a cell completely for each action to 'kill_crops'. Actions on the landscape cannot be regulated by managers, so the cost of this action is always 'minimum_cost'.</p>
</td></tr>
<tr><td><code id="gmse_+3A_stakeholders">stakeholders</code></td>
<td>
<p>This is the number of stakeholders in a simulation; there is always one manager, plus any natural number of stakeholders.</p>
</td></tr>
<tr><td><code id="gmse_+3A_manage_caution">manage_caution</code></td>
<td>
<p>This value moderates the caution a manager has when changing policy by assuming that at least 'manage_caution' of each possible action will always be performed by stakeholders. I manager will therefore not ignore policy for one action because no stakeholder is engaging in it; the default value of 'manage_caution' is 1.</p>
</td></tr>
<tr><td><code id="gmse_+3A_land_ownership">land_ownership</code></td>
<td>
<p>This value defines whether stakeholders own land and their actions are restricted to land that they own. If FALSE, then stakeholders can act on any landscape cell; if TRUE, then agents can only act on their own cells. The default of this value is FALSE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_manage_freq">manage_freq</code></td>
<td>
<p>This is the frequency with which policy is set by managers; a value of 1 means that policy is set in the manager model every time step; a value of 2 means that poilcy is set in the manager model every other time step, etc. The default value is 1.</p>
</td></tr>
<tr><td><code id="gmse_+3A_converge_crit">converge_crit</code></td>
<td>
<p>This is the convergence criteria for terminating a genetic algorithm. After continuing for the minimum number of generations, &lsquo;ga_mingen', the genetic algorithm will terminate if the convergence criteria is met. Usually making this criteria low doesn&rsquo;t do much to improve adaptive strategies; the default value is 1, which means that the genetic algorithm will continue as long as there is greater than a 1 percent increase in strategy fitness.</p>
</td></tr>
<tr><td><code id="gmse_+3A_manager_sense">manager_sense</code></td>
<td>
<p>This adjusts the sensitivity that a manager assumes their actions have with respect to changes in costs (their policy). For example, given a default 'manage_sense' value of 0.9, if the cost of culling resources doubles, then instead of a manager assuming the the number of culled resources per user will be cut in half, the manager will instead assume that the number of resources culled will be cut by one half times eight tenths. As a general rule, a value of ca 0.8 allows the manager to predict stake-holder responses to policy accurately; future versions of GMSE could allow managers to adjust this dynamically based on simulation history.</p>
</td></tr>
<tr><td><code id="gmse_+3A_public_land">public_land</code></td>
<td>
<p>The proportion of the landscape that will be public, and not owned by stakeholders. The remaining proportion of the landscape will be evenly divided among stakeholders. Note that this option is only available when land_ownership == TRUE. The default value is 0.</p>
</td></tr>
<tr><td><code id="gmse_+3A_group_think">group_think</code></td>
<td>
<p>If TRUE, all users will have identical actions; the genetic algorithm will find actions for one user and copy them for all users. This is a useful option if a lot of users are required but variation among user decisions can be ignored. The default value is FALSE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_age_repr">age_repr</code></td>
<td>
<p>The age below which resources are incapable of reproducing. The default value is 1.</p>
</td></tr>
<tr><td><code id="gmse_+3A_usr_budget_rng">usr_budget_rng</code></td>
<td>
<p>This specifies a range around the value of &lsquo;user_budget', such that the expected value of each user&rsquo;s budget will be 'user_budget', with a uniform distribution plus or minus 'usr_budget_rng'. Note that the minimum 'usr_budget_rng' allowed is 1 regardless of the range set, and the maximum is always 100000. The default value for this argument is 0.</p>
</td></tr>
<tr><td><code id="gmse_+3A_action_thres">action_thres</code></td>
<td>
<p>A value for the deviation of the estimated population from the manager target, below which manager will not update the policy. Recommended values are between 0 and 1, with the default value being 0.</p>
</td></tr>
<tr><td><code id="gmse_+3A_budget_bonus">budget_bonus</code></td>
<td>
<p>A percentage of the initial budget manager will receive if policy was not updated last time step. Corresponds to the time, energy and money saved by waiting for a better time to update the policy. Budget bonuses are cumulative, so many time steps of not updating policy can cause a compounding increase in the budget bonus. The default value is 0.</p>
</td></tr>
<tr><td><code id="gmse_+3A_consume_surv">consume_surv</code></td>
<td>
<p>This value defines the amount of yield on a landscape that an individual resource need to consume in a timestep to survive. The default value is 0 (i.e., no consumption is required for survival).</p>
</td></tr>
<tr><td><code id="gmse_+3A_consume_repr">consume_repr</code></td>
<td>
<p>This value defines the amount of yield on a landscape that an individual resource need to produce one offspring. Resources will produce as many offspring as is possible given their yield in take; e.g., if a resource consumes between three and four times the amount of yield required for reproduction, then they will produce three offspring. The default value is 0 (i.e., no consumption is required for reproduction).</p>
</td></tr>
<tr><td><code id="gmse_+3A_times_feeding">times_feeding</code></td>
<td>
<p>Number of searches that resources are allowed per time step for feeding on the landscape. Resources will move between times feeding based on whatever 'res_movement' and 'res_move_type' parameters are specified.</p>
</td></tr>
<tr><td><code id="gmse_+3A_ownership_var">ownership_var</code></td>
<td>
<p>Defines the extent to which the amount of land ownership allocated among users varies when 'land_ownership = TRUE'. A default value of 0 places roughly equal landscape ownership, while increasing values (must be &lt; 1) cause an exponential distribution of land ownership cell allocation.</p>
</td></tr>
<tr><td><code id="gmse_+3A_perceive_scare">perceive_scare</code></td>
<td>
<p>For a focal user, the perceived effect of scaring one resource on the total number of resources affecting the user (e.g., if -1, then the user perceives scaring as removing the equivalent of one resource from their land; NA by default, and calculated from other argument inputs).</p>
</td></tr>
<tr><td><code id="gmse_+3A_perceive_cull">perceive_cull</code></td>
<td>
<p>For a focal user, the perceived effect of culling one resource on the total number of resources affecting the user (e.g., if -1, then the user perceives culling as removing the equivalent of one resource; NA by default, and calculated from other argument inputs).</p>
</td></tr>
<tr><td><code id="gmse_+3A_perceive_cast">perceive_cast</code></td>
<td>
<p>For a focal user, the perceived effect of castrating one resource on the total number of resources affecting the user (e.g., if -1, then the user perceives castration as removing the equivalent of one resource; NA by default, and calculated from other argument inputs).</p>
</td></tr>
<tr><td><code id="gmse_+3A_perceive_feed">perceive_feed</code></td>
<td>
<p>For a focal user, the perceived effect of feeding one resource on the total number of resources affecting the user (e.g., if 1, then the user perceives feeding as adding the equivalent of one resource; NA by default, and calculated from other argument inputs).</p>
</td></tr>
<tr><td><code id="gmse_+3A_perceive_help">perceive_help</code></td>
<td>
<p>For a focal user, the perceived effect of helping the offspring of one resource on the total number of resources affecting the user (e.g., if 1, then the user perceives helping offspring as adding the equivalent of one resource; NA by default, and calculated from other argument inputs).</p>
</td></tr>
<tr><td><code id="gmse_+3A_perceive_tend">perceive_tend</code></td>
<td>
<p>For a focal user, the perceived effect of tending to crops on one cell of owned landscape the user's total crop yield (e.g., if 1, then the user perceives tending crop to increase crop yield on one of their landscape cells by 1; NA by default, and calculated from other argument inputs).</p>
</td></tr>
<tr><td><code id="gmse_+3A_perceive_kill">perceive_kill</code></td>
<td>
<p>For a focal user, the perceived effect of destroying the crops on one cell of owned landscape on the user's total crop yield (e.g., if -1, then the user perceives killing crop to reduce their total crop yield on a landscape cell by 1; unlike other perceived actions, this is not additive. The value defines that absolute effect on crop yield predicted at a single cell, so -1 assumes a 100 per cent loss of yield. This is NA by default).</p>
</td></tr>
<tr><td><code id="gmse_+3A_usr_yld_budget">usr_yld_budget</code></td>
<td>
<p>An increase in user budget caused by yield on their owned cells. The value of this parameter is multiplied by the user's total yield to get the user's budget increment (default 0). This argument can take any real value, but user budgets are always restricted to being between 1 and 100000. Where yield adjustments result in budgets &lt; 1, the actual budget is set to 1. And where yield adjustments result in budgets &gt; 100000, the actual budget is set to 100000.</p>
</td></tr>
<tr><td><code id="gmse_+3A_man_yld_budget">man_yld_budget</code></td>
<td>
<p>An increase in manager budget caused by mean yield on user owned cells. The value of this parameter is multiplied by the users' mean total yield to get the manager's budget increment (default 0). This argument can take any real value, but manager budgets are always restricted to being between 1 and 100000. Where yield adjustments result in budgets &lt; 1, the actual budget is set to 1. And where yield adjustments result in budgets &gt; 100000, the actual budget is set to 100000.</p>
</td></tr>
<tr><td><code id="gmse_+3A_mem_prv_observ">mem_prv_observ</code></td>
<td>
<p>A boolean parameter triggering the memorization of last time step's population size observation</p>
</td></tr>
<tr><td><code id="gmse_+3A_bgt_bonus_reset">bgt_bonus_reset</code></td>
<td>
<p>A boolean parameter. Default TRUE: bonus is reset to zero after a time step of policy update. FALSE: reset to zero only when the costs decreased last time step.</p>
</td></tr>
<tr><td><code id="gmse_+3A_traj_pred">traj_pred</code></td>
<td>
<p>A boolean parameter. Determines if the manager feeds the evolutionary algorithm with a prediction of population trajectory (TRUE) or the regular latest observation (FALSE). Default FALSE.</p>
</td></tr>
<tr><td><code id="gmse_+3A_user_annealing">user_annealing</code></td>
<td>
<p>Determines whether simulated annealing should be used in place of the genetic algorithm for agent decision-making. If TRUE, then simulated annealing is used for users. If FALSE, then the genetic algorithm is used.</p>
</td></tr>
<tr><td><code id="gmse_+3A_mana_annealing">mana_annealing</code></td>
<td>
<p>Determines whether simulated annealing should be used in place of the genetic algorithm for agent decision-making. If TRUE, then simulated annealing is used for managers If FALSE, then the genetic algorithm is used.</p>
</td></tr>
<tr><td><code id="gmse_+3A_kmax_annealing">kmax_annealing</code></td>
<td>
<p>Sets the maximum value of iterations for the simulated annealing algorithm</p>
</td></tr>
<tr><td><code id="gmse_+3A_mu_magnitude">mu_magnitude</code></td>
<td>
<p>Sets the magnitude of the maximum mutation in the genetic algorithm in terms of how many actions that an agent tries increases or decreases (e.g., mutation causes 1 to mu_magnitude more or fewer culling actions)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A large list is returned that includes detailed simulation histories for the resource, observation, management, and user models. This list includes eight elements, most of which are themselves complex lists of arrays: (1) A list of length 'time_max' in which each element is an array of resources as they exist at the end of each time step. Resource arrays include all resources and their attributes (e.g., locations, growth rates, offspring, how they are affected by stakeholders, etc.). (2) A list of length 'time_max' in which each element is an array of resource observations from the observation model. Observation arrays are similar to resource arrays, except that they can have a smaller number of rows if not all resources are observed, and they have additional columns that show the history of each resource being observed over the course of 'times_observe' observations in the observation model. (3) A 2D array showing parameter values at each time step (unique rows); most of these values are static but some (e.g., resource number) change over time steps. (4) A list of length 'time_max' in which each element is an array of the landscape that identifies proportion of crop production per cell. This allows for looking at where crop production is increased or decreased over time steps as a consequence of resource and stakeholder actions. (5) The total time the simulation took to run (not counting plotting time). (6) A 2D array of agents and their traits. (7) A list of length 'time_max' in which each element is a 3D array of the costs of performing each action for managers and stakeholders (each agent gets its own array layer with an identical number of rows and columns); the change in costs of particular actions can therefore be be examined over time. (8) A list of length 'time_max' in which each element is a 3D array of the actions performed by managers and stakeholders (each agent gets its own array layer with an identical number of rows and columns); the change in actions of agents can therefore be examined over time. Because the above lists cannot possibly be interpreted by eye all at once in the simulation output, it is highly recommended that the contents of a simulation be stored and interprted individually if need be; alternativley, simulations can more easily be interpreted through plots when 'plotting = TRUE'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim &lt;- gmse(lambda = 0.4, time_max = 5, plotting = FALSE);

## End(Not run)
</code></pre>

<hr>
<h2 id='gmse_apply'>GMSE apply function</h2><span id='topic+gmse_apply'></span>

<h3>Description</h3>

<p>The gmse_apply function is a flexible function that allows for user-defined sub-functions calling resource, observation, manager, and user models. Where such models are not specified, GMSE submodels 'resource', 'observation', 'manager', and 'user' are run by default. Any type of sub-model (e.g., numerical,  individual-based) is permitted as long as the input and output are appropriately specified. Only one time step is simulated per call to gmse_apply, so the function must be looped for simulation over time. Where model parameters are needed but not specified, defaults from gmse are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmse_apply(
  res_mod = resource,
  obs_mod = observation,
  man_mod = manager,
  use_mod = user,
  get_res = "basic",
  old_list = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmse_apply_+3A_res_mod">res_mod</code></td>
<td>
<p>The function specifying the resource model. By default, the individual-based resource model from gmse is called with default parameter values. User-defined functions must either return an unnamed matrix or vector, or return a named list in which one list element is named either 'resource_array' or 'resource_vector', and arrays must follow the format of GMSE in terms of column number and type (if there is only one resource type, then the model can also just return a scalar value).</p>
</td></tr>
<tr><td><code id="gmse_apply_+3A_obs_mod">obs_mod</code></td>
<td>
<p>The function specifying the observation model. By default, the individual-based observation model from gmse is called with default parameter values. User-defined functions must either return an unnamed matrix or vector, or return a named list in which one list element is named either 'observation_array' or 'observation_vector', and arrays must follow the format of GMSE in terms of column number and type  (if there is only one resource type, then the model can also just return a scalar value).</p>
</td></tr>
<tr><td><code id="gmse_apply_+3A_man_mod">man_mod</code></td>
<td>
<p>The function specifying the manager model. By default, the individual-based manager model that calls the genetic algorithm from gmse is used with default parameter values. User-defined functions must either return an unnamed matrix or vector, or return a named list in which one list element is named either 'manager_array' or 'manager_vector', and arrays must follow the (3 dimensional) format of the 'COST' array in GMSE in terms of column numbers and types, with appropriate rows for interactions and layers for agents (see documentation of GMSE for constructing these, if desired). User defined manager outputs will be recognised as costs by the default user model in gmse, but can be interpreted differently (e.g., total allowable catch) if specifying a custom user model.</p>
</td></tr>
<tr><td><code id="gmse_apply_+3A_use_mod">use_mod</code></td>
<td>
<p>The function specifying the user model. By default, the individual-based user model that calls the genetic algorithm from gmse is used with default parameter values. User-defined functions must either return an unnamed matrix or vector, or return a named list in which one list element is named either 'user_array' or 'user_vector', and arrays must follow the (3 dimensional) format of the 'ACTION' array in GMSE in terms of column numbers and types, with appropriate rows for interactions and layers for agents (see documentation of GMSE for constructing these, if desired).</p>
</td></tr>
<tr><td><code id="gmse_apply_+3A_get_res">get_res</code></td>
<td>
<p>How the output should be organised. The default 'basic' attempts to distill results down to their key values from submodel outputs, including resource abundances and estimates, and manager policy and actions. An option 'custom' simply returns a large list that includes the output of every submodel. Any other option (e.g. 'none') will return a large list with all of the input, output, and parameters used to run gmse_apply. This list will also include a list element named 'basic_output', which will display the default results.</p>
</td></tr>
<tr><td><code id="gmse_apply_+3A_old_list">old_list</code></td>
<td>
<p>A an existing list of results from gmse_apply, produced by setting 'get_res = TRUE' to be included in the function. The parameter and data structures from the previous run will be applied to the new run of gmse_apply, thereby making it easy to loop multiple generations. Additional arguments passed to '...' will over-ride those stored in the old list, allowing global parameter values to be updated (e.g., sub-models used, management options, genetic algorithm parameters). Note that if these arguments are passed, the function will attempt to work with them even if it means removing previous list elements (e.g., if a new number of stakeholders is passed through stakeholder = new_value, then an entirely new AGENT array and user and manager arrays will need to be built).</p>
</td></tr>
<tr><td><code id="gmse_apply_+3A_...">...</code></td>
<td>
<p>Arguments passed to user-defined functions, and passed to modify default parameter values that would otherwise be called for gmse default models. Any argument that can be passed to gmse can be specified explicitly, just as if it were an argument to gmse. Similarly, any argument taken by a user-defined function should be specified, though the function will work if the user-defined function has a default that is not specified explicitly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To integrate across different types of submodels, gmse_apply translates between vectors and arrays between each submodel. For example, because the default GMSE observation model requires a resource array with particular requirements for column identites, when a resource model subfunction returns a vector, or a list with a named element 'resource_vector', this vector is translated into an array that can be used by the observation model. Specifically, each element of the vector identifies the abundance of a resource type (and hence will usually be just a single value denoting abundance of the only focal population). If this is all the information provided, then a resource_array will be made with default GMSE parameter values with an identical number of rows to the abundance value (floored if the value is a non-integer; non-default values can also be put into this transformation from vector to array if they are specified in gmse_apply, e.g., through an argument such as lambda = 0.8). Similarly, a 'resource_array' is also translated into a vector after the default individual-based resource model is run, should the observation model require simple abundances instead of an array. The same is true of 'observation_vector' and 'observation_array' objects returned by observation models, of 'manager_vector' and 'manager_array' (i.e., COST) objects returned by manager models, and of 'user_vector' and 'user_array' (i.e., ACTION) objects returned by user models. At each step, a translation between the two is made, with necessary adjustments that can be tweaked through arguments to gmse_apply when needed.
</p>
<p>Parameter changes are accommodated by rebuilding data structures whenever necessary. For example, if the number of stakeholders is changed (and by including an argument 'stakeholders' to gmse_apply, it is assumed that stakeholders are changing even the value is identical to what is in the old_list), then a new array of agents will be built. If landscape dimensions are changed (i.e., if the argument 'land_dim_1' or 'land_dim_2' is included), then a new landscape willl be built. For custom defined GMSE sub-functions, arguments passed to '...' will not be found or updated, so changes to arguments of custom functions should be made directly to the 'old_list', or the use of old_list should be avoided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim &lt;- gmse_apply();
sim &lt;- gmse_apply(stakeholders = 2);
sim &lt;- gmse_apply(obs_mod = function(resource_vector) rnorm(1, resource_vector, 10));

## End(Not run)
</code></pre>

<hr>
<h2 id='gmse_apply_summary'>gmse_apply results summary</h2><span id='topic+gmse_apply_summary'></span>

<h3>Description</h3>

<p>Summarise gmse_apply() output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmse_apply_summary(data, output = NULL, include = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmse_apply_summary_+3A_data">data</code></td>
<td>
<p>The full list as returned by the gmse function.</p>
</td></tr>
<tr><td><code id="gmse_apply_summary_+3A_output">output</code></td>
<td>
<p>An existing gmse_apply_summary output structure to append to.
This should be a matrix with number of columns equal to the length of
'include'. If NULL, a matrix with a single row with just the summary of
given 'data' gmse_apply() output is returned.</p>
</td></tr>
<tr><td><code id="gmse_apply_summary_+3A_include">include</code></td>
<td>
<p>A character vector listing which gmse_apply values should be
reported/summarised. Currently allowable values are
&quot;res&quot;,&quot;obs&quot;,&quot;culls&quot;,&quot;scares&quot;,&quot;castrations&quot;,&quot;feeds&quot;,&quot;helps&quot;,&quot;tend_crops&quot;,
&quot;kill_crops&quot;,&quot;cull_cost&quot;,&quot;scare_cost&quot;, and &quot;yield&quot;. Note that for all 
actions and yield, the statistic returned is the sum across users; for 
cull_cost and scare_cost the returned values are the mean costs across 
users. Can be NULL; if so, if 'output' is also
NULL, all possible values are returned. If 'output' is not NULL, only the
values already present in 'ouput' are returned, in the same column order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of gmse_apply values, summarised.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim_old &lt;- gmse_apply(get_res = "Full", scaring = FALSE, 
land_ownership = TRUE);
gmse_apply_summary(data = sim_old, include = c("res","obs","culls","yield"))

## End(Not run)
</code></pre>

<hr>
<h2 id='gmse_gui'>GMSE GUI function</h2><span id='topic+gmse_gui'></span>

<h3>Description</h3>

<p>The gmse_gui function will call a browser-based graphical user interface 
(GUI) for the gmse function. The GUI will run simulations for a limited range
of parameter values and present results as plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmse_gui()
</code></pre>


<h3>Value</h3>

<p>A browser should immediately open with the gmse graphical user
interface
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim &lt;- gmse_gui();

## End(Not run)
</code></pre>

<hr>
<h2 id='gmse_replicates'>gmse replicate simulations</h2><span id='topic+gmse_replicates'></span>

<h3>Description</h3>

<p>Replicates the same simulation for a set of parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmse_replicates(replicates, all_time = FALSE, hide_unused_options = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmse_replicates_+3A_replicates">replicates</code></td>
<td>
<p>The number of replicate simulations to be run</p>
</td></tr>
<tr><td><code id="gmse_replicates_+3A_all_time">all_time</code></td>
<td>
<p>Passes to gmse_table. If TRUE, then results from all time steps of the simulation are returned; if FALSE (default), then only results from the last time step of each simulation is returned.</p>
</td></tr>
<tr><td><code id="gmse_replicates_+3A_hide_unused_options">hide_unused_options</code></td>
<td>
<p>Passes to gmse_table. If TRUE (default), then action options (e.g., scaring, culling, etc.) that are not available are not included in the results summary. If FALSE, then they are included as 'NA'</p>
</td></tr>
<tr><td><code id="gmse_replicates_+3A_...">...</code></td>
<td>
<p>Parameter values to be passed to the gmse function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simplified list that includes four elements, each of which is a table of data: 1. resources, a table showing time step in the first column, followed by resource abundance in the second column. 2. observations, a table showing time step in the first column, followed by the estimate of population size (produced by the manager) in the second column. 3. costs, a table showing time step in the first column, manager number in the second column (should always be zero), followed by the costs of each action set by the manager (policy); the far-right column indicates budget that is unused and therefore not allocated to any policy. 4. actions, a table showing time step in the first column, user number in the second column, followed by the actions of each user in the time step; additional columns indicate unused actions, crop yield on the user's land (if applicable), and the number of resources that a user successfully harvests (i.e., 'culls').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim_replicates &lt;- gmse_replicates(replicates = 2, time_max = 5);

## End(Not run)
</code></pre>

<hr>
<h2 id='gmse_summary'>gmse results summary</h2><span id='topic+gmse_summary'></span>

<h3>Description</h3>

<p>Summarise gmse output in a more user-friendly format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmse_summary(gmse_results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmse_summary_+3A_gmse_results">gmse_results</code></td>
<td>
<p>The full list as returned by the gmse function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simplified list that includes four elements, each of which is a table of data: 1. resources, a table showing time step in the first column, followed by resource abundance in the second column. 2. observations, a table showing time step in the first column, followed by the estimate of population size (produced by the manager) in the second column. 3. costs, a table showing time step in the first column, manager number in the second column (should always be zero), followed by the costs of each action set by the manager (policy); the far-right column indicates budget that is unused and therefore not allocated to any policy. 4. actions, a table showing time step in the first column, user number in the second column, followed by the actions of each user in the time step; additional columns indicate unused actions, crop yield on the user's land (if applicable), and the number of resources that a user successfully harvests (i.e., 'culls').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim_summary &lt;- gmse_summary(gmse_results = sim);

## End(Not run)
</code></pre>

<hr>
<h2 id='gmse_table'>GMSE table results</h2><span id='topic+gmse_table'></span>

<h3>Description</h3>

<p>The gmse_table function takes results created from simulations of the gmse
and concatenates key results from a large list into a more manageable data 
table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmse_table(gmse_sim, hide_unused_options = TRUE, all_time = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmse_table_+3A_gmse_sim">gmse_sim</code></td>
<td>
<p>The output of a 'gmse' simulation.</p>
</td></tr>
<tr><td><code id="gmse_table_+3A_hide_unused_options">hide_unused_options</code></td>
<td>
<p>Whether or not to hide results from policy options when creating the resulting table. If 'TRUE' (default), then policy and user actions that are not allowed in a simulation will not be placed as columns. If 'FALSE', then these columns will be placed with values of 'NA'.</p>
</td></tr>
<tr><td><code id="gmse_table_+3A_all_time">all_time</code></td>
<td>
<p>Whether or not results from each time step from the simulation should be individually placed as a row in the resulting table ('TRUE' by default). If 'FALSE', then only the last row will be placed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with one or more rows of results, each of which indicates a unique 'gmse' simulation for a given time step. Columns represent key simulation including resource densities, observation estimates, policy, and user actions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim       &lt;- gmse(time_max = 10);
sim_table &lt;- gmse_table(gmse_sim = sim);

## End(Not run)
</code></pre>

<hr>
<h2 id='ind_to_land'>Plot resource position on a landscape image output</h2><span id='topic+ind_to_land'></span>

<h3>Description</h3>

<p>Places individuals (simulated resources) on the landscape for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_to_land(inds, land)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind_to_land_+3A_inds">inds</code></td>
<td>
<p>A single time step of resources from GMSE</p>
</td></tr>
<tr><td><code id="ind_to_land_+3A_land">land</code></td>
<td>
<p>The landscape array on which interactions between resources and agents occur</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a landscape in which resources are embedded for a timestep for plotting purposes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
indis  &lt;- ind_to_land(inds=res_t, land=land1);

## End(Not run)
</code></pre>

<hr>
<h2 id='make_agents'>Agent initialisation</h2><span id='topic+make_agents'></span>

<h3>Description</h3>

<p>Initialise the agents of the GMSE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_agents(
  model = "IBM",
  agent_number = 2,
  type_counts = c(1, 1),
  move = 0,
  vision = 20,
  rows = 100,
  cols = 100,
  scaring = FALSE,
  culling = TRUE,
  castration = FALSE,
  feeding = FALSE,
  help_offspring = FALSE,
  tend_crops = FALSE,
  kill_crops = FALSE,
  perceive_scare = NA,
  perceive_cull = NA,
  perceive_cast = NA,
  perceive_feed = NA,
  perceive_help = NA,
  perceive_tend = NA,
  perceive_kill = NA,
  manager_sense = 1,
  lambda = 0.3,
  res_consume = 0,
  consume_repr = 0,
  tend_crop_yld = 0.2,
  times_feeding = 1,
  landscape = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_agents_+3A_model">model</code></td>
<td>
<p>The type of model being applied (Currently only individual-based
&ndash; i.e., 'agent-based' &ndash; models are allowed)</p>
</td></tr>
<tr><td><code id="make_agents_+3A_agent_number">agent_number</code></td>
<td>
<p>This is the number of agents that are set in the model; agent number does not change during the simulation, and each agent has a unique ID</p>
</td></tr>
<tr><td><code id="make_agents_+3A_type_counts">type_counts</code></td>
<td>
<p>A vector of how many agents there are of each type (element). The sum of this vector needs to equal the agent_number so that each agent can correctly be assigned a type. Currently, GMSE assumes that there are only two types of agents: managers (type 0) and stakeholders (type 1), and only one manager exists. Future versions of GMSE will allow for different options as requested.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_move">move</code></td>
<td>
<p>This parameter affects the movement of agents each time step. There are multiple types of movement (see obs_move_type in the gmse function), but this parameter determines the distance in cells that an agent will move. Agent movement is generally less important than resource movement, and typically does not affect how agents interact with resources</p>
</td></tr>
<tr><td><code id="make_agents_+3A_vision">vision</code></td>
<td>
<p>This parameter determines the distance around an agent's location within which it can observe resources. This is relevant for some (but not not all) types of observation in the observation model, particularly for density-based estimation (observe_type = 0 in the gmse() function).</p>
</td></tr>
<tr><td><code id="make_agents_+3A_rows">rows</code></td>
<td>
<p>The number of rows (y-axis) on the simulated landscape; agents are randomly placed somewhere on the landscape array</p>
</td></tr>
<tr><td><code id="make_agents_+3A_cols">cols</code></td>
<td>
<p>The number of columns (x-axis) on the simulated landscape; agents are randomly placed somewhere on the landscape array</p>
</td></tr>
<tr><td><code id="make_agents_+3A_scaring">scaring</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not scaring is an option for managers and stakeholders. If so, then stakeholders that scare cause resources to be moved from their current landscape cell to a random cell on the landscape (note, it is possible that the resource could be scared back onto the stakeholder's own land again). The default value of this is FALSE.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_culling">culling</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not culling is an option for managers and stakeholders. If so, then stakeholders that cull cause the resource to be removed from the simulation permanently (i.e., killing the resource). The default value of this is TRUE.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_castration">castration</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not castration is an option for managers and stakeholders. If so, then stakeholders that castrate do not remove the resource from the simulation, but prohibit the resource from reproducing by setting its 'lambda' value to zero. The default value of this is FALSE.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_feeding">feeding</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not feeding is an option for managers and stakeholders. If so, then stakeholders that feed increase a resource's growth rate (lambda) for one time step by 100 percent. The default value of this is FALSE.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_help_offspring">help_offspring</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not feeding is an option for managers and stakeholders. If so, then stakeholders that help_offspring increase a resource's offspring production for one time step by one (i.e., one more offspring is produced). The default value of this is FALSE.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_tend_crops">tend_crops</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not tending crops on the landscape is allowed for stakeholders. If so, then stakeholders can increase one cells yield by 50 percent for each action to 'tend_crops'. Actions on the landscape cannot be regulated by managers, so the cost of this action is always 'minimum_cost'. The default value of this is FALSE.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_kill_crops">kill_crops</code></td>
<td>
<p>This is a TRUE or FALSE value determining whether or not killing crops on the landscape is allowed for stakeholders. If so, then stakeholders can remove the crop yield on a cell completely for each action to 'kill_crops'. Actions on the landscape cannot be regulated by managers, so the cost of this action is always 'minimum_cost'.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_perceive_scare">perceive_scare</code></td>
<td>
<p>For a focal user, the perceived effect of scaring one resource on the total number of resources affecting the user</p>
</td></tr>
<tr><td><code id="make_agents_+3A_perceive_cull">perceive_cull</code></td>
<td>
<p>For a focal user, the perceived effect of culling one resource on the total number of resources affecting the user</p>
</td></tr>
<tr><td><code id="make_agents_+3A_perceive_cast">perceive_cast</code></td>
<td>
<p>For a focal user, the perceived effect of castrating one resource on the total number of resources affecting the user</p>
</td></tr>
<tr><td><code id="make_agents_+3A_perceive_feed">perceive_feed</code></td>
<td>
<p>For a focal user, the perceived effect of feeding one resource on the total number of resources affecting the user</p>
</td></tr>
<tr><td><code id="make_agents_+3A_perceive_help">perceive_help</code></td>
<td>
<p>For a focal user, the perceived effect of helping the offspring of one resource on the total number of resources affecting the user</p>
</td></tr>
<tr><td><code id="make_agents_+3A_perceive_tend">perceive_tend</code></td>
<td>
<p>For a focal user, the perceived effect of tending to crops on one cell of owned landscape the user's total crop yield</p>
</td></tr>
<tr><td><code id="make_agents_+3A_perceive_kill">perceive_kill</code></td>
<td>
<p>For a focal user, the perceived effect of destroying the crops on one cell of owned landscape on the user's total crop yield</p>
</td></tr>
<tr><td><code id="make_agents_+3A_manager_sense">manager_sense</code></td>
<td>
<p>This adjusts the sensitivity that a manager assumes their actions have with respect to changes in costs (their policy). For example, given a 'manage_sense' value of 0.9, if the cost of culling resources doubles, then instead of a manager assuming the the number of culled resources per user will be cut in half, the manager will instead assume that the number of resources culled will be cut by one half times eight tenths. As a general rule, a value of ca 0.8 allows the manager to predict stake-holder responses to policy accurately; future versions of GMSE could allow managers to adjust this dynamically based on simulation history.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_lambda">lambda</code></td>
<td>
<p>This value is the baseline population growth rate of resources. Each resource in the simulation produces Poisson(lambda) offspring in one time step within the resource model. The value of lambda might be increased or decreased by user actions, and juvenile survival can potentially be decreased by a carrying capacity placed on birth. The default value is 0.3, meaning that the average resource produces one offspring every three time steps.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_res_consume">res_consume</code></td>
<td>
<p>The fraction of remaining biomass (e.g. crop production) that a resource consumes while occupying a landscape cell. The default value is 0.5, so if one resource occupies the cell, then landscape production is halved, if two resources occupy the cell, then landscape production drops to 0.25; if three, then production drops to 0.125, etc.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_consume_repr">consume_repr</code></td>
<td>
<p>How much from a landscape does an individual resource need to produce one offspring (default 0)?</p>
</td></tr>
<tr><td><code id="make_agents_+3A_tend_crop_yld">tend_crop_yld</code></td>
<td>
<p>The per landscape cell proportional increase in crop yield when stakeholders take one action to increase yield on their landscape. The default value is set to 0.5 (i.e., a 50 percent increase in yield on a cell).</p>
</td></tr>
<tr><td><code id="make_agents_+3A_times_feeding">times_feeding</code></td>
<td>
<p>Number of searches that resources are allowed per time step for feeding on the landscape. Resources will move between times feeding based on whatever 'res_movement' and 'res_move_type' parameters are specified.</p>
</td></tr>
<tr><td><code id="make_agents_+3A_landscape">landscape</code></td>
<td>
<p>The landscape on which some cells are owned. This needs to have been created with the make_landscape, or be a three dimensional array in which the third layer of the array corresponds to owned cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An initialised data frame of agents being modelled
</p>


<h3>Examples</h3>

<pre><code class='language-R'>agents &lt;- make_agents(model = "IBM", agent_number = 2, type_counts = c(1, 1), 
move = 0, vision = 20, rows = 100, cols = 100);
</code></pre>

<hr>
<h2 id='make_costs'>COST initialisation</h2><span id='topic+make_costs'></span>

<h3>Description</h3>

<p>Initialise the cost array of the G-MSE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_costs(AGENTS, RESOURCES, res_opts, lnd_opts, min_cost)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_costs_+3A_agents">AGENTS</code></td>
<td>
<p>The array of agents produced in the main gmse() function</p>
</td></tr>
<tr><td><code id="make_costs_+3A_resources">RESOURCES</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="make_costs_+3A_res_opts">res_opts</code></td>
<td>
<p>A binary vector produced by the GMSE function defining what types of stakeholder interactions with resources (scaring, culling, castration, feeding, help_offspring) are permitted</p>
</td></tr>
<tr><td><code id="make_costs_+3A_lnd_opts">lnd_opts</code></td>
<td>
<p>A binary vector produced by the GMSE function defining what types of stakeholder interactions with the landscape (tend_crops, kill_crops) are permitted</p>
</td></tr>
<tr><td><code id="make_costs_+3A_min_cost">min_cost</code></td>
<td>
<p>The minimum cost that any agent (stakeholder or manager) incurrs for performing one action. This value is also set as an option in the main gmse() function (minimum_cost). This cost is recommended to be set to a value of 10, which gives managers increased precision when adjusting costs. For example, if the mimimum cost for a stakeholder performing an action is low, then a small change in the mimimum cost could halve or double the number of actions performed from the manager's perspective, with no options in between; hence the benefit of having a high mimimum cost combined with a higher agent budget (see the main gmse() function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A three dimensional array of initialised cost values for agent (manager and stakeholder) actions of the same dimensions as the ACTION array in GMSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
COST &lt;- make_costs( AGENTS = AGENTS, RESOURCES = starting_resources,
res_opts = user_res_opts, lnd_opts = user_lnd_opts, min_cost = minimum_cost);

## End(Not run)
</code></pre>

<hr>
<h2 id='make_interaction_array'>Initialise array of resource and landscape-level interactions.</h2><span id='topic+make_interaction_array'></span>

<h3>Description</h3>

<p>Initialise array of resource and landscape-level interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_interaction_array(
  RESOURCES,
  LAND,
  res_consume = 0.5,
  consume_surv = 0,
  consume_repr = 0,
  times_feeding = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_interaction_array_+3A_resources">RESOURCES</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="make_interaction_array_+3A_land">LAND</code></td>
<td>
<p>The landscape array on which interactions between resources and agents occur</p>
</td></tr>
<tr><td><code id="make_interaction_array_+3A_res_consume">res_consume</code></td>
<td>
<p>The proportion of a landscape cell that a resource consumes</p>
</td></tr>
<tr><td><code id="make_interaction_array_+3A_consume_surv">consume_surv</code></td>
<td>
<p>The amount that a resource needs to consume to survive a time step</p>
</td></tr>
<tr><td><code id="make_interaction_array_+3A_consume_repr">consume_repr</code></td>
<td>
<p>The amount that a resource needs to consume to produce one offspring</p>
</td></tr>
<tr><td><code id="make_interaction_array_+3A_times_feeding">times_feeding</code></td>
<td>
<p>The number of times a resource moves to feed on a cell in a time step</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Jacobian &lt;- make_interaction_array(RESOURCES = starting_resources, 
LAND = LANDSCAPE_r);

## End(Not run)
</code></pre>

<hr>
<h2 id='make_interaction_table'>Initialise array of resource and landscape-level interactions.</h2><span id='topic+make_interaction_table'></span>

<h3>Description</h3>

<p>Initialise array of resource and landscape-level interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_interaction_table(RESOURCES, LAND)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_interaction_table_+3A_resources">RESOURCES</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="make_interaction_table_+3A_land">LAND</code></td>
<td>
<p>The landscape array on which interactions between resources and agents occur</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
interaction_tabl &lt;- make_interaction_table(starting_resources, LANDSCAPE_r);

## End(Not run)
</code></pre>

<hr>
<h2 id='make_landscape'>Landscape initialisation</h2><span id='topic+make_landscape'></span>

<h3>Description</h3>

<p>Initialise the landscape of the G-MSE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_landscape(
  model,
  rows,
  cols,
  cell_types = 1,
  cell_val_mn = 1,
  cell_val_sd = 0,
  cell_val_max = 1,
  cell_val_min = 0,
  layers = 3,
  ownership = FALSE,
  owners = 4,
  public_land = 0,
  ownership_var = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_landscape_+3A_model">model</code></td>
<td>
<p>The type of model being applied (Currently only individual-based
&ndash; i.e., 'agent-based' &ndash; models are allowed)</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_rows">rows</code></td>
<td>
<p>The dimension of the other side of the landscape (e.g., Longitude)</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_cols">cols</code></td>
<td>
<p>The dimension of one side of the landscape (e.g., Latitude)</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_cell_types">cell_types</code></td>
<td>
<p>Scalar or vector of all possible types of landscape cells</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_cell_val_mn">cell_val_mn</code></td>
<td>
<p>Mean cell value (e.g., defining crop output on a cell)</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_cell_val_sd">cell_val_sd</code></td>
<td>
<p>Standard devation of cell values on a landscape</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_cell_val_max">cell_val_max</code></td>
<td>
<p>The maximum value of a cell</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_cell_val_min">cell_val_min</code></td>
<td>
<p>The minimum value of a cell</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_layers">layers</code></td>
<td>
<p>The number of layers in the 3D landscape (should usually be 3)</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_ownership">ownership</code></td>
<td>
<p>A TRUE or FALSE whether land should be owned by stakeholders</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_owners">owners</code></td>
<td>
<p>The number of stakeholders in the model that own land</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_public_land">public_land</code></td>
<td>
<p>The proportion of landscape cells that are not owned</p>
</td></tr>
<tr><td><code id="make_landscape_+3A_ownership_var">ownership_var</code></td>
<td>
<p>Does distribution of land vary among users? &gt;=0, &lt;1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the_land A cols by rows landscape with randomly distributed cell types
</p>


<h3>Examples</h3>

<pre><code class='language-R'>land &lt;- make_landscape(model = "IBM", rows = 10, cols = 10, cell_types = 1, 
cell_val_mn = 1, cell_val_sd =  0)
</code></pre>

<hr>
<h2 id='make_resource'>Resource initialisation</h2><span id='topic+make_resource'></span>

<h3>Description</h3>

<p>Initialise the resources of the G-MSE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_resource(
  model = "IBM",
  resource_quantity = 100,
  resource_types = 1,
  rows = 100,
  cols = 100,
  move = 1,
  rm_pr = 0,
  lambda = 0,
  consumption_rate = 0.1,
  max_age = 5,
  times_feeding = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_resource_+3A_model">model</code></td>
<td>
<p>The type of model being applied (Currently only individual-based
&ndash; i.e., 'agent-based' &ndash; models are allowed)</p>
</td></tr>
<tr><td><code id="make_resource_+3A_resource_quantity">resource_quantity</code></td>
<td>
<p>The total number of resources being initialised (e.g., the population size of the resource at the first time step)</p>
</td></tr>
<tr><td><code id="make_resource_+3A_resource_types">resource_types</code></td>
<td>
<p>The number of resource types that exist. Currently, only one resource type is recommended, but future versions of GMSE will include multiple resource types if requested</p>
</td></tr>
<tr><td><code id="make_resource_+3A_rows">rows</code></td>
<td>
<p>The number of rows (y-axis) on the simulated landscape; resources are randomly placed somewhere on the landscape array</p>
</td></tr>
<tr><td><code id="make_resource_+3A_cols">cols</code></td>
<td>
<p>The number of columns (x-axis) on the simulated landscape; resources are randomly placed somewhere on the landscape array</p>
</td></tr>
<tr><td><code id="make_resource_+3A_move">move</code></td>
<td>
<p>This parameter affects the movement of resources each time step. There are multiple types of movement (see res_move_type in the gmse function), but this parameter determines the distance in cells that a resource will move</p>
</td></tr>
<tr><td><code id="make_resource_+3A_rm_pr">rm_pr</code></td>
<td>
<p>This parameter sets the baseline probability of resource removal (death) per time step; this probability can be affected by user actions or carrying capacity, so a probability of zero does not ensure that resources will necessarily persist until the end of the simulation</p>
</td></tr>
<tr><td><code id="make_resource_+3A_lambda">lambda</code></td>
<td>
<p>This is the parameter for Poisson random sampling affecting birthrate; each resource gives birth to Poisson(lambda) offspring in the resource model</p>
</td></tr>
<tr><td><code id="make_resource_+3A_consumption_rate">consumption_rate</code></td>
<td>
<p>Rate at which resource consumes crops on landscape; consumption affects the landscape by decreasing values on the landscape array (which may, e.g., be interpreted as crop production being decreased), and might also affect resource demographic parameters depending on other global options set in GMSE</p>
</td></tr>
<tr><td><code id="make_resource_+3A_max_age">max_age</code></td>
<td>
<p>Maximum age allowed for a resource to be (in time steps)</p>
</td></tr>
<tr><td><code id="make_resource_+3A_times_feeding">times_feeding</code></td>
<td>
<p>Number of times a resource moves on a landscape during a single time step in search of food</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the_resources Initialised data frame of resources being modelled
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resource &lt;- make_resource(model = "IBM", resource_quantity = 100, 
resource_types = 1, rows = 100, cols = 100, move = 1, rm_pr = 0, lambda = 0, 
consumption_rate = 0.5, max_age = 5);
</code></pre>

<hr>
<h2 id='make_utilities'>Utility initialisation</h2><span id='topic+make_utilities'></span>

<h3>Description</h3>

<p>Initialise the utilities of the G-MSE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_utilities(AGENTS, RESOURCES)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_utilities_+3A_agents">AGENTS</code></td>
<td>
<p>The array of agents produced in the main gmse() function</p>
</td></tr>
<tr><td><code id="make_utilities_+3A_resources">RESOURCES</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A three dimensional ACTION array of initialised agent (manager and stakeholder) actions of the same dimensions as the COST array in GMSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ACTION &lt;- make_utilities(AGENTS = AGENTS, RESOURCES = starting_resources);

## End(Not run)
</code></pre>

<hr>
<h2 id='manager'>Manager model</h2><span id='topic+manager'></span>

<h3>Description</h3>

<p>A model of manager decisions for a single time step. Managers set costs for user actions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manager(
  RESOURCES = NULL,
  AGENTS = NULL,
  LAND = NULL,
  PARAS = NULL,
  COST = NULL,
  ACTION = NULL,
  INTERACT = NULL,
  inter_tabl = NULL,
  OBSERVATION = NULL,
  model = "IBM"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manager_+3A_resources">RESOURCES</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="manager_+3A_agents">AGENTS</code></td>
<td>
<p>The array of agents produced in the main gmse() function</p>
</td></tr>
<tr><td><code id="manager_+3A_land">LAND</code></td>
<td>
<p>The landscape array on which interactions between resources and agents occur</p>
</td></tr>
<tr><td><code id="manager_+3A_paras">PARAS</code></td>
<td>
<p>The vector of parameters that hold global and dynamic parameter values used by GMSE</p>
</td></tr>
<tr><td><code id="manager_+3A_cost">COST</code></td>
<td>
<p>A three dimensional array of cost values for agent (manager and stakeholder) actions</p>
</td></tr>
<tr><td><code id="manager_+3A_action">ACTION</code></td>
<td>
<p>A three dimensional array of agent (manager and stakeholder) actions</p>
</td></tr>
<tr><td><code id="manager_+3A_interact">INTERACT</code></td>
<td>
<p>An interaction (Jacobian) matrix of resources &amp; landscape layer effects</p>
</td></tr>
<tr><td><code id="manager_+3A_inter_tabl">inter_tabl</code></td>
<td>
<p>Interaction table indexing types with the INTERACT matrix</p>
</td></tr>
<tr><td><code id="manager_+3A_observation">OBSERVATION</code></td>
<td>
<p>The array of resource observations from the observation model, used to estimate abundance of resources</p>
</td></tr>
<tr><td><code id="manager_+3A_model">model</code></td>
<td>
<p>The type of model being applied (Currently only individual-based
&ndash; i.e., 'agent-based' &ndash; models are allowed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The manager function outputs an R list that includes five separate arrays, including (1) an new RESOURCES array, (2) a new AGENTS array, (3) a new LAND array, (4) a new ACTIONS array, and a new (5) COST array, each of which might be affected by the user function. The new arrays can then be read back into the broader GMSE function, thereby affecting the input into the user, resource, and observation models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MANAGER_OUT &lt;- run_manage(RESOURCE_c = RESOURCES, LANDSCAPE_c = LAND, 
PARAMETERS_c = PARAS, AGENT_c = AGENTS, COST_c = COST, ACTION_c = ACTION, 
JACOBIAN_c = INTERACT, INTERACT_c = inter_tabl, OBSERVATION_c = OBSERVATION);

## End(Not run)
</code></pre>

<hr>
<h2 id='manager_user_budgets'>Manager and user budgets</h2><span id='topic+manager_user_budgets'></span>

<h3>Description</h3>

<p>Initialise manager and user budgets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manager_user_budgets(
  agents,
  manager_budget = 1000,
  user_budget = 1000,
  usr_budget_rng = 0,
  budget_col = 17
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manager_user_budgets_+3A_agents">agents</code></td>
<td>
<p>The agents array</p>
</td></tr>
<tr><td><code id="manager_user_budgets_+3A_manager_budget">manager_budget</code></td>
<td>
<p>The budget of a manager</p>
</td></tr>
<tr><td><code id="manager_user_budgets_+3A_user_budget">user_budget</code></td>
<td>
<p>What is the budget of a user</p>
</td></tr>
<tr><td><code id="manager_user_budgets_+3A_usr_budget_rng">usr_budget_rng</code></td>
<td>
<p>Uniform range of users budgets</p>
</td></tr>
<tr><td><code id="manager_user_budgets_+3A_budget_col">budget_col</code></td>
<td>
<p>Column where the budget is located</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated agents data frame with correct budgets
</p>

<hr>
<h2 id='observation'>Observation model</h2><span id='topic+observation'></span>

<h3>Description</h3>

<p>A simulation of techniques (e.g., capture-mark-recapture) for estimating
population size and poperties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observation(
  RESOURCES = NULL,
  LAND = NULL,
  PARAS = NULL,
  AGENTS = NULL,
  inter_tabl = NULL,
  fixed_mark = 100,
  times_observe = 1,
  res_min_age = 0,
  agent_type = 0,
  type_cat = 1,
  observe_type = 0,
  res_move_obs = FALSE,
  model = "IBM"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="observation_+3A_resources">RESOURCES</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="observation_+3A_land">LAND</code></td>
<td>
<p>The landscape array on which interactions between resources and agents occur</p>
</td></tr>
<tr><td><code id="observation_+3A_paras">PARAS</code></td>
<td>
<p>The vector of parameters that hold global and dynamic parameter values used by GMSE</p>
</td></tr>
<tr><td><code id="observation_+3A_agents">AGENTS</code></td>
<td>
<p>The array of agents produced in the main gmse() function</p>
</td></tr>
<tr><td><code id="observation_+3A_inter_tabl">inter_tabl</code></td>
<td>
<p>Interaction table indexing types with the INTERACT matrix</p>
</td></tr>
<tr><td><code id="observation_+3A_fixed_mark">fixed_mark</code></td>
<td>
<p>Fixed number of individuals marked? (A number, or FALSE)</p>
</td></tr>
<tr><td><code id="observation_+3A_times_observe">times_observe</code></td>
<td>
<p>Number of times that the observations are made (e.g., managers go out sampling n times in an area of the landscape)</p>
</td></tr>
<tr><td><code id="observation_+3A_res_min_age">res_min_age</code></td>
<td>
<p>Minimum age of the resource being sampled (default = 1)</p>
</td></tr>
<tr><td><code id="observation_+3A_agent_type">agent_type</code></td>
<td>
<p>The type of agent doing the observing (default = 0)</p>
</td></tr>
<tr><td><code id="observation_+3A_type_cat">type_cat</code></td>
<td>
<p>The category of agent type (first 4 columns) doing observing; this will almost always be 1, so type 0 agents (managers, of which there is always one by default) will perform the observations</p>
</td></tr>
<tr><td><code id="observation_+3A_observe_type">observe_type</code></td>
<td>
<p>The type of method used to do the observing. For types of observation exist: (1) Density based observation, where observers count all of the resources within a subset of the landscape (the manager function can then later estimate total resource number from this estimate). (2) Mark-recapture based observation, where observers tag a fixed number of randomly sampled resources on the landscape some number of &lsquo;times'; some of these resources marks are later interpreted as marks (&rsquo;fixed_mark') while the rest are interpreted as recaptures. (3) Transect based observation, where observers sample a linear transect, observing all resources on the transect one row of landscape cells at a time, until all landscape cells are sampled; between samples, resources might move generating observation error. (4) Block based sampling, which is very similar to Transect based sampling; here observers instead sample square blocks of a landscape, counting resources one block at a time, until the whole landscape is sampled; between samples resources might move generating observation error.</p>
</td></tr>
<tr><td><code id="observation_+3A_res_move_obs">res_move_obs</code></td>
<td>
<p>Defines whether or not resources move during observation (default = FALSE). Note that if this is FALSE, then observation methods (observe_type) 3 and 4 produce no observation error</p>
</td></tr>
<tr><td><code id="observation_+3A_model">model</code></td>
<td>
<p>The type of model being applied (Currently only individual-based
&ndash; i.e., 'agent-based' &ndash; models are allowed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The observation function outputs an R list that includes three separate arrays, including (1) an new OBSERVATION array that holds observed resources and their traits with additional columns indicating when the resources were observed (relevant, e.g., for mark-recapture), (2) a new AGENTS array, and (3) a new PARAS array, each of which might be affected by the user function.  The new arrays can then be read back into the broader GMSE function, thereby affecting the input into the management, user, and resource models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
OBSERVATION_NEW &lt;- observation(RESOURCES = RESOURCES, LAND = LANDSCAPE_r,
PARAS = paras, AGENTS = AGENTS, inter_tabl = interaction_tabl, fixed_mark = fxo,
times_observe = tmo, res_min_age = rma, agent_type = 0, type_cat   = 1, observe_type = obt,
res_move_obs   = rmo);

## End(Not run)
</code></pre>

<hr>
<h2 id='owner_land_ssa'>Owner land SSA</h2><span id='topic+owner_land_ssa'></span>

<h3>Description</h3>

<p>Builds a layer of the landscape with a shortest-splitline algorithm to assign
landscape cells among owners
</p>


<h3>Usage</h3>

<pre><code class='language-R'>owner_land_ssa(dim_x, dim_y, owners, public_land, land_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="owner_land_ssa_+3A_dim_x">dim_x</code></td>
<td>
<p>The number of cells on the X dimension of the landscape</p>
</td></tr>
<tr><td><code id="owner_land_ssa_+3A_dim_y">dim_y</code></td>
<td>
<p>The number of cells on the Y dimension of the landscape</p>
</td></tr>
<tr><td><code id="owner_land_ssa_+3A_owners">owners</code></td>
<td>
<p>Number of owners among which landscape cells will be divided</p>
</td></tr>
<tr><td><code id="owner_land_ssa_+3A_public_land">public_land</code></td>
<td>
<p>The amount of land that will not be owned</p>
</td></tr>
<tr><td><code id="owner_land_ssa_+3A_land_var">land_var</code></td>
<td>
<p>Does distribution of land vary among users? &gt;=0, &lt;1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array of cells with ownership values
</p>

<hr>
<h2 id='plot_gmse_effort'>Plot the effort made by each user for each action</h2><span id='topic+plot_gmse_effort'></span>

<h3>Description</h3>

<p>Produce a five panel plot in which each panel compares the permissiveness of each action (scaring, culling, etc.) from the manager with the effort put into each action by individual users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gmse_effort(sim_results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gmse_effort_+3A_sim_results">sim_results</code></td>
<td>
<p>Output from gmse to be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function plots the permissiveness that each manager exhibits for each user action (scaring, culling, etc.) and the effort that each individual user puts into each action over time. On the left axis, permissiveness is calculated as 100 minus the percent of the manager's budget put into increasing the cost of a particular action, so, e.g., if a manager puts all of their effort into increasing the cost of culling, then permissiveness of culling is 0; if they put none of their effort into increasing the cost of culling, then permissiveness of culling is 100. On the right axis, percentage of user action expended is the percent of a user's budget put into a particular action (note, these might not add up to 100 because users are not forced to use their entire budget). Coloured lines that are above black lines could potentially (cautiously) be interpreted as conflict between managers and users.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot_gmse_effort(sim_results = sim);

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_gmse_results'>Plot the results of a gmse simulation</h2><span id='topic+plot_gmse_results'></span>

<h3>Description</h3>

<p>Produce six panels on a plot showing resource distribution, owned land, resource dynamics and estimates, stake-holder yield, and action costs and actions made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gmse_results(sim_results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gmse_results_+3A_sim_results">sim_results</code></td>
<td>
<p>Output from gmse to be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function plots the dynamics of GMSE resource, observation, managemer, and user models in six separate sub-panels. (1) Upper left panel: Shows the locations of resources on the landscape (black dots); landscape terrain is also shown in brown, but at the moment, this is only cosmetic and does not reflect anything occurring in the model. (2) Upper right panel: Shows ownership of land by agents; land is divided proportional based on parameters set in gmse() and colours correspond with other subplots. If agent utilities and actions are restricted to land ('land_ownership' in the gmse() function), then this gives some idea of where actions are being performed and where resources are affecting the landscape. (3) Middle left panel: Shows the actual population abundance (black solid line) and the population abundance estimated by the manager (blue solid line; shading indicates 95 percent confidence intervals) over time. The dotted red line shows the resource carrying capacity (death-based) and the dotted blue line shows the target for resource abundance as set in the gmse() function; the orange line shows the total percent yield of the landscape (i.e., 100 percent means that resources have not decreased yield at all, 0 percent means that resources have completely destroyed all yield). (4) Middle right panel: Shows the raw landscape yield for each stakeholder (can be ignored if 'land_ownership' is FALSE) over time; colours correspond to land ownership shown in the upper right panel. (5) Lower left panel: The cost of stakeholders performing actions over time, as set by the manager. (6) Lower right panel: The total number of actions performed by all stakeholders over time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot_gmse_results(sim_results = sim);

## End(Not run)
</code></pre>

<hr>
<h2 id='rec.n'>R data for recruitment used in SI4 vignette</h2><span id='topic+rec.n'></span>

<h3>Description</h3>

<p>This object contains SI4 vignette simulation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rec.n
</code></pre>


<h3>Format</h3>

<p>a set of <code>gmse_apply</code> output examples
</p>


<h3>Author(s)</h3>

<p>Brad Duthie
</p>

<hr>
<h2 id='resource'>Resource model</h2><span id='topic+resource'></span>

<h3>Description</h3>

<p>A population model of resource (including population) dynamics for 
a single time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resource(RESOURCES = NULL, LAND = NULL, PARAS = NULL, model = "IBM")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resource_+3A_resources">RESOURCES</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="resource_+3A_land">LAND</code></td>
<td>
<p>The landscape array on which interactions between resources and agents occur</p>
</td></tr>
<tr><td><code id="resource_+3A_paras">PARAS</code></td>
<td>
<p>The vector of parameters that hold global and dynamic parameter values used by GMSE</p>
</td></tr>
<tr><td><code id="resource_+3A_model">model</code></td>
<td>
<p>The type of model being applied (Currently only individual-based
&ndash; i.e., 'agent-based' &ndash; models are allowed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resource function outputs an R list that includes three separate arrays, including (1) an new RESOURCES array, (2) a new LAND array, (3) a new PARAS array, each of which might be affected by the user function. The new arrays can then be read back into the broader GMSE function, thereby affecting the input into the observation, management, and user models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
RESOURCE_NEW &lt;- resource(RESOURCES = RESOURCES, LAND = LANDSCAPE_r, 
PARAS = paras, model = "IBM");

## End(Not run)
</code></pre>

<hr>
<h2 id='ssb.n'>R data for spawning stock biomass used in SI4 vignette</h2><span id='topic+ssb.n'></span>

<h3>Description</h3>

<p>This object contains SI4 vignette simulation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssb.n
</code></pre>


<h3>Format</h3>

<p>a set of <code>gmse_apply</code> output examples
</p>


<h3>Author(s)</h3>

<p>Brad Duthie
</p>

<hr>
<h2 id='user'>User model</h2><span id='topic+user'></span>

<h3>Description</h3>

<p>A model of user decisions for a single time step. These decisions result in stakeholder actions that can potentially affect resources and the landscape in a GMSE simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>user(
  RESOURCES = NULL,
  AGENTS = NULL,
  LAND = NULL,
  PARAS = NULL,
  COST = NULL,
  ACTION = NULL,
  INTERACT = NULL,
  inter_tabl = NULL,
  model = "IBM"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="user_+3A_resources">RESOURCES</code></td>
<td>
<p>The resources array produced by the resource function within GMSE</p>
</td></tr>
<tr><td><code id="user_+3A_agents">AGENTS</code></td>
<td>
<p>The array of agents produced in the main gmse() function</p>
</td></tr>
<tr><td><code id="user_+3A_land">LAND</code></td>
<td>
<p>The landscape array on which interactions between resources and agents occur</p>
</td></tr>
<tr><td><code id="user_+3A_paras">PARAS</code></td>
<td>
<p>The vector of parameters that hold global and dynamic parameter values used by GMSE</p>
</td></tr>
<tr><td><code id="user_+3A_cost">COST</code></td>
<td>
<p>A three dimensional array of cost values for agent (manager and stakeholder) actions</p>
</td></tr>
<tr><td><code id="user_+3A_action">ACTION</code></td>
<td>
<p>ACTION A three dimensional array of agent (manager and stakeholder) actions</p>
</td></tr>
<tr><td><code id="user_+3A_interact">INTERACT</code></td>
<td>
<p>An interaction (Jacobian) matrix of resources &amp; landscape layer effects</p>
</td></tr>
<tr><td><code id="user_+3A_inter_tabl">inter_tabl</code></td>
<td>
<p>Interaction table indexing types with the INTERACT matrix</p>
</td></tr>
<tr><td><code id="user_+3A_model">model</code></td>
<td>
<p>The type of model being applied (Currently only individual-based
&ndash; i.e., 'agent-based' &ndash; models are allowed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The user function outputs an R list that includes five separate arrays, including (1) an new RESOURCES array, (2) a new AGENTS array, (3) a new LAND array, (4) a new ACTIONS array, and a new (5) COST array, each of which might be affected by the user function. The new arrays can then be read back into the broader GMSE function, thereby affecting the input into the resource, observation, and management models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
USERS &lt;- user(RESOURCES = RESOURCES, AGENTS = AGENTS, LAND = LANDSCAPE_r,
PARAS = paras, COST = COST, ACTION = ACTION, INTERACT = Jacobian, 
inter_tabl = interaction_tabl, model = "IBM");

## End(Not run)
</code></pre>

<hr>
<h2 id='utility_layer'>Utility layer for initialisation.</h2><span id='topic+utility_layer'></span>

<h3>Description</h3>

<p>Function to initialise a layer of the UTILITY array of the G-MSE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility_layer(agent_IDs, agent_number, res_types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility_layer_+3A_agent_ids">agent_IDs</code></td>
<td>
<p>Vector of agent IDs to use (including -1 and -2, which indicate direct actions to the landscape and resources, respectively)</p>
</td></tr>
<tr><td><code id="utility_layer_+3A_agent_number">agent_number</code></td>
<td>
<p>The number of agents to use (length of agent_IDs)</p>
</td></tr>
<tr><td><code id="utility_layer_+3A_res_types">res_types</code></td>
<td>
<p>The number of unique resource types (cols 2-4 of RESOURCES); for now, this should always be 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A layer of the COST or ACTION array, as called in building either make_costs or make_utilities, respectively. This layer corresponds to the costs or actions of a single agent, with the larger array in in which it is placed including all agents
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
UTIL_LIST &lt;- utility_layer(agent_IDs, agent_number, res_types);

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
