<!DOCTYPE html><html lang="en"><head><title>Help for package RMThreshold</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RMThreshold}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RMThreshold-package'><p> Signal-Noise Separation in Correlation Matrices by using Eigenvalue Spectrum Analysis</p></a></li>
<li><a href='#add.Gaussian.noise'><p> Add Gaussian noise to a matrix</p></a></li>
<li><a href='#create.rand.mat'><p> Create a real-valued, symmetric random matrix</p></a></li>
<li><a href='#rm.connections'><p> Create ordered list of largest matrix elements</p></a></li>
<li><a href='#rm.denoise.mat'><p> Remove noise from a random matrix by applying a threshold</p></a></li>
<li><a href='#rm.discard.zeros'><p> Discard rows and columns from a matrix that exclusively contain zero-valued off-diagonal matrix elements</p></a></li>
<li><a href='#rm.ev.density'><p>Create a density plot and a histogram of the eigenvalue distribution</p></a></li>
<li><a href='#rm.get.threshold'><p>Estimate an objective threshold for signal-noise separation in random matrices</p></a></li>
<li><a href='#rm.matrix.validation'><p>Validate input matrix prior to threshold computation</p></a></li>
<li><a href='#rm.show.plots'><p> Display a sequence of plots on screen</p></a></li>
<li><a href='#rm.spacing.distribution'><p>Plot the empirical distribution of the eigenvalue spacings</p></a></li>
<li><a href='#RMThreshold-internal'><p> Internal functions for the RMThreshold package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Signal-Noise Separation in Random Matrices by using Eigenvalue
Spectrum Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-06-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Uwe Menzel </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Uwe Menzel &lt;uwemenzel@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An algorithm which can be used to determine an objective threshold for signal-noise separation in large random matrices (correlation matrices, mutual information matrices, network adjacency matrices) is provided. The package makes use of the results of Random Matrix Theory (RMT). The algorithm increments a suppositional threshold monotonically, thereby recording the eigenvalue spacing distribution of the matrix. According to RMT, that distribution undergoes a characteristic change when the threshold properly separates signal from noise. By using the algorithm, the modular structure of a matrix - or of the corresponding network - can be unraveled.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, png</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-06-23 14:42:01 UTC; meuw0001</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-06-23 19:57:40</td>
</tr>
</table>
<hr>
<h2 id='RMThreshold-package'> Signal-Noise Separation in Correlation Matrices by using Eigenvalue Spectrum Analysis</h2><span id='topic+RMThreshold-package'></span><span id='topic+RMThreshold'></span>

<h3>Description</h3>

<p>The package provides an algorithm that can be used to determine an objective threshold for signal-noise separation in large random matrices.    
</p>


<h3>Details</h3>

<p>The package provides an algorithm which can be used to determine an objective threshold for signal-noise separation in large random matrices (correlation matrices, mutual information matrices, network adjacency matrices). The package makes use of the results of Random Matrix Theory (RMT). The algorithm increments a suppositional threshold monotonically, thereby recording the eigenvalue spacing distribution of the matrix. According to RMT, that distribution undergoes a characteristic change when the threshold properly separates signal from noise. The modular structure of the matrix (or of the corresponding network) can be unraveled if such a threshold is found. 
</p>


<h3>Author(s)</h3>

<p>Uwe Menzel &lt;uwemenzel@gmail.com&gt;
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Random_matrix">https://en.wikipedia.org/wiki/Random_matrix</a> 
</p>
<p>Wigner, E. P. , <em>Characteristic vectors of bordered matrices with infinite dimensions</em>, Ann. Math. 62, 548-564, 1955.
</p>
<p>Mehta, M., <em>Random Matrices</em>, 3nd edition. Academic Press, 2004.
</p>
<p>Furht, B. and Escalante, A. (eds.), <em>Handbook of Data Intensive Computing</em>, Springer Science and Business Media, 2011.
</p>
<p>Luo, F. et al., <em>Constructing gene co-expression networks and predicting functions of unknown genes by random matrix theory.</em> BMC Bioinformatics, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  set.seed(777)
  random.mat &lt;- create.rand.mat(size = 1000, distrib = "norm")$rand.matrix
  res &lt;- rm.matrix.validation(random.mat)	# ok
  res &lt;- rm.get.threshold(random.mat)		# threshold about 3.19	 			
  rm.show.plots(res$comparison.plots) 							
  cleaned.matrix &lt;- rm.denoise.mat(random.mat, threshold = 3.2)	
  cleaned.matrix &lt;- rm.discard.zeros(cleaned.matrix)

## End(Not run)					
</code></pre>

<hr>
<h2 id='add.Gaussian.noise'> Add Gaussian noise to a matrix</h2><span id='topic+add.Gaussian.noise'></span>

<h3>Description</h3>

<p> The function adds Gaussian (i.e. normally distributed) noise to a matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.Gaussian.noise(mat, mean = 0, stddev = 1, symm = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.Gaussian.noise_+3A_mat">mat</code></td>
<td>
<p> Input matrix.</p>
</td></tr>
<tr><td><code id="add.Gaussian.noise_+3A_mean">mean</code></td>
<td>
<p> Mean of the Gaussian noise to be added.</p>
</td></tr>
<tr><td><code id="add.Gaussian.noise_+3A_stddev">stddev</code></td>
<td>
<p> Standard deviation of the Gaussian noise to be added.</p>
</td></tr>
<tr><td><code id="add.Gaussian.noise_+3A_symm">symm</code></td>
<td>
<p> A logical variable that determines if the matrix is to be symmetrized after adding the noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the <code>rnorm</code> function to create the normally distributed noise and adds it to the input matrix. Optionally, the matrix is symmetrized by adding it's transpose and dividing by <code class="reqn">\sqrt 2</code>.</p>


<h3>Value</h3>

<p> The input matrix with noise added, optionally symmetrized.</p>


<h3>Note</h3>

<p> The matrix can not be symmetrized if it is not quadratic.</p>


<h3>Author(s)</h3>

<p> Uwe Menzel &lt;uwemenzel@gmail.com&gt;</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Gaussian_noise">https://en.wikipedia.org/wiki/Gaussian_noise</a>
</p>


<h3>See Also</h3>

<p> Random generation for the normal distribution: <code><a href="stats.html#topic+rnorm">rnorm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
N = 500
some.mat = matrix(rep(1, N*N), nrow = N)	
some.mat[1:3, 1:10]
res &lt;- rm.matrix.validation(some.mat)		# not really a proper matrix for this approach.

## End(Not run)

## It can help to add Gaussian noise to an improper matrix
## Not run: 
noisy.matrix &lt;- add.Gaussian.noise(some.mat, mean = 0, stddev = 1, symm = TRUE)
noisy.matrix[1:3, 1:10]
res &lt;- rm.matrix.validation(noisy.matrix)	# better!
res &lt;- rm.get.threshold(noisy.matrix)		# about 4.3	

## End(Not run)

</code></pre>

<hr>
<h2 id='create.rand.mat'> Create a real-valued, symmetric random matrix</h2><span id='topic+create.rand.mat'></span>

<h3>Description</h3>

<p> The function creates a real-valued, symmetric random matrix of desired dimension. Two alternatives for the probability distribution of the matrix elements are provided.</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.rand.mat(size = 1000, distrib = c("norm", "unif"), mean = 0, stddev = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.rand.mat_+3A_size">size</code></td>
<td>
<p> Dimension of the (quadratic) matrix.</p>
</td></tr>
<tr><td><code id="create.rand.mat_+3A_distrib">distrib</code></td>
<td>
<p> Desired probability distribution of the matrix elements. Can be <code>norm</code> or <code>unif</code>.</p>
</td></tr>
<tr><td><code id="create.rand.mat_+3A_mean">mean</code></td>
<td>
<p> Desired mean of the normal distribution. Only active if <code>distrib = 'norm'</code> was chosen.</p>
</td></tr>
<tr><td><code id="create.rand.mat_+3A_stddev">stddev</code></td>
<td>
<p> Desired standard deviation of the normal distribution. Only active if <code>distrib = 'norm'</code> was chosen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a real-valued, symmetrical random matrix of desired dimension. Two alternatives for the probability distribution of the matrix elements are provided: normal and uniform. If <code>distrib = 'norm'</code>, the mean and the standard deviation can additionally be chosen. If <code>distrib = 'unif'</code>, the matrix elements will be uniformly distributed in the interval (-1,1). 
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>mean.diag</code></td>
<td>
<p> The mean of the diagonal elements of the matrix.</p>
</td></tr>
<tr><td><code>stddev.diag</code></td>
<td>
<p> The standard deviation of the diagonal elements of the matrix.</p>
</td></tr>
<tr><td><code>mean.triangle</code></td>
<td>
<p> The mean of the upper triangle of the matrix (diagonal excluded).</p>
</td></tr>
<tr><td><code>stddev.triangle</code></td>
<td>
<p> The standard deviation of the upper triangle of the matrix (diagonal excluded).</p>
</td></tr>
<tr><td><code>rand.matrix</code></td>
<td>
<p> The random matrix created.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Uwe Menzel &lt;uwemenzel@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(777)
  random.matrix &lt;- create.rand.mat(size = 1000, distrib = "norm")$rand.matrix
  dim(random.matrix)
</code></pre>

<hr>
<h2 id='rm.connections'> Create ordered list of largest matrix elements</h2><span id='topic+rm.connections'></span>

<h3>Description</h3>

<p> The function creates a data frame which is sorted according to the (absolute) magnitude of the matrix elements.</p>


<h3>Usage</h3>

<pre><code class='language-R'> rm.connections(mat, nr.list = 30, abs.val = TRUE, fn = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.connections_+3A_mat">mat</code></td>
<td>
<p> Input matrix.</p>
</td></tr>
<tr><td><code id="rm.connections_+3A_nr.list">nr.list</code></td>
<td>
<p> Number of matrix elements to show.</p>
</td></tr>
<tr><td><code id="rm.connections_+3A_abs.val">abs.val</code></td>
<td>
<p> Logical variable determining if absolute values should be used for sorting.</p>
</td></tr>
<tr><td><code id="rm.connections_+3A_fn">fn</code></td>
<td>
<p> A file name. If not <code>NULL</code>, the data frame is saved to that file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can for instance be useful if pairs of samples with the largest correlation/mutual information are to be identified. By default, the matrix elements are sorted according to their absolute values. The list will not be saved if no filename is invoked, otherwise it will be saved to a tab-separated text file. 
</p>


<h3>Value</h3>

<p>A data frame containing the values of the largest <code>nr.list</code> matrix elements, together with the respective row- and column numbers. If present, the referring row- and column names are also included.
</p>


<h3>Author(s)</h3>

<p> Uwe Menzel &lt;uwemenzel@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(777)
random.mat &lt;- create.rand.mat(size = 1000, distrib = "norm")$rand.matr
dim(random.mat)

## After identification of a proper threshold:
cleaned.matrix &lt;- rm.denoise.mat(random.mat, threshold = 3.2, keep.diag = TRUE)	
cl2.matrix = rm.discard.zeros(cleaned.matrix)				 
df = rm.connections(cl2.matrix)  
</code></pre>

<hr>
<h2 id='rm.denoise.mat'> Remove noise from a random matrix by applying a threshold</h2><span id='topic+rm.denoise.mat'></span>

<h3>Description</h3>

<p> Matrix elements with an absolute value below the given threshold are set to zero. </p>


<h3>Usage</h3>

<pre><code class='language-R'> rm.denoise.mat(mat, threshold, keep.diag = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.denoise.mat_+3A_mat">mat</code></td>
<td>
<p> The noisy input matrix.</p>
</td></tr>
<tr><td><code id="rm.denoise.mat_+3A_threshold">threshold</code></td>
<td>
<p> Numerical value of the threshold.</p>
</td></tr>
<tr><td><code id="rm.denoise.mat_+3A_keep.diag">keep.diag</code></td>
<td>
<p> A logical variable that determines if the diagonal of the matrix is thresholded or not. The default is <code>keep.diag = T</code>. In that case, diagonal matrix elements are not touched.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The function outputs the number of non-zero matrix elements before and after thresholding.</p>


<h3>Value</h3>

<p> The thresholded matrix.</p>


<h3>Author(s)</h3>

<p> Uwe Menzel &lt;uwemenzel@gmail.com&gt;</p>


<h3>See Also</h3>

<p> Estimate an objective threshold for signal-noise separation in random matrices: <code><a href="#topic+rm.matrix.validation">rm.matrix.validation</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(777)
random.matrix &lt;- create.rand.mat(size = 1000, distrib = "norm")$rand.matr
dim(random.matrix)


## After identification of a proper candidate threshold:
cleaned.matrix &lt;- rm.denoise.mat(random.matrix, threshold = 3.2, keep.diag = TRUE)	  
  
</code></pre>

<hr>
<h2 id='rm.discard.zeros'> Discard rows and columns from a matrix that exclusively contain zero-valued off-diagonal matrix elements</h2><span id='topic+rm.discard.zeros'></span>

<h3>Description</h3>

<p> The function removes those rows and columns from an input matrix that exclusively contain zero-valued off-diagonal elements.</p>


<h3>Usage</h3>

<pre><code class='language-R'> rm.discard.zeros(mat, tol = 0, silent = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.discard.zeros_+3A_mat">mat</code></td>
<td>
<p> Input matrix (typically after using <code><a href="#topic+rm.denoise.mat">rm.denoise.mat</a></code>)</p>
</td></tr>
<tr><td><code id="rm.discard.zeros_+3A_tol">tol</code></td>
<td>
<p> A (small) real number specifying a thresholf for removal of matrix elements (see 'Details').</p>
</td></tr>
<tr><td><code id="rm.discard.zeros_+3A_silent">silent</code></td>
<td>
<p> A logical variable that determines if the number of removed rows and columns is printed by the function or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diagonal of the matrix is not included when counting the zeros in a row/column, i.e. a row/column is actually removed if the diagonal element is the only non-zero element in that row/column. The tolerance <code>tol</code> specifies a threshold. Matrix elements below this threshold will be treated as if they were zero.
</p>


<h3>Value</h3>

<p> A matrix with zero-valued rows/colums removed.</p>


<h3>Author(s)</h3>

<p> Uwe Menzel &lt;uwemenzel@gmail.com&gt;</p>


<h3>See Also</h3>

<p> Remove noise from a random matrix by applying a threshold: <code><a href="#topic+rm.denoise.mat">rm.denoise.mat</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(777)
random.matrix &lt;- create.rand.mat(size = 1000, distrib = "norm")$rand.matr
dim(random.matrix)

## After identification of a proper threshold:
cleaned.matrix &lt;- rm.denoise.mat(random.matrix, threshold = 3.2, keep.diag = TRUE)	
cl2.matrix = rm.discard.zeros(cleaned.matrix)				
 
</code></pre>

<hr>
<h2 id='rm.ev.density'>Create a density plot and a histogram of the eigenvalue distribution</h2><span id='topic+rm.ev.density'></span>

<h3>Description</h3>

<p>The function creates a density plot of the empirical distribution of the eigenvalues, combined with a histogram. Optionally, a curve illustrating the Wigner semi-circle can be added. The plot can be saved or shown in a plot window. Marks on the x-axis can be added optionally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rm.ev.density(eigenvalues, nr.breaks = 51, min.bw = 0.01, wigner = TRUE, 
	mark.on.x = NULL, title = "Eigenvalue density distribution", 
	pop.up = TRUE, fn = NULL) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.ev.density_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p> A numeric vector containing the eigenvalues.</p>
</td></tr>
<tr><td><code id="rm.ev.density_+3A_nr.breaks">nr.breaks</code></td>
<td>
<p> Number of bins used in the histogram.</p>
</td></tr> 
<tr><td><code id="rm.ev.density_+3A_min.bw">min.bw</code></td>
<td>
<p> Minimum bandwidth for the calculation of the density curve. If the automatically calculated bandwidth gets too low, it is replaced by this value. That prevents the density curve from being too cliffy.</p>
</td></tr>
<tr><td><code id="rm.ev.density_+3A_wigner">wigner</code></td>
<td>
<p> A logical variable that determines if the Wigner semi-circle is to be added to the plot.</p>
</td></tr> 
<tr><td><code id="rm.ev.density_+3A_mark.on.x">mark.on.x</code></td>
<td>
<p> A numeric vector or NULL. If not NULL, marks will be added on the x-axis at the positions given by the vector.</p>
</td></tr>   
<tr><td><code id="rm.ev.density_+3A_title">title</code></td>
<td>
<p> String containing the title of the plot.</p>
</td></tr>  
<tr><td><code id="rm.ev.density_+3A_pop.up">pop.up</code></td>
<td>
<p> A logical variable that determines if the plot is to be shown in a plot window.</p>
</td></tr>    
<tr><td><code id="rm.ev.density_+3A_fn">fn</code></td>
<td>
<p> A string determining the filename for storage. Must have extension 'png' or 'pdf'.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p> The name of the plot filename chosen, or NULL.</p>


<h3>Note</h3>

<p>This function plots the density of the eigenvalues. For illustration of their spacings, use <code>rm.spacing.distribution</code>.</p>


<h3>Author(s)</h3>

<p> Uwe Menzel <a href="mailto:uwemenzel@gmail.com">uwemenzel@gmail.com</a> </p>


<h3>See Also</h3>

<p> Plotting the eigenvalue spacing distribution: <code><a href="#topic+rm.spacing.distribution">rm.spacing.distribution</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot histogram of the spacings of the unfolded eigenvalues of a random matrix:
set.seed(777)
random.matrix &lt;- create.rand.mat(size = 1000, distrib = "norm")$rand.matr
res &lt;- rm.ev.unfold(random.matrix)					  
rm.ev.density(res$eigenvalues, wigner = TRUE) 
</code></pre>

<hr>
<h2 id='rm.get.threshold'>Estimate an objective threshold for signal-noise separation in random matrices</h2><span id='topic+rm.get.threshold'></span>

<h3>Description</h3>

<p>This is the main function of the package. A suppositional threshold is incremented monotonically, thereby recording the eigenvalue spacing distribution (nearest neighbor spacing distribution, NNSD) of the thresholded matrix. According to Random Matrix Theory, that distribution undergoes a characteristic change when the threshold properly separates signal from noise. By subsequent removal of the below-threshold matrix elements, the modular structure of the matrix - or of a network characterized by this matrix - can be unraveled. The function works for real symmetric matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rm.get.threshold(rand.mat, nr.thresholds = 51, 
    unfold.method = "gaussian", bandwidth = "nrd0", nr.fit.points = 51,
    dist.method = "LL", nr.breaks = 51, discard.outliers = TRUE, 
    discard.zeros = FALSE, min.mat.dim = 40, max.ev.spacing = 3, interval = NULL,
    interactive = TRUE, smooth.par = 0.5, plot.comp = TRUE,
    save.fit = FALSE, plot.spacing = FALSE, wait.seconds = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.get.threshold_+3A_rand.mat">rand.mat</code></td>
<td>
<p> A random, real-valued, symmetric matrix.</p>
</td></tr>
<tr><td><code id="rm.get.threshold_+3A_nr.thresholds">nr.thresholds</code></td>
<td>
<p> Number of equidistant thresholds being probed and recorded.</p>
</td></tr>
<tr><td><code id="rm.get.threshold_+3A_unfold.method">unfold.method</code></td>
<td>
<p> A string variable that determines which type of unfolding algorithm is used. Must be one of 'gaussian' (Gaussian kernel density) or 'spline' (cubic spline interpolation on the cumulative distribution function).</p>
</td></tr>
<tr><td><code id="rm.get.threshold_+3A_bandwidth">bandwidth</code></td>
<td>
<p> Bandwidth used to calculate the Gaussian kernel density. Only active if <code>unfold.method = 'gaussian'</code> is used. See description of the <code>density</code> function.</p>
</td></tr> 
<tr><td><code id="rm.get.threshold_+3A_dist.method">dist.method</code></td>
<td>
<p> A string variable that determines which type of distance estimation to the limiting distributions is used. Must be one of 'LL' (Log Likelihood) or 'KLD' (Kullback-Leibler Distance).</p>
</td></tr>
<tr><td><code id="rm.get.threshold_+3A_nr.fit.points">nr.fit.points</code></td>
<td>
<p> Number of supporting points used for the cubic spline to the empirical cumulative distribution function. Only active if <code>unfold.method = 'spline'</code> is used.</p>
</td></tr>  
<tr><td><code id="rm.get.threshold_+3A_nr.breaks">nr.breaks</code></td>
<td>
<p> Number of bins used in the analysis to subdivide the empirical eigenvalue spacing distribution.</p>
</td></tr>     
<tr><td><code id="rm.get.threshold_+3A_smooth.par">smooth.par</code></td>
<td>
<p> Parameter controlling the degree of smoothing in the loess regression curve presented in the final plot (distance vs. threshold).</p>
</td></tr> 
<tr><td><code id="rm.get.threshold_+3A_discard.outliers">discard.outliers</code></td>
<td>
<p> A logical variable that determines if outliers are to be discarded from the spectrum of eigenvalues (see 'Details').</p>
</td></tr>   
<tr><td><code id="rm.get.threshold_+3A_discard.zeros">discard.zeros</code></td>
<td>
<p> A logical variable specifying if rows and columns exclusively containing zeros outside the main diagonal are to be removed from the matrix after applying each threshold (see 'Details').</p>
</td></tr>   
<tr><td><code id="rm.get.threshold_+3A_min.mat.dim">min.mat.dim</code></td>
<td>
<p> By thresholding a matrix, rows and columns exclusively containing zeros in the off-diagonal matrix elements likely emerge. The parameter <code>min.mat.dim</code> determines the minimum number of non-zero rows and columns of the probed matrix during the thresholding. The thresholding loop is stopped if the number of non-zero rows and columns is getting below <code>min.mat.dim</code>.</p>
</td></tr>  
<tr><td><code id="rm.get.threshold_+3A_max.ev.spacing">max.ev.spacing</code></td>
<td>
<p> A number determining the maximum eigenvalue spacing that is considered when plotting and analyzing the empirical eigenvalue spacing distribution (see 'Details'). </p>
</td></tr>   
<tr><td><code id="rm.get.threshold_+3A_interval">interval</code></td>
<td>
<p> Interval of thresholds that is searched through. A numeric vector with two components (minimum and maximum threshold). The default is <code>interval = NULL</code> which means that the search interval ranges from the minimum absolute value of all matrix elements to the maximum absolute value of all matrix elements.</p>
</td></tr> 
<tr><td><code id="rm.get.threshold_+3A_interactive">interactive</code></td>
<td>
<p> A logical variable that determines if the user wants to choose the candidate thresholds interactively, by mouse clicks.</p>
</td></tr>     
<tr><td><code id="rm.get.threshold_+3A_plot.comp">plot.comp</code></td>
<td>
<p> A logical variable that determines if the empirical distribution of the eigenvalue spacings is displayed in a plot window during function execution.</p>
</td></tr>      
<tr><td><code id="rm.get.threshold_+3A_save.fit">save.fit</code></td>
<td>
<p> A logical variable that determines if a plot of the spline fit to the empirical cumulative distribution function is saved for each threshold. Can be used to check if fitting works well.</p>
</td></tr> 
<tr><td><code id="rm.get.threshold_+3A_plot.spacing">plot.spacing</code></td>
<td>
<p> A logical variable that determines if a scatterplot showing the eigenvalue spacing is saved at each suppositional threshold. Can be used to check if unfolding of the eigenvalue spacing works correctly (see 'Details').</p>
</td></tr>  
<tr><td><code id="rm.get.threshold_+3A_wait.seconds">wait.seconds</code></td>
<td>
<p> A numerical variable that, if set to non-zero values, enables viewing the plots with the eigenvalue spacing distribution during function execution for a predetermined duration. Useful on fast computers. Setting the variable to a specific number will cause the function to show the actual eigenvalue spacing distribution at least that number of seconds.</p>
</td></tr>     
</table>


<h3>Details</h3>

<p>The function <code>rm.get.threshold</code> is the main function of the package. It takes a random matrix as input and applies a sequence of suppositional thresholds on it by setting all matrix elements to zero whose absolute value is below the actual threshold. The eigenvalues of the modified matrix are calculated at each threshold by using the <code><a href="base.html#topic+eigen">eigen</a></code> function of the R <code>base</code> package. The eigenvalue spectrum is then unfolded, i.e. it is calibrated in such a way that the average global spacing between the eigenvalues is constant over the whole spectrum. The latter can be tracked by setting <code>plot.spacing = T</code>. Two methods are provided for unfolding: one method is based on calculation of the Gaussian kernel density of the eigenvalue spectrum; another method is based on fitting a cubic spline function to the cumulative empirical eigenvalue distribution. The latter is determined by the parameter <code>unfold.method</code>. See the references for details of the unfolding procedure. For each threshold, a distance between the empirical eigenvalue spacing distribution (NNSD) and both limiting distributions (Wigner-Dyson distribution and Exponential distribution, respectively) is estimated. Two methods of distance computation are implemented: a method based on computation of the log likelihood of the empirical eigenvalue spacing presupposing each of the limiting distributions, and a method based on calculation of the Kullback-Leibler divergence between empirical eigenvalue spacing distribution and these limiting distributions. If the assumed modular structure of the matrix is completely covered by noise, the empirical eigenvalue spacing distribution is close to the Wigner-Dyson distribution, a curve that approaches zero for small eigenvalue spacings. In the opposite case, when the modular structure of the matrix is prevailing, the empirical eigenvalue spacing distribution comes closer to an Exponential distribution (which represents the distribution of the intervals between two consecutive events in a Poisson process). If the matrix possesses a modular structure (hidden by noise), we expect that the NNSD changes gradually from the Wigner-Dyson case to the Exponential case when the threshold is increased stepwise. This change is monitored in a plot window if the <code>plot.comp</code> variable is left at it's default (<code>plot.comp = TRUE</code>). Two additional parameters are critical for proper functioning of the algorithm. For some types of input matrices, it might be necessary to remove the outliers of the eigenvalue distribution, in order to correctly investigate the bulk of the eigenvalue spectrum. This is achieved by the setting <code>discard.outliers = TRUE</code>, which is the default setting. In some other cases, it might be useful to retain the outliers during analysis. Another critical parameter is <code>discard.zeros</code>. If set to TRUE, rows and columns exclusively containing zeros outside the main diagonal are removed from the matrix at each threshold. This causes the matrix to shrink during the loop over thresholds. Setting <code>discard.zeros = TRUE</code> can be especially useful when the NNSD piles up at the left tail of the histogram shown during program execution. For very fast computers, the argument <code>wait.seconds</code> can be set to a non-zero value, in order to enable the user to follow that change of the NNSD visually. The distance between NNSD and the limiting distributions is not calculated over the whole range of eigenvalue spacings but over the interval <code>(0, max.ev.spacing)</code>. At a spacing of zero, the difference between the Wigner-Dyson distribution and the Exponential distribution is mostly pronounced. The maximum spacing considered in the distance calculation is determined by the parameter <code>max.ev.spacing</code>. This parameter should not be lower than <code class="reqn">\sqrt(2 / \pi)</code>, where the peak of the Wigner-Dyson distribution lies. On the other hand, is does not make sense to choose too high values for <code>max.ev.spacing</code>, because both the Wigner-Dyson and the Exponential distribution assume rather low values in the right tail (which might cause numerical errors). If the algorithm works well, a relatively sharp transition from the Wigner-Dyson case to the Exponential case should become apparent. The latter is (hopefully) confirmed in a plot which is shown after completion of the loop over the sequence of suppositional thresholds. This plot shows the calculated distance between the NNSD and both limiting distributions versus applied threshold. The user can interactively choose candidate thresholds by clickung with the left mouse button on the points of the red-coloured curve. The selection is terminated by a right mouse-click somewhere on the plot. Likewise, candidate thresholds can be chosen in a plot showing the p-values for a Kolmogorov-Smirnov test (testing for exponentiality), and in a plot showing the Sum of Squared Errors between the empirical NNSD and the Exponential distribution versus threshold. The hereby chosen candidate thresholds are returned by the function. The analysis can now be refined by narrowing down the search interval for the thresholds by specifying the <code>interval</code> parameter.    
</p>


<h3>Value</h3>

<p>A list containing the following entries:
</p>
<table role = "presentation">
<tr><td><code>unfold.method</code></td>
<td>
<p> The method that was used for eigenvalue unfolding. Either 'gaussian' or 'spline'.</p>
</td></tr>
<tr><td><code>dist.method</code></td>
<td>
<p> The method that was chosen to estimate the distance to the limiting distributions. Either 'LL' (Log Likelihood) or 'KLD' (Kullback-Leibler Divergence).</p>
</td></tr>  
<tr><td><code>tested.thresholds</code></td>
<td>
<p> A vector containing the probed thresholds.</p>
</td></tr>
<tr><td><code>dist.Wigner</code></td>
<td>
<p> A vector containing the numerical values of the estimated distance between empirical eigenvalue spacing distribution and Wigner-Dyson distribution.</p>
</td></tr>  
<tr><td><code>dist.Expon</code></td>
<td>
<p> A vector containing the numerical values of the estimated distance between empirical eigenvalue spacing distribution and Exponential distribution.</p>
</td></tr> 
<tr><td><code>nr.zeros</code></td>
<td>
<p> A vector containing the number of zero-valued matrix elements for each threshold.</p>
</td></tr>    
<tr><td><code>nr.uniq.ev</code></td>
<td>
<p> An integer vector indicating the number of unique eigenvalues at each threshold (when degenerated eigenvalues are counted as one).</p>
</td></tr>
<tr><td><code>max.ev.mult</code></td>
<td>
<p> An integer vector indicating the maximum eigenvalue multiplicity (degeneracy) at each threshold. </p>
</td></tr> 
<tr><td><code>nr.spacings</code></td>
<td>
<p> An integer vector containing the number of eigenvalue spacings at each threshold. This number is smaller than the matrix dimension if eigenvalues are degenerated.</p>
</td></tr>
<tr><td><code>nr.small.spacings</code></td>
<td>
<p> An integer vector containing the number of small spacings (<code>&lt; max.ev.spacing/1000</code>) for each probed threshold.</p>
</td></tr>
<tr><td><code>perc.small.spacings</code></td>
<td>
<p> A vector containing the percentage of small spacings for each probed threshold.</p>
</td></tr>  
<tr><td><code>eff.dimension</code></td>
<td>
<p> An integer number specifying the 'effective dimension' of the matrix after thresholding, i.e. the number of non-zero rows and columns.</p>
</td></tr>
<tr><td><code>comparison.plots</code></td>
<td>
<p> A character vector containing the names of the plots comparing the empirical eigenvalue spacing distribution with both limiting distributions (only if <code>plot.comp = T</code>).</p>
</td></tr>   
<tr><td><code>rm.dimension</code></td>
<td>
<p> An integer vector indicating the dimension of the matrix after each thresholding (only if <code>discard.zeros = TRUE</code>).</p>
</td></tr>
<tr><td><code>nr.outliers.removed</code></td>
<td>
<p> An integer vector containing the number of outliers in the eigenvalue spectrum removed at each threshold. Only if <code>discard.outliers = TRUE</code>.</p>
</td></tr> 
<tr><td><code>p.ks</code></td>
<td>
<p> A vector containing the p-values for the Kolmogorov-Smirnov test at each probed threshold.</p>
</td></tr>
<tr><td><code>sse.exp</code></td>
<td>
<p> A vector containing the Sum of Squared Errors (SSE) between observed NNSD and Exponential distribution for each probed threshold.</p>
</td></tr>  
<tr><td><code>number.zeros.plot</code></td>
<td>
<p> A character string with the name of the plot depicting the number of zero-valued matrix elements versus threshold.</p>
</td></tr>   
<tr><td><code>number.uniq.ev.plot</code></td>
<td>
<p> The name of the plot showing the number of unique eigenvalues vs. threshold.</p>
</td></tr>  
<tr><td><code>max.ev.mult.plot</code></td>
<td>
<p> The name of the plot showing the maximum eigenvalue multiplicity vs. threshold.</p>
</td></tr>
<tr><td><code>mat.dimension.plot</code></td>
<td>
<p> The name of the plot showing the matrix dimension after each thresholding step (only if <code>discard.zeros = TRUE</code>).</p>
</td></tr>
<tr><td><code>num.ev.spacings.plot</code></td>
<td>
<p> The name of the plot showing the number of eigenvalue spacings vs. threshold.</p>
</td></tr>   
<tr><td><code>distance.plot</code></td>
<td>
<p> The name of the (main) plot showing the distance of the empirical eigenvalue spacing distribution to the limiting distributions at each threshold.</p>
</td></tr>   
<tr><td><code>cumfit.plots</code></td>
<td>
<p> A character vector containing the names of the plots showing the spline-function fitting of the cumulative eigenvalue spacing distribution (only if <code>save.fit = TRUE</code>).</p>
</td></tr>  
<tr><td><code>space.plots</code></td>
<td>
<p> A character vector containing the names of the scatter plots with the eigenvalue spacing (only if <code>plot.spacing = TRUE</code>).</p>
</td></tr>   
<tr><td><code>chosen.thresholds</code></td>
<td>
<p> A vector containing the potential thresholds chosen by the user from the distance plot.</p>
</td></tr> 
<tr><td><code>p.ks.plot</code></td>
<td>
<p> The name of the plot showing the p-values for the Kolmogorov-Smirnow test versus probed thresholds.</p>
</td></tr>   
<tr><td><code>p.ks.chosen</code></td>
<td>
<p> A vector containing the candidate thresholds chosen by the user based on the Kolmogorov-Smirnow test.</p>
</td></tr>     
<tr><td><code>sse.plot</code></td>
<td>
<p> The name of the plot showing the SSE between observed NNSD and Exponential distribution versus probed thresholds.</p>
</td></tr>  
<tr><td><code>sse.chosen</code></td>
<td>
<p> A vector containing the candidate thresholds chosen by the user based on the SSE test.</p>
</td></tr>    
</table>


<h3>Note</h3>

<p>It is recommended to check the input matrix using <code>rm.matrix.validation</code> before running this function. If the histogram of empirical eigenvalue spacings piles up at zero, one should set <code>discard.zeros = TRUE</code></p>


<h3>Author(s)</h3>

<p> Uwe Menzel <a href="mailto:uwemenzel@gmail.com">uwemenzel@gmail.com</a> </p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Random_matrix">https://en.wikipedia.org/wiki/Random_matrix</a> 
</p>
<p>Wigner, E. P. , <em>Characteristic vectors of bordered matrices with infinite dimensions</em>, Ann. Math. 62, 548-564, 1955.
</p>
<p>Mehta, M., <em>Random Matrices</em>, 3nd edition. Academic Press, 2004.
</p>
<p>Furht, B. and Escalante, A. (eds.), <em>Handbook of Data Intensive Computing</em>, Springer Science and Business Media, 2011.
</p>
<p>Luo, F. et al., <em>Constructing gene co-expression networks and predicting functions of unknown genes by random matrix theory.</em> BMC Bioinformatics, 2007.
</p>


<h3>See Also</h3>

<p> Creating a random matrix: <code><a href="#topic+create.rand.mat">create.rand.mat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Run with pre-defined random matrix:
set.seed(777)
random.matrix &lt;- create.rand.mat(size = 1000, distrib = "norm")$rand.matr
dim(random.matrix)		# 1000 1000

## Not run: 
res &lt;- rm.get.threshold(random.matrix)	# threshold might be 3.21
str(res)								# List of 26
rm.show.plots(res$comparison.plots)  	# watch sequence of plots once more

## End(Not run)

## Try other parameters:
## Not run: 
res &lt;- rm.get.threshold(random.matrix, unfold.method = "spline")	
res &lt;- rm.get.threshold(random.matrix, dist.method = "KLD")			
res &lt;- rm.get.threshold(random.matrix, discard.outliers = FALSE) # might cause problems
res &lt;- rm.get.threshold(random.matrix, wait.seconds = 2)	 	 # slow down
res &lt;- rm.get.threshold(random.matrix, discard.zeros = TRUE)    	
res &lt;- rm.get.threshold(random.matrix, discard.zeros = TRUE, dist.method = "KLD")	

## End(Not run)

## Refine analysis by choosing narrower threshold range 
## Not run: 
res &lt;- rm.get.threshold(random.matrix, interval = c(2.5, 3.5))		

## End(Not run)

## Apply the identified threshold to the matrix
cleaned.matrix &lt;- rm.denoise.mat(random.matrix, threshold = 3.21)	
cleaned.matrix &lt;- rm.discard.zeros(cleaned.matrix)	 					  
dim(cleaned.matrix)	# smaller

## Find the clusters in the thresholded matrix:
## Not run: 
  library(igraph)
  g  &lt;- graph.adjacency(cleaned.matrix, mode = "undirected")
  clusters(g)		

## End(Not run)


## Not run: 

  ## Create modular matrix and validate:
  matlist = list()
  for (i in 1:4) matlist[[i]] = get.adjacency(erdos.renyi.game(250, 0.1))	
  mat &lt;- bdiag(matlist)					# create block-diagonal matrix 		 
  rm.matrix.validation(as.matrix(mat))	# Exponential case, modular matrix
  
  ## Add noise:
  mat1 = add.Gaussian.noise(as.matrix(mat), mean = 0, stddev = 0.1)
  
  ## Find threshold, denoise, reconstruct the modules:
  res &lt;- rm.get.threshold(mat1)	# threshold possibly about 0.46
  # a smaller interval had been ok as well:
  res &lt;- rm.get.threshold(mat1, interval = c(0, 0.8)) 
  cleaned &lt;- rm.denoise.mat(mat1, 0.5)
  matr &lt;- cleaned != 0
  g  &lt;- graph.adjacency(matr, mode = "undirected")
  clusters(g)	# 4 clusters reconstructed
  

## End(Not run)					  

</code></pre>

<hr>
<h2 id='rm.matrix.validation'>Validate input matrix prior to threshold computation</h2><span id='topic+rm.matrix.validation'></span>

<h3>Description</h3>

<p>The function checks if the input matrix is well-conditioned for the algorithm used by <code>RMThreshold</code>. The matrix must be real-valued, symmetric, and large. Rank and sparseness of the matrix are calculated. Diagnostic plots are created. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rm.matrix.validation(rand.mat, unfold.method = "gaussian", 
		bandwidth = "nrd0", nr.fit.points = 51, discard.outliers = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.matrix.validation_+3A_rand.mat">rand.mat</code></td>
<td>
<p> A random, real-valued, symmetric input matrix.</p>
</td></tr>
<tr><td><code id="rm.matrix.validation_+3A_unfold.method">unfold.method</code></td>
<td>
<p> A string variable that determines which type of unfolding algorithm is used. Must be one of 'gaussian' (Gaussian kernel density) or 'spline' (cubic spline interpolation on the cumulative distribution function).</p>
</td></tr>
<tr><td><code id="rm.matrix.validation_+3A_bandwidth">bandwidth</code></td>
<td>
<p> Bandwidth used to calculate the Gaussian kernel density. Only active if <code>unfold.method = 'gaussian'</code> is used. See the description of the <code>density</code> function.</p>
</td></tr>   
<tr><td><code id="rm.matrix.validation_+3A_nr.fit.points">nr.fit.points</code></td>
<td>
<p> Number of evenly spaced supporting points used for the cubic spline to the empirical cumulative distribution function.</p>
</td></tr>  
<tr><td><code id="rm.matrix.validation_+3A_discard.outliers">discard.outliers</code></td>
<td>
<p> A logical variable that determines if outliers are to be discarded from the spectrum of eigenvalues.</p>
</td></tr>     
</table>


<h3>Details</h3>

<p>The input matrix must be real-valued and symmetric (a correlation or mutual information matrix self-evidently is). The matrix must not be too sparse (if so, you are probably done without thresholding). The rank of the matrix must not be too low in order to obtain a sufficient number of non-zero eigenvalues. Furthermore, the matrix must not be too small because Random Matrix Theory applies for large (theoretically infinite) matrices only. The function creates a diagnostic plot, showing the empirical eigenvalue distribution and the distribution of the spacings between them. The eigenvalue distribution of the input matrix should approximately resemble the Wigner semi-circle, while the spacings should resemble the Wigner-Dyson distribution (Wigner surmise).   
</p>


<h3>Value</h3>

<p>A list containing the following entries:
</p>
<table role = "presentation">
<tr><td><code>sparseness</code></td>
<td>
<p> The sparseness of the input matrix.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p> The rank of the input matrix.</p>
</td></tr>  
<tr><td><code>validation.plot</code></td>
<td>
<p> The name of the valdation plot.</p>
</td></tr> 
<tr><td><code>unfold.plot</code></td>
<td>
<p> The name of the plot which can be used to check if eigenvalue unfolding worked correctly.</p>
</td></tr>
<tr><td><code>nr.outliers.removed</code></td>
<td>
<p> The number of eigenvalue outliers that have been removed. Only if <code>discard.outliers = TRUE</code> was used.</p>
</td></tr>  
</table>


<h3>Note</h3>

<p>It is highly recommended to check the input matrix using this function.</p>


<h3>Author(s)</h3>

<p> Uwe Menzel &lt;uwemenzel@gmail.com&gt; </p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Random_matrix">https://en.wikipedia.org/wiki/Random_matrix</a> 
</p>
<p>Wigner, E. P. , <em>Characteristic vectors of bordered matrices with infinite dimensions</em>, Ann. Math. 62, 548-564, 1955. 
</p>
<p>Mehta, M., <em>Random Matrices</em>, 3nd edition. Academic Press, 2004.
</p>
<p>Furht, B. and Escalante, A. (eds.), <em>Handbook of Data Intensive Computing</em>, Springer Science and Business Media, 2011.  
</p>


<h3>See Also</h3>

<p> Creating a random matrix: <code><a href="#topic+create.rand.mat">create.rand.mat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Run with self-created  random matrix:
set.seed(777)
random.matrix &lt;- create.rand.mat(size = 1000, distrib = "norm")$rand.matr
dim(random.matrix)		# 1000 1000   should be big enough

## Not run: 
res &lt;- rm.matrix.validation(random.matrix)
res &lt;- rm.matrix.validation(random.matrix, discard.outliers = FALSE)	
res &lt;- rm.matrix.validation(random.matrix, unfold.method = "spline")
res &lt;- rm.matrix.validation(random.matrix, unfold.method = "spline", discard.outliers = FALSE)

## End(Not run)

## Not run: 
  library(igraph)

  ## Create noisy matrix and validate:
  g &lt;- erdos.renyi.game(1000, 0.1)	
  adj = as.matrix(get.adjacency(g))
  rm.matrix.validation(adj)	# Wigner-Dyson case, unstructured matrix, noise

  ## Create modular (block-diagonal) matrix and validate:
  matlist = list()
  for (i in 1:4) matlist[[i]] = get.adjacency(erdos.renyi.game(250, 0.1))	
  mat &lt;- bdiag(matlist)	# block-diagonal matrix 		 
  rm.matrix.validation(as.matrix(mat))	# Exponential case, modular matrix


## End(Not run)

</code></pre>

<hr>
<h2 id='rm.show.plots'> Display a sequence of plots on screen</h2><span id='topic+rm.show.plots'></span>

<h3>Description</h3>

<p> The function displays a sequence of plots saved beforehand (e.g. by <code><a href="#topic+rm.get.threshold">rm.get.threshold</a></code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'> rm.show.plots(plotnames)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.show.plots_+3A_plotnames">plotnames</code></td>
<td>
<p> A character string or -vector containing the names of the plots to be viewed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Can be useful when the user wants to inspect the sequence of empirical eigenvalue spacing distributions (repeatedly). </p>


<h3>Value</h3>

<p> No return values are being created.</p>


<h3>Note</h3>

<p> Might cause problems in some environments, only tested on Linux.</p>


<h3>Author(s)</h3>

<p> Uwe Menzel &lt;uwemenzel@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(777)
random.matrix &lt;- create.rand.mat(size = 1000, distrib = "norm")$rand.matr
dim(random.matrix)
res &lt;- rm.get.threshold(random.matrix)					  
rm.show.plots(res$comparison.plots) # watch sequence of plots once more

## End(Not run) 
    
</code></pre>

<hr>
<h2 id='rm.spacing.distribution'>Plot the empirical distribution of the eigenvalue spacings</h2><span id='topic+rm.spacing.distribution'></span>

<h3>Description</h3>

<p>A histogram of the empirical distribution of the eigenvalue spacings is plotted. Optionally, curves illustrating the Wigner surmise and/or the Exponential distribution are added. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rm.spacing.distribution(ev.spacing, nr.breaks = 51, 
	wigner = TRUE, expo = TRUE, 
	title = "Eigenvalue spacing distribution (NNSD)", 
	threshold = NA, dist.Wigner = NA, 
	dist.Expon = NA, pop.up = TRUE, fn = NULL) 	
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.spacing.distribution_+3A_ev.spacing">ev.spacing</code></td>
<td>
<p> A numeric vector containing the spacings of the eigenvalues.</p>
</td></tr>
<tr><td><code id="rm.spacing.distribution_+3A_nr.breaks">nr.breaks</code></td>
<td>
<p> Number of bins used in the histogram.</p>
</td></tr>  
<tr><td><code id="rm.spacing.distribution_+3A_wigner">wigner</code></td>
<td>
<p> A logical variable that determines if the Wigner-Dyson distribution (Wigner surmise) is to be added to a plot.</p>
</td></tr>    
<tr><td><code id="rm.spacing.distribution_+3A_expo">expo</code></td>
<td>
<p> A logical variable that determines if the Exponential distribution is to be added to the plot.</p>
</td></tr>   
<tr><td><code id="rm.spacing.distribution_+3A_title">title</code></td>
<td>
<p> String containing the title of the plot.</p>
</td></tr>  
<tr><td><code id="rm.spacing.distribution_+3A_threshold">threshold</code></td>
<td>
<p> If not NA, this value will be displayed in the plot, labeled 'threshold'.</p>
</td></tr>    
<tr><td><code id="rm.spacing.distribution_+3A_dist.wigner">dist.Wigner</code></td>
<td>
<p> If not NA, this value will be added to the plot, with a text indicating that it is the numerical value of the Kullback-Leibler distance between the empirical eigenvalue spacing distribution function and the Wigner-Dyson distribution function. </p>
</td></tr>  
<tr><td><code id="rm.spacing.distribution_+3A_dist.expon">dist.Expon</code></td>
<td>
<p> If not NA, this value will be added to the plot, with a text indicating that it is the numerical value of the Kullback-Leibler distance between the empirical eigenvalue spacing distribution function and the Exponential distribution.</p>
</td></tr>  
<tr><td><code id="rm.spacing.distribution_+3A_pop.up">pop.up</code></td>
<td>
<p> A logical variable that determines if the plot is shown in a plot window.</p>
</td></tr>    
<tr><td><code id="rm.spacing.distribution_+3A_fn">fn</code></td>
<td>
<p> A string determining the filename for storage. Must have extension 'png' or 'pdf'.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p> The name of the plot filename chosen, or NULL.</p>


<h3>Author(s)</h3>

<p> Uwe Menzel <a href="mailto:uwemenzel@gmail.com">uwemenzel@gmail.com</a> </p>


<h3>See Also</h3>

<p> Plotting the eigenvalue distribution: <code><a href="#topic+rm.ev.density">rm.ev.density</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot histogram of the spacings of the unfolded eigenvalues of a random matrix:
set.seed(777)
random.matrix &lt;- create.rand.mat(size = 1000, distrib = "norm")$rand.matr
res &lt;- rm.ev.unfold(random.matrix)					  
rm.spacing.distribution(res$ev.spacing) 
</code></pre>

<hr>
<h2 id='RMThreshold-internal'> Internal functions for the RMThreshold package </h2><span id='topic+kb.distance'></span><span id='topic+rm.exp.distrib'></span><span id='topic+kld'></span><span id='topic+rm.get.file.extension'></span><span id='topic+rm.ev.unfold'></span><span id='topic+rm.spacing.scatter'></span><span id='topic+rm.trapez.int'></span><span id='topic+rm.reorder.ev'></span><span id='topic+rm.get.sparseness'></span><span id='topic+wigner.surmise'></span><span id='topic+wigner.semi.circle'></span><span id='topic+rm.get.distance'></span><span id='topic+rm.likelihood.plot'></span><span id='topic+rm.distance.plot'></span><span id='topic+rm.unfold.gauss'></span><span id='topic+rm.unfold.spline'></span><span id='topic+rm.sse.plot'></span><span id='topic+rm.sse'></span><span id='topic+rm.show.test'></span>

<h3>Description</h3>

<p> Internal functions for the RMThreshold package</p>


<h3>Usage</h3>

<pre><code class='language-R'>kb.distance(histo) 
rm.exp.distrib(x)
kld(observed, expected, plot) 
rm.get.file.extension(plotnames)
rm.ev.unfold(rand.mat, unfold.method, bandwidth, nr.fit.points, 
			discard.outliers, fn, pop.up, silent)  
rm.spacing.scatter(ev.spacing, title, pop.up, fn) 
rm.trapez.int(x, y)
rm.reorder.ev(eigenvalues, eigenvec) 
rm.get.sparseness(mat) 
wigner.surmise(x)
wigner.semi.circle(x)
rm.get.distance(ev.spacing, dist.method, nr.breaks)
rm.likelihood.plot(thresholds, log.le, log.lw, smooth.par, fn, interactive)
rm.distance.plot(thresholds, dist.Expon, dist.Wigner, smooth.par, fn, interactive)
rm.unfold.gauss(eigenvalues, bandwidth, fn, pop.up, silent)
rm.unfold.spline(eigenvalues, nr.fit.points, fn, pop.up)
rm.sse(ev.spacing, bandwidth, nr.points, N)
rm.show.test(thresholds, p.values, main, fn, interactive)
rm.sse.plot(thresholds, sse.values, main, fn, interactive)
</code></pre>


<h3>Arguments</h3>

	
<table role = "presentation">
<tr><td><code id="RMThreshold-internal_+3A_nr.fit.points">nr.fit.points</code></td>
<td>
<p> Number of supporting points used for the cubic spline to the empirical cumulative distribution function.</p>
</td></tr>
<tr><td><code id="RMThreshold-internal_+3A_discard.outliers">discard.outliers</code></td>
<td>
<p> A logical variable that determines if outliers are discarded from the spectrum of eigenvalues.</p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_silent">silent</code></td>
<td>
<p> A logical variable that decides if a function outputs runtime messages or not.</p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_histo">histo</code></td>
<td>
<p> An R object of class 'histogram'. Output of the <code>hist</code> function. </p>
</td></tr>
<tr><td><code id="RMThreshold-internal_+3A_x">x</code></td>
<td>
<p> A real-valued number.</p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p> A numerical vector containing the eigenvalues of a matrix.</p>
</td></tr>
<tr><td><code id="RMThreshold-internal_+3A_wigner">wigner</code></td>
<td>
<p> A logical variable that determines if the Wigner semi-circle or the Wigner surmise is added to a plot.</p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_title">title</code></td>
<td>
<p> String variable containing the title of a plot.</p>
</td></tr>
<tr><td><code id="RMThreshold-internal_+3A_pop.up">pop.up</code></td>
<td>
<p> A logical variable that determines if a plot window is supposed tp pop up during function execution.</p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_fn">fn</code></td>
<td>
<p> A filename.</p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_observed">observed</code></td>
<td>
<p> A numerical vector with the observed frequency of eigenvalues in each bin of the distribution function. </p>
</td></tr>
<tr><td><code id="RMThreshold-internal_+3A_expected">expected</code></td>
<td>
<p> A numerical vector with the expected frequency of eigenvalues in each bin. The expected values refer to a limiting distribution, either Wigner-Dyson or Exponential distribution.</p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_plot">plot</code></td>
<td>
<p> A logical variable that determines if a plot should be created. </p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_plotnames">plotnames</code></td>
<td>
<p> A string or character vector of filenames for plots to be viewed. </p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_rand.mat">rand.mat</code></td>
<td>
<p> A symmetric, real-valued random matrix. </p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_fit">fit</code></td>
<td>
<p> Name of the plot showing the cubic spline fit to the cumulative distribution. No plot will be made if <code>fit = NULL</code></p>
</td></tr> 
<tr><td><code id="RMThreshold-internal_+3A_ev.spacing">ev.spacing</code></td>
<td>
<p> A vector with the normalized eigenvalue spacings of a random matrix. </p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_y">y</code></td>
<td>
<p> A numerical vector defining the y-values of a function. </p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_eigenvec">eigenvec</code></td>
<td>
<p> A matrix containing the eigenvectors of a matrix (in columns).</p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_mat">mat</code></td>
<td>
<p> A real-valued matrix.</p>
</td></tr> 
<tr><td><code id="RMThreshold-internal_+3A_nr.breaks">nr.breaks</code></td>
<td>
<p> Number of bins used in the histogram to subdivide the empirical eigenvalue spacing distribution.</p>
</td></tr>   
<tr><td><code id="RMThreshold-internal_+3A_log.le">log.le</code></td>
<td>
<p> Log likelihood of the observed eigenvalue distances when an exponential distribution is assumed.</p>
</td></tr>   
<tr><td><code id="RMThreshold-internal_+3A_log.lw">log.lw</code></td>
<td>
<p> Log likelihood of the observed eigenvalue distances when a Wigner-Dyson distribution is assumed.</p>
</td></tr>   
<tr><td><code id="RMThreshold-internal_+3A_smooth.par">smooth.par</code></td>
<td>
<p> Parameter controlling the degree of smoothing in the loess regression curve presented in the final plot (distance vs. threshold).</p>
</td></tr>     
<tr><td><code id="RMThreshold-internal_+3A_interactive">interactive</code></td>
<td>
<p> A logical variable that determines if thresholds can be chosen by mouse clicks in the final plot (distance vs. threshold).</p>
</td></tr> 
<tr><td><code id="RMThreshold-internal_+3A_bandwidth">bandwidth</code></td>
<td>
<p> Bandwidth used to calculate the Gaussian kernel density. See description of the <code>density</code> function.</p>
</td></tr> 
<tr><td><code id="RMThreshold-internal_+3A_unfold.method">unfold.method</code></td>
<td>
<p> A string that decides which method is used for eigenvalue unfolding. One of 'gaussian' or 'spline'.</p>
</td></tr>
<tr><td><code id="RMThreshold-internal_+3A_dist.method">dist.method</code></td>
<td>
<p> A string that determines which method is used to estimate the distance to the limiting distributions. One of 'LL' (Log Likelihood) or 'KLD' (Kullback-Leibler Distance).</p>
</td></tr> 
<tr><td><code id="RMThreshold-internal_+3A_thresholds">thresholds</code></td>
<td>
<p> A numerical vector containing the values of the thresholds probed in the main function (<code>rm.get.threshold</code>).</p>
</td></tr>
<tr><td><code id="RMThreshold-internal_+3A_dist.expon">dist.Expon</code></td>
<td>
<p> A numerical vector containing the estimated distances to the Exponential distribution calculated in the main function (<code>rm.get.threshold</code>).</p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_dist.wigner">dist.Wigner</code></td>
<td>
<p> A numerical vector containing the estimated distances to the Exponential distribution calculated in the main function (<code>rm.get.threshold</code>).</p>
</td></tr> 
<tr><td><code id="RMThreshold-internal_+3A_p.values">p.values</code></td>
<td>
<p> A numerical vector containing the p-values for a significance test.</p>
</td></tr>
<tr><td><code id="RMThreshold-internal_+3A_sse.values">sse.values</code></td>
<td>
<p> A numerical vector containing the Sum of Squared Errors between observed NNSD and Exponential function.</p>
</td></tr>  
<tr><td><code id="RMThreshold-internal_+3A_nr.points">nr.points</code></td>
<td>
<p> Number of supporting points used to approximate the density function.</p>
</td></tr>
<tr><td><code id="RMThreshold-internal_+3A_n">N</code></td>
<td>
<p> Number of sections used to calculate the Sum of Squared Errors (SSE).</p>
</td></tr>     
<tr><td><code id="RMThreshold-internal_+3A_main">main</code></td>
<td>
<p> String variable containing the title of a plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> These functions are not intended to be called by the user.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
