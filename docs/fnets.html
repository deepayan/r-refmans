<!DOCTYPE html><html><head><title>Help for package fnets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fnets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abc.factor.number'><p>Factor number estimator of Alessi, Barigozzi and Capasso (2010)</p></a></li>
<li><a href='#Bartlett.weights'><p>Bartlett weights</p></a></li>
<li><a href='#common.irf.estimation'><p>Blockwise VAR estimation under GDFM</p></a></li>
<li><a href='#common.predict'><p>Forecasting the factor-driven common component</p></a></li>
<li><a href='#data.restricted'><p>Simulated data from the restricted factor-adjusted vector autoregression model</p></a></li>
<li><a href='#data.unrestricted'><p>Simulated data from the unrestricted factor-adjusted vector autoregression model</p></a></li>
<li><a href='#dyn.pca'><p>Dynamic PCA</p></a></li>
<li><a href='#ebic'><p>extended Bayesian Information Criterion</p></a></li>
<li><a href='#f.func.full'><p>full likelihood</p></a></li>
<li><a href='#factor.number'><p>Factor number selection methods</p></a></li>
<li><a href='#fnets'><p>Factor-adjusted network estimation</p></a></li>
<li><a href='#fnets.factor.model'><p>Factor model estimation</p></a></li>
<li><a href='#fnets.var'><p><code>l1</code>-regularised Yule-Walker estimation for VAR processes</p></a></li>
<li><a href='#fnets.var.internal'><p>internal function for <code>fnets.var</code></p></a></li>
<li><a href='#hl.factor.number'><p>Factor number estimator of Hallin and Liška (2007)</p></a></li>
<li><a href='#idio.predict'><p>Forecasting idiosyncratic VAR process</p></a></li>
<li><a href='#logfactorial'><p>logarithmic factorial of 'n'</p></a></li>
<li><a href='#network'><p>Convert networks into igraph objects</p></a></li>
<li><a href='#network.fnets'><p>Convert networks estimated by fnets into igraph objects</p></a></li>
<li><a href='#par.lrpc'><p>Parametric estimation of long-run partial correlations of factor-adjusted VAR processes</p></a></li>
<li><a href='#plot_internal'><p>internal function for <code>plot.fnets</code> and <code>network</code></p></a></li>
<li><a href='#plot.factor.number'><p>Plot factor number</p></a></li>
<li><a href='#plot.fnets'><p>Plotting the networks estimated by fnets</p></a></li>
<li><a href='#plot.threshold'><p>Plotting the thresholding procedure</p></a></li>
<li><a href='#predict.fm'><p>Forecasting for factor models</p></a></li>
<li><a href='#predict.fnets'><p>Forecasting by fnets</p></a></li>
<li><a href='#print.factor.number'><p>Print factor number</p></a></li>
<li><a href='#print.fm'><p>Print factor model</p></a></li>
<li><a href='#print.fnets'><p>Print fnets</p></a></li>
<li><a href='#print.threshold'><p>Print threshold</p></a></li>
<li><a href='#sim.restricted'><p>Simulate data from a restricted factor model</p></a></li>
<li><a href='#sim.unrestricted'><p>Simulate data from an unrestricted factor model</p></a></li>
<li><a href='#sim.var'><p>Simulate a VAR(1) process</p></a></li>
<li><a href='#static.pca'><p>Static PCA</p></a></li>
<li><a href='#threshold'><p>Threshold the entries of the input matrix at a data-driven level</p></a></li>
<li><a href='#tuning_plot'><p>Plotting output for tuning parameter selection in fnets</p></a></li>
<li><a href='#var.dantzig'><p>Dantzig selector-type estimator of VAR processes via constrained <code>l1</code>-minimisation</p></a></li>
<li><a href='#var.lasso'><p>Lasso-type estimator of VAR processes via <code>l1</code>-regularised <code>M</code>-estimation</p></a></li>
<li><a href='#yw.cv'><p>Cross validation for factor-adjusted VAR estimation</p></a></li>
<li><a href='#yw.ic'><p>Information criterion for factor-adjusted VAR estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Factor-Adjusted Network Estimation and Forecasting for
High-Dimensional Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haeran Cho &lt;haeran.cho@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements methods for network estimation and forecasting of high-dimensional time series 
    exhibiting strong serial and cross-sectional correlations under a factor-adjusted vector autoregressive model.
    See Barigozzi, Cho and Owens (2024+) &lt;<a href="https://doi.org/10.1080%2F07350015.2023.2257270">doi:10.1080/07350015.2023.2257270</a>&gt; for further descriptions of FNETS methodology and 
    Owens, Cho and Barigozzi (2024+) &lt;<a href="https://doi.org/10.48550/arXiv.2301.11675">doi:10.48550/arXiv.2301.11675</a>&gt; accompanying the R package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lpSolve, parallel, doParallel, foreach, MASS, fields, igraph,
RColorBrewer</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 08:17:08 UTC; h</td>
</tr>
<tr>
<td>Author:</td>
<td>Matteo Barigozzi [aut],
  Haeran Cho [cre, aut],
  Dom Owens [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 09:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='abc.factor.number'>Factor number estimator of Alessi, Barigozzi and Capasso (2010)</h2><span id='topic+abc.factor.number'></span>

<h3>Description</h3>

<p>Estimates the number of factors by minimising an information criterion over sub-samples of the data.
Currently the three information criteria proposed in Alessi, Barigozzi and Capasso (2010) (<code>ic.op = 1, 2, 3</code>)
and their variations with logarithm taken on the cost (<code>ic.op = 4, 5, 6</code>) are implemented,
with <code>ic.op = 5</code> recommended as a default choice based on numerical experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abc.factor.number(x, covx = NULL, q.max = NULL, center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abc.factor.number_+3A_x">x</code></td>
<td>
<p>input time series matrix, with each row representing a variable</p>
</td></tr>
<tr><td><code id="abc.factor.number_+3A_covx">covx</code></td>
<td>
<p>covariance of <code>x</code></p>
</td></tr>
<tr><td><code id="abc.factor.number_+3A_q.max">q.max</code></td>
<td>
<p>maximum number of factors; if <code>q.max = NULL</code>, a default value is selected as <code>min(50, floor(sqrt(min(dim(x)[2] - 1, dim(x)[1]))))</code></p>
</td></tr>
<tr><td><code id="abc.factor.number_+3A_center">center</code></td>
<td>
<p>whether to de-mean the input <code>x</code> row-wise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Alessi, Barigozzi and Capasso (2010) for further details.
</p>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>q.hat</code></td>
<td>
<p> the mimimiser of the chosen information criteria</p>
</td></tr>
</table>


<h3>References</h3>

<p>Alessi, L., Barigozzi, M.,  &amp; Capasso, M. (2010) Improved penalization for determining the number of factors in approximate factor models. Statistics &amp; Probability Letters, 80(23-24):1806–1813.
</p>

<hr>
<h2 id='Bartlett.weights'>Bartlett weights</h2><span id='topic+Bartlett.weights'></span>

<h3>Description</h3>

<p>Bartlett weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bartlett.weights(x)
</code></pre>

<hr>
<h2 id='common.irf.estimation'>Blockwise VAR estimation under GDFM</h2><span id='topic+common.irf.estimation'></span>

<h3>Description</h3>

<p>Blockwise VAR estimation under GDFM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common.irf.estimation(
  xx,
  Gamma_c,
  q,
  factor.var.order = NULL,
  max.var.order = NULL,
  trunc.lags,
  n.perm
)
</code></pre>

<hr>
<h2 id='common.predict'>Forecasting the factor-driven common component</h2><span id='topic+common.predict'></span>

<h3>Description</h3>

<p>Produces forecasts of the common component
for a given forecasting horizon by estimating the best linear predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common.predict(object, x, n.ahead = 1, fc.restricted = TRUE, r = c("ic", "er"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="common.predict_+3A_object">object</code></td>
<td>
<p><code>fnets</code> object</p>
</td></tr>
<tr><td><code id="common.predict_+3A_x">x</code></td>
<td>
<p>input time series matrix, with each row representing a variable</p>
</td></tr>
<tr><td><code id="common.predict_+3A_n.ahead">n.ahead</code></td>
<td>
<p>forecasting horizon</p>
</td></tr>
<tr><td><code id="common.predict_+3A_fc.restricted">fc.restricted</code></td>
<td>
<p>whether to forecast using a restricted or unrestricted, blockwise VAR representation of the common component</p>
</td></tr>
<tr><td><code id="common.predict_+3A_r">r</code></td>
<td>
<p>number of restricted factors, or a string specifying the factor number selection method when <code>fc.restricted = TRUE</code>;
possible values are:
</p>

<dl>
<dt><code>"ic"</code></dt><dd><p> information criteria of Alessi, Barigozzi &amp; Capasso (2010))</p>
</dd>
<dt><code>"er"</code></dt><dd><p> eigenvalue ratio of Ahn &amp; Horenstein (2013)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>is</code></td>
<td>
<p> in-sample estimator of the common component (with each column representing a variable)</p>
</td></tr>
<tr><td><code>fc</code></td>
<td>
<p> forecasts of the common component for a given forecasting horizon <code>h</code> (with each column representing a variable)</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p> restricted factor number</p>
</td></tr>
<tr><td><code>n.ahead</code></td>
<td>
<p> forecast horizon</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ahn, S. C. &amp; Horenstein, A. R. (2013) Eigenvalue ratio test for the number of factors. Econometrica, 81(3), 1203&ndash;1227.
</p>
<p>Alessi, L., Barigozzi, M., and Capasso, M. (2010) Improved penalization for determining the number of factors in approximate factor models. Statistics &amp; Probability Letters, 80(23-24):1806–1813.
</p>
<p>Barigozzi, M., Cho, H. &amp; Owens, D. (2024+) FNETS: Factor-adjusted network estimation and forecasting for high-dimensional time series. Journal of Business &amp; Economic Statistics (to appear).
</p>
<p>Forni, M., Hallin, M., Lippi, M. &amp; Reichlin, L. (2005) The generalized dynamic factor model: one-sided estimation and forecasting. Journal of the American Statistical Association, 100(471), 830&ndash;840.
</p>
<p>Forni, M., Hallin, M., Lippi, M. &amp; Zaffaroni, P. (2017) Dynamic factor models with infinite-dimensional factor space: Asymptotic analysis. Journal of Econometrics, 199(1), 74&ndash;92.
</p>
<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out &lt;- fnets(data.unrestricted, q = NULL, var.order = 1, var.method = "lasso",
do.lrpc = FALSE, var.args = list(n.cores = 2))
cpre &lt;- common.predict(out)
ipre &lt;- idio.predict(out, cpre)

## End(Not run)
</code></pre>

<hr>
<h2 id='data.restricted'>Simulated data from the restricted factor-adjusted vector autoregression model</h2><span id='topic+data.restricted'></span>

<h3>Description</h3>

<p><code>set.seed(123)</code> <br />
<code>n &lt;- 500</code> <br />
<code>p &lt;- 50</code> <br />
<code>common &lt;- sim.restricted(n, p)</code> <br />
<code>idio &lt;- sim.var(n, p)</code> <br />
<code>x &lt;- common$data + idio$data</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.restricted
</code></pre>


<h3>Format</h3>

<p>## 'data.restricted'
A ts object with 500 rows (observations) and 50 columns (series)
</p>

<hr>
<h2 id='data.unrestricted'>Simulated data from the unrestricted factor-adjusted vector autoregression model</h2><span id='topic+data.unrestricted'></span>

<h3>Description</h3>

<p><code>set.seed(123)</code> <br />
<code>n &lt;- 500</code> <br />
<code>p &lt;- 50</code> <br />
<code>common &lt;- sim.unrestricted(n, p)</code> <br />
<code>idio &lt;- sim.var(n, p)</code> <br />
<code>x &lt;- common$data + idio$data</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.unrestricted
</code></pre>


<h3>Format</h3>

<p>## 'data.unrestricted'
A ts object with 500 rows (observations) and 50 columns (series)
</p>

<hr>
<h2 id='dyn.pca'>Dynamic PCA</h2><span id='topic+dyn.pca'></span>

<h3>Description</h3>

<p>Performs principal components analysis in frequency domain for identifying common and idiosyncratic components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyn.pca(
  xx,
  q = NULL,
  q.method = c("ic", "er"),
  ic.op = 5,
  kern.bw = NULL,
  mm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyn.pca_+3A_xx">xx</code></td>
<td>
<p>centred input time series matrix, with each row representing a variable</p>
</td></tr>
<tr><td><code id="dyn.pca_+3A_q">q</code></td>
<td>
<p>number of factors. If <code>q = NULL</code>, the factor number is estimated by an information criterion-based approach of Hallin and Liška (2007)</p>
</td></tr>
<tr><td><code id="dyn.pca_+3A_q.method">q.method</code></td>
<td>
<p>A string specifying the factor number selection method; possible values are:
</p>

<dl>
<dt><code>"ic"</code></dt><dd><p> information criteria-based methods of Alessi, Barigozzi &amp; Capasso (2010) when <code>fm.restricted = TRUE</code> or Hallin and Liška (2007) when <code>fm.restricted = FALSE</code></p>
</dd>
<dt><code>"er"</code></dt><dd><p> eigenvalue ratio of Ahn and Horenstein (2013)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dyn.pca_+3A_ic.op">ic.op</code></td>
<td>
<p>choice of the information criterion penalty. Currently the three options from Hallin and Liška (2007) (<code>ic.op = 1, 2</code> or <code>3</code>) and
their variations with logarithm taken on the cost (<code>ic.op = 4, 5</code> or <code>6</code>) are implemented,
with <code>ic.op = 5</code> recommended as a default choice based on numerical experiments</p>
</td></tr>
<tr><td><code id="dyn.pca_+3A_kern.bw">kern.bw</code></td>
<td>
<p>a positive integer specifying the kernel bandwidth for dynamic PCA; by default, it is set to <code>floor(4 *(dim(x)[2]/log(dim(x)[2]))^(1/3)))</code></p>
</td></tr>
<tr><td><code id="dyn.pca_+3A_mm">mm</code></td>
<td>
<p>bandwidth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p> number of factors</p>
</td></tr>
<tr><td><code>q.method.out</code></td>
<td>
<p> if <code>q = NULL</code>, the output from the chosen <code>q.method</code>, either a vector of eigenvalue ratios or <a href="#topic+hl.factor.number">hl.factor.number</a></p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p> a list containing the estimates of the spectral density matrices for <code>x</code>, common and idiosyncratic components</p>
</td></tr>
<tr><td><code>acv</code></td>
<td>
<p> a list containing estimates of the autocovariance matrices for <code>x</code>, common and idiosyncratic components</p>
</td></tr>
<tr><td><code>kern.bw</code></td>
<td>
<p> input parameter</p>
</td></tr>
</table>

<hr>
<h2 id='ebic'>extended Bayesian Information Criterion</h2><span id='topic+ebic'></span>

<h3>Description</h3>

<p>extended Bayesian Information Criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebic(object, n, penalty = 0)
</code></pre>

<hr>
<h2 id='f.func.full'>full likelihood</h2><span id='topic+f.func.full'></span>

<h3>Description</h3>

<p>full likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.func.full(GG, gg, A)
</code></pre>

<hr>
<h2 id='factor.number'>Factor number selection methods</h2><span id='topic+factor.number'></span>

<h3>Description</h3>

<p>Methods to estimate the number of factor.
When <code>method = 'er'</code>, the factor number is estimated by maximising the ration of successive eigenvalues.
When <code>method = 'ic'</code>, the information criterion-methods discussed in Hallin and Liška (2007) (when <code>fm.restricted = FALSE</code>)
and Alessi, Barigozzi and Capasso (2010) (when <code>fm.restricted = TRUE</code>) are implemented.
The information criterion called by <code>ic.op = 5</code> (as an argument to <code>fnets</code> or <code>fnets.factor.model</code>) is recommended by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor.number(
  x,
  fm.restricted = FALSE,
  method = c("ic", "er"),
  q.max = NULL,
  center = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor.number_+3A_x">x</code></td>
<td>
<p>input time series each column representing a time series variable; it is coerced into a <a href="stats.html#topic+ts">ts</a> object</p>
</td></tr>
<tr><td><code id="factor.number_+3A_fm.restricted">fm.restricted</code></td>
<td>
<p>whether to estimate the number of restricted or unrestricted factors</p>
</td></tr>
<tr><td><code id="factor.number_+3A_method">method</code></td>
<td>
<p>A string specifying the factor number selection method; possible values are:
</p>

<dl>
<dt><code>"ic"</code></dt><dd><p> information criteria-based methods of Alessi, Barigozzi &amp; Capasso (2010) when <code>fm.restricted = TRUE</code> or Hallin and Liška (2007) when <code>fm.restricted = FALSE</code></p>
</dd>
<dt><code>"er"</code></dt><dd><p> eigenvalue ratio of Ahn and Horenstein (2013) when <code>fm.restricted = TRUE</code> or Avarucci et al. (2022) when <code>fm.restricted = FALSE</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="factor.number_+3A_q.max">q.max</code></td>
<td>
<p>maximum number of factors; if <code>q.max = NULL</code>, a default value is selected as <code>min(50, floor(sqrt(min(dim(x)[2] - 1, dim(x)[1]))))</code></p>
</td></tr>
<tr><td><code id="factor.number_+3A_center">center</code></td>
<td>
<p>whether to de-mean the input <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details, see references.
</p>


<h3>Value</h3>

<p>S3 object of class <code>factor.number</code>.
If <code>method = "ic"</code>, a vector containing minimisers of the six information criteria, otherwise, the maximiser of the eigenvalue ratio
</p>


<h3>References</h3>

<p>Ahn, S. C. &amp; Horenstein, A. R. (2013) Eigenvalue ratio test for the number of factors. Econometrica, 81(3), 1203&ndash;1227.
</p>
<p>Alessi, L., Barigozzi, M., and Capasso, M. (2010) Improved penalization for determining the number of factors in approximate factor models. Statistics &amp; Probability Letters, 80(23-24):1806–1813.
</p>
<p>Avarucci, M., Cavicchioli, M., Forni, M., &amp; Zaffaroni, P. (2022) The main business cycle shock(s): Frequency-band estimation of the number of dynamic factors.
</p>
<p>Hallin, M. &amp; Liška, R. (2007) Determining the number of factors in the general dynamic factor model. Journal of the American Statistical Association, 102(478), 603&ndash;617.
</p>
<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.factor.number">plot.factor.number</a>, <a href="#topic+print.factor.number">print.factor.number</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fnets)
## Alessi, Barigozzi, and Capasso method for restricted models
abc &lt;- factor.number(data.restricted, fm.restricted = TRUE)
print(abc)
plot(abc)

## Eigenvalue ratio method
er &lt;- factor.number(data.restricted, method = "er", fm.restricted = TRUE)
print(er)
plot(er)

## Hallin and Liška method for unrestricted models
hl &lt;- factor.number(data.unrestricted, fm.restricted = FALSE)
print(hl)
plot(hl)
</code></pre>

<hr>
<h2 id='fnets'>Factor-adjusted network estimation</h2><span id='topic+fnets'></span>

<h3>Description</h3>

<p>Under a factor-adjusted vector autoregressive (VAR) model,
the function estimates the spectral density and autocovariance matrices of the factor-driven common component and the idiosyncratic VAR process,
the impulse response functions and common shocks for the common component,
and VAR parameters, innovation covariance matrix and long-run partial correlations for the idiosyncratic component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnets(
  x,
  center = TRUE,
  fm.restricted = FALSE,
  q = c("ic", "er"),
  ic.op = NULL,
  kern.bw = NULL,
  common.args = list(factor.var.order = NULL, max.var.order = NULL, trunc.lags = 20,
    n.perm = 10),
  var.order = 1,
  var.method = c("lasso", "ds"),
  var.args = list(n.iter = NULL, n.cores = 1),
  do.threshold = FALSE,
  do.lrpc = TRUE,
  lrpc.adaptive = FALSE,
  tuning.args = list(tuning = c("cv", "bic"), n.folds = 1, penalty = NULL, path.length =
    10)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnets_+3A_x">x</code></td>
<td>
<p>input time series each column representing a time series variable; it is coerced into a <a href="stats.html#topic+ts">ts</a> object</p>
</td></tr>
<tr><td><code id="fnets_+3A_center">center</code></td>
<td>
<p>whether to de-mean the input <code>x</code></p>
</td></tr>
<tr><td><code id="fnets_+3A_fm.restricted">fm.restricted</code></td>
<td>
<p>whether to estimate a restricted factor model using static PCA</p>
</td></tr>
<tr><td><code id="fnets_+3A_q">q</code></td>
<td>
<p>Either the number of factors or a string specifying the factor number selection method; possible values are:
</p>

<dl>
<dt><code>"ic"</code></dt><dd><p> information criteria-based methods of Alessi, Barigozzi &amp; Capasso (2010) when <code>fm.restricted = TRUE</code> or Hallin and Liška (2007) when <code>fm.restricted = FALSE</code></p>
</dd>
<dt><code>"er"</code></dt><dd><p> eigenvalue ratio of Ahn and Horenstein (2013) when <code>fm.restricted = TRUE</code> or Avarucci et al. (2022) when <code>fm.restricted = FALSE</code></p>
</dd>
</dl>

<p>see <a href="#topic+factor.number">factor.number</a>.</p>
</td></tr>
<tr><td><code id="fnets_+3A_ic.op">ic.op</code></td>
<td>
<p>choice of the information criterion penalty, see <a href="#topic+factor.number">factor.number</a> for further details</p>
</td></tr>
<tr><td><code id="fnets_+3A_kern.bw">kern.bw</code></td>
<td>
<p>a positive integer specifying the kernel bandwidth for dynamic PCA; by default, it is set to <code>floor(4 *(dim(x)[2]/log(dim(x)[2]))^(1/3)))</code>.  When <code>fm.restricted = TRUE</code>, it is used to compute the number of lags for which autocovariance matrices are estimated</p>
</td></tr>
<tr><td><code id="fnets_+3A_common.args">common.args</code></td>
<td>
<p>a list specifying the tuning parameters required for estimating the impulse response functions and common shocks. It contains:
</p>

<dl>
<dt><code>factor.var.order</code></dt><dd><p> order of the blockwise VAR representation of the common component. If <code>factor.var.order = NULL</code>, it is selected blockwise by Schwarz criterion</p>
</dd>
<dt><code>max.var.order</code></dt><dd><p> maximum blockwise VAR order for the Schwarz criterion</p>
</dd>
<dt><code>trunc.lags</code></dt><dd><p> truncation lag for impulse response function estimation</p>
</dd>
<dt><code>n.perm</code></dt><dd><p> number of cross-sectional permutations involved in impulse response function estimation</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fnets_+3A_var.order">var.order</code></td>
<td>
<p>order of the idiosyncratic VAR process; if a vector of integers is supplied, the order is chosen via <code>tuning</code></p>
</td></tr>
<tr><td><code id="fnets_+3A_var.method">var.method</code></td>
<td>
<p>a string specifying the method to be adopted for idiosyncratic VAR process estimation; possible values are:
</p>

<dl>
<dt><code>"lasso"</code></dt><dd><p> Lasso-type <code>l1</code>-regularised <code>M</code>-estimation</p>
</dd>
<dt><code>"ds"</code></dt><dd><p> Dantzig Selector-type constrained <code>l1</code>-minimisation</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fnets_+3A_var.args">var.args</code></td>
<td>
<p>a list specifying the tuning parameters required for estimating the idiosyncratic VAR process. It contains:
</p>

<dl>
<dt><code>n.iter</code></dt><dd><p> maximum number of descent steps, by default depends on <code>var.order</code>; applicable when <code>var.method = "lasso"</code></p>
</dd>
<dt><code>n.cores</code></dt><dd><p> number of cores to use for parallel computing, see <a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a>; applicable when <code>var.method = "ds"</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fnets_+3A_do.threshold">do.threshold</code></td>
<td>
<p>whether to perform adaptive thresholding of all parameter estimators with <a href="#topic+threshold">threshold</a></p>
</td></tr>
<tr><td><code id="fnets_+3A_do.lrpc">do.lrpc</code></td>
<td>
<p>whether to estimate the long-run partial correlation</p>
</td></tr>
<tr><td><code id="fnets_+3A_lrpc.adaptive">lrpc.adaptive</code></td>
<td>
<p>whether to use the adaptive estimation procedure</p>
</td></tr>
<tr><td><code id="fnets_+3A_tuning.args">tuning.args</code></td>
<td>
<p>a list specifying arguments for selecting the tuning parameters involved in VAR parameter and (long-run) partial correlation matrix estimation. It contains:
</p>

<dl>
<dt><code>tuning</code></dt><dd><p>a string specifying the selection procedure for <code>var.order</code> and <code>lambda</code>; possible values are:
<code>"cv"</code> for cross validation, and <code>"bic"</code> for information criterion</p>
</dd>
<dt><code>n.folds</code></dt><dd><p> if <code>tuning = "cv"</code>, positive integer number of folds</p>
</dd>
<dt><code>penalty</code></dt><dd><p> if <code>tuning = "bic"</code>, penalty multiplier between 0 and 1; if <code>penalty = NULL</code>, it is set to <code>1/(1+exp(dim(x)[1])/dim(x)[2]))</code></p>
</dd></dl>
<p> by default
</p>
<dl>
<dt><code>path.length</code></dt><dd><p> positive integer number of regularisation parameter values to consider; a sequence is generated automatically based in this value</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>See Barigozzi, Cho and Owens (2024+) for further details.
List arguments do not need to be specified with all list components; any missing entries will be filled in with the default argument.
</p>


<h3>Value</h3>

<p>an S3 object of class <code>fnets</code>, which contains the following fields:
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p> number of factors</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p> if <code>fm.restricted = FALSE</code> a list containing estimates of the spectral density matrices for <code>x</code>, common and idiosyncratic components</p>
</td></tr>
<tr><td><code>acv</code></td>
<td>
<p> a list containing estimates of the autocovariance matrices for <code>x</code>, common and idiosyncratic components</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p> if <code>fm.restricted = TRUE</code>, factor loadings; if <code>fm.restricted = FALSE</code> and <code>q &gt;= 1</code>,
a list containing estimators of the impulse response functions (as an array of dimension <code>(p, q, trunc.lags + 2)</code>)</p>
</td></tr>
<tr><td><code>factors</code></td>
<td>
<p> if <code>fm.restricted = TRUE</code>, factor series; else, common shocks (an array of dimension <code>(q, n)</code>)</p>
</td></tr>
<tr><td><code>idio.var</code></td>
<td>
<p> a list containing the following fields:
</p>

<dl>
<dt><code>beta</code></dt><dd><p> estimate of VAR parameter matrix; each column contains parameter estimates for the regression model for a given variable</p>
</dd>
<dt><code>Gamma</code></dt><dd><p> estimate of the innovation covariance matrix</p>
</dd>
<dt><code>lambda</code></dt><dd><p> regularisation parameter</p>
</dd>
<dt><code>var.order</code></dt><dd><p> VAR order</p>
</dd>
</dl>
</td></tr>
<tr><td><code>lrpc</code></td>
<td>
<p> see the output of <a href="#topic+par.lrpc">par.lrpc</a></p>
</td></tr>
<tr><td><code>mean.x</code></td>
<td>
<p> if <code>center = TRUE</code>, returns a vector containing row-wise sample means of <code>x</code>; if <code>center = FALSE</code>, returns a vector of zeros</p>
</td></tr>
<tr><td><code>var.method</code></td>
<td>
<p> input parameter</p>
</td></tr>
<tr><td><code>do.lrpc</code></td>
<td>
<p> input parameter</p>
</td></tr>
<tr><td><code>kern.bw</code></td>
<td>
<p> input parameter</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ahn, S. C. &amp; Horenstein, A. R. (2013) Eigenvalue ratio test for the number of factors. Econometrica, 81(3), 1203&ndash;1227.
</p>
<p>Alessi, L., Barigozzi, M.,  &amp; Capasso, M. (2010) Improved penalization for determining the number of factors in approximate factor models. Statistics &amp; Probability Letters, 80(23-24):1806–1813.
</p>
<p>Avarucci, M., Cavicchioli, M., Forni, M., &amp; Zaffaroni, P. (2022) The main business cycle shock(s): Frequency-band estimation of the number of dynamic factors.
</p>
<p>Barigozzi, M., Cho, H. &amp; Owens, D. (2024+) FNETS: Factor-adjusted network estimation and forecasting for high-dimensional time series. Journal of Business &amp; Economic Statistics (to appear).
</p>
<p>Hallin, M. &amp; Liška, R. (2007) Determining the number of factors in the general dynamic factor model. Journal of the American Statistical Association, 102(478), 603&ndash;617.
</p>
<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.fnets">predict.fnets</a>, <a href="#topic+plot.fnets">plot.fnets</a>, <a href="#topic+print.fnets">print.fnets</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
out &lt;- fnets(data.unrestricted,
  do.threshold = TRUE,
  var.args = list(n.cores = 2)
)
pre &lt;- predict(out, common.method = "unrestricted")
plot(out, type = "granger", display = "network")
plot(out, type = "lrpc", display = "heatmap")

</code></pre>

<hr>
<h2 id='fnets.factor.model'>Factor model estimation</h2><span id='topic+fnets.factor.model'></span>

<h3>Description</h3>

<p>Performs factor modelling under either restricted (static) or unrestricted (dynamic) factor models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnets.factor.model(
  x,
  center = TRUE,
  fm.restricted = FALSE,
  q = c("ic", "er"),
  ic.op = NULL,
  kern.bw = NULL,
  common.args = list(factor.var.order = NULL, max.var.order = NULL, trunc.lags = 20,
    n.perm = 10)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnets.factor.model_+3A_x">x</code></td>
<td>
<p>input time series each column representing a time series variable; it is coerced into a <a href="stats.html#topic+ts">ts</a> object</p>
</td></tr>
<tr><td><code id="fnets.factor.model_+3A_center">center</code></td>
<td>
<p>whether to de-mean the input <code>x</code></p>
</td></tr>
<tr><td><code id="fnets.factor.model_+3A_fm.restricted">fm.restricted</code></td>
<td>
<p>whether to estimate a restricted factor model using static PCA</p>
</td></tr>
<tr><td><code id="fnets.factor.model_+3A_q">q</code></td>
<td>
<p>Either a string specifying the factor number selection method when <code>fm.restricted = TRUE</code>; possible values are:
</p>

<dl>
<dt><code>"ic"</code></dt><dd><p> information criteria-based methods of Alessi, Barigozzi &amp; Capasso (2010) when <code>fm.restricted = TRUE</code> or Hallin and Liška (2007) when <code>fm.restricted = FALSE</code></p>
</dd>
<dt><code>"er"</code></dt><dd><p> eigenvalue ratio of Ahn and Horenstein (2013) when <code>fm.restricted = TRUE</code> or Avarucci et al. (2022) when <code>fm.restricted = FALSE</code></p>
</dd>
</dl>

<p>or the number of unrestricted factors, see <a href="#topic+factor.number">factor.number</a></p>
</td></tr>
<tr><td><code id="fnets.factor.model_+3A_ic.op">ic.op</code></td>
<td>
<p>choice of the information criterion penalty, see <a href="#topic+hl.factor.number">hl.factor.number</a> or <a href="#topic+abc.factor.number">abc.factor.number</a> for further details</p>
</td></tr>
<tr><td><code id="fnets.factor.model_+3A_kern.bw">kern.bw</code></td>
<td>
<p>a positive integer specifying the kernel bandwidth for dynamic PCA;
by default, it is set to <code>floor(4 *(dim(x)[2]/log(dim(x)[2]))^(1/3)))</code>.
When <code>fm.restricted = TRUE</code>, it is used to compute the number of lags for which autocovariance matrices are estimated</p>
</td></tr>
<tr><td><code id="fnets.factor.model_+3A_common.args">common.args</code></td>
<td>
<p>a list specifying the tuning parameters required for estimating the impulse response functions and common shocks. It contains:
</p>

<dl>
<dt><code>factor.var.order</code></dt><dd><p> order of the blockwise VAR representation of the common component. If <code>factor.var.order = NULL</code>, it is selected blockwise by Schwarz criterion</p>
</dd>
<dt><code>max.var.order</code></dt><dd><p> maximum blockwise VAR order for the Schwarz criterion</p>
</dd>
<dt><code>trunc.lags</code></dt><dd><p> truncation lag for impulse response function estimation</p>
</dd>
<dt><code>n.perm</code></dt><dd><p> number of cross-sectional permutations involved in impulse response function estimation</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>See Barigozzi, Cho and Owens (2024+) for further details.
</p>


<h3>Value</h3>

<p>an S3 object of class <code>fm</code>, which contains the following fields:
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p> number of factors</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p> if <code>fm.restricted = FALSE</code> a list containing estimates of the spectral density matrices for <code>x</code>, common and idiosyncratic components</p>
</td></tr>
<tr><td><code>acv</code></td>
<td>
<p> a list containing estimates of the autocovariance matrices for <code>x</code>, common and idiosyncratic components</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p> if <code>fm.restricted = TRUE</code>, factor loadings; if <code>fm.restricted = FALSE</code> and <code>q &gt;= 1</code>,
a list containing estimators of the impulse response functions (as an array of dimension <code>(p, q, trunc.lags + 2)</code>)</p>
</td></tr>
<tr><td><code>factors</code></td>
<td>
<p> if <code>fm.restricted = TRUE</code>, factor series; else, common shocks (an array of dimension <code>(q, n)</code>)</p>
</td></tr>
<tr><td><code>mean.x</code></td>
<td>
<p> if <code>center = TRUE</code>, returns a vector containing row-wise sample means of <code>x</code>; if <code>center = FALSE</code>, returns a vector of zeros</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ahn, S. C. &amp; Horenstein, A. R. (2013) Eigenvalue ratio test for the number of factors. Econometrica, 81(3), 1203&ndash;1227.
</p>
<p>Alessi, L., Barigozzi, M.,  &amp; Capasso, M. (2010) Improved penalization for determining the number of factors in approximate factor models. Statistics &amp; Probability Letters, 80(23-24):1806–1813.
</p>
<p>Avarucci, M., Cavicchioli, M., Forni, M., &amp; Zaffaroni, P. (2022) The main business cycle shock(s): Frequency-band estimation of the number of dynamic factors.
</p>
<p>Barigozzi, M., Cho, H. &amp; Owens, D. (2024+) FNETS: Factor-adjusted network estimation and forecasting for high-dimensional time series. Journal of Business &amp; Economic Statistics (to appear).
</p>
<p>Hallin, M. &amp; Liška, R. (2007) Determining the number of factors in the general dynamic factor model. Journal of the American Statistical Association, 102(478), 603&ndash;617.
</p>
<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>See Also</h3>

<p><a href="#topic+print.fm">print.fm</a>, <a href="#topic+predict.fm">predict.fm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
out &lt;- fnets.factor.model(data.restricted, fm.restricted = TRUE)

</code></pre>

<hr>
<h2 id='fnets.var'><code>l1</code>-regularised Yule-Walker estimation for VAR processes</h2><span id='topic+fnets.var'></span>

<h3>Description</h3>

<p>Estimates the VAR parameter matrices via <code>l1</code>-regularised Yule-Walker estimation
and innovation covariance matrix via constrained <code>l1</code>-minimisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnets.var(
  x,
  center = TRUE,
  method = c("lasso", "ds"),
  lambda = NULL,
  var.order = 1,
  tuning.args = list(tuning = c("cv", "bic"), n.folds = 1, penalty = NULL, path.length =
    10),
  do.threshold = FALSE,
  n.iter = NULL,
  tol = 0,
  n.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnets.var_+3A_x">x</code></td>
<td>
<p>input time series each column representing a time series variable; it is coerced into a <a href="stats.html#topic+ts">ts</a> object</p>
</td></tr>
<tr><td><code id="fnets.var_+3A_center">center</code></td>
<td>
<p>whether to de-mean the input <code>x</code></p>
</td></tr>
<tr><td><code id="fnets.var_+3A_method">method</code></td>
<td>
<p>a string specifying the method to be adopted for VAR process estimation; possible values are:
</p>

<dl>
<dt><code>"lasso"</code></dt><dd><p> Lasso-type <code>l1</code>-regularised <code>M</code>-estimation</p>
</dd>
<dt><code>"ds"</code></dt><dd><p> Dantzig Selector-type constrained <code>l1</code>-minimisation</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fnets.var_+3A_lambda">lambda</code></td>
<td>
<p><code>l1</code>-regularisation parameter; if <code>lambda = NULL</code>, <code>tuning</code> is employed to select the parameter</p>
</td></tr>
<tr><td><code id="fnets.var_+3A_var.order">var.order</code></td>
<td>
<p>order of the VAR process; if a vector of integers is supplied, the order is chosen via <code>tuning</code></p>
</td></tr>
<tr><td><code id="fnets.var_+3A_tuning.args">tuning.args</code></td>
<td>
<p>a list specifying arguments for <code>tuning</code>
for selecting the regularisation parameter (and VAR order). It contains:
</p>

<dl>
<dt><code>tuning</code></dt><dd><p>a string specifying the selection procedure for <code>var.order</code> and <code>lambda</code>; possible values are:
<code>"cv"</code> for cross validation, and <code>"bic"</code> for information criterion</p>
</dd>
<dt><code>n.folds</code></dt><dd><p> if <code>tuning = "cv"</code>, positive integer number of folds</p>
</dd>
<dt><code>penalty</code></dt><dd><p> if <code>tuning = "bic"</code>, penalty multiplier between 0 and 1; if <code>penalty = NULL</code>, it is set to <code>1/(1+exp(dim(x)[1])/dim(x)[2]))</code></p>
</dd></dl>
<p> by default
</p>
<dl>
<dt><code>path.length</code></dt><dd><p> positive integer number of regularisation parameter values to consider; a sequence is generated automatically based in this value</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fnets.var_+3A_do.threshold">do.threshold</code></td>
<td>
<p>whether to perform adaptive thresholding of VAR parameter estimator with <a href="#topic+threshold">threshold</a></p>
</td></tr>
<tr><td><code id="fnets.var_+3A_n.iter">n.iter</code></td>
<td>
<p>maximum number of descent steps, by default depends on <code>var.order</code>; applicable when <code>method = "lasso"</code></p>
</td></tr>
<tr><td><code id="fnets.var_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance for increases in the loss function; applicable when <code>method = "lasso"</code></p>
</td></tr>
<tr><td><code id="fnets.var_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use for parallel computing, see <a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a>; applicable when <code>method = "ds"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further information can be found in Barigozzi, Cho and Owens (2024+).
</p>


<h3>Value</h3>

<p>a list which contains the following fields:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p> estimate of VAR parameter matrix; each column contains parameter estimates for the regression model for a given variable</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p> estimate of the innovation covariance matrix</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
 <p><code>l1</code>-regularisation parameter</p>
</td></tr>
<tr><td><code>var.order</code></td>
<td>
<p> VAR order</p>
</td></tr>
<tr><td><code>mean.x</code></td>
<td>
<p> if <code>center = TRUE</code>, returns a vector containing row-wise sample means of <code>x</code>; if <code>center = FALSE</code>, returns a vector of zeros</p>
</td></tr>
</table>


<h3>References</h3>

<p>Barigozzi, M., Cho, H. &amp; Owens, D. (2024+) FNETS: Factor-adjusted network estimation and forecasting for high-dimensional time series. Journal of Business &amp; Economic Statistics (to appear).
</p>
<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fnets)

set.seed(123)
n &lt;- 500
p &lt;- 50
idio &lt;- sim.var(n, p)
x &lt;- idio$data

fv &lt;- fnets.var(x,
  n.cores = 2
)
</code></pre>

<hr>
<h2 id='fnets.var.internal'>internal function for <code>fnets.var</code></h2><span id='topic+fnets.var.internal'></span>

<h3>Description</h3>

<p>internal function for <code>fnets.var</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnets.var.internal(
  xx,
  acv,
  method = c("lasso", "ds"),
  lambda = NULL,
  var.order = 1,
  tuning.args = list(tuning = c("cv", "bic"), n.folds = 1, penalty = NULL, path.length =
    10),
  do.threshold = FALSE,
  n.iter = NULL,
  tol = 0,
  n.cores = 1
)
</code></pre>

<hr>
<h2 id='hl.factor.number'>Factor number estimator of Hallin and Liška (2007)</h2><span id='topic+hl.factor.number'></span>

<h3>Description</h3>

<p>Estimates the number of factors by minimising an information criterion over sub-samples of the data.
Currently the three information criteria proposed in Hallin and Liška (2007) (<code>ic.op = 1, 2</code> or <code>3</code>)
and their variations with logarithm taken on the cost (<code>ic.op = 4, 5</code> or <code>6</code>) are implemented,
with <code>ic.op = 5</code> recommended as a default choice based on numerical experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hl.factor.number(x, q.max = NULL, mm = NULL, center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hl.factor.number_+3A_x">x</code></td>
<td>
<p>input time series matrix, with each row representing a variable</p>
</td></tr>
<tr><td><code id="hl.factor.number_+3A_q.max">q.max</code></td>
<td>
<p>maximum number of factors; if <code>q.max = NULL</code>, a default value is selected as <code>min(50, floor(sqrt(min(dim(x)[2] - 1, dim(x)[1]))))</code></p>
</td></tr>
<tr><td><code id="hl.factor.number_+3A_mm">mm</code></td>
<td>
<p>a positive integer specifying the kernel bandwidth for dynamic PCA; by default, it is set to <code>floor(4 *(dim(x)[2]/log(dim(x)[2]))^(1/3)))</code></p>
</td></tr>
<tr><td><code id="hl.factor.number_+3A_center">center</code></td>
<td>
<p>whether to de-mean the input <code>x</code> row-wise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Hallin and Liška (2007) for further details.
</p>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>q.hat</code></td>
<td>
<p> a vector containing minimisers of the six information criteria</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hallin, M. &amp; Liška, R. (2007) Determining the number of factors in the general dynamic factor model. Journal of the American Statistical Association, 102(478), 603&ndash;617.
</p>

<hr>
<h2 id='idio.predict'>Forecasting idiosyncratic VAR process</h2><span id='topic+idio.predict'></span>

<h3>Description</h3>

<p>Produces forecasts of the idiosyncratic VAR process
for a given forecasting horizon by estimating the best linear predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idio.predict(object, x, cpre, n.ahead = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idio.predict_+3A_object">object</code></td>
<td>
<p><code>fnets</code> object</p>
</td></tr>
<tr><td><code id="idio.predict_+3A_x">x</code></td>
<td>
<p>input time series, with each row representing a variable</p>
</td></tr>
<tr><td><code id="idio.predict_+3A_cpre">cpre</code></td>
<td>
<p>output of <a href="#topic+common.predict">common.predict</a></p>
</td></tr>
<tr><td><code id="idio.predict_+3A_n.ahead">n.ahead</code></td>
<td>
<p>forecast horizon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>is</code></td>
<td>
<p> in-sample estimator of the idiosyncratic component (with each column representing a variable)</p>
</td></tr>
<tr><td><code>fc</code></td>
<td>
<p> forecasts of the idiosyncratic component for a given forecasting horizon <code>h</code> (with each column representing a variable)</p>
</td></tr>
<tr><td><code>n.ahead</code></td>
<td>
<p> forecast horizon</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out &lt;- fnets(data.unrestricted,
do.lrpc = FALSE, var.args = list(n.cores = 2))
cpre &lt;- common.predict(out)
ipre &lt;- idio.predict(out, cpre)

## End(Not run)
</code></pre>

<hr>
<h2 id='logfactorial'>logarithmic factorial of 'n'</h2><span id='topic+logfactorial'></span>

<h3>Description</h3>

<p>logarithmic factorial of 'n'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logfactorial(n)
</code></pre>

<hr>
<h2 id='network'>Convert networks into igraph objects</h2><span id='topic+network'></span>

<h3>Description</h3>

<p>Convert networks into igraph objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_+3A_object">object</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="network_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+network.fnets">network.fnets</a>
</p>

<hr>
<h2 id='network.fnets'>Convert networks estimated by fnets into igraph objects</h2><span id='topic+network.fnets'></span>

<h3>Description</h3>

<p>Converts S3 objects of class <code>fnets</code> into a network.
Produces an igraph object for the three networks underlying factor-adjusted VAR processes:
(i) directed network representing Granger causal linkages, as given by estimated VAR transition matrices summed across the lags,
(ii) undirected network representing contemporaneous linkages after accounting for lead-lag dependence, as given by partial correlations of VAR innovations,
(iii) undirected network summarising (i) and (ii) as given by long-run partial correlations of VAR processes.
When plotting the network, note that the edge weights may be negative since they correspond to the entries of the estimators of VAR parameters and (long-run) partial correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fnets'
network(
  object,
  type = c("granger", "pc", "lrpc"),
  names = NA,
  groups = NA,
  group.colours = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.fnets_+3A_object">object</code></td>
<td>
<p><code>fnets</code> object</p>
</td></tr>
<tr><td><code id="network.fnets_+3A_type">type</code></td>
<td>
<p>a string specifying which of the above three networks (i)&ndash;(iii) to visualise; possible values are
</p>

<dl>
<dt><code>"granger"</code></dt><dd><p> directed network representing Granger causal linkages</p>
</dd>
<dt><code>"pc"</code></dt><dd><p> undirected network representing contemporaneous linkages; available when <code>object$do.lrpc = TRUE</code></p>
</dd>
<dt><code>"lrpc"</code></dt><dd><p> undirected network summarising Granger causal and contemporaneous linkages; available when <code>x$do.lrpc = TRUE</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="network.fnets_+3A_names">names</code></td>
<td>
<p>a character vector containing the names of the vertices</p>
</td></tr>
<tr><td><code id="network.fnets_+3A_groups">groups</code></td>
<td>
<p>an integer vector denoting any group structure of the vertices</p>
</td></tr>
<tr><td><code id="network.fnets_+3A_group.colours">group.colours</code></td>
<td>
<p>a vector denoting colours corresponding to <code>groups</code></p>
</td></tr>
<tr><td><code id="network.fnets_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>igraph::graph_from_adjacency_matrix</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>network</code></td>
<td>
 <p><code>igraph</code> object</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p> input argument</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p> input argument</p>
</td></tr>
<tr><td><code>grp.col</code></td>
<td>
<p> vector of colours corresponding to each node</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> additional arguments to <code>igraph::graph_from_adjacency_matrix</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+fnets">fnets</a>, <a href="#topic+plot.fnets">plot.fnets</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
out &lt;- fnets(data.unrestricted,
  do.threshold = TRUE,
  var.args = list(n.cores = 2)
)
net &lt;- network(out, type = "granger")$network
plot(net, layout = igraph::layout_in_circle(net))
network(out, type = "pc")
network(out, type = "lrpc")

</code></pre>

<hr>
<h2 id='par.lrpc'>Parametric estimation of long-run partial correlations of factor-adjusted VAR processes</h2><span id='topic+par.lrpc'></span>

<h3>Description</h3>

<p>Returns a parametric estimate of long-run partial correlations of the VAR process
from the VAR parameter estimates and the inverse of innovation covariance matrix obtained via constrained <code>l1</code>-minimisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par.lrpc(
  object,
  eta = NULL,
  tuning.args = list(n.folds = 1, path.length = 10),
  lrpc.adaptive = FALSE,
  eta.adaptive = NULL,
  do.correct = TRUE,
  do.threshold = FALSE,
  n.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par.lrpc_+3A_object">object</code></td>
<td>
<p><code>fnets</code> object</p>
</td></tr>
<tr><td><code id="par.lrpc_+3A_eta">eta</code></td>
<td>
<p><code>l1</code>-regularisation parameter; if <code>eta = NULL</code>, it is selected by cross validation</p>
</td></tr>
<tr><td><code id="par.lrpc_+3A_tuning.args">tuning.args</code></td>
<td>
<p>a list specifying arguments for the cross validation procedure
for selecting the tuning parameter involved in long-run partial correlation matrix estimation. It contains:
</p>

<dl>
<dt><code>n.folds</code></dt><dd><p> positive integer number of folds</p>
</dd>
<dt><code>path.length</code></dt><dd><p> positive integer number of regularisation parameter values to consider; a sequence is generated automatically based in this value</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="par.lrpc_+3A_lrpc.adaptive">lrpc.adaptive</code></td>
<td>
<p>whether to use the adaptive estimation procedure</p>
</td></tr>
<tr><td><code id="par.lrpc_+3A_eta.adaptive">eta.adaptive</code></td>
<td>
<p><code>l1</code>-regularisation parameter for Step 1 of the adaptive estimation procedure; if <code>eta.adaptive = NULL</code>, the default choice is <code>2 * sqrt(log(dim(x)[1])/dim(x)[2])</code></p>
</td></tr>
<tr><td><code id="par.lrpc_+3A_do.correct">do.correct</code></td>
<td>
<p>whether to correct for any negative entries in the diagonals of the inverse of long-run covariance matrix</p>
</td></tr>
<tr><td><code id="par.lrpc_+3A_do.threshold">do.threshold</code></td>
<td>
<p>whether to perform adaptive thresholding of <code>Delta</code> and <code>Omega</code> parameter estimators with <a href="#topic+threshold">threshold</a></p>
</td></tr>
<tr><td><code id="par.lrpc_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use for parallel computing, see <a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Barigozzi, Cho and Owens (2024+) for further details, and Cai, Liu and Zhou (2016) for further details on the adaptive estimation procedure.
</p>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>Delta</code></td>
<td>
<p> estimated inverse of the innovation covariance matrix</p>
</td></tr>
<tr><td><code>Omega</code></td>
<td>
<p> estimated inverse of the long-run covariance matrix</p>
</td></tr>
<tr><td><code>pc</code></td>
<td>
<p> estimated innovation partial correlation matrix</p>
</td></tr>
<tr><td><code>lrpc</code></td>
<td>
<p> estimated long-run partial correlation matrix</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
 <p><code>l1</code>-regularisation parameter</p>
</td></tr>
<tr><td><code>lrpc.adaptive</code></td>
<td>
<p> input argument </p>
</td></tr>
</table>


<h3>References</h3>

<p>Barigozzi, M., Cho, H. &amp; Owens, D. (2024+) FNETS: Factor-adjusted network estimation and forecasting for high-dimensional time series. Journal of Business &amp; Economic Statistics (to appear).
</p>
<p>Cai, T. T., Liu, W., &amp; Zhou, H. H. (2016) Estimating sparse precision matrix: Optimal rates of convergence and adaptive estimation. The Annals of Statistics, 44(2), 455-488.
</p>
<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
out &lt;- fnets(data.unrestricted, do.lrpc = FALSE, var.args = list(n.cores = 2))
plrpc &lt;- par.lrpc(out, n.cores = 2)
out$lrpc &lt;- plrpc
out$do.lrpc &lt;- TRUE
plot(out, type = "pc", display = "network")
plot(out, type = "lrpc", display = "heatmap")

</code></pre>

<hr>
<h2 id='plot_internal'>internal function for <code>plot.fnets</code> and <code>network</code></h2><span id='topic+plot_internal'></span>

<h3>Description</h3>

<p>internal function for <code>plot.fnets</code> and <code>network</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_internal(
  x,
  type = c("granger", "pc", "lrpc"),
  display = c("network", "heatmap"),
  names = NA,
  groups = NA,
  group.colours = NA,
  ...
)
</code></pre>

<hr>
<h2 id='plot.factor.number'>Plot factor number</h2><span id='topic+plot.factor.number'></span>

<h3>Description</h3>

<p>Plots the eigenvalue ratio or information criteria from a <code>factor.number</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factor.number'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.factor.number_+3A_x">x</code></td>
<td>
<p><code>factor.number</code> object</p>
</td></tr>
<tr><td><code id="plot.factor.number_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, printed to console
</p>


<h3>See Also</h3>

<p><a href="#topic+factor.number">factor.number</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fnets)
## Alessi, Barigozzi, and Capasso method for restricted models
abc &lt;- factor.number(data.restricted, fm.restricted = TRUE)
print(abc)
plot(abc)

## Eigenvalue ratio method
er &lt;- factor.number(data.restricted, method = "er", fm.restricted = TRUE)
print(er)
plot(er)

## Hallin and Liška method for unrestricted models
hl &lt;- factor.number(data.unrestricted, fm.restricted = FALSE)
print(hl)
plot(hl)
</code></pre>

<hr>
<h2 id='plot.fnets'>Plotting the networks estimated by fnets</h2><span id='topic+plot.fnets'></span>

<h3>Description</h3>

<p>Plotting method for S3 objects of class <code>fnets</code>.
When <code>display = "network"</code> or <code>display = "heatmap"</code>, it produces a plot visualising three networks underlying factor-adjusted VAR processes:
(i) directed network representing Granger causal linkages, as given by estimated VAR transition matrices summed across the lags,
(ii) undirected network representing contemporaneous linkages after accounting for lead-lag dependence, as given by partial correlations of VAR innovations,
(iii) undirected network summarising (i) and (ii) as given by long-run partial correlations of VAR processes.
Edge widths are determined by edge weights.
When <code>display = "tuning"</code>, it produces up to two plots (when <code>do.larpc = TRUE</code>) visualising
the outcome of CV or IC adopted for selecting the <code>l1</code>-regularisation parameters and the VAR order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fnets'
plot(
  x,
  type = c("granger", "pc", "lrpc"),
  display = c("network", "heatmap", "tuning"),
  names = NA,
  groups = NA,
  group.colours = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fnets_+3A_x">x</code></td>
<td>
<p><code>fnets</code> object</p>
</td></tr>
<tr><td><code id="plot.fnets_+3A_type">type</code></td>
<td>
<p>a string specifying which of the above three networks (i)&ndash;(iii) to visualise
when <code>display = "network"</code> or <code>display = "heatmap"</code>; possible values are
</p>

<dl>
<dt><code>"granger"</code></dt><dd><p> directed network representing Granger causal linkages</p>
</dd>
<dt><code>"pc"</code></dt><dd><p> undirected network representing contemporaneous linkages; available when <code>x$do.lrpc = TRUE</code></p>
</dd>
<dt><code>"lrpc"</code></dt><dd><p> undirected network summarising Granger causal and contemporaneous linkages; available when <code>x$do.lrpc = TRUE</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.fnets_+3A_display">display</code></td>
<td>
<p>a string specifying which plot to produce; possible values are
</p>

<dl>
<dt><code>"network"</code></dt><dd><p> visualise the network as an <code>igraph</code> object, see <a href="igraph.html#topic+plot.igraph">plot.igraph</a></p>
</dd>
<dt><code>"heatmap"</code></dt><dd><p> visualise the network as a heatmap, see <a href="fields.html#topic+imagePlot">imagePlot</a></p>
</dd>
<dt><code>"tuning"</code></dt><dd><p> visualise the outcome from CV or IC (specified by <code>tuning.args$tuning</code> of <a href="#topic+fnets">fnets</a>)
for selecting <code>l1</code>-regularisation parameters and the VAR order</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.fnets_+3A_names">names</code></td>
<td>
<p>a character vector containing the names of the network vertices</p>
</td></tr>
<tr><td><code id="plot.fnets_+3A_groups">groups</code></td>
<td>
<p>an integer vector denoting any group structure of the network vertices</p>
</td></tr>
<tr><td><code id="plot.fnets_+3A_group.colours">group.colours</code></td>
<td>
<p>a vector denoting colours corresponding to <code>groups</code></p>
</td></tr>
<tr><td><code id="plot.fnets_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot produced as per the input arguments
</p>


<h3>See Also</h3>

<p><a href="#topic+fnets">fnets</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
out &lt;- fnets(data.unrestricted,
  do.threshold = TRUE,
  var.args = list(n.cores = 2)
)
plot(out, type = "granger", display = "network",
groups = rep(c(1,2), 50/2), group.colours = c("orange","blue"))
plot(out, type = "lrpc", display = "heatmap")
plot(out, display = "tuning")

</code></pre>

<hr>
<h2 id='plot.threshold'>Plotting the thresholding procedure</h2><span id='topic+plot.threshold'></span>

<h3>Description</h3>

<p>Plotting method for S3 objects of class <code>threshold</code>.
Produces a plot visualising three diagnostics for the thresholding procedure, with threshold values t_k (x axis) against
(i) Ratio_k, the ratio of the number of non-zero to zero entries in the matrix, as the threshold varies
(ii) Diff_k, the first difference of <code>Ratio_k</code>
(iii) |CUSUM_k|, the absolute scaled cumulative sums of <code>Diff_k</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'threshold'
plot(x, plots = c(TRUE, FALSE, TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.threshold_+3A_x">x</code></td>
<td>
<p><code>threshold</code> object</p>
</td></tr>
<tr><td><code id="plot.threshold_+3A_plots">plots</code></td>
<td>
<p>logical vector, which plots to use (Ratio, Diff, CUSUM respectively)</p>
</td></tr>
<tr><td><code id="plot.threshold_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Owens, Cho and Barigozzi (2024+) for further details.
</p>


<h3>Value</h3>

<p>A network plot produced as per the input arguments
</p>


<h3>References</h3>

<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>See Also</h3>

<p><a href="#topic+threshold">threshold</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fnets)
out &lt;- fnets(data.unrestricted,
   var.args = list(n.cores = 2)
)
# Granger-causal network
th1 &lt;- threshold(out$idio.var$beta)
plot(th1)
print(th1)
# Partial correlations
th2 &lt;- threshold(out$lrpc$pc)
# Long-run partial correlations
th3 &lt;- threshold(out$lrpc$lrpc)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.fm'>Forecasting for factor models</h2><span id='topic+predict.fm'></span>

<h3>Description</h3>

<p>Produces forecasts of the data input to <code>object</code> for a given forecasting horizon by
estimating the best linear predictors of the common component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm'
predict(object, n.ahead = 1, fc.restricted = TRUE, r = c("ic", "er"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fm_+3A_object">object</code></td>
<td>
<p><code>fm</code> object</p>
</td></tr>
<tr><td><code id="predict.fm_+3A_n.ahead">n.ahead</code></td>
<td>
<p>forecasting horizon</p>
</td></tr>
<tr><td><code id="predict.fm_+3A_fc.restricted">fc.restricted</code></td>
<td>
<p>if <code>fc.restricted = TRUE</code>, the forecast is generated under a restricted factor model</p>
</td></tr>
<tr><td><code id="predict.fm_+3A_r">r</code></td>
<td>
<p>number of static factors, or a string specifying the factor number selection method when <code>fc.restricted = TRUE</code>;
possible values are:
</p>

<dl>
<dt><code>"ic"</code></dt><dd><p> information criteria of Alessi, Barigozzi &amp; Capasso (2010)</p>
</dd>
<dt><code>"er"</code></dt><dd><p> eigenvalue ratio of Ahn &amp; Horenstein (2013) </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="predict.fm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>is</code></td>
<td>
<p> in-sample predictions</p>
</td></tr>
<tr><td><code>forecast</code></td>
<td>
<p> forecasts for the given forecasting horizon</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p> factor number</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+fnets.factor.model">fnets.factor.model</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- fnets.factor.model(data.restricted, fm.restricted = TRUE)
pre &lt;- predict(out)
</code></pre>

<hr>
<h2 id='predict.fnets'>Forecasting by fnets</h2><span id='topic+predict.fnets'></span>

<h3>Description</h3>

<p>Produces forecasts of the data for a given forecasting horizon by
separately estimating the best linear predictors of common and idiosyncratic components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fnets'
predict(
  object,
  newdata = NULL,
  n.ahead = 1,
  fc.restricted = TRUE,
  r = c("ic", "er"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fnets_+3A_object">object</code></td>
<td>
<p><code>fnets</code> object</p>
</td></tr>
<tr><td><code id="predict.fnets_+3A_newdata">newdata</code></td>
<td>
<p>input time series matrix; by default, uses input to <code>object</code>.
Valid only for the case where <code>newdata</code> is modelled as a VAR process without any factors</p>
</td></tr>
<tr><td><code id="predict.fnets_+3A_n.ahead">n.ahead</code></td>
<td>
<p>forecasting horizon</p>
</td></tr>
<tr><td><code id="predict.fnets_+3A_fc.restricted">fc.restricted</code></td>
<td>
<p>whether to forecast using a restricted or unrestricted, blockwise VAR representation of the common component</p>
</td></tr>
<tr><td><code id="predict.fnets_+3A_r">r</code></td>
<td>
<p>number of static factors, or a string specifying the factor number selection method when <code>fc.restricted = TRUE</code>;
possible values are:
</p>

<dl>
<dt><code>"ic"</code></dt><dd><p> information criteria of Alessi, Barigozzi &amp; Capasso (2010)</p>
</dd>
<dt><code>"er"</code></dt><dd><p> eigenvalue ratio of Ahn &amp; Horenstein (2013)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="predict.fnets_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>forecast</code></td>
<td>
<p> forecasts for the given forecasting horizon</p>
</td></tr>
<tr><td><code>common.pred</code></td>
<td>
<p> a list containing forecasting results for the common component</p>
</td></tr>
<tr><td><code>idio.pred</code></td>
<td>
<p> a list containing forecasting results for the idiosyncratic component</p>
</td></tr>
<tr><td><code>mean.x</code></td>
<td>
 <p><code>mean.x</code> argument from <code>object</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+fnets">fnets</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- fnets(data.restricted, q = 2, do.lrpc = FALSE, var.args = list(n.cores = 2))
pre.unr &lt;- predict(out, fc.restricted = FALSE)
pre.res &lt;- predict(out, fc.restricted = TRUE)
</code></pre>

<hr>
<h2 id='print.factor.number'>Print factor number</h2><span id='topic+print.factor.number'></span>

<h3>Description</h3>

<p>Prints a summary of a <code>factor.number</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factor.number'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.factor.number_+3A_x">x</code></td>
<td>
<p><code>factor.number</code> object</p>
</td></tr>
<tr><td><code id="print.factor.number_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, printed to console
</p>


<h3>See Also</h3>

<p><a href="#topic+factor.number">factor.number</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fnets)
## Alessi, Barigozzi, and Capasso method for restricted models
abc &lt;- factor.number(data.restricted, fm.restricted = TRUE)
print(abc)
plot(abc)

## Eigenvalue ratio method
er &lt;- factor.number(data.restricted, method = "er", fm.restricted = TRUE)
print(er)
plot(er)

## Hallin and Liška method for unrestricted models
hl &lt;- factor.number(data.unrestricted, fm.restricted = FALSE)
print(hl)
plot(hl)
</code></pre>

<hr>
<h2 id='print.fm'>Print factor model</h2><span id='topic+print.fm'></span>

<h3>Description</h3>

<p>Prints a summary of a <code>fm</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fm_+3A_x">x</code></td>
<td>
<p><code>fm</code> object</p>
</td></tr>
<tr><td><code id="print.fm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, printed to console
</p>


<h3>See Also</h3>

<p><a href="#topic+fnets.factor.model">fnets.factor.model</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- fnets.factor.model(data.restricted, q = "ic")
print(out)
</code></pre>

<hr>
<h2 id='print.fnets'>Print fnets</h2><span id='topic+print.fnets'></span>

<h3>Description</h3>

<p>Prints a summary of a <code>fnets</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fnets'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fnets_+3A_x">x</code></td>
<td>
<p><code>fnets</code> object</p>
</td></tr>
<tr><td><code id="print.fnets_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, printed to console
</p>


<h3>See Also</h3>

<p><a href="#topic+fnets">fnets</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
out &lt;- fnets(data.restricted, q = 2,
do.lrpc = FALSE, var.args = list(n.cores = 2))
print(out)
x &lt;- sim.var(500, 50)$data
out &lt;- fnets.var(x,
n.cores = 2)
print(out)

</code></pre>

<hr>
<h2 id='print.threshold'>Print threshold</h2><span id='topic+print.threshold'></span>

<h3>Description</h3>

<p>Prints a summary of a <code>threshold</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'threshold'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.threshold_+3A_x">x</code></td>
<td>
<p><code>threshold</code> object</p>
</td></tr>
<tr><td><code id="print.threshold_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, printed to console
</p>


<h3>See Also</h3>

<p><a href="#topic+threshold">threshold</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fnets)
out &lt;- fnets(data.unrestricted,
   var.args = list(n.cores = 2)
)
# Granger-causal network
th1 &lt;- threshold(out$idio.var$beta)
plot(th1)
print(th1)
# Partial correlations
th2 &lt;- threshold(out$lrpc$pc)
# Long-run partial correlations
th3 &lt;- threshold(out$lrpc$lrpc)

## End(Not run)
</code></pre>

<hr>
<h2 id='sim.restricted'>Simulate data from a restricted factor model</h2><span id='topic+sim.restricted'></span>

<h3>Description</h3>

<p>Simulate the common component following an unrestricted factor model that admits a restricted representation;
see the model (C2) in the reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.restricted(n, p, q = 2, heavy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.restricted_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="sim.restricted_+3A_p">p</code></td>
<td>
<p>dimension</p>
</td></tr>
<tr><td><code id="sim.restricted_+3A_q">q</code></td>
<td>
<p>number of unrestricted factors; number of restricted factors is given by <code>2 * q</code></p>
</td></tr>
<tr><td><code id="sim.restricted_+3A_heavy">heavy</code></td>
<td>
<p>if <code>heavy = FALSE</code>, common shocks are generated from <code>rnorm</code> whereas if <code>heavy = TRUE</code>, from <code>rt</code> with <code>df = 5</code> and then scaled by <code>sqrt(3 / 5)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>data</code></td>
<td>
 <p><code>ts</code> object with <code>n</code> rows and <code>p</code> columns </p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p> number of factors</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p> number of restricted factors</p>
</td></tr>
</table>


<h3>References</h3>

<p>Barigozzi, M., Cho, H. &amp; Owens, D. (2024+) FNETS: Factor-adjusted network estimation and forecasting for high-dimensional time series. Journal of Business &amp; Economic Statistics (to appear).
</p>
<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>common &lt;- sim.restricted(500, 50)
</code></pre>

<hr>
<h2 id='sim.unrestricted'>Simulate data from an unrestricted factor model</h2><span id='topic+sim.unrestricted'></span>

<h3>Description</h3>

<p>Simulate the common component following an unrestricted factor model that does not admit a restricted representation;
see the model (C1) in Barigozzi, Cho and Owens (2024+)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.unrestricted(n, p, q = 2, heavy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.unrestricted_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="sim.unrestricted_+3A_p">p</code></td>
<td>
<p>dimension</p>
</td></tr>
<tr><td><code id="sim.unrestricted_+3A_q">q</code></td>
<td>
<p>number of unrestricted factors</p>
</td></tr>
<tr><td><code id="sim.unrestricted_+3A_heavy">heavy</code></td>
<td>
<p>if <code>heavy = FALSE</code>, common shocks are generated from <code>rnorm</code> whereas if <code>heavy = TRUE</code>, from <code>rt</code> with <code>df = 5</code> and then scaled by <code>sqrt(3 / 5)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>data</code></td>
<td>
 <p><code>ts</code> object with <code>n</code> rows and <code>p</code> columns </p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p> number of factors</p>
</td></tr>
</table>


<h3>References</h3>

<p>Barigozzi, M., Cho, H. &amp; Owens, D. (2024+) FNETS: Factor-adjusted network estimation and forecasting for high-dimensional time series. Journal of Business &amp; Economic Statistics (to appear).
</p>
<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>common &lt;- sim.unrestricted(500, 50)
</code></pre>

<hr>
<h2 id='sim.var'>Simulate a VAR(1) process</h2><span id='topic+sim.var'></span>

<h3>Description</h3>

<p>Simulate a VAR(1) process; see the reference for the generation of the transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.var(n, p, Gamma = diag(1, p), heavy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.var_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="sim.var_+3A_p">p</code></td>
<td>
<p>dimension</p>
</td></tr>
<tr><td><code id="sim.var_+3A_gamma">Gamma</code></td>
<td>
<p>innovation covariance matrix; ignored if <code>heavy = TRUE</code></p>
</td></tr>
<tr><td><code id="sim.var_+3A_heavy">heavy</code></td>
<td>
<p>if <code>heavy = FALSE</code>, common shocks are generated from <code>rnorm</code> whereas if <code>heavy = TRUE</code>, from <code>rt</code> with <code>df = 5</code> and then scaled by <code>sqrt(3 / 5)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>data</code></td>
<td>
 <p><code>ts</code> object with <code>n</code> rows and <code>p</code> columns </p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p> transition matrix</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p> innovation covariance matrix</p>
</td></tr>
</table>


<h3>References</h3>

<p>Barigozzi, M., Cho, H. &amp; Owens, D. (2024+) FNETS: Factor-adjusted network estimation and forecasting for high-dimensional time series. Journal of Business &amp; Economic Statistics (to appear).
</p>
<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>idio &lt;- sim.var(500, 50)
</code></pre>

<hr>
<h2 id='static.pca'>Static PCA</h2><span id='topic+static.pca'></span>

<h3>Description</h3>

<p>Static PCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>static.pca(
  xx,
  q = NULL,
  q.method = c("ic", "er"),
  q.max = NULL,
  ic.op = 2,
  mm = NULL
)
</code></pre>

<hr>
<h2 id='threshold'>Threshold the entries of the input matrix at a data-driven level</h2><span id='topic+threshold'></span>

<h3>Description</h3>

<p>Threshold the entries of the input matrix at a data-driven level.
This can be used to perform edge selection for VAR parameter, inverse innovation covariance, and long-run partial correlation networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(mat, path.length = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_+3A_mat">mat</code></td>
<td>
<p>input parameter matrix</p>
</td></tr>
<tr><td><code id="threshold_+3A_path.length">path.length</code></td>
<td>
<p>number of candidate thresholds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Owens, Cho &amp; Barigozzi (2024+) for more information on the threshold selection process
</p>


<h3>Value</h3>

<p>an S3 object of class <code>threshold</code>, which contains the following fields:
</p>
<table>
<tr><td><code>threshold</code></td>
<td>
<p> data-driven threshold</p>
</td></tr>
<tr><td><code>thr.mat</code></td>
<td>
<p> thresholded input matrix</p>
</td></tr>
</table>


<h3>References</h3>

<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.threshold">plot.threshold</a>, <a href="#topic+print.threshold">print.threshold</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(fnets)
out &lt;- fnets(data.unrestricted,
   var.args = list(n.cores = 2)
)
# Granger-causal network
th1 &lt;- threshold(out$idio.var$beta)
plot(th1)
print(th1)
# Partial correlations
th2 &lt;- threshold(out$lrpc$pc)
# Long-run partial correlations
th3 &lt;- threshold(out$lrpc$lrpc)

## End(Not run)
</code></pre>

<hr>
<h2 id='tuning_plot'>Plotting output for tuning parameter selection in fnets</h2><span id='topic+tuning_plot'></span>

<h3>Description</h3>

<p>Tuning plots for S3 objects of class <code>fnets</code>.
Produces up to two plots visualising CV and IC procedures for selecting tuning parameters and the VAR order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuning_plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tuning_plot_+3A_x">x</code></td>
<td>
<p><code>fnets</code> object</p>
</td></tr>
<tr><td><code id="tuning_plot_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Owens, Cho and Barigozzi (2024+) for further details.
</p>


<h3>Value</h3>

<p>CV/IC plot for the VAR component, and CV plot for the lrpc component (when <code>x$do.lrpc = TRUE</code>).
</p>


<h3>References</h3>

<p>Owens, D., Cho, H. &amp; Barigozzi, M. (2024+) fnets: An R Package for Network Estimation and Forecasting via Factor-Adjusted VAR Modelling. The R Journal (to appear).
</p>


<h3>See Also</h3>

<p><a href="#topic+fnets">fnets</a>
</p>

<hr>
<h2 id='var.dantzig'>Dantzig selector-type estimator of VAR processes via constrained <code>l1</code>-minimisation</h2><span id='topic+var.dantzig'></span>

<h3>Description</h3>

<p>Dantzig selector-type estimator of VAR processes via constrained <code>l1</code>-minimisation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.dantzig(GG, gg, lambda, symmetric = "min", n.cores = 1)
</code></pre>

<hr>
<h2 id='var.lasso'>Lasso-type estimator of VAR processes via <code>l1</code>-regularised <code>M</code>-estimation</h2><span id='topic+var.lasso'></span>

<h3>Description</h3>

<p>Lasso-type estimator of VAR processes via <code>l1</code>-regularised <code>M</code>-estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.lasso(GG, gg, lambda, symmetric = "min", n.iter = 100, tol = 0)
</code></pre>

<hr>
<h2 id='yw.cv'>Cross validation for factor-adjusted VAR estimation</h2><span id='topic+yw.cv'></span>

<h3>Description</h3>

<p>Cross validation for factor-adjusted VAR estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yw.cv(
  xx,
  method = c("lasso", "ds"),
  lambda.max = NULL,
  var.order = 1,
  n.folds = 1,
  path.length = 10,
  q = 0,
  kern.bw = NULL,
  n.cores = 1
)
</code></pre>

<hr>
<h2 id='yw.ic'>Information criterion for factor-adjusted VAR estimation</h2><span id='topic+yw.ic'></span>

<h3>Description</h3>

<p>Information criterion for factor-adjusted VAR estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yw.ic(
  xx,
  method = c("lasso", "ds"),
  lambda.max = NULL,
  var.order = 1,
  penalty = NULL,
  path.length = 10,
  q = 0,
  kern.bw = NULL
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
