<!DOCTYPE html><html><head><title>Help for package tabr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tabr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#append_phrases'><p>Concatenate and repeat</p></a></li>
<li><a href='#articulations'><p>Single note articulations and syntax</p></a></li>
<li><a href='#as_music_df'><p>Noteworthy string to data frame</p></a></li>
<li><a href='#chord_arpeggiate'><p>Arpeggiate a chord</p></a></li>
<li><a href='#chord_break'><p>Broken chords</p></a></li>
<li><a href='#chord_def'><p>Define chords</p></a></li>
<li><a href='#chord_invert'><p>Chord inversion</p></a></li>
<li><a href='#chord_is_major'><p>Check if chords are major or minor</p></a></li>
<li><a href='#chord_set'><p>Generate a chord set</p></a></li>
<li><a href='#chord-compare'><p>Rank, order and sort chords and notes</p></a></li>
<li><a href='#chord-filter'><p>Extract notes from chords</p></a></li>
<li><a href='#chord-mapping'><p>Chord mapping</p></a></li>
<li><a href='#chords'><p>Chord constructors</p></a></li>
<li><a href='#double-bracket'><p>Double bracket methods for tabr classes</p></a></li>
<li><a href='#dyad'><p>Construct a dyad</p></a></li>
<li><a href='#freq_ratio'><p>Frequency ratios</p></a></li>
<li><a href='#guitarChords'><p>Predefined guitar chords</p></a></li>
<li><a href='#hp'><p>Hammer ons and pull offs</p></a></li>
<li><a href='#interval_semitones'><p>Interval semitones</p></a></li>
<li><a href='#intervals'><p>Interval helpers</p></a></li>
<li><a href='#is_diatonic'><p>Check if notes and chords are diatonic</p></a></li>
<li><a href='#keys'><p>Key signatures</p></a></li>
<li><a href='#lilypond'><p>Save score to LilyPond file</p></a></li>
<li><a href='#lilypond_root'><p>LilyPond installation information</p></a></li>
<li><a href='#lp_chord_id'><p>LilyPond chord notation</p></a></li>
<li><a href='#lyrics'><p>Create lyrics and check lyrics string validity</p></a></li>
<li><a href='#mainIntervals'><p>Main musical intervals</p></a></li>
<li><a href='#midily'><p>Convert MIDI to LilyPond file</p></a></li>
<li><a href='#miditab'><p>Convert MIDI to tablature</p></a></li>
<li><a href='#mode-helpers'><p>Mode helpers</p></a></li>
<li><a href='#music'><p>Create music objects and check music string validity</p></a></li>
<li><a href='#music-helpers'><p>Accessing music object values and attributes</p></a></li>
<li><a href='#n_measures'><p>Summarize rhythm and time of music objects</p></a></li>
<li><a href='#notate'><p>Add text to music staff</p></a></li>
<li><a href='#note_ngram'><p>Note/chord n-gram</p></a></li>
<li><a href='#note_slice'><p>Slice, sort, rotate, shift and arpeggiate notes</p></a></li>
<li><a href='#note-checks'><p>Basic noteworthy string checks</p></a></li>
<li><a href='#note-coerce'><p>Basic noteworthy strings formatting and coercion helpers</p></a></li>
<li><a href='#note-equivalence'><p>Note, pitch and chord equivalence</p></a></li>
<li><a href='#note-logic'><p>Relational operators for noteworthy class</p></a></li>
<li><a href='#note-metadata'><p>Noteworthy string metadata</p></a></li>
<li><a href='#note-summaries'><p>Noteworthy string summaries</p></a></li>
<li><a href='#noteinfo'><p>Note info helpers</p></a></li>
<li><a href='#phrase'><p>Create a musical phrase</p></a></li>
<li><a href='#phrase-checks'><p>Phrase validation and coercion</p></a></li>
<li><a href='#pitch_freq'><p>Pitch conversions</p></a></li>
<li><a href='#pitch_seq'><p>Create a sequence from pitch notation</p></a></li>
<li><a href='#plot_fretboard'><p>Chord and fretboard diagram plots</p></a></li>
<li><a href='#plot_music'><p>Plot sheet music snippet with LilyPond</p></a></li>
<li><a href='#ratio_to_cents'><p>Convert between chord frequency ratios and cents</p></a></li>
<li><a href='#read_midi'><p>Read, inspect and convert MIDI file contents</p></a></li>
<li><a href='#render_chordchart'><p>Render a chord chart with LilyPond</p></a></li>
<li><a href='#render_music'><p>Render sheet music snippet with LilyPond</p></a></li>
<li><a href='#repeats'><p>Repeat phrases</p></a></li>
<li><a href='#rest'><p>Create rests</p></a></li>
<li><a href='#scale_chords'><p>Diatonic chords</p></a></li>
<li><a href='#scale-deg'><p>Scale degrees and mappings</p></a></li>
<li><a href='#scale-helpers'><p>Scale helpers</p></a></li>
<li><a href='#score'><p>Create a music score</p></a></li>
<li><a href='#sf_phrase'><p>Create a musical phrase from string/fret combinations</p></a></li>
<li><a href='#simplify_phrase'><p>Simplify the LilyPond syntax of a phrase</p></a></li>
<li><a href='#single-bracket'><p>Single bracket methods for tabr classes</p></a></li>
<li><a href='#string_unfold'><p>Fold and unfold strings</p></a></li>
<li><a href='#tab'><p>Render sheet music with LilyPond</p></a></li>
<li><a href='#tabr'><p>tabr: Music notation syntax, manipulation, analysis and transcription in R.</p></a></li>
<li><a href='#tabr_options'><p>Options</p></a></li>
<li><a href='#tabr-c'><p>Concatenate for tabr classes</p></a></li>
<li><a href='#tabr-head'><p>Head and tail for tabr classes</p></a></li>
<li><a href='#tabr-length'><p>Length for tabr classes</p></a></li>
<li><a href='#tabr-methods'><p>Summary of implemented S3 generic methods</p></a></li>
<li><a href='#tabr-rep'><p>Repeat for tabr classes</p></a></li>
<li><a href='#tabr-rev'><p>Reverse for tabr classes</p></a></li>
<li><a href='#tabrSyntax'><p>tabr syntax</p></a></li>
<li><a href='#tie'><p>Tied notes</p></a></li>
<li><a href='#to_tabr'><p>Music notation syntax converters</p></a></li>
<li><a href='#track'><p>Create a music track</p></a></li>
<li><a href='#trackbind'><p>Bind track tables</p></a></li>
<li><a href='#transpose'><p>Transpose pitch</p></a></li>
<li><a href='#tunings'><p>Predefined instrument tunings</p></a></li>
<li><a href='#tuplet'><p>Tuplets</p></a></li>
<li><a href='#valid-noteinfo'><p>Check note info validity</p></a></li>
<li><a href='#valid-notes'><p>Check note and chord validity</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Music Notation Syntax, Manipulation, Analysis and Transcription
in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.9</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a music notation syntax and a collection of music 
    programming functions for generating, manipulating, organizing, and analyzing 
    musical information in R. Music syntax can be entered directly in character 
    strings, for example to quickly transcribe short pieces of music. The 
    package contains functions for directly performing various mathematical, 
    logical and organizational operations and musical transformations on special 
    object classes that facilitate working with music data and notation. The 
    same music data can be organized in tidy data frames for a familiar and 
    powerful approach to the analysis of large amounts of structured music data. 
    Functions are available for mapping seamlessly between these formats and 
    their representations of musical information. The package also provides an 
    API to 'LilyPond' (<a href="https://lilypond.org/">https://lilypond.org/</a>) for transcribing musical 
    representations in R into tablature ("tabs") and sheet music. 'LilyPond' is 
    open source music engraving software for generating high quality sheet music 
    based on markup syntax. The package generates 'LilyPond' files from R code 
    and can pass them to the 'LilyPond' command line interface to be rendered 
    into sheet music PDF files or inserted into R markdown documents. The 
    package offers nominal MIDI file output support in conjunction with
    rendering sheet music. The package can read MIDI files and attempts to
    structure the MIDI data to integrate as best as possible with the data
    structures and functionality found throughout the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/leonawicz/tabr">https://github.com/leonawicz/tabr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/leonawicz/tabr/issues">https://github.com/leonawicz/tabr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>crayon, dplyr, ggplot2, purrr, tibble, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fansi, gridExtra, htmltools, kableExtra, knitr, png,
rmarkdown, testthat, tuneR</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>LilyPond v2.22.1-2+ (needed for rendering sheet
music or writing MIDI files)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-21 13:45:07 UTC; Matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Leonawicz <a href="https://orcid.org/0000-0001-9452-2771"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Leonawicz &lt;mfleonawicz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-21 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='append_phrases'>Concatenate and repeat</h2><span id='topic+append_phrases'></span><span id='topic+pc'></span><span id='topic+pn'></span>

<h3>Description</h3>

<p>Helper functions for concatenating musical phrases and raw strings
together as well as repetition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc(...)

pn(x, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_phrases_+3A_...">...</code></td>
<td>
<p>character, phrase or non-phrase string.</p>
</td></tr>
<tr><td><code id="append_phrases_+3A_x">x</code></td>
<td>
<p>character, phrase or non-phrase string.</p>
</td></tr>
<tr><td><code id="append_phrases_+3A_n">n</code></td>
<td>
<p>integer, number of repetitions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: When working with special <code>tabr</code> classes, you can simply use generics
like <code>c()</code> and <code>rep()</code> as many custom methods exist for these classes. The
additional respective helper functions, <code>pc()</code> and <code>pn()</code>, are more
specifically for phrase objects and when you are still working with character
strings, yet to be converted to a phrase object (numbers not yet in string
form are allowed). See examples.
</p>
<p>The functions <code>pc()</code> and <code>pn()</code> are based on base functions <code>paste()</code> and
<code>rep()</code>, respectively, but are tailored for efficiency in creating musical
phrases.
</p>
<p>These functions respect and retain the phrase class when applied to phrases.
They are aggressive for phrases and secondarily for noteworthy strings.
Combining a phrase with a non-phrase string will assume compatibility and
result in a new phrase object.
If no phrase objects are present, the presence of any noteworthy string will
in turn attempt to force conversion of all strings to noteworthy strings.
The aggressiveness provides convenience, but is counter to expected coercion
rules. It is up to the user to ensure all inputs can be forced into the more
specific child class.
</p>
<p>This is especially useful for repeated instances. This function applies to
general slur notation as well.
Multiple input formats are allowed. Total number of note durations must be
even because all slurs require start and stop points.
</p>


<h3>Value</h3>

<p>phrase on non-phrase character string, noteworthy string if
applicable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pc(8, "16-", "8^")
pn(1, 2)
x &lt;- phrase("c ec'g' ec'g'", "4 4 2", "5 432 432")
y &lt;- phrase("a", 1, 5)
pc(x, y)
pc(x, pn(y, 2))
pc(x, "r1") # add a simple rest instance
class(pc(x, y))
class(pn(y, 2))
class(pc(x, "r1"))
class(pn("r1", 2))
class(pc("r1", "r4"))
</code></pre>

<hr>
<h2 id='articulations'>Single note articulations and syntax</h2><span id='topic+articulations'></span>

<h3>Description</h3>

<p>A data frame containing categorized sets of articulations that can be used
in phrase construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>articulations
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 column and 44 rows.
</p>

<hr>
<h2 id='as_music_df'>Noteworthy string to data frame</h2><span id='topic+as_music_df'></span>

<h3>Description</h3>

<p>Convert a noteworthy string to a tibble data frame and include additional
derivative variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_music_df(
  notes,
  info = NULL,
  key = NULL,
  scale = "diatonic",
  chords = c("root", "list", "character"),
  si_format = c("mmp_abb", "mmp", "ad_abb", "ad")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_music_df_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string. Alternatively, a music object
or a phrase object, in which case <code>info</code> is ignored.</p>
</td></tr>
<tr><td><code id="as_music_df_+3A_info">info</code></td>
<td>
<p><code>NULL</code> or character, a note info string.</p>
</td></tr>
<tr><td><code id="as_music_df_+3A_key">key</code></td>
<td>
<p>character, key signature, only required for inclusion of scale
degrees.</p>
</td></tr>
<tr><td><code id="as_music_df_+3A_scale">scale</code></td>
<td>
<p>character, defaults to <code>"diatonic"</code>. Only used in conjunction
with <code>key</code>, this can be used to alter scale degrees. Not any arbitrary
combination of valid <code>key</code> and valid <code>scale</code> is valid. See <code><a href="#topic+scale_degree">scale_degree()</a></code>.</p>
</td></tr>
<tr><td><code id="as_music_df_+3A_chords">chords</code></td>
<td>
<p>character, how to structure columns containing multiple values
per chord/row of data frame. See details.</p>
</td></tr>
<tr><td><code id="as_music_df_+3A_si_format">si_format</code></td>
<td>
<p>character, format for scale intervals. See
<code><a href="#topic+scale_interval">scale_interval()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>info</code> is provided or <code>notes</code> is a phrase object, the resulting data frame
also contains note durations and other info variables. The <code>duration</code> column
is always included in the output even as a vector of <code>NA</code>s when <code>info = NULL</code>.
This makes it more explicit that a given music data frame was generated
without any time information for the timesteps. Other note info columns are
not included in this case.
</p>
<p>For some derived column variables the root note (lowest pitch) in chord is
used. This is done for pitch intervals and scale intervals between adjacent
timesteps. This also occurs for scale degrees.
</p>
<p><code>chord = "root"</code> additionally collapses columns like semitone, octave, and
frequency to the value for the root note so that all rows contain one numeric
value. <code>chord = "list"</code> retains full information as list columns.
<code>chord = "character"</code> collapses into strings so that values are readily
visible when printing the table, but information is not stripped and can be
recovered without recomputing from the original pitches.
</p>


<h3>Value</h3>

<p>a tibble data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "a, b, c d e f g# a r ac'e' a c' e' c' r r r a"
as_music_df(x, key = "c", scale = "major")
as_music_df(x, key = "am", scale = "harmonic_minor", si_format = "ad_abb")

a &lt;- notate("8", "Start here.")
time &lt;- paste(a, "8^*2 16-_ 4.. 16( 16)( 2) 2 4. t8- t8 t8- 8[accent]*4 1")
d1 &lt;- as_music_df(x, time)
d1

# Go directly from music object to data frame
m1 &lt;- as_music(x, time)
d2 &lt;- as_music_df(m1)
identical(d1, d2)

# Go directly from phrase object to data frame
p1 &lt;- phrase("a b cgc'", "4-+ 4[accent] 2", 5)
identical(as_music_df(as_music("a4-+;5 b[accent] cgc'2")), as_music_df(p1))
</code></pre>

<hr>
<h2 id='chord_arpeggiate'>Arpeggiate a chord</h2><span id='topic+chord_arpeggiate'></span>

<h3>Description</h3>

<p>Create an arpeggio from a chord.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chord_arpeggiate(
  chord,
  n = 0,
  by = c("note", "chord"),
  broken = FALSE,
  collapse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chord_arpeggiate_+3A_chord">chord</code></td>
<td>
<p>character, a single chord.</p>
</td></tr>
<tr><td><code id="chord_arpeggiate_+3A_n">n</code></td>
<td>
<p>integer, number of steps, negative indicates reverse direction
(decreasing pitch).</p>
</td></tr>
<tr><td><code id="chord_arpeggiate_+3A_by">by</code></td>
<td>
<p>whether each of the <code>n</code> steps refers to individual notes in the
chord (an inversion) or raising the entire chord in its given position by one
octave.</p>
</td></tr>
<tr><td><code id="chord_arpeggiate_+3A_broken">broken</code></td>
<td>
<p>logical, return result as an arpeggio of broken chords.</p>
</td></tr>
<tr><td><code id="chord_arpeggiate_+3A_collapse">collapse</code></td>
<td>
<p>logical, collapse result into a single string ready for
phrase construction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code>chord_invert</code>. If <code>n = 0</code> then <code>chord</code> is returned
immediately; other arguments are ignored.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chord_arpeggiate("ce_gb_", 2)
chord_arpeggiate("ce_gb_", -2)
chord_arpeggiate("ce_gb_", 2, by = "chord")
chord_arpeggiate("ce_gb_", 1, broken = TRUE, collapse = TRUE)
</code></pre>

<hr>
<h2 id='chord_break'>Broken chords</h2><span id='topic+chord_break'></span>

<h3>Description</h3>

<p>Convert chords in a noteworthy string or vector to broken chords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chord_break(notes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chord_break_+3A_notes">notes</code></td>
<td>
<p>character, noteworthy string that may contain chords.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chord_break("c e g ceg ceg")
</code></pre>

<hr>
<h2 id='chord_def'>Define chords</h2><span id='topic+chord_def'></span>

<h3>Description</h3>

<p>Function for creating new chord definition tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chord_def(fret, id, optional = NA, tuning = "standard", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chord_def_+3A_fret">fret</code></td>
<td>
<p>integer vector defining fretted chord. See details.</p>
</td></tr>
<tr><td><code id="chord_def_+3A_id">id</code></td>
<td>
<p>character, the chord type. See details.</p>
</td></tr>
<tr><td><code id="chord_def_+3A_optional">optional</code></td>
<td>
<p><code>NA</code> when all notes required. Otherwise an integer
vector giving the indices of<code>fret</code> that are considered optional notes
for the chord.</p>
</td></tr>
<tr><td><code id="chord_def_+3A_tuning">tuning</code></td>
<td>
<p>character, string tuning. See <code>tunings</code> for predefined
tunings. Custom tunings are specified with a similar <code>value</code> string.</p>
</td></tr>
<tr><td><code id="chord_def_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>transpose()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a tibble data frame containing information defining
various attributes of chords.
It is used to create the <code>guitarChords</code> dataset, but can be used to create
other pre-defined chord collections.
The tibble has only one row, providing all information for the defined chord.
The user can decide which arguments to vectorize over when creating a chord
collection. See examples.
</p>
<p>This function uses a vector of fret integers (<code>NA</code> for muted string) to
define a chord, in conjunction with a string <code>tuning</code> (defaults to standard
tuning, six-string guitar). <code>fret</code> is from lowest to highest pitch strings,
e.g., strings six through one.
</p>
<p>The <code>id</code> is passed directly to the output. It represents the type of chord
and should conform to accepted <code>tabr</code> notation. See <code>id</code> column in
<code>guitarChords</code> for examples.
</p>
<p>Note that the <code>semitones</code> column gives semitone intervals between chord
notes. These count from zero as the lowest pitch based on the tuning of the
instrument, e.g., zero is E2 with standard guitar tuning. To convert these
semitone intervals to standard semitone values assigned to pitches, use
e.g., <code>pitch_semitones("e2")</code> (40) if that is the lowest pitch and add
that value to the instrument semitone interval values.
This is the explanation, but doing this is not necessary. You can use
<code><a href="#topic+chord_semitones">chord_semitones()</a></code> to compute semitones directly on pitches in a
chord.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frets &lt;- c(NA, 0, 2, 2, 1, 0)
chord_def(frets, "m")
chord_def(frets, "m", 6)

purrr::map_dfr(c(0, 2, 3), ~chord_def(frets + .x, "m"))
</code></pre>

<hr>
<h2 id='chord_invert'>Chord inversion</h2><span id='topic+chord_invert'></span>

<h3>Description</h3>

<p>This function inverts a single chord given as a character string. If <code>n = 0</code>,
<code>chord</code> is returned immediately. Otherwise, the notes of the chord are
inverted. If <code>abs(n)</code> is greater than the number of inversions (excluding
root position), an error is thrown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chord_invert(chord, n = 0, limit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chord_invert_+3A_chord">chord</code></td>
<td>
<p>character, a single chord.</p>
</td></tr>
<tr><td><code id="chord_invert_+3A_n">n</code></td>
<td>
<p>inversion.</p>
</td></tr>
<tr><td><code id="chord_invert_+3A_limit">limit</code></td>
<td>
<p>logical, limit inversions in either direction to one less than
the number of notes in the chord.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>chord_invert()</code> has no knowledge of whether a chord might be
considered as in root position or some inversion already, as informed by a
key signature, chord name or user's intent.
This function simply inverts what it receives, treating any defined chord
string as in root position.
</p>
<p>Octave number applies to this function. Chords should always be defined by
notes of increasing pitch. Remember that an unspecified octave number on a
note is octave 3.
When the chord is inverted, it moves up the scale.
The lowest note is moved to the top of the chord, increasing its octave if
necessary, to ensure that the note takes the lowest octave number while
having the highest pitch.
The second lowest note becomes the lowest. It's octave does not change.
This pattern is repeated for higher order inversions. The opposite happens
if <code>n</code> is negative.
</p>
<p>The procedure ensures that the resulting inverted chord is still defined by
notes of increasing pitch.
However, if you construct an unusual chord that spans multiple octaves, the
extra space will be condensed by inversion.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chord_invert("ce_gb_", 3)
</code></pre>

<hr>
<h2 id='chord_is_major'>Check if chords are major or minor</h2><span id='topic+chord_is_major'></span><span id='topic+chord_is_minor'></span>

<h3>Description</h3>

<p>Check if chords are major or minor where possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chord_is_major(notes)

chord_is_minor(notes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chord_is_major_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions operate based only on ordered pitches.
They do not recognize what a human might interpret and name an inverted
chord with a root other than the lowest pitch.
This imposes limitations on the utility of these functions,
which scan the intervals for a minor or major third in a chord whose notes
are sorted by pitch.
</p>
<p>In several cases including single notes or no major or minor third interval
present, <code>NA</code> is returned.
<code>TRUE</code> or <code>FALSE</code> is only returned if such an interval is present.
If more than one is present, it is based on the lowest in pitch.
It prioritizes major/minor and minor/major adjacent intervals (recognizing a
common triad). If these do not occur adjacent, the lowest third is selected.
This is still imperfect, but a useful method. Second and higher unknown
chord inversions are problematic.
</p>


<h3>Value</h3>

<p>logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "c cg, ce ce_ ceg ce_gb g,ce g,ce_ e_,g,c e_,g,ce_ e_,g,c"
chord_is_major(x)
identical(chord_is_major(x), !chord_is_minor(x))
</code></pre>

<hr>
<h2 id='chord_set'>Generate a chord set</h2><span id='topic+chord_set'></span>

<h3>Description</h3>

<p>Generate a chord set for a music score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chord_set(x, id = NULL, n = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chord_set_+3A_x">x</code></td>
<td>
<p>character, n-string chord description from lowest to highest pitch,
strings n through 1. E.g., <code>"xo221o"</code>. You can use spaces or semicolons
when 2-digit fret numbers are present, e.g., <code>"8 10 10 9 o"</code>. Do not mix
formats. Leading <code>x</code> are inferred if the number of entries is less than <code>n</code>.</p>
</td></tr>
<tr><td><code id="chord_set_+3A_id">id</code></td>
<td>
<p>character, the name of the chord in LilyPond readable format,
e.g., <code>"a:m"</code>. Ignored if <code>x</code> is already a named vector.</p>
</td></tr>
<tr><td><code id="chord_set_+3A_n">n</code></td>
<td>
<p>number of instrument strings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chord set list returned by <code>chord_set()</code> is only used for top center
placement of a full set of chord fretboard diagrams for a music score.
<code>chord_set()</code> returns a named list. The names are the chords and the list
elements are strings defining string and fret fingering readable by LilyPond.
Multiple chord positions can be defined for the same chord name.
Instruments with a number of strings other than six are not currently
supported.
</p>
<p>When defining chords, you may also wish to define rests or silent rests for
chords that are to be added to a score for placement above the staff in
time, where no chord is to be played or explicitly written.
Therefore, there are occasions where you may pass chord names and positions
that happen to include entries <code>r</code> and/or <code>s</code> as <code>NA</code> as shown in the
example. These two special cases are passed through by <code>chord_set()</code> but are
ignored when the chord chart is generated.
</p>


<h3>Value</h3>

<p>a named list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chord_names &lt;- c("e:m", "c", "d", "e:m", "d", "r", "s")
chord_position &lt;- c("997x", "5553x", "7775x", "ooo22o", "232oxx", NA, NA)
chord_set(chord_position, chord_names)
</code></pre>

<hr>
<h2 id='chord-compare'>Rank, order and sort chords and notes</h2><span id='topic+chord-compare'></span><span id='topic+chord_rank'></span><span id='topic+chord_order'></span><span id='topic+chord_sort'></span>

<h3>Description</h3>

<p>Rank, order and sort chords and notes by various definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chord_rank(notes, pitch = c("min", "mean", "max"), ...)

chord_order(notes, pitch = c("min", "mean", "max"), ...)

chord_sort(notes, pitch = c("min", "mean", "max"), decreasing = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chord-compare_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string.</p>
</td></tr>
<tr><td><code id="chord-compare_+3A_pitch">pitch</code></td>
<td>
<p>character, how ranking of chords is determined; lowest pitch,
mean pitch, or highest pitch.</p>
</td></tr>
<tr><td><code id="chord-compare_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>rank()</code> or <code>order()</code>.</p>
</td></tr>
<tr><td><code id="chord-compare_+3A_decreasing">decreasing</code></td>
<td>
<p>logical, sort in decreasing order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three options for comparing the relative pitch position of chords
provided: comparison of the lowest or root note of each chord, the highest
pitch note, or taking the mean of all notes in a chord.
</p>


<h3>Value</h3>

<p>integer for rank and order, character for sort
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "a2 c a2 ceg ce_g cea"
chord_rank(x, "min")
chord_rank(x, "max")
chord_rank(x, "mean")

chord_order(x)
chord_order(x, "mean")
chord_sort(x, "mean")
</code></pre>

<hr>
<h2 id='chord-filter'>Extract notes from chords</h2><span id='topic+chord-filter'></span><span id='topic+chord_root'></span><span id='topic+chord_top'></span><span id='topic+chord_slice'></span>

<h3>Description</h3>

<p>Filter or slice chords to extract individual notes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chord_root(notes)

chord_top(notes)

chord_slice(notes, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chord-filter_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string.</p>
</td></tr>
<tr><td><code id="chord-filter_+3A_index">index</code></td>
<td>
<p>integer, the order of a note in a chord by pitch (not scale
degrees).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract notes from chords such as the root note, the highest
pitch, specific position among the notes by pitch, or trim chords to
simplify them.
They operate based only on ordered pitches.
</p>
<p>For <code>chord_slice()</code>, any entry that is empty after slicing is dropped. An
error is thrown is <code>index</code> is completely out of bounds for all chords.
</p>


<h3>Value</h3>

<p>a noteworthy string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "a_2 c#eg# e_gc egc,cc'"
chord_root(x)
chord_top(x)
identical(chord_slice(x, 1), chord_root(x))
chord_slice(x, 2)
chord_slice(x, 4)
chord_slice(x, 3:5)
</code></pre>

<hr>
<h2 id='chord-mapping'>Chord mapping</h2><span id='topic+chord-mapping'></span><span id='topic+gc_info'></span><span id='topic+gc_fretboard'></span><span id='topic+gc_notes_to_fb'></span><span id='topic+gc_notes'></span><span id='topic+gc_is_known'></span><span id='topic+gc_name_split'></span><span id='topic+gc_name_root'></span><span id='topic+gc_name_mod'></span>

<h3>Description</h3>

<p>Helper functions for chord mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gc_info(
  name,
  root_octave = NULL,
  root_fret = NULL,
  min_fret = NULL,
  bass_string = NULL,
  open = NULL,
  key = "c",
  ignore_octave = TRUE
)

gc_fretboard(
  name,
  root_octave = NULL,
  root_fret = NULL,
  min_fret = NULL,
  bass_string = NULL,
  open = NULL,
  key = "c",
  ignore_octave = TRUE
)

gc_notes_to_fb(
  notes,
  root_octave = NULL,
  root_fret = NULL,
  min_fret = NULL,
  bass_string = NULL,
  open = NULL
)

gc_notes(
  name,
  root_octave = NULL,
  root_fret = NULL,
  min_fret = NULL,
  bass_string = NULL,
  open = NULL,
  key = "c",
  ignore_octave = TRUE
)

gc_is_known(notes)

gc_name_split(name)

gc_name_root(name)

gc_name_mod(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chord-mapping_+3A_name">name</code></td>
<td>
<p>character, chord name in <code>tabr</code> format, e.g., <code>"bM b_m b_m7#5"</code>,
etc.</p>
</td></tr>
<tr><td><code id="chord-mapping_+3A_root_octave">root_octave</code></td>
<td>
<p>integer, optional filter for chords whose root note is in
a set of octave numbers. May be a vector.</p>
</td></tr>
<tr><td><code id="chord-mapping_+3A_root_fret">root_fret</code></td>
<td>
<p>integer, optional filter for chords whose root note matches
a specific fret. May be a vector.</p>
</td></tr>
<tr><td><code id="chord-mapping_+3A_min_fret">min_fret</code></td>
<td>
<p>integer, optional filter for chords whose notes are all at
or above a specific fret. May be a vector.</p>
</td></tr>
<tr><td><code id="chord-mapping_+3A_bass_string">bass_string</code></td>
<td>
<p>integer, optional filter for chords whose lowest pitch
string matches a specific string, 6, 5, or 4. May be a vector.</p>
</td></tr>
<tr><td><code id="chord-mapping_+3A_open">open</code></td>
<td>
<p>logical, optional filter for open and movable chords. <code>NULL</code>
retains both types.</p>
</td></tr>
<tr><td><code id="chord-mapping_+3A_key">key</code></td>
<td>
<p>character, key signature, used to enforce type of accidentals.</p>
</td></tr>
<tr><td><code id="chord-mapping_+3A_ignore_octave">ignore_octave</code></td>
<td>
<p>logical, if <code>TRUE</code>, functions like <code>gc_info()</code> and
<code>gc_fretboard()</code> return more results.</p>
</td></tr>
<tr><td><code id="chord-mapping_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions assist with mapping between different information that
define chords.
</p>
<p>For <code>gc_is_known()</code>, a check is done against chords in the <code>guitarChords</code>
dataset. A simple noteworthy string is permitted, but any single-note entry
will automatically yield a <code>FALSE</code> result.
</p>
<p><code>gc_info()</code> returns a tibble data frame containing complete information for
the subset of predefined guitar chords specified by <code>name</code> and <code>key</code>.
Any accidentals present in the chord root of <code>name</code> (but not in the chord
modifier, e.g., <code>m7_5</code> or <code>m7#5</code>) are converted according to <code>key</code> if
necessary.
<code>gc_notes()</code> and <code>gc_fretboard()</code> are wrappers around <code>gc_info()</code>, which
return noteworthy strings of chord notes and a named vector of LilyPond
fretboard diagram data, respectively.
Note that although the input to these functions can contain multiple chord
names, whether as a vector or as a single space-delimited string, the result
is not intended to be of equal length.
These functions filter <code>guitarChords</code>. The result is the set of all
chords matched by the supplied input filters.
</p>
<p><code>gc_name_split()</code> splits a vector or space-delimited set of chord names into
a tibble data frame containing separate chord root and chord modifier columns.
<code>gc_name_root()</code> and <code>gc_name_mod()</code> are wrappers around this.
</p>


<h3>Value</h3>

<p>various, see details regarding each function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gc_is_known("a b_,fb_d'f'")

gc_name_root("a aM b_,m7#5")
gc_name_mod("a aM b_,m7#5")

gc_info("a") # a major chord, not a single note
gc_info("ceg a#m7_5") # only second entry is a guitar chord
gc_info("ceg a#m7_5", key = "f")

gc_info("a,m c d f,")
gc_fretboard("a,m c d f,", root_fret = 0:3)
gc_notes_to_fb("a,eac'e' cgc'e'g'")

x &lt;- gc_notes("a, b,", root_fret = 0:2)
summary(x)

</code></pre>

<hr>
<h2 id='chords'>Chord constructors</h2><span id='topic+chords'></span><span id='topic+chord_min'></span><span id='topic+chord_maj'></span><span id='topic+chord_min7'></span><span id='topic+chord_dom7'></span><span id='topic+chord_7s5'></span><span id='topic+chord_maj7'></span><span id='topic+chord_min6'></span><span id='topic+chord_maj6'></span><span id='topic+chord_dim'></span><span id='topic+chord_dim7'></span><span id='topic+chord_m7b5'></span><span id='topic+chord_aug'></span><span id='topic+chord_5'></span><span id='topic+chord_sus2'></span><span id='topic+chord_sus4'></span><span id='topic+chord_dom9'></span><span id='topic+chord_7s9'></span><span id='topic+chord_maj9'></span><span id='topic+chord_add9'></span><span id='topic+chord_min9'></span><span id='topic+chord_madd9'></span><span id='topic+chord_min11'></span><span id='topic+chord_7s11'></span><span id='topic+chord_maj7s11'></span><span id='topic+chord_11'></span><span id='topic+chord_maj11'></span><span id='topic+chord_13'></span><span id='topic+chord_min13'></span><span id='topic+chord_maj13'></span><span id='topic+xm'></span><span id='topic+xM'></span><span id='topic+xm7'></span><span id='topic+x7'></span><span id='topic+x7s5'></span><span id='topic+xM7'></span><span id='topic+xm6'></span><span id='topic+xM6'></span><span id='topic+xdim'></span><span id='topic+xdim7'></span><span id='topic+xm7b5'></span><span id='topic+xaug'></span><span id='topic+x5'></span><span id='topic+xs2'></span><span id='topic+xs4'></span><span id='topic+x9'></span><span id='topic+x7s9'></span><span id='topic+xM9'></span><span id='topic+xadd9'></span><span id='topic+xm9'></span><span id='topic+xma9'></span><span id='topic+xm11'></span><span id='topic+x7s11'></span><span id='topic+xM7s11'></span><span id='topic+x_11'></span><span id='topic+xM11'></span><span id='topic+x_13'></span><span id='topic+xm13'></span><span id='topic+xM13'></span>

<h3>Description</h3>

<p>These functions construct basic chord string notation from root <code>notes</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chord_min(notes, key = "c", octaves = "tick")

chord_maj(notes, key = "c", octaves = "tick")

chord_min7(notes, key = "c", octaves = "tick")

chord_dom7(notes, key = "c", octaves = "tick")

chord_7s5(notes, key = "c", octaves = "tick")

chord_maj7(notes, key = "c", octaves = "tick")

chord_min6(notes, key = "c", octaves = "tick")

chord_maj6(notes, key = "c", octaves = "tick")

chord_dim(notes, key = "c", octaves = "tick")

chord_dim7(notes, key = "c", octaves = "tick")

chord_m7b5(notes, key = "c", octaves = "tick")

chord_aug(notes, key = "c", octaves = "tick")

chord_5(notes, key = "c", octaves = "tick")

chord_sus2(notes, key = "c", octaves = "tick")

chord_sus4(notes, key = "c", octaves = "tick")

chord_dom9(notes, key = "c", octaves = "tick")

chord_7s9(notes, key = "c", octaves = "tick")

chord_maj9(notes, key = "c", octaves = "tick")

chord_add9(notes, key = "c", octaves = "tick")

chord_min9(notes, key = "c", octaves = "tick")

chord_madd9(notes, key = "c", octaves = "tick")

chord_min11(notes, key = "c", octaves = "tick")

chord_7s11(notes, key = "c", octaves = "tick")

chord_maj7s11(notes, key = "c", octaves = "tick")

chord_11(notes, key = "c", octaves = "tick")

chord_maj11(notes, key = "c", octaves = "tick")

chord_13(notes, key = "c", octaves = "tick")

chord_min13(notes, key = "c", octaves = "tick")

chord_maj13(notes, key = "c", octaves = "tick")

xm(notes, key = "c", octaves = "tick")

xM(notes, key = "c", octaves = "tick")

xm7(notes, key = "c", octaves = "tick")

x7(notes, key = "c", octaves = "tick")

x7s5(notes, key = "c", octaves = "tick")

xM7(notes, key = "c", octaves = "tick")

xm6(notes, key = "c", octaves = "tick")

xM6(notes, key = "c", octaves = "tick")

xdim(notes, key = "c", octaves = "tick")

xdim7(notes, key = "c", octaves = "tick")

xm7b5(notes, key = "c", octaves = "tick")

xaug(notes, key = "c", octaves = "tick")

x5(notes, key = "c", octaves = "tick")

xs2(notes, key = "c", octaves = "tick")

xs4(notes, key = "c", octaves = "tick")

x9(notes, key = "c", octaves = "tick")

x7s9(notes, key = "c", octaves = "tick")

xM9(notes, key = "c", octaves = "tick")

xadd9(notes, key = "c", octaves = "tick")

xm9(notes, key = "c", octaves = "tick")

xma9(notes, key = "c", octaves = "tick")

xm11(notes, key = "c", octaves = "tick")

x7s11(notes, key = "c", octaves = "tick")

xM7s11(notes, key = "c", octaves = "tick")

x_11(notes, key = "c", octaves = "tick")

xM11(notes, key = "c", octaves = "tick")

x_13(notes, key = "c", octaves = "tick")

xm13(notes, key = "c", octaves = "tick")

xM13(notes, key = "c", octaves = "tick")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chords_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string of chord root notes.</p>
</td></tr>
<tr><td><code id="chords_+3A_key">key</code></td>
<td>
<p>key signature. See details.</p>
</td></tr>
<tr><td><code id="chords_+3A_octaves">octaves</code></td>
<td>
<p>character, passed to <code>transpose()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Providing a <code>key</code> signature is used only to ensure flats or sharps for
accidentals.
An additional set of aliases with efficient names, of the form <code style="white-space: pre;">&#8288;x*&#8288;</code> where <code>*</code>
is a chord modifier abbreviation, is provided to complement the set of
<code style="white-space: pre;">&#8288;chord_*&#8288;</code> functions.
</p>
<p>These functions create standard chords, not the multi-octave spanning types
of chords commonly played on guitar.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transpose">transpose()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chord_min("d")
chord_maj("d")
xM("d")
xm("c f g")
xm("c, f, g,", key = "e_")
</code></pre>

<hr>
<h2 id='double-bracket'>Double bracket methods for tabr classes</h2><span id='topic+double-bracket'></span><span id='topic++5B+5B.noteworthy'></span><span id='topic++5B+5B.noteinfo'></span><span id='topic++5B+5B.music'></span><span id='topic++5B+5B.lyrics'></span><span id='topic++5B+5B+3C-.noteworthy'></span><span id='topic++5B+5B+3C-.noteinfo'></span><span id='topic++5B+5B+3C-.music'></span><span id='topic++5B+5B+3C-.lyrics'></span>

<h3>Description</h3>

<p>Double bracket indexing and assignment. See <code><a href="#topic+tabr-methods">tabr-methods()</a></code> for more details
on methods for tabr classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'noteworthy'
x[[i]]

## S3 method for class 'noteinfo'
x[[i]]

## S3 method for class 'music'
x[[i]]

## S3 method for class 'lyrics'
x[[i]]

## S3 replacement method for class 'noteworthy'
x[[i]] &lt;- value

## S3 replacement method for class 'noteinfo'
x[[i]] &lt;- value

## S3 replacement method for class 'music'
x[[i]] &lt;- value

## S3 replacement method for class 'lyrics'
x[[i]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="double-bracket_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="double-bracket_+3A_i">i</code></td>
<td>
<p>index.</p>
</td></tr>
<tr><td><code id="double-bracket_+3A_value">value</code></td>
<td>
<p>values to assign at index.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tabr-methods">tabr-methods()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># noteworthy class examples
x &lt;- as_noteworthy("a, b, c ce_g")
x[[3]]
x[[2]] &lt;- paste0(transpose(x[2], 1), "~")
x

# noteinfo class examples
x &lt;- as_noteinfo(c("4-", "t8(", "t8)", "t8x"))
x[[3]]
x[[3]] &lt;- c("t8]")
x

# music class examples
x &lt;- as_music("c,~4 c,1 c'e_'g'4-.*2")
x[[3]]
x[[3]] &lt;- "c'e'g'8"
x
</code></pre>

<hr>
<h2 id='dyad'>Construct a dyad</h2><span id='topic+dyad'></span>

<h3>Description</h3>

<p>Construct a dyad given one note, an interval, and a direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyad(
  notes,
  interval,
  reverse = FALSE,
  octaves = c("tick", "integer"),
  accidentals = c("flat", "sharp"),
  key = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyad_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string, single notes only, no chords.
Number of timesteps must equal the length of <code>interval</code>.</p>
</td></tr>
<tr><td><code id="dyad_+3A_interval">interval</code></td>
<td>
<p>integer or character vector; semitones or interval ID,
respectively. See details.</p>
</td></tr>
<tr><td><code id="dyad_+3A_reverse">reverse</code></td>
<td>
<p>logical, reverse the transposition direction. Useful when
<code>interval</code> is character.</p>
</td></tr>
<tr><td><code id="dyad_+3A_octaves">octaves</code>, <code id="dyad_+3A_accidentals">accidentals</code>, <code id="dyad_+3A_key">key</code></td>
<td>
<p>See <code><a href="#topic+transpose">transpose()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>interval</code> may be specified by semitones of by common interval name
or abbreviation. See examples.
For a complete list of valid interval names and abbreviations see
<code><a href="#topic+mainIntervals">mainIntervals()</a></code>.
<code>key</code> enforces the use of sharps or flats. This function is based on
<code>transpose()</code>.
<code>notes</code> and <code>interval</code> may be vectors, but must be equal length.
Recycling occurs only if one argument is scalar.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mainIntervals">mainIntervals()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dyad("a", 4)
x &lt;- c("minor third", "m3", "augmented second", "A2")
dyad("a", x)
dyad("c'", x, reverse = TRUE)

x &lt;- c("M3", "m3", "m3", "M3", "M3", "m3", "m3")
dyad(letters[c(3:7, 1, 2)], x)

x &lt;- c("P1", "m3", "M3", "P4", "P5", "P8", "M9")
dyad("c", x)
dyad("c", x, reverse = TRUE)
dyad("d e", "m3")
</code></pre>

<hr>
<h2 id='freq_ratio'>Frequency ratios</h2><span id='topic+freq_ratio'></span>

<h3>Description</h3>

<p>Obtain frequency ratios data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq_ratio(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq_ratio_+3A_x">x</code></td>
<td>
<p>noteworthy or music object, or a numeric vector or list of numeric
vectors for frequencies.</p>
</td></tr>
<tr><td><code id="freq_ratio_+3A_...">...</code></td>
<td>
<p>additional arguments: <code>ratios</code>, which is one of <code>"all"</code>
(default), <code>"root"</code>, or <code>"range"</code> for filtering results. For
frequency input, you may also specify <code>octaves</code> and <code>accidentals</code>.
See details and examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function returns a data frame of frequency ratios from
a vector or list of frequencies, a noteworthy object, or a music object. For
frequency inputs, a list can be used to represent multiple timesteps.
Octave numbering and accidentals are inferred from noteworthy and music
objects, but can be specified for frequency. See examples.
</p>
<p>By default ratios are returned for all combinations of intervals in each
chord (<code>ratios = "all"</code>). <code>ratios = "root"</code> filters the result to only
include chord ratios with respect to the root note of each chord.
<code>ratios = "range"</code> filters to only the chord ratio between the root and
highest note.
</p>


<h3>Value</h3>

<p>a tibble data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_music("c4 e_ g ce_g")
(fr &lt;- freq_ratio(x))

x &lt;- music_notes(x)
identical(fr, freq_ratio(x))

x &lt;- chord_freq(x)
identical(fr, freq_ratio(x))

freq_ratio(x, accidentals = "sharp")

freq_ratio(x, ratios = "root")

freq_ratio(x, ratios = "range")
</code></pre>

<hr>
<h2 id='guitarChords'>Predefined guitar chords</h2><span id='topic+guitarChords'></span>

<h3>Description</h3>

<p>A data frame containing information for many predefined guitar chords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guitarChords
</code></pre>


<h3>Format</h3>

<p>A data frame with 12 columns and 3,967 rows
</p>

<hr>
<h2 id='hp'>Hammer ons and pull offs</h2><span id='topic+hp'></span>

<h3>Description</h3>

<p>Helper function for generating hammer on and pull off syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hp(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hp_+3A_...">...</code></td>
<td>
<p>character, note durations. Numeric is allowed for lists of single
inputs. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is especially useful for repeated instances. This function applies to
general slur notation as well.
Multiple input formats are allowed. Total number of note durations must be
even because all slurs require start and stop points.
</p>


<h3>Value</h3>

<p>character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hp(16, 16)
hp("16 16")
hp("16 8 16", "8 16 8")
</code></pre>

<hr>
<h2 id='interval_semitones'>Interval semitones</h2><span id='topic+interval_semitones'></span>

<h3>Description</h3>

<p>Convert named intervals to numbers of semitones.
For a complete list of valid interval names and abbreviations see
<code><a href="#topic+mainIntervals">mainIntervals()</a></code>. <code>interval</code> may be a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval_semitones(interval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_semitones_+3A_interval">interval</code></td>
<td>
<p>character, interval ID. See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mainIntervals">mainIntervals()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("minor third", "m3", "augmented second", "A2")
y &lt;- c("P1", "m2", "M2", "m3", "M3", "P4", "TT", "P5")
interval_semitones(x)
interval_semitones(y)
</code></pre>

<hr>
<h2 id='intervals'>Interval helpers</h2><span id='topic+intervals'></span><span id='topic+pitch_interval'></span><span id='topic+pitch_diff'></span><span id='topic+scale_interval'></span><span id='topic+scale_diff'></span><span id='topic+tuning_intervals'></span>

<h3>Description</h3>

<p>Helper functions for musical intervals defined by two notes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pitch_interval(notes1, notes2, use_root = TRUE)

pitch_diff(notes, use_root = TRUE, n = 1, trim = FALSE)

scale_interval(
  notes1,
  notes2,
  use_root = TRUE,
  format = c("mmp_abb", "mmp", "ad_abb", "ad")
)

scale_diff(
  notes,
  use_root = TRUE,
  n = 1,
  trim = FALSE,
  format = c("mmp_abb", "mmp", "ad_abb", "ad")
)

tuning_intervals(tuning = "standard")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals_+3A_use_root">use_root</code></td>
<td>
<p>logical, use lowest pitch in chord for pitch intervals or
scale intervals between adjacent timesteps. Otherwise intervals involving
chords are <code>NA</code>.</p>
</td></tr>
<tr><td><code id="intervals_+3A_notes">notes</code>, <code id="intervals_+3A_notes1">notes1</code>, <code id="intervals_+3A_notes2">notes2</code></td>
<td>
<p>character, a noteworthy string. <code>notes1</code> and
<code>notes2</code> must have equal number of timesteps.</p>
</td></tr>
<tr><td><code id="intervals_+3A_n">n</code></td>
<td>
<p>integer, size of lag.</p>
</td></tr>
<tr><td><code id="intervals_+3A_trim">trim</code></td>
<td>
<p>logical, trim the <code>n</code> leading <code>NA</code> values from lagged
intervals.</p>
</td></tr>
<tr><td><code id="intervals_+3A_format">format</code></td>
<td>
<p>character, format of the scale notation: major/minor/perfect,
augmented/diminished, and respective abbreviations. See argument options in
defaults.</p>
</td></tr>
<tr><td><code id="intervals_+3A_tuning">tuning</code></td>
<td>
<p>character, string tuning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numeric intervals are directional. <code>pitch_interval()</code> returns the signed
number of semitones defining the distance between two notes.
Named scale intervals are names only. Use pitch for direction.
</p>
<p><code>scale_interval()</code> returns a character string that provides the named main
interval, simple or compound, defined by  the two notes. This function
returns <code>NA</code> for any uncommon out of range large interval not listed as a
named interval in <code><a href="#topic+mainIntervals">mainIntervals()</a></code>.
</p>
<p><code>pitch_interval()</code> and <code>scale_interval()</code> compute intervals element-wise
between two noteworthy strings. <code>pitch_diff()</code> and <code>scale_diff()</code> work
similarly but compute lagged intervals on the elements in <code>notes</code>.
</p>


<h3>Value</h3>

<p>a musical interval, integer or character depending on the function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mainIntervals">mainIntervals()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pitch_interval("b", "c4")
pitch_interval("c, e_, g_, a,", "e_, g_, a, c")
pitch_interval("c r", "dfa d")
pitch_interval("c r", "dfa d", use_root = FALSE)
scale_interval("c", "e_")
scale_interval("ceg", "egd'")

x &lt;- "a, b, c d e f g# ac'e' a c' e'"
pitch_diff(x)
pitch_diff(x, use_root = FALSE)
scale_diff(x)
scale_diff(x, n = 2, trim = TRUE, use_root = FALSE)

# Lagged intervals respect rest timesteps.
# All timestep position including rests are retained.
# But the lag-n difference skips rest entries.
x &lt;- "a, c r r r r g"
pitch_diff(x)
scale_diff(x)
pitch_diff(x, n = 2)
scale_diff(x, n = 2)
pitch_diff(x, n = 2, trim = TRUE)
scale_diff(x, n = 2, trim = TRUE)
</code></pre>

<hr>
<h2 id='is_diatonic'>Check if notes and chords are diatonic</h2><span id='topic+is_diatonic'></span>

<h3>Description</h3>

<p>Check if notes and chords are diatonic in a given key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_diatonic(notes, key = "c")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_diatonic_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string.</p>
</td></tr>
<tr><td><code id="is_diatonic_+3A_key">key</code></td>
<td>
<p>character, key signature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around <code><a href="#topic+is_in_scale">is_in_scale()</a></code>. To check if individual
notes are in a scale, see <code><a href="#topic+note_in_scale">note_in_scale()</a></code>.
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_in_scale">is_in_scale()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_diatonic("ceg ace ce_g", "c")
is_diatonic(c("r", "d", "dfa", "df#a"), "d")
</code></pre>

<hr>
<h2 id='keys'>Key signatures</h2><span id='topic+keys'></span><span id='topic+key_is_natural'></span><span id='topic+key_is_sharp'></span><span id='topic+key_is_flat'></span><span id='topic+key_n_sharps'></span><span id='topic+key_n_flats'></span><span id='topic+key_is_major'></span><span id='topic+key_is_minor'></span>

<h3>Description</h3>

<p>Helper functions for key signature information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keys(type = c("all", "sharp", "flat"))

key_is_natural(key)

key_is_sharp(key)

key_is_flat(key)

key_n_sharps(key)

key_n_flats(key)

key_is_major(key)

key_is_minor(key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keys_+3A_type">type</code></td>
<td>
<p>character, defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="keys_+3A_key">key</code></td>
<td>
<p>character, key signature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>keys()</code> function returns a vector of valid key signature IDs. These IDs
are how key signatures are specified throughout <code>tabr</code>, including in the
other helper functions here via <code>key</code>. Like the other functions here,
<code>key_is_sharp()</code> and <code>key_is_flat()</code> are for <em>key signatures</em>, not single
pitches whose sharp or flat status is always self-evident from their notation.
Major and minor keys are also self-evident from their notation, but
<code>key_is_major()</code> and <code>key_is_minor()</code> can still be useful when programming.
</p>


<h3>Value</h3>

<p>character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>keys()
key_is_natural(c("c", "am", "c#"))
x &lt;- c("a", "e_")
key_is_sharp(x)
key_is_flat(x)
key_n_sharps(x)
key_n_flats(x)
</code></pre>

<hr>
<h2 id='lilypond'>Save score to LilyPond file</h2><span id='topic+lilypond'></span>

<h3>Description</h3>

<p>Write a score to a LilyPond format (<code>.ly</code>) text file for later use by
LilyPond or subsequent editing outside of R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lilypond(
  score,
  file,
  key = "c",
  time = "4/4",
  tempo = "2 = 60",
  header = NULL,
  paper = NULL,
  string_names = NULL,
  endbar = "|.",
  midi = TRUE,
  colors = NULL,
  crop_png = TRUE,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lilypond_+3A_score">score</code></td>
<td>
<p>a score object.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_file">file</code></td>
<td>
<p>character, LilyPond output file ending in <code>.ly</code>. May include an
absolute or relative path.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_key">key</code></td>
<td>
<p>character, key signature, e.g., <code>c</code>, <code>b_</code>, <code>f#m</code>, etc.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_time">time</code></td>
<td>
<p>character, defaults to <code>"4/4"</code>.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_tempo">tempo</code></td>
<td>
<p>character, defaults to <code>"2 = 60"</code>. Set to <code>NA</code> or <code>NULL</code> to
suppress metronome mark in output. If suppressed and <code>midi = TRUE</code>, an error
is thrown.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_header">header</code></td>
<td>
<p>a named list of arguments passed to the header of the LilyPond
file. See details.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_paper">paper</code></td>
<td>
<p>a named list of arguments for the LilyPond file page layout.
See details.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_string_names">string_names</code></td>
<td>
<p>label strings at beginning of tab staff. <code>NULL</code> (default)
for non-standard tunings only, <code>TRUE</code> or <code>FALSE</code> for force on or off
completely.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_endbar">endbar</code></td>
<td>
<p>character, the global end bar.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_midi">midi</code></td>
<td>
<p>logical, add midi inclusion specification to LilyPond file.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_colors">colors</code></td>
<td>
<p>a named list of LilyPond element color overrides. See details.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_crop_png">crop_png</code></td>
<td>
<p>logical, alter template for cropped height. See
details.</p>
</td></tr>
<tr><td><code id="lilypond_+3A_simplify">simplify</code></td>
<td>
<p>logical, uses <code>simplify_phrase()</code> to convert to simpler,
more efficient LilyPond syntax.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function only writes a LilyPond file to disk. It does not require a
LilyPond installation. It checks for the version number of an installation,
but LilyPond is not required to be found.
</p>
<p>This function can be used directly but is commonly used by <code style="white-space: pre;">&#8288;render_*&#8288;</code>
functions, which call this function internally to create the LilyPond file
and then call LilyPond to render that file to sheet music.
</p>


<h3>Value</h3>

<p>nothing returned; a file is written.
</p>


<h3>Header options</h3>

<p>All <code>header</code> list elements are character strings. The options for <code>header</code>
include the following.
</p>

<ul>
<li> <p><code>title</code>
</p>
</li>
<li> <p><code>subtitle</code>
</p>
</li>
<li> <p><code>composer</code>
</p>
</li>
<li> <p><code>album</code>
</p>
</li>
<li> <p><code>arranger</code>
</p>
</li>
<li> <p><code>instrument</code>
</p>
</li>
<li> <p><code>meter</code>
</p>
</li>
<li> <p><code>opus</code>
</p>
</li>
<li> <p><code>piece</code>
</p>
</li>
<li> <p><code>poet</code>
</p>
</li>
<li> <p><code>copyright</code>
</p>
</li>
<li> <p><code>tagline</code>
</p>
</li></ul>



<h3>Paper options</h3>

<p>All <code>paper</code> list elements are numeric except <code>page_numbers</code> and
<code>print_first_page_number</code>, which are logical. <code>page_numbers = FALSE</code>
suppresses all page numbering. When <code>page_numbers = TRUE</code>, you can set
<code>print_first_page_number = FALSE</code> to suppress printing of only the first page
number. <code>first_page_number</code> is the number of the first page, defaulting to 1,
and determines all subsequent page numbers. These arguments correspond to
LilyPond paper block variables.
</p>
<p>The options for <code>paper</code> include the following and have the following default
values if not provided.
</p>

<ul>
<li> <p><code>textheight = 220</code>
</p>
</li>
<li> <p><code>linewidth = 150</code>
</p>
</li>
<li> <p><code>indent = 0</code>
</p>
</li>
<li> <p><code>fontsize = 10</code>
</p>
</li>
<li> <p><code>page_numbers = TRUE</code>
</p>
</li>
<li> <p><code>print_first_page_number = TRUE</code>
</p>
</li>
<li> <p><code>first_page_number = 1</code>
</p>
</li></ul>



<h3>PNG-related options</h3>

<p>By default <code>crop_png = TRUE</code>. This alters the template so that when
the LilyPond output file is created, it contains specifications for cropping
the image to the content when that file is rendered by LilyPond to png.
The image will have its width and height automatically cropped rather than
retain the standard page dimensions. This only applies to png outputs made
from the LilyPond file, not pdf. The argument is also ignored if explicitly
providing <code>textheight</code> to <code>paper</code>. You may still provide <code>linewidth</code> to
<code>paper</code> if you find you need to increase it beyond the default 150mm,
generally as a result of using a large <code>fontsize</code>. Various <code style="white-space: pre;">&#8288;render_*&#8288;</code>
functions that wrap <code>lilypond</code> make use of this argument as well.
</p>


<h3>Color options</h3>

<p>You can provide a named list of global color overrides for various sheet
music elements with the <code>colors</code> argument of <code>lilypond</code> or one of the
associated rendering functions.
</p>
<p>By default, everything is black. Overrides are only inserted into the
generated LilyPond file if given. Values are character; either the hex color
or a named R color. The named list options include the following.
</p>

<ul>
<li> <p><code>color</code>
</p>
</li>
<li> <p><code>background</code>
</p>
</li>
<li> <p><code>staff</code>
</p>
</li>
<li> <p><code>time</code>
</p>
</li>
<li> <p><code>key</code>
</p>
</li>
<li> <p><code>clef</code>
</p>
</li>
<li> <p><code>bar</code>
</p>
</li>
<li> <p><code>beam</code>
</p>
</li>
<li> <p><code>head</code>
</p>
</li>
<li> <p><code>stem</code>
</p>
</li>
<li> <p><code>accidental</code>
</p>
</li>
<li> <p><code>slur</code>
</p>
</li>
<li> <p><code>tabhead</code>
</p>
</li>
<li> <p><code>lyrics</code>
</p>
</li></ul>

<p><code>color</code> is a global font color for the entire score. It affects staff
elements and <code>header</code> elements. It does not affect everything, e.g., page
numbers. <code>background</code> controls the background color of the entire page. Do
not use this if making a transparent background png with the <code>transparent</code>
argument available in the various <code style="white-space: pre;">&#8288;render_*&#8288;</code> functions. The other options are
also global but override <code>color</code>. You can change the color of elements
broadly with <code>color</code> and then change the color of specific elements using the
other options.
</p>
<p>There are currently some limitations. Specifically, if you provide any
<code>background</code> color override, most <code>header</code> elements will not display.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tab">tab()</a></code>, <code><a href="#topic+render_chordchart">render_chordchart()</a></code>,
<code><a href="#topic+midily">midily()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- phrase("c ec'g' ec'g'", "4 4 2", "5 432 432")
x &lt;- track(x)
x &lt;- score(x)
outfile &lt;- file.path(tempdir(), "out.ly")
lilypond(x, outfile)
</code></pre>

<hr>
<h2 id='lilypond_root'>LilyPond installation information</h2><span id='topic+lilypond_root'></span><span id='topic+lilypond_version'></span><span id='topic+tabr_lilypond_api'></span>

<h3>Description</h3>

<p>Details about local LilyPond installation and package API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lilypond_root()

lilypond_version()

tabr_lilypond_api()
</code></pre>


<h3>Details</h3>

<p>Version information and installation directory are returned if the
installation can be found. The LilyPond API references the currently loaded
version of <code>tabr</code>.
</p>


<h3>Value</h3>

<p>a message or system standard output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lilypond_root()
lilypond_version()
tabr_lilypond_api()
</code></pre>

<hr>
<h2 id='lp_chord_id'>LilyPond chord notation</h2><span id='topic+lp_chord_id'></span><span id='topic+lp_chord_mod'></span>

<h3>Description</h3>

<p>Obtain LilyPond quasi-chord notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_chord_id(root, chord, exact = FALSE, ...)

lp_chord_mod(root, chord, exact = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lp_chord_id_+3A_root">root</code></td>
<td>
<p>character, root note.</p>
</td></tr>
<tr><td><code id="lp_chord_id_+3A_chord">chord</code></td>
<td>
<p>character, <code>tabr</code> format chord name.</p>
</td></tr>
<tr><td><code id="lp_chord_id_+3A_exact">exact</code></td>
<td>
<p>logical, return a more exact LilyPond chord representation.</p>
</td></tr>
<tr><td><code id="lp_chord_id_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>transpose()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions take a <code>tabr</code> syntax representation of a chord name and
convert it to quasi-LilyPond syntax;
&quot;quasi&quot; because the result still uses <code style="white-space: pre;">&#8288;_&#8288;</code> for flats and <code style="white-space: pre;">&#8288;#&#8288;</code> for sharps,
whereas LilyPond itself uses <code>es</code> and <code>is</code> (mostly).
This is the format used by <code>tabr</code> functions involved in communicating with
LilyPond for music transcription, and they make these final conversions on
the fly.
This can be overridden with <code>exact = TRUE</code>.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lp_chord_id("a a a", "m M m7_5")
lp_chord_mod("a a a", "m M m7_5")
lp_chord_id("a a a", "m M m7_5", exact = TRUE)
lp_chord_mod("a a a", "m M m7_5", exact = TRUE)
</code></pre>

<hr>
<h2 id='lyrics'>Create lyrics and check lyrics string validity</h2><span id='topic+lyrics'></span><span id='topic+lyrical'></span><span id='topic+as_lyrics'></span><span id='topic+is_lyrics'></span><span id='topic+lyrics_template'></span>

<h3>Description</h3>

<p>Functions for creating and checking lyrics objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lyrical(x)

as_lyrics(x, format = NULL)

is_lyrics(x)

lyrics_template(x, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lyrics_+3A_x">x</code></td>
<td>
<p>character or lyrics object. For <code>lyrics_template()</code>, an integer or
one of the classes <code>noteworthy</code>, <code>noteinfo</code> or <code>music</code> to derive the number
of timesteps from.</p>
</td></tr>
<tr><td><code id="lyrics_+3A_format">format</code></td>
<td>
<p><code>NULL</code> or character, the timestep delimiter format, <code>"space"</code>
or <code>"vector"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>lyrics</code> class is a simple class for arranging lyrics text by timestep.
Its structure and behavior aligns with that of the classes <code>noteworthy</code>,
<code>noteinfo</code> and <code>music</code>.
</p>
<p><code>lyrical()</code> is a trivial function that returns a scalar logical result
essentially for any object that inherits from character, though this check
may become more specific in the future.
</p>
<p><code>as_lyrics()</code> can be used to coerce to the <code>lyrics</code> class. Coercion will fail
if the string is not lyrical. The <code>lyrics</code> class has its own <code>print()</code> and
<code>summary()</code> methods.
</p>
<p>When <code>format = NULL</code>, the timestep delimiter format is inferred from the
lyrical string input.
</p>


<h3>Value</h3>

<p>depends on the function
</p>


<h3>Examples</h3>

<pre><code class='language-R'># space-delimited lyrics; use periods for timesteps with no lyric
x &lt;- "These are the ly- rics . . . to this song"
is_lyrics(x)
lyrical(x)
as_lyrics(x)

# character vector; empty, period or NA for no lyric
x &lt;- c("These", "are", "the", "ly-", "rics",
       "", ".", NA, "to", "this", "song") #
as_lyrics(x)

# generate empty lyrics object from noteworthy, noteinfo or music object
notes &lt;- as_noteworthy("c d e d c r*3 e g c'")
x &lt;- lyrics_template(notes)
x

x[1:5] &lt;- strsplit("These are the ly- rics", " ")[[1]]
x[9:11] &lt;- c("to", "this", "song")
x

summary(x)

attributes(x)
</code></pre>

<hr>
<h2 id='mainIntervals'>Main musical intervals</h2><span id='topic+mainIntervals'></span>

<h3>Description</h3>

<p>A data frame containing descriptions of the main intervals, simple and
compound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mainIntervals
</code></pre>


<h3>Format</h3>

<p>A data frame with 5 columns and 26 rows
</p>

<hr>
<h2 id='midily'>Convert MIDI to LilyPond file</h2><span id='topic+midily'></span>

<h3>Description</h3>

<p>Convert a MIDI file (<code>.mid</code>) to a LilyPond format (<code>.ly</code>) text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midily(
  midi_file,
  file,
  key = "c",
  absolute = FALSE,
  quantize = NULL,
  explicit = FALSE,
  start_quant = NULL,
  allow_tuplet = c("4*2/3", "8*2/3", "16*2/3"),
  details = FALSE,
  lyric = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midily_+3A_midi_file">midi_file</code></td>
<td>
<p>character, MIDI file (<code>.mid</code>). May include an absolute or
relative path.</p>
</td></tr>
<tr><td><code id="midily_+3A_file">file</code></td>
<td>
<p>LilyPond output file ending in <code>.ly</code>.</p>
</td></tr>
<tr><td><code id="midily_+3A_key">key</code></td>
<td>
<p>key signature, defaults to <code>"c"</code>.</p>
</td></tr>
<tr><td><code id="midily_+3A_absolute">absolute</code></td>
<td>
<p>logical, print absolute pitches (unavailable in current
package version).</p>
</td></tr>
<tr><td><code id="midily_+3A_quantize">quantize</code></td>
<td>
<p>integer, duration, quantize notes on duration.</p>
</td></tr>
<tr><td><code id="midily_+3A_explicit">explicit</code></td>
<td>
<p>logical, print explicit durations.</p>
</td></tr>
<tr><td><code id="midily_+3A_start_quant">start_quant</code></td>
<td>
<p>integer, duration, quantize note starts on the duration.</p>
</td></tr>
<tr><td><code id="midily_+3A_allow_tuplet">allow_tuplet</code></td>
<td>
<p>character vector, allow tuplet durations. See details.</p>
</td></tr>
<tr><td><code id="midily_+3A_details">details</code></td>
<td>
<p>logical, print additional information to console.</p>
</td></tr>
<tr><td><code id="midily_+3A_lyric">lyric</code></td>
<td>
<p>logical, treat all text as lyrics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under development/testing. See warning and details below.
</p>
<p>This function is a wrapper around the <code>midi2ly()</code> command line utility
provided by LilyPond. It inherits all the limitations thereof.
LilyPond is not intended to be used to produce meaningful sheet music from
arbitrary MIDI files.
While <code><a href="#topic+lilypond">lilypond()</a></code> converts R code <code>score()</code> objects to LilyPond markup
directly, MIDI conversion to LilyPond markup by <code>midily()</code> requires LilyPond.
</p>
<p>WARNING: Even though the purpose of the command line utility is to convert
an existing MIDI file to a LilyPond file, it nevertheless generates a
LilyPond file that <em>specifies inclusion of MIDI output</em>.
This means when you subsequently process the LilyPond file with LilyPond or
if you use <code>miditab()</code> to go straight from your MIDI file to pdf output,
the command line tool will also produce a MIDI file output. It will
overwrite your original MIDI file if it has the same file name and location!
</p>
<p><code>allow_tuplets = NULL</code> to disallow all tuplets. Fourth, eighth and sixteenth
note triplets are allowed. The format is a character vector where each
element is <code>duration*numerator/denominator</code>, no spaces. See default argument.
</p>
<p>On Windows systems, it may be necessary to specify a path in <code><a href="#topic+tabr_options">tabr_options()</a></code>
to both <code>midi2ly</code> and <code>python</code> if they are not already added to the system
PATH variable.
</p>


<h3>Value</h3>

<p>nothing returned; a file is written.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+miditab">miditab()</a></code>, <code><a href="#topic+tab">tab()</a></code>, <code><a href="#topic+lilypond">lilypond()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(tabr_options()$midi2ly != ""){
  midi &lt;- system.file("example.mid", package = "tabr")
  outfile &lt;- file.path(tempdir(), "out.ly")
  midily(midi, outfile) # requires LilyPond installation
}

## End(Not run)
</code></pre>

<hr>
<h2 id='miditab'>Convert MIDI to tablature</h2><span id='topic+miditab'></span>

<h3>Description</h3>

<p>Convert a MIDI file to  sheet music/guitar tablature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miditab(midi_file, file, keep_ly = FALSE, details = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miditab_+3A_midi_file">midi_file</code></td>
<td>
<p>character, MIDI file (<code>.mid</code>). May include an absolute
or relative path.</p>
</td></tr>
<tr><td><code id="miditab_+3A_file">file</code></td>
<td>
<p>character, output file ending in .pdf or .png.</p>
</td></tr>
<tr><td><code id="miditab_+3A_keep_ly">keep_ly</code></td>
<td>
<p>logical, keep LilyPond file.</p>
</td></tr>
<tr><td><code id="miditab_+3A_details">details</code></td>
<td>
<p>logical, set to <code>TRUE</code> to print LilyPond log output to
console. Windows only.</p>
</td></tr>
<tr><td><code id="miditab_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+midily">midily()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under development/testing. See warning and details below.
</p>
<p>Convert a MIDI file to a pdf or png music score using the LilyPond music
engraving program.
Output format is inferred from <code>file</code> extension. This function is a wrapper
around <code><a href="#topic+midily">midily()</a></code>, the function that converts the MIDI file to a LilyPond
(<code>.ly</code>) file using a LilyPond command line utility.
</p>
<p>WARNING: Even though the purpose of the command line utility is to convert
an existing MIDI file to a LilyPond file, it nevertheless generates a
LilyPond file that <em>specifies inclusion of MIDI output</em>.
This means when you subsequently process the LilyPond file with LilyPond or
if you use <code>miditab()</code> to go straight from your MIDI file to pdf output,
the command line tool will also produce a MIDI file output. It will
overwrite your original MIDI file if it has the same file name and location!
</p>
<p>On Windows systems, it may be necessary to specify a path in <code><a href="#topic+tabr_options">tabr_options()</a></code>
to both <code>midi2ly</code> and <code>python</code> if they are not already added to the system
PATH variable.
</p>


<h3>Value</h3>

<p>nothing returned; a file is written.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+midily">midily()</a></code>, <code><a href="#topic+tab">tab()</a></code>, <code><a href="#topic+lilypond">lilypond()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if(tabr_options()$midi2ly != ""){
  midi &lt;- system.file("example.mid", package = "tabr")
  outfile &lt;- file.path(tempdir(), "out.pdf")
  miditab(midi, outfile, details = FALSE) # requires LilyPond installation
}

## End(Not run)
</code></pre>

<hr>
<h2 id='mode-helpers'>Mode helpers</h2><span id='topic+mode-helpers'></span><span id='topic+modes'></span><span id='topic+is_mode'></span><span id='topic+mode_rotate'></span><span id='topic+mode_modern'></span><span id='topic+mode_ionian'></span><span id='topic+mode_dorian'></span><span id='topic+mode_phrygian'></span><span id='topic+mode_lydian'></span><span id='topic+mode_mixolydian'></span><span id='topic+mode_aeolian'></span><span id='topic+mode_locrian'></span>

<h3>Description</h3>

<p>Helper functions for working with musical modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modes(mode = c("all", "major", "minor"))

is_mode(notes, ignore_octave = FALSE)

mode_rotate(notes, n = 0, ignore_octave = FALSE)

mode_modern(
  mode = "ionian",
  key = "c",
  collapse = FALSE,
  ignore_octave = FALSE
)

mode_ionian(key = "c", collapse = FALSE, ignore_octave = FALSE)

mode_dorian(key = "c", collapse = FALSE, ignore_octave = FALSE)

mode_phrygian(key = "c", collapse = FALSE, ignore_octave = FALSE)

mode_lydian(key = "c", collapse = FALSE, ignore_octave = FALSE)

mode_mixolydian(key = "c", collapse = FALSE, ignore_octave = FALSE)

mode_aeolian(key = "c", collapse = FALSE, ignore_octave = FALSE)

mode_locrian(key = "c", collapse = FALSE, ignore_octave = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode-helpers_+3A_mode">mode</code></td>
<td>
<p>character, which mode.</p>
</td></tr>
<tr><td><code id="mode-helpers_+3A_notes">notes</code></td>
<td>
<p>character, for mode, may be a noteworthy string of seven notes,
space- or vector-delimited.</p>
</td></tr>
<tr><td><code id="mode-helpers_+3A_ignore_octave">ignore_octave</code></td>
<td>
<p>logical, strip octave numbering from modes not rooted
on C.</p>
</td></tr>
<tr><td><code id="mode-helpers_+3A_n">n</code></td>
<td>
<p>integer, degree of rotation.</p>
</td></tr>
<tr><td><code id="mode-helpers_+3A_key">key</code></td>
<td>
<p>character, key signature.</p>
</td></tr>
<tr><td><code id="mode-helpers_+3A_collapse">collapse</code></td>
<td>
<p>logical, collapse result into a single string ready for
phrase construction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For valid key signatures, see <code><a href="#topic+keys">keys()</a></code>.
</p>
<p>Modern modes based on major scales are available by key signature using the
<code style="white-space: pre;">&#8288;mode_*&#8288;</code> functions. The seven modes can be listed with <code>modes</code>.
Noteworthy strings of proper length can be checked to match against a mode
with <code>is_mode()</code>.
Modes can be rotated with <code>mode_rotate()</code>, a wrapper around <code>note_rotate()</code>.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>See Also</h3>

<p><code><a href="#topic+keys">keys()</a></code>, <code><a href="#topic+scale-helpers">scale-helpers()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modes()
mode_dorian("c")
mode_modern("dorian", "c")
mode_modern("dorian", "c", ignore_octave = TRUE)

identical(mode_rotate(mode_ionian("c"), 1), mode_dorian("d"))
identical(
  mode_rotate(mode_ionian("c", ignore_octave = TRUE), 1),
  mode_dorian("d", ignore_octave = TRUE)
)

x &lt;- sapply(modes(), mode_modern, ignore_octave = TRUE)
setNames(data.frame(t(x)), as.roman(1:7))
</code></pre>

<hr>
<h2 id='music'>Create music objects and check music string validity</h2><span id='topic+music'></span><span id='topic+musical'></span><span id='topic+as_music'></span><span id='topic+is_music'></span><span id='topic+music_split'></span>

<h3>Description</h3>

<p>Check whether a string is comprised exclusively of valid syntax for music
strings. A music object can be built from such a string. It combines a
noteworthy string and a note info string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>musical(x)

as_music(
  notes,
  info = NULL,
  lyrics = NA,
  key = "c",
  time = "4/4",
  tempo = "2 = 60",
  accidentals = NULL,
  format = NULL,
  labels = NULL,
  at = seq_along(labels)
)

is_music(x)

music_split(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="music_+3A_x">x</code></td>
<td>
<p>character or music, a string to be coerced or an existing music
object.</p>
</td></tr>
<tr><td><code id="music_+3A_notes">notes</code>, <code id="music_+3A_info">info</code></td>
<td>
<p>noteworthy and note info strings. For <code>as_music()</code>, a
complete music string is assumed for <code>notes</code> when <code>info = NULL</code>.</p>
</td></tr>
<tr><td><code id="music_+3A_lyrics">lyrics</code></td>
<td>
<p>optional <code>lyrics</code> object or <code>NA</code>, attached to output as an
attribute.</p>
</td></tr>
<tr><td><code id="music_+3A_key">key</code></td>
<td>
<p>character, store the key signature as a music attribute. Defaults
to <code>"c"</code>. See details.</p>
</td></tr>
<tr><td><code id="music_+3A_time">time</code></td>
<td>
<p>character, store the time signature as a music attribute.
Defaults to <code>"4/4"</code>. See details.</p>
</td></tr>
<tr><td><code id="music_+3A_tempo">tempo</code></td>
<td>
<p>character or <code>NA</code>, defaults to <code>"2 = 60"</code>. See details.</p>
</td></tr>
<tr><td><code id="music_+3A_accidentals">accidentals</code></td>
<td>
<p><code>NULL</code> or character, represent accidentals, <code>"flat"</code> or
<code>"sharp"</code>.</p>
</td></tr>
<tr><td><code id="music_+3A_format">format</code></td>
<td>
<p><code>NULL</code> or character, the timestep delimiter format, <code>"space"</code>
or <code>"vector"</code>.</p>
</td></tr>
<tr><td><code id="music_+3A_labels">labels</code></td>
<td>
<p>character, text annotations to attach to timesteps using
<code>notate</code>.</p>
</td></tr>
<tr><td><code id="music_+3A_at">at</code></td>
<td>
<p>integer, timesteps for <code>labels</code>, defaults to starting from
time one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With note info strings, you are required to enter something at every
timestep, even if it is only the duration. This makes sense because if you
do not enter something, there is simply no indication of a timestep.
A nice feature of music strings is that explicit timesteps are achieved
just by having notes present, allowing you to leave out durations entirely
when they repeat, inheriting them from the previous timestep where duration
was given explicitly. There is no need to enter the same number across
consecutive timesteps; the first will suffice and the rest are automatically
filled in for you when the object is constructed.
</p>
<p><code>musical()</code> returns a scalar logical result indicating whether all timesteps
contain exclusively valid entries.
</p>
<p><code>as_music()</code> can be used to coerce to the <code>music</code> class. Coercion will fail
if the string is not musical. The <code>music</code> class has its own <code>print()</code> and
<code>summary()</code> methods. <code>music</code> objects are primarily intended to represent an
aggregation of a <code>noteworthy</code> object and a <code>noteinfo</code>. You can optionally
fold in a <code>lyrics</code> object as well. However, for music data analysis, any
operations will involve first splitting the object into its component parts.
The value of this class is for the more efficient data entry it provides.
</p>
<p>When <code>accidentals</code> or <code>format</code> are <code>NULL</code>, these settings are inferred from
the musical string input. When mixed formats are present, flats are the
default for accidentals.
</p>
<p>Other attributes are attached to a <code>music</code> object. <code>key</code> uses the <code>tabr</code>
syntax, e.g., <code>"c"</code>, <code>"b_"</code>, <code>"f#m"</code>, etc. <code>time</code> and <code>tempo</code> use the
LilyPond string format. For music programming and analysis, <code>key</code>, <code>time</code> and
<code>tempo</code> can most likely be ignored. They are primarily relevant when
rendering a music snippet directly from a <code>music</code> object with LilyPond.
These additional attributes provide more complete context for the rendered
sheet music.
</p>
<p>If you plan to render music snippets from a <code>music</code> object that you are
defining from a new character string, and the context you have in mind is a
stringed and fretted instrument like guitar, you can specify string numbers
at the end of each timestep with numbers following a semicolon delimiter.
This would still precede any <code>*</code> timestep multiplier number. See examples.
</p>
<p>Note that if you convert a music object to a phrase object, you are changing
contexts. The phrase object is the simplest LilyPond-format music structure.
Coercion with <code>phrase()</code> strips all attributes of a music object and
retains only notes, note info and string numbers.
</p>


<h3>Value</h3>

<p>depends on the function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+music-helpers">music-helpers()</a></code>, <code><a href="#topic+note-checks">note-checks()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>,
<code><a href="#topic+note-summaries">note-summaries()</a></code>, <code><a href="#topic+note-coerce">note-coerce()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># note durations inherit from previous timestep if missing
x &lt;- "a#4-+ b_[staccato] c,x d''t8( e)( g_')- a4 c,e_,g, ce_g4. a~8 a1"
is_music(x)
musical(x)
x &lt;- as_music(x)
is_music(x)
x

y &lt;- lyrics_template(x)
y[3:8] &lt;- strsplit("These are some song ly- rics", " ")[[1]]
y

x &lt;- as_music(x, lyrics = y, accidentals = "sharp")
summary(x)

# Starting string = 5: use ';5'. Carries over until an explicit change.
x &lt;- "a,4;5*5 b,4-+ c4[staccato] cgc'e'~4 cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51"
x &lt;- as_music_df(as_music(x))
x$string
</code></pre>

<hr>
<h2 id='music-helpers'>Accessing music object values and attributes</h2><span id='topic+music-helpers'></span><span id='topic+music_notes'></span><span id='topic+music_info'></span><span id='topic+music_strings'></span><span id='topic+music_key'></span><span id='topic+music_time'></span><span id='topic+music_tempo'></span><span id='topic+music_lyrics'></span>

<h3>Description</h3>

<p>Helper functions for accessing music object values and attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>music_notes(x)

music_info(x)

music_strings(x)

music_key(x)

music_time(x)

music_tempo(x)

music_lyrics(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="music-helpers_+3A_x">x</code></td>
<td>
<p>music object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that while lyrics always shows as an attribute even when <code>NA</code>, <code>strings</code>
is completely absent as a value if it was not part of the object construction
from a new character string.
</p>


<h3>Value</h3>

<p>depends on the function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+music">music()</a></code>, <code><a href="#topic+note-checks">note-checks()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>, <code><a href="#topic+note-summaries">note-summaries()</a></code>,
<code><a href="#topic+note-coerce">note-coerce()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Starting string = 5: use ';5'. Carries over until an explicit change.
x &lt;- "a,4;5*5 b,4- c4 cgc'e'~4 cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51"
x &lt;- as_music(x)

y &lt;- lyrics_template(x)
y[3:8] &lt;- strsplit("These are some song ly- rics", " ")[[1]]
y

x &lt;- as_music(x, lyrics = y)

attributes(x)

music_split(x)

music_notes(x)
music_info(x)
music_key(x)
music_time(x)
music_tempo(x)
music_lyrics(x)
music_strings(x)
</code></pre>

<hr>
<h2 id='n_measures'>Summarize rhythm and time of music objects</h2><span id='topic+n_measures'></span><span id='topic+n_beats'></span><span id='topic+steps_per_measure'></span><span id='topic+bpm'></span><span id='topic+seconds'></span><span id='topic+seconds_per_measure'></span><span id='topic+seconds_per_step'></span><span id='topic+steps_start_time'></span>

<h3>Description</h3>

<p>These functions assist with summarizing temporal data for music objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_measures(x)

n_beats(x, unit = 4)

steps_per_measure(x)

bpm(x, unit = 4, tempo = NULL)

seconds(x, tempo = NULL)

seconds_per_measure(x, tempo = NULL)

seconds_per_step(x, tempo = NULL)

steps_start_time(x, tempo = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_measures_+3A_x">x</code></td>
<td>
<p>note info or music object.</p>
</td></tr>
<tr><td><code id="n_measures_+3A_unit">unit</code></td>
<td>
<p>character, or an equivalent integer. A beat unit. See details.</p>
</td></tr>
<tr><td><code id="n_measures_+3A_tempo">tempo</code></td>
<td>
<p>character, LilyPond format tempo, e.g., &quot;4 = 120&quot; is 120
quarter note beats per minute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions also work with the simpler <code>noteinfo</code> class, though some
functions require you to provide additional arguments.
</p>
<p>Functions that deal with real time require a known tempo, which music
objects have. The simpler note info object does not contain this information.
You can provide a value to the <code>tempo</code> argument of such functions. This
overrides the tempo of <code>x</code> if a music object. But the reason to use
<code>tempo</code> is to provide one when <code>x</code> is a note info object.
By default <code>tempo = NULL</code>, in which case it will derive the value from
the music object or return an error for note info objects.
</p>
<p><code>n_measures()</code> gives the total number of measures covered by all timesteps.
Functions providing the number of beats and beats per minute both take a
<code>unit</code>, defaulting to 4 for quarter note beats. The unit can be any even
beat, triplet beat, dotted, or double dotted beat, from <code>"t32"</code> up to 1.
</p>
<p>The number of timesteps starting in each measure is obtained with
<code>steps_per_measure()</code>.
</p>


<h3>Value</h3>

<p>depends on function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- notate("t8x", "Start here")
notes &lt;- "a, b, c d e f g# a r ac'e' a c' e' c' r*3 ac'e'~ ac'e'"
info &lt;- paste(a, "t8x t8-. 16 4.. 16- 16 2^ 2 4. 8( 4)( 4) 8*4 1 1")
info &lt;- as_noteinfo(info)
x &lt;- as_music(notes, info)

n_measures(info) # fraction indicates incomplete final measure
n_measures(x)

n_beats(x)
n_beats(x, 1)
n_beats(x, "t16")

bpm(x)
bpm(x, "t8")

seconds(x)
seconds(info, "4 = 120")
seconds(info, "2 = 60")
seconds(x, "4 = 100")

steps_per_measure(x)
seconds_per_measure(x)
seconds_per_step(x)
steps_start_time(x)
</code></pre>

<hr>
<h2 id='notate'>Add text to music staff</h2><span id='topic+notate'></span>

<h3>Description</h3>

<p>Annotate a music staff, vertically aligned above or below the music staff at
a specific note/time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>notate(x, text, position = "top")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="notate_+3A_x">x</code></td>
<td>
<p>character.</p>
</td></tr>
<tr><td><code id="notate_+3A_text">text</code></td>
<td>
<p>character.</p>
</td></tr>
<tr><td><code id="notate_+3A_position">position</code></td>
<td>
<p>character, top or bottom.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function binds text annotation in LilyPond syntax to a note's
associated <code>info</code> entry.
Technically, the syntax is a hybrid form, but is later updated safely and
unambiguously to LilyPond syntax with respect to the rest of the note info
substring when it is fed to <code>phrase()</code> for musical phrase assembly.
</p>


<h3>Value</h3>

<p>a character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>notate("8", "Solo")
phrase("c'~ c' d' e'", pc(notate(8, "First solo"), "8 8 4."), "5 5 5 5")
</code></pre>

<hr>
<h2 id='note_ngram'>Note/chord n-gram</h2><span id='topic+note_ngram'></span>

<h3>Description</h3>

<p>Convert a noteworthy string to a list of noteworthy n-grams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>note_ngram(notes, n = 2, tally = FALSE, rests = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="note_ngram_+3A_notes">notes</code></td>
<td>
<p>a noteworthy string.</p>
</td></tr>
<tr><td><code id="note_ngram_+3A_n">n</code></td>
<td>
<p>Number of grams. Must be &gt;= 1 and &lt;= number of timesteps in
<code>notes</code>.</p>
</td></tr>
<tr><td><code id="note_ngram_+3A_tally">tally</code></td>
<td>
<p>logical, tally n-grams in a data frame. Otherwise a list.</p>
</td></tr>
<tr><td><code id="note_ngram_+3A_rests">rests</code></td>
<td>
<p>logical, exclude rests. Affects the number of timesteps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of noteworthy objects or a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_noteworthy("c r ceg dfa ceg dfa")
note_ngram(x)
(x &lt;- note_ngram(x, tally = TRUE))
x$ngram &lt;- as.character(x$ngram)
x
</code></pre>

<hr>
<h2 id='note_slice'>Slice, sort, rotate, shift and arpeggiate notes</h2><span id='topic+note_slice'></span><span id='topic+note_sort'></span><span id='topic+note_rotate'></span><span id='topic+note_shift'></span><span id='topic+note_arpeggiate'></span>

<h3>Description</h3>

<p>Helper functions for indexing and moving notes within noteworthy strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>note_slice(notes, ...)

note_sort(notes, decreasing = FALSE)

note_rotate(notes, n = 0)

note_shift(notes, n = 0)

note_arpeggiate(notes, n = 0, step = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="note_slice_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string, space-delimited or vector of
individual entries.</p>
</td></tr>
<tr><td><code id="note_slice_+3A_...">...</code></td>
<td>
<p>For <code>note_slice()</code>, an integer or logical vector.</p>
</td></tr>
<tr><td><code id="note_slice_+3A_decreasing">decreasing</code></td>
<td>
<p>logical, short in decreasing order.</p>
</td></tr>
<tr><td><code id="note_slice_+3A_n">n</code></td>
<td>
<p>integer, number of rotations or extensions of note sequence. See
details.</p>
</td></tr>
<tr><td><code id="note_slice_+3A_step">step</code></td>
<td>
<p>integer, number of semitone steps from the first (or last) note
in <code>notes</code> at which to begin repeating the shifted <code>notes</code> sequence as an
arpeggio. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>note_slice()</code> subsets the timesteps of a noteworthy string by integer index
or logical vector of length equal to the number of timesteps.
</p>
<p><code>note_sort()</code> sorts the timesteps of a noteworthy string by pitch. When a tie
exists by root note, the next note in chords are compared, if they exist.
For example, <code style="white-space: pre;">&#8288;a,&#8288;</code> sorts lower than <code style="white-space: pre;">&#8288;a,ce&#8288;</code>.
</p>
<p><code>note_rotate()</code> simply rotates anything space-delimited or vectorized in
place. It allows chords. Octave numbering is ignored if present.
</p>
<p>For <code>note_shift()</code> the entire sequence is shifted up or down in pitch, as if
inverting a broken chord. If <code>notes</code> contains chords, they are broken into
successive notes. Then all notes are ordered by pitch. Finally shifting
occurs.
</p>
<p>Instead of a moving window, <code>note_arpeggiate()</code> grows its sequence from the
original set of timesteps by repeating the entire sequence <code>n</code> times (<code>n</code>
must be positive). Each repeated sequence contributing to the arpeggio is
offset by <code>step</code> semitones from the original. <code>step</code> can be negative. It
defaults to 12, increasing all <code>notes</code> by one octave.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "bd'f#' a c'e'g' b ba c'g' gd'g'd''"
note_sort(x)
note_sort(x, decreasing = TRUE)

x &lt;- "e_2 a_, c#f#a#"
note_slice(x, 2:3)
note_slice(x, c(FALSE, TRUE, TRUE))

note_rotate(x, 1)

note_shift("c e g", 1)
note_shift("c e g", -4)

note_arpeggiate("c e g ceg", 3)
note_arpeggiate("c e g", 3, step = -12)
note_arpeggiate("g e c", 3, step = -12)
note_arpeggiate("c e_ g_ a", 3, step = 3)
note_arpeggiate("c a g_ e_", 3, step = -3)
</code></pre>

<hr>
<h2 id='note-checks'>Basic noteworthy string checks</h2><span id='topic+note-checks'></span><span id='topic+note_is_accidental'></span><span id='topic+note_is_natural'></span><span id='topic+note_is_flat'></span><span id='topic+note_is_sharp'></span><span id='topic+note_has_accidental'></span><span id='topic+note_has_natural'></span><span id='topic+note_has_flat'></span><span id='topic+note_has_sharp'></span>

<h3>Description</h3>

<p>The simplest functions for inspecting noteworthy strings to see if their
notes have certain properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>note_is_accidental(notes)

note_is_natural(notes)

note_is_flat(notes)

note_is_sharp(notes)

note_has_accidental(notes)

note_has_natural(notes)

note_has_flat(notes)

note_has_sharp(notes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="note-checks_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that these functions are the weakest in terms of checking
noteworthiness. They are simple regular expression-based wrappers. They are
often used internally by more complex functions without wasting computational
overhead on performing input validity checks, but they are exported from the
package for user convenience. Their results will only make sense on strings
that you define in accordance with noteworthy string rules.
</p>
<p>The <code style="white-space: pre;">&#8288;note_is_*&#8288;</code> functions return a logical vector with length equal to the
number of timesteps in <code>notes</code>. The <code style="white-space: pre;">&#8288;note_has_*&#8288;</code> functions summarize these to
a single logical value.
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>See Also</h3>

<p><code><a href="#topic+note-metadata">note-metadata()</a></code>, <code><a href="#topic+note-summaries">note-summaries()</a></code>, <code><a href="#topic+note-coerce">note-coerce()</a></code>,
<code><a href="#topic+valid-notes">valid-notes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "r a_2 a a#' s"
note_has_accidental(x)
note_has_natural(x)
note_has_flat(x)
note_has_sharp(x)
note_is_accidental(x)
note_is_natural(x)
note_is_flat(x)
note_is_sharp(x)
note_has_tick(x)
note_has_integer(x)
note_is_tick(x)
note_is_integer(x)
note_has_rest(x)
note_is_rest(x)
</code></pre>

<hr>
<h2 id='note-coerce'>Basic noteworthy strings formatting and coercion helpers</h2><span id='topic+note-coerce'></span><span id='topic+naturalize'></span><span id='topic+sharpen_flat'></span><span id='topic+flatten_sharp'></span><span id='topic+note_set_key'></span><span id='topic+as_tick_octaves'></span><span id='topic+as_integer_octaves'></span><span id='topic+as_space_time'></span><span id='topic+as_vector_time'></span><span id='topic+pretty_notes'></span>

<h3>Description</h3>

<p>Helper functions for setting formatting attributes of
noteworthy strings including representation of timesteps, octaves and
accidentals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naturalize(notes, type = c("both", "flat", "sharp"))

sharpen_flat(notes)

flatten_sharp(notes)

note_set_key(notes, key = "c")

as_tick_octaves(notes)

as_integer_octaves(notes)

as_space_time(x)

as_vector_time(x)

pretty_notes(notes, ignore_octave = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="note-coerce_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string, space-delimited or vector of
individual entries.</p>
</td></tr>
<tr><td><code id="note-coerce_+3A_type">type</code></td>
<td>
<p>character, type of note to naturalize.</p>
</td></tr>
<tr><td><code id="note-coerce_+3A_key">key</code></td>
<td>
<p>character, key signature to coerce any accidentals to the
appropriate form for the key. May also specify <code>"sharp"</code> or <code>"flat"</code>.</p>
</td></tr>
<tr><td><code id="note-coerce_+3A_x">x</code></td>
<td>
<p>for generic functions: notes, info or music string.</p>
</td></tr>
<tr><td><code id="note-coerce_+3A_ignore_octave">ignore_octave</code></td>
<td>
<p>logical, strip any octave notation that may be present,
returning only the basic notes without explicit pitch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>sharpen_flat()</code> and <code>flatten_sharp()</code>, sharpening flats and flattening
sharps refer to inverting their respective notation, not to raising or
lowering a flatted or sharped note by one semitone. For the latter, use
<code>naturalize()</code>, which removes flat and/or sharp notation from a string.
<code>note_set_key()</code> is used for coercing a noteworthy string to a specific
and consistent notation for accidentals based on a key signature.
This is a wrapper around <code>sharpen_flat()</code> and <code>flatten_sharp()</code>.
<code>as_tick_octaves()</code>, <code>as_integer_octaves()</code>, <code>as_space_time()</code> and
<code>as_vector_time()</code> similarly affect octave and timestep format.
For simultaneous control over the representation of timesteps, octave
numbering and accidentals, all three are available as arguments to
<code><a href="#topic+as_noteworthy">as_noteworthy()</a></code>.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>A note on generic functions</h3>

<p><code>as_space_time()</code> and <code>as_vector_time()</code> are generic since they apply clearly
to and are useful for not only noteworthy strings, but also note info and
music objects. If <code>x</code> is still a simple character string, these functions
attempt to guess which of the three it is. It is recommended to set the class
before using these functions.
</p>
<p>There are many package functions that operate on noteworthy strings that
could in concept work on music objects, but the expectation is that sound
and time/info are disentangled.
The music class is convenient for data entry, e.g., for transcription
purposes, but it is not sensible to perform data analysis with quantities
like pitch and time tightly bound together. This would only lead to
repetitive deconstructions and reconstructions of music class objects. Most
functions that operate on noteworthy strings or note info strings strictly
apply to one or the other. Generic functions are reserved for only the most
fundamental and generally applicable metadata retrieval and format coercion.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+note-checks">note-checks()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>, <code><a href="#topic+note-summaries">note-summaries()</a></code>,
<code><a href="#topic+valid-notes">valid-notes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "e_2 a_, b_, c#f#a# c#'f#'a#''"
note_set_key(x, "f")
note_set_key(x, "g")
as_tick_octaves(x)
as_integer_octaves(x)
y &lt;- as_vector_time(x)
is_vector_time(y)
is_space_time(as_space_time(y))

naturalize(x)
naturalize(x, "sharp")
sharpen_flat(x)
flatten_sharp(x)
pretty_notes(x)
</code></pre>

<hr>
<h2 id='note-equivalence'>Note, pitch and chord equivalence</h2><span id='topic+note-equivalence'></span><span id='topic+note_is_equal'></span><span id='topic+note_is_identical'></span><span id='topic+pitch_is_equal'></span><span id='topic+pitch_is_identical'></span><span id='topic+octave_is_equal'></span><span id='topic+octave_is_identical'></span>

<h3>Description</h3>

<p>Helper functions to check the equivalence of two noteworthy strings, and
other related functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>note_is_equal(notes1, notes2, ignore_octave = TRUE)

note_is_identical(notes1, notes2, ignore_octave = TRUE)

pitch_is_equal(notes1, notes2)

pitch_is_identical(notes1, notes2)

octave_is_equal(notes1, notes2)

octave_is_identical(notes1, notes2, single_octave = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="note-equivalence_+3A_notes1">notes1</code></td>
<td>
<p>character, noteworthy string, space-delimited or vector of
individual entries.</p>
</td></tr>
<tr><td><code id="note-equivalence_+3A_notes2">notes2</code></td>
<td>
<p>character, noteworthy string, space-delimited or vector of
individual entries.</p>
</td></tr>
<tr><td><code id="note-equivalence_+3A_ignore_octave">ignore_octave</code></td>
<td>
<p>logical, ignore octave position when considering
equivalence.</p>
</td></tr>
<tr><td><code id="note-equivalence_+3A_single_octave">single_octave</code></td>
<td>
<p>logical, for octave equality, require all notes share
the same octave. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Noteworthy strings may contain notes, pitches and chords. Noteworthy strings
are equal if they sound the same.
This means that if one string contains Eb (<code>e_</code>) and the other contains
D# (<code>d#</code>) then the two strings may be equal, but they are not identical.
</p>
<p><code>pitch_is_equal()</code> and <code>pitch_is_identical()</code> perform these respective
tests of equivalence on both notes and chords.
These are the strictest functions in terms of equivalent sound because pitch
includes the octave number.
</p>
<p><code>note_is_equal()</code> and <code>note_is_identical()</code> are similar but include a default
argument <code>ignore_octave = TRUE</code>, focusing only on the notes and chords.
This allows an even more relaxed definition of equivalence. Setting this
argument to <code>FALSE</code> is the same as calling the <code style="white-space: pre;">&#8288;pitch_is_*&#8288;</code> variant.
</p>
<p>Chords can be checked the same as notes. Every timestep in the sequence is
checked pairwise between <code>note1</code> and <code>note2</code>.
</p>
<p>These functions will return <code>TRUE</code> or <code>FALSE</code> for every timestep
in a sequence.
If the two noteworthy strings do not contain the same number of notes at a
specific step, such as a single note compared to a chord, this yields a
<code>FALSE</code> value,
even in a case of an octave dyad with octave number ignored.
If the two sequences have unequal length <code>NA</code> is returned.
These are bare minimum requirements for equivalence. See examples.
</p>
<p><code>octave_is_equal()</code> and <code>octave_is_identical()</code> allow much weaker forms of
equivalence in that they ignore notes completely. These functions are only
concerned with comparing the octave numbers spanned by any pitches present at
each timestep. When checking for equality, <code>octave_is_equal()</code> only looks at
the octave number associated with the first note at each step, e.g., only the
root note of a chord. <code>octave_is_identical()</code> compares all octaves spanned at
a given timestep.
</p>
<p>It does not matter when comparing two chords that they may be comprised of a
different numbers of notes.
If the set of unique octaves spanned by one chord is identical to the set
spanned by the other, they are considered to have identical octave coverage.
For example, <code>a1b2c3</code> is identical to <code>d1e1f2g3</code>. To be equal, it
only matters that the two chords begin with <code>x1</code>, where <code>x</code> is any
note.
Alternatively, for <code>octave_is_identical()</code> only, setting
<code>single_octave = TRUE</code> additionally requires that all notes from both
chords being compared at a given timestep share a single octave.
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "b_2 ce_g"
y &lt;- "b_ cd#g"
note_is_equal(x, y)
note_is_identical(x, y)

x &lt;- "b_2 ce_g"
y &lt;- "b_2 cd#g"
pitch_is_equal(x, y)
pitch_is_identical(x, y)

# same number of same notes, same order: unequal sequence length
x &lt;- "b_2 ce_g b_"
y &lt;- "b_2 ce_gb_"
note_is_equal(x, y)

# same number of same notes, order, equal length: unequal number per timestep
x &lt;- "b_2 ce_g b_"
y &lt;- "b_2 ce_ gb_"
note_is_equal(x, y)

x &lt;- "a1 b_2 a1b2c3 a1b4 g1a1b1"
y &lt;- "a_2 g#2 d1e1f2g3 a1b2b4 d1e1"
octave_is_equal(x, y)
octave_is_identical(x, y)
octave_is_identical(x, y, single_octave = TRUE)
</code></pre>

<hr>
<h2 id='note-logic'>Relational operators for noteworthy class</h2><span id='topic+note-logic'></span><span id='topic++3D+3D.noteworthy'></span><span id='topic++21+3D.noteworthy'></span><span id='topic++3C.noteworthy'></span><span id='topic++3C+3D.noteworthy'></span><span id='topic++3E.noteworthy'></span><span id='topic++3E+3D.noteworthy'></span>

<h3>Description</h3>

<p>Relational operators for comparing two noteworthy class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'noteworthy'
e1 == e2

## S3 method for class 'noteworthy'
e1 != e2

## S3 method for class 'noteworthy'
e1 &lt; e2

## S3 method for class 'noteworthy'
e1 &lt;= e2

## S3 method for class 'noteworthy'
e1 &gt; e2

## S3 method for class 'noteworthy'
e1 &gt;= e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="note-logic_+3A_e1">e1</code></td>
<td>
<p>noteworthy string.</p>
</td></tr>
<tr><td><code id="note-logic_+3A_e2">e2</code></td>
<td>
<p>noteworthy string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equality is assessed in the same manner as used for <code><a href="#topic+note_sort">note_sort()</a></code> when
sorting pitches. What matters is the underlying semitone value associated
with each pitch, not the string notation such as flat vs. sharp (see
<code><a href="#topic+pitch_is_identical">pitch_is_identical()</a></code>). When comparing chords, or a chord vs. a single note,
comparison favors the root. Comparison is made of the respective lowest
pitches, then proceeds to the next pitch if equal.
</p>
<p>For these operators, the objects on the left and right side of the operator
must both be <code>noteworthy</code> or an error is returned.
</p>
<p>The examples include a chord with its pitches entered out of pitch order.
This does not affect the results because pitches within chords are sorted
before note to note comparisons at each timestep are done between <code>e1</code> and
<code>e2</code>.
</p>


<h3>Value</h3>

<p>logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as_noteworthy("f# a d'f#'a' d'f#'a'")
y &lt;- as_noteworthy("g_ b f#'a'd' d'd''")
x == y
x != y
x &lt; y
x &gt; y
x &lt;= y
x &gt;= y
</code></pre>

<hr>
<h2 id='note-metadata'>Noteworthy string metadata</h2><span id='topic+note-metadata'></span><span id='topic+n_steps'></span><span id='topic+n_notes'></span><span id='topic+n_chords'></span><span id='topic+n_octaves'></span><span id='topic+chord_size'></span><span id='topic+octave_type'></span><span id='topic+accidental_type'></span><span id='topic+time_format'></span><span id='topic+is_space_time'></span><span id='topic+is_vector_time'></span><span id='topic+note_is_tick'></span><span id='topic+note_is_integer'></span><span id='topic+note_has_tick'></span><span id='topic+note_has_integer'></span><span id='topic+note_is_rest'></span><span id='topic+note_has_rest'></span>

<h3>Description</h3>

<p>Inspect basic metadata for noteworthy strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_steps(x)

n_notes(notes)

n_chords(notes)

n_octaves(notes)

chord_size(notes)

octave_type(notes)

accidental_type(x)

time_format(x)

is_space_time(x)

is_vector_time(x)

note_is_tick(notes)

note_is_integer(notes)

note_has_tick(notes)

note_has_integer(notes)

note_is_rest(notes)

note_has_rest(notes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="note-metadata_+3A_x">x</code></td>
<td>
<p>for generic functions: notes, info or music string.</p>
</td></tr>
<tr><td><code id="note-metadata_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string, space-delimited or vector of
individual entries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions inspect the basic metadata of noteworthy strings.
For functions that perform basic checks on strings, see <code><a href="#topic+note-checks">note-checks()</a></code>.
</p>
<p>The <code style="white-space: pre;">&#8288;n_*&#8288;</code> functions give summary totals of the number of timesteps,
number of individual note (non-chord) timesteps, number of chord time
steps, and the number of distinct octaves present across timesteps.
</p>
<p>Functions pertaining to type or format of a noteworthy string provide
information on how a particular string is defined, e.g. <code>time_format</code>.
Note that the result pertains to true <code>noteworthy</code>-class objects. If
inspecting a standard character string, the result pertains to
post-conversion to the <code>noteworthy</code> class and does not necessarily
reflect what is found in <code>notes</code> verbatim. See examples.
</p>


<h3>Value</h3>

<p>varies by function
</p>


<h3>A note on generic functions</h3>

<p><code>n_steps()</code> and the three time format functions are generic since they
apply clearly to and are useful for not only noteworthy strings, but also
note info, music, and lyrics objects.
If <code>x</code> is still a simple character string, these functions attempt to
guess if it is noteworthy, note info, or music. Lyrics content is arbitrary
so is never considered for a simple character string. Best practice is to
set the class before using these functions anyway.
</p>
<p>There are many package functions that operate on noteworthy strings that
could in concept also work on music objects, but the expectation is that
sound and time/info are disentangled for analysis.
The music class is convenient and relatively efficient data entry, e.g., for
transcription purposes, but it is not sensible to perform data analysis with
quantities like pitch and time tightly bound together in a single string.
This would only lead to repetitive deconstructions and reconstructions of
music class objects.
</p>
<p>The music class is intended to be a transient class such as during data
import, data entry, or data export.
Most functions that operate on noteworthy strings or note info
strings strictly apply to one or the other. Generic functions are reserved
for only the most fundamental and generally applicable metadata retrieval
and format coercion.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tabr-methods">tabr-methods()</a></code>, <code><a href="#topic+note-checks">note-checks()</a></code>, <code><a href="#topic+note-summaries">note-summaries()</a></code>,
<code><a href="#topic+note-coerce">note-coerce()</a></code>, <code><a href="#topic+valid-notes">valid-notes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "e_2 a_, c#f#a#"
n_steps(x)
n_notes(x)
n_chords(x)
n_octaves(x)
chord_size(x)

# Type is mixed in `x` but is inferred under default conversion rules.
# These check `x` once validated and coerced to 'noteworthy' class.
octave_type(x)
accidental_type(x)
# The default is tick octaves and flats
as_noteworthy(x)

time_format(x)
is_space_time(x)
is_vector_time(x)
</code></pre>

<hr>
<h2 id='note-summaries'>Noteworthy string summaries</h2><span id='topic+note-summaries'></span><span id='topic+tally_notes'></span><span id='topic+tally_pitches'></span><span id='topic+octaves'></span><span id='topic+tally_octaves'></span><span id='topic+distinct_notes'></span><span id='topic+distinct_pitches'></span><span id='topic+distinct_octaves'></span><span id='topic+pitch_range'></span><span id='topic+semitone_range'></span><span id='topic+semitone_span'></span><span id='topic+octave_range'></span><span id='topic+octave_span'></span>

<h3>Description</h3>

<p>Basic summary functions for noteworthy strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tally_notes(notes, rests = FALSE)

tally_pitches(notes, rests = FALSE)

octaves(notes)

tally_octaves(notes)

distinct_notes(notes, rests = FALSE)

distinct_pitches(notes, rests = FALSE)

distinct_octaves(notes)

pitch_range(notes)

semitone_range(notes)

semitone_span(notes)

octave_range(notes)

octave_span(notes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="note-summaries_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string, space-delimited or vector of
individual entries.</p>
</td></tr>
<tr><td><code id="note-summaries_+3A_rests">rests</code></td>
<td>
<p>logical, include rests <code>r</code> and silent rests <code>s</code> in tally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide basic summaries of noteworthy strings.
</p>
<p>Returned object depends on the nature of the function. It can be integers,
logical, character. Results can be a vector of equal length of a single
value summary.
</p>
<p>Use the <code style="white-space: pre;">&#8288;tally_*&#8288;</code> and <code style="white-space: pre;">&#8288;distinct_*&#8288;</code> functions specifically for summaries of
unique elements.
</p>
<p><code>distinct_notes()</code> and <code>distinct_pitches()</code> filter a noteworthy string
to its unique elements, respectively. These functions return another
noteworthy string.
</p>
<p><code style="white-space: pre;">&#8288;*_span&#8288;</code> functions are just the size of a range, e.g., <code>semitone_range()</code> and
<code>semitone_span()</code>.
</p>


<h3>Value</h3>

<p>varies by function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+note-checks">note-checks()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>, <code><a href="#topic+note-coerce">note-coerce()</a></code>, <code><a href="#topic+valid-notes">valid-notes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "r s e_2 a_, c#f#a#"
tally_notes(x)
tally_pitches(x)
octaves(x)
tally_octaves(x)
distinct_notes(x)
distinct_pitches(x)
distinct_octaves(x)

pitch_range(x)
semitone_range(x)
semitone_span(x)
octave_range(x)
octave_span(x)
</code></pre>

<hr>
<h2 id='noteinfo'>Note info helpers</h2><span id='topic+noteinfo'></span><span id='topic+info_duration'></span><span id='topic+info_slur_on'></span><span id='topic+info_slur_off'></span><span id='topic+info_slide'></span><span id='topic+info_bend'></span><span id='topic+info_dotted'></span><span id='topic+info_single_dotted'></span><span id='topic+info_double_dotted'></span><span id='topic+info_annotation'></span><span id='topic+info_articulation'></span>

<h3>Description</h3>

<p>Functions for working with note info strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_duration(x)

info_slur_on(x)

info_slur_off(x)

info_slide(x)

info_bend(x)

info_dotted(x)

info_single_dotted(x)

info_double_dotted(x)

info_annotation(x)

info_articulation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noteinfo_+3A_x">x</code></td>
<td>
<p>character, note info string normally accompanying a noteworthy
string for building phrase objects. <code>x</code> may also be a phrase object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a phrase object, there are some parsing limitations such as tuplets
and repeats.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>See Also</h3>

<p><code><a href="#topic+valid-noteinfo">valid-noteinfo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- notate("t8x", "Start here")
notes &lt;- "a, b, c d e f g# a r ac'e' a c' e' c' r*3 ac'e'~ ac'e'"
info &lt;- paste(a, "t8x t8-. 16 4.. 16- 16 2^ 2 4. 8( 4)( 4) 8*4 1 1")
x &lt;- as_music(notes, info)

data.frame(
  duration = info_duration(x),
  slur_on = info_slur_on(x),
  slur_off = info_slur_off(x),
  slide = info_slide(x),
  bend = info_bend(x),
  dotted = info_dotted(x),
  dotted1 = info_single_dotted(x),
  dotted2 = info_double_dotted(x),
  annotation = info_annotation(x),
  articulation = info_articulation(x)
)
</code></pre>

<hr>
<h2 id='phrase'>Create a musical phrase</h2><span id='topic+phrase'></span><span id='topic+p'></span>

<h3>Description</h3>

<p>Create a musical phrase from character strings that define notes, note
metadata, and optionally explicit strings fretted. The latter can be used to
ensure proper tablature layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phrase(notes, info = NULL, string = NULL, bar = NULL)

p(notes, info = NULL, string = NULL, bar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phrase_+3A_notes">notes</code>, <code id="phrase_+3A_info">info</code></td>
<td>
<p>noteworthy and note info strings. When <code>info = NULL</code>,
it is assumed that <code>notes</code> refers to a music object or string formatted
as such.</p>
</td></tr>
<tr><td><code id="phrase_+3A_string">string</code></td>
<td>
<p>space-delimited character string or vector (or integer vector
if simple string numbers). This is an optional argument that specifies which
instrument strings to play for each specific timestep. Otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="phrase_+3A_bar">bar</code></td>
<td>
<p>character or <code>NULL</code> (default). Terminates the phrase with a
bar or bar check. See details. Also see the LilyPond help documentation
on bar notation for all the valid options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A phrase object combines a valid string of notes with a corresponding valid
string of note info. The only required note info is time, but other
information can be included as well. You do not need to input an existing
<code>noteworthy</code> class object and <code>noteinfo</code> class object, but both
inputs must be valid and thus coercible to these classes. This is similar to
how the <code>music</code> class works. The difference with phrase objects is that
they are used to create LilyPond syntax analogous to what a music object
contains.
</p>
<p>Note that if you convert a music object to a phrase object, you are changing
contexts. The phrase object is the simplest LilyPond-format music structure.
Coercion with <code>phrase()</code> strips all attributes of a music object and
retains only notes, note info and string numbers.
</p>
<p>See the help documentation on <code>noteworthy</code>, <code>noteinfo</code>, and
<code>music</code> classes for an understanding of the input data structures.
The function <code>p()</code> is a convenient shorthand wrapper for <code>phrase()</code>.
</p>
<p>If a string is provided to <code>bar</code>, it is interpreted as LilyPond bar
notation. E.g., <code>bar = "|"</code> adds the LilyPond syntax <code style="white-space: pre;">&#8288;\bar "|"&#8288;</code>
to the end of a phrase. If only a bar check is desired, use
<code>bar = TRUE</code>. <code>FALSE</code> is treated as <code>NULL</code> for completeness.
</p>


<h3>Value</h3>

<p>a phrase.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+valid-notes">valid-notes()</a></code>, <code><a href="#topic+valid-noteinfo">valid-noteinfo()</a></code>, <code><a href="#topic+music">music()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phrase("c ec'g' ec'g'", "4- 4 2") # no string arg (not recommended for tabs)
phrase("c ec4g4 ec4g4", "4 4 2") # same as above
phrase("c b, c", "4. 8( 8)", "5 5 5") # direction implies hammer on
phrase("b2 c d", "4( 4)- 2", "5 5 5") # hammer and slide

phrase("c ec'g' ec'g'", "1 1 1", "5 432 432")
p("c ec'g' ec'g'", 1, "5 4 4") # same as above


n &lt;- "a, b, c d e f g e f g a~ a"
i &lt;- "8- 8 8 8-. t8( t8)( t8) t16( t16)( t16) 8 1"
m &lt;- as_music(n, i)

x &lt;- p(n, i)
x
identical(x, p(m))

x &lt;- "a,4;5*5 b,4- c4 cgc'e'~4 cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51"
p(x)
identical(p(x), p(as_music(x)))

x &lt;- p("a b", 2, bar = "|.")
x2 &lt;- pc(p("a b", 2), '\\bar "|."')
identical(x, x2)
</code></pre>

<hr>
<h2 id='phrase-checks'>Phrase validation and coercion</h2><span id='topic+phrase-checks'></span><span id='topic+as_phrase'></span><span id='topic+phrasey'></span><span id='topic+notify'></span><span id='topic+phrase_notes'></span><span id='topic+phrase_info'></span><span id='topic+phrase_strings'></span><span id='topic+notable'></span>

<h3>Description</h3>

<p>These helper functions add some validation checks for phrase and candidate
phrase objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_phrase(phrase)

phrasey(phrase)

notify(phrase)

phrase_notes(phrase, collapse = TRUE)

phrase_info(phrase, collapse = TRUE, annotations = TRUE)

phrase_strings(phrase, collapse = FALSE)

notable(phrase)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phrase-checks_+3A_phrase">phrase</code></td>
<td>
<p>phrase object or character string (candidate phrase).</p>
</td></tr>
<tr><td><code id="phrase-checks_+3A_collapse">collapse</code></td>
<td>
<p>logical, collapse result into a single string ready for
phrase construction.</p>
</td></tr>
<tr><td><code id="phrase-checks_+3A_annotations">annotations</code></td>
<td>
<p>logical, strip any text annotations from the note info
converted from <code>phrase()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use these functions with some caution. They are not intended for strictness
and perfection. <code>phrasey()</code> checks whether an object is weakly phrase-like
and returns <code>TRUE</code> or <code>FALSE</code>. It can be used to safeguard against the most
obvious cases of <code>phrase()</code> not containing valid phrase syntax when
programming. However, it may also be limiting. Use wear sensible.
</p>
<p><code>as_phrase()</code> coerces an object to a phrase object if possible. This function
performs an internal <code>phrasey()</code> check.
</p>
<p><code>notify()</code> attempts to decompose a phrase object back to its original input
vectors consisting of notes, note info, and optionally, instrument string
numbering. If successful, it returns a tibble data frame with columns:
<code>notes</code>, <code>info</code>, <code>string</code>.
</p>
<p>Unless decomposing very simple phrases, this function is likely to reveal
limitations. Complex phrase objects constructed originally with <code>phrase()</code>
can be challenging to deconstruct in a one to one manner. Information may be
lost, garbled, or the function may fail. For example, this function is not
advanced enough to unravel repeat notation or tuplets.
</p>
<p><code>notable()</code> returns <code>TRUE</code> or <code>FALSE</code> regarding whether a phrase can be
converted back to character string inputs, not necessarily with complete
correctness, but without simple failure.It checks for phrasiness. Then it
tries to call <code>notify()</code> and returns <code>FALSE</code> gracefully if that call throws
an exception.
</p>


<h3>Value</h3>

<p>see details for each function's purpose and return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a list of phrase objects
p1 &lt;- phrase("c ec'g' ec'g'", "4 4 2") # no string numbers (not recommended)
p2 &lt;- phrase("c ec4g4 ec4g4", "4 4 2") # same as above
p3 &lt;- phrase("c b, c", "4. 8( 8)", "5 5 5") # direction implies hammer on
p4 &lt;- phrase("b2 c d", "4( 4)- 2", "5 5 5") # hammer and slide
p5 &lt;- phrase("c ec'g'~ ec'g'", 1, "5 432 432") # tied chord
x &lt;- list(p1, p2, p3, p4, p5)

# Check if phrases and strings are phrasey
sapply(x, phrasey)
sapply(as.character(x), phrasey, USE.NAMES = FALSE)

# Coerce character string representation to phrase and compare with original
y &lt;- lapply(as.character(x), as_phrase)
identical(x, y)

# Check if notable
sapply(x, notable)
notable(p("a b c", 1))
notable("a b x") # note: not constructible as a phrase in the first place

# Notify phrases
d &lt;- do.call(rbind, lapply(x, notify))
d

# Wrappers around notify extract components, default to collapsed strings
phrase_notes(p5)
phrase_info(p5)
phrase_strings(p5)

# If phrase decomposition works well, coercion is one to one
x2 &lt;- lapply(x,
  function(x) p(phrase_notes(x), phrase_info(x), phrase_strings(x))
)
identical(x, x2)
</code></pre>

<hr>
<h2 id='pitch_freq'>Pitch conversions</h2><span id='topic+pitch_freq'></span><span id='topic+pitch_semitones'></span><span id='topic+chord_freq'></span><span id='topic+chord_semitones'></span><span id='topic+freq_pitch'></span><span id='topic+freq_semitones'></span><span id='topic+semitone_pitch'></span><span id='topic+semitone_freq'></span>

<h3>Description</h3>

<p>Convert between pitches, chords, semitones and frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pitch_freq(notes, a4 = 440)

pitch_semitones(notes)

chord_freq(notes, a4 = 440)

chord_semitones(notes)

freq_pitch(
  freq,
  octaves = c("tick", "integer"),
  accidentals = c("flat", "sharp"),
  collapse = FALSE,
  a4 = 440
)

freq_semitones(freq, a4 = 440)

semitone_pitch(
  semitones,
  octaves = c("tick", "integer"),
  accidentals = c("flat", "sharp"),
  collapse = FALSE
)

semitone_freq(semitones, a4 = 440)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pitch_freq_+3A_notes">notes</code></td>
<td>
<p>character, noteworthy string, space-delimited or vector of
individual entries. See details.</p>
</td></tr>
<tr><td><code id="pitch_freq_+3A_a4">a4</code></td>
<td>
<p>the fixed frequency of the A above middle C, typically 440 Hz.</p>
</td></tr>
<tr><td><code id="pitch_freq_+3A_freq">freq</code></td>
<td>
<p>numeric vector, frequencies in Hz.</p>
</td></tr>
<tr><td><code id="pitch_freq_+3A_octaves">octaves</code></td>
<td>
<p><code>NULL</code> or character, <code>"tick"</code> or <code>"integer"</code> octave numbering
in result.</p>
</td></tr>
<tr><td><code id="pitch_freq_+3A_accidentals">accidentals</code></td>
<td>
<p><code>NULL</code> or character, represent accidentals, <code>"flat"</code> or
<code>"sharp"</code>.</p>
</td></tr>
<tr><td><code id="pitch_freq_+3A_collapse">collapse</code></td>
<td>
<p>logical, collapse result into a single string. <code>key</code> and
<code>style</code>.</p>
</td></tr>
<tr><td><code id="pitch_freq_+3A_semitones">semitones</code></td>
<td>
<p>integer values of pitches.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Frequencies are in Hertz. Values are based on the 12-tone equal-tempered
scale. When converting an arbitrary frequency to pitch, it is rounded to the
nearest pitch.
<code>pitch_freq()</code> and <code>pitch_semitones()</code> strictly accept single notes in
noteworthy strings and return numeric vectors.
<code>chord_freq()</code> and <code>chord_semitones()</code> accept any noteworthy string and
always return a list. These are provided so that all functions are type-safe.
See examples.
</p>


<h3>Value</h3>

<p>integer, numeric or noteworthy vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "a e4 a4 e5 a5"
y &lt;- pitch_freq(x)
y

freq_semitones(y)
freq_pitch(y)

identical(as_noteworthy(x), freq_pitch(y, "integer", collapse = TRUE))

s &lt;- pitch_semitones(x)
s
semitone_pitch(s)

x &lt;- "a, a,c#e"
chord_semitones(x)
chord_freq(x)
</code></pre>

<hr>
<h2 id='pitch_seq'>Create a sequence from pitch notation</h2><span id='topic+pitch_seq'></span>

<h3>Description</h3>

<p>Create a noteworthy string of a sequence of consecutive pitches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pitch_seq(x, y, key = NULL, scale = NULL, format = c("space", "vector"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pitch_seq_+3A_x">x</code></td>
<td>
<p>character, valid pitch notation, e.g., <code>"a2"</code> or <code>"a,"</code>.</p>
</td></tr>
<tr><td><code id="pitch_seq_+3A_y">y</code></td>
<td>
<p>character, same as <code>x</code> for the sequence <code>x:y</code>. If a number, the
length of the sequence from <code>x</code> and the sign of <code>y</code> determines the direction.</p>
</td></tr>
<tr><td><code id="pitch_seq_+3A_key">key</code></td>
<td>
<p>character, key signature for a diatonic sequence.
<code>key = NULL</code> (default) results in a chromatic sequence.</p>
</td></tr>
<tr><td><code id="pitch_seq_+3A_scale">scale</code></td>
<td>
<p>character, if you want to use a different scale in conjunction
with the key/root note, you can provide it, e.g., <code>scale = "harmonic minor"</code>.
Ignored if <code>key = NULL</code>.</p>
</td></tr>
<tr><td><code id="pitch_seq_+3A_format">format</code></td>
<td>
<p>character, the timestep delimiter format, <code>"space"</code> or
<code>"vector"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all pitches resulting from the defined sequence must be in the
semitone range 0-131 or an error is thrown.
</p>
<p>If not using a chromatic sequence and <code>x</code> (or <code>y</code> if also a pitch) is not
part of the key signature or scale, the sequence is internally bound. See
examples.
</p>
<p>Format of accidentals in the result is prioritized by the scale and key, the
key when no scale is given, then <code>x</code> (and <code>y</code> if also a pitch), and finally
defaults to flats if ambiguous.
</p>


<h3>Value</h3>

<p>noteworthy
</p>


<h3>Examples</h3>

<pre><code class='language-R'># chromatic sequence (default)
pitch_seq("a,", 13)
pitch_seq("c5", -2)
pitch_seq("c", "b")

# diatonic sequence
pitch_seq("c", 8, key = "c")
pitch_seq("c", 8, "am")
pitch_seq("c#,", "a#'", "am")

# combine with alternative scale
pitch_seq("a", 8, "am", "harmonic minor")
</code></pre>

<hr>
<h2 id='plot_fretboard'>Chord and fretboard diagram plots</h2><span id='topic+plot_fretboard'></span><span id='topic+plot_chord'></span>

<h3>Description</h3>

<p>Create a fretboard diagram for a single chord or a general progression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fretboard(
  string,
  fret,
  labels = NULL,
  mute = FALSE,
  label_size = 10,
  label_color = "white",
  point_size = 10,
  point_color = "black",
  point_fill = "black",
  group = NULL,
  horizontal = FALSE,
  left_handed = FALSE,
  fret_range = NULL,
  accidentals = c("flat", "sharp"),
  tuning = "standard",
  show_tuning = FALSE,
  asp = NULL,
  base_size = 20
)

plot_chord(
  chord,
  labels = NULL,
  label_size = 10,
  label_color = "white",
  point_size = 10,
  point_color = "black",
  point_fill = "black",
  group = NULL,
  horizontal = FALSE,
  left_handed = FALSE,
  fret_range = NULL,
  accidentals = c("flat", "sharp"),
  tuning = "standard",
  show_tuning = FALSE,
  asp = NULL,
  base_size = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_fretboard_+3A_string">string</code></td>
<td>
<p>integer or as a space-delimited character string; instrument
string numbers.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_fret">fret</code></td>
<td>
<p>integer or as a space-delimited character string; fret numbers.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_labels">labels</code></td>
<td>
<p>character, optional text labels, must be one for every point.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_mute">mute</code></td>
<td>
<p>logical vector or specific integer indices, which notes to mute.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_label_size">label_size</code></td>
<td>
<p>numeric, size of fretted note labels.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_label_color">label_color</code></td>
<td>
<p>character, label color.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_point_size">point_size</code></td>
<td>
<p>numeric, size of fretted note points.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_point_color">point_color</code></td>
<td>
<p>character, point color.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_point_fill">point_fill</code></td>
<td>
<p>character, point fill color.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_group">group</code></td>
<td>
<p>optional vector to facet by.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_horizontal">horizontal</code></td>
<td>
<p>logical, directional orientation.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_left_handed">left_handed</code></td>
<td>
<p>logical, handedness orientation.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_fret_range">fret_range</code></td>
<td>
<p>fret limits, if not <code>NULL</code>, overrides limits derived
from <code>fret</code>.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_accidentals">accidentals</code></td>
<td>
<p>character, when <code>labels = "notes"</code> represent accidentals:
<code>"flat"</code> or <code>"sharp"</code>.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_tuning">tuning</code></td>
<td>
<p>explicit tuning, e.g., <code>"e, a, d g b e'"</code>, or a pre-defined
tuning. See details.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_show_tuning">show_tuning</code></td>
<td>
<p>logical, show tuning of each string.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_asp">asp</code></td>
<td>
<p>numeric, aspect ratio, overrides default aspect ratio derived
from number of strings and frets.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_base_size">base_size</code></td>
<td>
<p>base size for <code>ggplot2::theme_void()</code>.</p>
</td></tr>
<tr><td><code id="plot_fretboard_+3A_chord">chord</code></td>
<td>
<p>character, a single chord given in fret notation. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are under development and subject to change. They each
return a ggplot object.
</p>
<p>Use <code>plot_chord()</code> to create a fretboard diagram of a specific chord.
<code>plot_chord()</code> accepts a character string in simple fretboard format,
e.g., <code>chord = "xo221o"</code>.
Zero is allowed in place of <code>"o"</code>. This only works when no spaces or
semicolons are detected. The function checks for spaces first, then
semicolons, to split fret numbers.
Do not mix formats. For example, you can use <code>chord = "xo221o"</code>,
<code>chord = "x 8 10 10 9 8"</code> or <code>chord = "x;8;10;10;9;8"</code>.
Trailing delimiters are ignored (LilyPond format: <code>"x;8;10;10;9;8;"</code>).
If there are fewer fret values than there are strings on the instrument, as
inferred from <code>tuning</code>, then muted strings, <code>x</code>, are inferred for
the remaining lower-pitch strings.
</p>
<p><code>plot_fretboard()</code> produces a more general fretboard diagram plot. It is
intended for scales, arpeggios and other patterns along the fretboard. For
this function, provide vectors of string and fret numbers. <code>mute</code> is
available but not as applicable for this function. For single chord diagrams,
use <code>plot_chord()</code>.
</p>
<p>Number of strings is derived from <code>tuning</code>. See <code><a href="#topic+tunings">tunings()</a></code>
for pre-defined tunings and examples of explicit tunings.
<code>tuning</code> affects point labels when <code>labels = "notes"</code>.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># General patterns: scale shifting exercise
string &lt;- c(6, 6, 6, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 2, 2, 2, 1, 1, 1)
fret &lt;- "2 4 5 2 4 5 2 4 6 7 9 6 7 9 7 9 10 7 9 10" # string input accepted
plot_fretboard(string, fret, labels = "notes")

# Single chord diagrams
# open chord
idx &lt;- c(1, 1, 2, 2, 2, 1)
fill &lt;- c("white", "black")[idx]
lab_col &lt;- c("black", "white")[idx]
plot_chord("xo221o", "notes", label_color = lab_col, point_fill = fill)

# moveable chord
plot_chord("355433", horizontal = TRUE, show_tuning = TRUE)

plot_chord("0231") # leading x inferred; same as plot_chord("xxo321")

plot_chord("10 12 13 11", fret_range = c(10, 14))
</code></pre>

<hr>
<h2 id='plot_music'>Plot sheet music snippet with LilyPond</h2><span id='topic+plot_music'></span><span id='topic+plot_music_tc'></span><span id='topic+plot_music_bc'></span><span id='topic+plot_music_tab'></span><span id='topic+plot_music_guitar'></span><span id='topic+plot_music_bass'></span>

<h3>Description</h3>

<p>These functions are wrappers around the <code style="white-space: pre;">&#8288;render_music*&#8288;</code> functions. They
abstract the process of rendering a sheet music snippet to png and loading
the rendered image back into R to be displayed as a plot in an open graphics
device or inserted into an R Markdown code chunk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_music(
  music,
  clef = "treble",
  tab = FALSE,
  tuning = "standard",
  string_names = NULL,
  header = NULL,
  paper = NULL,
  colors = NULL,
  transparent = FALSE,
  res = 300
)

plot_music_tc(
  music,
  header = NULL,
  paper = NULL,
  colors = NULL,
  transparent = FALSE,
  res = 300
)

plot_music_bc(
  music,
  header = NULL,
  paper = NULL,
  colors = NULL,
  transparent = FALSE,
  res = 300
)

plot_music_tab(
  music,
  clef = NA,
  tuning = "standard",
  string_names = NULL,
  header = NULL,
  paper = NULL,
  colors = NULL,
  transparent = FALSE,
  res = 300
)

plot_music_guitar(
  music,
  tuning = "standard",
  string_names = NULL,
  header = NULL,
  paper = NULL,
  colors = NULL,
  transparent = FALSE,
  res = 300
)

plot_music_bass(
  music,
  tuning = "bass",
  string_names = FALSE,
  header = NULL,
  paper = NULL,
  colors = NULL,
  transparent = FALSE,
  res = 300
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_music_+3A_music">music</code></td>
<td>
<p>a music object.</p>
</td></tr>
<tr><td><code id="plot_music_+3A_clef">clef</code></td>
<td>
<p>character, include a music staff with the given clef. <code>NA</code> to
suppress. See <code>track()</code> for details.</p>
</td></tr>
<tr><td><code id="plot_music_+3A_tab">tab</code></td>
<td>
<p>logical, include tablature staff. <code>NA</code> to suppress. See <code>track()</code>.</p>
</td></tr>
<tr><td><code id="plot_music_+3A_tuning">tuning</code></td>
<td>
<p>character, string tuning, only applies to tablature. See
<code>track()</code>.</p>
</td></tr>
<tr><td><code id="plot_music_+3A_string_names">string_names</code></td>
<td>
<p>label strings at beginning of tab staff. <code>NULL</code> (default)
for non-standard tunings only, <code>TRUE</code> or <code>FALSE</code> for force on or off
completely.</p>
</td></tr>
<tr><td><code id="plot_music_+3A_header">header</code></td>
<td>
<p>a named list of arguments passed to the header of the LilyPond
file. See <code>lilypond()</code> details.</p>
</td></tr>
<tr><td><code id="plot_music_+3A_paper">paper</code></td>
<td>
<p>a named list of arguments for the LilyPond file page layout. See
<code>lilypond()</code> details.</p>
</td></tr>
<tr><td><code id="plot_music_+3A_colors">colors</code></td>
<td>
<p>a named list of LilyPond element color global overrides. See
<code>lilypond()</code> for details.</p>
</td></tr>
<tr><td><code id="plot_music_+3A_transparent">transparent</code></td>
<td>
<p>logical, transparent background for intermediate png file.</p>
</td></tr>
<tr><td><code id="plot_music_+3A_res">res</code></td>
<td>
<p>numeric, resolution, png only. Defaults to 300.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While these functions abstract away the details of the process, this is not
the same as making the plot completely in R. R is only displaying the
intermediary png file. LilyPond is required to engrave the sheet music.
</p>
<p>For R Markdown you can alternatively render the png using the corresponding
<code style="white-space: pre;">&#8288;render_music*&#8288;</code> function and then place it in the document explicitly
using <code>knitr::include_graphics()</code>. See <code><a href="#topic+render_music">render_music()</a></code> for more details.
</p>


<h3>Value</h3>

<p>a plot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+render_music">render_music()</a></code>, <code><a href="#topic+phrase">phrase()</a></code>, <code><a href="#topic+track">track()</a></code>, <code><a href="#topic+score">score()</a></code>, <code><a href="#topic+lilypond">lilypond()</a></code>,
<code><a href="#topic+tab">tab()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "a,4;5*5 b,4- c4 cgc'e'~4 cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51"
x &lt;- as_music(x)

y &lt;- "a,,4;3*5 b,,4- c,4 c,g,c~4 c,g,c1 c4;1 g,;2 c,;3 g,;2 c,c1;31"
y &lt;- as_music(y)

## Not run: 
if(tabr_options()$lilypond != ""){ # requires LilyPond installation
  plot_music(x)
  plot_music(x, "treble_8", tab = TRUE)

  plot_music_tc(x)
  plot_music_bc(x)

  plot_music_tab(x)
  plot_music_guitar(x)
  plot_music_bass(y)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='ratio_to_cents'>Convert between chord frequency ratios and cents</h2><span id='topic+ratio_to_cents'></span><span id='topic+cents_to_ratio'></span>

<h3>Description</h3>

<p>Convert between frequency ratios and logarithmic cents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratio_to_cents(x, y = NULL)

cents_to_ratio(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ratio_to_cents_+3A_x">x</code></td>
<td>
<p>a vector of ratios if <code>y = NULL</code>, otherwise frequencies. Cents for
<code>cents_to_ratio()</code>.</p>
</td></tr>
<tr><td><code id="ratio_to_cents_+3A_y">y</code></td>
<td>
<p>if not <code>NULL</code>, frequencies and the ratios are given by <code>y / x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ratio_to_cents(c(0.5, 1, 1.5, 2))
cents_to_ratio(c(-1200, 0, 701.955, 1200))
</code></pre>

<hr>
<h2 id='read_midi'>Read, inspect and convert MIDI file contents</h2><span id='topic+read_midi'></span><span id='topic+midi_metadata'></span><span id='topic+midi_notes'></span><span id='topic+midi_time'></span><span id='topic+midi_key'></span><span id='topic+ticks_to_duration'></span><span id='topic+duration_to_ticks'></span>

<h3>Description</h3>

<p>Read MIDI file into a data frame and inspect the music data with supporting
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_midi(file, ticks_per_qtr = 480)

midi_metadata(x)

midi_notes(x, channel = NULL, track = NULL, noteworthy = TRUE)

midi_time(x)

midi_key(x)

ticks_to_duration(x, ticks_per_qtr = 480)

duration_to_ticks(x, ticks_per_qtr = 480)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_midi_+3A_file">file</code></td>
<td>
<p>character, path to MIDI file.</p>
</td></tr>
<tr><td><code id="read_midi_+3A_ticks_per_qtr">ticks_per_qtr</code></td>
<td>
<p>ticks per quarter note. Used to compute durations from
MIDI file ticks.</p>
</td></tr>
<tr><td><code id="read_midi_+3A_x">x</code></td>
<td>
<p>a data frame returned by <code>read_midi()</code>. An integer vector for
<code>ticks_to_duration()</code>; a character vector (may be a space-delimited string)
for <code>duration_to_ticks()</code>.</p>
</td></tr>
<tr><td><code id="read_midi_+3A_channel">channel</code>, <code id="read_midi_+3A_track">track</code></td>
<td>
<p>integer, filter rows on channel or track.</p>
</td></tr>
<tr><td><code id="read_midi_+3A_noteworthy">noteworthy</code></td>
<td>
<p>logical, convert to <code>noteworthy</code> and <code>noteinfo</code> data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>read_midi()</code> function wraps around <code>tuneR::readMidi()</code> by Uwe Ligges and
Johanna Mielke. <code>midi_notes()</code> is a work in progress, but converts MIDI data
to noteworthy strings and note info formats. This makes it easy to analyze,
transform and edit the music data as well as render it to sheet music and a
new MIDI file.
</p>
<p><code>read_midi()</code> does not parse the ticks per quarter note from the MIDI file
input at this time. It must be specified with <code>ticks_per_qtr</code>.
</p>


<h3>Value</h3>

<p>a tibble data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ticks_to_duration(c(120, 160))
ticks_to_duration(c(128, 192, 512), ticks_per_qtr = 384)
duration_to_ticks(c("t8", "8", "8.", "8.."))
duration_to_ticks(c("t8 8 8. 8.."), ticks_per_qtr = 384)

file &lt;- system.file("example2.mid", package = "tabr")
if(require("tuneR")){
  x &lt;- read_midi(file, ticks_per_qtr = 384)
  midi_metadata(x)
  midi_time(x)
  midi_key(x)
  midi_notes(x, channel = 0, noteworthy = FALSE)

  (x &lt;- midi_notes(x, channel = 0))
  (x &lt;- as_music(x$pitch, x$duration))

  # requires LilyPond installation
  if(tabr_options()$lilypond != ""){
    out &lt;- file.path(tempdir(), "out.pdf")
    phrase(x) |&gt; track_bc() |&gt; score() |&gt; tab(out, details = FALSE)
  }
}
</code></pre>

<hr>
<h2 id='render_chordchart'>Render a chord chart with LilyPond</h2><span id='topic+render_chordchart'></span>

<h3>Description</h3>

<p>Render a standalone chord chart of chord fretboard diagrams with LilyPond
for a set of chords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_chordchart(
  chords,
  file,
  size = 1.2,
  header = NULL,
  paper = NULL,
  colors = NULL,
  crop_png = TRUE,
  transparent = FALSE,
  res = 150,
  keep_ly = FALSE,
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_chordchart_+3A_chords">chords</code></td>
<td>
<p>named character vector of valid formatting for LilyPond chord
names and values. See examples.</p>
</td></tr>
<tr><td><code id="render_chordchart_+3A_file">file</code></td>
<td>
<p>output file.</p>
</td></tr>
<tr><td><code id="render_chordchart_+3A_size">size</code></td>
<td>
<p>numeric, size of fretboard diagrams (relative to paper font
size). Use this to scale diagrams up or down.</p>
</td></tr>
<tr><td><code id="render_chordchart_+3A_header">header</code></td>
<td>
<p>a named list of arguments passed to the header of the
LilyPond file. See details.</p>
</td></tr>
<tr><td><code id="render_chordchart_+3A_paper">paper</code></td>
<td>
<p>a named list of arguments for the LilyPond file page layout.
See details.</p>
</td></tr>
<tr><td><code id="render_chordchart_+3A_colors">colors</code></td>
<td>
<p>reserved; not yet implemented for this function.</p>
</td></tr>
<tr><td><code id="render_chordchart_+3A_crop_png">crop_png</code></td>
<td>
<p>logical, see <code>lilypond()</code> for details.</p>
</td></tr>
<tr><td><code id="render_chordchart_+3A_transparent">transparent</code></td>
<td>
<p>logical, transparent background, png only.</p>
</td></tr>
<tr><td><code id="render_chordchart_+3A_res">res</code></td>
<td>
<p>numeric, resolution, png only. <code>transparent = TRUE</code> may fail when
<code>res</code> exceeds ~150.</p>
</td></tr>
<tr><td><code id="render_chordchart_+3A_keep_ly">keep_ly</code></td>
<td>
<p>logical, keep intermediate LilyPond file.</p>
</td></tr>
<tr><td><code id="render_chordchart_+3A_details">details</code></td>
<td>
<p>logical, set to <code>TRUE</code> to print LilyPond log output to
console. Windows only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a generates a LilyPond template for displaying only a
fretboard diagram chart. It then passes the file to LilyPond for rendering.
To plot specific fretboard diagrams in R using ggplot and with greater
control, use <code>plot_fretboard()</code>.
</p>
<p>The options for <code>paper</code> include the following and have the following
default values if not provided.
</p>

<ul>
<li> <p><code>textheight = 220</code>
</p>
</li>
<li> <p><code>linewidth = 150</code>
</p>
</li>
<li> <p><code>indent = 0</code>
</p>
</li>
<li> <p><code>fontsize = 10</code>
</p>
</li>
<li> <p><code>page_numbers = FALSE</code>
</p>
</li>
<li> <p><code>print_first_page_number = TRUE</code>
</p>
</li>
<li> <p><code>first_page_number = 1</code>
</p>
</li></ul>

<p><code>fontsize</code> only controls the global font size. If you want to scale the
size of the fretboard diagrams up or down use the the <code>size</code> argument
rather than this <code>paper</code> value.
</p>
<p>Note that chord chart output must fit on a single page. If the full set of
chord diagrams does not fit on one page then diagrams will be clipped in the
rendered output. Use <code>size</code> to keep the output to one page or make
multiple sheets separately.
</p>


<h3>Value</h3>

<p>writes files to disk
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_fretboard">plot_fretboard()</a></code>, <code><a href="#topic+lilypond">lilypond()</a></code>,
<code><a href="#topic+tab">tab()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressPackageStartupMessages(library(dplyr))

chords &lt;- filter(
  guitarChords, root %in% c("c", "f") &amp; id %in% c("7", "M7", "m7") &amp;
  !grepl("#", notes) &amp; root_fret &lt;= 12) |&gt;
  arrange(root, id)
chords &lt;- setNames(chords$fretboard, chords$lp_name)
head(chords)

# requires LilyPond installation
if(tabr_options()$lilypond != ""){
  outfile &lt;- file.path(tempdir(), "out.pdf")
  hdr &lt;- list(
    title = "Dominant 7th, major 7th and minor 7th chords",
    subtitle = "C and F root"
  )
  render_chordchart(chords, outfile, 2, hdr, list(textheight = 175))
}
</code></pre>

<hr>
<h2 id='render_music'>Render sheet music snippet with LilyPond</h2><span id='topic+render_music'></span><span id='topic+render_music_tc'></span><span id='topic+render_music_bc'></span><span id='topic+render_music_tab'></span><span id='topic+render_music_guitar'></span><span id='topic+render_music_bass'></span>

<h3>Description</h3>

<p>Render a sheet music/tablature snippet from a music object with LilyPond.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_music(
  music,
  file,
  clef = "treble",
  tab = FALSE,
  tuning = "standard",
  string_names = NULL,
  header = NULL,
  paper = NULL,
  midi = FALSE,
  colors = NULL,
  transparent = FALSE,
  res = 150,
  keep_ly = FALSE,
  simplify = TRUE
)

render_music_tc(
  music,
  file,
  header = NULL,
  paper = NULL,
  midi = FALSE,
  colors = NULL,
  transparent = FALSE,
  res = 150,
  keep_ly = FALSE,
  simplify = TRUE
)

render_music_bc(
  music,
  file,
  header = NULL,
  paper = NULL,
  midi = FALSE,
  colors = NULL,
  transparent = FALSE,
  res = 150,
  keep_ly = FALSE,
  simplify = TRUE
)

render_music_tab(
  music,
  file,
  clef = NA,
  tuning = "standard",
  string_names = NULL,
  header = NULL,
  paper = NULL,
  midi = FALSE,
  colors = NULL,
  transparent = FALSE,
  res = 150,
  keep_ly = FALSE,
  simplify = TRUE
)

render_music_guitar(
  music,
  file,
  tuning = "standard",
  string_names = NULL,
  header = NULL,
  paper = NULL,
  midi = FALSE,
  colors = NULL,
  transparent = FALSE,
  res = 150,
  keep_ly = FALSE,
  simplify = TRUE
)

render_music_bass(
  music,
  file,
  tuning = "bass",
  string_names = NULL,
  header = NULL,
  paper = NULL,
  midi = FALSE,
  colors = NULL,
  transparent = FALSE,
  res = 150,
  keep_ly = FALSE,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_music_+3A_music">music</code></td>
<td>
<p>a music object.</p>
</td></tr>
<tr><td><code id="render_music_+3A_file">file</code></td>
<td>
<p>character, output file ending in .pdf or .png.</p>
</td></tr>
<tr><td><code id="render_music_+3A_clef">clef</code></td>
<td>
<p>character, include a music staff with the given clef. <code>NA</code> to
suppress. See <code>track()</code> for details.</p>
</td></tr>
<tr><td><code id="render_music_+3A_tab">tab</code></td>
<td>
<p>logical, include tablature staff. <code>NA</code> to suppress. See <code>track()</code>.</p>
</td></tr>
<tr><td><code id="render_music_+3A_tuning">tuning</code></td>
<td>
<p>character, string tuning, only applies to tablature. See
<code>track()</code>.</p>
</td></tr>
<tr><td><code id="render_music_+3A_string_names">string_names</code></td>
<td>
<p>label strings at beginning of tab staff. <code>NULL</code> (default)
for non-standard tunings only, <code>TRUE</code> or <code>FALSE</code> for force on or off
completely.</p>
</td></tr>
<tr><td><code id="render_music_+3A_header">header</code></td>
<td>
<p>a named list of arguments passed to the header of the LilyPond
file. See <code>lilypond()</code> details.</p>
</td></tr>
<tr><td><code id="render_music_+3A_paper">paper</code></td>
<td>
<p>a named list of arguments for the LilyPond file page layout. See
<code>lilypond()</code> details.</p>
</td></tr>
<tr><td><code id="render_music_+3A_midi">midi</code></td>
<td>
<p>logical, also output an corresponding MIDI file.</p>
</td></tr>
<tr><td><code id="render_music_+3A_colors">colors</code></td>
<td>
<p>a named list of LilyPond element color global overrides. See
<code>lilypond()</code> for details.</p>
</td></tr>
<tr><td><code id="render_music_+3A_transparent">transparent</code></td>
<td>
<p>logical, transparent background, png only.</p>
</td></tr>
<tr><td><code id="render_music_+3A_res">res</code></td>
<td>
<p>numeric, resolution, png only. <code>transparent = TRUE</code> may fail when
<code>res</code> exceeds ~150.</p>
</td></tr>
<tr><td><code id="render_music_+3A_keep_ly">keep_ly</code></td>
<td>
<p>logical, keep the intermediary LilyPond file.</p>
</td></tr>
<tr><td><code id="render_music_+3A_simplify">simplify</code></td>
<td>
<p>logical, uses <code>simplify_phrase()</code> to convert to simpler, more
efficient LilyPond syntax.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions allow you to render short, simple snippets of sheet music
directly from a <code>music</code> object. This is useful when you do not need to
build up from phrases to tracks to a full score. They treat <code>music</code> objects
as a single voice for a single track. This simplifies the possible output but
is very convenient when this is all you need.
</p>
<p>These functions abstract the following pipeline,
</p>
<p><code style="white-space: pre;">&#8288;music |&gt; phrase() |&gt; track() |&gt; score() |&gt; render_*()&#8288;</code>
</p>
<p>for this simple edge case and directly expose the most relevant arguments.
</p>
<p>All <code>header</code> list elements are character strings. The options for
<code>header</code> include the following.
</p>

<ul>
<li> <p><code>title</code>
</p>
</li>
<li> <p><code>subtitle</code>
</p>
</li>
<li> <p><code>composer</code>
</p>
</li>
<li> <p><code>album</code>
</p>
</li>
<li> <p><code>arranger</code>
</p>
</li>
<li> <p><code>instrument</code>
</p>
</li>
<li> <p><code>meter</code>
</p>
</li>
<li> <p><code>opus</code>
</p>
</li>
<li> <p><code>piece</code>
</p>
</li>
<li> <p><code>poet</code>
</p>
</li>
<li> <p><code>copyright</code>
</p>
</li>
<li> <p><code>tagline</code>
</p>
</li></ul>

<p>All <code>paper</code> list elements are numeric except <code>page_numbers</code> and
<code>print_first_page_number</code>, which are logical. <code>page_numbers = FALSE</code>
suppresses all page numbering. When <code>page_numbers = TRUE</code>, you can set
<code>print_first_page_number = FALSE</code> to suppress printing of only the first
page number. <code>first_page_number</code> is the number of the first page,
defaulting to 1, and determines all subsequent page numbers. These arguments
correspond to LilyPond paper block variables.
</p>
<p>The options for <code>paper</code> include the following and have the following default
values if not provided.
</p>

<ul>
<li> <p><code>textheight = 220</code>
</p>
</li>
<li> <p><code>linewidth = 150</code>
</p>
</li>
<li> <p><code>indent = 0</code>
</p>
</li>
<li> <p><code>fontsize = 20</code>
</p>
</li>
<li> <p><code>page_numbers = FALSE</code>
</p>
</li>
<li> <p><code>print_first_page_number = TRUE</code>
</p>
</li>
<li> <p><code>first_page_number = 1</code>
</p>
</li></ul>

<p><code>textheight = 150</code> is the default, but for music snippet rendering, a value
must be provided explicitly via <code>paper</code> when rendering to png. Otherwise for
png outputs the height is cropped automatically rather than remaining a full
page. See <code>lilypond()</code> for details.
</p>
<p>Passing arguments to <code>header</code> can completely or partially prevent cropping in
both directions, which must then be done manually with <code>linewidth</code> and
<code>textheight</code>. This is all based on underlying LilyPond behavior.
</p>
<p>If <code>music</code> contains lyrics and there are rests in the note sequence,
note-lyric alignment is maintained automatically when these functions
remove the lyric timesteps corresponding to the rests prior to sending to
LilyPond. LilyPond skips rests when engraving lyrics and expects a shortened
lyrics sequence in comparison to how <code>tabr</code> matches by timestep including
rests. This is in contrast to <code>track()</code>, for which you have to shorten the
lyrics object yourself prior to combining with a phrase object that has rests.
</p>


<h3>Value</h3>

<p>nothing returned; a file is written.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_music">plot_music()</a></code>, <code><a href="#topic+phrase">phrase()</a></code>, <code><a href="#topic+track">track()</a></code>, <code><a href="#topic+score">score()</a></code>, <code><a href="#topic+lilypond">lilypond()</a></code>,
<code><a href="#topic+tab">tab()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "a,4;5*5 b,- c cgc'e'~ cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51"
x &lt;- as_music(x)

y &lt;- "a,,4;3*5 b,,- c, c,g,c~ c,g,c1 c4;1 g,;2 c,;3 g,;2 c,c1;31"
y &lt;- as_music(y)

z &lt;- as_music("a,4 b, r c~ c2 d", lyrics = as_lyrics("A2 B2 . C3 . D3"))

## Not run: 
if(tabr_options()$lilypond != ""){ # requires LilyPond installation
  outfile &lt;- file.path(tempdir(), "out.pdf")
  render_music(x, outfile)

  outfile &lt;- file.path(tempdir(), "out.png")
  render_music(x, outfile, "treble_8", tab = TRUE)

  render_music_tc(x, outfile)
  render_music_bc(x, outfile)

  render_music_tab(x, outfile)
  render_music_guitar(x, outfile)
  render_music_bass(y, outfile)

  # lyrics example
  render_music_guitar(z, outfile)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='repeats'>Repeat phrases</h2><span id='topic+repeats'></span><span id='topic+rp'></span><span id='topic+pct'></span><span id='topic+volta'></span>

<h3>Description</h3>

<p>Create a repeat section in LilyPond readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rp(phrase, n = 1)

pct(phrase, n = 1, counter = FALSE, step = 1, reset = TRUE)

volta(phrase, n = 1, endings = NULL, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repeats_+3A_phrase">phrase</code></td>
<td>
<p>a phrase object or equivalent string to be repeated.</p>
</td></tr>
<tr><td><code id="repeats_+3A_n">n</code></td>
<td>
<p>integer, number of repeats of <code>phrase</code> (one less than the total
number of plays).</p>
</td></tr>
<tr><td><code id="repeats_+3A_counter">counter</code></td>
<td>
<p>logical, if <code>TRUE</code>, print the percent repeat counter above the
staff, applies only to <em>measure</em> repeats of more than two repeats (<code>n</code> &gt; 2).</p>
</td></tr>
<tr><td><code id="repeats_+3A_step">step</code></td>
<td>
<p>integer, print the <em>measure</em> percent repeat counter above the
staff only at every <code>step</code> measures when <code>counter = TRUE</code>.</p>
</td></tr>
<tr><td><code id="repeats_+3A_reset">reset</code></td>
<td>
<p>logical, percent repeat <code>counter</code> and <code>step</code> settings are only
applied to the single <code>pct()</code> call and are reset afterward. If
<code>reset = FALSE</code>, the settings are left open to apply to any subsequent
percent repeat sections in a track.</p>
</td></tr>
<tr><td><code id="repeats_+3A_endings">endings</code></td>
<td>
<p>a single phrase or a list of phrases, alternate endings.</p>
</td></tr>
<tr><td><code id="repeats_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code>, no text will be printed above the staff at the
beginning of a volta section. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions wraps a phrase object or a character string in LilyPond
repeat syntax. The most basic is <code>rp()</code> for basic wrapping a LilyPond
<code>unfold</code> repeat tag around a phrase. This repeats the phrase <code>n</code> times, but
it is displayed in the engraved sheet music fully written out as a literal
propagation of the phrase with no repeat notation used to reduce redundant
presentation. The next is <code>pct()</code>, which wraps a <code>percent()</code> repeat tag
around a phrase. This is displayed in sheet music as percent repeat notation
whose specific notation changes based on the length of the repeated section
of music, used for beats or whole measures. <code>volta()</code> wraps a phrase in a
<code>volta()</code> repeat tag, used for long repeats of one or more full measures or
bars of music, optionally with alternate endings.
</p>
<p>Note that basic strings should still be interpretable as a valid musical
phrase by LilyPond and such strings will be coerced to the phrase class by
these functions. For example, a one-measure rest, <code>"r1"</code>, does not need to be
a phrase object to work with these functions, nor does any other character
string explicitly written out in valid LilyPond syntax. As always, see the
LilyPond documentation if you are not familiar with LilyPond syntax.
</p>
<p>VOLTA REPEAT: When <code>silent = TRUE</code> there is no indication of the number
of plays above the staff at the start of the volta section. This otherwise
happens automatically when the number of repeats is greater than one and no
alternate endings are included (which are already numbered).
This override creates ambiguity on its own, but is important to use multiple
staves are present and another staff already displays the text regarding the
number or plays. This prevents printing the same text above every staff.
</p>
<p>PERCENT REPEAT: As indicated in the parameter descriptions, the arguments
<code>counter</code> and <code>step</code> only apply to full measures or bars of music.
It does not apply to shorter beats that are repeated using <code>pct()</code>.
</p>


<h3>Value</h3>

<p>a phrase.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phrase">phrase()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- phrase("c ec'g' ec'g'", "4 4 2", "5 432 432")
e1 &lt;- phrase("a", 1, 5) # ending 1
e2 &lt;- phrase("b", 1, 5) # ending 2

rp(x) # simple unfolded repeat, one repeat or two plays
rp(x, 3) # three repeats or four plays

pct(x) # one repeat or two plays
pct(x, 9, TRUE, 5) # 10 plays, add counter every 5 steps
pct(x, 9, TRUE, 5, FALSE) # as above, but do not reset counter settings

volta(x) # one repeat or two plays
volta(x, 1, list(e1, e2)) # one repeat with alternate ending
volta(x, 4, list(e1, e2)) # multiple repeats with only one alternate ending
volta(x, 4) # no alternates, more than one repeat
</code></pre>

<hr>
<h2 id='rest'>Create rests</h2><span id='topic+rest'></span>

<h3>Description</h3>

<p>Create multiple rests efficiently with a simple wrapper around <code>rep()</code> using
the <code>times</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rest(x, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rest_+3A_x">x</code></td>
<td>
<p>integer, duration.</p>
</td></tr>
<tr><td><code id="rest_+3A_n">n</code></td>
<td>
<p>integer, number of repetitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rest(c(1, 8), c(1, 4))
</code></pre>

<hr>
<h2 id='scale_chords'>Diatonic chords</h2><span id='topic+scale_chords'></span>

<h3>Description</h3>

<p>Obtain an ordered sequence of the diatonic chords for a given scale, as
triads or sevenths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_chords(
  root = "c",
  scale = "major",
  type = c("triad", "seventh"),
  collapse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_chords_+3A_root">root</code></td>
<td>
<p>character, root note or starting position of scale.</p>
</td></tr>
<tr><td><code id="scale_chords_+3A_scale">scale</code></td>
<td>
<p>character, a valid named scale, referring to one of the
existing <code style="white-space: pre;">&#8288;scale_*&#8288;</code> functions.</p>
</td></tr>
<tr><td><code id="scale_chords_+3A_type">type</code></td>
<td>
<p>character, type of chord, triad or seventh.</p>
</td></tr>
<tr><td><code id="scale_chords_+3A_collapse">collapse</code></td>
<td>
<p>logical, collapse result into a single string ready for
phrase construction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scale_chords("c", "major")
scale_chords("a", "minor")
scale_chords("a", "harmonic minor")
scale_chords("a", "melodic minor")
scale_chords("a", "jazz minor")
scale_chords("a", "hungarian minor")

scale_chords("c", "major", "seventh", collapse = TRUE)
scale_chords("a", "minor", "seventh", collapse = TRUE)
</code></pre>

<hr>
<h2 id='scale-deg'>Scale degrees and mappings</h2><span id='topic+scale-deg'></span><span id='topic+scale_degree'></span><span id='topic+scale_note'></span><span id='topic+note_in_scale'></span><span id='topic+chord_degree'></span><span id='topic+is_in_scale'></span>

<h3>Description</h3>

<p>These functions assist with mapping between scale degrees, notes and chords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_degree(
  notes,
  key = "c",
  scale = "diatonic",
  use_root = TRUE,
  strict_accidentals = TRUE,
  naturalize = FALSE,
  roman = FALSE
)

scale_note(deg, key = "c", scale = "diatonic", collapse = FALSE, ...)

note_in_scale(
  notes,
  key = "c",
  scale = "diatonic",
  use_root = TRUE,
  strict_accidentals = TRUE
)

chord_degree(
  notes,
  key = "c",
  scale = "diatonic",
  strict_accidentals = TRUE,
  naturalize = FALSE,
  roman = FALSE
)

is_in_scale(notes, key = "c", scale = "diatonic", strict_accidentals = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale-deg_+3A_notes">notes</code></td>
<td>
<p>character, a string of notes.</p>
</td></tr>
<tr><td><code id="scale-deg_+3A_key">key</code></td>
<td>
<p>character, key signature (or root note) for scale, depending on
the type of <code>scale</code>.</p>
</td></tr>
<tr><td><code id="scale-deg_+3A_scale">scale</code></td>
<td>
<p>character, the suffix of a supported <code style="white-space: pre;">&#8288;scale_*&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="scale-deg_+3A_use_root">use_root</code></td>
<td>
<p>logical, use lowest pitch in chord. Otherwise yield an
<code>NA</code> in output.</p>
</td></tr>
<tr><td><code id="scale-deg_+3A_strict_accidentals">strict_accidentals</code></td>
<td>
<p>logical, whether representation must match key and
scale. See details.</p>
</td></tr>
<tr><td><code id="scale-deg_+3A_naturalize">naturalize</code></td>
<td>
<p>logical, whether to naturalize any sharps or flats before
obtaiuning the scale degree.</p>
</td></tr>
<tr><td><code id="scale-deg_+3A_roman">roman</code></td>
<td>
<p>logical, return integer scale degrees as Roman numerals.</p>
</td></tr>
<tr><td><code id="scale-deg_+3A_deg">deg</code></td>
<td>
<p>integer, roman class, or character roman, the scale degree.</p>
</td></tr>
<tr><td><code id="scale-deg_+3A_collapse">collapse</code></td>
<td>
<p>logical, collapse result into a single string ready for
phrase construction.</p>
</td></tr>
<tr><td><code id="scale-deg_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the scale function, e.g.,
<code>sharp = FALSE</code> for <code>scale_chromatic()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obtain the scale degree of a note in a supported scale with <code>scale_degree()</code>.
This function works on any noteworthy string. It ignores octave numbering.
Rests and any note not explicitly in the scale return <code>NA</code>. If <code>deg</code> is
greater than the number of degrees in the scale, it is recycled, e.g., in C
major 8 starts over as C.
</p>
<p>By default, flats and sharps checked strictly against the scale. Setting
<code>strict_accidentals = FALSE</code> will convert any flats or sharps present,
if necessary based on the combination of <code>key</code> signature and
<code>scale</code>. The chromatic scale is a special case where strict accidental
is always ignored.
</p>
<p>Not any arbitrary combination of valid <code>key</code> and valid <code>scale</code> is valid. For
example, <code>key = "am"</code> and <code>scale = "harmonic"</code> is valid, but not with
<code>key = "a"</code>.
</p>
<p><code>note_in_scale()</code> is a wrapper around <code>scale_degree()</code>. To check if full
chords are diatonic to the scale, see <code><a href="#topic+is_diatonic">is_diatonic()</a></code>.
</p>
<p>The inverse of <code>scale_degree()</code> is <code>scale_note()</code>, for obtaining the note
associated with a scale degree. This could be done simply by calling a
<code style="white-space: pre;">&#8288;scale_*&#8288;</code> function and indexing its output directly, but this wrapper is
provided to complement <code>scale_degree()</code>.
Additionally, it accepts the common Roman numeral input for the degree.
This can be with the <code>roman</code> class or as a character string.
Degrees return <code>NA</code> if outside the scale degree range.
</p>


<h3>Value</h3>

<p>integer, or roman class if <code>roman = TRUE</code> for <code>scale_degree()</code>;
character for <code>scale_note()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale-helpers">scale-helpers()</a></code>, <code><a href="#topic+is_diatonic">is_diatonic()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scale_degree("r c, e3 g~ g s g# ceg")
note_in_scale("r c, e3 g~ g s g# ceg")

scale_degree("c e g", roman = TRUE)

scale_degree("c c# d_ e", key = "d")
scale_degree("c c# d_ e", key = "d", strict_accidentals = FALSE)

scale_degree("c, e_3 g' f#ac#", use_root = FALSE)
scale_degree("c, e_3 g' f#ac#", naturalize = TRUE) # lowest chord pitch: c#

scale_degree("c# d_ e_' e4 f f# g", key = "c#", scale = "chromatic")

scale_note(1:3, key = "am")
scale_note(c(1, 3, 8), "d", collapse = TRUE)
all(sapply(list(4, "IV", as.roman(4)), scale_note) == "f")

x &lt;- "d dfa df#a f#ac#"
chord_degree(x, "d")
is_in_scale(x, "d")
</code></pre>

<hr>
<h2 id='scale-helpers'>Scale helpers</h2><span id='topic+scale-helpers'></span><span id='topic+scale_diatonic'></span><span id='topic+scale_major'></span><span id='topic+scale_minor'></span><span id='topic+scale_harmonic_minor'></span><span id='topic+scale_hungarian_minor'></span><span id='topic+scale_melodic_minor'></span><span id='topic+scale_jazz_minor'></span><span id='topic+scale_chromatic'></span>

<h3>Description</h3>

<p>Helper functions for working with musical scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_diatonic(key = "c", collapse = FALSE, ignore_octave = FALSE)

scale_major(key = "c", collapse = FALSE, ignore_octave = FALSE)

scale_minor(key = "am", collapse = FALSE, ignore_octave = FALSE)

scale_harmonic_minor(key = "am", collapse = FALSE, ignore_octave = FALSE)

scale_hungarian_minor(key = "am", collapse = FALSE, ignore_octave = FALSE)

scale_melodic_minor(
  key = "am",
  descending = FALSE,
  collapse = FALSE,
  ignore_octave = FALSE
)

scale_jazz_minor(key = "am", collapse = FALSE, ignore_octave = FALSE)

scale_chromatic(
  root = "c",
  collapse = FALSE,
  sharp = TRUE,
  ignore_octave = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale-helpers_+3A_key">key</code></td>
<td>
<p>character, key signature.</p>
</td></tr>
<tr><td><code id="scale-helpers_+3A_collapse">collapse</code></td>
<td>
<p>logical, collapse result into a single string ready for
phrase construction.</p>
</td></tr>
<tr><td><code id="scale-helpers_+3A_ignore_octave">ignore_octave</code></td>
<td>
<p>logical, strip octave numbering from scales not rooted
on C.</p>
</td></tr>
<tr><td><code id="scale-helpers_+3A_descending">descending</code></td>
<td>
<p>logical, return the descending scale, available as a
built-in argument for the melodic minor scale, which is different in each
direction.</p>
</td></tr>
<tr><td><code id="scale-helpers_+3A_root">root</code></td>
<td>
<p>character, root note.</p>
</td></tr>
<tr><td><code id="scale-helpers_+3A_sharp">sharp</code></td>
<td>
<p>logical, accidentals in arbitrary scale output should be sharp
rather than flat.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For valid key signatures, see <code><a href="#topic+keys">keys()</a></code>.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>See Also</h3>

<p><code><a href="#topic+keys">keys()</a></code>, <code><a href="#topic+mode-helpers">mode-helpers()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scale_diatonic(key = "dm")
scale_minor(key = "dm")
scale_major(key = "d")

scale_chromatic(root = "a")

scale_harmonic_minor("am")
scale_hungarian_minor("am")

identical(scale_melodic_minor("am"), scale_jazz_minor("am"))
rev(scale_melodic_minor("am", descending = TRUE))
scale_jazz_minor("am")
</code></pre>

<hr>
<h2 id='score'>Create a music score</h2><span id='topic+score'></span>

<h3>Description</h3>

<p>Create a music score from a collection of tracks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(track, chords = NULL, chord_seq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_track">track</code></td>
<td>
<p>a track table consisting of one or more tracks.</p>
</td></tr>
<tr><td><code id="score_+3A_chords">chords</code></td>
<td>
<p>an optional named list of chords and respective fingerings
generated by <code>chord_set</code>, for inclusion of a top center chord diagram chart.</p>
</td></tr>
<tr><td><code id="score_+3A_chord_seq">chord_seq</code></td>
<td>
<p>an optional named vector of chords and their durations, for
placing chord diagrams above staves in time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Score takes track tables generated by <code><a href="#topic+track">track()</a></code> and fortifies them
as a music score. It optionally binds tracks with a set of chord diagrams.
There may be only one track in <code>track()</code> as well as no chord information
passed, but for consistency <code>score()</code> is still required to fortify the
single track as a score object that can be rendered by <code><a href="#topic+tab">tab()</a></code>.
</p>


<h3>Value</h3>

<p>a tibble data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phrase">phrase()</a></code>, <code><a href="#topic+track">track()</a></code>, <code><a href="#topic+trackbind">trackbind()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- phrase("c ec'g' ec'g'", "4 4 2", "5 432 432")
x &lt;- track(x)
score(x)
</code></pre>

<hr>
<h2 id='sf_phrase'>Create a musical phrase from string/fret combinations</h2><span id='topic+sf_phrase'></span><span id='topic+sfp'></span><span id='topic+sf_note'></span><span id='topic+sfn'></span>

<h3>Description</h3>

<p>Create a musical phrase from character strings that define string numbers,
fret numbers and note metadata. This function is a wrapper around
<code><a href="#topic+phrase">phrase()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_phrase(
  string,
  fret = NULL,
  info = NULL,
  key = "c",
  tuning = "standard",
  to_notes = FALSE,
  bar = NULL
)

sfp(
  string,
  fret = NULL,
  info = NULL,
  key = "c",
  tuning = "standard",
  to_notes = FALSE,
  bar = NULL
)

sf_note(...)

sfn(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_phrase_+3A_string">string</code></td>
<td>
<p>character, space-delimited or vector. String numbers
associated with notes. Alternatively, provide all information here in a
single space-delimited string and ignore <code>fret</code> and <code>info</code>. See details.</p>
</td></tr>
<tr><td><code id="sf_phrase_+3A_fret">fret</code></td>
<td>
<p>character, space-delimited or vector (or integer vector) of fret
numbers associated with notes. Same number of timesteps as <code>string</code>.</p>
</td></tr>
<tr><td><code id="sf_phrase_+3A_info">info</code></td>
<td>
<p>character, space-delimited or vector (or integer vector if simple
durations) giving metadata associated with notes. Same number of timesteps as
<code>string</code>.</p>
</td></tr>
<tr><td><code id="sf_phrase_+3A_key">key</code></td>
<td>
<p>character, key signature or just specify <code>"sharp"</code> or <code>"flat"</code>.</p>
</td></tr>
<tr><td><code id="sf_phrase_+3A_tuning">tuning</code></td>
<td>
<p>character, instrument tuning.</p>
</td></tr>
<tr><td><code id="sf_phrase_+3A_to_notes">to_notes</code></td>
<td>
<p>logical, return only the mapped notes character string
rather than the entire phrase object.</p>
</td></tr>
<tr><td><code id="sf_phrase_+3A_bar">bar</code></td>
<td>
<p>character or <code>NULL</code> (default). Terminates the phrase with a
bar or bar check. See details for <code><a href="#topic+phrase">phrase()</a></code>. Also see the LilyPond help
documentation on bar notation for all the valid options.</p>
</td></tr>
<tr><td><code id="sf_phrase_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sf_phrase()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This alternate specification wrapper is not receiving further support
and will be removed in a future version of <code>tabr</code>.
</p>
<p>This alternate syntax allows for specifying string/fret combinations instead
of unambiguous pitch as is used by <code>phrase()</code>. In order to remove ambiguity,
it is critical to specify the instrument string tuning and key signature. It
essentially uses <code>string</code> and <code>fret</code> in combination with a known tuning and
key signature to generate <code>notes</code> for <code><a href="#topic+phrase">phrase()</a></code>. <code>info</code> is passed straight
through to <code>phrase()</code>, as is <code>string</code> once it is done being used to help
derive <code>notes</code>.
</p>
<p>See the main function <code>phrase</code> for general details on phrase
construction.
</p>


<h3>Value</h3>

<p>a phrase.
</p>


<h3>Comparison with <code>phrase()</code></h3>

<p>This function is a wrapper function for users not working with musical notes
(what to play), but rather just position on the guitar neck (where to play).
This approach has conveniences, but is more limiting.
In order to remove ambiguity, it is necessary to specify the instrument
<code>tuning</code> and the <code>key</code> signature.
</p>
<p>In the standard approach with <code>phrase()</code> you specify what to play;
specifying exactly where to play is optional, but highly recommended (by
providing <code>string</code>).
With <code>sf_phrase()</code>, the <code>string</code> argument is of course required along with
<code>fret</code>.
But any time the tuning changes, this &quot;where to play&quot; method breaks down and
must be redone. It is more robust to provide the string and pitch rather
than the string and fret.
The <code>key</code> is additionally important because it is the only way to
indicate if accidentals should be notated as sharps or flats.
</p>
<p>This wrapper also increases redundancy and typing. In order to specify rests
<code>r</code>, silent rests <code>s</code>, and tied notes <code>~</code>, these must now be providing in
parallel in both the <code>string</code> and <code>fret</code> arguments, whereas in the standard
method using <code>phrase()</code>, they need only be provided once to <code>notes</code>.
A mismatch will throw an error. Despite the redundancy, this is helpful for
ensuring proper match up between <code>string</code> and <code>fret</code>, which is essentially a
dual entry method that aims to reduce itself inside <code>sf_phrase()</code> to a single
<code>notes</code> string that is passed internally to <code>phrase()</code>.
</p>
<p>The important thing to keep in mind is that by its nature, this method of
writing out music does not lend itself well to high detail.
Tabs that are informed by nothing but string and fret number remove a lot of
important information, and those that attempt to compensate with additional
symbols in say, an ascii tab, are difficult to read.
This wrapper function providing this alternative input method to
<code>phrase()</code> does its job of allowing users to create phrase objects that
are equivalent to standard <code>phrase()</code>-generated objects, including rests
and ties.
But practice and comfort working with <code>phrase()</code> is is highly recommended
for greater control of development support.
</p>
<p>The function <code>sfp()</code> is a convenient shorthand wrapper for <code>sf_phrase()</code>.
<code>sf_note()</code> and the alias <code>sfn()</code> are wrappers around <code>sf_phrase()</code> that
force <code>to_notes = TRUE</code>.
</p>


<h3>Single-string input</h3>

<p>Another way to use <code>sf_phrase()</code> is to provide all musical input to
<code>string</code> and ignore <code>fret</code> and <code>info</code> as explicit arguments.
Providing all three explicit arguments more closely mimics the inputs of
<code>phrase()</code> and is useful when you have this information as three
independent sources.
However, in some cases the single-argument input method can reduce typing,
though this depends on the phrase.
More importantly, it allow you to reason about your musical inputs by time
step rather than by argument.
If you provide all three components as a single character string to the
<code>string</code> argument, leaving both <code>fret</code> and <code>info</code> as <code>NULL</code>, then
<code>sf_phrase()</code> will decompose <code>string</code> into its three component parts
internally.
</p>
<p>There are some rules for single-argument input. The three components are
separated by semicolons as <code>"string;fret;info"</code>.
For example, <code>"3;7x7;4"</code> means begin on the third string
(infer higher number strings muted).
The frets are 7th and 7th, meaning two notes are played. When an <code>x</code> is
present in the second entry it means a string is not played.
This is how it is inferred that the string numbers starting from the third
string are strings 3 and 1 rather than 3 and 2 in this example.
The 4 indicates a quarter note since it is part of the third entry where the
additional <code>info</code> is specified. This is contextual. For example, an
<code>x</code> here would still indicate a dead note, rather than an unplayed
string in the second entry, so this is contextual.
</p>
<p>A bonus when using this input method is that explicit <code>string</code> and
<code>info</code> values persist from one timestep to the next.
Neither needs to be provided again until there is a change in value.
For example, <code>"3;7x7;4 7x7 ;7x7;1"</code> repeats the string and info values
from timestep one for timestep two.
In timestep three, string numbers repeat again, but the duration changes
from quarter note to whole note.
</p>
<p>Note that except when both <code>string</code> and <code>info</code> are repeating and
only fret numbers are provided (see timestep two above), two semicolons
must be present so that it is unambiguous whether the sole missing component
is a <code>string</code> or <code>info</code> (see timestep three).
</p>
<p>Ambiguity would arise from a case like <code>"4;4"</code> without the second semicolon.
This type of indexing was chosen over using two different delimiters.
</p>
<p>If a rest, <code>r</code> or <code>s</code>, is provided for the <code>fret</code> entry, then the <code>string</code>
entry is ignored. When using this input method, ties <code>~</code> are given in the
info entry.
</p>
<p>See the examples for a comparison of two identical phrases specified using
both input methods for <code>sf_phrase()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phrase">phrase()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sf_phrase("5 4 3 2 1", "1 3 3 3 1", "8*4 1", key = "b_")
sf_phrase("6 6 12 1 21", "133211 355333 11 (13) (13)(13)", "4 4 8 8 4",
          key = "f")
sfp("6*2 1*4", "000232*2 2*4", "4 4 8*4", tuning = "dropD", key = "d")

# compare with single-argument input
s &lt;- "3*5 53~*3 543*2 643"
f &lt;- "987*2 775 553 335 77~*3 545 325 210"
i &lt;- "2*3 4. 16 4.*3 4*3"
p1 &lt;- sfp(s, f, i)

# Nominally shorter syntax, but potentially much easier to reason about
p2 &lt;- sfp("3;987;2*2 775 ;553;4. ;335;16 5;7x7;4.~*3 ;545;4 325 6;2x10;")

identical(p1, p2)
</code></pre>

<hr>
<h2 id='simplify_phrase'>Simplify the LilyPond syntax of a phrase</h2><span id='topic+simplify_phrase'></span>

<h3>Description</h3>

<p>This function can be used to simplify the LilyPond syntax of a phrase. Not
intended for direct use. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_phrase(phrase)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_phrase_+3A_phrase">phrase</code></td>
<td>
<p>a phrase object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function not intended to be used directly, but is available so that you
can see how LilyPond syntax for phrases will be transformed by default in
the process of creating a LilyPond file. This function is used by the
<code>lilypond()</code> function and associated <code style="white-space: pre;">&#8288;render_*&#8288;</code> functions. When using
<code>lilypond()</code> directly, this can be controlled by the <code>simplify</code> argument.
</p>
<p>The result of this function is a character string containing simpler, more
efficient LilyPond syntax. It can be coerced back to a phrase with
<code>as_phrase()</code>, but its print method colors will no longer display properly.
More importantly, this simplification removes any possibility of transforming
the phrase back to its original inputs. The more complex but nicely
structured original representation does a better job at maintaining
reasonable possibility of one to one transformation between a phrase object
and the inputs that it was built from.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>notes &lt;- "a~ a b c' c'e'g'~ c'e'g'"
info &lt;- "8.. 8..-. 8- 8-^ 4.^ 4."
(x &lt;- p(notes, info))
as_phrase(simplify_phrase(x))

(x &lt;- p(notes, info, 5))
as_phrase(simplify_phrase(x))
</code></pre>

<hr>
<h2 id='single-bracket'>Single bracket methods for tabr classes</h2><span id='topic+single-bracket'></span><span id='topic++5B.noteworthy'></span><span id='topic++5B.noteinfo'></span><span id='topic++5B.music'></span><span id='topic++5B.lyrics'></span><span id='topic++5B+3C-.noteworthy'></span><span id='topic++5B+3C-.noteinfo'></span><span id='topic++5B+3C-.music'></span><span id='topic++5B+3C-.lyrics'></span>

<h3>Description</h3>

<p>Single bracket indexing and assignment. See <code><a href="#topic+tabr-methods">tabr-methods()</a></code> for more details
on methods for tabr classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'noteworthy'
x[i]

## S3 method for class 'noteinfo'
x[i]

## S3 method for class 'music'
x[i]

## S3 method for class 'lyrics'
x[i]

## S3 replacement method for class 'noteworthy'
x[i] &lt;- value

## S3 replacement method for class 'noteinfo'
x[i] &lt;- value

## S3 replacement method for class 'music'
x[i] &lt;- value

## S3 replacement method for class 'lyrics'
x[i] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single-bracket_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="single-bracket_+3A_i">i</code></td>
<td>
<p>index.</p>
</td></tr>
<tr><td><code id="single-bracket_+3A_value">value</code></td>
<td>
<p>values to assign at index.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tabr-methods">tabr-methods()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># noteworthy class examples
x &lt;- as_noteworthy("a, b, c ce_g d4f#4a4")
x[3:4]
x[-2]
x[2] &lt;- paste0(transpose(x[2], 1), "~")
x

# noteinfo class examples
x &lt;- as_noteinfo(c("4-", "t8(", "t8)", "t8x", "8^", "16"))
x[2:4]
x[-1]
x[5:6] &lt;- c("16^", "8")
x
x[x == "4-"]

# music class examples
x &lt;- as_music("c,~4 c,1 c'e_'g'4-.*4")
x[1:3]
x[-c(1:2)]
x[3:6] &lt;- "c'e'g'8"
x
</code></pre>

<hr>
<h2 id='string_unfold'>Fold and unfold strings</h2><span id='topic+string_unfold'></span><span id='topic+string_fold'></span>

<h3>Description</h3>

<p>Fold or unfold a string on the expansion operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_unfold(x)

string_fold(x, n = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_unfold_+3A_x">x</code></td>
<td>
<p>character string, should be valid notes or note info such as beats.</p>
</td></tr>
<tr><td><code id="string_unfold_+3A_n">n</code></td>
<td>
<p>integer, minimum number of consecutive repeated values to warrant
folding, defaults to 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These function work on arbitrary stings. They do not perform a noteworthy
check. This allows them to work for <code>info</code> strings as well. Make sure
your strings are properly formatted. <code>string_fold()</code> always collapses the
output string as space-delimited.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time &lt;- "8*3 16 4.. 16 16 2 2 4. 8 4 4 8*4 1"
x &lt;- string_unfold(time)
x
string_fold(x) == time

notes &lt;- "a, b, c d e f g# a r ac'e' a c' e' c' r r r a"
x &lt;- string_fold(notes)
x
string_unfold(x) == notes
</code></pre>

<hr>
<h2 id='tab'>Render sheet music with LilyPond</h2><span id='topic+tab'></span><span id='topic+render_tab'></span><span id='topic+render_score'></span><span id='topic+render_midi'></span>

<h3>Description</h3>

<p>Render sheet music/tablature from a music score with LilyPond.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab(
  score,
  file,
  key = "c",
  time = "4/4",
  tempo = "2 = 60",
  header = NULL,
  paper = NULL,
  string_names = NULL,
  endbar = "|.",
  midi = TRUE,
  colors = NULL,
  crop_png = TRUE,
  transparent = FALSE,
  res = 150,
  keep_ly = FALSE,
  simplify = TRUE,
  details = FALSE
)

render_tab(
  score,
  file,
  key = "c",
  time = "4/4",
  tempo = "2 = 60",
  header = NULL,
  paper = NULL,
  string_names = NULL,
  endbar = "|.",
  midi = TRUE,
  colors = NULL,
  crop_png = TRUE,
  transparent = FALSE,
  res = 150,
  keep_ly = FALSE,
  simplify = TRUE,
  details = FALSE
)

render_score(
  score,
  file,
  key = "c",
  time = "4/4",
  tempo = "2 = 60",
  header = NULL,
  paper = NULL,
  endbar = "|.",
  colors = NULL,
  crop_png = TRUE,
  transparent = FALSE,
  res = 150,
  keep_ly = FALSE,
  simplify = TRUE,
  details = FALSE
)

render_midi(score, file, key = "c", time = "4/4", tempo = "2 = 60")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab_+3A_score">score</code></td>
<td>
<p>a score object.</p>
</td></tr>
<tr><td><code id="tab_+3A_file">file</code></td>
<td>
<p>character, output file ending in .pdf or .png for sheet music or
tablature for <code>score()</code>. May include an absolute or relative path. For
<code>render_midi()</code>, a file ending in <code>.mid</code>.</p>
</td></tr>
<tr><td><code id="tab_+3A_key">key</code></td>
<td>
<p>character, key signature, e.g., <code>c</code>, <code>b_</code>, <code>f#m</code>, etc.</p>
</td></tr>
<tr><td><code id="tab_+3A_time">time</code></td>
<td>
<p>character, defaults to <code>"4/4"</code>.</p>
</td></tr>
<tr><td><code id="tab_+3A_tempo">tempo</code></td>
<td>
<p>character, defaults to <code>"2 = 60"</code>. Set to <code>NULL</code> to suppress
display of the time signature in the output.</p>
</td></tr>
<tr><td><code id="tab_+3A_header">header</code></td>
<td>
<p>a named list of arguments passed to the header of the LilyPond
file. See <code>lilypond()</code> for details.</p>
</td></tr>
<tr><td><code id="tab_+3A_paper">paper</code></td>
<td>
<p>a named list of arguments for the LilyPond file page layout. See
<code>lilypond()</code> for details.</p>
</td></tr>
<tr><td><code id="tab_+3A_string_names">string_names</code></td>
<td>
<p>label strings at beginning of tab staff. <code>NULL</code> (default)
for non-standard tunings only, <code>TRUE</code> or <code>FALSE</code> for force on or off
completely.</p>
</td></tr>
<tr><td><code id="tab_+3A_endbar">endbar</code></td>
<td>
<p>character, the global end bar.</p>
</td></tr>
<tr><td><code id="tab_+3A_midi">midi</code></td>
<td>
<p>logical, output midi file in addition to sheet music.</p>
</td></tr>
<tr><td><code id="tab_+3A_colors">colors</code></td>
<td>
<p>a named list of LilyPond element color overrides. See
<code>lilypond()</code> for details.</p>
</td></tr>
<tr><td><code id="tab_+3A_crop_png">crop_png</code></td>
<td>
<p>logical, see <code>lilypond()</code> for details.</p>
</td></tr>
<tr><td><code id="tab_+3A_transparent">transparent</code></td>
<td>
<p>logical, transparent background, png only.</p>
</td></tr>
<tr><td><code id="tab_+3A_res">res</code></td>
<td>
<p>numeric, resolution, png only. <code>transparent = TRUE</code> may fail when
<code>res</code> exceeds ~150.</p>
</td></tr>
<tr><td><code id="tab_+3A_keep_ly">keep_ly</code></td>
<td>
<p>logical, keep the intermediary LilyPond file.</p>
</td></tr>
<tr><td><code id="tab_+3A_simplify">simplify</code></td>
<td>
<p>logical, uses <code>simplify_phrase()</code> to convert to simpler,
more efficient LilyPond syntax for the LilyPond file before rendering it.</p>
</td></tr>
<tr><td><code id="tab_+3A_details">details</code></td>
<td>
<p>logical, set to <code>TRUE</code> to print LilyPond log output to
console. Windows only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate a pdf or png of a music score using the LilyPond music engraving
program.
Output format is inferred from <code>file</code> extension. This function is a wrapper
around <code><a href="#topic+lilypond">lilypond()</a></code>, the function that creates the LilyPond (<code>.ly</code>) file.
</p>
<p><code>render_score()</code> renders <code>score()</code> to pdf or png. <code>render_midi()</code> renders a
MIDI file based on <code>score()</code>. This is still done via LilyPond. The sheet
music is created automatically in the process behind the scenes but is
deleted and only the MIDI output is retained.
</p>
<p><code>tab()</code> or <code>render_tab()</code> (equivalent) produces both the sheet music and the
MIDI file output by default and includes other arguments such as the
tablature-relevant argument <code>string_names</code>. This is the all-purpose function.
Also use this when you intend to create both a sheet music document and a
MIDI file.
</p>
<p>Remember that whether a track contains a tablature staff, standard music
staff, or both, is defined in each individual track object contained in
<code>score()</code>. It is the contents you have assembled in<code>score()</code> that dictate
what render function you should use. <code>render_tab()</code> is general and always
works, but <code>render_score()</code> would not be the best choice when a tablature
staff is present unless you accept the default string naming convention.
</p>
<p><code>render_midi()</code> is different from <code>midily()</code> and <code>miditab()</code>, whose purpose
is to create sheet music from an existing MIDI file using a LilyPond command
line utility.
</p>
<p>For Windows users, add the path to the LilyPond executable to the system
path variable. For example, if the file is at
<code style="white-space: pre;">&#8288;C:/lilypond-2.24.2/bin/lilypond.exe&#8288;</code>, then add <code style="white-space: pre;">&#8288;C:/lilypond-2.24.2/bin&#8288;</code> to
the system path.
</p>


<h3>Value</h3>

<p>nothing returned; a file is written.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lilypond">lilypond()</a></code>, <code><a href="#topic+render_chordchart">render_chordchart()</a></code>,
<code><a href="#topic+miditab">miditab()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(tabr_options()$lilypond != ""){
  x &lt;- phrase("c ec'g' ec'g'", "4 4 2", "5 432 432")
  x &lt;- track(x)
  x &lt;- score(x)
  outfile &lt;- file.path(tempdir(), "out.pdf")
  tab(x, outfile) # requires LilyPond installation
}
</code></pre>

<hr>
<h2 id='tabr'>tabr: Music notation syntax, manipulation, analysis and transcription in R.</h2><span id='topic+tabr'></span><span id='topic+tabr-package'></span>

<h3>Description</h3>

<p>The <code>tabr</code> package provides a music notation syntax and a collection of music
programming functions for generating, manipulating, organizing and analyzing
musical information in R. The music notation framework facilitates creating
and analyzing music data in notation form.
</p>


<h3>Details</h3>

<p>Music syntax can be entered directly in character strings, for example to
quickly transcribe short pieces of music. The package contains functions for
directly performing various mathematical, logical and organizational
operations and musical transformations on special object classes that
facilitate working with music data and notation. The same music data can be
organized in tidy data frames for a familiar and powerful approach to the
analysis of large amounts of structured music data. Functions are available
for mapping seamlessly between these formats and their representations of
musical information.
</p>
<p>The package also provides an API to 'LilyPond' (<a href="https://lilypond.org/">https://lilypond.org/</a>) for
transcribing musical representations in R into tablature (&quot;tabs&quot;) and sheet
music. 'LilyPond' is open source music engraving software for generating high
quality sheet music based on markup syntax. The package generates 'LilyPond'
files from R code and can pass them to the 'LilyPond' command line interface
to be rendered into sheet music PDF files or inserted into R markdown
documents.
</p>
<p>The package offers nominal MIDI file output support in conjunction with
rendering sheet music. The package can read MIDI files and attempts to
structure the MIDI data to integrate as best as possible with the data
structures and functionality found throughout the package.
</p>
<p><code>tabr</code> offers a useful but limited LilyPond API and is not intended to
access all LilyPond functionality from R,
nor is transcription via the API the entire scope of <code>tabr</code>.
If you are only creating sheet music on a case by case basis, write your own
LilyPond files manually.
There is no need to use <code>tabr</code> or limit yourself to its existing
LilyPond API.
If you are generating music notation programmatically,
<code>tabr</code> provides the ability to do so in R and has the added benefit of
converting what you write in R code to the LilyPond file format to be
rendered as printable guitar tablature.
</p>
<p>While LilyPond is listed as a system requirement for <code>tabr</code>, you can
use the package for music analysis without installing LilyPond if you do not
intend to render tabs.
</p>

<hr>
<h2 id='tabr_options'>Options</h2><span id='topic+tabr_options'></span>

<h3>Description</h3>

<p>Options for tabr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabr_options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabr_options_+3A_...">...</code></td>
<td>
<p>a list of options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently only <code>lilypond</code>, <code>midi2ly</code> and <code>python</code> are used.
On Windows systems, if the system path for lilypond.exe, midi2ly and
python.exe are not stored in the system PATH environmental variable, they
must be provided by the user after loading the package.
</p>


<h3>Value</h3>

<p>The function prints all set options if called with no arguments.
When setting options, nothing is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tabr_options()
lilypond_path &lt;- "C:/lilypond-2.24.2/bin/lilypond.exe" # if installed here
tabr_options(lilypond = lilypond_path)
</code></pre>

<hr>
<h2 id='tabr-c'>Concatenate for tabr classes</h2><span id='topic+tabr-c'></span><span id='topic+c.noteworthy'></span><span id='topic+c.noteinfo'></span><span id='topic+c.music'></span><span id='topic+c.lyrics'></span><span id='topic+c.phrase'></span>

<h3>Description</h3>

<p>Several methods are implemented for the classes <code>noteworthy</code>, <code>noteinfo</code>, and
<code>music</code>. See <code><a href="#topic+tabr-methods">tabr-methods()</a></code> for more details on methods for tabr classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'noteworthy'
c(...)

## S3 method for class 'noteinfo'
c(...)

## S3 method for class 'music'
c(...)

## S3 method for class 'lyrics'
c(...)

## S3 method for class 'phrase'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabr-c_+3A_...">...</code></td>
<td>
<p>objects.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tabr-methods">tabr-methods()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># noteworthy class examples
x &lt;- "a b c"
c(x, x)
c(as_noteworthy(x), x)

# noteinfo class examples
x &lt;- "4- t8( t8)( t8) 4*2"
c(as_noteinfo(x), x)

# music class examples
x &lt;- "c,~4 c,1 c'e_'g'4-.*2"
c(as_music(x), x)

# phrase class examples
c(phrase(x), x)
</code></pre>

<hr>
<h2 id='tabr-head'>Head and tail for tabr classes</h2><span id='topic+tabr-head'></span><span id='topic+head.noteworthy'></span><span id='topic+head.noteinfo'></span><span id='topic+head.music'></span><span id='topic+head.lyrics'></span><span id='topic+tail.noteworthy'></span><span id='topic+tail.noteinfo'></span><span id='topic+tail.music'></span><span id='topic+tail.lyrics'></span>

<h3>Description</h3>

<p>Several methods are implemented for the classes <code>noteworthy</code>, <code>noteinfo</code>, and
<code>music</code>. See <code><a href="#topic+tabr-methods">tabr-methods()</a></code> for more details on methods for tabr classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'noteworthy'
head(x, ...)

## S3 method for class 'noteinfo'
head(x, ...)

## S3 method for class 'music'
head(x, ...)

## S3 method for class 'lyrics'
head(x, ...)

## S3 method for class 'noteworthy'
tail(x, ...)

## S3 method for class 'noteinfo'
tail(x, ...)

## S3 method for class 'music'
tail(x, ...)

## S3 method for class 'lyrics'
tail(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabr-head_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="tabr-head_+3A_...">...</code></td>
<td>
<p>number of elements to return.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tabr-methods">tabr-methods()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># noteworthy class examples
x &lt;- "a b c d e f g"
head(x, 2)
head(as_noteworthy(x), 2)
tail(as_noteworthy(x), 2)

# noteinfo class examples
x &lt;- "4x 4-.*8 2 4"
head(as_noteinfo(x))
tail(as_noteinfo(x))

# music class examples
x &lt;- "c,~4 c,1 c'e_'g'4-."
head(as_music(x), 2)
tail(as_music(x), 2)
</code></pre>

<hr>
<h2 id='tabr-length'>Length for tabr classes</h2><span id='topic+tabr-length'></span><span id='topic+length.noteworthy'></span><span id='topic+length.noteinfo'></span><span id='topic+length.music'></span><span id='topic+length.lyrics'></span>

<h3>Description</h3>

<p>Several methods are implemented for the classes <code>noteworthy</code>, <code>noteinfo</code>, and
<code>music</code>. See <code><a href="#topic+tabr-methods">tabr-methods()</a></code> for more details on methods for tabr classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'noteworthy'
length(x)

## S3 method for class 'noteinfo'
length(x)

## S3 method for class 'music'
length(x)

## S3 method for class 'lyrics'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabr-length_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tabr-methods">tabr-methods()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># noteworthy class examples
x &lt;- "a b c"
length(x)
length(as_noteworthy(x))
length(as_noteworthy("a b*2 c*2"))

# noteinfo class examples
x &lt;- "4- t8( t8)( t8) 4*2"
length(x)
length(as_noteinfo(x))

# music class examples
x &lt;- "c,~4 c,1 c'e_'g'4-.*4"
length(x)
length(as_music(x))
</code></pre>

<hr>
<h2 id='tabr-methods'>Summary of implemented S3 generic methods</h2><span id='topic+tabr-methods'></span>

<h3>Description</h3>

<p>Several methods are implemented for the classes <code>noteworthy</code>, <code>noteinfo</code>,
<code>music</code> and <code>lyrics</code>. See further below for details on limited
implementations for the <code>phrase</code> class.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabr-methods_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="tabr-methods_+3A_i">i</code></td>
<td>
<p>index.</p>
</td></tr>
<tr><td><code id="tabr-methods_+3A_value">value</code></td>
<td>
<p>values to assign at index.</p>
</td></tr>
<tr><td><code id="tabr-methods_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to custom print and summary methods, the following methods have
been implemented for all four classes: <code>[</code>, <code style="white-space: pre;">&#8288;[&lt;-&#8288;</code>, <code>[[</code>, <code style="white-space: pre;">&#8288;[[&lt;-&#8288;</code>, <code>length()</code>,
<code>c()</code>, <code>rep()</code>, <code>rev()</code>, <code>head()</code> and <code>tail()</code>. Logical operators are also
implemented for noteworthy strings.
</p>


<h3>Methods <code>length()</code> and <code>c()</code></h3>

<p>The implementation of <code>length()</code> is equivalent to <code>n_steps()</code>. They
access the same attribute, returning the number of timesteps in the object.
This gives the same result even when the underlying string is in
space-delimited format. To obtain the character string length, coerce with
<code>as.character()</code> or any other function that would have the same effect.
</p>
<p>The implementation of <code>c()</code> for these classes is strict and favors the
object class in question. This is different from how <code>c()</code> might normally
behave, coercing objects of different types such as numeric and character to
character.
</p>
<p>For these four classes, <code>c()</code> is strict in that it will return
an error if attempting to concatenate one of these classes with any other
class besides character. This includes each other. While it would be
possible to coerce a music object down to a <code>noteworthy</code> object or a
<code>noteinfo</code> object, this is the opposite of the aggressive coercion
these classes are intended to have with <code>c()</code> so this is not done.
</p>
<p>While other classes such as numeric immediately return an error, any
concatenation with character strings attempts to coerce each character
string present to the given class. If coercion fails for any character class
object, the usual error is returned concerning invalid notes or note info
present. If coercion succeeds for all character strings, the result of
<code>c()</code> is to concatenate the timesteps of all objects passed to it. The
output is a new <code>noteworthy</code>, <code>noteinfo</code> or<code>music</code> object.
</p>


<h3>Methods <code>rep()</code> <code>rev()</code> <code>head()</code> and <code>tail()</code></h3>

<p>The <code>rep()</code> function is similar to <code>c()</code> except that it never has to consider
other classes. You could pass a vector of objects to <code>rep()</code>, but doing so
with <code>c()</code> will already have resolved all objects to the single class. Again,
what matters is not the underlying length or elements in the character vector
the class is built upon, but the timesteps. <code>rep()</code> will extend <code>x</code> in terms
of timesteps. You can also provide the <code>each</code> or <code>times</code> arguments.
</p>
<p><code>rev()</code>, <code>head()</code> and <code>tail()</code> work similarly, based on the sequence of
timesteps, not the character vector length.
</p>
<p>Remember that this accounts not only for vectors of length one that contain
multiple timesteps in space-delimited time format, but also that multiple
timesteps can be condensed even in space-delimited time format with the
<code>*</code> expansion operator.
For example, <code>"a'*4 b'*2"</code> has six timesteps in this form as well as in
vector form. The object length is neither one nor two. All of these generic
method implementations work in this manner.
</p>


<h3>Square brackets</h3>

<p>Single and double bracket subsetting by index work similarly to what occurs
with lists. Single bracket subsetting returns the same object, but only
containing the indexed timesteps. Double bracket subsetting only operates on
a single timestep and extracts the character string value.
</p>
<p>For assignment, single and double brackets change the value at timesteps and
return the same object, but again double brackets only allow indexing a
single timestep. Double bracket indexing is mostly useful for combining the
steps of extracting a single value and discarding the special class in one
command.
</p>


<h3>Limited phrase implementations</h3>

<p>Methods implemented for the <code>phrase</code> class are limited to <code>c()</code> and <code>rep()</code>.
Due to the complex LilyPond syntax, applying most of the functions above
directly to phrases is problematic. <code>c()</code> is implemented like it is for the
other classes. <code>rep()</code> is restricted in that it can only repeat the entire
phrase sequence, not the timesteps within. However, you can convert a phrase
class back to <code>noteworthy</code> and <code>noteinfo</code> objects (under reasonable
conditions). See <code><a href="#topic+notify">notify()</a></code>.
</p>
<p>One exception made for <code>phrase</code> objects with respect to concatenation is that
an attempt to concatenate any combination of phrase and music objects, in
any order, results in coercion to a new phrase. This happens even in a case
where the first object in the sequence is a music object (thus calling
<code>c.music()</code> rather than <code>c.phrase()</code>). It will subsequently fall back
to <code>c.phrase()</code> in that case.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+note-logic">note-logic()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># noteworthy class examples
x &lt;- as_noteworthy("a, b, c ce_g d4f#4a4")
x
x[3:4]
x[-2]
x[2] &lt;- paste0(transpose(x[2], 1), "~")
x
length(x) # equal to number of timesteps
c(x, x)
tail(rep(x, times = c(1, 2, 1, 3, 1)))

# noteinfo class examples
x &lt;- as_noteinfo(c("4-", "t8(", "t8)", "t8x", "8^", "16"))
x
x[2:4]
x[-1]
x[5:6] &lt;- c("16^", "8")
x
x[x == "4-"]
c(x[1], x[2]) == c(x[1:2])
head(rep(x, each = 2))

# music class examples
x &lt;- as_music("c,~4 c,1 c'e_'g'4-.*4")
x
x[1:3]
x[-c(1:2)]
x[3:6] &lt;- "c'e'g'8"
x
c(x[1], x[1]) == x[c(1, 1)]
rev(x)

x[[3]]
x[[3]] &lt;- "b_t8"
x
</code></pre>

<hr>
<h2 id='tabr-rep'>Repeat for tabr classes</h2><span id='topic+tabr-rep'></span><span id='topic+rep.noteworthy'></span><span id='topic+rep.noteinfo'></span><span id='topic+rep.music'></span><span id='topic+rep.lyrics'></span><span id='topic+rep.phrase'></span>

<h3>Description</h3>

<p>Several methods are implemented for the classes <code>noteworthy</code>, <code>noteinfo</code>, and
<code>music</code>. See <code><a href="#topic+tabr-methods">tabr-methods()</a></code> for more details on methods for tabr classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'noteworthy'
rep(x, ...)

## S3 method for class 'noteinfo'
rep(x, ...)

## S3 method for class 'music'
rep(x, ...)

## S3 method for class 'lyrics'
rep(x, ...)

## S3 method for class 'phrase'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabr-rep_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="tabr-rep_+3A_...">...</code></td>
<td>
<p>additional arguments. Not accepted for phrase objects.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tabr-methods">tabr-methods()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># noteworthy class examples
x &lt;- "a b c"
rep(x, 2)
rep(as_noteworthy(x), 2)

# noteinfo class examples
x &lt;- "4x 4-.*2 2"
rep(as_noteinfo(x), times = c(2, 1, 1, 2))

# music class examples
x &lt;- "c,~4 c,1 c'e_'g'4-."
rep(as_music(x), each = 2)

# phrase class examples
rep(phrase(x), 2)
</code></pre>

<hr>
<h2 id='tabr-rev'>Reverse for tabr classes</h2><span id='topic+tabr-rev'></span><span id='topic+rev.noteworthy'></span><span id='topic+rev.noteinfo'></span><span id='topic+rev.music'></span><span id='topic+rev.lyrics'></span>

<h3>Description</h3>

<p>Several methods are implemented for the classes <code>noteworthy</code>, <code>noteinfo</code>, and
<code>music</code>. See <code><a href="#topic+tabr-methods">tabr-methods()</a></code> for more details on methods for tabr classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'noteworthy'
rev(x)

## S3 method for class 'noteinfo'
rev(x)

## S3 method for class 'music'
rev(x)

## S3 method for class 'lyrics'
rev(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabr-rev_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tabr-methods">tabr-methods()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># noteworthy class examples
x &lt;- "a b c"
rev(x)
rev(as_noteworthy(x))

# noteinfo class examples
x &lt;- "4x 4-.*2 2"
rev(as_noteinfo(x))

# music class examples
x &lt;- "c,~4 c,1 c'e_'g'4-."
rev(as_music(x))
</code></pre>

<hr>
<h2 id='tabrSyntax'>tabr syntax</h2><span id='topic+tabrSyntax'></span>

<h3>Description</h3>

<p>A data frame containing descriptions of syntax used in phrase construction
in tabr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabrSyntax
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 columns for syntax description, operators and
examples.
</p>

<hr>
<h2 id='tie'>Tied notes</h2><span id='topic+tie'></span><span id='topic+untie'></span>

<h3>Description</h3>

<p>Tie notes efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tie(x)

untie(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tie_+3A_x">x</code></td>
<td>
<p>character, a single chord.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for bar chords.
</p>


<h3>Value</h3>

<p>a character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tie("e,b,egbe'")
</code></pre>

<hr>
<h2 id='to_tabr'>Music notation syntax converters</h2><span id='topic+to_tabr'></span><span id='topic+from_chorrrds'></span><span id='topic+from_music21'></span>

<h3>Description</h3>

<p>Convert alternative representations of music notation to <code>tabr</code> syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_tabr(id, ...)

from_chorrrds(x, key = "c", guitar = FALSE, gc_args = list())

from_music21(x, accidentals = c("flat", "sharp"), output = c("music", "list"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_tabr_+3A_id">id</code></td>
<td>
<p>character, suffix of <code style="white-space: pre;">&#8288;from_*&#8288;</code> function, e.g., <code>"chorrrds"</code></p>
</td></tr>
<tr><td><code id="to_tabr_+3A_...">...</code></td>
<td>
<p>arguments passed to the function matched by <code>id</code>.</p>
</td></tr>
<tr><td><code id="to_tabr_+3A_x">x</code></td>
<td>
<p>character, general syntax input. See details and examples for how
inputs are structured for each converter.</p>
</td></tr>
<tr><td><code id="to_tabr_+3A_key">key</code></td>
<td>
<p>key signature, used to enforce consistent use of flats or sharps.</p>
</td></tr>
<tr><td><code id="to_tabr_+3A_guitar">guitar</code></td>
<td>
<p>logical, attempt to match input chords to known guitar chords
in <code><a href="#topic+guitarChords">guitarChords()</a></code>. Otherwise by default standard piano chords of
consecutive pitches covering minimum pitch range are returned.</p>
</td></tr>
<tr><td><code id="to_tabr_+3A_gc_args">gc_args</code></td>
<td>
<p>named list of additional arguments passed to <code><a href="#topic+gc_info">gc_info()</a></code>, used
when <code>guitar = TRUE</code>.</p>
</td></tr>
<tr><td><code id="to_tabr_+3A_accidentals">accidentals</code></td>
<td>
<p>character, represent accidentals, <code>"flat"</code> or <code>"sharp"</code>.</p>
</td></tr>
<tr><td><code id="to_tabr_+3A_output">output</code></td>
<td>
<p>character, type of output when multiple options are available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions convert music notation from other data sources into the style
used by <code>tabr</code> for music analysis and sheet music transcription.
</p>


<h3>Value</h3>

<p>noteworthy string for chorrrds; music string or list for music21.
</p>


<h3>Syntax converter for chorrrds</h3>

<p>The input <code>x</code> is a character vector of chords output from the <code>chorrrds</code>
package, as shown in the examples. Output is a noteworthy string object.
</p>
<p>Some sources do not offer as complete or explicit information in order to
make sheet music. However, what is available in those formats is converted
to the extent possible and available function arguments can allow the user
to add some additional specification. Different input syntax makes use of a
different syntax converter. Depending on the format, different arguments
may be available and/or required. The general wrapper function for all of
the available syntax converters is <code>to_tabr()</code>. This function takes an
<code>id</code> argument for the appropriate converter function. See examples.
</p>
<p>For example, output from the <code>chorrrds</code> package that scrapes chord
information from the Cifraclub website only provides chords, not note for
note transcription data for any particular instrument. This means the result
of syntax conversion still yields only chords, which is fine for data
analysis but doesn't add anything useful for sheet music transcription.
</p>
<p>The input in this case also does not specify distinct pitches by assigning
octaves numbers to a chord's notes, not even the root note. It remains up to
the user if they want to apply the information. By default, every chord
starts in octave three. It is also ambiguous how the chord is played since
all that is provided is a generic chord symbol. By default a standard chord
is constructed if it can be determined.
</p>
<p>Setting <code>guitar = TRUE</code> switches to using the <code><a href="#topic+guitarChords">guitarChords()</a></code> dataset to
find matching guitar chords using <code><a href="#topic+gc_info">gc_info()</a></code>, which can be provided
additional arguments in a named list to <code>gc_args</code>. For guitar, this allows
some additional control over the actual structure of the chord, its shape and
position on the guitar neck. The options will never work perfectly for all
chords in <code>chords</code>, but at a minimum, typical default component pitches
will be determined and returned in <code>tabr</code> notation style.
</p>


<h3>Syntax converter for music21</h3>

<p>The input <code>x</code> is a character vector of in music21 tiny notation syntax,
as shown in the examples. Default output is a music object. Setting
<code>output = "list"</code> returns a list of three elements: a noteworthy string,
a note info string, and the time signature.
</p>
<p>The recommendation for music21 syntax is to keep it simple. Do not use the
letter <code>n</code> for explicit natural notes. Do not add text annotations such
as lyrics. Double flats and sharps are not supported. The examples
demonstrate what is currently supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># chorrrds package output
chords &lt;- c("Bb", "Bbm", "Bbm7", "Bbm7(b5)", "Bb7(#5)/G", "Bb7(#5)/Ab")
from_chorrrds(chords)
to_tabr(id = "chorrrds", x = chords)

from_chorrrds(chords, guitar = TRUE)
to_tabr(id = "chorrrds", x = chords, guitar = TRUE)

# music21 tiny notation
x &lt;- "4/4 CC#FF4.. trip{c#8eg# d'- e-' f g a'} D4~# D E F r B16"
from_music21(x)

from_music21(x, accidentals = "sharp")

from_music21(x, output = "list")
</code></pre>

<hr>
<h2 id='track'>Create a music track</h2><span id='topic+track'></span><span id='topic+track_guitar'></span><span id='topic+track_tc'></span><span id='topic+track_bc'></span><span id='topic+track_bass'></span>

<h3>Description</h3>

<p>Create a music track from a collection of musical phrases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track(
  phrase,
  clef = "treble_8",
  key = NA,
  tab = TRUE,
  tuning = "standard",
  voice = 1,
  lyrics = NA
)

track_guitar(
  phrase,
  clef = "treble_8",
  key = NA,
  tab = TRUE,
  tuning = "standard",
  voice = 1,
  lyrics = NA
)

track_tc(phrase, key = NA, voice = 1, lyrics = NA)

track_bc(phrase, key = NA, voice = 1, lyrics = NA)

track_bass(phrase, key = NA, voice = 1, lyrics = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_+3A_phrase">phrase</code></td>
<td>
<p>a phrase object.</p>
</td></tr>
<tr><td><code id="track_+3A_clef">clef</code></td>
<td>
<p>character, include a music staff with the given clef. <code>NA</code> to
suppress. See details.</p>
</td></tr>
<tr><td><code id="track_+3A_key">key</code></td>
<td>
<p>character, key signature for music staff. See details.</p>
</td></tr>
<tr><td><code id="track_+3A_tab">tab</code></td>
<td>
<p>logical, include tablature staff. <code>NA</code> to suppress.</p>
</td></tr>
<tr><td><code id="track_+3A_tuning">tuning</code></td>
<td>
<p>character, pitches describing the instrument string tuning or
a predefined tuning ID. See <code><a href="#topic+tunings">tunings()</a></code>.
Defaults to standard guitar tuning; not relevant if tablature staff is
suppressed.</p>
</td></tr>
<tr><td><code id="track_+3A_voice">voice</code></td>
<td>
<p>integer, ID indicating the unique voice <code>phrase()</code> belongs
to within a single track (another track may share the same tab/music staff
but have a different voice ID). Up to two voices are supported per track.</p>
</td></tr>
<tr><td><code id="track_+3A_lyrics">lyrics</code></td>
<td>
<p>a lyrics object or <code>NA</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Musical phrases generated by <code><a href="#topic+phrase">phrase()</a></code> are fortified in a track table. All
tracks are stored as track tables, one per row, even if that table consists
of a single track. <code>track()</code> creates a single-entry track table. See
<code><a href="#topic+trackbind">trackbind()</a></code> for merging single tracks into a multi-track table. This is row
binding that also properly preserves phrase and track classes.
</p>
<p>There are various <code style="white-space: pre;">&#8288;track_*&#8288;</code> functions offering sensible defaults based on the
function suffix. The base <code>track()</code> function is equivalent to
<code>track_guitar()</code>. See examples. Setting <code>clef = NA</code> or <code>tab = NA</code> suppresses
the music staff or tablature staff, respectively. By default <code>key = NA</code>, in
which case its inherits the global key from the <code>key</code> argument of various
sheet music rendering functions. If planning to bind two tracks as one where
they are given <code>voice = 1</code> and <code>voice = 2</code>, respectively, they must also have
a common key, even if <code>key = NA</code>.
</p>
<p><code>lyrics</code> should only be used for simple tracks that do not contain repeats.
You also need to ensure the timesteps for <code>lyrics</code> align with those of
<code>phrase()</code> in advance. Additionally, LilyPond does not engrave lyrics at
rests or tied notes (excluding first note in tied sequence) so if Therefore,
if <code>phrase()</code> contains rests and tied notes then the lyrics object should be
subset to exclude these timesteps as well. This is in contrast to using
<code style="white-space: pre;">&#8288;render_music*&#8288;</code> functions, which handle this automatically for music objects.
</p>


<h3>Value</h3>

<p>a tibble data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phrase">phrase()</a></code>, <code><a href="#topic+score">score()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- phrase("c ec'g' ec'g'", "4 4 2", "5 4 4")
track(x) # same as track_guitar(x); 8va treble clef above tab staff
track_tc(x) # treble clef sheet music, no tab staff
track_bc(x) # bass clef sheet music, no tab staff

x &lt;- phrase("c, g,c g,c", "4 4 2", "3 2 2")
track_bass(x) # includes tab staff and standard bass tuning
</code></pre>

<hr>
<h2 id='trackbind'>Bind track tables</h2><span id='topic+trackbind'></span>

<h3>Description</h3>

<p>Bind together track tables by row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackbind(..., id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trackbind_+3A_...">...</code></td>
<td>
<p>single-entry track data frames.</p>
</td></tr>
<tr><td><code id="trackbind_+3A_id">id</code></td>
<td>
<p>integer, ID vector indicating distinct tracks corresponding to
distinct sheet music staves. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function appends multiple track tables into a single track table for
preparation of generating a multi-track score. <code>id</code> is used to separate
staves in the sheet music/tablature output. A track's <code>voice</code> is used to
separate distinct voices within a common music staff.
</p>
<p>If not provided, <code>id</code> automatically propagates <code>1:n</code> for <code>n</code> tracks passed to
<code>...</code> when binding these tracks together. This expresses the default
assumption of one staff or music/tab staff pair per track. This is the
typical use case.
</p>
<p>Some tracks represent different voices that share the same staff.
These should be assigned the same <code>id</code>, in which case you must
provide the <code>id</code> argument. Up to two voices per track are supported.
An error will be thrown if any two tracks have both the same <code>voice</code>
and the same <code>id</code>. The pair must be unique. E.g., provide <code>id = c(1, 1)</code> when
you have two tracks with <code>voice</code> equal to 1 and 2. See examples.
</p>
<p>Note that the actual ID values assigned to each track do not matter;
only the order in which tracks are bound, first to last.
</p>


<h3>Value</h3>

<p>a tibble data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phrase">phrase()</a></code>, <code><a href="#topic+track">track()</a></code>, <code><a href="#topic+score">score()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- phrase("c ec'g' ec'g'", "4 4 2", "5 432 432")
x1 &lt;- track(x)
x2 &lt;- track(x, voice = 2)
trackbind(x1, x1)
trackbind(x1, x2, id = c(1, 1))
</code></pre>

<hr>
<h2 id='transpose'>Transpose pitch</h2><span id='topic+transpose'></span><span id='topic+tp'></span>

<h3>Description</h3>

<p>Transpose pitch by a number of semitones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transpose(notes, n = 0, octaves = NULL, accidentals = NULL, key = NULL)

tp(notes, n = 0, octaves = NULL, accidentals = NULL, key = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpose_+3A_notes">notes</code></td>
<td>
<p>character, a noteworthy string.</p>
</td></tr>
<tr><td><code id="transpose_+3A_n">n</code></td>
<td>
<p>integer, positive or negative number of semitones to transpose.</p>
</td></tr>
<tr><td><code id="transpose_+3A_octaves">octaves</code></td>
<td>
<p><code>NULL</code> or character, <code>"tick"</code> or <code>"integer"</code> octave numbering
in result.</p>
</td></tr>
<tr><td><code id="transpose_+3A_accidentals">accidentals</code></td>
<td>
<p><code>NULL</code> or character, represent accidentals, <code>"flat"</code> or
<code>"sharp"</code>.</p>
</td></tr>
<tr><td><code id="transpose_+3A_key">key</code></td>
<td>
<p><code>NULL</code> or character, use a key signature to specify and override
<code>accidentals</code>. Ignored if <code>c</code> or <code>am</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function transposes the pitch of notes in a noteworthy string.
</p>
<p>Transposing is not currently supported on a phrase object. The notes in a
phrase object have already been transformed to LilyPond syntax and mixed with
other potentially complex information. Transposing is intended to be done on
a string of notes prior to passing it to <code>phrase()</code>. It will work on strings
that use either integer or tick mark octave numbering formats and flats or
sharps, in any combination. The transposed result conforms according to the
function arguments. When integer octaves are returned, all <code>3</code>s are dropped
since the third octave is implicit in LilyPond.
</p>
<p>When <code>octaves</code>, <code>accidentals</code> and <code>key</code> are <code>NULL</code>, formatting is inferred
from <code>notes</code>. When mixed formats are present, tick format is the default for
octave numbering and flats are the default for accidentals.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transpose("a_3 b_4 c5", 0)
tp("a_3 b_4 c5", -1)
tp("a_3 b_4 c5", 1)
tp("a#3 b4 c#5", 11)
tp("a#3 b4 c#5", 12)
tp("r s a#3 b4 c#5", 13)
tp("a b' c#''", 2, "integer", "flat")
tp("a, b ceg", 2, "tick", "sharp")
</code></pre>

<hr>
<h2 id='tunings'>Predefined instrument tunings</h2><span id='topic+tunings'></span>

<h3>Description</h3>

<p>A data frame containing some predefined instrument tunings commonly used for
guitar, bass, mandolin, banjo, ukulele and orchestral instruments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tunings
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 columns for the tuning ID and corresponding
pitches and 32 rows for all predefined tunings.
</p>

<hr>
<h2 id='tuplet'>Tuplets</h2><span id='topic+tuplet'></span><span id='topic+triplet'></span>

<h3>Description</h3>

<p>Helper function for generating tuplet syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuplet(x, n, string = NULL, a = 3, b = 2)

triplet(x, n, string = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tuplet_+3A_x">x</code></td>
<td>
<p>noteworthy string or phrase object.</p>
</td></tr>
<tr><td><code id="tuplet_+3A_n">n</code></td>
<td>
<p>integer, duration of each tuplet note, e.g., 8 for 8th note tuplet.</p>
</td></tr>
<tr><td><code id="tuplet_+3A_string">string</code></td>
<td>
<p>character, optional string or vector with same number of
timesteps as <code>x</code> that specifies which strings to play for each specific
note. Only applies when <code>x</code> is a noteworthy string.</p>
</td></tr>
<tr><td><code id="tuplet_+3A_a">a</code></td>
<td>
<p>integer, notes per tuplet.</p>
</td></tr>
<tr><td><code id="tuplet_+3A_b">b</code></td>
<td>
<p>integer, beats per tuplet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives control over tuplet construction. The default arguments
<code>a = 3</code> and <code>b = 2</code> generates a triplet where three triplet notes,
each lasting for two thirds of a beat, take up two beats.
<code style="white-space: pre;">&#8288;n} is used to describe the beat duration with the same fraction-of-measure denominator notation used for notes in &#8288;</code>tabr' phrases,
e.g., 16th note triplet, 8th note triplet, etc.
</p>
<p>If you provide a note sequence for multiple tuplets in a row of the same
type, they will be connected automatically. It is not necessary to call
<code>tuplet()</code> each time when the pattern is constant.
If you provide a complete phrase object, it will simply be wrapped in the
tuplet tag, so take care to ensure the phrase contents make sense as part of
a tuplet.
</p>


<h3>Value</h3>

<p>phrase
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tuplet("c c# d", 8)
triplet("c c# d", 8)
tuplet("c c# d c c# d", 4, a = 6, b = 4)

p1 &lt;- phrase("c c# d", "8-. 8( 8)", "5*3")
tuplet(p1, 8)
</code></pre>

<hr>
<h2 id='valid-noteinfo'>Check note info validity</h2><span id='topic+valid-noteinfo'></span><span id='topic+informable'></span><span id='topic+as_noteinfo'></span><span id='topic+is_noteinfo'></span>

<h3>Description</h3>

<p>Check whether a note info string is comprised exclusively of valid note info
syntax.
<code>noteinfo</code> returns a scalar logical result indicating whether the entire set
contains exclusively valid entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>informable(x, na.rm = FALSE)

as_noteinfo(x, format = NULL)

is_noteinfo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid-noteinfo_+3A_x">x</code></td>
<td>
<p>character, a note info string.</p>
</td></tr>
<tr><td><code id="valid-noteinfo_+3A_na.rm">na.rm</code></td>
<td>
<p>remove <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="valid-noteinfo_+3A_format">format</code></td>
<td>
<p><code>NULL</code> or character, the timestep delimiter format, <code>"space"</code>
or <code>"vector"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_noteinfo()</code> can be used to coerce to the <code>noteinfo</code> class.
Coercion will fail if the string is has any syntax that is not valid for
note info.
Using the <code>noteinfo</code> class is generally not needed by the user during
an interactive session, but is available and offers its own <code>print()</code> and
<code>summary()</code> methods for note info strings.
The class is often used by other functions, and functions that output a
note info string attach the <code>noteinfo</code> class.
</p>
<p>When <code>format = NULL</code>, the timestep delimiter format is inferred from the note
info string input. When unclear, such as with phrase objects, the default is
space-delimited time.
</p>


<h3>Value</h3>

<p>depends on the function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+noteinfo">noteinfo()</a></code>, <code><a href="#topic+valid-notes">valid-notes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- notate("8x", "Start here")
x &lt;- paste(a, "8[stacatto] 8-. 16 4.. 16- 16 2^ 2 4. 8( 4)( 4) 8*4 1 1")

informable(x) # is it of 'noteinfo' class; a validity check for any string
x &lt;- as_noteinfo(x) # coerce to 'noteinfo' class
is_noteinfo(x) # check for 'noteinfo' class
x

summary(x)
</code></pre>

<hr>
<h2 id='valid-notes'>Check note and chord validity</h2><span id='topic+valid-notes'></span><span id='topic+is_note'></span><span id='topic+is_chord'></span><span id='topic+noteworthy'></span><span id='topic+as_noteworthy'></span><span id='topic+is_noteworthy'></span>

<h3>Description</h3>

<p>Check if a string is comprised exclusively of valid note and/or chord syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_note(x, na.rm = FALSE)

is_chord(x, na.rm = FALSE)

noteworthy(x, na.rm = FALSE)

as_noteworthy(x, octaves = NULL, accidentals = NULL, format = NULL)

is_noteworthy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid-notes_+3A_x">x</code></td>
<td>
<p>character, a noteworthy string.</p>
</td></tr>
<tr><td><code id="valid-notes_+3A_na.rm">na.rm</code></td>
<td>
<p>remove <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="valid-notes_+3A_octaves">octaves</code></td>
<td>
<p><code>NULL</code> or character, <code>"tick"</code> or <code>"integer"</code> octave numbering
in result.</p>
</td></tr>
<tr><td><code id="valid-notes_+3A_accidentals">accidentals</code></td>
<td>
<p><code>NULL</code> or character, represent accidentals, <code>"flat"</code> or
<code>"sharp"</code>.</p>
</td></tr>
<tr><td><code id="valid-notes_+3A_format">format</code></td>
<td>
<p><code>NULL</code> or character, the timestep delimiter format, <code>"space"</code>
or <code>"vector"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_note()</code> and <code>is_chord()</code> are vectorized and their positive results
are mutually exclusive. <code>noteworthy()</code> is also vectorized and performs both
checks, but it returns a scalar logical result indicating whether the entire
set contains exclusively valid entries.
</p>
<p><code>as_noteworthy()</code> can be used to coerce to the <code>noteworthy</code> class. Coercion
will fail if the string is not noteworthy.
While many functions will work on simple character strings and, if their
syntax is valid, coerce them to the 'noteworthy' class, it is recommended to
use this class. Not all functions are so aggressive, and several generic
methods are implemented for the class. It also offers its own <code>print()</code>
and <code>summary()</code> methods for noteworthy strings.
An added benefit to using <code>as_noteworthy()</code> is to conform all notes in a
noteworthy string to specific formatting for accidentals and octave numbering.
Functions that output a noteworthy string attach the <code>noteworthy</code> class.
</p>
<p>When <code>octaves</code>, <code>accidentals</code>, and <code>format</code> are <code>NULL</code>, formatting is
inferred from the noteworthy string input. When mixed formats are present,
tick format is the default for octave numbering and flats are the default for
accidentals.
</p>


<h3>Value</h3>

<p>depends on the function
</p>


<h3>See Also</h3>

<p><code><a href="#topic+note-checks">note-checks()</a></code>, <code><a href="#topic+note-metadata">note-metadata()</a></code>, <code><a href="#topic+note-summaries">note-summaries()</a></code>,
<code><a href="#topic+note-coerce">note-coerce()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "a# b_ c, d'' e3 g_4 A m c2e_2g2 cegh" # includes invalid syntax
data.frame(
  x = strsplit(x, " ")[[1]],
  note = is_note(x),
  chord = is_chord(x),
  either = noteworthy(x))

is_diatonic("ace ac#e d e_", "c")

x &lt;- "a# b_ c,~ c, d'' e3 g_4 c2e_2g2"
noteworthy(x) # is it noteworthy; a validity check for any string
x &lt;- as_noteworthy(x) # coerce to 'noteworthy' class, conform formatting
is_noteworthy(x) # check for 'noteworthy' class
x

summary(x)

x &lt;- as_noteworthy(x, format = "vector", octaves = "integer",
                   accidentals = "flat")
x

summary(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
