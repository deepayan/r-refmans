<!DOCTYPE html><html><head><title>Help for package shinyCohortBuilder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shinyCohortBuilder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#shinyCohortBuilder-package'><p>GUI layer for cohortBuilder package</p></a></li>
<li><a href='#.cb_input'><p>Create input controller insensitive to server updates</p></a></li>
<li><a href='#.render_filter'><p>Define filter related output in filtering panel</p></a></li>
<li><a href='#.save_observer'><p>Save observer to user session</p></a></li>
<li><a href='#.sendOutput'><p>Send output rendering</p></a></li>
<li><a href='#autofilter'><p>Generate filters definition based on the Source data</p></a></li>
<li><a href='#available-filters-choices'><p>Generate available filters choices based on the Source data</p></a></li>
<li><a href='#cb_ui'><p>Include filtering panel in Shiny</p></a></li>
<li><a href='#demo_app'><p>Run demo application</p></a></li>
<li><a href='#gui'><p>Run filtering panel locally</p></a></li>
<li><a href='#gui-filter-layer'><p>Return GUI layer methods for filter of specified type</p></a></li>
<li><a href='#keep_na_input'><p>Generate NA's filter selection GUI input</p></a></li>
<li><a href='#pre_post_stats'><p>Generate structure of pre/post statistics</p></a></li>
<li><a href='#rendering-custom-attrition'><p>Method for generating custom attrition output</p></a></li>
<li><a href='#rendering-filters'><p>Render filtering panels for all the filters included in Cohort</p></a></li>
<li><a href='#rendering-step-attrition'><p>Generate output of attrition plot</p></a></li>
<li><a href='#source-gui-layer'><p>Source compatibility methods.</p></a></li>
<li><a href='#trigger-action'><p>Trigger filtering panel action</p></a></li>
<li><a href='#updating-data-statistics'><p>Render source data related statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modular Cohort-Building Framework for Analytical Dashboards</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Krystian Igras &lt;krystian8207@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>You can easily add advanced cohort-building component
    to your analytical dashboard or simple 'Shiny' app.
    Then you can instantly start building cohorts using multiple
    filters of different types, filtering datasets, and filtering steps.
    Filters can be complex and data-specific, and together
    with multiple filtering steps you can use complex filtering rules.
    The cohort-building sidebar panel allows you to easily
    work with filters, add and remove filtering steps.
    It helps you with handling missing values during filtering,
    and provides instant filtering feedback with filter feedback plots.
    The GUI panel is not only compatible with native shiny
    bookmarking, but also provides reproducible R code.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, glue, bslib, jsonlite, purrr, ggplot2, ggiraph,
htmltools, shiny (&ge; 1.7.0), shinyWidgets (&ge; 0.7.0),
htmlwidgets, dplyr, cohortBuilder (&ge; 0.2.0), tryCatchLog,
highr, shinyGizmo (&ge; 0.4.2), rlang (&ge; 1.0), tibble, lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pkgload, packer, sass, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'shinyCohortBuilder-package.R' 'ui_utils.R' 'control_utils.R'
'actions.R' 'renders.R' 'filter_discrete.R' 'filter_range.R'
'filter_date_range.R' 'filter_discrete_text.R'
'filter_multi_discrete.R' 'app.R' 'cb_layer.R' 'source.R'
'source_tblist.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-28 08:15:54 UTC; krystiai</td>
</tr>
<tr>
<td>Author:</td>
<td>Krystian Igras [cre, aut],
  Kamil Wais [aut],
  Adam Fory≈õ [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-28 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='shinyCohortBuilder-package'>GUI layer for cohortBuilder package</h2><span id='topic+shinyCohortBuilder-package'></span>

<h3>Description</h3>

<p>GUI layer for cohortBuilder package
</p>

<hr>
<h2 id='.cb_input'>Create input controller insensitive to server updates</h2><span id='topic+.cb_input'></span>

<h3>Description</h3>

<p>Input controllers created with '.cb_input' are sending its value to server only when
user changes it's value directly in browser.
That means all the 'update*' functions have only visible effect on application output.
</p>
<p>The method should be used for each filter input controller and precise which
filter value should be updated when the input selection is changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cb_input(ui, data_param, ..., priority = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cb_input_+3A_ui">ui</code></td>
<td>
<p>UI defining input controllers.</p>
</td></tr>
<tr><td><code id=".cb_input_+3A_data_param">data_param</code></td>
<td>
<p>Name of the parameter that should be updated in filter whenever user change the input value.</p>
</td></tr>
<tr><td><code id=".cb_input_+3A_...">...</code></td>
<td>
<p>Extra attributes passed to the input div container.</p>
</td></tr>
<tr><td><code id=".cb_input_+3A_priority">priority</code></td>
<td>
<p>Set to 'event' to force sending value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'shiny.tag' object defining html structure of filter input container.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
  library(shiny)
  library(shinyCohortBuilder)

  shiny::addResourcePath(
    "shinyCohortBuilder",
    system.file("www", package = "shinyCohortBuilder")
  )
  ui &lt;- fluidPage(
    tags$head(
      shiny::tags$script(type = "text/javascript", src = file.path("shinyCohortBuilder", "scb.js"))
    ),
    actionButton("update", "Update with random value"),
    div(
      class = "cb_container",
      `data-ns_prefix` = "",
      div(
        class = "cb_step",
        `data-step_id` = "1",
        div(
          class = "cb_filter",
          `data-filter_id` = "filid",
          .cb_input(
            numericInput("val", "Value", value = 1),
            data_param = "range"
          )
        )
      )
    )
  )

  server &lt;- function(input, output, session) {
    observeEvent(input$action, {
      # print should be avoided when value is changed due to update
      print(input$action)
    })
    observeEvent(input$update, {
      updateNumericInput(session, "val", value = rnorm(1))
    })
  }

  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='.render_filter'>Define filter related output in filtering panel</h2><span id='topic+.render_filter'></span>

<h3>Description</h3>

<p>The method exported only for custom extensions use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.render_filter(filter, step_id, cohort, ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".render_filter_+3A_filter">filter</code></td>
<td>
<p>Filter object.</p>
</td></tr>
<tr><td><code id=".render_filter_+3A_step_id">step_id</code></td>
<td>
<p>Id of the step.</p>
</td></tr>
<tr><td><code id=".render_filter_+3A_cohort">cohort</code></td>
<td>
<p>Cohort object.</p>
</td></tr>
<tr><td><code id=".render_filter_+3A_ns">ns</code></td>
<td>
<p>Namespace function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'shiny.tag' class 'div' object defining html structure of filter input panel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(magrittr)
  library(shiny)
  library(cohortBuilder)
  library(shinyCohortBuilder)

  ui &lt;- fluidPage(
    actionButton("add_filter", "Add Filter"),
    div(id = "filter_container")
  )

  server &lt;- function(input, output, session) {
    add_gui_filter_layer &lt;- function(public, private, ...) {
      private$steps[["1"]]$filters$copies$gui &lt;- .gui_filter(
        private$steps[["1"]]$filters$copies
      )
    }
    add_hook("post_cohort_hook", add_gui_filter_layer)
    coh &lt;- cohort(
      set_source(as.tblist(librarian)),
      filter(
        "range", id = "copies", name = "Copies", dataset = "books",
        variable = "copies", range = c(5, 12)
      )
    ) %&gt;% run()
    coh$attributes$session &lt;- session
    coh$attributes$feedback &lt;- TRUE

    observeEvent(input$add_filter, {
      insertUI(
        "#filter_container",
        ui = .render_filter(
          coh$get_filter("1", "copies"),
          step_id = "1",
          cohort = coh,
          ns = function(x) x
        ))
    }, ignoreInit = TRUE, once = TRUE)
  }

  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='.save_observer'>Save observer to user session</h2><span id='topic+.save_observer'></span>

<h3>Description</h3>

<p>The method used to store created observers (used to implement extra filter logic).
The saved observer are then destroyed when filtering step is removed which prevents
duplicated execution of accumulated observers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.save_observer(observer, id, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".save_observer_+3A_observer">observer</code></td>
<td>
<p>An 'observe' or 'observeEvent' to be saved.</p>
</td></tr>
<tr><td><code id=".save_observer_+3A_id">id</code></td>
<td>
<p>Id of the observer. Preferably prefixed with step_id.
The saved observer is saved as &lsquo;session$userData$observers[[&rsquo;&lt;id&gt;-observer']]' object.</p>
</td></tr>
<tr><td><code id=".save_observer_+3A_session">session</code></td>
<td>
<p>Shiny session object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, used for side effect which is saving the observer to
'session$userData' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(shiny)
  library(shinyCohortBuilder)

  ui &lt;- fluidPage(
    numericInput("power", "Power", min = 0, max = 10, value = 1, step = 1),
    numericInput("value", "Value", min = 0, max = 100, value = 2, step = 0.1),
    actionButton("add", "Observe the selected power"),
    actionButton("rm", "Stop observing the selected power")
  )

  server &lt;- function(input, output, session) {
    observeEvent(input$add, {
      .save_observer(
        observeEvent(input$value, {
           print(input$value ^ input$power)
        }),
        as.character(input$power),
        session = session
      )
    }, ignoreInit = TRUE)

    observeEvent(input$rm, {
      id &lt;- paste0(input$power, "-observer")
      session$userData$observers[[id]]$destroy()
      session$userData$observers[[id]] &lt;- NULL
    }, ignoreInit = TRUE)
  }

  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='.sendOutput'>Send output rendering</h2><span id='topic+.sendOutput'></span>

<h3>Description</h3>

<p>Functional approach to rendering output.
Equivalent of 'output[[name]] &lt;- rendering'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sendOutput(name, rendering, session = shiny::getDefaultReactiveDomain())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sendOutput_+3A_name">name</code></td>
<td>
<p>Name of the output to be rendered</p>
</td></tr>
<tr><td><code id=".sendOutput_+3A_rendering">rendering</code></td>
<td>
<p>Rendering expression to be sent.</p>
</td></tr>
<tr><td><code id=".sendOutput_+3A_session">session</code></td>
<td>
<p>Shiny session object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, used for side effect which is assigning rendering to the output object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(shiny)
  library(shinyCohortBuilder)

  rendering &lt;- function(x_max) {
    renderPlot({
      x &lt;- seq(0, x_max, by = 0.01)
      plot(x, sin(x), type = "l")
    })
  }

  ui &lt;- fluidPage(
    numericInput("xmax", "X Axis Limit", min = 0, max = 10, value = pi),
    plotOutput("out")
  )

  server &lt;- function(input, output, session) {
    observeEvent(input$xmax, {
      .sendOutput("out", rendering(input$xmax))
    })
  }

  shinyApp(ui, server)
}

</code></pre>

<hr>
<h2 id='autofilter'>Generate filters definition based on the Source data</h2><span id='topic+autofilter'></span><span id='topic+autofilter.default'></span><span id='topic+autofilter.tblist'></span>

<h3>Description</h3>

<p>The method should analyze source data structure, generate proper filters based on
the data (e.g. column types) and attach them to source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autofilter(source, attach_as = c("step", "meta"), ...)

## Default S3 method:
autofilter(source, ...)

## S3 method for class 'tblist'
autofilter(source, attach_as = c("step", "meta"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autofilter_+3A_source">source</code></td>
<td>
<p>Source object.</p>
</td></tr>
<tr><td><code id="autofilter_+3A_attach_as">attach_as</code></td>
<td>
<p>Choose whether the filters should be attached as a new step,
or list of available filters (used in filtering panel when 'new_step = &quot;configure&quot;').
By default in <code>step</code>.</p>
</td></tr>
<tr><td><code id="autofilter_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to a specific method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Source object having step configuration attached.
</p>


<h3>See Also</h3>

<p><a href="#topic+source-gui-layer">source-gui-layer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
library(cohortBuilder)
library(shinyCohortBuilder)

iris_source &lt;- set_source(tblist(iris = iris)) %&gt;%
  autofilter()
iris_cohort &lt;- cohort(iris_source)
sum_up(iris_cohort)

if (interactive()) {
  library(shiny)

  ui &lt;- fluidPage(
    cb_ui("mycoh")
  )

  server &lt;- function(input, output, session) {
    cb_server("mycoh", cohort = iris_cohort)
  }

  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='available-filters-choices'>Generate available filters choices based on the Source data</h2><span id='topic+available-filters-choices'></span><span id='topic+.available_filters_choices'></span><span id='topic+.available_filters_choices.default'></span><span id='topic+.available_filters_choices.tblist'></span>

<h3>Description</h3>

<p>The method should return the available choices for
virtualSelect input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.available_filters_choices(source, cohort, ...)

## Default S3 method:
.available_filters_choices(source, cohort, ...)

## S3 method for class 'tblist'
.available_filters_choices(source, cohort, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="available-filters-choices_+3A_source">source</code></td>
<td>
<p>Source object.</p>
</td></tr>
<tr><td><code id="available-filters-choices_+3A_cohort">cohort</code></td>
<td>
<p>cohortBuilder cohort object</p>
</td></tr>
<tr><td><code id="available-filters-choices_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to a specific method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'shinyWidgets::prepare_choices' output value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(magrittr)
  library(shiny)
  library(cohortBuilder)
  library(shinyCohortBuilder)
  library(shinyWidgets)

  coh &lt;- cohort(
    set_source(as.tblist(librarian), available_filters = list(
      filter(
        "range", id = "copies", name = "Copies", dataset = "books",
        variable = "copies", range = c(5, 12)
      ),
      filter(
        "date_range", id = "registered", name = "Registered",  dataset = "borrowers",
        variable = "registered", range = c(as.Date("2010-01-01"), Inf)
      )
    ))
  ) %&gt;% run()
  filter_choices &lt;- .available_filters_choices(coh$get_source(), coh)

  ui &lt;- fluidPage(
    virtualSelectInput("filters", "Filters", choices = filter_choices, html = TRUE)
  )

  server &lt;- function(input, output, session) {

  }

  shinyApp(ui, server)
}

</code></pre>

<hr>
<h2 id='cb_ui'>Include filtering panel in Shiny</h2><span id='topic+cb_ui'></span><span id='topic+cb_server'></span>

<h3>Description</h3>

<p>The function returns filtering panel placeholder, you may use in you custom Shiny application.
Use in the UI part of your application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cb_ui(
  id,
  ...,
  state = FALSE,
  steps = TRUE,
  code = TRUE,
  attrition = TRUE,
  new_step = c("clone", "configure")
)

cb_server(
  id,
  cohort,
  run_button = "none",
  stats = c("pre", "post"),
  feedback = FALSE,
  enable_bookmarking = shiny::getShinyOption("bookmarkStore", default = "disable"),
  show_help = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cb_ui_+3A_id">id</code></td>
<td>
<p>Id of the module used to render the panel.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_...">...</code></td>
<td>
<p>Extra attributes passed to the panel div container.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_state">state</code></td>
<td>
<p>Set to TRUE (default) to enable get/set state panel.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_steps">steps</code></td>
<td>
<p>Set to TRUE (default) if multiple steps should be available.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_code">code</code></td>
<td>
<p>Set to TRUE (default) to enable reproducible code panel.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_attrition">attrition</code></td>
<td>
<p>Set to TRUE (default) to enable attrition plot panel.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_new_step">new_step</code></td>
<td>
<p>Choose which add step method should be used for creating new step.
Possible options are: &quot;clone&quot; - copy filters from last step,
&quot;configure&quot; - opening modal and allow to chose filters from available filters.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_cohort">cohort</code></td>
<td>
<p>Cohort object storing filtering steps configuration.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_run_button">run_button</code></td>
<td>
<p>Should Run button be displayed? If so, the current step computations are run only when clicked.
Three options are available &quot;none&quot; - no button, &quot;local&quot; - button displayed at each step panel,
&quot;global&quot; - button visible in top filtering panel.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_stats">stats</code></td>
<td>
<p>Choose which statistics should be displayed for data (and some filters).
Possible options are: &quot;pre&quot; - previous step stat, &quot;post&quot; - current step stats,
'c(&quot;pre&quot;, &quot;post&quot;)' - for both and NULL for no stats.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_feedback">feedback</code></td>
<td>
<p>Set to TRUE (default) if feedback plots should be displayed at each filter.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_enable_bookmarking">enable_bookmarking</code></td>
<td>
<p>Set to TRUE (default) if panel should be compatible with native shiny bookmarking.</p>
</td></tr>
<tr><td><code id="cb_ui_+3A_show_help">show_help</code></td>
<td>
<p>Set to TRUE (default) to enable help buttons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nested list of 'shiny.tag' objects - html structure of filtering panel module.
</p>
<p>'shiny::moduleServer' output providing server logic for filtering panel module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(cohortBuilder)
  library(shiny)
  library(shinyCohortBuilder)

  librarian_source &lt;- set_source(as.tblist(librarian))
  librarian_cohort &lt;- cohort(
    librarian_source,
    filter(
      "discrete", id = "author", dataset = "books",
      variable = "author", value = "Dan Brown",
      active = FALSE
    ),
    filter(
      "range", id = "copies", dataset = "books",
      variable = "copies", range = c(5, 10),
      active = FALSE
    ),
    filter(
      "date_range", id = "registered", dataset = "borrowers",
      variable = "registered", range = c(as.Date("2010-01-01"), Inf),
      active = FALSE
    )
  )

  ui &lt;- fluidPage(
    sidebarLayout(
      sidebarPanel(
        cb_ui("librarian")
      ),
      mainPanel()
    )
  )

  server &lt;- function(input, output, session) {
    cb_server("librarian", librarian_cohort)
  }

  shinyApp(ui, server)
}

</code></pre>

<hr>
<h2 id='demo_app'>Run demo application</h2><span id='topic+demo_app'></span>

<h3>Description</h3>

<p>The demo presents available filters and toolbox features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo_app(
  steps = TRUE,
  stats = c("pre", "post"),
  run_button = "none",
  feedback = TRUE,
  state = TRUE,
  bootstrap = 3,
  enable_bookmarking = TRUE,
  code = TRUE,
  attrition = TRUE,
  show_help = TRUE,
  new_step = c("clone", "configure"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demo_app_+3A_steps">steps</code></td>
<td>
<p>Set to TRUE (default) if multiple steps should be available.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_stats">stats</code></td>
<td>
<p>Choose which statistics should be displayed for data (and some filters).
Possible options are: &quot;pre&quot; - previous step stat, &quot;post&quot; - current step stats,
'c(&quot;pre&quot;, &quot;post&quot;)' - for both and NULL for no stats.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_run_button">run_button</code></td>
<td>
<p>Should Run button be displayed? If so, the current step computations are run only when clicked.
Three options are available &quot;none&quot; - no button, &quot;local&quot; - button displayed at each step panel,
&quot;global&quot; - button visible in top filtering panel.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_feedback">feedback</code></td>
<td>
<p>Set to TRUE (default) if feedback plots should be displayed at each filter.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_state">state</code></td>
<td>
<p>Set to TRUE (default) to enable get/set state panel.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Boostrap version to be used for filtering panel.
See <a href="bslib.html#topic+bs_theme">bs_theme</a> version argument.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_enable_bookmarking">enable_bookmarking</code></td>
<td>
<p>Set to TRUE (default) if panel should be compatible with native shiny bookmarking.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_code">code</code></td>
<td>
<p>Set to TRUE (default) to enable reproducible code panel.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_attrition">attrition</code></td>
<td>
<p>Set to TRUE (default) to enable attrition plot panel.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_show_help">show_help</code></td>
<td>
<p>Set to TRUE (default) to enable help buttons.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_new_step">new_step</code></td>
<td>
<p>Choose which add step method should be used for creating new step.
Possible options are: &quot;clone&quot; - copy filters from last step,
&quot;configure&quot; - opening modal and allow to chose filters from available filters.</p>
</td></tr>
<tr><td><code id="demo_app_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to selected cohort methods.
Now only <a href="htmltools.html#topic+code">code</a> arguments are supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, used for side effect which is running a Shiny application.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(shinyCohortBuilder)
  demo_app(steps = FALSE)
}
if (interactive()) {
  library(shinyCohortBuilder)
  demo_app(run_button = "local", state = FALSE)
}
</code></pre>

<hr>
<h2 id='gui'>Run filtering panel locally</h2><span id='topic+gui'></span>

<h3>Description</h3>

<p>Run filtering panel locally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gui(
  cohort,
  steps = TRUE,
  stats = c("pre", "post"),
  run_button = "none",
  feedback = TRUE,
  state = TRUE,
  bootstrap = 3,
  enable_bookmarking = TRUE,
  code = TRUE,
  attrition = TRUE,
  show_help = TRUE,
  new_step = c("clone", "configure")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gui_+3A_cohort">cohort</code></td>
<td>
<p>Cohort object with configured filters.</p>
</td></tr>
<tr><td><code id="gui_+3A_steps">steps</code></td>
<td>
<p>Set to TRUE (default) if multiple steps should be available.</p>
</td></tr>
<tr><td><code id="gui_+3A_stats">stats</code></td>
<td>
<p>Choose which statistics should be displayed for data (and some filters).
Possible options are: &quot;pre&quot; - previous step stat, &quot;post&quot; - current step stats,
'c(&quot;pre&quot;, &quot;post&quot;)' - for both and NULL for no stats.</p>
</td></tr>
<tr><td><code id="gui_+3A_run_button">run_button</code></td>
<td>
<p>Should Run button be displayed? If so, the current step computations are run only when clicked.
Three options are available &quot;none&quot; - no button, &quot;local&quot; - button displayed at each step panel,
&quot;global&quot; - button visible in top filtering panel.</p>
</td></tr>
<tr><td><code id="gui_+3A_feedback">feedback</code></td>
<td>
<p>Set to TRUE (default) if feedback plots should be displayed at each filter.</p>
</td></tr>
<tr><td><code id="gui_+3A_state">state</code></td>
<td>
<p>Set to TRUE (default) to enable get/set state panel.</p>
</td></tr>
<tr><td><code id="gui_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Boostrap version to be used for filtering panel.
See <a href="bslib.html#topic+bs_theme">bs_theme</a> version argument.</p>
</td></tr>
<tr><td><code id="gui_+3A_enable_bookmarking">enable_bookmarking</code></td>
<td>
<p>Set to TRUE (default) if panel should be compatible with native shiny bookmarking.</p>
</td></tr>
<tr><td><code id="gui_+3A_code">code</code></td>
<td>
<p>Set to TRUE (default) to enable reproducible code panel.</p>
</td></tr>
<tr><td><code id="gui_+3A_attrition">attrition</code></td>
<td>
<p>Set to TRUE (default) to enable attrition plot panel.</p>
</td></tr>
<tr><td><code id="gui_+3A_show_help">show_help</code></td>
<td>
<p>Set to TRUE (default) to enable help buttons.</p>
</td></tr>
<tr><td><code id="gui_+3A_new_step">new_step</code></td>
<td>
<p>Choose which add step method should be used for creating new step.
Possible options are: &quot;clone&quot; - copy filters from last step,
&quot;configure&quot; - opening modal and allow to chose filters from available filters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, used for side effect which is running a Shiny application.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(magrittr)
  library(cohortBuilder)
  library(shinyCohortBuilder)
  mtcars_source &lt;- set_source(tblist(mtcars = mtcars))
  mtcars_cohort &lt;- cohort(
    mtcars_source,
    filter("discrete", id = "am", dataset = "mtcars", variable = "am", value = 1)
  ) %&gt;% run()
  gui(mtcars_cohort)
}

</code></pre>

<hr>
<h2 id='gui-filter-layer'>Return GUI layer methods for filter of specified type</h2><span id='topic+gui-filter-layer'></span><span id='topic+.gui_filter'></span><span id='topic+.gui_filter.discrete'></span><span id='topic+.gui_filter.range'></span><span id='topic+.gui_filter.date_range'></span><span id='topic+.gui_filter.discrete_text'></span><span id='topic+.gui_filter.multi_discrete'></span>

<h3>Description</h3>

<p>For each filter type '.gui_filter' method should return a list of the below objects:
</p>

<ul>
<li><p>input UI structure defining filter input controllers.
</p>
</li>
<li><p>feedback List defining feedback plot output.
</p>
</li>
<li><p>server Optional server-side expression attached to filter panel (e.g. filter specific observers).
</p>
</li>
<li><p>update An expression used for updating filter panel based on its configuration.
</p>
</li>
<li><p>post_stats TRUE if post statistics are displayed in filter controller (e.g. for discrete filter).
If FALSE, some operations are skipped which results with better performance.
</p>
</li>
<li><p>multi_input TRUE if multiple input controllers are used for providing
filter value (e.g. range input where both numericInput and sliderInput are used).
If FALSE, some operations are skipped which results with better performance.

</p>
</li></ul>

<p>If you want to learn more about creating filter layers see 'vignette(&quot;gui-filter-layer&quot;)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.gui_filter(filter, ...)

## S3 method for class 'discrete'
.gui_filter(filter, ...)

## S3 method for class 'range'
.gui_filter(filter, ...)

## S3 method for class 'date_range'
.gui_filter(filter, ...)

## S3 method for class 'discrete_text'
.gui_filter(filter, ...)

## S3 method for class 'multi_discrete'
.gui_filter(filter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gui-filter-layer_+3A_filter">filter</code></td>
<td>
<p>Filter object.</p>
</td></tr>
<tr><td><code id="gui-filter-layer_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to a specific method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List consisting filter metadata and methods that allow to perform filter based operations.
See 'vignette(&quot;custom-filters&quot;)'.
</p>


<h3>See Also</h3>

<p><a href="#topic+source-gui-layer">source-gui-layer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cohortBuilder)
librarian_source &lt;- set_source(as.tblist(librarian))
copies_filter &lt;- filter(
  "range", id = "copies", name = "Copies", dataset = "books",
  variable = "copies", range = c(5, 12)
)
copies_filter_evaled &lt;- copies_filter(librarian_source)
copies_filter_evaled$gui &lt;- .gui_filter(copies_filter_evaled)

str(copies_filter_evaled$gui)

</code></pre>

<hr>
<h2 id='keep_na_input'>Generate NA's filter selection GUI input</h2><span id='topic+keep_na_input'></span><span id='topic+.keep_na_input'></span><span id='topic+.update_keep_na_input'></span>

<h3>Description</h3>

<p>When used within filter's GUI input method, the component is responsible for
updating 'keep_na' filter parameter.
</p>
<p>Use &lsquo;.update_keep_na_input' inside filter&rsquo;s GUI update method to update the
output based on the filter state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.keep_na_input(
  input_id,
  filter,
  cohort,
  msg_fun = function(x) glue::glue("Keep missing values ({x})")
)

.update_keep_na_input(
  session,
  input_id,
  filter,
  cohort,
  msg_fun = function(x) glue::glue("Keep missing values ({x})")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_na_input_+3A_input_id">input_id</code></td>
<td>
<p>Id of the keep na input.</p>
</td></tr>
<tr><td><code id="keep_na_input_+3A_filter">filter</code></td>
<td>
<p>Filter object.</p>
</td></tr>
<tr><td><code id="keep_na_input_+3A_cohort">cohort</code></td>
<td>
<p>Cohort object.</p>
</td></tr>
<tr><td><code id="keep_na_input_+3A_msg_fun">msg_fun</code></td>
<td>
<p>Function taking number of missing values as an argument and
returning missing values label.</p>
</td></tr>
<tr><td><code id="keep_na_input_+3A_session">session</code></td>
<td>
<p>Shiny session object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nested list of 'shiny.tag' objects storing html structure of the input,
or no value in case of usage 'update' method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
library(cohortBuilder)

librarian_source &lt;- set_source(as.tblist(librarian))
coh &lt;- cohort(
  librarian_source,
  filter(
    "range", id = "copies", name = "Copies", dataset = "books",
    variable = "copies", range = c(5, 12)
  )
) %&gt;% run()
.keep_na_input("keep_na", coh$get_filter("1", "copies"), coh)

</code></pre>

<hr>
<h2 id='pre_post_stats'>Generate structure of pre/post statistics</h2><span id='topic+pre_post_stats'></span><span id='topic+.pre_post_stats'></span><span id='topic+.pre_post_stats_text'></span>

<h3>Description</h3>

<p>The method exported only for custom extensions use.
</p>
<p>'.pre_post_stats' returns the statistics having html tags structure.
'.pre_post_stats_text' returns the same output but flatten to a single character object.
The latter function works faster and supports vector arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pre_post_stats(
  current,
  previous,
  name,
  brackets = FALSE,
  percent = FALSE,
  stats = c("pre", "post")
)

.pre_post_stats_text(
  current,
  previous,
  name,
  brackets = TRUE,
  percent = FALSE,
  stats = c("pre", "post")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_post_stats_+3A_current">current</code></td>
<td>
<p>Current step statistic value.</p>
</td></tr>
<tr><td><code id="pre_post_stats_+3A_previous">previous</code></td>
<td>
<p>Previous step statistic value.</p>
</td></tr>
<tr><td><code id="pre_post_stats_+3A_name">name</code></td>
<td>
<p>Name displayed nearby the statistics output.</p>
</td></tr>
<tr><td><code id="pre_post_stats_+3A_brackets">brackets</code></td>
<td>
<p>If TRUE, statistics will be displayed in brackets.</p>
</td></tr>
<tr><td><code id="pre_post_stats_+3A_percent">percent</code></td>
<td>
<p>Should current/previous ration in percentages be displayed?</p>
</td></tr>
<tr><td><code id="pre_post_stats_+3A_stats">stats</code></td>
<td>
<p>Vector of &quot;pre&quot; and &quot;post&quot; defining which statistics should be returned.
&quot;pre&quot; for previous, &quot;post&quot; for current and NULL for none.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'shiny.tag' class 'span' object defining html structure of data/value
statistics, or character object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.pre_post_stats(5, 10, "books")
.pre_post_stats_text(5, 10, "books")
.pre_post_stats(5, 10, "books", brackets = TRUE)
.pre_post_stats_text(5, 10, "books", brackets = TRUE)
.pre_post_stats(5, 10, "books", percent = TRUE)
.pre_post_stats_text(5, 10, "books", percent = TRUE)
.pre_post_stats_text(5:6, 10:11, "books", percent = TRUE)

</code></pre>

<hr>
<h2 id='rendering-custom-attrition'>Method for generating custom attrition output</h2><span id='topic+rendering-custom-attrition'></span><span id='topic+.custom_attrition'></span>

<h3>Description</h3>

<p>When method is defined for selected source, the output is displayed in attrition modal tab.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.custom_attrition(source, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rendering-custom-attrition_+3A_source">source</code></td>
<td>
<p>Source object.</p>
</td></tr>
<tr><td><code id="rendering-custom-attrition_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to specific method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to <a href="#topic+.step_attrition">.step_attrition</a> the method should return list of 'render' and 'output' expressions.
</p>


<h3>Value</h3>

<p>List of two objects: 'render' and 'output' defining rendering and
output placeholder for custom attrition plot feature.
</p>


<h3>See Also</h3>

<p><a href="#topic+source-gui-layer">source-gui-layer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(magrittr)
  library(shiny)
  library(cohortBuilder)
  library(shinyCohortBuilder)

  .custom_attrition.tblist &lt;- function(source, id, cohort, session, ...) {
    ns &lt;- session$ns
    choices &lt;- names(source$dtconn)

    list(
      render = shiny::renderPlot({
        cohort$show_attrition(dataset = session$input$attrition_input)
      }),
      output = shiny::tagList(
        shiny::h3("Step-wise Attrition Plot"),
        shiny::selectInput(ns("attrition_input"), "Choose dataset", choices),
        shiny::plotOutput(id)
      )
    )
  }
  coh &lt;- cohort(
    set_source(as.tblist(librarian)),
    step(
      filter(
        "range", id = "copies", dataset = "books",
        variable = "copies", range = c(5, 12)
      )
    ),
    step(
      filter(
        "range", id = "copies", dataset = "books",
        variable = "copies", range = c(6, 8)
      )
    )
  ) %&gt;% run()

  ui &lt;- fluidPage(
    div(id = "attrition")
  )

  server &lt;- function(input, output, session) {
    rendering &lt;- .custom_attrition(
      coh$get_source(), id = "attr", cohort = coh, session = session, dataset = "books"
    )
    insertUI("#attrition", ui = rendering$output)
    output$attr &lt;- rendering$render
  }

  shinyApp(ui, server)
}

</code></pre>

<hr>
<h2 id='rendering-filters'>Render filtering panels for all the filters included in Cohort</h2><span id='topic+rendering-filters'></span><span id='topic+.render_filters'></span><span id='topic+.render_filters.default'></span><span id='topic+.render_filters.tblist'></span>

<h3>Description</h3>

<p>The method exported only for custom extensions use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.render_filters(source, ...)

## Default S3 method:
.render_filters(source, cohort, step_id, ns, ...)

## S3 method for class 'tblist'
.render_filters(source, cohort, step_id, ns, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rendering-filters_+3A_source">source</code></td>
<td>
<p>Source object.</p>
</td></tr>
<tr><td><code id="rendering-filters_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to a specific method.</p>
</td></tr>
<tr><td><code id="rendering-filters_+3A_cohort">cohort</code></td>
<td>
<p>Cohort object.</p>
</td></tr>
<tr><td><code id="rendering-filters_+3A_step_id">step_id</code></td>
<td>
<p>Id of the step.</p>
</td></tr>
<tr><td><code id="rendering-filters_+3A_ns">ns</code></td>
<td>
<p>Namespace function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within the method you should define source data stats output (see <a href="#topic+.update_data_stats">.update_data_stats</a>),
and define a loop that renders filtering panel for each filter (using <a href="#topic+.render_filter">.render_filter</a>).
</p>


<h3>Value</h3>

<p>Nested list of 'shiny.tag' objects storing html structure of filter input panels.
</p>


<h3>See Also</h3>

<p><a href="#topic+source-gui-layer">source-gui-layer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(magrittr)
  library(shiny)
  library(cohortBuilder)
  library(shinyCohortBuilder)

  ui &lt;- fluidPage(
    actionButton("add_filter", "Add Filter"),
    div(id = "filter_container")
  )

  server &lt;- function(input, output, session) {
    add_gui_filter_layer &lt;- function(public, private, ...) {
      private$steps[["1"]]$filters$copies$gui &lt;- .gui_filter(
        private$steps[["1"]]$filters$copies
      )
      private$steps[["1"]]$filters$registered$gui &lt;- .gui_filter(
        private$steps[["1"]]$filters$registered
      )
    }
    add_hook("post_cohort_hook", add_gui_filter_layer)
    coh &lt;- cohort(
      set_source(as.tblist(librarian)),
      filter(
        "range", id = "copies", name = "Copies", dataset = "books",
        variable = "copies", range = c(5, 12)
      ),
      filter(
        "date_range", id = "registered", name = "Registered",  dataset = "borrowers",
        variable = "registered", range = c(as.Date("2010-01-01"), Inf)
      )
    ) %&gt;% run()
    coh$attributes$session &lt;- session
    coh$attributes$feedback &lt;- TRUE

    observeEvent(input$add_filter, {
      insertUI(
        "#filter_container",
        ui = .render_filters(
          coh$get_source(),
          cohort = coh,
          step_id = "1",
          ns = function(x) x
        ))
    }, ignoreInit = TRUE, once = TRUE)
  }

  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='rendering-step-attrition'>Generate output of attrition plot</h2><span id='topic+rendering-step-attrition'></span><span id='topic+.step_attrition'></span><span id='topic+.step_attrition.default'></span><span id='topic+.step_attrition.tblist'></span>

<h3>Description</h3>

<p>The method should return list of two object:
</p>

<ul>
<li><p>render Rendering expression of attrition output.
</p>
</li>
<li><p>output Output expression related to rendering (with id equal to 'id' parameter).
</p>
</li></ul>

<p>For example:
</p>
<pre>
  list(
    render = shiny::renderPlot({
      cohort$show_attrition()
    }),
    output = shiny::plotOutput(id)
  )
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>.step_attrition(source, ...)

## Default S3 method:
.step_attrition(source, id, cohort, session, ...)

## S3 method for class 'tblist'
.step_attrition(source, id, cohort, session, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rendering-step-attrition_+3A_source">source</code></td>
<td>
<p>Source object.</p>
</td></tr>
<tr><td><code id="rendering-step-attrition_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to specific method.</p>
</td></tr>
<tr><td><code id="rendering-step-attrition_+3A_id">id</code></td>
<td>
<p>Id of attrition output.</p>
</td></tr>
<tr><td><code id="rendering-step-attrition_+3A_cohort">cohort</code></td>
<td>
<p>Cohort object.</p>
</td></tr>
<tr><td><code id="rendering-step-attrition_+3A_session">session</code></td>
<td>
<p>Shiny session object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two objects: 'render' and 'output' defining rendering and
output placeholder for step attrition plot feature.
</p>


<h3>See Also</h3>

<p><a href="#topic+source-gui-layer">source-gui-layer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(magrittr)
  library(shiny)
  library(cohortBuilder)
  library(shinyCohortBuilder)

  coh &lt;- cohort(
    set_source(as.tblist(librarian)),
    step(
      filter(
        "range", id = "copies", dataset = "books",
        variable = "copies", range = c(5, 12)
      )
    ),
    step(
      filter(
        "range", id = "copies", dataset = "books",
        variable = "copies", range = c(6, 8)
      )
    )
  ) %&gt;% run()

  ui &lt;- fluidPage(
    div(id = "attrition")
  )

  server &lt;- function(input, output, session) {
    rendering &lt;- .step_attrition(
      coh$get_source(), id = "attr", cohort = coh, session = session, dataset = "books"
    )
    insertUI("#attrition", ui = rendering$output)
    output$attr &lt;- rendering$render
  }

  shinyApp(ui, server)
}

</code></pre>

<hr>
<h2 id='source-gui-layer'>Source compatibility methods.</h2><span id='topic+source-gui-layer'></span>

<h3>Description</h3>

<p>List of methods that allow compatibility of different source types.
Most of the methods should be defined in order to make new source layer functioning.
See 'Details' section for more information.
</p>


<h3>Details</h3>

<p>The package is designed to make the functionality work with multiple data sources.
Data source can be based for example on list of tables, connection to database schema
or API service that allows to access and operate on data.
In order to make new source type layer functioning, the following list of methods
should be defined:
</p>

<ul>
<li><p>.render_filters 
</p>
</li>
<li><p>.update_data_stats 
</p>
</li>
<li><p>.step_attrition 
</p>
</li>
<li><p>.custom_attrition 
</p>
</li>
<li><p>.available_filter_choices 
</p>
</li>
<li><p>autofilter 
</p>
</li></ul>

<p>Except from the above methods, you may extend the existing or new source with providing
custom gui filtering methods. See <a href="#topic+gui-filter-layer">gui-filter-layer</a>.
In order to see more details about how to implement custom source check 'vignette(&quot;custom-gui-layer&quot;)'.
</p>


<h3>Value</h3>

<p>Various type outputs dependent on the selected method.
See each method documentation for details.
</p>

<hr>
<h2 id='trigger-action'>Trigger filtering panel action</h2><span id='topic+trigger-action'></span><span id='topic+.trigger_action'></span><span id='topic+.trigger_action_js'></span>

<h3>Description</h3>

<p>The two functions that allow to trigger a specific filtering panel action directly
from Shiny server (.trigger_action) or application browser (.trigger_action_js)
attached to a specific JS event, e.g. onclick.
</p>
<p>Check Details section to see possible options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.trigger_action(session, action, params = NULL)

.trigger_action_js(action, params = list(), ns = function(id) id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trigger-action_+3A_session">session</code></td>
<td>
<p>Shiny session object.</p>
</td></tr>
<tr><td><code id="trigger-action_+3A_action">action</code></td>
<td>
<p>Id of the action.</p>
</td></tr>
<tr><td><code id="trigger-action_+3A_params">params</code></td>
<td>
<p>List of parameters passed to specific action method.</p>
</td></tr>
<tr><td><code id="trigger-action_+3A_ns">ns</code></td>
<td>
<p>Namespace function (if used within Shiny modal).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of possible actions:
</p>

<ul>
<li><p>update_filter Calls 'shinyCohortBuilder:::gui_update_filter' that triggers filter arguments update.
</p>
</li>
<li><p>add_step Calls 'shinyCohortBuilder:::gui_add_step' that triggers adding a new filtering step (based on configuration of the previous one).
</p>
</li>
<li><p>rm_step Calls 'shinyCohortBuilder:::gui_rm_step' used to remove a selected filtering step.,
</p>
</li>
<li><p>clear_step Calls 'shinyCohortBuilder:::gui_clear_step' used to clear filters configuration in selected step.
</p>
</li>
<li><p>update_step Calls 'shinyCohortBuilder:::gui_update_step' used to update filters and feedback plots for the specific filter GUI panel.
</p>
</li>
<li><p>update_data_stats Calls 'shinyCohortBuilder:::gui_update_data_stats' that is called to update data statistics. 
</p>
</li>
<li><p>show_repro_code Calls 'shinyCohortBuilder:::gui_show_repro_code' that is used to show reproducible code. 
</p>
</li>
<li><p>run_step Calls 'shinyCohortBuilder:::gui_run_step' used to trigger specific step data calculation. 
</p>
</li>
<li><p>show_state Calls 'shinyCohortBuilder:::gui_show_state' that is used to show filtering panel state json. 
</p>
</li>
<li><p>input_state Calls 'shinyCohortBuilder:::gui_input_state' that is used to generate modal in which filtering panel state can be provided (as json). 
</p>
</li>
<li><p>restore_state Calls 'shinyCohortBuilder:::gui_restore_state' used for restoring filtering panel state based on provided json. 
</p>
</li>
<li><p>show_attrition Calls 'shinyCohortBuilder:::gui_show_attrition' a method used to show attrition data plot(s).
</p>
</li></ul>

<p>Both '.trigger_action' and '.trigger_action_js' methods are exported for advanced use only.
</p>


<h3>Value</h3>

<p>No return value ('.trigger_action' - sends message to the browser) or
character string storing JS code for sending input value to Shiny server ('.trigger_action_js').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(shiny)
  library(shinyCohortBuilder)

  shiny::addResourcePath(
    "shinyCohortBuilder",
    system.file("www", package = "shinyCohortBuilder")
  )
  ui &lt;- fluidPage(
    tags$head(
      shiny::tags$script(type = "text/javascript", src = file.path("shinyCohortBuilder", "scb.js"))
    ),
    tags$button(
      "Trigger action from UI", class = "btn btn-default",
      onclick = .trigger_action_js("uiaction", params = list(a = 1))
    ),
    actionButton("send", "Trigger action from server")
  )

  server &lt;- function(input, output, session) {
    observeEvent(input$send, {
      .trigger_action(session, "serveraction", params = list(a = 2))
    })
    observeEvent(input$action, {
      print(input$action)
    })
  }

  shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='updating-data-statistics'>Render source data related statistics</h2><span id='topic+updating-data-statistics'></span><span id='topic+.update_data_stats'></span><span id='topic+.update_data_stats.default'></span><span id='topic+.update_data_stats.tblist'></span>

<h3>Description</h3>

<p>The function should assign rendering that displays data source statistics to the valid output.
By default, the output is placed within <a href="#topic+.render_filters">.render_filters</a> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.update_data_stats(source, ...)

## Default S3 method:
.update_data_stats(source, step_id, cohort, session, ...)

## S3 method for class 'tblist'
.update_data_stats(source, step_id, cohort, session, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updating-data-statistics_+3A_source">source</code></td>
<td>
<p>Source object.</p>
</td></tr>
<tr><td><code id="updating-data-statistics_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to a specific method.</p>
</td></tr>
<tr><td><code id="updating-data-statistics_+3A_step_id">step_id</code></td>
<td>
<p>Id if filtering step.</p>
</td></tr>
<tr><td><code id="updating-data-statistics_+3A_cohort">cohort</code></td>
<td>
<p>Cohort object.</p>
</td></tr>
<tr><td><code id="updating-data-statistics_+3A_session">session</code></td>
<td>
<p>Shiny session object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When rendering the output, a good practice is to use cached data statistics available with
'cohort$get_cache(step_id)'.
This way, you omit running additional computations which results with performance improvement.
</p>


<h3>Value</h3>

<p>No return value, used for side effect which assigning Cohort data
statistics to the 'output' object.
</p>


<h3>See Also</h3>

<p><a href="#topic+source-gui-layer">source-gui-layer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(magrittr)
  library(shiny)
  library(cohortBuilder)
  library(shinyCohortBuilder)

  ui &lt;- fluidPage(
    sliderInput("step_two_max", "Max step two copies", min = 6, max = 12, value = 8),
    uiOutput("2-stats_books")
  )

  server &lt;- function(input, output, session) {
    coh &lt;- cohort(
      set_source(as.tblist(librarian)),
      step(
        filter(
          "range", id = "copies", dataset = "books",
          variable = "copies", range = c(5, 12)
        )
      ),
      step(
        filter(
          "range", id = "copies", dataset = "books",
          variable = "copies", range = c(6, 8)
        )
      )
    ) %&gt;% run()
    coh$attributes$stats &lt;- c("pre", "post")
    observeEvent(input$step_two_max, {
      coh$update_filter("copies", step_id = 2, range = c(6, input$step_two_max))
      run(coh, min_step_id = "2")
      .update_data_stats(coh$get_source(), step_id = "2", cohort = coh, session = session)
    })
  }

  shinyApp(ui, server)
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
