<!DOCTYPE html><html><head><title>Help for package quadtree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quadtree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_legend'><p>Add a gradient legend to a plot</p></a></li>
<li><a href='#as_data_frame'><p>Convert a <code>Quadtree</code> to a data frame</p></a></li>
<li><a href='#as_raster'><p>Create a raster from a <code>Quadtree</code></p></a></li>
<li><a href='#as_sf'><p>Convert to other R spatial objects</p></a></li>
<li><a href='#as_vector'><p>Get all <code>Quadtree</code> cell values as a vector</p></a></li>
<li><a href='#copy'><p>Create a deep copy of a <code>Quadtree</code></p></a></li>
<li><a href='#CppLcpFinder-class'><p><code>CppLcpFinder</code>: C++ LCP finder</p></a></li>
<li><a href='#CppNode-class'><p><code>CppNode</code>: C++ quadtree node</p></a></li>
<li><a href='#CppQuadtree-class'><p><code>CppQuadtree</code>: C++ quadtree data structure</p></a></li>
<li><a href='#extent'><p>Get the extent of a <code>Quadtree</code></p></a></li>
<li><a href='#extract'><p>Extract <code>Quadtree</code> values</p></a></li>
<li><a href='#find_lcp'><p>Find the LCP between two points on a <code>Quadtree</code></p></a></li>
<li><a href='#find_lcps'><p>Find LCPs to surrounding points</p></a></li>
<li><a href='#get_neighbors'><p>Get the neighbors of a <code>Quadtree</code> cell</p></a></li>
<li><a href='#lcp_finder'><p>Create a <code>LcpFinder</code></p></a></li>
<li><a href='#LcpFinder-class'><p>LcpFinder Class</p></a></li>
<li><a href='#n_cells'><p>Get the number of cells in a <code>Quadtree</code></p></a></li>
<li><a href='#plot'><p>Plot a <code>Quadtree</code></p></a></li>
<li><a href='#plot.LcpFinder'><p>Plot a <code>LcpFinder</code> object</p></a></li>
<li><a href='#projection'><p>Retrieve the projection of a <code>Quadtree</code></p></a></li>
<li><a href='#quadtree'><p>Create a <code>Quadtree</code> from a raster or matrix</p></a></li>
<li><a href='#Quadtree-class'><p>Quadtree class</p></a></li>
<li><a href='#quadtree-package'><p>Quadtree Representation of Rasters</p></a></li>
<li><a href='#read_quadtree'><p>Read/write a <code>Quadtree</code></p></a></li>
<li><a href='#set_values'><p>Change values of <code>Quadtree</code> cells</p></a></li>
<li><a href='#summarize_lcps'><p>Get a matrix summarizing all LCPs found by a <code>LcpFinder</code></p></a></li>
<li><a href='#summary.LcpFinder'><p>Show a summary of a <code>LcpFinder</code></p></a></li>
<li><a href='#summary.Quadtree'><p>Show a summary of a <code>Quadtree</code></p></a></li>
<li><a href='#transform_values'><p>Transform the values of all <code>Quadtree</code> cells</p></a></li>
<li><a href='#write_quadtree_ptr'><p>Read/write a <code>Quadtree</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Region Quadtrees for Spatial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.14</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-26</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality for working with raster-like quadtrees
    (also called “region quadtrees”), which allow for variable-sized
    cells. The package allows for flexibility in the quadtree creation
    process.  Several functions defining how to split and aggregate cells
    are provided, and custom functions can be written for both of these
    processes. In addition, quadtrees can be created using other quadtrees
    as “templates”, so that the new quadtree's structure is identical to
    the template quadtree. The package also includes functionality for
    modifying quadtrees, querying values, saving quadtrees to a file, and
    calculating least-cost paths using the quadtree as a resistance
    surface.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dfriend21/quadtree/">https://github.com/dfriend21/quadtree/</a>,
<a href="https://dfriend21.github.io/quadtree/">https://dfriend21.github.io/quadtree/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dfriend21/quadtree/issues/">https://github.com/dfriend21/quadtree/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, methods, Rcpp (&ge; 1.0.5), terra, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>raster, sf, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'CppLcpFinder-class.R' 'CppNode-class.R' 'CppQuadtree-class.R'
'classes.R' 'generics.R' 'as_data_frame.R' 'as_foreign.R'
'as_raster.R' 'as_vector.R' 'copy.R' 'extent.R' 'extract.R'
'get_neighbors.R' 'lcp.R' 'n_cells.R' 'plot_LcpFinder.R'
'plot_Quadtree.R' 'projection.R' 'qtree-exports.R'
'quadtree-package.R' 'quadtree.R' 'read_write.R' 'set_values.R'
'summary_LcpFinder.R' 'summary_Quadtree.R' 'transform_values.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-29 00:11:44 UTC; dfriend</td>
</tr>
<tr>
<td>Author:</td>
<td>Derek Friend <a href="https://orcid.org/0000-0002-6909-8769"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Andrew Brown [ctb],
  Randolph Voorhies [cph] (Author of included 'cereal' library),
  Shane Grant [cph] (Author of included 'cereal' library),
  Juan Pedro Bolivar Puente [cph] (Author of included 'cereal' library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Derek Friend &lt;dafriend.R@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-29 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_legend'>Add a gradient legend to a plot</h2><span id='topic+add_legend'></span>

<h3>Description</h3>

<p>Adds a gradient legend to a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_legend(
  zlim,
  col,
  alpha = 1,
  lgd_box_col = NULL,
  lgd_x_pct = 0.5,
  lgd_y_pct = 0.5,
  lgd_wd_pct = 0.5,
  lgd_ht_pct = 0.5,
  bar_box_col = "black",
  bar_wd_pct = 0.2,
  bar_ht_pct = 1,
  text_cex = 1,
  text_col = NULL,
  text_font = NULL,
  text_x_pct = 1,
  ticks = NULL,
  ticks_n = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_legend_+3A_zlim">zlim</code></td>
<td>
<p>two-element numeric vector; required; the min and max value of z</p>
</td></tr>
<tr><td><code id="add_legend_+3A_col">col</code></td>
<td>
<p>character vector; required; the colors that will be used in the
legend.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_alpha">alpha</code></td>
<td>
<p>numeric; transparency of the colors. Must be in the range
0-1, where 0 is fully transparent and 1 is fully opaque. Default is 1.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_lgd_box_col">lgd_box_col</code></td>
<td>
<p>character; color of the box to draw around the entire
legend. If <code>NULL</code> (the default), no box is drawn</p>
</td></tr>
<tr><td><code id="add_legend_+3A_lgd_x_pct">lgd_x_pct</code></td>
<td>
<p>numeric; location of the center of the legend in the
x-dimension, as a fraction (0 to 1) of the <em>right margin area</em>,
<strong>not</strong> the entire width of the figure</p>
</td></tr>
<tr><td><code id="add_legend_+3A_lgd_y_pct">lgd_y_pct</code></td>
<td>
<p>numeric; location of the center of the legend in the
y-dimension, as a fraction (0 to 1). Unlike <code>lgd_x_pct</code>, this
<strong>is</strong> relative to the entire figure height (since the right margin
area spans the entire vertical dimension)</p>
</td></tr>
<tr><td><code id="add_legend_+3A_lgd_wd_pct">lgd_wd_pct</code></td>
<td>
<p>numeric; width of the entire legend, as a fraction (0 to 1)
of the right margin width</p>
</td></tr>
<tr><td><code id="add_legend_+3A_lgd_ht_pct">lgd_ht_pct</code></td>
<td>
<p>numeric; height of the entire legend, as a fraction (0 to
1) of the figure height</p>
</td></tr>
<tr><td><code id="add_legend_+3A_bar_box_col">bar_box_col</code></td>
<td>
<p>character; color of the box to draw around the color bar.
If <code>NULL</code>, no box is drawn</p>
</td></tr>
<tr><td><code id="add_legend_+3A_bar_wd_pct">bar_wd_pct</code></td>
<td>
<p>numeric; width of the color bar, as a fraction (0 to 1) of
the width of the <em>legend area</em> (<strong>not</strong> the entire right margin
width)</p>
</td></tr>
<tr><td><code id="add_legend_+3A_bar_ht_pct">bar_ht_pct</code></td>
<td>
<p>numeric; height of the color bar, as a fraction (0 to 1) of
the height of the <em>legend area</em> (<strong>not</strong> the entire right margin
height)</p>
</td></tr>
<tr><td><code id="add_legend_+3A_text_cex">text_cex</code></td>
<td>
<p>numeric; size of the legend text. Default is 1.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_text_col">text_col</code></td>
<td>
<p>character; color of the legend text. Default is &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_text_font">text_font</code></td>
<td>
<p>integer; specifies which font to use. See
<code><a href="graphics.html#topic+par">par()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_text_x_pct">text_x_pct</code></td>
<td>
<p>numeric; the x-placement of the legend text as a fraction
(0 to 1) of the width of the legend area. This corresponds to the
<em>right-most</em> part of the text - i.e. a value of 1 means the text will
end exactly at the right border of the legend area. Default is 1.</p>
</td></tr>
<tr><td><code id="add_legend_+3A_ticks">ticks</code></td>
<td>
<p>numeric vector; the z-values at which to place tick marks. If
<code>NULL</code> (the default), tick placement is automatically calculated</p>
</td></tr>
<tr><td><code id="add_legend_+3A_ticks_n">ticks_n</code></td>
<td>
<p>integer; the number of ticks desired - only used if
<code>ticks</code> is <code>NULL</code>. Note that this is an <em>approximate</em> number
- the <code><a href="base.html#topic+pretty">pretty()</a></code> function is used to generate
&quot;nice-looking&quot; values, but it doesn't guarantee a set number of tick marks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>I took an HTML/CSS-like approach to determining the positioning -
that is, each space is treated as <code>&lt;div&gt;</code>-like space, and the position
of objects within that space happens <em>relative to that space</em> rather
than the entire space. The parameters prefixed by <code>lgd</code> are all
relative to the right margin space and correspond to the box that contains
the entire legend. The parameters prefixed by <code>bar</code> and <code>ticks</code>
are relative to the space within the legend box.
</p>
<p>This function is used within <code><a href="#topic+plot.Quadtree">plot</a>()</code>, so the
user shouldn't call this function to manually create the legend.
Customizations to the legend can be done via the <code>legend_args</code>
parameter of <code><a href="#topic+plot.Quadtree">plot</a>()</code>. Using this function to
plot the legend after using <code><a href="#topic+plot.Quadtree">plot</a>()</code> raises the
possibility of the legend not corresponding correctly with the plot, and
thus should be avoided.
</p>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))
qt &lt;- quadtree(habitat, .2)

old_par &lt;- par(mar = c(5, 4, 4, 5))
plot(qt, legend = FALSE)
leg &lt;- terra::minmax(habitat)[1:2]
quadtree::add_legend(leg, rev(terrain.colors(100)))
par(old_par)
# this example simply illustrates how it COULD be used, but as stated in the
# 'Details' section, it shouldn't be called separately from 'plot()' - if
# customizations to the legend are desired, use the 'legend_args' parameter
# of 'plot()'.
</code></pre>

<hr>
<h2 id='as_data_frame'>Convert a <code>Quadtree</code> to a data frame</h2><span id='topic+as_data_frame'></span><span id='topic+as_data_frame+2CQuadtree-method'></span>

<h3>Description</h3>

<p>Creates a data frame with information on each quadtree cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree'
as_data_frame(x, terminal_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_data_frame_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="as_data_frame_+3A_terminal_only">terminal_only</code></td>
<td>
<p>boolean; if <code>TRUE</code> (the default) only information
on terminal cells is returned. If <code>FALSE</code>, information on all cells is
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row for each quadtree cell. The columns are as
follows:
</p>

<ul>
<li> <p><code>id</code>: the id of the cell
</p>
</li>
<li> <p><code>hasChildren</code>: 1 if the cell has children, 0 otherwise
</p>
</li>
<li> <p><code>level</code>: integer; the depth of this cell/node in the quadtree,
where the root of the quadtree is considered to be level 0
</p>
</li>
<li> <p><code>xmin</code>, <code>xmax</code>, <code>ymin</code>, <code>ymax</code>: the x and y
limits of the cell
</p>
</li>
<li> <p><code>value</code>: the value of the cell
</p>
</li>
<li> <p><code>smallestChildLength</code>: the smallest cell length among all of
this cell's descendants
</p>
</li>
<li> <p><code>parentID</code>: the ID of the cell's parent. The root, which has
no parent, has a value of -1 for this column
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+as_vector">as_vector</a>()</code> returns all the cell values as a numeric
vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)

mat &lt;- rbind(c(1, 1, 0, 1),
             c(1, 1, 1, 0),
             c(1, 0, 1, 1),
             c(0, 1, 1, 1))
qt &lt;- quadtree(mat, .1)
plot(qt)
as_data_frame(qt)
</code></pre>

<hr>
<h2 id='as_raster'>Create a raster from a <code>Quadtree</code></h2><span id='topic+as_raster'></span><span id='topic+as_raster+2CQuadtree-method'></span>

<h3>Description</h3>

<p>Creates a <code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code>
from a <code><a href="#topic+Quadtree">Quadtree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree'
as_raster(x, rast = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_raster_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="as_raster_+3A_rast">rast</code></td>
<td>
<p>a <code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> or
<code><a href="raster.html#topic+RasterLayer-class">RasterLayer</a></code>; optional;
this will be used as a template - the output raster will have the same
extent and dimensions as this raster. If <code>NULL</code> (the default), a
raster is automatically created, where the quadtree extent is used as the
raster extent, and the size of smallest cell in the quadtree is used as
the resolution of the raster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the value of a raster cell is determined by the value of the
quadtree cell located at the centroid of the raster cell - thus, if a raster
cell overlaps several quadtree cells, whichever quadtree cell the centroid of
the raster cell falls in will determine the raster cell's value. If no value
is provided for the <code>rast</code> parameter, the raster's dimensions are
automatically determined from the quadtree in such a way that the cells are
guaranteed to line up with the quadtree cells with no overlap, thus avoiding
the issue.
</p>


<h3>Value</h3>

<p>a <code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

# create a quadtree
qt &lt;- quadtree(habitat, split_threshold = .1, split_method = "sd")

rst1 &lt;- as_raster(qt) # use the default raster
rst2 &lt;- as_raster(qt, habitat) # use another raster as a template

old_par &lt;- par(mfrow = c(2, 2))
plot(habitat, main = "original raster")
plot(qt, main = "quadtree")
plot(rst1, main = "raster from quadtree")
plot(rst2, main = "raster from quadtree")
par(old_par)
</code></pre>

<hr>
<h2 id='as_sf'>Convert to other R spatial objects</h2><span id='topic+as_sf'></span><span id='topic+as_vect'></span><span id='topic+as_character'></span>

<h3>Description</h3>

<p>Convert to other R spatial objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sf(x)

as_vect(x)

as_character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_sf_+3A_x">x</code></td>
<td>
<p>Quadtree object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>sf</code> or <code>SpatVector</code>, or a Well-Known Text (WKT) <code>character</code> representation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, .1)
sf &lt;- as(qt, "sf")
sr &lt;- as(qt, "SpatRaster")
sv &lt;- as(qt, "SpatVector")
ch &lt;- as(qt, "character")
</code></pre>

<hr>
<h2 id='as_vector'>Get all <code>Quadtree</code> cell values as a vector</h2><span id='topic+as_vector'></span><span id='topic+as_vector+2CQuadtree-method'></span>

<h3>Description</h3>

<p>Returns all cell values  of a <code><a href="#topic+Quadtree">Quadtree</a></code> as a
numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree'
as_vector(x, terminal_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_vector_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="as_vector_+3A_terminal_only">terminal_only</code></td>
<td>
<p>boolean; if <code>TRUE</code> (the default) only values of
terminal cells are returned. If <code>FALSE</code>, all cell values are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_data_frame">as_data_frame</a></code> creates a data frame from a
<code><a href="#topic+Quadtree">Quadtree</a></code> that has all the cell values as well as details
about each cell's size and extent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, .2)
head(as_vector(qt), 20)
head(as_vector(qt, FALSE), 20)
</code></pre>

<hr>
<h2 id='copy'>Create a deep copy of a <code>Quadtree</code></h2><span id='topic+copy'></span><span id='topic+copy+2CQuadtree-method'></span><span id='topic+copy.Quadtree'></span>

<h3>Description</h3>

<p>Creates a <em>deep</em> copy of a <code><a href="#topic+Quadtree">Quadtree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree'
copy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a <em>deep</em> copy of a <code><a href="#topic+Quadtree">Quadtree</a></code>
object. The <code><a href="#topic+Quadtree">Quadtree</a></code> class contains a pointer to a
<code><a href="#topic+CppQuadtree">CppQuadtree</a></code> C++ object. If a copy is attempted by simply
assigning the quadtree to a new variable, it will simply make a copy of the
<em>pointer</em>, and both variables will point to the same
<code><a href="#topic+CppQuadtree">CppQuadtree</a></code>. Thus, changes made to one will also change the
other. See &quot;Examples&quot; for a demonstration of this.
</p>
<p>This function creates a deep copy by copying the entire quadtree, and
should be used whenever a copy of a quadtree is desired.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+Quadtree">Quadtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

# create a quadtree, then create a shallow copy and a deep copy
qt1 &lt;- quadtree(habitat, split_threshold = .1)
plot(qt1)

qt2 &lt;- qt1 # SHALLOW copy
qt3 &lt;- copy(qt1) # DEEP copy

# change the values of qt1 so we can observe how this affects qt2 and qt3
transform_values(qt1, function(x) 1 - x)

# plot it out to see what happened
old_par &lt;- par(mfrow = c(1, 3))
plot(qt1, main = "qt1", border_col = "transparent")
plot(qt2, main = "qt2", border_col = "transparent")
plot(qt3, main = "qt3", border_col = "transparent")
par(old_par)
# qt2 was modified but qt3 was not
</code></pre>

<hr>
<h2 id='CppLcpFinder-class'><code>CppLcpFinder</code>: C++ LCP finder</h2><span id='topic+CppLcpFinder-class'></span><span id='topic+CppLcpFinder'></span>

<h3>Description</h3>

<p><code>CppLcpFinder</code> is a C++ class for finding least-cost paths
(LCPs) using a <code><a href="#topic+Quadtree">Quadtree</a></code> as a resistance surface. The average
user should not need to interact with this class at all - all of the LCP
functionality is made available through the <code><a href="#topic+LcpFinder">LcpFinder</a></code> S4
class.
</p>


<h3>Details</h3>

<p>This class is defined in 'src/LcpFinderWrapper.h' and
'src/LcpFinderWrapper.cpp'. When made available to R, it is
exposed as <code>CppLcpFinder</code> rather than
<code>LcpFinderWrapper</code>. <code>LcpFinderWrapper</code> contains
a pointer to a <code>LcpFinder</code> C++ object (defined in
'src/LcpFinder.h' and 'src/LcpFinder.cpp'). All of the
core functionality is in the <code>LcpFinder</code> C++ class.
<code>LcpFinderWrapper</code> is a wrapper class that adds the 'Rcpp' code
required for it to be accessible from R.
</p>
<p>Note that there is no constructor made accessible to R - a
<code>CppLcpFinder</code> is created by using the
<code>getLcpFinder</code> method of the <code><a href="#topic+CppQuadtree">CppQuadtree</a></code> class.
</p>


<h3>Fields</h3>


<dl>
<dt><code>getAllPathsSummary</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns a matrix summarizing all the LCPs
calculated so far. <code><a href="#topic+summarize_lcps">summarize_lcps</a>()</code> is a wrapper for this
function - see documentation of that function for more details.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a matrix with one row per LCP. See documentation of
<code><a href="#topic+summarize_lcps">summarize_lcps</a>()</code> for details.
</p>
</li></ul>
</dd>
<dt><code>getLcp</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Finds the LCP from the starting point to
another point. <code><a href="#topic+find_lcp">find_lcp</a></code> is a wrapper for this function - see
its documentation for more details.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>endPoint</code>: two-element numeric vector (x,y) - the point to
find a shortest path to
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: A matrix representing the least-cost path. See
<code><a href="#topic+find_lcp">find_lcp</a>()</code> for details on the return matrix.
</p>
</li></ul>
</dd>
<dt><code>getSearchLimits</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the x and y limits of the search area.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>:  four-element numeric vector, in this order: xmin,
xmax, ymin, ymax
</p>
</li></ul>
</dd>
<dt><code>getStartPoint</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the start point
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: two-element numeric vector (x,y)
</p>
</li></ul>
</dd>
<dt><code>makeNetworkAll</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Calculates LCPs to all cells in the search
area. This is used by <code><a href="#topic+find_lcps">find_lcps</a></code> when <code>limit</code> is
<code>NULL</code>. See documentation of that function for more details.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: void - no return value. Specific paths can be
retrieved using <code>getLcp</code>, and <code>getAllPathsSummary</code> can
be used to summarize all paths that have been found.
</p>
</li></ul>
</dd>
<dt><code>makeNetworkCostDist</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Calculates all LCPs whose cost-distance is less
than a given threshold. This is used in <code><a href="#topic+find_lcps">find_lcps</a></code> when
<code>limit</code> is not <code>NULL</code>. See documentation of that function for
more details.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>constraint</code>: double; the maximum cost-distance allowed for a
LCP
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: void - no return value. Specific paths can be
retrieved using <code>getLcp</code>, and <code>getAllPathsSummary</code> can
be used to summarize all paths that have been found.
</p>
</li></ul>
</dd>
</dl>

<hr>
<h2 id='CppNode-class'><code>CppNode</code>: C++ quadtree node</h2><span id='topic+CppNode-class'></span><span id='topic+CppNode'></span><span id='topic+Rcpp_CppNode'></span><span id='topic+Rcpp_CppNode-class'></span>

<h3>Description</h3>

<p>The <code>CppNode</code> C++ class defines objects that represent a
single node of a quadtree. This is used internally - end users should have
no need to use any of the methods listed here.
</p>


<h3>Details</h3>

<p>This class is defined in 'src/NodeWrapper.h' and
'src/NodeWrapper.cpp'. When made available to R, it is exposed as
<code>CppNode</code> instead of <code>NodeWrapper</code>. <code>NodeWrapper</code> contains a
pointer to a <code>Node</code> object (defined in 'src/Node.h' and
'src/Node.cpp'). All of the core functionality is in the <code>Node</code> class
- <code>NodeWrapper</code> is a wrapper class that adds the 'Rcpp' code required
for it to be accessible from R.
</p>


<h3>Fields</h3>


<dl>
<dt><code>asVector</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns a vector giving info about the node
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a numeric vector with the following named elements:
</p>

<ul>
<li><p><code>id</code>
</p>
</li>
<li><p><code>hasChidren</code>
</p>
</li>
<li><p><code>level</code>
</p>
</li>
<li><p><code>xmin</code>
</p>
</li>
<li><p><code>xmax</code>
</p>
</li>
<li><p><code>ymin</code>
</p>
</li>
<li><p><code>ymax</code>
</p>
</li>
<li><p><code>smallestChildLength</code>
</p>
</li></ul>

<p><code><a href="#topic+as_data_frame">as_data_frame</a></code> makes use of this function to output info on
each node - see the documentation of that function for details on what each
column represents
</p>
</li></ul>
</dd>
<dt><code>getChildren</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns a list of the child nodes
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a list of <code>CppNode</code> objects
</p>
</li></ul>
</dd>
<dt><code>getNeighborIds</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the IDs of the neighboring cells
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a numeric vector containing the neighbor IDs
</p>
</li></ul>
</dd>
<dt><code>getNeighborInfo</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns a matrix with info on each of the
neighboring cells
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a matrix. The <code>getNeighborList()</code> member
function of <code><a href="#topic+CppQuadtree">CppQuadtree</a></code> makes use of this function - see
documentation of that function for details on the return matrix.
</p>
</li></ul>
</dd>
<dt><code>getNeighborVals</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the values of all neighboring cells
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a numeric vector
</p>
</li></ul>
</dd>
<dt><code>getNeighbors</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns a list of the neighboring nodes
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a list of <code>CppNode</code> objects
</p>
</li></ul>
</dd>
<dt><code>hasChildren</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns a boolean representing whether the node
has children
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a boolean value - <code>TRUE</code> if it has children,
<code>FALSE</code> otherwise
</p>
</li></ul>
</dd>
<dt><code>id</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the ID of this node
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: an integer
</p>
</li></ul>
</dd>
<dt><code>level</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the 'level' (i.e. depth in the tree) of
this node
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: an integer
</p>
</li></ul>
</dd>
<dt><code>smallestChildSideLength</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the side length of the smallest
descendant node
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a double
</p>
</li></ul>
</dd>
<dt><code>value</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the value of the node
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a double
</p>
</li></ul>
</dd>
<dt><code>xLims</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the x boundaries of the node
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: two-element numeric vector (xmin, xmax)
</p>
</li></ul>
</dd>
<dt><code>yLims</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the y boundaries of the node
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: two-element numeric vector (ymin, ymax)
</p>
</li></ul>
</dd>
</dl>

<hr>
<h2 id='CppQuadtree-class'><code>CppQuadtree</code>: C++ quadtree data structure</h2><span id='topic+CppQuadtree-class'></span><span id='topic+Rcpp_CppQuadtree'></span><span id='topic+Rcpp_CppQuadtree-class'></span><span id='topic+CppQuadtree'></span>

<h3>Description</h3>

<p>The <code>CppQuadtree</code> class is the underlying C++ data structure used by
the <code><a href="#topic+Quadtree">Quadtree</a></code> S4 class. Note that the average user should not
need to use these functions - there are R wrapper functions that provide
access to the many of the member functions.
</p>


<h3>Details</h3>

<p>This class is defined in 'src/QuadtreeWrapper.h' and
'src/QuadtreeWrapper.cpp'. When made available to R, it is exposed as
<code>CppQuadtree</code> rather than <code>QuadtreeWrapper</code>.
<code>QuadtreeWrapper</code> contains a pointer to a <code>Quadtree</code> C++ object
(defined in 'src/Quadtree.h' and 'src/Quadtree.cpp'). All of the core
functionality is in the <code>Quadtree</code> C++ class - <code>QuadtreeWrapper</code>
is a wrapper class that adds the 'Rcpp' code required for it to be
accessible from R.
</p>


<h3>Fields</h3>


<dl>
<dt><code>constructor</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Default constructor. Can be used as follows:
<code>qt &lt;- new(CppQuadtree)</code>
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: an empty <code>CppQuadtree</code> object
</p>
</li></ul>
</dd>
<dt><code>constructor</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Constructor. Can be used as follows: <code>qt
  &lt;- new(CppQuadtree, xlims, ylims, maxCellLength, minCellLength,
  splitAllNAs, splitAnyNAs)</code>. Used in <code><a href="#topic+quadtree">quadtree</a>()</code>. The
parameters for this constructor correspond with the similarly named
parameters in <code><a href="#topic+quadtree">quadtree</a>()</code> - see its documentation for more
details on what the parameters signify. Note that the constructor does not
&quot;build&quot; the quadtree structure - that is done by <code>createTree()</code>.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>xlims</code>: two-element numeric vector (xmin, xmax)
</p>
</li>
<li> <p><code>ylims</code>: two-element numeric vector (ymin, ymax)
</p>
</li>
<li> <p><code>maxCellLength</code>: two-element numeric vector - first element is
for the x dimension, second is for the y dimension
</p>
</li>
<li> <p><code>minCellLength</code>: two-element numeric vector - first element is
for the x dimension, second is for the y dimension
</p>
</li>
<li> <p><code>splitAllNAs</code>: boolean
</p>
</li>
<li> <p><code>splitAnyNAs</code>: boolean
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>readQuadtree</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Reads a quadtree from a file. Note that this is
a static function, so it does not require an instance of <code>CppQuadtree</code>
to be called. <code><a href="#topic+read_quadtree">read_quadtree</a>()</code> is a wrapper for this function
- see its documentation for more details.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>filePath</code>: string; the file to read from
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: a <code>CppQuadtree</code>
</p>
</li></ul>
</dd>
<dt><code>asList</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Outputs a list containing details about
each cell. <code><a href="#topic+as_data_frame">as_data_frame</a>()</code> is a wrapper for this function
that <code>rbind</code>s the individual list elements into a data frame.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a list of named numeric vectors. Each
numeric vector provides information on a single cell. The elements returned
are the same as the columns described in the documentation for
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code> - see that help page for details.
</p>
</li></ul>
</dd>
<dt><code>asVector</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns cell values as a vector.
<code><a href="#topic+as_vector">as_vector</a>()</code> is a wrapper for this function.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>terminalOnly</code>: boolean; if <code>TRUE</code>, returns only the
values of the terminal cells. If <code>FALSE</code>, returns all cell values
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: a numeric vector
</p>
</li></ul>
</dd>
<dt><code>copy</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns a deep copy of a quadtree.
<code><a href="#topic+copy">copy</a>()</code> is a wrapper for this function - see the
documentation for that function for more details.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a <code>CppQuadtree</code> object
</p>
</li></ul>
</dd>
<dt><code>createTree</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Constructs a quadtree from a matrix.
<code><a href="#topic+quadtree">quadtree</a>()</code> is a wrapper for this function and should be used
to create quadtrees. The parameters correspond with the similarly
named parameters in <code><a href="#topic+quadtree">quadtree</a>()</code> - see the
documentation of that function for details on the parameters.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>mat</code>: matrix; data to be used to create the quadtree
</p>
</li>
<li> <p><code>splitMethod</code>: string
</p>
</li>
<li> <p><code>splitThreshold</code>: double
</p>
</li>
<li> <p><code>splitFun</code>: function
</p>
</li>
<li> <p><code>splitArgs</code>: list
</p>
</li>
<li> <p><code>combineFun</code>: function
</p>
</li>
<li> <p><code>combineArgs</code>: list
</p>
</li>
<li> <p><code>templateQuadtree</code>: <code>CppQuadtree</code> object
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: void - no return value
</p>
</li></ul>
</dd>
<dt><code>extent</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the extent of the quadtree. This is
equivalent to <code><a href="#topic+extent">extent</a>(qt, original = FALSE)</code>
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: four-element numeric vector, in this order: xmin,
xmax, ymin, ymax
</p>
</li></ul>
</dd>
<dt><code>getCell</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Given the x and y coordinates of a point,
returns the cell at that point.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>pt</code>: two-element numeric vector (x,y)
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: a <code><a href="#topic+CppNode">CppNode</a></code> object representing the
cell that contains the point
</p>
</li></ul>
</dd>
<dt><code>getCells</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Given x and y coordinates of points, returns a
list of the cells at those points (as <code><a href="#topic+CppNode">CppNode</a></code> objects). It is
the same as <code>getCell</code>, except that it allows users to get multiple
cells at once instead of one at a time.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>x</code>: numeric vector; the x coordinates
</p>
</li>
<li> <p><code>y</code>: numeric vector; the y coordinates; must be the same
length as <code>x</code>
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: a list of <code><a href="#topic+CppNode">CppNode</a></code> objects
corresponding to the x and y coordinates passed to the function
</p>
</li></ul>
</dd>
<dt><code>getCellsDetails</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Given points defined by their x and y
coordinates, returns a matrix giving details on the cells at each of the
points.
<code><a href="#topic+extract">extract</a>(qt, extents = TRUE)</code> is a wrapper for this function.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>x</code>: numeric vector; the x coordinates
</p>
</li>
<li> <p><code>y</code>: numeric vector; the y coordinates; must be the same
length as x
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: A matrix with the cell details. See
<code><a href="#topic+extract">extract</a>()</code> for details about the matrix columns
</p>
</li></ul>
</dd>
<dt><code>getLcpFinder</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns a <code><a href="#topic+CppLcpFinder">CppLcpFinder</a></code> object
that can be used to find least-cost paths on the quadtree.
<code><a href="#topic+lcp_finder">lcp_finder</a>()</code> is a wrapper for this function. For details on
the parameters see the documentation of the similarly named parameters in
<code><a href="#topic+lcp_finder">lcp_finder</a>()</code>.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>startPoint</code>: two-element numeric vector
</p>
</li>
<li> <p><code>xlim</code>: two-element numeric vector
</p>
</li>
<li> <p><code>ylim</code>: two-element numeric vector
</p>
</li>
<li> <p><code>searchByCentroid</code> : boolean
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: a <code><a href="#topic+CppLcpFinder">CppLcpFinder</a></code> object
</p>
</li></ul>
</dd>
<dt><code>getNeighborList</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the neighbor relationships between all
cells.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a list of matrices. Each matrix corresponds to
a single cell and has one line for each neighboring cell. &quot;neighbor&quot;
includes diagonal adjacency. Each matrix has the following columns:
</p>

<ul>
<li> <p><code>id0</code>, <code>x0</code>, <code>y0</code>, <code>val0</code>, <code>hasChildren0</code>:
the ID, x and y coordinates of the centroid, cell value, and whether the
cell has children. This is for the cell of interest. Note that the values
of these columns will be same across all rows because they refer to the
same cell.
</p>
</li>
<li> <p><code>id1</code>, <code>x1</code>, <code>y1</code>, <code>val1</code>, <code>hasChildren1</code>:
the ID, x and y coordinates of the centroid, cell value, and whether the
cell has children. This is for the neighbors of the cell of interest.
(i.e. the cell represented by the columns suffixed with '0').
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>getNeighbors</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Given a point, returns a matrix with info on
the cells that neighbor the cell that the point falls in.
<code><a href="#topic+get_neighbors">get_neighbors</a>()</code> is a wrapper for this function.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>pt</code>: two-element numeric vector (x,y)
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: a six-column matrix with one row per neighboring
cell. It has the following columns: </p>

<ul>
<li> <p><code>id</code>
</p>
</li>
<li> <p><code>xmin</code>
</p>
</li>
<li> <p><code>xmax</code>
</p>
</li>
<li> <p><code>ymin</code>
</p>
</li>
<li> <p><code>ymax</code>
</p>
</li>
<li> <p><code>value</code>
</p>
</li></ul>

</li></ul>
</dd>
<dt><code>getValues</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Given points defined by their x and y
coordinates, returns a numeric vector of the values of the cells at each of
the points.
<code><a href="#topic+extract">extract</a>(qt, extents = FALSE)</code> is a wrapper for this function.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>x</code>: numeric vector; the x coordinates
</p>
</li>
<li> <p><code>y</code>: numeric vector; the y coordinates; must be the same
length as <code>x</code>
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: a numeric vector of cell values corresponding with
the x and y coordinates passed to the function
</p>
</li></ul>
</dd>
<dt><code>maxCellDims</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the maximum allowable cell length used
when constructing the quadtree (i.e. the value passed to the
<code>max_cell_length</code> parameter of <code><a href="#topic+quadtree">quadtree</a>()</code>). Note that
this does <strong>not</strong> return the maximum cell size in the quadtree - it
returns the maximum <em>allowable</em> cell size. Also note that if no value
was provided for <code>max_cell_length</code>, the max allowable cell length is
set to the length and width of the total extent.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: A two-element numeric vector giving the maximum
allowable side length for the x and y dimensions.
</p>
</li></ul>
</dd>
<dt><code>minCellDims</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the minimum allowable cell length used
when constructing the quadtree (i.e. the value passed to the
<code>min_cell_length</code> parameter of <code><a href="#topic+quadtree">quadtree</a>()</code>). Note that
this does <strong>not</strong> return the minimum cell size in the quadtree - it
returns the minimum <em>allowable</em> cell size. Also note that if no value
was provided for <code>min_cell_length</code>, the min allowable cell length is
set to -1.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: A two-element numeric vector giving the minimum
allowable side length for the x and y dimensions.
</p>
</li></ul>
</dd>
<dt><code>nNodes</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the total number of nodes in the
quadtree. Note that this includes <em>all</em> nodes, not just terminal
nodes.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: integer
</p>
</li></ul>
</dd>
<dt><code>originalDim</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the dimensions of the raster used to
create the quadtree <em>before</em> its dimensions were adjusted.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: two-element numeric vector that gives the number of
cells along the x and y dimensions.
</p>
</li></ul>
</dd>
<dt><code>originalExtent</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the extent of the raster used to create
the quadtree <em>before</em> its dimensions/extent were adjusted. This is
equivalent to <code><a href="#topic+extent">extent</a>(qt, original = TRUE)</code>
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: four-element numeric vector, in this order: xmin,
xmax, ymin, ymax
</p>
</li></ul>
</dd>
<dt><code>originalRes</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the resolution of the raster used to
create the quadtree <em>before</em> its dimensions/extent were adjusted.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: two-element numeric vector (x cell length, y cell
length)
</p>
</li></ul>
</dd>
<dt><code>print</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns a string that represents the quadtree.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a string
</p>
</li></ul>
</dd>
<dt><code>projection</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the projection of the quadtree.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a string
</p>
</li></ul>
</dd>
<dt><code>root</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Returns the root node of the quadtree.
</p>
</li>
<li> <p><strong>Parameters</strong>: none
</p>
</li>
<li> <p><strong>Returns</strong>: a <code><a href="#topic+CppNode">CppNode</a></code> object
</p>
</li></ul>
</dd>
<dt><code>setOriginalValues</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Sets the properties that record the extent and
dimensions of the original raster used to create the quadtree
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>xmin</code>: double
</p>
</li>
<li> <p><code>xmax</code>: double
</p>
</li>
<li> <p><code>ymin</code>: double
</p>
</li>
<li> <p><code>ymax</code>: double
</p>
</li>
<li> <p><code>nX</code>: integer - number of cells along the x dimension
</p>
</li>
<li> <p><code>nY</code>: integer - number of cells along the y dimension
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: void - no return value
</p>
</li></ul>
</dd>
<dt><code>setProjection</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Sets the the projection of the quadtree.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>projection</code>: string
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: void - no return value
</p>
</li></ul>
</dd>
<dt><code>setValues</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Given points defined by their x and y
coordinates and a vector of values, sets the values of the quadtree cells
at each of the points. <code><a href="#topic+set_values">set_values</a>()</code> is a wrapper for this
function - see its documentation page for more details.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>x</code>: numeric vector; the x coordinates
</p>
</li>
<li> <p><code>y</code>: numeric vector; the y coordinates; must be the same
length as x
</p>
</li>
<li> <p><code>newVals</code>: numeric vector; must be the same length as x and y
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: void - no return value
</p>
</li></ul>
</dd>
<dt><code>transformValues</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Uses a function to transform the values of all
cells. <code><a href="#topic+transform_values">transform_values</a>()</code> is a wrapper for this function -
see its documentation page for more details.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>trasform_fun</code>: function
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: void - no return value
</p>
</li></ul>
</dd>
<dt><code>writeQuadtree</code></dt><dd>
<ul>
<li> <p><strong>Description</strong>: Writes a quadtree to a file.
<code><a href="#topic+write_quadtree">write_quadtree</a>()</code> is a wrapper for this function - see its
documentation page for more details.
</p>
</li>
<li> <p><strong>Parameters</strong>: </p>

<ul>
<li> <p><code>filePath</code>: string; the file to save the quadtree to
</p>
</li></ul>

</li>
<li> <p><strong>Returns</strong>: void - no return value
</p>
</li></ul>
</dd>
</dl>

<hr>
<h2 id='extent'>Get the extent of a <code>Quadtree</code></h2><span id='topic+extent'></span><span id='topic+extent+2CQuadtree-method'></span><span id='topic+extent.Quadtree'></span>

<h3>Description</h3>

<p>Gets the extent of the <code><a href="#topic+Quadtree">Quadtree</a></code> as an
<code><a href="raster.html#topic+Extent-class">Extent</a></code> object (from the raster package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree'
extent(x, original = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extent_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="extent_+3A_original">original</code></td>
<td>
<p>boolean; if <code>FALSE</code> (the default), it returns the total
extent covered by the quadtree. If <code>TRUE</code>, the function returns the
extent of the original raster used to create the quadtree, before the
dimensions were adjusted by padding with <code>NA</code>s and/or the raster was
resampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="raster.html#topic+Extent-class">Extent</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

# create a quadtree
qt &lt;- quadtree(habitat, split_threshold = .1, adj_type = "expand")

# retrieve the extent and the original extent
ext &lt;- extent(qt)
ext_orig &lt;- extent(qt, original = TRUE)

ext
ext_orig

# plot them
plot(qt)
rect(ext[1], ext[3], ext[2], ext[4], border = "blue", lwd = 4)
rect(ext_orig[1], ext_orig[3], ext_orig[2], ext_orig[4],
     border = "red", lwd = 4)
</code></pre>

<hr>
<h2 id='extract'>Extract <code>Quadtree</code> values</h2><span id='topic+extract'></span><span id='topic+extract+2CQuadtree+2CANY-method'></span><span id='topic+extract.Quadtree'></span>

<h3>Description</h3>

<p>Extracts the cell values and optionally the cell extents at the
given points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree,ANY'
extract(x, y, extents = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="extract_+3A_y">y</code></td>
<td>
<p>a two-column matrix representing point coordinates. First column
contains the x-coordinates, second column contains the y-coordinates</p>
</td></tr>
<tr><td><code id="extract_+3A_extents">extents</code></td>
<td>
<p>boolean; if <code>FALSE</code> (the default), a vector containing
cell values is returned. If <code>TRUE</code>, a matrix is returned providing
each cell's extent in addition to its value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>extents = FALSE</code>, returns a numeric vector corresponding to the
values at the points represented by <code>pts</code>.
</p>
<p>If <code>extents = TRUE</code>, returns a six-column numeric matrix providing the
extent of each cell along with the cell's value and ID. The six columns are,
in this order: <code>id</code>, <code>xmin</code>, <code>xmax</code>, <code>ymin</code>, <code>ymax</code>,
<code>value</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

# create quadtree
qt1 &lt;- quadtree(habitat, split_threshold = .1, adj_type = "expand")
plot(qt1)

# create points at which we'll extract values
coords &lt;- seq(-1000, 40010, length.out = 10)
pts &lt;- cbind(coords,coords)

# extract the cell values
vals &lt;- extract(qt1, pts)

# plot the quadtree and the points
plot(qt1, border_col = "gray50", border_lwd = .4)
points(pts, pch = 16, cex = .6)
text(pts, labels = round(vals, 2), pos = 4)

# we can also extract the cell extents in addition to the values
extract(qt1, pts, extents = TRUE)
</code></pre>

<hr>
<h2 id='find_lcp'>Find the LCP between two points on a <code>Quadtree</code></h2><span id='topic+find_lcp'></span><span id='topic+find_lcp+2CQuadtree-method'></span><span id='topic+find_lcp.Quadtree'></span><span id='topic+find_lcp+2CLcpFinder-method'></span><span id='topic+find_lcp.LcpFinder'></span>

<h3>Description</h3>

<p>Finds the least-cost path (LCP) from the start point (the point
used to create the <code><a href="#topic+LcpFinder">LcpFinder</a></code>) to another point, using a
<code><a href="#topic+Quadtree">Quadtree</a></code> as a resistance surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree'
find_lcp(
  x,
  start_point,
  end_point,
  use_orig_points = TRUE,
  xlim = NULL,
  ylim = NULL,
  search_by_centroid = FALSE
)

## S4 method for signature 'LcpFinder'
find_lcp(x, end_point, allow_same_cell_path = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_lcp_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+LcpFinder">LcpFinder</a></code> or a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="find_lcp_+3A_start_point">start_point</code></td>
<td>
<p>two-element numeric vector; the x and y coordinates of the
starting point. Not used if <code>x</code> is a <code><a href="#topic+LcpFinder">LcpFinder</a></code> since the
start point is determined when the <code><a href="#topic+LcpFinder">LcpFinder</a></code> is created
(using <code><a href="#topic+lcp_finder">lcp_finder</a>()</code>).</p>
</td></tr>
<tr><td><code id="find_lcp_+3A_end_point">end_point</code></td>
<td>
<p>two-element numeric vector; the x and y coordinates of the
destination point</p>
</td></tr>
<tr><td><code id="find_lcp_+3A_use_orig_points">use_orig_points</code></td>
<td>
<p>boolean; if <code>TRUE</code> (the default), the path is
calculated between <code>start_point</code> and <code>end_point</code>. If
<code>FALSE</code>, the path is calculated between the centroids of the cells the
points fall in.</p>
</td></tr>
<tr><td><code id="find_lcp_+3A_xlim">xlim</code></td>
<td>
<p>two-element numeric vector (xmin, xmax); passed to
<code><a href="#topic+lcp_finder">lcp_finder</a>()</code>; constrains the nodes included in the network to
those whose x limits fall in the range specified in <code>xlim</code>. If
<code>NULL</code> the x limits of <code>x</code> are used</p>
</td></tr>
<tr><td><code id="find_lcp_+3A_ylim">ylim</code></td>
<td>
<p>same as <code>xlim</code>, but for y</p>
</td></tr>
<tr><td><code id="find_lcp_+3A_search_by_centroid">search_by_centroid</code></td>
<td>
<p>boolean; passed to <code><a href="#topic+lcp_finder">lcp_finder</a>()</code>;
determines which cells are considered to be &quot;in&quot; the box specified by
<code>xlim</code> and <code>ylim</code>. If <code>FALSE</code> (the default) any cell that
overlaps with the box is included. If <code>TRUE</code>, a cell is only included
if its <strong>centroid</strong> falls inside the box.</p>
</td></tr>
<tr><td><code id="find_lcp_+3A_allow_same_cell_path">allow_same_cell_path</code></td>
<td>
<p>boolean; default is FALSE; if TRUE, allows
paths to be found between two points that fall in the same cell. See
'Details' for more.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette 'quadtree-lcp' for more details and examples (i.e. run
<code>vignette("quadtree-lcp", package = "quadtree")</code>)
</p>
<p>Using <code>find_lcp(&lt;Quadtree&gt;)</code> rather than <code>find_lcp(&lt;LcpFinder&gt;)</code>
is simply a matter of convenience - when a <code><a href="#topic+Quadtree">Quadtree</a></code> is passed
to <code>find_lcp()</code>, it automatically creates an <code><a href="#topic+LcpFinder">LcpFinder</a></code>
and then uses <code>find_lcp(&lt;LcpFinder&gt;)</code> to get the path between the two
points. This is convenient if you only want a single LCP. However, if you
want to find multiple LCPs from a single start point, it is better to first
create the <code><a href="#topic+LcpFinder">LcpFinder</a></code> object using <code><a href="#topic+lcp_finder">lcp_finder</a>()</code>
and then use <code>find_lcp(&lt;LcpFinder&gt;)</code> for finding LCPs. This is because
an <code><a href="#topic+LcpFinder">LcpFinder</a></code> object saves state, so subsequent calls to
<code>find_lcp(&lt;LcpFinder&gt;)</code> will run faster.
</p>
<p>By default, if the end point falls in the same cell as the start point, the
path will consist only of the point associated with the cell. When using
<code>find_lcp</code> with a <code><a href="#topic+LcpFinder">LcpFinder</a></code>, setting
<code>allow_same_cell_path</code> to <code>TRUE</code> allows for paths to be found
within a single cell. In this case, if the start and end points fall in the
same cell, the path will consist of two points - the point associated with
the cell and <code>end_point</code>. If using <code>find_lcp</code> with a
<code><a href="#topic+Quadtree">Quadtree</a></code>, this will automatically be allowed if
<code>use_orig_points</code> is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>Returns a five column matrix representing the LCP. It has the
following columns:
</p>

<ul>
<li><p><code>x</code>: x coordinate of this point (centroid of the cell)
</p>
</li>
<li><p><code>y</code>: y coordinate of this point (centroid of the cell)
</p>
</li>
<li><p><code>cost_tot</code>: the cumulative cost up to this point
</p>
</li>
<li><p><code>dist_tot</code>: the cumulative distance up to this point - note
that this is not straight-line distance, but instead the distance along
the path
</p>
</li>
<li><p><code>cost_cell</code>: the cost of the cell that contains this point
</p>
</li>
<li><p><code>id</code>: the ID of the cell that contains this point
</p>
</li></ul>

<p>If no path is possible between the two points, a zero-row matrix with the
previously described columns is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lcp_finder">lcp_finder</a>()</code> creates the LCP finder object used as
input to this function. <code><a href="#topic+find_lcps">find_lcps</a>()</code> calculates all LCPs
whose cost-distance is less than some value. <code><a href="#topic+summarize_lcps">summarize_lcps</a>()</code>
outputs a summary matrix of all LCPs that have been calculated so far.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### NOTE #######
# see the "quadtree-lcp" vignette for more details and examples:
# vignette("quadtree-lcp", package = "quadtree")
####################

library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

# create a quadtree
qt &lt;- quadtree(habitat, split_threshold = .1, adj_type = "expand")
plot(qt, crop = TRUE, na_col = NULL, border_lwd = .4)

# define our start and end points
start_pt &lt;- c(6989, 34007)
end_pt &lt;- c(33015, 38162)

# create the LCP finder object and find the LCP
lcpf &lt;- lcp_finder(qt, start_pt)
path &lt;- find_lcp(lcpf, end_pt)

# plot the LCP
plot(qt, crop = TRUE, na_col = NULL, border_col = "gray30", border_lwd = .4)
points(rbind(start_pt, end_pt), pch = 16, col = "red")
lines(path[, 1:2], col = "black")

# note that the above path can also be found as follows:
path &lt;- find_lcp(qt, start_pt, end_pt)
</code></pre>

<hr>
<h2 id='find_lcps'>Find LCPs to surrounding points</h2><span id='topic+find_lcps'></span><span id='topic+find_lcps+2CLcpFinder-method'></span>

<h3>Description</h3>

<p>Calculates least-cost paths (LCPs) from the start point (the
point used to create the <code><a href="#topic+LcpFinder">LcpFinder</a></code>) to surrounding points. A
constraint can be placed on the LCPs so that only LCPs that are less than
some specified cost-distance are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LcpFinder'
find_lcps(x, limit = NULL, return_summary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_lcps_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+LcpFinder">LcpFinder</a></code></p>
</td></tr>
<tr><td><code id="find_lcps_+3A_limit">limit</code></td>
<td>
<p>numeric; the maximum cost-distance for the LCPs. If <code>NULL</code>
(the default), no limit is applied and all possible LCPs (within the
<code>LcpFinder</code>'s search area) are found</p>
</td></tr>
<tr><td><code id="find_lcps_+3A_return_summary">return_summary</code></td>
<td>
<p>boolean; if <code>TRUE</code> (the default),
<code><a href="#topic+summarize_lcps">summarize_lcps</a>()</code> is used to return a summary matrix of all
paths found. If <code>FALSE</code>, no value is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once the LCPs have been calculated, <code><a href="#topic+find_lcp">find_lcp</a>()</code> can be
used to extract paths to individual points. No further calculation will be
required to retrieve these paths so long as they were calculated when
<code>find_lcps()</code> was run.
</p>
<p>A very important note to make is that once the LCP tree is calculated, it
never gets smaller. For example, we could use <code><a href="#topic+find_lcps">find_lcps</a>()</code>
with <code>limit = NULL</code> to calculate all LCPs. If we then used
<code><a href="#topic+find_lcps">find_lcps</a>()</code> on the same <code>LcpFinder</code> but this time used a
limit, it would still return <em>all</em> of the LCPs, even those that are
greater than the specified limit, since the tree never shrinks.
</p>


<h3>Value</h3>

<p>If <code>return_summary</code> is <code>TRUE</code>,
<code><a href="#topic+summarize_lcps">summarize_lcps</a>()</code> is used to return a matrix summarizing each
LCP found. See the help page of that function for details on the return
matrix. If <code>return_summary</code> is <code>FALSE</code>, no value is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lcp_finder">lcp_finder</a>()</code> creates the <code><a href="#topic+LcpFinder">LcpFinder</a></code>
object used as input to this function. <code><a href="#topic+find_lcp">find_lcp</a>()</code> returns the
LCP between the start point and another point.
<code><a href="#topic+summarize_lcps">summarize_lcps</a>()</code> outputs a summary matrix of all LCPs that
have been calculated so far.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### NOTE #######
# see the "quadtree-lcp" vignette  for more details and examples:
# vignette("quadtree-lcp", package = "quadtree")
####################

library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, split_threshold = .1, adj_type = "expand")

start_pt &lt;- c(19000, 25000)

# finds LCPs to all cells
lcpf1 &lt;- lcp_finder(qt, start_pt)
paths1 &lt;- find_lcps(lcpf1, limit = NULL)

# limit LCPs by cost-distance
lcpf2 &lt;- lcp_finder(qt, start_pt)
paths2 &lt;- find_lcps(lcpf2, limit = 5000)

# Now plot the reachable cells
plot(qt, crop = TRUE, na_col = NULL, border_lwd = .3)
points(lcpf1, col = "black", pch = 16, cex = 1)
points(lcpf2, col = "red", pch = 16, cex = .7)
points(start_pt[1], start_pt[2], bg = "skyblue", col = "black", pch = 24,
       cex = 1.5)
</code></pre>

<hr>
<h2 id='get_neighbors'>Get the neighbors of a <code>Quadtree</code> cell</h2><span id='topic+get_neighbors'></span><span id='topic+get_neighbors+2CQuadtree+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Returns a matrix with information about the neighbors of a
quadtree cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree,numeric'
get_neighbors(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_neighbors_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="get_neighbors_+3A_y">y</code></td>
<td>
<p>two-element numeric vector; the x and y coordinates of a point -
this is used to identify which quadtree cell to find neighbors for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A six-column matrix with one row per neighboring cell. It has the following
columns: </p>

<ul>
<li> <p><code>id</code>: the ID of the cell
</p>
</li>
<li> <p><code>xmin</code>, <code>xmax</code>, <code>ymin</code>, <code>ymax</code>: the x and y
limits of the cell
</p>
</li>
<li> <p><code>value</code>: the value of the cell
</p>
</li></ul>

<p>Note that this return matrix only includes terminal nodes/cells - that is,
cells that have no children. Also note that cells that are diagonal from each
other are considered to be neighbors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

# create a quadtree
qt &lt;- quadtree(habitat, split_threshold = .1, adj_type = "expand")

# get the cell's neighbors
pt &lt;- c(27000, 10000)
nbs &lt;- get_neighbors(qt, pt)

# plot the neighbors
plot(qt, border_lwd = .3)
points(pt[1], pt[2], col = "black", bg = "lightblue", pch = 21)
with(data.frame(nbs),
   rect(xmin, ymin, xmax, ymax, col = "red", border = "black", lwd = 2))
</code></pre>

<hr>
<h2 id='lcp_finder'>Create a <code>LcpFinder</code></h2><span id='topic+lcp_finder'></span><span id='topic+lcp_finder+2CQuadtree-method'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+LcpFinder">LcpFinder</a></code> object that can then be used
by <code><a href="#topic+find_lcp">find_lcp</a></code> and <code><a href="#topic+find_lcps">find_lcps</a></code> to find least-cost
paths (LCPs) using a <code><a href="#topic+Quadtree">Quadtree</a></code> as a resistance surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree'
lcp_finder(
  x,
  start_point,
  xlim = NULL,
  ylim = NULL,
  new_points = matrix(nrow = 0, ncol = 2),
  search_by_centroid = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcp_finder_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code> to be used as a resistance surface</p>
</td></tr>
<tr><td><code id="lcp_finder_+3A_start_point">start_point</code></td>
<td>
<p>two-element numeric vector (x, y) - the x and y coordinates of the
starting point</p>
</td></tr>
<tr><td><code id="lcp_finder_+3A_xlim">xlim</code></td>
<td>
<p>two-element numeric vector (xmin, xmax) - constrains the nodes
included in the network to those whose x limits fall in the range specified
in <code>xlim</code>. If <code>NULL</code> the x limits of <code>x</code> are used</p>
</td></tr>
<tr><td><code id="lcp_finder_+3A_ylim">ylim</code></td>
<td>
<p>same as <code>xlim</code>, but for y</p>
</td></tr>
<tr><td><code id="lcp_finder_+3A_new_points">new_points</code></td>
<td>
<p>a two-column matrix representing point coordinates. First
column contains the x-coordinates, second column contains the
y-coordinates. This matrix specifies point locations to use instead of the
node centroids. See 'Details' for more.</p>
</td></tr>
<tr><td><code id="lcp_finder_+3A_search_by_centroid">search_by_centroid</code></td>
<td>
<p>boolean; determines which cells are considered to
be &quot;in&quot; the box specified by <code>xlim</code> and <code>ylim</code>. If <code>FALSE</code>
(the default) any cell that overlaps with the box is included. If
<code>TRUE</code>, a cell is only included if its <strong>centroid</strong> falls inside
the box.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette 'quadtree-lcp' for more details and examples (i.e. run
<code>vignette("quadtree-lcp", package = "quadtree")</code>)
</p>
<p>To find a least-cost path, the cells are treated as points - by default,
the cell centroids are used. This results in some degree of error,
especially for large cells. The <code>new_points</code> parameter can be used to
specify the points used to represent the cells - this is particularly
useful for specifying the points to be used for the start and end cells.
Each point in the matrix will be used as the point for the cell it falls in
(if two points fall in the same cell, the first point is used). Note that
this raises the possibility that a straight line between neighboring cells
may pass through other cells as well, which complicates the calculation of
the edge cost. To mitigate this, when a straight line between neighboring
cells passes through a different cell, the path is adjusted so that it
actually consists of two segments - the start point to the &quot;corner point&quot;
where the two cells meet, and then from that point to the end point. See
the &quot;quadtree-lcp&quot; vignette for a graphical example of this situation.
</p>
<p>An <code>LcpFinder</code> saves state, so once the LCP tree is calculated,
individual LCPs can be retrieved without further computation. This makes it
efficient at calculating multiple LCPs from a single starting point.
However, in the case where only a single LCP is needed,
<code><a href="#topic+find_lcp">find_lcp</a>()</code> offers an interface for finding an LCP without
needing to use <code>lcp_finder()</code> to create the <code>LcpFinder</code> object
first.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+LcpFinder">LcpFinder</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_lcp">find_lcp</a>()</code> returns the LCP between the start point and
another point. <code><a href="#topic+find_lcps">find_lcps</a>()</code> finds all LCPs whose cost-distance
is less than some value. <code><a href="#topic+summarize_lcps">summarize_lcps</a>()</code> outputs a summary
matrix of all LCPs that have been calculated so far.
<code><a href="#topic+plot.LcpFinder">points</a>()</code> and
<code><a href="#topic+plot.LcpFinder">lines</a>()</code> can be used to plot a
<code><a href="#topic+LcpFinder">LcpFinder</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### NOTE #######
# see the "quadtree-lcp" vignette for more details and examples:
# vignette("quadtree-lcp", package = "quadtree")
####################

library(quadtree)

habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))
qt &lt;- quadtree(habitat, split_threshold = .1, adj_type = "expand")

# find the LCP between two points
start_pt &lt;- c(6989, 34007)
end_pt &lt;- c(33015, 38162)

# create the LCP finder object and find the LCP
lcpf &lt;- lcp_finder(qt, start_pt)
path &lt;- find_lcp(lcpf, end_pt)

# plot the LCP
plot(qt, crop = TRUE, na_col = NULL, border_lwd = .3)
points(rbind(start_pt, end_pt), pch = 16, col = "red")
lines(path[, 1:2], col = "black")


</code></pre>

<hr>
<h2 id='LcpFinder-class'>LcpFinder Class</h2><span id='topic+LcpFinder-class'></span><span id='topic+LcpFinder'></span>

<h3>Description</h3>

<p>This S4 class is a wrapper around a <code>CppLcpFinder</code> C++ object
that is made available to R via the 'Rcpp' package. Instances of this class
can be created from a <code><a href="#topic+Quadtree">Quadtree</a></code> object using the
<code><a href="#topic+lcp_finder">lcp_finder</a></code> function.
</p>
<p>The methods of the C++ object (<code><a href="#topic+CppLcpFinder">CppLcpFinder</a></code>) can be
accessed from R, but the typical end-user should have no need of these
methods - they are meant for internal use. That being said, descriptions of
the available methods can be found on the <code><a href="#topic+CppLcpFinder">CppLcpFinder</a></code>
documentation page.
</p>


<h3>Details</h3>

<p>Functions for creating a <code>LcpFinder</code> object: </p>

<ul>
<li> <p><code><a href="#topic+lcp_finder">lcp_finder</a>()</code>
</p>
</li></ul>

<p>Methods: </p>

<ul>
<li> <p><code><a href="#topic+find_lcp">find_lcp</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+find_lcps">find_lcps</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+plot.LcpFinder">plot</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+show.LcpFinder">show</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+summarize_lcps">summarize_lcps</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+summary.LcpFinder">summary</a>()</code>
</p>
</li></ul>



<h3>Slots</h3>


<dl>
<dt><code>ptr</code></dt><dd><p>a C++ object of class <code>CppLcpFinder</code></p>
</dd>
</dl>

<hr>
<h2 id='n_cells'>Get the number of cells in a <code>Quadtree</code></h2><span id='topic+n_cells'></span><span id='topic+n_cells+2CQuadtree-method'></span>

<h3>Description</h3>

<p>Returns the number of nodes/cells in the quadtree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree'
n_cells(x, terminal_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_cells_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="n_cells_+3A_terminal_only">terminal_only</code></td>
<td>
<p>boolean; if <code>TRUE</code> (the default) only the terminal
nodes are counted. If <code>FALSE</code>, all nodes are counted, thereby giving the
total number of nodes in the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, .1)
n_cells(qt)
n_cells(qt, terminal_only = FALSE)
</code></pre>

<hr>
<h2 id='plot'>Plot a <code>Quadtree</code></h2><span id='topic+plot'></span><span id='topic+plot+2CQuadtree+2Cmissing-method'></span><span id='topic+plot.Quadtree'></span>

<h3>Description</h3>

<p>Plots a <code><a href="#topic+Quadtree">Quadtree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree,missing'
plot(
  x,
  add = FALSE,
  col = NULL,
  alpha = NULL,
  nb_line_col = NULL,
  border_col = "black",
  border_lwd = 0.4,
  xlim = NULL,
  ylim = NULL,
  zlim = NULL,
  crop = FALSE,
  na_col = "white",
  adj_mar_auto = 6,
  legend = TRUE,
  legend_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="plot_+3A_add">add</code></td>
<td>
<p>boolean; if <code>FALSE</code> (the default) a new plot is created. If
<code>TRUE</code>, the plot is added to the existing plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>character vector; the colors that will be used to create the
color ramp used in the plot. If no argument is provided,
<code>terrain.colors(100, rev = TRUE)</code> is used.</p>
</td></tr>
<tr><td><code id="plot_+3A_alpha">alpha</code></td>
<td>
<p>numeric; transparency of the cell colors. Must be in the range
0-1, where 0 is fully transparent and 1 is fully opaque. If <code>NULL</code>
(the default) it sets <code>alpha</code> to 1.</p>
</td></tr>
<tr><td><code id="plot_+3A_nb_line_col">nb_line_col</code></td>
<td>
<p>character; the color of the lines drawn between
neighboring cells. If <code>NULL</code> (the default), these lines are not
plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_border_col">border_col</code></td>
<td>
<p>character; the color to use for the cell borders. Use
&quot;transparent&quot; if you don't want borders to be shown. Default is &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plot_+3A_border_lwd">border_lwd</code></td>
<td>
<p>numeric; the line width of the cell borders. Default is .4.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlim">xlim</code></td>
<td>
<p>two-element numeric vector; defines the minimum and
maximum values of the x axis. Note that this overrides the <code>crop</code>
parameter.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylim">ylim</code></td>
<td>
<p>two-element numeric vector; defines the minimum and
maximum values of the y axis. Note that this overrides the <code>crop</code>
parameter.</p>
</td></tr>
<tr><td><code id="plot_+3A_zlim">zlim</code></td>
<td>
<p>two-element numeric vector; defines how the colors are
assigned to the cell values.  The first color in <code>col</code> will correspond
to <code>zlim[1]</code> and the last color in <code>col</code> will correspond to
<code>zlim[2]</code>. If <code>zlim</code> does not encompass the entire range of cell
values, cells that have values outside of the range specified by
<code>zlim</code> will be treated as <code>NA</code> cells. If this value is
<code>NULL</code> (the default), it uses the min and max cell values.</p>
</td></tr>
<tr><td><code id="plot_+3A_crop">crop</code></td>
<td>
<p>boolean; if <code>TRUE</code>, only displays the extent of the original
raster, thus ignoring any of the <code>NA</code> cells that were added to pad the
raster before making the quadtree. Ignored if either <code>xlim</code> or
<code>ylim</code> are non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_na_col">na_col</code></td>
<td>
<p>character; the color to use for <code>NA</code> cells. If
<code>NULL</code>, <code>NA</code> cells are not plotted. Default is &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="plot_+3A_adj_mar_auto">adj_mar_auto</code></td>
<td>
<p>numeric; checks the size of the right margin
(<code>par("mar")[4]</code>) - if it is less than the provided value and
<code>legend</code> is <code>TRUE</code>, then it sets it to be the provided value in
order to make room for the legend (after plotting, it resets it to its
original value). If <code>NULL</code>, the margin is not adjusted. Default is 6.</p>
</td></tr>
<tr><td><code id="plot_+3A_legend">legend</code></td>
<td>
<p>boolean; if <code>TRUE</code> (the default) a legend is plotted in
the right margin.</p>
</td></tr>
<tr><td><code id="plot_+3A_legend_args">legend_args</code></td>
<td>
<p>named list; contains arguments that are sent to the
<code><a href="#topic+add_legend">add_legend</a>()</code> function. See the help page for
<code><a href="#topic+add_legend">add_legend</a>()</code> for the parameters. Note that <code>zlim</code>,
<code>cols</code>, and <code>alpha</code> are supplied automatically, so if the list
contains elements named <code>zlim</code>, <code>cols</code>, or <code>alpha</code> the
user-provided values will be ignored.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>arguments passed to the default
<code><a href="graphics.html#topic+plot.default">plot</a>()</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'Examples' for demonstrations of how the various options can be
used.
</p>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

# create quadtree
qt &lt;- quadtree(habitat, split_threshold = .1, adj_type = "expand")

#####################################
# DEFAULT
#####################################

# default - no additional parameters provided
plot(qt)

#####################################
# CHANGE PLOT EXTENT
#####################################

# note that additional parameters like 'main', 'xlab', 'ylab', etc. will be
# passed to the default 'plot()' function

# crop extent to the original extent of the raster
plot(qt, crop = TRUE, main = "cropped")

# crop and don't plot NA cells
plot(qt, crop = TRUE, na_col = NULL, main = "cropped")

# use 'xlim' and 'ylim' to zoom in on an area
plot(qt, xlim = c(10000, 20000), ylim = c(20000, 30000), main = "zoomed in")

#####################################
# COLORS AND BORDERS
#####################################

# change border color and width
plot(qt, border_col = "transparent") # no borders
plot(qt, border_col = "gray60") # gray borders
plot(qt, border_lwd = .3) # change line thickness of borders

# change color palette
plot(qt, col = c("blue", "yellow", "red"))
plot(qt, col = hcl.colors(100))
plot(qt, col = c("black", "white"))

# change color transparency
plot(qt, alpha = .5)
plot(qt, col = c("blue", "yellow", "red"), alpha = .5)

# change color of NA cells
plot(qt, na_col = "lavender")

# don't plot NA cells at all
plot(qt, na_col = NULL)

# change 'zlim'
plot(qt, zlim = c(0, 5))
plot(qt, zlim = c(.2, .7))

#####################################
# SHOW NEIGHBOR CONNECTIONS
#####################################

# plot all neighbor connections
plot(qt, nb_line_col = "black", border_col = "gray60")

# don't plot connections to NA cells
plot(qt, nb_line_col = "black", border_col = "gray60", na_col = NULL)

#####################################
# LEGEND
#####################################

# no legend
plot(qt, legend = FALSE)

# increase right margin size
plot(qt, adj_mar_auto = 10)

# use 'legend_args' to customize the legend
plot(qt, adj_mar_auto = 10,
     legend_args = list(lgd_ht_pct = .8, bar_wd_pct = .4))
</code></pre>

<hr>
<h2 id='plot.LcpFinder'>Plot a <code>LcpFinder</code> object</h2><span id='topic+plot.LcpFinder'></span><span id='topic+points.LcpFinder'></span><span id='topic+points+2CLcpFinder-method'></span><span id='topic+lines.LcpFinder'></span><span id='topic+lines+2CLcpFinder-method'></span>

<h3>Description</h3>

<p>Plots a <code><a href="#topic+LcpFinder">LcpFinder</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LcpFinder'
points(x, add = TRUE, ...)

## S4 method for signature 'LcpFinder'
lines(x, add = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.LcpFinder_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+LcpFinder">LcpFinder</a></code></p>
</td></tr>
<tr><td><code id="plot.LcpFinder_+3A_add">add</code></td>
<td>
<p>boolean; if <code>TRUE</code> (the default), the plot is added to the
existing plot. If <code>FALSE</code>, a new plot is created.</p>
</td></tr>
<tr><td><code id="plot.LcpFinder_+3A_...">...</code></td>
<td>
<p>arguments passed to the default plotting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>points()</code> plots points at the centroids of the cells to which
a path has been found. <code>lines()</code> plots all of the LCPs found so far by
the <code><a href="#topic+LcpFinder">LcpFinder</a></code> object.
</p>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, .1)

start_point &lt;- c(6989, 34007)
end_point &lt;- c(12558, 27602)
lcpf &lt;- lcp_finder(qt, start_point)
lcp &lt;- find_lcp(lcpf, end_point)

plot(qt, crop = TRUE, border_lwd = .3, na_col = NULL)
points(lcpf, col = "red", pch = 16, cex = .4)
lines(lcpf)
</code></pre>

<hr>
<h2 id='projection'>Retrieve the projection of a <code>Quadtree</code></h2><span id='topic+projection'></span><span id='topic+projection+2CQuadtree-method'></span><span id='topic+projection+3C-'></span><span id='topic+projection+3C-+2CQuadtree+2CANY-method'></span><span id='topic+projection+3C-+2CQuadtree-method'></span>

<h3>Description</h3>

<p>Retrieves the projection of a <code><a href="#topic+Quadtree">Quadtree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree'
projection(x)

## S4 replacement method for signature 'Quadtree'
projection(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projection_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="projection_+3A_value">value</code></td>
<td>
<p>character; the projection to assign to the
<code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, .1)
quadtree::projection(qt) &lt;- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
quadtree::projection(qt)
</code></pre>

<hr>
<h2 id='quadtree'>Create a <code>Quadtree</code> from a raster or matrix</h2><span id='topic+quadtree'></span><span id='topic+quadtree+2CANY-method'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+Quadtree">Quadtree</a></code> from a 
<code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code>,
<code><a href="raster.html#topic+RasterLayer-class">RasterLayer</a></code> or a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
quadtree(
  x,
  split_threshold = NULL,
  split_method = "range",
  split_fun = NULL,
  split_args = list(),
  split_if_any_na = TRUE,
  split_if_all_na = FALSE,
  combine_method = "mean",
  combine_fun = NULL,
  combine_args = list(),
  max_cell_length = NULL,
  min_cell_length = NULL,
  adj_type = "expand",
  resample_n_side = NULL,
  resample_pad_nas = TRUE,
  extent = NULL,
  projection = "",
  proj4string = NULL,
  template_quadtree = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadtree_+3A_x">x</code></td>
<td>
<p>a <code><a href="raster.html#topic+RasterLayer-class">RasterLayer</a></code>,
<code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code>, or
<code>matrix</code>. If <code>x</code> is a <code>matrix</code>, the <code>extent</code> and
<code>projection</code> parameters can be used to set the extent and projection
of the quadtree. If <code>x</code> is a
<code><a href="raster.html#topic+RasterLayer-class">RasterLayer</a></code> or
<code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code>, the extent and
projection are derived from the raster.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_split_threshold">split_threshold</code></td>
<td>
<p>numeric; the threshold value used by the split method
(specified by <code>split_method</code>) to decide whether to split a quadrant.
If the value for a quadrant is greater than this value, it is split into
its four child cells. If <code>split_method</code> is <code>"custom"</code>, this
parameter is ignored.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_split_method">split_method</code></td>
<td>
<p>character; one of <code>"range"</code> (the default),
<code>"sd"</code> (standard deviation), <code>"cv"</code> (coefficient of variation) or
<code>"custom"</code>. Determines the method used for calculating the value used
to determine whether or not to split a quadrant (this calculated value is
compared with <code>split_threshold</code> to decide whether to split a cell). If
<code>"custom"</code>, a function must be supplied to <code>split_fun</code>. See
'Details' for more.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_split_fun">split_fun</code></td>
<td>
<p>function; function used on each quadrant to decide whether
or not to split the quadrant. Only used when <code>split_method</code> is
<code>"custom"</code>. Must take two arguments, <code>vals</code> (a numeric vector of
the cell values in a quadrant) and <code>args</code> (a named list of arguments
used within the function), and must output <code>TRUE</code> if the quadrant is
to be split and <code>FALSE</code> otherwise. It must be able to handle <code>NA</code>
values - if <code>NA</code> is ever returned, an error will occur.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_split_args">split_args</code></td>
<td>
<p>list; named list that contains the arguments needed by
<code>split_fun</code>. This list is given to the <code>args</code> parameter of
<code>split_fun</code>.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_split_if_any_na">split_if_any_na</code></td>
<td>
<p>boolean; if <code>TRUE</code> (the default), a quadrant is
automatically split if any of the values within the quadrant are <code>NA</code>.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_split_if_all_na">split_if_all_na</code></td>
<td>
<p>boolean; if <code>FALSE</code> (the default), a quadrant
that contains only <code>NA</code> values is not split. If <code>TRUE</code>, quadrants
that contain all <code>NA</code> values are split to the smallest possible cell
size.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_combine_method">combine_method</code></td>
<td>
<p>character; one of <code>"mean"</code>, <code>"median"</code>,
<code>"min"</code>, <code>"max"</code>, or <code>"custom"</code>. Determines the method used
for aggregating the values of multiple cells into a single value for a
larger, aggregated cell. Default is <code>"mean"</code>. If <code>"custom"</code>, a
function must be supplied to <code>combine_fun</code>.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_combine_fun">combine_fun</code></td>
<td>
<p>function; function used to calculate the value of a
quadrant. Only used when <code>combine_method</code> is <code>"custom"</code>. Must
take two arguments, <code>vals</code> (a numeric vector of the cell values in a
quadrant) and <code>args</code> (a named list of arguments used within the
function), and must output a single numeric value, which will be used as
the cell value.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_combine_args">combine_args</code></td>
<td>
<p>list; named list that contains the arguments needed by
<code>combine_fun</code>. This list is given to the <code>args</code> parameter of
<code>combine_fun</code>.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_max_cell_length">max_cell_length</code></td>
<td>
<p>numeric; the maximum side length allowed for a
quadtree cell. Any quadrants larger than <code>max_cell_length</code> will
automatically be split. If <code>NULL</code> (the default) no restrictions are
placed on the maximum cell length.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_min_cell_length">min_cell_length</code></td>
<td>
<p>numeric; the minimum side length allowed for a
quadtree cell. A quadrant will not be split if its children would be
smaller than <code>min_cell_length</code>. If <code>NULL</code> (the default) no
restrictions are placed on the minimum cell length.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_adj_type">adj_type</code></td>
<td>
<p>character; one of <code>"expand"</code> (the default),
<code>"resample"</code>, or <code>"none"</code>. Specifies the method used to adjust
<code>x</code> so that its dimensions are suitable for quadtree creation (i.e.
square and with the number of cells in each direction being a power of 2).
See 'Details' for more on the two methods of adjustment.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_resample_n_side">resample_n_side</code></td>
<td>
<p>integer; if <code>adj_type</code> is <code>'resample'</code>, this
number is used to determine the dimensions to resample the raster to.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_resample_pad_nas">resample_pad_nas</code></td>
<td>
<p>boolean; only applicable if <code>adj_type</code> is
<code>'resample'</code>. If <code>TRUE</code> (the default), <code>NA</code>s are added to
the shorter side of the raster to make it square before resampling. This
ensures that the cells of the resulting quadtree will be square. If
<code>FALSE</code>, no <code>NA</code>s are added - the cells in the quadtree will not
be square.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_extent">extent</code></td>
<td>
<p><code><a href="raster.html#topic+Extent-class">Extent</a></code> object or else a
four-element numeric vector describing the extent of the data (in this
order: xmin, xmax, ymin, ymax). Only used when <code>x</code> is a matrix - this
parameter is ignored if <code>x</code> is a raster since the extent is derived
directly from the raster. If no value is provided and <code>x</code> is a matrix,
the extent is assumed to be <code>c(0,ncol(x),0,nrow(x))</code>.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_projection">projection</code></td>
<td>
<p>character; string describing the projection of the
data. Only used when <code>x</code> is a matrix - this parameter is ignored if
<code>x</code> is a raster since the proj4ection of the raster is automatically
used. If no value is provided and <code>x</code> is a matrix, the projection of
the quadtree is set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_proj4string">proj4string</code></td>
<td>
<p>deprecated. Use <code>projection</code> instead.</p>
</td></tr>
<tr><td><code id="quadtree_+3A_template_quadtree">template_quadtree</code></td>
<td>
<p><code><a href="#topic+Quadtree">Quadtree</a></code>; if provided, the new
quadtree will be created so that it has the exact same structure as the
template quadtree. Thus, no split function is used because the decision
about whether to split is pre-determined by the template quadtree. The
raster used to create the template quadtree should have the exact same
extent and dimensions as <code>x</code>. If <code>template_quadtree</code> is
non-<code>NULL</code>, all <code>split_</code>* parameters are disregarded, as are
<code>max_cell_length</code> and <code>min_cell_length</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'quadtree-creation' vignette contains detailed explanations and
examples for all of the various creation options - run
<code>vignette("quadtree-creation", package = "quadtree")</code> to view the
vignette.
</p>
<p>If <code>adj_type</code> is <code>"expand"</code>, <code>NA</code> cells are added to the
raster in order to create an expanded raster whose dimensions are a power
of two. The smallest number that is a power of two but greater than the
larger dimension is used as the dimensions of the expanded raster. If
<code>adj_type</code> is <code>"resample"</code>, the raster is resampled to a raster
with <code>resample_n_side</code> rows and columns. If <code>resample_pad_nas</code> is
<code>TRUE</code>, <code>NA</code> rows or columns are are added to the shorter
dimension before resampling to make the raster square. This ensures that
the quadtree cells will be square (assuming the original raster cells were
square).
</p>
<p>When <code>split_method</code> is <code>"range"</code>, the difference between the
maximum and minimum cell values in a quadrant is calculated - if this value
is greater than <code>split_threshold</code>, the quadrant is split. When
<code>split_method</code> is <code>"sd"</code>, the standard deviation of the cell
values in a quadrant is calculated - if this value is greater than
<code>split_threshold</code>, the quadrant is split.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+Quadtree">Quadtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### NOTE #######
# see the "quadtree-creation" vignette for more details and examples of all
# the different parameter options:
# vignette("quadtree-creation", package = "quadtree")
####################

library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, .15)
plot(qt)
# we can make it look nicer by customizing the plotting parameters
plot(qt, crop = TRUE, na_col = NULL, border_lwd = .3)

# try a different splitting method
qt &lt;- quadtree(habitat, .05, "sd")
plot(qt)

# ---- using a custom split function ----

# split a cell if any of the values are below a given value
split_fun = function(vals, args) {
  if (any(is.na(vals))) { # check for NAs first
    return(TRUE) # if there are any NAs we'll split automatically
  } else {
    return(any(vals &lt; args$threshold))
  }
}

qt &lt;- quadtree(habitat, split_method = "custom", split_fun = split_fun,
                split_args = list(threshold = .8))
plot(qt)
</code></pre>

<hr>
<h2 id='Quadtree-class'>Quadtree class</h2><span id='topic+Quadtree-class'></span><span id='topic+Quadtree'></span>

<h3>Description</h3>

<p>This S4 class is essentially a wrapper around a <code><a href="#topic+CppQuadtree">CppQuadtree</a></code> C++
object. <code>Quadtree</code> has one slot, which is named <code>ptr</code> and contains
a <code><a href="#topic+CppQuadtree">CppQuadtree</a></code> object. Instances of this class can be created
through the <code><a href="#topic+quadtree">quadtree</a>()</code> function.
</p>
<p>An important note to make is that functions that modify a <code>Quadtree</code>
modify the existing object. For example, running
<code><a href="#topic+transform_values">transform_values</a>(qt, function(x) x+1)</code> modifies <code>qt</code>. This
differs from the way R objects usually function - most functions that modify
R objects return a modified copy of the object, thus preserving the original
object. Note that the <code><a href="#topic+copy">copy</a>()</code> function, which makes a deep copy
of a <code>Quadtree</code>, can be used to preserve a copy of a <code>Quadtree</code>
before modifying it.
</p>
<p>The methods of the C++ object (<code><a href="#topic+CppQuadtree">CppQuadtree</a></code>) stored in the
<code>ptr</code> slot can be accessed from R, but the typical end-user should have
no need of these methods - they are meant for internal use. That being said,
descriptions of the available methods can be found on the
<code><a href="#topic+CppQuadtree">CppQuadtree</a></code> documentation page.
</p>


<h3>Details</h3>

<p>Functions for creating a <code>Quadtree</code> object: </p>

<ul>
<li> <p><code><a href="#topic+quadtree">quadtree</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+read_quadtree">read_quadtree</a>()</code>
</p>
</li></ul>

<p>Methods:
</p>

<ul>
<li> <p><code><a href="#topic+as_data_frame">as_data_frame</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+as_raster">as_raster</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+as_vector">as_vector</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+copy">copy</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+extent">extent</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+extract">extract</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+get_neighbors">get_neighbors</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+lcp_finder">lcp_finder</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+n_cells">n_cells</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+projection">projection</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+plot.Quadtree">plot</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+set_values">set_values</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+show.Quadtree">show</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+summary.Quadtree">summary</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+transform_values">transform_values</a>()</code>
</p>
</li>
<li> <p><code><a href="#topic+write_quadtree">write_quadtree</a>()</code>
</p>
</li></ul>



<h3>Slots</h3>


<dl>
<dt><code>ptr</code></dt><dd><p>a C++ object of class <code>CppQuadtree</code></p>
</dd>
</dl>

<hr>
<h2 id='quadtree-package'>Quadtree Representation of Rasters</h2><span id='topic+quadtree-package'></span>

<h3>Description</h3>

<p>This package provides functionality for working with raster-like quadtrees
(also called “region quadtrees”), which allow for variable-sized cells. The
package allows for flexibility in the quadtree creation process.  Several
functions defining how to split and aggregate cells are provided, and custom
functions can be written for both of these processes. In addition, quadtrees
can be created using other quadtrees as “templates”, so that the new
quadtree's structure is identical to the template quadtree. The package also
includes functionality for modifying quadtrees, querying values, saving
quadtrees to a file, and calculating least-cost paths using the quadtree as a
resistance surface.
</p>
<p>Vignettes are included that demonstrate the functionality contained in the
package - these are intended to serve as an introduction to using the
<code>quadtree</code> package. You can see the available vignettes by running
<code>vignette(package = "quadtree")</code> and view individual vignettes using
<code>vignette("vignette-name", package = "quadtree")</code>.
</p>
<p>I'd recommend reading the vignettes in the following order: </p>

<ol>
<li> <p><code>"quadtree-creation"</code>
</p>
</li>
<li> <p><code>"quadtree-usage"</code>
</p>
</li>
<li> <p><code>"quadtree-lcp"</code>
</p>
</li></ol>

<p>A fourth vignette called &quot;quadtree-code&quot; is also available. This briefly
discusses the structure of the package. It is not necessary for using the
package but may be useful for those who want more details about the code.
</p>

<hr>
<h2 id='read_quadtree'>Read/write a <code>Quadtree</code></h2><span id='topic+read_quadtree'></span><span id='topic+write_quadtree'></span><span id='topic+read_quadtree+2Ccharacter-method'></span><span id='topic+write_quadtree+2Ccharacter-method'></span><span id='topic+write_quadtree+2Ccharacter+2CQuadtree-method'></span>

<h3>Description</h3>

<p>Reads and writes a <code><a href="#topic+Quadtree">Quadtree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
read_quadtree(x)

## S4 method for signature 'character,Quadtree'
write_quadtree(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_quadtree_+3A_x">x</code></td>
<td>
<p>character; the filepath to read from or write to</p>
</td></tr>
<tr><td><code id="read_quadtree_+3A_y">y</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>To read/write a quadtree object, the C++ library <code>cereal</code> is used to
serialize the quadtree and save it to a file. The file extension is
unimportant - it can be anything (I've been using the extension '.qtree').
</p>


<h3>Value</h3>

<p><code>read_quadtree()</code> - returns a <code><a href="#topic+Quadtree">Quadtree</a></code>
</p>
<p><code>write_quadtree()</code> - no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, .1)

path &lt;- tempfile(fileext = "qtree")
write_quadtree(path, qt)
qt2 &lt;- read_quadtree(path)
</code></pre>

<hr>
<h2 id='set_values'>Change values of <code>Quadtree</code> cells</h2><span id='topic+set_values'></span><span id='topic+set_values+2CQuadtree+2CANY+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+Quadtree">Quadtree</a></code>, a set of points, and a vector of
new values, changes the value of the quadtree cells containing the points
to the corresponding value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree,ANY,numeric'
set_values(x, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_values_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="set_values_+3A_y">y</code></td>
<td>
<p>A two-column matrix representing point coordinates. First column
contains the x-coordinates, second column contains the y-coordinates.</p>
</td></tr>
<tr><td><code id="set_values_+3A_z">z</code></td>
<td>
<p>A numeric vector the same length as the number of rows of
<code>y</code>. The values of the cells containing <code>y</code> will be changed
to the corresponding value in <code>z</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that it is entirely possible for <code>y</code> to contain multiple points
that all fall within the same cell. The values are changed in the order
given, so the cell will take on the <em>last</em> value given for that cell.
</p>
<p>It's important to note that this modifies the original quadtree. If you wish
to maintain a version of the original quadtree, use <code><a href="#topic+copy">copy</a></code>
beforehand to make a copy of the quadtree.
</p>


<h3>Value</h3>

<p>no return value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transform_values">transform_values</a>()</code> can be used to transform the
existing values of all cells using a function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

# create a quadtree
qt &lt;- quadtree(habitat, split_threshold = .1)

# generate some random points, then change the values at those points
ext &lt;- extent(qt)
pts &lt;- cbind(runif(100, ext[1], ext[2]), runif(100, ext[3], ext[4]))
set_values(qt, pts, rep(10, 100))

# plot it out to see what happened
old_par &lt;- par(mfrow = c(1, 2))
plot(qt, main = "original")
plot(qt, main = "after modification")
par(old_par)
</code></pre>

<hr>
<h2 id='summarize_lcps'>Get a matrix summarizing all LCPs found by a <code>LcpFinder</code></h2><span id='topic+summarize_lcps'></span><span id='topic+summarize_lcps+2CLcpFinder-method'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+LcpFinder">LcpFinder</a></code>, returns a matrix that
summarizes all of the LCPs that have been calculated by the
<code><a href="#topic+LcpFinder">LcpFinder</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LcpFinder'
summarize_lcps(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_lcps_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+LcpFinder">LcpFinder</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function returns <strong>all</strong> of the paths that have
been calculated. Finding one LCP likely involves finding other LCPs as
well. Thus, even if the <code><a href="#topic+LcpFinder">LcpFinder</a></code> has been used to find one
LCP, others have most likely been calculated. This function returns all of
the LCPs that have been calculated so far.
</p>


<h3>Value</h3>

<p>Returns a nine-column matrix with one row for each LCP (and therefore
one row per destination cell). The columns are as follows:
</p>

<ul>
<li><p><code>id</code>: the ID of the destination cell
</p>
</li>
<li><p><code>xmin, xmax, ymin, ymax</code>: the extent of the destination
cell
</p>
</li>
<li><p><code>value</code>: the value of the destination cell
</p>
</li>
<li><p><code>area</code>: the area of the destination cell
</p>
</li>
<li><p><code>lcp_cost</code>: the cumulative cost of the LCP to this cell
</p>
</li>
<li><p><code>lcp_dist</code>: the cumulative distance of the LCP to this cell
- note that this is not straight-line distance, but instead the distance
along the path </p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+lcp_finder">lcp_finder</a>()</code> creates the <code><a href="#topic+LcpFinder">LcpFinder</a></code>
object used as input to this function. <code><a href="#topic+find_lcp">find_lcp</a>()</code> returns the
LCP between the start point and another point. <code><a href="#topic+find_lcps">find_lcps</a>()</code>
calculates all LCPs whose cost-distance is less than some value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, split_threshold = .1, adj_type = "expand")

start_pt &lt;- c(19000, 25000)
end_pt &lt;- c(33015, 38162)

# find LCP from 'start_pt' to 'end_pt'
lcpf &lt;- lcp_finder(qt, start_pt)
lcp &lt;- find_lcp(lcpf, end_pt)

# retrieve ALL the paths that have been calculated
paths &lt;- summarize_lcps(lcpf)
head(paths)
</code></pre>

<hr>
<h2 id='summary.LcpFinder'>Show a summary of a <code>LcpFinder</code></h2><span id='topic+summary.LcpFinder'></span><span id='topic+summary+2CLcpFinder-method'></span><span id='topic+show.LcpFinder'></span><span id='topic+show+2CLcpFinder-method'></span>

<h3>Description</h3>

<p>Prints out information about the <code><a href="#topic+LcpFinder">LcpFinder</a></code>.
Information shown is:
</p>

<ul>
<li><p> class of object
</p>
</li>
<li><p> start point
</p>
</li>
<li><p> search limits
</p>
</li>
<li><p> number of paths found
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LcpFinder'
summary(object)

## S4 method for signature 'LcpFinder'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.LcpFinder_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+LcpFinder">LcpFinder</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, .1)

start_point &lt;- c(6989, 34007)
end_point &lt;- c(33015, 38162)

lcpf &lt;- lcp_finder(qt, start_point)
lcp &lt;- find_lcp(lcpf, end_point)

summary(lcpf)
</code></pre>

<hr>
<h2 id='summary.Quadtree'>Show a summary of a <code>Quadtree</code></h2><span id='topic+summary.Quadtree'></span><span id='topic+summary+2CQuadtree-method'></span><span id='topic+show.Quadtree'></span><span id='topic+show+2CQuadtree-method'></span>

<h3>Description</h3>

<p>Prints out information about a <code><a href="#topic+Quadtree">Quadtree</a></code>.
Information shown is:
</p>

<ul>
<li><p> class of object
</p>
</li>
<li><p> number of cells
</p>
</li>
<li><p> minimum cell size
</p>
</li>
<li><p> extent
</p>
</li>
<li><p> projection
</p>
</li>
<li><p> minimum and maximum values
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree'
summary(object)

## S4 method for signature 'Quadtree'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Quadtree_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, .1)
summary(qt)
</code></pre>

<hr>
<h2 id='transform_values'>Transform the values of all <code>Quadtree</code> cells</h2><span id='topic+transform_values'></span><span id='topic+transform_values+2CQuadtree+2Cfunction-method'></span>

<h3>Description</h3>

<p>Uses a function to change all cell values of a
<code><a href="#topic+Quadtree">Quadtree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Quadtree,'function''
transform_values(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_values_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
<tr><td><code id="transform_values_+3A_y">y</code></td>
<td>
<p>function; function used on each cell to transform the
value. Must accept a single numeric value and return a single numeric
value. The function must also be able to handle <code>NA</code> values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies a function to every single cell, which allows the user
to do things like multiply by a scalar, invert the values, etc.
</p>
<p>Since a quadtree may contain <code>NA</code> values, <code>y</code> must
be able to handle <code>NA</code>s without throwing an error. For example, if
<code>y</code> contains some control statement such as <code>if(x &lt;
.7)</code>, the function must have a separate statement before this to catch
<code>NA</code> values, since having an <code>NA</code> in an if statement is not
allowed. See 'Examples' for an example of this.
</p>
<p>It's important to note that this modifies the original quadtree. If you wish
to maintain a version of the original quadtree, use <code><a href="#topic+copy">copy</a></code>
beforehand to make a copy of the quadtree (see 'Examples').
</p>


<h3>Value</h3>

<p>no return value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_values">set_values</a>()</code> can be used to set the values of cells
to specified values (rather than transforming the existing values).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

# create a quadtree
qt1 &lt;- quadtree(habitat, split_threshold = .1)

# copy the quadtree so that we have a copy of the original (since using
#'transform_values' modifies the quadtree object)
qt2 &lt;- copy(qt1)
qt3 &lt;- copy(qt1)
qt4 &lt;- copy(qt1)

transform_values(qt2, function(x) 1 - x)
transform_values(qt3, function(x) x^3)
transform_values(qt4, function(x) {
  if (is.na(x)) return(NA) # make sure to handle NA's
  if (x &lt; .7) return(0)
  return(1)
})

old_par &lt;- par(mfrow = c(2, 2))
plot(qt1, main = "original", crop = TRUE, na_col = NULL,
     border_lwd = .3, zlim = c(0, 1))
plot(qt2, main = "1 - value", crop = TRUE, na_col = NULL,
     border_lwd = .3, zlim = c(0, 1))
plot(qt3, main = "values cubed", crop = TRUE, na_col = NULL,
     border_lwd = .3, zlim = c(0, 1))
plot(qt4, main = "values converted to 0/1", crop = TRUE, na_col = NULL,
     border_lwd = .3, zlim = c(0, 1))
par(old_par)
</code></pre>

<hr>
<h2 id='write_quadtree_ptr'>Read/write a <code>Quadtree</code></h2><span id='topic+write_quadtree_ptr'></span><span id='topic+write_quadtree_ptr+2Ccharacter+2CQuadtree-method'></span>

<h3>Description</h3>

<p>This is for debugging only, and users should never need to use
this function - use <code><a href="#topic+write_quadtree">write_quadtree</a>()</code> instead.
<code><a href="#topic+write_quadtree">write_quadtree</a>()</code> serializes the <code>CppQuadtree</code> object
(note that the underlying C++ object is actually called
<code>QuadtreeWrapper</code>, but it is exposed to R as <code>CppQuadtree</code>) stored
in the <code>ptr</code> slot of <code><a href="#topic+Quadtree">Quadtree</a></code>.
</p>
<p>This function, however, serializes only the <code>Quadtree</code> object contained by the
<code>QuadtreeWrapper</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character,Quadtree'
write_quadtree_ptr(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_quadtree_ptr_+3A_x">x</code></td>
<td>
<p>character; the filepath to read from or write to</p>
</td></tr>
<tr><td><code id="write_quadtree_ptr_+3A_y">y</code></td>
<td>
<p>a <code><a href="#topic+Quadtree">Quadtree</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quadtree)
habitat &lt;- terra::rast(system.file("extdata", "habitat.tif", package="quadtree"))

qt &lt;- quadtree(habitat, .1)

path &lt;- tempfile(fileext = "qtree")
write_quadtree_ptr(path, qt)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
