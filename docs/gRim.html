<!DOCTYPE html><html><head><title>Help for package gRim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gRim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cg-stats'><p>Mean, covariance and counts for grouped data (statistics for</p>
conditional Gaussian distribution).</a></li>
<li><a href='#citest-array'><p>Test for conditional independence in a contingency table</p></a></li>
<li><a href='#citest-df'><p>Test for conditional independence in a dataframe</p></a></li>
<li><a href='#citest-generic'><p>Generic function for conditional independence test</p></a></li>
<li><a href='#citest-mvn'><p>Test for conditional independence in the multivariate normal</p>
distribution</a></li>
<li><a href='#citest-ordinal'><p>A function to compute Monte Carlo and asymptotic tests of conditional</p>
independence for ordinal and/or nominal variables.</a></li>
<li><a href='#cmod'><p>Graphical Gaussian model</p></a></li>
<li><a href='#getEdges'><p>Find edges in a graph or edges not in an undirected graph.</p></a></li>
<li><a href='#ggmfit'><p>Iterative proportional fitting of graphical Gaussian model</p></a></li>
<li><a href='#imodel-dmod'><p>Discrete interaction model (log-linear model)</p></a></li>
<li><a href='#imodel-general'><p>General functions related to iModels</p></a></li>
<li><a href='#imodel-info'><p>Get information about mixed interaction model objects</p></a></li>
<li><a href='#imodel-mmod'><p>Mixed interaction model.</p></a></li>
<li><a href='#internal'><p>Internal functions for the gRim package</p></a></li>
<li><a href='#loglin-dim'><p>Return the dimension of a log-linear model</p></a></li>
<li><a href='#loglin-effloglin'><p>Fitting Log-Linear Models by Message Passing</p></a></li>
<li><a href='#modify_glist'><p>Modify generating class for a graphical/hierarchical model</p></a></li>
<li><a href='#parm-conversion'><p>Conversion between different parametrizations of mixed models</p></a></li>
<li><a href='#parse_gm_formula'><p>Parse graphical model formula</p></a></li>
<li><a href='#stepwise'><p>Stepwise model selection in (graphical) interaction models</p></a></li>
<li><a href='#test-edges'><p>Test edges in graphical models with p-value/AIC value</p></a></li>
<li><a href='#testadd'><p>Test addition of edge to graphical model</p></a></li>
<li><a href='#testdelete'><p>Test deletion of edge from an interaction model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Graphical Interaction Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the following types of models: Models for contingency
    tables (i.e. log-linear models) Graphical Gaussian models for multivariate
    normal data (i.e. covariance selection models) Mixed interaction models.
    Documentation about 'gRim' is provided by vignettes included in this
    package and the book by Højsgaard, Edwards and Lauritzen (2012,
    &lt;<a href="https://doi.org/10.1007%2F978-1-4614-2299-0">doi:10.1007/978-1-4614-2299-0</a>&gt;); see 'citation("gRim")' for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://people.math.aau.dk/~sorenh/software/gR/">https://people.math.aau.dk/~sorenh/software/gR/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), methods, gRbase (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, stats4, gRain (&ge; 1.3.10), magrittr, Rcpp (&ge; 0.11.1)</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.1), RcppArmadillo, RcppEigen, gRbase (&ge;
2.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-02 02:24:30 UTC; sorenh</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-02 03:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cg-stats'>Mean, covariance and counts for grouped data (statistics for
conditional Gaussian distribution).</h2><span id='topic+cg-stats'></span><span id='topic+CGstats'></span><span id='topic+CGstats.data.frame'></span>

<h3>Description</h3>

<p><code>CGstats</code> provides what corresponds to calling
<code>cow.wt</code> on different strata of data where the strata are defined by
the combinations of factors in data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGstats(object, varnames = NULL, homogeneous = TRUE, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cg-stats_+3A_object">object</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="cg-stats_+3A_varnames">varnames</code></td>
<td>
<p>Names of variables to be used.</p>
</td></tr>
<tr><td><code id="cg-stats_+3A_homogeneous">homogeneous</code></td>
<td>
<p>Logical; if TRUE a common covariance matrix is reported.</p>
</td></tr>
<tr><td><code id="cg-stats_+3A_simplify">simplify</code></td>
<td>
<p>Logical; if TRUE the result will be presented in a simpler
form.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose form depends on the type of input data and the varnames.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov.wt">cov.wt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(milkcomp)
# milkcomp &lt;- subset(milkcomp, (treat %in% c("a", "b")) &amp; (lactime %in% c("t1", "t2")))
# milkcomp &lt;- milkcomp[,-1]
# milkcomp$treat 	&lt;- factor(milkcomp$treat)
# milkcomp$lactime 	&lt;- factor(milkcomp$lactime)

CGstats(milkcomp)
CGstats(milkcomp, c(1, 2))
CGstats(milkcomp, c("lactime", "treat"))
CGstats(milkcomp, c(3, 4))
CGstats(milkcomp, c("fat", "protein"))

CGstats(milkcomp, c(2, 3, 4), simplify=FALSE)
CGstats(milkcomp, c(2, 3, 4), homogeneous=FALSE)
CGstats(milkcomp, c(2, 3, 4), simplify=FALSE, homogeneous=FALSE)



</code></pre>

<hr>
<h2 id='citest-array'>Test for conditional independence in a contingency table</h2><span id='topic+citest-array'></span><span id='topic+ciTest_table'></span>

<h3>Description</h3>

<p>Test for conditional independence in a contingency table
represented as an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciTest_table(
  x,
  set = NULL,
  statistic = "dev",
  method = "chisq",
  adjust.df = TRUE,
  slice.info = TRUE,
  L = 20,
  B = 200,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="citest-array_+3A_x">x</code></td>
<td>
<p>An array of counts with named dimnames.</p>
</td></tr>
<tr><td><code id="citest-array_+3A_set">set</code></td>
<td>
<p>A specification of the test to be made. The tests are of the form u
and v are independent condionally on S where u and v are variables and S
is a set of variables. See 'details' for details about specification of
<code>set</code>.</p>
</td></tr>
<tr><td><code id="citest-array_+3A_statistic">statistic</code></td>
<td>
<p>Possible choices of the test statistic are <code>"dev"</code> for
deviance and <code>"X2"</code> for Pearsons X2 statistic.</p>
</td></tr>
<tr><td><code id="citest-array_+3A_method">method</code></td>
<td>
<p>Method of evaluating the test statistic. Possible choices are
<code>"chisq"</code>, <code>"mc"</code> (for Monte Carlo) and <code>"smc"</code> for
sequential Monte Carlo.</p>
</td></tr>
<tr><td><code id="citest-array_+3A_adjust.df">adjust.df</code></td>
<td>
<p>Logical. Should degrees of freedom be adjusted for
sparsity?</p>
</td></tr>
<tr><td><code id="citest-array_+3A_slice.info">slice.info</code></td>
<td>
<p>Logical. Should slice info be stored in the
output?</p>
</td></tr>
<tr><td><code id="citest-array_+3A_l">L</code></td>
<td>
<p>Number of extreme cases as stop criterion if method is
<code>"smc"</code> (sequential Monte Carlo test); ignored otherwise.</p>
</td></tr>
<tr><td><code id="citest-array_+3A_b">B</code></td>
<td>
<p>Number (maximum) of simulations to make if method is
<code>"mc"</code> or <code>"smc"</code> (Monte Carlo test or sequential
Monte Carlo test); ignored otherwise.</p>
</td></tr>
<tr><td><code id="citest-array_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>set</code> can be 1) a vector or 2) a right-hand sided formula in
which variables are separated by '+'. In either case, it is tested if the
first two variables in the <code>set</code> are conditionally independent given
the remaining variables in <code>set</code>.  (Notice an abuse of the '+'
operator in the right-hand sided formula: The order of the variables does
matter.)
</p>
<p>If <code>set</code> is <code>NULL</code> then it is tested whether the first two
variables are conditionally independent given the remaining variables.
</p>


<h3>Value</h3>

<p>An object of class <code>citest</code> (which is a list).
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ciTest">ciTest</a></code>, <code><a href="#topic+ciTest_df">ciTest_df</a></code>,
<code><a href="#topic+ciTest_mvn">ciTest_mvn</a></code>, <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lizard)

## lizard is has named dimnames
names( dimnames( lizard ))
## checked with
is.named.array( lizard )

## Testing for conditional independence:
# the following are all equivalent:
ciTest(lizard, set=~diam + height + species)
# ciTest(lizard, set=c("diam", "height", "species"))
# ciTest(lizard, set=1:3)
# ciTest(lizard)
# (The latter because the names in lizard are as given above.)

## Testing for marginal independence
ciTest(lizard, set=~diam + height)
ciTest(lizard, set=1:2)

## Getting slice information:
ciTest(lizard, set=c("diam", "height", "species"), slice.info=TRUE)$slice

## Do Monte Carlo test instead of usual likelihood ratio test. Different
# options:

# 1) Do B*10 simulations divided equally over each slice: 
ciTest(lizard, set=c("diam", "height", "species"), method="mc", B=400)
# 2) Do at most B*10 simulations divided equally over each slice, but stop
# when at most L extreme values are found
ciTest(lizard, set=c("diam", "height", "species"), method="smc", B=400)
</code></pre>

<hr>
<h2 id='citest-df'>Test for conditional independence in a dataframe</h2><span id='topic+citest-df'></span><span id='topic+ciTest_df'></span>

<h3>Description</h3>

<p>Test for conditional independence in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciTest_df(x, set = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="citest-df_+3A_x">x</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="citest-df_+3A_set">set</code></td>
<td>
<p>A specification of the test to be made. The tests are of
the form u and v are independent condionally on S where u and v
are variables and S is a set of variables. See 'details' for
details about specification of <code>set</code>.</p>
</td></tr>
<tr><td><code id="citest-df_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>set</code> can be 1) a vector or 2) a right-hand sided formula in
which variables are separated by '+'. In either case, it is tested
if the first two variables in the <code>set</code> are conditionally
independent given the remaining variables in <code>set</code>.  (Notice
an abuse of the '+' operator in the right-hand sided formula: The
order of the variables does matter.)
</p>
</li>
<li><p> If <code>set</code> is <code>NULL</code> then it is tested whether the first two
variables are conditionally independent given the remaining variables.
</p>
</li>
<li><p> If <code>set</code> consists only of factors then <code>x[,set]</code> is converted to a
contingency table and the test is made in this table using
<code>ciTest_table()</code>.
</p>
</li>
<li><p> If <code>set</code> consists only of numeric values and integers then
<code>x[,set]</code> is converted to a list with components <code>cov</code> and
<code>n.obs</code> by calling <code>cov.wt(x[,set], method='ML')</code>. This list is
then passed on to <code>ciTest_mvn()</code> which makes the test.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>citest</code> (which is a list).
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ciTest">ciTest</a></code>, <code><a href="#topic+ciTest_table">ciTest_table</a></code>,
<code><a href="#topic+ciTest_mvn">ciTest_mvn</a></code>, <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(milkcomp1)
ciTest(milkcomp1, set=~tre + fat + pro)
ciTest_df(milkcomp1, set=~tre + fat + pro)
</code></pre>

<hr>
<h2 id='citest-generic'>Generic function for conditional independence test</h2><span id='topic+citest-generic'></span><span id='topic+ciTest'></span>

<h3>Description</h3>

<p>Generic function for conditional independence test. Specializes
to specific types of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciTest(x, set = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="citest-generic_+3A_x">x</code></td>
<td>
<p>An object for which a test for conditional independence is to be
made. See 'details' for valid types of <code>x</code>.</p>
</td></tr>
<tr><td><code id="citest-generic_+3A_set">set</code></td>
<td>
<p>A specification of the test to be made. The tests are of the form
u and v are independent condionally on S where u and v are variables and
S is a set of variables. See 'details' for details about specification of
<code>set</code>.</p>
</td></tr>
<tr><td><code id="citest-generic_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> can be
</p>

<ol>
<li><p> a table (an array). In this case <code>ciTest_table</code> is called.
</p>
</li>
<li><p> a dataframe whose columns are numerics and factors. In this
case <code>ciTest_df</code> is called.
</p>
</li>
<li><p> a list with components <code>cov</code> and <code>n.obs</code>. In this
case <code>ciTest_mvn</code> is called.
</p>
</li></ol>

<p><code>set</code> can be
</p>

<ol>
<li><p> a vector,
</p>
</li>
<li><p> a right-hand sided
formula in which variables are separated by '+'.
</p>
</li></ol>

<p>In either case, it is tested if the first two variables in the
<code>set</code> are conditionally independent given the remaining
variables in <code>set</code>.  (Notice an abuse of the '+' operator in
the right-hand sided formula: The order of the variables does
matter.)
</p>


<h3>Value</h3>

<p>An object of class <code>citest</code> (which is a list).
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ciTest_table">ciTest_table</a></code>,
<code><a href="#topic+ciTest_df">ciTest_df</a></code>,
<code><a href="#topic+ciTest_mvn">ciTest_mvn</a></code>,
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## contingency table:
data(reinis)
## dataframe with only numeric variables:
data(carcass)
## dataframe with numeric variables and factors:
data(milkcomp1)

ciTest(cov.wt(carcass, method='ML'), set=~Fat11 + Meat11 + Fat12)
ciTest(reinis, set=~smo + phy + sys)
ciTest(milkcomp1, set=~tre + fat + pro)
</code></pre>

<hr>
<h2 id='citest-mvn'>Test for conditional independence in the multivariate normal
distribution</h2><span id='topic+citest-mvn'></span><span id='topic+ciTest_mvn'></span>

<h3>Description</h3>

<p>Test for conditional independence in the multivariate
normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciTest_mvn(x, set = NULL, statistic = "DEV", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="citest-mvn_+3A_x">x</code></td>
<td>
<p>A list with elements <code>cov</code> and <code>n.obs</code> (such as
returned from calling <code>cov.wt()</code> on a dataframe. See
examples below.)</p>
</td></tr>
<tr><td><code id="citest-mvn_+3A_set">set</code></td>
<td>
<p>A specification of the test to be made. The tests are of
the form u and v are independent condionally on S where u and v
are variables and S is a set of variables. See 'details' for
details about specification of <code>set</code>.</p>
</td></tr>
<tr><td><code id="citest-mvn_+3A_statistic">statistic</code></td>
<td>
<p>The test statistic to be used, valid choices are
<code>"DEV"</code> and <code>"F"</code>.</p>
</td></tr>
<tr><td><code id="citest-mvn_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>set</code> can be 1) a vector or 2) a right-hand sided formula in
which variables are separated by '+'. In either case, it is tested
if the first two variables in the <code>set</code> are conditionally
independent given the remaining variables in <code>set</code>.  (Notice
an abuse of the '+' operator in the right-hand sided formula: The
order of the variables does matter.)
</p>
<p>If <code>set</code> is <code>NULL</code> then it is tested whether the first
two variables are conditionally independent given the remaining
variables.
</p>
<p><code>x</code> must be a list with components <code>cov</code> and <code>n.obs</code>
such as returned by calling <code>cov.wt( , method='ML')</code> on a
dataframe.
</p>


<h3>Value</h3>

<p>An object of class <code>citest</code> (which is a list).
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ciTest">ciTest</a></code>, <code><a href="#topic+ciTest_table">ciTest_table</a></code>,
<code><a href="#topic+ciTest_df">ciTest_df</a></code>, <code><a href="#topic+ciTest_mvn">ciTest_mvn</a></code>,
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(carcass)
ciTest(cov.wt(carcass, method='ML'), set=~Fat11 + Meat11 + Fat12)
ciTest_mvn(cov.wt(carcass, method='ML'), set=~Fat11 + Meat11 + Fat12)

</code></pre>

<hr>
<h2 id='citest-ordinal'>A function to compute Monte Carlo and asymptotic tests of conditional
independence for ordinal and/or nominal variables.</h2><span id='topic+citest-ordinal'></span><span id='topic+ciTest_ordinal'></span>

<h3>Description</h3>

<p>The function computes tests of independence of two variables,
say u and v, given a set of variables, say S. The deviance, Wilcoxon,
Kruskal-Wallis and Jonkheere-Terpstra tests are supported.  Asymptotic
and Monte Carlo p-values are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ciTest_ordinal(x, set = NULL, statistic = "dev", N = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="citest-ordinal_+3A_x">x</code></td>
<td>
<p>A dataframe or table.</p>
</td></tr>
<tr><td><code id="citest-ordinal_+3A_set">set</code></td>
<td>
<p>The variable set (u,v,S), given either as an integer vector of the
column numbers of a dataframe or dimension numbers of a table, or as a
character vector with the corresponding variable or dimension names.</p>
</td></tr>
<tr><td><code id="citest-ordinal_+3A_statistic">statistic</code></td>
<td>
<p>Either &quot;deviance&quot;, &quot;wilcoxon&quot;, &quot;kruskal&quot; or &quot;jt&quot;.</p>
</td></tr>
<tr><td><code id="citest-ordinal_+3A_n">N</code></td>
<td>
<p>The number of Monte Carlo samples. If N&lt;=0 then Monte Carlo p-values
are not computed.</p>
</td></tr>
<tr><td><code id="citest-ordinal_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The deviance test is appropriate when u and v are nominal; Wilcoxon,
when u is binary and v is ordinal; Kruskal-Wallis, when u is nominal and
v is ordinal; Jonckheere-Terpstra, when both u and v are ordinal.
</p>


<h3>Value</h3>

<p>A list including the test statistic, the asymptotic p-value and, when
computed, the Monte Carlo p-value.  </p>
<table>
<tr><td><code>P</code></td>
<td>
<p>Asymptotic p-value</p>
</td></tr>
<tr><td><code>montecarlo.P</code></td>
<td>
<p>Monte Carlo p-value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Flaminia Musella, David Edwards, Søren Højsgaard,
<a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>See Edwards D. (2000), &quot;Introduction to Graphical Modelling&quot;, 2nd
ed., Springer-Verlag, pp. 130-153.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ciTest_table">ciTest_table</a></code>, <code><a href="#topic+ciTest">ciTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(gRim)
data(dumping, package="gRbase")

ciTest_ordinal(dumping, c(2,1,3), stat="jt", N=1000)
ciTest_ordinal(dumping, c("Operation", "Symptom", "Centre"), stat="jt", N=1000)
ciTest_ordinal(dumping, ~Operation + Symptom + Centre, stat="jt", N=1000)

data(reinis)
ciTest_ordinal(reinis, c(1,3,4:6), N=1000)

# If data is a dataframe
dd     &lt;- as.data.frame(dumping)
ncells &lt;- prod(dim(dumping))
ff     &lt;- dd$Freq
idx    &lt;- unlist(mapply(function(i,n) rep(i,n),1:ncells,ff))
dumpDF &lt;- dd[idx, 1:3]
rownames(dumpDF) &lt;- 1:NROW(dumpDF)

ciTest_ordinal(dumpDF, c(2,1,3), stat="jt", N=1000)
ciTest_ordinal(dumpDF, c("Operation","Symptom","Centre"), stat="jt", N=1000)
ciTest_ordinal(dumpDF, ~ Operation + Symptom + Centre, stat="jt", N=1000)
</code></pre>

<hr>
<h2 id='cmod'>Graphical Gaussian model</h2><span id='topic+cmod'></span><span id='topic+extract_cmod_data'></span>

<h3>Description</h3>

<p>Specification of graphical Gaussian model. The 'c' in
the name <code>cmod</code> refers to that it is a (graphical) model
for 'c'ontinuous variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmod(formula, data, marginal = NULL, fit = TRUE, details = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmod_+3A_formula">formula</code></td>
<td>
<p>Model specification in one of the following forms:
1) a right-hand sided formula, 2) as a list of generators.
Notice that there are certain model specification shortcuts,
see Section 'details' below.</p>
</td></tr>
<tr><td><code id="cmod_+3A_data">data</code></td>
<td>
<p>Data in one of the following forms: 1) A dataframe or
2) a list with elements <code>cov</code> and <code>n.obs</code> (such as
returned by the <code>cov.wt()</code> function.)</p>
</td></tr>
<tr><td><code id="cmod_+3A_marginal">marginal</code></td>
<td>
<p>Should only a subset of the variables be used in
connection with the model specification shortcuts.</p>
</td></tr>
<tr><td><code id="cmod_+3A_fit">fit</code></td>
<td>
<p>Should the model be fitted.</p>
</td></tr>
<tr><td><code id="cmod_+3A_details">details</code></td>
<td>
<p>Control the amount of output; for debugging
purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The independence model can be specified as <code>~.^1</code> and
the saturated model as <code>~.^.</code>. The <code>marginal</code>
argument can be used for specifying the independence or
saturated models for only a subset of the variables.
</p>


<h3>Value</h3>

<p>An object of class <code>cModel</code> (a list)
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmod">dmod</a></code>, <code><a href="#topic+mmod">mmod</a></code>,
<code><a href="#topic+ggmfit">ggmfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Graphical Gaussian model
data(carcass)
cm1 &lt;- cmod(~ .^., data=carcass)

## Stepwise selection based on BIC
cm2 &lt;- backward(cm1, k=log(nrow(carcass)))

## Stepwise selection with fixed edges
cm3 &lt;- backward(cm1, k=log(nrow(carcass)),
 fixin=matrix(c("LeanMeat", "Meat11", "Meat12", "Meat13",
                "LeanMeat", "Fat11", "Fat12", "Fat13"),
                 ncol=2))

</code></pre>

<hr>
<h2 id='getEdges'>Find edges in a graph or edges not in an undirected graph.</h2><span id='topic+getEdges'></span><span id='topic+getEdges.list'></span><span id='topic+getEdges.graphNEL'></span><span id='topic+getEdges.matrix'></span><span id='topic+getInEdges'></span><span id='topic+getOutEdges'></span><span id='topic+getEdgesMAT'></span><span id='topic+getInEdgesMAT'></span><span id='topic+getOutEdgesMAT'></span>

<h3>Description</h3>

<p>Returns the edges of a graph (or edges not in a graph) where the
graph can be either an igraph object, a list of generators or an
adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEdges(object, type = "unrestricted", ingraph = TRUE, discrete = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEdges_+3A_object">object</code></td>
<td>
<p>An object representing a graph; either a generator list, an
igraph object or an adjacency matrix.</p>
</td></tr>
<tr><td><code id="getEdges_+3A_type">type</code></td>
<td>
<p>Either &quot;unrestricted&quot; or &quot;decomposable&quot;</p>
</td></tr>
<tr><td><code id="getEdges_+3A_ingraph">ingraph</code></td>
<td>
<p>If TRUE the result is the edges in the graph; if FALSE the
result is the edges not in the graph.</p>
</td></tr>
<tr><td><code id="getEdges_+3A_discrete">discrete</code></td>
<td>
<p>This argument is relevant only if <code>object</code> specifies a
marked graph in which some vertices represent discrete variables and some
represent continuous variables.</p>
</td></tr>
<tr><td><code id="getEdges_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>ingraph=TRUE</code>: If type=&quot;decomposable&quot; then
<code>getEdges()</code> returns those edges e for which the graph with e
removed is decomposable.
</p>
<p>When <code>ingraph=FALSE</code>: Likewise, if type=&quot;decomposable&quot; then
<code>getEdges()</code> returns those edges e for which the graph with e added is
decomposable.
</p>
<p>The functions <code>getInEdges()</code> and <code>getInEdges()</code> are just wrappers
for calls to <code>getEdges()</code>.
</p>
<p>The workhorses are <code>getInEdgesMAT()</code> and <code>getOutEdgesMAT()</code> and
these work on adjacency matrices.
</p>
<p>Regarding the argument <code>discrete</code>, please see the documentation of
<code><a href="gRbase.html#topic+graph-mcs">mcs_marked</a></code>.
</p>


<h3>Value</h3>

<p>A p * 2 matrix with edges.
</p>


<h3>Note</h3>

<p>These functions work on undirected graphs. The behaviour is
undocumented for directed graphs.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="gRbase.html#topic+edgeList">edgeList</a></code>, <code><a href="gRbase.html#topic+nonEdgeList">nonEdgeList</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gg     &lt;- ug(~a:b:d + a:c:d + c:e, result="igraph")
glist  &lt;- getCliques(gg)
adjmat &lt;- as(gg, "matrix")

#### On a glist
getEdges(glist)
getEdges(glist, type="decomposable")
# Deleting (a,d) would create a 4-cycle

getEdges(glist, ingraph=FALSE)
getEdges(glist, type="decomposable", ingraph=FALSE)
# Adding (e,b) would create a 4-cycle

#### On a graphNEL
getEdges(gg)
getEdges(gg, type="decomposable")
# Deleting (a,d) would create a 4-cycle

getEdges(gg, ingraph=FALSE)
getEdges(gg, type="decomposable", ingraph=FALSE)
# Adding (e,b) would create a 4-cycle

#### On an adjacency matrix
getEdges(adjmat)
getEdges(adjmat, type="decomposable")
# Deleting (a,d) would create a 4-cycle

getEdges(adjmat, ingraph=FALSE)
getEdges(adjmat, type="decomposable", ingraph=FALSE)
# Adding (e,b) would create a 4-cycle


## Marked graphs; vertices a,b are discrete; c,d are continuous
UG &lt;- ug(~a:b:c + b:c:d, result="igraph")
disc &lt;- c("a", "b")
getEdges(UG)
getEdges(UG, discrete=disc)
## Above: same results; there are 5 edges in the graph

getEdges(UG, type="decomposable")
## Above: 4 edges can be removed and will give a decomposable graph
##(only removing the edge (b,c) would give a non-decomposable model)

getEdges(UG, type="decomposable", discrete=c("a","b"))
## Above: 3 edges can be removed and will give a strongly decomposable
## graph. Removing (b,c) would create a 4--cycle and removing (a,b)
## would create a forbidden path; a path with only continuous vertices
## between two discrete vertices.

</code></pre>

<hr>
<h2 id='ggmfit'>Iterative proportional fitting of graphical Gaussian model</h2><span id='topic+ggmfit'></span><span id='topic+ggmfitr'></span>

<h3>Description</h3>

<p>Fit graphical Gaussian model by iterative proportional fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggmfit(
  S,
  n.obs,
  glist,
  start = NULL,
  eps = 1e-12,
  iter = 1000,
  details = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggmfit_+3A_s">S</code></td>
<td>
<p>Empirical covariance matrix</p>
</td></tr>
<tr><td><code id="ggmfit_+3A_n.obs">n.obs</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="ggmfit_+3A_glist">glist</code></td>
<td>
<p>Generating class for model (a list)</p>
</td></tr>
<tr><td><code id="ggmfit_+3A_start">start</code></td>
<td>
<p>Initial value for concentration matrix</p>
</td></tr>
<tr><td><code id="ggmfit_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="ggmfit_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="ggmfit_+3A_details">details</code></td>
<td>
<p>Controlling the amount of output.</p>
</td></tr>
<tr><td><code id="ggmfit_+3A_...">...</code></td>
<td>
<p>Optional arguments; currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggmfit</code> is based on a C implementation.  <code>ggmfitr</code> is
implemented purely in R (and is provided mainly as a benchmark for the
C-version).
</p>


<h3>Value</h3>

<p>A list with </p>
<table>
<tr><td><code>lrt</code></td>
<td>
<p>Likelihood ratio statistic (-2logL)</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom</p>
</td></tr> <tr><td><code>logL</code></td>
<td>
<p>log likelihood</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Estimated concentration matrix (inverse covariance matrix)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmod">cmod</a></code>, <code><a href="stats.html#topic+loglin">loglin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Fitting "butterfly model" to mathmark data
## Notice that the output from the two fitting functions is not
## entirely identical.
data(math)
ddd &lt;- cov.wt(math, method="ML")
glist &lt;- list(c("al", "st", "an"), c("me", "ve", "al"))
ggmfit (ddd$cov, ddd$n.obs, glist)
ggmfitr(ddd$cov, ddd$n.obs, glist)

</code></pre>

<hr>
<h2 id='imodel-dmod'>Discrete interaction model (log-linear model)</h2><span id='topic+imodel-dmod'></span><span id='topic+dmod'></span><span id='topic+print.dModel'></span><span id='topic+fitted.dModel'></span><span id='topic+residuals.dModel'></span><span id='topic+triangulate.dModel'></span>

<h3>Description</h3>

<p>Specification of log&ndash;linear (graphical) model. The
'd' in the name <code>dmod</code> refers to that it is a (graphical)
model for 'd'iscrete variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmod(
  formula,
  data,
  marginal = NULL,
  interactions = NULL,
  fit = TRUE,
  details = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imodel-dmod_+3A_formula">formula</code></td>
<td>
<p>Model specification in one of the following forms: 1) a
right-hand sided formula, 2) as a list of generators, 3) an undirected
graph (represented either as an igraph object or as an adjacency
matrix).  Notice that there are certain model specification shortcuts,
see Section 'details' below.</p>
</td></tr>
<tr><td><code id="imodel-dmod_+3A_data">data</code></td>
<td>
<p>Either a table or a dataframe. In the latter case, the dataframe
will be coerced to a table. See 'details' below.</p>
</td></tr>
<tr><td><code id="imodel-dmod_+3A_marginal">marginal</code></td>
<td>
<p>Should only a subset of the variables be used in connection
with the model specification shortcuts</p>
</td></tr>
<tr><td><code id="imodel-dmod_+3A_interactions">interactions</code></td>
<td>
<p>A number given the highest order interactions in the
model, see Section 'details' below.</p>
</td></tr>
<tr><td><code id="imodel-dmod_+3A_fit">fit</code></td>
<td>
<p>Should the model be fitted.</p>
</td></tr>
<tr><td><code id="imodel-dmod_+3A_details">details</code></td>
<td>
<p>Control the amount of output; for debugging purposes.</p>
</td></tr>
<tr><td><code id="imodel-dmod_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently no used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The independence model can be specified as <code>~.^1</code> and
<code>~.^.</code> specifies the saturated model.  Setting
e.g. <code>interactions=3</code> implies that there will be at most
three factor interactions in the model.
</p>
<p>Data can be specified as a table of counts or as a dataframe. If
data is a dataframe then it will be converted to a table (using
<code>xtabs()</code>). This means that if the dataframe contains numeric
values then the you can get a very sparse and high dimensional
table. When a dataframe contains numeric values it may be
worthwhile to discretize data using the <code>cut()</code> function.
</p>
<p>The <code>marginal</code> argument can be used for specifying the
independence or saturated models for only a subset of the
variables. When <code>marginal</code> is given the corresponding marginal
table of data is formed and used in the analysis (notice that this
is different from the behaviour of <code>loglin()</code> which uses the
full table.
</p>
<p>The <code>triangulate()</code> method for discrete models (dModel
objects) will for a model look at the dependence graph for the
model.
</p>


<h3>Value</h3>

<p>An object of class <code>dModel</code>.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmod">cmod</a></code>, <code><a href="#topic+mmod">mmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Graphical log-linear model
data(reinis)
dm1 &lt;- dmod(~ .^., reinis)
dm2 &lt;- backward(dm1, k=2)
dm3 &lt;- backward(dm1, k=2, fixin=list(c("family", "phys", "systol")))
## At most 3-factor interactions
dm1&lt;-dmod(~ .^., data=reinis, interactions=3)
</code></pre>

<hr>
<h2 id='imodel-general'>General functions related to iModels</h2><span id='topic+imodel-general'></span><span id='topic+logLik.iModel'></span><span id='topic+extractAIC.iModel'></span><span id='topic+summary.iModel'></span><span id='topic+print.iModelsummary'></span><span id='topic+formula.iModel'></span><span id='topic+terms.iModel'></span><span id='topic+isGraphical.dModel'></span><span id='topic+isDecomposable.dModel'></span><span id='topic+modelProperties'></span><span id='topic+modelProperties.dModel'></span>

<h3>Description</h3>

<p>General functions related to iModels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iModel'
logLik(object, ...)

## S3 method for class 'iModel'
extractAIC(fit, scale, k = 2, ...)

## S3 method for class 'iModel'
summary(object, ...)

## S3 method for class 'iModelsummary'
print(x, ...)

## S3 method for class 'iModel'
formula(x, ...)

## S3 method for class 'iModel'
terms(x, ...)

## S3 method for class 'dModel'
isGraphical(x)

## S3 method for class 'dModel'
isDecomposable(x)

modelProperties(object)

## S3 method for class 'dModel'
modelProperties(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imodel-general_+3A_object">object</code>, <code id="imodel-general_+3A_fit">fit</code>, <code id="imodel-general_+3A_x">x</code></td>
<td>
<p>An <code>iModel</code> object.</p>
</td></tr>
<tr><td><code id="imodel-general_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="imodel-general_+3A_scale">scale</code></td>
<td>
<p>Unused (and irrelevant for these models)</p>
</td></tr>
<tr><td><code id="imodel-general_+3A_k">k</code></td>
<td>
<p>Weight of the degrees of freedom in the AIC formula</p>
</td></tr>
</table>

<hr>
<h2 id='imodel-info'>Get information about mixed interaction model objects</h2><span id='topic+imodel-info'></span><span id='topic+getmi'></span>

<h3>Description</h3>

<p>General functions related to iModels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getmi(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imodel-info_+3A_object">object</code></td>
<td>
<p>An <code>iModel</code> object.</p>
</td></tr>
<tr><td><code id="imodel-info_+3A_name">name</code></td>
<td>
<p>The slot / information to be extracted.</p>
</td></tr>
</table>

<hr>
<h2 id='imodel-mmod'>Mixed interaction model.</h2><span id='topic+imodel-mmod'></span><span id='topic+mmod'></span><span id='topic+coef.mModel'></span><span id='topic+coefficients.mModel'></span><span id='topic+print.mModel'></span><span id='topic+summary.mModel'></span><span id='topic+mmod_dimension'></span>

<h3>Description</h3>

<p>A mixed interaction model is a model (often with conditional
independence restrictions) for a combination of discrete and continuous
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmod(formula, data, marginal = NULL, fit = TRUE, details = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imodel-mmod_+3A_formula">formula</code></td>
<td>
<p>A right hand sided formula specifying the model.</p>
</td></tr>
<tr><td><code id="imodel-mmod_+3A_data">data</code></td>
<td>
<p>Data (a dataframe)</p>
</td></tr>
<tr><td><code id="imodel-mmod_+3A_marginal">marginal</code></td>
<td>
<p>A possible subsets of columns of <code>data</code>; useful when
<code>formula</code> contains model specification shortcuts.</p>
</td></tr>
<tr><td><code id="imodel-mmod_+3A_fit">fit</code></td>
<td>
<p>Currently not used</p>
</td></tr>
<tr><td><code id="imodel-mmod_+3A_details">details</code></td>
<td>
<p>For printing debugging information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mModel</code> and the more general class
<code>iModel</code>.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmod">dmod</a></code>, <code><a href="#topic+cmod">cmod</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### FIXME: To be written
</code></pre>

<hr>
<h2 id='internal'>Internal functions for the gRim package</h2><span id='topic+internal'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Internal functions for the gRim package
</p>

<hr>
<h2 id='loglin-dim'>Return the dimension of a log-linear model</h2><span id='topic+loglin-dim'></span><span id='topic+dim_loglin'></span><span id='topic+dim_loglin_decomp'></span>

<h3>Description</h3>

<p>Return the dimension of a log-linear model given by
the generating class 'glist'. If the model is decomposable and
adjusted dimension can be found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim_loglin(glist, tableinfo)

dim_loglin_decomp(glist, tableinfo, adjust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglin-dim_+3A_glist">glist</code></td>
<td>
<p>Generating class (a list) for a log-linear model. See
'details' below.</p>
</td></tr>
<tr><td><code id="loglin-dim_+3A_tableinfo">tableinfo</code></td>
<td>
<p>Specification of the levels of the variables. See
'details' below.</p>
</td></tr>
<tr><td><code id="loglin-dim_+3A_adjust">adjust</code></td>
<td>
<p>Should model dimension be adjusted for sparsity of
data (only available for decomposable models)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>glist</code> can be either a list of vectors with variable names or a list
of vectors of variable indices.
</p>
<p><code>tableinfo</code> can be one of three different things.
</p>

<ol>
<li><p> A contingency table (a <code>table</code>).
</p>
</li>
<li><p> A list with the names of the variables and their levels (such as one
would get if calling <code>dimnames</code> on a <code>table</code>).
</p>
</li>
<li><p> A vector with the levels. If <code>glist</code> is a list of vectors with
variable names, then the entries of the vector <code>tableinfo</code> must be
named.
</p>
</li></ol>

<p>If the model is decomposable it <code>dim_loglin_decomp</code> is to be preferred over
<code>dim_loglin</code> as the former is much faster.
</p>
<p>Setting <code>adjust=TRUE</code> will force <code>dim_loglin_decomp</code> to calculated a
dimension which is adjusted for sparsity of data. For this to work,
<code>tableinfo</code> <em>MUST</em> be a table.
</p>


<h3>Value</h3>

<p>A numeric.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmod">dmod</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="MASS.html#topic+loglm">loglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## glist contains variable names and tableinfo is a named vector:
dim_loglin(list(c("a", "b"), c("b", "c")), c(a=4, b=7, c=6))

## glist contains variable names and tableinfo is not named:
dim_loglin(list(c(1, 2), c(2, 3)), c(4, 7, 6))

## For decomposable models:
dim_loglin_decomp(list(c("a", "b"), c("b", "c")), c(a=4, b=7, c=6),adjust=FALSE)

</code></pre>

<hr>
<h2 id='loglin-effloglin'>Fitting Log-Linear Models by Message Passing</h2><span id='topic+loglin-effloglin'></span><span id='topic+effloglin'></span>

<h3>Description</h3>

<p>Fit log-linear models to multidimensional contingency
tables by Iterative Proportional Fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effloglin(table, margin, fit = FALSE, eps = 0.01, iter = 20, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglin-effloglin_+3A_table">table</code></td>
<td>
<p>A contingency table</p>
</td></tr>
<tr><td><code id="loglin-effloglin_+3A_margin">margin</code></td>
<td>
<p>A generating class for a hierarchical log&ndash;linear model</p>
</td></tr>
<tr><td><code id="loglin-effloglin_+3A_fit">fit</code></td>
<td>
<p>If TRUE, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="loglin-effloglin_+3A_eps">eps</code></td>
<td>
<p>Convergence limit; see 'details' below.</p>
</td></tr>
<tr><td><code id="loglin-effloglin_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations allowed</p>
</td></tr>
<tr><td><code id="loglin-effloglin_+3A_print">print</code></td>
<td>
<p>If TRUE, iteration details are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function differs from <code>loglin</code> in that 1) data
can be given in the form of a list of sufficient marginals and
2) the model is fitted only on the cliques of the triangulated
interaction graph of the model. This means that the full table
is not fitted, which means that <code>effloglin</code> is efficient
(in terms of storage requirements). However <code>effloglin</code> is
implemented entirely in R and is therefore slower than
<code>loglin</code>. Argument names are chosen so as to match those
of loglin()
</p>


<h3>Value</h3>

<p>A list.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Radim Jirousek and Stanislav Preucil (1995). On the
effective implementation of the iterative proportional fitting
procedure. Computational Statistics &amp; Data Analysis Volume 19,
Issue 2, February 1995, Pages 177-189
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+loglin">loglin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(reinis)
glist &lt;-list(c("smoke", "mental"), c("mental", "phys"),
             c("phys", "systol"), c("systol", "smoke"))

stab &lt;- lapply(glist, function(gg) tabMarg(reinis, gg))
fv3 &lt;- effloglin(stab, glist, print=FALSE)


</code></pre>

<hr>
<h2 id='modify_glist'>Modify generating class for a graphical/hierarchical model</h2><span id='topic+modify_glist'></span>

<h3>Description</h3>

<p>Modify generating class for a graphical/hierarchical model by 1)
adding edges, 2) deleting edges, 3) adding terms and 4) deleting terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_glist(glist, items, details = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_glist_+3A_glist">glist</code></td>
<td>
<p>A list of vectors where each vector is a generator of the model.</p>
</td></tr>
<tr><td><code id="modify_glist_+3A_items">items</code></td>
<td>
<p>A list with edges / terms to be added and deleted. See section
'details' below.</p>
</td></tr>
<tr><td><code id="modify_glist_+3A_details">details</code></td>
<td>
<p>Control the amount of output (for debugging purposes).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>items</code> is a list with named entries as <code>list(add.edge=,
drop.edge=, add.term=, drop.term=)</code>
</p>
<p>Not all entries need to be in the list. The corresponding actions are
carried out in the order in which they appear in the list.
</p>
<p>See section 'examples' below for examples.
</p>
<p>Notice that the operations do not in general commute: Adding an edge which
is already in a generating class and then removing the edge again does not
give the original generating class.
</p>


<h3>Value</h3>

<p>A generating class for the modified model. The elements of the list
are character vectors.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmod">cmod</a></code>, <code><a href="#topic+dmod">dmod</a></code>, <code><a href="#topic+mmod">mmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
glist &lt;- list(c(1, 2, 3), c(2, 3, 4))

## Add edges
modify_glist(glist, items=list(add.edge=c(1, 4)))
modify_glist(glist, items=list(add.edge=~1:4))

## Add terms
modify_glist(glist, items=list(add.term=c(1, 4)))
modify_glist(glist, items=list(add.term=~1:4))

## Notice: Only the first term is added as the second is already 
## in the model.
modify_glist(glist, items=list(add.term=list(c(1, 4), c(1, 3))))
modify_glist(glist, items=list(add.term=~1:4 + 1:3))

## Notice: Operations are carried out in the order given in the
## items list and hence we get different results: 
modify_glist(glist, items=list(drop.edge=c(1, 4), add.edge=c(1, 4)))
modify_glist(glist, items=list(add.edge=c(1, 4), drop.edge=c(1, 4)))

</code></pre>

<hr>
<h2 id='parm-conversion'>Conversion between different parametrizations of mixed models</h2><span id='topic+parm-conversion'></span><span id='topic+parm_pms2ghk'></span><span id='topic+parm_ghk2pms'></span><span id='topic+parm_pms2phk'></span><span id='topic+parm_phk2ghk'></span><span id='topic+parm_phk2pms'></span><span id='topic+parm_ghk2phk'></span><span id='topic+parm_CGstats2mmod'></span><span id='topic+parm_moment2pms'></span>

<h3>Description</h3>

<p>Functions to convert between canonical parametrization
(g,h,K), moment parametrization (p,m,S) and mixed
parametrization (p,h,K).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parm_pms2ghk(parms)

parm_ghk2pms(parms)

parm_pms2phk(parms)

parm_phk2ghk(parms)

parm_phk2pms(parms)

parm_ghk2phk(parms)

parm_CGstats2mmod(parms, type = "ghk")

parm_moment2pms(SS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parm-conversion_+3A_parms">parms</code></td>
<td>
<p>Parameters of a mixed interaction model</p>
</td></tr>
<tr><td><code id="parm-conversion_+3A_type">type</code></td>
<td>
<p>Output parameter type; either &quot;ghk&quot; or &quot;pms&quot;.</p>
</td></tr>
<tr><td><code id="parm-conversion_+3A_ss">SS</code></td>
<td>
<p>List of moment parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameters of a mixed interaction model.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>

<hr>
<h2 id='parse_gm_formula'>Parse graphical model formula</h2><span id='topic+parse_gm_formula'></span>

<h3>Description</h3>

<p>Parse graphical model formula to internal representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_gm_formula(
  formula,
  varnames = NULL,
  marginal = NULL,
  interactions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_gm_formula_+3A_formula">formula</code></td>
<td>
<p>A right hand sided formula or a list.</p>
</td></tr>
<tr><td><code id="parse_gm_formula_+3A_varnames">varnames</code></td>
<td>
<p>Specification of the variables.</p>
</td></tr>
<tr><td><code id="parse_gm_formula_+3A_marginal">marginal</code></td>
<td>
<p>Possible specification of marginal (a set of
variables); useful in connection with model specification
shortcuts.</p>
</td></tr>
<tr><td><code id="parse_gm_formula_+3A_interactions">interactions</code></td>
<td>
<p>The maximum order of interactions allowed;
useful in connection with model specification shortcuts.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vn &lt;- c("me", "ve", "al", "an", "st")

form1 &lt;- ~me:ve:al + ve:al + an
form2 &lt;- ~me:ve:al + ve:al + s
form3 &lt;- ~me:ve:al + ve:al + anaba
parse_gm_formula(form1, varnames=vn)
parse_gm_formula(form2, varnames=vn)
## parse_gm_formula(form3, varnames=vn)
parse_gm_formula(form1)
parse_gm_formula(form2)
parse_gm_formula(form3)

## parse_gm_formula(~.^1)
## parse_gm_formula(~.^.)

parse_gm_formula(~.^1, varnames=vn)
parse_gm_formula(~.^., varnames=vn)
parse_gm_formula(~.^., varnames=vn, interactions=3)

vn2 &lt;- vn[1:3]
## parse_gm_formula(form1, varnames=vn, marginal=vn2)
## parse_gm_formula(form2, varnames=vn, marginal=vn2)
## parse_gm_formula(form3, varnames=vn, marginal=vn2)
parse_gm_formula(~.^1, varnames=vn, marginal=vn2)
parse_gm_formula(~.^., varnames=vn, marginal=vn2)

</code></pre>

<hr>
<h2 id='stepwise'>Stepwise model selection in (graphical) interaction models</h2><span id='topic+stepwise'></span><span id='topic+drop_func'></span><span id='topic+stepwise.iModel'></span><span id='topic+backward'></span><span id='topic+forward'></span>

<h3>Description</h3>

<p>Stepwise model selection in (graphical) interaction
models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_func(criterion)

## S3 method for class 'iModel'
stepwise(
  object,
  criterion = "aic",
  alpha = NULL,
  type = "decomposable",
  search = "all",
  steps = 1000,
  k = 2,
  direction = "backward",
  fixin = NULL,
  fixout = NULL,
  details = 0,
  trace = 2,
  ...
)

backward(
  object,
  criterion = "aic",
  alpha = NULL,
  type = "decomposable",
  search = "all",
  steps = 1000,
  k = 2,
  fixin = NULL,
  details = 1,
  trace = 2,
  ...
)

forward(
  object,
  criterion = "aic",
  alpha = NULL,
  type = "decomposable",
  search = "all",
  steps = 1000,
  k = 2,
  fixout = NULL,
  details = 1,
  trace = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise_+3A_criterion">criterion</code></td>
<td>
<p>Either <code>"aic"</code> or <code>"test"</code> (for significance test)</p>
</td></tr>
<tr><td><code id="stepwise_+3A_object">object</code></td>
<td>
<p>An <code>iModel</code> model object</p>
</td></tr>
<tr><td><code id="stepwise_+3A_alpha">alpha</code></td>
<td>
<p>Critical value for deeming an edge to be significant/
insignificant. When <code>criterion="aic"</code>, <code>alpha</code> defaults to 0;
when <code>criterion="test"</code>, <code>alpha</code> defaults to 0.05.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_type">type</code></td>
<td>
<p>Type of models to search. Either <code>"decomposable"</code> or
<code>"unrestricted"</code>. If <code>type="decomposable"</code> and the initial
model is decompsable, then the search is among decomposable models only.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_search">search</code></td>
<td>
<p>Either <code>'all'</code> (greedy) or <code>'headlong'</code> (search edges
randomly; stop when an improvement has been found).</p>
</td></tr>
<tr><td><code id="stepwise_+3A_steps">steps</code></td>
<td>
<p>Maximum number of steps.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_k">k</code></td>
<td>
<p>Penalty term when <code>criterion="aic"</code>. Only k=2 gives genuine
AIC.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_direction">direction</code></td>
<td>
<p>Direction for model search. Either <code>"backward"</code> or
<code>"forward"</code>.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_fixin">fixin</code></td>
<td>
<p>Matrix (p x 2) of edges. If those edges are in the model,
they are not considered for removal.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_fixout">fixout</code></td>
<td>
<p>Matrix (p x 2) of edges. If those edges are not in the model,
they are not considered for addition.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_details">details</code></td>
<td>
<p>Controls the level of printing on the screen.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_trace">trace</code></td>
<td>
<p>For debugging only</p>
</td></tr>
<tr><td><code id="stepwise_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to <code>testdelete</code> (for
<code>testInEdges</code>) and <code>testadd</code> (for <code>testOutEdges</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmod">cmod</a></code>, <code><a href="#topic+dmod">dmod</a></code>, <code><a href="#topic+mmod">mmod</a></code>,
<code><a href="#topic+testInEdges">testInEdges</a></code>, <code><a href="#topic+testOutEdges">testOutEdges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(reinis)
## The saturated model
m1 &lt;- dmod(~.^., data=reinis)
m2 &lt;- stepwise(m1)
m2
</code></pre>

<hr>
<h2 id='test-edges'>Test edges in graphical models with p-value/AIC value</h2><span id='topic+test-edges'></span><span id='topic+testEdges'></span><span id='topic+testInEdges'></span><span id='topic+testOutEdges'></span>

<h3>Description</h3>

<p>Test edges in graphical models with p-value/AIC
value. The models must be <code>iModel</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testEdges(
  object,
  edgeMAT = NULL,
  ingraph = TRUE,
  criterion = "aic",
  k = 2,
  alpha = NULL,
  headlong = FALSE,
  details = 1,
  ...
)

testInEdges(
  object,
  edgeMAT = NULL,
  criterion = "aic",
  k = 2,
  alpha = NULL,
  headlong = FALSE,
  details = 1,
  ...
)

testOutEdges(
  object,
  edgeMAT = NULL,
  criterion = "aic",
  k = 2,
  alpha = NULL,
  headlong = FALSE,
  details = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test-edges_+3A_object">object</code></td>
<td>
<p>An <code>iModel</code> model object</p>
</td></tr>
<tr><td><code id="test-edges_+3A_edgemat">edgeMAT</code></td>
<td>
<p>A <code>p * 2</code> matrix with edges</p>
</td></tr>
<tr><td><code id="test-edges_+3A_ingraph">ingraph</code></td>
<td>
<p>If TRUE, edges in graph are tested; if FALSE, edges
not in graph are tested.</p>
</td></tr>
<tr><td><code id="test-edges_+3A_criterion">criterion</code></td>
<td>
<p>Either <code>"aic"</code> or <code>"test"</code> (for
significance test)</p>
</td></tr>
<tr><td><code id="test-edges_+3A_k">k</code></td>
<td>
<p>Penalty term when <code>criterion="aic"</code>. Only k=2 gives
genuine AIC.</p>
</td></tr>
<tr><td><code id="test-edges_+3A_alpha">alpha</code></td>
<td>
<p>Critical value for deeming an edge to be significant/
insignificant. When <code>criterion="aic"</code>, <code>alpha</code>
defaults to 0; when <code>criterion="test"</code>, <code>alpha</code>
defaults to 0.05.</p>
</td></tr>
<tr><td><code id="test-edges_+3A_headlong">headlong</code></td>
<td>
<p>If TRUE then testing will stop once a model
improvement has been found.</p>
</td></tr>
<tr><td><code id="test-edges_+3A_details">details</code></td>
<td>
<p>Controls the level of printing on the screen.</p>
</td></tr>
<tr><td><code id="test-edges_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to <code>testdelete</code>
(for <code>testInEdges</code>) and <code>testadd</code> (for
<code>testOutEdges</code>).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> testIn: Function which tests whether each edge in &quot;edgeList&quot; can
be delete from model &quot;object&quot;
</p>
</li>
<li><p> testOut: Is similar but in the other direction.
</p>
</li></ul>



<h3>Value</h3>

<p>A dataframe with test statistics (p-value or change in
AIC), edges and logical telling if the edge can be deleted.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getEdges">getEdges</a></code>, <code><a href="#topic+testadd">testadd</a></code>,
<code><a href="#topic+testdelete">testdelete</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(math)
cm1 &lt;- cmod(~me:ve + ve:al + al:an, data=math)
testEdges(cm1, ingraph=TRUE)
testEdges(cm1, ingraph=FALSE)
## Same as
# testInEdges(cm1)
# testOutEdges(cm) 
</code></pre>

<hr>
<h2 id='testadd'>Test addition of edge to graphical model</h2><span id='topic+testadd'></span><span id='topic+testadd.iModel'></span><span id='topic+print.testadd'></span><span id='topic+testadd.mModel'></span>

<h3>Description</h3>

<p>Performs a test of addition of an edge to a graphical
model (an <code>iModel</code> object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testadd(object, edge, k = 2, details = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testadd_+3A_object">object</code></td>
<td>
<p>A model; an object of class <code>iModel</code>.</p>
</td></tr>
<tr><td><code id="testadd_+3A_edge">edge</code></td>
<td>
<p>An edge; either as a vector or as a right hand sided
formula.</p>
</td></tr>
<tr><td><code id="testadd_+3A_k">k</code></td>
<td>
<p>Penalty parameter used when calculating change in AIC</p>
</td></tr>
<tr><td><code id="testadd_+3A_details">details</code></td>
<td>
<p>The amount of details to be printed; 0 surpresses
all information</p>
</td></tr>
<tr><td><code id="testadd_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to the underlying
functions for testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let M0 be the model and e=u,v be an edge and let M1 be
the model obtained by adding e to M0. If M1 is decomposable AND
e is contained in one clique C only of M1 then the test is
carried out in the C-marginal model. In this case, and if the
model is a log-linear model then the degrees of freedom is
adjusted for sparsity.
</p>


<h3>Value</h3>

<p>A list
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testdelete">testdelete</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Discrete models
data(reinis)

## A decomposable model
mf &lt;- ~smoke:phys:mental + smoke:systol:mental
object &lt;- dmod(mf, data=reinis)
testadd(object, c("systol", "phys"))

## A non-decomposable model
mf &lt;- ~smoke:phys + phys:mental + smoke:systol + systol:mental
object &lt;- dmod(mf, data=reinis)
testadd(object, c("phys", "systol"))

## Continuous models
data(math)

## A decomposable model
mf &lt;- ~me:ve:al + al:an
object &lt;- cmod(mf, data=math)
testadd(object, c("me", "an"))

## A non-decomposable model
mf &lt;- ~me:ve + ve:al + al:an + an:me
object &lt;- cmod(mf, data=math)
testadd(object, c("me", "al"))
</code></pre>

<hr>
<h2 id='testdelete'>Test deletion of edge from an interaction model</h2><span id='topic+testdelete'></span><span id='topic+testdelete.iModel'></span><span id='topic+print.testdelete'></span><span id='topic+testdelete.mModel'></span>

<h3>Description</h3>

<p>Tests if an edge can be deleted from an interaction
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testdelete(object, edge, k = 2, details = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testdelete_+3A_object">object</code></td>
<td>
<p>A model; an object of class <code>iModel</code>.</p>
</td></tr>
<tr><td><code id="testdelete_+3A_edge">edge</code></td>
<td>
<p>An edge in the model; either as a right-hand sided
formula or as a vector</p>
</td></tr>
<tr><td><code id="testdelete_+3A_k">k</code></td>
<td>
<p>Penalty parameter used when calculating change in AIC</p>
</td></tr>
<tr><td><code id="testdelete_+3A_details">details</code></td>
<td>
<p>The amount of details to be printed; 0 surpresses
all information</p>
</td></tr>
<tr><td><code id="testdelete_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to the underlying
functions for testing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model is decomposable and the edge is contained in
one clique only then the test is made in the marginal model
given by that clique. In that case, if the model is a
log-linear model then degrees of freedom are adjusted for
sparsity
</p>
<p>If model is decomposable and edge is in one clique only,
then degrees of freedom are adjusted for sparsity
</p>


<h3>Value</h3>

<p>A list.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testadd">testadd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Discrete models
data(reinis)

## A decomposable model
mf &lt;- ~smoke:phys:mental + smoke:systol:mental
object &lt;- dmod(mf, data=reinis)
testdelete(object, c("phys", "mental"))
testdelete(object, c("smoke", "mental"))

## A non-decomposable model
mf &lt;- ~smoke:phys + phys:mental + smoke:systol + systol:mental
object &lt;- dmod(mf, data=reinis)

testdelete(object, c("phys", "mental"))

## Continuous models
data(math)

## A decomposable model
mf &lt;- ~me:ve:al + me:al:an
object &lt;- cmod(mf, data=math)
testdelete(object, c("ve", "al"))
testdelete(object, c("me", "al"))

## A non-decomposable model
mf &lt;- ~me:ve + ve:al + al:an + an:me
object &lt;- cmod(mf, data=math)
testdelete(object, c("me", "ve"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
