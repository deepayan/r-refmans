<!DOCTYPE html><html><head><title>Help for package dsfa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dsfa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BurkinaFarms'><p>BurkinaFarms</p></a></li>
<li><a href='#BurkinaFarms_polys'><p>BurkinaFarms_polys</p></a></li>
<li><a href='#cdf2quantile'><p>Inverse cumulative distribution function</p></a></li>
<li><a href='#chainrule'><p>Chainrule</p></a></li>
<li><a href='#comper'><p>comper</p></a></li>
<li><a href='#comper_mv'><p>comper</p></a></li>
<li><a href='#cop'><p>cop</p></a></li>
<li><a href='#dcomper'><p>Composed-Error distribution</p></a></li>
<li><a href='#dcomper_mv'><p>Multivariate Composed-Error distribution</p></a></li>
<li><a href='#dcop'><p>Copula function</p></a></li>
<li><a href='#delta_bounds'><p>Bounds of Copula Parameter delta</p></a></li>
<li><a href='#derivs_transform'><p>derivs_transform</p></a></li>
<li><a href='#differencerule'><p>Differencerule</p></a></li>
<li><a href='#dnormexp'><p>Normal-Exponential distribution</p></a></li>
<li><a href='#dnormhnorm'><p>Normal-halfnormal distribution</p></a></li>
<li><a href='#dsfa'><p>dsfa-package: Distributional Stochastic Frontier Analysis</p></a></li>
<li><a href='#efficiency'><p>efficiency</p></a></li>
<li><a href='#elasticity'><p>elasticity</p></a></li>
<li><a href='#ind2joint'><p>Independent to joint function</p></a></li>
<li><a href='#list2derivs'><p>list2derivs</p></a></li>
<li><a href='#manuf'><p>NBER-CES Manufacturing Dairy Data</p></a></li>
<li><a href='#mom2par'><p>Moments to Parameters</p></a></li>
<li><a href='#par2mom'><p>Parameter to Moments</p></a></li>
<li><a href='#productrule'><p>Productrule</p></a></li>
<li><a href='#quotientrule'><p>Quotientrule</p></a></li>
<li><a href='#sumrule'><p>Sumrule</p></a></li>
<li><a href='#transform'><p>transform</p></a></li>
<li><a href='#trind'><p>trind function</p></a></li>
<li><a href='#trind_generator'><p>Trind_generator function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Distributional Stochastic Frontier Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Framework to fit distributional stochastic frontier models. Casts the stochastic frontier model into the flexible framework of distributional regression or otherwise known as General Additive Models of Location, Scale and Shape (GAMLSS). Allows for linear, non-linear, random and spatial effects on all the parameters of the distribution of the output, e.g. effects on the production or cost function, heterogeneity of the noise and inefficiency. Available distributions are the normal-halfnormal and normal-exponential distribution. Estimation via the fast and reliable routines of the 'mgcv' package. For more details see &lt;<a href="https://doi.org/10.1016%2Fj.csda.2023.107796">doi:10.1016/j.csda.2023.107796</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv, stats, Rdpack, Rcpp, RcppArmadillo, copula, gratia</td>
</tr>
<tr>
<td>Suggests:</td>
<td>plm, sfaR</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-19 14:58:34 UTC; Rouven</td>
</tr>
<tr>
<td>Author:</td>
<td>Rouven Schmidt [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rouven Schmidt &lt;rouven.schmidt@tu-clausthal.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-19 21:40:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='BurkinaFarms'>BurkinaFarms</h2><span id='topic+BurkinaFarms'></span>

<h3>Description</h3>

<p>Dataset of the Center for Environmental Economics and Policy in Africa (CEEPA), University of Pretoria. It contains information on the production of millet and sorghum in Burkina Faso.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BurkinaFarms
</code></pre>


<h3>Format</h3>

<p>BurkinaFarms is a data frame with 560 rows and 20 columns:
</p>

<dl>
<dt>hhcode</dt><dd><p>Respondent Householdsâ€™ identification number</p>
</dd>
<dt>farmtype</dt><dd><p>Type of Farm Entity: <br />
'1' = small-scale<br />
'2' = medium-scale<br />
'3' = large-scale<br />
</p>
</dd>
<dt>incfarm</dt><dd><p>Income of farmers</p>
</dd>
<dt>educ1</dt><dd><p>education of household head in number of years</p>
</dd>
<dt>adm1</dt><dd><p>Province/Region</p>
</dd>
<dt>material</dt><dd><p>Light and heavy machinery as well as farm animal power multiplied with their price</p>
</dd>
<dt>qharv_millet</dt><dd><p>Quantity of millet harvested in kg</p>
</dd>
<dt>lost_millet</dt><dd><p>Quantity of millet lost due to disease and pests in kg</p>
</dd>
<dt>seed_millet</dt><dd><p>Amount of seeds used for the production of millet in kg</p>
</dd>
<dt>land_millet</dt><dd><p>Amount of land used for the production of millet in ha</p>
</dd>
<dt>labour_millet</dt><dd><p>Total estimated number of workdays for the production of millet. One day corresponds to 6-8 hours of work completed by one individual. Household labor and hired labor are accumulated</p>
</dd>
<dt>fert_millet</dt><dd><p>Amount of fertilizer used for the production of millet in kg</p>
</dd>
<dt>pest_millet</dt><dd><p>Amount of pesticides used for the production of millet in kg</p>
</dd>
<dt>qharv_sorghum</dt><dd><p>Quantity of sorghum harvested in kg</p>
</dd>
<dt>lost_sorghum</dt><dd><p>Quantity of sorghum lost due to disease and pests in kg</p>
</dd>
<dt>seed_sorghum</dt><dd><p>Amount of seeds used for the production of sorghum in kg</p>
</dd>
<dt>land_sorghum</dt><dd><p>Amount of land used for the production of sorghum in ha</p>
</dd>
<dt>labour_sorghum</dt><dd><p>Total estimated number of workdays for the production of sorghum. One day corresponds to 6-8 hours of work completed by one individual. Household labor and hired labor are accumulated</p>
</dd>
<dt>fert_sorghum</dt><dd><p>Amount of fertilizer used for the production of sorghum in kg</p>
</dd>
<dt>pest_sorghum</dt><dd><p>Amount of pesticides used for the production of sorghum in kg</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a subset of the data which contains data only from Burkina Faso for the outputs sorghum and millet.
</p>


<h3>Source</h3>

<p>&lt;https://figshare.com/collections/An_agricultural_survey_for_more_than_9_500_African_households/1574094&gt;
</p>


<h3>References</h3>

<p>Waha K, Zipf B, Kurukulasuriya P, Hassan RM (2016).
&ldquo;An agricultural survey for more than 9,500 African households.&rdquo;
<em>Scientific data</em>, <b>3</b>(1), 1&ndash;8.
</p>

<hr>
<h2 id='BurkinaFarms_polys'>BurkinaFarms_polys</h2><span id='topic+BurkinaFarms_polys'></span>

<h3>Description</h3>

<p>Dataset of Burkina Faso - Subnational Administrative Boundaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BurkinaFarms_polys
</code></pre>


<h3>Format</h3>

<p>This file contains the polygons of the regions of Burkina Faso.
</p>


<h3>Source</h3>

<p>&lt;https://data.humdata.org/dataset/burkina-faso-administrative-boundaries&gt;
</p>

<hr>
<h2 id='cdf2quantile'>Inverse cumulative distribution function</h2><span id='topic+cdf2quantile'></span>

<h3>Description</h3>

<p>Inverse cumulative distribution function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdf2quantile(p, cdf, interval = c(-3, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf2quantile_+3A_p">p</code></td>
<td>
<p>numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="cdf2quantile_+3A_cdf">cdf</code></td>
<td>
<p>function, cumulative distribution function which to invert.</p>
</td></tr>
<tr><td><code id="cdf2quantile_+3A_interval">interval</code></td>
<td>
<p>numeric vector of length 2, determining the lower and upper bound of the uniroot interval</p>
</td></tr>
<tr><td><code id="cdf2quantile_+3A_...">...</code></td>
<td>
<p>other arguments for the cdf, e.g. mu, sigma_v, sigma_u, s...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Code is a clone from the package <span class="pkg">gbutils</span>.
</p>


<h3>Value</h3>

<p>Numeric vector of <code>p</code> evaluated in the inverse cdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q=5
cdf &lt;- pnorm(q=q, mean=1, sd=2)
q_numeric &lt;- cdf2quantile(p=cdf, cdf=pnorm, mean=1, sd=2)
all.equal(q,q_numeric)

</code></pre>

<hr>
<h2 id='chainrule'>Chainrule</h2><span id='topic+chainrule'></span>

<h3>Description</h3>

<p>Chainrule for derivs objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chainrule(f_list, tri, deriv_order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chainrule_+3A_f_list">f_list</code></td>
<td>
<p>list of <code>derivs</code> objects of length <code class="reqn">M</code>, e.g. <code class="reqn">list(f_1(\cdot), f_2(\cdot),...,f_M(\cdot))</code></p>
</td></tr>
<tr><td><code id="chainrule_+3A_tri">tri</code></td>
<td>
<p>list; created by the function [trind_generator()].</p>
</td></tr>
<tr><td><code id="chainrule_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">f_m</code> be a function defined in [trind()], where <code class="reqn">m \in {1,...,M}</code>.
Define <code class="reqn">h((x_{n1},x_{n2},...,x_{nK})) = f_1(\cdot) \circ f_2(\cdot) ... \circ f_M(x_{n1},x_{n2},...,x_{nK}))</code>.
In order to get the derivatives of <code class="reqn">h(\cdot)</code> w.r.t all parameters <code class="reqn">x_{nk}</code>, the chainrule is applied.
For more details see [trind()] and [trind_generator()].
</p>


<h3>Value</h3>

<p>Returns an object of class <code>derivs</code> for the function <code class="reqn">h(\cdot)</code>.
</p>


<h3>See Also</h3>

<p>Other derivs: 
<code><a href="#topic+derivs_transform">derivs_transform</a>()</code>,
<code><a href="#topic+differencerule">differencerule</a>()</code>,
<code><a href="#topic+ind2joint">ind2joint</a>()</code>,
<code><a href="#topic+list2derivs">list2derivs</a>()</code>,
<code><a href="#topic+productrule">productrule</a>()</code>,
<code><a href="#topic+quotientrule">quotientrule</a>()</code>,
<code><a href="#topic+sumrule">sumrule</a>()</code>,
<code><a href="#topic+trind_generator">trind_generator</a>()</code>,
<code><a href="#topic+trind">trind</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1:9)/10, ncol=1)
A_derivs&lt;-list2derivs(list(A, A^0, A^2, A^3, A^4), deriv_order=4)
B_derivs&lt;-transform(A, type="exp", par=0, deriv_order=4)
C_derivs&lt;-transform(B_derivs, type="log", par=0, deriv_order=4)
chainrule(list(C_derivs, B_derivs), trind_generator(1), deriv_order=4) #equal to A_derivs

</code></pre>

<hr>
<h2 id='comper'>comper</h2><span id='topic+comper'></span>

<h3>Description</h3>

<p>The comper implements the composed-error distribution in which the <code class="reqn">\mu</code>, <code class="reqn">\sigma_V</code> and <code class="reqn">\sigma_U</code> can depend on additive predictors.
Useable with <code>mgcv::gam</code>, the additive predictors are specified via a list of formulae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comper(
  link = list("identity", "logshift", "logshift"),
  s = -1,
  distr = "normhnorm",
  b = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comper_+3A_link">link</code></td>
<td>
<p>three item list, specifying the link for the <code class="reqn">\mu</code>, <code class="reqn">\sigma_V</code> and <code class="reqn">\sigma_U</code> parameters. See details.</p>
</td></tr>
<tr><td><code id="comper_+3A_s">s</code></td>
<td>
<p>integer; <code class="reqn">s=-1</code> for production and <code class="reqn">s=1</code> for cost function.</p>
</td></tr>
<tr><td><code id="comper_+3A_distr">distr</code></td>
<td>
<p>string; determines the distribution:<br />
'normhnorm', Normal-halfnormal distribution <br />
'normexp', Normal-exponential distribution <br /></p>
</td></tr>
<tr><td><code id="comper_+3A_b">b</code></td>
<td>
<p>positive parameter of the logshift link function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used with <code><a href="mgcv.html#topic+gam">gam()</a></code> to fit distributional stochastic frontier model. The function is called with a list containing three formulae:
</p>

<ol>
<li><p> The first formula specifies the response on the left hand side and the structure of the additive predictor for <code class="reqn">\mu</code> parameter on the right hand side. Link function is &quot;identity&quot;.
</p>
</li>
<li><p> The second formula is one sided, specifying the additive predictor for the  <code class="reqn">\sigma_V</code> on the right hand side. Link function is &quot;logshift&quot;, e.g. <code class="reqn">\log \{ \sigma_V \}  + b </code>.
</p>
</li>
<li><p> The third formula  is one sided, specifying the additive predictor for the  <code class="reqn">\sigma_U</code> on the right hand side. Link function is &quot;logshift&quot;, e.g. <code class="reqn">\log \{ \sigma_U \}  + b </code>.
</p>
</li></ol>

<p>The fitted values and linear predictors for this family will be three column matrices. The first column is the <code class="reqn">\mu</code>, the second column is the <code class="reqn">\sigma_V</code>, the third column is <code class="reqn">\sigma_U</code>.
For more details of the distribution see <code>dcomper()</code>.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>general.family</code> of the mgcv package, which can be used in the <span class="pkg">mgcv</span> and <span class="pkg">dsfa</span> package.
</p>


<h3>References</h3>


<ul>
<li> <p>Schmidt R, Kneib T (2023).
&ldquo;Multivariate distributional stochastic frontier models.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, 107796.
</p>
</li>
<li> <p>Wood SN, Fasiolo M (2017).
&ldquo;A generalized Fellner-Schall method for smoothing parameter optimization with application to Tweedie location, scale and shape models.&rdquo;
<em>Biometrics</em>, <b>73</b>(4), 1071&ndash;1081.
</p>
</li>
<li> <p>Aigner D, Lovell CK, Schmidt P (1977).
&ldquo;Formulation and estimation of stochastic frontier production function models.&rdquo;
<em>Journal of econometrics</em>, <b>6</b>(1), 21&ndash;37.
</p>
</li>
<li> <p>Kumbhakar SC, Wang H, Horncastle AP (2015).
<em>A practitioner's guide to stochastic frontier analysis using Stata</em>.
Cambridge University Press.
</p>
</li>
<li> <p>Azzalini A (2013).
<em>The skew-normal and related families</em>, volume 3.
Cambridge University Press.
</p>
</li>
<li> <p>Schmidt R, Kneib T (2020).
&ldquo;Analytic expressions for the Cumulative Distribution Function of the Composed Error Term in Stochastic Frontier Analysis with Truncated Normal and Exponential Inefficiencies.&rdquo;
<em>arXiv preprint arXiv:2006.03459</em>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>### First example with simulated data
#Set seed, sample size and type of function
set.seed(1337)
N=500 #Sample size
s=-1 #Set to production function

#Generate covariates
x1&lt;-runif(N,-1,1); x2&lt;-runif(N,-1,1); x3&lt;-runif(N,-1,1)
x4&lt;-runif(N,-1,1); x5&lt;-runif(N,-1,1)

#Set parameters of the distribution
mu=2+0.75*x1+0.4*x2+0.6*x2^2+6*log(x3+2)^(1/4) #production function parameter
sigma_v=exp(-1.5+0.75*x4) #noise parameter
sigma_u=exp(-1+sin(2*pi*x5)) #inefficiency parameter

#Simulate responses and create dataset
y&lt;-rcomper(n=N, mu=mu, sigma_v=sigma_v, sigma_u=sigma_u, s=s, distr="normhnorm")
dat&lt;-data.frame(y, x1, x2, x3, x4, x5)

#Write formulae for parameters
mu_formula&lt;-y~x1+x2+I(x2^2)+s(x3, bs="ps")
sigma_v_formula&lt;-~1+x4
sigma_u_formula&lt;-~1+s(x5, bs="ps")

#Fit model
model&lt;-dsfa(formula=list(mu_formula, sigma_v_formula, sigma_u_formula),
                 data=dat, family=comper(s=s, distr="normhnorm"), optimizer = c("efs"))

#Model summary
summary(model)

#Smooth effects
#Effect of x3 on the predictor of the production function
plot(model, select=1) #Estimated function
lines(x3[order(x3)], 6*log(x3[order(x3)]+2)^(1/4)-
        mean(6*log(x3[order(x3)]+2)^(1/4)), col=2) #True effect

#Effect of x5 on the predictor of the inefficiency
plot(model, select=2) #Estimated function
lines(x5[order(x5)], -1+sin(2*pi*x5)[order(x5)]-
        mean(-1+sin(2*pi*x5)),col=2) #True effect

### Second example with real data

data("RiceFarms", package = "plm") #load data
RiceFarms[,c("goutput","size","seed", "totlabor", "urea")]&lt;-
  log(RiceFarms[,c("goutput","size","seed", "totlabor", "urea")]) #log outputs and inputs
RiceFarms$id&lt;-factor(RiceFarms$id) #id as factor

#Set to production function
s=-1 

#Write formulae for parameters
mu_formula&lt;-goutput ~  s(size, bs="ps") + s(seed, bs="ps") + #non-linear effects
  s(totlabor, bs="ps") + s(urea, bs="ps") + #non-linear effects
  varieties + #factor
  s(id, bs="re") #random effect
sigma_v_formula&lt;-~1 
sigma_u_formula&lt;-~bimas

#Fit model with normhnorm dstribution
model&lt;-dsfa(formula=list(mu_formula, sigma_v_formula, sigma_u_formula),
data=RiceFarms, family=comper(s=-1, distr="normhnorm"), optimizer = "efs")

#Summary of model
summary(model)

#Plot smooths
plot(model)


### Third example with real data of cost function

data("electricity", package = "sfaR") #load data

#Log inputs and outputs as in Greene 1990 eq. 46
electricity$lcof&lt;-log(electricity$cost/electricity$fprice)
electricity$lo&lt;-log(electricity$output)
electricity$llf&lt;-log(electricity$lprice/electricity$fprice)
electricity$lcf&lt;-log(electricity$cprice/electricity$fprice)

#Set to cost function
s=1

#Write formulae for parameters
mu_formula&lt;-lcof ~ s(lo, bs="ps") + s(llf, bs="ps") + s(lcf, bs="ps") #non-linear effects
sigma_v_formula&lt;-~1
sigma_u_formula&lt;-~s(lo, bs="ps") + s(lshare, bs="ps") + s(cshare, bs="ps")

#Fit model with normhnorm dstribution
model&lt;-dsfa(formula=list(mu_formula, sigma_v_formula, sigma_u_formula),
                           data=electricity, family=comper(s=s, distr="normhnorm"),
                           optimizer = "efs")

#Summary of model
summary(model)

#Plot smooths
plot(model)


</code></pre>

<hr>
<h2 id='comper_mv'>comper</h2><span id='topic+comper_mv'></span>

<h3>Description</h3>

<p>The comper implements the multivariate composed-error distribution in which the <code class="reqn">\mu_1</code>, <code class="reqn">\sigma_{V1}</code>, <code class="reqn">\sigma_{U2}</code>, <code class="reqn">\mu_2</code>, <code class="reqn">\sigma_{V2}</code>,  <code class="reqn">\sigma_{U2}</code> and <code class="reqn">\delta</code> can depend on additive predictors.
Useable with <code>mgcv::gam</code>, the additive predictors are specified via a list of formulae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comper_mv(
  link = list("identity", "logshift", "logshift", "identity", "logshift", "logshift",
    "glogit"),
  s = c(-1, -1),
  distr = c("normhnorm", "normhnorm", "normal"),
  rot = 0,
  b = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comper_mv_+3A_link">link</code></td>
<td>
<p>seven item list, specifying the links for <code class="reqn">\mu_1</code>, <code class="reqn">\sigma_{V1}</code>, <code class="reqn">\sigma_{U2}</code>, <code class="reqn">\mu_2</code>, <code class="reqn">\sigma_{V2}</code>,  <code class="reqn">\sigma_{U2}</code> and <code class="reqn">\delta</code>. See details.</p>
</td></tr>
<tr><td><code id="comper_mv_+3A_s">s</code></td>
<td>
<p>integer vector of length two; each element corresponds to one marginal.</p>
</td></tr>
<tr><td><code id="comper_mv_+3A_distr">distr</code></td>
<td>
<p>string vector of length three; the first two elements determine the distribution of the marginals. Available are:<br />
'normhnorm', Normal-halfnormal distribution <br />
'normexp', Normal-exponential distribution <br />
The last element determines the distribution of the copula:<br />
'independent', Independence copula <br />
'normal', Gaussian copula <br />
'clayton', Clayton copula <br />
'gumbel', Gumbel copula <br />
'frank', Frank copula <br />
'joe', Joe copula <br />
'amh', Ali-Mikhail-Haq copula <br /></p>
</td></tr>
<tr><td><code id="comper_mv_+3A_rot">rot</code></td>
<td>
<p>integer determining the rotation for Archimedian copulas. Can be <code>90</code>, <code>180</code> or <code>270</code>.</p>
</td></tr>
<tr><td><code id="comper_mv_+3A_b">b</code></td>
<td>
<p>positive parameter of the logshift link function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used with <code><a href="mgcv.html#topic+gam">gam()</a></code> to fit distributional stochastic frontier model. The function is called with a list containing three formulae:
</p>

<ol>
<li><p> The first formula specifies the response of marginal one on the left hand side and the structure of the additive predictor for <code class="reqn">\mu_1</code> parameter on the right hand side. Link function is &quot;identity&quot;.
</p>
</li>
<li><p> The second formula is one sided, specifying the additive predictor for the  <code class="reqn">\sigma_{V1}</code> on the right hand side. Link function is &quot;logshift&quot;, e.g. <code class="reqn">\log \{ \sigma_{V1} \}  + b </code>.
</p>
</li>
<li><p> The third formula  is one sided, specifying the additive predictor for the  <code class="reqn">\sigma_{U1}</code> on the right hand side. Link function is &quot;logshift&quot;, e.g. <code class="reqn">\log \{ \sigma_{U1} \}  + b </code>.
</p>
</li>
<li><p> The fourth formula specifies the response of marginal two on the left hand side and the structure of the additive predictor for <code class="reqn">\mu_2</code> parameter on the right hand side. Link function is &quot;identity&quot;.
</p>
</li>
<li><p> The fifth formula is one sided, specifying the additive predictor for the  <code class="reqn">\sigma_{V2}</code> on the right hand side. Link function is &quot;logshift&quot;, e.g. <code class="reqn">\log \{ \sigma_{V2} \}  + b </code>.
</p>
</li>
<li><p> The sixth formula  is one sided, specifying the additive predictor for the  <code class="reqn">\sigma_{U2}</code> on the right hand side. Link function is &quot;logshift&quot;, e.g. <code class="reqn">\log \{ \sigma_{U2} \}  + b </code>.
</p>
</li>
<li><p> The seventh formula  is one sided, specifying the additive predictor for the  <code class="reqn">\delta</code> on the right hand side. Link function is &quot;glogit&quot;.
</p>
</li></ol>

<p>The fitted values and linear predictors for this family will be seven column matrices.
For more details of the distribution see <code>dcomper()</code>.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>general.family</code> of the mgcv package, which can be used in the <span class="pkg">mgcv</span> and <span class="pkg">dsfa</span> package.
</p>


<h3>References</h3>


<ul>
<li> <p>Schmidt R, Kneib T (2023).
&ldquo;Multivariate distributional stochastic frontier models.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, 107796.
</p>
</li>
<li> <p>Wood SN, Fasiolo M (2017).
&ldquo;A generalized Fellner-Schall method for smoothing parameter optimization with application to Tweedie location, scale and shape models.&rdquo;
<em>Biometrics</em>, <b>73</b>(4), 1071&ndash;1081.
</p>
</li>
<li> <p>Aigner D, Lovell CK, Schmidt P (1977).
&ldquo;Formulation and estimation of stochastic frontier production function models.&rdquo;
<em>Journal of econometrics</em>, <b>6</b>(1), 21&ndash;37.
</p>
</li>
<li> <p>Kumbhakar SC, Wang H, Horncastle AP (2015).
<em>A practitioner's guide to stochastic frontier analysis using Stata</em>.
Cambridge University Press.
</p>
</li>
<li> <p>Azzalini A (2013).
<em>The skew-normal and related families</em>, volume 3.
Cambridge University Press.
</p>
</li>
<li> <p>Schmidt R, Kneib T (2020).
&ldquo;Analytic expressions for the Cumulative Distribution Function of the Composed Error Term in Stochastic Frontier Analysis with Truncated Normal and Exponential Inefficiencies.&rdquo;
<em>arXiv preprint arXiv:2006.03459</em>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#Set seed, sample size and type of function
set.seed(1337)
N=1000 #Sample size
s&lt;-c(-1,-1) #Set to production function for margin 1 and set to cost function for margin 2

distr_cop="normal"
distr_marg1="normhnorm"
distr_marg2="normhnorm"

#Generate covariates
x1&lt;-runif(N,-1,1); x2&lt;-runif(N,-1,1); x3&lt;-runif(N,-1,1)
x4&lt;-runif(N,-1,1); x5&lt;-runif(N,-1,1); x6&lt;-runif(N,-1,1)
x7&lt;-runif(N,-1,1)

mu1=6+2*x1+(-2/3)*x1^2 #production function parameter 1
sigma_v1=exp(-1.5+sin(2*pi*x2)) #noise parameter 1
sigma_u1=exp(-1) #inefficiency parameter 1
mu2=5*x4^2+4*log(x4+2)^(1/4) #cost function parameter 2
sigma_v2=exp(-1.5) #noise parameter 2
sigma_u2=exp(-1+sin(2*pi*x6)) #inefficiency parameter 2
delta=transform(x=matrix(1+2.5*cos(4*x7)),
      type="glogitinv",
      par=delta_bounds(distr_cop), deriv_order = 0)

#Simulate responses and create dataset
Y&lt;-rcomper_mv(n=N, mu=cbind(mu1,mu2),
              sigma_v=cbind(sigma_v1, sigma_v2),
              sigma_u = cbind(sigma_u1, sigma_u2), s=s,
              delta=delta,
              distr = c(distr_marg1,distr_marg2,distr_cop))
dat&lt;-data.frame(y1=Y[,1],y2=Y[,2], x1, x2, x3, x4, x5, x6, x7)

#Write formulae for parameters
mu_1_formula&lt;-y1~s(x1,bs="ps")
sigma_v1_formula&lt;-~s(x2,bs="ps")
sigma_u1_formula&lt;-~1
mu_2_formula&lt;-y2~s(x4,bs="ps")
sigma_v2_formula&lt;-~1
sigma_u2_formula&lt;-~s(x6,bs="ps")
delta_formula&lt;-~s(x7,bs="ps")

#Fit model
model&lt;-dsfa(formula=list(mu_1_formula,sigma_v1_formula,sigma_u1_formula,
                              mu_2_formula,sigma_v2_formula,sigma_u2_formula,
                              delta_formula),  data=dat,
                 family=comper_mv(s=s, distr=c(distr_marg1,distr_marg2,distr_cop)),
                 optimizer="efs")

#Model summary
summary(model)

#Smooth effects
#Effect of x1 on the predictor of the production function of margin 1
plot(model, select=1) #Estimated function
lines(x1[order(x1)], 2*x1[order(x1)]+(-1/3)*x1[order(x1)]^2-
        mean(2*x1+(-1/3)*x1^2), col=2) #True effect

#Effect of x2 on the predictor of the noise of margin 1
plot(model, select=2) #Estimated function
lines(x2[order(x2)], -1.5+sin(2*pi*x2[order(x2)])-
        mean(-1.5+sin(2*pi*x2)),col=2) #True effect

#Effect of x4 on the predictor of the production function of margin 2
plot(model, select=3) #Estimated function
lines(x4[order(x4)], 3+5*x4[order(x4)]^2+4*log(x4[order(x4)]+2)^(1/4)-
        mean(3+5*x4^2+4*log(x4+2)^(1/4)), col=2) #True effect

#Effect of x6 on the predictor of the inefficiency of margin 2
plot(model, select=4) #Estimated function
lines(x6[order(x6)], -1+sin(2*pi*x6[order(x6)])-
        mean(-1+sin(2*pi*x6)),col=2) #True effect

#Effect of x7 on the predictor of the copula
plot(model, select=5) #Estimated function
lines(x7[order(x7)], 2.5*cos(4*x7[order(x7)])-
        mean(2.5*cos(4*x7)),col=2) #True effect

efficiency(model)
elasticity(model)

#' ### Second example with real data

data(BurkinaFarms)
data(BurkinaFarms_polys)

#Write formulae for parameters
mu_1_formula&lt;-qharv_millet~s(land_millet, bs="ps")+s(labour_millet, bs="ps")+
                           s(material, bs="ps")+s(fert_millet, bs="ps")+
                           s(adm1, bs="mrf",xt=BurkinaFarms_polys)
sigma_v1_formula&lt;-~1
sigma_u1_formula&lt;-~farmtype+s(pest_millet, bs="ps")

mu_2_formula&lt;-qharv_sorghum~s(land_sorghum, bs="ps")+s(labour_sorghum, bs="ps")+
                            s(material, bs="ps")+s(fert_sorghum, bs="ps")+
                            s(adm1, bs="mrf",xt=BurkinaFarms_polys)
sigma_v2_formula&lt;-~1
sigma_u2_formula&lt;-~farmtype+s(pest_sorghum, bs="ps")

delta_formula&lt;-~1

model&lt;-dsfa(formula=list(mu_1_formula, sigma_v1_formula, sigma_u1_formula,
                                mu_2_formula, sigma_v2_formula, sigma_u2_formula,
                                delta_formula),
                        data=BurkinaFarms,
                        family=comper_mv(s=c(-1,-1),
                        distr=c("normhnorm","normhnorm","normal")),
                        optimizer="efs")
plot(model) 


</code></pre>

<hr>
<h2 id='cop'>cop</h2><span id='topic+cop'></span>

<h3>Description</h3>

<p>The cop implements multiple copula distributions in which the parameter <code class="reqn">\delta</code> can depend on additive predictors.
Useable with <code>mgcv::gam</code>, the additive predictors are specified via a formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop(link = list("glogit"), W, distr = "normal", rot = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_+3A_link">link</code></td>
<td>
<p>formula, specifying the link for <code class="reqn">\delta</code> parameter. See details.</p>
</td></tr>
<tr><td><code id="cop_+3A_w">W</code></td>
<td>
<p>numeric matrix of pseudo observations. Must have two columns.</p>
</td></tr>
<tr><td><code id="cop_+3A_distr">distr</code></td>
<td>
<p>string, defines the copula family:<br />
'independent' = Independence copula <br />
'normal' = Gaussian copula <br />
'clayton' = Clayton copula <br />
'gumbel' = Gumbel copula <br />
'frank' = Frank copula <br />
'joe' = Joe copula <br />
'amh' = Ali-Mikhail-Haq copula <br /></p>
</td></tr>
<tr><td><code id="cop_+3A_rot">rot</code></td>
<td>
<p>integer determining the rotation for Archimedian copulas. Can be <code>90</code>, <code>180</code> or <code>270</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mostly internal function. Used with gam to fit copula model, which in turn is used for starting values. The function <code>gam</code> is from the mgcv package and is called with a formula.
The formula specifies a dummy on the left hand side and the structure of the additive predictor for the <code class="reqn">\delta</code> parameter on the right hand side.
Link function is &quot;generalized logit&quot;, where for each <code>distr</code> argument there are specific <code>min</code> and <code>max</code> arguments, which are the boundaries of the parameter space.
Although the parameter space is larger in theory for some copulas, numeric under- and overflow limits the parameter space. The intervals for the parameter <code>delta</code> are provided by [delta_bounds()].
WARNING: Only the estimates of the coefficients are useful. The rest of the 'mgcv' object has no meaningful values,
as <code><a href="mgcv.html#topic+gam">gam()</a></code> was more or less abused here.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>general.family</code> of the mgcv package, which can be used in the 'mgcv' and 'dsfa' package.
</p>


<h3>References</h3>


<ul>
<li> <p>Schmidt R, Kneib T (2023).
&ldquo;Multivariate distributional stochastic frontier models.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, 107796.
</p>
</li>
<li> <p>Wood SN, Fasiolo M (2017).
&ldquo;A generalized Fellner-Schall method for smoothing parameter optimization with application to Tweedie location, scale and shape models.&rdquo;
<em>Biometrics</em>, <b>73</b>(4), 1071&ndash;1081.
</p>
</li>
<li> <p>Aigner D, Lovell CK, Schmidt P (1977).
&ldquo;Formulation and estimation of stochastic frontier production function models.&rdquo;
<em>Journal of econometrics</em>, <b>6</b>(1), 21&ndash;37.
</p>
</li>
<li> <p>Kumbhakar SC, Wang H, Horncastle AP (2015).
<em>A practitioner's guide to stochastic frontier analysis using Stata</em>.
Cambridge University Press.
</p>
</li>
<li> <p>Azzalini A (2013).
<em>The skew-normal and related families</em>, volume 3.
Cambridge University Press.
</p>
</li>
<li> <p>Schmidt R, Kneib T (2020).
&ldquo;Analytic expressions for the Cumulative Distribution Function of the Composed Error Term in Stochastic Frontier Analysis with Truncated Normal and Exponential Inefficiencies.&rdquo;
<em>arXiv preprint arXiv:2006.03459</em>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other copula: 
<code><a href="#topic+dcop">dcop</a>()</code>,
<code><a href="#topic+delta_bounds">delta_bounds</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Set seed, sample size and type of copula
set.seed(1337)
N=500 #Sample size
cop="gumbel" #copula
rot=180 #rotation

#Generate covariates
x1&lt;-runif(N,-1,1); x2&lt;-runif(N,-1,1)

#Set parameters of the copula
eta&lt;-matrix(1+2.5*x1+1.75*sin(pi*x2),nrow=N)
delta&lt;-transform(x=eta, type="glogitinv", par=as.numeric(delta_bounds(cop)), deriv_order = 0)

#Simulate pseudo observations W and create dataset
dat&lt;-as.data.frame(rcop(n=N, delta=delta, distr=cop, rot=rot))
dat$y&lt;-1 #Add dummy response variable

#Write formulae for parameters
delta_formula&lt;-y~x1+s(x2,bs="ps")

#Fit model
model&lt;-mgcv::gam(delta_formula, data=dat,
                 family=cop(W=dat[,1:2],
                            distr=cop, rot=rot),
                 optimizer="efs")

#Smooth effects
#Effect of x2 on the predictor of delta
plot(model, select=1) #Estimated function
lines(x2[order(x2)], 1.75*sin(pi*x2[order(x2)])-
        mean(1.75*sin(pi*x2)), col=2) #True effect


</code></pre>

<hr>
<h2 id='dcomper'>Composed-Error distribution</h2><span id='topic+dcomper'></span><span id='topic+pcomper'></span><span id='topic+qcomper'></span><span id='topic+rcomper'></span>

<h3>Description</h3>

<p>Probablitiy density function, distribution, quantile function and random number generation for the composed-error distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcomper(
  x,
  mu = 0,
  sigma_v = 1,
  sigma_u = 1,
  s = -1,
  distr = "normhnorm",
  deriv_order = 0,
  tri = NULL,
  log.p = FALSE
)

pcomper(
  q,
  mu = 0,
  sigma_v = 1,
  sigma_u = 1,
  s = -1,
  distr = "normhnorm",
  deriv_order = 0,
  tri = NULL,
  log.p = FALSE
)

qcomper(
  p,
  mu = 0,
  sigma_v = 1,
  sigma_u = 1,
  s = -1,
  distr = "normhnorm",
  log.p = FALSE
)

rcomper(n, mu = 0, sigma_v = 1, sigma_u = 1, s = -1, distr = "normhnorm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcomper_+3A_x">x</code></td>
<td>
<p>numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="dcomper_+3A_mu">mu</code></td>
<td>
<p>numeric vector of <code class="reqn">\mu</code>.</p>
</td></tr>
<tr><td><code id="dcomper_+3A_sigma_v">sigma_v</code></td>
<td>
<p>numeric vector of <code class="reqn">\sigma_V</code>. Must be positive.</p>
</td></tr>
<tr><td><code id="dcomper_+3A_sigma_u">sigma_u</code></td>
<td>
<p>numeric vector of <code class="reqn">\sigma_U</code>. Must be positive.</p>
</td></tr>
<tr><td><code id="dcomper_+3A_s">s</code></td>
<td>
<p>integer; <code class="reqn">s=-1</code> for production and <code class="reqn">s=1</code> for cost function.</p>
</td></tr>
<tr><td><code id="dcomper_+3A_distr">distr</code></td>
<td>
<p>string; determines the distribution:<br />
'normhnorm', Normal-halfnormal distribution <br />
'normexp', Normal-exponential distribution <br /></p>
</td></tr>
<tr><td><code id="dcomper_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
<tr><td><code id="dcomper_+3A_tri">tri</code></td>
<td>
<p>optional; index matrix for upper triangular, generated by <code><a href="#topic+trind_generator">trind_generator</a></code>.</p>
</td></tr>
<tr><td><code id="dcomper_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dcomper_+3A_q">q</code></td>
<td>
<p>numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="dcomper_+3A_p">p</code></td>
<td>
<p>numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="dcomper_+3A_n">n</code></td>
<td>
<p>positive integer; number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is wrapper function for the normal-halfnormal and normal-exponential distribution. A random variable <code class="reqn">X</code> follows a composed error distribution if <code class="reqn">X = V + s \cdot U </code>, where <code class="reqn">V \sim N(\mu, \sigma_V^2)</code> and <code class="reqn">U \sim HN(0,\sigma_U^2)</code> or <code class="reqn">U \sim Exp(\sigma_U^2)</code>.
For more details see <code><a href="#topic+dnormhnorm">dnormhnorm</a></code> and <code><a href="#topic+dnormexp">dnormexp</a></code>. Here, <code class="reqn">s=-1</code> for production and <code class="reqn">s=1</code> for cost function.
</p>


<h3>Value</h3>

<p><code>dcomper()</code> gives the density, <code>pcomper()</code> give the distribution function, <code>qcomper()</code> gives the quantile function, and <code>rcomper()</code> generates random numbers, with given parameters.
<code>dcomper()</code> and <code>pcomper()</code> returns a <code>derivs</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pcomper()</code>: distribution function for the composed-error distribution.
</p>
</li>
<li> <p><code>qcomper()</code>: quantile function for the composed-error distribution.
</p>
</li>
<li> <p><code>rcomper()</code>: random number generation for the composed-error distribution.
</p>
</li></ul>


<h3>References</h3>


<ul>
<li> <p>Aigner D, Lovell CK, Schmidt P (1977).
&ldquo;Formulation and estimation of stochastic frontier production function models.&rdquo;
<em>Journal of econometrics</em>, <b>6</b>(1), 21&ndash;37.
</p>
</li>
<li> <p>Kumbhakar SC, Wang H, Horncastle AP (2015).
<em>A practitioner's guide to stochastic frontier analysis using Stata</em>.
Cambridge University Press.
</p>
</li>
<li> <p>Schmidt R, Kneib T (2020).
&ldquo;Analytic expressions for the Cumulative Distribution Function of the Composed Error Term in Stochastic Frontier Analysis with Truncated Normal and Exponential Inefficiencies.&rdquo;
<em>arXiv preprint arXiv:2006.03459</em>.
</p>
</li>
<li> <p>Gradshteyn IS, Ryzhik IM (2014).
<em>Table of integrals, series, and products</em>.
Academic press.
</p>
</li>
<li> <p>Azzalini A (2013).
<em>The skew-normal and related families</em>, volume 3.
Cambridge University Press.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other distribution: 
<code><a href="#topic+dcomper_mv">dcomper_mv</a>()</code>,
<code><a href="#topic+dnormexp">dnormexp</a>()</code>,
<code><a href="#topic+dnormhnorm">dnormhnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdf &lt;- dcomper(x=5, mu=1, sigma_v=2, sigma_u=3, s=-1, distr="normhnorm")
cdf &lt;- pcomper(q=5, mu=1, sigma_v=2, sigma_u=3, s=-1, distr="normhnorm")
q &lt;- qcomper(p=seq(0.1, 0.9, by=0.1), mu=1, sigma_v=2, sigma_u=3, s=-1, distr="normhnorm")
r &lt;- rcomper(n=10, mu=1, sigma_v=2, sigma_u=3, s=-1, distr="normhnorm")

</code></pre>

<hr>
<h2 id='dcomper_mv'>Multivariate Composed-Error distribution</h2><span id='topic+dcomper_mv'></span><span id='topic+pcomper_mv'></span><span id='topic+rcomper_mv'></span>

<h3>Description</h3>

<p>Probablitiy density function, distribution, quantile function and random number generation for the multivariate composed-error distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcomper_mv(
  x,
  mu = matrix(c(0, 0), ncol = 2),
  sigma_v = matrix(c(1, 1), ncol = 2),
  sigma_u = matrix(c(1, 1), ncol = 2),
  delta = matrix(0, nrow = 1),
  s = c(-1, -1),
  distr = c("normhnorm", "normhnorm", "normal"),
  rot = 0,
  deriv_order = 0,
  tri = NULL,
  log.p = FALSE
)

pcomper_mv(
  q,
  mu = matrix(c(0, 0), ncol = 2),
  sigma_v = matrix(c(1, 1), ncol = 2),
  sigma_u = matrix(c(1, 1), ncol = 2),
  delta = 0,
  s = c(-1, -1),
  distr = c("normhnorm", "normhnorm", "normal"),
  rot = 0,
  deriv_order = 0,
  tri = NULL,
  log.p = FALSE
)

rcomper_mv(
  n,
  mu = matrix(c(0, 0), ncol = 2),
  sigma_v = matrix(c(1, 1), ncol = 2),
  sigma_u = matrix(c(1, 1), ncol = 2),
  delta = matrix(0, nrow = 1),
  s = c(-1, -1),
  distr = c("normhnorm", "normhnorm", "normal"),
  rot = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcomper_mv_+3A_x">x</code></td>
<td>
<p>numeric matrix of quantiles. Must have two columns.</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_mu">mu</code></td>
<td>
<p>numeric matrix of <code class="reqn">\mu</code>. Must have two columns.</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_sigma_v">sigma_v</code></td>
<td>
<p>numeric matrix of <code class="reqn">\sigma_V</code>. Must be positive and have two columns.</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_sigma_u">sigma_u</code></td>
<td>
<p>numeric matrix of <code class="reqn">\sigma_U</code>. Must be positive and have two columns.</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_delta">delta</code></td>
<td>
<p>numeric vector of copula parameter <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_s">s</code></td>
<td>
<p>integer vector of length two; each element corresponds to one marginal.</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_distr">distr</code></td>
<td>
<p>string vector of length three; the first two elements determine the distribution of the marginals. Available are:<br />
'normhnorm', Normal-halfnormal distribution <br />
'normexp', Normal-exponential distribution <br />
The last element determines the distribution of the copula:<br />
'independent', Independence copula <br />
'normal', Gaussian copula <br />
'clayton', Clayton copula <br />
'gumbel', Gumbel copula <br />
'frank', Frank copula <br />
'joe', Joe copula <br />
'amh', Ali-Mikhail-Haq copula <br /></p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_rot">rot</code></td>
<td>
<p>integer determining the rotation for Archimedian copulas. Can be <code>90</code>, <code>180</code> or <code>270</code>.</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_tri">tri</code></td>
<td>
<p>optional; List of objects generated by [trind_generator()].</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_q">q</code></td>
<td>
<p>numeric matrix of probabilities.</p>
</td></tr>
<tr><td><code id="dcomper_mv_+3A_n">n</code></td>
<td>
<p>positive integer; number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bivariate random vector <code class="reqn">(X_1,X_2)=\boldsymbol{X}</code> follows a multivariate composed-errordistribution <code class="reqn">f_{X_1,X_2}(x_1,x_2)</code>, which can be rewritten using Sklars' theorem via a copula
</p>
<p style="text-align: center;"><code class="reqn">f_{X_1,X_2}(y_1,y_2)=c(F_{X_1}(x_1),F_{X_2}(x_2),\delta) \cdot f_{X_1}(x_1) f_{X_2}(x_2) \qquad,</code>
</p>

<p>where <code class="reqn">c(\cdot)</code> is the density of the copula and <code class="reqn">F_{X_m}(x_m)</code>,<code class="reqn">f_{X_m}(x_m)</code> are the marginal cdfs and pdfs respectively for <code class="reqn">m \in \{1,2\}</code>. <code class="reqn">\delta</code> is the copula parameter.
</p>


<h3>Value</h3>

<p><code>dcomper_mv</code> gives the density, <code>pcomper_mv</code> give the distribution function, and <code>rcomper_mv</code> generates random numbers, with given parameters.
If the derivatives are calculated the output is a <code>derivs</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pcomper_mv()</code>: distribution function for the multivariate composed-error distribution.
</p>
</li>
<li> <p><code>rcomper_mv()</code>: random number generation for the multivariate composed-error distribution.
</p>
</li></ul>


<h3>References</h3>


<ul>
<li> <p>Aigner D, Lovell CK, Schmidt P (1977).
&ldquo;Formulation and estimation of stochastic frontier production function models.&rdquo;
<em>Journal of econometrics</em>, <b>6</b>(1), 21&ndash;37.
</p>
</li>
<li> <p>Kumbhakar SC, Wang H, Horncastle AP (2015).
<em>A practitioner's guide to stochastic frontier analysis using Stata</em>.
Cambridge University Press.
</p>
</li>
<li> <p>Schmidt R, Kneib T (2020).
&ldquo;Analytic expressions for the Cumulative Distribution Function of the Composed Error Term in Stochastic Frontier Analysis with Truncated Normal and Exponential Inefficiencies.&rdquo;
<em>arXiv preprint arXiv:2006.03459</em>.
</p>
</li>
<li> <p>Gradshteyn IS, Ryzhik IM (2014).
<em>Table of integrals, series, and products</em>.
Academic press.
</p>
</li>
<li> <p>Azzalini A (2013).
<em>The skew-normal and related families</em>, volume 3.
Cambridge University Press.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other distribution: 
<code><a href="#topic+dcomper">dcomper</a>()</code>,
<code><a href="#topic+dnormexp">dnormexp</a>()</code>,
<code><a href="#topic+dnormhnorm">dnormhnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdf &lt;- dcomper_mv(x=matrix(c(0,10),ncol=2), mu=matrix(c(1,2),ncol=2),
                  sigma_v=matrix(c(3,4),ncol=2), sigma_u=matrix(c(5,6),ncol=2),
                  delta=c(0.5), s=c(-1,-1), distr=c("normhnorm","normhnorm","normal"),
                  deriv=2 ,
                  tri=list(trind_generator(3),trind_generator(3),trind_generator(1),
                  trind_generator(6),trind_generator(7)), 
                  log.p=TRUE)
cdf &lt;- pcomper_mv(q=matrix(c(0,10),ncol=2), mu=matrix(c(1,2),ncol=2),
                  sigma_v=matrix(c(3,4),ncol=2), sigma_u=matrix(c(5,6),ncol=2),
                  delta=c(0.5), s=c(-1,-1), distr=c("normhnorm","normhnorm","normal"))
r &lt;- rcomper_mv(n=10, mu=matrix(c(1,2),ncol=2),
                sigma_v=matrix(c(3,4),ncol=2), sigma_u=matrix(c(5,6),ncol=2),
                delta=c(0.5), s=c(-1,-1), distr=c("normhnorm","normhnorm","normal"))

</code></pre>

<hr>
<h2 id='dcop'>Copula function</h2><span id='topic+dcop'></span><span id='topic+pcop'></span><span id='topic+rcop'></span>

<h3>Description</h3>

<p>Probablitiy density function, distribution and random number generation for copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcop(
  W,
  delta,
  distr = "normal",
  rot = 0,
  deriv_order = 0,
  tri = NULL,
  log.p = FALSE
)

pcop(W, delta = 0, distr = "normal", rot = 0, log.p = FALSE)

rcop(n, delta = 0, distr = "normal", rot = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcop_+3A_w">W</code></td>
<td>
<p>numeric matrix of pseudo observations. Must have two columns.</p>
</td></tr>
<tr><td><code id="dcop_+3A_delta">delta</code></td>
<td>
<p>numeric vector of copula parameter <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="dcop_+3A_distr">distr</code></td>
<td>
<p>string, defines the copula family:<br />
'independent' = Independence copula <br />
'normal' = Gaussian copula <br />
'clayton' = Clayton copula <br />
'gumbel' = Gumbel copula <br />
'frank' = Frank copula <br />
'joe' = Joe copula <br />
'amh' = Ali-Mikhail-Haq copula <br /></p>
</td></tr>
<tr><td><code id="dcop_+3A_rot">rot</code></td>
<td>
<p>integer determining the rotation for Archimedian copulas. Can be <code>90</code>, <code>180</code> or <code>270</code>.</p>
</td></tr>
<tr><td><code id="dcop_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
<tr><td><code id="dcop_+3A_tri">tri</code></td>
<td>
<p>optional; index matrix for upper triangular, generated by <code><a href="#topic+trind_generator">trind_generator</a></code>.</p>
</td></tr>
<tr><td><code id="dcop_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dcop_+3A_n">n</code></td>
<td>
<p>positive integer; number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A two-dimensional copula <code class="reqn">C(w_1, w_2, \delta)</code> is a multivariate cumulative distribution function for which the marginal probability distribution of <code class="reqn">w_1</code> and <code class="reqn">w_2</code> are uniform on the interval <code class="reqn">[0,1]</code>.
The parameter <code class="reqn">\delta</code> specifies the copula.
</p>
<p>The functions <code>pcop()</code> and <code>rcop()</code> are wrapper functions for the <code><a href="copula.html#topic+pCopula">pCopula</a></code> and <code><a href="copula.html#topic+rCopula">rCopula</a></code>.
</p>


<h3>Value</h3>

<p><code>dcop</code> gives the density, <code>pcop</code> gives the distribution function for a specified copula and <code>rcop</code> generates random numbers, with given <code>delta</code>.
<code>dcop()</code> returns a <code>derivs</code> object. For more details see <code><a href="#topic+trind">trind</a></code> and <code><a href="#topic+trind_generator">trind_generator</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pcop()</code>: distribution function for copula.
</p>
</li>
<li> <p><code>rcop()</code>: random number generation for copula.
</p>
</li></ul>


<h3>References</h3>


<ul>
<li> <p>Schepsmeier U, StÃ¶ber J (2014).
&ldquo;Derivatives and Fisher information of bivariate copulas.&rdquo;
<em>Statistical Papers</em>, <b>55</b>(2), 525&ndash;542.
</p>
</li>
<li> <p>Hofert M, Kojadinovic I, MÃ¤chler M, Yan J (2018).
<em>Elements of copula modeling with R</em>.
Springer.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other copula: 
<code><a href="#topic+cop">cop</a>()</code>,
<code><a href="#topic+delta_bounds">delta_bounds</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u=0.3; v=0.7; p=0.5
pdf &lt;- dcop(W=cbind(u,v), delta=p, distr="normal")
cdf &lt;- pcop(W=cbind(u,v), delta=p, distr="normal")
r &lt;- rcop(n=100, delta=p, distr="normal")

</code></pre>

<hr>
<h2 id='delta_bounds'>Bounds of Copula Parameter delta</h2><span id='topic+delta_bounds'></span>

<h3>Description</h3>

<p>Provides the minimum and maximum of the parameter space for <code class="reqn">\delta</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_bounds(distr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_bounds_+3A_distr">distr</code></td>
<td>
<p>string, defines the copula family:<br />
'independent' = Independence copula <br />
'normal' = Gaussian copula <br />
'clayton' = Clayton copula <br />
'gumbel' = Gumbel copula <br />
'frank' = Frank copula <br />
'joe' = Joe copula <br />
'amh' = Ali-Mikhail-Haq copula <br /></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although the parameter space is larger in theory for some copulas, numeric under- and overflow limits the parameter space. The parameter space of <code class="reqn">\delta</code> is specified for each copula below: 
</p>

<ul>
<li><p>  'independent', min=0 and max=1
</p>
</li>
<li><p>  'normal', min=-1 and max=1
</p>
</li>
<li><p>  'clayton', min=1e-16 and max=28
</p>
</li>
<li><p>  'gumbel', min=1 and max=17
</p>
</li>
<li><p>  'frank', min=-35 and max=35
</p>
</li>
<li><p>  'joe', min=1e-16 and max=30
</p>
</li>
<li><p>  'amh', min=-1 and max=1
</p>
</li></ul>



<h3>Value</h3>

<p>Returns numeric vector of length two with first argument being the minimum and the second argument being the maximum of the parameter space.
</p>


<h3>See Also</h3>

<p>Other copula: 
<code><a href="#topic+cop">cop</a>()</code>,
<code><a href="#topic+dcop">dcop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delta_bounds("normal")

</code></pre>

<hr>
<h2 id='derivs_transform'>derivs_transform</h2><span id='topic+derivs_transform'></span>

<h3>Description</h3>

<p>Transforms a derivs object via the specified function and applies the chainrule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivs_transform(f, type, par, tri, deriv_order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivs_transform_+3A_f">f</code></td>
<td>
<p>derivs object.</p>
</td></tr>
<tr><td><code id="derivs_transform_+3A_type">type</code></td>
<td>
<p>string, specifies the transformation function. Available are:
</p>

<ol>
<li><p>  'identity': <code class="reqn">f(x)=x</code>.
</p>
</li>
<li><p>  'exp': <code class="reqn">f(x)=\exp\{x\}</code>.
</p>
</li>
<li><p>  'log': <code class="reqn">f(x)=\log\{x\}</code>.
</p>
</li>
<li><p>  'glogit': <code class="reqn">f(x)=\log\{(-x + min)/(x - max)</code>, where <code>par=c(min, max)</code>.
</p>
</li>
<li><p>  'glogitinv': <code class="reqn">f(x)=\exp\{x\} \cdot (max + min)/(1 + \exp\{x\}) </code>, where <code>par=c(min, max)</code>.
</p>
</li>
<li><p>  'inv': <code class="reqn">f(x)=\frac{1}{x}</code>.
</p>
</li>
<li><p>  'pnorm': <code class="reqn">f(x)=\Phi(x)</code>.
</p>
</li>
<li><p>  'qnorm': <code class="reqn">f(x)=\Phi^{-1}(x)</code>.
</p>
</li>
<li><p>  'mexp': <code class="reqn">f(x)=-\exp\{x\}</code>.
</p>
</li>
<li><p>  'zeta': <code class="reqn">f(x)=\log\{2 \cdot \Phi(x)\}</code>.
</p>
</li>
<li><p>  'constant': <code class="reqn">f(x)=c</code>.
</p>
</li>
<li><p>  'chainrule_utility': <code class="reqn">f(x)=f'(x)=f''(x)=f'''(x)=f''''(x)</code>.
</p>
</li>
<li><p>   onemx: <code class="reqn">1-x</code>
</p>
</li></ol>
</td></tr>
<tr><td><code id="derivs_transform_+3A_par">par</code></td>
<td>
<p>numeric vector, additional parameters, e.g. min and max for <code>glogit</code>.</p>
</td></tr>
<tr><td><code id="derivs_transform_+3A_tri">tri</code></td>
<td>
<p>list; created by the function [trind_generator()].</p>
</td></tr>
<tr><td><code id="derivs_transform_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes the derivs object <code>f</code> as an input for the function specified by <code>type</code> and evaluates it together with the derivatives utilizing the chainrule.
For more details see [trind()] and [trind_generator()].
</p>


<h3>Value</h3>

<p>Returns an object of class <code>derivs</code>
</p>


<h3>See Also</h3>

<p>Other derivs: 
<code><a href="#topic+chainrule">chainrule</a>()</code>,
<code><a href="#topic+differencerule">differencerule</a>()</code>,
<code><a href="#topic+ind2joint">ind2joint</a>()</code>,
<code><a href="#topic+list2derivs">list2derivs</a>()</code>,
<code><a href="#topic+productrule">productrule</a>()</code>,
<code><a href="#topic+quotientrule">quotientrule</a>()</code>,
<code><a href="#topic+sumrule">sumrule</a>()</code>,
<code><a href="#topic+trind_generator">trind_generator</a>()</code>,
<code><a href="#topic+trind">trind</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1:9)/10, ncol=1)
A_mat&lt;-list2derivs(list(A, A^0, A^2, A^3, A^4), deriv_order=4)
derivs_transform(f =derivs_transform(f = A, type="exp", par=0,
                                     tri=trind_generator(1), deriv_order=4),
                   type="log", par=0, tri=trind_generator(1), deriv_order=4)

</code></pre>

<hr>
<h2 id='differencerule'>Differencerule</h2><span id='topic+differencerule'></span>

<h3>Description</h3>

<p>Differencerule for derivs objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>differencerule(f_list, tri, deriv_order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="differencerule_+3A_f_list">f_list</code></td>
<td>
<p>list of <code>derivs</code> objects of length <code class="reqn">M</code>, e.g. <code class="reqn">list(f_1(\cdot), f_2(\cdot),...,f_M(\cdot))</code></p>
</td></tr>
<tr><td><code id="differencerule_+3A_tri">tri</code></td>
<td>
<p>list; created by the function [trind_generator()].</p>
</td></tr>
<tr><td><code id="differencerule_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">f_m</code> be a function defined in [trind()], where <code class="reqn">m \in {1,...,M}</code>.
Define <code class="reqn">h((x_{n1},x_{n2},...,x_{nK})) = f_1(\cdot) - f_2(\cdot) ... - f_M(x_{n1},x_{n2},...,x_{nK}))</code>.
In order to get the derivatives of <code class="reqn">h(\cdot)</code> w.r.t all parameters <code class="reqn">x_{nk}</code>, the difference rule is applied.
For more details see [trind()] and [trind_generator()].
</p>


<h3>Value</h3>

<p>Returns an object of class <code>derivs</code> for the function <code class="reqn">h(\cdot)</code>.
</p>


<h3>See Also</h3>

<p>Other derivs: 
<code><a href="#topic+chainrule">chainrule</a>()</code>,
<code><a href="#topic+derivs_transform">derivs_transform</a>()</code>,
<code><a href="#topic+ind2joint">ind2joint</a>()</code>,
<code><a href="#topic+list2derivs">list2derivs</a>()</code>,
<code><a href="#topic+productrule">productrule</a>()</code>,
<code><a href="#topic+quotientrule">quotientrule</a>()</code>,
<code><a href="#topic+sumrule">sumrule</a>()</code>,
<code><a href="#topic+trind_generator">trind_generator</a>()</code>,
<code><a href="#topic+trind">trind</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1:9)/10, ncol=1)
A_derivs&lt;-list2derivs(list(A, A^0, A^2, A^3, A^4), deriv_order=4)
differencerule(list(A_derivs, A_derivs), trind_generator(1), deriv_order=4) #equal to 0

</code></pre>

<hr>
<h2 id='dnormexp'>Normal-Exponential distribution</h2><span id='topic+dnormexp'></span><span id='topic+normexp'></span><span id='topic+pnormexp'></span><span id='topic+qnormexp'></span><span id='topic+rnormexp'></span>

<h3>Description</h3>

<p>Probablitiy density function, distribution, quantile function and random number generation for the normal-exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnormexp(
  x,
  mu = 0,
  sigma_v = 1,
  sigma_u = 1,
  s = -1,
  deriv_order = 0,
  tri = NULL,
  log.p = FALSE
)

pnormexp(
  q,
  mu = 0,
  sigma_v = 1,
  sigma_u = 1,
  s = -1,
  deriv_order = 0,
  tri = NULL,
  log.p = FALSE
)

qnormexp(p, mu = 0, sigma_v = 1, sigma_u = 1, s = -1, log.p = FALSE)

rnormexp(n, mu = 0, sigma_v = 1, sigma_u = 1, s = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnormexp_+3A_x">x</code></td>
<td>
<p>numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="dnormexp_+3A_mu">mu</code></td>
<td>
<p>numeric vector of <code class="reqn">\mu</code>.</p>
</td></tr>
<tr><td><code id="dnormexp_+3A_sigma_v">sigma_v</code></td>
<td>
<p>numeric vector of <code class="reqn">\sigma_V</code>. Must be positive.</p>
</td></tr>
<tr><td><code id="dnormexp_+3A_sigma_u">sigma_u</code></td>
<td>
<p>numeric vector of <code class="reqn">\sigma_U</code>. Must be positive.</p>
</td></tr>
<tr><td><code id="dnormexp_+3A_s">s</code></td>
<td>
<p>integer; <code class="reqn">s=-1</code> for production and <code class="reqn">s=1</code> for cost function.</p>
</td></tr>
<tr><td><code id="dnormexp_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
<tr><td><code id="dnormexp_+3A_tri">tri</code></td>
<td>
<p>optional; index matrix for upper triangular, generated by <code><a href="#topic+trind_generator">trind_generator</a></code>.</p>
</td></tr>
<tr><td><code id="dnormexp_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dnormexp_+3A_q">q</code></td>
<td>
<p>numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="dnormexp_+3A_p">p</code></td>
<td>
<p>numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="dnormexp_+3A_n">n</code></td>
<td>
<p>positive integer; number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A random variable <code class="reqn">X</code> follows a normal-exponential distribution if <code class="reqn">X = V + s \cdot U </code>, where <code class="reqn">V \sim N(\mu, \sigma_V^2)</code> and <code class="reqn">U \sim Exp(\sigma_U)</code>.
The density is given by </p>
<p style="text-align: center;"><code class="reqn">f_X(x)=\frac{\sigma_U}{2} \exp \{\sigma_U (s \mu) + \frac{1}{2} \sigma_U^2 \sigma_V^2-\sigma_U (s x) \} 2 \Phi(\frac{1}{\sigma_V} (-s \mu)-\sigma_U \sigma_V+\frac{1}{\sigma_V}(s x)) \qquad,</code>
</p>

<p>where <code class="reqn">s=-1</code> for production and <code class="reqn">s=1</code> for cost function. In the latter case the distribution is equivalent to the Exponentially modified Gaussian distribution. 
'
</p>


<h3>Value</h3>

<p><code>dnormexp()</code> gives the density, <code>pnormexp()</code> give the distribution function, <code>qnormexp()</code> gives the quantile function, and <code>rnormexp()</code> generates random numbers, with given parameters.
<code>dnormexp()</code> and <code>pnormexp()</code> return a <code>derivs</code> object. For more details see <code><a href="#topic+trind">trind</a></code> and <code><a href="#topic+trind_generator">trind_generator</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pnormexp()</code>: distribution function for the normal-exponential distribution.
</p>
</li>
<li> <p><code>qnormexp()</code>: quantile function for the normal-exponential distribution.
</p>
</li>
<li> <p><code>rnormexp()</code>: random number generation for the normal-exponential distribution.
</p>
</li></ul>


<h3>References</h3>


<ul>
<li> <p>Aigner D, Lovell CK, Schmidt P (1977).
&ldquo;Formulation and estimation of stochastic frontier production function models.&rdquo;
<em>Journal of econometrics</em>, <b>6</b>(1), 21&ndash;37.
</p>
</li>
<li> <p>Kumbhakar SC, Wang H, Horncastle AP (2015).
<em>A practitioner's guide to stochastic frontier analysis using Stata</em>.
Cambridge University Press.
</p>
</li>
<li> <p>Schmidt R, Kneib T (2020).
&ldquo;Analytic expressions for the Cumulative Distribution Function of the Composed Error Term in Stochastic Frontier Analysis with Truncated Normal and Exponential Inefficiencies.&rdquo;
<em>arXiv preprint arXiv:2006.03459</em>.
</p>
</li>
<li> <p>Gradshteyn IS, Ryzhik IM (2014).
<em>Table of integrals, series, and products</em>.
Academic press.
</p>
</li>
<li> <p>Azzalini A (2013).
<em>The skew-normal and related families</em>, volume 3.
Cambridge University Press.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other distribution: 
<code><a href="#topic+dcomper_mv">dcomper_mv</a>()</code>,
<code><a href="#topic+dcomper">dcomper</a>()</code>,
<code><a href="#topic+dnormhnorm">dnormhnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdf &lt;- dnormexp(x=5, mu=1, sigma_v=2, sigma_u=3, s=-1)
cdf &lt;- pnormexp(q=5, mu=1, sigma_v=2, sigma_u=3, s=-1)
q &lt;- qnormexp(p=seq(0.1, 0.9, by=0.1), mu=1, sigma_v=2, sigma_u=3, s=-1)
r &lt;- rnormexp(n=10, mu=1, sigma_v=2, sigma_u=3, s=-1)

</code></pre>

<hr>
<h2 id='dnormhnorm'>Normal-halfnormal distribution</h2><span id='topic+dnormhnorm'></span><span id='topic+normhnorm'></span><span id='topic+pnormhnorm'></span><span id='topic+qnormhnorm'></span><span id='topic+rnormhnorm'></span>

<h3>Description</h3>

<p>Probablitiy density function, distribution, quantile function and random number generation for the normal-halfnormal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnormhnorm(
  x,
  mu = 0,
  sigma_v = 1,
  sigma_u = 1,
  s = -1,
  deriv_order = 0,
  tri = NULL,
  log.p = FALSE
)

pnormhnorm(
  q,
  mu = 0,
  sigma_v = 1,
  sigma_u = 1,
  s = -1,
  deriv_order = 0,
  tri = NULL,
  log.p = FALSE
)

qnormhnorm(p, mu = 0, sigma_v = 1, sigma_u = 1, s = -1)

rnormhnorm(n, mu = 0, sigma_v = 1, sigma_u = 1, s = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnormhnorm_+3A_x">x</code></td>
<td>
<p>numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="dnormhnorm_+3A_mu">mu</code></td>
<td>
<p>numeric vector of <code class="reqn">\mu</code>.</p>
</td></tr>
<tr><td><code id="dnormhnorm_+3A_sigma_v">sigma_v</code></td>
<td>
<p>numeric vector of <code class="reqn">\sigma_V</code>. Must be positive.</p>
</td></tr>
<tr><td><code id="dnormhnorm_+3A_sigma_u">sigma_u</code></td>
<td>
<p>numeric vector of <code class="reqn">\sigma_U</code>. Must be positive.</p>
</td></tr>
<tr><td><code id="dnormhnorm_+3A_s">s</code></td>
<td>
<p>integer; <code class="reqn">s=-1</code> for production and <code class="reqn">s=1</code> for cost function.</p>
</td></tr>
<tr><td><code id="dnormhnorm_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
<tr><td><code id="dnormhnorm_+3A_tri">tri</code></td>
<td>
<p>optional; index matrix for upper triangular, generated by <code><a href="#topic+trind_generator">trind_generator</a></code>.</p>
</td></tr>
<tr><td><code id="dnormhnorm_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="dnormhnorm_+3A_q">q</code></td>
<td>
<p>numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="dnormhnorm_+3A_p">p</code></td>
<td>
<p>numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="dnormhnorm_+3A_n">n</code></td>
<td>
<p>positive integer; number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A random variable <code class="reqn">X</code> follows a normal-halfnormal distribution if <code class="reqn">X = V + s \cdot U </code>, where <code class="reqn">V \sim N(\mu, \sigma_V^2)</code> and <code class="reqn">U \sim HN(\sigma_U^2)</code>.
The density is given by </p>
<p style="text-align: center;"><code class="reqn">f_X(x)=\frac{1}{\sqrt{\sigma_V^2+\sigma_U^2}} \phi(\frac{x-\mu}{\sqrt{\sigma_V^2+\sigma_U^2}}) \Phi(s \frac{\sigma_U}{\sigma_V} \frac{x-\mu}{\sqrt{\sigma_V^2+\sigma_U^2}}) \qquad,</code>
</p>

<p>where <code class="reqn">s=-1</code> for production and <code class="reqn">s=1</code> for cost function.
</p>


<h3>Value</h3>

<p><code>dnormhnorm()</code> gives the density, <code>pnormhnorm()</code> give the distribution function, <code>qnormhnorm()</code> gives the quantile function, and <code>rnormhnorm()</code> generates random numbers, with given parameters.
<code>dnormhnorm()</code> and <code>pnormhnorm()</code> return a <code>derivs</code> object. For more details see <code><a href="#topic+trind">trind</a></code> and <code><a href="#topic+trind_generator">trind_generator</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pnormhnorm()</code>: distribution function for the normal-halfnormal distribution.
</p>
</li>
<li> <p><code>qnormhnorm()</code>: quantile function for the normal-halfnormal distribution.
</p>
</li>
<li> <p><code>rnormhnorm()</code>: random number generation for the normal-halfnormal distribution.
</p>
</li></ul>


<h3>References</h3>


<ul>
<li> <p>Aigner D, Lovell CK, Schmidt P (1977).
&ldquo;Formulation and estimation of stochastic frontier production function models.&rdquo;
<em>Journal of econometrics</em>, <b>6</b>(1), 21&ndash;37.
</p>
</li>
<li> <p>Kumbhakar SC, Wang H, Horncastle AP (2015).
<em>A practitioner's guide to stochastic frontier analysis using Stata</em>.
Cambridge University Press.
</p>
</li>
<li> <p>Schmidt R, Kneib T (2020).
&ldquo;Analytic expressions for the Cumulative Distribution Function of the Composed Error Term in Stochastic Frontier Analysis with Truncated Normal and Exponential Inefficiencies.&rdquo;
<em>arXiv preprint arXiv:2006.03459</em>.
</p>
</li>
<li> <p>Gradshteyn IS, Ryzhik IM (2014).
<em>Table of integrals, series, and products</em>.
Academic press.
</p>
</li>
<li> <p>Azzalini A (2013).
<em>The skew-normal and related families</em>, volume 3.
Cambridge University Press.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other distribution: 
<code><a href="#topic+dcomper_mv">dcomper_mv</a>()</code>,
<code><a href="#topic+dcomper">dcomper</a>()</code>,
<code><a href="#topic+dnormexp">dnormexp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdf &lt;- dnormhnorm(x=5, mu=1, sigma_v=2, sigma_u=3, s=-1)
cdf &lt;- pnormhnorm(q=5, mu=1, sigma_v=2, sigma_u=3, s=-1)
q &lt;- qnormhnorm(p=seq(0.1, 0.9, by=0.1), mu=1, sigma_v=2, sigma_u=3, s=-1)
r &lt;- rnormhnorm(n=10, mu=1, sigma_v=2, sigma_u=3, s=-1)

</code></pre>

<hr>
<h2 id='dsfa'>dsfa-package: Distributional Stochastic Frontier Analysis</h2><span id='topic+dsfa'></span>

<h3>Description</h3>

<p>The <span class="pkg">dsfa</span> package implements the specification, estimation and prediction of distributional stochastic frontier models via <span class="pkg">mgcv</span>.
The basic distributional stochastic frontier model is given by: </p>
<p style="text-align: center;"><code class="reqn">Y_n = \eta^\mu(\boldsymbol{x}_n^\mu) + V_n + s \cdot U_n </code>
</p>
<p> where <code class="reqn">n \in \{1,2,...,N\}</code>.
<code class="reqn">V_n</code> and <code class="reqn">U_n</code> are the noise and (in)efficiency respectively.
</p>

<ul>
<li><p> For <code class="reqn">s=-1</code>, <code class="reqn">\eta^\mu(\cdot)</code> is the production function and <code class="reqn">\boldsymbol{x}_n^\mu</code> are the log inputs.
Alternatively, if <code class="reqn">s=1</code>, <code class="reqn">\eta^\mu(\cdot)</code> is the cost function and <code class="reqn">\boldsymbol{x}_n^\mu</code> are the log cost.
The vector <code class="reqn">\boldsymbol{x}_n^\mu</code> may also contain other variables.
</p>
</li>
<li><p> The noise is represented as <code class="reqn">V_n \sim N(0,\sigma_{Vn}^2)</code>, where <code class="reqn">\sigma_{Vn}=\exp(\eta^{\sigma_{V}}(\boldsymbol{x}_n^{\sigma_{V}}))</code>.
Here, <code class="reqn">\boldsymbol{x}_n^{\sigma_{V}}</code> are the observed covariates which influence the parameter of the noise.
</p>
</li>
<li><p> The (in)efficiency can be represented in two ways.
</p>

<ul>
<li><p> If <code class="reqn">U_n \sim HN(\sigma_{Un}^2)</code>, where <code class="reqn">\sigma_{Un}=\exp(\eta^{\sigma_{Un}}(\boldsymbol{x}_n^{\sigma_{U}}))</code>.
Here, <code class="reqn">\boldsymbol{x}_n^{\sigma_{U}}</code> are the observed covariates which influence the parameter of the (in)efficiency.
Consequently: </p>
<p style="text-align: center;"><code class="reqn">Y_n \sim normhnorm(\mu_n=\eta^\mu(\boldsymbol{x}_n^\mu), \sigma_{Vn}=\exp(\eta^{\sigma_{V}}(\boldsymbol{x}_n^{\sigma_{V}})), \sigma_{Un}=\exp(\eta^{\sigma_{U}}(\boldsymbol{x}_n^{\sigma_{U}})), s=s)</code>
</p>
<p>.
For more details see <code><a href="#topic+dnormhnorm">dnormhnorm</a></code>.
</p>
</li>
<li><p> If <code class="reqn">U_n \sim Exp(\sigma_{Un})</code>, where <code class="reqn">\sigma_{Un}=\exp(\eta^{\sigma_{Un}}(\boldsymbol{x}_n^{\sigma_{U}}))</code>.
Here, <code class="reqn">\boldsymbol{x}_n^{\sigma_{U}}</code> are the observed covariates which influence the parameter of the (in)efficiency.
Consequently: </p>
<p style="text-align: center;"><code class="reqn">Y_n \sim normexp(\mu_n=\eta^\mu(\boldsymbol{x}_n^\mu), \sigma_{Vn}=\exp(\eta^{\sigma_{V}}(\boldsymbol{x}_n^{\sigma_{V}})), \sigma_{Un}=\exp(\eta^{\sigma_{U}}(\boldsymbol{x}_n^{\sigma_{U}})), s=s)</code>
</p>
<p>.
For more details see <code><a href="#topic+dnormexp">dnormexp</a></code>.
</p>
</li></ul>

</li></ul>

<p>Consequently, <code class="reqn">Y_n</code> follows a composed-error distribution. For an overview see <code><a href="#topic+dcomper">dcomper</a></code>. 
</p>
<p>Let <code class="reqn">\theta_n</code> be a parameter of the distribution of <code class="reqn">Y_n</code>, e.g. <code class="reqn">\theta_n \in \{\mu_n, \sigma_{Un}, \sigma_{Vn}\}</code>.
Further, let <code class="reqn">g^{-1}_{\theta}(\cdot)</code> be the monotonic response function, which links the additive predictor <code class="reqn">\eta(\boldsymbol{x}_n^\theta)</code> to the parameter space for the parameter <code class="reqn">\theta_n</code> via the additive model:
</p>
<p style="text-align: center;"><code class="reqn">g^{-1}_{\theta}(\theta_n)=\eta(\boldsymbol{x}_n^\theta)=\beta^\theta_0 + \sum_{j^\theta=1}^{J^\theta} h^\theta_{j^\theta}(x^\theta_{nj^\theta})</code>
</p>

<p>Thus, the additive predictor <code class="reqn">\eta(\boldsymbol{x}_n^\theta)</code> is made up by the intercept <code class="reqn">\beta^\theta_0</code> and <code class="reqn">J^\theta</code> smooths terms.
The <span class="pkg">mgcv</span> packages provides a framework for fitting distributional regression models. For more information see <code><a href="#topic+comper">comper</a></code>.
The additive predictors can be defined via formulae in <code><a href="mgcv.html#topic+gam">gam</a></code>. Within the formulae for the parameter <code class="reqn">\theta_n</code>, the smooth function for the variable <code class="reqn">x^\theta_{nj^\theta}</code> can be specified via the function <code><a href="mgcv.html#topic+s">s</a></code>, which is <code class="reqn">h^\theta_{j^\theta}(\cdot)</code> in the notation above.
The smooth functions may be:
</p>

<ul>
<li><p> linear effects, may include polynomials or regression splines.
</p>
</li>
<li><p> non-linear effects, which can be modeled via penalized regression splines, e.g. <code><a href="mgcv.html#topic+p.spline">p.spline</a></code>, <code><a href="mgcv.html#topic+tprs">tprs</a></code>.
</p>
</li>
<li><p> random effects, <code><a href="mgcv.html#topic+random.effects">random.effects</a></code>.
</p>
</li>
<li><p> spatial effects, which can be modeled via <code><a href="mgcv.html#topic+mrf">mrf</a></code>.
</p>
</li></ul>

<p>An overview is provided at <code><a href="mgcv.html#topic+smooth.terms">smooth.terms</a></code>.
The functions <code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> and <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>,
are alike to the basic <code>S</code> functions.
A number of other functions such as <code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code>, <code><a href="mgcv.html#topic+residuals.gam">residuals.gam</a></code> and
<code><a href="mgcv.html#topic+anova.gam">anova.gam</a></code> are also provided, for extracting information from a fitted <code><a href="mgcv.html#topic+gamObject">gamOject</a></code>.
</p>
<p>The main functions are:
</p>

<ul>
<li> <p><code><a href="#topic+comper">comper</a></code>  Object which can be used to fit a composed-error stochastic frontier model with the <code>mgcv</code> package.
</p>
</li>
<li> <p><code><a href="#topic+comper_mv">comper_mv</a></code>  Object which can be used to fit a multivariate composed-error stochastic frontier model with the <code>mgcv</code> package.
</p>
</li>
<li> <p><code><a href="#topic+elasticity">elasticity</a></code>  Calculates and plots the elasticity of a smooth function.
</p>
</li>
<li> <p><code><a href="#topic+efficiency">efficiency</a></code>  Calculates the expected technical (in)efficiency index <code class="reqn">E[U|\mathcal{E}]</code> or <code class="reqn">E[\exp(-U)|\mathcal{E}]</code>.
</p>
</li></ul>

<p>Further useful functions are:
</p>

<ul>
<li> <p><code><a href="#topic+dcomper">dcomper</a></code> Probablitiy density function, distribution, quantile function and random number generation for the composed-error distribution.
</p>
</li>
<li> <p><code><a href="#topic+dcomper_mv">dcomper_mv</a></code> Probablitiy density function, distribution, quantile function and random number generation for the multivariate composed-error distribution.
</p>
</li>
<li> <p><code><a href="#topic+dcop">dcop</a></code>  Probablitiy density function, distribution and random number generation for copulas.
</p>
</li></ul>

<p>These are written in <code>C++</code> for fast and accurate evaluation including derivatives. They may be helpful for other researchers, who want to avoid the tedious implementation.
Additionally:
</p>

<ul>
<li> <p><code><a href="#topic+cop">cop</a></code>  Object which can be used to fit a copula with the <span class="pkg">mgcv</span> package.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dsfa(
  formula,
  family = comper(link = list("identity", "logshift", "logshift"), s = -1, distr =
    "normhnorm"),
  data = list(),
  optimizer = "efs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsfa_+3A_formula">formula</code></td>
<td>
<p>A list of formulas specifying the additive predictors. See <code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code> and <code><a href="mgcv.html#topic+gam.models">gam.models</a></code> for more details.</p>
</td></tr>
<tr><td><code id="dsfa_+3A_family">family</code></td>
<td>
<p>The family object specifies the (multivariate) composed-error distribution and link of the model. See <code><a href="#topic+comper">comper</a></code> and <code><a href="#topic+comper_mv">comper_mv</a></code> for more details.</p>
</td></tr>
<tr><td><code id="dsfa_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the model response variable and covariates required by the formula. By default the variables are taken from environment(formula): typically the environment from which <code>dsfa</code> is called.</p>
</td></tr>
<tr><td><code id="dsfa_+3A_optimizer">optimizer</code></td>
<td>
<p>An array specifying the numerical optimization method to use to optimize the smoothing parameter estimation criterion (given by method). 
&quot;outer&quot; for the more stable direct approach. &quot;outer&quot; can use several alternative optimizers, specified in the second element of optimizer: &quot;newton&quot; (default), &quot;bfgs&quot;, &quot;optim&quot;, &quot;nlm&quot; and &quot;nlm.fd&quot; (the latter is based entirely on finite differenced derivatives and is very slow).
&quot;efs&quot; for the extended Fellner Schall method of Wood and Fasiolo (2017).</p>
</td></tr>
<tr><td><code id="dsfa_+3A_...">...</code></td>
<td>
<p>other parameters of <code><a href="mgcv.html#topic+gam">gam</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for <code><a href="mgcv.html#topic+gam">gam</a></code>.
</p>


<h3>Value</h3>

<p>Returns a  <code><a href="mgcv.html#topic+gam">gam</a></code> object.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Rouven Schmidt  <a href="mailto:rouven.schmidt@tu-clausthal.de">rouven.schmidt@tu-clausthal.de</a>
</p>
</li></ul>



<h3>References</h3>


<ul>
<li> <p>Schmidt R, Kneib T (2023).
&ldquo;Multivariate distributional stochastic frontier models.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, 107796.
</p>
</li>
<li> <p>Wood SN, Fasiolo M (2017).
&ldquo;A generalized Fellner-Schall method for smoothing parameter optimization with application to Tweedie location, scale and shape models.&rdquo;
<em>Biometrics</em>, <b>73</b>(4), 1071&ndash;1081.
</p>
</li>
<li> <p>Kumbhakar SC, Wang H, Horncastle AP (2015).
<em>A practitioner's guide to stochastic frontier analysis using Stata</em>.
Cambridge University Press.
</p>
</li>
<li> <p>Schmidt R, Kneib T (2020).
&ldquo;Analytic expressions for the Cumulative Distribution Function of the Composed Error Term in Stochastic Frontier Analysis with Truncated Normal and Exponential Inefficiencies.&rdquo;
<em>arXiv preprint arXiv:2006.03459</em>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
### First example with simulated data
#Set seed, sample size and type of function
set.seed(1337)
N=500 #Sample size
s=-1 #Set to production function

#Generate covariates
x1&lt;-runif(N,-1,1); x2&lt;-runif(N,-1,1); x3&lt;-runif(N,-1,1)
x4&lt;-runif(N,-1,1); x5&lt;-runif(N,-1,1)

#Set parameters of the distribution
mu=2+0.75*x1+0.4*x2+0.6*x2^2+6*log(x3+2)^(1/4) #production function parameter
sigma_v=exp(-1.5+0.75*x4) #noise parameter
sigma_u=exp(-1+sin(2*pi*x5)) #inefficiency parameter

#Simulate responses and create dataset
y&lt;-rcomper(n=N, mu=mu, sigma_v=sigma_v, sigma_u=sigma_u, s=s, distr="normhnorm")
dat&lt;-data.frame(y, x1, x2, x3, x4, x5)

#Write formulae for parameters
mu_formula&lt;-y~x1+x2+I(x2^2)+s(x3, bs="ps")
sigma_v_formula&lt;-~1+x4
sigma_u_formula&lt;-~1+s(x5, bs="ps")

#Fit model
model&lt;-dsfa(formula=list(mu_formula, sigma_v_formula, sigma_u_formula),
                 data=dat, family=comper(s=s, distr="normhnorm"), optimizer = c("efs"))

#Model summary
summary(model)

#Smooth effects
#Effect of x3 on the predictor of the production function
plot(model, select=1) #Estimated function
lines(x3[order(x3)], 6*log(x3[order(x3)]+2)^(1/4)-
        mean(6*log(x3[order(x3)]+2)^(1/4)), col=2) #True effect

#Effect of x5 on the predictor of the inefficiency
plot(model, select=2) #Estimated function
lines(x5[order(x5)], -1+sin(2*pi*x5)[order(x5)]-
        mean(-1+sin(2*pi*x5)),col=2) #True effect

### Second example with real data of production function

data("RiceFarms", package = "plm") #load data
RiceFarms[,c("goutput","size","seed", "totlabor", "urea")]&lt;-
  log(RiceFarms[,c("goutput","size","seed", "totlabor", "urea")]) #log outputs and inputs
RiceFarms$id&lt;-factor(RiceFarms$id) #id as factor

#Set to production function
s=-1 

#Write formulae for parameters
mu_formula&lt;-goutput ~  s(size, bs="ps") + s(seed, bs="ps") + #non-linear effects
  s(totlabor, bs="ps") + s(urea, bs="ps") + #non-linear effects
  varieties + #factor
  s(id, bs="re") #random effect
sigma_v_formula&lt;-~1 
sigma_u_formula&lt;-~bimas

#Fit model with normhnorm dstribution
model&lt;-dsfa(formula=list(mu_formula, sigma_v_formula, sigma_u_formula),
data=RiceFarms, family=comper(s=s, distr="normhnorm"), optimizer = "efs")

#Summary of model
summary(model)

#Plot smooths
plot(model)

### Third example with real data of cost function

data("electricity", package = "sfaR") #load data

#Log inputs and outputs as in Greene 1990 eq. 46
electricity$lcof&lt;-log(electricity$cost/electricity$fprice)
electricity$lo&lt;-log(electricity$output)
electricity$llf&lt;-log(electricity$lprice/electricity$fprice)
electricity$lcf&lt;-log(electricity$cprice/electricity$fprice)

#Set to cost function
s=1

#Write formulae for parameters
mu_formula&lt;-lcof ~ s(lo, bs="ps") + s(llf, bs="ps") + s(lcf, bs="ps") #non-linear effects
sigma_v_formula&lt;-~1
sigma_u_formula&lt;-~s(lo, bs="ps") + s(lshare, bs="ps") + s(cshare, bs="ps")

#Fit model with normhnorm dstribution
model&lt;-dsfa(formula=list(mu_formula, sigma_v_formula, sigma_u_formula),
                           data=electricity, family=comper(s=s, distr="normhnorm"),
                           optimizer = "efs")

#Summary of model
summary(model)

#Plot smooths
plot(model)

</code></pre>

<hr>
<h2 id='efficiency'>efficiency</h2><span id='topic+efficiency'></span>

<h3>Description</h3>

<p>Calculates the expected technical (in)efficiency index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiency(object, alpha = 0.05, type = "jondrow")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiency_+3A_object">object</code></td>
<td>
<p>fitted mgcv object with family <code>comper()</code> or <code>comper_mv()</code>.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_alpha">alpha</code></td>
<td>
<p>for the <code class="reqn">(1-\alpha) \cdot 100\%</code> confidence interval. Must be in (0,1).</p>
</td></tr>
<tr><td><code id="efficiency_+3A_type">type</code></td>
<td>
<p>default is &quot;jondrow&quot; for <code class="reqn">E[U|\mathcal{E}]</code>, alternatively &quot;battese&quot; for <code class="reqn">E[\exp(-U)|\mathcal{E}]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of the expected (in)efficiency estimates as well the lower and upper bound of the <code class="reqn">(1-\alpha)\cdot 100\%</code> confidence interval.
</p>


<h3>References</h3>


<ul>
<li> <p>Schmidt R, Kneib T (2023).
&ldquo;Multivariate distributional stochastic frontier models.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, 107796.
</p>
</li>
<li> <p>Kumbhakar SC, Wang H, Horncastle AP (2015).
<em>A practitioner's guide to stochastic frontier analysis using Stata</em>.
Cambridge University Press.
</p>
</li>
<li> <p>Azzalini A (2013).
<em>The skew-normal and related families</em>, volume 3.
Cambridge University Press.
</p>
</li>
<li> <p>Jondrow J, Lovell CK, Materov IS, Schmidt P (1982).
&ldquo;On the estimation of technical inefficiency in the stochastic frontier production function model.&rdquo;
<em>Journal of econometrics</em>, <b>19</b>(2-3), 233&ndash;238.
</p>
</li>
<li> <p>Battese GE, Coelli TJ (1988).
&ldquo;Prediction of firm-level technical efficiencies with a generalized frontier production function and panel data.&rdquo;
<em>Journal of econometrics</em>, <b>38</b>(3), 387&ndash;399.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#Set seed, sample size and type of function
set.seed(1337)
N=500 #Sample size
s=-1 #Set to production function

#Generate covariates
x1&lt;-runif(N,-1,1); x2&lt;-runif(N,-1,1); x3&lt;-runif(N,-1,1)
x4&lt;-runif(N,-1,1); x5&lt;-runif(N,-1,1)

#Set parameters of the distribution
mu=2+0.75*x1+0.4*x2+0.6*x2^2+6*log(x3+2)^(1/4) #production function parameter
sigma_v=exp(-1.5+0.75*x4) #noise parameter
sigma_u=exp(-1+sin(2*pi*x5)) #inefficiency parameter

y&lt;-rcomper(n=N, mu=mu, sigma_v=sigma_v, sigma_u=sigma_u, s=s, distr="normhnorm")
dat&lt;-data.frame(y, x1, x2, x3, x4, x5)

#Write formulae for parameters
mu_formula&lt;-y~x1+x2+I(x2^2)+s(x3, bs="ps")
sigma_v_formula&lt;-~1+x4
sigma_u_formula&lt;-~1+s(x5, bs="ps")

#Fit model
model&lt;-dsfa(formula=list(mu_formula, sigma_v_formula, sigma_u_formula),
                 data=dat, family=comper(s=s, distr="normhnorm"), optimizer = c("efs"))
                                   
#Estimate efficiency
efficiency(model, type="jondrow")
efficiency(model, type="battese")

</code></pre>

<hr>
<h2 id='elasticity'>elasticity</h2><span id='topic+elasticity'></span>

<h3>Description</h3>

<p>Calculates and plots the elasticity of a smooth function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elasticity(object, select = NULL, plot = TRUE, se = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elasticity_+3A_object">object</code></td>
<td>
<p>fitted mgcv object with family <code>comper()</code> or <code>comper_mv()</code>.</p>
</td></tr>
<tr><td><code id="elasticity_+3A_select">select</code></td>
<td>
<p>specifying the smooth function for which the elasticity is calculated. If <code>term=NULL</code> the elasticities for all smooths of <code class="reqn">\mu</code> are returned (excluding random and spatial effects).</p>
</td></tr>
<tr><td><code id="elasticity_+3A_plot">plot</code></td>
<td>
<p>logical; if TRUE, plots the elasticities. If FALSE, returns the average elasticity.</p>
</td></tr>
<tr><td><code id="elasticity_+3A_se">se</code></td>
<td>
<p>logical; if TRUE, adds standard errors to the plot of elasticities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the marginal product for parametric terms. For smooth terms the average of the derivative is calculated.
</p>


<h3>Value</h3>

<p>If plot is TRUE, plots the elasticities specified in select of the provided object. If plot is FALSE returns a named vector of the elasticity of the provided inputs.
</p>


<h3>References</h3>


<ul>
<li> <p>Schmidt R, Kneib T (2023).
&ldquo;Multivariate distributional stochastic frontier models.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, 107796.
</p>
</li>
<li> <p>Kumbhakar SC, Wang H, Horncastle AP (2015).
<em>A practitioner's guide to stochastic frontier analysis using Stata</em>.
Cambridge University Press.
</p>
</li>
<li> <p>Aigner D, Lovell CK, Schmidt P (1977).
&ldquo;Formulation and estimation of stochastic frontier production function models.&rdquo;
<em>Journal of econometrics</em>, <b>6</b>(1), 21&ndash;37.
</p>
</li>
<li> <p>Meeusen W, van Den Broeck J (1977).
&ldquo;Efficiency estimation from Cobb-Douglas production functions with composed error.&rdquo;
<em>International economic review</em>, 435&ndash;444.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#Set seed, sample size and type of function
set.seed(1337)
N=500 #Sample size
s=-1 #Set to production function

#Generate covariates
x1&lt;-runif(N,-1,1); x2&lt;-runif(N,-1,1); x3&lt;-runif(N,-1,1)
x4&lt;-runif(N,-1,1); x5&lt;-runif(N,-1,1)

#Set parameters of the distribution
mu=2+0.75*x1+0.4*x2+0.6*x2^2+6*log(x3+2)^(1/4) #production function parameter
sigma_v=exp(-1.5+0.75*x4) #noise parameter
sigma_u=exp(-1+sin(2*pi*x5)) #inefficiency parameter

y&lt;-rcomper(n=N, mu=mu, sigma_v=sigma_v, sigma_u=sigma_u, s=s, distr="normhnorm")
dat&lt;-data.frame(y, x1, x2, x3, x4, x5)

#Write formulae for parameters
mu_formula&lt;-y~x1+x2+I(x2^2)+s(x3, bs="ps")
sigma_v_formula&lt;-~1+x4
sigma_u_formula&lt;-~1+s(x5, bs="ps")

#Fit model
model&lt;-dsfa(formula=list(mu_formula, sigma_v_formula, sigma_u_formula),
                 data=dat, family=comper(s=s, distr="normhnorm"), optimizer = c("efs"))

#Get elasticities
elasticity(model, plot=TRUE)

</code></pre>

<hr>
<h2 id='ind2joint'>Independent to joint function</h2><span id='topic+ind2joint'></span>

<h3>Description</h3>

<p>Combines multiple derivs objects into a single derivs object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind2joint(f_list, tri_f_list, tri_h_list, deriv_order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind2joint_+3A_f_list">f_list</code></td>
<td>
<p>list of <code>derivs</code> objects of length <code class="reqn">M</code>, e.g. <code class="reqn">list(f_1(\cdot), f_2(\cdot),...,f_M(\cdot))</code></p>
</td></tr>
<tr><td><code id="ind2joint_+3A_tri_f_list">tri_f_list</code></td>
<td>
<p>list of length <code class="reqn">K</code> trind_generator objects, the <code class="reqn">kth</code> element corresponds to <code class="reqn">kth</code> derivs object.</p>
</td></tr>
<tr><td><code id="ind2joint_+3A_tri_h_list">tri_h_list</code></td>
<td>
<p>list of length <code class="reqn">K</code> trind_generator objects, the <code class="reqn">kth</code> element corresponds to a derivs object with <code class="reqn">k \cdot (k+1)/2</code> parameters.</p>
</td></tr>
<tr><td><code id="ind2joint_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">f_m</code> be a function defined in [trind()], where <code class="reqn">m \in {1,...,M}</code>.
Define <code class="reqn">h((x_{n1},x_{n2},...,x_{nK})) = (f_1(x_{n1}), f_2(x_{n2}), ... ,f_M(x_{nK}))</code>.
In order to get the derivatives of <code class="reqn">h(\cdot)</code> w.r.t all parameters <code class="reqn">x_{nk}</code>, the independent functions are combined.
For more details see [trind()] and [trind_generator()].
</p>


<h3>Value</h3>

<p>Returns a derivs object.
</p>


<h3>See Also</h3>

<p>Other derivs: 
<code><a href="#topic+chainrule">chainrule</a>()</code>,
<code><a href="#topic+derivs_transform">derivs_transform</a>()</code>,
<code><a href="#topic+differencerule">differencerule</a>()</code>,
<code><a href="#topic+list2derivs">list2derivs</a>()</code>,
<code><a href="#topic+productrule">productrule</a>()</code>,
<code><a href="#topic+quotientrule">quotientrule</a>()</code>,
<code><a href="#topic+sumrule">sumrule</a>()</code>,
<code><a href="#topic+trind_generator">trind_generator</a>()</code>,
<code><a href="#topic+trind">trind</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1:9)/10, ncol=1)
A_derivs&lt;-list2derivs(list(A, A^0, A^2, A^3, A^4), deriv_order=4)
B_derivs&lt;-transform(A, type="exp", par=0, deriv_order=4)
ind2joint (list(A_derivs,B_derivs),
           list(trind_generator(1),trind_generator(1)),
           list(trind_generator(1),trind_generator(1+1)), 4)

</code></pre>

<hr>
<h2 id='list2derivs'>list2derivs</h2><span id='topic+list2derivs'></span>

<h3>Description</h3>

<p>Transforms a list of matrices d0, d1, d2, d3, d4 to a <code>derivs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2derivs(f, deriv_order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2derivs_+3A_f">f</code></td>
<td>
<p>list of matrices; d0, d1, d2, d3, d4</p>
</td></tr>
<tr><td><code id="list2derivs_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mostly internal function. Returns an object of class <code>derivs</code>
For more details see [trind()] and [trind_generator()].
</p>


<h3>See Also</h3>

<p>Other derivs: 
<code><a href="#topic+chainrule">chainrule</a>()</code>,
<code><a href="#topic+derivs_transform">derivs_transform</a>()</code>,
<code><a href="#topic+differencerule">differencerule</a>()</code>,
<code><a href="#topic+ind2joint">ind2joint</a>()</code>,
<code><a href="#topic+productrule">productrule</a>()</code>,
<code><a href="#topic+quotientrule">quotientrule</a>()</code>,
<code><a href="#topic+sumrule">sumrule</a>()</code>,
<code><a href="#topic+trind_generator">trind_generator</a>()</code>,
<code><a href="#topic+trind">trind</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1:9)/10, ncol=3)
list2derivs(list(A, A^0, A^2, A^3, A^4), deriv_order=4)

</code></pre>

<hr>
<h2 id='manuf'>NBER-CES Manufacturing Dairy Data</h2><span id='topic+manuf'></span>

<h3>Description</h3>

<p>Dataset of the National Bureau of Economic Research (NBER) and U.S. Census Bureau's Center for Economic Studies (CES). It contains information on the annual industry-level from 1958-2016 of the US.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manuf
</code></pre>


<h3>Format</h3>

<p>manuf is a data frame with 6188 rows and 7 columns:
</p>

<dl>
<dt>naics</dt><dd><p>NAICS 2012 6-digit industry code</p>
</dd>
<dt>year</dt><dd><p>Year from 2000 to 2016</p>
</dd>
<dt>Y</dt><dd><p>Total value of shipments in millions of 2012 dollars</p>
</dd>
<dt>K</dt><dd><p>Real capital stock in millions of 2012 dollars</p>
</dd>
<dt>L</dt><dd><p>Production worker hours in millions</p>
</dd>
<dt>M</dt><dd><p>Total cost of materials  in millions of 2012 dollars</p>
</dd>
<dt>I</dt><dd><p>New capital spending in millions of 2012 dollars</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a subset of the data which contains data from 2000-2016 on output, employment, materials, investment and capital stocks.
</p>


<h3>Source</h3>

<p>&lt;https://www.nber.org/research/data/nber-ces-manufacturing-industry-database&gt;
</p>


<h3>References</h3>

<p>Bartlesman E, Gray WB (1996).
&ldquo;The NBER manufacturing productivity database.&rdquo;
</p>

<hr>
<h2 id='mom2par'>Moments to Parameters</h2><span id='topic+mom2par'></span>

<h3>Description</h3>

<p>Calculates the parameters of composed-error distribution based on the provided moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mom2par(mean = 0, sd = 1, skew = 0, s = -1, distr = "normhnorm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mom2par_+3A_mean">mean</code></td>
<td>
<p>numeric vector of means.</p>
</td></tr>
<tr><td><code id="mom2par_+3A_sd">sd</code></td>
<td>
<p>numeric vector of standard deviations. Must be positive.</p>
</td></tr>
<tr><td><code id="mom2par_+3A_skew">skew</code></td>
<td>
<p>numeric vector of skewness. <code>s*skew</code> must be positive.</p>
</td></tr>
<tr><td><code id="mom2par_+3A_s">s</code></td>
<td>
<p>integer; <code class="reqn">s=-1</code> for production and <code class="reqn">s=1</code> for cost function.</p>
</td></tr>
<tr><td><code id="mom2par_+3A_distr">distr</code></td>
<td>
<p>string; determines the distribution:<br />
'normhnorm', Normal-halfnormal distribution <br />
'normexp', Normal-exponential distribution <br /></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+dcomper">dcomper</a></code> for details of the distribution. For the inverse transformation see <code><a href="#topic+par2mom">par2mom</a></code>.
</p>


<h3>Value</h3>

<p>Returns a matrix where the first column corresponds to <code class="reqn">\mu</code>, the second to <code class="reqn">\sigma_V</code> and the third to <code class="reqn">\sigma_U</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mom2par(mean=0, sd=1, skew=-0.5, s=-1, distr="normhnorm")
mom2par(mean=0, sd=1, skew=-1, s=-1, distr="normexp")

</code></pre>

<hr>
<h2 id='par2mom'>Parameter to Moments</h2><span id='topic+par2mom'></span>

<h3>Description</h3>

<p>Calculates the moments of composed-error distribution based on the provided parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par2mom(mu = 0, sigma_v = 1, sigma_u = 1, s = -1, distr = "normhnorm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par2mom_+3A_mu">mu</code></td>
<td>
<p>numeric vector of <code class="reqn">\mu</code>.</p>
</td></tr>
<tr><td><code id="par2mom_+3A_sigma_v">sigma_v</code></td>
<td>
<p>numeric vector of <code class="reqn">\sigma_V</code>. Must be positive.</p>
</td></tr>
<tr><td><code id="par2mom_+3A_sigma_u">sigma_u</code></td>
<td>
<p>numeric vector of <code class="reqn">\sigma_U</code>. Must be positive.</p>
</td></tr>
<tr><td><code id="par2mom_+3A_s">s</code></td>
<td>
<p>integer; <code class="reqn">s=-1</code> for production and <code class="reqn">s=1</code> for cost function.</p>
</td></tr>
<tr><td><code id="par2mom_+3A_distr">distr</code></td>
<td>
<p>string; determines the distribution:<br />
'normhnorm', Normal-halfnormal distribution <br />
'normexp', Normal-exponential distribution <br /></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+dcomper">dcomper</a></code> for details of the distribution. For the inverse transformation see <code><a href="#topic+mom2par">mom2par</a></code>.
</p>


<h3>Value</h3>

<p>Returns a matrix where the first column corresponds to the mean, the second to the standard deviation and the third to the skewness.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par2mom(mu=0, sigma_v=1, sigma_u=1, s=-1, distr="normhnorm")
par2mom(mu=0, sigma_v=1, sigma_u=1, s=-1, distr="normexp")

</code></pre>

<hr>
<h2 id='productrule'>Productrule</h2><span id='topic+productrule'></span>

<h3>Description</h3>

<p>Productrule for derivs objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>productrule(f_list, tri, deriv_order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="productrule_+3A_f_list">f_list</code></td>
<td>
<p>list of <code>derivs</code> objects of length <code class="reqn">M</code>, e.g. <code class="reqn">list(f_1(\cdot), f_2(\cdot),...,f_M(\cdot))</code></p>
</td></tr>
<tr><td><code id="productrule_+3A_tri">tri</code></td>
<td>
<p>list; created by the function [trind_generator()].</p>
</td></tr>
<tr><td><code id="productrule_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">f_m</code> be a function defined in [trind()], where <code class="reqn">m \in {1,...,M}</code>.
Define <code class="reqn">h((x_{n1},x_{n2},...,x_{nK})) = f_1(\cdot) \cdot f_2(\cdot) ... \cdot f_M(x_{n1},x_{n2},...,x_{nK}))</code>.
In order to get the derivatives of <code class="reqn">h(\cdot)</code> w.r.t all parameters <code class="reqn">x_{nk}</code>, the productrule is applied.
For more details see [trind()] and [trind_generator()].
</p>


<h3>Value</h3>

<p>Returns an object of class <code>derivs</code> for the function <code class="reqn">h(\cdot)</code>.
</p>


<h3>See Also</h3>

<p>Other derivs: 
<code><a href="#topic+chainrule">chainrule</a>()</code>,
<code><a href="#topic+derivs_transform">derivs_transform</a>()</code>,
<code><a href="#topic+differencerule">differencerule</a>()</code>,
<code><a href="#topic+ind2joint">ind2joint</a>()</code>,
<code><a href="#topic+list2derivs">list2derivs</a>()</code>,
<code><a href="#topic+quotientrule">quotientrule</a>()</code>,
<code><a href="#topic+sumrule">sumrule</a>()</code>,
<code><a href="#topic+trind_generator">trind_generator</a>()</code>,
<code><a href="#topic+trind">trind</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1:9)/10, ncol=1)
A_derivs&lt;-list2derivs(list(A, A^0, A^2, A^3, A^4), deriv_order=2)
B_derivs&lt;-derivs_transform(A, type="inv", par=0,  trind_generator(1), deriv_order=2)
productrule (list(A_derivs, B_derivs), trind_generator(1), deriv_order=2) #identity

</code></pre>

<hr>
<h2 id='quotientrule'>Quotientrule</h2><span id='topic+quotientrule'></span>

<h3>Description</h3>

<p>Quotientrule for derivs objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quotientrule(f_list, tri, deriv_order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quotientrule_+3A_f_list">f_list</code></td>
<td>
<p>list of <code>derivs</code> objects of length <code class="reqn">M</code>, e.g. <code class="reqn">list(f_1(\cdot), f_2(\cdot),...,f_M(\cdot))</code></p>
</td></tr>
<tr><td><code id="quotientrule_+3A_tri">tri</code></td>
<td>
<p>list; created by the function [trind_generator()].</p>
</td></tr>
<tr><td><code id="quotientrule_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">f_m</code> be a function defined in [trind()], where <code class="reqn">m \in {1,...,M}</code>.
Define <code class="reqn">h((x_{n1},x_{n2},...,x_{nK})) = f_1(\cdot) / f_2(\cdot) ... / f_M(x_{n1},x_{n2},...,x_{nK}))</code>.
In order to get the derivatives of <code class="reqn">h(\cdot)</code> w.r.t all parameters <code class="reqn">x_{nk}</code>, the quotientrule is applied.
For more details see [trind()] and [trind_generator()].The values of the <code>derivs</code> objects must be positive.
Numerically not precise, but included for  reasons of completeness.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>derivs</code> for the function <code class="reqn">h(\cdot)</code>.
</p>


<h3>See Also</h3>

<p>Other derivs: 
<code><a href="#topic+chainrule">chainrule</a>()</code>,
<code><a href="#topic+derivs_transform">derivs_transform</a>()</code>,
<code><a href="#topic+differencerule">differencerule</a>()</code>,
<code><a href="#topic+ind2joint">ind2joint</a>()</code>,
<code><a href="#topic+list2derivs">list2derivs</a>()</code>,
<code><a href="#topic+productrule">productrule</a>()</code>,
<code><a href="#topic+sumrule">sumrule</a>()</code>,
<code><a href="#topic+trind_generator">trind_generator</a>()</code>,
<code><a href="#topic+trind">trind</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1:9)/10, ncol=1)
A_derivs&lt;-list2derivs(list(A, A^0, A^2, A^3, A^4), deriv_order=2)
B_derivs&lt;-derivs_transform(A, type="inv", par=0,  trind_generator(1), deriv_order=2)
quotientrule (list(A_derivs, B_derivs), trind_generator(1), deriv_order=2) #A/(1/A)=A^2

</code></pre>

<hr>
<h2 id='sumrule'>Sumrule</h2><span id='topic+sumrule'></span>

<h3>Description</h3>

<p>Sumrule for derivs objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumrule(f_list, tri, deriv_order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumrule_+3A_f_list">f_list</code></td>
<td>
<p>list of <code>derivs</code> objects of length <code class="reqn">M</code>, e.g. <code class="reqn">list(f_1(\cdot), f_2(\cdot),...,f_M(\cdot))</code></p>
</td></tr>
<tr><td><code id="sumrule_+3A_tri">tri</code></td>
<td>
<p>list; created by the function [trind_generator()].</p>
</td></tr>
<tr><td><code id="sumrule_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">f_m</code> be a function defined in [trind()], where <code class="reqn">m \in {1,...,M}</code>.
Define <code class="reqn">h((x_{n1},x_{n2},...,x_{nK})) = f_1(\cdot) + f_2(\cdot) ... + f_M(x_{n1},x_{n2},...,x_{nK}))</code>.
In order to get the derivatives of <code class="reqn">h(\cdot)</code> w.r.t all parameters <code class="reqn">x_{nk}</code>, the sumrule is applied.
For more details see [trind()] and [trind_generator()].
</p>


<h3>Value</h3>

<p>Returns an object of class <code>derivs</code> for the function <code class="reqn">h(\cdot)</code>.
</p>


<h3>See Also</h3>

<p>Other derivs: 
<code><a href="#topic+chainrule">chainrule</a>()</code>,
<code><a href="#topic+derivs_transform">derivs_transform</a>()</code>,
<code><a href="#topic+differencerule">differencerule</a>()</code>,
<code><a href="#topic+ind2joint">ind2joint</a>()</code>,
<code><a href="#topic+list2derivs">list2derivs</a>()</code>,
<code><a href="#topic+productrule">productrule</a>()</code>,
<code><a href="#topic+quotientrule">quotientrule</a>()</code>,
<code><a href="#topic+trind_generator">trind_generator</a>()</code>,
<code><a href="#topic+trind">trind</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1:9)/10, ncol=1)
A_derivs&lt;-list2derivs(list(A, A^0, A^2, A^3, A^4), deriv_order=4)
sumrule(list(A_derivs, A_derivs), trind_generator(1), deriv_order=4) #equal to 2*A_derivs

</code></pre>

<hr>
<h2 id='transform'>transform</h2><span id='topic+transform'></span>

<h3>Description</h3>

<p>Transforms a matrix via the specified function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform(x, type, par, deriv_order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_+3A_x">x</code></td>
<td>
<p>numeric matrix to be transformed.</p>
</td></tr>
<tr><td><code id="transform_+3A_type">type</code></td>
<td>
<p>string, specifies the transformation function. Available are:
</p>

<ol>
<li><p>  'identity': <code class="reqn">f(x)=x</code>.
</p>
</li>
<li><p>  'exp': <code class="reqn">f(x)=\exp\{x\}</code>.
</p>
</li>
<li><p>  'log': <code class="reqn">f(x)=\log\{x\}</code>.
</p>
</li>
<li><p>  'glogit': <code class="reqn">f(x)=\log\{(-x + min)/(x - max)</code>, where <code>par=c(min, max)</code>.
</p>
</li>
<li><p>  'glogitinv': <code class="reqn">f(x)=\exp\{x\} \cdot (max + min)/(1 + \exp\{x\}) </code>, where <code>par=c(min, max)</code>.
</p>
</li>
<li><p>  'inv': <code class="reqn">f(x)=\frac{1}{x}</code>.
</p>
</li>
<li><p>  'pnorm': <code class="reqn">f(x)=\Phi(x)</code>.
</p>
</li>
<li><p>  'qnorm': <code class="reqn">f(x)=\Phi^{-1}(x)</code>.
</p>
</li>
<li><p>  'mexp': <code class="reqn">f(x)=-\exp\{x\}</code>.
</p>
</li>
<li><p>  'zeta': <code class="reqn">f(x)=\log\{2 \cdot \Phi(x)\}</code>.
</p>
</li>
<li><p>  'constant': <code class="reqn">f(x)=c</code>.
</p>
</li>
<li><p>  'chainrule_utility': <code class="reqn">f(x)=f'(x)=f''(x)=f'''(x)=f''''(x)</code>.
</p>
</li>
<li><p>   onemx: <code class="reqn">1-x</code>
</p>
</li></ol>
</td></tr>
<tr><td><code id="transform_+3A_par">par</code></td>
<td>
<p>numeric vector, additional parameters, e.g. min and max for <code>glogit</code>.</p>
</td></tr>
<tr><td><code id="transform_+3A_deriv_order">deriv_order</code></td>
<td>
<p>integer; maximum order of derivative. Available are <code>0</code>,<code>2</code> and <code>4</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes the numeric matrix x as an input for the function specified by <code>type</code> and evaluates it together with the derivatives.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>derivs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1:9)/10, ncol=3)
A_mat&lt;-list2derivs(list(A, A^0, A^2, A^3, A^4), deriv_order=4)
transform(x=transform(x = A, type="exp", par=0, deriv_order=4), type="log", deriv_order=4, par = 0)

</code></pre>

<hr>
<h2 id='trind'>trind function</h2><span id='topic+trind'></span>

<h3>Description</h3>

<p>Provides the column index of the required derivative for the specified order of a <code>derivs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trind(tri, part_deriv_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trind_+3A_tri">tri</code></td>
<td>
<p>list; created by the function [trind_generator()].</p>
</td></tr>
<tr><td><code id="trind_+3A_part_deriv_var">part_deriv_var</code></td>
<td>
<p>integer vector; specifies <code class="reqn">\frac{\partial^J f(\cdot)}{\partial x_{ni_1} ... \partial x_{ni_J}}</code>.
The length of the vector is denoted as <code class="reqn">J</code> and determines the order of the partial derivatives with maximum four. The element <code class="reqn">i_j \in \{0,...,K-1\}</code>  
specifies the variable with respect to which the derivative is taken, where <code class="reqn">j \in \{1,...,J\}</code>, The order corresponds to the order of derivatives.
For example <code>c(0,0,1,2)</code> is equal to <code class="reqn">\frac{\partial^4 f(\cdot)}{\partial x_{n1} \partial x_{n1} \partial x_{n2} \partial x_{n3}}</code>.
See details for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">f:\mathbb{R}^K -&gt; \mathbb{R}^L, (x_{n1},x_{n2},...,x_{nK}) -&gt; f(x_{n1},x_{n2},...,x_{nK})</code> be differentiable up to order four w.r.t all parameters <code class="reqn">x_{nk}</code>, where <code class="reqn">k \in \{1,...,K\}</code> and <code class="reqn">n \in \{1,...,N\}</code>.
Then a <code>derivs</code> class object is a numeric matrix with <code class="reqn">N</code> rows and <code class="reqn">L</code> columns. <code class="reqn">N</code> is the length  of the input vectors. Further, it has the following attributes:
</p>

<ol>
<li><p>  'd1': a numeric matrix of the first derivatives w.r.t all parameters,
where the <code class="reqn">nth</code> row  corresponds to: <code class="reqn">(\frac{\partial   f(\cdot)}{\partial x_{n1}}, \frac{\partial f(\cdot)}{\partial x_{n1}},...,\frac{\partial f(\cdot)}{\partial x_{nK}})</code>
</p>
</li>
<li><p>  'd2': a numeric matrix of the second derivatives w.r.t all parameters,
where the <code class="reqn">nth</code> row  corresponds to: <code class="reqn">(\frac{\partial^2 f(\cdot)}{\partial x_{n1} \partial x_{n1}}, \frac{\partial^2 f(\cdot)}{\partial x_{n1} \partial x_{n2}},...,\frac{\partial^2 f(\cdot)}{\partial x_{nK} \partial x_{nK}})</code>
</p>
</li>
<li><p>  'd3': a numeric matrix of the third derivatives w.r.t all parameters,
where the <code class="reqn">nth</code> row  corresponds to: <code class="reqn">(\frac{\partial^3 f(\cdot)}{\partial x_{n1} \partial x_{n1} \partial x_{n1}}, \frac{\partial^3 f(\cdot)}{\partial x_{n1} \partial x_{n1} \partial x_{n2}},...,\frac{\partial^3 f(\cdot)}{\partial x_{nK} \partial x_{nK} \partial x_{nK}})</code>
</p>
</li>
<li><p>  'd4': a numeric matrix of the fourth derivatives w.r.t all parameters,
where the <code class="reqn">nth</code> row  corresponds to: <code class="reqn">(\frac{\partial^4 f(\cdot)}{\partial x_{n1} \partial x_{n1} \partial x_{n1} \partial x_{n1}}, \frac{\partial^4 f(\cdot)}{\partial x_{n1} \partial x_{n1} \partial x_{n1} \partial x_{n2}},...,\frac{\partial^4 f(\cdot)}{\partial x_{nK} \partial x_{nK} \partial x_{nK} \partial x_{nK}})</code>
</p>
</li></ol>

<p>The function <code>trind()</code> provides the index for the corresponding derivatives. The <code>derivs</code> class object allows for a modular system which can be easily extended and is faster than numerical derivatives.
The advantage compared to analytical derivatives provided by 'mathematica' or <code><a href="stats.html#topic+deriv">deriv()</a></code> is that asymptotics and approximations can be used for individual parts.
Handwritten derivatives can be tedious at times and may be prone to errors. Thus, the <code>derivs</code> class object can be used by lazy users.
Mainly intended for internal use.
</p>


<h3>Value</h3>

<p>Integer, the index for a derivs object.
</p>


<h3>See Also</h3>

<p>Other derivs: 
<code><a href="#topic+chainrule">chainrule</a>()</code>,
<code><a href="#topic+derivs_transform">derivs_transform</a>()</code>,
<code><a href="#topic+differencerule">differencerule</a>()</code>,
<code><a href="#topic+ind2joint">ind2joint</a>()</code>,
<code><a href="#topic+list2derivs">list2derivs</a>()</code>,
<code><a href="#topic+productrule">productrule</a>()</code>,
<code><a href="#topic+quotientrule">quotientrule</a>()</code>,
<code><a href="#topic+sumrule">sumrule</a>()</code>,
<code><a href="#topic+trind_generator">trind_generator</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tri=trind_generator(3)
trind(tri, c(2,1))

</code></pre>

<hr>
<h2 id='trind_generator'>Trind_generator function</h2><span id='topic+trind_generator'></span>

<h3>Description</h3>

<p>Generates index matrices for upper triangular storage up to order four.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trind_generator(K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trind_generator_+3A_k">K</code></td>
<td>
<p>integer; determines the number of parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful when working with higher order derivatives, which generate symmetric arrays. Mainly intended for internal use. Similar to 'mgcv::trind.generator'. Mostly internal function.
</p>


<h3>Value</h3>

<p>Returns a list with index matrices for the first to fourth derivative, which can be accessed via the function [trind()].
The numerical vectors <code>i_start</code> and <code>i_end</code> hold the starting and ending indexes, which are required by [trind()] for derivatives greater than two.
</p>


<h3>See Also</h3>

<p>Other derivs: 
<code><a href="#topic+chainrule">chainrule</a>()</code>,
<code><a href="#topic+derivs_transform">derivs_transform</a>()</code>,
<code><a href="#topic+differencerule">differencerule</a>()</code>,
<code><a href="#topic+ind2joint">ind2joint</a>()</code>,
<code><a href="#topic+list2derivs">list2derivs</a>()</code>,
<code><a href="#topic+productrule">productrule</a>()</code>,
<code><a href="#topic+quotientrule">quotientrule</a>()</code>,
<code><a href="#topic+sumrule">sumrule</a>()</code>,
<code><a href="#topic+trind">trind</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tri&lt;-trind_generator(3)
tri_mgcv&lt;-mgcv::trind.generator(3)

for(i in 1:3){
  print(i==trind(tri, part_deriv_var=c(i)-1)+1)
  for(j in i:3){
    print(tri_mgcv$i2[i,j]==trind(tri, part_deriv_var=c(i,j)-1)+1)
    for(k in j:3){
      print(tri_mgcv$i3[i,j,k]==trind(tri, part_deriv_var=c(i,j,k)-1)+1)
      for(l in k:3){
        print(tri_mgcv$i4[i,j,k,l]==trind(tri, part_deriv_var=c(i,j,k,l)-1)+1)
      } 
    } 
  }
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
