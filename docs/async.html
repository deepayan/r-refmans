<!DOCTYPE html><html><head><title>Help for package async</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {async}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#async-package'><p>The async package.</p></a></li>
<li><a href='#async'><p>Create an asynchronous task from sequential code.</p></a></li>
<li><a href='#awaitNext'><p>Wait for the next value from a channel or stream.</p></a></li>
<li><a href='#channel'><p>An object representing a sequence of future values.</p></a></li>
<li><a href='#combine'><p>Combine several channels into one.</p></a></li>
<li><a href='#debugAsync'><p>Toggle single-step debugging for a coroutine.</p></a></li>
<li><a href='#delay'><p>Asynchronous pause.</p></a></li>
<li><a href='#format.coroutine'><p>Query / display coroutine properties and state.</p></a></li>
<li><a href='#gather'><p>Collect iterator / channel items into a vector.</p></a></li>
<li><a href='#gen'><p>Create an iterator using sequential code.</p></a></li>
<li><a href='#goto'><p>Coroutine switch with delimited goto.</p></a></li>
<li><a href='#graphAsync'><p>Draw a graph representation of a coroutine.</p></a></li>
<li><a href='#nextThen'><p>Receive values from channels by callback.</p></a></li>
<li><a href='#pausables'><p>Pausable functions.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#run'><p>Execute a generator expression immediately, collecting yielded values.</p></a></li>
<li><a href='#stream'><p>Create an asynchronous iterator by writing sequential code.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Coroutines: Generators / Yield, Async / Await, and Streams</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-24</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://crowding.github.io/async/">https://crowding.github.io/async/</a>,
<a href="https://github.com/crowding/async/">https://github.com/crowding/async/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/crowding/async/issues">https://github.com/crowding/async/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Write sequential-looking code that pauses and resumes.
             gen() creates a generator, an iterator that returns a
             value and pauses each time it reaches a yield() call.
             async() creates a promise, which runs until it reaches
             a call to await(), then resumes when information is available.
             These work similarly to generator and async constructs
             from 'Python' or 'JavaScript'. Objects produced are
             compatible with the 'iterators' and 'promises' packages.
             Version 0.3 supports on.exit, single-step debugging,
             stream() for making asynchronous iterators, and
             delimited goto() in switch() calls.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>iterors, nseval (&ge; 0.4.3), later, promises, testthat (&ge;
3.0.0), stringr, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, dplyr, curl, audio, profvis, ggplot2, XML</td>
</tr>
<tr>
<td>Collate:</td>
<td>'async-package.R' 'util.R' 'cps.R' 'signals.R' 'syntax.R'
'coroutine.R' 'pump.R' 'run.R' 'gen.R' 'async.R' 'channel.R'
'stream.R' 'collect.R' 'all_names.R' 'walk.R' 'all_indices.R'
'graph.R' 'trans.R' 'munge.R' 'inline.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-25 22:42:49 UTC; peter</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Meilstrup [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Meilstrup &lt;peter.meilstrup@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-25 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='async-package'>The async package.</h2><span id='topic+async-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>The <code>async</code> package allows you to write sequential-looking code
that can pause, return control to R, then pick up where it left
off.  Async constructs include generators, async/await blocks, and
streams (experimental as of async 0.3).
</p>


<h3>Details</h3>

<p>A generator runs until it yields a value and then stops, returning
control to R until another value is requested. An async block can
pause and return control to R until some data is available, then
resume. Generators implement the <a href="#topic+iteror">iteror</a> interface (which is
back-compatible with <a href="iterators.html#topic+iterators-package">iterator</a>
package.) Async blocks implement the <a href="promises.html#topic+promise">promise</a>
interface. The new <a href="#topic+stream">stream</a> construct implements the <a href="#topic+channel">channel</a>
interface, which is defined in this package.
</p>

<ul>
<li> <p><code><a href="#topic+gen">gen(...)</a></code> creates a generator (an iterator); within a generator use
<code><a href="#topic+yield">yield(x)</a></code> to return a value.
</p>
</li>
<li> <p><code><a href="#topic+async">async(...)</a></code> creates an async block (a promise); within the <code>async</code>
write <code><a href="#topic+await">await(x)</a></code> to pause on <code>x</code> (another promise).
</p>
</li>
<li> <p><code><a href="#topic+stream">stream(...)</a></code> creates a stream (an asynchronous iterator or
<a href="#topic+channel">channel</a>); in writing a <code>stream</code> you can use both <code>await</code> and <code>yield</code>.)
</p>
</li></ul>

<p>Theare are some global package <a href="base.html#topic+options">options</a>:
</p>
<p><code>async.verbose</code>: (default FALSE) if TRUE, coroutines will print an extremely
chatty play-by-play of what they are doing.
<code>async.compileLevel</code>: (0) Default compile level for new coroutines. See
description of levels under <a href="#topic+gen">gen</a>.
<code>async.paranoid</code>: (FALSE) If true, perform various time-consuming integrity
checks on the results of compilation. Meant to be enabled during certain
package tests.
<code>async.destructive</code>: (TRUE) If true, tear down interpreted coroutines
while building compiled replacements.
<code>async.sendLater</code>: (TRUE) If true, channels will send messages to listeners
in the event loop. If false, messages are sent immediately, which may be
faster but may have a higher risk of stack overflow, as well as expose
different sorts of bugs in your code.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://crowding.github.io/async/">https://crowding.github.io/async/</a>
</p>
</li>
<li> <p><a href="https://github.com/crowding/async/">https://github.com/crowding/async/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/crowding/async/issues">https://github.com/crowding/async/issues</a>
</p>
</li></ul>


<hr>
<h2 id='async'>Create an asynchronous task from sequential code.</h2><span id='topic+async'></span><span id='topic+await'></span>

<h3>Description</h3>

<p><code>async({...})</code>, with an expression written in its argument, allows
that expression to be evaluated in an asynchronous, or non-blocking
manner. <code>async</code> returns an object with class <code>c("async", "promise")</code> which
implements the <a href="promises.html#topic+promise">promise</a> interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>async(
  expr,
  ...,
  split_pipes = TRUE,
  compileLevel = getOption("async.compileLevel"),
  debugR = FALSE,
  debugInternal = FALSE,
  trace = getOption("async.verbose")
)

await(prom, error)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="async_+3A_expr">expr</code></td>
<td>
<p>An expression, to be executed asynchronously.</p>
</td></tr>
<tr><td><code id="async_+3A_...">...</code></td>
<td>
<p>Undocumented.</p>
</td></tr>
<tr><td><code id="async_+3A_split_pipes">split_pipes</code></td>
<td>
<p>Rewrite chained calls that use <code>await</code> (see
below)</p>
</td></tr>
<tr><td><code id="async_+3A_compilelevel">compileLevel</code></td>
<td>
<p>Compilation level; same options as for <a href="#topic+gen">gen</a>.</p>
</td></tr>
<tr><td><code id="async_+3A_debugr">debugR</code></td>
<td>
<p>Set TRUE to enter the browser immediately on
executing the first R expression.</p>
</td></tr>
<tr><td><code id="async_+3A_debuginternal">debugInternal</code></td>
<td>
<p>Set TRUE to single-step at implementation
level, immediately upon execution.</p>
</td></tr>
<tr><td><code id="async_+3A_trace">trace</code></td>
<td>
<p>Enable verbose logging by passing a function to
<code>trace</code>, like <code>trace=cat</code>. This function should take a character
argument.</p>
</td></tr>
<tr><td><code id="async_+3A_prom">prom</code></td>
<td>
<p>A promise, or something that can be converted to such
by <code><a href="promises.html#topic+is.promise">promises::as.promise()</a></code>.</p>
</td></tr>
<tr><td><code id="async_+3A_error">error</code></td>
<td>
<p>This argument will be forced if the promise rejects.  If
it is a function, it will be called with the error condition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An example Shiny app using <code>async/await</code> is on Github:
<a href="https://github.com/crowding/cranwhales-await">https://github.com/crowding/cranwhales-await</a>
</p>
<p>When an <code>async</code> object is activated, it will evaluate its expression
until it reaches the keyword <code>await</code>. The <code>async</code> object will return
to its caller and preserve the partial state of its evaluation.
When the awaited promise is resolved, evaluation continues from where
the <code>async</code> left off.
</p>
<p>When an async block finishes (either by reaching the end, or using
<code>return()</code>), the promise resolves with the resulting value. If the
async block stops with an error, the promise is rejected with
that error.
</p>
<p>Async blocks and generators are conceptually related and share much
of the same underlying mechanism. You can think of one as &quot;output&quot;
and the other as &quot;input&quot;. A generator pauses until a value is
requested, runs until it has a value to output, then pauses again.
An async runs until it requires an external value, pauses until
it receives the value, then continues.
</p>
<p>The syntax rules for an <code>async</code> are analogous to those for <code><a href="#topic+gen">gen()</a></code>;
<code>await</code> must appear only within the arguments of functions for
which there is a pausable implementation (See <code style="white-space: pre;">&#8288;[pausables()]&#8288;</code>). For
<code>async</code> the default <code>split_pipes=TRUE</code> is enabled; this will
rearrange some expressions to satisfy this requirement.
</p>
<p>When <code>split_pipes=FALSE</code>, <code>await()</code> can only appear in the
arguments of <a href="#topic+pausables">pausables</a> and not ordinary R functions.  This is an
inconvenience as it prevents using <code>await()</code> in a pipeline. With
<code>split_pipes=TRUE</code> applies some syntactic sugar: if an <code>await()</code>
appears in the leftmost, unnamed, argument of an R function, the
pipe will be &quot;split&quot; at that call using a temporary variable. For
instance, either
</p>
<div class="sourceCode"><pre>async(makeRequest() |&gt; await() |&gt; sort())
</pre></div>
<p>or, equivalently,
</p>
<div class="sourceCode"><pre>async(sort(await(makeRequest())))
</pre></div>
<p>will be effectively rewritten to something like
</p>
<div class="sourceCode"><pre>async({.tmp &lt;- await(makeRequest()); sort(.tmp)})
</pre></div>
<p>This works only so long as <code>await</code> appears in calls that evaluate
their leftmost arguments normally. <code>split_pipes</code> can backfire if
the outer call has other side effects; for instance
<code>suppressWarnings(await(x))</code> will be rewritten as <code>{.tmp &lt;- await(x); suppressWarnings(x)}</code>, which would defeat the purpose.
</p>
<p>If <code>async</code> is given a function expression, like <code>async(function(...) ...)</code>, it will return an &quot;async function&quot; i.e. a function that
constructs an async.
</p>


<h3>Value</h3>

<p><code>async()</code> returns an object with class &quot;promise,&quot; as
defined by the <a href="base.html#topic+promises">promises</a> package (i.e., rather than the kind of
promise used in R's lazy evaluation.)
</p>
<p>In the context of an <code>async</code> or <code>stream</code>, <code>await(x)</code> returns
the resolved value of a promise <code>x</code>, or stops with an error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myAsync &lt;- async(for (i in 1:4) {
  await(delay(5))
  cat(i, "\n")
})

</code></pre>

<hr>
<h2 id='awaitNext'>Wait for the next value from a channel or stream.</h2><span id='topic+awaitNext'></span>

<h3>Description</h3>

<p><code>awaitNext</code> can be used within an <a href="#topic+async">async</a> or <a href="#topic+stream">stream</a> coroutine.
When reached, <code>awaitNext</code> will register to receive the next element
from an async or a coroutine object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awaitNext(strm, or, err)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="awaitNext_+3A_strm">strm</code></td>
<td>
<p>A <a href="#topic+channel">channel</a> or <a href="#topic+stream">stream</a> object.</p>
</td></tr>
<tr><td><code id="awaitNext_+3A_or">or</code></td>
<td>
<p>This argument will be evaluated and returned in the case
the channel closes. If not specified, awaiting on a closed stream
will raise an error with message &quot;StopIteration&quot;.</p>
</td></tr>
<tr><td><code id="awaitNext_+3A_err">err</code></td>
<td>
<p>A function to be called if the channel throws an error
condition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the context of an <code>async</code> or <code>stream</code>, <code>awaitNext(x)</code>
returns the resolved value of a promise <code>x</code>, or stops with an
error.
</p>

<hr>
<h2 id='channel'>An object representing a sequence of future values.</h2><span id='topic+channel'></span><span id='topic+channel.function'></span><span id='topic+is.channel'></span>

<h3>Description</h3>

<p>A <code>channel</code> is an object that represents a sequence of values yet
to be determined. It is something like a combination of a <a href="base.html#topic+promise">promise</a>
and an <a href="#topic+iteror">iteror</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>channel(obj, ...)

## S3 method for class ''function''
channel(
  obj,
  ...,
  max_queue = 500L,
  max_awaiting = 500L,
  wakeup = function(...) NULL
)

is.channel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="channel_+3A_obj">obj</code></td>
<td>
<p>A user-provided function; it will receive three
callback functions as arguments, in order, <code>emit(val)</code>,
<code>reject(err)</code> and <code>close()</code></p>
</td></tr>
<tr><td><code id="channel_+3A_...">...</code></td>
<td>
<p>Specialized channel methods may take other arguments.</p>
</td></tr>
<tr><td><code id="channel_+3A_max_queue">max_queue</code></td>
<td>
<p>The maximum number of outgoing values to store if
there are no listeners. Beyond this, calling <code>emit</code> will return
an error.</p>
</td></tr>
<tr><td><code id="channel_+3A_max_awaiting">max_awaiting</code></td>
<td>
<p>The maximum number of pending requests. If
there are this many outstanding requests, for values, calling
<code>nextThen(ch, ...)</code> or <code>nextElem(ch)</code> will raise an error.</p>
</td></tr>
<tr><td><code id="channel_+3A_wakeup">wakeup</code></td>
<td>
<p>You may optionally provide a callback function here.
It will be called when the queue is empty and there is at least
one listener/outstanding promise.</p>
</td></tr>
<tr><td><code id="channel_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The channel interface is intended to represent and work with
asynchronous, live data sources, for instance event logs,
non-blocking connections, paginated query results, reactive values,
and other processes that yield a sequence of values over time.
</p>
<p><code>channel</code> is an S3 method and will attempt to convert the argument
<code>obj</code> into a channel object according to its class.
</p>
<p>The friendly way to obtain values from a channel is to use
<code>awaitNext</code> or <code>for</code> loops within an <a href="#topic+async">async</a> or <a href="#topic+stream">stream</a> coroutine.
</p>
<p>The low-level interface to obtain values from a channel is to call
<a href="#topic+nextThen">nextThen</a><code style="white-space: pre;">&#8288;(ch, onNext=, onError=, onClose=, ...)]&#8288;</code>, providing callback
functions for at least <code>onNext(val)</code>. Those callbacks will be
appended to an internal queue, and will be called as soon as data
is available, in the order that requests were received.
</p>
<p>You can also treat a channel as an <a href="#topic+iteror">iteror</a> over promises, calling
<code>nextOr(pri)</code> to return a <a href="base.html#topic+promise">promise</a> representing the next
available value. Each promise created this way will be resolved in
the order that data come in. Note that this way there is no special
signal for end of iteration; a promise will reject with
a condition message <code>"StopIteration"</code> to signal end of iteration.
</p>
<p>Be careful with the iterator-over-promises interface though: if you
call <code>as.list.iteror(pr)</code> you may get stuck in an infinite loop, as
<code>as.list</code> keeps calling <code>nextElem</code> and receives more promises to
represent values that exist only hypothetically. This is one
reason for the <code>max_listeners</code> limit.
</p>
<p>The friendly way to create a channel with custom behavior is to use
a <a href="#topic+stream">stream</a> coroutine. Inside of <code>stream()</code> call <a href="#topic+await">await</a> to wait on
promises, <a href="#topic+awaitNext">awaitNext</a> to wait on other streams and <a href="#topic+yield">yield</a> to yield
values. To signal end of iteration use <code>return()</code> (which will
discard its value) and to signal an error use <code>stop()</code>.
</p>
<p>The low-level interface to create a channel with custom behavior
is to call <code>channel(function(emit, reject, cancel) {...})</code>,
providing your own function definition; your function will
receive those three callback methods as arguments. Then use
whatever means to arrange to call <code>emit(val)</code> some time in the
future as data comes in. When you are done emitting values, call
the <code>close()</code> callback. To report an error call
<code>reject(err)</code>; the next requestor will receive the error. If there
is more than one listener, other queued listeners will get a
<code>close</code> signal.
</p>


<h3>Value</h3>

<p>a channel object, supporting methods &quot;nextThen&quot; and &quot;nextOr&quot;
</p>
<p><code>is.channel(x)</code> returns TRUE if its argument is a channel object.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>

<hr>
<h2 id='combine'>Combine several channels into one.</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p><code>combine(...)</code> takes any number of <a href="base.html#topic+promise">promise</a> or <a href="#topic+channel">channel</a>
objects. It awaits each one, and returns a <a href="#topic+channel">channel</a> object
which re-emits every value from its targets, in whatever
order they are received.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_...">...</code></td>
<td>
<p>Each argument should be a <a href="base.html#topic+promise">promise</a> or a <a href="#topic+channel">channel</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="#topic+channel">channel</a> object.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>

<hr>
<h2 id='debugAsync'>Toggle single-step debugging for a coroutine.</h2><span id='topic+debugAsync'></span>

<h3>Description</h3>

<p>Toggle single-step debugging for a coroutine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>debugAsync(x, R, internal, trace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="debugAsync_+3A_x">x</code></td>
<td>
<p>A coroutine object as constructed by (<a href="#topic+async">async</a>, <a href="#topic+gen">gen</a> or
<a href="#topic+stream">stream</a>).</p>
</td></tr>
<tr><td><code id="debugAsync_+3A_r">R</code></td>
<td>
<p>Set TRUE to step through expressions at user level</p>
</td></tr>
<tr><td><code id="debugAsync_+3A_internal">internal</code></td>
<td>
<p>Set TRUE to step through at coroutine
implementation level.</p>
</td></tr>
<tr><td><code id="debugAsync_+3A_trace">trace</code></td>
<td>
<p>Set TRUE or provide a print function to print each R
expression evaluated in turn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list(R=, internal=, trace=)</code> with the current debug state.
</p>

<hr>
<h2 id='delay'>Asynchronous pause.</h2><span id='topic+delay'></span>

<h3>Description</h3>

<p>&quot;delay&quot; returns a promise which resolves only after the specified
number of seconds. This uses the R event loop via <a href="later.html#topic+later">later</a>.
In an <code style="white-space: pre;">&#8288;[async]&#8288;</code> construct you can use <code>await(delay(secs))</code> to yield
control, for example if you need to poll in a loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delay(secs, expr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delay_+3A_secs">secs</code></td>
<td>
<p>The promise will resolve after at least this many seconds.</p>
</td></tr>
<tr><td><code id="delay_+3A_expr">expr</code></td>
<td>
<p>The value to resolve with; will be forced after the delay.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <a href="promises.html#topic+promise">&quot;promise&quot;</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># print a message after a few seconds
async({await(delay(10)); cat("Time's up!\n")})
</code></pre>

<hr>
<h2 id='format.coroutine'>Query / display coroutine properties and state.</h2><span id='topic+format.coroutine'></span><span id='topic+summary.coroutine'></span><span id='topic+summary.generator'></span><span id='topic+summary.async'></span><span id='topic+summary.stream'></span>

<h3>Description</h3>

<p>The coroutine <code>format</code> method displays its source code, its
effective environment, whether it is running or finished, and a
label indicating its last known state. The <code>summary</code> method
returns the same information in a list.
</p>
<p><code>summary(obj)</code> returns a list with information on a coroutine's state,  including:
</p>

<ul>
<li> <p><code>code</code>: the expression used to create the coroutine;
</p>
</li>
<li> <p><code>state</code>: the current state (see below);
</p>
</li>
<li> <p><code>node</code>: is a character string that
identifies a location in the coroutine source code; for example,
a typical state string might be &quot;.{.&lt;-2.await__then&quot;, which
can be read like &quot;in the first argument of <code style="white-space: pre;">&#8288;\{&#8288;</code>, in the second
argument of <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>, in a call to <code>await()</code>, at internal node <code>then</code>.&quot;;
</p>
</li>
<li> <p><code>envir</code>: the environment where the coroutine is evaluating R expressions;
</p>
</li>
<li> <p><code>err</code>: the error object, if the coroutine caught an error.
</p>
</li></ul>

<p><code>summary(g)$state</code> for a <a href="#topic+gen">generator</a> <code>g</code> might be  &quot;yielded&quot;,
&quot;running&quot; (if nextElem is <em>currently</em> being called,) &quot;stopped&quot; (for
generators that have stopped with an error,) or &quot;finished&quot; (for
generators that have finished normally.)
</p>
<p><code>summary(a)$state</code> of an <a href="#topic+async">async</a> might be &quot;pending&quot;, &quot;resolved&quot; or
&quot;rejected&quot;.
</p>
<p><code>summary(s)$state</code> on a <a href="#topic+stream">stream</a> might be &quot;resolved&quot;,
&quot;rejected&quot;, &quot;running&quot;, &quot;woken&quot;, &quot;yielding&quot;, or &quot;yielded&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coroutine'
format(x, ...)

## S3 method for class 'coroutine'
summary(object, ...)

## S3 method for class 'generator'
summary(object, ...)

## S3 method for class 'async'
summary(object, ...)

## S3 method for class 'stream'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.coroutine_+3A_x">x</code></td>
<td>
<p>A coroutine.</p>
</td></tr>
<tr><td><code id="format.coroutine_+3A_...">...</code></td>
<td>
<p>Undocumented.</p>
</td></tr>
<tr><td><code id="format.coroutine_+3A_object">object</code></td>
<td>
<p>a coroutine (<a href="#topic+async">async</a>, <a href="#topic+gen">generator</a>, or <a href="#topic+stream">stream</a>) object.</p>
</td></tr>
</table>

<hr>
<h2 id='gather'>Collect iterator / channel items into a vector.</h2><span id='topic+gather'></span><span id='topic+as.promise.channel'></span><span id='topic+collect'></span><span id='topic+collector'></span>

<h3>Description</h3>

<p><code>gather</code> takes a <a href="#topic+channel">channel</a> as argument and returns a
<a href="base.html#topic+promise">promise</a>. All values emitted by the channel will be collected
into a vector matching the prototype mode. After the source
channel closes, the promise will resolve with the collected
vector.
</p>
<p>Method <code>as.promise.channel</code> is a synonym for <code>gather</code>.
</p>
<p><code>collect</code> and <code>collector</code> are used in the
implementation of the above functions.  <code>collect</code> calls the
function <code>fn</code> in its argument, supplying a callback of the form
<code>function (val, name=NULL).</code> I like to call it <code>emit</code>.  While
<code>fn</code> is running, it can call <code>emit(x)</code> any number of times.
After <code>fn</code> returns, all the values passed to <code>emit</code> are returned
in a vector, with optional names.
</p>
<p><code>collector()</code> works similarly to collect() but does
not gather values when your inner function returns. Instead, it
provides your inner function with two callbacks, one to add a
value and the second to extract the value; so you can use that
callback to extract values at a later time. For an example of
<code>collector</code> usage see the definition of <a href="#topic+gather">gather</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather(ch, type = list())

## S3 method for class 'channel'
as.promise(x)

collect(fn, type = list())

collector(fn, type = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_+3A_ch">ch</code></td>
<td>
<p>a <a href="#topic+channel">channel</a> object.</p>
</td></tr>
<tr><td><code id="gather_+3A_type">type</code></td>
<td>
<p>A prototype output vector (similar to the <code>FUN.VALUE</code>
argument of <a href="base.html#topic+vapply">vapply</a>) Defaults to <code>list()</code>.</p>
</td></tr>
<tr><td><code id="gather_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+channel">channel</a>.</p>
</td></tr>
<tr><td><code id="gather_+3A_fn">fn</code></td>
<td>
<p>A function, which should accept a single argument, here
called <code>emit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gather(ch, list())</code> returns a [<a href="base.html#topic+promise">promise</a>] that eventually
resolves with a list. If the channel emits an error, the promise
will reject with that error. The partial results will be attached
to the error's <code>attr(err, "partialResults")</code>.
</p>
<p><code>collect</code> returns a vector of the same mode as <code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ch &lt;- stream(for (i in 1:10) {await(delay(0.1)); if (i %% 3 == 0) yield(i)})
## Not run:  ch |&gt; gather(numeric(0)) |&gt; then(\(x)cat(x, "\n")) 

#cumulative sum with collect
cumsum &lt;- function(vec) {
  total &lt;- 0
  collect(type=0, function(emit) {
    for (i in vec) total &lt;- emit(total+i)
  })
}

# `as.list.iteror` is implemented simply with `collect`:
as.list.iteror &lt;- function(it) {
  collect(\(yield) repeat yield(nextOr(it, break)))
}
</code></pre>

<hr>
<h2 id='gen'>Create an iterator using sequential code.</h2><span id='topic+gen'></span><span id='topic+yield'></span><span id='topic+yieldFrom'></span>

<h3>Description</h3>

<p><code>gen({...})</code> with an expression written in its argument, creates a
generator, an object which computes an indefinite sequence.
</p>
<p>When written inside a generator expression, <code>yield(expr)</code> causes the
generator to return the given value, then pause until the next value is
requested.
</p>
<p>When running in a generator expression, <code style="white-space: pre;">&#8288;yieldFrom(it))&#8288;</code>, given
a list or <a href="#topic+iteror">iteror</a> in its argument, will yield successive values from that
iteror until it is exhausted, then continue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen(
  expr,
  ...,
  split_pipes = FALSE,
  compileLevel = getOption("async.compileLevel")
)

yield(expr)

yieldFrom(it, err)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_+3A_expr">expr</code></td>
<td>
<p>An expression, to be turned into an iterator.</p>
</td></tr>
<tr><td><code id="gen_+3A_...">...</code></td>
<td>
<p>Undocumented.</p>
</td></tr>
<tr><td><code id="gen_+3A_split_pipes">split_pipes</code></td>
<td>
<p>Silently rewrite expressions where &quot;yield&quot;
appears in chained calls. See <a href="#topic+async">async</a>.</p>
</td></tr>
<tr><td><code id="gen_+3A_compilelevel">compileLevel</code></td>
<td>
<p>Current levels are 0 (no compilation) or
-1 (name munging only).</p>
</td></tr>
<tr><td><code id="gen_+3A_it">it</code></td>
<td>
<p>A list, <a href="#topic+iteror">iteror</a> or compatible object.</p>
</td></tr>
<tr><td><code id="gen_+3A_err">err</code></td>
<td>
<p>An error handler</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On the &quot;inside&quot;, that is the point of view of code you write in
<code>{...}</code>, is ordinary sequential code using conditionals, branches,
loops and such, outputting one value after another with <code>yield()</code>.
For example, this code creates a generator that computes a random
walk:
</p>
<div class="sourceCode r"><pre>rwalk &lt;- gen({
  x &lt;- 0;
  repeat {
    x &lt;- x + rnorm(1)
    yield(x)
  }
})
</pre></div>
<p>On the &quot;outside,&quot; that is, the object returned by <code>gen()</code>, a
generator behaves like an iterator over an indefinite
collection. So we can collect the first 100 values from the above
generator and compute their mean:
</p>
<div class="sourceCode"><pre>rwalk |&gt; itertools2::take(100) |&gt; as.numeric() |&gt; mean()
</pre></div>
<p>When <code>nextOr(rwalk, ...)</code> is called, the generator executes its
&quot;inside&quot; expression, in a local environment, until it reaches a
call to <code style="white-space: pre;">&#8288;yield().&#8288;</code> THe generator 'pauses', preserving its execution
state, and <code>nextElem</code> then returns what was passed to <code>yield</code>. The
next time <code>nextElem(rwalk)</code> is called, the generator resumes
executing its inside expression starting after the <code>yield()</code>.
</p>
<p>If you call <code>gen</code> with a function expression, as in:
</p>
<div class="sourceCode"><pre>gseq &lt;- gen(function(x) for (i in 1:x) yield(i))
</pre></div>
<p>then instead of returning a single generator it will return a
<em>generator function</em> (i.e. a function that constructs and returns a
generator.) The above is morally equivalent to:
</p>
<div class="sourceCode"><pre>gseq &lt;- function(x) {force(x); gen(for (i in 1:x) yield(i))}
</pre></div>
<p>so the generator function syntax just saves you writing the <a href="base.html#topic+force">force</a>
call.
</p>
<p>A generator expression can use any R functions, but a call to
<code>yield</code> may only appear in the arguments of a &quot;pausable&quot; function.
The <code>async</code> package has several built-in pausable functions corresponding
to base R's control flow functions, such as <code>if</code>, <code>while</code>, <code>tryCatch</code>,
<code style="white-space: pre;">&#8288;&lt;-&#8288;</code>, <code>{}</code>, <code>||</code> and so on (see <a href="#topic+pausables">pausables</a> for more details.)  A call
to <code>yield</code> may only appear in an argument of one of these pausable
functions. So this random walk generator:
</p>
<div class="sourceCode r"><pre>rwalk &lt;- gen({x &lt;- 0; repeat {x &lt;- yield(x + rnorm(1))}})
</pre></div>
<p>is legal, because <code>yield</code> appears within arguments to <code>{}</code>,
<code>repeat</code>, and <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>, for which this package has pausable
definitions. However, this:
</p>
<div class="sourceCode r"><pre>rwalk &lt;- gen({x &lt;- rnorm(1); repeat {x &lt;- rnorm(1) + yield(x)}})
</pre></div>
<p>is not legal, because <code>yield</code> appears in an argument to <code>+</code>, which
does not have a pausable definition.
</p>


<h3>Value</h3>

<p>'gen(...) returns an <a href="#topic+iteror">iteror</a>.
</p>
<p><code>yield(x)</code> returns the same value x.
</p>
<p>yieldFrom returns NULL, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i_chain &lt;- function(...) {
  iterators &lt;- list(...)
  gen(for (it in iterators) yieldFrom(it))
}
</code></pre>

<hr>
<h2 id='goto'>Coroutine switch with delimited goto.</h2><span id='topic+goto'></span>

<h3>Description</h3>

<p>The <code>switch</code> function implemented for coroutines in the <code>async</code>
package is more strict than the one in base R. In a coroutine,
<code>switch</code> will always either take one of the given branches or throw
an error, whereas base R <code>switch</code> will silently return NULL if no
branch matches switch argument. Otherwise, the same conventions
apply as <code><a href="base.html#topic+switch">base::switch()</a></code> (e.g. empty switch branches fall through;
a character switch may have one unnamed argument as a default.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goto(branch = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goto_+3A_branch">branch</code></td>
<td>
<p>A character string naming the new branch. If missing or NULL,
jumps back to re-evaluate the switch argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coroutine <code>switch</code> also supports a delimited form of <code>goto</code>. Within
a branch, <code>goto("other_branch")</code> will stop executing the present
branch and jump to the named branch.  Calling <code>goto()</code> without
arguments will jump back to re-evaluate the switch expression.
</p>
<p>If a <code>goto</code> appears in a try-finally call, as in:
</p>
<div class="sourceCode"><pre>switch("branch",
   branch=tryCatch({...; goto("otherBranch")},
                   finally={cleanup()}),
   otherBranch={...}
)
</pre></div>
<p>the <code>finally</code> clause will be executed <em>before</em> switching to the new branch.
</p>

<hr>
<h2 id='graphAsync'>Draw a graph representation of a coroutine.</h2><span id='topic+graphAsync'></span>

<h3>Description</h3>

<p><code>graphAsync</code> will traverse the objects representing a
<a href="#topic+gen">generator</a> or <a href="#topic+async">async</a> and render a graph of its structure
using Graphviz (if it is installed.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphAsync(
  obj,
  basename = if (is.name(substitute(obj))) as.character(substitute(obj)) else
    stop("Please specify basename"),
  type = "pdf",
  ...,
  envs = TRUE,
  vars = FALSE,
  handlers = FALSE,
  orphans = FALSE,
  dot = find_dot(),
  filename = paste0(basename, ".", type),
  dotfile = if (type == "dot") filename else paste0(basename, ".dot")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphAsync_+3A_obj">obj</code></td>
<td>
<p>A <a href="#topic+gen">generator</a>, <a href="#topic+async">async</a> or <a href="#topic+stream">stream</a> object.</p>
</td></tr>
<tr><td><code id="graphAsync_+3A_basename">basename</code></td>
<td>
<p>The base file name. If <code>basename="X"</code> and
<code>type="pdf"</code> you will end up with two files, <code>"X.dot"</code> and
<code>"X.pdf"</code>.</p>
</td></tr>
<tr><td><code id="graphAsync_+3A_type">type</code></td>
<td>
<p>the output format. If &quot;dot&quot;, we will just write a
Graphviz dot file. If another extension like &quot;pdf&quot; or &quot;svg&quot;, will
write a DOT file and then attempt to invoke Graphviz <code>dot</code> (if it
is available according to <code><a href="base.html#topic+Sys.which">Sys.which</a></code>) to produce the image.
If <code>type=""</code> <code>graphAsync</code> will return graphviz DOT language as a
character vector</p>
</td></tr>
<tr><td><code id="graphAsync_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="graphAsync_+3A_envs">envs</code></td>
<td>
<p>If <code>TRUE</code>, multiple nodes that share the same
environment will be grouped together in clusters.</p>
</td></tr>
<tr><td><code id="graphAsync_+3A_vars">vars</code></td>
<td>
<p>If <code>TRUE</code>, context variables used in each state node
will be included on the graph, with edges indicating
reads/stores.</p>
</td></tr>
<tr><td><code id="graphAsync_+3A_handlers">handlers</code></td>
<td>
<p>If <code>TRUE</code>, state nodes will have thin edges
connecting to trampoline handlers they call, in addition to the
dashed edges connecting to the next transition.</p>
</td></tr>
<tr><td><code id="graphAsync_+3A_orphans">orphans</code></td>
<td>
<p>If <code>TRUE</code>, nodes will be included even if there are
no connections to them (this mostly being interface methods and
unused handlers).</p>
</td></tr>
<tr><td><code id="graphAsync_+3A_dot">dot</code></td>
<td>
<p>Optional path to the <code>dot</code> executable.</p>
</td></tr>
<tr><td><code id="graphAsync_+3A_filename">filename</code></td>
<td>
<p>Optionally specify the output picture file name.</p>
</td></tr>
<tr><td><code id="graphAsync_+3A_dotfile">dotfile</code></td>
<td>
<p>Optionally specify the output DOT file name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>graphAsync</code> will write a Graphviz DOT format file describing the
given <a href="#topic+gen">generator</a> or <a href="#topic+async">async</a>/await block. The graph shows the
generator as a state machine with nodes that connect to each other.
</p>
<p>If <code>type</code> is something other than <code>dot</code> <code style="white-space: pre;">&#8288;graphAsync will then try to invoke Graphviz &#8288;</code>dot' to turn the graph description into an image
file.
</p>
<p>The green octagonal node is where the program starts, while red
&quot;stop&quot; and blue &quot;return&quot; are where it ends. Nodes in green type on
dark background show code that runs in the host language
unmodified; gray nodes implement control flow. Dark arrows carry a
value; gray edges carry no value. A &quot;semicolon&quot; node receives a
value and discards it.
</p>
<p>Some nodes share a context with other nodes, shown by an enclosing
box. Contexts can have state variables, shown as a rectangular
record; orange edges from functions to variables represent writes;
blue edges represent reads.
</p>
<p>Dashed edges represent a state transition that goes through a
trampoline handler. Dashed edges have a Unicode symbol representing
the type of trampoline; (DOUBLE VERTICAL BAR) for await/yield; (TOP
ARC ANTICLOCKWISE ARROW WITH PLUS) or (TOP ARC CLOCKWISE ARROW WITH
MINUS) to wind on or off an exception handler; (ANTICLOCKWISE
TRIANGLE-HEADED BOTTOM U-SHAPED ARROW) for a plain trampoline with
no side effects (done once per loop, to avoid overflowing the
stack.)  Meanwhile, a thin edge connects to the trampoline handler.
(So the user-facing &quot;yield&quot; function registers a continuation to
the next step but actually calls the generator's yield handler.)
</p>


<h3>Value</h3>

<p>If <code>type=""</code>, a character vector of DOT source. Else
The name of the file that was created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>randomWalk &lt;- gen({x &lt;- 0; repeat {yield(x); x &lt;- x + rnorm(1)}})
## Not run: 
graphAsync(randomWalk, "pdf")
# writes "randomWalk.dot" and invokes dot to make "randomWalk.pdf"

#or, display it in an R window with the Rgraphviz package:
g &lt;- Rgraphviz::agread("randomWalk.dot")
Rgraphviz::plot(g)

## End(Not run)
#Or render an HTML sidget using DiagrammeR:
## Not run: 
dot &lt;- graphAsync(randomWalk, type="")
DiagrammeR::DiagrammeR(paste0(dot, collapse="\n"), type="grViz")

## End(Not run)
</code></pre>

<hr>
<h2 id='nextThen'>Receive values from channels by callback.</h2><span id='topic+nextThen'></span><span id='topic+subscribe'></span>

<h3>Description</h3>

<p><code>nextThen</code> is the callback-oriented interface to work with
<a href="#topic+channel">channel</a> objects. Provide the channel callback functions to
receive the next element, error, and closing signals; your
callbacks will be stored in a queue and called when values are
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextThen(x, onNext, onError, onClose, ...)

subscribe(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextThen_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+channel">channel</a> object</p>
</td></tr>
<tr><td><code id="nextThen_+3A_onnext">onNext</code></td>
<td>
<p>For <a href="#topic+nextThen">nextThen</a>, a function to be called with the next
emitted value. For <a href="#topic+subscribe">subscribe</a>, a function to be called with each
emitted value until the stream finishes.</p>
</td></tr>
<tr><td><code id="nextThen_+3A_onerror">onError</code></td>
<td>
<p>Function to be called if channel stops with an
error. Note that if you call nextThen multiple times to register
multile callbacks, only the first will receive onError; the rest
will be called with onClose.</p>
</td></tr>
<tr><td><code id="nextThen_+3A_onclose">onClose</code></td>
<td>
<p>Function to be called if the channel finishes normally.</p>
</td></tr>
<tr><td><code id="nextThen_+3A_...">...</code></td>
<td>
<p>Undocumented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>subscribe</code> is similar to nextThen except that your <code>onNext</code> will be
called for each value the channel emits. It is just implemented
in terms of nextThen, with a callback that re-registers itself.
</p>

<hr>
<h2 id='pausables'>Pausable functions.</h2><span id='topic+pausables'></span>

<h3>Description</h3>

<p>Coroutines rely on &quot;pausable&quot; workalikes for control flow functions
like <code>if</code>, <code>while</code>, and so on. <code>pausables()</code> scans for and returns
a list of all pausable functions visible from the present
environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pausables(envir = caller(), packages = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pausables_+3A_envir">envir</code></td>
<td>
<p>The environment to search (defaulting to the calling
environment).</p>
</td></tr>
<tr><td><code id="pausables_+3A_packages">packages</code></td>
<td>
<p>By default, will only look for pausable functions
visible from the caller's environment. <code>packages</code> argument
additionally specifies aditional packages to
search. <code>packages=base::.packages()</code> will search all currently
loaded packages. <code style="white-space: pre;">&#8288;[.packages(all.available=TRUE)]&#8288;</code> will search
all installped package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pausable function is a public function that has a corresponding
private function with a name endng with <code style="white-space: pre;">&#8288;_cps&#8288;</code>.  Most of these
private functions are defined in <code>async</code> source file <code>cps.r</code>. For
instance, <code>async:::for_cps</code> contains the pausable implementation of
<code>for</code>.
</p>


<h3>Value</h3>

<p>A list of expressions (either names or <code>:::</code> calls)
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+nextOr'></span><span id='topic+iteror'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>iterors</dt><dd><p><code><a href="iterors.html#topic+iteror">iteror</a></code>, <code><a href="iterors.html#topic+nextOr">nextOr</a></code></p>
</dd>
</dl>

<hr>
<h2 id='run'>Execute a generator expression immediately, collecting yielded values.</h2><span id='topic+run'></span>

<h3>Description</h3>

<p><code>run(expr)</code> with an expression directly writen, will parse that
expression as a coroutine, but then run it without pausing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run(
  expr,
  type = list(),
  ...,
  split_pipes = FALSE,
  debugR = FALSE,
  debugInternal = FALSE,
  trace = getOption("async.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_+3A_expr">expr</code></td>
<td>
<p>A generator expression, same as you would write in
<a href="#topic+gen">gen</a>.</p>
</td></tr>
<tr><td><code id="run_+3A_type">type</code></td>
<td>
<p>A value whose mode will determine the output vector mode (as
in <a href="base.html#topic+vapply">vapply</a>.)</p>
</td></tr>
<tr><td><code id="run_+3A_...">...</code></td>
<td>
<p>Undocumented.</p>
</td></tr>
<tr><td><code id="run_+3A_split_pipes">split_pipes</code></td>
<td>
<p>See <a href="#topic+async">async</a>; defaults to FALSE.</p>
</td></tr>
<tr><td><code id="run_+3A_debugr">debugR</code></td>
<td>
<p>Will open a browser at the first and subsequent R
evaluations allowing single-stepping through user code.</p>
</td></tr>
<tr><td><code id="run_+3A_debuginternal">debugInternal</code></td>
<td>
<p>Will set a breakpoint at the implementation
level, allowing single-stepping through <code>async</code> package code.</p>
</td></tr>
<tr><td><code id="run_+3A_trace">trace</code></td>
<td>
<p>a tracing function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the expression contains any calls to <code>yield()</code>, <code>run()</code> will
collect all the values passed to yield() and return a list. If the
expression contains a <code>yield()</code> but it is never called, <code>run()</code>
returns an empty list. If the expression does not contain a <code>yield</code>
at all, <code>run</code> returns the expression's final return value.
</p>
<p><code>run(expr)</code> is similar to <code>as.list(gen(expr))</code>, except <code>run(expr)</code>
evaluates its expression directly in the calling environment, while
<code>gen</code> creates a new enclosed environment to run in.
</p>
<p><code>run</code> is useful if you want to take advantage of coroutine language
extensions, such as using <code>for</code> loops over iterators, or using
<code><a href="#topic+goto">goto()</a></code> in <code>switch</code> statements, in otherwise synchronous code. If
you want to collect a variable-length sequence of values but don't
need those features, using <a href="#topic+collect">collect</a> directly will have better
performance.
</p>


<h3>Value</h3>

<p>If <code>expr</code> contains any <code>yield</code> calls, a vector of the
same mode as <code>type</code>; otherwise the return value of <code>expr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
run(type=0, {
  for (i in iterors::iseq(2, Inf, by=5)) {
    if (i %% 37 == 0) break
    else yield(i)
  }
})

</code></pre>

<hr>
<h2 id='stream'>Create an asynchronous iterator by writing sequential code.</h2><span id='topic+stream'></span>

<h3>Description</h3>

<p>(Experimental as of async 0.3) <code>stream(...)</code> constructs a <a href="#topic+channel">channel</a>
object, i.e. an asynchronous iterator, which will compute and
return values according to sequential code written in <code>expr</code>. A
<code>stream</code> is a coroutine wearing a <a href="#topic+channel">channel</a> interface in the same
way that <code>async</code> is a coroutine wearing a <a href="base.html#topic+promise">promise</a> interface, and a
<a href="#topic+gen">gen</a> is a coroutine sitting behind an <a href="#topic+iteror">iteror</a> interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stream(
  expr,
  ...,
  split_pipes = TRUE,
  lazy = TRUE,
  compileLevel = getOption("async.compileLevel"),
  debugR = FALSE,
  debugInternal = FALSE,
  trace = getOption("async.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stream_+3A_expr">expr</code></td>
<td>
<p>A coroutine expression, using some combination of
<code>yield</code>, <code>await</code>, <code>awaitNext</code>, <code>yieldFrom</code>, standard control flow
operators and other calls.</p>
</td></tr>
<tr><td><code id="stream_+3A_...">...</code></td>
<td>
<p>Undocumented.</p>
</td></tr>
<tr><td><code id="stream_+3A_split_pipes">split_pipes</code></td>
<td>
<p>See description under <a href="#topic+async">async</a>; defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stream_+3A_lazy">lazy</code></td>
<td>
<p>If TRUE, start paused, and pause after <code>yield()</code> (see above.)</p>
</td></tr>
<tr><td><code id="stream_+3A_compilelevel">compileLevel</code></td>
<td>
<p>Compilation level.</p>
</td></tr>
<tr><td><code id="stream_+3A_debugr">debugR</code></td>
<td>
<p>Set TRUE to single-step debug at R level. Use <code><a href="#topic+debugAsync">debugAsync()</a></code>
to enable or disable debugging on a stream after it has been created.</p>
</td></tr>
<tr><td><code id="stream_+3A_debuginternal">debugInternal</code></td>
<td>
<p>Set TRUE to single-step debug at coroutine
implementation level.</p>
</td></tr>
<tr><td><code id="stream_+3A_trace">trace</code></td>
<td>
<p>An optional tracing function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a stream expression, you can call <code>yield()</code> to emit a value, and
<code>await()</code> to wait for a value from a <a href="base.html#topic+promise">promise</a>. To have your stream
wait for values from another stream or <a href="#topic+channel">channel</a>, call
<code>awaitNext()</code>; you can also use <code>awaitNext</code> when you are writing an
<code>async</code>. You can also use a simple <code>for</code> loop to consume all future
values from a stream or channel.
</p>
<p>The lower-level interface to consume values from a stream is by using
<a href="#topic+nextThen">nextThen</a> from the <a href="#topic+channel">channel</a> interface.
</p>
<p>Streams come in both &quot;lazy&quot; and &quot;eager&quot; varieties. If <code>lazy=TRUE</code>,
a stream starts idle, and does not process anything
until it is woken up by a call to its channel's <code>nextThen</code>. It will
pause after reaching <code>yield</code> if there are no more outstanding
requests. If <code>lazy=FALSE</code>, a stream will begin executing
immediately, not pausing on <code>yield</code>, possibly queuing up emitted
values until it needs to <code>await</code> something.
</p>
<p>(For comparison, in this package, <a href="#topic+gen">gen</a> are lazy in that they do
not start executing until a call to <code>nextOr</code> and pause
immediately after <code>yield</code>, while <a href="#topic+async">async</a> blocks are eager,
starting at construction and running until they hit an <code>await</code>.)
</p>
<p>Like its coroutine counterparts, if <code>stream</code> is given a function
expression, like <code>stream(function(...)  ...)</code>, it will return a
&quot;stream function&quot; i.e. a function that constructs a stream object.
</p>


<h3>Value</h3>

<p>An object with (at least) classes &quot;stream&quot;, &quot;channel&quot;,
&quot;coroutine&quot;, &quot;iteror&quot;, &quot;iter&quot;.
</p>


<h3>Author(s)</h3>

<p>Peter Meilstrup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# emit values _no more than_ once per second
count_to &lt;- stream(function(n, interval=1) {
  for (i in 1:n) {
    await(delay(interval))
    yield(i)
  }
})

accumulate &lt;- stream(function(st, sum=0) {
  for (i in st) {sum &lt;- sum + i; yield(sum)}
})

print_each &lt;- async(function(st) for (i in st) print(i))

count_to(10) |&gt; accumulate() |&gt; print_each()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
