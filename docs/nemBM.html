<!DOCTYPE html><html><head><title>Help for package nemBM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nemBM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assortativity'><p>Assortativity mechanism</p></a></li>
<li><a href='#chooseBlockRow'><p>Sum of squared error across blocks</p></a></li>
<li><a href='#genNetworkLE'><p>Relocating Links algorithm (RL algorithm)</p></a></li>
<li><a href='#globalDensity'><p>Network density based on an image matrix and a partition</p></a></li>
<li><a href='#mutuality'><p>Mutuality mechanism</p></a></li>
<li><a href='#nem'><p>Generating networks according to the selected local network mechanisms</p></a></li>
<li><a href='#nemBM'><p>Network evolution model with a prespecified blockmodel type and partition</p></a></li>
<li><a href='#nemSym'><p>Generating symmetric networks according to the selected local network mechanisms</p></a></li>
<li><a href='#nemSymBMinout'><p>Network evolution model with a prespecified blockmodel type and partition (symmetric networks with incomers and outgoers)</p></a></li>
<li><a href='#normalizeRsphere'><p>Normalize values on a sphere</p></a></li>
<li><a href='#OSPtransitivity'><p>Outgoing shared partners mechanism</p></a></li>
<li><a href='#OTPtransitivity'><p>Outgoing two-path mechanism</p></a></li>
<li><a href='#popularity'><p>Popularity mechanism</p></a></li>
<li><a href='#randomizePartition'><p>Randomize a partition</p></a></li>
<li><a href='#RL'><p>Relocating Links algorithm (RL algorithm)</p></a></li>
<li><a href='#SSEblock'><p>Sum of squared error across blocks</p></a></li>
<li><a href='#WeightedNetworkStatistics'><p>Weighted network statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Using Network Evolution Models to Generate Networks with
Selected Blockmodel Type</td>
</tr>
<tr>
<td>Version:</td>
<td>1.00.01</td>
</tr>
<tr>
<td>Description:</td>
<td>To study network evolution models and different blockmodeling approaches. Various functions enable generating (temporal) networks with a selected blockmodel type, taking into account selected local network mechanisms. The development of this package is financially supported the Slovenian Research Agency (www.arrs.gov.si) within the research program P5&lt;96&gt;0168 and the research project J5-2557 (Comparison and evaluation of different approaches to blockmodeling dynamic networks by simulations with application to Slovenian co-authorship networks).</td>
</tr>
<tr>
<td>Depends:</td>
<td>ergm, blockmodeling</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-14 12:48:54 UTC; marss</td>
</tr>
<tr>
<td>Author:</td>
<td>Marjan Cugmas [aut, cre],
  Aleš Žiberna [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marjan Cugmas &lt;marjan.cugmas@fdv.uni-lj.si&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-14 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='assortativity'>Assortativity mechanism</h2><span id='topic+assortativity'></span>

<h3>Description</h3>

<p>Calculate the normalized network statistic according to the assortativity mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assortativity(X, actor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assortativity_+3A_x">X</code></td>
<td>
<p>Binary network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="assortativity_+3A_actor">actor</code></td>
<td>
<p>A unit (actor; row/column number), which have an opportunity to change a link.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns the value 1 when actor (i.e. ego) and alter do not differ in the number of incoming ties. 
Otherwise, lower values indicate higher difference in the number of incoming ties between the actor and alter.
</p>


<h3>Value</h3>

<p>A vector with the assortativity mechanism, cacluated between the actor and other units.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>References</h3>

<p>Cugmas, M., &amp; Žiberna, A. (2022). Approaches to blockmodeling dynamic networks: a Monte Carlo simulation study. Social Networks, in print
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
mutuality(X, actor = 2)
</code></pre>

<hr>
<h2 id='chooseBlockRow'>Sum of squared error across blocks</h2><span id='topic+chooseBlockRow'></span>

<h3>Description</h3>

<p>The actor choose the block (i.e., column in an image matrix) in which he will change a link, based on the difference between the density of his out-degrees by blocks and the ideal block density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseBlockRow(X, actor, partition, M, loops, randomBlock = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseBlockRow_+3A_x">X</code></td>
<td>
<p>Binary network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="chooseBlockRow_+3A_actor">actor</code></td>
<td>
<p>A unit (actor; row/column number), which have an opportunity to change a link.</p>
</td></tr>
<tr><td><code id="chooseBlockRow_+3A_partition">partition</code></td>
<td>
<p>A partition in a vector format. Each unique value (positive integers) represents one cluster.</p>
</td></tr>
<tr><td><code id="chooseBlockRow_+3A_m">M</code></td>
<td>
<p>Image matrix with block densities.</p>
</td></tr>
<tr><td><code id="chooseBlockRow_+3A_loops">loops</code></td>
<td>
<p>Wheter loops are allowed or not.</p>
</td></tr>
<tr><td><code id="chooseBlockRow_+3A_randomblock">randomBlock</code></td>
<td>
<p>How to select a block; the one with the highest difference (<code>FALSE</code>, default), proportionally to the differences (<code>linear</code>) or squared differences (<code>square</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with two elements: <code>block</code> (selected block number) and <code>sign</code> (wheter the selected block is too sparse (-1) or too dense (+1)).
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
diag(X) &lt;- 0
M &lt;- matrix(c(0.1, 0.4, 0.5, 0.3), nrow = 2)
partition &lt;- c(1, 2, 2, 1, 1, 2, 2, 2, 1)
chooseBlockRow(X = X, actor = 3, partition = partition, 
M = M, loops = FALSE, randomBlock = "square")
</code></pre>

<hr>
<h2 id='genNetworkLE'>Relocating Links algorithm (RL algorithm)</h2><span id='topic+genNetworkLE'></span>

<h3>Description</h3>

<p>Generate network with a selected blockmodel and level or errors. See details section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genNetworkLE(BM = BM, LE = 0.4, size = NULL, symmetric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genNetworkLE_+3A_bm">BM</code></td>
<td>
<p>An image matrix of a blockmodel; of class <code>matrix</code> with possible values &quot;nul&quot; and &quot;com&quot;.</p>
</td></tr>
<tr><td><code id="genNetworkLE_+3A_le">LE</code></td>
<td>
<p>Desired level of errors.</p>
</td></tr>
<tr><td><code id="genNetworkLE_+3A_size">size</code></td>
<td>
<p>A vector with the values specifying clusters' sizes. The number of elements of this vector must be the same as the number of clusters specified by an image matrix.</p>
</td></tr>
<tr><td><code id="genNetworkLE_+3A_symmetric">symmetric</code></td>
<td>
<p>Wheter a symmetric network should be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The level of errors (LE) is used to simulate the extent of inconsistencies in blockmodels. It is defined on 
a scale between 0 and 1, where 0 corresponds to an ideal blockmodel, and 1 corresponds to a totally randomised 
network with the same density as in the ideal blockmodel.
</p>


<h3>Value</h3>

<p>A binary network (of class <code>matrix</code>) with selected blockmodel type and level of errors.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>References</h3>

<p>Cugmas, M., Žiberna, A., &amp; Ferligoj, A. (2021). The Relative Fit measure for evaluating a blockmodel. Statistical Methods &amp; Applications, 30(5), 1315-1335.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cohesiveBM &lt;- rbind(c("com", "nul"), c("nul", "com"))
network &lt;- genNetworkLE(BM = cohesiveBM, LE = 0.5, size = c(5, 3))
</code></pre>

<hr>
<h2 id='globalDensity'>Network density based on an image matrix and a partition</h2><span id='topic+globalDensity'></span>

<h3>Description</h3>

<p>Based on an image matrix and a partition it calculate the density of a whole network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalDensity(M, partition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="globalDensity_+3A_m">M</code></td>
<td>
<p>Image matrix with block densities.</p>
</td></tr>
<tr><td><code id="globalDensity_+3A_partition">partition</code></td>
<td>
<p>A partition in a vector format. Each unique value (positive integers) represents one cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Density of a whole network (a single value).
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(0.1, 0.4, 0.5, 0.3), nrow = 2)
partition &lt;- c(1, 2, 2, 1, 1, 2, 2, 2, 1)
globalDensity(M = M, partition = partition)
</code></pre>

<hr>
<h2 id='mutuality'>Mutuality mechanism</h2><span id='topic+mutuality'></span>

<h3>Description</h3>

<p>Calculate the normalized network statistic according to the mutuality mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutuality(X, actor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutuality_+3A_x">X</code></td>
<td>
<p>Binary network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="mutuality_+3A_actor">actor</code></td>
<td>
<p>A unit (actor; row/column number), which have an opportunity to change a link.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the normalized mutuality mechanism, cacluated between the actor and other units.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>References</h3>


<ul>
<li><p> Cugmas, M., Žiberna, A., &amp; Ferligoj, A. (2019). Mechanisms generating asymmetric core-cohesive blockmodels. Advances in Methodology and Statistics, 16(1), 17-41.
</p>
</li>
<li><p> Cugmas, M., &amp; Žiberna, A. (2022). Approaches to blockmodeling dynamic networks: a Monte Carlo simulation study. Social Networks, in print.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
mutuality(X, actor = 2)
</code></pre>

<hr>
<h2 id='nem'>Generating networks according to the selected local network mechanisms</h2><span id='topic+nem'></span>

<h3>Description</h3>

<p>It generates random network considering the selected local network mechanisms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nem(X, formula, theta, k = 5000, q, b = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nem_+3A_x">X</code></td>
<td>
<p>Initial network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="nem_+3A_formula">formula</code></td>
<td>
<p>The list of local netork mechanisms to be considered.</p>
</td></tr>
<tr><td><code id="nem_+3A_theta">theta</code></td>
<td>
<p>A vector with the mechanisms' weights/strengths.</p>
</td></tr>
<tr><td><code id="nem_+3A_k">k</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
<tr><td><code id="nem_+3A_q">q</code></td>
<td>
<p>The probability of establishing a link.</p>
</td></tr>
<tr><td><code id="nem_+3A_b">b</code></td>
<td>
<p>The share of alters among which an actor (i.e., ego) chooses to create or break a tie.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list with the following elements:
</p>

<ul>
<li> <p><code>initialNetwork</code> - Initial network; of class <code>matrix</code>.
</p>
</li>
<li> <p><code>finalNetwork</code> - Final (generated) network; of class <code>matrix</code>.
</p>
</li>
<li> <p><code>formula</code> - The list of functions that define mechanisms used.
</p>
</li>
<li> <p><code>theta</code> - A vector with the mechanisms' weights/strengths used.
</p>
</li>
<li> <p><code>k</code> - The number of iterations.
</p>
</li>
<li> <p><code>q</code> - The probability of establishing a link.
</p>
</li>
<li> <p><code>b</code> - The share of alters among which an actor (i.e., ego) chooses to create or break a tie.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>References</h3>

<p>Cugmas, M., Žiberna, A., &amp; Ferligoj, A. (2019). Mechanisms generating asymmetric core-cohesive blockmodels. Advances in Methodology and Statistics, 16(1), 17-41.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formula &lt;- list(mutuality, popularity, assortativity)
X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
nem(X = X, formula = formula, theta = c(1, 1, 1), k = 100, q = 0.25)
</code></pre>

<hr>
<h2 id='nemBM'>Network evolution model with a prespecified blockmodel type and partition</h2><span id='topic+nemBM'></span>

<h3>Description</h3>

<p>Generates an asymmetric network with a selected blockmodel type and partition. 
Considers local network mechanisms when creating links within blocks. 
Does not enable considering incomers and outgoers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nemBM(X = X, partition, M, formula, theta, k = 10000, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nemBM_+3A_x">X</code></td>
<td>
<p>Initial binary network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="nemBM_+3A_partition">partition</code></td>
<td>
<p>A desired partition in a vector format. Each unique value (positive integers) represents one cluster.</p>
</td></tr>
<tr><td><code id="nemBM_+3A_m">M</code></td>
<td>
<p>Desired image matrix with block densities.</p>
</td></tr>
<tr><td><code id="nemBM_+3A_formula">formula</code></td>
<td>
<p>The list of local netork mechanisms to be considered.</p>
</td></tr>
<tr><td><code id="nemBM_+3A_theta">theta</code></td>
<td>
<p>A vector with the mechanisms' weights/strengths.</p>
</td></tr>
<tr><td><code id="nemBM_+3A_k">k</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
<tr><td><code id="nemBM_+3A_loops">loops</code></td>
<td>
<p>Wheter loops are allowed or not (default <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list with the following elements:
</p>

<ul>
<li> <p><code>initialNetwork</code> - Initial network; of class <code>matrix</code>.
</p>
</li>
<li> <p><code>finalNetwork</code> - Final (generated) network; of class <code>matrix</code>.
</p>
</li>
<li> <p><code>formula</code> - The list of functions that define mechanisms used.
</p>
</li>
<li> <p><code>theta</code> - A vector with the mechanisms' weights/strengths used.
</p>
</li>
<li> <p><code>ERR</code> - Sum of squared differences between the desired and empirical densities across blocks; for each iteration.
</p>
</li>
<li> <p><code>iterations</code> - The number of iterations.
</p>
</li>
<li> <p><code>loops</code> - Wheter loops were allowed.
</p>
</li>
<li> <p><code>M</code> - The desired (specified) image matrix.
</p>
</li>
<li> <p><code>partition</code> - The partition.
</p>
</li>
<li> <p><code>density</code> - Network density at each iteration.
</p>
</li>
<li> <p><code>timeElapsed</code> - Running time.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>References</h3>

<p>Cugmas, M., &amp; Žiberna, A. (2022). Approaches to blockmodeling dynamic networks: a Monte Carlo simulation study. Social Networks, in print.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formula &lt;- list(mutuality, popularity, OTPtransitivity)
X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
diag(X) &lt;- 0
M &lt;- matrix(c(0.1, 0.8, 0.1, 0.5), nrow = 2)
partition &lt;- c(1, 2, 2, 1, 1, 2, 2, 2, 1)
res &lt;- nemBM(X = X, partition = partition, formula = formula, 
theta = c(1, 1, 1), M = M, k = 100, loops = FALSE)
</code></pre>

<hr>
<h2 id='nemSym'>Generating symmetric networks according to the selected local network mechanisms</h2><span id='topic+nemSym'></span>

<h3>Description</h3>

<p>It generates random network considering the selected local network mechanisms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nemSym(X, formula, theta, k = 5000, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nemSym_+3A_x">X</code></td>
<td>
<p>Initial network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="nemSym_+3A_formula">formula</code></td>
<td>
<p>The list of local netork mechanisms to be considered.</p>
</td></tr>
<tr><td><code id="nemSym_+3A_theta">theta</code></td>
<td>
<p>A vector with the mechanisms' weights/strengths.</p>
</td></tr>
<tr><td><code id="nemSym_+3A_k">k</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
<tr><td><code id="nemSym_+3A_q">q</code></td>
<td>
<p>The probability of establishing a link (i.e. expected/desired density).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list with the following elements:
</p>

<ul>
<li> <p><code>initialNetwork</code> - Initial network; of class <code>matrix</code>.
</p>
</li>
<li> <p><code>finalNetwork</code> - Final (generated) network; of class <code>matrix</code>.
</p>
</li>
<li> <p><code>formula</code> - The list of functions that define mechanisms used.
</p>
</li>
<li> <p><code>theta</code> - A vector with the mechanisms' weights/strengths used.
</p>
</li>
<li> <p><code>k</code> - The number of iterations.
</p>
</li>
<li> <p><code>q</code> - The probability of establishing a link.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>References</h3>

<p>Cugmas, M., DeLay, D., Žiberna, A., &amp; Ferligoj, A. (2020). Symmetric core-cohesive blockmodel in preschool children’s interaction networks. PloS one, 15(1), e0226801.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formula &lt;- list(popularity, assortativity)
X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
diag(X) &lt;- 0
nemSym(X = X, formula = formula, theta = c(1, 1), k = 100, q = 0.25)
</code></pre>

<hr>
<h2 id='nemSymBMinout'>Network evolution model with a prespecified blockmodel type and partition (symmetric networks with incomers and outgoers)</h2><span id='topic+nemSymBMinout'></span>

<h3>Description</h3>

<p>Generate a symmetric network with a selected blockmodel type and partition 
with a specified number of incomers and outgoers. Considers local network mechanisms when
creating links within blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nemSymBMinout(
  X = X,
  partition = partition,
  M = M,
  formula = NULL,
  theta = NULL,
  nin = 5,
  nout = 20,
  minClusterSize = 5,
  k = 1000,
  loops = FALSE,
  randomizeP = 0,
  randomSD = 0.02
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nemSymBMinout_+3A_x">X</code></td>
<td>
<p>Initial binary network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_partition">partition</code></td>
<td>
<p>A desired partition in a vector format. Each unique value (positive integers) represents one cluster.</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_m">M</code></td>
<td>
<p>Desired image matrix with block densities.</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_formula">formula</code></td>
<td>
<p>The list of local netork mechanisms to be considered.</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_theta">theta</code></td>
<td>
<p>A vector with the mechanisms' weights/strengths.</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_nin">nin</code></td>
<td>
<p>Number of incomers.</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_nout">nout</code></td>
<td>
<p>Number of outgoers.</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_minclustersize">minClusterSize</code></td>
<td>
<p>Minimum cluster size.</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_k">k</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_loops">loops</code></td>
<td>
<p>Wheter loops are allowed or not (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_randomizep">randomizeP</code></td>
<td>
<p>The share of units to be randomly relocated between clusters.</p>
</td></tr>
<tr><td><code id="nemSymBMinout_+3A_randomsd">randomSD</code></td>
<td>
<p>The srandard deviation of a normal distribution form which the random part of weighed network statistics is sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list with the following elements:
</p>

<ul>
<li> <p><code>initialNetwork</code> - Initial network; of class <code>matrix</code>.
</p>
</li>
<li> <p><code>finalNetwork</code> - Final (generated) network; of class <code>matrix</code>.
</p>
</li>
<li> <p><code>initialPartition</code> - Initial partition.
</p>
</li>
<li> <p><code>finalPartition</code> - Final partition (i.e., partition after randomization and after incomers and outgoers).
</p>
</li>
<li> <p><code>M</code> - The desired (specified) image matrix.
</p>
</li>
<li> <p><code>k</code> - The number of iterations.
</p>
</li>
<li> <p><code>combinedPartitions</code> - Data frame with initial and final partition.
</p>
</li>
<li> <p><code>whenIncomers</code> - A vector of which elements tells us at which iterations the incomers were added.
</p>
</li>
<li> <p><code>whenOutgoers</code> - A vector of which elements tells us at which iterations the outgoers were removed.
</p>
</li>
<li> <p><code>ERR</code> - Sum of squared differences between the desired and empirical densities across blocks; for each iteration.
</p>
</li>
<li> <p><code>linkERR</code> - The difference in the number of links between the generated number of links and desired number of links; for each iteration.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formula &lt;- list(mutuality, popularity, OTPtransitivity)
X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
diag(X) &lt;- 0
M &lt;- matrix(c(0.1, 0.8, 0.8, 0.1), nrow = 2)
partition &lt;- c(1, 2, 2, 1, 1, 2, 2, 2, 1)
nemSymBMinout(X = X, 
              partition = partition, 
              formula = formula, 
              theta = c(1, 1, 1), 
              M = M, 
              k = 100, 
              minClusterSize = 2,
              nin = 10,
              nout = 5,
              loops = FALSE)
</code></pre>

<hr>
<h2 id='normalizeRsphere'>Normalize values on a sphere</h2><span id='topic+normalizeRsphere'></span>

<h3>Description</h3>

<p>Normalizes values of a vector such that the sum of squared elements equal to <code class="reqn">r^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeRsphere(x, r = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeRsphere_+3A_x">x</code></td>
<td>
<p>A vector or a matrix with values to be normalized.</p>
</td></tr>
<tr><td><code id="normalizeRsphere_+3A_r">r</code></td>
<td>
<p>The diameter of a sphere, default 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a data frame with normalized values.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalizeRsphere(x = c(1, 0.5, 0.4))
</code></pre>

<hr>
<h2 id='OSPtransitivity'>Outgoing shared partners mechanism</h2><span id='topic+OSPtransitivity'></span>

<h3>Description</h3>

<p>Calculates the network statistic according to the outgoing shared partners mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSPtransitivity(X, actor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSPtransitivity_+3A_x">X</code></td>
<td>
<p>Binary network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="OSPtransitivity_+3A_actor">actor</code></td>
<td>
<p>A unit (actor; row/column number), which have an opportunity to change a link.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the number of paths of length two between the actor and other units.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>References</h3>

<p>Cugmas, M., &amp; Žiberna, A. (2022). Approaches to blockmodeling dynamic networks: a Monte Carlo simulation study. Social Networks, in review.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
OSPtransitivity(X, actor = 2)
</code></pre>

<hr>
<h2 id='OTPtransitivity'>Outgoing two-path mechanism</h2><span id='topic+OTPtransitivity'></span>

<h3>Description</h3>

<p>Calculates the network statistic according to the outgoing two path mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OTPtransitivity(X, actor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OTPtransitivity_+3A_x">X</code></td>
<td>
<p>Binary network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="OTPtransitivity_+3A_actor">actor</code></td>
<td>
<p>A unit (actor; row/column number), which have an opportunity to change a link.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the number of paths of length two between the actor and other units.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>References</h3>

<p>Cugmas, M., &amp; Žiberna, A. (2022). Approaches to blockmodeling dynamic networks: a Monte Carlo simulation study. Social Networks, in print.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
OTPtransitivity(X, actor = 2)
</code></pre>

<hr>
<h2 id='popularity'>Popularity mechanism</h2><span id='topic+popularity'></span>

<h3>Description</h3>

<p>Calculate the normalized network statistic according to the popularity mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popularity(X, actor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popularity_+3A_x">X</code></td>
<td>
<p>Binary network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="popularity_+3A_actor">actor</code></td>
<td>
<p>Not used by the function, set to <code>NULL</code>. Necessary for using within other functions, e.g. nemBM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the normalized popularity mechanism, cacluated for each unit.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>References</h3>

<p>Cugmas, M., &amp; Žiberna, A. (2022). Approaches to blockmodeling dynamic networks: a Monte Carlo simulation study. Social Networks, in print.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
popularity(X)
</code></pre>

<hr>
<h2 id='randomizePartition'>Randomize a partition</h2><span id='topic+randomizePartition'></span>

<h3>Description</h3>

<p>It randomizes a partition by randomly relocating a given share of units between the clusters. The group sizes are preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomizePartition(partition, p, checkSelected = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomizePartition_+3A_partition">partition</code></td>
<td>
<p>Initial partition in a vector format. Each unique value (positive integers) represents one cluster.</p>
</td></tr>
<tr><td><code id="randomizePartition_+3A_p">p</code></td>
<td>
<p>The share of relocated units.</p>
</td></tr>
<tr><td><code id="randomizePartition_+3A_checkselected">checkSelected</code></td>
<td>
<p>If <code>TRUE</code> (default is <code>FALSE</code>) a given unit can be relocated only once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A partition (in a vector format).
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'>randomizePartition(partition = c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3), p = 0.3)
</code></pre>

<hr>
<h2 id='RL'>Relocating Links algorithm (RL algorithm)</h2><span id='topic+RL'></span>

<h3>Description</h3>

<p>It generates random network considering the selected types of triads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RL(ideal.net, initial.net, triads = "forb", k = 100, custom.triads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RL_+3A_ideal.net">ideal.net</code></td>
<td>
<p>Network with a desired blockmodel without inconsistencies; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="RL_+3A_initial.net">initial.net</code></td>
<td>
<p>Initial network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="RL_+3A_triads">triads</code></td>
<td>
<p>What types of triads has to be considered (allowed <code>allow</code>, forbidden <code>forb</code>, all <code>all</code> or custom <code>cust</code>). Provide a list of triad types as used in package ergm.</p>
</td></tr>
<tr><td><code id="RL_+3A_k">k</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code id="RL_+3A_custom.triads">custom.triads</code></td>
<td>
<p>A list with names of a subset of triads to be considered. The same names must be used as in ERGM package. Only if <code>triads = "cust"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contiainig: <code>new.network</code> which is the generated network (of class <code>matrix</code>); and <code>CR</code> which is
a vector of CR values (calculated after each iteration).
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>References</h3>

<p>Cugmas M, Ferligoj A, Žiberna A (2018) Generating global network structures by triad types. PLoS ONE 13(5): e0197514. https://doi.org/10.1371/journal.pone.0197514
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate initial and ideal network
cohesiveBM &lt;- rbind(c("com", "nul"), c("nul", "com"))
ideal &lt;- genNetworkLE(BM = cohesiveBM, LE = 0, size = c(4, 4))
random &lt;- genNetworkLE(BM = cohesiveBM, LE = 1, size = c(4, 4))
# generate network with the RL algorithm
generatedNetwork &lt;- RL(ideal.net = ideal, initial.net = random, triads = "all", k = 10)
</code></pre>

<hr>
<h2 id='SSEblock'>Sum of squared error across blocks</h2><span id='topic+SSEblock'></span>

<h3>Description</h3>

<p>It calculates the sum of square differences between the desired (specified by an image matrix M) denstities and empirical densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSEblock(X, M, partition, loops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSEblock_+3A_x">X</code></td>
<td>
<p>Initial binary network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="SSEblock_+3A_m">M</code></td>
<td>
<p>Image matrix with block densities.</p>
</td></tr>
<tr><td><code id="SSEblock_+3A_partition">partition</code></td>
<td>
<p>A partition in a vector format. Each unique value (positive integers) represents one cluster.</p>
</td></tr>
<tr><td><code id="SSEblock_+3A_loops">loops</code></td>
<td>
<p>Wheter loops are allowed or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of squared error (a single value).
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
diag(X) &lt;- 0
M &lt;- matrix(c(0.1, 0.4, 0.5, 0.3), nrow = 2)
partition &lt;- c(1, 2, 2, 1, 1, 2, 2, 2, 1)
SSEblock(X = X, M = M, partition = partition, loops = TRUE)
</code></pre>

<hr>
<h2 id='WeightedNetworkStatistics'>Weighted network statistics</h2><span id='topic+WeightedNetworkStatistics'></span>

<h3>Description</h3>

<p>It calculates the weighted network statistics, considering the selected local network mecahnisms and their weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WeightedNetworkStatistics(X, formula, theta, actor, randomSD = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WeightedNetworkStatistics_+3A_x">X</code></td>
<td>
<p>Binary network; of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="WeightedNetworkStatistics_+3A_formula">formula</code></td>
<td>
<p>The list of local netork mechanisms to be considered.</p>
</td></tr>
<tr><td><code id="WeightedNetworkStatistics_+3A_theta">theta</code></td>
<td>
<p>A vector with the mechanisms' weights/strengths.</p>
</td></tr>
<tr><td><code id="WeightedNetworkStatistics_+3A_actor">actor</code></td>
<td>
<p>A unit (actor; row/column number), which have an opportunity to change a link.</p>
</td></tr>
<tr><td><code id="WeightedNetworkStatistics_+3A_randomsd">randomSD</code></td>
<td>
<p>The srandard deviation of a normal distribution form which the random part of weighed network statistics is sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame with one column and the number of rows equal to the number of units.
</p>


<h3>Author(s)</h3>

<p>Marjan Cugmas and Aleš Žiberna
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formula &lt;- list(mutuality, popularity, OTPtransitivity)
X &lt;- matrix(sample(c(0,1), size = 9**2, replace = TRUE), nrow = 9)
WeightedNetworkStatistics(X = X, formula = formula, theta = c(1, 1, 1), actor = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
