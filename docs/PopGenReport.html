<!DOCTYPE html><html><head><title>Help for package PopGenReport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PopGenReport}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addline'><p>Function to add lines to landscape</p></a></li>
<li><a href='#addpoly'><p>Function to add a polygon to a landscape</p></a></li>
<li><a href='#allel.rich'><p>Calculates the allelic richness for a genind object</p></a></li>
<li><a href='#allele.dist'><p>Counts and visualises allele frequencies across loci and subpopulations</p></a></li>
<li><a href='#bilby'><p>Bilby data set</p></a></li>
<li><a href='#costdistances'><p>Calculates cost distances for a given landscape (resistance matrix)</p></a></li>
<li><a href='#emigration'><p>Function to execute emigration on a pops object</p></a></li>
<li><a href='#gd.kosman'><p>Individual genetic distance calculation based on Kosman &amp; Leonhard 2005</p></a></li>
<li><a href='#gd.smouse'><p>Individual genetic distance calculation based on Smouse and Peakall 1999</p></a></li>
<li><a href='#genleastcost'><p>Least-cost path analysis based on a friction matrix</p></a></li>
<li><a href='#init.popgensim'><p>Initialise a spatial meta-population for a popgen simulation</p></a></li>
<li><a href='#landgen'><p>A simulated genind data set with spatial coordinates</p></a></li>
<li><a href='#landgenreport'><p>Create a landscape genetic report</p></a></li>
<li><a href='#lgrMMRR'><p>Multiple Matrix Regression with Randomization analysis</p></a></li>
<li><a href='#mutation'><p>Function to execute mutation on a pop data.frame</p></a></li>
<li><a href='#null.all'><p>Checks for the presence of and determine the frequency of null alleles</p></a></li>
<li><a href='#opt.landgen'><p>Function for optimising a landscape genetic analysis based on resistance layers</p></a></li>
<li><a href='#p2p'><p>Function to calculate dispersal distances based on cost distances</p></a></li>
<li><a href='#pairwise.fstb'><p>Calculates pairwise fsts using a genind object (very fast)</p></a></li>
<li><a href='#pairwise.propShared'><p>Calculates proportion of shared alleles per pairs of populations</p></a></li>
<li><a href='#popgenreport'><p>This is the main function of the package. It analyses an object of class</p>
<code>genind</code> and then creates a report containing the results of the
analysis. There are several routines that can be optionally included in the
analysis and there are multiple output options including a PDF with the
report, R-code and an object (<code>fname.results</code>) containing all of the
results, which can be used for further analyses.</a></li>
<li><a href='#pops2genind'><p>Function converts pops to a genind object</p></a></li>
<li><a href='#possums'><p>A genlight object created via the read.genetable functions [possum data set from Sarre et al. 2015]</p></a></li>
<li><a href='#read.genetable'><p>Function to convert textfiles into a genind object (the format</p>
required for popgenreport)</a></li>
<li><a href='#reproduction'><p>Function to execute reproduction on a pop data.frame</p></a></li>
<li><a href='#run.popgensim'><p>Run a time-forward popgen simulation</p></a></li>
<li><a href='#spautocor'><p>Spatial autocorrelation following Smouse and Pekall 1999</p></a></li>
<li><a href='#wassermann'><p>Partial Mantel tests on costdistance matrices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Simple Framework to Analyse Population and Landscape Genetic
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides beginner friendly framework to analyse population genetic
    data. Based on 'adegenet' objects it uses 'knitr' to create comprehensive reports on spatial genetic data. 
    For detailed information how to use the package refer to the comprehensive
    tutorials or visit <a href="http://www.popgenreport.org/">http://www.popgenreport.org/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), knitr, adegenet (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, RgoogleMaps, gap, calibrate, xtable, plyr, dismo,
reshape2, ggplot2, R.utils, ade4, pegas, genetics, gdistance,
vegan, sp, mmod, GGally, graphics, grDevices, methods, stats,
utils, raster</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sf</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/green-striped-gecko/PopGenReport">https://github.com/green-striped-gecko/PopGenReport</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-11 06:11:21 UTC; s425824</td>
</tr>
<tr>
<td>Author:</td>
<td>Bernd Gruber [aut, cre],
  Aaron Adamack [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bernd Gruber &lt;bernd.gruber@canberra.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-11 07:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addline'>Function to add lines to landscape</h2><span id='topic+addline'></span>

<h3>Description</h3>

<p>adds a line from x1 to x2 to a raster layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addline(r, x1, x2, val, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addline_+3A_r">r</code></td>
<td>
<p>raster that represents the landscape</p>
</td></tr>
<tr><td><code id="addline_+3A_x1">x1</code></td>
<td>
<p>from coordinates</p>
</td></tr>
<tr><td><code id="addline_+3A_x2">x2</code></td>
<td>
<p>to coordinates</p>
</td></tr>
<tr><td><code id="addline_+3A_val">val</code></td>
<td>
<p>resistance value 1 is no resistance</p>
</td></tr>
<tr><td><code id="addline_+3A_plot">plot</code></td>
<td>
<p>switch if landscape should be plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns modified raster layer
</p>

<hr>
<h2 id='addpoly'>Function to add a polygon to a landscape</h2><span id='topic+addpoly'></span>

<h3>Description</h3>

<p>adds a polygon to a raster layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addpoly(r, pol, val, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addpoly_+3A_r">r</code></td>
<td>
<p>raster that represents the landscape</p>
</td></tr>
<tr><td><code id="addpoly_+3A_pol">pol</code></td>
<td>
<p>coordinates of the polygon</p>
</td></tr>
<tr><td><code id="addpoly_+3A_val">val</code></td>
<td>
<p>resistance value, One equals no resistance</p>
</td></tr>
<tr><td><code id="addpoly_+3A_plot">plot</code></td>
<td>
<p>switch if landscape should be plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns modified raster layer
</p>

<hr>
<h2 id='allel.rich'>Calculates the allelic richness for a genind object</h2><span id='topic+allel.rich'></span>

<h3>Description</h3>

<p>The function calculates the allelic richness for each combination of
population and locus for a genind object. To account for differences in
sample sizes and genotyping success, rarefication is used in the
calculation. The sample size for each combination of population and locus
was set equal to the smallest number of alleles seen in a sample across all
combinations of population and locus. Allelic richness was calculated using
the methods of Mousadik and Petit (1996) which are in turn based upon the
work of Hurlbert (1971).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allel.rich(population, min.alleles = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allel.rich_+3A_population">population</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code> object (from package adegenet)</p>
</td></tr>
<tr><td><code id="allel.rich_+3A_min.alleles">min.alleles</code></td>
<td>
<p>the minimum number of alleles that will be sampled for
calculating allelic richness. If min.alleles is set to NULL the min.alleles
sampled will be determined automatically (see description)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to the allelic.richness function in hiefstat. The
main differences between the two packages are that allel.rich works on a
genind object while allelic richness works on a data frame and allel.rich is
capable of determining allelic richness for species with most ploidies while
allelic.richness only works for haploid and diploid species.
</p>


<h3>Value</h3>

<p>Returns a list with the following entries:
</p>
<p>all.richness is the allelic richness for each combination of population and
locus sum.richness is the sum of the allelic richnesses for each population
mean.richness is the mean allelic richness across all loci alleles.sampled
is the smallest number of individuals sampled across all combinations of
population and locus multiplied by the ploidy of the species.  pop.sizes is
a matrix with the total number of alleles counted for each combination of
population and locus.
</p>


<h3>Author(s)</h3>

<p>Aaron Adamack, aaron.adamack@canberra.edu.au
</p>


<h3>References</h3>

<p>El Mousadik A, Petit RJ. (1996) High level of genetic
differentiation for allelic richness among populations of the argan tree
[Argania spinosa (L.) Skeels] endemic to Morocco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popgenreport">popgenreport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 data(bilby)
 popgenreport(bilby, mk.allel.rich=TRUE, mk.pdf=FALSE)
 #to get a pdf output you need to have a running Latex version installed
#on your system.
#popgenreport(bilby, mk.allel.rich=TRUE, mk.pdf=TRUE)

data(bilby)
allel.rich(bilby)
</code></pre>

<hr>
<h2 id='allele.dist'>Counts and visualises allele frequencies across loci and subpopulations</h2><span id='topic+allele.dist'></span>

<h3>Description</h3>

<p>Counts the number of observations for each combination of allele variant and
subpopulation for each locus. Calculates relative allele proportions for
each subpopulations and then produces a heatmap using that data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allele.dist(population, mk.figures = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allele.dist_+3A_population">population</code></td>
<td>
<p>this is the <code><a href="adegenet.html#topic+genind">genind</a></code> object the analysis will
be based on</p>
</td></tr>
<tr><td><code id="allele.dist_+3A_mk.figures">mk.figures</code></td>
<td>
<p>if set to FALSE no figures are plotted. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces heatmaps of the relative allele frequencies for each
subpopulation at each locus and returns a list containing the counts (count)
for each combination of allele and subpopulation and the relative
frequencies of alleles by subpopulation (frequency) for each locus. The
color bars on the heatmaps shows the relative frequency of an allele within
a subpopulation for a locus while the histogram gives an overall count for
the number of combinations of allele and subpopulation with a relative
frequency.
</p>


<h3>Author(s)</h3>

<p>Aaron Adamack, aaron.adamack@canberra.edu.au
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popgenreport">popgenreport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 data(bilby)
 #here we use only the first 50 individuals to speep up the example
 popgenreport(bilby, mk.allele.dist=TRUE, mk.pdf=FALSE)
 
#to get a pdf output you need to have a running Latex version installed on your system.
popgenreport(bilby, mk.allele.dist=TRUE, mk.pdf=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='bilby'>Bilby data set</h2><span id='topic+bilby'></span>

<h3>Description</h3>

<p>This is a synthetic sample data set (in <code><a href="adegenet.html#topic+genind">genind</a></code> format) of
microsatellite data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bilby
</code></pre>


<h3>Format</h3>

<p>genlight object
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber <a href="mailto:bernd.gruber@canberra.edu.au">bernd.gruber@canberra.edu.au</a>
</p>

<hr>
<h2 id='costdistances'>Calculates cost distances for a given landscape (resistance matrix)</h2><span id='topic+costdistances'></span>

<h3>Description</h3>

<p>calculates a cost distance matrix, to be used with run.popgensim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>costdistances(landscape, locs, method, NN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costdistances_+3A_landscape">landscape</code></td>
<td>
<p>a raster object coding the resistance of the landscape</p>
</td></tr>
<tr><td><code id="costdistances_+3A_locs">locs</code></td>
<td>
<p>coordinates of the subpopulations</p>
</td></tr>
<tr><td><code id="costdistances_+3A_method">method</code></td>
<td>
<p>defines the type of cost distance, types are &quot;least-cost&quot;, &quot;rSPDistance&quot; or &quot;commute (Circuitscape type)&quot;</p>
</td></tr>
<tr><td><code id="costdistances_+3A_nn">NN</code></td>
<td>
<p>number of next neighbours recommendation is 8</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a costdistance matrix between all pairs of locs
</p>

<hr>
<h2 id='emigration'>Function to execute emigration on a pops object</h2><span id='topic+emigration'></span>

<h3>Description</h3>

<p>emigration process on all population in one go
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emigration(xp, perc.mig, emi.m, emi.table = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emigration_+3A_xp">xp</code></td>
<td>
<p>all pops combined in a list</p>
</td></tr>
<tr><td><code id="emigration_+3A_perc.mig">perc.mig</code></td>
<td>
<p>percentage if migrating individuals</p>
</td></tr>
<tr><td><code id="emigration_+3A_emi.m">emi.m</code></td>
<td>
<p>emigration probability (normally based on cost dispersal distance)</p>
</td></tr>
<tr><td><code id="emigration_+3A_emi.table">emi.table</code></td>
<td>
<p>a fixed number of migrating individuals can be specified (overrides emi.m)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, first entry are updated pops, second entry the number of disperserin a matrix
</p>

<hr>
<h2 id='gd.kosman'>Individual genetic distance calculation based on Kosman &amp; Leonhard 2005</h2><span id='topic+gd.kosman'></span>

<h3>Description</h3>

<p>Calculates pairwise genetic distances between all individuals using the
individual genetic distance measure of Kosman and Leonard (2005). This
function is similiar to the dist.codom in the package mmod. The two
functions differ in their treatment of individuals with missing data.
dist.codom omits individuals from the calculation of pairwise individual
genetic distances while this function includes individuals with missing
data. This is done by simply calculating the mean individual pairwise
genetic distance over all loci for which there are values. Note that
depending on your computers capabilities, you may run into memory errors
when this function is used on datasets with large numbers of individuals
(&gt;1000). Additionally, the time for this function to run can be lengthy.
Using a PC with a 3.5 GHz processor to calculate pairwise genetic distances
between individuals with 36 diploid loci it took 0.3 seconds for 100
individuals, 5 seconds for 500 individuals, 21 seconds for 1000 individuals,
84 seconds for 2000 individuals, and 194 seconds for 3000 individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gd.kosman(population)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gd.kosman_+3A_population">population</code></td>
<td>
<p>this is the <code><a href="adegenet.html#topic+genind">genind</a></code> object the analysis will
be based on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with two distance matrices. The first (geneticdist)
contains pairwise individual genetic distances for each individual within a
population, the second (loci_used) provides the number of loci that were
used to calculate pairwise individual genetic distances between a pair of
individuals.
</p>


<h3>Author(s)</h3>

<p>Aaron Adamack, aaron.adamack@canberra.edu.au
</p>


<h3>References</h3>

<p>Kosman E., Leonard K.J. 2005. Similarity coefficients for
molecular markers in studies of genetic relationships between individuals
for haploid, diploid, and polyploidy species. Molecular Ecology 14:415-424.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popgenreport">popgenreport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(bilby)
popgenreport(bilby, mk.gd.kosman = TRUE, mk.pdf=FALSE)

## End(Not run)
#to get a pdf output you need to have a running Latex version installed on your system.
#popgenreport(bilby, mk.gd.kosman = TRUE, mk.pdf=TRUE)
</code></pre>

<hr>
<h2 id='gd.smouse'>Individual genetic distance calculation based on Smouse and Peakall 1999</h2><span id='topic+gd.smouse'></span>

<h3>Description</h3>

<p>Calculate pairwise genetic distances between all individuals using the
individual genetic distance measure of Smouse and Peakall (1999). This
function should produce the same results as the individual genetic distances
calculated using GenAlEx and choosing the interpolate missing data option.
Note that depending on your computers capabilities, you may run into memory
errors when this function is used on datasets with large numbers of
individuals (&gt;1000). Additionally, the time for this function to run can be
quite lengthy. Using a PC with a 3.5 GHz processor to calculate pairwise
genetic distances between individuals with 36 diploid loci it took 2 seconds
for 100 individuals, 51 seconds for 500 individuals, 200 seconds for 1000
individuals, 836 seconds (~14 minutes) for 2000 individuals, and 1793
seconds (~30 minutes) for 3000 individuals.  Please note that for each of
your population groupings there must be at least one individual with
genotyped alleles for each locus (it doesn't have to be the same individual
for every locus). If a population doesn't meet this requirement, it will be
dropped from the analysis and a warning message will be generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gd.smouse(population, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gd.smouse_+3A_population">population</code></td>
<td>
<p>this is the <code><a href="adegenet.html#topic+genind">genind</a></code> object that the analysis
will be based on.</p>
</td></tr>
<tr><td><code id="gd.smouse_+3A_verbose">verbose</code></td>
<td>
<p>information on progress. For large data sets this could be
informative as it allows the user to estimate the amount of time remaining
until the function is complete. The counter shows the number of the
population for which genetic distances are currently being determined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns pairwise individual genetic distances for each individual
within a population.
</p>


<h3>Author(s)</h3>

<p>Aaron Adamack, aaron.adamack@canberra.edu.au
</p>


<h3>References</h3>

<p>Smouse PE, Peakall R. 1999. Spatial autocorrelation analysis of
individual multiallele and multilocus genetic structure. Heredity 82:
561-573.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popgenreport">popgenreport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(bilby)
popgenreport(bilby, mk.gd.smouse = TRUE, mk.pdf=FALSE)
#to get a pdf output you need to have a running Latex version installed on your system.
#popgenreport(bilby, mk.gd.smouse = TRUE, mk.pdf=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='genleastcost'>Least-cost path analysis based on a friction matrix</h2><span id='topic+genleastcost'></span>

<h3>Description</h3>

<p>This function calculates the pairwise distances (Euclidean, cost path
distances and genetic distances) of populations using a friction matrix and
a spatial genind object. The genind object needs to have coordinates in the
same projected coordinate system as the friction matrix. The friction matrix
can be either a single raster of a stack of several layers. If a stack is
provided the specified cost distance is calculated for each layer in the
stack. The output of this function can be used with the functions
<code><a href="#topic+wassermann">wassermann</a></code> or <code><a href="#topic+lgrMMRR">lgrMMRR</a></code> to test for the
significance of a layer on the genetic structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genleastcost(
  cats,
  fric.raster,
  gen.distance,
  NN = NULL,
  pathtype = "leastcost",
  plotpath = TRUE,
  theta = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genleastcost_+3A_cats">cats</code></td>
<td>
<p>a spatial genind object. see ?popgenreport how to provide
coordinates in genind objects</p>
</td></tr>
<tr><td><code id="genleastcost_+3A_fric.raster">fric.raster</code></td>
<td>
<p>a friction matrix</p>
</td></tr>
<tr><td><code id="genleastcost_+3A_gen.distance">gen.distance</code></td>
<td>
<p>specification which genetic distance method should be
used to calculate pairwise genetic distances between populations ( &quot;D&quot;,
&quot;Gst.Nei&quot;, &quot;Gst.Hedrick&quot;) or individuals (&quot;Smouse&quot;, &quot;Kosman&quot;, &quot;propShared&quot;)</p>
</td></tr>
<tr><td><code id="genleastcost_+3A_nn">NN</code></td>
<td>
<p>Number of neighbours used when calculating the cost distance
(possible values 4,8 or 16). As the default is NULL a value has to be
provided if pathtype='leastcost'. NN=8 is most commonly used. Be aware that
linear structures may cause artefacts in the least-cost paths, therefore
inspect the actual least-cost paths in the provided output.</p>
</td></tr>
<tr><td><code id="genleastcost_+3A_pathtype">pathtype</code></td>
<td>
<p>Type of cost distance to be calculated (based on function in
the <code><a href="gdistance.html#topic+gdistance">gdistance</a></code> package. Available distances are 'leastcost',
'commute' or 'rSPDistance'. See functions in the gdistance package for
futher explanations. If the path type is set to 'leastcost' then paths and
also pathlength are returned.</p>
</td></tr>
<tr><td><code id="genleastcost_+3A_plotpath">plotpath</code></td>
<td>
<p>switch if least cost paths should be plotted (works only if
pathtype='leastcost'. Be aware this slows down the computation, but it is
recommended to do this to check least cost paths visually.</p>
</td></tr>
<tr><td><code id="genleastcost_+3A_theta">theta</code></td>
<td>
<p>value needed for rSPDistance function. see
<code><a href="gdistance.html#topic+rSPDistance">rSPDistance</a></code> in package <code>gdistance</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>to be written
</p>


<h3>Value</h3>

<p>returns a list that consists of four pairwise distance matrixes
(Euclidean, Cost, length of path and genetic) and the actual paths as
spatial line objects.
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber
</p>


<h3>References</h3>

<p>Cushman, S., Wasserman, T., Landguth, E. and Shirk, A. (2013).
Re-Evaluating Causal Modeling with Mantel Tests in Landscape Genetics.
Diversity, 5(1), 51-72.
</p>
<p>Landguth, E. L., Cushman, S. A., Schwartz, M. K., McKelvey, K. S., Murphy,
M. and Luikart, G. (2010). Quantifying the lag time to detect barriers in
landscape genetics. Molecular ecology, 4179-4191.
</p>
<p>Wasserman, T. N., Cushman, S. A., Schwartz, M. K. and Wallin, D. O. (2010).
Spatial scaling and multi-model inference in landscape genetics: Martes
americana in northern Idaho. Landscape Ecology, 25(10), 1601-1612.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landgenreport">landgenreport</a></code>, <code><a href="#topic+popgenreport">popgenreport</a></code>,
<code><a href="#topic+wassermann">wassermann</a></code>, <code><a href="#topic+lgrMMRR">lgrMMRR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(raster)
fric.raster &lt;- readRDS(system.file("extdata","fric.raster.rdata", package="PopGenReport"))
glc &lt;- genleastcost(cats=landgen, fric.raster, "D", NN=8)
wassermann(eucl.mat = glc$eucl.mat, cost.mat = glc$cost.mats, gen.mat = glc$gen.mat)
lgrMMRR(gen.mat = glc$gen.mat, cost.mats = glc$cost.mats, eucl.mat = glc$eucl.mat)

</code></pre>

<hr>
<h2 id='init.popgensim'>Initialise a spatial meta-population for a popgen simulation</h2><span id='topic+init.popgensim'></span>

<h3>Description</h3>

<p>This functions initialises a time-forward, agent-based and spatiallly explicit genetic meta-population simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init.popgensim(
  n.pops,
  n.ind,
  sex.ratio,
  n.loci,
  n.allels,
  locs = NULL,
  n.cov = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init.popgensim_+3A_n.pops">n.pops</code></td>
<td>
<p>number of subpopulations</p>
</td></tr>
<tr><td><code id="init.popgensim_+3A_n.ind">n.ind</code></td>
<td>
<p>number of individuals per subpopulation</p>
</td></tr>
<tr><td><code id="init.popgensim_+3A_sex.ratio">sex.ratio</code></td>
<td>
<p>sex ratio of males and females</p>
</td></tr>
<tr><td><code id="init.popgensim_+3A_n.loci">n.loci</code></td>
<td>
<p>number of loci</p>
</td></tr>
<tr><td><code id="init.popgensim_+3A_n.allels">n.allels</code></td>
<td>
<p>number of maximal alleles per loci</p>
</td></tr>
<tr><td><code id="init.popgensim_+3A_locs">locs</code></td>
<td>
<p>coordinates of the subpopulations, provided as a row named data.frame(x=, y=) with n.pops rows.[Only used to name the subpopulations by row.names(locs). If not provided subpopulations are simply numbered.</p>
</td></tr>
<tr><td><code id="init.popgensim_+3A_n.cov">n.cov</code></td>
<td>
<p>number of covariates (currenlty do not change, defaults to 3. In future versions covariates such as age etc. will be implemented)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To set up a population we have to specify the following parameters: n.pops defines the number of subpopulations and n.ind the number of individuals within subpopulations (carrying capacity). In the current implementaiton all subpopulations have the same number of individuals. sex.ratio determines the proportion of females in a subpopulation. finaly the number of loci and number of alleles need to be specified. locs is used to name the populations. For simplicity the names are provided via a data.frame of x and y coordinates (as they normally come from a genind object)
</p>


<h3>Value</h3>

<p>a simpops object (to be used in run.popgensim ), which is a list of subpopulations. Each subpopulation consists of a data.frame with a row for each individual (coding the covariates and genetic make-up).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.popgensim">run.popgensim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init.popgensim(n.pops = 5, n.ind=8, sex.ratio = 0.25, n.loci = 4, n.allels = 7, n.cov = 3)
</code></pre>

<hr>
<h2 id='landgen'>A simulated genind data set with spatial coordinates</h2><span id='topic+landgen'></span>

<h3>Description</h3>

<p>This data set is used to demonstrate the use of the
<code><a href="#topic+landgenreport">landgenreport</a></code> and <code><a href="#topic+genleastcost">genleastcost</a></code> functions. It is
a simple spatial <code>genind</code> object with 100 individuals in 10 populations
and 20 loci with up to 20 alleles per loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landgen
</code></pre>


<h3>Format</h3>

<p>An object of class <code>genind</code> of length 1.
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber <a href="mailto:bernd.gruber@canberra.edu.au">bernd.gruber@canberra.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landgenreport">landgenreport</a></code>, <code><a href="#topic+genleastcost">genleastcost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(landgen)
summary(landgen)
</code></pre>

<hr>
<h2 id='landgenreport'>Create a landscape genetic report</h2><span id='topic+landgenreport'></span>

<h3>Description</h3>

<p>This function is the landscape genetic version of the
<code><a href="#topic+popgenreport">popgenreport</a></code> function. It needs to be provided with a genind
object with spatial coordinates, a friction map (raster) and a specification
which type of genetic distance should be used.  Once all three type of input
are provided with the necessary input, a landscape genetic analysis using
least cost path analysis is computed (see Cushman et al. 2010, Landguth et
al. 2010). Depending on the genetic distance meassurement this is done on a
subpopulation basis (D, Gst.Hedrick, Gst.Nei=Fst) or on an individual basis
(Kosman, Smouse).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landgenreport(
  cats,
  fric.raster,
  gen.distance = "Gst.Nei",
  NN = NULL,
  pathtype = "leastcost",
  plotpath = TRUE,
  theta = 1,
  mk.resistance = TRUE,
  mapdotcolor = "blue",
  mapdotsize = 1,
  mapdotalpha = 0.4,
  mapdottype = 19,
  mapzoom = NULL,
  mk.custom = FALSE,
  fname = "LandGenReport",
  foldername = "results",
  path.pgr = NULL,
  mk.Rcode = FALSE,
  mk.complete = FALSE,
  mk.pdf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landgenreport_+3A_cats">cats</code></td>
<td>
<p>a <code>genind</code> object with spatial coordinates in the other
slot</p>
</td></tr>
<tr><td><code id="landgenreport_+3A_fric.raster">fric.raster</code></td>
<td>
<p>friction (resistance) raster, that specifies the
landscape where the analysis should be computed on. If fric.raser is a stack
a cost distances are calculated for each layer in the stack.</p>
</td></tr>
<tr><td><code id="landgenreport_+3A_gen.distance">gen.distance</code></td>
<td>
<p>type of genetic distance that should be used. Depending
on the genetic distance meassurement this is done on a subpopulation basis
(D, Gst.Hedrick, Gst.Nei=Fst) or on an individual basis (Kosman, Smouse,
propShared). propShared is the proportion of shared alleles between
individuals.</p>
</td></tr>
<tr><td><code id="landgenreport_+3A_nn">NN</code></td>
<td>
<p>Number of neighbours used when calculating the cost distance
(possible values 4,8 or 16). As the default is NULL a value has to be
provided if pathtype is 'leastcost'. NN=8 is most commonly used as it avoids
a directional bias, but be aware that linear structures may cause artefacts
in the least-cost paths in the NN=8 case, therefore we strongly recommend to
inspect the actual least-cost paths in the provided output.</p>
</td></tr>
<tr><td><code id="landgenreport_+3A_pathtype">pathtype</code></td>
<td>
<p>Type of cost distance to be calculated (based on function in
the <code><a href="gdistance.html#topic+gdistance">gdistance</a></code> package. Available distances are 'leastcost',
'commute' or 'rSPDistance'. See functions in the gdistance package for
futher explanations.</p>
</td></tr>
<tr><td><code id="landgenreport_+3A_plotpath">plotpath</code></td>
<td>
<p>switch if least cost paths should be plotted (works only if
pathtype='leastcost'. Be aware this slows down the computation, but it is
recommended to check least cost paths visually.</p>
</td></tr>
<tr><td><code id="landgenreport_+3A_theta">theta</code></td>
<td>
<p>value needed for rSPDistance function. see
<code><a href="gdistance.html#topic+rSPDistance">rSPDistance</a></code> in package <code>gdistance</code>.</p>
</td></tr>
<tr><td><code id="landgenreport_+3A_mk.resistance">mk.resistance</code></td>
<td>
<p>switch to do the landscape genetic analysis based on
resistance matrices, should be set to TRUE</p>
</td></tr>
<tr><td><code id="landgenreport_+3A_mapdotcolor">mapdotcolor</code></td>
<td>
<p>see <code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
<tr><td><code id="landgenreport_+3A_mapdotsize">mapdotsize</code></td>
<td>
<p>see <code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
<tr><td><code id="landgenreport_+3A_mapdotalpha">mapdotalpha</code></td>
<td>
<p>see<code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
<tr><td><code id="landgenreport_+3A_mapdottype">mapdottype</code></td>
<td>
<p>see <code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
<tr><td><code id="landgenreport_+3A_mapzoom">mapzoom</code></td>
<td>
<p>see <code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
<tr><td><code id="landgenreport_+3A_mk.custom">mk.custom</code></td>
<td>
<p>switch to add a customised part to the landgenreport</p>
</td></tr>
<tr><td><code id="landgenreport_+3A_fname">fname</code></td>
<td>
<p>see <code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
<tr><td><code id="landgenreport_+3A_foldername">foldername</code></td>
<td>
<p>see <code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
<tr><td><code id="landgenreport_+3A_path.pgr">path.pgr</code></td>
<td>
<p>see <code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
<tr><td><code id="landgenreport_+3A_mk.rcode">mk.Rcode</code></td>
<td>
<p>see <code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
<tr><td><code id="landgenreport_+3A_mk.complete">mk.complete</code></td>
<td>
<p>see <code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
<tr><td><code id="landgenreport_+3A_mk.pdf">mk.pdf</code></td>
<td>
<p>see <code><a href="#topic+popgenreport">popgenreport</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Check the help pages of <code><a href="#topic+popgenreport">popgenreport</a></code> how to include
coordinates to a genind object. The coordinates need to be projected.
Latlongs are not valid, because Euclidean distances are calcuated based on
these coordinates. For an example how to convert latlongs into a projected
format have a look at the vignette that comes with this package. The
friction needs to be a raster and needs to be in the same projection as the
genind object. Also the type of genetic distance to be used needs to be
specified.
</p>


<h3>Value</h3>

<p>Four distance matrices are returned. Pairwise Euclidean distances
between subpopulations/individuals, cost distances, path lengths and genetic
distances. Also following the approach of Wassermann et al. 2010 a series of
partial mantel tests are performed. A multiple regression analysis based on
Wang 2013 and Legendre 1994 is returned.The actual least-cost paths can be
found under paths
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber (bernd.gruber@canberra.edu.au)
</p>


<h3>References</h3>

<p>Cushman, S., Wasserman, T., Landguth, E. and Shirk, A. (2013).
Re-Evaluating Causal Modeling with Mantel Tests in Landscape Genetics.
Diversity, 5(1), 51-72.
</p>
<p>Landguth, E. L., Cushman, S. A., Schwartz, M. K., McKelvey, K. S., Murphy,
M. and Luikart, G. (2010). Quantifying the lag time to detect barriers in
landscape genetics. Molecular ecology, 4179-4191.
</p>
<p>Wang,I 2013. Examining the full effects of landscape heterogeneity on
spatial genetic variation: a multiple matrix regression approach for
quantifying geographic and ecological isolation. Evolution: 67-12:
3403-3411.
</p>
<p>Wasserman, T. N., Cushman, S. A., Schwartz, M. K. and Wallin, D. O. (2010).
Spatial scaling and multi-model inference in landscape genetics: Martes
americana in northern Idaho. Landscape Ecology, 25(10), 1601-1612.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popgenreport">popgenreport</a></code>, <code><a href="#topic+wassermann">wassermann</a></code>,
<code><a href="#topic+genleastcost">genleastcost</a></code>, <code><a href="#topic+lgrMMRR">lgrMMRR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(raster)
fric.raster &lt;- readRDS(system.file("extdata","fric.raster.rdata", package="PopGenReport"))
lc&lt;-landgenreport(cats=landgen, fric.raster=fric.raster,
gen.distance="D", NN=4, mk.resistance=TRUE, mk.pdf=FALSE)
names(lc$leastcost)

</code></pre>

<hr>
<h2 id='lgrMMRR'>Multiple Matrix Regression with Randomization analysis</h2><span id='topic+lgrMMRR'></span>

<h3>Description</h3>

<p>performs Multiple Matrix Regression with Randomization analysis This method
was implemented by Wang 2013 (MMRR function see references) and also by
Sarah Goslee in package ecodist. lgrMMRR is a simple wrapper to have a more
user friendly output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgrMMRR(gen.mat, cost.mats, eucl.mat = NULL, nperm = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgrMMRR_+3A_gen.mat">gen.mat</code></td>
<td>
<p>a genetic distance matrix (e.g. output from
<code><a href="#topic+genleastcost">genleastcost</a></code></p>
</td></tr>
<tr><td><code id="lgrMMRR_+3A_cost.mats">cost.mats</code></td>
<td>
<p>a list of cost distance matrices</p>
</td></tr>
<tr><td><code id="lgrMMRR_+3A_eucl.mat">eucl.mat</code></td>
<td>
<p>pairwise Euclidean distance matrix. If not specificed
ignored</p>
</td></tr>
<tr><td><code id="lgrMMRR_+3A_nperm">nperm</code></td>
<td>
<p>the number of permutations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs multiple regression on distance matrices following the methods
outlined in Legendre et al. 1994 and implemented by Wang 2013.
</p>


<h3>Value</h3>

<p>a table with the results of the matrix regression analysis.
(regression coefficients and associated p-values from the permutation test
(using the pseudo-t of Legendre et al. 1994).  and also r.squared from and
associated p-value from the permutation test. F.test.
</p>
<p>Finally also the F-statistic and p-value for overall F-test for lack of fit.
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber (bernd.gruber@canberra.edu.au) using the
implementation of Wang 2013.
</p>


<h3>References</h3>

<p>Legendre, P.; Lapointe, F. and Casgrain, P. 1994. Modeling brain
evolution from behavior: A permutational regression approach. Evolution 48:
1487-1499.
</p>
<p>Lichstein, J. 2007. Multiple regression on distance matrices: A multivariate
spatial analysis tool. Plant Ecology 188: 117-131.
</p>
<p>Wang,I 2013. Examining the full effects of landscape heterogeneity on
spatial genetic variation: a multiple matrix regression approach for
quantifying geographic and ecological isolation. Evolution: 67-12:
3403-3411.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popgenreport">popgenreport</a></code>,
<code><a href="#topic+genleastcost">genleastcost</a></code>, <code><a href="#topic+landgenreport">landgenreport</a></code>,
<code><a href="#topic+wassermann">wassermann</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(landgen)
library(raster)
fric.raster &lt;- readRDS(system.file("extdata","fric.raster.rdata", package="PopGenReport"))
glc &lt;- genleastcost(landgen, fric.raster, "D", NN=4, path="leastcost")
lgrMMRR(glc$gen.mat, glc$cost.mats, glc$eucl.mat, nperm=999)

</code></pre>

<hr>
<h2 id='mutation'>Function to execute mutation on a pop data.frame</h2><span id='topic+mutation'></span>

<h3>Description</h3>

<p>mutation subprocess on single populations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation(x, n.allels, mutrate, mtype = "n.all", n.cov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutation_+3A_x">x</code></td>
<td>
<p>a pop object</p>
</td></tr>
<tr><td><code id="mutation_+3A_n.allels">n.allels</code></td>
<td>
<p>number of alleles</p>
</td></tr>
<tr><td><code id="mutation_+3A_mutrate">mutrate</code></td>
<td>
<p>the mutation rate</p>
</td></tr>
<tr><td><code id="mutation_+3A_mtype">mtype</code></td>
<td>
<p>the mutation process (currently on n.all is implemented. (=Choose any allel from 1:n.allels))</p>
</td></tr>
<tr><td><code id="mutation_+3A_n.cov">n.cov</code></td>
<td>
<p>(number of covariates, default  )</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dispersal probability matrix
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber, Erin Peterson
</p>

<hr>
<h2 id='null.all'>Checks for the presence of and determine the frequency of null alleles</h2><span id='topic+null.all'></span>

<h3>Description</h3>

<p>The function null.all determines the frequency of null alleles at each locus
of a genind object. As an initial step, the function makes a bootstrap
estimate (based on the observed allele frequencies) of the probability of
seeing the number of homozygotes observed for each allele. If there are a
large number of null alleles present at a locus, it would result in multiple
alleles at a locus having an excess of homozygotes. The second step of the
function estimates the frequency of null alleles and a bootstrap confidence
interval for each locus using the methods of Chakraborty et al. (1994) and
Brookfield (1996). If the 95% confidence interval includes zero, it
indicates that the frequency of null alleles at a locus does not
significantly differ from zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null.all(population)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null.all_+3A_population">population</code></td>
<td>
<p>a <code><a href="adegenet.html#topic+genind">genind</a></code> object (from the package adegenet)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with two main components: homozygotes
and null.allele.freq.  Homozygotes contains the output of the first part of
the analysis: determining the observed number of homozygotes for allele at
each locus (homozygotes$observed), generating a distribution of the expected
number of homozygotes for each allele at each locus (homozygotes$bootstrap)
based upond the observed allele frequencies at a locus, and producing a
summary table given the probability of observing the number of homozygotes
(homozygotes$probability.obs).  null.allele.freq list contains summary
tables of the null allele frequency estimates based upon the forumulas of
Chakraborty et al. (1994) (summary1), and Brookfield (1996) (summary2). For
each summary table, the observed frequency is the null allele frequency
determined from the observed heterozygosity and homozygosity at a locus. The
median, 2.5th, and 97.5th percentiles are from bootstrap estimates of null
allele frequencies obtained by resampling the individual genotypes from the
original genind object.
</p>
<p>Brookfield (1996) provides a brief discussion on which estimator should be
used. In summary, it was recommended that Chakraborty et al. (1994)'s method
(e.g. summary1) be used if there are individuals with no bands at a locus
seen, but they are discounted as possible artefacts. If all individuals have
one or more bands at a locus then Brookfield (1996)'s method (e.g. summary2)
should be used.
</p>


<h3>Author(s)</h3>

<p>Aaron Adamack, aaron.adamack@canberra.edu.au
</p>


<h3>References</h3>

<p>Brookfield JFY. (1996) A simple new method for estimating null
allele frequency from heterozygote deficiency. Molecular Ecology 5:453-455
</p>
<p>Chakraborty R, Zhong Y, Jin L, Budowle B. (1994) Nondetectability of
restriction fragments and independence of DNA fragment sizes within and
between loci in RFLP typing of DNA. American Journal of Human Genetics
55:391-401
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popgenreport">popgenreport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 data(bilby)
 #here we use only the first 50 individuals to speep up the example
 popgenreport(bilby, mk.null.all=TRUE, mk.pdf=FALSE)
 
#to get a pdf output you need to have a running Latex version installed on your system.
#popgenreport(bilby, mk.null.all=TRUE, mk.pdf=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='opt.landgen'>Function for optimising a landscape genetic analysis based on resistance layers</h2><span id='topic+opt.landgen'></span>

<h3>Description</h3>

<p>opt.landgen places iter times nlocations in a given landscape. For each scenario the pairwise costdistances and Euclidean distances are calculated and the standard deviation of detour (see Gruber et al. in prep) is calculated. This metric evaluates the scenerio in their ability to find a significant effect for the given resistance layer on population structure (based on the causal modelling approach of Cushman et al.). To allow for more realistic designs previously locations, a minimal distance between locations and a mask that indicates &quot;forbidden&quot; areas can be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.landgen(
  landscape,
  nlocations,
  mindist = 0,
  fixed = NULL,
  method,
  NN = 8,
  iter = 100,
  retry = 10,
  mask = NULL,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.landgen_+3A_landscape">landscape</code></td>
<td>
<p>resistance layer as a raster object (if not projected dimensions are assumed to be in meters!!)</p>
</td></tr>
<tr><td><code id="opt.landgen_+3A_nlocations">nlocations</code></td>
<td>
<p>the number of locations</p>
</td></tr>
<tr><td><code id="opt.landgen_+3A_mindist">mindist</code></td>
<td>
<p>minimal distance in map units (meter if not specified)</p>
</td></tr>
<tr><td><code id="opt.landgen_+3A_fixed">fixed</code></td>
<td>
<p>n fixed locations, provided as a data.frame with dimenstions nx2</p>
</td></tr>
<tr><td><code id="opt.landgen_+3A_method">method</code></td>
<td>
<p>least cost path algorithm provided by the gdistance package. Options are &quot;leastcost&quot;, &quot;SPDistance&quot; and &quot;commute&quot;. see function costdistances.</p>
</td></tr>
<tr><td><code id="opt.landgen_+3A_nn">NN</code></td>
<td>
<p>number of next neighboring cells to be used, default is 8. see function costdistances.</p>
</td></tr>
<tr><td><code id="opt.landgen_+3A_iter">iter</code></td>
<td>
<p>number of iterations that should be used to find an optimised design. Try initially the default and if it runs fast (depends on the type of costdistance an d dimenstions of landscape), increase to higher values.</p>
</td></tr>
<tr><td><code id="opt.landgen_+3A_retry">retry</code></td>
<td>
<p>number of retries if optimisation is not possible in a certain iteration (due to mindist and/or fixed locations). Defaults to 10, which should be sufficient in most cases.</p>
</td></tr>
<tr><td><code id="opt.landgen_+3A_mask">mask</code></td>
<td>
<p>a raster object that masks positions which are not available. Areas which are not to be used for locations are coded as NA (not available), all other values are treated as suitable for placing locations.</p>
</td></tr>
<tr><td><code id="opt.landgen_+3A_plot">plot</code></td>
<td>
<p>if true, some plots are presented that show the histogramm, ecdf of the best (and the worst scenario).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object with two slots. The first slot is called opt and contains iter optimisation values (sd.detour and sd.cost) in a iter x 2 dimenstional data.frame. The second slot is called scenario and contains the corrosponding 1:iter scenarios, given as coordinates in a data.frame of dimensions nlocations x 2. Both slots are ordered in decreasing order of sd.detour values. So the best scenario is at 1 and the worst is at position iter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(raster)
fric.raster &lt;- readRDS(system.file("extdata","fric.raster.rdata", package="PopGenReport"))
opt.landgen(landscape = fric.raster, nlocations = 5, mindist = 3, 
method = "leastcost", NN = 8, iter = 10)

</code></pre>

<hr>
<h2 id='p2p'>Function to calculate dispersal distances based on cost distances</h2><span id='topic+p2p'></span>

<h3>Description</h3>

<p>converts cost distances to probabilities: to reach a certain patch[ d0 average distance of p of all individuals, for example d0=100, p =0.5 -&gt; 50% procent of all migrating individuals go up to 100 m.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2p(x, d0, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2p_+3A_x">x</code></td>
<td>
<p>Cost (Euclidean) distance matrix</p>
</td></tr>
<tr><td><code id="p2p_+3A_d0">d0</code></td>
<td>
<p>dispersal distance</p>
</td></tr>
<tr><td><code id="p2p_+3A_p">p</code></td>
<td>
<p>of all individuals in a population</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dispersal probability matrix
</p>

<hr>
<h2 id='pairwise.fstb'>Calculates pairwise fsts using a genind object (very fast)</h2><span id='topic+pairwise.fstb'></span>

<h3>Description</h3>

<p>for simulation the original pairwise.fst was too slow. The fast version works only with genind objects without NAs and diploid data (so to be save do not use it on non-simulated data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.fstb(gsp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.fstb_+3A_gsp">gsp</code></td>
<td>
<p>a genind object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pairwise fst matrix (same as hierfstat pairwise.fst)
</p>

<hr>
<h2 id='pairwise.propShared'>Calculates proportion of shared alleles per pairs of populations</h2><span id='topic+pairwise.propShared'></span>

<h3>Description</h3>

<p>Calculates proportion of shared alleles per pairs of populations based on the minima of allele frequency for each allel (then summed and averaged over loci). Returns a similarity matrix (upper diagonal of the pairwise matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.propShared(gi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.propShared_+3A_gi">gi</code></td>
<td>
<p>a genind object with at least two populations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of proportion of shared alleles between populations
</p>

<hr>
<h2 id='popgenreport'>This is the main function of the package. It analyses an object of class
<code><a href="adegenet.html#topic+genind">genind</a></code> and then creates a report containing the results of the
analysis. There are several routines that can be optionally included in the
analysis and there are multiple output options including a PDF with the
report, R-code and an object (<code>fname.results</code>) containing all of the
results, which can be used for further analyses.</h2><span id='topic+popgenreport'></span>

<h3>Description</h3>

<p>This function is used to analyse population genetic data. The main idea is
to provide a framework for analysing microsatellite and also SNP genetic
data (if not too many loci, say below 1000) using a mix of existing and new
functions. The function works on an object of class <code>genind</code>. There are
several ways to convert data into a <code><a href="adegenet.html#topic+genind">genind</a></code> object using
existing functions provided by the <code>adegenet</code> package (
<code><a href="adegenet.html#topic+import2genind">import2genind</a></code>,
<code><a href="adegenet.html#topic+df2genind">df2genind</a></code>,<code><a href="adegenet.html#topic+read.fstat">read.fstat</a></code>,
<code><a href="adegenet.html#topic+read.structure">read.structure</a></code>, <code><a href="adegenet.html#topic+read.genetix">read.genetix</a></code>
,<code><a href="adegenet.html#topic+read.genepop">read.genepop</a></code>) or refer to <code>read.genetable</code> how to import
data from an EXCEL (csv) document. The function performs a number of
different genetic analyses (e.g. counts of indivuals and alleles across
sub-populations, tests for heterozygosity and Hardy-Weinberg Equilibrium,
differentiation statistics Fst, G'st, Jost's D, and genetic distance between
individuals and populations), with users having the option to select which
analysis routines are included in the report. To select a routine, the user
simply turns on a switch e.g. mk.map=TRUE returns a map with the sampling
location for each individual (if coordinates are provided). <br /> Coordinates
need to specified within the genind object. As a standard genind object does
not require spatial coordinates, we extended it by using the <code>other</code>
slot in the genind object. The easiest way to provide spatial coordinates is
to use the read.genetable function and use the <code>lat</code>, <code>long</code> or
<code>x</code>, <code>y</code> arguments for WGS1984 projected data or mercator
projected data respectively. To calculate distances the data are internally
reprojected using the <code><a href="dismo.html#topic+Mercator">Mercator</a></code> function in package
<code><a href="dismo.html#topic+dismo">dismo</a></code>), which is the projection used by google maps. Or you
can add data manually to your <code>genind</code> object using the mentioned (e.g.
<code>genindobject@other$latlong &lt;- yourlatlong data</code> or
<code>genindobject@other$xy &lt;- your_xy_data</code>). If you have your data in a
different projection you need to reproject them into either WGS1984 or the
google maps Mercator projection. If you use a different projection distance
calculation may be wrong and probably the map will not be correct. See the
manual for an example how to project and add spatial coordinates to your
genetic data.<br /> Names for alleles (<code>genindobject@loc.names</code>) are
truncated if longer than six characters. If truncated Captial letters linked
by a hyphen are added to guarentee they are unique. You can rename them by
providing new names by accessing the <code>genind@loc.names</code> slot prior to
running <code>popgenreport</code>.<br /> Note that the popgenreport function can take
a long time to run if the options mk.complete, mk.gd.kosman, or mk.gd.smouse
are set to <code>TRUE</code>. For example, running popgenreport with
<code>mk.complete=TRUE</code> on a dataset with 500 individuals with 36 loci will
take 14 to 15 minutes on a PC with a 3.5 Ghz processor and nearly 3 hours
for a dataset with ~3200 individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popgenreport(
  cats = NULL,
  mk.counts = TRUE,
  mk.map = FALSE,
  maptype = "satellite",
  mapdotcolor = "blue",
  mapdotsize = 1,
  mapdotalpha = 0.4,
  mapdottype = 19,
  mapzoom = NULL,
  mk.locihz = FALSE,
  mk.hwe = FALSE,
  mk.fst = FALSE,
  mk.gd.smouse = FALSE,
  mk.gd.kosman = FALSE,
  mk.pcoa = FALSE,
  mk.spautocor = FALSE,
  mk.allele.dist = FALSE,
  mk.null.all = FALSE,
  mk.allel.rich = FALSE,
  mk.differ.stats = FALSE,
  mk.custom = FALSE,
  fname = "PopGenReport",
  foldername = "results",
  path.pgr = NULL,
  mk.Rcode = FALSE,
  mk.complete = FALSE,
  mk.pdf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popgenreport_+3A_cats">cats</code></td>
<td>
<p>this is the <code><a href="adegenet.html#topic+genind">genind</a></code> object the analysis will be
based on.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.counts">mk.counts</code></td>
<td>
<p>switch is to provide overview counts of the number of
individuals sampled, numbers of individuals and alleles sampled per
sub-population, number of alleles per locus, mean number of alleles per
locus and the percentatge of missing data.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.map">mk.map</code></td>
<td>
<p>switch to produce a map with the sampling location of each
individual marked. This switch requires individual coordinates (latitudes
and longitudes in WGS1984) be provided (under cats@other$latlong or see
<code>read.genetable</code> on how to import them from a table of genetic data).
An error message will be generated if you turn this routine on, but do not
provide the coordinates in the right format. If the coordinates are provided
in a seperate file, they must be attached to the genind object in the slot
<br /><code>yourgenindobject@other$latlong &lt;- yourlatlongdata</code>.<br />
<code>yourlatlongdata</code> needs to be a data frame that has the same number and
order of individuals per row as the population genetic data. Note that an
internet connection is required to connect to the Google Maps server which
provides the basemap for this routine.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_maptype">maptype</code></td>
<td>
<p>Defines the type of map. Default is 'satellite'. Other
options are: 'roadmap', 'mobile', 'terrain', 'hybrid'.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mapdotcolor">mapdotcolor</code></td>
<td>
<p>Color of dots for each individual on the map. Default is
'blue'.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mapdotsize">mapdotsize</code></td>
<td>
<p>Size of dots for each individual. Default is 1.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mapdotalpha">mapdotalpha</code></td>
<td>
<p>Transparency of dots. 1 is invisible, 0 is no
transparency. Default is 0.4.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mapdottype">mapdottype</code></td>
<td>
<p>Defines the type of the symbol. For explanation see pch
under <code><a href="graphics.html#topic+par">par</a></code>. Default is 19 - a filled circle.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mapzoom">mapzoom</code></td>
<td>
<p>Zoom level of the map. If not specified the default zoom of
Google maps are used. Please be aware if you set the zoom level to high, the
map may not show all sample locations.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.locihz">mk.locihz</code></td>
<td>
<p>switch to test for population heterozygosity</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.hwe">mk.hwe</code></td>
<td>
<p>switch to test for Hardy-Weinberg equilibrium for each loci
and population</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.fst">mk.fst</code></td>
<td>
<p>switch to calculate Fst values for each loci and pairwise Fst
(Nei's 1973) over subpopulations</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.gd.smouse">mk.gd.smouse</code></td>
<td>
<p>Individual pairwise genetic distances based on Smouse
and Peakall (1999). Refer to <code>gd_smouse</code>. Spatial coordinates need to
be provided to be able to run this analysis.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.gd.kosman">mk.gd.kosman</code></td>
<td>
<p>Individual pairwise genetic distances based on Kosman &amp;
Leonhard (2005). Refer to <code>gd_kosman</code>. Spatial coordinates need to be
provided to be able to run this analysis.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.pcoa">mk.pcoa</code></td>
<td>
<p>Principal component analysis following Jombart et al. 2009.
Spatial coordinates need to be provided to be able to run this analysis.
Refer to vignettes within <code>adegenet</code>.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.spautocor">mk.spautocor</code></td>
<td>
<p>Spatial autocorrelation analysis following Smouse &amp;
Peakall 1999. Spatial coordinates need to be provided to be able to run this
analysis. Refer to <code>spautocor</code> for more information.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.allele.dist">mk.allele.dist</code></td>
<td>
<p>switch to look at allele distributions by loci and
subpopulation</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.null.all">mk.null.all</code></td>
<td>
<p>check for null alleles</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.allel.rich">mk.allel.rich</code></td>
<td>
<p>calculation of allelic richness</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.differ.stats">mk.differ.stats</code></td>
<td>
<p>switch to look at population differentiation
statistics (Nei's Gst, Hedrick's Gst, and Jost's D)</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.custom">mk.custom</code></td>
<td>
<p>edit custom.snw to include your own function to a report.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_fname">fname</code></td>
<td>
<p>filename for the output files. Defauts to PopGenReport. Note
that using a filename which includes a space in the name will result in the
filename for each figure being printed out in the PDF report for each
figure. Replacing the space with an underscore should prevent this from
happening.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_foldername">foldername</code></td>
<td>
<p>name of folder, where files are stored. Defaults to
'results'</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_path.pgr">path.pgr</code></td>
<td>
<p>Folder where the output files are stored. Defaults to the
temporary directory (<code>tempdir()</code>). If you want to store the output in
another directory, simply provide the path here. e.g.
<code>path.pgr=getwd()</code> saves it in your current working directory.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.rcode">mk.Rcode</code></td>
<td>
<p>switch to get the full R script that is used to generate the
report. A great way to get a very detailed insight on the kind of analysis
and also an easy way to generate a script which you can customize for your
analytical needs.</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.complete">mk.complete</code></td>
<td>
<p>switch to create a full report using all of the routines
(all switches are set to <code>TRUE</code>, except <code>mk.subgroups</code>).</p>
</td></tr>
<tr><td><code id="popgenreport_+3A_mk.pdf">mk.pdf</code></td>
<td>
<p>switch to create a shiny pdf output. You need a working
<b>latex</b> version running on your system (e.g. MikTex (Windows) or
Texmaker (Linux, MacOSX). For more information how to install latex on your
system refer to the <a href="http://www.popgenreport.org">http://www.popgenreport.org</a> and to the manuals of the
<code><a href="knitr.html#topic+knitr">knitr</a></code> package and its manuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object (e.g. res) that has all of the
results produced by this function in it. The structure of the object can be
accessed via <code>str(res)</code>. The main slots in this object (if you ran a
full report) are:<br /> <code>dataoverview, PopHet, Alleledist, Fst,
HsHtdifferentiate, HWEresults,</code> <br /><code>subgroups, GDKosman, GDSmouse</code>
</p>
<p>Additional ouput is provided in the form of a PDF (if mk.pdf=TRUE),which
will be saved to the specified subfolder (via foldername) in your current
working directory, and maps and figures which will be placed in this folder
as well. This folder will be generated automatically in your current working
directory. If you do not specify a working directory via <code>path.pgr</code>
then the temporary working directory of R will be used (<code>tempdir()</code>).
If <code>mk.Rcode=T</code> is set, an R file named fname.R will be saved to your
specified subfolder.
</p>


<h3>Author(s)</h3>

<p>Aaron Adamack &amp; Bernd Gruber, aaron.adamack@canberra.edu.au,
bernd.gruber@canberra.edu.au
</p>


<h3>References</h3>

<p>Kosman E., Leonard K.J. 2005. Similarity coefficients for
molecular markers in studies of genetic relationships between individuals
for haploid, diploid, and polyploidy species. Molecular Ecology 14:415-424
</p>
<p>Peakall R., Smouse P. 2012. GenAlEx 6.5: Genetic analysis in Excel.
Population genetic software for teaching and research - an update.
Bioinformatics 28:2537-2539
</p>


<h3>See Also</h3>

<p><code><a href="adegenet.html#topic+adegenet">adegenet</a></code>, <code><a href="pegas.html#topic+pegas">pegas</a></code>, <code><a href="mmod.html#topic+mmod">mmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bilby) # a generated data set
res &lt;- popgenreport(bilby, mk.counts=TRUE, mk.map=TRUE, mk.pdf=FALSE)
#check results via res or use created tables in the results folder.

### RUN ONLY with a working Latex version installed
res &lt;- popgenreport(bilby, mk.counts=TRUE, mk.map=TRUE, mk.pdf=TRUE, path.pgr="c:/temp")
#for a full report in a single pdf set mk.complete to TRUE

## End(Not run)
</code></pre>

<hr>
<h2 id='pops2genind'>Function converts pops to a genind object</h2><span id='topic+pops2genind'></span>

<h3>Description</h3>

<p>converts pops into genind (to calculate Fst etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pops2genind(x, locs = NULL, n.cov = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pops2genind_+3A_x">x</code></td>
<td>
<p>pops object (a list of pop)</p>
</td></tr>
<tr><td><code id="pops2genind_+3A_locs">locs</code></td>
<td>
<p>named coordinates of locations</p>
</td></tr>
<tr><td><code id="pops2genind_+3A_n.cov">n.cov</code></td>
<td>
<p>number of covariates (defaults to 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spatial genind object
</p>

<hr>
<h2 id='possums'>A genlight object created via the read.genetable functions [possum data set from Sarre et al. 2015]</h2><span id='topic+possums'></span>

<h3>Description</h3>

<p>A genlight object created via the read.genetable functions [possum data set from Sarre et al. 2015]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possums
</code></pre>


<h3>Format</h3>

<p>genind object
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber <a href="mailto:bernd.gruber@canberra.edu.au">bernd.gruber@canberra.edu.au</a>
</p>


<h3>References</h3>

<p>Sarre, S.D., Aitken, N., Adamack, A.T., Macdonald, A.J., Gruber, B. &amp; Cowan, P. (2014). Creating new evolutionary pathways through bioinvasion: The population genetics of brushtail possums in New Zealand. Molecular Ecology, 23, 3419-3433.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>possums
</code></pre>

<hr>
<h2 id='read.genetable'>Function to convert textfiles into a <a href="adegenet.html#topic+genind-class">genind</a> object (the format
required for popgenreport)</h2><span id='topic+read.genetable'></span>

<h3>Description</h3>

<p>This function converts genetic data provided in a tabular 'comma separated
value' (.csv) file into a genind object, the data format required to run
PopGenReport. At the moment it works only for codominant markers (e.g.
microsatellites). This function is based on df2genind from the
<code><a href="adegenet.html#topic+adegenet">adegenet</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.genetable(
  filename,
  pop = NULL,
  ind = NULL,
  lat = NULL,
  long = NULL,
  x = NULL,
  y = NULL,
  other.min = NULL,
  other.max = NULL,
  oneColPerAll,
  NA.char = NA,
  sep = NULL,
  ncode = NULL,
  ploidy = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.genetable_+3A_filename">filename</code></td>
<td>
<p>the name of your file in .csv file format</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_pop">pop</code></td>
<td>
<p>the column number if subpopulations are known, otherwise set to NULL</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_ind">ind</code></td>
<td>
<p>the column number of an individual identifier, otherwise set to NULL</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_lat">lat</code></td>
<td>
<p>the column number where the latitudinal coordinate is recorded
(can be set to NULL)</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_long">long</code></td>
<td>
<p>the column number where the longitudinal coordinate is recorded
(can be set to NULL)</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_x">x</code></td>
<td>
<p>the column number where the x coordinate is recorded. If not in
Mercator it needs to be transformed!!! (can be set to NULL)</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_y">y</code></td>
<td>
<p>the column number where the y coordinate is recorded. If not in
Mercator it needs to be transformed!!! (can be set to NULL)</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_other.min">other.min</code></td>
<td>
<p>if your data has some additional data (e.g. gender, size
etc.) you can include this data in the genind object as well. Values in this
section have to be in adjacent columns with no other columns between them.
other.min is the column number where this section starts.</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_other.max">other.max</code></td>
<td>
<p>if your data has some additional data (e.g. gender, size
etc.) then you can convert this data as well. This section has to be in a
consecutive order with no other type of columns in between. other.max is the
column number where this section ends.</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_onecolperall">oneColPerAll</code></td>
<td>
<p>needs to be specified. If your data is coded as a single
column per allele</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_na.char">NA.char</code></td>
<td>
<p>can be NA, 0 or mean. See details section.</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_sep">sep</code></td>
<td>
<p>a character string separating alleles. See details.</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_ncode">ncode</code></td>
<td>
<p>an optional integer giving the number of characters used for coding one genotype at one locus.
If not provided, this is determined from data.</p>
</td></tr>
<tr><td><code id="read.genetable_+3A_ploidy">ploidy</code></td>
<td>
<p>Ploidy of the data set. Be aware that most analysis do only
run for diploid data and that missing data in polyploid data sets are
ambigious, which may give dubious results if not handled appropriately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format of the .csv file is very important. Make sure your <b>headings
are exactly as provided in the example file</b> or the conversion will likely
fail (e.g. use lower cases for all headings). Use your favourite text editor
to reformat the file (e.g. Excel) to prepare the data and save it as csv
file. You need to provide the number of columns for each of your data
sections. These are: ind, pop, lat, long, other.min, other.max, and whether
there is a single column per allele (if you use a single column for both
alleles then you need to specify the seperator as well), or two columns per
allele. Please refer to the example files to make sure your file is in the
correct format and then check the conversion by typing:
</p>
<p>mydata &lt;- read.genetable(\&quot;mygeneticdat.csv\&quot;) mydata
</p>
<p>The easiest way to provide spatial coordinates is to use the read.genetable
function and use the <code>lat</code>, <code>long</code> arguments for WGS1984 projected
data (the most common projection globally). For additional information how
to use spatial data with PopGenReport refer to the help of the
<code>popgenreport</code> function and to the popgenreport manual. <br /> === There
are 3 treatments for missing values === - NA: kept as NA.
</p>
<p>- 0: allelic frequencies are set to 0 on all alleles of the concerned locus.
Recommended for a PCA on compositionnal data.
</p>
<p>- \&quot;mean\&quot;: missing values are replaced by the mean frequency of the
corresponding allele, computed on the whole set of individuals. Recommended
for a centred PCA.
</p>
<p>=== Details for the sep argument === this character is directly used in
reguar expressions like gsub, and thus require some characters to be
preceeded by double backslashes. For instance, \&quot;/\&quot; works but \&quot;|\&quot; must be
coded as \&quot;\|\&quot;.
</p>


<h3>Value</h3>

<p>an object of the class genind This kind of object is needed to be
passed on to the popgen.report function.
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber (bernd.gruber@canberra.edu.au)
</p>


<h3>See Also</h3>

<p><code><a href="adegenet.html#topic+import2genind">import2genind</a></code>, <code><a href="adegenet.html#topic+df2genind">df2genind</a></code>,
<code><a href="adegenet.html#topic+read.fstat">read.fstat</a></code>, <code><a href="adegenet.html#topic+read.structure">read.structure</a></code>,
<code><a href="adegenet.html#topic+read.genetix">read.genetix</a></code> <code><a href="adegenet.html#topic+read.genepop">read.genepop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#example file with one column per loci, seperated by forwardslash
read.csv(paste(.libPaths()[1],"/PopGenReport/extdata/platypus1c.csv", sep="" ))
platy1c &lt;- read.genetable( paste(.libPaths()[1],"/PopGenReport/extdata/platypus1c.csv"
, sep="" ), ind=1, pop=2, lat=3, long=4, other.min=5, other.max=6, oneColPerAll=FALSE, 
sep="/", )


#example file with two columns per loci
read.csv(paste(.libPaths()[1],"/PopGenReport/extdata/platypus2c.csv", sep="" ))
platy2c &lt;- read.genetable( paste(.libPaths()[1],"/PopGenReport/extdata/platypus2c.csv",
 sep="" ), ind=1, pop=2, lat=3, long=4, other.min=5, other.max=6, oneColPerAll=TRUE)

#to get a pdf output you need to have a running Latex version installed on your system.
#run a report (with a map)
#res&lt;- popgenreport(platy2c, mk.counts=TRUE, mk.map=TRUE, mk.allele.dist=TRUE, mk.pdf=TRUE)
</code></pre>

<hr>
<h2 id='reproduction'>Function to execute reproduction on a pop data.frame</h2><span id='topic+reproduction'></span>

<h3>Description</h3>

<p>reproduction subprocess on single populations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reproduction(x, type = "K.limit", K = n.ind, n.off, n.cov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reproduction_+3A_x">x</code></td>
<td>
<p>a pop object</p>
</td></tr>
<tr><td><code id="reproduction_+3A_type">type</code></td>
<td>
<p>type of density dependence K.limit only yet</p>
</td></tr>
<tr><td><code id="reproduction_+3A_k">K</code></td>
<td>
<p>Kapacity of a subpoplation</p>
</td></tr>
<tr><td><code id="reproduction_+3A_n.off">n.off</code></td>
<td>
<p>number of offspring per female</p>
</td></tr>
<tr><td><code id="reproduction_+3A_n.cov">n.cov</code></td>
<td>
<p>(number of covariates, default 3 )</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated pop object
</p>

<hr>
<h2 id='run.popgensim'>Run a time-forward popgen simulation</h2><span id='topic+run.popgensim'></span>

<h3>Description</h3>

<p>performs a time-forward, agent-based and spatiallly explicit genetic population simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.popgensim(
  simpops,
  steps,
  cost.mat,
  n.offspring,
  n.ind,
  mig.rate,
  disp.max,
  disp.rate,
  n.allels,
  mut.rate,
  n.cov = 3,
  rec = "none",
  emi.table = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.popgensim_+3A_simpops">simpops</code></td>
<td>
<p>pops object (a list of pop)</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_steps">steps</code></td>
<td>
<p>the number of steps (generations)</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_cost.mat">cost.mat</code></td>
<td>
<p>a cost matrix (e.g. calculated via costDistance)</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_n.offspring">n.offspring</code></td>
<td>
<p>number of offsprings per female</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_n.ind">n.ind</code></td>
<td>
<p>number of individuals</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_mig.rate">mig.rate</code></td>
<td>
<p>migration rate</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_disp.max">disp.max</code></td>
<td>
<p>dispersal distance of disp.rate individuals</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_disp.rate">disp.rate</code></td>
<td>
<p>percentage of individuals achieving disp.max</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_n.allels">n.allels</code></td>
<td>
<p>number of maximal alleles at a loci</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_mut.rate">mut.rate</code></td>
<td>
<p>mutation rate</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_n.cov">n.cov</code></td>
<td>
<p>number of covariates (defaults to 3)</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_rec">rec</code></td>
<td>
<p>switch if emigration matrix should be recorded, either &quot;none&quot; or &quot;emi&quot;</p>
</td></tr>
<tr><td><code id="run.popgensim_+3A_emi.table">emi.table</code></td>
<td>
<p>a emigration matrix, if provide a fixed number of migration events will take place otherwise based on disp.max, mig.rate and disp.rate,</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pops object created via <code>init.popgensim</code> is used as input. The function simulates time forward individual-based spatially explicit population dynamics. Subpopulations are linked by dispersal that can be specified via a pairwise distance matrix between subpopulations [cost.mat]. Distances are converted to a probability. Currenlty the function used is the p2p function, where dispersal is modeled using an exponential function, that can be specified via disp.max and disp.rate. disp.max specifies the maximal distance that are achieved by the proportion of disp.rate individuals in a subpopulation. The number of dispersers per generation is set to round(mig.rate * n.ind). A simple mutation rate can be specified (the probability of a mutation per loci) using mut.rate. The maximal allowed number of alleles per loci need to be specified. Currently the mutation model is a simple Kmax-allele model [n.alleles]. As before n.cov is the number if covariates in the data.frame (currenlty fixed to n.cov=3). To track emigration events between subpopulations (be aware output is then a list instead of a simple pops object) rec can be set to &quot;emi&quot;, which provides a matrix that shows the actual emigrations between subpopulations during the simulation. Emigration can also be determistic (instead of using disp.max and disp.rate) to a specified number of dispersal events per subpopulations. Over each generation events are occuring in that order: 1. dispersal, 2. reproduction, 3. mutation. For convinience the simulation can be run a specified number of generations [steps]. In case extra dynamics need to be modelled (e.g. one population is increased in number be a managment action or population are affected by environmental factors) simulations can also run only in single time steps [steps=1]. See example.
</p>


<h3>Value</h3>

<p>an updated pops object after steps time steps or a list that includes the pops object and the emigration matrix [rec=&quot;emi&quot;].
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init.popgensim">init.popgensim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(raster)
set.seed(1)
locs &lt;- cbind(x=round(runif(5,5,45)), y=round(runif(5,5,45)) )
cm &lt;- as.matrix(dist(locs))
pops &lt;- init.popgensim(n.pops = 5, n.ind=20, sex.ratio = 0.25, n.loci = 5, n.allels = 10, n.cov = 3)
#run pops
pops &lt;- run.popgensim(pops, steps = 200, cost.mat= cm, n.offspring = 2, n.ind = 20,
mig.rate = 0.125, disp.max = 30, disp.rate =0.1, n.allels = 10, mut.rate = 0)
#convert to genind object
pops.gi &lt;-pops2genind(pops)
#calculate pairwise fsts using pairwise.fstb
fsts &lt;- pairwise.fstb(pops.gi)
#plot
plot(locs, xlim=c(0,50), ylim=c(0,50), pch=16,cex=4, col="darkgrey")
for (i in 1:4)
for (ii in (i+1):5)
lines(c(locs[i,1], locs[ii,1]), c(locs[i,2], locs[ii,2]), lwd=fsts[i,ii]*30, col="darkgreen")
text(locs+0.5, labels=1:5, col="white", font=2)

</code></pre>

<hr>
<h2 id='spautocor'>Spatial autocorrelation following Smouse and Pekall 1999</h2><span id='topic+spautocor'></span>

<h3>Description</h3>

<p>Global spatial autocorrelation is a multivariate approach combining all loci
into a single analysis. The autocorrelation coefficient r is calculated for
each pairwise genetic distance pairs for all specified distance classes. For
more information see Smouse and Peakall 1999, Peakall et a. 2003 and Smouse
et al. 2008.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spautocor(gen.m, eucl.m, shuffle = FALSE, bins = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spautocor_+3A_gen.m">gen.m</code></td>
<td>
<p>a matrix of individual pairwise genetic distances. Easiest to
use gd_smouse or gd_kosman to create such a matrix, but in priniciple any
other squared distance matrix can be used. see example</p>
</td></tr>
<tr><td><code id="spautocor_+3A_eucl.m">eucl.m</code></td>
<td>
<p>A euclidean distance matrix, based on the coordinates of
individuals. see example</p>
</td></tr>
<tr><td><code id="spautocor_+3A_shuffle">shuffle</code></td>
<td>
<p>used internally for the permutation calculation</p>
</td></tr>
<tr><td><code id="spautocor_+3A_bins">bins</code></td>
<td>
<p>number of bins for the distance classes. Currently only even
bins are supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with r values and number of distances within
each distance class.
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber, Bernd.Gruber@canberra.edu.au
</p>


<h3>References</h3>

<p>Smouse PE, Peakall R. 1999. Spatial autocorrelation analysis of
individual multiallele and multilocus genetic structure. Heredity 82:
561-573.
</p>
<p>Double, MC, et al. 2005. Dispersal, philopatry and infidelity: dissecting
local genetic structure in superb fairy-wrens (Malurus cyaneus). Evolution
59, 625-635.
</p>
<p>Peakall, R, et al. 2003. Spatial autocorrelation analysis offers new
insights into gene flow in the Australian bush rat, Rattus fuscipes.
Evolution 57, 1182-1195.
</p>
<p>Smouse, PE, et al. 2008. A heterogeneity test for fine-scale genetic
structure. Molecular Ecology 17, 3389-3400.
</p>
<p>Gonzales, E, et al. 2010. The impact of landscape disturbance on spatial
genetic structure in the Guanacaste tree, Enterolobium
cyclocarpum(Fabaceae). Journal of Heredity 101, 133-143.
</p>
<p>Beck, N, et al. 2008. Social constraint and an absence of sex-biased
dispersal drive fine-scale genetic structure in white-winged choughs.
Molecular Ecology 17, 4346-4358.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popgenreport">popgenreport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(bilby)
popgenreport(bilby, mk.spautocor=TRUE, mk.pdf=FALSE)
#to get a pdf output you need to have a running Latex version installed on your system.
#popgenreport(bilby[1:50], mk.spautocor=TRUE, mk.pdf=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='wassermann'>Partial Mantel tests on costdistance matrices</h2><span id='topic+wassermann'></span>

<h3>Description</h3>

<p>This function implements the Causal modelling approach as suggested by
Wassermann et al. 2010 and Cushman et al. 2010. It tests for the effect of
landscape features using a cost distance matrix on the genetic structure of
subpopulation/individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wassermann(gen.mat, cost.mats, eucl.mat = NULL, plot = TRUE, nperm = 999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wassermann_+3A_gen.mat">gen.mat</code></td>
<td>
<p>pairwise genetic distance matrix</p>
</td></tr>
<tr><td><code id="wassermann_+3A_cost.mats">cost.mats</code></td>
<td>
<p>pairwise cost distance matrix</p>
</td></tr>
<tr><td><code id="wassermann_+3A_eucl.mat">eucl.mat</code></td>
<td>
<p>pairwise Eukclidean distance matrix</p>
</td></tr>
<tr><td><code id="wassermann_+3A_plot">plot</code></td>
<td>
<p>switch for control plots of the partial mantel test</p>
</td></tr>
<tr><td><code id="wassermann_+3A_nperm">nperm</code></td>
<td>
<p>number of permutations for the partial mantel test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+landgenreport">landgenreport</a></code>
</p>


<h3>Value</h3>

<p>A table with the results of the partial mantel test. Using plot=TRUE
results in diagnostic plots for the partial mantel tests.
</p>


<h3>Author(s)</h3>

<p>Bernd Gruber (bernd.gruber@canberra.edu.au)
</p>


<h3>References</h3>

<p>Wassermann, T.N., Cushman, S. A., Schwartz, M. K. and Wallin, D.
O. (2010). Spatial scaling and multi-model inference in landscape genetics:
Martes americana in northern Idaho. Landscape Ecology, 25(10), 1601-1612.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popgenreport">popgenreport</a></code>, <code><a href="#topic+genleastcost">genleastcost</a></code>,
<code><a href="#topic+landgenreport">landgenreport</a></code>, <code><a href="#topic+lgrMMRR">lgrMMRR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(raster)
fric.raster &lt;- readRDS(system.file("extdata","fric.raster.rdata", package="PopGenReport"))
glc &lt;- genleastcost(landgen, fric.raster, "D", NN=8)
wassermann(eucl.mat = glc$eucl.mat, cost.mats = glc$cost.mats, gen.mat = glc$gen.mat)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
