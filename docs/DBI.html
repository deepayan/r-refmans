<!DOCTYPE html><html><head><title>Help for package DBI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DBI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DBI-package'><p>DBI: R Database Interface</p></a></li>
<li><a href='#.SQL92Keywords'><p>Keywords according to the SQL-92 standard</p></a></li>
<li><a href='#ANSI'><p>A dummy DBI connector that simulates ANSI-SQL compliance</p></a></li>
<li><a href='#dbAppendTable'><p>Insert rows into a table</p></a></li>
<li><a href='#dbAppendTableArrow'><p>Insert rows into a table from an Arrow stream</p></a></li>
<li><a href='#dbBegin'><p>Begin/commit/rollback SQL transactions</p></a></li>
<li><a href='#dbBind'><p>Bind values to a parameterized/prepared statement</p></a></li>
<li><a href='#dbCallProc'><p>Call an SQL stored procedure</p></a></li>
<li><a href='#dbCanConnect'><p>Check if a connection to a DBMS can be established</p></a></li>
<li><a href='#dbClearResult'><p>Clear a result set</p></a></li>
<li><a href='#dbColumnInfo'><p>Information about result types</p></a></li>
<li><a href='#dbConnect'><p>Create a connection to a DBMS</p></a></li>
<li><a href='#dbCreateTable'><p>Create a table in the database</p></a></li>
<li><a href='#dbCreateTableArrow'><p>Create a table in the database based on an Arrow object</p></a></li>
<li><a href='#dbDataType'><p>Determine the SQL data type of an object</p></a></li>
<li><a href='#dbDisconnect'><p>Disconnect (close) a connection</p></a></li>
<li><a href='#dbDriver'><p>Load and unload database drivers</p></a></li>
<li><a href='#dbExecute'><p>Change database state</p></a></li>
<li><a href='#dbExistsTable'><p>Does a table exist?</p></a></li>
<li><a href='#dbFetch'><p>Fetch records from a previously executed query</p></a></li>
<li><a href='#dbFetchArrow'><p>Fetch records from a previously executed query as an Arrow object</p></a></li>
<li><a href='#dbFetchArrowChunk'><p>Fetch the next batch of records from a previously executed query as an Arrow object</p></a></li>
<li><a href='#dbGetConnectArgs'><p>Get connection arguments</p></a></li>
<li><a href='#dbGetDBIVersion'><p>Determine the current version of the package.</p></a></li>
<li><a href='#dbGetException'><p>Get DBMS exceptions</p></a></li>
<li><a href='#dbGetInfo'><p>Get DBMS metadata</p></a></li>
<li><a href='#dbGetQuery'><p>Retrieve results from a query</p></a></li>
<li><a href='#dbGetQueryArrow'><p>Retrieve results from a query as an Arrow object</p></a></li>
<li><a href='#dbGetRowCount'><p>The number of rows fetched so far</p></a></li>
<li><a href='#dbGetRowsAffected'><p>The number of rows affected</p></a></li>
<li><a href='#dbGetStatement'><p>Get the statement associated with a result set</p></a></li>
<li><a href='#dbHasCompleted'><p>Completion status</p></a></li>
<li><a href='#DBIConnection-class'><p>DBIConnection class</p></a></li>
<li><a href='#DBIConnector-class'><p>DBIConnector class</p></a></li>
<li><a href='#DBIDriver-class'><p>DBIDriver class</p></a></li>
<li><a href='#DBIObject-class'><p>DBIObject class</p></a></li>
<li><a href='#DBIResult-class'><p>DBIResult class</p></a></li>
<li><a href='#DBIResultArrow-class'><p>DBIResultArrow class</p></a></li>
<li><a href='#dbIsReadOnly'><p>Is this DBMS object read only?</p></a></li>
<li><a href='#dbIsValid'><p>Is this DBMS object still valid?</p></a></li>
<li><a href='#dbListConnections'><p>List currently open connections</p></a></li>
<li><a href='#dbListFields'><p>List field names of a remote table</p></a></li>
<li><a href='#dbListObjects'><p>List remote objects</p></a></li>
<li><a href='#dbListResults'><p>A list of all pending results</p></a></li>
<li><a href='#dbListTables'><p>List remote tables</p></a></li>
<li><a href='#dbQuoteIdentifier'><p>Quote identifiers</p></a></li>
<li><a href='#dbQuoteLiteral'><p>Quote literal values</p></a></li>
<li><a href='#dbQuoteString'><p>Quote literal strings</p></a></li>
<li><a href='#dbReadTable'><p>Read database tables as data frames</p></a></li>
<li><a href='#dbReadTableArrow'><p>Read database tables as Arrow objects</p></a></li>
<li><a href='#dbRemoveTable'><p>Remove a table from the database</p></a></li>
<li><a href='#dbSendQuery'><p>Execute a query on a given database connection</p></a></li>
<li><a href='#dbSendQueryArrow'><p>Execute a query on a given database connection for retrieval via Arrow</p></a></li>
<li><a href='#dbSendStatement'><p>Execute a data manipulation statement on a given database connection</p></a></li>
<li><a href='#dbSetDataMappings'><p>Set data mappings between an DBMS and R.</p></a></li>
<li><a href='#dbUnquoteIdentifier'><p>Unquote identifiers</p></a></li>
<li><a href='#dbWithTransaction'><p>Self-contained SQL transactions</p></a></li>
<li><a href='#dbWriteTable'><p>Copy data frames to database tables</p></a></li>
<li><a href='#dbWriteTableArrow'><p>Copy Arrow objects to database tables</p></a></li>
<li><a href='#hidden_aliases'><p>Internal page for hidden aliases</p></a></li>
<li><a href='#Id-class'><p>Refer to a table nested in a hierarchy (e.g. within a schema)</p></a></li>
<li><a href='#make.db.names.default'><p>Make R identifiers into legal SQL identifiers</p></a></li>
<li><a href='#rownames'><p>Convert row names back and forth between columns</p></a></li>
<li><a href='#SQL'><p>SQL quoting</p></a></li>
<li><a href='#sqlAppendTable'><p>Compose query to insert rows into a table</p></a></li>
<li><a href='#sqlCommentSpec'><p>Parse interpolated variables from SQL.</p></a></li>
<li><a href='#sqlCreateTable'><p>Compose query to create a simple table</p></a></li>
<li><a href='#sqlData'><p>Convert a data frame into form suitable for upload to an SQL database</p></a></li>
<li><a href='#sqlInterpolate'><p>Safely interpolate values into an SQL string</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>R Database Interface</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-02</td>
</tr>
<tr>
<td>Description:</td>
<td>A database interface definition for communication between R
    and relational database management systems.  All classes in this
    package are virtual and need to be extended by the various R/DBMS
    implementations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2.1)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dbi.r-dbi.org">https://dbi.r-dbi.org</a>, <a href="https://github.com/r-dbi/DBI">https://github.com/r-dbi/DBI</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-dbi/DBI/issues">https://github.com/r-dbi/DBI/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>arrow, blob, covr, DBItest, dbplyr, downlit, dplyr, glue,
hms, knitr, magrittr, nanoarrow (&ge; 0.3.0.1), RMariaDB,
rmarkdown, rprojroot, RSQLite (&ge; 1.1-2), testthat (&ge; 3.0.0),
vctrs, xml2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/autostyle/scope:</td>
<td>line_breaks</td>
</tr>
<tr>
<td>Config/autostyle/strict:</td>
<td>false</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>r-dbi/DBItest</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>r-dbi/DBItest, r-dbi/dbitemplate, adbi,
AzureKusto, bigrquery, DatabaseConnector, dittodb, duckdb,
implyr, lazysf, odbc, pool, RAthena, IMSMWU/RClickhouse, RH2,
RJDBC, RMariaDB, RMySQL, RPostgres, RPostgreSQL, RPresto,
RSQLite, sergeant, sparklyr, withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-02 20:26:05 UTC; kirill</td>
</tr>
<tr>
<td>Author:</td>
<td>R Special Interest Group on Databases (R-SIG-DB) [aut],
  Hadley Wickham [aut],
  Kirill Müller <a href="https://orcid.org/0000-0002-1416-3412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  R Consortium [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kirill Müller &lt;kirill@cynkra.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-02 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DBI-package'>DBI: R Database Interface</h2><span id='topic+DBI'></span><span id='topic+DBI-package'></span>

<h3>Description</h3>

<p>DBI defines an interface for communication between R and relational database
management systems.
All classes in this package are virtual and need to be extended by
the various R/DBMS implementations (so-called <em>DBI backends</em>).
</p>


<h3>Definition</h3>

<p>A DBI backend is an R package
which imports the <span class="pkg">DBI</span>
and <span class="pkg">methods</span>
packages.
For better or worse, the names of many existing backends start with
&lsquo;R&rsquo;, e.g., <span class="pkg">RSQLite</span>, <span class="pkg">RMySQL</span>, <span class="pkg">RSQLServer</span>; it is up
to the backend author to adopt this convention or not.
</p>


<h3>DBI classes and methods</h3>

<p>A backend defines three classes,
which are subclasses of
<a href="#topic+DBIDriver-class">DBIDriver</a>,
<a href="#topic+DBIConnection-class">DBIConnection</a>,
and <a href="#topic+DBIResult-class">DBIResult</a>.
The backend provides implementation for all methods
of these base classes
that are defined but not implemented by DBI.
All methods defined in <span class="pkg">DBI</span> are reexported (so that the package can
be used without having to attach <span class="pkg">DBI</span>),
and have an ellipsis <code>...</code> in their formals for extensibility.
</p>


<h3>Construction of the DBIDriver object</h3>

<p>The backend must support creation of an instance of its <a href="#topic+DBIDriver-class">DBIDriver</a> subclass
with a <dfn>constructor function</dfn>.
By default, its name is the package name without the leading &lsquo;R&rsquo;
(if it exists), e.g., <code>SQLite</code> for the <span class="pkg">RSQLite</span> package.
However, backend authors may choose a different name.
The constructor must be exported, and
it must be a function
that is callable without arguments.
DBI recommends to define a constructor with an empty argument list.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kirill Müller <a href="mailto:kirill@cynkra.com">kirill@cynkra.com</a> (<a href="https://orcid.org/0000-0002-1416-3412">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> R Special Interest Group on Databases (R-SIG-DB)
</p>
</li>
<li><p> Hadley Wickham
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> R Consortium [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Important generics: <code><a href="#topic+dbConnect">dbConnect()</a></code>, <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>,
<code><a href="#topic+dbReadTable">dbReadTable()</a></code>, <code><a href="#topic+dbWriteTable">dbWriteTable()</a></code>, <code><a href="#topic+dbDisconnect">dbDisconnect()</a></code>
</p>
<p>Formal specification (currently work in progress and incomplete):
<code>vignette("spec", package = "DBI")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
RSQLite::SQLite()

</code></pre>

<hr>
<h2 id='.SQL92Keywords'>Keywords according to the SQL-92 standard</h2><span id='topic+.SQL92Keywords'></span>

<h3>Description</h3>

<p>A character vector of SQL-92 keywords, uppercase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.SQL92Keywords
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 220.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>"SELECT" %in% .SQL92Keywords
</code></pre>

<hr>
<h2 id='ANSI'>A dummy DBI connector that simulates ANSI-SQL compliance</h2><span id='topic+ANSI'></span>

<h3>Description</h3>

<p>A dummy DBI connector that simulates ANSI-SQL compliance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANSI()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>ANSI()
</code></pre>

<hr>
<h2 id='dbAppendTable'>Insert rows into a table</h2><span id='topic+dbAppendTable'></span>

<h3>Description</h3>

<p>The <code>dbAppendTable()</code> method assumes that the table has been created
beforehand, e.g. with <code><a href="#topic+dbCreateTable">dbCreateTable()</a></code>.
The default implementation calls <code><a href="#topic+sqlAppendTableTemplate">sqlAppendTableTemplate()</a></code> and then
<code><a href="#topic+dbExecute">dbExecute()</a></code> with the <code>param</code> argument.
Use <code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow()</a></code> to append data from an Arrow stream.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbAppendTable(conn, name, value, ..., row.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbAppendTable_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbAppendTable_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbAppendTable_+3A_value">value</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> (or coercible to data.frame).</p>
</td></tr>
<tr><td><code id="dbAppendTable_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
<tr><td><code id="dbAppendTable_+3A_row.names">row.names</code></td>
<td>
<p>Must be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Backends compliant to
ANSI SQL 99 which use <code style="white-space: pre;">&#8288;?&#8288;</code> as a placeholder for prepared queries don't need
to override it. Backends with a different SQL syntax which use <code style="white-space: pre;">&#8288;?&#8288;</code>
as a placeholder for prepared queries can override <code><a href="#topic+sqlAppendTable">sqlAppendTable()</a></code>.
Other backends (with different placeholders or with entirely different
ways to create tables) need to override the <code>dbAppendTable()</code> method.
</p>
<p>The <code>row.names</code> argument is not supported by this method.
Process the values with <code><a href="#topic+sqlRownamesToColumn">sqlRownamesToColumn()</a></code> before calling this method.
</p>


<h3>Value</h3>

<p><code>dbAppendTable()</code> returns a
scalar
numeric.
</p>


<h3>Failure modes</h3>

<p>If the table does not exist,
or the new data in <code>values</code> is not a data frame or has different column names,
an error is raised; the remote table remains unchanged.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> or
if this results in a non-scalar.
Invalid values for the <code>row.names</code> argument
(non-scalars,
unsupported data types,
<code>NA</code>)
also raise an error.
</p>
<p>Passing a <code>value</code> argument different to <code>NULL</code> to the <code>row.names</code> argument
(in particular <code>TRUE</code>,
<code>NA</code>,
and a string)
raises an error.
</p>


<h3>Specification</h3>

<p>SQL keywords can be used freely in table names, column names, and data.
Quotes, commas, spaces, and other special characters such as newlines and tabs,
can also be used in the data,
and, if the database supports non-syntactic identifiers,
also for table names
and column names.
</p>
<p>The following data types must be supported at least,
and be read identically with <code><a href="#topic+dbReadTable">dbReadTable()</a></code>:
</p>

<ul>
<li><p> integer
</p>
</li>
<li><p> numeric
(the behavior for <code>Inf</code> and <code>NaN</code> is not specified)
</p>
</li>
<li><p> logical
</p>
</li>
<li> <p><code>NA</code> as NULL
</p>
</li>
<li><p> 64-bit values (using <code>"bigint"</code> as field type); the result can be
</p>

<ul>
<li><p> converted to a numeric, which may lose precision,
</p>
</li>
<li><p> converted a character vector, which gives the full decimal
representation
</p>
</li>
<li><p> written to another table and read again unchanged
</p>
</li></ul>

</li>
<li><p> character (in both UTF-8
and native encodings),
supporting empty strings
(before and after non-empty strings)
</p>
</li>
<li><p> factor (returned as character,
with a warning)
</p>
</li>
<li><p> list of raw
(if supported by the database)
</p>
</li>
<li><p> objects of type <a href="blob.html#topic+blob">blob::blob</a>
(if supported by the database)
</p>
</li>
<li><p> date
(if supported by the database;
returned as <code>Date</code>)
also for dates prior to 1970 or 1900 or after 2038
</p>
</li>
<li><p> time
(if supported by the database;
returned as objects that inherit from <code>difftime</code>)
</p>
</li>
<li><p> timestamp
(if supported by the database;
returned as <code>POSIXct</code>
respecting the time zone but not necessarily preserving the
input time zone),
also for timestamps prior to 1970 or 1900 or after 2038
respecting the time zone but not necessarily preserving the
input time zone)
</p>
</li></ul>

<p>Mixing column types in the same table is supported.
</p>
<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>

<ul>
<li><p> If an unquoted table name as string: <code>dbAppendTable()</code> will do the quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li><p> If the result of a call to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>: no more quoting is done
to support databases that allow non-syntactic names for their objects:
</p>
</li></ul>

<p>The <code>row.names</code> argument must be <code>NULL</code>, the default value.
Row names are ignored.
</p>
<p>The <code>value</code> argument must be a data frame
with a subset of the columns of the existing table.
The order of the columns does not matter.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
dbCreateTable(con, "iris", iris)
dbAppendTable(con, "iris", iris)
dbReadTable(con, "iris")
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbAppendTableArrow'>Insert rows into a table from an Arrow stream</h2><span id='topic+dbAppendTableArrow'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The <code>dbAppendTableArrow()</code> method assumes that the table has been created
beforehand, e.g. with <code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow()</a></code>.
The default implementation calls <code><a href="#topic+dbAppendTable">dbAppendTable()</a></code> for each chunk
of the stream.
Use <code><a href="#topic+dbAppendTable">dbAppendTable()</a></code> to append data from a data.frame.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbAppendTableArrow(conn, name, value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbAppendTableArrow_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbAppendTableArrow_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbAppendTableArrow_+3A_value">value</code></td>
<td>
<p>An object coercible with <code><a href="nanoarrow.html#topic+as_nanoarrow_array_stream">nanoarrow::as_nanoarrow_array_stream()</a></code>.</p>
</td></tr>
<tr><td><code id="dbAppendTableArrow_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbAppendTableArrow()</code> returns a
scalar
numeric.
</p>


<h3>Failure modes</h3>

<p>If the table does not exist,
or the new data in <code>values</code> is not a data frame or has different column names,
an error is raised; the remote table remains unchanged.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> or
if this results in a non-scalar.
</p>


<h3>Specification</h3>

<p>SQL keywords can be used freely in table names, column names, and data.
Quotes, commas, spaces, and other special characters such as newlines and tabs,
can also be used in the data,
and, if the database supports non-syntactic identifiers,
also for table names
and column names.
</p>
<p>The following data types must be supported at least,
and be read identically with <code><a href="#topic+dbReadTable">dbReadTable()</a></code>:
</p>

<ul>
<li><p> integer
</p>
</li>
<li><p> numeric
(the behavior for <code>Inf</code> and <code>NaN</code> is not specified)
</p>
</li>
<li><p> logical
</p>
</li>
<li> <p><code>NA</code> as NULL
</p>
</li>
<li><p> 64-bit values (using <code>"bigint"</code> as field type); the result can be
</p>

<ul>
<li><p> converted to a numeric, which may lose precision,
</p>
</li>
<li><p> converted a character vector, which gives the full decimal
representation
</p>
</li>
<li><p> written to another table and read again unchanged
</p>
</li></ul>

</li>
<li><p> character (in both UTF-8
and native encodings),
supporting empty strings
(before and after non-empty strings)
</p>
</li>
<li><p> factor (possibly returned as character)
</p>
</li>
<li><p> objects of type <a href="blob.html#topic+blob">blob::blob</a>
(if supported by the database)
</p>
</li>
<li><p> date
(if supported by the database;
returned as <code>Date</code>)
also for dates prior to 1970 or 1900 or after 2038
</p>
</li>
<li><p> time
(if supported by the database;
returned as objects that inherit from <code>difftime</code>)
</p>
</li>
<li><p> timestamp
(if supported by the database;
returned as <code>POSIXct</code>
respecting the time zone but not necessarily preserving the
input time zone),
also for timestamps prior to 1970 or 1900 or after 2038
respecting the time zone but not necessarily preserving the
input time zone)
</p>
</li></ul>

<p>Mixing column types in the same table is supported.
</p>
<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>

<ul>
<li><p> If an unquoted table name as string: <code>dbAppendTableArrow()</code> will do the quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li><p> If the result of a call to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>: no more quoting is done
to support databases that allow non-syntactic names for their objects:
</p>
</li></ul>

<p>The <code>value</code> argument must be a data frame
with a subset of the columns of the existing table.
The order of the columns does not matter.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
dbCreateTableArrow(con, "iris", iris[0, ])
dbAppendTableArrow(con, "iris", iris[1:5, ])
dbReadTable(con, "iris")
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbBegin'>Begin/commit/rollback SQL transactions</h2><span id='topic+dbBegin'></span><span id='topic+dbCommit'></span><span id='topic+dbRollback'></span><span id='topic+transactions'></span>

<h3>Description</h3>

<p>A transaction encapsulates several SQL statements in an atomic unit.
It is initiated with <code>dbBegin()</code> and either made persistent with <code>dbCommit()</code>
or undone with <code>dbRollback()</code>.
In any case, the DBMS guarantees that either all or none of the statements
have a permanent effect.
This helps ensuring consistency of write operations to multiple tables.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbBegin(conn, ...)

dbCommit(conn, ...)

dbRollback(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbBegin_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbBegin_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all database engines implement transaction management, in which case
these methods should not be implemented for the specific
<a href="#topic+DBIConnection-class">DBIConnection</a> subclass.
</p>


<h3>Value</h3>

<p><code>dbBegin()</code>, <code>dbCommit()</code> and <code>dbRollback()</code> return <code>TRUE</code>, invisibly.
</p>


<h3>Failure modes</h3>

<p>The implementations are expected to raise an error in case of failure,
but this is not tested.
In any way, all generics throw an error with a closed
or invalid connection.
In addition, a call to <code>dbCommit()</code>
or <code>dbRollback()</code>
without a prior call to <code>dbBegin()</code> raises an error.
Nested transactions are not supported by DBI,
an attempt to call <code>dbBegin()</code> twice
yields an error.
</p>


<h3>Specification</h3>

<p>Actual support for transactions may vary between backends.
A transaction is initiated by a call to <code>dbBegin()</code>
and committed by a call to <code>dbCommit()</code>.
Data written in a transaction must persist after the transaction is committed.
For example, a record that is missing when the transaction is started
but is created during the transaction
must exist
both during
and after the transaction,
and also in a new connection.
</p>
<p>A transaction
can also be aborted with <code>dbRollback()</code>.
All data written in such a transaction must be removed after the
transaction is rolled back.
For example, a record that is missing when the transaction is started
but is created during the transaction
must not exist anymore after the rollback.
</p>
<p>Disconnection from a connection with an open transaction
effectively rolls back the transaction.
All data written in such a transaction must be removed after the
transaction is rolled back.
</p>
<p>The behavior is not specified if other arguments are passed to these
functions. In particular, <span class="pkg">RSQLite</span> issues named transactions
with support for nesting
if the <code>name</code> argument is set.
</p>
<p>The transaction isolation level is not specified by DBI.
</p>


<h3>See Also</h3>

<p>Self-contained transactions: <code><a href="#topic+dbWithTransaction">dbWithTransaction()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cash", data.frame(amount = 100))
dbWriteTable(con, "account", data.frame(amount = 2000))

# All operations are carried out as logical unit:
dbBegin(con)
withdrawal &lt;- 300
dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
dbCommit(con)

dbReadTable(con, "cash")
dbReadTable(con, "account")

# Rolling back after detecting negative value on account:
dbBegin(con)
withdrawal &lt;- 5000
dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
if (dbReadTable(con, "account")$amount &gt;= 0) {
  dbCommit(con)
} else {
  dbRollback(con)
}

dbReadTable(con, "cash")
dbReadTable(con, "account")

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbBind'>Bind values to a parameterized/prepared statement</h2><span id='topic+dbBind'></span><span id='topic+dbBindArrow'></span>

<h3>Description</h3>

<p>For parametrized or prepared statements,
the <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code>, <code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code>, and <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> functions
can be called with statements that contain placeholders for values.
The <code>dbBind()</code> and <code>dbBindArrow()</code> functions bind these placeholders
to actual values,
and are intended to be called on the result set
before calling <code><a href="#topic+dbFetch">dbFetch()</a></code> or <code><a href="#topic+dbFetchArrow">dbFetchArrow()</a></code>.
The values are passed to <code>dbBind()</code> as lists or data frames,
and to <code>dbBindArrow()</code> as a stream
created by <code><a href="nanoarrow.html#topic+as_nanoarrow_array_stream">nanoarrow::as_nanoarrow_array_stream()</a></code>.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>dbBindArrow()</code> is experimental, as are the other <code style="white-space: pre;">&#8288;*Arrow&#8288;</code> functions.
<code>dbSendQuery()</code> is compatible with <code>dbBindArrow()</code>, and <code>dbSendQueryArrow()</code>
is compatible with <code>dbBind()</code>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbBind(res, params, ...)

dbBindArrow(res, params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbBind_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResult-class">DBIResult</a>.</p>
</td></tr>
<tr><td><code id="dbBind_+3A_params">params</code></td>
<td>
<p>For <code>dbBind()</code>, a list of values, named or unnamed,
or a data frame, with one element/column per query parameter.
For <code>dbBindArrow()</code>, values as a nanoarrow stream,
with one column per query parameter.</p>
</td></tr>
<tr><td><code id="dbBind_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">DBI</span> supports parametrized (or prepared) queries and statements
via the <code>dbBind()</code> and <code>dbBindArrow()</code> generics.
Parametrized queries are different from normal queries
in that they allow an arbitrary number of placeholders,
which are later substituted by actual values.
Parametrized queries (and statements) serve two purposes:
</p>

<ul>
<li><p> The same query can be executed more than once with different values.
The DBMS may cache intermediate information for the query,
such as the execution plan, and execute it faster.
</p>
</li>
<li><p> Separation of query syntax and parameters protects against SQL injection.
</p>
</li></ul>

<p>The placeholder format is currently not specified by <span class="pkg">DBI</span>;
in the future, a uniform placeholder syntax may be supported.
Consult the backend documentation for the supported formats.
For automated testing, backend authors specify the placeholder syntax with
the <code>placeholder_pattern</code> tweak.
Known examples are:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;?&#8288;</code> (positional matching in order of appearance) in <span class="pkg">RMariaDB</span> and <span class="pkg">RSQLite</span>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$1&#8288;</code> (positional matching by index) in <span class="pkg">RPostgres</span> and <span class="pkg">RSQLite</span>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;:name&#8288;</code> and <code style="white-space: pre;">&#8288;$name&#8288;</code> (named matching) in <span class="pkg">RSQLite</span>
</p>
</li></ul>



<h3>Value</h3>

<p><code>dbBind()</code> returns the result set,
invisibly,
for queries issued by <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> or <code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code> and
also for data manipulation statements issued by
<code><a href="#topic+dbSendStatement">dbSendStatement()</a></code>.
</p>


<h3>The data retrieval flow</h3>

<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>,
is implemented by <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> to create a result set object of class
<a href="#topic+DBIResult-class">DBIResult</a>.
</p>
</li>
<li><p> Optionally, bind query parameters with <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Optionally, use <code><a href="#topic+dbColumnInfo">dbColumnInfo()</a></code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li><p> Use <code><a href="#topic+dbFetch">dbFetch()</a></code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li><p> Use <code><a href="#topic+dbHasCompleted">dbHasCompleted()</a></code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li><p> Repeat the last four steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>The data retrieval flow for Arrow streams</h3>

<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as an Arrow stream.
</p>
<p>Most of this flow, except repeated calling of <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code> or <code><a href="#topic+dbBind">dbBind()</a></code>,
is implemented by <code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow()</a></code>,
which should be sufficient
unless you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code> to create a result set object of class
<a href="#topic+DBIResultArrow-class">DBIResultArrow</a>.
</p>
</li>
<li><p> Optionally, bind query parameters with <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code> or <code><a href="#topic+dbBind">dbBind()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Use <code><a href="#topic+dbFetchArrow">dbFetchArrow()</a></code> to get a data stream.
</p>
</li>
<li><p> Repeat the last two steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>The command execution flow</h3>

<p>This section gives a complete overview over the flow
for the execution of SQL statements that have side effects
such as stored procedures, inserting or deleting data,
or setting database or connection options.
Most of this flow, except repeated calling of <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>,
is implemented by <code><a href="#topic+dbExecute">dbExecute()</a></code>, which should be sufficient
for non-parameterized queries.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> to create a result set object of class
<a href="#topic+DBIResult-class">DBIResult</a>.
For some queries you need to pass <code>immediate = TRUE</code>.
</p>
</li>
<li><p> Optionally, bind query parameters with<code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Optionally, use <code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code> to retrieve the number
of rows affected by the query.
</p>
</li>
<li><p> Repeat the last two steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>Calling <code>dbBind()</code> for a query without parameters
raises an error.
</p>
<p>Binding too many
or not enough values,
or parameters with wrong names
or unequal length,
also raises an error.
If the placeholders in the query are named,
all parameter values must have names
(which must not be empty
or <code>NA</code>),
and vice versa,
otherwise an error is raised.
The behavior for mixing placeholders of different types
(in particular mixing positional and named placeholders)
is not specified.
</p>
<p>Calling <code>dbBind()</code> on a result set already cleared by <code><a href="#topic+dbClearResult">dbClearResult()</a></code>
also raises an error.
</p>


<h3>Specification</h3>

<p><span class="pkg">DBI</span> clients execute parametrized statements as follows:
</p>

<ol>
<li><p> Call <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code>, <code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code> or <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code>
with a query or statement that contains placeholders,
store the returned <a href="#topic+DBIResult-class">DBIResult</a> object in a variable.
Mixing placeholders (in particular, named and unnamed ones) is not
recommended.
It is good practice to register a call to <code><a href="#topic+dbClearResult">dbClearResult()</a></code> via
<code><a href="base.html#topic+on.exit">on.exit()</a></code> right after calling <code>dbSendQuery()</code> or <code>dbSendStatement()</code>
(see the last enumeration item).
Until <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code> have been called,
the returned result set object has the following behavior:
</p>

<ul>
<li> <p><code><a href="#topic+dbFetch">dbFetch()</a></code> raises an error (for <code>dbSendQuery()</code> and <code>dbSendQueryArrow()</code>)
</p>
</li>
<li> <p><code><a href="#topic+dbGetRowCount">dbGetRowCount()</a></code> returns zero (for <code>dbSendQuery()</code> and <code>dbSendQueryArrow()</code>)
</p>
</li>
<li> <p><code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code> returns an integer <code>NA</code> (for <code>dbSendStatement()</code>)
</p>
</li>
<li> <p><code><a href="#topic+dbIsValid">dbIsValid()</a></code> returns <code>TRUE</code>
</p>
</li>
<li> <p><code><a href="#topic+dbHasCompleted">dbHasCompleted()</a></code> returns <code>FALSE</code>
</p>
</li></ul>

</li>
<li><p> Call <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>:
</p>

<ul>
<li><p> For <code><a href="#topic+dbBind">dbBind()</a></code>, the <code>params</code> argument must be a list where all elements
have the same lengths and contain values supported by the backend.
A <a href="base.html#topic+data.frame">data.frame</a> is internally stored as such a list.
</p>
</li>
<li><p> For <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>, the <code>params</code> argument must be a
nanoarrow array stream, with one column per query parameter.
</p>
</li></ul>

</li>
<li><p> Retrieve the data or the number of affected rows from the <code>DBIResult</code> object.
</p>

<ul>
<li><p> For queries issued by <code>dbSendQuery()</code> or <code>dbSendQueryArrow()</code>, call <code><a href="#topic+dbFetch">dbFetch()</a></code>.
</p>
</li>
<li><p> For statements issued by <code>dbSendStatements()</code>,
call <code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code>.
(Execution begins immediately after the <code><a href="#topic+dbBind">dbBind()</a></code> call,
the statement is processed entirely before the function returns.)
</p>
</li></ul>

</li>
<li><p> Repeat 2. and 3. as necessary.
</p>
</li>
<li><p> Close the result set via <code><a href="#topic+dbClearResult">dbClearResult()</a></code>.
</p>
</li></ol>

<p>The elements of the <code>params</code> argument do not need to be scalars,
vectors of arbitrary length
(including length 0)
are supported.
For queries, calling <code>dbFetch()</code> binding such parameters returns
concatenated results, equivalent to binding and fetching for each set
of values and connecting via <code><a href="base.html#topic+rbind">rbind()</a></code>.
For data manipulation statements, <code>dbGetRowsAffected()</code> returns the
total number of rows affected if binding non-scalar parameters.
<code>dbBind()</code> also accepts repeated calls on the same result set
for both queries
and data manipulation statements,
even if no results are fetched between calls to <code>dbBind()</code>,
for both queries
and data manipulation statements.
</p>
<p>If the placeholders in the query are named,
their order in the <code>params</code> argument is not important.
</p>
<p>At least the following data types are accepted on input (including <a href="base.html#topic+NA">NA</a>):
</p>

<ul>
<li> <p><a href="base.html#topic+integer">integer</a>
</p>
</li>
<li> <p><a href="base.html#topic+numeric">numeric</a>
</p>
</li>
<li> <p><a href="base.html#topic+logical">logical</a> for Boolean values
</p>
</li>
<li> <p><a href="base.html#topic+character">character</a>
(also with special characters such as spaces, newlines, quotes, and backslashes)
</p>
</li>
<li> <p><a href="base.html#topic+factor">factor</a> (bound as character,
with warning)
</p>
</li>
<li> <p><a href="base.html#topic+Date">Date</a>
(also when stored internally as integer)
</p>
</li>
<li> <p><a href="base.html#topic+POSIXct">POSIXct</a> timestamps
</p>
</li>
<li> <p><a href="base.html#topic+POSIXlt">POSIXlt</a> timestamps
</p>
</li>
<li> <p><a href="base.html#topic+difftime">difftime</a> values
(also with units other than seconds
and with the value stored as integer)
</p>
</li>
<li><p> lists of <a href="base.html#topic+raw">raw</a> for blobs (with <code>NULL</code> entries for SQL NULL values)
</p>
</li>
<li><p> objects of type <a href="blob.html#topic+blob">blob::blob</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>
<p>Other DBIResultArrow generics: 
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>
</p>
<p>Other data retrieval generics: 
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>
</p>
<p>Other command execution generics: 
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data frame flow:
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "iris", iris)

# Using the same query for different values
iris_result &lt;- dbSendQuery(con, "SELECT * FROM iris WHERE [Petal.Width] &gt; ?")
dbBind(iris_result, list(2.3))
dbFetch(iris_result)
dbBind(iris_result, list(3))
dbFetch(iris_result)
dbClearResult(iris_result)

# Executing the same statement with different values at once
iris_result &lt;- dbSendStatement(con, "DELETE FROM iris WHERE [Species] = $species")
dbBind(iris_result, list(species = c("setosa", "versicolor", "unknown")))
dbGetRowsAffected(iris_result)
dbClearResult(iris_result)

nrow(dbReadTable(con, "iris"))

dbDisconnect(con)



# Arrow flow:
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "iris", iris)

# Using the same query for different values
iris_result &lt;- dbSendQueryArrow(con, "SELECT * FROM iris WHERE [Petal.Width] &gt; ?")
dbBindArrow(
  iris_result,
  nanoarrow::as_nanoarrow_array_stream(data.frame(2.3, fix.empty.names = FALSE))
)
as.data.frame(dbFetchArrow(iris_result))
dbBindArrow(
  iris_result,
  nanoarrow::as_nanoarrow_array_stream(data.frame(3, fix.empty.names = FALSE))
)
as.data.frame(dbFetchArrow(iris_result))
dbClearResult(iris_result)

# Executing the same statement with different values at once
iris_result &lt;- dbSendStatement(con, "DELETE FROM iris WHERE [Species] = $species")
dbBindArrow(iris_result, nanoarrow::as_nanoarrow_array_stream(data.frame(
  species = c("setosa", "versicolor", "unknown")
)))
dbGetRowsAffected(iris_result)
dbClearResult(iris_result)

nrow(dbReadTable(con, "iris"))

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbCallProc'>Call an SQL stored procedure</h2><span id='topic+dbCallProc'></span>

<h3>Description</h3>

<p><strong>Deprecated since 2014</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbCallProc(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbCallProc_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbCallProc_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recommended way of calling a stored procedure is now
</p>

<ol>
<li><p><code><a href="#topic+dbGetQuery">dbGetQuery</a></code> if a result set is returned
</p>
</li>
<li><p><code><a href="#topic+dbExecute">dbExecute</a></code>  for data manipulation and other cases where no result set is returned
</p>
</li></ol>


<hr>
<h2 id='dbCanConnect'>Check if a connection to a DBMS can be established</h2><span id='topic+dbCanConnect'></span>

<h3>Description</h3>

<p>Like <code><a href="#topic+dbConnect">dbConnect()</a></code>, but only checks validity without actually returning
a connection object.  The default implementation opens a connection
and disconnects on success, but individual backends might implement
a lighter-weight check.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbCanConnect(drv, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbCanConnect_+3A_drv">drv</code></td>
<td>
<p>an object that inherits from <a href="#topic+DBIDriver-class">DBIDriver</a>,
or an existing <a href="#topic+DBIConnection-class">DBIConnection</a>
object (in order to clone an existing connection).</p>
</td></tr>
<tr><td><code id="dbCanConnect_+3A_...">...</code></td>
<td>
<p>authentication arguments needed by the DBMS instance; these
typically include <code>user</code>, <code>password</code>, <code>host</code>, <code>port</code>, <code>dbname</code>, etc.
For details see the appropriate <code>DBIDriver</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar logical.  If <code>FALSE</code>, the <code>"reason"</code> attribute indicates
a reason for failure.
</p>


<h3>See Also</h3>

<p>Other DBIDriver generics: 
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDriver">dbDriver</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListConnections">dbListConnections</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# SQLite only needs a path to the database. (Here, ":memory:" is a special
# path that creates an in-memory database.) Other database drivers
# will require more details (like user, password, host, port, etc.)
dbCanConnect(RSQLite::SQLite(), ":memory:")

</code></pre>

<hr>
<h2 id='dbClearResult'>Clear a result set</h2><span id='topic+dbClearResult'></span>

<h3>Description</h3>

<p>Frees all resources (local and remote) associated with a result set.
This step is mandatory for all objects obtained by calling
<code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> or <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbClearResult(res, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbClearResult_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResult-class">DBIResult</a>.</p>
</td></tr>
<tr><td><code id="dbClearResult_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbClearResult()</code> returns <code>TRUE</code>, invisibly, for result sets obtained from
<code>dbSendQuery()</code>,
<code>dbSendStatement()</code>,
or <code>dbSendQueryArrow()</code>,
</p>


<h3>The data retrieval flow</h3>

<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>,
is implemented by <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> to create a result set object of class
<a href="#topic+DBIResult-class">DBIResult</a>.
</p>
</li>
<li><p> Optionally, bind query parameters with <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Optionally, use <code><a href="#topic+dbColumnInfo">dbColumnInfo()</a></code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li><p> Use <code><a href="#topic+dbFetch">dbFetch()</a></code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li><p> Use <code><a href="#topic+dbHasCompleted">dbHasCompleted()</a></code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li><p> Repeat the last four steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>The command execution flow</h3>

<p>This section gives a complete overview over the flow
for the execution of SQL statements that have side effects
such as stored procedures, inserting or deleting data,
or setting database or connection options.
Most of this flow, except repeated calling of <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>,
is implemented by <code><a href="#topic+dbExecute">dbExecute()</a></code>, which should be sufficient
for non-parameterized queries.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> to create a result set object of class
<a href="#topic+DBIResult-class">DBIResult</a>.
For some queries you need to pass <code>immediate = TRUE</code>.
</p>
</li>
<li><p> Optionally, bind query parameters with<code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Optionally, use <code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code> to retrieve the number
of rows affected by the query.
</p>
</li>
<li><p> Repeat the last two steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>An attempt to close an already closed result set issues a warning
for <code>dbSendQuery()</code>,
<code>dbSendStatement()</code>,
and <code>dbSendQueryArrow()</code>,
</p>


<h3>Specification</h3>

<p><code>dbClearResult()</code> frees all resources associated with retrieving
the result of a query or update operation.
The DBI backend can expect a call to <code>dbClearResult()</code> for each
<code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> or <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> call.
</p>


<h3>See Also</h3>

<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>
<p>Other DBIResultArrow generics: 
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>
</p>
<p>Other data retrieval generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>
</p>
<p>Other command execution generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

rs &lt;- dbSendQuery(con, "SELECT 1")
print(dbFetch(rs))

dbClearResult(rs)
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbColumnInfo'>Information about result types</h2><span id='topic+dbColumnInfo'></span>

<h3>Description</h3>

<p>Produces a data.frame that describes the output of a query. The data.frame
should have as many rows as there are output fields in the result set, and
each column in the data.frame describes an aspect of the result set
field (field name, type, etc.)
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbColumnInfo(res, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbColumnInfo_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResult-class">DBIResult</a>.</p>
</td></tr>
<tr><td><code id="dbColumnInfo_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbColumnInfo()</code>
returns a data frame
with at least two columns <code>"name"</code> and <code>"type"</code> (in that order)
(and optional columns that start with a dot).
The <code>"name"</code> and <code>"type"</code> columns contain the names and types
of the R columns of the data frame that is returned from <code><a href="#topic+dbFetch">dbFetch()</a></code>.
The <code>"type"</code> column is of type <code>character</code> and only for information.
Do not compute on the <code>"type"</code> column, instead use <code>dbFetch(res, n = 0)</code>
to create a zero-row data frame initialized with the correct data types.
</p>


<h3>The data retrieval flow</h3>

<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>,
is implemented by <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> to create a result set object of class
<a href="#topic+DBIResult-class">DBIResult</a>.
</p>
</li>
<li><p> Optionally, bind query parameters with <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Optionally, use <code><a href="#topic+dbColumnInfo">dbColumnInfo()</a></code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li><p> Use <code><a href="#topic+dbFetch">dbFetch()</a></code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li><p> Use <code><a href="#topic+dbHasCompleted">dbHasCompleted()</a></code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li><p> Repeat the last four steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>An attempt to query columns for a closed result set raises an error.
</p>


<h3>Specification</h3>

<p>A column named <code>row_names</code> is treated like any other column.
</p>
<p>The column names are always consistent
with the data returned by <code>dbFetch()</code>.
</p>
<p>If the query returns unnamed columns,
non-empty and non-<code>NA</code> names are assigned.
</p>
<p>Column names that correspond to SQL or R keywords are left unchanged.
</p>


<h3>See Also</h3>

<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

rs &lt;- dbSendQuery(con, "SELECT 1 AS a, 2 AS b")
dbColumnInfo(rs)
dbFetch(rs)

dbClearResult(rs)
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbConnect'>Create a connection to a DBMS</h2><span id='topic+dbConnect'></span>

<h3>Description</h3>

<p>Connect to a DBMS going through the appropriate authentication procedure.
Some implementations may allow you to have multiple connections open, so you
may invoke this function repeatedly assigning its output to different
objects.
The authentication mechanism is left unspecified, so check the
documentation of individual drivers for details.
Use <code><a href="#topic+dbCanConnect">dbCanConnect()</a></code> to check if a connection can be established.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbConnect(drv, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbConnect_+3A_drv">drv</code></td>
<td>
<p>an object that inherits from <a href="#topic+DBIDriver-class">DBIDriver</a>,
or an existing <a href="#topic+DBIConnection-class">DBIConnection</a>
object (in order to clone an existing connection).</p>
</td></tr>
<tr><td><code id="dbConnect_+3A_...">...</code></td>
<td>
<p>authentication arguments needed by the DBMS instance; these
typically include <code>user</code>, <code>password</code>, <code>host</code>, <code>port</code>, <code>dbname</code>, etc.
For details see the appropriate <code>DBIDriver</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbConnect()</code> returns an S4 object that inherits from <a href="#topic+DBIConnection-class">DBIConnection</a>.
This object is used to communicate with the database engine.
</p>
<p>A <code><a href="base.html#topic+format">format()</a></code> method is defined for the connection object.
It returns a string that consists of a single line of text.
</p>


<h3>Specification</h3>

<p>DBI recommends using the following argument names for authentication
parameters, with <code>NULL</code> default:
</p>

<ul>
<li> <p><code>user</code> for the user name (default: current user)
</p>
</li>
<li> <p><code>password</code> for the password
</p>
</li>
<li> <p><code>host</code> for the host name (default: local connection)
</p>
</li>
<li> <p><code>port</code> for the port number (default: local connection)
</p>
</li>
<li> <p><code>dbname</code> for the name of the database on the host, or the database file
name
</p>
</li></ul>

<p>The defaults should provide reasonable behavior, in particular a
local connection for <code>host = NULL</code>.  For some DBMS (e.g., PostgreSQL),
this is different to a TCP/IP connection to <code>localhost</code>.
</p>
<p>In addition, DBI supports the <code>bigint</code> argument that governs how
64-bit integer data is returned.  The following values are supported:
</p>

<ul>
<li> <p><code>"integer"</code>: always return as <code>integer</code>, silently overflow
</p>
</li>
<li> <p><code>"numeric"</code>: always return as <code>numeric</code>, silently round
</p>
</li>
<li> <p><code>"character"</code>: always return the decimal representation as <code>character</code>
</p>
</li>
<li> <p><code>"integer64"</code>: return as a data type that can be coerced using
<code><a href="base.html#topic+as.integer">as.integer()</a></code> (with warning on overflow), <code><a href="base.html#topic+as.numeric">as.numeric()</a></code>
and <code><a href="base.html#topic+as.character">as.character()</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+dbDisconnect">dbDisconnect()</a></code> to disconnect from a database.
</p>
<p>Other DBIDriver generics: 
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+dbCanConnect">dbCanConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDriver">dbDriver</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListConnections">dbListConnections</a>()</code>
</p>
<p>Other DBIConnector generics: 
<code><a href="#topic+DBIConnector-class">DBIConnector-class</a></code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbGetConnectArgs">dbGetConnectArgs</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# SQLite only needs a path to the database. (Here, ":memory:" is a special
# path that creates an in-memory database.) Other database drivers
# will require more details (like user, password, host, port, etc.)
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
con

dbListTables(con)

dbDisconnect(con)

# Bad, for subtle reasons:
# This code fails when RSQLite isn't loaded yet,
# because dbConnect() doesn't know yet about RSQLite.
dbListTables(con &lt;- dbConnect(RSQLite::SQLite(), ":memory:"))

</code></pre>

<hr>
<h2 id='dbCreateTable'>Create a table in the database</h2><span id='topic+dbCreateTable'></span>

<h3>Description</h3>

<p>The default <code>dbCreateTable()</code> method calls <code><a href="#topic+sqlCreateTable">sqlCreateTable()</a></code> and
<code><a href="#topic+dbExecute">dbExecute()</a></code>.
Use <code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow()</a></code> to create a table from an Arrow schema.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbCreateTable(conn, name, fields, ..., row.names = NULL, temporary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbCreateTable_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbCreateTable_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbCreateTable_+3A_fields">fields</code></td>
<td>
<p>Either a character vector or a data frame.
</p>
<p>A named character vector: Names are column names, values are types.
Names are escaped with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>.
Field types are unescaped.
</p>
<p>A data frame: field types are generated using
<code><a href="#topic+dbDataType">dbDataType()</a></code>.</p>
</td></tr>
<tr><td><code id="dbCreateTable_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
<tr><td><code id="dbCreateTable_+3A_row.names">row.names</code></td>
<td>
<p>Must be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dbCreateTable_+3A_temporary">temporary</code></td>
<td>
<p>If <code>TRUE</code>, will generate a temporary table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Backends compliant to ANSI SQL 99 don't need to override it.
Backends with a different SQL syntax can override <code>sqlCreateTable()</code>,
backends with entirely different ways to create tables need to
override this method.
</p>
<p>The <code>row.names</code> argument is not supported by this method.
Process the values with <code><a href="#topic+sqlRownamesToColumn">sqlRownamesToColumn()</a></code> before calling this method.
</p>
<p>The argument order is different from the <code>sqlCreateTable()</code> method, the
latter will be adapted in a later release of DBI.
</p>


<h3>Value</h3>

<p><code>dbCreateTable()</code> returns <code>TRUE</code>, invisibly.
</p>


<h3>Failure modes</h3>

<p>If the table exists, an error is raised; the remote table remains unchanged.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> or
if this results in a non-scalar.
Invalid values for the <code>row.names</code> and <code>temporary</code> arguments
(non-scalars,
unsupported data types,
<code>NA</code>,
incompatible values,
duplicate names)
also raise an error.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbCreateTable()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>temporary</code> (default: <code>FALSE</code>)
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Specification&quot; and &quot;Value&quot; sections for details on their usage.
</p>


<h3>Specification</h3>

<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>

<ul>
<li><p> If an unquoted table name as string: <code>dbCreateTable()</code> will do the quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li><p> If the result of a call to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>: no more quoting is done
</p>
</li></ul>

<p>The <code>value</code> argument can be:
</p>

<ul>
<li><p> a data frame,
</p>
</li>
<li><p> a named list of SQL types
</p>
</li></ul>

<p>If the <code>temporary</code> argument is <code>TRUE</code>, the table is not available in a
second connection and is gone after reconnecting.
Not all backends support this argument.
A regular, non-temporary table is visible in a second connection,
in a pre-existing connection,
and after reconnecting to the database.
</p>
<p>SQL keywords can be used freely in table names, column names, and data.
Quotes, commas, and spaces can also be used  for table names and column names,
if the database supports non-syntactic identifiers.
</p>
<p>The <code>row.names</code> argument must be missing
or <code>NULL</code>, the default value.
All other values for the <code>row.names</code> argument
(in particular <code>TRUE</code>,
<code>NA</code>,
and a string)
raise an error.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
dbCreateTable(con, "iris", iris)
dbReadTable(con, "iris")
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbCreateTableArrow'>Create a table in the database based on an Arrow object</h2><span id='topic+dbCreateTableArrow'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The default <code>dbCreateTableArrow()</code> method determines the R data types
of the Arrow schema associated with the Arrow object,
and calls <code><a href="#topic+dbCreateTable">dbCreateTable()</a></code>.
Backends that implement <code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow()</a></code> should typically
also implement this generic.
Use <code><a href="#topic+dbCreateTable">dbCreateTable()</a></code> to create a table from the column types
as defined in a data frame.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbCreateTableArrow(conn, name, value, ..., temporary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbCreateTableArrow_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbCreateTableArrow_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbCreateTableArrow_+3A_value">value</code></td>
<td>
<p>An object for which a schema can be determined via
<code><a href="nanoarrow.html#topic+as_nanoarrow_schema">nanoarrow::infer_nanoarrow_schema()</a></code>.</p>
</td></tr>
<tr><td><code id="dbCreateTableArrow_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
<tr><td><code id="dbCreateTableArrow_+3A_temporary">temporary</code></td>
<td>
<p>If <code>TRUE</code>, will generate a temporary table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbCreateTableArrow()</code> returns <code>TRUE</code>, invisibly.
</p>


<h3>Failure modes</h3>

<p>If the table exists, an error is raised; the remote table remains unchanged.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> or
if this results in a non-scalar.
Invalid values for the <code>temporary</code> argument
(non-scalars,
unsupported data types,
<code>NA</code>,
incompatible values,
duplicate names)
also raise an error.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbCreateTableArrow()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>temporary</code> (default: <code>FALSE</code>)
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Specification&quot; and &quot;Value&quot; sections for details on their usage.
</p>


<h3>Specification</h3>

<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>

<ul>
<li><p> If an unquoted table name as string: <code>dbCreateTableArrow()</code> will do the quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li><p> If the result of a call to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>: no more quoting is done
</p>
</li></ul>

<p>The <code>value</code> argument can be:
</p>

<ul>
<li><p> a data frame,
</p>
</li>
<li><p> a nanoarrow array
</p>
</li>
<li><p> a nanoarrow array stream
(which will still contain the data after the call)
</p>
</li>
<li><p> a nanoarrow schema
</p>
</li></ul>

<p>If the <code>temporary</code> argument is <code>TRUE</code>, the table is not available in a
second connection and is gone after reconnecting.
Not all backends support this argument.
A regular, non-temporary table is visible in a second connection,
in a pre-existing connection,
and after reconnecting to the database.
</p>
<p>SQL keywords can be used freely in table names, column names, and data.
Quotes, commas, and spaces can also be used  for table names and column names,
if the database supports non-syntactic identifiers.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
ptype &lt;- data.frame(a = numeric())
dbCreateTableArrow(con, "df", nanoarrow::infer_nanoarrow_schema(ptype))
dbReadTable(con, "df")
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbDataType'>Determine the SQL data type of an object</h2><span id='topic+dbDataType'></span>

<h3>Description</h3>

<p>Returns an SQL string that describes the SQL data type to be used for an
object.
The default implementation of this generic determines the SQL type of an
R object according to the SQL 92 specification, which may serve as a starting
point for driver implementations. DBI also provides an implementation
for data.frame which will return a character vector giving the type for each
column in the dataframe.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbDataType(dbObj, obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbDataType_+3A_dbobj">dbObj</code></td>
<td>
<p>A object inheriting from <a href="#topic+DBIDriver-class">DBIDriver</a>
or <a href="#topic+DBIConnection-class">DBIConnection</a></p>
</td></tr>
<tr><td><code id="dbDataType_+3A_obj">obj</code></td>
<td>
<p>An R object whose SQL type we want to determine.</p>
</td></tr>
<tr><td><code id="dbDataType_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data types supported by databases are different than the data types in R,
but the mapping between the primitive types is straightforward:
</p>

<ul>
<li><p> Any of the many fixed and varying length character types are mapped to
character vectors
</p>
</li>
<li><p> Fixed-precision (non-IEEE) numbers are mapped into either numeric or
integer vectors.
</p>
</li></ul>

<p>Notice that many DBMS do not follow IEEE arithmetic, so there are potential
problems with under/overflows and loss of precision.
</p>


<h3>Value</h3>

<p><code>dbDataType()</code> returns the SQL type that corresponds to the <code>obj</code> argument
as a non-empty
character string.
For data frames, a character vector with one element per column
is returned.
</p>


<h3>Failure modes</h3>

<p>An error is raised for invalid values for the <code>obj</code> argument such as a
<code>NULL</code> value.
</p>


<h3>Specification</h3>

<p>The backend can override the <code><a href="#topic+dbDataType">dbDataType()</a></code> generic
for its driver class.
</p>
<p>This generic expects an arbitrary object as second argument.
To query the values returned by the default implementation,
run <code>example(dbDataType, package = "DBI")</code>.
If the backend needs to override this generic,
it must accept all basic R data types as its second argument, namely
<a href="base.html#topic+logical">logical</a>,
<a href="base.html#topic+integer">integer</a>,
<a href="base.html#topic+numeric">numeric</a>,
<a href="base.html#topic+character">character</a>,
dates (see <a href="base.html#topic+Dates">Dates</a>),
date-time (see <a href="base.html#topic+DateTimeClasses">DateTimeClasses</a>),
and <a href="base.html#topic+difftime">difftime</a>.
If the database supports blobs,
this method also must accept lists of <a href="base.html#topic+raw">raw</a> vectors,
and <a href="blob.html#topic+blob">blob::blob</a> objects.
As-is objects (i.e., wrapped by <code><a href="base.html#topic+I">I()</a></code>) must be
supported and return the same results as their unwrapped counterparts.
The SQL data type for <a href="base.html#topic+factor">factor</a> and
<a href="base.html#topic+ordered">ordered</a> is the same as for character.
The behavior for other object types is not specified.
</p>
<p>All data types returned by <code>dbDataType()</code> are usable in an SQL statement
of the form
<code>"CREATE TABLE test (a ...)"</code>.
</p>


<h3>See Also</h3>

<p>Other DBIDriver generics: 
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+dbCanConnect">dbCanConnect</a>()</code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDriver">dbDriver</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListConnections">dbListConnections</a>()</code>
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>
<p>Other DBIConnector generics: 
<code><a href="#topic+DBIConnector-class">DBIConnector-class</a></code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbGetConnectArgs">dbGetConnectArgs</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dbDataType(ANSI(), 1:5)
dbDataType(ANSI(), 1)
dbDataType(ANSI(), TRUE)
dbDataType(ANSI(), Sys.Date())
dbDataType(ANSI(), Sys.time())
dbDataType(ANSI(), Sys.time() - as.POSIXct(Sys.Date()))
dbDataType(ANSI(), c("x", "abc"))
dbDataType(ANSI(), list(raw(10), raw(20)))
dbDataType(ANSI(), I(3))

dbDataType(ANSI(), iris)


con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbDataType(con, 1:5)
dbDataType(con, 1)
dbDataType(con, TRUE)
dbDataType(con, Sys.Date())
dbDataType(con, Sys.time())
dbDataType(con, Sys.time() - as.POSIXct(Sys.Date()))
dbDataType(con, c("x", "abc"))
dbDataType(con, list(raw(10), raw(20)))
dbDataType(con, I(3))

dbDataType(con, iris)

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbDisconnect'>Disconnect (close) a connection</h2><span id='topic+dbDisconnect'></span>

<h3>Description</h3>

<p>This closes the connection, discards all pending work, and frees
resources (e.g., memory, sockets).
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbDisconnect(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbDisconnect_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbDisconnect_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbDisconnect()</code> returns <code>TRUE</code>, invisibly.
</p>


<h3>Failure modes</h3>

<p>A warning is issued on garbage collection when a connection has been
released without calling <code>dbDisconnect()</code>,
but this cannot be tested automatically.
At least one warning is issued immediately when calling <code>dbDisconnect()</code> on an
already disconnected
or invalid connection.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbDriver'>Load and unload database drivers</h2><span id='topic+dbDriver'></span><span id='topic+dbUnloadDriver'></span>

<h3>Description</h3>

<p>These methods are deprecated, please consult the documentation of the
individual backends for the construction of driver instances.
</p>
<p><code>dbDriver()</code> is a helper method used to create an new driver object
given the name of a database or the corresponding R package. It works
through convention: all DBI-extending packages should provide an exported
object with the same name as the package. <code>dbDriver()</code> just looks for
this object in the right places: if you know what database you are connecting
to, you should call the function directly.
</p>
<p><code>dbUnloadDriver()</code> is not implemented for modern backends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbDriver(drvName, ...)

dbUnloadDriver(drv, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbDriver_+3A_drvname">drvName</code></td>
<td>
<p>character name of the driver to instantiate.</p>
</td></tr>
<tr><td><code id="dbDriver_+3A_...">...</code></td>
<td>
<p>any other arguments are passed to the driver <code>drvName</code>.</p>
</td></tr>
<tr><td><code id="dbDriver_+3A_drv">drv</code></td>
<td>
<p>an object that inherits from <code>DBIDriver</code> as created by
<code>dbDriver</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The client part of the database communication is
initialized (typically dynamically loading C code, etc.) but note that
connecting to the database engine itself needs to be done through calls to
<code>dbConnect</code>.
</p>


<h3>Value</h3>

<p>In the case of <code>dbDriver</code>, an driver object whose class extends
<code>DBIDriver</code>. This object may be used to create connections to the
actual DBMS engine.
</p>
<p>In the case of <code>dbUnloadDriver</code>, a logical indicating whether the
operation succeeded or not.
</p>


<h3>See Also</h3>

<p>Other DBIDriver generics: 
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+dbCanConnect">dbCanConnect</a>()</code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListConnections">dbListConnections</a>()</code>
</p>
<p>Other DBIDriver generics: 
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+dbCanConnect">dbCanConnect</a>()</code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListConnections">dbListConnections</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a RSQLite driver with a string
d &lt;- dbDriver("SQLite")
d

# But better, access the object directly
RSQLite::SQLite()

</code></pre>

<hr>
<h2 id='dbExecute'>Change database state</h2><span id='topic+dbExecute'></span>

<h3>Description</h3>

<p>Executes a statement and returns the number of rows affected.
<code>dbExecute()</code> comes with a default implementation
(which should work with most backends) that calls
<code><a href="#topic+dbSendStatement">dbSendStatement()</a></code>, then <code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code>, ensuring that
the result is always freed by <code><a href="#topic+dbClearResult">dbClearResult()</a></code>.
For passing query parameters, see <code><a href="#topic+dbBind">dbBind()</a></code>, in particular
the &quot;The command execution flow&quot; section.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbExecute(conn, statement, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbExecute_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbExecute_+3A_statement">statement</code></td>
<td>
<p>a character string containing SQL.</p>
</td></tr>
<tr><td><code id="dbExecute_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use <code>dbExecute()</code> to call a stored procedure
that performs data manipulation or other actions that do not return a result set.
To execute a stored procedure that returns a result set,
or a data manipulation query that also returns a result set
such as <code style="white-space: pre;">&#8288;INSERT INTO ... RETURNING ...&#8288;</code>, use <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code> instead.
</p>


<h3>Value</h3>

<p><code>dbExecute()</code> always returns a
scalar
numeric
that specifies the number of rows affected
by the statement.
</p>


<h3>Implementation notes</h3>

<p>Subclasses should override this method only if they provide some sort of
performance optimization.
</p>


<h3>Failure modes</h3>

<p>An error is raised when issuing a statement over a closed
or invalid connection,
if the syntax of the statement is invalid,
or if the statement is not a non-<code>NA</code> string.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbExecute()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>params</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>immediate</code> (default: <code>NULL</code>)
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Specification&quot; sections for details on their usage.
</p>


<h3>Specification</h3>

<p>The <code>param</code> argument allows passing query parameters, see <code><a href="#topic+dbBind">dbBind()</a></code> for details.
</p>


<h3>Specification for the <code>immediate</code> argument</h3>

<p>The <code>immediate</code> argument supports distinguishing between &quot;direct&quot;
and &quot;prepared&quot; APIs offered by many database drivers.
Passing <code>immediate = TRUE</code> leads to immediate execution of the
query or statement, via the &quot;direct&quot; API (if supported by the driver).
The default <code>NULL</code> means that the backend should choose whatever API
makes the most sense for the database, and (if relevant) tries the
other API if the first attempt fails. A successful second attempt
should result in a message that suggests passing the correct
<code>immediate</code> argument.
Examples for possible behaviors:
</p>

<ol>
<li><p> DBI backend defaults to <code>immediate = TRUE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed: query is executed
</p>
</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: rejected immediately by the database
because of a syntax error in the query, the backend tries
<code>immediate = FALSE</code> (and gives a message)
</p>
</li>
<li> <p><code>params</code> given: query is executed using <code>immediate = FALSE</code>
</p>
</li></ol>

</li></ol>

</li>
<li><p> DBI backend defaults to <code>immediate = FALSE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed:
</p>

<ol>
<li><p> simple query: query is executed
</p>
</li>
<li><p> &quot;special&quot; query (such as setting a config options): fails,
the backend tries <code>immediate = TRUE</code> (and gives a message)
</p>
</li></ol>

</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: waiting for parameters via <code><a href="#topic+dbBind">dbBind()</a></code>
</p>
</li>
<li> <p><code>params</code> given: query is executed
</p>
</li></ol>

</li></ol>

</li></ol>



<h3>See Also</h3>

<p>For queries: <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> and <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>.
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>
<p>Other command execution generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cars", head(cars, 3))
dbReadTable(con, "cars")   # there are 3 rows
dbExecute(
  con,
  "INSERT INTO cars (speed, dist) VALUES (1, 1), (2, 2), (3, 3)"
)
dbReadTable(con, "cars")   # there are now 6 rows

# Pass values using the param argument:
dbExecute(
  con,
  "INSERT INTO cars (speed, dist) VALUES (?, ?)",
  params = list(4:7, 5:8)
)
dbReadTable(con, "cars")   # there are now 10 rows

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbExistsTable'>Does a table exist?</h2><span id='topic+dbExistsTable'></span>

<h3>Description</h3>

<p>Returns if a table given by name exists in the database.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbExistsTable(conn, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbExistsTable_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbExistsTable_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbExistsTable_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbExistsTable()</code> returns a logical scalar, <code>TRUE</code> if the table or view
specified by the <code>name</code> argument exists, <code>FALSE</code> otherwise.
</p>
<p>This includes temporary tables if supported by the database.
</p>


<h3>Failure modes</h3>

<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> or
if this results in a non-scalar.
</p>


<h3>Specification</h3>

<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>

<ul>
<li><p> If an unquoted table name as string: <code>dbExistsTable()</code> will do the
quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li><p> If the result of a call to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>: no more quoting is done
</p>
</li></ul>

<p>For all tables listed by <code><a href="#topic+dbListTables">dbListTables()</a></code>, <code>dbExistsTable()</code> returns <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbExistsTable(con, "iris")
dbWriteTable(con, "iris", iris)
dbExistsTable(con, "iris")

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbFetch'>Fetch records from a previously executed query</h2><span id='topic+dbFetch'></span><span id='topic+fetch'></span>

<h3>Description</h3>

<p>Fetch the next <code>n</code> elements (rows) from the result set and return them
as a data.frame.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbFetch(res, n = -1, ...)

fetch(res, n = -1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbFetch_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResult-class">DBIResult</a>, created by
<code><a href="#topic+dbSendQuery">dbSendQuery()</a></code>.</p>
</td></tr>
<tr><td><code id="dbFetch_+3A_n">n</code></td>
<td>
<p>maximum number of records to retrieve per fetch. Use <code>n = -1</code>
or <code>n = Inf</code>
to retrieve all pending records.  Some implementations may recognize other
special values.</p>
</td></tr>
<tr><td><code id="dbFetch_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fetch()</code> is provided for compatibility with older DBI clients - for all
new code you are strongly encouraged to use <code>dbFetch()</code>. The default
implementation for <code>dbFetch()</code> calls <code>fetch()</code> so that it is compatible with
existing code. Modern backends should implement for <code>dbFetch()</code> only.
</p>


<h3>Value</h3>

<p><code>dbFetch()</code> always returns a <a href="base.html#topic+data.frame">data.frame</a> with
as many rows as records were fetched and as many
columns as fields in the result set,
even if the result is a single value
or has one
or zero rows.
Passing <code>n = NA</code> is supported and returns an arbitrary number of rows (at least one)
as specified by the driver, but at most the remaining rows in the result set.
</p>


<h3>The data retrieval flow</h3>

<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>,
is implemented by <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> to create a result set object of class
<a href="#topic+DBIResult-class">DBIResult</a>.
</p>
</li>
<li><p> Optionally, bind query parameters with <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Optionally, use <code><a href="#topic+dbColumnInfo">dbColumnInfo()</a></code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li><p> Use <code><a href="#topic+dbFetch">dbFetch()</a></code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li><p> Use <code><a href="#topic+dbHasCompleted">dbHasCompleted()</a></code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li><p> Repeat the last four steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>An attempt to fetch from a closed result set raises an error.
If the <code>n</code> argument is not an atomic whole number
greater or equal to -1 or Inf, an error is raised,
but a subsequent call to <code>dbFetch()</code> with proper <code>n</code> argument succeeds.
</p>
<p>Calling <code>dbFetch()</code> on a result set from a data manipulation query
created by <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> can
be fetched and return an empty data frame, with a warning.
</p>


<h3>Specification</h3>

<p>Fetching multi-row queries with one
or more columns by default returns the entire result.
Multi-row queries can also be fetched progressively
by passing a whole number (<a href="base.html#topic+integer">integer</a> or
<a href="base.html#topic+numeric">numeric</a>)
as the <code>n</code> argument.
A value of <a href="base.html#topic+Inf">Inf</a> for the <code>n</code> argument is supported
and also returns the full result.
If more rows than available are fetched, the result is returned in full
without warning.
If fewer rows than requested are returned, further fetches will
return a data frame with zero rows.
If zero rows are fetched, the columns of the data frame are still fully
typed.
Fetching fewer rows than available is permitted,
no warning is issued when clearing the result set.
</p>
<p>A column named <code>row_names</code> is treated like any other column.
</p>
<p>The column types of the returned data frame depend on the data returned:
</p>

<ul>
<li> <p><a href="base.html#topic+integer">integer</a> (or coercible to an integer) for integer values between -2^31 and 2^31 - 1,
with <a href="base.html#topic+NA">NA</a> for SQL <code>NULL</code> values
</p>
</li>
<li> <p><a href="base.html#topic+numeric">numeric</a> for numbers with a fractional component,
with NA for SQL <code>NULL</code> values
</p>
</li>
<li> <p><a href="base.html#topic+logical">logical</a> for Boolean values (some backends may return an integer);
with NA for SQL <code>NULL</code> values
</p>
</li>
<li> <p><a href="base.html#topic+character">character</a> for text,
with NA for SQL <code>NULL</code> values
</p>
</li>
<li><p> lists of <a href="base.html#topic+raw">raw</a> for blobs
with <a href="base.html#topic+NULL">NULL</a> entries for SQL NULL values
</p>
</li>
<li><p> coercible using <code><a href="base.html#topic+as.Date">as.Date()</a></code> for dates,
with NA for SQL <code>NULL</code> values
(also applies to the return value of the SQL function <code>current_date</code>)
</p>
</li>
<li><p> coercible using <code><a href="hms.html#topic+hms">hms::as_hms()</a></code> for times,
with NA for SQL <code>NULL</code> values
(also applies to the return value of the SQL function <code>current_time</code>)
</p>
</li>
<li><p> coercible using <code><a href="base.html#topic+as.POSIXct">as.POSIXct()</a></code> for timestamps,
with NA for SQL <code>NULL</code> values
(also applies to the return value of the SQL function <code>current_timestamp</code>)
</p>
</li></ul>

<p>If dates and timestamps are supported by the backend, the following R types are
used:
</p>

<ul>
<li> <p><a href="base.html#topic+Date">Date</a> for dates
(also applies to the return value of the SQL function <code>current_date</code>)
</p>
</li>
<li> <p><a href="base.html#topic+POSIXct">POSIXct</a> for timestamps
(also applies to the return value of the SQL function <code>current_timestamp</code>)
</p>
</li></ul>

<p>R has no built-in type with lossless support for the full range of 64-bit
or larger integers. If 64-bit integers are returned from a query,
the following rules apply:
</p>

<ul>
<li><p> Values are returned in a container with support for the full range of
valid 64-bit values (such as the <code>integer64</code> class of the <span class="pkg">bit64</span>
package)
</p>
</li>
<li><p> Coercion to numeric always returns a number that is as close as possible
to the true value
</p>
</li>
<li><p> Loss of precision when converting to numeric gives a warning
</p>
</li>
<li><p> Conversion to character always returns a lossless decimal representation
of the data
</p>
</li></ul>



<h3>See Also</h3>

<p>Close the result set with <code><a href="#topic+dbClearResult">dbClearResult()</a></code> as soon as you
finish retrieving the records you want.
</p>
<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>
<p>Other data retrieval generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)

# Fetch all results
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetch(rs)
dbClearResult(rs)

# Fetch in chunks
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")
while (!dbHasCompleted(rs)) {
  chunk &lt;- dbFetch(rs, 10)
  print(nrow(chunk))
}

dbClearResult(rs)
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbFetchArrow'>Fetch records from a previously executed query as an Arrow object</h2><span id='topic+dbFetchArrow'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Fetch the result set and return it as an Arrow object.
Use <code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk()</a></code> to fetch results in chunks.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbFetchArrow(res, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbFetchArrow_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResultArrow-class">DBIResultArrow</a>, created by
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code>.</p>
</td></tr>
<tr><td><code id="dbFetchArrow_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbFetchArrow()</code> always returns an object coercible to a <a href="base.html#topic+data.frame">data.frame</a> with
as many rows as records were fetched and as many
columns as fields in the result set,
even if the result is a single value
or has one
or zero rows.
</p>


<h3>The data retrieval flow for Arrow streams</h3>

<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as an Arrow stream.
</p>
<p>Most of this flow, except repeated calling of <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code> or <code><a href="#topic+dbBind">dbBind()</a></code>,
is implemented by <code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow()</a></code>,
which should be sufficient
unless you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code> to create a result set object of class
<a href="#topic+DBIResultArrow-class">DBIResultArrow</a>.
</p>
</li>
<li><p> Optionally, bind query parameters with <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code> or <code><a href="#topic+dbBind">dbBind()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Use <code><a href="#topic+dbFetchArrow">dbFetchArrow()</a></code> to get a data stream.
</p>
</li>
<li><p> Repeat the last two steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>An attempt to fetch from a closed result set raises an error.
</p>


<h3>Specification</h3>

<p>Fetching multi-row queries with one
or more columns by default returns the entire result.
The object returned by <code>dbFetchArrow()</code> can also be passed to
<code><a href="nanoarrow.html#topic+as_nanoarrow_array_stream">nanoarrow::as_nanoarrow_array_stream()</a></code> to create a nanoarrow
array stream object that can be used to read the result set
in batches.
The chunk size is implementation-specific.
</p>


<h3>See Also</h3>

<p>Close the result set with <code><a href="#topic+dbClearResult">dbClearResult()</a></code> as soon as you
finish retrieving the records you want.
</p>
<p>Other DBIResultArrow generics: 
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>
</p>
<p>Other data retrieval generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)

# Fetch all results
rs &lt;- dbSendQueryArrow(con, "SELECT * FROM mtcars WHERE cyl = 4")
as.data.frame(dbFetchArrow(rs))
dbClearResult(rs)

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbFetchArrowChunk'>Fetch the next batch of records from a previously executed query as an Arrow object</h2><span id='topic+dbFetchArrowChunk'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Fetch the next chunk of the result set and return it as an Arrow object.
The chunk size is implementation-specific.
Use <code><a href="#topic+dbFetchArrow">dbFetchArrow()</a></code> to fetch all results.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbFetchArrowChunk(res, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbFetchArrowChunk_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResultArrow-class">DBIResultArrow</a>, created by
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code>.</p>
</td></tr>
<tr><td><code id="dbFetchArrowChunk_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbFetchArrowChunk()</code> always returns an object coercible to a <a href="base.html#topic+data.frame">data.frame</a> with
as many rows as records were fetched and as many
columns as fields in the result set,
even if the result is a single value
or has one
or zero rows.
</p>


<h3>The data retrieval flow for Arrow streams</h3>

<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as an Arrow stream.
</p>
<p>Most of this flow, except repeated calling of <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code> or <code><a href="#topic+dbBind">dbBind()</a></code>,
is implemented by <code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow()</a></code>,
which should be sufficient
unless you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code> to create a result set object of class
<a href="#topic+DBIResultArrow-class">DBIResultArrow</a>.
</p>
</li>
<li><p> Optionally, bind query parameters with <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code> or <code><a href="#topic+dbBind">dbBind()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Use <code><a href="#topic+dbFetchArrow">dbFetchArrow()</a></code> to get a data stream.
</p>
</li>
<li><p> Repeat the last two steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>An attempt to fetch from a closed result set raises an error.
</p>


<h3>Specification</h3>

<p>Fetching multi-row queries with one
or more columns returns the next chunk.
The size of the chunk is implementation-specific.
The object returned by <code>dbFetchArrowChunk()</code> can also be passed to
<code><a href="nanoarrow.html#topic+as_nanoarrow_array">nanoarrow::as_nanoarrow_array()</a></code> to create a nanoarrow array object.
The chunk size is implementation-specific.
</p>


<h3>See Also</h3>

<p>Close the result set with <code><a href="#topic+dbClearResult">dbClearResult()</a></code> as soon as you
finish retrieving the records you want.
</p>
<p>Other DBIResultArrow generics: 
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>
</p>
<p>Other data retrieval generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)

# Fetch all results
rs &lt;- dbSendQueryArrow(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbHasCompleted(rs)
as.data.frame(dbFetchArrowChunk(rs))
dbHasCompleted(rs)
as.data.frame(dbFetchArrowChunk(rs))
dbClearResult(rs)

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbGetConnectArgs'>Get connection arguments</h2><span id='topic+dbGetConnectArgs'></span>

<h3>Description</h3>

<p>Returns the arguments stored in a <a href="#topic+DBIConnector-class">DBIConnector</a> object for inspection,
optionally evaluating them.
This function is called by <code><a href="#topic+dbConnect">dbConnect()</a></code>
and usually does not need to be called directly.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbGetConnectArgs(drv, eval = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbGetConnectArgs_+3A_drv">drv</code></td>
<td>
<p>A object inheriting from <a href="#topic+DBIConnector-class">DBIConnector</a>.</p>
</td></tr>
<tr><td><code id="dbGetConnectArgs_+3A_eval">eval</code></td>
<td>
<p>Set to <code>FALSE</code> to return the functions that generate the argument
instead of evaluating them.</p>
</td></tr>
<tr><td><code id="dbGetConnectArgs_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not otherwise used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other DBIConnector generics: 
<code><a href="#topic+DBIConnector-class">DBIConnector-class</a></code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cnr &lt;- new("DBIConnector",
  .drv = RSQLite::SQLite(),
  .conn_args = list(dbname = ":memory:", password = function() "supersecret")
)
dbGetConnectArgs(cnr)
dbGetConnectArgs(cnr, eval = FALSE)

</code></pre>

<hr>
<h2 id='dbGetDBIVersion'>Determine the current version of the package.</h2><span id='topic+dbGetDBIVersion'></span>

<h3>Description</h3>

<p>Determine the current version of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbGetDBIVersion()
</code></pre>

<hr>
<h2 id='dbGetException'>Get DBMS exceptions</h2><span id='topic+dbGetException'></span>

<h3>Description</h3>

<p>DEPRECATED. Backends should use R's condition system to signal errors and
warnings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbGetException(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbGetException_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbGetException_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements <code>errorNum</code> (an integer error number) and
<code>errorMsg</code> (a character string) describing the last error in the
connection <code>conn</code>.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>

<hr>
<h2 id='dbGetInfo'>Get DBMS metadata</h2><span id='topic+dbGetInfo'></span>

<h3>Description</h3>

<p>Retrieves information on objects of class <a href="#topic+DBIDriver-class">DBIDriver</a>,
<a href="#topic+DBIConnection-class">DBIConnection</a> or <a href="#topic+DBIResult-class">DBIResult</a>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbGetInfo(dbObj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbGetInfo_+3A_dbobj">dbObj</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIObject-class">DBIObject</a>,
i.e. <a href="#topic+DBIDriver-class">DBIDriver</a>, <a href="#topic+DBIConnection-class">DBIConnection</a>,
or a <a href="#topic+DBIResult-class">DBIResult</a></p>
</td></tr>
<tr><td><code id="dbGetInfo_+3A_...">...</code></td>
<td>
<p>Other arguments to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For objects of class <a href="#topic+DBIDriver-class">DBIDriver</a>, <code>dbGetInfo()</code>
returns a named list
that contains at least the following components:
</p>

<ul>
<li> <p><code>driver.version</code>: the package version of the DBI backend,
</p>
</li>
<li> <p><code>client.version</code>: the version of the DBMS client library.
</p>
</li></ul>

<p>For objects of class <a href="#topic+DBIConnection-class">DBIConnection</a>, <code>dbGetInfo()</code>
returns a named list
that contains at least the following components:
</p>

<ul>
<li> <p><code>db.version</code>: version of the database server,
</p>
</li>
<li> <p><code>dbname</code>: database name,
</p>
</li>
<li> <p><code>username</code>: username to connect to the database,
</p>
</li>
<li> <p><code>host</code>: hostname of the database server,
</p>
</li>
<li> <p><code>port</code>: port on the database server.
It must not contain a <code>password</code> component.
Components that are not applicable should be set to <code>NA</code>.
</p>
</li></ul>

<p>For objects of class <a href="#topic+DBIResult-class">DBIResult</a>, <code>dbGetInfo()</code>
returns a named list
that contains at least the following components:
</p>

<ul>
<li> <p><code>statatment</code>: the statement used with <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> or <code><a href="#topic+dbExecute">dbExecute()</a></code>,
as returned by <code><a href="#topic+dbGetStatement">dbGetStatement()</a></code>,
</p>
</li>
<li> <p><code>row.count</code>: the number of rows fetched so far (for queries),
as returned by <code><a href="#topic+dbGetRowCount">dbGetRowCount()</a></code>,
</p>
</li>
<li> <p><code>rows.affected</code>: the number of rows affected (for statements),
as returned by <code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code>
</p>
</li>
<li> <p><code>has.completed</code>: a logical that indicates
if the query or statement has completed,
as returned by <code><a href="#topic+dbHasCompleted">dbHasCompleted()</a></code>.
</p>
</li></ul>



<h3>Implementation notes</h3>

<p>The default implementation for <code style="white-space: pre;">&#8288;DBIResult objects&#8288;</code>
constructs such a list from the return values of the corresponding methods,
<code><a href="#topic+dbGetStatement">dbGetStatement()</a></code>, <code><a href="#topic+dbGetRowCount">dbGetRowCount()</a></code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code>, and <code><a href="#topic+dbHasCompleted">dbHasCompleted()</a></code>.
</p>


<h3>See Also</h3>

<p>Other DBIDriver generics: 
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+dbCanConnect">dbCanConnect</a>()</code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDriver">dbDriver</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListConnections">dbListConnections</a>()</code>
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>
<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dbGetInfo(RSQLite::SQLite())

</code></pre>

<hr>
<h2 id='dbGetQuery'>Retrieve results from a query</h2><span id='topic+dbGetQuery'></span>

<h3>Description</h3>

<p>Returns the result of a query as a data frame.
<code>dbGetQuery()</code> comes with a default implementation
(which should work with most backends) that calls
<code><a href="#topic+dbSendQuery">dbSendQuery()</a></code>, then <code><a href="#topic+dbFetch">dbFetch()</a></code>, ensuring that
the result is always freed by <code><a href="#topic+dbClearResult">dbClearResult()</a></code>.
For retrieving chunked/paged results or for passing query parameters,
see <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code>, in particular the &quot;The data retrieval flow&quot; section.
For retrieving results as an Arrow object, see <code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow()</a></code>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbGetQuery(conn, statement, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbGetQuery_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbGetQuery_+3A_statement">statement</code></td>
<td>
<p>a character string containing SQL.</p>
</td></tr>
<tr><td><code id="dbGetQuery_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is for <code>SELECT</code> queries only
(incl. other SQL statements that return a <code>SELECT</code>-alike result,
e.g., execution of a stored procedure or data manipulation queries
like <code style="white-space: pre;">&#8288;INSERT INTO ... RETURNING ...&#8288;</code>).
To execute a stored procedure that does not return a result set,
use <code><a href="#topic+dbExecute">dbExecute()</a></code>.
</p>
<p>Some backends may
support data manipulation statements through this method for compatibility
reasons.  However, callers are strongly advised to use
<code><a href="#topic+dbExecute">dbExecute()</a></code> for data manipulation statements.
</p>


<h3>Value</h3>

<p><code>dbGetQuery()</code> always returns a <a href="base.html#topic+data.frame">data.frame</a>, with
as many rows as records were fetched and as many
columns as fields in the result set,
even if the result is a single value
or has one
or zero rows.
</p>


<h3>Implementation notes</h3>

<p>Subclasses should override this method only if they provide some sort of
performance optimization.
</p>


<h3>Failure modes</h3>

<p>An error is raised when issuing a query over a closed
or invalid connection,
if the syntax of the query is invalid,
or if the query is not a non-<code>NA</code> string.
If the <code>n</code> argument is not an atomic whole number
greater or equal to -1 or Inf, an error is raised,
but a subsequent call to <code>dbGetQuery()</code> with proper <code>n</code> argument succeeds.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbGetQuery()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>n</code> (default: -1)
</p>
</li>
<li> <p><code>params</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>immediate</code> (default: <code>NULL</code>)
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Specification&quot; and &quot;Value&quot; sections for details on their usage.
</p>


<h3>Specification</h3>

<p>A column named <code>row_names</code> is treated like any other column.
</p>
<p>The <code>n</code> argument specifies the number of rows to be fetched.
If omitted, fetching multi-row queries with one
or more columns returns the entire result.
A value of <a href="base.html#topic+Inf">Inf</a> for the <code>n</code> argument is supported
and also returns the full result.
If more rows than available are fetched (by passing a too large value for
<code>n</code>), the result is returned in full without warning.
If zero rows are requested, the columns of the data frame are still fully
typed.
Fetching fewer rows than available is permitted,
no warning is issued.
</p>
<p>The <code>param</code> argument allows passing query parameters, see <code><a href="#topic+dbBind">dbBind()</a></code> for details.
</p>


<h3>Specification for the <code>immediate</code> argument</h3>

<p>The <code>immediate</code> argument supports distinguishing between &quot;direct&quot;
and &quot;prepared&quot; APIs offered by many database drivers.
Passing <code>immediate = TRUE</code> leads to immediate execution of the
query or statement, via the &quot;direct&quot; API (if supported by the driver).
The default <code>NULL</code> means that the backend should choose whatever API
makes the most sense for the database, and (if relevant) tries the
other API if the first attempt fails. A successful second attempt
should result in a message that suggests passing the correct
<code>immediate</code> argument.
Examples for possible behaviors:
</p>

<ol>
<li><p> DBI backend defaults to <code>immediate = TRUE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed: query is executed
</p>
</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: rejected immediately by the database
because of a syntax error in the query, the backend tries
<code>immediate = FALSE</code> (and gives a message)
</p>
</li>
<li> <p><code>params</code> given: query is executed using <code>immediate = FALSE</code>
</p>
</li></ol>

</li></ol>

</li>
<li><p> DBI backend defaults to <code>immediate = FALSE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed:
</p>

<ol>
<li><p> simple query: query is executed
</p>
</li>
<li><p> &quot;special&quot; query (such as setting a config options): fails,
the backend tries <code>immediate = TRUE</code> (and gives a message)
</p>
</li></ol>

</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: waiting for parameters via <code><a href="#topic+dbBind">dbBind()</a></code>
</p>
</li>
<li> <p><code>params</code> given: query is executed
</p>
</li></ol>

</li></ol>

</li></ol>



<h3>See Also</h3>

<p>For updates: <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> and <code><a href="#topic+dbExecute">dbExecute()</a></code>.
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>
<p>Other data retrieval generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
dbGetQuery(con, "SELECT * FROM mtcars")
dbGetQuery(con, "SELECT * FROM mtcars", n = 6)

# Pass values using the param argument:
# (This query runs eight times, once for each different
# parameter. The resulting rows are combined into a single
# data frame.)
dbGetQuery(
  con,
  "SELECT COUNT(*) FROM mtcars WHERE cyl = ?",
  params = list(1:8)
)

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbGetQueryArrow'>Retrieve results from a query as an Arrow object</h2><span id='topic+dbGetQueryArrow'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Returns the result of a query as an Arrow object.
<code>dbGetQueryArrow()</code> comes with a default implementation
(which should work with most backends) that calls
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code>, then <code><a href="#topic+dbFetchArrow">dbFetchArrow()</a></code>, ensuring that
the result is always freed by <code><a href="#topic+dbClearResult">dbClearResult()</a></code>.
For passing query parameters,
see <code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code>, in particular
the &quot;The data retrieval flow for Arrow streams&quot; section.
For retrieving results as a data frame, see <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbGetQueryArrow(conn, statement, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbGetQueryArrow_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbGetQueryArrow_+3A_statement">statement</code></td>
<td>
<p>a character string containing SQL.</p>
</td></tr>
<tr><td><code id="dbGetQueryArrow_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is for <code>SELECT</code> queries only
(incl. other SQL statements that return a <code>SELECT</code>-alike result,
e.g., execution of a stored procedure or data manipulation queries
like <code style="white-space: pre;">&#8288;INSERT INTO ... RETURNING ...&#8288;</code>).
To execute a stored procedure that does not return a result set,
use <code><a href="#topic+dbExecute">dbExecute()</a></code>.
</p>
<p>Some backends may
support data manipulation statements through this method.
However, callers are strongly advised to use
<code><a href="#topic+dbExecute">dbExecute()</a></code> for data manipulation statements.
</p>


<h3>Value</h3>

<p><code>dbGetQueryArrow()</code> always returns an object coercible to a <a href="base.html#topic+data.frame">data.frame</a>, with
as many rows as records were fetched and as many
columns as fields in the result set,
even if the result is a single value
or has one
or zero rows.
</p>


<h3>Implementation notes</h3>

<p>Subclasses should override this method only if they provide some sort of
performance optimization.
</p>


<h3>Failure modes</h3>

<p>An error is raised when issuing a query over a closed
or invalid connection,
if the syntax of the query is invalid,
or if the query is not a non-<code>NA</code> string.
The object returned by <code>dbGetQueryArrow()</code> can also be passed to
<code><a href="nanoarrow.html#topic+as_nanoarrow_array_stream">nanoarrow::as_nanoarrow_array_stream()</a></code> to create a nanoarrow
array stream object that can be used to read the result set
in batches.
The chunk size is implementation-specific.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbGetQueryArrow()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>params</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>immediate</code> (default: <code>NULL</code>)
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Specification&quot; and &quot;Value&quot; sections for details on their usage.
</p>
<p>The <code>param</code> argument allows passing query parameters, see <code><a href="#topic+dbBind">dbBind()</a></code> for details.
</p>


<h3>Specification for the <code>immediate</code> argument</h3>

<p>The <code>immediate</code> argument supports distinguishing between &quot;direct&quot;
and &quot;prepared&quot; APIs offered by many database drivers.
Passing <code>immediate = TRUE</code> leads to immediate execution of the
query or statement, via the &quot;direct&quot; API (if supported by the driver).
The default <code>NULL</code> means that the backend should choose whatever API
makes the most sense for the database, and (if relevant) tries the
other API if the first attempt fails. A successful second attempt
should result in a message that suggests passing the correct
<code>immediate</code> argument.
Examples for possible behaviors:
</p>

<ol>
<li><p> DBI backend defaults to <code>immediate = TRUE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed: query is executed
</p>
</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: rejected immediately by the database
because of a syntax error in the query, the backend tries
<code>immediate = FALSE</code> (and gives a message)
</p>
</li>
<li> <p><code>params</code> given: query is executed using <code>immediate = FALSE</code>
</p>
</li></ol>

</li></ol>

</li>
<li><p> DBI backend defaults to <code>immediate = FALSE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed:
</p>

<ol>
<li><p> simple query: query is executed
</p>
</li>
<li><p> &quot;special&quot; query (such as setting a config options): fails,
the backend tries <code>immediate = TRUE</code> (and gives a message)
</p>
</li></ol>

</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: waiting for parameters via <code><a href="#topic+dbBind">dbBind()</a></code>
</p>
</li>
<li> <p><code>params</code> given: query is executed
</p>
</li></ol>

</li></ol>

</li></ol>



<h3>See Also</h3>

<p>For updates: <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> and <code><a href="#topic+dbExecute">dbExecute()</a></code>.
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>
<p>Other data retrieval generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Retrieve data as arrow table
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
dbGetQueryArrow(con, "SELECT * FROM mtcars")

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbGetRowCount'>The number of rows fetched so far</h2><span id='topic+dbGetRowCount'></span>

<h3>Description</h3>

<p>Returns the total number of rows actually fetched with calls to <code><a href="#topic+dbFetch">dbFetch()</a></code>
for this result set.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbGetRowCount(res, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbGetRowCount_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResult-class">DBIResult</a>.</p>
</td></tr>
<tr><td><code id="dbGetRowCount_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbGetRowCount()</code> returns a scalar number (integer or numeric),
the number of rows fetched so far.
After calling <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code>,
the row count is initially zero.
After a call to <code><a href="#topic+dbFetch">dbFetch()</a></code> without limit,
the row count matches the total number of rows returned.
Fetching a limited number of rows
increases the number of rows by the number of rows returned,
even if fetching past the end of the result set.
For queries with an empty result set,
zero is returned
even after fetching.
For data manipulation statements issued with
<code><a href="#topic+dbSendStatement">dbSendStatement()</a></code>,
zero is returned before
and after calling <code>dbFetch()</code>.
</p>


<h3>Failure modes</h3>

<p>Attempting to get the row count for a result set cleared with
<code><a href="#topic+dbClearResult">dbClearResult()</a></code> gives an error.
</p>


<h3>See Also</h3>

<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")

dbGetRowCount(rs)
ret1 &lt;- dbFetch(rs, 10)
dbGetRowCount(rs)
ret2 &lt;- dbFetch(rs)
dbGetRowCount(rs)
nrow(ret1) + nrow(ret2)

dbClearResult(rs)
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbGetRowsAffected'>The number of rows affected</h2><span id='topic+dbGetRowsAffected'></span>

<h3>Description</h3>

<p>This method returns the number of rows that were added, deleted, or updated
by a data manipulation statement.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbGetRowsAffected(res, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbGetRowsAffected_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResult-class">DBIResult</a>.</p>
</td></tr>
<tr><td><code id="dbGetRowsAffected_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbGetRowsAffected()</code> returns a scalar number (integer or numeric),
the number of rows affected by a data manipulation statement
issued with <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code>.
The value is available directly after the call
and does not change after calling <code><a href="#topic+dbFetch">dbFetch()</a></code>.
<code>NA_integer_</code> or <code>NA_numeric_</code> are allowed if the number of rows affected is not known.
</p>
<p>For queries issued with <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code>,
zero is returned before
and after the call to <code>dbFetch()</code>.
<code>NA</code> values are not allowed.
</p>


<h3>The command execution flow</h3>

<p>This section gives a complete overview over the flow
for the execution of SQL statements that have side effects
such as stored procedures, inserting or deleting data,
or setting database or connection options.
Most of this flow, except repeated calling of <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>,
is implemented by <code><a href="#topic+dbExecute">dbExecute()</a></code>, which should be sufficient
for non-parameterized queries.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> to create a result set object of class
<a href="#topic+DBIResult-class">DBIResult</a>.
For some queries you need to pass <code>immediate = TRUE</code>.
</p>
</li>
<li><p> Optionally, bind query parameters with<code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Optionally, use <code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code> to retrieve the number
of rows affected by the query.
</p>
</li>
<li><p> Repeat the last two steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>Attempting to get the rows affected for a result set cleared with
<code><a href="#topic+dbClearResult">dbClearResult()</a></code> gives an error.
</p>


<h3>See Also</h3>

<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>
<p>Other command execution generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendStatement(con, "DELETE FROM mtcars")
dbGetRowsAffected(rs)
nrow(mtcars)

dbClearResult(rs)
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbGetStatement'>Get the statement associated with a result set</h2><span id='topic+dbGetStatement'></span>

<h3>Description</h3>

<p>Returns the statement that was passed to <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code>
or <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbGetStatement(res, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbGetStatement_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResult-class">DBIResult</a>.</p>
</td></tr>
<tr><td><code id="dbGetStatement_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbGetStatement()</code> returns a string, the query used in
either <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> or
<code><a href="#topic+dbSendStatement">dbSendStatement()</a></code>.
</p>


<h3>Failure modes</h3>

<p>Attempting to query the statement for a result set cleared with
<code><a href="#topic+dbClearResult">dbClearResult()</a></code> gives an error.
</p>


<h3>See Also</h3>

<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")
dbGetStatement(rs)

dbClearResult(rs)
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbHasCompleted'>Completion status</h2><span id='topic+dbHasCompleted'></span>

<h3>Description</h3>

<p>This method returns if the operation has completed.
A <code>SELECT</code> query is completed if all rows have been fetched.
A data manipulation statement is always completed.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbHasCompleted(res, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbHasCompleted_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResult-class">DBIResult</a>.</p>
</td></tr>
<tr><td><code id="dbHasCompleted_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbHasCompleted()</code> returns a logical scalar.
For a query initiated by <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> with non-empty result set,
<code>dbHasCompleted()</code> returns <code>FALSE</code> initially
and <code>TRUE</code> after calling <code><a href="#topic+dbFetch">dbFetch()</a></code> without limit.
For a query initiated by <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code>,
<code>dbHasCompleted()</code> always returns <code>TRUE</code>.
</p>


<h3>The data retrieval flow</h3>

<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>,
is implemented by <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> to create a result set object of class
<a href="#topic+DBIResult-class">DBIResult</a>.
</p>
</li>
<li><p> Optionally, bind query parameters with <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Optionally, use <code><a href="#topic+dbColumnInfo">dbColumnInfo()</a></code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li><p> Use <code><a href="#topic+dbFetch">dbFetch()</a></code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li><p> Use <code><a href="#topic+dbHasCompleted">dbHasCompleted()</a></code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li><p> Repeat the last four steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>Attempting to query completion status for a result set cleared with
<code><a href="#topic+dbClearResult">dbClearResult()</a></code> gives an error.
</p>


<h3>Specification</h3>

<p>The completion status for a query is only guaranteed to be set to
<code>FALSE</code> after attempting to fetch past the end of the entire result.
Therefore, for a query with an empty result set,
the initial return value is unspecified,
but the result value is <code>TRUE</code> after trying to fetch only one row.
</p>
<p>Similarly, for a query with a result set of length n,
the return value is unspecified after fetching n rows,
but the result value is <code>TRUE</code> after trying to fetch only one more
row.
</p>


<h3>See Also</h3>

<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>
<p>Other DBIResultArrow generics: 
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>
</p>
<p>Other data retrieval generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")

dbHasCompleted(rs)
ret1 &lt;- dbFetch(rs, 10)
dbHasCompleted(rs)
ret2 &lt;- dbFetch(rs)
dbHasCompleted(rs)

dbClearResult(rs)
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='DBIConnection-class'>DBIConnection class</h2><span id='topic+DBIConnection-class'></span>

<h3>Description</h3>

<p>This virtual class encapsulates the connection to a DBMS, and it provides
access to dynamic queries, result sets, DBMS session management
(transactions), etc.
</p>


<h3>Implementation note</h3>

<p>Individual drivers are free to implement single or multiple simultaneous
connections.
</p>


<h3>See Also</h3>

<p>Other DBI classes: 
<code><a href="#topic+DBIConnector-class">DBIConnector-class</a></code>,
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+DBIObject-class">DBIObject-class</a></code>,
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
con
dbDisconnect(con)
## Not run: 
con &lt;- dbConnect(RPostgreSQL::PostgreSQL(), "username", "password")
con
dbDisconnect(con)

## End(Not run)

</code></pre>

<hr>
<h2 id='DBIConnector-class'>DBIConnector class</h2><span id='topic+DBIConnector-class'></span>

<h3>Description</h3>

<p>Wraps objects of the <a href="#topic+DBIDriver-class">DBIDriver</a> class to include connection options.
The purpose of this class is to store both the driver
and the connection options.
A database connection can be established
with a call to <code><a href="#topic+dbConnect">dbConnect()</a></code>, passing only that object
without additional arguments.
</p>


<h3>Details</h3>

<p>To prevent leakage of passwords and other credentials,
this class supports delayed evaluation.
All arguments can optionally be a function (callable without arguments).
In such a case, the function is evaluated transparently when connecting in
<code><a href="#topic+dbGetConnectArgs">dbGetConnectArgs()</a></code>.
</p>


<h3>See Also</h3>

<p>Other DBI classes: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+DBIObject-class">DBIObject-class</a></code>,
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>
</p>
<p>Other DBIConnector generics: 
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbGetConnectArgs">dbGetConnectArgs</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a connector:
cnr &lt;- new("DBIConnector",
  .drv = RSQLite::SQLite(),
  .conn_args = list(dbname = ":memory:")
)
cnr

# Establish a connection through this connector:
con &lt;- dbConnect(cnr)
con

# Access the database through this connection:
dbGetQuery(con, "SELECT 1 AS a")
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='DBIDriver-class'>DBIDriver class</h2><span id='topic+DBIDriver-class'></span>

<h3>Description</h3>

<p>Base class for all DBMS drivers (e.g., RSQLite, MySQL, PostgreSQL).
The virtual class <code>DBIDriver</code> defines the operations for creating
connections and defining data type mappings.  Actual driver classes, for
instance <code>RPostgres</code>, <code>RMariaDB</code>, etc. implement these operations in a
DBMS-specific manner.
</p>


<h3>See Also</h3>

<p>Other DBI classes: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+DBIConnector-class">DBIConnector-class</a></code>,
<code><a href="#topic+DBIObject-class">DBIObject-class</a></code>,
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>
</p>
<p>Other DBIDriver generics: 
<code><a href="#topic+dbCanConnect">dbCanConnect</a>()</code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDriver">dbDriver</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListConnections">dbListConnections</a>()</code>
</p>

<hr>
<h2 id='DBIObject-class'>DBIObject class</h2><span id='topic+DBIObject-class'></span>

<h3>Description</h3>

<p>Base class for all other DBI classes (e.g., drivers, connections). This
is a virtual Class: No objects may be created from it.
</p>


<h3>Details</h3>

<p>More generally, the DBI defines a very small set of classes and generics that
allows users and applications access DBMS with a common interface.  The
virtual classes are <code>DBIDriver</code> that individual drivers extend,
<code>DBIConnection</code> that represent instances of DBMS connections, and
<code>DBIResult</code> that represent the result of a DBMS statement.  These three
classes extend the basic class of <code>DBIObject</code>, which serves as the root
or parent of the class hierarchy.
</p>


<h3>Implementation notes</h3>

<p>An implementation MUST provide methods for the following generics:
</p>

<ul>
<li> <p><code><a href="#topic+dbGetInfo">dbGetInfo()</a></code>.
</p>
</li></ul>

<p>It MAY also provide methods for:
</p>

<ul>
<li> <p><code><a href="base.html#topic+summary">summary()</a></code>. Print a concise description of the
object. The default method invokes <code>dbGetInfo(dbObj)</code> and prints
the name-value pairs one per line.  Individual implementations may
tailor this appropriately.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other DBI classes: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+DBIConnector-class">DBIConnector-class</a></code>,
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
drv &lt;- RSQLite::SQLite()
con &lt;- dbConnect(drv)

rs &lt;- dbSendQuery(con, "SELECT 1")
is(drv, "DBIObject")   ## True
is(con, "DBIObject")   ## True
is(rs, "DBIObject")

dbClearResult(rs)
dbDisconnect(con)

</code></pre>

<hr>
<h2 id='DBIResult-class'>DBIResult class</h2><span id='topic+DBIResult-class'></span>

<h3>Description</h3>

<p>This virtual class describes the result and state of execution of
a DBMS statement (any statement, query or non-query).  The result set
keeps track of whether the statement produces output how many rows were
affected by the operation, how many rows have been fetched (if statement is
a query), whether there are more rows to fetch, etc.
</p>


<h3>Implementation notes</h3>

<p>Individual drivers are free to allow single or multiple
active results per connection.
</p>
<p>The default show method displays a summary of the query using other
DBI generics.
</p>


<h3>See Also</h3>

<p>Other DBI classes: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+DBIConnector-class">DBIConnector-class</a></code>,
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+DBIObject-class">DBIObject-class</a></code>,
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>
</p>
<p>Other DBIResult generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>

<hr>
<h2 id='DBIResultArrow-class'>DBIResultArrow class</h2><span id='topic+DBIResultArrow-class'></span><span id='topic+DBIResultArrowDefault-class'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This virtual class describes the result and state of execution of
a DBMS statement (any statement, query or non-query)
for returning data as an Arrow object.
</p>


<h3>Implementation notes</h3>

<p>Individual drivers are free to allow single or multiple
active results per connection.
</p>
<p>The default show method displays a summary of the query using other
DBI generics.
</p>


<h3>See Also</h3>

<p>Other DBI classes: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+DBIConnector-class">DBIConnector-class</a></code>,
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+DBIObject-class">DBIObject-class</a></code>,
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>
</p>
<p>Other DBIResultArrow generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>
</p>

<hr>
<h2 id='dbIsReadOnly'>Is this DBMS object read only?</h2><span id='topic+dbIsReadOnly'></span>

<h3>Description</h3>

<p>This generic tests whether a database object is read only.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbIsReadOnly(dbObj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbIsReadOnly_+3A_dbobj">dbObj</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIObject-class">DBIObject</a>,
i.e. <a href="#topic+DBIDriver-class">DBIDriver</a>, <a href="#topic+DBIConnection-class">DBIConnection</a>,
or a <a href="#topic+DBIResult-class">DBIResult</a></p>
</td></tr>
<tr><td><code id="dbIsReadOnly_+3A_...">...</code></td>
<td>
<p>Other arguments to methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other DBIDriver generics: 
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+dbCanConnect">dbCanConnect</a>()</code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDriver">dbDriver</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListConnections">dbListConnections</a>()</code>
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>
<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>
<p>Other DBIConnector generics: 
<code><a href="#topic+DBIConnector-class">DBIConnector-class</a></code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbGetConnectArgs">dbGetConnectArgs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dbIsReadOnly(ANSI())
</code></pre>

<hr>
<h2 id='dbIsValid'>Is this DBMS object still valid?</h2><span id='topic+dbIsValid'></span>

<h3>Description</h3>

<p>This generic tests whether a database object is still valid (i.e. it hasn't
been disconnected or cleared).
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbIsValid(dbObj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbIsValid_+3A_dbobj">dbObj</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIObject-class">DBIObject</a>,
i.e. <a href="#topic+DBIDriver-class">DBIDriver</a>, <a href="#topic+DBIConnection-class">DBIConnection</a>,
or a <a href="#topic+DBIResult-class">DBIResult</a></p>
</td></tr>
<tr><td><code id="dbIsValid_+3A_...">...</code></td>
<td>
<p>Other arguments to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbIsValid()</code> returns a logical scalar,
<code>TRUE</code> if the object specified by <code>dbObj</code> is valid,
<code>FALSE</code> otherwise.
A <a href="#topic+DBIConnection-class">DBIConnection</a> object is initially valid,
and becomes invalid after disconnecting with <code><a href="#topic+dbDisconnect">dbDisconnect()</a></code>.
For an invalid connection object (e.g., for some drivers if the object
is saved to a file and then restored), the method also returns <code>FALSE</code>.
A <a href="#topic+DBIResult-class">DBIResult</a> object is valid after a call to <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code>,
and stays valid even after all rows have been fetched;
only clearing it with <code><a href="#topic+dbClearResult">dbClearResult()</a></code> invalidates it.
A <a href="#topic+DBIResult-class">DBIResult</a> object is also valid after a call to <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code>,
and stays valid after querying the number of rows affected;
only clearing it with <code><a href="#topic+dbClearResult">dbClearResult()</a></code> invalidates it.
If the connection to the database system is dropped (e.g., due to
connectivity problems, server failure, etc.), <code>dbIsValid()</code> should return
<code>FALSE</code>. This is not tested automatically.
</p>


<h3>See Also</h3>

<p>Other DBIDriver generics: 
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+dbCanConnect">dbCanConnect</a>()</code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDriver">dbDriver</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbListConnections">dbListConnections</a>()</code>
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>
<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>
<p>Other DBIResultArrow generics: 
<code><a href="#topic+DBIResultArrow-class">DBIResultArrow-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dbIsValid(RSQLite::SQLite())

con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
dbIsValid(con)

rs &lt;- dbSendQuery(con, "SELECT 1")
dbIsValid(rs)

dbClearResult(rs)
dbIsValid(rs)

dbDisconnect(con)
dbIsValid(con)

</code></pre>

<hr>
<h2 id='dbListConnections'>List currently open connections</h2><span id='topic+dbListConnections'></span>

<h3>Description</h3>

<p>DEPRECATED, drivers are no longer required to implement this method.
Keep track of the connections you opened if you require a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbListConnections(drv, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbListConnections_+3A_drv">drv</code></td>
<td>
<p>A object inheriting from <a href="#topic+DBIDriver-class">DBIDriver</a></p>
</td></tr>
<tr><td><code id="dbListConnections_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>


<h3>See Also</h3>

<p>Other DBIDriver generics: 
<code><a href="#topic+DBIDriver-class">DBIDriver-class</a></code>,
<code><a href="#topic+dbCanConnect">dbCanConnect</a>()</code>,
<code><a href="#topic+dbConnect">dbConnect</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDriver">dbDriver</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>
</p>

<hr>
<h2 id='dbListFields'>List field names of a remote table</h2><span id='topic+dbListFields'></span>

<h3>Description</h3>

<p>Returns the field names of a remote table as a character vector.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbListFields(conn, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbListFields_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbListFields_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbListFields_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbListFields()</code>
returns a character vector
that enumerates all fields
in the table in the correct order.
This also works for temporary tables if supported by the database.
The returned names are suitable for quoting with <code>dbQuoteIdentifier()</code>.
</p>


<h3>Failure modes</h3>

<p>If the table does not exist, an error is raised.
Invalid types for the <code>name</code> argument
(e.g., <code>character</code> of length not equal to one,
or numeric)
lead to an error.
An error is also raised when calling this method for a closed
or invalid connection.
</p>


<h3>Specification</h3>

<p>The <code>name</code> argument can be
</p>

<ul>
<li><p> a string
</p>
</li>
<li><p> the return value of <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>
</p>
</li>
<li><p> a value from the <code>table</code> column from the return value of
<code><a href="#topic+dbListObjects">dbListObjects()</a></code> where <code>is_prefix</code> is <code>FALSE</code>
</p>
</li></ul>

<p>A column named <code>row_names</code> is treated like any other column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbColumnInfo">dbColumnInfo()</a></code> to get the type of the fields.
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
dbListFields(con, "mtcars")

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbListObjects'>List remote objects</h2><span id='topic+dbListObjects'></span>

<h3>Description</h3>

<p>Returns the names of remote objects accessible through this connection
as a data frame.
This should include temporary objects, but not all database backends
(in particular <span class="pkg">RMariaDB</span> and <span class="pkg">RMySQL</span>) support this.
Compared to <code><a href="#topic+dbListTables">dbListTables()</a></code>, this method also enumerates tables and views
in schemas, and returns fully qualified identifiers to access these objects.
This allows exploration of all database objects available to the current
user, including those that can only be accessed by giving the full
namespace.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbListObjects(conn, prefix = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbListObjects_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbListObjects_+3A_prefix">prefix</code></td>
<td>
<p>A fully qualified path in the database's namespace, or <code>NULL</code>.
This argument will be processed with <code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier()</a></code>.
If given the method will return all objects accessible through this prefix.</p>
</td></tr>
<tr><td><code id="dbListObjects_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbListObjects()</code>
returns a data frame
with columns
<code>table</code> and <code>is_prefix</code> (in that order),
optionally with other columns with a dot (<code>.</code>) prefix.
The <code>table</code> column is of type list.
Each object in this list is suitable for use as argument in <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>.
The <code>is_prefix</code> column is a logical.
This data frame contains one row for each object (schema, table
and view)
accessible from the prefix (if passed) or from the global namespace
(if prefix is omitted).
Tables added with <code><a href="#topic+dbWriteTable">dbWriteTable()</a></code> are
part of the data frame.
As soon a table is removed from the database,
it is also removed from the data frame of database objects.
</p>
<p>The same applies to temporary objects if supported by the database.
</p>
<p>The returned names are suitable for quoting with <code>dbQuoteIdentifier()</code>.
</p>


<h3>Failure modes</h3>

<p>An error is raised when calling this method for a closed
or invalid connection.
</p>


<h3>Specification</h3>

<p>The <code>prefix</code> column indicates if the <code>table</code> value refers to a table
or a prefix.
For a call with the default <code>prefix = NULL</code>, the <code>table</code>
values that have <code>is_prefix == FALSE</code> correspond to the tables
returned from <code><a href="#topic+dbListTables">dbListTables()</a></code>,
</p>
<p>The <code>table</code> object can be quoted with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>.
The result of quoting can be passed to <code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier()</a></code>.
(For backends it may be convenient to use the <a href="#topic+Id">Id</a> class, but this is
not required.)
</p>
<p>Values in <code>table</code> column that have <code>is_prefix == TRUE</code> can be
passed as the <code>prefix</code> argument to another call to <code>dbListObjects()</code>.
For the data frame returned from a <code>dbListObject()</code> call with the
<code>prefix</code> argument set, all <code>table</code> values where <code>is_prefix</code> is
<code>FALSE</code> can be used in a call to <code><a href="#topic+dbExistsTable">dbExistsTable()</a></code> which returns
<code>TRUE</code>.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbListObjects(con)
dbWriteTable(con, "mtcars", mtcars)
dbListObjects(con)

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbListResults'>A list of all pending results</h2><span id='topic+dbListResults'></span>

<h3>Description</h3>

<p>DEPRECATED. DBI currenty supports only one open result set per connection,
you need to keep track of the result sets you open if you need this
functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbListResults(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbListResults_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbListResults_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list. If no results are active, an empty list. If only
a single result is active, a list with one element.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>

<hr>
<h2 id='dbListTables'>List remote tables</h2><span id='topic+dbListTables'></span>

<h3>Description</h3>

<p>Returns the unquoted names of remote tables accessible through this
connection.
This should include views and temporary objects, but not all database backends
(in particular <span class="pkg">RMariaDB</span> and <span class="pkg">RMySQL</span>) support this.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbListTables(conn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbListTables_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbListTables_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbListTables()</code>
returns a character vector
that enumerates all tables
and views
in the database.
Tables added with <code><a href="#topic+dbWriteTable">dbWriteTable()</a></code> are
part of the list.
As soon a table is removed from the database,
it is also removed from the list of database tables.
</p>
<p>The same applies to temporary tables if supported by the database.
</p>
<p>The returned names are suitable for quoting with <code>dbQuoteIdentifier()</code>.
</p>


<h3>Failure modes</h3>

<p>An error is raised when calling this method for a closed
or invalid connection.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbListTables(con)
dbWriteTable(con, "mtcars", mtcars)
dbListTables(con)

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbQuoteIdentifier'>Quote identifiers</h2><span id='topic+dbQuoteIdentifier'></span>

<h3>Description</h3>

<p>Call this method to generate a string that is suitable for
use in a query as a column or table name, to make sure that you
generate valid SQL and protect against SQL injection attacks. The inverse
operation is <code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier()</a></code>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbQuoteIdentifier(conn, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbQuoteIdentifier_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbQuoteIdentifier_+3A_x">x</code></td>
<td>
<p>A character vector, <a href="#topic+SQL">SQL</a> or <a href="#topic+Id">Id</a> object to quote as identifier.</p>
</td></tr>
<tr><td><code id="dbQuoteIdentifier_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbQuoteIdentifier()</code> returns an object that can be coerced to <a href="base.html#topic+character">character</a>,
of the same length as the input.
For an empty character vector this function returns a length-0 object.
The names of the input argument are preserved in the output.
When passing the returned object again to <code>dbQuoteIdentifier()</code>
as <code>x</code>
argument, it is returned unchanged.
Passing objects of class <a href="#topic+SQL">SQL</a> should also return them unchanged.
(For backends it may be most convenient to return <a href="#topic+SQL">SQL</a> objects
to achieve this behavior, but this is not required.)
</p>


<h3>Failure modes</h3>

<p>An error is raised if the input contains <code>NA</code>,
but not for an empty string.
</p>


<h3>Specification</h3>

<p>Calling <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code> for a query of the format <code style="white-space: pre;">&#8288;SELECT 1 AS ...&#8288;</code>
returns a data frame with the identifier, unquoted, as column name.
Quoted identifiers can be used as table and column names in SQL queries,
in particular in queries like <code style="white-space: pre;">&#8288;SELECT 1 AS ...&#8288;</code>
and <code style="white-space: pre;">&#8288;SELECT * FROM (SELECT 1) ...&#8288;</code>.
The method must use a quoting mechanism that is unambiguously different
from the quoting mechanism used for strings, so that a query like
<code style="white-space: pre;">&#8288;SELECT ... FROM (SELECT 1 AS ...)&#8288;</code>
throws an error if the column names do not match.
</p>
<p>The method can quote column names that
contain special characters such as a space,
a dot,
a comma,
or quotes used to mark strings
or identifiers,
if the database supports this.
In any case, checking the validity of the identifier
should be performed only when executing a query,
and not by <code>dbQuoteIdentifier()</code>.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Quoting ensures that arbitrary input is safe for use in a query
name &lt;- "Robert'); DROP TABLE Students;--"
dbQuoteIdentifier(ANSI(), name)

# Use Id() to specify other components such as the schema
id_name &lt;- Id(schema = "schema_name", table = "table_name")
id_name
dbQuoteIdentifier(ANSI(), id_name)

# SQL vectors are always passed through as is
var_name &lt;- SQL("select")
var_name
dbQuoteIdentifier(ANSI(), var_name)

# This mechanism is used to prevent double escaping
dbQuoteIdentifier(ANSI(), dbQuoteIdentifier(ANSI(), name))
</code></pre>

<hr>
<h2 id='dbQuoteLiteral'>Quote literal values</h2><span id='topic+dbQuoteLiteral'></span>

<h3>Description</h3>

<p>Call these methods to generate a string that is suitable for
use in a query as a literal value of the correct type, to make sure that you
generate valid SQL and protect against SQL injection attacks.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbQuoteLiteral(conn, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbQuoteLiteral_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbQuoteLiteral_+3A_x">x</code></td>
<td>
<p>A vector to quote as string.</p>
</td></tr>
<tr><td><code id="dbQuoteLiteral_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbQuoteLiteral()</code> returns an object that can be coerced to <a href="base.html#topic+character">character</a>,
of the same length as the input.
For an empty
integer,
numeric,
character,
logical,
date,
time,
or blob vector,
this function returns a length-0 object.
</p>
<p>When passing the returned object again to <code>dbQuoteLiteral()</code>
as <code>x</code>
argument, it is returned unchanged.
Passing objects of class <a href="#topic+SQL">SQL</a> should also return them unchanged.
(For backends it may be most convenient to return <a href="#topic+SQL">SQL</a> objects
to achieve this behavior, but this is not required.)
</p>


<h3>Failure modes</h3>

<p>Passing a list
for the <code>x</code> argument raises an error.
</p>


<h3>Specification</h3>

<p>The returned expression can be used in a <code style="white-space: pre;">&#8288;SELECT ...&#8288;</code> query,
and the value of
<code>dbGetQuery(paste0("SELECT ", dbQuoteLiteral(x)))[[1]]</code>
must be equal to <code>x</code>
for any scalar
integer,
numeric,
string,
and logical.
If <code>x</code> is <code>NA</code>, the result must merely satisfy <code><a href="base.html#topic+is.na">is.na()</a></code>.
The literals <code>"NA"</code> or <code>"NULL"</code> are not treated specially.
</p>
<p><code>NA</code> should be translated to an unquoted SQL <code>NULL</code>,
so that the query <code style="white-space: pre;">&#8288;SELECT * FROM (SELECT 1) a WHERE ... IS NULL&#8288;</code>
returns one row.
</p>


<h3>See Also</h3>

<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteString">dbQuoteString</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Quoting ensures that arbitrary input is safe for use in a query
name &lt;- "Robert'); DROP TABLE Students;--"
dbQuoteLiteral(ANSI(), name)

# NAs become NULL
dbQuoteLiteral(ANSI(), c(1:3, NA))

# Logicals become integers by default
dbQuoteLiteral(ANSI(), c(TRUE, FALSE, NA))

# Raw vectors become hex strings by default
dbQuoteLiteral(ANSI(), list(as.raw(1:3), NULL))

# SQL vectors are always passed through as is
var_name &lt;- SQL("select")
var_name
dbQuoteLiteral(ANSI(), var_name)

# This mechanism is used to prevent double escaping
dbQuoteLiteral(ANSI(), dbQuoteLiteral(ANSI(), name))
</code></pre>

<hr>
<h2 id='dbQuoteString'>Quote literal strings</h2><span id='topic+dbQuoteString'></span>

<h3>Description</h3>

<p>Call this method to generate a string that is suitable for
use in a query as a string literal, to make sure that you
generate valid SQL and protect against SQL injection attacks.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbQuoteString(conn, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbQuoteString_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbQuoteString_+3A_x">x</code></td>
<td>
<p>A character vector to quote as string.</p>
</td></tr>
<tr><td><code id="dbQuoteString_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbQuoteString()</code> returns an object that can be coerced to <a href="base.html#topic+character">character</a>,
of the same length as the input.
For an empty character vector this function returns a length-0 object.
</p>
<p>When passing the returned object again to <code>dbQuoteString()</code>
as <code>x</code>
argument, it is returned unchanged.
Passing objects of class <a href="#topic+SQL">SQL</a> should also return them unchanged.
(For backends it may be most convenient to return <a href="#topic+SQL">SQL</a> objects
to achieve this behavior, but this is not required.)
</p>


<h3>Failure modes</h3>

<p>Passing a numeric,
integer,
logical,
or raw vector,
or a list
for the <code>x</code> argument raises an error.
</p>


<h3>Specification</h3>

<p>The returned expression can be used in a <code style="white-space: pre;">&#8288;SELECT ...&#8288;</code> query,
and for any scalar character <code>x</code> the value of
<code>dbGetQuery(paste0("SELECT ", dbQuoteString(x)))[[1]]</code>
must be identical to <code>x</code>,
even if <code>x</code> contains
spaces,
tabs,
quotes (single
or double),
backticks,
or newlines
(in any combination)
or is itself the result of a <code>dbQuoteString()</code> call coerced back to
character (even repeatedly).
If <code>x</code> is <code>NA</code>, the result must merely satisfy <code><a href="base.html#topic+is.na">is.na()</a></code>.
The strings <code>"NA"</code> or <code>"NULL"</code> are not treated specially.
</p>
<p><code>NA</code> should be translated to an unquoted SQL <code>NULL</code>,
so that the query <code style="white-space: pre;">&#8288;SELECT * FROM (SELECT 1) a WHERE ... IS NULL&#8288;</code>
returns one row.
</p>


<h3>See Also</h3>

<p>Other DBIResult generics: 
<code><a href="#topic+DBIResult-class">DBIResult-class</a></code>,
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbColumnInfo">dbColumnInfo</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetRowCount">dbGetRowCount</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>,
<code><a href="#topic+dbGetStatement">dbGetStatement</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Quoting ensures that arbitrary input is safe for use in a query
name &lt;- "Robert'); DROP TABLE Students;--"
dbQuoteString(ANSI(), name)

# NAs become NULL
dbQuoteString(ANSI(), c("x", NA))

# SQL vectors are always passed through as is
var_name &lt;- SQL("select")
var_name
dbQuoteString(ANSI(), var_name)

# This mechanism is used to prevent double escaping
dbQuoteString(ANSI(), dbQuoteString(ANSI(), name))
</code></pre>

<hr>
<h2 id='dbReadTable'>Read database tables as data frames</h2><span id='topic+dbReadTable'></span>

<h3>Description</h3>

<p>Reads a database table to a data frame, optionally converting
a column to row names and converting the column names to valid
R identifiers.
Use <code><a href="#topic+dbReadTableArrow">dbReadTableArrow()</a></code> instead to obtain an Arrow object.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbReadTable(conn, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbReadTable_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbReadTable_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbReadTable_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a data frame.
Use <code><a href="#topic+dbReadTableArrow">dbReadTableArrow()</a></code> to obtain an Arrow object.
</p>


<h3>Value</h3>

<p><code>dbReadTable()</code> returns a data frame that contains the complete data
from the remote table, effectively the result of calling <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code> with
<code style="white-space: pre;">&#8288;SELECT * FROM &lt;name&gt;&#8288;</code>.
</p>
<p>An empty table is returned as a data frame with zero rows.
</p>
<p>The presence of <a href="#topic+rownames">rownames</a> depends on the <code>row.names</code> argument,
see <code><a href="#topic+sqlColumnToRownames">sqlColumnToRownames()</a></code> for details:
</p>

<ul>
<li><p> If <code>FALSE</code> or <code>NULL</code>, the returned data frame doesn't have row names.
</p>
</li>
<li><p> If <code>TRUE</code>, a column named &quot;row_names&quot; is converted to row names.
</p>
</li></ul>


<ul>
<li><p> If <code>NA</code>, a column named &quot;row_names&quot; is converted to row names if it exists,
otherwise no translation occurs.
</p>
</li>
<li><p> If a string, this specifies the name of the column in the remote table
that contains the row names.
</p>
</li></ul>

<p>The default is <code>row.names = FALSE</code>.
</p>
<p>If the database supports identifiers with special characters,
the columns in the returned data frame are converted to valid R
identifiers
if the <code>check.names</code> argument is <code>TRUE</code>,
If <code>check.names = FALSE</code>, the returned table has non-syntactic column names without quotes.
</p>


<h3>Failure modes</h3>

<p>An error is raised if the table does not exist.
</p>
<p>An error is raised if <code>row.names</code> is <code>TRUE</code> and no &quot;row_names&quot; column exists,
</p>
<p>An error is raised if <code>row.names</code> is set to a string and no corresponding column exists.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is raised
if <code>name</code> cannot be processed with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>
or if this results in a non-scalar.
Unsupported values for <code>row.names</code> and <code>check.names</code>
(non-scalars,
unsupported data types,
<code>NA</code> for <code>check.names</code>)
also raise an error.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbReadTable()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>row.names</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>check.names</code>
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Value&quot; section for details on their usage.
</p>


<h3>Specification</h3>

<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>

<ul>
<li><p> If an unquoted table name as string: <code>dbReadTable()</code> will do the
quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li><p> If the result of a call to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>: no more quoting is done
</p>
</li></ul>



<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars[1:10, ])
dbReadTable(con, "mtcars")

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbReadTableArrow'>Read database tables as Arrow objects</h2><span id='topic+dbReadTableArrow'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Reads a database table as an Arrow object.
Use <code><a href="#topic+dbReadTable">dbReadTable()</a></code> instead to obtain a data frame.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbReadTableArrow(conn, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbReadTableArrow_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbReadTableArrow_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbReadTableArrow_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns an Arrow object.
Convert it to a data frame with <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code> or
use <code><a href="#topic+dbReadTable">dbReadTable()</a></code> to obtain a data frame.
</p>


<h3>Value</h3>

<p><code>dbReadTableArrow()</code> returns an Arrow object that contains the complete data
from the remote table, effectively the result of calling <code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow()</a></code> with
<code style="white-space: pre;">&#8288;SELECT * FROM &lt;name&gt;&#8288;</code>.
</p>
<p>An empty table is returned as an Arrow object with zero rows.
</p>


<h3>Failure modes</h3>

<p>An error is raised if the table does not exist.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is raised
if <code>name</code> cannot be processed with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> or
if this results in a non-scalar.
</p>


<h3>Specification</h3>

<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>

<ul>
<li><p> If an unquoted table name as string: <code>dbReadTableArrow()</code> will do the
quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li><p> If the result of a call to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>: no more quoting is done
</p>
</li></ul>



<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read data as Arrow table
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars[1:10, ])
dbReadTableArrow(con, "mtcars")

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbRemoveTable'>Remove a table from the database</h2><span id='topic+dbRemoveTable'></span>

<h3>Description</h3>

<p>Remove a remote table (e.g., created by <code><a href="#topic+dbWriteTable">dbWriteTable()</a></code>)
from the database.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbRemoveTable(conn, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbRemoveTable_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbRemoveTable_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbRemoveTable_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbRemoveTable()</code> returns <code>TRUE</code>, invisibly.
</p>


<h3>Failure modes</h3>

<p>If the table does not exist, an error is raised.
An attempt to remove a view with this function may result in an error.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> or
if this results in a non-scalar.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbRemoveTable()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>temporary</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>fail_if_missing</code> (default: <code>TRUE</code>)
</p>
</li></ul>

<p>These arguments must be provided as named arguments.
</p>
<p>If <code>temporary</code> is <code>TRUE</code>, the call to <code>dbRemoveTable()</code>
will consider only temporary tables.
Not all backends support this argument.
In particular, permanent tables of the same name are left untouched.
</p>
<p>If <code>fail_if_missing</code> is <code>FALSE</code>, the call to <code>dbRemoveTable()</code>
succeeds if the table does not exist.
</p>


<h3>Specification</h3>

<p>A table removed by <code>dbRemoveTable()</code> doesn't appear in the list of tables
returned by <code><a href="#topic+dbListTables">dbListTables()</a></code>,
and <code><a href="#topic+dbExistsTable">dbExistsTable()</a></code> returns <code>FALSE</code>.
The removal propagates immediately to other connections to the same database.
This function can also be used to remove a temporary table.
</p>
<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>

<ul>
<li><p> If an unquoted table name as string: <code>dbRemoveTable()</code> will do the
quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li><p> If the result of a call to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>: no more quoting is done
</p>
</li></ul>



<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbExistsTable(con, "iris")
dbWriteTable(con, "iris", iris)
dbExistsTable(con, "iris")
dbRemoveTable(con, "iris")
dbExistsTable(con, "iris")

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbSendQuery'>Execute a query on a given database connection</h2><span id='topic+dbSendQuery'></span>

<h3>Description</h3>

<p>The <code>dbSendQuery()</code> method only submits and synchronously executes the
SQL query to the database engine.  It does <em>not</em> extract any
records &mdash; for that you need to use the <code><a href="#topic+dbFetch">dbFetch()</a></code> method, and
then you must call <code><a href="#topic+dbClearResult">dbClearResult()</a></code> when you finish fetching the
records you need.
For interactive use, you should almost always prefer <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>.
Use <code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code> or <code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow()</a></code> instead to retrieve the results
as an Arrow object.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbSendQuery(conn, statement, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbSendQuery_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbSendQuery_+3A_statement">statement</code></td>
<td>
<p>a character string containing SQL.</p>
</td></tr>
<tr><td><code id="dbSendQuery_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is for <code>SELECT</code> queries only.  Some backends may
support data manipulation queries through this method for compatibility
reasons.  However, callers are strongly encouraged to use
<code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> for data manipulation statements.
</p>
<p>The query is submitted to the database server and the DBMS executes it,
possibly generating vast amounts of data. Where these data live
is driver-specific: some drivers may choose to leave the output on the server
and transfer them piecemeal to R, others may transfer all the data to the
client &ndash; but not necessarily to the memory that R manages. See individual
drivers' <code>dbSendQuery()</code> documentation for details.
</p>


<h3>Value</h3>

<p><code>dbSendQuery()</code> returns
an S4 object that inherits from <a href="#topic+DBIResult-class">DBIResult</a>.
The result set can be used with <code><a href="#topic+dbFetch">dbFetch()</a></code> to extract records.
Once you have finished using a result, make sure to clear it
with <code><a href="#topic+dbClearResult">dbClearResult()</a></code>.
</p>


<h3>The data retrieval flow</h3>

<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as data frames.
</p>
<p>Most of this flow, except repeated calling of <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>,
is implemented by <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>, which should be sufficient
unless you want to access the results in a paged way
or you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> to create a result set object of class
<a href="#topic+DBIResult-class">DBIResult</a>.
</p>
</li>
<li><p> Optionally, bind query parameters with <code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Optionally, use <code><a href="#topic+dbColumnInfo">dbColumnInfo()</a></code> to retrieve the structure of the result set
without retrieving actual data.
</p>
</li>
<li><p> Use <code><a href="#topic+dbFetch">dbFetch()</a></code> to get the entire result set, a page of results,
or the remaining rows.
Fetching zero rows is also possible to retrieve the structure of the result set
as a data frame.
This step can be called multiple times.
Only forward paging is supported, you need to cache previous pages
if you need to navigate backwards.
</p>
</li>
<li><p> Use <code><a href="#topic+dbHasCompleted">dbHasCompleted()</a></code> to tell when you're done.
This method returns <code>TRUE</code> if no more rows are available for fetching.
</p>
</li>
<li><p> Repeat the last four steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>An error is raised when issuing a query over a closed
or invalid connection,
or if the query is not a non-<code>NA</code> string.
An error is also raised if the syntax of the query is invalid
and all query parameters are given (by passing the <code>params</code> argument)
or the <code>immediate</code> argument is set to <code>TRUE</code>.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbSendQuery()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>params</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>immediate</code> (default: <code>NULL</code>)
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Specification&quot; sections for details on their usage.
</p>


<h3>Specification</h3>

<p>No warnings occur under normal conditions.
When done, the DBIResult object must be cleared with a call to
<code><a href="#topic+dbClearResult">dbClearResult()</a></code>.
Failure to clear the result set leads to a warning
when the connection is closed.
</p>
<p>If the backend supports only one open result set per connection,
issuing a second query invalidates an already open result set
and raises a warning.
The newly opened result set is valid
and must be cleared with <code>dbClearResult()</code>.
</p>
<p>The <code>param</code> argument allows passing query parameters, see <code><a href="#topic+dbBind">dbBind()</a></code> for details.
</p>


<h3>Specification for the <code>immediate</code> argument</h3>

<p>The <code>immediate</code> argument supports distinguishing between &quot;direct&quot;
and &quot;prepared&quot; APIs offered by many database drivers.
Passing <code>immediate = TRUE</code> leads to immediate execution of the
query or statement, via the &quot;direct&quot; API (if supported by the driver).
The default <code>NULL</code> means that the backend should choose whatever API
makes the most sense for the database, and (if relevant) tries the
other API if the first attempt fails. A successful second attempt
should result in a message that suggests passing the correct
<code>immediate</code> argument.
Examples for possible behaviors:
</p>

<ol>
<li><p> DBI backend defaults to <code>immediate = TRUE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed: query is executed
</p>
</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: rejected immediately by the database
because of a syntax error in the query, the backend tries
<code>immediate = FALSE</code> (and gives a message)
</p>
</li>
<li> <p><code>params</code> given: query is executed using <code>immediate = FALSE</code>
</p>
</li></ol>

</li></ol>

</li>
<li><p> DBI backend defaults to <code>immediate = FALSE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed:
</p>

<ol>
<li><p> simple query: query is executed
</p>
</li>
<li><p> &quot;special&quot; query (such as setting a config options): fails,
the backend tries <code>immediate = TRUE</code> (and gives a message)
</p>
</li></ol>

</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: waiting for parameters via <code><a href="#topic+dbBind">dbBind()</a></code>
</p>
</li>
<li> <p><code>params</code> given: query is executed
</p>
</li></ol>

</li></ol>

</li></ol>



<h3>See Also</h3>

<p>For updates: <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> and <code><a href="#topic+dbExecute">dbExecute()</a></code>.
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>
<p>Other data retrieval generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetch(rs)
dbClearResult(rs)

# Pass one set of values with the param argument:
rs &lt;- dbSendQuery(
  con,
  "SELECT * FROM mtcars WHERE cyl = ?",
  params = list(4L)
)
dbFetch(rs)
dbClearResult(rs)

# Pass multiple sets of values with dbBind():
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = ?")
dbBind(rs, list(6L))
dbFetch(rs)
dbBind(rs, list(8L))
dbFetch(rs)
dbClearResult(rs)

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbSendQueryArrow'>Execute a query on a given database connection for retrieval via Arrow</h2><span id='topic+dbSendQueryArrow'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The <code>dbSendQueryArrow()</code> method only submits and synchronously executes the
SQL query to the database engine.
It does <em>not</em> extract any
records &mdash; for that you need to use the <code><a href="#topic+dbFetchArrow">dbFetchArrow()</a></code> method, and
then you must call <code><a href="#topic+dbClearResult">dbClearResult()</a></code> when you finish fetching the
records you need.
For interactive use, you should almost always prefer <code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow()</a></code>.
Use <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> or <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code> instead to retrieve the results
as a data frame.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbSendQueryArrow(conn, statement, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbSendQueryArrow_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbSendQueryArrow_+3A_statement">statement</code></td>
<td>
<p>a character string containing SQL.</p>
</td></tr>
<tr><td><code id="dbSendQueryArrow_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is for <code>SELECT</code> queries only.  Some backends may
support data manipulation queries through this method for compatibility
reasons.  However, callers are strongly encouraged to use
<code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> for data manipulation statements.
</p>


<h3>Value</h3>

<p><code>dbSendQueryArrow()</code> returns
an S4 object that inherits from <a href="#topic+DBIResultArrow-class">DBIResultArrow</a>.
The result set can be used with <code><a href="#topic+dbFetchArrow">dbFetchArrow()</a></code> to extract records.
Once you have finished using a result, make sure to clear it
with <code><a href="#topic+dbClearResult">dbClearResult()</a></code>.
</p>


<h3>The data retrieval flow for Arrow streams</h3>

<p>This section gives a complete overview over the flow
for the execution of queries that return tabular data as an Arrow stream.
</p>
<p>Most of this flow, except repeated calling of <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code> or <code><a href="#topic+dbBind">dbBind()</a></code>,
is implemented by <code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow()</a></code>,
which should be sufficient
unless you have a parameterized query that you want to reuse.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow()</a></code> to create a result set object of class
<a href="#topic+DBIResultArrow-class">DBIResultArrow</a>.
</p>
</li>
<li><p> Optionally, bind query parameters with <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code> or <code><a href="#topic+dbBind">dbBind()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Use <code><a href="#topic+dbFetchArrow">dbFetchArrow()</a></code> to get a data stream.
</p>
</li>
<li><p> Repeat the last two steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>An error is raised when issuing a query over a closed
or invalid connection,
or if the query is not a non-<code>NA</code> string.
An error is also raised if the syntax of the query is invalid
and all query parameters are given (by passing the <code>params</code> argument)
or the <code>immediate</code> argument is set to <code>TRUE</code>.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbSendQueryArrow()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>params</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>immediate</code> (default: <code>NULL</code>)
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Specification&quot; sections for details on their usage.
</p>


<h3>Specification</h3>

<p>No warnings occur under normal conditions.
When done, the DBIResult object must be cleared with a call to
<code><a href="#topic+dbClearResult">dbClearResult()</a></code>.
Failure to clear the result set leads to a warning
when the connection is closed.
</p>
<p>If the backend supports only one open result set per connection,
issuing a second query invalidates an already open result set
and raises a warning.
The newly opened result set is valid
and must be cleared with <code>dbClearResult()</code>.
</p>
<p>The <code>param</code> argument allows passing query parameters, see <code><a href="#topic+dbBind">dbBind()</a></code> for details.
</p>


<h3>Specification for the <code>immediate</code> argument</h3>

<p>The <code>immediate</code> argument supports distinguishing between &quot;direct&quot;
and &quot;prepared&quot; APIs offered by many database drivers.
Passing <code>immediate = TRUE</code> leads to immediate execution of the
query or statement, via the &quot;direct&quot; API (if supported by the driver).
The default <code>NULL</code> means that the backend should choose whatever API
makes the most sense for the database, and (if relevant) tries the
other API if the first attempt fails. A successful second attempt
should result in a message that suggests passing the correct
<code>immediate</code> argument.
Examples for possible behaviors:
</p>

<ol>
<li><p> DBI backend defaults to <code>immediate = TRUE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed: query is executed
</p>
</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: rejected immediately by the database
because of a syntax error in the query, the backend tries
<code>immediate = FALSE</code> (and gives a message)
</p>
</li>
<li> <p><code>params</code> given: query is executed using <code>immediate = FALSE</code>
</p>
</li></ol>

</li></ol>

</li>
<li><p> DBI backend defaults to <code>immediate = FALSE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed:
</p>

<ol>
<li><p> simple query: query is executed
</p>
</li>
<li><p> &quot;special&quot; query (such as setting a config options): fails,
the backend tries <code>immediate = TRUE</code> (and gives a message)
</p>
</li></ol>

</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: waiting for parameters via <code><a href="#topic+dbBind">dbBind()</a></code>
</p>
</li>
<li> <p><code>params</code> given: query is executed
</p>
</li></ol>

</li></ol>

</li></ol>



<h3>See Also</h3>

<p>For updates: <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> and <code><a href="#topic+dbExecute">dbExecute()</a></code>.
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>
<p>Other data retrieval generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbFetch">dbFetch</a>()</code>,
<code><a href="#topic+dbFetchArrow">dbFetchArrow</a>()</code>,
<code><a href="#topic+dbFetchArrowChunk">dbFetchArrowChunk</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbHasCompleted">dbHasCompleted</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Retrieve data as arrow table
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQueryArrow(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetchArrow(rs)
dbClearResult(rs)

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbSendStatement'>Execute a data manipulation statement on a given database connection</h2><span id='topic+dbSendStatement'></span>

<h3>Description</h3>

<p>The <code>dbSendStatement()</code> method only submits and synchronously executes the
SQL data manipulation statement (e.g., <code>UPDATE</code>, <code>DELETE</code>,
<code style="white-space: pre;">&#8288;INSERT INTO&#8288;</code>, <code style="white-space: pre;">&#8288;DROP TABLE&#8288;</code>, ...) to the database engine.  To query
the number of affected rows, call <code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code> on the
returned result object.  You must also call <code><a href="#topic+dbClearResult">dbClearResult()</a></code> after
that. For interactive use, you should almost always prefer
<code><a href="#topic+dbExecute">dbExecute()</a></code>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbSendStatement(conn, statement, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbSendStatement_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbSendStatement_+3A_statement">statement</code></td>
<td>
<p>a character string containing SQL.</p>
</td></tr>
<tr><td><code id="dbSendStatement_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> comes with a default implementation that simply
forwards to <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code>, to support backends that only
implement the latter.
</p>


<h3>Value</h3>

<p><code>dbSendStatement()</code> returns
an S4 object that inherits from <a href="#topic+DBIResult-class">DBIResult</a>.
The result set can be used with <code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code> to
determine the number of rows affected by the query.
Once you have finished using a result, make sure to clear it
with <code><a href="#topic+dbClearResult">dbClearResult()</a></code>.
</p>


<h3>The command execution flow</h3>

<p>This section gives a complete overview over the flow
for the execution of SQL statements that have side effects
such as stored procedures, inserting or deleting data,
or setting database or connection options.
Most of this flow, except repeated calling of <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>,
is implemented by <code><a href="#topic+dbExecute">dbExecute()</a></code>, which should be sufficient
for non-parameterized queries.
This flow requires an active connection established by <code><a href="#topic+dbConnect">dbConnect()</a></code>.
See also <code>vignette("dbi-advanced")</code> for a walkthrough.
</p>

<ol>
<li><p> Use <code><a href="#topic+dbSendStatement">dbSendStatement()</a></code> to create a result set object of class
<a href="#topic+DBIResult-class">DBIResult</a>.
For some queries you need to pass <code>immediate = TRUE</code>.
</p>
</li>
<li><p> Optionally, bind query parameters with<code><a href="#topic+dbBind">dbBind()</a></code> or <code><a href="#topic+dbBindArrow">dbBindArrow()</a></code>.
This is required only if the query contains placeholders
such as <code style="white-space: pre;">&#8288;?&#8288;</code> or <code style="white-space: pre;">&#8288;$1&#8288;</code>, depending on the database backend.
</p>
</li>
<li><p> Optionally, use <code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected()</a></code> to retrieve the number
of rows affected by the query.
</p>
</li>
<li><p> Repeat the last two steps as necessary.
</p>
</li>
<li><p> Use <code><a href="#topic+dbClearResult">dbClearResult()</a></code> to clean up the result set object.
This step is mandatory even if no rows have been fetched
or if an error has occurred during the processing.
It is good practice to use <code><a href="base.html#topic+on.exit">on.exit()</a></code> or <code><a href="withr.html#topic+defer">withr::defer()</a></code>
to ensure that this step is always executed.
</p>
</li></ol>



<h3>Failure modes</h3>

<p>An error is raised when issuing a statement over a closed
or invalid connection,
or if the statement is not a non-<code>NA</code> string.
An error is also raised if the syntax of the query is invalid
and all query parameters are given (by passing the <code>params</code> argument)
or the <code>immediate</code> argument is set to <code>TRUE</code>.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbSendStatement()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>params</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>immediate</code> (default: <code>NULL</code>)
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Specification&quot; sections for details on their usage.
</p>


<h3>Specification</h3>

<p>No warnings occur under normal conditions.
When done, the DBIResult object must be cleared with a call to
<code><a href="#topic+dbClearResult">dbClearResult()</a></code>.
Failure to clear the result set leads to a warning
when the connection is closed.
If the backend supports only one open result set per connection,
issuing a second query invalidates an already open result set
and raises a warning.
The newly opened result set is valid
and must be cleared with <code>dbClearResult()</code>.
</p>
<p>The <code>param</code> argument allows passing query parameters, see <code><a href="#topic+dbBind">dbBind()</a></code> for details.
</p>


<h3>Specification for the <code>immediate</code> argument</h3>

<p>The <code>immediate</code> argument supports distinguishing between &quot;direct&quot;
and &quot;prepared&quot; APIs offered by many database drivers.
Passing <code>immediate = TRUE</code> leads to immediate execution of the
query or statement, via the &quot;direct&quot; API (if supported by the driver).
The default <code>NULL</code> means that the backend should choose whatever API
makes the most sense for the database, and (if relevant) tries the
other API if the first attempt fails. A successful second attempt
should result in a message that suggests passing the correct
<code>immediate</code> argument.
Examples for possible behaviors:
</p>

<ol>
<li><p> DBI backend defaults to <code>immediate = TRUE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed: query is executed
</p>
</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: rejected immediately by the database
because of a syntax error in the query, the backend tries
<code>immediate = FALSE</code> (and gives a message)
</p>
</li>
<li> <p><code>params</code> given: query is executed using <code>immediate = FALSE</code>
</p>
</li></ol>

</li></ol>

</li>
<li><p> DBI backend defaults to <code>immediate = FALSE</code> internally
</p>

<ol>
<li><p> A query without parameters is passed:
</p>

<ol>
<li><p> simple query: query is executed
</p>
</li>
<li><p> &quot;special&quot; query (such as setting a config options): fails,
the backend tries <code>immediate = TRUE</code> (and gives a message)
</p>
</li></ol>

</li>
<li><p> A query with parameters is passed:
</p>

<ol>
<li> <p><code>params</code> not given: waiting for parameters via <code><a href="#topic+dbBind">dbBind()</a></code>
</p>
</li>
<li> <p><code>params</code> given: query is executed
</p>
</li></ol>

</li></ol>

</li></ol>



<h3>See Also</h3>

<p>For queries: <code><a href="#topic+dbSendQuery">dbSendQuery()</a></code> and <code><a href="#topic+dbGetQuery">dbGetQuery()</a></code>.
</p>
<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>
<p>Other command execution generics: 
<code><a href="#topic+dbBind">dbBind</a>()</code>,
<code><a href="#topic+dbClearResult">dbClearResult</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbGetRowsAffected">dbGetRowsAffected</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cars", head(cars, 3))

rs &lt;- dbSendStatement(
  con,
  "INSERT INTO cars (speed, dist) VALUES (1, 1), (2, 2), (3, 3)"
)
dbHasCompleted(rs)
dbGetRowsAffected(rs)
dbClearResult(rs)
dbReadTable(con, "cars")   # there are now 6 rows

# Pass one set of values directly using the param argument:
rs &lt;- dbSendStatement(
  con,
  "INSERT INTO cars (speed, dist) VALUES (?, ?)",
  params = list(4L, 5L)
)
dbClearResult(rs)

# Pass multiple sets of values using dbBind():
rs &lt;- dbSendStatement(
  con,
  "INSERT INTO cars (speed, dist) VALUES (?, ?)"
)
dbBind(rs, list(5:6, 6:7))
dbBind(rs, list(7L, 8L))
dbClearResult(rs)
dbReadTable(con, "cars")   # there are now 10 rows

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbSetDataMappings'>Set data mappings between an DBMS and R.</h2><span id='topic+dbSetDataMappings'></span>

<h3>Description</h3>

<p>This generic is deprecated since no working implementation was ever produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbSetDataMappings(res, flds, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbSetDataMappings_+3A_res">res</code></td>
<td>
<p>An object inheriting from <a href="#topic+DBIResult-class">DBIResult</a>.</p>
</td></tr>
<tr><td><code id="dbSetDataMappings_+3A_flds">flds</code></td>
<td>
<p>a field description object as returned by <code>dbColumnInfo</code>.</p>
</td></tr>
<tr><td><code id="dbSetDataMappings_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets one or more conversion functions to handle the translation of DBMS data
types to R objects.  This is only needed for non-primitive data, since all
DBI drivers handle the common base types (integers, numeric, strings, etc.)
</p>
<p>The details on conversion functions (e.g., arguments, whether they can invoke
initializers and/or destructors) have not been specified.
</p>

<hr>
<h2 id='dbUnquoteIdentifier'>Unquote identifiers</h2><span id='topic+dbUnquoteIdentifier'></span>

<h3>Description</h3>

<p>Call this method to convert a <a href="#topic+SQL">SQL</a> object created by <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>
back to a list of <a href="#topic+Id">Id</a> objects.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbUnquoteIdentifier(conn, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbUnquoteIdentifier_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbUnquoteIdentifier_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+SQL">SQL</a> or <a href="#topic+Id">Id</a> object.</p>
</td></tr>
<tr><td><code id="dbUnquoteIdentifier_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbUnquoteIdentifier()</code> returns a list of objects
of the same length as the input.
For an empty vector, this function returns a length-0 object.
The names of the input argument are preserved in the output.
If <code>x</code> is a value returned by <code>dbUnquoteIdentifier()</code>,
calling <code>dbUnquoteIdentifier(..., dbQuoteIdentifier(..., x))</code>
returns <code>list(x)</code>.
If <code>x</code> is an object of class <a href="#topic+Id">Id</a>,
calling <code>dbUnquoteIdentifier(..., x)</code> returns <code>list(x)</code>.
(For backends it may be most convenient to return <a href="#topic+Id">Id</a> objects
to achieve this behavior, but this is not required.)
</p>
<p>Plain character vectors can also be passed to <code>dbUnquoteIdentifier()</code>.
</p>


<h3>Failure modes</h3>

<p>An error is raised if a character vectors with a missing value is passed
as the <code>x</code> argument.
</p>


<h3>Specification</h3>

<p>For any character vector of length one, quoting (with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>)
then unquoting then quoting the first element is identical to just quoting.
This is also true for strings that
contain special characters such as a space,
a dot,
a comma,
or quotes used to mark strings
or identifiers,
if the database supports this.
</p>
<p>Unquoting simple strings (consisting of only letters) wrapped with <code><a href="#topic+SQL">SQL()</a></code> and
then quoting via <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> gives the same result as just
quoting the string.
Similarly, unquoting expressions of the form <code>SQL("schema.table")</code>
and then quoting gives the same result as quoting the identifier
constructed by <code>Id("schema", "table")</code>.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unquoting allows to understand the structure of a
# possibly complex quoted identifier
dbUnquoteIdentifier(
  ANSI(),
  SQL(c('"Catalog"."Schema"."Table"', '"Schema"."Table"', '"UnqualifiedTable"'))
)

# The returned object is always a list,
# also for Id objects
dbUnquoteIdentifier(ANSI(), Id("Catalog", "Schema", "Table"))

# Quoting and unquoting are inverses
dbQuoteIdentifier(
  ANSI(),
  dbUnquoteIdentifier(ANSI(), SQL("UnqualifiedTable"))[[1]]
)

dbQuoteIdentifier(
  ANSI(),
  dbUnquoteIdentifier(ANSI(), Id("Schema", "Table"))[[1]]
)
</code></pre>

<hr>
<h2 id='dbWithTransaction'>Self-contained SQL transactions</h2><span id='topic+dbWithTransaction'></span><span id='topic+dbBreak'></span>

<h3>Description</h3>

<p>Given that <a href="#topic+transactions">transactions</a> are implemented, this function
allows you to pass in code that is run in a transaction.
The default method of <code>dbWithTransaction()</code> calls <code><a href="#topic+dbBegin">dbBegin()</a></code>
before executing the code,
and <code><a href="#topic+dbCommit">dbCommit()</a></code> after successful completion,
or <code><a href="#topic+dbRollback">dbRollback()</a></code> in case of an error.
The advantage is
that you don't have to remember to do <code>dbBegin()</code> and <code>dbCommit()</code> or
<code>dbRollback()</code> &ndash; that is all taken care of.
The special function <code>dbBreak()</code> allows an early exit with rollback,
it can be called only inside <code>dbWithTransaction()</code>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbWithTransaction(conn, code, ...)

dbBreak()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbWithTransaction_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbWithTransaction_+3A_code">code</code></td>
<td>
<p>An arbitrary block of R code.</p>
</td></tr>
<tr><td><code id="dbWithTransaction_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DBI implements <code>dbWithTransaction()</code>, backends should need to override this
generic only if they implement specialized handling.
</p>


<h3>Value</h3>

<p><code>dbWithTransaction()</code> returns the value of the executed code.
</p>


<h3>Failure modes</h3>

<p>Failure to initiate the transaction
(e.g., if the connection is closed
or invalid
of if <code><a href="#topic+dbBegin">dbBegin()</a></code> has been called already)
gives an error.
</p>


<h3>Specification</h3>

<p><code>dbWithTransaction()</code> initiates a transaction with <code>dbBegin()</code>, executes
the code given in the <code>code</code> argument, and commits the transaction with
<code><a href="#topic+dbCommit">dbCommit()</a></code>.
If the code raises an error, the transaction is instead aborted with
<code><a href="#topic+dbRollback">dbRollback()</a></code>, and the error is propagated.
If the code calls <code>dbBreak()</code>, execution of the code stops and the
transaction is silently aborted.
All side effects caused by the code
(such as the creation of new variables)
propagate to the calling environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cash", data.frame(amount = 100))
dbWriteTable(con, "account", data.frame(amount = 2000))

# All operations are carried out as logical unit:
dbWithTransaction(
  con,
  {
    withdrawal &lt;- 300
    dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
    dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
  }
)

# The code is executed as if in the current environment:
withdrawal

# The changes are committed to the database after successful execution:
dbReadTable(con, "cash")
dbReadTable(con, "account")

# Rolling back with dbBreak():
dbWithTransaction(
  con,
  {
    withdrawal &lt;- 5000
    dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
    dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
    if (dbReadTable(con, "account")$amount &lt; 0) {
      dbBreak()
    }
  }
)

# These changes were not committed to the database:
dbReadTable(con, "cash")
dbReadTable(con, "account")

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dbWriteTable'>Copy data frames to database tables</h2><span id='topic+dbWriteTable'></span>

<h3>Description</h3>

<p>Writes, overwrites or appends a data frame to a database table, optionally
converting row names to a column and specifying SQL data types for fields.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbWriteTable(conn, name, value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbWriteTable_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbWriteTable_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbWriteTable_+3A_value">value</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> (or coercible to data.frame).</p>
</td></tr>
<tr><td><code id="dbWriteTable_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function expects a data frame.
Use <code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow()</a></code> to write an Arrow object.
</p>
<p>This function is useful if you want to create and load a table at the same time.
Use <code><a href="#topic+dbAppendTable">dbAppendTable()</a></code> or <code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow()</a></code> for appending data to an existing
table, <code><a href="#topic+dbCreateTable">dbCreateTable()</a></code> or <code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow()</a></code> for creating a table,
and <code><a href="#topic+dbExistsTable">dbExistsTable()</a></code> and <code><a href="#topic+dbRemoveTable">dbRemoveTable()</a></code> for overwriting tables.
</p>
<p>DBI only standardizes writing data frames with <code>dbWriteTable()</code>.
Some backends might implement methods that can consume CSV files
or other data formats.
For details, see the documentation for the individual methods.
</p>


<h3>Value</h3>

<p><code>dbWriteTable()</code> returns <code>TRUE</code>, invisibly.
</p>


<h3>Failure modes</h3>

<p>If the table exists, and both <code>append</code> and <code>overwrite</code> arguments are unset,
or <code>append = TRUE</code> and the data frame with the new data has different
column names,
an error is raised; the remote table remains unchanged.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> or
if this results in a non-scalar.
Invalid values for the additional arguments <code>row.names</code>,
<code>overwrite</code>, <code>append</code>, <code>field.types</code>, and <code>temporary</code>
(non-scalars,
unsupported data types,
<code>NA</code>,
incompatible values,
duplicate
or missing names,
incompatible columns)
also raise an error.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbWriteTable()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>row.names</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>overwrite</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>append</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>field.types</code> (default: <code>NULL</code>)
</p>
</li>
<li> <p><code>temporary</code> (default: <code>FALSE</code>)
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Specification&quot; and &quot;Value&quot; sections for details on their usage.
</p>


<h3>Specification</h3>

<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>

<ul>
<li><p> If an unquoted table name as string: <code>dbWriteTable()</code> will do the quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li><p> If the result of a call to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>: no more quoting is done
</p>
</li></ul>

<p>The <code>value</code> argument must be a data frame
with a subset of the columns of the existing table if <code>append = TRUE</code>.
The order of the columns does not matter with <code>append = TRUE</code>.
</p>
<p>If the <code>overwrite</code> argument is <code>TRUE</code>, an existing table of the same name
will be overwritten.
This argument doesn't change behavior if the table does not exist yet.
</p>
<p>If the <code>append</code> argument is <code>TRUE</code>, the rows in an existing table are
preserved, and the new data are appended.
If the table doesn't exist yet, it is created.
</p>
<p>If the <code>temporary</code> argument is <code>TRUE</code>, the table is not available in a
second connection and is gone after reconnecting.
Not all backends support this argument.
A regular, non-temporary table is visible in a second connection,
in a pre-existing connection,
and after reconnecting to the database.
</p>
<p>SQL keywords can be used freely in table names, column names, and data.
Quotes, commas, spaces, and other special characters such as newlines and tabs,
can also be used in the data,
and, if the database supports non-syntactic identifiers,
also for table names
and column names.
</p>
<p>The following data types must be supported at least,
and be read identically with <code><a href="#topic+dbReadTable">dbReadTable()</a></code>:
</p>

<ul>
<li><p> integer
</p>
</li>
<li><p> numeric
(the behavior for <code>Inf</code> and <code>NaN</code> is not specified)
</p>
</li>
<li><p> logical
</p>
</li>
<li> <p><code>NA</code> as NULL
</p>
</li>
<li><p> 64-bit values (using <code>"bigint"</code> as field type); the result can be
</p>

<ul>
<li><p> converted to a numeric, which may lose precision,
</p>
</li>
<li><p> converted a character vector, which gives the full decimal
representation
</p>
</li>
<li><p> written to another table and read again unchanged
</p>
</li></ul>

</li>
<li><p> character (in both UTF-8
and native encodings),
supporting empty strings
before and after a non-empty string
</p>
</li>
<li><p> factor (returned as character)
</p>
</li>
<li><p> list of raw
(if supported by the database)
</p>
</li>
<li><p> objects of type <a href="blob.html#topic+blob">blob::blob</a>
(if supported by the database)
</p>
</li>
<li><p> date
(if supported by the database;
returned as <code>Date</code>),
also for dates prior to 1970 or 1900 or after 2038
</p>
</li>
<li><p> time
(if supported by the database;
returned as objects that inherit from <code>difftime</code>)
</p>
</li>
<li><p> timestamp
(if supported by the database;
returned as <code>POSIXct</code>
respecting the time zone but not necessarily preserving the
input time zone),
also for timestamps prior to 1970 or 1900 or after 2038
respecting the time zone but not necessarily preserving the
input time zone)
</p>
</li></ul>

<p>Mixing column types in the same table is supported.
</p>
<p>The <code>field.types</code> argument must be a named character vector with at most
one entry for each column.
It indicates the SQL data type to be used for a new column.
If a column is missed from <code>field.types</code>, the type is inferred
from the input data with <code><a href="#topic+dbDataType">dbDataType()</a></code>.
</p>
<p>The interpretation of <a href="#topic+rownames">rownames</a> depends on the <code>row.names</code> argument,
see <code><a href="#topic+sqlRownamesToColumn">sqlRownamesToColumn()</a></code> for details:
</p>

<ul>
<li><p> If <code>FALSE</code> or <code>NULL</code>, row names are ignored.
</p>
</li>
<li><p> If <code>TRUE</code>, row names are converted to a column named &quot;row_names&quot;,
even if the input data frame only has natural row names from 1 to <code>nrow(...)</code>.
</p>
</li>
<li><p> If <code>NA</code>, a column named &quot;row_names&quot; is created if the data has custom row names,
no extra column is created in the case of natural row names.
</p>
</li>
<li><p> If a string, this specifies the name of the column in the remote table
that contains the row names,
even if the input data frame only has natural row names.
</p>
</li></ul>

<p>The default is <code>row.names = FALSE</code>.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTableArrow">dbWriteTableArrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars[1:5, ])
dbReadTable(con, "mtcars")

dbWriteTable(con, "mtcars", mtcars[6:10, ], append = TRUE)
dbReadTable(con, "mtcars")

dbWriteTable(con, "mtcars", mtcars[1:10, ], overwrite = TRUE)
dbReadTable(con, "mtcars")

# No row names
dbWriteTable(con, "mtcars", mtcars[1:10, ], overwrite = TRUE, row.names = FALSE)
dbReadTable(con, "mtcars")

</code></pre>

<hr>
<h2 id='dbWriteTableArrow'>Copy Arrow objects to database tables</h2><span id='topic+dbWriteTableArrow'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Writes, overwrites or appends an Arrow object to a database table.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dbWriteTableArrow(conn, name, value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbWriteTableArrow_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="dbWriteTableArrow_+3A_name">name</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dbWriteTableArrow_+3A_value">value</code></td>
<td>
<p>An nanoarray stream, or an object coercible to a nanoarray stream with
<code><a href="nanoarrow.html#topic+as_nanoarrow_array_stream">nanoarrow::as_nanoarrow_array_stream()</a></code>.</p>
</td></tr>
<tr><td><code id="dbWriteTableArrow_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function expects an Arrow object.
Convert a data frame to an Arrow object with <code><a href="nanoarrow.html#topic+as_nanoarrow_array_stream">nanoarrow::as_nanoarrow_array_stream()</a></code> or
use <code><a href="#topic+dbWriteTable">dbWriteTable()</a></code> to write a data frame.
</p>
<p>This function is useful if you want to create and load a table at the same time.
Use <code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow()</a></code> for appending data to an existing
table, <code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow()</a></code> for creating a table and specifying field types,
and <code><a href="#topic+dbRemoveTable">dbRemoveTable()</a></code> for overwriting tables.
</p>


<h3>Value</h3>

<p><code>dbWriteTableArrow()</code> returns <code>TRUE</code>, invisibly.
</p>


<h3>Failure modes</h3>

<p>If the table exists, and both <code>append</code> and <code>overwrite</code> arguments are unset,
or <code>append = TRUE</code> and the data frame with the new data has different
column names,
an error is raised; the remote table remains unchanged.
</p>
<p>An error is raised when calling this method for a closed
or invalid connection.
An error is also raised
if <code>name</code> cannot be processed with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> or
if this results in a non-scalar.
Invalid values for the additional arguments
<code>overwrite</code>, <code>append</code>, and <code>temporary</code>
(non-scalars,
unsupported data types,
<code>NA</code>,
incompatible values,
incompatible columns)
also raise an error.
</p>


<h3>Additional arguments</h3>

<p>The following arguments are not part of the <code>dbWriteTableArrow()</code> generic
(to improve compatibility across backends)
but are part of the DBI specification:
</p>

<ul>
<li> <p><code>overwrite</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>append</code> (default: <code>FALSE</code>)
</p>
</li>
<li> <p><code>temporary</code> (default: <code>FALSE</code>)
</p>
</li></ul>

<p>They must be provided as named arguments.
See the &quot;Specification&quot; and &quot;Value&quot; sections for details on their usage.
</p>


<h3>Specification</h3>

<p>The <code>name</code> argument is processed as follows,
to support databases that allow non-syntactic names for their objects:
</p>

<ul>
<li><p> If an unquoted table name as string: <code>dbWriteTableArrow()</code> will do the quoting,
perhaps by calling <code>dbQuoteIdentifier(conn, x = name)</code>
</p>
</li>
<li><p> If the result of a call to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>: no more quoting is done
</p>
</li></ul>

<p>The <code>value</code> argument must be a data frame
with a subset of the columns of the existing table if <code>append = TRUE</code>.
The order of the columns does not matter with <code>append = TRUE</code>.
</p>
<p>If the <code>overwrite</code> argument is <code>TRUE</code>, an existing table of the same name
will be overwritten.
This argument doesn't change behavior if the table does not exist yet.
</p>
<p>If the <code>append</code> argument is <code>TRUE</code>, the rows in an existing table are
preserved, and the new data are appended.
If the table doesn't exist yet, it is created.
</p>
<p>If the <code>temporary</code> argument is <code>TRUE</code>, the table is not available in a
second connection and is gone after reconnecting.
Not all backends support this argument.
A regular, non-temporary table is visible in a second connection,
in a pre-existing connection,
and after reconnecting to the database.
</p>
<p>SQL keywords can be used freely in table names, column names, and data.
Quotes, commas, spaces, and other special characters such as newlines and tabs,
can also be used in the data,
and, if the database supports non-syntactic identifiers,
also for table names
and column names.
</p>
<p>The following data types must be supported at least,
and be read identically with <code><a href="#topic+dbReadTable">dbReadTable()</a></code>:
</p>

<ul>
<li><p> integer
</p>
</li>
<li><p> numeric
(the behavior for <code>Inf</code> and <code>NaN</code> is not specified)
</p>
</li>
<li><p> logical
</p>
</li>
<li> <p><code>NA</code> as NULL
</p>
</li>
<li><p> 64-bit values (using <code>"bigint"</code> as field type); the result can be
</p>

<ul>
<li><p> converted to a numeric, which may lose precision,
</p>
</li>
<li><p> converted a character vector, which gives the full decimal
representation
</p>
</li>
<li><p> written to another table and read again unchanged
</p>
</li></ul>

</li>
<li><p> character (in both UTF-8
and native encodings),
supporting empty strings
before and after a non-empty string
</p>
</li>
<li><p> factor (possibly returned as character)
</p>
</li>
<li><p> objects of type <a href="blob.html#topic+blob">blob::blob</a>
(if supported by the database)
</p>
</li>
<li><p> date
(if supported by the database;
returned as <code>Date</code>),
also for dates prior to 1970 or 1900 or after 2038
</p>
</li>
<li><p> time
(if supported by the database;
returned as objects that inherit from <code>difftime</code>)
</p>
</li>
<li><p> timestamp
(if supported by the database;
returned as <code>POSIXct</code>
respecting the time zone but not necessarily preserving the
input time zone),
also for timestamps prior to 1970 or 1900 or after 2038
respecting the time zone but not necessarily preserving the
input time zone)
</p>
</li></ul>

<p>Mixing column types in the same table is supported.
</p>


<h3>See Also</h3>

<p>Other DBIConnection generics: 
<code><a href="#topic+DBIConnection-class">DBIConnection-class</a></code>,
<code><a href="#topic+dbAppendTable">dbAppendTable</a>()</code>,
<code><a href="#topic+dbAppendTableArrow">dbAppendTableArrow</a>()</code>,
<code><a href="#topic+dbCreateTable">dbCreateTable</a>()</code>,
<code><a href="#topic+dbCreateTableArrow">dbCreateTableArrow</a>()</code>,
<code><a href="#topic+dbDataType">dbDataType</a>()</code>,
<code><a href="#topic+dbDisconnect">dbDisconnect</a>()</code>,
<code><a href="#topic+dbExecute">dbExecute</a>()</code>,
<code><a href="#topic+dbExistsTable">dbExistsTable</a>()</code>,
<code><a href="#topic+dbGetException">dbGetException</a>()</code>,
<code><a href="#topic+dbGetInfo">dbGetInfo</a>()</code>,
<code><a href="#topic+dbGetQuery">dbGetQuery</a>()</code>,
<code><a href="#topic+dbGetQueryArrow">dbGetQueryArrow</a>()</code>,
<code><a href="#topic+dbIsReadOnly">dbIsReadOnly</a>()</code>,
<code><a href="#topic+dbIsValid">dbIsValid</a>()</code>,
<code><a href="#topic+dbListFields">dbListFields</a>()</code>,
<code><a href="#topic+dbListObjects">dbListObjects</a>()</code>,
<code><a href="#topic+dbListResults">dbListResults</a>()</code>,
<code><a href="#topic+dbListTables">dbListTables</a>()</code>,
<code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier</a>()</code>,
<code><a href="#topic+dbReadTable">dbReadTable</a>()</code>,
<code><a href="#topic+dbReadTableArrow">dbReadTableArrow</a>()</code>,
<code><a href="#topic+dbRemoveTable">dbRemoveTable</a>()</code>,
<code><a href="#topic+dbSendQuery">dbSendQuery</a>()</code>,
<code><a href="#topic+dbSendQueryArrow">dbSendQueryArrow</a>()</code>,
<code><a href="#topic+dbSendStatement">dbSendStatement</a>()</code>,
<code><a href="#topic+dbUnquoteIdentifier">dbUnquoteIdentifier</a>()</code>,
<code><a href="#topic+dbWriteTable">dbWriteTable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTableArrow(con, "mtcars", nanoarrow::as_nanoarrow_array_stream(mtcars[1:5, ]))
dbReadTable(con, "mtcars")

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='hidden_aliases'>Internal page for hidden aliases</h2><span id='topic+hidden_aliases'></span><span id='topic+SQLKeywords_DBIObject'></span><span id='topic+SQLKeywords+2CDBIObject-method'></span><span id='topic+SQLKeywords_missing'></span><span id='topic+SQLKeywords+2Cmissing-method'></span><span id='topic+dbAppendTableArrow_DBIConnection'></span><span id='topic+dbAppendTableArrow+2CDBIConnection-method'></span><span id='topic+dbAppendTable_DBIConnection'></span><span id='topic+dbAppendTable+2CDBIConnection-method'></span><span id='topic+dbBindArrow_DBIResult'></span><span id='topic+dbBindArrow+2CDBIResult-method'></span><span id='topic+dbBindArrow_DBIResultArrowDefault'></span><span id='topic+dbBindArrow+2CDBIResultArrowDefault-method'></span><span id='topic+dbBind_DBIResultArrow'></span><span id='topic+dbBind+2CDBIResultArrow-method'></span><span id='topic+dbCanConnect_DBIDriver'></span><span id='topic+dbCanConnect+2CDBIDriver-method'></span><span id='topic+dbClearResult_DBIResultArrow'></span><span id='topic+dbClearResult+2CDBIResultArrow-method'></span><span id='topic+dbConnect_DBIConnector'></span><span id='topic+dbConnect+2CDBIConnector-method'></span><span id='topic+dbCreateTableArrow_DBIConnection'></span><span id='topic+dbCreateTableArrow+2CDBIConnection-method'></span><span id='topic+dbCreateTable_DBIConnection'></span><span id='topic+dbCreateTable+2CDBIConnection-method'></span><span id='topic+dbDataType_DBIConnector'></span><span id='topic+dbDataType+2CDBIConnector-method'></span><span id='topic+dbDataType_DBIObject'></span><span id='topic+dbDataType+2CDBIObject-method'></span><span id='topic+dbDriver_character'></span><span id='topic+dbDriver+2Ccharacter-method'></span><span id='topic+dbExecute_DBIConnection_character'></span><span id='topic+dbExecute+2CDBIConnection+2Ccharacter-method'></span><span id='topic+dbExistsTable_DBIConnection_Id'></span><span id='topic+dbExistsTable+2CDBIConnection+2CId-method'></span><span id='topic+dbFetchArrowChunk_DBIResultArrow'></span><span id='topic+dbFetchArrowChunk+2CDBIResultArrow-method'></span><span id='topic+dbFetchArrow_DBIResultArrow'></span><span id='topic+dbFetchArrow+2CDBIResultArrow-method'></span><span id='topic+dbFetch_DBIResult'></span><span id='topic+dbFetch+2CDBIResult-method'></span><span id='topic+dbFetch_DBIResultArrow'></span><span id='topic+dbFetch+2CDBIResultArrow-method'></span><span id='topic+dbGetConnectArgs_DBIConnector'></span><span id='topic+dbGetConnectArgs+2CDBIConnector-method'></span><span id='topic+dbGetInfo_DBIResult'></span><span id='topic+dbGetInfo+2CDBIResult-method'></span><span id='topic+dbGetInfo_DBIResultArrow'></span><span id='topic+dbGetInfo+2CDBIResultArrow-method'></span><span id='topic+dbGetQueryArrow_DBIConnection_character'></span><span id='topic+dbGetQueryArrow+2CDBIConnection-method'></span><span id='topic+dbGetQuery_DBIConnection_character'></span><span id='topic+dbGetQuery+2CDBIConnection+2Ccharacter-method'></span><span id='topic+dbGetRowCount_DBIResultArrow'></span><span id='topic+dbGetRowCount+2CDBIResultArrow-method'></span><span id='topic+dbGetRowsAffected_DBIResultArrow'></span><span id='topic+dbGetRowsAffected+2CDBIResultArrow-method'></span><span id='topic+dbGetStatement_DBIResultArrow'></span><span id='topic+dbGetStatement+2CDBIResultArrow-method'></span><span id='topic+dbHasCompleted_DBIResultArrow'></span><span id='topic+dbHasCompleted+2CDBIResultArrow-method'></span><span id='topic+dbIsReadOnly_DBIConnector'></span><span id='topic+dbIsReadOnly+2CDBIConnector-method'></span><span id='topic+dbIsReadOnly_DBIObject'></span><span id='topic+dbIsReadOnly+2CDBIObject-method'></span><span id='topic+dbIsValid_DBIResultArrowDefault'></span><span id='topic+dbIsValid+2CDBIResultArrowDefault-method'></span><span id='topic+dbListFields_DBIConnection_Id'></span><span id='topic+dbListFields+2CDBIConnection+2CId-method'></span><span id='topic+dbListFields_DBIConnection_character'></span><span id='topic+dbListFields+2CDBIConnection+2Ccharacter-method'></span><span id='topic+dbListObjects_DBIConnection_ANY'></span><span id='topic+dbListObjects+2CDBIConnection-method'></span><span id='topic+dbQuoteIdentifier_DBIConnection'></span><span id='topic+dbQuoteIdentifier+2CDBIConnection+2CANY-method'></span><span id='topic+dbQuoteIdentifier+2CDBIConnection+2Ccharacter-method'></span><span id='topic+dbQuoteIdentifier+2CDBIConnection+2CSQL-method'></span><span id='topic+dbQuoteIdentifier+2CDBIConnection+2CId-method'></span><span id='topic+dbQuoteLiteral_DBIConnection'></span><span id='topic+dbQuoteLiteral+2CDBIConnection-method'></span><span id='topic+dbQuoteString_DBIConnection'></span><span id='topic+dbQuoteString+2CDBIConnection+2CANY-method'></span><span id='topic+dbQuoteString+2CDBIConnection+2Ccharacter-method'></span><span id='topic+dbQuoteString+2CDBIConnection+2CSQL-method'></span><span id='topic+dbReadTableArrow_DBIConnection'></span><span id='topic+dbReadTableArrow+2CDBIConnection-method'></span><span id='topic+dbReadTable_DBIConnection_Id'></span><span id='topic+dbReadTable+2CDBIConnection+2CId-method'></span><span id='topic+dbReadTable_DBIConnection_character'></span><span id='topic+dbReadTable+2CDBIConnection+2Ccharacter-method'></span><span id='topic+dbRemoveTable_DBIConnection_Id'></span><span id='topic+dbRemoveTable+2CDBIConnection+2CId-method'></span><span id='topic+dbSendQueryArrow_DBIConnection'></span><span id='topic+dbSendQueryArrow+2CDBIConnection-method'></span><span id='topic+dbSendStatement_DBIConnection_character'></span><span id='topic+dbSendStatement+2CDBIConnection+2Ccharacter-method'></span><span id='topic+dbUnquoteIdentifier_DBIConnection'></span><span id='topic+dbUnquoteIdentifier+2CDBIConnection-method'></span><span id='topic+dbWithTransaction_DBIConnection'></span><span id='topic+dbWithTransaction+2CDBIConnection-method'></span><span id='topic+dbWriteTableArrow_DBIConnection'></span><span id='topic+dbWriteTableArrow+2CDBIConnection-method'></span><span id='topic+dbWriteTable_DBIConnection_Id_ANY'></span><span id='topic+dbWriteTable+2CDBIConnection+2CId-method'></span><span id='topic+isSQLKeyword_DBIObject_character'></span><span id='topic+isSQLKeyword+2CDBIObject+2Ccharacter-method'></span><span id='topic+make.db.names_DBIObject_character'></span><span id='topic+make.db.names+2CDBIObject+2Ccharacter-method'></span><span id='topic+show_AnsiConnection'></span><span id='topic+show+2CAnsiConnection-method'></span><span id='topic+show_DBIConnection'></span><span id='topic+show+2CDBIConnection-method'></span><span id='topic+show_DBIConnector'></span><span id='topic+show+2CDBIConnector-method'></span><span id='topic+show_DBIDriver'></span><span id='topic+show+2CDBIDriver-method'></span><span id='topic+show_DBIResult'></span><span id='topic+show+2CDBIResult-method'></span><span id='topic+show_Id'></span><span id='topic+show+2CId-method'></span><span id='topic+show_SQL'></span><span id='topic+show+2CSQL-method'></span><span id='topic+sqlAppendTable_DBIConnection'></span><span id='topic+sqlAppendTable+2CDBIConnection-method'></span><span id='topic+sqlCreateTable_DBIConnection'></span><span id='topic+sqlCreateTable+2CDBIConnection-method'></span><span id='topic+sqlData_DBIConnection'></span><span id='topic+sqlData+2CDBIConnection-method'></span><span id='topic+sqlInterpolate_DBIConnection'></span><span id='topic+sqlInterpolate+2CDBIConnection-method'></span><span id='topic+sqlParseVariables_DBIConnection'></span><span id='topic+sqlParseVariables+2CDBIConnection-method'></span>

<h3>Description</h3>

<p>For S4 methods that require a documentation entry but only clutter the index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DBIObject'
SQLKeywords(dbObj, ...)

## S4 method for signature 'missing'
SQLKeywords(dbObj, ...)

## S4 method for signature 'DBIConnection'
dbAppendTableArrow(conn, name, value, ...)

## S4 method for signature 'DBIConnection'
dbAppendTable(conn, name, value, ..., row.names = NULL)

## S4 method for signature 'DBIResult'
dbBindArrow(res, params, ...)

## S4 method for signature 'DBIResultArrowDefault'
dbBindArrow(res, params, ...)

## S4 method for signature 'DBIResultArrow'
dbBind(res, params, ...)

## S4 method for signature 'DBIDriver'
dbCanConnect(drv, ...)

## S4 method for signature 'DBIResultArrow'
dbClearResult(res, ...)

## S4 method for signature 'DBIConnector'
dbConnect(drv, ...)

## S4 method for signature 'DBIConnection'
dbCreateTableArrow(conn, name, value, ..., temporary = FALSE)

## S4 method for signature 'DBIConnection'
dbCreateTable(conn, name, fields, ..., row.names = NULL, temporary = FALSE)

## S4 method for signature 'DBIConnector'
dbDataType(dbObj, obj, ...)

## S4 method for signature 'DBIObject'
dbDataType(dbObj, obj, ...)

## S4 method for signature 'character'
dbDriver(drvName, ...)

## S4 method for signature 'DBIConnection,character'
dbExecute(conn, statement, ...)

## S4 method for signature 'DBIConnection,Id'
dbExistsTable(conn, name, ...)

## S4 method for signature 'DBIResultArrow'
dbFetchArrowChunk(res, ...)

## S4 method for signature 'DBIResultArrow'
dbFetchArrow(res, ...)

## S4 method for signature 'DBIResult'
dbFetch(res, n = -1, ...)

## S4 method for signature 'DBIResultArrow'
dbFetch(res, n = -1, ...)

## S4 method for signature 'DBIConnector'
dbGetConnectArgs(drv, eval = TRUE, ...)

## S4 method for signature 'DBIResult'
dbGetInfo(dbObj, ...)

## S4 method for signature 'DBIResultArrow'
dbGetInfo(dbObj, ...)

## S4 method for signature 'DBIConnection'
dbGetQueryArrow(conn, statement, ...)

## S4 method for signature 'DBIConnection,character'
dbGetQuery(conn, statement, ..., n = -1L)

## S4 method for signature 'DBIResultArrow'
dbGetRowCount(res, ...)

## S4 method for signature 'DBIResultArrow'
dbGetRowsAffected(res, ...)

## S4 method for signature 'DBIResultArrow'
dbGetStatement(res, ...)

## S4 method for signature 'DBIResultArrow'
dbHasCompleted(res, ...)

## S4 method for signature 'DBIConnector'
dbIsReadOnly(dbObj, ...)

## S4 method for signature 'DBIObject'
dbIsReadOnly(dbObj, ...)

## S4 method for signature 'DBIResultArrowDefault'
dbIsValid(dbObj, ...)

## S4 method for signature 'DBIConnection,Id'
dbListFields(conn, name, ...)

## S4 method for signature 'DBIConnection,character'
dbListFields(conn, name, ...)

## S4 method for signature 'DBIConnection'
dbListObjects(conn, prefix = NULL, ...)

## S4 method for signature 'DBIConnection,ANY'
dbQuoteIdentifier(conn, x, ...)

## S4 method for signature 'DBIConnection,character'
dbQuoteIdentifier(conn, x, ...)

## S4 method for signature 'DBIConnection,SQL'
dbQuoteIdentifier(conn, x, ...)

## S4 method for signature 'DBIConnection,Id'
dbQuoteIdentifier(conn, x, ...)

## S4 method for signature 'DBIConnection'
dbQuoteLiteral(conn, x, ...)

## S4 method for signature 'DBIConnection,ANY'
dbQuoteString(conn, x, ...)

## S4 method for signature 'DBIConnection,character'
dbQuoteString(conn, x, ...)

## S4 method for signature 'DBIConnection,SQL'
dbQuoteString(conn, x, ...)

## S4 method for signature 'DBIConnection'
dbReadTableArrow(conn, name, ...)

## S4 method for signature 'DBIConnection,Id'
dbReadTable(conn, name, ...)

## S4 method for signature 'DBIConnection,character'
dbReadTable(conn, name, ..., row.names = FALSE, check.names = TRUE)

## S4 method for signature 'DBIConnection,Id'
dbRemoveTable(conn, name, ...)

## S4 method for signature 'DBIConnection'
dbSendQueryArrow(conn, statement, params = NULL, ...)

## S4 method for signature 'DBIConnection,character'
dbSendStatement(conn, statement, ...)

## S4 method for signature 'DBIConnection'
dbUnquoteIdentifier(conn, x, ...)

## S4 method for signature 'DBIConnection'
dbWithTransaction(conn, code)

## S4 method for signature 'DBIConnection'
dbWriteTableArrow(
  conn,
  name,
  value,
  append = FALSE,
  overwrite = FALSE,
  ...,
  temporary = FALSE
)

## S4 method for signature 'DBIConnection,Id'
dbWriteTable(conn, name, value, ...)

## S4 method for signature 'DBIObject,character'
isSQLKeyword(
  dbObj,
  name,
  keywords = .SQL92Keywords,
  case = c("lower", "upper", "any")[3],
  ...
)

## S4 method for signature 'DBIObject,character'
make.db.names(
  dbObj,
  snames,
  keywords = .SQL92Keywords,
  unique = TRUE,
  allow.keywords = TRUE,
  ...
)

## S4 method for signature 'AnsiConnection'
show(object)

## S4 method for signature 'DBIConnection'
show(object)

## S4 method for signature 'DBIConnector'
show(object)

## S4 method for signature 'DBIDriver'
show(object)

## S4 method for signature 'DBIResult'
show(object)

## S4 method for signature 'Id'
show(object)

## S4 method for signature 'SQL'
show(object)

## S4 method for signature 'DBIConnection'
sqlAppendTable(con, table, values, row.names = NA, ...)

## S4 method for signature 'DBIConnection'
sqlCreateTable(con, table, fields, row.names = NA, temporary = FALSE, ...)

## S4 method for signature 'DBIConnection'
sqlData(con, value, row.names = NA, ...)

## S4 method for signature 'DBIConnection'
sqlInterpolate(conn, sql, ..., .dots = list())

## S4 method for signature 'DBIConnection'
sqlParseVariables(conn, sql, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidden_aliases_+3A_n">n</code></td>
<td>
<p>Number of rows to fetch, default -1</p>
</td></tr>
<tr><td><code id="hidden_aliases_+3A_object">object</code></td>
<td>
<p>Table object to print</p>
</td></tr>
</table>

<hr>
<h2 id='Id-class'>Refer to a table nested in a hierarchy (e.g. within a schema)</h2><span id='topic+Id-class'></span><span id='topic+Id'></span>

<h3>Description</h3>

<p>Objects of class <code>Id</code> have a single slot <code>name</code>, which is a character vector.
The <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> method converts <code>Id</code> objects to strings.
Support for <code>Id</code> objects depends on the database backend.
</p>
<p>They can be used in the following methods as <code>name</code> or <code>table</code> argument:
</p>

<ul>
<li> <p><code><a href="#topic+dbCreateTable">dbCreateTable()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dbAppendTable">dbAppendTable()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dbReadTable">dbReadTable()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dbWriteTable">dbWriteTable()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dbExistsTable">dbExistsTable()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dbRemoveTable">dbRemoveTable()</a></code>
</p>
</li></ul>

<p>Objects of this class are also returned from <code><a href="#topic+dbListObjects">dbListObjects()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Id(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Id-class_+3A_...">...</code></td>
<td>
<p>Components of the hierarchy, e.g. <code>cluster</code>,
<code>catalog</code>, <code>schema</code>, or <code>table</code>, depending on the database backend. For more
on these concepts, see <a href="https://stackoverflow.com/questions/7022755/">https://stackoverflow.com/questions/7022755/</a></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Identifies a table in a specific schema:
Id("dbo", "Customer")
# You can name the components if you want, but it's not needed
Id(table = "Customer", schema = "dbo")

# Create a SQL expression for an identifier:
dbQuoteIdentifier(ANSI(), Id("nycflights13", "flights"))

# Write a table in a specific schema:
## Not run: 
dbWriteTable(con, Id("myschema", "mytable"), data.frame(a = 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='make.db.names.default'>Make R identifiers into legal SQL identifiers</h2><span id='topic+make.db.names.default'></span><span id='topic+isSQLKeyword.default'></span><span id='topic+isSQLKeyword'></span><span id='topic+make.db.names'></span><span id='topic+SQLKeywords'></span>

<h3>Description</h3>

<p>These methods are DEPRECATED. Please use <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>
(or possibly <code><a href="#topic+dbQuoteString">dbQuoteString()</a></code>) instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.db.names.default(
  snames,
  keywords = .SQL92Keywords,
  unique = TRUE,
  allow.keywords = TRUE
)

isSQLKeyword.default(
  name,
  keywords = .SQL92Keywords,
  case = c("lower", "upper", "any")[3]
)

isSQLKeyword(
  dbObj,
  name,
  keywords = .SQL92Keywords,
  case = c("lower", "upper", "any")[3],
  ...
)

make.db.names(
  dbObj,
  snames,
  keywords = .SQL92Keywords,
  unique = TRUE,
  allow.keywords = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.db.names.default_+3A_snames">snames</code></td>
<td>
<p>a character vector of R identifiers (symbols) from which we
need to make SQL identifiers.</p>
</td></tr>
<tr><td><code id="make.db.names.default_+3A_keywords">keywords</code></td>
<td>
<p>a character vector with SQL keywords, by default it's
<code>.SQL92Keywords</code> defined by the DBI.</p>
</td></tr>
<tr><td><code id="make.db.names.default_+3A_unique">unique</code></td>
<td>
<p>logical describing whether the resulting set of SQL names
should be unique.  Its default is <code>TRUE</code>.  Following the SQL 92
standard, uniqueness of SQL identifiers is determined regardless of whether
letters are upper or lower case.</p>
</td></tr>
<tr><td><code id="make.db.names.default_+3A_allow.keywords">allow.keywords</code></td>
<td>
<p>logical describing whether SQL keywords should be
allowed in the resulting set of SQL names.  Its default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="make.db.names.default_+3A_name">name</code></td>
<td>
<p>a character vector with database identifier candidates we need
to determine whether they are legal SQL identifiers or not.</p>
</td></tr>
<tr><td><code id="make.db.names.default_+3A_case">case</code></td>
<td>
<p>a character string specifying whether to make the comparison as
lower case, upper case, or any of the two.  it defaults to <code>any</code>.</p>
</td></tr>
<tr><td><code id="make.db.names.default_+3A_dbobj">dbObj</code></td>
<td>
<p>any DBI object (e.g., <code>DBIDriver</code>).</p>
</td></tr>
<tr><td><code id="make.db.names.default_+3A_...">...</code></td>
<td>
<p>any other argument are passed to the driver implementation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm in <code>make.db.names</code> first invokes <code>make.names</code> and
then replaces each occurrence of a dot <code>.</code> by an underscore <code style="white-space: pre;">&#8288;_&#8288;</code>.  If
<code>allow.keywords</code> is <code>FALSE</code> and identifiers collide with SQL
keywords, a small integer is appended to the identifier in the form of
<code>"_n"</code>.
</p>
<p>The set of SQL keywords is stored in the character vector
<code>.SQL92Keywords</code> and reflects the SQL ANSI/ISO standard as documented
in &quot;X/Open SQL and RDA&quot;, 1994, ISBN 1-872630-68-8.  Users can easily
override or update this vector.
</p>


<h3>Value</h3>

<p><code>make.db.names</code> returns a character vector of legal SQL
identifiers corresponding to its <code>snames</code> argument.
</p>
<p><code>SQLKeywords</code> returns a character vector of all known keywords for the
database-engine associated with <code>dbObj</code>.
</p>
<p><code>isSQLKeyword</code> returns a logical vector parallel to <code>name</code>.
</p>


<h3>Bugs</h3>

<p>The current mapping is not guaranteed to be fully reversible: some SQL
identifiers that get mapped into R identifiers with <code>make.names</code> and
then back to SQL with <code><a href="#topic+make.db.names">make.db.names()</a></code> will not be equal to the
original SQL identifiers (e.g., compound SQL identifiers of the form
<code>username.tablename</code> will loose the dot &ldquo;.&rdquo;).
</p>


<h3>References</h3>

<p>The set of SQL keywords is stored in the character vector
<code>.SQL92Keywords</code> and reflects the SQL ANSI/ISO standard as documented
in &quot;X/Open SQL and RDA&quot;, 1994, ISBN 1-872630-68-8.  Users can easily
override or update this vector.
</p>

<hr>
<h2 id='rownames'>Convert row names back and forth between columns</h2><span id='topic+rownames'></span><span id='topic+sqlRownamesToColumn'></span><span id='topic+sqlColumnToRownames'></span>

<h3>Description</h3>

<p>These functions provide a reasonably automatic way of preserving the row
names of data frame during back-and-forth translation to an SQL table.
By default, row names will be converted to an explicit column
called &quot;row_names&quot;, and any query returning a column called &quot;row_names&quot;
will have those automatically set as row names.
These methods are mostly useful for backend implementers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqlRownamesToColumn(df, row.names = NA)

sqlColumnToRownames(df, row.names = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rownames_+3A_df">df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="rownames_+3A_row.names">row.names</code></td>
<td>
<p>Either <code>TRUE</code>, <code>FALSE</code>, <code>NA</code> or a string.
</p>
<p>If <code>TRUE</code>, always translate row names to a column called &quot;row_names&quot;.
If <code>FALSE</code>, never translate row names. If <code>NA</code>, translate
rownames only if they're a character vector.
</p>
<p>A string is equivalent to <code>TRUE</code>, but allows you to override the
default name.
</p>
<p>For backward compatibility, <code>NULL</code> is equivalent to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># If have row names
sqlRownamesToColumn(head(mtcars))
sqlRownamesToColumn(head(mtcars), FALSE)
sqlRownamesToColumn(head(mtcars), "ROWNAMES")

# If don't have
sqlRownamesToColumn(head(iris))
sqlRownamesToColumn(head(iris), TRUE)
sqlRownamesToColumn(head(iris), "ROWNAMES")
</code></pre>

<hr>
<h2 id='SQL'>SQL quoting</h2><span id='topic+SQL'></span><span id='topic+SQL-class'></span>

<h3>Description</h3>

<p>This set of classes and generics make it possible to flexibly deal with SQL
escaping needs. By default, any user supplied input to a query should be
escaped using either <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> or <code><a href="#topic+dbQuoteString">dbQuoteString()</a></code>
depending on whether it refers to a table or variable name, or is a literal
string.
These functions may return an object of the <code>SQL</code> class,
which tells DBI functions that a character string does not need to be escaped
anymore, to prevent double escaping.
The <code>SQL</code> class has associated the <code>SQL()</code> constructor function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SQL(x, ..., names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SQL_+3A_x">x</code></td>
<td>
<p>A character vector to label as being escaped SQL.</p>
</td></tr>
<tr><td><code id="SQL_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Not otherwise used.</p>
</td></tr>
<tr><td><code id="SQL_+3A_names">names</code></td>
<td>
<p>Names for the returned object, must have the same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SQL</code>.
</p>


<h3>Implementation notes</h3>

<p>DBI provides default generics for SQL-92 compatible quoting. If the database
uses a different convention, you will need to provide your own methods.
Note that because of the way that S4 dispatch finds methods and because
SQL inherits from character, if you implement (e.g.) a method for
<code>dbQuoteString(MyConnection, character)</code>, you will also need to
implement <code>dbQuoteString(MyConnection, SQL)</code> - this should simply
return <code>x</code> unchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dbQuoteIdentifier(ANSI(), "SELECT")
dbQuoteString(ANSI(), "SELECT")

# SQL vectors are always passed through as is
var_name &lt;- SQL("SELECT")
var_name

dbQuoteIdentifier(ANSI(), var_name)
dbQuoteString(ANSI(), var_name)

# This mechanism is used to prevent double escaping
dbQuoteString(ANSI(), dbQuoteString(ANSI(), "SELECT"))
</code></pre>

<hr>
<h2 id='sqlAppendTable'>Compose query to insert rows into a table</h2><span id='topic+sqlAppendTable'></span><span id='topic+sqlAppendTableTemplate'></span>

<h3>Description</h3>

<p><code>sqlAppendTable()</code> generates a single SQL string that inserts a
data frame into an existing table. <code>sqlAppendTableTemplate()</code> generates
a template suitable for use with <code><a href="#topic+dbBind">dbBind()</a></code>.
The default methods are ANSI SQL 99 compliant.
These methods are mostly useful for backend implementers.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sqlAppendTable(con, table, values, row.names = NA, ...)

sqlAppendTableTemplate(
  con,
  table,
  values,
  row.names = NA,
  prefix = "?",
  ...,
  pattern = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqlAppendTable_+3A_con">con</code></td>
<td>
<p>A database connection.</p>
</td></tr>
<tr><td><code id="sqlAppendTable_+3A_table">table</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="sqlAppendTable_+3A_values">values</code></td>
<td>
<p>A data frame. Factors will be converted to character vectors.
Character vectors will be escaped with <code><a href="#topic+dbQuoteString">dbQuoteString()</a></code>.</p>
</td></tr>
<tr><td><code id="sqlAppendTable_+3A_row.names">row.names</code></td>
<td>
<p>Either <code>TRUE</code>, <code>FALSE</code>, <code>NA</code> or a string.
</p>
<p>If <code>TRUE</code>, always translate row names to a column called &quot;row_names&quot;.
If <code>FALSE</code>, never translate row names. If <code>NA</code>, translate
rownames only if they're a character vector.
</p>
<p>A string is equivalent to <code>TRUE</code>, but allows you to override the
default name.
</p>
<p>For backward compatibility, <code>NULL</code> is equivalent to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sqlAppendTable_+3A_...">...</code></td>
<td>
<p>Other arguments used by individual methods.</p>
</td></tr>
<tr><td><code id="sqlAppendTable_+3A_prefix">prefix</code></td>
<td>
<p>Parameter prefix to use for placeholders.</p>
</td></tr>
<tr><td><code id="sqlAppendTable_+3A_pattern">pattern</code></td>
<td>
<p>Parameter pattern to use for placeholders:
</p>

<ul>
<li> <p><code>""</code>: no pattern
</p>
</li>
<li> <p><code>"1"</code>: position
</p>
</li>
<li><p> anything else: field name
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>row.names</code> argument must be passed explicitly in order to avoid
a compatibility warning.  The default will be changed in a later release.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqlAppendTable(ANSI(), "iris", head(iris))

sqlAppendTable(ANSI(), "mtcars", head(mtcars))
sqlAppendTable(ANSI(), "mtcars", head(mtcars), row.names = FALSE)
sqlAppendTableTemplate(ANSI(), "iris", iris)

sqlAppendTableTemplate(ANSI(), "mtcars", mtcars)
sqlAppendTableTemplate(ANSI(), "mtcars", mtcars, row.names = FALSE)
</code></pre>

<hr>
<h2 id='sqlCommentSpec'>Parse interpolated variables from SQL.</h2><span id='topic+sqlCommentSpec'></span><span id='topic+sqlQuoteSpec'></span><span id='topic+sqlParseVariablesImpl'></span><span id='topic+sqlParseVariables'></span>

<h3>Description</h3>

<p>If you're implementing a backend that uses non-ANSI quoting or commenting
rules, you'll need to implement a method for <code>sqlParseVariables</code> that
calls <code>sqlParseVariablesImpl</code> with the appropriate quote and
comment specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqlCommentSpec(start, end, endRequired)

sqlQuoteSpec(start, end, escape = "", doubleEscape = TRUE)

sqlParseVariablesImpl(sql, quotes, comments)

sqlParseVariables(conn, sql, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqlCommentSpec_+3A_start">start</code>, <code id="sqlCommentSpec_+3A_end">end</code></td>
<td>
<p>Start and end characters for quotes and comments</p>
</td></tr>
<tr><td><code id="sqlCommentSpec_+3A_endrequired">endRequired</code></td>
<td>
<p>Is the ending character of a comment required?</p>
</td></tr>
<tr><td><code id="sqlCommentSpec_+3A_escape">escape</code></td>
<td>
<p>What character can be used to escape quoting characters?
Defaults to <code>""</code>, i.e. nothing.</p>
</td></tr>
<tr><td><code id="sqlCommentSpec_+3A_doubleescape">doubleEscape</code></td>
<td>
<p>Can quoting characters be escaped by doubling them?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sqlCommentSpec_+3A_sql">sql</code></td>
<td>
<p>SQL to parse (a character string)</p>
</td></tr>
<tr><td><code id="sqlCommentSpec_+3A_quotes">quotes</code></td>
<td>
<p>A list of <code>QuoteSpec</code> calls defining the quoting
specification.</p>
</td></tr>
<tr><td><code id="sqlCommentSpec_+3A_comments">comments</code></td>
<td>
<p>A list of <code>CommentSpec</code> calls defining the commenting
specification.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Use [] for quoting and no comments
sqlParseVariablesImpl("[?a]",
  list(sqlQuoteSpec("[", "]", "\\", FALSE)),
  list()
)

# Standard quotes, use # for commenting
sqlParseVariablesImpl("# ?a\n?b",
  list(sqlQuoteSpec("'", "'"), sqlQuoteSpec('"', '"')),
  list(sqlCommentSpec("#", "\n", FALSE))
)
</code></pre>

<hr>
<h2 id='sqlCreateTable'>Compose query to create a simple table</h2><span id='topic+sqlCreateTable'></span>

<h3>Description</h3>

<p>Exposes an interface to simple <code style="white-space: pre;">&#8288;CREATE TABLE&#8288;</code> commands. The default
method is ANSI SQL 99 compliant.
This method is mostly useful for backend implementers.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sqlCreateTable(con, table, fields, row.names = NA, temporary = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqlCreateTable_+3A_con">con</code></td>
<td>
<p>A database connection.</p>
</td></tr>
<tr><td><code id="sqlCreateTable_+3A_table">table</code></td>
<td>
<p>The table name, passed on to <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>. Options are:
</p>

<ul>
<li><p> a character string with the unquoted DBMS table name,
e.g. <code>"table_name"</code>,
</p>
</li>
<li><p> a call to <code><a href="#topic+Id">Id()</a></code> with components to the fully qualified table name,
e.g. <code>Id(schema = "my_schema", table = "table_name")</code>
</p>
</li>
<li><p> a call to <code><a href="#topic+SQL">SQL()</a></code> with the quoted and fully qualified table name
given verbatim, e.g. <code>SQL('"my_schema"."table_name"')</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="sqlCreateTable_+3A_fields">fields</code></td>
<td>
<p>Either a character vector or a data frame.
</p>
<p>A named character vector: Names are column names, values are types.
Names are escaped with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>.
Field types are unescaped.
</p>
<p>A data frame: field types are generated using
<code><a href="#topic+dbDataType">dbDataType()</a></code>.</p>
</td></tr>
<tr><td><code id="sqlCreateTable_+3A_row.names">row.names</code></td>
<td>
<p>Either <code>TRUE</code>, <code>FALSE</code>, <code>NA</code> or a string.
</p>
<p>If <code>TRUE</code>, always translate row names to a column called &quot;row_names&quot;.
If <code>FALSE</code>, never translate row names. If <code>NA</code>, translate
rownames only if they're a character vector.
</p>
<p>A string is equivalent to <code>TRUE</code>, but allows you to override the
default name.
</p>
<p>For backward compatibility, <code>NULL</code> is equivalent to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sqlCreateTable_+3A_temporary">temporary</code></td>
<td>
<p>If <code>TRUE</code>, will generate a temporary table.</p>
</td></tr>
<tr><td><code id="sqlCreateTable_+3A_...">...</code></td>
<td>
<p>Other arguments used by individual methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>row.names</code> argument must be passed explicitly in order to avoid
a compatibility warning.  The default will be changed in a later release.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sqlCreateTable(ANSI(), "my-table", c(a = "integer", b = "text"))
sqlCreateTable(ANSI(), "my-table", iris)

# By default, character row names are converted to a row_names colum
sqlCreateTable(ANSI(), "mtcars", mtcars[, 1:5])
sqlCreateTable(ANSI(), "mtcars", mtcars[, 1:5], row.names = FALSE)
</code></pre>

<hr>
<h2 id='sqlData'>Convert a data frame into form suitable for upload to an SQL database</h2><span id='topic+sqlData'></span>

<h3>Description</h3>

<p>This is a generic method that coerces R objects into vectors suitable for
upload to the database. The output will vary a little from method to
method depending on whether the main upload device is through a single
SQL string or multiple parameterized queries.
This method is mostly useful for backend implementers.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sqlData(con, value, row.names = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqlData_+3A_con">con</code></td>
<td>
<p>A database connection.</p>
</td></tr>
<tr><td><code id="sqlData_+3A_value">value</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="sqlData_+3A_row.names">row.names</code></td>
<td>
<p>Either <code>TRUE</code>, <code>FALSE</code>, <code>NA</code> or a string.
</p>
<p>If <code>TRUE</code>, always translate row names to a column called &quot;row_names&quot;.
If <code>FALSE</code>, never translate row names. If <code>NA</code>, translate
rownames only if they're a character vector.
</p>
<p>A string is equivalent to <code>TRUE</code>, but allows you to override the
default name.
</p>
<p>For backward compatibility, <code>NULL</code> is equivalent to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sqlData_+3A_...">...</code></td>
<td>
<p>Other arguments used by individual methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method:
</p>

<ul>
<li><p> Converts factors to characters
</p>
</li>
<li><p> Quotes all strings with <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code>
</p>
</li>
<li><p> Converts all columns to strings with <code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral()</a></code>
</p>
</li>
<li><p> Replaces NA with NULL
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

sqlData(con, head(iris))
sqlData(con, head(mtcars))

dbDisconnect(con)

</code></pre>

<hr>
<h2 id='sqlInterpolate'>Safely interpolate values into an SQL string</h2><span id='topic+sqlInterpolate'></span>

<h3>Description</h3>

<p>Accepts a query string with placeholders for values, and returns a string
with the values embedded.
The function is careful to quote all of its inputs with <code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral()</a></code>
to protect against SQL injection attacks.
</p>
<p>Placeholders can be specified with one of two syntaxes:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;?&#8288;</code>: each occurrence of a standalone <code style="white-space: pre;">&#8288;?&#8288;</code> is replaced with a value
</p>
</li>
<li> <p><code>?name1</code>, <code>?name2</code>, ...: values are given as named arguments or a
named list, the names are used to match the values
</p>
</li></ul>

<p>Mixing <code style="white-space: pre;">&#8288;?&#8288;</code> and <code>?name</code> syntaxes is an error.
The number and names of values supplied must correspond to the placeholders
used in the query.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sqlInterpolate(conn, sql, ..., .dots = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqlInterpolate_+3A_conn">conn</code></td>
<td>
<p>A <a href="#topic+DBIConnection-class">DBIConnection</a> object, as returned by
<code><a href="#topic+dbConnect">dbConnect()</a></code>.</p>
</td></tr>
<tr><td><code id="sqlInterpolate_+3A_sql">sql</code></td>
<td>
<p>A SQL string containing variables to interpolate.
Variables must start with a question mark and can be any valid R
identifier, i.e. it must start with a letter or <code>.</code>, and be followed
by a letter, digit, <code>.</code> or <code style="white-space: pre;">&#8288;_&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sqlInterpolate_+3A_...">...</code>, <code id="sqlInterpolate_+3A_.dots">.dots</code></td>
<td>
<p>Values (for <code>...</code>) or a list (for <code>.dots</code>)
to interpolate into a string.
Names are required if  <code>sql</code> uses the <code>?name</code> syntax for placeholders.
All values will be first escaped with <code><a href="#topic+dbQuoteLiteral">dbQuoteLiteral()</a></code> prior
to interpolation to protect against SQL injection attacks.
Arguments created by <code><a href="#topic+SQL">SQL()</a></code> or <code><a href="#topic+dbQuoteIdentifier">dbQuoteIdentifier()</a></code> remain unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>sql</code> query with the values from <code>...</code> and <code>.dots</code> safely
embedded.
</p>


<h3>Backend authors</h3>

<p>If you are implementing an SQL backend with non-ANSI quoting rules, you'll
need to implement a method for <code><a href="#topic+sqlParseVariables">sqlParseVariables()</a></code>. Failure to
do so does not expose you to SQL injection attacks, but will (rarely) result
in errors matching supplied and interpolated variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sql &lt;- "SELECT * FROM X WHERE name = ?name"
sqlInterpolate(ANSI(), sql, name = "Hadley")

# This is safe because the single quote has been double escaped
sqlInterpolate(ANSI(), sql, name = "H'); DROP TABLE--;")

# Using paste0() could lead to dangerous SQL with carefully crafted inputs
# (SQL injection)
name &lt;- "H'); DROP TABLE--;"
paste0("SELECT * FROM X WHERE name = '", name, "'")

# Use SQL() or dbQuoteIdentifier() to avoid escaping
sql2 &lt;- "SELECT * FROM ?table WHERE name in ?names"
sqlInterpolate(ANSI(), sql2,
  table = dbQuoteIdentifier(ANSI(), "X"),
  names = SQL("('a', 'b')")
)

# Don't use SQL() to escape identifiers to avoid SQL injection
sqlInterpolate(ANSI(), sql2,
  table = SQL("X; DELETE FROM X; SELECT * FROM X"),
  names = SQL("('a', 'b')")
)

# Use dbGetQuery() or dbExecute() to process these queries:
if (requireNamespace("RSQLite", quietly = TRUE)) {
  con &lt;- dbConnect(RSQLite::SQLite())
  sql &lt;- "SELECT ?value AS value"
  query &lt;- sqlInterpolate(con, sql, value = 3)
  print(dbGetQuery(con, query))
  dbDisconnect(con)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
