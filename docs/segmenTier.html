<!DOCTYPE html><html><head><title>Help for package segmenTier</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {segmenTier}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#segmenTier'><p>segmenTier : cluster-based segmentation</p>
from a sequential clustering</a></li>
<li><a href='#ash'><p><code>asinh</code> data transformation</p></a></li>
<li><a href='#backtrace'><p>Back-tracing step of the <code>segmenTier</code> algorithm.</p></a></li>
<li><a href='#calculateScore'><p>segmenTier's core dynamic programming routine in Rcpp</p></a></li>
<li><a href='#clusterCor_c'><p>Calculates position-cluster correlations for scoring function &quot;icor&quot;.</p></a></li>
<li><a href='#clusterTimeseries'><p>Cluster a processed time-series with k-means.</p></a></li>
<li><a href='#colorClusters'><p>Assign colors to clusters.</p></a></li>
<li><a href='#flowclusterTimeseries'><p>Cluster a processed time-series with</p>
<code>flowClust</code> &amp;
<code>flowMerge</code>.</a></li>
<li><a href='#log_1'><p>log transformation handling zeros by adding 1</p></a></li>
<li><a href='#logLik.kmeans'><p>Experimental: AIC/BIC for kmeans</p></a></li>
<li><a href='#myPearson'><p>Pearson product-moment correlation coefficient</p></a></li>
<li><a href='#plot.clustering'><p>Plot method for the &quot;clustering&quot; object.</p></a></li>
<li><a href='#plot.segments'><p>Plot method for the &quot;segments&quot; object.</p></a></li>
<li><a href='#plot.timeseries'><p>Plot method for the &quot;timeseries&quot; object.</p></a></li>
<li><a href='#plotdev'><p>Switch between plot devices.</p></a></li>
<li><a href='#plotSegmentation'><p>Summary plot for the <code>segmenTier</code> pipeline.</p></a></li>
<li><a href='#print.segments'><p>Print method for segmentation result from <code>segmentClusters</code>.</p></a></li>
<li><a href='#processTimeseries'><p>Process a time-series for clustering and segmentation.</p></a></li>
<li><a href='#segmentCluster.batch'><p>Batch wrapper for <code>segmentClusters</code>.</p></a></li>
<li><a href='#segmentClusters'><p>Run the <code>segmenTier</code> algorithm.</p></a></li>
<li><a href='#setVarySettings'><p>Parameters for <code>segmentCluster.batch</code>.</p></a></li>
<li><a href='#sortClusters'><p>Sort clusters by similarity.</p></a></li>
<li><a href='#tsd'><p>Transcriptome time-series from budding yeast.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Similarity-Based Segmentation of Multidimensional Signals</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Rainer Machne, Douglas B. Murray, Peter F. Stadler</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/raim/segmenTier">https://github.com/raim/segmenTier</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/raim/segmenTier/issues">https://github.com/raim/segmenTier/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rainer Machne &lt;raim@tbi.univie.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A dynamic programming solution to segmentation based on
        maximization of arbitrary similarity measures within segments.
	The general idea, theory and this implementation are described in
	Machne, Murray &amp; Stadler (2017) &lt;<a href="https://doi.org/10.1038%2Fs41598-017-12401-8">doi:10.1038/s41598-017-12401-8</a>&gt;.
	In addition to the core algorithm, the package provides time-series
	processing and clustering functions as described in the publication.
	These are generally applicable where a &lsquo;k-means' clustering yields
	meaningful results, and have been specifically developed for
	clustering of the Discrete Fourier Transform of periodic gene
	expression data ('circadian&rsquo; or &lsquo;yeast metabolic oscillations&rsquo;).
	This clustering approach is outlined in the supplemental material of
	Machne &amp; Murray (2012) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0037906">doi:10.1371/journal.pone.0037906</a>&gt;), and here
	is used as a basis of segment similarity measures. Notably, the
	time-series processing and clustering functions can also be used as
	stand-alone tools, independent of segmentation, e.g., for 
        transcriptome data already mapped to genes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.7)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>flowMerge, flowClust, flowCore, knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-02-09 13:04:24 UTC; raim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-02-18 23:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='segmenTier'>segmenTier : cluster-based segmentation
from a sequential clustering</h2><span id='topic+segmenTier'></span><span id='topic+segmenTier-package'></span>

<h3>Description</h3>

<p>segmenTier : cluster-based segmentation
from a sequential clustering
</p>


<h3>Dependencies</h3>

<p>The package strictly depends only on
<code>Rcpp</code>.
All other dependencies are usually present in a
basic installation (<code>stats</code>, <code>graphics</code>, <code>grDevices</code>)).
</p>


<h3>Author(s)</h3>

<p>Rainer Machne <a href="mailto:raim@tbi.univie.ac.at">raim@tbi.univie.ac.at</a>, Douglas B. Murray,
Peter F. Stadler <a href="mailto:studla@bioinf.uni-leipzig.de">studla@bioinf.uni-leipzig.de</a>
</p>


<h3>References</h3>

<p>Machne, Murray &amp; Stadler (2017) &lt;doi:10.1038/s41598-017-12401-8&gt;,
Machne &amp; Murray (2012) &lt;doi:10.1371/journal.pone.0037906&gt;, and
Lehmann et al. (2013) &lt;doi:10.1186/1471-2105-14-133&gt;
</p>

<hr>
<h2 id='ash'><code>asinh</code> data transformation</h2><span id='topic+ash'></span>

<h3>Description</h3>

<p>The asinh transformation, (<code>ash(x) = log(x + sqrt(x^2+1))</code>), is
an alternative to log transformation that has less (compressing) effects
on the extreme values (low and high values), and naturally handles
negative numbers and 0. Also see <code><a href="#topic+log_1">log_1</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ash(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ash_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>

<hr>
<h2 id='backtrace'>Back-tracing step of the <code>segmenTier</code> algorithm.</h2><span id='topic+backtrace'></span>

<h3>Description</h3>

<p>back-tracing step: collect clustered segments from the scoring matrix
<code>S(i,c)</code> by back-tracing the position <code>j=k</code> which delivered
the maximal score at position <code>i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backtrace(S, K, multib, nextmax = FALSE, verb = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backtrace_+3A_s">S</code></td>
<td>
<p>matrix S, containing the local scores</p>
</td></tr>
<tr><td><code id="backtrace_+3A_k">K</code></td>
<td>
<p>matrix K, containing the position k used for score maximization</p>
</td></tr>
<tr><td><code id="backtrace_+3A_multib">multib</code></td>
<td>
<p>if multiple k produce the maximal score, take either the
shortest k (&quot;max&quot;) or the longest k (&quot;min&quot;); if <code>multib</code> is set to
&quot;skip&quot; the next unique k will be searched</p>
</td></tr>
<tr><td><code id="backtrace_+3A_nextmax">nextmax</code></td>
<td>
<p>proceed backwards while score is increasing before
opening a new segment</p>
</td></tr>
<tr><td><code id="backtrace_+3A_verb">verb</code></td>
<td>
<p>print messages</p>
</td></tr>
</table>

<hr>
<h2 id='calculateScore'>segmenTier's core dynamic programming routine in Rcpp</h2><span id='topic+calculateScore'></span>

<h3>Description</h3>

<p>segmenTier's core dynamic programming routine in Rcpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateScore(seq, C, score, csim, M, Mn, multi = "max")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateScore_+3A_seq">seq</code></td>
<td>
<p>the cluster sequence (where clusters at positions k:i are
considered). Note, that unlike the R wrapper, clustering numbers
here are 0-based, where 0 is the nuisance cluster.</p>
</td></tr>
<tr><td><code id="calculateScore_+3A_c">C</code></td>
<td>
<p>the list of clusters, including nuisance cluster '0', see 
<code>seq</code></p>
</td></tr>
<tr><td><code id="calculateScore_+3A_score">score</code></td>
<td>
<p>the scoring function to be used, one of &quot;ccor&quot; or &quot;icor&quot;,
an apt similarity matrix must be supplied via option <code>csim</code></p>
</td></tr>
<tr><td><code id="calculateScore_+3A_csim">csim</code></td>
<td>
<p>a matrix, providing either the cluster-cluster (scoring 
function &quot;ccor&quot;) or the position-cluster similarity function
(scoring function &quot;icor&quot;)</p>
</td></tr>
<tr><td><code id="calculateScore_+3A_m">M</code></td>
<td>
<p>minimal sequence length; Note, that this is not a strict
cut-off but defined as an accumulating penalty that must be
&quot;overcome&quot; by good score</p>
</td></tr>
<tr><td><code id="calculateScore_+3A_mn">Mn</code></td>
<td>
<p>minimal sequence length for nuisance cluster, Mn&lt;M will allow
shorter distances between segments</p>
</td></tr>
<tr><td><code id="calculateScore_+3A_multi">multi</code></td>
<td>
<p>if multiple <code>k</code> are found which return the same maximal
score, should the &quot;max&quot; (shorter segment) or &quot;min&quot; (longer segment) be used?
This has little effect on real-life large data sets, since the situation
will rarely occur. Default is &quot;max&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is <code><a href="#topic+segmenTier">segmenTier</a></code>'s core dynamic programming
routine. It constructs the total score matrix S(i,c), based on
the passed scoring function (&quot;icor&quot; or &quot;ccor&quot;), and length penalty
<code>M</code>. &quot;Nuisance&quot; cluster &quot;0&quot; can have a smaller penalty <code>Mn</code>
to allow for shorter distances between &quot;real&quot; segments.
</p>
<p>Scoring function &quot;icor&quot; calculates the sum of similarities of
data at positions k:i to cluster centers c over all k and i.
The similarities are calculated e.g., as a (Pearson) correlation between
the data at individual positions and the tested cluster c center.
</p>
<p>Scoring function &quot;ccor&quot; calculates the sum of similarities
between the clusters at positions k:i to cluster c over all k and i.
</p>
<p>Scoring function &quot;ccls&quot; is a special case of &quot;ccor&quot; and is NOT handled
here, but is reflected in the cluster similarity matrix <code>csim</code>. It
is handled and automatically constructed in the R wrapper 
<code><a href="#topic+segmentClusters">segmentClusters</a></code>, and merely counts the 
number of clusters in sequence k:i, over all k and i, that are identical
to the tested cluster <code>c</code>, and sub-tracts 
a penalty for the count of non-identical clusters.
</p>


<h3>Value</h3>

<p>Returns the total score matrix <code>S(i,c)</code> and the matrix 
<code>K(i,c)</code> which stores the position <code>k</code> which delivered
the maximal score at position <code>i</code>. This is used in the back-tracing
phase.
</p>


<h3>References</h3>

<p>Machne, Murray &amp; Stadler (2017)
&lt;doi:10.1038/s41598-017-12401-8&gt;
</p>

<hr>
<h2 id='clusterCor_c'>Calculates position-cluster correlations for scoring function &quot;icor&quot;.</h2><span id='topic+clusterCor_c'></span>

<h3>Description</h3>

<p>Calculates Pearson's product-moment correlation coefficients
between rows in <code>data</code>  and <code>cluster</code>, and is used to calculate
the position-cluster similarity matrix for the scoring function &quot;icor&quot;.
This is implemented in Rcpp for calculation speed, using 
<code><a href="#topic+myPearson">myPearson</a></code> to calculate correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterCor_c(data, clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterCor_c_+3A_data">data</code></td>
<td>
<p>original data matrix</p>
</td></tr>
<tr><td><code id="clusterCor_c_+3A_clusters">clusters</code></td>
<td>
<p>cluster centers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a position-cluster correlation matrix as used in
scoring function &quot;icor&quot;.
</p>

<hr>
<h2 id='clusterTimeseries'>Cluster a processed time-series with k-means.</h2><span id='topic+clusterTimeseries'></span>

<h3>Description</h3>

<p>Performs <code><a href="stats.html#topic+kmeans">kmeans</a></code> clustering of a
time-series object <code>tset</code> provided by
<code><a href="#topic+processTimeseries">processTimeseries</a></code>, and calculates cluster-cluster
and cluster-position similarity matrices as required for
<code><a href="#topic+segmentClusters">segmentClusters</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterTimeseries(tset, K = 16, iter.max = 1e+05, nstart = 100,
  nui.thresh = -Inf, verb = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterTimeseries_+3A_tset">tset</code></td>
<td>
<p>a &quot;timeseries&quot; object returned by
<code><a href="#topic+processTimeseries">processTimeseries</a></code></p>
</td></tr>
<tr><td><code id="clusterTimeseries_+3A_k">K</code></td>
<td>
<p>the number of clusters to be calculated, ie. the argument
<code>centers</code> of <code><a href="stats.html#topic+kmeans">kmeans</a></code>, but here
multiple clusterings can be calculated, ie. <code>K</code> can be an
integer vector. Note that a smaller cluster number is automatically
chosen, if the data doesn't have more then K different values.</p>
</td></tr>
<tr><td><code id="clusterTimeseries_+3A_iter.max">iter.max</code></td>
<td>
<p>the maximum number of iterations allowed in
<code><a href="stats.html#topic+kmeans">kmeans</a></code></p>
</td></tr>
<tr><td><code id="clusterTimeseries_+3A_nstart">nstart</code></td>
<td>
<p>number of randomized initializations of
<code><a href="stats.html#topic+kmeans">kmeans</a></code>: &quot;how many random sets should
be chosen?&quot;</p>
</td></tr>
<tr><td><code id="clusterTimeseries_+3A_nui.thresh">nui.thresh</code></td>
<td>
<p>threshold correlation of a data point to a
cluster center; if below the data point will be added to
nuisance cluster 0</p>
</td></tr>
<tr><td><code id="clusterTimeseries_+3A_verb">verb</code></td>
<td>
<p>level of verbosity, 0: no output, 1: progress messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs one or more time-series clustering(s)
using <code><a href="stats.html#topic+kmeans">kmeans</a></code>, and the output of
<code><a href="#topic+processTimeseries">processTimeseries</a></code> as input. It further calculates
cluster centers, cluster-cluster and cluster-position similarity
matrices (Pearson correlation) that will be used by the main function
of this package, <code><a href="#topic+segmentClusters">segmentClusters</a></code>, to split the cluster
association sequence into segments, and assigns each segment to
the &quot;winning&quot; input cluster.
</p>
<p>The argument <code>K</code> is an integer vector that sets the requested
cluster numbers (argument <code>centers</code> in
<code><a href="stats.html#topic+kmeans">kmeans</a></code>). However, to avoid errors in batch
use, a smaller <code>K</code> is chosen, if the data contains less then
<code>K</code> distinct values.
</p>
<p>Nuisance Cluster:
values that were removed during time-series processing, such as
rows that only contain 0 or NA values, will be assigned to
the &quot;nuisance cluster&quot; with cluster label &quot;0&quot;. Additionally, a minimal
correlation to any cluster center can be specified, argument
<code>nui.thresh</code>, and positions without any correlation higher
then this, will also be assigned to the &quot;nuisance&quot; cluster.
Resulting &quot;nuisance segments&quot; will not be shown in the results.
</p>
<p>Cluster Sorting and Coloring:
additionally the cluster labels in the result object will be sorted by
cluster-cluster similarity (see <code><a href="#topic+sortClusters">sortClusters</a></code>) and cluster
colors assigned (see <code><a href="#topic+colorClusters">colorClusters</a></code>) for convenient data
inspection with the plot methods available for each data processing
step (see examples).
</p>
<p>Note that the function, in conjunction with
<code><a href="#topic+processTimeseries">processTimeseries</a></code>, can also be used as a stand-alone
tool for time-series clusterings, specifically implementing the
strategy of clustering the Discrete Fourier Transform of periodic
time-series developed by Machne &amp; Murray (2012)
&lt;doi:10.1371/journal.pone.0037906&gt;, and further analyzed in Lehmann
et al. (2013) &lt;doi:10.1186/1471-2105-14-133&gt;, such as transcriptome
data from circadian or yeast respiratory oscillation systems.
</p>


<h3>Value</h3>

<p>Returns a list of class &quot;clustering&quot; comprising of a matrix
of clusterings, lists of cluster centers, cluster-cluster and
cluster-position similarity matrices (Pearson correlation) used
by <code><a href="#topic+segmentClusters">segmentClusters</a></code>, and additional information
such as a cluster sorting by similarity and cluster colors that
allow to track clusters in plots. A plot method exists that
allows to plot clusters aligned to &quot;timeseries&quot; and &quot;segment&quot;
plots.
</p>


<h3>References</h3>

<p>Machne &amp; Murray (2012)
&lt;doi:10.1371/journal.pone.0037906&gt;, and Lehmann et al. (2013)
&lt;doi:10.1186/1471-2105-14-133&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primseg436)
## Discrete Fourier Transform of the time-series, 
## see ?processTimeseries for details
tset &lt;- processTimeseries(ts=tsd, na2zero=TRUE, use.fft=TRUE,
                          dft.range=1:7,  dc.trafo="ash", use.snr=TRUE)
## ... and cluster the transformed time-series
cset &lt;- clusterTimeseries(tset)
## plot methods for both returned objects allow aligned plots
par(mfcol=c(3,1))
plot(tset)
plot(cset)
</code></pre>

<hr>
<h2 id='colorClusters'>Assign colors to clusters.</h2><span id='topic+colorClusters'></span>

<h3>Description</h3>

<p>Takes a clustering set as returned by <code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code> and
assigns colors to each cluster in each clustering along
the &quot;hue&quot; color wheel, as in <code>scale_colour_hue</code> in <code>ggplot2</code>.
If <code>cset</code> contains a sorting, this sorting will be used to assign
colors along the color wheel, otherwise a sorting will be calculated first,
using <code><a href="#topic+sortClusters">sortClusters</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorClusters(cset, colf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorClusters_+3A_cset">cset</code></td>
<td>
<p>a clustering set as returned by <code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code></p>
</td></tr>
<tr><td><code id="colorClusters_+3A_colf">colf</code></td>
<td>
<p>a function that generates <code>n</code> colors</p>
</td></tr>
<tr><td><code id="colorClusters_+3A_...">...</code></td>
<td>
<p>arguments to color function <code>colf</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input &quot;clustering&quot; object with a list of vectors
(&quot;colors&quot;), each providing a named vector of colors for each cluster.
</p>

<hr>
<h2 id='flowclusterTimeseries'>Cluster a processed time-series with
<code><a href="flowClust.html#topic+flowClust">flowClust</a></code> &amp;
<code><a href="flowMerge.html#topic+merge">flowMerge</a></code>.</h2><span id='topic+flowclusterTimeseries'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="flowClust.html#topic+flowClust">flowClust</a></code>, clustering
a time-series object <code>tset</code> provided by <code><a href="#topic+processTimeseries">processTimeseries</a></code>,
where specifically the DFT of a time-series and requested data
transformation were calculated. This is intended to work in the same way
as <code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code> but was so far only tested for
clustering of the final segment time-series, as previously applied
to microarray data from yeast by Machne &amp; Murray (2012)
&lt;doi:10.1371/journal.pone.0037906&gt; and from cyanobacteria by Lehmann
et al. (2013) &lt;doi:10.1186/1471-2105-14-133&gt;.
It could in principle also be used for segmentation, but that has not
been extensively tested. <code><a href="flowClust.html#topic+flowClust">flowClust</a></code>
implements a model-based clustering approach and is much slower then
<code><a href="stats.html#topic+kmeans">kmeans</a></code> used in <code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code>. 
Please see option <code>ncpu</code> on how to use parallel mode, which
does not work on some installations. However, model-based clustering has
the advantage of an intrinsic measure (<code>BIC</code>) to decide on the optimal
cluster numbers. Additionally, the clusters can be &quot;merged&quot; to fewer
clusters at constant <code>BIC</code> using
<code><a href="flowMerge.html#topic+merge">flowMerge</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flowclusterTimeseries(tset, ncpu = 1, K = 10, selected,
  merge = FALSE, B = 500, tol = 1e-05, lambda = 1, nu = 4,
  nu.est = 0, trans = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flowclusterTimeseries_+3A_tset">tset</code></td>
<td>
<p>processed time-series as provided by
<code><a href="#topic+processTimeseries">processTimeseries</a></code></p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_ncpu">ncpu</code></td>
<td>
<p>number of cores available for parallel mode of
<span class="pkg">flowClust</span>. NOTE: parallel mode of
<code><a href="flowClust.html#topic+flowClust">flowClust</a></code> is often non-functional.
Alternatively, you can set <code>options(mc.cores=ncpu)</code> directly.</p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_k">K</code></td>
<td>
<p>the requested cluster numbers (vector of integers)</p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_selected">selected</code></td>
<td>
<p>a pre-selected cluster number  which is then
used as a start clustering for  <code><a href="flowMerge.html#topic+merge">flowMerge</a></code>
(if option <code>merge==TRUE</code>)</p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_merge">merge</code></td>
<td>
<p>logical indicating whether cluster merging with
<code><a href="flowMerge.html#topic+merge">flowMerge</a></code> should be attempted</p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_b">B</code></td>
<td>
<p>maximal number of EM iterations</p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_tol">tol</code></td>
<td>
<p>tolerance for EM convergence</p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_lambda">lambda</code></td>
<td>
<p>initial Box-Cox trafo</p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom used for the t distribution, Inf for
pure Gaussian</p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_nu.est">nu.est</code></td>
<td>
<p>0: no, 1: non-specific, 2: cluster-specific estimation of nu</p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_trans">trans</code></td>
<td>
<p>0: no, 1: non-specific, 2: cluster-specific estim. of lambda</p>
</td></tr>
<tr><td><code id="flowclusterTimeseries_+3A_...">...</code></td>
<td>
<p>further parameters for
<code><a href="flowClust.html#topic+flowClust">flowClust</a></code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Machne &amp; Murray (2012)
&lt;doi:10.1371/journal.pone.0037906&gt;
</p>

<hr>
<h2 id='log_1'>log transformation handling zeros by adding 1</h2><span id='topic+log_1'></span>

<h3>Description</h3>

<p>A conventional approach to handle 0 in log transformation is to simply
add 1 to all data, <code>log_1(x) = log(x+1)</code>. Also see <code><a href="#topic+ash">ash</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_1_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>

<hr>
<h2 id='logLik.kmeans'>Experimental: AIC/BIC for kmeans</h2><span id='topic+logLik.kmeans'></span>

<h3>Description</h3>

<p>This function is supposed to provide a log-likelihood method for
<code><a href="stats.html#topic+kmeans">kmeans</a></code> results, after Neal Fultz at
<a href="https://stackoverflow.com/a/33202188">https://stackoverflow.com/a/33202188</a> and also featured in the
<a href="https://rdrr.io/github/nfultz/stackoverflow/src/R/logLik_kmeans.R">stackoverflow package</a>. Note, that the blogged version on Jan 30, 2019 adds
a minus and a division by 2 compared to a linked git version.
This idea has not been reviewed, and this function has not been
tested extensively; feel free to do so and contribute your results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kmeans'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.kmeans_+3A_object">object</code></td>
<td>
<p>a <code><a href="stats.html#topic+kmeans">kmeans</a></code> result object</p>
</td></tr>
<tr><td><code id="logLik.kmeans_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an attempt to reproduce the <code>BIC</code> measure
in model-based clustering to decide on an optimal number of clusters.
This function will be used for <code><a href="stats.html#topic+kmeans">kmeans</a></code>
results objects when passed to <code><a href="stats.html#topic+BIC">BIC</a></code> and
<code><a href="stats.html#topic+AIC">AIC</a></code> functions from the <span class="pkg">stats</span> package in
base R, and BIC and AIC are calculated this way in
<code><a href="#topic+segmentClusters">segmentClusters</a></code>. It is however not used anywhere at the
moment.
</p>

<hr>
<h2 id='myPearson'>Pearson product-moment correlation coefficient</h2><span id='topic+myPearson'></span>

<h3>Description</h3>

<p>Incremental calculation of the Pearson correlation coefficient between
two vectors for calculation within Rcpp functions
<code><a href="#topic+clusterCor_c">clusterCor_c</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myPearson(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myPearson_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="myPearson_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simply calculates Pearson's product-moment correlation
between vectors <code>x</code> and <code>y</code>.
</p>

<hr>
<h2 id='plot.clustering'>Plot method for the &quot;clustering&quot; object.</h2><span id='topic+plot.clustering'></span>

<h3>Description</h3>

<p>plot the clustering object returned by <code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clustering'
plot(x, k, sort = FALSE, xaxis, axes = 1:2,
  pch = 16, ylabh = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.clustering_+3A_x">x</code></td>
<td>
<p>a &quot;clustering&quot; object as returned by
<code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code></p>
</td></tr>
<tr><td><code id="plot.clustering_+3A_k">k</code></td>
<td>
<p>a numeric or string vector indicating the clusterings to be plotted;
specifically the column numbers or names in the matrix of clusterings
in <code>cset$clusters</code>; if missing all columns will be plotted
and the calling code must take care of properly assigning <code>par(mfcol)</code>
or <code>layout</code> for the plot</p>
</td></tr>
<tr><td><code id="plot.clustering_+3A_sort">sort</code></td>
<td>
<p>if <code>TRUE</code> and the clustering is yet unsorted a cluster
sorting will be calculated based on &quot;ccor&quot; cluster-cluster similarity
matrix <code>x$Ccc</code>; see <code><a href="#topic+sortClusters">sortClusters</a></code></p>
</td></tr>
<tr><td><code id="plot.clustering_+3A_xaxis">xaxis</code></td>
<td>
<p>optionally x-values to use as x-axis (e.g. to reflect absolute
chromosomal coordinates)</p>
</td></tr>
<tr><td><code id="plot.clustering_+3A_axes">axes</code></td>
<td>
<p>list of axes to plot, numbers as used as first argument
in function <code>axis</code></p>
</td></tr>
<tr><td><code id="plot.clustering_+3A_pch">pch</code></td>
<td>
<p>argument <code>pch</code> (symbol) for plot</p>
</td></tr>
<tr><td><code id="plot.clustering_+3A_ylabh">ylabh</code></td>
<td>
<p>plot &quot;clustering&quot; horizontally at y-axis</p>
</td></tr>
<tr><td><code id="plot.clustering_+3A_...">...</code></td>
<td>
<p>additional arguments to plot, eg. to set point <code>cex</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the input &quot;clustering&quot; object with (potentially new)
cluster sorting and colors as in shown in the plot
</p>

<hr>
<h2 id='plot.segments'>Plot method for the &quot;segments&quot; object.</h2><span id='topic+plot.segments'></span>

<h3>Description</h3>

<p>plot the final segmentation objects returned by
<code><a href="#topic+segmentClusters">segmentClusters</a></code> and <code><a href="#topic+segmentCluster.batch">segmentCluster.batch</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segments'
plot(x, plot = c("S", "segments"), types, params,
  xaxis, show.fused = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.segments_+3A_x">x</code></td>
<td>
<p>a segmentation object as returned by
<code><a href="#topic+segmentClusters">segmentClusters</a></code> and <code><a href="#topic+segmentCluster.batch">segmentCluster.batch</a></code></p>
</td></tr>
<tr><td><code id="plot.segments_+3A_plot">plot</code></td>
<td>
<p>string vector indicating which data should be plotted;
&quot;segments&quot;: plot segments as arrows; &quot;S1&quot; plot the scoring vectors
<code>s(i,j,c</code> for all <code>c</code>; &quot;S&quot; plot the derivative of
matrix <code>S(i,c)</code> for all <code>c</code></p>
</td></tr>
<tr><td><code id="plot.segments_+3A_types">types</code></td>
<td>
<p>a string vector indicating segment types to plot (a subset of
<code>x$ids</code>; defaults to all in <code>x$ids</code>)</p>
</td></tr>
<tr><td><code id="plot.segments_+3A_params">params</code></td>
<td>
<p>a named vector of parameter settings used in
<code><a href="#topic+segmentCluster.batch">segmentCluster.batch</a></code> allows to filter plotted segment
types, e.g. params=c(S=&quot;icor&quot;) will only plot segments where
the scoring function (parameter S) &quot;icor&quot; was used.</p>
</td></tr>
<tr><td><code id="plot.segments_+3A_xaxis">xaxis</code></td>
<td>
<p>optional x-values to use as x-axis (e.g. to reflect absolute
chromosomal coordinates)</p>
</td></tr>
<tr><td><code id="plot.segments_+3A_show.fused">show.fused</code></td>
<td>
<p>show the fuse tag as a black x</p>
</td></tr>
<tr><td><code id="plot.segments_+3A_...">...</code></td>
<td>
<p>additional arguments forwarded to
<code><a href="graphics.html#topic+arrows">arrows</a></code>, eg. to set <code>lwd</code> for
for <code>plot="segments"</code>, or to <code><a href="graphics.html#topic+matplot">matplot</a></code>
for <code>plot="S"</code></p>
</td></tr>
</table>

<hr>
<h2 id='plot.timeseries'>Plot method for the &quot;timeseries&quot; object.</h2><span id='topic+plot.timeseries'></span>

<h3>Description</h3>

<p>plot the processed time-series object returned from
<code><a href="#topic+processTimeseries">processTimeseries</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timeseries'
plot(x, plot = c("total", "timeseries"), xaxis,
  ylabh = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.timeseries_+3A_x">x</code></td>
<td>
<p>a time-series object as returned by
<code><a href="#topic+processTimeseries">processTimeseries</a></code></p>
</td></tr>
<tr><td><code id="plot.timeseries_+3A_plot">plot</code></td>
<td>
<p>a string vector indicating the values to be plotted;
&quot;total&quot;: plot of the total signal, summed over
the time-points, and indicating the applied threshold <code>low.thresh</code>;
note that the total levels may have been transformed (e.g. by
<code><a href="#topic+log_1">log_1</a></code> or <code><a href="#topic+ash">ash</a></code>) depending on the arguments
<code>trafo</code> and <code>dc.trafo</code> in <code><a href="#topic+processTimeseries">processTimeseries</a></code>;
&quot;timeseries&quot;: plot the complete time-series as a heatmap, where time is
plotted bottom-up on the y-axis and segmentation coordinates on the x-axis;</p>
</td></tr>
<tr><td><code id="plot.timeseries_+3A_xaxis">xaxis</code></td>
<td>
<p>x-values to use as x-axis (e.g. to reflect absolute
chromosomal coordinates)</p>
</td></tr>
<tr><td><code id="plot.timeseries_+3A_ylabh">ylabh</code></td>
<td>
<p>plot y-axis title horizontally</p>
</td></tr>
<tr><td><code id="plot.timeseries_+3A_...">...</code></td>
<td>
<p>additional arguments to plot of total signal</p>
</td></tr>
</table>

<hr>
<h2 id='plotdev'>Switch between plot devices.</h2><span id='topic+plotdev'></span>

<h3>Description</h3>

<p>Switch between plot devices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdev(file.name = "test", type = "png", width = 5, height = 5,
  res = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotdev_+3A_file.name">file.name</code></td>
<td>
<p>file name without suffix (.png, etc)</p>
</td></tr>
<tr><td><code id="plotdev_+3A_type">type</code></td>
<td>
<p>plot type: png, jpeg, eps, pdf, tiff or svg</p>
</td></tr>
<tr><td><code id="plotdev_+3A_width">width</code></td>
<td>
<p>figure width in inches</p>
</td></tr>
<tr><td><code id="plotdev_+3A_height">height</code></td>
<td>
<p>figure height in inches</p>
</td></tr>
<tr><td><code id="plotdev_+3A_res">res</code></td>
<td>
<p>resolution in ppi (pixels per inch), only for types png,
jpeg and tiff</p>
</td></tr>
</table>

<hr>
<h2 id='plotSegmentation'>Summary plot for the <code>segmenTier</code> pipeline.</h2><span id='topic+plotSegmentation'></span>

<h3>Description</h3>

<p>Plot all objects from the segmentation pipeline, i.e. the processed
time-series, the clustering, the internal scoring matrices and
the final segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSegmentation(tset, cset, sset, split = FALSE, plot.matrix = FALSE,
  mai = c(0.01, 2, 0.01, 0.01), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSegmentation_+3A_tset">tset</code></td>
<td>
<p>a time-series object as returned by
<code><a href="#topic+processTimeseries">processTimeseries</a></code></p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_cset">cset</code></td>
<td>
<p>a clusterings object as returned by
<code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code></p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_sset">sset</code></td>
<td>
<p>a segmentation object as returned by
<code><a href="#topic+segmentClusters">segmentClusters</a></code> and <code><a href="#topic+segmentCluster.batch">segmentCluster.batch</a></code></p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_split">split</code></td>
<td>
<p>split segment plots by clustering plots</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_plot.matrix">plot.matrix</code></td>
<td>
<p>include the internal scoring matrices in the plot</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_mai">mai</code></td>
<td>
<p>margins of individual plots, see <code>par</code></p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_...">...</code></td>
<td>
<p>further arguments to
<code><a href="#topic+plot.clustering">plot.clustering</a></code> (<code>cset</code>) and
<code><a href="#topic+plot.segments">plot.segments</a></code> (<code>sset</code>). Note: these may
conflict and cause errors, but eg. a combination of <code>cex=0.5, lwd=3</code>
works, affecting cluster point size and segment line width, respectively.</p>
</td></tr>
</table>

<hr>
<h2 id='print.segments'>Print method for segmentation result from <code><a href="#topic+segmentClusters">segmentClusters</a></code>.</h2><span id='topic+print.segments'></span>

<h3>Description</h3>

<p>Print method for segmentation result from <code><a href="#topic+segmentClusters">segmentClusters</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'segments'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.segments_+3A_x">x</code></td>
<td>
<p>result object returned by function <code><a href="#topic+segmentClusters">segmentClusters</a></code></p>
</td></tr>
<tr><td><code id="print.segments_+3A_...">...</code></td>
<td>
<p>further argument to <code>print.data.frame</code></p>
</td></tr>
</table>

<hr>
<h2 id='processTimeseries'>Process a time-series for clustering and segmentation.</h2><span id='topic+processTimeseries'></span>

<h3>Description</h3>

<p>Prepares a time-series (time points in columns) for subsequent
clustering, and performs requested data transformations, including
a Discrete Fourier Transform (DFT) of the time-series, as direct
input for the clustering wrapper
<code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code>. When used for segmentation
the row order reflects the order of the data points along which
segmentation will occur. The function can also be used as a
stand-alone function equipped especially for analysis of
oscillatory time-series, including calculation of phases and
p-values for all DFT components, and can also be used for
Fourier Analysis and subsequent clustering without segmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processTimeseries(ts, na2zero = FALSE, trafo = "raw",
  use.fft = FALSE, dc.trafo = "raw", dft.range, perm = 0,
  use.snr = FALSE, lambda = 1, low.thresh = -Inf, smooth.space = 1,
  smooth.time = 1, circular.time = FALSE, verb = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processTimeseries_+3A_ts">ts</code></td>
<td>
<p>a time-series as a matrix, where columns are the
time points and rows are ordered measurements, e.g., genomic
positions for transcriptome data</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_na2zero">na2zero</code></td>
<td>
<p>interpret NA values as 0</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_trafo">trafo</code></td>
<td>
<p>prior data transformation, pass any function name,
e.g., &quot;log&quot;, or the package functions &quot;ash&quot; (asinh:
<code>ash(x) = log(x + sqrt(x^2+1))</code>) or &quot;log_1&quot;
(<code>log(ts+1)</code>)</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_use.fft">use.fft</code></td>
<td>
<p>use the Discrete Fourier Transform of the data</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_dc.trafo">dc.trafo</code></td>
<td>
<p>data transformation for the first (DC) component of
the DFT, pass any function name, e.g., &quot;log&quot;, or the package
functions &quot;ash&quot; (asinh: <code>ash(x) = log(x + sqrt(x^2+1))</code>)
or &quot;log_1&quot; (<code>log(x+1)</code>).</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_dft.range">dft.range</code></td>
<td>
<p>a vector of integers, giving the components of the
Discrete Fourier Transform to be used where 1 is the first
component (DC) corresponding to the total signal (sum over all
time points), and 2:n are the higher components corresponding
to 2:n full cycles in the data</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_perm">perm</code></td>
<td>
<p>number of permutations of the data set, to obtain
p-values for the oscillation</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_use.snr">use.snr</code></td>
<td>
<p>use a scaled amplitude, where each component of the
Discrete Fourier Transform is divided by the mean of all other
components (without the first or DC component), a normalization
that can be interpreted to reflect a signal-to-noise ratio
(SNR)</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_lambda">lambda</code></td>
<td>
<p>parameter lambda for Box-Cox transformation of DFT
amplitudes (experimental; not tested)</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_low.thresh">low.thresh</code></td>
<td>
<p>use this threshold to cut-off data, which will be
added to the absent/nuisance cluster later</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_smooth.space">smooth.space</code></td>
<td>
<p>integer, if set a moving average is calculated
for each time-point between adjacent data points using stats
package's <code><a href="stats.html#topic+smooth">smooth</a></code> with option
<code>span=smooth.space</code></p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_smooth.time">smooth.time</code></td>
<td>
<p>integer, if set the time-series will be smoothed
using stats package's <code><a href="stats.html#topic+filter">filter</a></code> to
calculate a moving average with span <code>smooth.time</code> and
<code><a href="stats.html#topic+smoothEnds">smoothEnds</a></code> to extrapolate
smoothed first and last time-points (again using span
<code>smooth.time</code>)</p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_circular.time">circular.time</code></td>
<td>
<p>logical value indicating whether time can be
treated as circular in smoothing via option <code>smooth.time</code></p>
</td></tr>
<tr><td><code id="processTimeseries_+3A_verb">verb</code></td>
<td>
<p>level of verbosity, 0: no output, 1: progress messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exemplifies the processing of an oscillatory
transcriptome time-series data as used in the establishment of this
algorithm and the demo <code>segment_data</code>. As suggested by Machne &amp; Murray
(PLoS ONE 2012) and Lehmann et al. (BMC Bioinformatics 2014) a Discrete
Fourier Transform of time-series data allows to cluster time-series by
their change pattern. 
</p>
<p>Note that NA values are here interpreted as 0. Please take care of NA
values yourself, if you do not want this behavior.
</p>
<p>Rows consisting only of 0 (or NA) values, or with a total signal
(sum over all time points) below the value passed in argument
<code>low.thresh</code>, are detected, result in NA values in the
transformed data, and will be assigned to the
&quot;nuisance&quot; cluster in <code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code>.
</p>
<p>Discrete Fourier Transform (DFT): if requested (option
<code>use.fft=TRUE</code>), a DFT will be applied using base R's
<code><a href="stats.html#topic+fft">mvfft</a></code> function and reporting all or only
requested (option <code>dft.range</code>) DFT components, where the
first, or DC (&quot;direct current&quot;) component, equals the total signal
(sum over all points) and other components are numbered 1:n,
reflecting the number of full cycles in the time-series. Values are
reported as complex numbers, from which both amplitude and phase
can be calculated.  All returned DFT components will be used by
<code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code>.
</p>
<p>Additional Transformations: data can be transformed prior to DFT
(options <code>trafo</code>, <code>smooth.time</code>, <code>smooth.space</code>), or
after DFT (options <code>use.snr</code> and <code>dc.trafo</code>). It is
recommended to use the amplitude scaling (a signal-to-noise ratio
transformation, see option documentation).  The separate
transformation of the DC component allows to de-emphasize the total
signal in subsequent clustering &amp; segmentation.  Additionally, but
not tested in the context of segmentation, a Box-Cox transformation
of the DFT can be performed (option <code>lambda</code>).  This
transformation proofed useful in DFT-based clustering with the
model-based clustering algorithm in package <span class="pkg">flowClust</span>, and is
available here for further tests with k-means clustering.
</p>
<p>Phase, Amplitude and Permutation Analysis: this time-series
processing and subsequent clustering can also be used without
segmentation, eg. for conventional microarray data or RNA-seq data
already mapped to genes. The option <code>perm</code> allows to perform a
permutation test (<code>perm</code> times) and adds a matrix of empirical
p-values for all DFT components to the results object, ie. the
fraction of <code>perm</code> where amplitude was higher then the
amplitude of the randomized time-series.  Phases and amplitudes can
be derived from the complex numbers in matrix &quot;dft&quot; of the result
object.
</p>


<h3>Value</h3>

<p>Returns a list of class &quot;timeseries&quot; which comprises of
the transformed time-series and additional information, such as
the total signal, and positions of rows with only NA/0
values. Note that NA values are interpreted as 0.
</p>


<h3>References</h3>

<p>Machne &amp; Murray (2012)
&lt;doi:10.1371/journal.pone.0037906&gt;, and Lehmann et al. (2013)
&lt;doi:10.1186/1471-2105-14-133&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primseg436)
## The input data is a matrix with time points in columns
## and a 1D order, here 7624 genome positions, is reflected in rows,
## if the time-series should be segmented.
nrow(tsd)
## Time-series processing prepares the data for clustering,
## the example data is periodic, and we will cluster its Discrete Fourier
## Transform (DFT) rather then the original data. Specifically we will
## only use components 1 to 7 of the DFT (dft.range) and also apply
## a signal/noise ratio normalization, where each component is
## divided by the mean of all other components. To de-emphasize
## total levels the first component (DC for "direct current") of the
## DFT will be separately arcsinh transformed. This peculiar combination
## proofed best for our data:
tset &lt;- processTimeseries(ts=tsd, na2zero=TRUE, use.fft=TRUE,
                          dft.range=1:7, dc.trafo="ash", use.snr=TRUE)
## a plot method exists for the returned time-series class:
par(mfcol=c(2,1))
plot(tset)
</code></pre>

<hr>
<h2 id='segmentCluster.batch'>Batch wrapper for <code><a href="#topic+segmentClusters">segmentClusters</a></code>.</h2><span id='topic+segmentCluster.batch'></span>

<h3>Description</h3>

<p>A high-level wrapper for multiple runs of segmentation by
<code><a href="#topic+segmentClusters">segmentClusters</a></code> for multiple clusterings and/or
multiple segmentation parameters. It additionally allows to
tag adjacent segments to be potentially fused due to similarity
of their clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentCluster.batch(cset, varySettings = setVarySettings(),
  fuse.threshold = 0.2, rm.nui = TRUE, type.name, short.name = TRUE,
  id, save.matrix = FALSE, verb = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentCluster.batch_+3A_cset">cset</code></td>
<td>
<p>a clustering set as returned by <code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code></p>
</td></tr>
<tr><td><code id="segmentCluster.batch_+3A_varysettings">varySettings</code></td>
<td>
<p>list of settings where each entry can be a vector;
the function will construct a matrix of all possible combinations of
parameter values in this list, call <code><a href="#topic+segmentClusters">segmentClusters</a></code> for
each, and report a matrix of segments where the segment &lsquo;type&rsquo; is
constructed from the varied parameters; see option <code>short.name</code>.
A varySettings list with all required (default) parameters can be
obtained via function <code><a href="#topic+setVarySettings">setVarySettings</a></code>.</p>
</td></tr>
<tr><td><code id="segmentCluster.batch_+3A_fuse.threshold">fuse.threshold</code></td>
<td>
<p>if adjacent segments are associated with clusters
the centers of which have a Pearson correlation <code>&gt;fuse.threshold</code>
the field &quot;fuse&quot; will be set to 1 for the second segments (top-to-bottom
as reported)</p>
</td></tr>
<tr><td><code id="segmentCluster.batch_+3A_rm.nui">rm.nui</code></td>
<td>
<p>remove nuisance cluster segments from final results</p>
</td></tr>
<tr><td><code id="segmentCluster.batch_+3A_type.name">type.name</code></td>
<td>
<p>vector of strings selecting the parameters which will be
used as segment types. Note, that all parameters that are actually varied
will be automatically added (if missing). The list can include parameters
from time-series processing found in the &quot;clustering&quot; object <code>cset</code>
as <code>cset$tids</code>.</p>
</td></tr>
<tr><td><code id="segmentCluster.batch_+3A_short.name">short.name</code></td>
<td>
<p>default type name construction; if TRUE (default)
parameters that are not varied will not be part of the segment type and ID.
This argument has no effect if argument <code>type.name</code> is set.</p>
</td></tr>
<tr><td><code id="segmentCluster.batch_+3A_id">id</code></td>
<td>
<p>if set, the default segment IDs, constructed from numbered
segment types, are replaced by this</p>
</td></tr>
<tr><td><code id="segmentCluster.batch_+3A_save.matrix">save.matrix</code></td>
<td>
<p>store the total score matrix <code>S(i,c)</code> and the
backtracing matrix <code>K(i,c)</code>; useful in testing stage or for
debugging or illustration of the algorithm;
TODO: save.matrix is currently not implemented, since batch function
returns a matrix only</p>
</td></tr>
<tr><td><code id="segmentCluster.batch_+3A_verb">verb</code></td>
<td>
<p>level of verbosity, 0: no output, 1: progress messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a high-level wrapper for <code><a href="#topic+segmentClusters">segmentClusters</a></code>
which allows segmentation over multiple clusterings as provided by the
function <code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code> and over multiple segmentation
parameters. Each parameter in the list <code>varySettings</code> can be
a vector and ALL combinations of the passed parameter values will
be used for one run of <code><a href="#topic+segmentClusters">segmentClusters</a></code>.
The resulting segment table, list item &quot;segments&quot; of the returned object,
is a <code><a href="base.html#topic+data.frame">data.frame</a></code> with additional
columns &quot;ID&quot; and &quot;type&quot;, automatically generated strings indicating
the used parameters (each &quot;type&quot; reflects one parameter set), and
&quot;colors&quot;, indicating the automatically generated color of the assigned
cluster label.
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;segments&quot;, just as its base function
<code><a href="#topic+segmentClusters">segmentClusters</a></code>, but the main segment table, list item
&quot;segments&quot;, is a <code><a href="base.html#topic+data.frame">data.frame</a></code> with additional
columns &quot;ID&quot; and &quot;type&quot;, automatically generated strings indicating
the used parameters (each &quot;type&quot; reflects one parameter set), and
&quot;colors&quot;, indicating the automatically generated color of the assigned
cluster label.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data, an RNA-seq time-series data from a short genomic
# region of budding yeast
data(primseg436)

# 1) Fourier-transform time series:
tset &lt;- processTimeseries(ts=tsd, na2zero=TRUE, use.fft=TRUE,
                          dft.range=1:7, dc.trafo="ash", use.snr=TRUE)

# 2) cluster time-series several times into K=12 clusters:
cset &lt;- clusterTimeseries(tset, K=c(12,12,12))

# 3) choose parameter ranges, here only E is varied 
vary &lt;- setVarySettings(M=100, E=c(1,3), nui=3, S="icor", Mn=20)

# 4) ... segment ALL using the batch function:
## Not run:  ## NOTE: takes too long for CRAN example timing restrictions
segments &lt;- segmentCluster.batch(cset=cset, varySettings=vary)

# 5) inspect results:
print(segments)
plotSegmentation(tset, cset, segments)

# 6) and get segment border table. Note that the table has
#    additional columns "ID" and "type", indicating the used parameters,
#    and "color" providing the color of the cluster the segment was
#    assigned to. This allows to track segments in the inspection plots.
sgtable &lt;- segments$segments

## End(Not run)

</code></pre>

<hr>
<h2 id='segmentClusters'>Run the <code>segmenTier</code> algorithm.</h2><span id='topic+segmentClusters'></span>

<h3>Description</h3>

<p>segmenTier's main wrapper interface, calculates segments from a
clustering sequence. This will run the segmentation algorithm once
for the indicated parameters. The function
<code><a href="#topic+segmentCluster.batch">segmentCluster.batch</a></code> allows for multiple runs over
different parameters or input-clusterings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentClusters(seq, k = 1, csim, E = 1, S = "ccor", M = 175,
  Mn = 20, a = -2, nui = 1, nextmax = TRUE, multi = "max",
  multib = "max", rm.nui = TRUE, save.matrix = FALSE, verb = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentClusters_+3A_seq">seq</code></td>
<td>
<p>Either an integer vector of cluster labels, or a
structure of class 'clustering' as returned by
<code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code>. The only strict requirement
for the first option is that nuisance clusters (which will be
treated specially during the dynamic programming routine) have
to be '0' (zero).</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_k">k</code></td>
<td>
<p>if argument <code>seq</code> is of class 'clustering' the kth
clustering will be used; defaults to 1</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_csim">csim</code></td>
<td>
<p>The cluster-cluster or position-cluster similarity
matrix for scoring functions &quot;ccor&quot; and &quot;icor&quot; (option
<code>S</code>), respectively. If <code>seq</code> is of class 'clustering'
<code>csim</code> is optional and will override the similarity
matrices in <code>seq</code>. If argument <code>seq</code> is a simple
vector of cluster labels and the scoring function is &quot;icor&quot; or
&quot;ccor&quot;, an appropriate matrix <code>csim</code> MUST be
provided. Finally, for scoring function &quot;ccls&quot; the argument
<code>csim</code> will be ignored and the matrix is instead
automatically constructed from argument <code>a</code>, and using
argument <code>nui</code> for the nuisance cluster.</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_e">E</code></td>
<td>
<p>exponent to scale similarity matrices</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_s">S</code></td>
<td>
<p>the scoring function to be used: &quot;ccor&quot;, &quot;icor&quot; or &quot;ccls&quot;</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_m">M</code></td>
<td>
<p>segment length penalty. Note, that this is not a strict
cut-off but defined as a penalty that must be &quot;overcome&quot; by
good score.</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_mn">Mn</code></td>
<td>
<p>segment length penalty for nuisance cluster. Mn&lt;M will
allow shorter distances between &quot;real&quot; segments; only used in
scoring functions &quot;ccor&quot; and &quot;icor&quot;</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_a">a</code></td>
<td>
<p>a cluster &quot;dissimilarity&quot; only used for pure cluster-based
scoring w/o cluster similarity measures in scoring function
&quot;ccls&quot;.</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_nui">nui</code></td>
<td>
<p>the similarity score to be used for nuisance clusters
in the cluster similarity matrices</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_nextmax">nextmax</code></td>
<td>
<p>go backwards while score is increasing before
opening a new segment, default is TRUE</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_multi">multi</code></td>
<td>
<p>handling of multiple k with max. score in forward
phase, either &quot;min&quot; (default) or &quot;max&quot;</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_multib">multib</code></td>
<td>
<p>handling of multiple k with max. score in back-trace
phase, either &quot;min&quot; (default), &quot;max&quot; or &quot;skip&quot;</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_rm.nui">rm.nui</code></td>
<td>
<p>remove nuisance cluster segments from final results</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_save.matrix">save.matrix</code></td>
<td>
<p>store the total score matrix <code>S(i,c)</code> and
the backtracing matrix <code>K(i,c)</code>; useful in testing stage
or for debugging or illustration of the algorithm;</p>
</td></tr>
<tr><td><code id="segmentClusters_+3A_verb">verb</code></td>
<td>
<p>level of verbosity, 0: no output, 1: progress messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main R wrapper function for the &lsquo;segmenTier&rsquo;
segmentation algorithm. It takes an ordered sequence of cluster
labels and returns segments of consistent clusterings, where
cluster-cluster or cluster-position similarities are
maximal. Its main input (argument <code>seq</code>) is either a
&quot;clustering&quot; object returned by <code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code>
(scenario I), or an integer vector of cluster labels (scenario
II) or. The function then runs the dynamic programming algorithm
(<code><a href="#topic+calculateScore">calculateScore</a></code>) for a selected scoring function
and an according cluster similarity matrix, followed by the
back-tracing step (<code><a href="#topic+backtrace">backtrace</a></code>) to find segment
borders.
</p>
<p>The main result, list item &quot;segments&quot; of the returned 
object, is a 3-column matrix, where column 1 is the cluster
assignment and columns 2 and 3 are start and end indices of the
segments. For the batch function <code><a href="#topic+segmentCluster.batch">segmentCluster.batch</a></code>,
the &quot;segments&quot; item is a <code><a href="base.html#topic+data.frame">data.frame</a></code>
contain additional information, see ?segmentCluster.batch.
</p>
<p>As shown in the publication, the parameters <code>M</code>,
<code>E</code> and <code>nui</code> have the strongest impact on resulting
segment borders.  Other parameters can be fine-tuned but had
little impact on our test data set.
</p>
<p>In the default and tested scenario I, when the input is an object
of class &quot;clustering&quot; produced by <code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code>,
the cluster-cluster and cluster-position similarity matrices are
already provided by this object.
</p>
<p>In the second scenario II for custom use, argument <code>seq</code> can
be a simple clustering vector, where a nuisance cluster must be
indicated by cluster label &quot;0&quot; (zero). The cluster-cluster or
cluster-position similarities MUST be provided (argument
<code>csim</code>) for scoring functions &quot;ccor&quot; and &quot;icor&quot;,
respectively. For the simplest scoring function &quot;ccls&quot;, a uniform
cluster similarity matrix is constructed from arguments <code>a</code>
and <code>nui</code>, with cluster self-similarities of 1,
&quot;dissimilarities&quot; between different clusters using argument
<code>a&lt;0</code>, and nuisance cluster self-similarity of <code>-a</code>.
</p>
<p>The function returns a list (class &quot;segments&quot;) comprising of the
main result (list item &quot;segments&quot;), and &quot;warnings&quot; from the dynamic
programming and backtracing phases, the used similarity matrix
<code>csim</code>, extended by the nuisance cluster; and optionally (see
option <code>save.matrix</code>) the scoring vectors <code>S1(i,c)</code>, the
total score matrix <code>S(i,c)</code> and the backtracing matrix
<code>K(i,c)</code> for analysis of algorithm performance for novel data
sets.  Additional convenience data is reported, such as cluster
colors and sortings if argument <code>seq</code> was of class
'clustering'. These allow for convenient inspection of all data
processing steps with the plot methods. A plot method exists that
allows to plot segments aligned to &quot;timeseries&quot; and &quot;clustering&quot;
plots.
</p>


<h3>Value</h3>

<p>Returns a list (class &quot;segments&quot;) containing the main
result (list item &quot;segments&quot;), and additional information (see
&lsquo;Details&rsquo;). A plot method exists that allows to plot clusters
aligned to time-series and segmentation plots.
</p>


<h3>References</h3>

<p>Machne, Murray &amp; Stadler (2017)
&lt;doi:10.1038/s41598-017-12401-8&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data, an RNA-seq time-series data from a short genomic region
# of budding yeast
data(primseg436)

# 1) Fourier-transform time series:
## NOTE: reducing official example data set to stay within 
## CRAN example timing restrictions with segmentation below
tset &lt;- processTimeseries(ts=tsd[2500:6500,], na2zero=TRUE, use.fft=TRUE,
                          dft.range=1:7, dc.trafo="ash", use.snr=TRUE)

# 2) cluster time-series into K=12 clusters:
cset &lt;- clusterTimeseries(tset, K=12)

# 3) ... segment it; this takes a few seconds:
segments &lt;- segmentClusters(seq=cset, M=100, E=2, nui=3, S="icor")

# 4) inspect results:
print(segments)
plotSegmentation(tset, cset, segments, cex=.5, lwd=3)

# 5) and get segment border table for further processing:
sgtable &lt;- segments$segments

</code></pre>

<hr>
<h2 id='setVarySettings'>Parameters for <code><a href="#topic+segmentCluster.batch">segmentCluster.batch</a></code>.</h2><span id='topic+setVarySettings'></span>

<h3>Description</h3>

<p>Generates the parameter list (<code>varySettings</code>) for
<code><a href="#topic+segmentCluster.batch">segmentCluster.batch</a></code>, using defaults
for all parameters not passed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setVarySettings(E = c(1, 3), S = "ccor", M = 100, Mn = 100,
  a = -2, nui = c(1, 3), nextmax = TRUE, multi = "max",
  multib = "max")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setVarySettings_+3A_e">E</code></td>
<td>
<p>exponent to scale similarity matrices</p>
</td></tr>
<tr><td><code id="setVarySettings_+3A_s">S</code></td>
<td>
<p>the scoring function to be used: &quot;ccor&quot;, &quot;icor&quot; or &quot;ccls&quot;</p>
</td></tr>
<tr><td><code id="setVarySettings_+3A_m">M</code></td>
<td>
<p>segment length penalty. Note, that this is not a strict
cut-off but defined as a penalty that must be &quot;overcome&quot; by
good score.</p>
</td></tr>
<tr><td><code id="setVarySettings_+3A_mn">Mn</code></td>
<td>
<p>segment length penalty for nuisance cluster. Mn&lt;M will
allow shorter distances between &quot;real&quot; segments; only used in
scoring functions &quot;ccor&quot; and &quot;icor&quot;</p>
</td></tr>
<tr><td><code id="setVarySettings_+3A_a">a</code></td>
<td>
<p>a cluster &quot;dissimilarity&quot; only used for pure cluster-based
scoring w/o cluster similarity measures in scoring function
&quot;ccls&quot;.</p>
</td></tr>
<tr><td><code id="setVarySettings_+3A_nui">nui</code></td>
<td>
<p>the similarity score to be used for nuisance clusters
in the cluster similarity matrices</p>
</td></tr>
<tr><td><code id="setVarySettings_+3A_nextmax">nextmax</code></td>
<td>
<p>go backwards while score is increasing before
opening a new segment, default is TRUE</p>
</td></tr>
<tr><td><code id="setVarySettings_+3A_multi">multi</code></td>
<td>
<p>handling of multiple k with max. score in forward
phase, either &quot;min&quot; (default) or &quot;max&quot;</p>
</td></tr>
<tr><td><code id="setVarySettings_+3A_multib">multib</code></td>
<td>
<p>handling of multiple k with max. score in back-trace
phase, either &quot;min&quot; (default), &quot;max&quot; or &quot;skip&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a parameter settings structure that can be used
in the batch function <code><a href="#topic+segmentCluster.batch">segmentCluster.batch</a></code>.
</p>

<hr>
<h2 id='sortClusters'>Sort clusters by similarity.</h2><span id='topic+sortClusters'></span>

<h3>Description</h3>

<p>Takes a &quot;clustering&quot; object as returned by
<code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code> and uses the cluster-cluster
similarity matrix, item <code>Ccc</code>, to sort clusters by their
similarity, starting with the cluster labeled &lsquo;1&rsquo;; the next
cluster is the first cluster (lowest cluster label) with the
highest similarity to cluster &lsquo;1&rsquo;, and proceeding from there. The
final sorting is added as item &quot;sorting&quot; to the <code>cset</code> object
and returned.  This sorting is subsequently used to select cluster
colors and in the plot method. This simply allows for more
informative plots of the clustering underlying a segmentation but
has no consequence on segmentation itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortClusters(cset, sort = TRUE, verb = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortClusters_+3A_cset">cset</code></td>
<td>
<p>a clustering set as returned by
<code><a href="#topic+clusterTimeseries">clusterTimeseries</a></code></p>
</td></tr>
<tr><td><code id="sortClusters_+3A_sort">sort</code></td>
<td>
<p>if set to FALSE the clusters will be sorted merely
numerically</p>
</td></tr>
<tr><td><code id="sortClusters_+3A_verb">verb</code></td>
<td>
<p>level of verbosity, 0: no output, 1: progress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input &quot;clustering&quot; object with a list of
vectors (named &quot;sorting&quot;), each providing a similarity-based
sorting of cluster labels.
</p>

<hr>
<h2 id='tsd'>Transcriptome time-series from budding yeast.</h2><span id='topic+tsd'></span>

<h3>Description</h3>

<p>Transcriptome time-series data from a region encompassing
four genes and a regulatory upstream non-coding RNA in budding yeast.
The data set is described in more detail in the publication
Machne, Murray &amp; Stadler (2017) &lt;doi:10.1038/s41598-017-12401-8&gt;.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
