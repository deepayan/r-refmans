<!DOCTYPE html><html><head><title>Help for package kairos</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kairos}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aoristic'><p>Aoristic Analysis</p></a></li>
<li><a href='#AoristicSum-class'><p>Aoristic Sum</p></a></li>
<li><a href='#apportion'><p>Chronological Apportioning</p></a></li>
<li><a href='#CountApportion-class'><p>Count Apportioning</p></a></li>
<li><a href='#data.frame'><p>Coerce to a Data Frame</p></a></li>
<li><a href='#event'><p>Event and Accumulation Dates</p></a></li>
<li><a href='#EventDate-class'><p>Date Model</p></a></li>
<li><a href='#fit'><p>Frequency Increment Test</p></a></li>
<li><a href='#IncrementTest-class'><p>Frequency Increment Test</p></a></li>
<li><a href='#kairos-deprecated'><p>Deprecated Functions in kairos</p></a></li>
<li><a href='#kairos-package'><p>kairos: Analysis of Chronological Patterns from Archaeological Count Data</p></a></li>
<li><a href='#mcd'><p>Mean Ceramic Date</p></a></li>
<li><a href='#MeanDate-class'><p>Mean Date</p></a></li>
<li><a href='#model'><p>Extract Model Results</p></a></li>
<li><a href='#mutators'><p>Get or Set Parts of an Object</p></a></li>
<li><a href='#PermutationOrder-class'><p>Permutation Order</p></a></li>
<li><a href='#permute'><p>Rearranges a Data Matrix</p></a></li>
<li><a href='#plot_aoristic'><p>Plot Aoristic Analysis</p></a></li>
<li><a href='#plot_event'><p>Event Plot</p></a></li>
<li><a href='#plot_fit'><p>Detection of Selective Processes</p></a></li>
<li><a href='#plot_mcd'><p>MCD Plot</p></a></li>
<li><a href='#plot_time'><p>Abundance vs Time Plot</p></a></li>
<li><a href='#predict_event'><p>Predict Event and Accumulation Dates</p></a></li>
<li><a href='#RateOfChange-class'><p>Rate of Change</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#RefinePermutationOrder-class'><p>Partial Bootstrap CA</p></a></li>
<li><a href='#resample_event'><p>Resample Event Dates</p></a></li>
<li><a href='#resample_mcd'><p>Resample Mean Ceramic Dates</p></a></li>
<li><a href='#roc'><p>Rate of Change</p></a></li>
<li><a href='#seriate_average'><p>Correspondence Analysis-Based Seriation</p></a></li>
<li><a href='#seriate_rank'><p>Reciprocal Ranking Seriation</p></a></li>
<li><a href='#seriate_refine'><p>Refine CA-based Seriation</p></a></li>
<li><a href='#series'><p>Sampling Times</p></a></li>
<li><a href='#subset'><p>Extract or Replace Parts of an Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis of Chronological Patterns from Archaeological Count
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit for absolute and relative dating and analysis of
    chronological patterns. This package includes functions for
    chronological modeling and dating of archaeological assemblages from
    count data. It provides methods for matrix seriation. It also allows
    to compute time point estimates and density estimates of the
    occupation and duration of an archaeological site.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://packages.tesselle.org/kairos/">https://packages.tesselle.org/kairos/</a>,
<a href="https://github.com/tesselle/kairos">https://github.com/tesselle/kairos</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tesselle/kairos/issues">https://github.com/tesselle/kairos/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), dimensio (&ge; 0.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>aion (&ge; 1.0.2), arkhe (&ge; 1.6.0), extraDistr, grDevices,
methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>folio (&ge; 1.4.0), knitr, markdown, rsvg, svglite, tabula (&ge;
3.0.1), tinysnapshot, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AllClasses.R' 'AllGenerics.R' 'aoristic.R' 'apportion.R'
'coerce.R' 'event_date.R' 'event_model.R' 'event_plot.R'
'event_resample.R' 'fit.R' 'kairos-deprecated.R'
'kairos-internal.R' 'kairos-package.R' 'mcd.R' 'mutators.R'
'permute.R' 'plot_time.R' 'reexport.R' 'seriate_average.R'
'seriate_rank.R' 'seriate_refine.R' 'show.R' 'subset.R'
'summary.R' 'validate.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-26 16:33:41 UTC; nicolas</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicolas Frerebeau <a href="https://orcid.org/0000-0001-5759-4944"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (Université Bordeaux Montaigne),
  Brice Lebrun <a href="https://orcid.org/0000-0001-7503-8685"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Université Bordeaux Montaigne),
  Ben Marwick <a href="https://orcid.org/0000-0001-7879-4531"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (University of Washington),
  Anne Philippe <a href="https://orcid.org/0000-0002-5331-5087"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Université de Nantes),
  Université Bordeaux Montaigne [fnd],
  CNRS [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Frerebeau &lt;nicolas.frerebeau@u-bordeaux-montaigne.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-26 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aoristic'>Aoristic Analysis</h2><span id='topic+aoristic'></span><span id='topic+aoristic-method'></span><span id='topic+aoristic+2Cnumeric+2Cnumeric-method'></span><span id='topic+aoristic+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Computes the aoristic sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aoristic(x, y, ...)

## S4 method for signature 'numeric,numeric'
aoristic(
  x,
  y,
  step = 1,
  start = min(x),
  end = max(y),
  calendar = CE(),
  weight = TRUE,
  groups = NULL
)

## S4 method for signature 'ANY,missing'
aoristic(
  x,
  step = 1,
  start = NULL,
  end = NULL,
  calendar = CE(),
  weight = TRUE,
  groups = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aoristic_+3A_x">x</code>, <code id="aoristic_+3A_y">y</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the lower and upper boundaries of the
time intervals, respectively. If <code>y</code> is missing, an attempt is made to
interpret <code>x</code> in a suitable way (see <code><a href="grDevices.html#topic+xy.coords">grDevices::xy.coords()</a></code>).</p>
</td></tr>
<tr><td><code id="aoristic_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="aoristic_+3A_step">step</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+integer">integer</a></code> vector giving the step size, i.e. the
width of each time step in the time series (defaults to <code class="reqn">1</code>,
i.e. annual level).</p>
</td></tr>
<tr><td><code id="aoristic_+3A_start">start</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the beginning of the time
window.</p>
</td></tr>
<tr><td><code id="aoristic_+3A_end">end</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the end of the time
window.</p>
</td></tr>
<tr><td><code id="aoristic_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the calendar of
<code>x</code> and <code>y</code> (see <code><a href="#topic+calendar">calendar()</a></code>). Defaults to Gregorian Common Era.</p>
</td></tr>
<tr><td><code id="aoristic_+3A_weight">weight</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the aoristic sum be weighted by
the length of periods (default). If <code>FALSE</code> the aoristic sum is the number
of elements within a time block.</p>
</td></tr>
<tr><td><code id="aoristic_+3A_groups">groups</code></td>
<td>
<p>A <code><a href="base.html#topic+factor">factor</a></code> vector in the sense that <code>as.factor(groups)</code>
defines the grouping. If <code>x</code> is a <code>list</code> (or a <code>data.frame</code>), <code>groups</code> can
be a length-one vector giving the index of the grouping component (column)
of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aoristic analysis is used to determine the probability of contemporaneity of
archaeological sites or assemblages. The aoristic analysis distributes the
probability of an event uniformly over each temporal fraction of the period
considered. The aoristic sum is then the distribution of the total number of
events to be assumed within this period.
</p>
<p>Muller and Hinz (2018) pointed out that the overlapping of temporal
intervals related to period categorization and dating accuracy is likely to
bias the analysis. They proposed a weighting method to overcome this
problem. This method is not implemented here (for the moment), see the
<a href="https://github.com/ISAAKiel/aoristAAR"><span class="pkg">aoristAAR</span> package</a>.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+AoristicSum-class">AoristicSum</a></code> object.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Crema, E. R. (2012). Modelling Temporal Uncertainty in Archaeological
Analysis. <em>Journal of Archaeological Method and Theory</em>, 19(3): 440-61.
<a href="https://doi.org/10.1007/s10816-011-9122-3">doi:10.1007/s10816-011-9122-3</a>.
</p>
<p>Johnson, I. (2004). Aoristic Analysis: Seeds of a New Approach to Mapping
Archaeological Distributions through Time. <em>In</em> Ausserer, K. F., Börner, W.,
Goriany, M. &amp; Karlhuber-Vöckl, L. (ed.), <em>Enter the Past - The E-Way into
the Four Dimensions of Cultural Heritage</em>, Oxford: Archaeopress, p. 448-52.
BAR International Series 1227.
<a href="https://doi.org/10.15496/publikation-2085">doi:10.15496/publikation-2085</a>
</p>
<p>Müller-Scheeßel, N. &amp; Hinz, M. (2018). <em>Aoristic Research in R: Correcting
Temporal Categorizations in Archaeology</em>. Presented at the Human History and
Digital Future (CAA 2018), Tubingen, March 21.
<a href="https://www.youtube.com/watch?v=bUBukex30QI">https://www.youtube.com/watch?v=bUBukex30QI</a>.
</p>
<p>Palmisano, A., Bevan, A. &amp; Shennan, S. (2017). Comparing Archaeological
Proxies for Long-Term Population Patterns: An Example from Central Italy.
<em>Journal of Archaeological Science</em>, 87: 59-72.
<a href="https://doi.org/10.1016/j.jas.2017.10.001">doi:10.1016/j.jas.2017.10.001</a>.
</p>
<p>Ratcliffe, J. H. (2000). Aoristic Analysis: The Spatial Interpretation of
Unspecific Temporal Events. <em>International Journal of Geographical
Information Science</em>, 14(7): 669-79. <a href="https://doi.org/10.1080/136588100424963">doi:10.1080/136588100424963</a>.
</p>
<p>Ratcliffe, J. H. (2002). Aoristic Signatures and the Spatio-Temporal
Analysis of High Volume Crime Patterns. <em>Journal of Quantitative
Criminology</em>, 18(1): 23-43. <a href="https://doi.org/10.1023/A%3A1013240828824">doi:10.1023/A:1013240828824</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc">roc()</a></code>, <code><a href="#topic+plot_aoristic">plot()</a></code>
</p>
<p>Other chronological analysis: 
<code><a href="#topic+apportion">apportion</a>()</code>,
<code><a href="#topic+fit">fit</a>()</code>,
<code><a href="#topic+roc">roc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Husi 2022
data("loire", package = "folio")

## Get time range
loire_range &lt;- loire[, c("lower", "upper")]

## Calculate aoristic sum (normal)
aorist_raw &lt;- aoristic(loire_range, step = 50, weight = FALSE)
plot(aorist_raw, col = "grey")

## Calculate aoristic sum (weights)
aorist_weighted &lt;- aoristic(loire_range, step = 50, weight = TRUE)
plot(aorist_weighted, col = "grey")

## Calculate aoristic sum (weights) by group
aorist_groups &lt;- aoristic(loire_range, step = 50, weight = TRUE,
                          groups = loire$area)
plot(aorist_groups, flip = TRUE, col = "grey")
image(aorist_groups)

## Rate of change
roc_weighted &lt;- roc(aorist_weighted, n = 30)
plot(roc_weighted)

## Rate of change by group
roc_groups &lt;- roc(aorist_groups, n = 30)
plot(roc_groups, flip = TRUE)
</code></pre>

<hr>
<h2 id='AoristicSum-class'>Aoristic Sum</h2><span id='topic+AoristicSum-class'></span><span id='topic+.AoristicSum'></span>

<h3>Description</h3>

<p>An S4 class to represent an aoristic analysis results.
</p>


<h3>Slots</h3>


<dl>
<dt><code>breaks</code></dt><dd><p>A <code><a href="aion.html#topic+RataDie-class">RataDie</a></code> vector giving the date break between
time-blocks.</p>
</dd>
<dt><code>weights</code></dt><dd><p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector.</p>
</dd>
<dt><code>groups</code></dt><dd><p>A <code><a href="base.html#topic+character">character</a></code> vector to store the group names (if any).</p>
</dd>
<dt><code>p</code></dt><dd><p>A <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+array">array</a></code> giving the aorisitic probabilities.</p>
</dd>
</dl>


<h3>Coerce</h3>

<p>In the code snippets below, <code>x</code> is an <code>AoristicSum</code> object.
</p>

<dl>
<dt><code>as.data.frame(x)</code></dt><dd><p>Coerces to a <code><a href="#topic+data.frame">data.frame</a></code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This class inherits from <code><a href="aion.html#topic+TimeSeries-class">aion::TimeSeries</a></code>: dates are internally
stored as <em><a href="aion.html#topic+RataDie-class">rata die</a></em>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+CountApportion-class">CountApportion-class</a></code>,
<code><a href="#topic+EventDate-class">EventDate-class</a></code>,
<code><a href="#topic+IncrementTest-class">IncrementTest-class</a></code>,
<code><a href="#topic+MeanDate-class">MeanDate-class</a></code>,
<code><a href="#topic+PermutationOrder-class">PermutationOrder-class</a></code>,
<code><a href="#topic+RateOfChange-class">RateOfChange-class</a></code>,
<code><a href="#topic+RefinePermutationOrder-class">RefinePermutationOrder-class</a></code>
</p>

<hr>
<h2 id='apportion'>Chronological Apportioning</h2><span id='topic+apportion'></span><span id='topic+apportion-method'></span><span id='topic+apportion+2Cdata.frame-method'></span><span id='topic+apportion+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Chronological Apportioning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apportion(object, ...)

## S4 method for signature 'data.frame'
apportion(
  object,
  s0,
  s1,
  t0,
  t1,
  from = min(s0),
  to = max(s1),
  step = 25,
  method = c("uniform", "truncated"),
  z = 2,
  progress = getOption("kairos.progress")
)

## S4 method for signature 'matrix'
apportion(
  object,
  s0,
  s1,
  t0,
  t1,
  from = min(s0),
  to = max(s1),
  step = 25,
  method = c("uniform", "truncated"),
  z = 2,
  progress = getOption("kairos.progress")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apportion_+3A_object">object</code></td>
<td>
<p>A <code class="reqn">m \times p</code> <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="#topic+data.frame">data.frame</a></code> of count data (absolute frequencies giving the number of
individuals for each category, i.e. a contingency table). A <code><a href="#topic+data.frame">data.frame</a></code>
will be coerced to a <code>numeric</code> <code>matrix</code> via <code><a href="base.html#topic+data.matrix">data.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="apportion_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="apportion_+3A_s0">s0</code></td>
<td>
<p>A length-<code class="reqn">m</code> <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the site beginning dates
expressed in CE years (BCE years must be given as negative numbers).</p>
</td></tr>
<tr><td><code id="apportion_+3A_s1">s1</code></td>
<td>
<p>A length-<code class="reqn">m</code> <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the site end dates
expressed in CE years (BCE years must be given as negative numbers).</p>
</td></tr>
<tr><td><code id="apportion_+3A_t0">t0</code></td>
<td>
<p>A length-<code class="reqn">p</code> <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the type beginning dates
expressed in CE years (BCE years must be given as negative numbers).</p>
</td></tr>
<tr><td><code id="apportion_+3A_t1">t1</code></td>
<td>
<p>A length-<code class="reqn">p</code> <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the type end dates
expressed in CE years (BCE years must be given as negative numbers).</p>
</td></tr>
<tr><td><code id="apportion_+3A_from">from</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the beginning of the
period of interest (in years CE).</p>
</td></tr>
<tr><td><code id="apportion_+3A_to">to</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the end of the period of
interest (in years CE).</p>
</td></tr>
<tr><td><code id="apportion_+3A_step">step</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+integer">integer</a></code> vector giving the step size, i.e. the
width of each time step for apportioning (in years CE; defaults to
<code class="reqn">25</code>).</p>
</td></tr>
<tr><td><code id="apportion_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the distribution to be used
(type popularity curve). It must be one of &quot;<code>uniform</code>&quot; (uniform
distribution) or &quot;<code>truncated</code>&quot; (truncated standard normal distribution).
Any unambiguous substring can be given.</p>
</td></tr>
<tr><td><code id="apportion_+3A_z">z</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> value giving the lower and upper truncation points
(defaults to <code class="reqn">2</code>). Only used if <code>method</code> is &quot;<code>truncated</code>&quot;.</p>
</td></tr>
<tr><td><code id="apportion_+3A_progress">progress</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should a progress bar be displayed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+CountApportion-class">CountApportion</a></code> object.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Roberts, J. M., Mills, B. J., Clark, J. J., Haas, W. R., Huntley, D. L. &amp;
Trowbridge, M. A. (2012). A Method for Chronological Apportioning of Ceramic
Assemblages. <em>Journal of Archaeological Science</em>, 39(5): 1513-20.
<a href="https://doi.org/10.1016/j.jas.2011.12.022">doi:10.1016/j.jas.2011.12.022</a>.
</p>


<h3>See Also</h3>

<p>Other chronological analysis: 
<code><a href="#topic+aoristic">aoristic</a>()</code>,
<code><a href="#topic+fit">fit</a>()</code>,
<code><a href="#topic+roc">roc</a>()</code>
</p>

<hr>
<h2 id='CountApportion-class'>Count Apportioning</h2><span id='topic+CountApportion-class'></span><span id='topic+.CountApportion'></span>

<h3>Description</h3>

<p>An S4 class to represent an artifact apportioning results. Gives the
apportioning of artifact types (columns) per site (rows) and per period
(dim. 3).
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>An <code class="reqn">m \times p \times k</code> <code><a href="base.html#topic+array">array</a></code> giving the
proportion of an artifact type (<code class="reqn">p</code>) for a given period (<code class="reqn">k</code>).</p>
</dd>
<dt><code>p</code></dt><dd><p>An <code class="reqn">m \times p \times k</code> <code><a href="base.html#topic+array">array</a></code> giving the
probability of apportioning an artifact type (<code class="reqn">p</code>) to a given period
(<code class="reqn">k</code>).</p>
</dd>
<dt><code>method</code></dt><dd><p>A <code><a href="base.html#topic+character">character</a></code> string specifying the distribution used for
apportioning (type popularity curve).</p>
</dd>
<dt><code>from</code></dt><dd><p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the beginning of the
period of interest (in years AD).</p>
</dd>
<dt><code>to</code></dt><dd><p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the end of the period of
interest (in years AD).</p>
</dd>
<dt><code>step</code></dt><dd><p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the step size, i.e. the
width of each time step for apportioning (in years AD).</p>
</dd>
</dl>


<h3>Note</h3>

<p>This class inherits from base <code><a href="base.html#topic+array">array</a></code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+AoristicSum-class">AoristicSum-class</a></code>,
<code><a href="#topic+EventDate-class">EventDate-class</a></code>,
<code><a href="#topic+IncrementTest-class">IncrementTest-class</a></code>,
<code><a href="#topic+MeanDate-class">MeanDate-class</a></code>,
<code><a href="#topic+PermutationOrder-class">PermutationOrder-class</a></code>,
<code><a href="#topic+RateOfChange-class">RateOfChange-class</a></code>,
<code><a href="#topic+RefinePermutationOrder-class">RefinePermutationOrder-class</a></code>
</p>

<hr>
<h2 id='data.frame'>Coerce to a Data Frame</h2><span id='topic+data.frame'></span><span id='topic+as.data.frame+2CMeanDate-method'></span><span id='topic+as.data.frame+2CAoristicSum-method'></span><span id='topic+as.data.frame+2CIncrementTest-method'></span>

<h3>Description</h3>

<p>Coerce to a Data Frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MeanDate'
as.data.frame(x, ..., calendar = getOption("kairos.calendar"))

## S4 method for signature 'AoristicSum'
as.data.frame(x, ..., calendar = getOption("kairos.calendar"))

## S4 method for signature 'IncrementTest'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.frame_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="data.frame_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to <code><a href="#topic+data.frame">data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="data.frame_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the target calendar
(see <code><a href="#topic+calendar">calendar()</a></code>). If <code>NULL</code>, <em>rata die</em> are returned.</p>
</td></tr>
<tr><td><code id="data.frame_+3A_row.names">row.names</code>, <code id="data.frame_+3A_optional">optional</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+data.frame">data.frame</a></code> with an extra <code>time</code> column giving the (decimal) years at
which the time series was sampled.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+model">model</a></code>,
<code><a href="#topic+mutators">mutators</a></code>,
<code><a href="#topic+series">series</a>()</code>,
<code><a href="#topic+subset">subset</a>()</code>
</p>

<hr>
<h2 id='event'>Event and Accumulation Dates</h2><span id='topic+event'></span><span id='topic+event-method'></span><span id='topic+event+2Cdata.frame+2Cnumeric-method'></span><span id='topic+event+2Cmatrix+2Cnumeric-method'></span><span id='topic+summary+2CEventDate-method'></span><span id='topic+summary+2CEventDate+2Cmissing-method'></span>

<h3>Description</h3>

<p>Fits a date event model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event(object, dates, ...)

## S4 method for signature 'data.frame,numeric'
event(object, dates, rank = NULL, sup_row = NULL, calendar = CE(), ...)

## S4 method for signature 'matrix,numeric'
event(object, dates, rank = NULL, sup_row = NULL, calendar = CE(), ...)

## S4 method for signature 'EventDate'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_+3A_object">object</code></td>
<td>
<p>A <code class="reqn">m \times p</code> <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="#topic+data.frame">data.frame</a></code> of count data (absolute frequencies giving the number of
individuals for each category, i.e. a contingency table). A <code><a href="#topic+data.frame">data.frame</a></code>
will be coerced to a <code>numeric</code> <code>matrix</code> via <code><a href="base.html#topic+data.matrix">data.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="event_+3A_dates">dates</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector of dates. If named, the names must match
the row names of <code>object</code>.</p>
</td></tr>
<tr><td><code id="event_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to internal methods.</p>
</td></tr>
<tr><td><code id="event_+3A_rank">rank</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the number of CA factorial components
to be use for linear model fitting (see details). If <code>NULL</code> (the default),
axes corresponding to at least 60% of the inertia will be used.</p>
</td></tr>
<tr><td><code id="event_+3A_sup_row">sup_row</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+logical">logical</a></code> vector specifying the indices of
the supplementary rows.</p>
</td></tr>
<tr><td><code id="event_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the calendar of
<code>dates</code> (see <code><a href="#topic+calendar">calendar()</a></code>). Defaults to Gregorian Common Era.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of the chronological modeling method proposed by
Bellanger and Husi (2012, 2013).
</p>
<p>Event and accumulation dates are density estimates of the occupation and
duration of an archaeological site (Bellanger and Husi 2012, 2013).
The event date is an estimation of the <em>terminus post-quem</em> of an
archaeological assemblage. The accumulation date represents the
&quot;chronological profile&quot; of the assemblage. According to Bellanger and Husi
(2012), accumulation date can be interpreted &quot;at best [...] as a formation
process reflecting the duration or succession of events on the scale of
archaeological time, and at worst, as imprecise dating due to contamination
of the context by residual or intrusive material.&quot; In other words,
accumulation dates estimate occurrence of archaeological events and rhythms
of the long term.
</p>
<p>Dates are converted to <em><a href="aion.html#topic+RataDie-class">rata die</a></em> before any
computation.
</p>
<p>This method relies on strong archaeological and statistical assumptions
(see <code>vignette("event")</code>).
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+EventDate-class">EventDate</a></code> object.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Bellanger, L. &amp; Husi, P. (2013). Mesurer et modéliser le temps inscrit dans
la matière à partir d'une source matérielle : la céramique médiévale.
In <em>Mesure et Histoire Médiévale</em>. Histoire ancienne et médiévale.
Paris: Publication de la Sorbonne, p. 119-134.
</p>
<p>Bellanger, L. &amp; Husi, P. (2012). Statistical Tool for Dating and
Interpreting Archaeological Contexts Using Pottery. <em>Journal of
Archaeological Science</em>, 39(4), 777-790. <a href="https://doi.org/10.1016/j.jas.2011.06.031">doi:10.1016/j.jas.2011.06.031</a>.
</p>
<p>Bellanger, L., Tomassone, R. &amp; Husi, P. (2008). A Statistical Approach for
Dating Archaeological Contexts. <em>Journal of Data Science</em>, 6, 135-154.
</p>
<p>Bellanger, L., Husi, P. &amp; Tomassone, R. (2006). Une approche statistique
pour la datation de contextes archéologiques. <em>Revue de Statistique
Appliquée</em>, 54(2), 65-81.
</p>
<p>Bellanger, L., Husi, P. &amp; Tomassone, R. (2006). Statistical Aspects of
Pottery Quantification for the Dating of Some Archaeological Contexts.
<em>Archaeometry</em>, 48(1), 169-183. <a href="https://doi.org/10.1111/j.1475-4754.2006.00249.x">doi:10.1111/j.1475-4754.2006.00249.x</a>.
</p>
<p>Poblome, J. &amp; Groenen, P. J. F. (2003). Constrained Correspondence Analysis
for Seriation of Sagalassos Tablewares. In Doerr, M. &amp; Apostolis, S. (eds.),
<em>The Digital Heritage of Archaeology</em>. Athens: Hellenic Ministry of Culture.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_event">plot()</a></code>, <code><a href="#topic+predict_event">predict_event()</a></code>,
<code><a href="#topic+predict_event">predict_accumulation()</a></code>, <code><a href="#topic+resample_event">jackknife()</a></code>,
<code><a href="#topic+resample_event">bootstrap()</a></code>
</p>
<p>Other dating methods: 
<code><a href="#topic+mcd">mcd</a>()</code>,
<code><a href="#topic+predict_event">predict_event</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Peeples and Schachner 2012
data("zuni", package = "folio")

## Assume that some assemblages are reliably dated (this is NOT a real example)
zuni_dates &lt;- c(
  LZ0569 = 1097, LZ0279 = 1119, CS16 = 1328, LZ0066 = 1111,
  LZ0852 = 1216, LZ1209 = 1251, CS144 = 1262, LZ0563 = 1206,
  LZ0329 = 1076, LZ0005Q = 859, LZ0322 = 1109, LZ0067 = 863,
  LZ0578 = 1180, LZ0227 = 1104, LZ0610 = 1074
)

## Model the event and accumulation date for each assemblage
model &lt;- event(zuni, zuni_dates, rank = 10)
plot(model, select = 1:10, event = TRUE, flip = TRUE)
</code></pre>

<hr>
<h2 id='EventDate-class'>Date Model</h2><span id='topic+EventDate-class'></span><span id='topic+.EventDate'></span>

<h3>Description</h3>

<p>An S4 class to store the event and accumulation times of archaeological
assemblages.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dates</code></dt><dd><p>A length-<code class="reqn">m</code> <code><a href="base.html#topic+numeric">numeric</a></code> vector of dates expressed in
<em><a href="aion.html#topic+RataDie-class">rata die</a></em>.</p>
</dd>
<dt><code>model</code></dt><dd><p>A <a href="stats.html#topic+lm">multiple linear model</a>: the Gaussian
multiple linear regression model fitted for event date estimation and
prediction.</p>
</dd>
<dt><code>keep</code></dt><dd><p>An <code><a href="base.html#topic+integer">integer</a></code> vector giving the subscripts of the CA components
to keep.</p>
</dd>
</dl>


<h3>Extract</h3>

<p>In the code snippets below, <code>x</code> is an <code>EventDate</code> object.
</p>

<dl>
<dt><code><a href="#topic+time">time(x)</a></code></dt><dd><p>Extract dates of assemblages.</p>
</dd>
<dt><code><a href="stats.html#topic+coef">coef(x)</a></code></dt><dd><p>Extract model coefficients.</p>
</dd>
<dt><code><a href="stats.html#topic+fitted">fitted(x)</a></code></dt><dd><p>Extract model fitted values.</p>
</dd>
<dt><code><a href="stats.html#topic+residuals">residuals(x)</a></code></dt><dd><p>Extract model residuals.</p>
</dd>
<dt><code><a href="stats.html#topic+sigma">sigma(x)</a></code></dt><dd><p>Extract the residual standard deviation.</p>
</dd>
<dt><code><a href="stats.html#topic+terms">terms(x)</a></code></dt><dd><p>Extract model terms.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Dates are internally stored as <em><a href="aion.html#topic+RataDie-class">rata die</a></em>.
This class inherits from <code><a href="dimensio.html#topic+CA-class">dimensio::CA</a></code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p><code><a href="dimensio.html#topic+CA-class">dimensio::CA</a></code>
</p>
<p>Other classes: 
<code><a href="#topic+AoristicSum-class">AoristicSum-class</a></code>,
<code><a href="#topic+CountApportion-class">CountApportion-class</a></code>,
<code><a href="#topic+IncrementTest-class">IncrementTest-class</a></code>,
<code><a href="#topic+MeanDate-class">MeanDate-class</a></code>,
<code><a href="#topic+PermutationOrder-class">PermutationOrder-class</a></code>,
<code><a href="#topic+RateOfChange-class">RateOfChange-class</a></code>,
<code><a href="#topic+RefinePermutationOrder-class">RefinePermutationOrder-class</a></code>
</p>

<hr>
<h2 id='fit'>Frequency Increment Test</h2><span id='topic+fit'></span><span id='topic+fit-method'></span><span id='topic+fit+2Cdata.frame+2Cnumeric-method'></span><span id='topic+fit+2Cmatrix+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Frequency Increment Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(object, dates, ...)

## S4 method for signature 'data.frame,numeric'
fit(object, dates, calendar = CE(), level = 0.95, roll = FALSE, window = 3)

## S4 method for signature 'matrix,numeric'
fit(object, dates, calendar = CE(), level = 0.95, roll = FALSE, window = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_object">object</code></td>
<td>
<p>A <code class="reqn">m \times p</code> <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="#topic+data.frame">data.frame</a></code> of count data (absolute frequencies giving the number of
individuals for each category, i.e. a contingency table). A <code><a href="#topic+data.frame">data.frame</a></code>
will be coerced to a <code>numeric</code> <code>matrix</code> via <code><a href="base.html#topic+data.matrix">data.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_+3A_dates">dates</code></td>
<td>
<p>A length-<code class="reqn">m</code> <code><a href="base.html#topic+numeric">numeric</a></code> vector of dates.</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="fit_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the calendar of
<code>dates</code> (see <code><a href="#topic+calendar">calendar()</a></code>). Defaults to Gregorian Common Era.</p>
</td></tr>
<tr><td><code id="fit_+3A_level">level</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the confidence level.</p>
</td></tr>
<tr><td><code id="fit_+3A_roll">roll</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should each time series be subsetted to
look for episodes of selection?</p>
</td></tr>
<tr><td><code id="fit_+3A_window">window</code></td>
<td>
<p>An odd <code><a href="base.html#topic+integer">integer</a></code> giving the size of the rolling
window. Only used if <code>roll</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Frequency Increment Test (FIT) rejects neutrality if the distribution
of normalized variant frequency increments exhibits a mean that deviates
significantly from zero.
</p>
<p>If <code>roll</code> is <code>TRUE</code>, each time series is subsetted according to <code>window</code> to
see if episodes of selection can be identified among variables that might
not show overall selection.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+IncrementTest-class">IncrementTest</a></code> object.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Feder, A. F., Kryazhimskiy, S. &amp; Plotkin, J. B. (2014). Identifying
Signatures of Selection in Genetic Time Series. <em>Genetics</em>, 196(2):
509-522. <a href="https://doi.org/10.1534/genetics.113.158220">doi:10.1534/genetics.113.158220</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_fit">plot()</a></code>
</p>
<p>Other chronological analysis: 
<code><a href="#topic+aoristic">aoristic</a>()</code>,
<code><a href="#topic+apportion">apportion</a>()</code>,
<code><a href="#topic+roc">roc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Crema et al. 2016
data("merzbach", package = "folio")

## Keep only decoration types that have a maximum frequency of at least 50
keep &lt;- apply(X = merzbach, MARGIN = 2, FUN = function(x) max(x) &gt;= 50)
counts &lt;- merzbach[, keep]

## Group by phase
## We use the row names as time coordinates (roman numerals)
dates &lt;- as.numeric(utils::as.roman(rownames(counts)))

## Frequency Increment Test
freq &lt;- fit(counts, dates, calendar = NULL)

## Plot time vs abundance
plot(freq, calendar = NULL, ncol = 3, xlab = "Phases")

## Plot time vs abundance and highlight selection
freq &lt;- fit(counts, dates, calendar = NULL, roll = TRUE, window = 5)
plot(freq, calendar = NULL, ncol = 3, xlab = "Phases")
</code></pre>

<hr>
<h2 id='IncrementTest-class'>Frequency Increment Test</h2><span id='topic+IncrementTest-class'></span><span id='topic+.IncrementTest'></span>

<h3>Description</h3>

<p>An S4 class to represent a Frequency Increment Test results.
</p>


<h3>Slots</h3>


<dl>
<dt><code>statistic</code></dt><dd><p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the values of the t-statistic.</p>
</dd>
<dt><code>parameter</code></dt><dd><p>An <code><a href="base.html#topic+integer">integer</a></code> giving the degrees of freedom for the
t-statistic.</p>
</dd>
<dt><code>p_value</code></dt><dd><p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the the p-value for the test.</p>
</dd>
</dl>


<h3>Coerce</h3>

<p>In the code snippets below, <code>x</code> is an <code>IncrementTest</code> object.
</p>

<dl>
<dt><code>as.data.frame(x)</code></dt><dd><p>Coerces to a <code><a href="#topic+data.frame">data.frame</a></code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This class inherits from <code><a href="aion.html#topic+TimeSeries-class">aion::TimeSeries</a></code>: dates are internally
stored as <em><a href="aion.html#topic+RataDie-class">rata die</a></em>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+AoristicSum-class">AoristicSum-class</a></code>,
<code><a href="#topic+CountApportion-class">CountApportion-class</a></code>,
<code><a href="#topic+EventDate-class">EventDate-class</a></code>,
<code><a href="#topic+MeanDate-class">MeanDate-class</a></code>,
<code><a href="#topic+PermutationOrder-class">PermutationOrder-class</a></code>,
<code><a href="#topic+RateOfChange-class">RateOfChange-class</a></code>,
<code><a href="#topic+RefinePermutationOrder-class">RefinePermutationOrder-class</a></code>
</p>

<hr>
<h2 id='kairos-deprecated'>Deprecated Functions in kairos</h2><span id='topic+kairos-deprecated'></span>

<h3>Description</h3>

<p>These functions still work but will be removed (defunct) in the next version.
</p>

<hr>
<h2 id='kairos-package'>kairos: Analysis of Chronological Patterns from Archaeological Count Data</h2><span id='topic+kairos-package'></span><span id='topic+kairos'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A toolkit for absolute and relative dating and analysis of chronological patterns. This package includes functions for chronological modeling and dating of archaeological assemblages from count data. It provides methods for matrix seriation. It also allows to compute time point estimates and density estimates of the occupation and duration of an archaeological site.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
<strong>Package:</strong> </td><td style="text-align: left;"> kairos </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Type:</strong> </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Version:</strong> </td><td style="text-align: left;"> 2.1.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>License:</strong> </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Package options</h3>

<p><code>kairos</code> uses the following <code><a href="base.html#topic+options">options()</a></code> to configure behavior:
</p>

<ul>
<li> <p><code>kairos.progress</code>: a <code><a href="base.html#topic+logical">logical</a></code> scalar. Should progress bars be
displayed?
</p>
</li>
<li> <p><code>kairos.calendar</code>: a <code><a href="aion.html#topic+TimeScale-class">aion::TimeScale</a></code> object (default calendar
for printing).
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Full list of authors and contributors</strong> (alphabetic order)
</p>

<table>
<tr>
 <td style="text-align: left;">
Nicolas Frerebeau </td><td style="text-align: left;"> <em>Université Bordeaux Montaigne, France</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
Brice Lebrun </td><td style="text-align: left;"> <em>Université Bordeaux Montaigne, France</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
Ben Marwick </td><td style="text-align: left;"> <em>University of Washington, USA</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
Anne Philippe </td><td style="text-align: left;"> <em>Université de Nantes, France</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><strong>Package maintainer</strong>
</p>
<p>Nicolas Frerebeau<br />
<a href="mailto:nicolas.frerebeau@u-bordeaux-montaigne.fr">nicolas.frerebeau@u-bordeaux-montaigne.fr</a>
</p>
<p>Archéosciences Bordeaux (UMR 6034)<br />
Maison de l'Archéologie<br />
Université Bordeaux Montaigne<br />
F-33607 Pessac cedex<br />
France
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://packages.tesselle.org/kairos/">https://packages.tesselle.org/kairos/</a>
</p>
</li>
<li> <p><a href="https://github.com/tesselle/kairos">https://github.com/tesselle/kairos</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tesselle/kairos/issues">https://github.com/tesselle/kairos/issues</a>
</p>
</li></ul>


<hr>
<h2 id='mcd'>Mean Ceramic Date</h2><span id='topic+mcd'></span><span id='topic+mcd-method'></span><span id='topic+mcd+2Cnumeric+2Cnumeric-method'></span><span id='topic+mcd+2Cdata.frame+2Cnumeric-method'></span><span id='topic+mcd+2Cmatrix+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Estimates the Mean Ceramic Date of an assemblage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcd(object, dates, ...)

## S4 method for signature 'numeric,numeric'
mcd(object, dates, calendar = CE())

## S4 method for signature 'data.frame,numeric'
mcd(object, dates, calendar = CE())

## S4 method for signature 'matrix,numeric'
mcd(object, dates, calendar = CE())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcd_+3A_object">object</code></td>
<td>
<p>A <code class="reqn">m \times p</code> <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="#topic+data.frame">data.frame</a></code> of count data (absolute frequencies giving the number of
individuals for each category, i.e. a contingency table). A <code><a href="#topic+data.frame">data.frame</a></code>
will be coerced to a <code>numeric</code> <code>matrix</code> via <code><a href="base.html#topic+data.matrix">data.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="mcd_+3A_dates">dates</code></td>
<td>
<p>A length-<code class="reqn">p</code> <code><a href="base.html#topic+numeric">numeric</a></code> vector of dates expressed in years.</p>
</td></tr>
<tr><td><code id="mcd_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="mcd_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the calendar of
<code>dates</code> (see <code><a href="#topic+calendar">calendar()</a></code>). Defaults to Gregorian Common Era.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Mean Ceramic Date (MCD) is a point estimate of the occupation of an
archaeological site (South 1977). The MCD is estimated as the weighted mean
of the date midpoints of the ceramic types (based on absolute dates or the
known production interval) found in a given assemblage. The weights are the
relative frequencies of the respective types in the assemblage.
</p>
<p>A bootstrapping procedure is used to estimate the confidence interval of a
given MCD. For each assemblage, a large number of new bootstrap replicates
is created, with the same sample size, by resampling the original
assemblage with replacement. MCDs are calculated for each replicates and
upper and lower boundaries of the confidence interval associated with each
MCD are then returned.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+MeanDate-class">MeanDate</a></code> object.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>South, S. A. (1977). <em>Method and Theory in Historical Archaeology</em>.
New York: Academic Press.
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_mcd">plot()</a>, <a href="#topic+resample_mcd">bootstrap()</a>,
<a href="#topic+resample_mcd">jackknife()</a>, <a href="#topic+resample_mcd">simulate()</a>
</p>
<p>Other dating methods: 
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+predict_event">predict_event</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Peeples and Schachner 2012
data("zuni", package = "folio")

## Set the start and end dates for each ceramic type
dates &lt;- list(
  LINO = c(600, 875), KIAT = c(850, 950), RED = c(900, 1050),
  GALL = c(1025, 1125), ESC = c(1050, 1150), PUBW = c(1050, 1150),
  RES = c(1000, 1200), TULA = c(1175, 1300), PINE = c(1275, 1350),
  PUBR = c(1000, 1200), WING = c(1100, 1200), WIPO = c(1125, 1225),
  SJ = c(1200, 1300), LSJ = c(1250, 1300), SPR = c(1250, 1300),
  PINER = c(1275, 1325), HESH = c(1275, 1450), KWAK = c(1275, 1450)
)

## Calculate date midpoints
mid &lt;- vapply(X = dates, FUN = mean, FUN.VALUE = numeric(1))

## Calculate MCD
(mc_dates &lt;- mcd(zuni[100:125, ], dates = mid))

## Get MCD in years CE
time(mc_dates, calendar = CE())

## Plot
plot(mc_dates)

## Bootstrap resampling
boot &lt;- bootstrap(mc_dates, n = 30)
head(boot)

## Jackknife resampling
jack &lt;- jackknife(mc_dates)
head(jack)

## Simulation
sim &lt;- simulate(mc_dates, nsim = 30)
plot(sim, interval = "range", pch = 16)
</code></pre>

<hr>
<h2 id='MeanDate-class'>Mean Date</h2><span id='topic+MeanDate-class'></span><span id='topic+.MeanDate'></span>

<h3>Description</h3>

<p>An S4 class to store the weighted mean date (e.g. Mean Ceramic Date) of
archaeological assemblages.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dates</code></dt><dd><p>A length-<code class="reqn">p</code> <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the dates of the
(ceramic) types expressed in <em><a href="aion.html#topic+RataDie-class">rata die</a></em>.</p>
</dd>
<dt><code>replications</code></dt><dd><p>A <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> giving the replications.</p>
</dd>
</dl>


<h3>Coerce</h3>

<p>In the code snippets below, <code>x</code> is a <code>MeanDate</code> object.
</p>

<dl>
<dt><code>as.data.frame(x)</code></dt><dd><p>Coerces to a <code><a href="#topic+data.frame">data.frame</a></code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This class inherits from <code><a href="aion.html#topic+TimeSeries-class">aion::TimeSeries</a></code>: dates are internally
stored as <em><a href="aion.html#topic+RataDie-class">rata die</a></em>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p><code><a href="aion.html#topic+TimeSeries-class">aion::TimeSeries</a></code>
</p>
<p>Other classes: 
<code><a href="#topic+AoristicSum-class">AoristicSum-class</a></code>,
<code><a href="#topic+CountApportion-class">CountApportion-class</a></code>,
<code><a href="#topic+EventDate-class">EventDate-class</a></code>,
<code><a href="#topic+IncrementTest-class">IncrementTest-class</a></code>,
<code><a href="#topic+PermutationOrder-class">PermutationOrder-class</a></code>,
<code><a href="#topic+RateOfChange-class">RateOfChange-class</a></code>,
<code><a href="#topic+RefinePermutationOrder-class">RefinePermutationOrder-class</a></code>
</p>

<hr>
<h2 id='model'>Extract Model Results</h2><span id='topic+model'></span><span id='topic+coef+2CEventDate-method'></span><span id='topic+fitted+2CEventDate-method'></span><span id='topic+residuals+2CEventDate-method'></span><span id='topic+sigma+2CEventDate-method'></span><span id='topic+terms+2CEventDate-method'></span>

<h3>Description</h3>


<ul>
<li> <p><code>coef()</code> extracts model coefficients (see <code><a href="stats.html#topic+coef">stats::coef()</a></code>).
</p>
</li>
<li> <p><code>fitted()</code> extracts model fitted values (see <code><a href="stats.html#topic+fitted.values">stats::fitted()</a></code>).
</p>
</li>
<li> <p><code>residuals()</code> extracts model residuals (see <code><a href="stats.html#topic+residuals">stats::residuals()</a></code>).
</p>
</li>
<li> <p><code>sigma()</code> extracts the residual standard deviation (see <code><a href="stats.html#topic+sigma">stats::sigma()</a></code>).
</p>
</li>
<li> <p><code>terms()</code> extracts model terms (see <code><a href="stats.html#topic+terms">stats::terms()</a></code>).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EventDate'
coef(object, calendar = NULL, ...)

## S4 method for signature 'EventDate'
fitted(object, calendar = NULL, ...)

## S4 method for signature 'EventDate'
residuals(object, calendar = NULL, ...)

## S4 method for signature 'EventDate'
sigma(object, calendar = NULL, ...)

## S4 method for signature 'EventDate'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the target calendar
(see <code><a href="#topic+calendar">calendar()</a></code>). If <code>NULL</code> (the default), <em>rata die</em> are returned.</p>
</td></tr>
<tr><td><code id="model_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="model_+3A_x">x</code>, <code id="model_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+EventDate-class">EventDate</a></code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+data.frame">data.frame</a></code>,
<code><a href="#topic+mutators">mutators</a></code>,
<code><a href="#topic+series">series</a>()</code>,
<code><a href="#topic+subset">subset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Peeples and Schachner 2012
data("zuni", package = "folio")

## Assume that some assemblages are reliably dated (this is NOT a real example)
zuni_dates &lt;- c(
  LZ0569 = 1097, LZ0279 = 1119, CS16 = 1328, LZ0066 = 1111,
  LZ0852 = 1216, LZ1209 = 1251, CS144 = 1262, LZ0563 = 1206,
  LZ0329 = 1076, LZ0005Q = 859, LZ0322 = 1109, LZ0067 = 863,
  LZ0578 = 1180, LZ0227 = 1104, LZ0610 = 1074
)

## Model the event and accumulation date for each assemblage
model &lt;- event(zuni, zuni_dates, rank = 10)
plot(model, select = 1:10, event = TRUE, flip = TRUE)
</code></pre>

<hr>
<h2 id='mutators'>Get or Set Parts of an Object</h2><span id='topic+mutators'></span><span id='topic+get'></span><span id='topic+set'></span><span id='topic+weights+2CAoristicSum-method'></span><span id='topic+weights+2CCountApportion-method'></span>

<h3>Description</h3>

<p>Getters and setters to retrieve or set parts of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AoristicSum'
weights(object, ...)

## S4 method for signature 'CountApportion'
weights(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutators_+3A_object">object</code></td>
<td>
<p>An object from which to get or set element(s).</p>
</td></tr>
<tr><td><code id="mutators_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+data.frame">data.frame</a></code>,
<code><a href="#topic+model">model</a></code>,
<code><a href="#topic+series">series</a>()</code>,
<code><a href="#topic+subset">subset</a>()</code>
</p>

<hr>
<h2 id='PermutationOrder-class'>Permutation Order</h2><span id='topic+PermutationOrder-class'></span><span id='topic+.PermutationOrder'></span><span id='topic+RankPermutationOrder-class'></span><span id='topic+.RankPermutationOrder'></span><span id='topic+AveragePermutationOrder-class'></span><span id='topic+.AveragePermutationOrder'></span>

<h3>Description</h3>

<p>S4 classes to represent a permutation order.
</p>


<h3>Slots</h3>


<dl>
<dt><code>rows_order</code></dt><dd><p>An <code><a href="base.html#topic+integer">integer</a></code> vector giving the rows permutation.</p>
</dd>
<dt><code>columns_order</code></dt><dd><p>An <code><a href="base.html#topic+integer">integer</a></code> vector giving the columns permutation.</p>
</dd>
</dl>


<h3>Subset</h3>

<p>In the code snippets below, <code>x</code> is a <code>PermutationOrder</code> object.
</p>

<dl>
<dt><code>x[[i]]</code></dt><dd><p>Extract information from a slot selected by subscript <code>i</code>.
<code>i</code> is a length-one character vector.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p><code><a href="dimensio.html#topic+CA-class">dimensio::CA</a></code>
</p>
<p>Other classes: 
<code><a href="#topic+AoristicSum-class">AoristicSum-class</a></code>,
<code><a href="#topic+CountApportion-class">CountApportion-class</a></code>,
<code><a href="#topic+EventDate-class">EventDate-class</a></code>,
<code><a href="#topic+IncrementTest-class">IncrementTest-class</a></code>,
<code><a href="#topic+MeanDate-class">MeanDate-class</a></code>,
<code><a href="#topic+RateOfChange-class">RateOfChange-class</a></code>,
<code><a href="#topic+RefinePermutationOrder-class">RefinePermutationOrder-class</a></code>
</p>

<hr>
<h2 id='permute'>Rearranges a Data Matrix</h2><span id='topic+permute'></span><span id='topic+permute-method'></span><span id='topic+get_order'></span><span id='topic+get_order-method'></span><span id='topic+permute+2Cdata.frame+2CPermutationOrder-method'></span><span id='topic+permute+2Cmatrix+2CPermutationOrder-method'></span><span id='topic+get_order+2CPermutationOrder-method'></span>

<h3>Description</h3>


<ul>
<li> <p><code>permute()</code> rearranges a data matrix according to a permutation order.
</p>
</li>
<li> <p><code>get_order()</code> returns the seriation order for rows and/or columns.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>permute(object, order, ...)

get_order(x, ...)

## S4 method for signature 'data.frame,PermutationOrder'
permute(object, order)

## S4 method for signature 'matrix,PermutationOrder'
permute(object, order)

## S4 method for signature 'PermutationOrder'
get_order(x, margin = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_+3A_object">object</code></td>
<td>
<p>A <code class="reqn">m \times p</code> <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="#topic+data.frame">data.frame</a></code> of count data (absolute frequencies giving the number of
individuals for each category, i.e. a contingency table). A <code><a href="#topic+data.frame">data.frame</a></code>
will be coerced to a <code>numeric</code> <code>matrix</code> via <code><a href="base.html#topic+data.matrix">data.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="permute_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="permute_+3A_x">x</code>, <code id="permute_+3A_order">order</code></td>
<td>
<p>A <code><a href="#topic+PermutationOrder-class">PermutationOrder</a></code> object giving the permutation
order for rows and columns.</p>
</td></tr>
<tr><td><code id="permute_+3A_margin">margin</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the subscripts which the
rearrangement will be applied over: <code>1</code> indicates rows, <code>2</code> indicates
columns, <code>c(1, 2)</code> indicates rows and columns.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>permute()</code> returns a permuted <code>matrix</code> or a permuted <code>data.frame</code>
(the same as <code>object</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p><code><a href="dimensio.html#topic+ca">dimensio::ca()</a></code>
</p>
<p>Other seriation methods: 
<code><a href="#topic+seriate_average">seriate_average</a>()</code>,
<code><a href="#topic+seriate_rank">seriate_rank</a>()</code>,
<code><a href="#topic+seriate_refine">seriate_refine</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Replicates Desachy 2004 results
data("compiegne", package = "folio")

## Get seriation order for columns on EPPM using the reciprocal averaging method
## Expected column order: N, A, C, K, P, L, B, E, I, M, D, G, O, J, F, H
(indices &lt;- seriate_rank(compiegne, EPPM = TRUE, margin = 2))

## Get permutation order
get_order(indices, 1) # rows
get_order(indices, 2) # columns

## Permute columns
(new &lt;- permute(compiegne, indices))

## See the vignette
## Not run: 
utils::vignette("seriation")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_aoristic'>Plot Aoristic Analysis</h2><span id='topic+plot_aoristic'></span><span id='topic+plot+2CAoristicSum+2Cmissing-method'></span><span id='topic+image+2CAoristicSum-method'></span><span id='topic+plot+2CRateOfChange+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot Aoristic Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AoristicSum,missing'
plot(
  x,
  calendar = getOption("kairos.calendar"),
  type = c("bar"),
  flip = FALSE,
  ncol = NULL,
  main = NULL,
  sub = NULL,
  ann = graphics::par("ann"),
  axes = TRUE,
  frame.plot = axes,
  panel.first = NULL,
  panel.last = NULL,
  ...
)

## S4 method for signature 'AoristicSum'
image(x, calendar = getOption("kairos.calendar"), ...)

## S4 method for signature 'RateOfChange,missing'
plot(
  x,
  calendar = getOption("kairos.calendar"),
  level = 0.95,
  flip = FALSE,
  ncol = NULL,
  main = NULL,
  sub = NULL,
  ann = graphics::par("ann"),
  axes = TRUE,
  frame.plot = axes,
  panel.first = NULL,
  panel.last = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_aoristic_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+AoristicSum-class">AoristicSum</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the target calendar
(see <code><a href="aion.html#topic+calendar">calendar()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_type">type</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying whether bar or density should
be plotted? It must be one of &quot;<code>bar</code>&quot; or &quot;<code>density</code>&quot;. Any unambiguous
substring can be given.</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_flip">flip</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the y-axis (ticks and numbering) be
flipped from side 2 (left) to 4 (right) from series to series when <code>facet</code>
is &quot;<code>multiple</code>&quot;?</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_ncol">ncol</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the number of columns to use when
<code>facet</code> is &quot;<code>multiple</code>&quot;. Defaults to 1 for up to 4 series, otherwise to 2.</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_main">main</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_sub">sub</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving a subtitle for the plot.</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_ann">ann</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the default annotation (title and x
and y axis labels) appear on the plot?</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_axes">axes</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should axes be drawn on the plot?</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_frame.plot">frame.plot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should a box be drawn around the
plot?</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_panel.first">panel.first</code></td>
<td>
<p>An an <code>expression</code> to be evaluated after the plot axes are
set up but before any plotting takes place. This can be useful for drawing
background grids.</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_panel.last">panel.last</code></td>
<td>
<p>An <code>expression</code> to be evaluated after plotting has taken
place but before the axes, title and box are added.</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to <code>panel</code>
(e.g. <a href="graphics.html#topic+par">graphical parameters</a>).</p>
</td></tr>
<tr><td><code id="plot_aoristic_+3A_level">level</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the confidence level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot()</code> is called it for its side-effects: it results in a graphic being
displayed (invisibly returns <code>x</code>).
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aoristic">aoristic()</a></code>, <code><a href="#topic+roc">roc()</a></code>
</p>
<p>Other plotting methods: 
<code><a href="#topic+plot_event">plot_event</a></code>,
<code><a href="#topic+plot_fit">plot_fit</a></code>,
<code><a href="#topic+plot_mcd">plot_mcd</a></code>,
<code><a href="#topic+plot_time">plot_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Husi 2022
data("loire", package = "folio")

## Get time range
loire_range &lt;- loire[, c("lower", "upper")]

## Calculate aoristic sum (normal)
aorist_raw &lt;- aoristic(loire_range, step = 50, weight = FALSE)
plot(aorist_raw, col = "grey")

## Calculate aoristic sum (weights)
aorist_weighted &lt;- aoristic(loire_range, step = 50, weight = TRUE)
plot(aorist_weighted, col = "grey")

## Calculate aoristic sum (weights) by group
aorist_groups &lt;- aoristic(loire_range, step = 50, weight = TRUE,
                          groups = loire$area)
plot(aorist_groups, flip = TRUE, col = "grey")
image(aorist_groups)

## Rate of change
roc_weighted &lt;- roc(aorist_weighted, n = 30)
plot(roc_weighted)

## Rate of change by group
roc_groups &lt;- roc(aorist_groups, n = 30)
plot(roc_groups, flip = TRUE)
</code></pre>

<hr>
<h2 id='plot_event'>Event Plot</h2><span id='topic+plot_event'></span><span id='topic+plot+2CEventDate+2Cmissing-method'></span>

<h3>Description</h3>

<p>Produces an activity or a tempo plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EventDate,missing'
plot(
  x,
  type = c("activity", "tempo"),
  event = FALSE,
  calendar = getOption("kairos.calendar"),
  select = 1,
  n = 500,
  eps = 1e-09,
  col.accumulation = "black",
  col.event = "red",
  flip = FALSE,
  ncol = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  sub = NULL,
  ann = graphics::par("ann"),
  axes = TRUE,
  frame.plot = axes,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_event_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+EventDate-class">EventDate</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_type">type</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string indicating the type of plot.
It must be one of &quot;<code>activity</code>&quot; (default) or &quot;<code>tempo</code>&quot; (see details).
Any unambiguous substring can be given.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_event">event</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the distribution of the event date
be displayed? Only used if type is &quot;<code>activity</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the target calendar
(see <code><a href="aion.html#topic+calendar">calendar()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_event_+3A_select">select</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code> vector giving the selection of
the assemblage that are drawn.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_n">n</code></td>
<td>
<p>A length-one non-negative <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the desired
length of the vector of quantiles for density computation.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_eps">eps</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> value giving the cutoff below which
values will be removed.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_col.accumulation">col.accumulation</code></td>
<td>
<p>A color specification for the accumulation density
curve.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_col.event">col.event</code></td>
<td>
<p>A color specification for the event density curve.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_flip">flip</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the y-axis (ticks and numbering) be
flipped from side 2 (left) to 4 (right) from series to series when <code>facet</code>
is &quot;<code>multiple</code>&quot;?</p>
</td></tr>
<tr><td><code id="plot_event_+3A_ncol">ncol</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the number of columns to use when
<code>facet</code> is &quot;<code>multiple</code>&quot;. Defaults to 1 for up to 4 series, otherwise to 2.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_xlab">xlab</code>, <code id="plot_event_+3A_ylab">ylab</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector giving the x and y axis labels.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_main">main</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_sub">sub</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving a subtitle for the plot.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_ann">ann</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the default annotation (title and x
and y axis labels) appear on the plot?</p>
</td></tr>
<tr><td><code id="plot_event_+3A_axes">axes</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should axes be drawn on the plot?</p>
</td></tr>
<tr><td><code id="plot_event_+3A_frame.plot">frame.plot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should a box be drawn around the
plot?</p>
</td></tr>
<tr><td><code id="plot_event_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to <code>panel</code>
(e.g. <a href="graphics.html#topic+par">graphical parameters</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot()</code> is called it for its side-effects: it results in a graphic being
displayed (invisibly returns <code>x</code>).
</p>


<h3>Event and Acccumulation Dates</h3>

<p><code>plot()</code> displays the probability estimate density curves of archaeological
assemblage dates (<em>event</em> and <em>accumulation</em> dates; Bellanger and Husi
2012). The <em>event</em> date is plotted as a line, while the <em>accumulation</em> date
is shown as a grey filled area.
</p>
<p>The accumulation date can be displayed as a tempo plot (Dye 2016) or an
activity plot (Philippe and Vibet 2020):
</p>

<dl>
<dt><code>tempo</code></dt><dd><p>A tempo plot estimates the cumulative occurrence of
archaeological events, such as the slope of the plot directly reflects the
pace of change.</p>
</dd>
<dt><code>activity</code></dt><dd><p>An activity plot displays the first derivative of the
tempo plot.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Bellanger, L. &amp; Husi, P. (2012). Statistical Tool for Dating and
Interpreting Archaeological Contexts Using Pottery. <em>Journal of
Archaeological Science</em>, 39(4), 777-790. <a href="https://doi.org/10.1016/j.jas.2011.06.031">doi:10.1016/j.jas.2011.06.031</a>.
</p>
<p>Dye, T. S. (2016). Long-Term Rhythms in the Development of Hawaiian
Social Stratification. <em>Journal of Archaeological Science</em>, 71, 1-9.
<a href="https://doi.org/10.1016/j.jas.2016.05.006">doi:10.1016/j.jas.2016.05.006</a>.
</p>
<p>Philippe, A. &amp; Vibet, M.-A. (2020). Analysis of Archaeological Phases Using
the R Package ArchaeoPhases. <em>Journal of Statistical Software, Code
Snippets</em>, 93(1), 1-25. <a href="https://doi.org/10.18637/jss.v093.c01">doi:10.18637/jss.v093.c01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event">event()</a></code>
</p>
<p><code><a href="#topic+event">event()</a></code>
</p>
<p>Other plotting methods: 
<code><a href="#topic+plot_aoristic">plot_aoristic</a></code>,
<code><a href="#topic+plot_fit">plot_fit</a></code>,
<code><a href="#topic+plot_mcd">plot_mcd</a></code>,
<code><a href="#topic+plot_time">plot_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Peeples and Schachner 2012
data("zuni", package = "folio")

## Assume that some assemblages are reliably dated (this is NOT a real example)
zuni_dates &lt;- c(
  LZ0569 = 1097, LZ0279 = 1119, CS16 = 1328, LZ0066 = 1111,
  LZ0852 = 1216, LZ1209 = 1251, CS144 = 1262, LZ0563 = 1206,
  LZ0329 = 1076, LZ0005Q = 859, LZ0322 = 1109, LZ0067 = 863,
  LZ0578 = 1180, LZ0227 = 1104, LZ0610 = 1074
)

## Model the event and accumulation date for each assemblage
model &lt;- event(zuni, zuni_dates, rank = 10)
plot(model, select = 1:10, event = TRUE, flip = TRUE)
</code></pre>

<hr>
<h2 id='plot_fit'>Detection of Selective Processes</h2><span id='topic+plot_fit'></span><span id='topic+plot+2CIncrementTest+2Cmissing-method'></span>

<h3>Description</h3>

<p>Produces an abundance <em>vs</em> time diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IncrementTest,missing'
plot(
  x,
  calendar = getOption("kairos.calendar"),
  col.neutral = "#004488",
  col.selection = "#BB5566",
  col.roll = "grey",
  flip = FALSE,
  ncol = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  sub = NULL,
  ann = graphics::par("ann"),
  axes = TRUE,
  frame.plot = axes,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_fit_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+IncrementTest-class">IncrementTest</a></code> object to be plotted.</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the target calendar
(see <code><a href="aion.html#topic+calendar">calendar()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_col.neutral">col.neutral</code>, <code id="plot_fit_+3A_col.selection">col.selection</code>, <code id="plot_fit_+3A_col.roll">col.roll</code></td>
<td>
<p>A vector of colors.</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_flip">flip</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the y-axis (ticks and numbering) be
flipped from side 2 (left) to 4 (right) from series to series when <code>facet</code>
is &quot;<code>multiple</code>&quot;?</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_ncol">ncol</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the number of columns to use when
<code>facet</code> is &quot;<code>multiple</code>&quot;. Defaults to 1 for up to 4 series, otherwise to 2.</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_xlab">xlab</code>, <code id="plot_fit_+3A_ylab">ylab</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector giving the x and y axis labels.</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_main">main</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_sub">sub</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving a subtitle for the plot.</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_ann">ann</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the default annotation (title and x
and y axis labels) appear on the plot?</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_axes">axes</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should axes be drawn on the plot?</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_frame.plot">frame.plot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should a box be drawn around the
plot?</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to <code>panel</code>
(e.g. <a href="graphics.html#topic+par">graphical parameters</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Results of the frequency increment test can be displayed on an abundance
<em>vs</em> time diagram aid in the detection and quantification of selective
processes in the archaeological record. If <code>roll</code> is <code>TRUE</code>, each time
series is subsetted according to <code>window</code> to see if episodes of selection
can be identified among decoration types that might not show overall
selection. If so, shading highlights the data points where
<code><a href="#topic+fit">fit()</a></code> identifies selection.
</p>


<h3>Value</h3>

<p><code>plot()</code> is called it for its side-effects: it results in a graphic being
displayed (invisibly returns <code>x</code>).
</p>


<h3>Note</h3>

<p>Displaying FIT results on an abundance <em>vs</em> time diagram is adapted from Ben
Marwick's <a href="https://github.com/benmarwick/signatselect/">original idea</a>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit">fit()</a></code>
</p>
<p>Other plotting methods: 
<code><a href="#topic+plot_aoristic">plot_aoristic</a></code>,
<code><a href="#topic+plot_event">plot_event</a></code>,
<code><a href="#topic+plot_mcd">plot_mcd</a></code>,
<code><a href="#topic+plot_time">plot_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Crema et al. 2016
data("merzbach", package = "folio")

## Keep only decoration types that have a maximum frequency of at least 50
keep &lt;- apply(X = merzbach, MARGIN = 2, FUN = function(x) max(x) &gt;= 50)
counts &lt;- merzbach[, keep]

## Group by phase
## We use the row names as time coordinates (roman numerals)
dates &lt;- as.numeric(utils::as.roman(rownames(counts)))

## Frequency Increment Test
freq &lt;- fit(counts, dates, calendar = NULL)

## Plot time vs abundance
plot(freq, calendar = NULL, ncol = 3, xlab = "Phases")

## Plot time vs abundance and highlight selection
freq &lt;- fit(counts, dates, calendar = NULL, roll = TRUE, window = 5)
plot(freq, calendar = NULL, ncol = 3, xlab = "Phases")
</code></pre>

<hr>
<h2 id='plot_mcd'>MCD Plot</h2><span id='topic+plot_mcd'></span><span id='topic+plot+2CMeanDate+2Cmissing-method'></span><span id='topic+plot+2CSimulationMeanDate+2Cmissing-method'></span>

<h3>Description</h3>

<p>MCD Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MeanDate,missing'
plot(
  x,
  calendar = getOption("kairos.calendar"),
  decreasing = TRUE,
  main = NULL,
  sub = NULL,
  ann = graphics::par("ann"),
  axes = TRUE,
  frame.plot = axes,
  panel.first = NULL,
  panel.last = NULL,
  ...
)

## S4 method for signature 'SimulationMeanDate,missing'
plot(
  x,
  calendar = getOption("kairos.calendar"),
  interval = "student",
  level = 0.8,
  decreasing = TRUE,
  main = NULL,
  sub = NULL,
  ann = graphics::par("ann"),
  axes = TRUE,
  frame.plot = axes,
  panel.first = NULL,
  panel.last = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mcd_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+MeanDate-class">MeanDate</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the target calendar
(see <code><a href="#topic+calendar">calendar()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the sort be increasing or
decreasing?</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_main">main</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_sub">sub</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving a subtitle for the plot.</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_ann">ann</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the default annotation (title and x,
y and z axis labels) appear on the plot?</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_axes">axes</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should axes be drawn on the plot?</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_frame.plot">frame.plot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should a box be drawn around the
plot?</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_panel.first">panel.first</code></td>
<td>
<p>An an <code>expression</code> to be evaluated after the plot axes are
set up but before any plotting takes place. This can be useful for drawing
background grids.</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_panel.last">panel.last</code></td>
<td>
<p>An <code>expression</code> to be evaluated after plotting has taken
place but before the axes, title and box are added.</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_...">...</code></td>
<td>
<p>Further <a href="graphics.html#topic+par">graphical parameters</a>.</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_interval">interval</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the type of confidence
interval to be returned. It must be one &quot;<code>student</code>&quot; (the default),
&quot;<code>normal</code>&quot;, &quot;<code>percentiles</code>&quot; or &quot;<code>range</code>&quot; (min-max).
Any unambiguous substring can be given.</p>
</td></tr>
<tr><td><code id="plot_mcd_+3A_level">level</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the confidence level.
Only used if <code>interval</code> is not &quot;<code>range</code>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot()</code> is called it for its side-effects: it results in a graphic being
displayed (invisibly returns <code>x</code>).
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcd">mcd()</a></code>
</p>
<p>Other plotting methods: 
<code><a href="#topic+plot_aoristic">plot_aoristic</a></code>,
<code><a href="#topic+plot_event">plot_event</a></code>,
<code><a href="#topic+plot_fit">plot_fit</a></code>,
<code><a href="#topic+plot_time">plot_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Peeples and Schachner 2012
data("zuni", package = "folio")

## Set the start and end dates for each ceramic type
dates &lt;- list(
  LINO = c(600, 875), KIAT = c(850, 950), RED = c(900, 1050),
  GALL = c(1025, 1125), ESC = c(1050, 1150), PUBW = c(1050, 1150),
  RES = c(1000, 1200), TULA = c(1175, 1300), PINE = c(1275, 1350),
  PUBR = c(1000, 1200), WING = c(1100, 1200), WIPO = c(1125, 1225),
  SJ = c(1200, 1300), LSJ = c(1250, 1300), SPR = c(1250, 1300),
  PINER = c(1275, 1325), HESH = c(1275, 1450), KWAK = c(1275, 1450)
)

## Calculate date midpoints
mid &lt;- vapply(X = dates, FUN = mean, FUN.VALUE = numeric(1))

## Calculate MCD
(mc_dates &lt;- mcd(zuni[100:125, ], dates = mid))

## Get MCD in years CE
time(mc_dates, calendar = CE())

## Plot
plot(mc_dates)

## Bootstrap resampling
boot &lt;- bootstrap(mc_dates, n = 30)
head(boot)

## Jackknife resampling
jack &lt;- jackknife(mc_dates)
head(jack)

## Simulation
sim &lt;- simulate(mc_dates, nsim = 30)
plot(sim, interval = "range", pch = 16)
</code></pre>

<hr>
<h2 id='plot_time'>Abundance vs Time Plot</h2><span id='topic+plot_time'></span><span id='topic+plot_time-method'></span><span id='topic+plot_time+2Cdata.frame+2Cnumeric-method'></span><span id='topic+plot_time+2Cmatrix+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Produces an abundance <em>vs</em> time diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_time(object, dates, ...)

## S4 method for signature 'data.frame,numeric'
plot_time(object, dates, calendar = getOption("kairos.calendar"), ...)

## S4 method for signature 'matrix,numeric'
plot_time(object, dates, calendar = getOption("kairos.calendar"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_time_+3A_object">object</code></td>
<td>
<p>A <code class="reqn">m \times p</code> <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="#topic+data.frame">data.frame</a></code> of count data (absolute frequencies giving the number of
individuals for each category, i.e. a contingency table). A <code><a href="#topic+data.frame">data.frame</a></code>
will be coerced to a <code>numeric</code> <code>matrix</code> via <code><a href="base.html#topic+data.matrix">data.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_time_+3A_dates">dates</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector of dates.</p>
</td></tr>
<tr><td><code id="plot_time_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to <code><a href="aion.html#topic+plot">aion::plot()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_time_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the target calendar
(see <code><a href="#topic+calendar">calendar()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot_time()</code> is called it for its side-effects: it results in a graphic
being displayed (invisibly returns <code>object</code>).
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other plotting methods: 
<code><a href="#topic+plot_aoristic">plot_aoristic</a></code>,
<code><a href="#topic+plot_event">plot_event</a></code>,
<code><a href="#topic+plot_fit">plot_fit</a></code>,
<code><a href="#topic+plot_mcd">plot_mcd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Crema et al. 2016
data("merzbach", package = "folio")

## Coerce the merzbach dataset to a count matrix
## Keep only decoration types that have a maximum frequency of at least 50
keep &lt;- apply(X = merzbach, MARGIN = 2, FUN = function(x) max(x) &gt;= 50)
counts &lt;- merzbach[, keep]

## Set dates
## We use the row names as time coordinates (roman numerals)
dates &lt;- as.numeric(utils::as.roman(rownames(counts)))

## Plot abundance vs time
plot_time(counts, dates, calendar = NULL, ncol = 3, xlab = "Phases")
</code></pre>

<hr>
<h2 id='predict_event'>Predict Event and Accumulation Dates</h2><span id='topic+predict_event'></span><span id='topic+predict_event-method'></span><span id='topic+predict_accumulation'></span><span id='topic+predict_accumulation-method'></span><span id='topic+predict_event+2CEventDate+2Cmissing-method'></span><span id='topic+predict_event+2CEventDate+2Cmatrix-method'></span><span id='topic+predict_accumulation+2CEventDate+2Cmissing-method'></span><span id='topic+predict_accumulation+2CEventDate+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Estimates the event and accumulation dates of an assemblage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_event(object, data, ...)

predict_accumulation(object, data, ...)

## S4 method for signature 'EventDate,missing'
predict_event(object, margin = 1, level = 0.95, calendar = NULL)

## S4 method for signature 'EventDate,matrix'
predict_event(object, data, margin = 1, level = 0.95, calendar = NULL)

## S4 method for signature 'EventDate,missing'
predict_accumulation(object, calendar = NULL)

## S4 method for signature 'EventDate,matrix'
predict_accumulation(object, data, level = 0.95, calendar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_event_+3A_object">object</code></td>
<td>
<p>A <code class="reqn">m \times p</code> <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="#topic+data.frame">data.frame</a></code> of count data (absolute frequencies giving the number of
individuals for each category, i.e. a contingency table). A <code><a href="#topic+data.frame">data.frame</a></code>
will be coerced to a <code>numeric</code> <code>matrix</code> via <code><a href="base.html#topic+data.matrix">data.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="predict_event_+3A_data">data</code></td>
<td>
<p>A <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> or a <code><a href="#topic+data.frame">data.frame</a></code> of count data
(absolute frequencies) for which to predict event and accumulation dates.</p>
</td></tr>
<tr><td><code id="predict_event_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to internal methods.</p>
</td></tr>
<tr><td><code id="predict_event_+3A_margin">margin</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the subscripts which the prediction
will be applied over: <code>1</code> indicates rows, <code>2</code> indicates columns.</p>
</td></tr>
<tr><td><code id="predict_event_+3A_level">level</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the confidence level.</p>
</td></tr>
<tr><td><code id="predict_event_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the target calendar
(see <code><a href="#topic+calendar">calendar()</a></code>). If <code>NULL</code> (the default), <em>rata die</em> are returned.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>predict_event()</code> returns a <code><a href="#topic+data.frame">data.frame</a></code>.
</p>
</li>
<li> <p><code>predict_accumulation()</code> returns a <code><a href="#topic+data.frame">data.frame</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Bellanger, L. &amp; Husi, P. (2013). Mesurer et modéliser le temps inscrit dans
la matière à partir d'une source matérielle : la céramique médiévale.
In <em>Mesure et Histoire Médiévale</em>. Histoire ancienne et médiévale.
Paris: Publication de la Sorbonne, p. 119-134.
</p>
<p>Bellanger, L. &amp; Husi, P. (2012). Statistical Tool for Dating and
Interpreting Archaeological Contexts Using Pottery. <em>Journal of
Archaeological Science</em>, 39(4), 777-790. <a href="https://doi.org/10.1016/j.jas.2011.06.031">doi:10.1016/j.jas.2011.06.031</a>.
</p>
<p>Bellanger, L., Tomassone, R. &amp; Husi, P. (2008). A Statistical Approach for
Dating Archaeological Contexts. <em>Journal of Data Science</em>, 6, 135-154.
</p>
<p>Bellanger, L., Husi, P. &amp; Tomassone, R. (2006). Une approche statistique
pour la datation de contextes archéologiques. <em>Revue de Statistique
Appliquée</em>, 54(2), 65-81.
</p>
<p>Bellanger, L., Husi, P. &amp; Tomassone, R. (2006). Statistical Aspects of
Pottery Quantification for the Dating of Some Archaeological Contexts.
<em>Archaeometry</em>, 48(1), 169-183. <a href="https://doi.org/10.1111/j.1475-4754.2006.00249.x">doi:10.1111/j.1475-4754.2006.00249.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event">event()</a></code>
</p>
<p>Other dating methods: 
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+mcd">mcd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Peeples and Schachner 2012
data("zuni", package = "folio")

## Assume that some assemblages are reliably dated (this is NOT a real example)
zuni_dates &lt;- c(
  LZ0569 = 1097, LZ0279 = 1119, CS16 = 1328, LZ0066 = 1111,
  LZ0852 = 1216, LZ1209 = 1251, CS144 = 1262, LZ0563 = 1206,
  LZ0329 = 1076, LZ0005Q = 859, LZ0322 = 1109, LZ0067 = 863,
  LZ0578 = 1180, LZ0227 = 1104, LZ0610 = 1074
)

## Model the event and accumulation date for each assemblage
model &lt;- event(zuni, zuni_dates, rank = 10)
plot(model, select = 1:10, event = TRUE, flip = TRUE)
</code></pre>

<hr>
<h2 id='RateOfChange-class'>Rate of Change</h2><span id='topic+RateOfChange-class'></span><span id='topic+.RateOfChange'></span>

<h3>Description</h3>

<p>An S4 class to represent rates of change from an aoristic analysis.
</p>


<h3>Slots</h3>


<dl>
<dt><code>replicates</code></dt><dd><p>A non-negative <code><a href="base.html#topic+integer">integer</a></code> giving the number of
replications.</p>
</dd>
<dt><code>groups</code></dt><dd><p>A <code><a href="base.html#topic+character">character</a></code> vector to store the group names (if any).</p>
</dd>
</dl>


<h3>Coerce</h3>

<p>In the code snippets below, <code>x</code> is an <code>AoristicSum</code> object.
</p>

<dl>
<dt><code>as.data.frame(x)</code></dt><dd><p>Coerces to a <code><a href="#topic+data.frame">data.frame</a></code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This class inherits from <code><a href="aion.html#topic+TimeSeries-class">aion::TimeSeries</a></code>: dates are internally
stored as <em><a href="aion.html#topic+RataDie-class">rata die</a></em>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+AoristicSum-class">AoristicSum-class</a></code>,
<code><a href="#topic+CountApportion-class">CountApportion-class</a></code>,
<code><a href="#topic+EventDate-class">EventDate-class</a></code>,
<code><a href="#topic+IncrementTest-class">IncrementTest-class</a></code>,
<code><a href="#topic+MeanDate-class">MeanDate-class</a></code>,
<code><a href="#topic+PermutationOrder-class">PermutationOrder-class</a></code>,
<code><a href="#topic+RefinePermutationOrder-class">RefinePermutationOrder-class</a></code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+replace_NA'></span><span id='topic+replace_zero'></span><span id='topic+remove_NA'></span><span id='topic+remove_zero'></span><span id='topic+remove_constant'></span><span id='topic+calendar'></span><span id='topic+BP'></span><span id='topic+b2k'></span><span id='topic+BC'></span><span id='topic+BCE'></span><span id='topic+AD'></span><span id='topic+CE'></span><span id='topic+start'></span><span id='topic+time'></span><span id='topic+year_axis'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>aion</dt><dd><p><code><a href="aion.html#topic+gregorian">AD</a></code>, <code><a href="aion.html#topic+gregorian">BC</a></code>, <code><a href="aion.html#topic+gregorian">BCE</a></code>, <code><a href="aion.html#topic+gregorian">BP</a></code>, <code><a href="aion.html#topic+gregorian">CE</a></code>, <code><a href="aion.html#topic+gregorian">b2k</a></code>, <code><a href="aion.html#topic+calendar">calendar</a></code>, <code><a href="aion.html#topic+start">start</a></code>, <code><a href="aion.html#topic+start">start</a></code>, <code><a href="aion.html#topic+time">time</a></code>, <code><a href="aion.html#topic+year_axis">year_axis</a></code></p>
</dd>
<dt>arkhe</dt><dd><p><code><a href="arkhe.html#topic+remove_NA">remove_NA</a></code>, <code><a href="arkhe.html#topic+remove_constant">remove_constant</a></code>, <code><a href="arkhe.html#topic+remove_zero">remove_zero</a></code>, <code><a href="arkhe.html#topic+replace_NA">replace_NA</a></code>, <code><a href="arkhe.html#topic+replace_zero">replace_zero</a></code></p>
</dd>
</dl>

<hr>
<h2 id='RefinePermutationOrder-class'>Partial Bootstrap CA</h2><span id='topic+RefinePermutationOrder-class'></span><span id='topic+.RefinePermutationOrder'></span><span id='topic+RefineCA-class'></span>

<h3>Description</h3>

<p>An S4 class to store partial bootstrap correspondence analysis results.
</p>


<h3>Slots</h3>


<dl>
<dt><code>length</code></dt><dd><p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the convex hull maximum
dimension length.</p>
</dd>
<dt><code>cutoff</code></dt><dd><p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the cutoff value for
samples selection.</p>
</dd>
<dt><code>keep</code></dt><dd><p>An <code><a href="base.html#topic+integer">integer</a></code> vector giving the subscript of the variables
to be kept.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+AoristicSum-class">AoristicSum-class</a></code>,
<code><a href="#topic+CountApportion-class">CountApportion-class</a></code>,
<code><a href="#topic+EventDate-class">EventDate-class</a></code>,
<code><a href="#topic+IncrementTest-class">IncrementTest-class</a></code>,
<code><a href="#topic+MeanDate-class">MeanDate-class</a></code>,
<code><a href="#topic+PermutationOrder-class">PermutationOrder-class</a></code>,
<code><a href="#topic+RateOfChange-class">RateOfChange-class</a></code>
</p>

<hr>
<h2 id='resample_event'>Resample Event Dates</h2><span id='topic+resample_event'></span><span id='topic+jackknife+2CEventDate-method'></span><span id='topic+bootstrap+2CEventDate-method'></span>

<h3>Description</h3>


<ul>
<li> <p><code>bootstrap()</code> generate bootstrap estimations of an <a href="#topic+event">event</a>.
</p>
</li>
<li> <p><code>jackknife()</code> generate jackknife estimations of an <a href="#topic+event">event</a>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EventDate'
jackknife(object, level = 0.95, progress = getOption("kairos.progress"), ...)

## S4 method for signature 'EventDate'
bootstrap(
  object,
  level = 0.95,
  probs = c(0.05, 0.95),
  n = 1000,
  progress = getOption("kairos.progress"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_event_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+EventDate-class">EventDate</a></code> object (typically returned by <code><a href="#topic+event">event()</a></code>).</p>
</td></tr>
<tr><td><code id="resample_event_+3A_level">level</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the confidence level.</p>
</td></tr>
<tr><td><code id="resample_event_+3A_progress">progress</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should a progress bar be displayed?</p>
</td></tr>
<tr><td><code id="resample_event_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to internal methods.</p>
</td></tr>
<tr><td><code id="resample_event_+3A_probs">probs</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector of probabilities with values in
<code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="resample_event_+3A_n">n</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+integer">integer</a></code> specifying the number of bootstrap
replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>jackknife()</code> is used, one type/fabric is removed at a
time and all statistics are recalculated. In this way, one can assess
whether certain type/fabric has a substantial influence on the date
estimate.
A three columns <code>data.frame</code> is returned, giving the results of
the resampling procedure (jackknifing fabrics) for each assemblage (in rows)
with the following columns:
</p>

<dl>
<dt><code>mean</code></dt><dd><p>The jackknife mean (event date).</p>
</dd>
<dt><code>bias</code></dt><dd><p>The jackknife estimate of bias.</p>
</dd>
<dt><code>error</code></dt><dd><p>The standard error of predicted means.</p>
</dd>
</dl>

<p>If <code>bootstrap()</code> is used, a large number of new bootstrap assemblages is
created, with the same sample size, by resampling each of the original
assemblage with replacement. Then, examination of the bootstrap statistics
makes it possible to pinpoint assemblages that require further
investigation.
</p>
<p>A five columns <code>data.frame</code> is returned, giving the bootstrap
distribution statistics for each replicated assemblage (in rows)
with the following columns:
</p>

<dl>
<dt><code>min</code></dt><dd><p>Minimum value.</p>
</dd>
<dt><code>mean</code></dt><dd><p>Mean value (event date).</p>
</dd>
<dt><code>max</code></dt><dd><p>Maximum value.</p>
</dd>
<dt><code>Q5</code></dt><dd><p>Sample quantile to 0.05 probability.</p>
</dd>
<dt><code>Q95</code></dt><dd><p>Sample quantile to 0.95 probability.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="#topic+data.frame">data.frame</a></code>.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event">event()</a></code>
</p>
<p>Other resampling methods: 
<code><a href="#topic+resample_mcd">resample_mcd</a></code>
</p>

<hr>
<h2 id='resample_mcd'>Resample Mean Ceramic Dates</h2><span id='topic+resample_mcd'></span><span id='topic+bootstrap+2CMeanDate-method'></span><span id='topic+jackknife+2CMeanDate-method'></span><span id='topic+simulate+2CMeanDate-method'></span>

<h3>Description</h3>


<ul>
<li> <p><code>bootstrap()</code> generate bootstrap estimations of an <a href="#topic+mcd">MCD</a>.
</p>
</li>
<li> <p><code>jackknife()</code> generate jackknife estimations of an <a href="#topic+mcd">MCD</a>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MeanDate'
bootstrap(object, n = 1000, f = NULL, calendar = getOption("kairos.calendar"))

## S4 method for signature 'MeanDate'
jackknife(object, f = NULL, calendar = getOption("kairos.calendar"))

## S4 method for signature 'MeanDate'
simulate(object, nsim = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_mcd_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+MeanDate-class">MeanDate</a></code> object (typically returned by <code><a href="#topic+mcd">mcd()</a></code>).</p>
</td></tr>
<tr><td><code id="resample_mcd_+3A_n">n</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+integer">integer</a></code> specifying the number of bootstrap
replications.</p>
</td></tr>
<tr><td><code id="resample_mcd_+3A_f">f</code></td>
<td>
<p>A <code><a href="base.html#topic+function">function</a></code> that takes a single numeric vector (the result of
the resampling procedure) as argument.</p>
</td></tr>
<tr><td><code id="resample_mcd_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the target calendar
(see <code><a href="#topic+calendar">calendar()</a></code>).</p>
</td></tr>
<tr><td><code id="resample_mcd_+3A_nsim">nsim</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+integer">integer</a></code> specifying the number of simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>f</code> is <code>NULL</code>, <code>bootstrap()</code> and <code>jackknife()</code> return a <code><a href="#topic+data.frame">data.frame</a></code>
with the following elements (else, returns the result of <code>f</code> applied to the
<code>n</code> resampled values) :
</p>

<dl>
<dt>original</dt><dd><p>The observed value.</p>
</dd>
<dt>mean</dt><dd><p>The bootstrap/jackknife estimate of mean.</p>
</dd>
<dt>bias</dt><dd><p>The bootstrap/jackknife estimate of bias.</p>
</dd>
<dt>error</dt><dd><p>The boostrap/jackknife estimate of standard erro.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other resampling methods: 
<code><a href="#topic+resample_event">resample_event</a></code>
</p>

<hr>
<h2 id='roc'>Rate of Change</h2><span id='topic+roc'></span><span id='topic+roc-method'></span><span id='topic+roc+2CAoristicSum-method'></span>

<h3>Description</h3>

<p>Computes the rate of change from an aoristic analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc(object, ...)

## S4 method for signature 'AoristicSum'
roc(object, n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+AoristicSum-class">AoristicSum</a></code> object.</p>
</td></tr>
<tr><td><code id="roc_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="roc_+3A_n">n</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+integer">integer</a></code> giving the number of replications (see
details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+RateOfChange-class">RateOfChange</a></code> object.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Baxter, M. J. &amp; Cool, H. E. M. (2016). Reinventing the Wheel? Modelling
Temporal Uncertainty with Applications to Brooch Distributions in Roman
Britain. <em>Journal of Archaeological Science</em>, 66: 120-27.
<a href="https://doi.org/10.1016/j.jas.2015.12.007">doi:10.1016/j.jas.2015.12.007</a>.
</p>
<p>Crema, E. R. (2012). Modelling Temporal Uncertainty in Archaeological
Analysis. <em>Journal of Archaeological Method and Theory</em>, 19(3): 440-61.
<a href="https://doi.org/10.1007/s10816-011-9122-3">doi:10.1007/s10816-011-9122-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aoristic">aoristic()</a></code>, <code><a href="#topic+plot_aoristic">plot()</a></code>
</p>
<p>Other chronological analysis: 
<code><a href="#topic+aoristic">aoristic</a>()</code>,
<code><a href="#topic+apportion">apportion</a>()</code>,
<code><a href="#topic+fit">fit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Husi 2022
data("loire", package = "folio")

## Get time range
loire_range &lt;- loire[, c("lower", "upper")]

## Calculate aoristic sum (normal)
aorist_raw &lt;- aoristic(loire_range, step = 50, weight = FALSE)
plot(aorist_raw, col = "grey")

## Calculate aoristic sum (weights)
aorist_weighted &lt;- aoristic(loire_range, step = 50, weight = TRUE)
plot(aorist_weighted, col = "grey")

## Calculate aoristic sum (weights) by group
aorist_groups &lt;- aoristic(loire_range, step = 50, weight = TRUE,
                          groups = loire$area)
plot(aorist_groups, flip = TRUE, col = "grey")
image(aorist_groups)

## Rate of change
roc_weighted &lt;- roc(aorist_weighted, n = 30)
plot(roc_weighted)

## Rate of change by group
roc_groups &lt;- roc(aorist_groups, n = 30)
plot(roc_groups, flip = TRUE)
</code></pre>

<hr>
<h2 id='seriate_average'>Correspondence Analysis-Based Seriation</h2><span id='topic+seriate_average'></span><span id='topic+seriate_average-method'></span><span id='topic+seriate_average+2Cdata.frame-method'></span><span id='topic+seriate_average+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Correspondence Analysis-Based Seriation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriate_average(object, ...)

## S4 method for signature 'data.frame'
seriate_average(object, margin = c(1, 2), axes = 1, ...)

## S4 method for signature 'matrix'
seriate_average(object, margin = c(1, 2), axes = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriate_average_+3A_object">object</code></td>
<td>
<p>A <code class="reqn">m \times p</code> <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="#topic+data.frame">data.frame</a></code> of count data (absolute frequencies giving the number of
individuals for each category, i.e. a contingency table). A <code><a href="#topic+data.frame">data.frame</a></code>
will be coerced to a <code>numeric</code> <code>matrix</code> via <code><a href="base.html#topic+data.matrix">data.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="seriate_average_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to internal methods.</p>
</td></tr>
<tr><td><code id="seriate_average_+3A_margin">margin</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the subscripts which the
rearrangement will be applied over: <code>1</code> indicates rows, <code>2</code> indicates
columns, <code>c(1, 2)</code> indicates rows then columns, <code>c(2, 1)</code> indicates columns
then rows.</p>
</td></tr>
<tr><td><code id="seriate_average_+3A_axes">axes</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> vector giving the subscripts of the CA axes to be
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Correspondence analysis (CA) is an effective method for the seriation of
archaeological assemblages. The order of the rows and columns is given by
the coordinates along one dimension of the CA space, assumed to account for
temporal variation. The direction of temporal change within the
correspondence analysis space is arbitrary: additional information is needed
to determine the actual order in time.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+AveragePermutationOrder-class">AveragePermutationOrder</a></code> object.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Ihm, P. (2005). A Contribution to the History of Seriation in Archaeology.
In C. Weihs &amp; W. Gaul (Eds.), <em>Classification: The Ubiquitous
Challenge</em>. Berlin Heidelberg: Springer, p. 307-316.
<a href="https://doi.org/10.1007/3-540-28084-7_34">doi:10.1007/3-540-28084-7_34</a>.
</p>


<h3>See Also</h3>

<p><code><a href="dimensio.html#topic+ca">dimensio::ca()</a></code>
</p>
<p>Other seriation methods: 
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+seriate_rank">seriate_rank</a>()</code>,
<code><a href="#topic+seriate_refine">seriate_refine</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Replicates Desachy 2004 results
data("compiegne", package = "folio")

## Get seriation order for columns on EPPM using the reciprocal averaging method
## Expected column order: N, A, C, K, P, L, B, E, I, M, D, G, O, J, F, H
(indices &lt;- seriate_rank(compiegne, EPPM = TRUE, margin = 2))

## Get permutation order
get_order(indices, 1) # rows
get_order(indices, 2) # columns

## Permute columns
(new &lt;- permute(compiegne, indices))

## See the vignette
## Not run: 
utils::vignette("seriation")

## End(Not run)
</code></pre>

<hr>
<h2 id='seriate_rank'>Reciprocal Ranking Seriation</h2><span id='topic+seriate_rank'></span><span id='topic+seriate_rank-method'></span><span id='topic+seriate_rank+2Cdata.frame-method'></span><span id='topic+seriate_rank+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Reciprocal Ranking Seriation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriate_rank(object, ...)

## S4 method for signature 'data.frame'
seriate_rank(object, EPPM = FALSE, margin = c(1, 2), stop = 100)

## S4 method for signature 'matrix'
seriate_rank(object, EPPM = FALSE, margin = c(1, 2), stop = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriate_rank_+3A_object">object</code></td>
<td>
<p>A <code class="reqn">m \times p</code> <code>numeric</code> <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="#topic+data.frame">data.frame</a></code> of count data (absolute frequencies giving the number of
individuals for each category, i.e. a contingency table). A <code><a href="#topic+data.frame">data.frame</a></code>
will be coerced to a <code>numeric</code> <code>matrix</code> via <code><a href="base.html#topic+data.matrix">data.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="seriate_rank_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="seriate_rank_+3A_eppm">EPPM</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the seriation be computed on EPPM
instead of raw data?</p>
</td></tr>
<tr><td><code id="seriate_rank_+3A_margin">margin</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the subscripts which the
rearrangement will be applied over: <code>1</code> indicates rows, <code>2</code> indicates
columns, <code>c(1, 2)</code> indicates rows then columns, <code>c(2, 1)</code> indicates columns
then rows.</p>
</td></tr>
<tr><td><code id="seriate_rank_+3A_stop">stop</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> giving the stopping rule (i.e. maximum number of
iterations) to avoid infinite loop.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This procedure iteratively rearrange rows and/or columns according to their
weighted rank in the data matrix until convergence.
</p>
<p>Note that this procedure could enter into an infinite loop. If no
convergence is reached before the maximum number of iterations, it stops
with a warning.
</p>


<h3>Value</h3>

<p>A <a href="#topic+RankPermutationOrder-class">RankPermutationOrder</a> object.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Desachy, B. (2004). Le sériographe EPPM: un outil informatisé de sériation
graphique pour tableaux de comptages. <em>Revue archéologique de Picardie</em>,
3(1), 39-56. <a href="https://doi.org/10.3406/pica.2004.2396">doi:10.3406/pica.2004.2396</a>.
</p>
<p>Dunnell, R. C. (1970). Seriation Method and Its Evaluation. <em>American
Antiquity</em>, 35(03), 305-319. <a href="https://doi.org/10.2307/278341">doi:10.2307/278341</a>.
</p>
<p>Ihm, P. (2005). A Contribution to the History of Seriation in Archaeology.
In C. Weihs &amp; W. Gaul (Eds.), <em>Classification: The Ubiquitous
Challenge</em>. Berlin Heidelberg: Springer, p. 307-316.
<a href="https://doi.org/10.1007/3-540-28084-7_34">doi:10.1007/3-540-28084-7_34</a>.
</p>


<h3>See Also</h3>

<p>Other seriation methods: 
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+seriate_average">seriate_average</a>()</code>,
<code><a href="#topic+seriate_refine">seriate_refine</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Replicates Desachy 2004 results
data("compiegne", package = "folio")

## Get seriation order for columns on EPPM using the reciprocal averaging method
## Expected column order: N, A, C, K, P, L, B, E, I, M, D, G, O, J, F, H
(indices &lt;- seriate_rank(compiegne, EPPM = TRUE, margin = 2))

## Get permutation order
get_order(indices, 1) # rows
get_order(indices, 2) # columns

## Permute columns
(new &lt;- permute(compiegne, indices))

## See the vignette
## Not run: 
utils::vignette("seriation")

## End(Not run)
</code></pre>

<hr>
<h2 id='seriate_refine'>Refine CA-based Seriation</h2><span id='topic+seriate_refine'></span><span id='topic+seriate_refine-method'></span><span id='topic+seriate_refine+2CAveragePermutationOrder-method'></span><span id='topic+seriate_refine+2CBootstrapCA-method'></span><span id='topic+hist+2CRefinePermutationOrder-method'></span>

<h3>Description</h3>

<p>Refine CA-based Seriation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriate_refine(object, ...)

## S4 method for signature 'AveragePermutationOrder'
seriate_refine(object, cutoff, margin = 1, axes = 1, n = 30, ...)

## S4 method for signature 'BootstrapCA'
seriate_refine(object, cutoff, margin = 1, axes = 1, ...)

## S4 method for signature 'RefinePermutationOrder'
hist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriate_refine_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+PermutationOrder-class">PermutationOrder</a></code> object (typically returned by
<code><a href="#topic+seriate_average">seriate_average()</a></code>).</p>
</td></tr>
<tr><td><code id="seriate_refine_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to internal methods.</p>
</td></tr>
<tr><td><code id="seriate_refine_+3A_cutoff">cutoff</code></td>
<td>
<p>A function that takes a numeric vector as argument and returns
a single numeric value (see below).</p>
</td></tr>
<tr><td><code id="seriate_refine_+3A_margin">margin</code></td>
<td>
<p>A length-one <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the subscripts which the
refinement will be applied over: <code>1</code> indicates rows, <code>2</code> indicates columns.</p>
</td></tr>
<tr><td><code id="seriate_refine_+3A_axes">axes</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> vector giving the subscripts of the CA axes to be
used.</p>
</td></tr>
<tr><td><code id="seriate_refine_+3A_n">n</code></td>
<td>
<p>A non-negative <code><a href="base.html#topic+integer">integer</a></code> giving the number of bootstrap
replications.</p>
</td></tr>
<tr><td><code id="seriate_refine_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+RefinePermutationOrder-class">RefinePermutationOrder</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>seriate_refine()</code> allows to identify samples that are subject to
sampling error or samples that have underlying structural relationships
and might be influencing the ordering along the CA space.
</p>
<p>This relies on a partial bootstrap approach to CA-based seriation where each
sample is replicated <code>n</code> times. The maximum dimension length of
the convex hull around the sample point cloud allows to remove samples for
a given <code>cutoff</code> value.
</p>
<p>According to Peebles and Schachner (2012), &quot;[this] point removal procedure
[results in] a reduced dataset where the position of individuals within
the CA are highly stable and which produces an ordering consistent with the
assumptions of frequency seriation.&quot;
</p>


<h3>Value</h3>


<ul>
<li> <p><code>seriate_refine()</code> returns a <code><a href="#topic+RefinePermutationOrder-class">RefinePermutationOrder</a></code> object.
</p>
</li>
<li> <p><code>hist()</code> is called it for its side-effects: it results in a histogram
being displayed (invisibly returns <code>x</code>).
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>hist(RefinePermutationOrder)</code>: Compute and plot a histogram of convex hull
maximum dimension length.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>References</h3>

<p>Peeples, M. A., &amp; Schachner, G. (2012). Refining correspondence
analysis-based ceramic seriation of regional data sets. <em>Journal of
Archaeological Science</em>, 39(8), 2818-2827.
<a href="https://doi.org/10.1016/j.jas.2012.04.040">doi:10.1016/j.jas.2012.04.040</a>.
</p>


<h3>See Also</h3>

<p>Other seriation methods: 
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+seriate_average">seriate_average</a>()</code>,
<code><a href="#topic+seriate_rank">seriate_rank</a>()</code>
</p>

<hr>
<h2 id='series'>Sampling Times</h2><span id='topic+series'></span><span id='topic+time+2CEventDate-method'></span><span id='topic+get_dates+2CEventDate-method'></span>

<h3>Description</h3>

<p>Get the times at which a time series was sampled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EventDate'
time(x, calendar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="series_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="series_+3A_calendar">calendar</code></td>
<td>
<p>A <code><a href="aion.html#topic+TimeScale-class">TimeScale</a></code> object specifying the target calendar
(see <code><a href="#topic+calendar">calendar()</a></code>). If <code>NULL</code> (the default), <em>rata die</em> are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+data.frame">data.frame</a></code>,
<code><a href="#topic+model">model</a></code>,
<code><a href="#topic+mutators">mutators</a></code>,
<code><a href="#topic+subset">subset</a>()</code>
</p>

<hr>
<h2 id='subset'>Extract or Replace Parts of an Object</h2><span id='topic+subset'></span><span id='topic++5B+2CMeanDate-method'></span><span id='topic++5B+2CIncrementTest-method'></span><span id='topic++5B+5B+2CPermutationOrder+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Operators acting on objects to extract or replace parts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MeanDate'
x[i, j, k, drop = FALSE]

## S4 method for signature 'IncrementTest'
x[i, j, k, drop = FALSE]

## S4 method for signature 'PermutationOrder,ANY,missing'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>An object from which to extract element(s) or in which to replace
element(s).</p>
</td></tr>
<tr><td><code id="subset_+3A_i">i</code>, <code id="subset_+3A_j">j</code>, <code id="subset_+3A_k">k</code></td>
<td>
<p>Indices specifying elements to extract or replace.</p>
</td></tr>
<tr><td><code id="subset_+3A_drop">drop</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> scalar: should the result be coerced to
the lowest possible dimension? This only works for extracting elements,
not for the replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subsetted object.
</p>


<h3>Author(s)</h3>

<p>N. Frerebeau
</p>


<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+data.frame">data.frame</a></code>,
<code><a href="#topic+model">model</a></code>,
<code><a href="#topic+mutators">mutators</a></code>,
<code><a href="#topic+series">series</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
