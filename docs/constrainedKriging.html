<!DOCTYPE html><html lang="en"><head><title>Help for package constrainedKriging</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {constrainedKriging}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#constrainedKriging-package'><p>Nonlinear Spatial Kriging Predictions under Change of Support</p></a></li>
<li><a href='#ck.colors'><p>Colour Palette</p></a></li>
<li><a href='#CKrige'><p>Constrained, Covariance-matching Constrained and Universal Kriging</p></a></li>
<li><a href='#covmodel'><p>Create isotropic covariance model</p></a></li>
<li><a href='#internal-functions'><p>Internal Functions Exported For Use In Dependent Packages</p></a></li>
<li><a href='#meuse.blocks'><p>Meuse block</p></a></li>
<li><a href='#plot.preCKrigePolygons'><p>Plotting a Polygon Neighbourhood Configuration</p></a></li>
<li><a href='#preCKrige'><p>Spatial Variance-Covariance Matrices for Sets of Points and Polygons</p></a></li>
<li><a href='#preCKrigePoints-class'><p>Class &quot;preCKrigePoints&quot;</p></a></li>
<li><a href='#preCKrigePolygons-class'><p>Class preCKrigePolygons</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.2-11</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Constrained, Covariance-Matching Constrained and Universal Point
or Block Kriging</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-04</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for efficient computation of non-linear spatial predictions with local change of support (Hofer, C. and Papritz, A. (2011) "constrainedKriging: An R-package for customary, constrained and covariance-matching constrained point or block kriging" &lt;<a href="https://doi.org/10.1016%2Fj.cageo.2011.02.009">doi:10.1016/j.cageo.2011.02.009</a>&gt;).  This package supplies functions for two-dimensional spatial interpolation by constrained (Cressie, N. (1993) "Aggregation in geostatistical problems" &lt;<a href="https://doi.org/10.1007%2F978-94-011-1739-5_3">doi:10.1007/978-94-011-1739-5_3</a>&gt;), covariance-matching constrained (Aldworth, J. and Cressie, N. (2003) "Prediction of nonlinear spatial functionals" &lt;<a href="https://doi.org/10.1016%2FS0378-3758%2802%2900321-X">doi:10.1016/S0378-3758(02)00321-X</a>&gt;) and universal (external drift) Kriging for points or blocks of any shape from data with a non-stationary mean function and an isotropic weakly stationary covariance function.  The linear spatial interpolation methods, constrained and covariance-matching constrained Kriging, provide approximately unbiased prediction for non-linear target values under change of support.  This package extends the range of tools for spatial predictions available in R and provides an alternative to conditional simulation for non-linear spatial prediction problems with local change of support.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.9), sp(&ge; 0.9-60)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, methods, parallel, sf(&ge; 1.0-14),
spatialCovariance(&ge; 0.6-4), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gstat, spdep(&ge; 0.5-43)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-04 15:56:48 UTC; papritz</td>
</tr>
<tr>
<td>Author:</td>
<td>Christoph Hofer [aut],
  Andreas Papritz [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Papritz &lt;papritz@retired.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-04 22:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='constrainedKriging-package'>Nonlinear Spatial Kriging Predictions under Change of Support</h2><span id='topic+constrainedKriging-package'></span><span id='topic+constrainedKriging'></span>

<h3>Description</h3>

<p>The package <span class="pkg">constrainedKriging</span> provides functions for
spatial interpolation by <em>constrained</em>,<br />
<em>covariance-matching constrained</em> and <em>universal</em>
(<em>external drift</em>) <em>Kriging</em> for points or blocks of any shape in
a two-dimensional domain from data with a non-stationary mean function and
an isotropic weakly stationary variogram.  The linear spatial interpolation
methods constrained and covariance-matching constrained Kriging provide
approximately unbiased predictions for non-linearly transformed target
values under change of support.
</p>
<p>The package provides two main user functions, <code><a href="#topic+preCKrige">preCKrige</a></code> and
<code><a href="#topic+CKrige">CKrige</a></code>, to calculate spatial predictions in two steps:
</p>
 <ol>
<li> <p><code><a href="#topic+preCKrige">preCKrige</a></code> computes the
variance-covariance matrices for sets of prediction points or
prediction blocks (polygons).
</p>
</li>
<li> <p><code><a href="#topic+CKrige">CKrige</a></code> computes from the output of
<code><a href="#topic+preCKrige">preCKrige</a></code> spatial predictions by one of three Kriging
methods mentioned above.
</p>
</li></ol>


<h3>Details</h3>

<p> The constrained Kriging predictor introduced by
<cite>Cressie (1993)</cite> and the covariance-matching constrained Kriging
predictor proposed by <cite>Aldworth and Cressie (2003)</cite> are linear in the
data like the universal Kriging predictor.  However, the constrained
Kriging predictor satisfies in addition to the unbiasedness constraint of
universal Kriging a second constraint that matches the variances of the
predictions to the variances of the prediction targets (either point values
or block means).  The covariance-matching constrained Kriging predictor
matches for a set of points or blocks both the variances and covariances of
predictions and prediction targets and is the extended version of the
constrained Kriging predictor.  Like constrained Kriging,
covariance-matching constrained Kriging is less biased than universal
Kriging for predictions of non-linearly transformed functionals of a spatial
variable and exactly unbiased if the variable is Gaussian.  We summarize
the formulae of the three Kriging methods below for predicting block means
from point observations, but analogous equations could be given for
problems that do not involve change of support.
</p>
<p>For a set of <code class="reqn">m</code> blocks, <code class="reqn">B_1, \ldots, B_m</code>, the covariance-matching
constrained Kriging predictor is given by
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\mathbf{Y}}_{\mathrm{CMCK}} =
  \mathbf{X}_{m}\widehat{\boldsymbol{\beta}}_{\mathrm{GLS}} +
  \mathbf{K}^{\prime}
  \mathbf{C}^{\prime}\boldsymbol{\Sigma}^{-1} (\mathbf{Z} -
  \mathbf{X}\widehat{\boldsymbol{\beta}}_{\mathrm{GLS}}),
</code>
</p>

<p>where
<code class="reqn">
  \mathbf{Y} = (Y(B_1), \ldots, Y(B_m))^\prime
</code> is the set of block means to be predicted,
with <code class="reqn">Y(B_i)</code> the mean value of
<code class="reqn">Y</code> averaged over the block <code class="reqn">B_i</code>;
<code class="reqn">
  \mathbf{Z} = (Z(\mathbf{s}_{1}), \ldots, Z(\mathbf{s}_{n}))^{^\prime}
</code> is the vector with data
<code class="reqn">
  Z(\mathbf{s}_{i}) = Y(\mathbf{s}_{i}) + \epsilon_i
</code> where the response
<code class="reqn">Y(\mathbf{s}_{i})</code> is possibly contaminated by measurement error
<code class="reqn">\epsilon_i</code>;
<code class="reqn">\mathbf{s} = (x,y)^{\prime}</code> indicates a location in
the survey domain;
<code class="reqn">
  \mathbf{X} = (\mathbf{x}(\mathbf{s}_{1}), \ldots,
  \mathbf{x}(\mathbf{s}_{n}))^{\prime}
</code>
is the design matrix of the data and
<code class="reqn">
  \mathbf{X}_m = (\mathbf{x}(B_{1}), \ldots, \mathbf{x}(B_{m}))^{\prime}
</code>  the design matrix of the target blocks;
<code class="reqn">\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}}</code>
is the vector with the generalised least square estimate of the
linear regression coefficients;
<code class="reqn">
  \mathbf{C} = (\mathbf{c}_{1}, \ldots, \mathbf{c}_{m})
</code> is a <code class="reqn">(n\times m)</code>-matrix that
contains the covariances between the <code class="reqn">n</code> data points and the <code class="reqn">m</code>
prediction targets;
<code class="reqn">\boldsymbol{\Sigma}</code> is the <code class="reqn">(n\times n)</code>-covariance
matrix of the data;
and <code class="reqn">\mathbf{K}</code> is the <code class="reqn">(m \times m)</code>-matrix
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf{K} = \mathbf{Q}_{1}^{-1}\mathbf{P_{1}},
</code>
</p>

<p>where <code class="reqn">\mathbf{P}_{1}</code> is the <code class="reqn">(m \times m)</code>-matrix
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf{P}_{1} = ( \mathrm{Cov}[\mathbf{Y}, \mathbf{Y}^{\prime}] -
    \mathrm{Cov}[\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}},
   (\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}})^{\prime}] )^{\frac{1}{2}}
</code>
</p>

<p>and <code class="reqn">\mathbf{Q}_{1}</code> the <code class="reqn">(m \times m)</code>-matrix
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf{Q}_{1} = (\mathrm{Cov}[\widehat{\mathbf{Y}}_{\mathrm{UK}},
  \widehat{\mathbf{Y}}_{\mathrm{UK}}^{\prime}] -
  \mathrm{Cov}[\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}},
  (\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}})^{\prime}])^{\frac{1}{2}}
</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\mathbf{Y}}_{\mathrm{UK}} =
  \mathbf{X}_{m}\widehat{\boldsymbol{\beta}}_{\mathrm{GLS}} +
  \mathbf{C}^{\prime}\boldsymbol{\Sigma}^{-1} (\mathbf{Z} -
  \mathbf{X}\widehat{\boldsymbol{\beta}}_{\mathrm{GLS}}),
</code>
</p>

<p>denoting the universal Kriging predictor of <code class="reqn">\mathbf{Y}</code>.
</p>
<p>For <code class="reqn">m = 1</code> <code class="reqn">\widehat{\mathbf{Y}}_{\mathrm{CMCK}}</code> reduces
to the constrained Kriging predictor
</p>
<p style="text-align: center;"><code class="reqn">\widehat{Y}_{\mathrm{CK}}(B_1) =
  \mathbf{x}(B_1)^{\prime}\widehat{\boldsymbol{\beta}}_{\mathrm{GLS}} + K
  \mathbf{c_1}^{\prime} \boldsymbol{\Sigma}^{-1} ( \mathbf{Z} -
  \mathbf{X}\widehat{\boldsymbol{\beta}}_{\mathrm{GLS}}) ,
</code>
</p>

<p>with the scalar
</p>
<p style="text-align: center;"><code class="reqn">
  K = (\mathrm{Var}[Y(B_1)] -
  \mathrm{Var}[\mathbf{x}(B_1)^{\prime}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}}] )^{\frac{1}{2}} /
  (\mathrm{Var}[\widehat{Y}_{\mathrm{UK}}(B_1)] - \mathrm{Var}[
  \mathbf{x}(B_1)^{\prime}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}}] )^{\frac{1}{2}} =
  (P/Q)^{\frac{1}{2}}.
</code>
</p>

<p>The mean square prediction error (MSEP) of
<code class="reqn">\widehat{\mathbf{Y}}_{\mathrm{CMCK}}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">
  \mathrm{MSPE}[\widehat{\mathbf{Y}}_{\mathrm{CMCK}}] = \mathrm{MSPE}[
  \widehat{\mathbf{Y}}_{\mathrm{UK}} ] +
  (\mathbf{P}_{1}-\mathbf{Q}_{1})(\mathbf{P}_{1}-\mathbf{Q}_{1}).
</code>
</p>

<p>and of <code class="reqn">\widehat{Y}_{\mathrm{CK}}(B_1)</code> by
</p>
<p style="text-align: center;"><code class="reqn">
  \mathrm{MSPE}[\widehat{Y}_{\mathrm{CK}}(B_{1})] = \mathrm{MSPE}[
  \widehat{Y}_{\mathrm{UK}}(B_{1})] + (P^{\frac{1}{2}} - Q^{\frac{1}{2}})^{2},
</code>
</p>

<p>where the MSEP of universal Kriging is given by
</p>
<p style="text-align: center;"><code class="reqn">
  \mathrm{MSPE}[\widehat{\mathbf{Y}}_\mathrm{UK}] =
  \mathrm{Cov}[\mathbf{Y}, \mathbf{Y}^{\prime}] -
  \mathbf{C}^{\prime}\boldsymbol{\Sigma}^{-1}\mathbf{C} +
  (\mathbf{X}_{m}^{\prime} - \mathbf{X}^{\prime}\boldsymbol{\Sigma}^{-1}\mathbf{C})^{\prime}
  (\mathbf{X}^{\prime}\boldsymbol{\Sigma}^{-1}\mathbf{X})^{-1}
  (\mathbf{X}_{m}^{\prime} - \mathbf{X}^{\prime}\boldsymbol{\Sigma}^{-1}\mathbf{C}).
</code>
</p>



<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a>
</p>


<h3>References</h3>


<p>Aldworth, J. and Cressie, N. (2003). Prediction of non-linear spatial
functionals. <em>Journal of Statistical Planning and Inference</em>,
<b>112</b>, 3&ndash;41, <a href="https://doi.org/10.1016/S0378-3758%2802%2900321-X">doi:10.1016/S0378-3758(02)00321-X</a>.
</p>
<p>Cressie, N. (1993). Aggregation in geostatistical problems. In
A. Soares, editor, <em>Geostatistics Troia 92</em>, <b>1</b>, pages 25&ndash;36,
Dordrecht. Kluwer Academic Publishers, <a href="https://doi.org/10.1007/978-94-011-1739-5_3">doi:10.1007/978-94-011-1739-5_3</a>.
</p>
<p>Hofer, C. and Papritz, A. (2010).  Predicting threshold exceedance by
local block means in soil pollution surveys.  <em>Mathematical
Geosciences</em>.  <b>42</b>, 631&ndash;656, <a href="https://doi.org/10.1007/s11004-010-9287-4">doi:10.1007/s11004-010-9287-4</a>
</p>
<p>Hofer, C. and Papritz, A. (2011).  constrainedKriging: an R-package
for customary, constrained and covariance-matching constrained point
or block Kriging.  <em>Computers &amp; Geosciences</em>. <b>37</b>, 1562&ndash;1569,
<a href="https://doi.org/10.1016/j.cageo.2011.02.009">doi:10.1016/j.cageo.2011.02.009</a>
</p>

<hr>
<h2 id='ck.colors'>Colour Palette</h2><span id='topic+ck.colors'></span>

<h3>Description</h3>

<p>Create a vector of <var>n</var> contiguous colours based on
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ck.colors(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ck.colors_+3A_n">n</code></td>
<td>
<p>a positive integer scalar with the numbers of colours in the
palette.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with <var>n</var> hex colour codes.</p>


<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>ck.colors(3L)
</code></pre>

<hr>
<h2 id='CKrige'>Constrained, Covariance-matching Constrained and Universal Kriging</h2><span id='topic+CKrige'></span><span id='topic+CKrige.points'></span><span id='topic+CKrige.polygons'></span><span id='topic+CKrige-methods'></span><span id='topic+CKrige+2Cformula+2Cdata.frame+2Cformula+2CpreCKrigePoints-method'></span><span id='topic+CKrige+2Cformula+2Cdata.frame+2Cformula+2CpreCKrigePolygons-method'></span><span id='topic+print.CKrige.exout.polygons'></span><span id='topic+summary.CKrige.exout.polygons'></span><span id='topic+print.CKrige.exout.points'></span><span id='topic+summary.CKrige.exout.points'></span>

<h3>Description</h3>

<p>Function computes constrained, covariance-matching
constrained and universal (external drift) Kriging predictions for
points or blocks (of any shape) in a global neighbourhood and for
isotropic covariance models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKrige(formula, data, locations, object, ...)

## S4 method for signature 'formula,data.frame,formula,preCKrigePolygons'
CKrige(formula,
  data, locations, object, method = 2, ex.out = FALSE, ncores = 1L,
  fork = !identical(.Platform[["OS.type"]], "windows"))

## S4 method for signature 'formula,data.frame,formula,preCKrigePoints'
CKrige(formula,
  data, locations, object, method = 2, ex.out = FALSE)
</code></pre>


<h3>Arguments</h3>

 <table role = "presentation">
<tr><td><code id="CKrige_+3A_formula">formula</code></td>
<td>
<p>a formula for the linear regression model
of the spatial variable in the form <code>response ~ terms of
  covariates</code>, for ordinary Kriging use the formula<br /> <code>response ~
  1</code>.</p>
</td></tr>
<tr><td><code id="CKrige_+3A_data">data</code></td>
<td>
<p>a data frame with the values of the covariates for the
observations.  The names of the covariates used in <code>formula</code>
must match the column names of <code>data</code>.</p>
</td></tr>
<tr><td><code id="CKrige_+3A_locations">locations</code></td>
<td>
<p>a one-sided <code>formula</code> that describes the
coordinates of the observations (e.g. <code>~ x+y</code>).</p>
</td></tr>
<tr><td><code id="CKrige_+3A_object">object</code></td>
<td>
<p>either an object of class
&ldquo;<code>preCKrigePolygons</code>&rdquo; for block Kriging or of class
&ldquo;<code>preCKrigePoints</code>&rdquo; for point Kriging as generated by the
<code><a href="#topic+preCKrige">preCKrige</a></code> function.</p>
</td></tr>
<tr><td><code id="CKrige_+3A_...">...</code></td>
<td>
<p>further arguments to control the spatial
interpolation method and the output.</p>
</td></tr>
<tr><td><code id="CKrige_+3A_method">method</code></td>
<td>
<p>a numeric scalar to choose the Kriging approach:
<code>method = 1</code>: universal (external drift), <code>method = 2</code>:
constrained (default) and <code>method = 3</code>: covariance-matching
constrained Kriging.</p>
</td></tr>
<tr><td><code id="CKrige_+3A_ex.out">ex.out</code></td>
<td>
<p>a logical scalar.  If <code>ex.out</code> is set equal to
<code>TRUE</code> <code>CKrige</code> returns an extended output with additional
items, see <em>Value</em> for more information, by default
<code>ex.out = FALSE</code>.</p>
</td></tr>
<tr><td><code id="CKrige_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer scalar with the number of CPUs to
use for parallel computations.</p>
</td></tr>
<tr><td><code id="CKrige_+3A_fork">fork</code></td>
<td>
<p>a logical scalar to control whether parallel
computations are done by forking using <code><a href="parallel.html#topic+mclapply">mclapply</a></code>
(non-windows OSes) or by socket clusters using
<code><a href="parallel.html#topic+parLapply">parLapply</a></code> (windows OS).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>CKrige</code> function depends on a
<code><a href="#topic+preCKrige">preCKrige</a></code> output object that contains the parameters of
the isotropic covariance model, the covariates of the prediction
targets and the variance-covariance matrices of the prediction
targets.</p>


<h3>Value</h3>

<p>If <code>ex.out = FALSE</code> then the function <code>CKrige</code>
returns an object of class &ldquo;<code>SpatialPointsDataFrame</code>&rdquo; or
&ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo;.  The class of the argument
<code>object</code> of <code>CKrige</code><br /> (&ldquo;<code>preCKrigePoints</code>&rdquo; or
&ldquo;<code>preCKrigePolygons</code>&rdquo;) determines whether a
<code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> or <code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code>
is returned.
</p>
<p>Irrespective of the chosen Kriging method, the data frame in the
<code>data</code> slot of the returned object contains the columns:
</p>
<table role = "presentation">
<tr><td><code>prediction</code></td>
<td>
<p>a numeric vector with the Kriging predictions by the
chosen method.</p>
</td></tr>
<tr><td><code>prediction.se</code></td>
<td>
<p>a numeric vector with the root mean square
prediction errors (Kriging standard errors).</p>
</td></tr>
</table>
<p>For constrained Kriging (argument <code>method = 2</code>) the data frame
has 3 additional columns, see<br />
<code><a href="#topic+constrainedKriging-package">constrainedKriging-package</a></code>:
</p>
<table role = "presentation">
<tr><td><code>P1</code></td>
<td>
<p>a numeric vector with
<code class="reqn">P_{1} = (\mathrm{Var}[Y(B_1)] -
  \mathrm{Var}[\mathbf{x}(B_1)^{\prime}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}}] )^{0.5}.
</code>
</p>
</td></tr>
<tr><td><code>Q1</code></td>
<td>
<p>a numeric vector with
<code class="reqn">Q_{1} = (\mathrm{Var}[\widehat{Y}_{\mathrm{UK}}(B_1)] - \mathrm{Var}[
  \mathbf{x}(B_1)^{\prime}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}}] )^{0.5}.
</code>
</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>a numeric vector with <code class="reqn">K = P_{1} / Q_{1}</code>.</p>
</td></tr>
</table>
<p>For covariance-matching constrained Kriging (argument <code>method =
3</code>) the data frame has also 3 additional columns, see
<code><a href="#topic+constrainedKriging-package">constrainedKriging-package</a></code>:
</p>
<table role = "presentation">
<tr><td><code>P1.11</code></td>
<td>
<p>a numeric vector with first diagonal elements
(which correspond to the target blocks) of the matrices
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf{P}_{1} = ( \mathrm{Cov}[\mathbf{Y}, \mathbf{Y}^{\prime}] -
    \mathrm{Cov}[\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}},
   (\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}})^{\prime}] )^{\frac{1}{2}}.
</code>
</p>

</td></tr>
<tr><td><code>Q1.11</code></td>
<td>
<p>a numeric vector with first diagonal elements of the matrices
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf{Q}_{1} = (\mathrm{Cov}[\widehat{\mathbf{Y}}_{\mathrm{UK}},
  \widehat{\mathbf{Y}}_{\mathrm{UK}}^{\prime}] -
  \mathrm{Cov}[\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}},
  (\mathbf{X}_{m}\widehat{\boldsymbol{\boldsymbol{\beta}}}_{\mathrm{GLS}})^{\prime}])^{\frac{1}{2}}.
</code>
</p>

</td></tr>
<tr><td><code>K.11</code></td>
<td>
<p>a numeric vector with first diagonal elements of the matrices
of the matrices
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf{K} = \mathbf{Q}_{1}^{-1}\mathbf{P_{1}}.
</code>
</p>

</td></tr>
</table>
<p>If the argument <code>ex.out = TRUE</code> is used and the argument
<code>method</code> is either equal to <code>1</code> (universal) or <code>2</code>
(constrained Kriging) then the function <code>CKrige</code> returns an
object either of class<br /> &ldquo;<code>CKrige.exout.polygons</code>&rdquo; or
&ldquo;<code>CKrige.exout.points</code>&rdquo;, which are lists with the
following components:
</p>
<table role = "presentation">
<tr><td><code>object</code></td>
<td>
<p>either an object of class
&ldquo;<code>SpatialPointsDataFrame</code>&rdquo; or<br />
&ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo; as described above.</p>
</td></tr>
<tr><td><code>krig.method</code></td>
<td>
<p>a numeric scalar, number of the chosen Kriging
<code>method</code> (1, 2).</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>a list with 2 components.  First component
<code>beta.coef</code> is the vector with the generalized least squares
estimates of the linear regression coefficients, and the second
component <code>cov.beta</code> contains the covariance matrix of the
generalized least squares estimates.</p>
</td></tr>
<tr><td><code>sk.weights</code></td>
<td>
<p>a matrix with the simple Kriging weights.  The
<var>i</var>th column contains the simple Kriging weights for the <var>i</var>th
prediction target.
</p>
</td></tr>
<tr><td><code>inv.Sigma</code></td>
<td>
<p>a matrix with the inverse covariance matrix
<code class="reqn">\boldsymbol{\Sigma}^{-1}</code> of the observations.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a numeric vector with the generalized least squares
residuals of the linear regression.</p>
</td></tr>
</table>
<p>If the argument <code>ex.out = TRUE</code> is used and the argument
<code>method</code> is either equal to <code>3</code> (covariance-matching
constrained kriging) then the function <code>CKrige</code> returns an object
either of class<br /> &ldquo;<code>CKrige.exout.polygons</code>&rdquo; or
&ldquo;<code>CKrige.exout.points</code>&rdquo;, which are lists with the
following components:
</p>
<table role = "presentation">
<tr><td><code>object</code></td>
<td>
<p>either an object of class
&ldquo;<code>SpatialPointsDataFrame</code>&rdquo; or<br />
&ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo; as described above.</p>
</td></tr>
<tr><td><code>krig.method</code></td>
<td>
<p>a numeric scalar, number of the chosen Kriging
<code>method</code> (3).</p>
</td></tr>
<tr><td><code>CMCK.par</code></td>
<td>
<p>a list of 3 lists with the following components:
</p>

<ul>
<li> <p><code>P1</code> a list of matrices <code class="reqn">\mathbf{P}_1</code> for all
point or polygon neighbourhood configurations (the first row and
columns correspond to the target points or blocks of the
configurations).
</p>
</li>
<li> <p><code>Q1</code> a list of matrices <code class="reqn">\mathbf{Q}_1</code> for all
point or polygon neighbourhood configurations  (the first row and
columns correspond to the target points or blocks of the
configurations).
</p>
</li>
<li> <p><code>K</code> a list of matrices <code class="reqn">\mathbf{K}</code> for all
polygon neighbourhood configurations  (the first row and
columns correspond to the target points or blocks of the
configurations).
</p>
</li></ul>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>a list with 2 components.  First component
<code>beta.coef</code> is the vector with the generalized least squares
estimates of the linear regression coefficients, and the second
component <code>cov.beta</code> contains the covariance matrix of the
generalized least squares estimates.</p>
</td></tr>
<tr><td><code>sk.weights</code></td>
<td>
<p>a list with the simple Kriging weights of all point
or polygon neighbourhood configurations (the first columns contain the
weights of the target points or blocks of the configurations).
</p>
</td></tr>
<tr><td><code>inv.Sigma</code></td>
<td>
<p>a matrix with the inverse covariance matrix
<code class="reqn">\boldsymbol{\Sigma}^{-1}</code> of the observations.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a numeric vector with the generalized least squares
residuals of the linear regression.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>print</code> and <code>summary</code> methods are available for
<code>CKrige</code> output object of the classes
&ldquo;<code>CKrige.exout.polygons</code>&rdquo; and
&ldquo;<code>CKrige.exout.points</code>&rdquo;.</p>


<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a></p>


<h3>References</h3>

<p>Cressie, N. (2006) Block Kriging for Lognormal Spatial Processes.
<em>Mathematical Geology</em>, <b>38</b>, 413&ndash;443,
<a href="https://doi.org/10.1007/s11004-005-9022-8">doi:10.1007/s11004-005-9022-8</a>.
</p>
<p>Hofer, C. and Papritz, A. (2011).  constrainedKriging: an R-package
for customary, constrained and covariance-matching constrained point
or block Kriging.  <em>Computers &amp; Geosciences</em>. <b>37</b>, 1562&ndash;1569,
<a href="https://doi.org/10.1016/j.cageo.2011.02.009">doi:10.1016/j.cageo.2011.02.009</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+preCKrige">preCKrige</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
### load meuse data
data(meuse, package = "sp")
data(meuse.grid, package = "sp")
data(meuse.blocks)

### convert data frame meuse.grid to SpatialPointsDataFrame
coordinates(meuse.grid) &lt;- ~ x+y

### plot blocks along with observation locations
plot(meuse.blocks)
points(y ~ x, meuse, cex = 0.5)


### example 1: lognormal constrained block Kriging
### cf. Hofer &amp; Papritz, 2011, pp. 1567

### compute the approximated block variance of each block in meuse.blocks
### without any neighbouring blocks (default, required for in universal
### and constrained Kriging) for an exponential covariance function without
### a measurement error, a nugget = 0.15 (micro scale white noise process),
### a partial sill variance = 0.15 and a scale parameter = 192.5
### approximation of block variance by pixels of size 75m x 75m
preCK_block &lt;- preCKrige(newdata = meuse.blocks, model = covmodel(modelname =
    "exponential", mev = 0, nugget = 0.05, variance = 0.15,
    scale = 192.5), pwidth = 75, pheight = 75)

### block prediction by constrained Kriging on the log scale
### extended output required for backtransformation
CK_block &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCK_block, ex.out = TRUE)

### backtransformation of the CK predictions to original scale
### cf Hofer &amp; Papritz, 2011, eq. (14), p. 1567
### note that Var(\hat{Y}{B}) = Var(Y(B))!
beta &lt;- CK_block$parameter$beta.coef
M &lt;- meuse.blocks@data$M
var.blockmeans &lt;- unlist(preCK_block@covmat)
CK_block$object@data$Zn &lt;- exp(CK_block$object@data$prediction
  + 0.5*(0.2 + beta[2]^2 * M - var.blockmeans))

### upper limits U of the relative 95%  prediction intervals for CK
### U multiplied by the predictions CK_block$object@data$Zn gives
### the upper limits of the 95% prediction intervals
CK_block$object@data$U &lt;- exp(CK_block$object@data$prediction
    + 1.96 * CK_block$object@data$prediction.se) / CK_block$object@data$Zn

### plot the CK predictions of Zn and the upper limits of relative 95%
### prediction intervals by function spplot of sp package
### function ck.colors(n) creates a rainbow-like color vector
breaks &lt;- seq(0, 1850, by = 185)
spplot(CK_block$object, zcol = "Zn", at = breaks, col.regions = ck.colors(10),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "CK predictions of Zn block means")

### plot of upper limits of the relative 95% prediction intervals
breaks &lt;- seq(1, 3.2, by = 0.2)
spplot(CK_block$object, zcol = "U", at = breaks, col.regions = ck.colors(11),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "Upper limits rel. prediction intervals CK predictions")



### example 2: lognormal covariance-matching constrained block Kriging

### define neighbours by using the poly2nb function of spdep package
if(!requireNamespace("spdep", quietly = TRUE)){
  stop("install package spdep to run example")
}
neighbours_block &lt;- spdep::poly2nb(meuse.blocks)
class(neighbours_block)
### neighbours_block should be an object of class "list"
class(neighbours_block) &lt;- "list"

### compute the approximated block variance-covariance matrices of each
### polygon neighbourhood configuration (= target block plus its
### neighbours)
preCMCK_block &lt;- preCKrige(newdata = meuse.blocks, neighbours = neighbours_block,
  model = covmodel("exponential", mev = 0, nugget = 0.05, variance = 0.15,
    scale = 192.5), pwidth = 75, pheight = 75)

### block prediction by covariance-matching constrained Kriging on log
### scale
CMCK_block &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCMCK_block, method = 3, ex.out = TRUE)

### backtransformation of the CK predictions to the original scale
### cf Hofer &amp; Papritz, 2011, eq. (14), p. 1567
beta &lt;- CMCK_block$parameter$beta.coef
M &lt;- meuse.blocks@data$M
var.blockmeans &lt;- sapply(preCMCK_block@covmat, function(x) x[1, 1])
CMCK_block$object@data$Zn &lt;- exp(CMCK_block$object@data$prediction
  + 0.5*(0.2 + beta[2]^2 * M - var.blockmeans))

### plot the CMCK predictions of Zn by function spplot of sp package
### function ck.colors(n) creates a rainbow-like color vector
breaks &lt;- seq(0, 1850, by = 185)
spplot(CMCK_block$object, zcol = "Zn", at = breaks, col.regions = ck.colors(10),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "CMCK predictions of Zn block means")



### example 3: lognormal universal block Kriging

### block prediction by universal Kriging on log scale
UK_block &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCK_block, method = 1, ex.out = TRUE)

### backtransformation of the CK predictions to the original scale
### cf Hofer &amp; Papritz, 2011, Appendix B, pp. 1568 - 1569
beta &lt;- UK_block$parameter$beta.coef
cov.beta &lt;- UK_block$parameter$cov.beta.coef
M &lt;- meuse.blocks@data$M
var.blockmeans &lt;- unlist(preCK_block@covmat)
SKw &lt;-  UK_block$sk.weights
X &lt;-  model.matrix(~sqrt(dist), meuse)
XB &lt;- model.matrix(~sqrt(dist), meuse.blocks)
c1 &lt;- 0.5 * (0.2 + beta[2]^2*M - var.blockmeans +
  UK_block$object@data$prediction.se^2)
c2 &lt;- rowSums((XB - t(SKw) %*% X) * (XB %*% cov.beta))
UK_block$object@data$Zn &lt;- exp(UK_block$object@data$prediction + c1 - c2)

### upper limits U of the relative 95%  prediction intervals for CK
### U multiplied by the predictions UK_block$object@data$Zn gives
### the upper limits of the 95% prediction intervals
UK_block$object@data$U &lt;- exp(UK_block$object@data$prediction
    + 1.96 * UK_block$object@data$prediction.se) / UK_block$object@data$Zn

### plot the UK predictions of Zn by function spplot of sp package
### function ck.colors(n) creates a rainbow-like color vector
breaks &lt;- seq(0, 1850, by = 185)
spplot(UK_block$object, zcol = "Zn", at = breaks, col.regions = ck.colors(10),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "UK predictions of Zn block means")

### plot of upper limits of the relative 95% prediction intervals
breaks &lt;- seq(1, 3.2, by = 0.2)
spplot(UK_block$object, zcol = "U", at = breaks, col.regions = ck.colors(11),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "Upper limits rel. prediction intervals UK predictions")



### example 4: constrained point Kriging
### generate point CK preCKrige object for locations in meuse.grid
preCK_point &lt;- preCKrige(newdata = meuse.grid, model = covmodel(modelname =
    "exponential", mev = 0, nugget = 0.05, variance = 0.15,
    scale = 192.5))

### point prediction by constrained Kriging on the log scale
### no extended output required for backtransformation
CK_point &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCK_point)

### backtransformation of the CK predictions to the original scale
### cf. Cressie, 2006, eq. (20), p. 421
### note that Var(\hat{Y}{s_0}) = Var(Y(s_0))!
CK_point@data$Zn &lt;- exp(CK_point@data$prediction)

### convert results object to SpatialGridDataFrame
gridded(CK_point) &lt;- TRUE
fullgrid(CK_point) &lt;- TRUE

### plot the CK predictions of Zn by function spplot of sp package
breaks &lt;- seq(0, 2600, by = 185)
spplot(CK_point, zcol = "Zn", at = breaks, col.regions = ck.colors(20),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "CK predictions of Zn point values")



### example 5: covariance-matching constrained point Kriging
### define 4 nearest neighbours to each grid location by using the
### knearneigh function of the spdep package
if(!requireNamespace("spdep", quietly = TRUE)){
  stop("install package spdep to run example")
}
neighbours_point &lt;- spdep::knearneigh(meuse.grid, k = 4)
### convert matrix with neighbours indices to list
neighbours_point &lt;- apply(neighbours_point$nn, 1, FUN = function(x) x,
  simplify = FALSE)

### generate point CMCK preCKrige object for locations in meuse.grid
preCMCK_point &lt;- preCKrige(newdata = meuse.grid, neighbours = neighbours_point,
  model = covmodel(modelname = "exponential", mev = 0, nugget = 0.05,
    variance = 0.15, scale = 192.5))

### point prediction by covariance-matching constrained Kriging on the log
### scale
### no extended output required for backtransformation
CMCK_point &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCMCK_point, method = 3)

### backtransformation of the CMCK predictions to the original scale
### cf. Cressie, 2006, eq. (20), p. 421
### note that Var(\hat{Y}{s_0}) = Var(Y(s_0))!
CMCK_point@data$Zn &lt;- exp(CMCK_point@data$prediction)

### convert results object to SpatialGridDataFrame
gridded(CMCK_point) &lt;- TRUE
fullgrid(CMCK_point) &lt;- TRUE

### plot the CMCK predictions of Zn by function spplot of sp package
breaks &lt;- seq(0, 2600, by = 185)
spplot(CMCK_point, zcol = "Zn", at = breaks, col.regions = ck.colors(20),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "CMCK predictions of Zn point values")



### example 6: universal point Kriging
UK_point &lt;- CKrige(formula = log(zinc) ~ sqrt(dist), data = meuse,
  locations = ~ x+y, object = preCK_point, method = 1, ex.out = TRUE)

### backtransformation of the UK predictions to the original scale cf.
### Cressie, 2006, eq.  (20), p.  421 and Hofer &amp; Papritz, 2011, Appendix
### B, p.  1569
cov.beta &lt;- UK_point$parameter$cov.beta.coef
SKw &lt;- UK_point$sk.weights
X &lt;-  model.matrix(~sqrt(dist), meuse)
Xgrid &lt;- model.matrix(~sqrt(dist), meuse.grid)
### universal kriging variances
c1 &lt;- 0.5 * UK_point$object@data$prediction.se^2
### \psi^' x(s_0)
c2 &lt;- rowSums((Xgrid - t(SKw) %*% X) * (Xgrid %*% cov.beta))
UK_point$object@data$Zn &lt;- exp(UK_point$object@data$prediction + c1 - c2)

### convert results object to SpatialGridDataFrame
gridded(UK_point$object) &lt;- TRUE
fullgrid(UK_point$object) &lt;- TRUE

### plot the CMCK predictions of Zn by function spplot of sp package
breaks &lt;- seq(0, 2600, by = 185)
spplot(UK_point$object, zcol = "Zn", at = breaks, col.regions = ck.colors(20),
  colorkey = list(labels = list(at = breaks, labels = breaks)),
  main = "UK predictions of Zn point values")




### example 7: universal block Kriging of mean over whole domain
### cf chapter 4 of vignette of package georob
### (https://CRAN.R-project.org/package=georob)
if(!requireNamespace("gstat", quietly = TRUE)){
  stop("install package gstat to run example")
}
### load coalash data
data(coalash, package="gstat")

### generate SpatialPointsDataFrame covering entire domain of coalash data
coalash.domain &lt;- rbind(c(0.5,0), c(16.5,0), c(16.5,24), c(0.5,24), c(0.5,0))
coalash.domain &lt;- SpatialPolygonsDataFrame(
  SpatialPolygons(list(Polygons(list(Polygon(coalash.domain)), ID= "domain"))),
  data=data.frame(x=8.5,y=12,row.names="domain"))

### universal block Kriging
preCK_coalash &lt;- preCKrige(newdata = coalash.domain, model = covmodel(modelname =
    "exponential", mev = 1.023, nugget = 0, variance = 0.268,
    scale = 1.907), pwidth = 16, pheight = 24)
UK_coalash &lt;- CKrige(formula = coalash ~ x, data = coalash,
  locations = ~ x+y, object = preCK_coalash, method = 1)
slot( UK_coalash, "data")
</code></pre>

<hr>
<h2 id='covmodel'>Create isotropic covariance model
</h2><span id='topic+covmodel'></span><span id='topic+covmodellist'></span><span id='topic+print.covmodel'></span>

<h3>Description</h3>

<p>Function to generate isotropic covariance models or to add an
isotropic covariance model to an existing isotropic model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmodel(modelname, mev, nugget,variance, scale, parameter, add.covmodel)

## S3 method for class 'covmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covmodel_+3A_modelname">modelname</code></td>
<td>
<p>a character scalar with the name of an isotropic
covariance model, see <em>Details</em> for a list of implemented models.  A
call of <code>covmodel()</code> without any function argument displays a table
with all available models and their parameters, see <em>Examples</em>.</p>
</td></tr>
<tr><td><code id="covmodel_+3A_mev">mev</code></td>
<td>
<p>a numeric scalar, variance of the measurement error.</p>
</td></tr>
<tr><td><code id="covmodel_+3A_nugget">nugget</code></td>
<td>
<p>a numeric scalar, variance of microstructure white noise
process with range smaller than the minimal distance between any
pair of support data.</p>
</td></tr>
<tr><td><code id="covmodel_+3A_variance">variance</code></td>
<td>
<p>a numeric scalar, partial sill of the covariance model.</p>
</td></tr>
<tr><td><code id="covmodel_+3A_scale">scale</code></td>
<td>
<p>a numeric scalar, scale (&quot;range&quot;) parameter of the covariance
model.</p>
</td></tr>
<tr><td><code id="covmodel_+3A_parameter">parameter</code></td>
<td>
<p>a numeric vector of further covariance parameters, missing
for some model like <code>nugget</code>, <code>spherical</code> or <code>gauss</code>, etc,
see <em>Details</em>.  If a model has several extra parameters, say
<code>a</code>, <code>b</code>, ...  then they must be given as <code>c(a, b, ...)</code>.
</p>
</td></tr>
<tr><td><code id="covmodel_+3A_add.covmodel">add.covmodel</code></td>
<td>
<p>an object of the class <code>covmodel</code> that is added to
the covariance model defined by <code>modelname</code> (see examples)</p>
</td></tr>
<tr><td><code id="covmodel_+3A_x">x</code></td>
<td>
<p>a covariance model generated by <code>covmodel</code></p>
</td></tr>
<tr><td><code id="covmodel_+3A_...">...</code></td>
<td>
<p>further printing arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name and parametrisation of the covariance models originate from the
function <code>CovarianceFct</code> of the archived package <span class="pkg">RandomFields</span>,
version 2.0.71.
</p>
<p>The following isotropic covariance functions are implemented (equations
taken from help page of function <code>CovarianceFct</code> of archived package
<span class="pkg">RandomFields</span>, version 2.0.71, note that the variance and range
parameters are equal to 1 in the following formulae and <code class="reqn">h</code> is the
lag distance.):
</p>

<ul>
<li> <p><code>bessel</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=2^a \Gamma(a+1)h^{-a} J_a(h)</code>
</p>

<p>For a 2-dimensional region, the parameter <code class="reqn">a</code> must be greater than
or equal to 0.
</p>
</li>
<li> <p><code>cauchy</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=\left(1+h^2\right)^{-a}</code>
</p>

<p>The parameter <code class="reqn">a</code> must be positive.
</p>
</li>
<li> <p><code>cauchytbm</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)= (1+(1-b/3)h^a)(1+h^a)^{(-b/a-1)}</code>
</p>

<p>The parameter <code class="reqn">a</code> must be in (0,2] and  <code class="reqn">b</code>
positive.
The model is valid for 3 dimensions.
It allows for simulating random fields where
fractal dimension and Hurst coefficient can be chosen
independently.
</p>
</li>
<li> <p><code>circular</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=
      \left(1-\frac 2\pi
      \left(h \sqrt{1-h^2} +
      \arcsin(h)\right)\right)
      1_{[0,1]}(h)</code>
</p>

<p>This isotropic covariance function is valid only for dimensions
less than or equal to 2.
</p>
</li>
<li> <p><code>constant</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=1</code>
</p>

</li>
<li> <p><code>cubic</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=(1- 7h^2+8.75h^3-3.5h^5+0.75 h^7)1_{[0,1]}(h)</code>
</p>

<p>This model is valid only for dimensions less than or equal to 3.
It is a 2 times differentiable covariance functions with compact
support.
</p>
</li>
<li> <p><code>dampedcosine</code> (hole effect model)
</p>
<p style="text-align: center;"><code class="reqn">C(h)= e^{-a h} \cos(h)</code>
</p>

<p>This model is valid for 2 dimensions iff <code class="reqn">a \ge 1</code>.
</p>
</li>
<li> <p><code>exponential</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=e^{-h}</code>
</p>

<p>This model is a special case of the <code>whittle</code> model
(for <code class="reqn">a=0.5</code>)
and the <code>stable</code> model (for <code class="reqn">a = 1</code>).
</p>
</li>
<li> <p><code>gauss</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=e^{-h^2}</code>
</p>

<p>This model is a special case of the <code>stable</code> model
(for <code class="reqn">a=2</code>).
See <code>gneiting</code> for an alternative model that does not have
the disadvantages of the Gaussian model.
</p>
</li>
<li> <p><code>gencauchy</code> (generalised <code>cauchy</code>)
</p>
<p style="text-align: center;"><code class="reqn">C(h)= \left(1+h^a\right)^{(-b/a)}</code>
</p>

<p>The parameter <code class="reqn">a</code> must be in (0,2] and <code class="reqn">b</code>
positive.
This model allows for random fields where
fractal dimension and Hurst coefficient can be chosen
independently.
</p>
</li>
<li> <p><code>gengneiting</code> (generalised <code>gneiting</code>)
If <code class="reqn">a=1</code> and let <code class="reqn">\beta = b+1</code> then
</p>
<p style="text-align: center;"><code class="reqn">C(h)=\left(1+\beta h\right) (1-h)^{\beta}
      1_{[0,1]}(h)</code>
</p>

<p>If <code class="reqn">a=2</code>  and let <code class="reqn">\beta = b+2</code> then
</p>
<p style="text-align: center;"><code class="reqn">C(h)=\left(1+\beta h+\left(\beta ^2-1\right)h^2/3\right)
      (1-h)^{\beta}  1_{[0,1]}(h)</code>
</p>

<p>If <code class="reqn">a=3</code>   and let <code class="reqn">\beta = b+3</code> then
</p>
<p style="text-align: center;"><code class="reqn">C(h)=\left(1+\beta h+\left(2\beta ^2-3\right)\frac{h^2}{5}
      +\left(\beta ^2-4\right)\beta \frac{h^3}{15}\right)(1-h)^{\beta}
      1_{[0,1]}(h)</code>
</p>

<p>The parameter <code class="reqn">a</code> is a positive integer; here only the
cases <code class="reqn">a=1, 2, 3</code> are implemented.
For two dimensional regions the parameter <code class="reqn">b</code> must greater than or equal to
<code class="reqn">(2 + 2a +1)/2</code>.
</p>
</li>
<li> <p><code>gneiting</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=\left(1 + 8 sh + 25 (sh)^2 + 32
      (sh)^3\right)(1-sh)^8 1_{[0,1]}(sh)</code>
</p>

<p>where
<code class="reqn">s=0.301187465825</code>.
This  covariance function is valid only for dimensions less
than or equal to 3.
It is a 6 times differentiable covariance functions with compact
support.
It is an alternative to the <code>gaussian</code> model since
its graph is visually hardly distinguishable from the graph of
the Gaussian model, but possesses neither the mathematical and nor the
numerical disadvantages of the Gaussian model.
</p>
</li>
<li> <p><code>hyperbolic</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)= c^{-b}(K_{b}(a c))^{-1}
      ( c^2 + h^2 )^{b/2}
      K_{b}(
      a [ c^2 + h^2 ]^{1/2} )</code>
</p>

<p>The parameters are such that<br />
<code class="reqn">c\ge0</code>,  <code class="reqn">a&gt;0</code>  and
<code class="reqn">b&gt;0,\quad</code>
or<br />
<code class="reqn">c&gt;0</code>,  <code class="reqn">a&gt;0</code>  and  <code class="reqn">b=0,\quad</code>
or<br />
<code class="reqn">c&gt;0</code>,  <code class="reqn">a\ge0</code>, and   <code class="reqn">b&lt;0</code>.<br />
Note that this class is over-parametrised; always one
of the three parameters
<code class="reqn">a</code>, <code class="reqn">c</code>, and scale
can be eliminated in the formula.
</p>
</li>
<li> <p><code>lgd1</code> (local-global distinguisher)
</p>
<p style="text-align: center;"><code class="reqn">C(h)=
      1 - \frac{b}{a+b} h^{a}, h \le 1 \qquad \hbox{and} \qquad
      \frac{a}{a+b} h^{-b}, h &gt; 1
    </code>
</p>

<p>Here <code class="reqn">b&gt;0</code> and <code class="reqn">a</code> msut be in
<code class="reqn">(0,0.5]</code>.
The random field has for 2-dimensional regions fractal dimension
<code class="reqn">3 - a/2</code>
and Hurst coefficient <code class="reqn">1 -b/2</code> for
<code class="reqn">b \in (0,1]</code>
</p>
</li>
<li> <p><code>matern</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)= 2^{1-a} \Gamma(a)^{-1}
       (\sqrt{2 a} h)^a K_a(\sqrt{2 a}h)</code>
</p>

<p>The parameter <code class="reqn">a</code> must be positive.
This is the model of choice if the smoothness of a random field is to
be parametrised: if <code class="reqn">a &gt; m</code> then the
graph is <code class="reqn">m</code> times differentiable.
</p>
</li>
<li> <p><code>nugget</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=1_{[0]}(h)</code>
</p>

</li>
<li> <p><code>penta</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)= \left(1 - \frac{22}3 h^2 +33 h^4 -
      \frac{77}2 h^5 + \frac{33}2
      h^7 -\frac{11}2 h^9 + \frac 56 h^{11}
      \right)1_{[0,1]}(h)</code>
</p>

<p>valid only for dimensions less than or equal to 3.
This is a 4 times differentiable covariance functions with compact
support.
</p>
</li>
<li> <p><code>power</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)= (1-h)^a 1_{[0,1]}(h)</code>
</p>

<p>This covariance function is valid for 2 dimensions iff
<code class="reqn">a \ge 1.5</code>.
For <code class="reqn">a=1</code> we get the well-known triangle (or tent)
model, which is valid on the real line, only.
</p>
</li>
<li> <p><code>qexponential</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)= ( 2 e^{-h} - a e^{-2x} ) / ( 2 - a )</code>
</p>

<p>The parameter <code class="reqn">a</code> must be in <code class="reqn">[0,1]</code>.
</p>
</li>
<li> <p><code>spherical</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=\left(1- 1.5 h+0.5 h^3\right) 1_{[0,1]}(h)</code>
</p>

<p>This  covariance function is valid only for dimensions
less than or equal to 3.
</p>
</li>
<li> <p><code>stable</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=\exp\left(-h^a\right)</code>
</p>

<p>The parameter <code class="reqn">a</code> must be in <code class="reqn">(0,2]</code>.
See <code>exponential</code> and <code>gaussian</code> for special cases.
</p>
</li>
<li> <p><code>wave</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h)=\frac{\sin h}{h}, \quad h&gt;0 \qquad \hbox{and } \qquad C(0)=1</code>
</p>

<p>This isotropic covariance function is valid only for dimensions less
than or equal to 3.
It is a special case of the <code>bessel</code> model
(for <code class="reqn">a=0.5</code>).
</p>
</li>
<li> <p><code>whittle</code>
</p>
<p style="text-align: center;"><code class="reqn">C(h) = 2^{1-a} \Gamma(a)^{-1} h^a
      K_a(h)</code>
</p>

<p>The parameter <code class="reqn">a</code> must be positive.
This is the model of choice if the smoothness of a random field is to
be parametrised: if <code class="reqn">a &gt; m</code> then the
graph is <code class="reqn">m</code> times differentiable.
</p>
</li></ul>

<p>The default values of the arguments
<code>mev</code>,
<code>nugget</code>,
<code>variance</code> and <code>scale</code> are eq 0.
</p>


<h3>Value</h3>

<p>an object of the class <code>covmodel</code> that defines a covariance model.
</p>


<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># table with all available covariance models and their
# parameters
covmodel()

# exponential model without a measurement error and without a nugget,
# partial sill = 10, scale  parameter = 15
covmodel(modelname = "exponential", variance = 10, scale = 15)

# exponential model with a measurement error ( mev = 0.5) and a
# nugget (nugget = 2.1), exponential partial  sill (variance = 10)
# and scale parameter = 15
covmodel(modelname = "exponential", mev  = 0.5, nugget = 2.1,
variance = 10, scale = 15)
</code></pre>

<hr>
<h2 id='internal-functions'>Internal Functions Exported For Use In Dependent Packages</h2><span id='topic+f.point.block.cov'></span><span id='topic+K'></span>

<h3>Description</h3>

<p>The internal functions <code>K</code> and <code>f.point.block.cov</code>
are not meant to be called by users directly.  They are exported because
other R packages that import from <span class="pkg">constrainedKriging</span> use them.</p>


<h3>Usage</h3>

<pre><code class='language-R'>K(dist, model)

f.point.block.cov(pixconfig, locations, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internal-functions_+3A_dist">dist</code></td>
<td>
<p>a numeric vector with distances.</p>
</td></tr>
<tr><td><code id="internal-functions_+3A_model">model</code></td>
<td>
<p>an object of class &ldquo;<code>covmodel</code>&rdquo; that defines an
isotropic covariance model.</p>
</td></tr>
<tr><td><code id="internal-functions_+3A_pixconfig">pixconfig</code></td>
<td>
<p>a list of lists  with the information about the pixels used
for the covariance approximation of the polygon neighbourhood
configurations, see respective information in section <em>Value</em> of
<code><a href="#topic+preCKrige">preCKrige</a></code>.</p>
</td></tr>
<tr><td><code id="internal-functions_+3A_locations">locations</code></td>
<td>
<p>a numeric matrix with two columns that contain the
coordinates of the observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>K</code> computes a vector with autocorrelations.
</p>
<p><code>f.point.block.cov</code> computes a (<var>n</var> <code class="reqn">\times</code> <var>m</var> )
matrix with the autocovariances between <var>n</var> observations and
<var>m</var> prediction target blocks.
</p>


<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a></p>

<hr>
<h2 id='meuse.blocks'>Meuse block</h2><span id='topic+meuse.blocks'></span>

<h3>Description</h3>

 <p><code>meuse.blocks</code> is an object of the class
&ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo; that contains the coordinates
of 259 artificially defined (mostly square) blocks obtained by intersecting
a grid with 150 m mesh width over the the flood plain area of the river
Meuse, near the village Stein.  The 259 x 2 data frame contains the
covariate
<code>dist</code> and the attribute <code>M</code> (spatial variance of
<code>sqrt(dist)</code>) for each block.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meuse.blocks)
</code></pre>


<h3>Format</h3>

<p>The object contains the following slots:
</p>

<dl>
<dt>data</dt><dd><p>a 259 x 2 data frame contains:
</p>

<dl>
<dt>dist</dt><dd><p>mean Euclidean distance of the blocks from the
river, normalized to the interval [0;1].</p>
</dd>
<dt>M</dt><dd><p>the (spatial) variance of <code>sqrt(dist)</code>
within the blocks, see <cite>Hofer &amp; Papritz (2011)</cite>.</p>
</dd>
</dl>

</dd>
<dt>polygons</dt><dd><p>an object of the class <code>SpatialPolygons</code> that
contains the coordinates of the 259 blocks, see
<code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code>.</p>
</dd>
<dt>plotOrder</dt><dd><p>see <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code>.</p>
</dd>
<dt>bbox</dt><dd><p>see <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code>.</p>
</dd>
<dt>proj4string</dt><dd><p>see <code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a></p>


<h3>References</h3>

<p>Hofer, C. and Papritz, A. (2011).  constrainedKriging: an R-package
for customary, constrained and covariance-matching constrained point
or block Kriging.  <em>Computers &amp; Geosciences</em>. <b>37</b>, 1562&ndash;1569,
<a href="https://doi.org/10.1016/j.cageo.2011.02.009">doi:10.1016/j.cageo.2011.02.009</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+preCKrige">preCKrige</a> and <a href="#topic+CKrige">CKrige</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.blocks)
summary(meuse.blocks)
### show the shape of the 259 blocks
plot(meuse.blocks)
### plot maps of the covariate dist and attribute M
spplot(meuse.blocks)
</code></pre>

<hr>
<h2 id='plot.preCKrigePolygons'>Plotting a Polygon Neighbourhood Configuration</h2><span id='topic+plot.preCKrigePolygons'></span>

<h3>Description</h3>

<p>Plotting method for objects of the class
&ldquo;<code>preCKrige.polygons</code>&rdquo;.  The plot shows the polygon
neighbourhood configuration for one polygon (block) in a
<code>preCKrige.polygons</code> object as well as its representation by the
pixels.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'preCKrigePolygons'
plot(x, index, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.preCKrigePolygons_+3A_x">x</code></td>
<td>
<p>an object of the class &ldquo;<code>preCKrigePolygons</code>&rdquo;.  In
general the output object of a <code><a href="#topic+preCKrige">preCKrige</a></code> function call.</p>
</td></tr>
<tr><td><code id="plot.preCKrigePolygons_+3A_index">index</code></td>
<td>
<p>a numeric scalar with the index of the desired polygon
(block) in the list of polygons <code>x@polygons</code>.</p>
</td></tr>
<tr><td><code id="plot.preCKrigePolygons_+3A_...">...</code></td>
<td>
<p>further plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.</p>


<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a></p>


<h3>References</h3>

<p>Hofer, C. and Papritz, A. (2011).  constrainedKriging: an R-package
for customary, constrained and covariance-matching constrained point
or block Kriging.  <em>Computers &amp; Geosciences</em>. <b>37</b>, 1562&ndash;1569,
<a href="https://doi.org/10.1016/j.cageo.2011.02.009">doi:10.1016/j.cageo.2011.02.009</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+preCKrige">preCKrige</a></code> and <code><a href="#topic+preCKrigePolygons">preCKrigePolygons</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### load data
data(meuse, package = "sp")
data(meuse.blocks)

### plot blocks
plot(meuse.blocks)

### compute the approximated block variance of each block in
### meuse.blocks without the definition of neighbours blocks (default)
preCK_1  &lt;- preCKrige(newdata = meuse.blocks,
    model = covmodel("exponential", 0.05, 0.15, scale = 192.5),
    pwidth = 75, pheight = 75)

### plot block approximation of block 59
plot(preCK_1, 59)


### define neighbours
if(!requireNamespace("spdep", quietly = TRUE)){
  stop("install package spdep to run example")
}
neighbours &lt;- spdep::poly2nb(meuse.blocks)
class(neighbours)
### neighbours should be an object of the class "list"
class(neighbours) &lt;- "list"
### compute the approximated block variance-covariance matrices of each block in
### meuse.blocks without the defined block neighbours
preCK_2 &lt;- preCKrige(newdata = meuse.blocks, neighbours = neighbours,
    model = covmodel("exponential", 0.05, 0.15, scale = 192.5),
    pwidth = 75, pheight = 75)

### plot block approximation of block 59 and its
### block neighbours
plot(preCK_2, 59)


</code></pre>

<hr>
<h2 id='preCKrige'>Spatial Variance-Covariance Matrices for Sets of Points and Polygons</h2><span id='topic+preCKrige-methods'></span><span id='topic+preCKrige'></span><span id='topic+preCKrige.points'></span><span id='topic+preCKrige.polygons'></span><span id='topic+preCKrige.pointsDF'></span><span id='topic+preCKrige.polygonsDF'></span><span id='topic+preCKrige+2CSpatialPoints+2CANY+2Ccovmodel-method'></span><span id='topic+preCKrige+2CSpatialPointsDataFrame+2CANY+2Ccovmodel-method'></span><span id='topic+preCKrige+2CSpatialPolygons+2CANY+2Ccovmodel-method'></span><span id='topic+preCKrige+2CSpatialPolygonsDataFrame+2CANY+2Ccovmodel-method'></span>

<h3>Description</h3>

<p>The function <code>preCKrige</code> computes (approximated) spatial
variance-covariance matrices for user-defined sets of points or polygons
(blocks) of any shape for two-dimensional isotropic random fields.  The
areas of a set of polygons (polygon neighbourhood configuration) are
approximated by pixels and the block-block covariances are approximated by
averaging covariances between the pixels used to approximate the polygons.
</p>
<p>The object returned by <code>preCKrige</code> is needed by <code><a href="#topic+CKrige">CKrige</a></code>
for computing spatial point or block predictions by constrained,
covariance-matching constrained or universal (external drift) Kriging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preCKrige(newdata, neighbours, model, ...)
## S4 method for signature 'SpatialPoints,ANY,covmodel'
preCKrige(newdata, neighbours, model)
## S4 method for signature 'SpatialPointsDataFrame,ANY,covmodel'
preCKrige(newdata, neighbours, model)
## S4 method for signature 'SpatialPolygons,ANY,covmodel'
preCKrige(newdata, neighbours, model,
  pwidth = 0, pheight = 0, napp = 1, ncores = 1L,
  fork = !identical( .Platform[["OS.type"]], "windows"))
## S4 method for signature 'SpatialPolygonsDataFrame,ANY,covmodel'
preCKrige(newdata, neighbours,
  model, pwidth = 0, pheight = 0, napp = 1, ncores = 1L,
  fork = !identical( .Platform[["OS.type"]], "windows"))
</code></pre>


<h3>Arguments</h3>


<table role = "presentation">
<tr><td><code id="preCKrige_+3A_newdata">newdata</code></td>
<td>
<p>either an object of the class
&ldquo;<code>SpatialPointsDataFrame</code>&rdquo;
or &ldquo;<code>SpatialPoints</code>&rdquo; that contains the coordinates of the
prediction points and optionally additional information (covariates) stored
in the <code>data</code> slot of the <code>SpatialPointsDataFrame</code>,
or an object of the class &ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo; or
&ldquo;<code>SpatialPolygons</code>&rdquo;
with the coordinates of the polygons (blocks) for which predictions are
computed and optionally additional information (covariates) stored in the
<code>data</code> slot of the
<code>SpatialPolygonsDataFrame</code>.</p>
</td></tr>

<tr><td><code id="preCKrige_+3A_neighbours">neighbours</code></td>
<td>
<p>a list of length <var>n</var> with integer vectors as
components.  <var>n</var> is equal to the number of points if
<code>newdata</code> is an object of class
&ldquo;<code>SpatialPointsDataFrame</code>&rdquo; or
&ldquo;<code>SpatialPoints</code>&rdquo; or equal to number of polygons (blocks)
if <code>newdata</code> is an object of class
&ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo; or
&ldquo;<code>SpatialPolygons</code>&rdquo;.
</p>
<p>The <var>i</var>th list component defines the neighbours of the <var>i</var>th
point or <var>i</var>th polygon (block) in <code>newdata</code>, which form
jointly with the <var>i</var>th point or polygon the so-called <em>point</em>
or <em>polygon neighbourhood configuration</em>.  If <code>newdata</code> is
an object of class &ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo; or
&ldquo;<code>SpatialPolygons</code>&rdquo; the <var>i</var>th list component contains
the indices of the neighbouring polygons for the <var>i</var>th polygon.
If <code>newdata</code> is an object of class &ldquo;<code>SpatialPoints</code>&rdquo;
or &ldquo;<code>SpatialPointsDataFrame</code>&rdquo; the <var>i</var>th list component
contains the row indices of the neighbouring points in the point
coordinate matrix.  The <var>i</var>th list component is set to
<code>integer(0)</code> if the <var>i</var>th polygon or <var>i</var>th point have no
(defined) neighbours.  By default, the points or polygons have no
neighbours.
</p>
<p>See the second example below where the function <code>poly2nb</code> of the
package <span class="pkg">spdep</span> is used to build a list of neighbours for target
polygons of the  data set <code><a href="#topic+meuse.blocks">meuse.blocks</a></code>.</p>
</td></tr>

<tr><td><code id="preCKrige_+3A_model">model</code></td>
<td>
<p>an object of class &ldquo;<code>covmodel</code>&rdquo;.  The object
contains the parameters of the isotropic covariance function,
generated by the function <code><a href="#topic+covmodel">covmodel</a></code>.</p>
</td></tr>

<tr><td><code id="preCKrige_+3A_...">...</code></td>
<td>
<p>further arguments if <code>newdata</code> is of class
&ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo; or<br />
&ldquo;<code>SpatialPolygons</code>&rdquo;.</p>
</td></tr>

<tr><td><code id="preCKrige_+3A_pwidth">pwidth</code></td>
<td>
<p>a positive numeric scalar, defines the width of the
pixels used to approximate the polygon (block) areas.</p>
</td></tr>

<tr><td><code id="preCKrige_+3A_pheight">pheight</code></td>
<td>
<p>a positive numeric scalar, defines the height of the
pixels used to approximate the polygon (block) areas.</p>
</td></tr>

<tr><td><code id="preCKrige_+3A_napp">napp</code></td>
<td>
<p>a positive integer scalar.  <code>napp</code> &gt; 1 reduces the
block-block variance-covariance approximation error.  By default,
<code>napp</code> = 1, see <em>Details.</em></p>
</td></tr>

<tr><td><code id="preCKrige_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer scalar with the number of CPUs to
use for parallel computations.</p>
</td></tr>

<tr><td><code id="preCKrige_+3A_fork">fork</code></td>
<td>
<p>a logical scalar to control whether parallel
computations are done by forking using <code><a href="parallel.html#topic+mclapply">mclapply</a></code>
(non-windows OSes) or by socket clusters using
<code><a href="parallel.html#topic+parLapply">parLapply</a></code> (windows OS).</p>
</td></tr>
</table>


<h3>Details</h3>

<p> If the object <code>newdata</code> is of class
&ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo; or
&ldquo;<code>SpatialPolygons</code>&rdquo; then<br /> <code>preCKrige</code> searches the
polygon neighbourhood configuration (defined by <code>neighbours</code>)
with the largest bounding box and generates a pixel grid that
completely covers the largest bounding box.  Subsequently, the
covariance matrix of this set of pixels is calculated by the
<span class="pkg">spatialCovariance</span> package and the polygon (block) areas of each
polygon neighbourhood configuration are approximated by intersecting
the polygons with the shifted pixel grid, which yields a pixel
representation of the polygon neighbourhood configuration.  Finally,
the block-block covariances of the polygons are approximated by
averaging the covariances of the pixel representation of the
polygon neighbourhood configuration.
</p>
<p>By default, <code>napp = 1</code>, which means that the approximation of the
block-block variance-covariance matrix for each polygon neighbourhood
configuration is computed just once.  If <code>napp</code> &gt; 1 the
approximation of the block-block variance-covariance matrix for one
polygon neighbourhood configuration is based on the mean of
<code>napp</code> repetitions of the approximation to reduce the
approximation error.  Each of the <code>napp</code> block-block
variance-covariance approximations are based on a new, randomly
shifted pixel gird which results each time in a new pixel
representation of the polygon neighbourhood configuration.  Large
values of the argument <code>napp</code> increases the computation time.
</p>
<p>There is a plot method <code><a href="#topic+plot.preCKrigePolygons">plot.preCKrigePolygons</a></code> for
<code>preCKrige</code> output objects of class<br />
&ldquo;<code>preCKrigePolygons</code>&rdquo; to visually control the polygon
(block) area approximation by the pixels.  </p>


<h3>Value</h3>

<p><code>preCKrige</code> returns an S4 object, either of class
&ldquo;<code>preCKrigePolygons</code>&rdquo; if
<code>newdata</code> is of class<br /> &ldquo;<code>SpatialPolygons</code>&rdquo; or
&ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo; or an S4 object of class
&ldquo;<code>preCKrigePoints</code>&rdquo; if
<code>newdata</code> is of class &ldquo;<code>SpatialPoints</code>&rdquo; or
&ldquo;<code>SpatialPointsDataFrame</code>&rdquo;.
</p>
<p><em>Notation</em>:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code class="reqn">n</code> </td><td style="text-align: left;"> number of polygons or points in <code>newdata</code>,
               <var>i</var> = 1, ..., <code class="reqn">n</code></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code class="reqn">m_i</code> </td><td style="text-align: left;"> size of point or polygon neighbourhood configuration </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> <code class="reqn">m_i</code> = 1 + number of (defined) neighbours of the <var>i</var>th point
               or <var>i</var>th polygon </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code class="reqn">r_{\mathrm{pix}}</code> </td><td style="text-align: left;"> number of pixel grid rows </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code class="reqn">c_{\mathrm{pix}}</code>  </td><td style="text-align: left;"> number of pixel grid columns </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code class="reqn">n_{\mathrm{pix}}</code>  </td><td style="text-align: left;"> number of pixels in pixel grid
     <code class="reqn">n_{\mathrm{pix}} = r_{\mathrm{pix}} \cdot c_{\mathrm{pix}}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>An object of class &ldquo;<code>preCKrigePoints</code>&rdquo; contains the
following slots:
</p>
<table role = "presentation">
<tr><td><code>covmat</code></td>
<td>
<p>a list of length <code class="reqn">n</code>, the <code class="reqn">i</code>th list component
contains the point-point covariance matrix of the <code class="reqn">i</code>th prediction
point and its neighbours, i.e. of the <code class="reqn">i</code>th point neighbourhood
configuration.</p>
</td></tr>
<tr><td><code>posindex</code></td>
<td>
<p>a list of length <code class="reqn">n</code>, the <code class="reqn">i</code>th list component
contains a vector with the row indices of the <code class="reqn">m_i - 1</code> neighbours
in the <code class="reqn">i</code>th point neighbourhood configuration.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>an object of class &ldquo;<code>covmodel</code>&rdquo; with the
parameters of the used covariance function.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a data frame, which is the <code>data</code> slot of the
<code>SpatialPointsDataFrame</code> object.  This data frame is used to
build the design matrix of the prediction points by the
<code><a href="#topic+CKrige">CKrige</a></code> function.  <code>data</code> is empty with
<code>dim(data)</code> = (0, 0) if <code>newdata</code> is an object of class
&ldquo;<code>SpatialPoints</code>&rdquo;.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>a matrix with <code>dim(coords)</code> = (<code class="reqn">n</code>, 2) with the
coordinates of the prediction points.</p>
</td></tr>
</table>
<p>An object of class &ldquo;<code>preCKrigePolygons</code>&rdquo; contains the
following slots:
</p>
<table role = "presentation">
<tr><td><code>covmat</code></td>
<td>
<p>a list of length <code class="reqn">n</code>, the <code class="reqn">i</code>th list component
contains the approximated block-block covariance matrix of the
<code class="reqn">i</code>th polygon and its neighbours, i.e. of the <code class="reqn">i</code>th polygon
neighbourhood configuration.</p>
</td></tr>
<tr><td><code>se.covmat</code></td>
<td>
<p>a list of length <code class="reqn">n</code>, the <code class="reqn">i</code>th list
component contains a matrix with the standard errors of the
approximated block-block covariances of the <code class="reqn">i</code>th polygon
neighbourhood configuration. Values are equal to <code>NaN</code> for
argument <code>napp = 1</code>, see <em>Details</em>.</p>
</td></tr>
<tr><td><code>pixconfig</code></td>
<td>
<p>a list of lists of length <code class="reqn">n</code>, the <code class="reqn">i</code>th list
component contains a list with the information about the pixels used
for the covariance approximation of the <code class="reqn">i</code>th polygon
neighbourhood configuration.  The components of <code>pixconfig</code> are
described below.</p>
</td></tr>
<tr><td><code>pixcovmat</code></td>
<td>
<p>a matrix, <code>dim(matrix)</code> =
(<code class="reqn">n_{\mathrm{pix}}</code>, <code class="reqn">n_{\mathrm{pix}}</code> ), with
the covariance matrix of the pixels.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>an object of class &ldquo;<code>covmodel</code>&rdquo; with the
parameters of the used covariance function.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a data frame which is the <code>data</code> slot of the
<code>SpatialPolygonsDataFrame</code> object.  This data frame is used to
build the design matrix of the prediction polygons by the
<code><a href="#topic+CKrige">CKrige</a></code> function.  <code>data</code> is empty with
<code>dim(data)</code> = (0, 0) if <code>newdata</code> is an object of class
&ldquo;<code>SpatialPolygons</code>&rdquo;.</p>
</td></tr>
<tr><td><code>polygons</code></td>
<td>
<p>a <code>SpatialPolygons</code> object.  A list of length
<code class="reqn">n</code> with the polygons of the <code>newdata</code> object.</p>
</td></tr>
</table>
<p>The <code class="reqn">i</code>th component of <code>pixconfig</code> is a list with the
following 10 components:
</p>
<table role = "presentation">
<tr><td><code>pixcenter</code></td>
<td>
<p>a matrix with <code>dim(pixcenter)</code> =
(<code class="reqn">n_{\mathrm{pix}}</code>, 2) with the coordinates of the pixels
centroids for the <code class="reqn">i</code>th polygon neighbourhood configuration.</p>
</td></tr>
<tr><td><code>rowwidth</code></td>
<td>
<p><code>preCKrige</code> input argument <code>pheight</code>.</p>
</td></tr>
<tr><td><code>colwidth</code></td>
<td>
<p><code>preCKrige</code> input argument <code>pwidth</code>.</p>
</td></tr>
<tr><td><code>nrows</code></td>
<td>
<p>a numeric scalar with number of rows
<code class="reqn">r_{\mathrm{pix}}</code> of the pixel grid.</p>
</td></tr>
<tr><td><code>ncols</code></td>
<td>
<p>a numeric scalar with number of columns
<code class="reqn">c_{\mathrm{pix}}</code> of the pixel grid.</p>
</td></tr>
<tr><td><code>no.pix.in.poly</code></td>
<td>
<p>a numeric vector of length <code class="reqn">m_i</code>, each
number indicates by how many pixels a polygon of the <code class="reqn">i</code>th polygon
configuration is approximated.</p>
</td></tr>
<tr><td><code>sa.polygons</code></td>
<td>
<p>a logical vector of length <code class="reqn">m_i</code>, TRUE means
that the <code class="reqn">i</code>th polygon is treated as a point because its area is
smaller than the area of a pixel, and FALSE means that the polygon is
approximated by pixels, see <em>Note</em> for more details.</p>
</td></tr>
<tr><td><code>polygon.centroids</code></td>
<td>
<p>a matrix with <code>dim(polygon.centroids)</code> =
(<code class="reqn">m_i</code>, 2) with the coordinates of the polygon centroids of the
<code class="reqn">i</code>th polygon neighbourhood configuration.</p>
</td></tr>
<tr><td><code>posindex</code></td>
<td>
<p>an integer vector of length <code class="reqn">m_i</code> with indices of
the <code class="reqn">i</code>th polygon and its neighbours as defined by the argument
<code>neighbours</code>.</p>
</td></tr>
<tr><td><code>pix.in.poly</code></td>
<td>
<p>is a binary matrix with <code>dim(pix.in.poly)</code> =
(<code class="reqn">n_{\mathrm{pix}}</code>, <code class="reqn">m_i</code>).  <code>pix.in.poly[k, j] = 1</code>
indicates that the centroid of the <var>k</var>th pixel lies in the
<var>j</var>th polygon, and <code>pix.in.poly[k, j] = 0</code> indicates that the
<var>k</var>th pixel centroid does not lie in the <var>j</var>th
polygon.</p>
</td></tr> </table>


<h3>Note</h3>

<p>A polygon (block) is treated as point if the polygon area is smaller than
the (defined) pixel area or if all pixel centroids of the generated pixel grid
lie outside the polygon (block) area.  If a pixel centroid lies
inside a polygon that has a smaller area than a pixel, the pixel is
allocated to the polygon (block) by which it shares the largest area.
</p>
<p>The point-point correlations are calculated via the internal function
<code>CorrelationFct</code> (this function implements a subset of the
covariance models available previously in the function
<code>CovarianceFct</code> of the archived package <span class="pkg">RandomFields</span>,
version 2.0.71) and the point-block covariances are calculated by the C
function <code>PointRectCov</code> of the package.</p>


<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a>
</p>


<h3>References</h3>

<p>Hofer, C. and Papritz, A. (2011).  constrainedKriging: an R-package
for customary, constrained and covariance-matching constrained point
or block Kriging.  <em>Computers &amp; Geosciences</em>. <b>37</b>, 1562&ndash;1569,
<a href="https://doi.org/10.1016/j.cageo.2011.02.009">doi:10.1016/j.cageo.2011.02.009</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CKrige">CKrige</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
### first example
### load data
data(meuse, package = "sp")
data(meuse.blocks)

### plot blocks
plot(meuse.blocks)

### compute the approximated block variance of each block in meuse.blocks
### without any neighbouring blocks (default, required for in universal
### and constrained Kriging) for an exponential covariance function without
### a measurement error, a nugget  = 0.15 (micro scale white noise process),
### a partial sill variance = 0.15 and a scale parameter = 192.5
### approximation of block variance by pixel of size 75m x 75m
preCK_1 &lt;- preCKrige(newdata = meuse.blocks, model = covmodel(modelname =
    "exponential", mev = 0, nugget = 0.05, variance = 0.15,
    scale = 192.5), pwidth = 75, pheight = 75)

### plot block approximation for block 59
plot(preCK_1, 59)

### second example
### define neighbours by using the poly2nb function
### of the spdep package
if(!requireNamespace("spdep", quietly = TRUE)){
  stop("install package spdep to run example")
}
neighbours &lt;- spdep::poly2nb(meuse.blocks)
class(neighbours)
### neighbours should be an object of class "list"
class(neighbours) &lt;- "list"
### compute the approximated block variance-covariance
### matrices of each block in meuse.blocks without the
### defined block neighbours
preCK_2 &lt;- preCKrige(newdata = meuse.blocks, neighbours = neighbours,
  model = covmodel("exponential", nugget = 0.05, variance = 0.15,
    scale = 192.5), pwidth = 75, pheight = 75)

### plot block approximation of block 59 and its
### block neighbours
plot(preCK_2, 59)

</code></pre>

<hr>
<h2 id='preCKrigePoints-class'>Class &quot;preCKrigePoints&quot;</h2><span id='topic+preCKrigePoints'></span><span id='topic+preCKrigePoints-class'></span><span id='topic+print.preCKrigePoints'></span><span id='topic+summary.preCKrigePoints'></span><span id='topic+show+2CpreCKrigePoints-method'></span>

<h3>Description</h3>

<p>Class of objects that are generated by <code><a href="#topic+preCKrige">preCKrige</a></code>
if the attribute <code>newdata</code> is of class <br />
&ldquo;<code>SpatialPoints</code>&rdquo; or &ldquo;<code>SpatialPointsDataFrame</code>&rdquo;.
This class has a <code>show</code>, <code>summary</code> and a <code><a href="#topic+CKrige">CKrige</a></code> method.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the generic function
<code><a href="#topic+preCKrige">preCKrige</a></code>.  </p>


<h3>Slots</h3>


<dl>
<dt><code>covmat</code>:</dt><dd><p>Object of class <code>"list"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>. </p>
</dd>
<dt><code>posindex</code>:</dt><dd><p>Object of class <code>"list"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>. </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"list"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>.  </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>.  </p>
</dd>
<dt><code>coords</code>:</dt><dd><p>Object of class <code>"matrix"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>.  </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>CKrige</dt><dd><p><code>signature(formula = "formula", data = "data.frame", locations = "formula",
    object = "preCKrigePoints", method = "numeric", ex.out = "logical")</code> </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+preCKrige">preCKrige</a></code>, <code><a href="#topic+preCKrigePolygons-class">preCKrigePolygons</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("preCKrigePoints")
</code></pre>

<hr>
<h2 id='preCKrigePolygons-class'>Class preCKrigePolygons</h2><span id='topic+preCKrigePolygons'></span><span id='topic+preCKrigePolygons-class'></span><span id='topic+print.preCKrigePolygons'></span><span id='topic+summary.preCKrigePolygons'></span><span id='topic+show-methods'></span><span id='topic+show+2CpreCKrigePolygons-method'></span>

<h3>Description</h3>

<p>Class of objects that are generated by <code><a href="#topic+preCKrige">preCKrige</a></code>
if the attribute <code>newdata</code> is of the class <br />
&ldquo;<code>SpatialPolygons</code>&rdquo; or
&ldquo;<code>SpatialPolygonsDataFrame</code>&rdquo;.  This class has a <code>show</code>,
<code>summary</code> and a <code><a href="#topic+CKrige">CKrige</a></code> method.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the generic function
<code><a href="#topic+preCKrige">preCKrige</a></code>.  </p>


<h3>Slots</h3>


<dl>
<dt><code>covmat</code>:</dt><dd><p>Object of class <code>"list"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>. </p>
</dd>
<dt><code>se.covmat</code>:</dt><dd><p>Object of class <code>"list"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>. </p>
</dd>
<dt><code>pixconfig</code>:</dt><dd><p>Object of class <code>"list"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>. </p>
</dd>
<dt><code>pixcovmat</code>:</dt><dd><p>Object of class <code>"matrix"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"list"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>.</p>
</dd>
<dt><code>polygons</code>:</dt><dd><p>Object of class <code>"list"</code>,
see <code><a href="#topic+preCKrige">preCKrige</a></code>, section <em>Value</em>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>CKrige</dt><dd><p><code>signature(formula = "formula", data = "data.frame", locations = "formula", object = "preCKrigePolygons", method = "numeric", ex.out = "logical")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Christoph Hofer, <a href="mailto:christoph.hofer@alumni.ethz.ch">christoph.hofer@alumni.ethz.ch</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+preCKrige">preCKrige</a></code>, <code><a href="#topic+preCKrigePoints-class">preCKrigePoints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("preCKrigePolygons")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
