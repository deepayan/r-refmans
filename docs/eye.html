<!DOCTYPE html><html><head><title>Help for package eye</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eye}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#blink'><p>Your data in a blink of an eye</p></a></li>
<li><a href='#clean_va'><p>Cleaning up Visual acuity entries</p></a></li>
<li><a href='#convertQuali'><p>convert quali entries</p></a></li>
<li><a href='#count_eyes'><p>internal count</p></a></li>
<li><a href='#eye'><p>eye</p></a></li>
<li><a href='#eye_codes'><p>List of codes</p></a></li>
<li><a href='#eyes'><p>Count patients and eyes</p></a></li>
<li><a href='#eyes_to_string'><p>Eye count to strings</p></a></li>
<li><a href='#getage'><p>getage</p></a></li>
<li><a href='#getElem'><p>Find element based or strings</p></a></li>
<li><a href='#hyperop'><p>Hyperopic eye data</p></a></li>
<li><a href='#introduceNA'><p>introduce NA for implausible VA entries</p></a></li>
<li><a href='#myop'><p>Myopic eye data</p></a></li>
<li><a href='#myop_pivot'><p>myopizer</p></a></li>
<li><a href='#myop_rename'><p>Rename</p></a></li>
<li><a href='#myopizer'><p>myopizer</p></a></li>
<li><a href='#parse_snellen'><p>parsing snellen fractions to numeric values</p></a></li>
<li><a href='#plausibility_methods'><p>Plausibility checking</p></a></li>
<li><a href='#print_methods'><p>print eye classes</p></a></li>
<li><a href='#recodeye'><p>Recode eyes</p></a></li>
<li><a href='#remCols'><p>Remove cols from selected cols</p></a></li>
<li><a href='#reveal'><p>reveal</p></a></li>
<li><a href='#reveal_methods'><p>reveals little helper</p></a></li>
<li><a href='#reveal_split'><p>reveals little helper</p></a></li>
<li><a href='#set_eye_strings'><p>Set list of codes</p></a></li>
<li><a href='#snellen_steps'><p>Convert plus minus entries</p></a></li>
<li><a href='#sort_substr'><p>sort substrings</p></a></li>
<li><a href='#split_mult'><p>split columns in multiple by regex</p></a></li>
<li><a href='#str_search'><p>String search helper</p></a></li>
<li><a href='#tidyNA'><p>Tidy NA entries to actual NA values</p></a></li>
<li><a href='#tocapital'><p>Capitalize words</p></a></li>
<li><a href='#va'><p>Visual acuity notation conversion</p></a></li>
<li><a href='#va_methods'><p>VA conversion methods</p></a></li>
<li><a href='#va_mixed'><p>VA classes</p></a></li>
<li><a href='#VAclasses'><p>VA classes</p></a></li>
<li><a href='#VAwrapper'><p>VA conversion wrapper</p></a></li>
<li><a href='#warnings'><p>recode warnings</p></a></li>
<li><a href='#which_va'><p>Guessing the VA class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis of Eye Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>There is no ophthalmic researcher who has not had headaches from 
    the handling of visual acuity entries. Different notations, untidy entries. 
    This shall now be a matter of the past. Eye makes it as easy as pie to work
    with VA data - easy cleaning, easy conversion between 
    Snellen, logMAR, ETDRS letters, and qualitative visual acuity 
    shall never pester you again. The eye 
    package automates the pesky task to count number of patients and eyes, 
    and can help to clean data with easy re-coding for right and left eyes. 
    It also contains functions to help reshaping eye side specific variables 
    between wide and long format. Visual acuity conversion is based on 
    Schulze-Bonsel et al. (2006) &lt;<a href="https://doi.org/10.1167%2Fiovs.05-0981">doi:10.1167/iovs.05-0981</a>&gt;, 
    Gregori et al. (2010) &lt;<a href="https://doi.org/10.1097%2Fiae.0b013e3181d87e04">doi:10.1097/iae.0b013e3181d87e04</a>&gt;, 
    Beck et al. (2003) &lt;<a href="https://doi.org/10.1016%2Fs0002-9394%2802%2901825-1">doi:10.1016/s0002-9394(02)01825-1</a>&gt; and 
    Bach (2007) &lt;http:michaelbach.de/sci/acuity.html&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tjebo/eye">https://github.com/tjebo/eye</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tjebo/eye/issues">https://github.com/tjebo/eye/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.0.1), dplyr (&ge; 1.0.7), english (&ge; 1.2-6),
lubridate (&ge; 1.7.10), magrittr (&ge; 2.0.1), pillar (&ge; 1.6.2),
purrr (&ge; 0.3.4), rlang (&ge; 0.4.11), stringr (&ge; 1.4.0), tibble
(&ge; 3.1.3), tidyr (&ge; 1.1.3), tidyselect (&ge; 1.1.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>eyedata (&ge; 0.1.0), knitr (&ge; 1.33), rmarkdown (&ge; 2.10),
testthat (&ge; 3.0.4)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-04 17:47:04 UTC; tjebo</td>
</tr>
<tr>
<td>Author:</td>
<td>Tjebo Heeren <a href="https://orcid.org/0000-0001-5297-2301"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Antoine Fabri [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tjebo Heeren &lt;tjebo@gmx.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-04 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>

<hr>
<h2 id='blink'>Your data in a blink of an eye</h2><span id='topic+blink'></span>

<h3>Description</h3>

<p><code>blink</code> summarizes your data tailored to the need of
ophthalmic research: It looks for VA and IOP columns and summarises those
with common statistics. In order to make it work, it requires specific
column naming - please see section &quot;column names&quot; and &quot;data coding&quot;.
For more details how blink works, see <code>vignette("eye")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blink(x, va_to = "logmar", va_cols = NULL, iop_cols = NULL, fct_level = 0:4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blink_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="blink_+3A_va_to">va_to</code></td>
<td>
<p>to which VA notation (passed to <code><a href="#topic+va">va()</a></code>)</p>
</td></tr>
<tr><td><code id="blink_+3A_va_cols">va_cols</code></td>
<td>
<p>if specified, overruling automatic VA columns selection.
tidyselection supported</p>
</td></tr>
<tr><td><code id="blink_+3A_iop_cols">iop_cols</code></td>
<td>
<p>if specified, overruling automatic IOP columns selection.
tidyselection supported</p>
</td></tr>
<tr><td><code id="blink_+3A_fct_level">fct_level</code></td>
<td>
<p>Remove columns for Summarizing when all unique values
fall into range. character or numeric vector, default <code>1:4</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>blink</code> is basically a wrapper around <a href="#topic+myop">myop</a>, <a href="#topic+eyes">eyes</a> and <a href="#topic+reveal">reveal</a>:
</p>

<ul>
<li><p> Duplicate rows are always removed
</p>
</li>
<li><p> Column names are prepared for myopization (see <a href="#topic+myop">myop</a>)
</p>
</li>
<li><p> VA will always be converted to logmar
</p>
</li></ul>



<h3>Value</h3>

<p>object of class <code>blink</code> and <code>list</code>. Class blink contains the
myopized data, count of patients and eyes,
and summaries for visual acuities and intraocular pressure.
</p>


<h3>Data coding</h3>


<ul>
<li><p> Only common codes supported:
</p>
</li>
<li> <p><strong>eyes</strong>: &quot;r&quot;, &quot;re&quot;, &quot;od&quot;, &quot;right&quot; - or numeric coding r:l = 0:1 or 1:2
</p>
</li>
<li> <p><strong>Visual acuity</strong>: &quot;VA&quot;, &quot;BCVA&quot;, &quot;Acuity&quot;
</p>
</li>
<li> <p><strong>Intraocular pressure</strong>: &quot;IOP&quot;, &quot;GAT&quot;, &quot;NCT&quot;, &quot;pressure&quot;
</p>
</li></ul>



<h3>Column name rules</h3>


<ul>
<li><p> No spaces!
</p>
</li>
<li><p> Do not use numeric coding for eyes in column names
</p>
</li>
<li><p> Separate eye and VA and IOP codes with <strong>underscores</strong>
(&quot;bcva_l_preop&quot;, &quot;VA_r&quot;, &quot;left_va&quot;, &quot;IOP_re&quot;)
</p>
</li>
<li><p> Avoid separate VA or IOP codes if this is not actually containing
VA/ IOP data (e.g. &quot;stableVA&quot; instead of &quot;stable_va&quot;, ChangeIOP instead
of &quot;change_IOP&quot;)
</p>
</li>
<li><p> Keep names short
</p>
</li>
<li><p> Don't use underscores when you don't have to.
Consider each section divided by an underscore as a relevant
characteristic of your variable. (&quot;preop&quot; instead of &quot;pre_op&quot;,
&quot;VA&quot; instead of &quot;VA_ETDRS_Letters&quot;)
</p>
</li>
<li><p> Use common codes for your patient column (see <a href="#topic+eyes">eyes</a>, section Guessing)
(e.g., &quot;pat&quot;, &quot;patient&quot; or &quot;ID&quot;, ideally both: &quot;patientID&quot; or &quot;patID&quot;)
</p>
</li>
<li> <p><strong>Don't be too creative with your names!</strong>
</p>
</li></ul>



<h3>Names examples</h3>

<p><strong>Good names</strong>:
</p>
<p>-<code>c("patid", "surgery_right", "iop_r_preop", "va_r_preop", "iop_r", "iop_l")</code>
</p>
<p><strong>OK names</strong>
</p>
<p>-<code>c("Id", "Eye", "BaselineAge", "VA_ETDRS_Letters", "InjectionNumber")</code>:
Names are long and there are two unnecessary underscore in the VA column.
Better just &quot;VA&quot;
-<code>c("id", "r",  "l")</code>: All names are commonly used (good!),
but which dimension of &quot;r&quot;/&quot;l&quot; are we exactly looking at?
</p>
<p><strong>Bad names</strong> (<code>eye</code> will fail)
</p>

<ul>
<li> <p><code>c("id", "iopr", "iopl", "VAr", "VAl")</code>:
<code>eye</code> won't be able to recognize IOP and VA columns
</p>
</li>
<li> <p><code>c("id", "iop_r", "iop_l", "stable_iop_r", "stable_iop_l")</code>:
<code>eye</code> <em>may</em> wrongly identify the (probably logical) columns &quot;stable_iop&quot;
as columns containing IOP data. Better maybe: &quot;stableIOP_l&quot;
</p>
</li>
<li> <p><code>c("person", "goldmann", "vision")</code>: <code>eye</code> will not recognize that at all
</p>
</li></ul>



<h3>tidy data</h3>

<p><strong>blink and myop work more reliably with clean data</strong>
(any package will, really!).
<a href="https://tidyr.tidyverse.org/articles/tidy-data.html">clean data.</a>
</p>


<h3>column removal</h3>

<p>Done with <a href="#topic+remCols">remCols</a>: Removes columns that only
contain values defined in <em>fct_levels</em> or logicals from selected columns
(currently for both automatically and manually selected columns).
fct_levels are removed because they are likely categorical codes.
</p>


<h3>See Also</h3>

<p><a href="https://tidyselect.r-lib.org/reference/language.html">About tidyselection</a>.
</p>
<p>How to rename your columns (two threads on stackoverflow.com):
</p>

<ul>
<li> <p><a href="https://stackoverflow.com/questions/7531868/how-to-rename-a-single-column-in-a-data-frame">Rename columns 1</a>
</p>
</li>
<li> <p><a href="https://stackoverflow.com/questions/20987295/rename-multiple-columns-by-names/59567220#59567220">Rename columns 2</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(eyedata)
blink(amd2)

messy_df &lt;- data.frame( id = letters[1:3],
iop_r_preop = sample(21:23), iop_r_postop = sample(11:13),
iop_l_postop = sample(11:13), iop_l_preop = sample(31:33),
va_r_preop = sample(41:43),  va_l_preop = sample(41:43),
va_r_postop = sample(51:53), va_l_postop = sample(45:47)
)
blink(messy_df)
</code></pre>

<hr>
<h2 id='clean_va'>Cleaning up Visual acuity entries</h2><span id='topic+clean_va'></span><span id='topic+cleanVA'></span>

<h3>Description</h3>

<p>VA cleaning:
</p>

<ol>
<li> <p><a href="#topic+tidyNA">tidyNA</a>:
Replacing empty placeholders (&quot;.&quot;,&quot;&quot;, &quot;(any number of empty space)&quot;,
&quot;NULL&quot;, &quot;NA&quot;, &quot;N/A&quot; , &quot;-&quot;) - any cases - with NA
</p>
</li>
<li><p> Simplifying the notation for qualitative
VA notation (NPL becomes NLP, PL becomes LP)
</p>
</li>
<li><p> Removing non-Snellen character strings
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>clean_va(x, quali = c("nlp", "lp", "hm", "cf"), message = TRUE)

cleanVA(x, quali = c("nlp", "lp", "hm", "cf"), message = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_va_+3A_x">x</code></td>
<td>
<p>Vector with VA entries</p>
</td></tr>
<tr><td><code id="clean_va_+3A_quali">quali</code></td>
<td>
<p>strings for qualitative visual acuity entries</p>
</td></tr>
<tr><td><code id="clean_va_+3A_message">message</code></td>
<td>
<p>message for replaced NA values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>Other VA cleaner: 
<code><a href="#topic+va">va</a>()</code>
</p>

<hr>
<h2 id='convertQuali'>convert quali entries</h2><span id='topic+convertQuali'></span>

<h3>Description</h3>

<p>converting quality VA entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertQuali(x, to_class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertQuali_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="convertQuali_+3A_to_class">to_class</code></td>
<td>
<p>to which class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>

<hr>
<h2 id='count_eyes'>internal count</h2><span id='topic+count_eyes'></span>

<h3>Description</h3>

<p><code>count_eyes()</code> is the internal counting function for <a href="#topic+eyes">eyes</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_eyes(x, id_col, eye_col, details = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_eyes_+3A_x">x</code></td>
<td>
<p>object (data frame)</p>
</td></tr>
<tr><td><code id="count_eyes_+3A_id_col">id_col</code></td>
<td>
<p>patient column</p>
</td></tr>
<tr><td><code id="count_eyes_+3A_eye_col">eye_col</code></td>
<td>
<p>eye column</p>
</td></tr>
<tr><td><code id="count_eyes_+3A_details">details</code></td>
<td>
<p>if TRUE, will get more information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named integer vector with count of patients and eyes
</p>

<hr>
<h2 id='eye'>eye</h2><span id='topic+eye'></span>

<h3>Description</h3>

<p>See more with <em>eye</em>
</p>


<h3>Ophthalmology functions</h3>

<p><em>eye</em> is dedicated to facilitate very common tasks
in ophthalmic research.
</p>

<ul>
<li><p> Visual acuity conversion for snellen, logMAR and ETDRS <code><a href="#topic+va">va</a></code>
and the wrapper <a href="#topic+to_snellen">to_snellen</a>, <a href="#topic+to_etdrs">to_etdrs</a> and <a href="#topic+to_logmar">to_logmar</a>
</p>
</li>
<li><p> Counting patients and eyes <code><a href="#topic+eyes">eyes</a></code>
</p>
</li>
<li><p> Recode eye strings <code><a href="#topic+recodeye">recodeye</a></code>
</p>
</li>
<li><p> Reshape eye specific variables <code><a href="#topic+myop">myop</a></code> and <code><a href="#topic+hyperop">hyperop</a></code>
</p>
</li>
<li><p> Summarizing data with common statistics (mean, sd, n, range)<code><a href="#topic+reveal">reveal</a></code>
</p>
</li>
<li><p> Easy summary of your eye data in one blink <code><a href="#topic+blink">blink</a></code>
</p>
</li></ul>



<h3>Beyond ophthalmology</h3>


<ul>
<li> <p><code><a href="#topic+getage">getage</a></code>: Calculate age
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tjebo Heeren
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tjebo/eye"><code>eye</code> on github</a>
</p>
</li>
<li> <p><a href="https://github.com/tjebo/eye/issues">Report bugs</a>
</p>
</li></ul>


<hr>
<h2 id='eye_codes'>List of codes</h2><span id='topic+eye_codes'></span>

<h3>Description</h3>

<p>List of codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eye_codes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 11.
</p>


<h3>Details</h3>


<ul>
<li><p> r right eyes
</p>
</li>
<li><p> l left eyes
</p>
</li>
<li><p> iop IOP codes
</p>
</li>
<li><p> va VA codes
</p>
</li>
<li><p> method VA methods
</p>
</li>
<li><p> id patient column codes
</p>
</li>
<li><p> quali quali VA codes
</p>
</li></ul>


<hr>
<h2 id='eyes'>Count patients and eyes</h2><span id='topic+eyes'></span><span id='topic+eyestr'></span>

<h3>Description</h3>

<p>Counts number of subjects and right and left eyes. Columns are
guessed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eyes(x, id_col = NULL, eye_col = NULL, dropunknown = TRUE, details = FALSE)

eyestr(x, ..., english = "small", caps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eyes_+3A_x">x</code></td>
<td>
<p>required. (data frame)</p>
</td></tr>
<tr><td><code id="eyes_+3A_id_col">id_col</code></td>
<td>
<p>Subject identifying column, passed as (quoted) character
Can also be abbreviated to &quot;id&quot; as per partial matching</p>
</td></tr>
<tr><td><code id="eyes_+3A_eye_col">eye_col</code></td>
<td>
<p>Eye identifying column, passed as (quoted) character.
Can also be abbreviated to &quot;eye&quot; as per partial matching</p>
</td></tr>
<tr><td><code id="eyes_+3A_dropunknown">dropunknown</code></td>
<td>
<p>introduces NA for values not recognized by <a href="#topic+recodeye">recodeye</a></p>
</td></tr>
<tr><td><code id="eyes_+3A_details">details</code></td>
<td>
<p>if TRUE, will add information about which and how many
subjects have only one eye or both included, and provide a list of
subject IDs for each</p>
</td></tr>
<tr><td><code id="eyes_+3A_...">...</code></td>
<td>
<p>passed to <a href="#topic+eyes">eyes</a></p>
</td></tr>
<tr><td><code id="eyes_+3A_english">english</code></td>
<td>
<p>Which numbers to be written in plain english:
choose &quot;small&quot; for numbers till 12, &quot;all&quot; (all numbers),
or &quot;none&quot; (or any other string!) for none</p>
</td></tr>
<tr><td><code id="eyes_+3A_caps">caps</code></td>
<td>
<p>if TRUE, first number will have capital first letter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List (of class &quot;eyes&quot; with count of patients and eyes
if &quot;details = TRUE&quot;, an list of class &quot;eyes_details&quot; will be returned
</p>
<p><code>eyestr</code>: Character string - can be directly pasted into reports
</p>


<h3>Column guessing</h3>

<p><strong>id_col</strong> and <strong>eye_col</strong> arguments overrule the name guessing for
the respective columns (here, cases need to match). Both arguments can be
abbreviated (<em>id</em> or <em>eye</em>) as per partial argument name matching.
</p>
<p>For any below, <strong>cases are always ignored</strong> (column names can be in upper or
lower case, as you please)
</p>
<p><strong>patient ID columns</strong>:
</p>

<ul>
<li><p> First, <code>eyes</code> is looking for names that contain both strings
&quot;pat&quot; and &quot;id&quot; (the order doesn't matter) -
you can change this with <a href="#topic+set_eye_strings">set_eye_strings</a>
</p>
</li>
<li><p> Next, it will look for columns that are plainly called &quot;ID&quot;
</p>
</li>
<li><p> Last, it will search for all names that contain either &quot;pat&quot;
or &quot;id&quot;
</p>
</li></ul>

<p><strong>eye column</strong>:
</p>

<ul>
<li> <p><code>eyes</code> primarily looks for columns called either &quot;eye&quot; or &quot;eyes&quot;,
(you can change this with <a href="#topic+set_eye_strings">set_eye_strings</a>)
and if they are not present, columns containing string &quot;eye&quot;
(e.g., EyeName will be recognized)
</p>
</li></ul>



<h3>Eye coding</h3>

<p>The following codes are recognized: (change this with <a href="#topic+set_eye_strings">set_eye_strings</a>)
</p>

<ul>
<li><p> integer coding 0:1 and 1:2, right eye being the lower number.
</p>
</li>
<li><p> right eyes: c(&quot;r&quot;, &quot;re&quot;, &quot;od&quot;, &quot;right&quot;) and
</p>
</li>
<li><p> left eyes: c(&quot;l&quot;, &quot;le&quot;, &quot;os&quot;, &quot;left&quot;) and
</p>
</li>
<li><p> both eyes: c(&quot;b&quot;, &quot;both&quot;, &quot;ou&quot;)
</p>
</li></ul>

<p>If your eye column contains other values, they will be dropped to
NA (dropunknown) or kept (and then only patients will be counted, because
coding remains unclear). Recommend then to recode with <a href="#topic+recodeye">recodeye</a>
</p>


<h3>eyestr</h3>

<p>eyestr creates a string which can be pasted into reports.
It currently only supports &quot;x eyes of n patient(s)&quot; This is a limitation,
but I guess in the vast majority  of cases will be &quot;correct&quot;.
To use for other categories (e.g., &quot;people&quot; or &quot;participants&quot;), use
<code>eyes(...)[1]</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(eyedata)
eyes(amd2)

## If you code your eyes with different strings,
## e.g., because you are using a different language,
## you can change this either with `set_eye_strings`
set_eye_strings(right = c("droit", "od"), left = c("gauche", "og"))

## restore defaults with
set_eye_strings()
# Examples for the usage of eyestr
eyestr(amd2)

set.seed(1)
ls_dat &lt;-
  lapply(c(1, 12, 13),
    function(x) data.frame(id = as.character(1:x),
                           eye = sample(c("r", "l"), x, replace = TRUE)))

lapply(ls_dat, eyestr, english = "small")
lapply(ls_dat, eyestr, english = "all")
lapply(ls_dat, eyestr, english = "all", caps = TRUE)
lapply(ls_dat, eyestr, english = "none")
lapply(ls_dat, eyestr, english = "none")
</code></pre>

<hr>
<h2 id='eyes_to_string'>Eye count to strings</h2><span id='topic+eyes_to_string'></span>

<h3>Description</h3>

<p>Eye count to strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eyes_to_string(x, english = "small", caps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eyes_to_string_+3A_x">x</code></td>
<td>
<p>vector of one or two</p>
</td></tr>
<tr><td><code id="eyes_to_string_+3A_english">english</code></td>
<td>
<p>Which numbers to be written in plain english:
choose &quot;small&quot; for numbers till 12, &quot;all&quot; (all numbers),
or &quot;none&quot; (or any other string!) for none</p>
</td></tr>
<tr><td><code id="eyes_to_string_+3A_caps">caps</code></td>
<td>
<p>if TRUE, first number will have capital first letter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string - can be directly pasted into reports
</p>

<hr>
<h2 id='getage'>getage</h2><span id='topic+getage'></span>

<h3>Description</h3>

<p>calculates age in years, as durations or periods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getage(from_date, to_date = lubridate::now(), period = FALSE, dec = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getage_+3A_from_date">from_date</code></td>
<td>
<p>start date</p>
</td></tr>
<tr><td><code id="getage_+3A_to_date">to_date</code></td>
<td>
<p>end date</p>
</td></tr>
<tr><td><code id="getage_+3A_period">period</code></td>
<td>
<p>Calculating period (TRUE) or duration (FALSE- default)</p>
</td></tr>
<tr><td><code id="getage_+3A_dec">dec</code></td>
<td>
<p>How many decimals are displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector
</p>


<h3>Author(s)</h3>

<p>Antoine Fabri and Tjebo Heeren
</p>


<h3>See Also</h3>

<p><a href="https://stackoverflow.com/a/47529507/7941188">OP on stackoverflow</a>
from which this function was inspired.
<a href="https://lubridate.tidyverse.org/articles/lubridate.html#time-intervals">Read about periods and durations</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getage("1984-10-16")

dob &lt;-  c("1984-10-16", "2000-01-01")
test_date &lt;-  as.Date(dob) + c(15000, 20000)
getage(dob, test_date)
</code></pre>

<hr>
<h2 id='getElem'>Find element based or strings</h2><span id='topic+getElem'></span><span id='topic+getElem_id'></span><span id='topic+getElem_eyecol'></span><span id='topic+getElem_eye'></span><span id='topic+getElem_va'></span><span id='topic+getElem_iop'></span>

<h3>Description</h3>

<p>Finds the element in an object for one of the following:
</p>

<ul>
<li> <p><em>getElem_id</em> ID column
</p>
</li>
<li> <p><em>getElem_eyecol</em> eye column
</p>
</li>
<li> <p><em>getElem_eye</em> columns that contain information for right/left eyes
</p>
</li>
<li> <p><em>getElem_va</em> Visual acuity
</p>
</li>
<li> <p><em>getElem_iop</em> IOP
</p>
</li></ul>

<p><code>getElem</code> search a vector, the column names (data frame) or the names (list)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getElem_id(obj)

getElem_eyecol(obj)

getElem_eye(obj)

getElem_va(obj)

getElem_iop(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getElem_+3A_obj">obj</code></td>
<td>
<p>can be vector, data frame or list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>See Also</h3>

<p>Other string matching functions: 
<code><a href="#topic+recodeye">recodeye</a>()</code>,
<code><a href="#topic+sort_substr">sort_substr</a>()</code>,
<code><a href="#topic+str_search">str_search</a></code>
</p>

<hr>
<h2 id='hyperop'>Hyperopic eye data</h2><span id='topic+hyperop'></span>

<h3>Description</h3>

<p>Pivot eye-related variables to two columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperop(x, cols, eye = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperop_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="hyperop_+3A_cols">cols</code></td>
<td>
<p>columns which should be made &quot;wide&quot;. Tidyselection supported</p>
</td></tr>
<tr><td><code id="hyperop_+3A_eye">eye</code></td>
<td>
<p>eye column (default looking for &quot;eye&quot; or &quot;eyes&quot;, all cases)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically the opposite of <code><a href="#topic+myop">myop()</a></code> - a slightly intelligent
wrapper around <code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code> and <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code>
Will find the eye column, unify the codes for the eyes (all to &quot;r&quot; and &quot;l&quot;)
and pivot the columns wide, that have been specified in &quot;cols&quot;.
</p>
<p><strong>Good names and tidy data always help!</strong>
</p>
<p>For more information about shaping data and good names, see <code>vignette("eye")</code>,
or <code>?blink</code> or <code>?myop</code>
</p>


<h3>Value</h3>

<p>A tibble, see also <a href="tibble.html#topic+tibble">tibble::tibble</a>
</p>


<h3>See Also</h3>

<p><a href="https://tidyselect.r-lib.org/reference/language.html">About tidyselection</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example to clean a bit messy data frame

iopva &lt;- data.frame(
  id = c("a", "e", "j", "h"),
  va_r = c(37L, 36L, 33L, 38L),
  iop_r = c(38L, 40L, 33L, 34L),
  va_l = c(30L, 39L, 37L, 40L),
  iop_l = c(31L, 34L, 33L, 31L)
)
myop_iop &lt;- myop(iopva)
hyperop(myop_iop, cols = matches("va|iop"))


</code></pre>

<hr>
<h2 id='introduceNA'>introduce NA for implausible VA entries</h2><span id='topic+introduceNA'></span>

<h3>Description</h3>

<p>introduce NA for implausible VA entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>introduceNA(x, test)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="introduceNA_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="introduceNA_+3A_test">test</code></td>
<td>
<p>plausibility test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>

<hr>
<h2 id='myop'>Myopic eye data</h2><span id='topic+myop'></span><span id='topic+myopic'></span>

<h3>Description</h3>

<p>Pivot &quot;eye&quot; variable to one column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myop(x, var = "value")

myopic(x, var = "value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myop_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="myop_+3A_var">var</code></td>
<td>
<p>Character vector of length 1 specifying the variable if there
is only one column per eye with no further info on the variable
(default &quot;value&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Out of convenience, data is often entered in a very &quot;wide&quot; format:
there will be two columns for the same variable, one column for each eye.
myop will pivot the eye variable to one column and keep all other
variables wide. E.g., eight columns that store data of four variables for two eyes
will be pivoted to 5 columns (one eye and four further variable columns,
see also <em>examples</em>).
</p>
<p><strong>myop requires a specific data format</strong>
</p>
<p>If there is a column called &quot;eye&quot; or &quot;eyes&quot;, myop will not make
any changes - because the data is then already assumed to be in long
format. If you <em>also</em> have columns with eye-specific values,
then you have messy data. Maybe, you could remove or rename the &quot;eye&quot;
column and then let myop do the work.
</p>
<p>myop will only recognize meaningful coding for eyes:
</p>

<ul>
<li><p> Right eyes: <em>&quot;r&quot;, &quot;re&quot;, &quot;od&quot;, &quot;right&quot;</em>
</p>
</li>
<li><p> Left eyes:  <em>&quot;l&quot;, &quot;le&quot;, &quot;os&quot;, &quot;left&quot;</em>
</p>
</li>
<li><p> for other codes see also <a href="#topic+eye_codes">eye_codes</a>
The strings for eyes need to be <strong>separated by period or underscores</strong>.
(Periods will be replaced by underscores). Any order is allowed.
</p>
</li>
<li> <p><strong>Will work</strong>: &quot;va_r&quot;, &quot;right_morningpressure&quot;, &quot;night_iop.le&quot;, &quot;gat_os_postop&quot;
</p>
</li>
<li> <p><strong>Will fail</strong>: &quot;VAr&quot;, &quot;rightmorningPressure&quot;, &quot;night_IOPle&quot;, &quot;gatOSpostop&quot;
</p>
</li></ul>

<p>An exception is when there is only one column for each eye. Then
the column names can consist of eye strings (see above) only.
In this case, <em>var</em> will be used to &quot;name&quot; the resulting variable.
</p>
<p>If there are only eye columns in your data (should actually not happen),
myop will create identifiers by row position.
</p>
<p><strong>Please always check the result for plausibility.</strong>
Depending a lot on how the data was entered, the results could become
quite surprising. There is basically a nearly infinite amount of
possible combinations of how to enter data, and it is likely that
myop will not be able to deal with all of them
</p>


<h3>Value</h3>

<p>A tibble, see also <a href="tibble.html#topic+tibble">tibble::tibble</a>
</p>


<h3>internal preparation</h3>


<ul>
<li><p> Rename data names with  <a href="#topic+myop_rename">myop_rename</a>, replacing &quot;.&quot; with &quot;_&quot;
</p>
</li>
<li><p> Use of <code><a href="#topic+sort_substr">sort_substr()</a></code> - sorting eye strings first, then strings coding
for methods  (IOP/VA), then the rest.
</p>
</li></ul>



<h3>myopization</h3>

<p>The actual work is done with <a href="#topic+myopizer">myopizer</a> and <a href="#topic+myop_pivot">myop_pivot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example to clean a bit messy data frame
iopva &lt;- data.frame(
  id = c("a", "e", "j", "h"),
  va_r = c(37L, 36L, 33L, 38L),
  iop_r = c(38L, 40L, 33L, 34L),
  va_l = c(30L, 39L, 37L, 40L),
  iop_l = c(31L, 34L, 33L, 31L)
)
myop(iopva)

iop_wide &lt;- data.frame(id = letters[1:3],  r = 11:13 , l = 14:16)
# the variable has not been exactly named, so you can specify
# it with the var argument
myop(iop_wide, var = "iop")
</code></pre>

<hr>
<h2 id='myop_pivot'>myopizer</h2><span id='topic+myop_pivot'></span>

<h3>Description</h3>

<p>The actual myopization using <a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer</a>
several columns with partial strings with &quot;eye codes&quot; in their names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myop_pivot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myop_pivot_+3A_x">x</code></td>
<td>
<p>object (data frame)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other myopizer: 
<code><a href="#topic+myop_rename">myop_rename</a>()</code>,
<code><a href="#topic+myopizer">myopizer</a>()</code>
</p>

<hr>
<h2 id='myop_rename'>Rename</h2><span id='topic+myop_rename'></span>

<h3>Description</h3>

<p>Rename data names for <code><a href="#topic+myop">myop()</a></code>, replacing &quot;.&quot; with &quot;_&quot;
in order to prepare for the use of <code><a href="#topic+sort_substr">sort_substr()</a></code> - sorting
eye strings first, then strings coding for methods like IOP/VA,
then the rest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myop_rename(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myop_rename_+3A_x">x</code></td>
<td>
<p>object (data frame)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other myopizer: 
<code><a href="#topic+myop_pivot">myop_pivot</a>()</code>,
<code><a href="#topic+myopizer">myopizer</a>()</code>
</p>

<hr>
<h2 id='myopizer'>myopizer</h2><span id='topic+myopizer'></span>

<h3>Description</h3>

<p>internal function, checks and prepares data frames for
&quot;myopization&quot;:
Removing duplicates, returning myopized data if criteria fulfilled
(No &quot;eye&quot; column, more than one variable column with eye codes
as partial string). Names need to be prepared with
<a href="#topic+myop_rename">myop_rename</a> beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myopizer(x, var = "value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myopizer_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="myopizer_+3A_var">var</code></td>
<td>
<p>Character vector of length 1 specifying the variable if there
is only one column per eye with no further info on the variable
(default &quot;value&quot;)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other myopizer: 
<code><a href="#topic+myop_pivot">myop_pivot</a>()</code>,
<code><a href="#topic+myop_rename">myop_rename</a>()</code>
</p>

<hr>
<h2 id='parse_snellen'>parsing snellen fractions to numeric values</h2><span id='topic+parse_snellen'></span>

<h3>Description</h3>

<p>parsing snellen fractions to numeric values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_snellen(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_snellen_+3A_y">y</code></td>
<td>
<p>vector</p>
</td></tr>
</table>

<hr>
<h2 id='plausibility_methods'>Plausibility checking</h2><span id='topic+plausibility_methods'></span><span id='topic+checkVA'></span><span id='topic+checkVA.quali'></span><span id='topic+checkVA.snellen'></span><span id='topic+checkVA.snellendec'></span><span id='topic+checkVA.logmar'></span><span id='topic+checkVA.etdrs'></span><span id='topic+checkVA.default'></span>

<h3>Description</h3>

<p>S3 methods for checking plausibility of VA entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkVA(x, ...)

## S3 method for class 'quali'
checkVA(x, ...)

## S3 method for class 'snellen'
checkVA(x, ...)

## S3 method for class 'snellendec'
checkVA(x, ...)

## S3 method for class 'logmar'
checkVA(x, ...)

## S3 method for class 'etdrs'
checkVA(x, ...)

## Default S3 method:
checkVA(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plausibility_methods_+3A_x">x</code></td>
<td>
<p>vector of visual acuities</p>
</td></tr>
<tr><td><code id="plausibility_methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with visual acuity of class <code>va</code>. See also &quot;VA classes&quot;
</p>


<h3>Plausibility checks</h3>

<p>VA can be snellen (fraction: feet/meter), snellen decimal, logMAR, ETDRS, or
&quot;qualitative&quot; (Counting fingers, etc.)
</p>

<ul>
<li><p> Snellen fractions need to be either form 6/x or 20/x
</p>
</li>
<li><p> Snellen decimal must be &gt; 0 and &lt;= 2
</p>
</li>
<li><p> ETDRS must be &gt;= 0 and &lt;= 100
</p>
</li>
<li><p> logMAR must be &gt;= -0.3 and &lt;= 3.0
</p>
</li>
<li><p> Qualitative must be PL, LP, NLP, NPL, HM, CF (any case allowed)
</p>
</li></ul>

<p>Any element which is implausible / not recognized will be converted to NA
</p>


<h3>See Also</h3>

<p>Other VA converter: 
<code><a href="#topic+VAwrapper">VAwrapper</a></code>,
<code><a href="#topic+snellen_steps">snellen_steps</a></code>,
<code><a href="#topic+va_methods">va_methods</a></code>,
<code><a href="#topic+va_mixed">va_mixed</a>()</code>,
<code><a href="#topic+va">va</a>()</code>,
<code><a href="#topic+which_va">which_va</a>()</code>
</p>

<hr>
<h2 id='print_methods'>print eye classes</h2><span id='topic+print_methods'></span><span id='topic+print.snellen'></span><span id='topic+print.logmar'></span><span id='topic+print.etdrs'></span><span id='topic+print.blink'></span><span id='topic+print.eyes'></span><span id='topic+print.eyes_details'></span>

<h3>Description</h3>

<p>S3 methods for VA classes &quot;snellen&quot;, &quot;logmar&quot; and &quot;etdrs&quot;.
<strong>snellen</strong> is always also a character class- because it is more categorical
than continuous. <strong>logmar</strong> and <strong>etdrs</strong> are both numerics
(logMAR is double, etdrs is integer).
</p>
<p>S3 methods for class blink
</p>
<p>S3 methods for class eyes
</p>
<p>S3 methods for class eyes_details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snellen'
print(x, ...)

## S3 method for class 'logmar'
print(x, ...)

## S3 method for class 'etdrs'
print(x, ...)

## S3 method for class 'blink'
print(x, ...)

## S3 method for class 'eyes'
print(x, ...)

## S3 method for class 'eyes_details'
print(x, show = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_methods_+3A_x">x</code></td>
<td>
<p>object of class &quot;eyes_details&quot;</p>
</td></tr>
<tr><td><code id="print_methods_+3A_...">...</code></td>
<td>
<p>arguments passed to <a href="base.html#topic+print.default">print.default</a></p>
</td></tr>
<tr><td><code id="print_methods_+3A_show">show</code></td>
<td>
<p>how many subjects to be shown before printing the footnote</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects (printing)
</p>

<hr>
<h2 id='recodeye'>Recode eyes</h2><span id='topic+recodeye'></span>

<h3>Description</h3>

<p>recoding eyes to &quot;r&quot; and &quot;l&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recodeye(x, to = NULL, eyestrings = NULL, dropunknown = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recodeye_+3A_x">x</code></td>
<td>
<p>vector of strings</p>
</td></tr>
<tr><td><code id="recodeye_+3A_to">to</code></td>
<td>
<p>named vector to which eye codes. If unnamed, this order: c(r, l, b)</p>
</td></tr>
<tr><td><code id="recodeye_+3A_eyestrings">eyestrings</code></td>
<td>
<p>named list of substrings which should be converted to
right and left eyes - if passed unnamed, this order: list(r, l, b)</p>
</td></tr>
<tr><td><code id="recodeye_+3A_dropunknown">dropunknown</code></td>
<td>
<p>introduces NA for values that are not part of eyestrings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>


<h3>string detection</h3>

<p>recodeye will automatically detect the following strings:
right = c(&quot;r&quot;, &quot;re&quot;, &quot;od&quot;, &quot;right&quot;),
left = c(&quot;l&quot;, &quot;le&quot;, &quot;os&quot;, &quot;left&quot;),
both = c(&quot;b&quot;,&quot;both&quot;,&quot;ou&quot;)
</p>
<p>You can change this with <a href="#topic+set_eye_strings">set_eye_strings</a>
</p>


<h3>to and eyecode arguments</h3>

<p>If passed, should ideally be of same length, and have the respective eyes
at the same index (or with the same name!). If the lengths are not equal,
e.g., if only &quot;to&quot; is passed with n elements, the shorter argument will be
will be cut down to the first n elements of the longer argument.
</p>
<p>Note that all unique strings which are part of the column should be contained
in the &quot;eyecode&quot; argument.
</p>


<h3>numeric coding</h3>

<p>Currently numeric coding only accepts binary
coding (right and left eye). In order to use numeric coding for &quot;both eyes&quot;
as well, a workaround using the eyestrings argument is suggested.
</p>


<h3>See Also</h3>

<p>Other string matching functions: 
<code><a href="#topic+getElem">getElem</a></code>,
<code><a href="#topic+sort_substr">sort_substr</a>()</code>,
<code><a href="#topic+str_search">str_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("r", "re", "od", "right", "l", "le", "os", "left", "both", "ou")
recodeye(x)

## chose the resulting codes
recodeye(x, to = c("od", "os", "ou"))

x &lt;- 1:2
recodeye(x)

## If you code your eyes with different strings,
## e.g., because you are using a different language,
## you can change this either with the eyestrings argument,
french &lt;- c("OD", "droit", "gauche", "OG")
recodeye(french, eyestrings = list(r = c("droit", "od"), l = c("gauche", "og")))

## or change it more globally with `set_eye_strings`
set_eye_strings(right = c("droit", "od"), left = c("gauche", "og"))
recodeye(french)

## restore defaults with
set_eye_strings()
</code></pre>

<hr>
<h2 id='remCols'>Remove cols from selected cols</h2><span id='topic+remCols'></span>

<h3>Description</h3>

<p>Helper for <code><a href="#topic+blink">blink()</a></code>. Removes columns that only
contain values fct_levels or binary from selected columns (currently for
both automatically and manually selected columns).
fct_levels are removed because they are likely categorical codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remCols(x, cols, fct_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remCols_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="remCols_+3A_cols">cols</code></td>
<td>
<p>cols</p>
</td></tr>
<tr><td><code id="remCols_+3A_fct_level">fct_level</code></td>
<td>
<p>Remove columns for reveal and va when all unique values
fall into the range of fct_level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>

<hr>
<h2 id='reveal'>reveal</h2><span id='topic+reveal'></span>

<h3>Description</h3>

<p>Shows commonly used summary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal(x, by = NULL, dec = 1, funs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_+3A_x">x</code></td>
<td>
<p>data frame, numeric vector, or list of numeric vectors</p>
</td></tr>
<tr><td><code id="reveal_+3A_by">by</code></td>
<td>
<p>character vector with the names of the columns. Can be
several variables!</p>
</td></tr>
<tr><td><code id="reveal_+3A_dec">dec</code></td>
<td>
<p>how many decimals are displayed</p>
</td></tr>
<tr><td><code id="reveal_+3A_funs">funs</code></td>
<td>
<p>not really meant to be used at the moment - change the
Summarizing functions with a named(!) list of functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Character vectors (or character columns) will be removed.
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other revealer: 
<code><a href="#topic+reveal_methods">reveal_methods</a></code>,
<code><a href="#topic+reveal_split">reveal_split</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = y = z = c(rnorm(20), NA)
mylist &lt;- list(x = x, y = y, z = z)
## vectors
reveal(x)
reveal(1:10)
## named or unnamed list
reveal(mylist)
set.seed(42)
mydf &lt;- cbind(group = rep(letters[1:3], 4),
setNames(as.data.frame(replicate(c(rnorm(11), NA), n = 3)), letters[24:26]))
## data frames
reveal(mydf)
## data frames by group
reveal(mydf, by = "group")
</code></pre>

<hr>
<h2 id='reveal_methods'>reveals little helper</h2><span id='topic+reveal_methods'></span><span id='topic+revealEye'></span><span id='topic+revealEye.list'></span><span id='topic+revealEye.numeric'></span><span id='topic+revealEye.data.frame'></span><span id='topic+revealEye.default'></span>

<h3>Description</h3>

<p>S3 generic and methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revealEye(x, ...)

## S3 method for class 'list'
revealEye(x, by, dec, funs, ...)

## S3 method for class 'numeric'
revealEye(x, dec, funs, ...)

## S3 method for class 'data.frame'
revealEye(x, dec, funs, ...)

## Default S3 method:
revealEye(x, dec, funs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_methods_+3A_x">x</code></td>
<td>
<p>data frame, numeric vector, or list of numeric vectors</p>
</td></tr>
<tr><td><code id="reveal_methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods</p>
</td></tr>
<tr><td><code id="reveal_methods_+3A_by">by</code></td>
<td>
<p>character vector with the names of the columns. Can be
several variables!</p>
</td></tr>
<tr><td><code id="reveal_methods_+3A_dec">dec</code></td>
<td>
<p>how many decimals are displayed</p>
</td></tr>
<tr><td><code id="reveal_methods_+3A_funs">funs</code></td>
<td>
<p>not really meant to be used at the moment - change the
Summarizing functions with a named(!) list of functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other revealer: 
<code><a href="#topic+reveal_split">reveal_split</a>()</code>,
<code><a href="#topic+reveal">reveal</a>()</code>
</p>

<hr>
<h2 id='reveal_split'>reveals little helper</h2><span id='topic+reveal_split'></span>

<h3>Description</h3>

<p>splits into groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_split(x, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_split_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="reveal_split_+3A_by">by</code></td>
<td>
<p>character vector with the names of the columns</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other revealer: 
<code><a href="#topic+reveal_methods">reveal_methods</a></code>,
<code><a href="#topic+reveal">reveal</a>()</code>
</p>

<hr>
<h2 id='set_eye_strings'>Set list of codes</h2><span id='topic+set_eye_strings'></span>

<h3>Description</h3>

<p>This sets the list of codes used throughout the eye package for
the coding of all kind of stuff. If you want to change recognized codes,
this is the place to do it. See examples below how to easily overwrite it.
It is important that you must pass them as a character vector!
</p>
<p><strong>cases are always ignored</strong>, so you don't need to worry about this bit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_eye_strings(
  right = c("r", "re", "od", "right"),
  left = c("l", "le", "os", "left"),
  both = c("b", "both", "ou"),
  iop = c("iop", "gat", "nct"),
  iop_partial = c("pressure"),
  va = c("va", "bcva"),
  va_method = c("etdrs", "snellen", "logmar"),
  va_partial = c("acuit"),
  id = c("pat", "id"),
  eye = c("eye", "eyes"),
  quali = c("nlp", "lp", "hm", "cf"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_eye_strings_+3A_right">right</code></td>
<td>
<p>right eyes</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_left">left</code></td>
<td>
<p>left eyes</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_both">both</code></td>
<td>
<p>both eyes</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_iop">iop</code></td>
<td>
<p>IOP codes</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_iop_partial">iop_partial</code></td>
<td>
<p>partial strings used to find IOP columns</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_va">va</code></td>
<td>
<p>VA codes</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_va_method">va_method</code></td>
<td>
<p>VA methods (used to recognize VA columns -
when those strings occur &quot;fully&quot;, i.e., not as part of sth else)</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_va_partial">va_partial</code></td>
<td>
<p>Also used to find VA columns - looking for partial strings</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_id">id</code></td>
<td>
<p>patient column codes</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_eye">eye</code></td>
<td>
<p>eye column codes</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_quali">quali</code></td>
<td>
<p>quali VA codes</p>
</td></tr>
<tr><td><code id="set_eye_strings_+3A_...">...</code></td>
<td>
<p>currently not used, but might be needed in the future</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># To expand recognized codes for eyes, e.g. if you want to use French names
set_eye_strings(right = c("droit", "od"), left = c("gauche", "og"))

# To restore the defaults, simply call set_eye_strings empty
set_eye_strings()
</code></pre>

<hr>
<h2 id='snellen_steps'>Convert plus minus entries</h2><span id='topic+snellen_steps'></span><span id='topic+snellensteps'></span>

<h3>Description</h3>

<p>Convert plus minus entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snellensteps(x, smallstep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snellen_steps_+3A_x">x</code></td>
<td>
<p>Vector with VA entries of class snellen - needs to be in
format xx/yy</p>
</td></tr>
<tr><td><code id="snellen_steps_+3A_smallstep">smallstep</code></td>
<td>
<p>if plusminus shall be considered as logmar equivalent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of Snellen entries
</p>


<h3>See Also</h3>

<p>https://en.wikipedia.org/wiki/Psychometric_function
</p>
<p>Other VA converter: 
<code><a href="#topic+VAwrapper">VAwrapper</a></code>,
<code><a href="#topic+plausibility_methods">plausibility_methods</a></code>,
<code><a href="#topic+va_methods">va_methods</a></code>,
<code><a href="#topic+va_mixed">va_mixed</a>()</code>,
<code><a href="#topic+va">va</a>()</code>,
<code><a href="#topic+which_va">which_va</a>()</code>
</p>

<hr>
<h2 id='sort_substr'>sort substrings</h2><span id='topic+sort_substr'></span>

<h3>Description</h3>

<p>unify code for substrings and arrange, after tokenizing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_substr(x, list_substr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_substr_+3A_x">x</code></td>
<td>
<p>vector of strings</p>
</td></tr>
<tr><td><code id="sort_substr_+3A_list_substr">list_substr</code></td>
<td>
<p>list of substrings to match against and sort -
the order in the list defines the resulting order in the string
Should be names list - the names will be the codes to which the
tokens will be matched against.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other string matching functions: 
<code><a href="#topic+getElem">getElem</a></code>,
<code><a href="#topic+recodeye">recodeye</a>()</code>,
<code><a href="#topic+str_search">str_search</a></code>
</p>

<hr>
<h2 id='split_mult'>split columns in multiple by regex</h2><span id='topic+split_mult'></span>

<h3>Description</h3>

<p>Reveal helper. cuts column into multiple in reveal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_mult(x, col, pattern = "_", into = NULL, prefix = "var", sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_mult_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="split_mult_+3A_col">col</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="split_mult_+3A_pattern">pattern</code></td>
<td>
<p>regex by which to split</p>
</td></tr>
<tr><td><code id="split_mult_+3A_into">into</code></td>
<td>
<p>names of columns - character vector of length of n splits</p>
</td></tr>
<tr><td><code id="split_mult_+3A_prefix">prefix</code></td>
<td>
<p>if into not specified, names created &quot;prefix(sep)index&quot;</p>
</td></tr>
<tr><td><code id="split_mult_+3A_sep">sep</code></td>
<td>
<p>separator of prefix and index</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>modified from
<a href="https://stackoverflow.com/a/47060452/7941188">this thread on stackoverflow</a>
</p>

<hr>
<h2 id='str_search'>String search helper</h2><span id='topic+str_search'></span><span id='topic+whole_str'></span><span id='topic+part_str'></span><span id='topic+both_str'></span>

<h3>Description</h3>

<p><strong>whole_str</strong> finds haystack with &quot;whole needles&quot;
with any non character as boundaries
</p>
<p><strong>part_str</strong> finds haystacks that match any of the needles
</p>
<p><strong>both_str</strong> will find haystacks that contain both needles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whole_str(haystack, needle)

part_str(haystack, needle)

both_str(haystack, needle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_search_+3A_haystack">haystack</code></td>
<td>
<p>object in which to look for the needle</p>
</td></tr>
<tr><td><code id="str_search_+3A_needle">needle</code></td>
<td>
<p>vector of strings to look for - accepts regular expressions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other string matching functions: 
<code><a href="#topic+getElem">getElem</a></code>,
<code><a href="#topic+recodeye">recodeye</a>()</code>,
<code><a href="#topic+sort_substr">sort_substr</a>()</code>
</p>

<hr>
<h2 id='tidyNA'>Tidy NA entries to actual NA values</h2><span id='topic+tidyNA'></span><span id='topic+tidyNA_low'></span><span id='topic+isNAstring'></span>

<h3>Description</h3>

<p>Creates tidy NA entries - NA equivalent strings are tidied to
actual NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidyNA(x, ...)

tidyNA_low(x, ...)

isNAstring(x, string = NULL, defaultstrings = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyNA_+3A_x">x</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="tidyNA_+3A_...">...</code></td>
<td>
<p>passed to <a href="#topic+isNAstring">isNAstring</a></p>
</td></tr>
<tr><td><code id="tidyNA_+3A_string">string</code></td>
<td>
<p>vector of full strings to be replaced by NA</p>
</td></tr>
<tr><td><code id="tidyNA_+3A_defaultstrings">defaultstrings</code></td>
<td>
<p>by default (TRUE), the following strings will be replaced by
NA values: c(&quot;\.+&quot;, &quot;&quot;, &quot;\s+&quot;, &quot;n/a&quot;, &quot;na&quot;, &quot;null&quot;, &quot;^-$&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tidyNA_low is an internal function used for VA cleaning
returning a lower case vector.
</p>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a", "   ", ".", "-", "NULL")
tidyNA(x)

# in addition to the default strings, a new string can be added
tidyNA(x, string = "a")

# or just remove the strings you want
tidyNA(x, string = "a", defaultstrings = FALSE)
</code></pre>

<hr>
<h2 id='tocapital'>Capitalize words</h2><span id='topic+tocapital'></span>

<h3>Description</h3>

<p>capitalises single words
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tocapital(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tocapital_+3A_x">x</code></td>
<td>
<p>string vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>

<hr>
<h2 id='va'>Visual acuity notation conversion</h2><span id='topic+va'></span>

<h3>Description</h3>

<p>Cleans and converts visual acuity notations (classes)
between Snellen (decimal, meter and feet), ETDRS, and logMAR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>va(x, from = NULL, to = NULL, type = "ft", smallstep = FALSE, noplus = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="va_+3A_x">x</code></td>
<td>
<p>Vector with visual acuity entries. Must be atomic.
Snellen fractions need to be entered with &quot;/&quot;</p>
</td></tr>
<tr><td><code id="va_+3A_from">from</code></td>
<td>
<p>will force to evaluate from which notation to convert - Must be
&quot;etdrs&quot;, &quot;logmar&quot;, &quot;snellen&quot; or &quot;snellendec&quot;.
Ignored if the value should not be plausible.</p>
</td></tr>
<tr><td><code id="va_+3A_to">to</code></td>
<td>
<p>To which class to convert. &quot;etdrs&quot;, &quot;logmar&quot; or &quot;snellen&quot; -
any case allowed. If NULL (default), will simply &quot;clean up&quot; VA entries.
This may then result in a vector of &quot;mixed&quot; VA notations.</p>
</td></tr>
<tr><td><code id="va_+3A_type">type</code></td>
<td>
<p>To which Snellen notation to convert: &quot;m&quot;, &quot;dec&quot; or &quot;ft&quot;</p>
</td></tr>
<tr><td><code id="va_+3A_smallstep">smallstep</code></td>
<td>
<p>how +/- entries are evaluated. FALSE:
increase/decrease Snellen fractions by lines. TRUE: plus/minus
entries equivalent to 0.02 logmar</p>
</td></tr>
<tr><td><code id="va_+3A_noplus">noplus</code></td>
<td>
<p>ignoring plus/minus entries and just returning the
snellen fraction. This overrides the smallstep argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of <code>va</code> class. See also &quot;VA classes&quot;
</p>


<h3>VA conversion</h3>


<ul>
<li> <p><strong>logMAR to ETDRS</strong>: logMAR rounded to the first digit and converted with
the visual acuity chart (see section VA chart)
</p>
</li>
<li> <p><strong>Snellen to logMAR</strong>: logMAR = -1 * log10(snellen_frac)
</p>
</li>
<li> <p><strong>Snellen to ETDRS</strong>: ETDRS = 85 + 50 * log10(snellen_frac)
doi: <a href="https://doi.org/10.1097/iae.0b013e3181d87e04">10.1097/iae.0b013e3181d87e04</a>
</p>
</li>
<li> <p><strong>ETDRS to logMAR</strong>: logMAR = -0.02 * etdrs + 1.7
Beck et al. doi: <a href="https://doi.org/10.1016/s0002-9394(02)01825-1">10.1016/s0002-9394(02)01825-1</a>
</p>
</li>
<li> <p><strong>Hand movements and counting fingers</strong> are converted following
Schulze-Bonsel et al. - https://doi.org/10.1167/iovs.05-0981
</p>
</li>
<li> <p><strong>(No) light perception</strong> are converted following the suggestions by
<a href="https://michaelbach.de/sci/acuity.html">Michael Bach</a>
</p>
</li></ul>



<h3>Qualitative visual acuity entries</h3>

<p>In order to calculate with qualitative entries counting fingers,
hand movement and (no) perception of light, <strong>use logMAR</strong> !
Qualitative visual acuity lower than counting fingers is assigned 0
ETDRS letter, in order to keep it as a measurement (not: NA). It is very
difficult to justify a &quot;negative&quot; letter score in a test which only has
a specific range (0-100).
</p>

<ul>
<li> <p><strong>To Snellen</strong>:
Although there seems to be no good statistical reason to convert
back to Snellen, it is a very natural thing to eye specialists to think
in Snellen. A conversion to snellen gives a good gauge of how the visual
acuity for the patients are. However, back-conversion should not be
considered an exact science and any attempt to use formulas will result
in very weird Snellen values that have no correspondence to common charts.
Therefore, Snellen matching the nearest ETDRS and logMAR value in
the VA chart are used.
</p>
</li></ul>



<h3>VA chart</h3>

<p>You can find with eye:::va_chart.
This chart and VA conversion formulas are based on charts in
Holladay et al.doi: <a href="https://doi.org/10.1016/j.jcrs.2004.01.014">10.1016/j.jcrs.2004.01.014</a>, Beck et al.
doi: <a href="https://doi.org/10.1016/s0002-9394(02)01825-1">10.1016/s0002-9394(02)01825-1</a>Beck et al., and
Gregori et al.doi: <a href="https://doi.org/10.1097/iae.0b013e3181d87e04">10.1097/iae.0b013e3181d87e04</a>.
The etdrs values for NLP and PL are deliberately set at those values because
they are unlikely to happen by chance as a wrong entry (and as integers),
and it has internal reasons that make conversion easier.
</p>


<h3>Accepted VA formats / Plausibility checks</h3>


<ul>
<li><p> Snellen fractions (meter/ feet) need to be entered as fraction with
&quot;/&quot;. Any fractions allowed. You can get creative with your snellens.
see <strong>&quot;Examples&quot;</strong>
</p>
</li>
<li><p> ETDRS must be integer-equivalent between 0 and 100 (integer equivalent
means, it can also be a character vector)
</p>
</li>
<li><p> logMAR must be -0.3 &lt;= x &lt;= 3.0
</p>
</li>
<li><p> Snellen decimal must be 0 &lt; x &lt;= 2
</p>
</li>
<li><p> Qualitative must be either of PL, LP, NLP, NPL, HM, CF (any case allowed)
</p>
</li>
<li><p> Plausibility checks are performed for the automatically or manually defined
notation.
</p>
</li>
<li><p> Any element which is implausible/ not recognized will be converted to NA
</p>
</li></ul>



<h3>Entries with mixed VA notations</h3>

<p>Use <a href="#topic+va_mixed">va_mixed</a> instead.
</p>


<h3>Snellen &quot;+/-&quot; entries</h3>

<p>By default, plus/minus entries are evaluated as intended by the
test design: Snellen fractions increase/decrease only by lines.</p>
<pre>- if entry -2 to +2 : take same Snellen value
- if &lt; -2 : take Snellen value one line below
- if &gt; +2 : take Snellen value one line above
</pre>
<p>If smallstep = TRUE, each snellen optotype will be considered
equivalent to 0.02 logmar (assuming 5 letters in a row in a chart)
</p>


<h3>VA cleaning</h3>

<p>For more details see <code><a href="#topic+clean_va">clean_va()</a></code>
</p>

<ol>
<li> <p><code>NA</code> is assigned to strings such as &quot;.&quot; or &quot;&quot;, &quot;n/a&quot; or &quot;   &quot;
</p>
</li>
<li><p> notation for qualitative entries is simplified.
</p>
</li></ol>



<h3>VA classes</h3>

<p>convertVA returns a vector of three classes:
</p>

<ol>
<li> <p><code>va</code>
</p>
</li>
<li><p> One of snellen, snellendec, logmar, etdrs or quali.
</p>
</li>
<li><p> Either of <code>character</code> (for Snellen, snellendec, and qualitative),
<code>numeric</code> (for logMAR), or <code>integer</code> (for ETDRS).
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Ophthalmic functions: 
<code><a href="#topic+va_mixed">va_mixed</a>()</code>
</p>
<p>Other VA converter: 
<code><a href="#topic+VAwrapper">VAwrapper</a></code>,
<code><a href="#topic+plausibility_methods">plausibility_methods</a></code>,
<code><a href="#topic+snellen_steps">snellen_steps</a></code>,
<code><a href="#topic+va_methods">va_methods</a></code>,
<code><a href="#topic+va_mixed">va_mixed</a>()</code>,
<code><a href="#topic+which_va">which_va</a>()</code>
</p>
<p>Other VA cleaner: 
<code><a href="#topic+clean_va">clean_va</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## will automatically detect VA class and convert to logMAR by default
## ETDRS letters
x &lt;- c(23, 56, 74, 58)
va(x)

## ... or convert to snellen
va(x, to = "snellen")

## snellen, mixed with categories. Also dealing with those "plus/minus" entries
va(c("NLP", "NPL", "PL", "LP", "HM", "CF", "6/60", "20/200", "6/9",
 "20/40", "20/40+3", "20/50-2"))

## A mix of notations is also possible
x &lt;- c("NLP", "0.8", "34", "3/60", "2/200", "20/40+3", "20/50-2")
va(x)

## Any fraction is possible, and empty values
x &lt;- c("CF", "3/60", "2/200", "", "20/40+3", ".", "      ")
va(x)

## but this not any fraction when converting from one class to the other
x &lt;- c("3/60", "2/200", "6/60", "20/200", "6/9")
va(x, to="snellen", type = "m")
</code></pre>

<hr>
<h2 id='va_methods'>VA conversion methods</h2><span id='topic+va_methods'></span><span id='topic+convertVA'></span><span id='topic+convertVA.quali'></span><span id='topic+convertVA.snellendec'></span><span id='topic+convertVA.snellen'></span><span id='topic+convertVA.logmar'></span><span id='topic+convertVA.etdrs'></span><span id='topic+convertVA.default'></span>

<h3>Description</h3>

<p>S3 methods for VA conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertVA(x, ...)

## S3 method for class 'quali'
convertVA(x, to, type, ...)

## S3 method for class 'snellendec'
convertVA(x, to, type, ...)

## S3 method for class 'snellen'
convertVA(x, to, type, smallstep, noplus, ...)

## S3 method for class 'logmar'
convertVA(x, to, type, ...)

## S3 method for class 'etdrs'
convertVA(x, to, type, ...)

## Default S3 method:
convertVA(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="va_methods_+3A_x">x</code></td>
<td>
<p>vector of visual acuities</p>
</td></tr>
<tr><td><code id="va_methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods</p>
</td></tr>
<tr><td><code id="va_methods_+3A_to">to</code></td>
<td>
<p>to which VA class to convert</p>
</td></tr>
<tr><td><code id="va_methods_+3A_type">type</code></td>
<td>
<p>which snellen notation. One of &quot;ft&quot;, &quot;m&quot; or &quot;dec&quot;</p>
</td></tr>
<tr><td><code id="va_methods_+3A_smallstep">smallstep</code></td>
<td>
<p>how plus/minus entries are evaluated. Default to
increase/decrease snellen fractions by lines. If TRUE, each snellen
optotype will be considered equivalent to 0.02 logmar or 1 ETDRS
letter (assuming 5 letters in a row in a chart)</p>
</td></tr>
<tr><td><code id="va_methods_+3A_noplus">noplus</code></td>
<td>
<p>ignoring plus/minus entries and just returning the
snellen fraction. This overrides the smallstep argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>VA can be snellen feet/meter/decimal, logMAR, ETDRS, or
&quot;qualitative&quot; (Counting fingers, etc.)
</p>

<ul>
<li><p> Snellen fractions need to be either form 6/x or 20/x
</p>
</li>
<li><p> ETDRS must be between 0 and 100
</p>
</li>
<li><p> logMAR must be between -0.3 and 3.0
</p>
</li>
<li><p> Qualitative must be PL, LP, NLP, NPL, HM, CF (any case allowed)
</p>
</li></ul>

<p>Any element which is not recognized will be converted to NA
</p>


<h3>Value</h3>

<p>vector with visual acuity of class <code>va</code>. See also &quot;VA classes&quot;
</p>


<h3>Conversion</h3>

<p>For other conversion and theory behind conversion rules see <a href="#topic+va">va</a>
section VA conversion.
</p>


<h3>plus/minus entries</h3>

<p>The following rules for plus minus notations will be applied:
</p>

<ul>
<li><p> if entry -2 to +2 : take same Snellen value
</p>
</li>
<li><p> if &lt; -2 : take Snellen value one line below
</p>
</li>
<li><p> if &gt; +2: Snellen value one line above
</p>
</li></ul>

<p>Snellen are unfortunately often entered with &quot;+/-&quot;, which is a
violation of a psychophysical method designed to assign one
unambiguous value to visual acuity, with
non-arbitrary thresholds based on psychometric functions. Therefore,
transforming &quot;+/-&quot; notation to actual results is in itself
problematic and the below suggestion to convert it will remain an
approximation to the most likely &quot;true&quot; result. Even more so, as the
given conditions should work for charts with
4 or 5 optotypes in a line, and visual acuity is not always tested
on such charts. Yet, I believe that the approach is still better than
just omitting the letters or (worse) assigning a missing value to those
entries.
</p>


<h3>See Also</h3>

<p>Other VA converter: 
<code><a href="#topic+VAwrapper">VAwrapper</a></code>,
<code><a href="#topic+plausibility_methods">plausibility_methods</a></code>,
<code><a href="#topic+snellen_steps">snellen_steps</a></code>,
<code><a href="#topic+va_mixed">va_mixed</a>()</code>,
<code><a href="#topic+va">va</a>()</code>,
<code><a href="#topic+which_va">which_va</a>()</code>
</p>

<hr>
<h2 id='va_mixed'>VA classes</h2><span id='topic+va_mixed'></span>

<h3>Description</h3>

<p>va_mixed is a wrapper around <a href="#topic+va">va</a> on all possible VA notations.
By default, c(&quot;snellen&quot;, &quot;etdrs&quot;, &quot;logmar&quot;, &quot;snellendec&quot;) will be converted -
in that order! For tricky cases see details and examples. Note
that va_mixed will not give nice messages which values are transformed
from which notation, and which values were replaced with NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>va_mixed(x, to, possible)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="va_mixed_+3A_x">x</code></td>
<td>
<p>vector with mixed VA entries</p>
</td></tr>
<tr><td><code id="va_mixed_+3A_to">to</code></td>
<td>
<p>to which notation to be converted</p>
</td></tr>
<tr><td><code id="va_mixed_+3A_possible">possible</code></td>
<td>
<p>which possible VA notations - and the precedence given,
see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixed entries are challenging, but unfortunately seem to occur in
real life data. It will be fairly individual what you have in yours, but
it should hopefully not happen that you have <em>all</em> possible notations.
Snellen fractions are usually not challenging because they contain a &quot;/&quot;,
thus are easy to recognize.
</p>
<p><strong>Most problematic are values between 0 and 3</strong>,
in particular full integers - this can be EDTRS, snellen decimal notation
or logmar. If your data doesn't have snellen decimal notation,
specify this with &quot;possible&quot;, e.g. with
<code>possible = c("snellen", "etdrs", "logmar")</code>. If you know that you don't
have any ETDRS value less than 4, you can safely give precedence to logmar
instead, like this: <code>possible = c("snellen", "logmar", "etdrs")</code>
@examples
</p>


<h3>awfully mixed notation!! (and note the wrong -1 value)</h3>

<p>x &lt;- c(NA, &quot;nlp&quot;, 1:2, 1.1, -1, &quot;20/40&quot;, &quot;4/6&quot;, &quot;6/1000&quot;, 34)
va_mixed(x, to = &quot;snellen&quot;)
</p>


<h3>&quot;I only have snellen and snellen decimal notation in my data&quot;</h3>

<p>va_mixed(x, to = &quot;snellen&quot;, possible = c(&quot;snellen&quot;, &quot;snellendec&quot;))
</p>


<h3>&quot;I have snellen, logmar and etdrs in my data, and there is no etdrs value</h3>

<p>less than 4&quot;
va_mixed(x, to = &quot;snellen&quot;, possible = c(&quot;snellen&quot;, &quot;logmar&quot;, &quot;etdrs&quot;))
</p>


<h3>See Also</h3>

<p>Other Ophthalmic functions: 
<code><a href="#topic+va">va</a>()</code>
</p>
<p>Other VA converter: 
<code><a href="#topic+VAwrapper">VAwrapper</a></code>,
<code><a href="#topic+plausibility_methods">plausibility_methods</a></code>,
<code><a href="#topic+snellen_steps">snellen_steps</a></code>,
<code><a href="#topic+va_methods">va_methods</a></code>,
<code><a href="#topic+va">va</a>()</code>,
<code><a href="#topic+which_va">which_va</a>()</code>
</p>

<hr>
<h2 id='VAclasses'>VA classes</h2><span id='topic+VAclasses'></span>

<h3>Description</h3>

<p>VA classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAclasses
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 5.
</p>

<hr>
<h2 id='VAwrapper'>VA conversion wrapper</h2><span id='topic+VAwrapper'></span><span id='topic+to_logmar'></span><span id='topic+to_etdrs'></span><span id='topic+to_snellen'></span><span id='topic+as_logmar'></span><span id='topic+as_etdrs'></span><span id='topic+as_snellen'></span>

<h3>Description</h3>

<p>Simple convenience wrapper around <a href="#topic+va">va</a> to get desired VA class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_logmar(x, ...)

to_etdrs(x, ...)

to_snellen(x, ...)

as_logmar(x, ...)

as_etdrs(x, ...)

as_snellen(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VAwrapper_+3A_x">x</code></td>
<td>
<p>vector of visual acuities</p>
</td></tr>
<tr><td><code id="VAwrapper_+3A_...">...</code></td>
<td>
<p>parameters passed to <a href="#topic+va">va</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with visual acuity of class as_(...) or to_(...)
See also <a href="#topic+convertVA">convertVA</a>: &quot;VA classes&quot;
</p>


<h3>VA conversion</h3>

<p>For details see <a href="#topic+va">va</a> and <a href="#topic+convertVA">convertVA</a>
</p>


<h3>See Also</h3>

<p>Other VA converter: 
<code><a href="#topic+plausibility_methods">plausibility_methods</a></code>,
<code><a href="#topic+snellen_steps">snellen_steps</a></code>,
<code><a href="#topic+va_methods">va_methods</a></code>,
<code><a href="#topic+va_mixed">va_mixed</a>()</code>,
<code><a href="#topic+va">va</a>()</code>,
<code><a href="#topic+which_va">which_va</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(23, 56, 74, 58) ## ETDRS letters
to_logmar(x)
to_snellen(x)
to_snellen(x, type = "dec")

x &lt;- c("NLP", "0.8", "34", "3/60", "2/200", "20/50", "  ", ".", "-", "NULL")
to_snellen(x, from = "snellendec")
to_snellen(x, from = "etdrs")
to_snellen(x, from = "logmar")
</code></pre>

<hr>
<h2 id='warnings'>recode warnings</h2><span id='topic+warnings'></span><span id='topic+warn_recode'></span><span id='topic+messageNA'></span>

<h3>Description</h3>

<p>recode warnings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warn_recode(x)

messageNA(x, eyestrings)
</code></pre>

<hr>
<h2 id='which_va'>Guessing the VA class</h2><span id='topic+which_va'></span>

<h3>Description</h3>

<p>Guessing the VA notation (VA class). Requires x that was
prepared with <a href="#topic+clean_va">clean_va</a>
</p>

<ul>
<li> <p><code>which_va</code>: guessing VA class for entire vector
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>which_va(x, quali = c("nlp", "npl", "pl", "lp", "hm", "cf"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_va_+3A_x">x</code></td>
<td>
<p>Vector with VA entries</p>
</td></tr>
<tr><td><code id="which_va_+3A_quali">quali</code></td>
<td>
<p>strings for qualitative visual acuity entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector indicating guessed VA notation
</p>


<h3>See Also</h3>

<p>Other VA converter: 
<code><a href="#topic+VAwrapper">VAwrapper</a></code>,
<code><a href="#topic+plausibility_methods">plausibility_methods</a></code>,
<code><a href="#topic+snellen_steps">snellen_steps</a></code>,
<code><a href="#topic+va_methods">va_methods</a></code>,
<code><a href="#topic+va_mixed">va_mixed</a>()</code>,
<code><a href="#topic+va">va</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
