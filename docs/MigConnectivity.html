<!DOCTYPE html><html lang="en"><head><title>Help for package MigConnectivity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MigConnectivity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abundExamples'><p>Example relative abundance estimates from simulated data</p></a></li>
<li><a href='#calcMantel'><p>Calculate Mantel correlation (rM) from points and/or distances.</p></a></li>
<li><a href='#calcMC'><p>Migratory connectivity strength function</p></a></li>
<li><a href='#calcTransition'><p>Calculate psi (transition probabilities between sites in two phases of the</p>
annual cycle)</a></li>
<li><a href='#diffMantel'><p>Pairwise differences between two or more independent Mantel correlation</p>
estimates</a></li>
<li><a href='#diffMC'><p>Pairwise differences between two or more independent MC estimates</p></a></li>
<li><a href='#distFromPos'><p>Distance matrix from position matrix</p></a></li>
<li><a href='#estMantel'><p>Estimate Mantel correlation (rM) from geolocator, GPS, and/or raster data.</p></a></li>
<li><a href='#estMC'><p>Estimate migratory connectivity</p></a></li>
<li><a href='#estStrength'><p>Estimate MC, migratory connectivity strength</p></a></li>
<li><a href='#estTransition'><p>Estimate psi (transition probabilities between locations in two phases of</p>
the annual cycle)</a></li>
<li><a href='#getCMRexample'><p>Grab (from https://github.com/SMBC-NZP/MigConnectivity) example RMark</p>
transition probability estimates obtained from simulated data</a></li>
<li><a href='#getIsoMap'><p>Get Isoscape map</p>
getIsoMap</a></li>
<li><a href='#isoAssign'><p>Generate probabilistic isotope assignments</p></a></li>
<li><a href='#MigConnectivity'><p>MigConnectivity: A package for quantifying migratory connectivity pattern and</p>
strength for migratory animals</a></li>
<li><a href='#modelCountDataJAGS'><p>Estimates population-level relative abundance from count data</p></a></li>
<li><a href='#OVENdata'><p>Ovenbird light-level geolocator and GPS necessary data</p></a></li>
<li><a href='#plot.estMigConnectivity'><p>Basic plot function for estMigConnectivity objects</p></a></li>
<li><a href='#plot.intrinsicAssign'><p>Basic plot function for the different isoAssign outputs</p></a></li>
<li><a href='#projections'><p>Map projections</p></a></li>
<li><a href='#reverseTransition'><p>Reverse transition probabilities and origin relative abundance</p></a></li>
<li><a href='#sampleOriginN'><p>Example origin site abundances and relative abundances</p></a></li>
<li><a href='#sampleOriginPos'><p>Example origin and target site positions and distances on a 2-D plane</p></a></li>
<li><a href='#samplePsis'><p>Example transition probabilities (psis) between origin and target sites</p></a></li>
<li><a href='#simCMRData'><p>Simulate capture-mark-reencounter (CMR) migratory movement data</p></a></li>
<li><a href='#simCountData'><p>Simulates Breeding Bird Survey-style count data</p></a></li>
<li><a href='#simGLData'><p>Simulate geolocator (GL) migratory movement data</p></a></li>
<li><a href='#simMove'><p>Simulates position of birds by individual, season, year, and month.</p></a></li>
<li><a href='#simProbData'><p>Simulate Dirichlet-based probability table data</p></a></li>
<li><a href='#simTelemetryData'><p>Simulate telemetry/GPS data</p></a></li>
<li><a href='#weightAssign'><p>Calculate Weights for Isotope Assignments</p>
weightAssign</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate Migratory Connectivity for Migratory Animals</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-3-25</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows the user to estimate transition probabilities for
    migratory animals between any two phases of the annual cycle, using a
    variety of different data types. Also quantifies the strength of
    migratory connectivity (MC), a standardized metric to quantify the
    extent to which populations co-occur between two phases of the annual
    cycle. Includes functions to estimate MC and the more traditional
    metric of migratory connectivity strength (Mantel correlation)
    incorporating uncertainty from multiple sources of sampling error. For
    cross-species comparisons, methods are provided to estimate
    differences in migratory connectivity strength, incorporating
    uncertainty. See Cohen et al. (2018) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12916">doi:10.1111/2041-210X.12916</a>&gt;,
    Cohen et al. (2019) &lt;<a href="https://doi.org/10.1111%2Fecog.03974">doi:10.1111/ecog.03974</a>&gt;, and Roberts et al.
    (2023) &lt;<a href="https://doi.org/10.1002%2Feap.2788">doi:10.1002/eap.2788</a>&gt; for details on some of these methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SMBC-NZP/MigConnectivity">https://github.com/SMBC-NZP/MigConnectivity</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, geodist, gplots, graphics, grDevices, MASS, methods,
ncf, R2jags, RMark (&ge; 2.1.14), sf, shape, stats, terra, utils,
VGAM</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, maps, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS (https://mcmc-jags.sourceforge.net)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-25 20:56:58 UTC; jhostetler</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey A. Hostetler [cre, aut],
  Michael T. Hallworth [aut],
  Clark S. Rushing [ctb],
  Emily B. Cohen [ctb],
  Valentine Herrmann [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeffrey A. Hostetler &lt;jhostetler@usgs.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abundExamples'>Example relative abundance estimates from simulated data</h2><span id='topic+abundExamples'></span>

<h3>Description</h3>

<p>A dataset containing mcmc relative abundance estimates from simulated
BBS-type data from Cohen et al. (2018). Each estimate can
be used in <code>estStrength</code> function to estimate MC with uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abundExamples
</code></pre>


<h3>Format</h3>

<p>A list with 10 mcmc (coda) estimates in it.
</p>

<hr>
<h2 id='calcMantel'>Calculate Mantel correlation (rM) from points and/or distances.</h2><span id='topic+calcMantel'></span>

<h3>Description</h3>

<p>Calculation of rM from POINTS geolocators and/or GPS
data, not accounting for uncertainty. If you've already calculated
distances between points, you can use those instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcMantel(
  targetPoints = NULL,
  originPoints = NULL,
  targetDist = NULL,
  originDist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcMantel_+3A_targetpoints">targetPoints</code></td>
<td>
<p>A sf <code>POINTS</code> object, with length number of animals
tracked.  Each point indicates the point estimate location in the
non-release season.</p>
</td></tr>
<tr><td><code id="calcMantel_+3A_originpoints">originPoints</code></td>
<td>
<p>A sf <code>POINTS</code> object, with length number of animals
tracked.  Each point indicates the release location of an animal.</p>
</td></tr>
<tr><td><code id="calcMantel_+3A_targetdist">targetDist</code></td>
<td>
<p>Distances between the target locations of the tracked
animals.  Symmetric matrix with number of animals rows and columns,
although really you only need the lower triangle filled in.</p>
</td></tr>
<tr><td><code id="calcMantel_+3A_origindist">originDist</code></td>
<td>
<p>Distances between the origin locations of the tracked
animals.  Symmetric matrix with number of animals rows and columns,
although really you only need the lower triangle filled in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>calcMantel</code> returns a list with elements:
</p>

<dl>
<dt><code>pointCorr</code></dt><dd><p>Simple point estimate of Mantel correlation.</p>
</dd>
<dt><code>originDist, targetDist</code></dt><dd><p>Distances between each pair of
<code>originPoints</code> and each pair of <code>targetPoints</code>, respectively,
in meters. If you used distances as inputs instead, then these are just
what you fed in.</p>
</dd>
</dl>



<h3>References</h3>

<p>Ambrosini, R., A. P. Moller, and N. Saino. 2009. A quantitative measure of
migratory connectivity. Journal of Theoretical Biology 257:203-211.
<a href="https://doi.org/10.1016/j.jtbi.2008.11.019">doi:10.1016/j.jtbi.2008.11.019</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estMantel">estMantel</a></code>, <code><a href="#topic+calcMC">calcMC</a></code>, <code><a href="#topic+estMC">estMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(OVENdata) # Ovenbird
rM0 &lt;- calcMantel(originPoints = OVENdata$originPoints, # Capture Locations
                  targetPoints = OVENdata$targetPoints) # Target locations
str(rM0)
</code></pre>

<hr>
<h2 id='calcMC'>Migratory connectivity strength function</h2><span id='topic+calcMC'></span><span id='topic+calcStrength'></span>

<h3>Description</h3>

<p>Migratory connectivity strength function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcMC(originDist, targetDist, originRelAbund, psi, sampleSize = NULL)

calcStrength(originDist, targetDist, originRelAbund, psi, sampleSize = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcMC_+3A_origindist">originDist</code></td>
<td>
<p>Distances between the B origin sites.  Symmetric B by B
matrix.</p>
</td></tr>
<tr><td><code id="calcMC_+3A_targetdist">targetDist</code></td>
<td>
<p>Distances between the W target sites.  Symmetric W by W
matrix.</p>
</td></tr>
<tr><td><code id="calcMC_+3A_originrelabund">originRelAbund</code></td>
<td>
<p>Relative abundances at B origin sites. Numeric vector
of length B that sums to 1.</p>
</td></tr>
<tr><td><code id="calcMC_+3A_psi">psi</code></td>
<td>
<p>Transition probabilities between B origin and W target sites.
Matrix with B rows and W columns where rows sum to 1.</p>
</td></tr>
<tr><td><code id="calcMC_+3A_samplesize">sampleSize</code></td>
<td>
<p>Total sample size of animals that psi was calculated from.
Should be the number of animals released in one of the origin sites and
observed in one of the target sites.  Optional, but recommended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar real value, usually between 0 and 1 (can be negative),
indicating the strength of migratory connectivity.
</p>
<p>If <code>sampleSize</code> is provided, this function uses the standard (relative
abundance and small-sample size corrected) formula for MC.  If not, it uses
the MC(R) formula, which only corrects for relative abundance.
</p>


<h3>References</h3>

<p>Cohen, E. B., J. A. Hostetler, M. T. Hallworth, C. S. Rushing, T. S. Sillett,
and P. P. Marra. 2018. Quantifying the strength of migratory connectivity.
Methods in Ecology and Evolution 9: 513 - 524.
<a href="https://doi.org/10.1111/2041-210X.12916">doi:10.1111/2041-210X.12916</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with three breeding and three nonbreeding sites
nBreeding &lt;- 3
nNonBreeding &lt;- 3
psi &lt;- matrix(c(0.4, 0.35, 0.25,
                0.3, 0.4, 0.3,
                0.2, 0.3, 0.5), nBreeding, nNonBreeding, byrow = TRUE)
breedDist &lt;- matrix(c(0, 1, 2,
                      1, 0, 1,
                      2, 1, 0), nBreeding, nBreeding)
nonBreedDist &lt;- matrix(c(0, 5, 10,
                      5, 0, 5,
                      10, 5, 0), nNonBreeding, nNonBreeding)
relN &lt;- rep(1/nBreeding, nBreeding)
round(calcMC(breedDist, nonBreedDist, relN, psi), 3) # == 0.05

# Example with small sample size
sampleSize &lt;- 20 * nBreeding
round(calcMC(breedDist, nonBreedDist, relN, psi, sampleSize = sampleSize), 3) # == 0.026

###############################################################################
# Example data input values
###############################################################################

#########################
#Input values 1 of 3
# Eight transition probability scenarios
#########################
nScenarios1 &lt;- length(samplePsis)
MC1 &lt;- rep(NA, nScenarios1)
for (i in 1:nScenarios1) {
  MC1[i] &lt;- calcMC(sampleOriginDist[[1]], sampleTargetDist[[1]],
                   sampleOriginRelN[[1]], samplePsis[[i]])
}
names(MC1) &lt;- names(samplePsis)
round(MC1, 6)

#########################
#Input values 2 of 3
# 12 spatial arrangements that result in different distances between regions
# Distance scenarios
## A) Base distances, linear/ linear    1
## B) Distance between breeding sites 2 and 3 doubled
## C) Distance between breeding sites 2 and 3 halved
## D) Distance between breeding sites 3 and 4 doubled
## E) Distance between breeding sites 3 and 4 halved
## F) Breeding sites on square grid/ winter linear   6
## G) Distance between wintering sites 2 and 3 doubled
## H) Distance between wintering sites 2 and 3 halved
## I) Distance between wintering sites 3 and 4 doubled
## J) Distance between wintering sites 3 and 4 halved
## K) Breeding linear, Wintering sites on square grid
## L) Wintering and breeding on square grid  12
#########################

# Get MC strengths
nScenarios2 &lt;- length(sampleOriginPos)
MC2 &lt;- matrix(NA, nScenarios1, nScenarios2)
rownames(MC2) &lt;- names(samplePsis)
colnames(MC2) &lt;- names(sampleOriginPos)
for (i in 1:nScenarios1) {
  for (j in 1:nScenarios2) {
    MC2[i, j] &lt;- calcMC(sampleOriginDist[[j]], sampleTargetDist[[j]],
                        sampleOriginRelN[[1]], samplePsis[[i]])
  }
}

t(round(MC2, 4))

# Different way of comparing results
MC.diff2 &lt;- apply(MC2, 2, "-", MC2[ , 1])
t(round(MC.diff2, 4))

#########################
#Input values 3 of 3
# Changes to relative breeding abundance:
#   1. Base
#   2. Abundance at site B doubled
#   3. Abundance at site B halved
#   4. Abundance at site D doubled
#   5. Abundance at site D halved
# For all eight transition probability matrices and three distance scenarios
#########################

nScenarios3 &lt;- length(sampleOriginRelN)

# Get MC strengths for breeding linear/ winter linear arrangement
MC3 &lt;- matrix(NA, nScenarios1, nScenarios3)
rownames(MC3) &lt;- names(samplePsis)
colnames(MC3) &lt;- names(sampleOriginRelN)
for (i in 1:nScenarios1) {
  for (j in 1) {
    for (k in 1:nScenarios3) {
      MC3[i, k] &lt;- calcMC(sampleOriginDist[[j]], sampleTargetDist[[j]],
                          sampleOriginRelN[[k]], samplePsis[[i]])
    }
  }
}
t(round(MC3, 4)) # linear arrangement

# Get MC strengths for breeding grid/ winter grid arrangement
MC4 &lt;- matrix(NA, nScenarios1, nScenarios3)
rownames(MC4) &lt;- names(samplePsis)
colnames(MC4) &lt;- names(sampleOriginRelN)
for (i in 1:nScenarios1) {
  for (j in nScenarios2) {
    for (k in 1:nScenarios3) {
      MC4[i, k] &lt;- calcMC(sampleOriginDist[[j]], sampleTargetDist[[j]],
                          sampleOriginRelN[[k]], samplePsis[[i]])
    }
  }
}
t(round(MC4, 4)) # grid arrangement

# Get MC strengths for breeding grid, winter linear arrangement
MC5 &lt;- matrix(NA, nScenarios1, nScenarios3)
rownames(MC5) &lt;- names(samplePsis)
colnames(MC5) &lt;- names(sampleOriginRelN)
for (i in 1:nScenarios1) {
  for (j in 6) {
    for (k in 1:nScenarios3) {
      MC5[i, k] &lt;- calcMC(sampleOriginDist[[j]], sampleTargetDist[[j]],
                          sampleOriginRelN[[k]], samplePsis[[i]])
    }
  }
}
t(round(MC5, 4)) # breeding grid, winter linear arrangement

</code></pre>

<hr>
<h2 id='calcTransition'>Calculate psi (transition probabilities between sites in two phases of the
annual cycle)</h2><span id='topic+calcTransition'></span><span id='topic+calcPsi'></span>

<h3>Description</h3>

<p>Provides simple maximum-likelihood point estimate of transition probabilities
that does not include measures of uncertainty. Incorporates detection
heterogeneity where appropriate (band/ring return data), but not location
uncertainty. Shared primarily for testing; use of <code><a href="#topic+estTransition">estTransition</a></code>
is recommended instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcTransition(
  banded = NULL,
  reencountered = NULL,
  counts = NULL,
  originAssignment = NULL,
  targetAssignment = NULL,
  originNames = NULL,
  targetNames = NULL,
  method = "SANN"
)

calcPsi(
  banded = NULL,
  reencountered = NULL,
  counts = NULL,
  originAssignment = NULL,
  targetAssignment = NULL,
  originNames = NULL,
  targetNames = NULL,
  method = "SANN"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcTransition_+3A_banded">banded</code></td>
<td>
<p>For band return data, a vector of the number of released
animals from each origin site (including those never reencountered
in a target region)</p>
</td></tr>
<tr><td><code id="calcTransition_+3A_reencountered">reencountered</code></td>
<td>
<p>For band return data, a matrix with B rows and W
columns. Number of animals reencountered
on each target site by origin site they came from</p>
</td></tr>
<tr><td><code id="calcTransition_+3A_counts">counts</code></td>
<td>
<p>Migration data without target-region detection heterogeneity
(i.e., anything but band return data) can be entered one of two ways: either
here or with <code>originAssignment</code> and <code>targetAssignment</code>. If here, a
matrix with B rows and W columns with counts of animals observed in each
combination of origin and target site</p>
</td></tr>
<tr><td><code id="calcTransition_+3A_originassignment">originAssignment</code></td>
<td>
<p>Assignment of animals (not including band return
data) to origin season sites. A vector of integers (1-B) with length number
of animals tracked. Note that these data can either be entered using this
argument and <code>targetAssignment</code> or using <code>counts</code>, but not both</p>
</td></tr>
<tr><td><code id="calcTransition_+3A_targetassignment">targetAssignment</code></td>
<td>
<p>Assignment of animals (not including band return
data) to target season sites. A vector of integers (1-W) with length number
of animals tracked. Note that these data can either be entered using this
argument and <code>originAssignment</code> or using <code>counts</code>, but not both</p>
</td></tr>
<tr><td><code id="calcTransition_+3A_originnames">originNames</code></td>
<td>
<p>Optional, but recommended to keep track. Vector of names
for the origin sites. If not provided, the function will either try to get
these from another input or provide default names (capital letters)</p>
</td></tr>
<tr><td><code id="calcTransition_+3A_targetnames">targetNames</code></td>
<td>
<p>Optional, but recommended to keep track. Vector of names
for the target sites. If not provided, the function will either try to get
these from another input or provide default names (numbers)</p>
</td></tr>
<tr><td><code id="calcTransition_+3A_method">method</code></td>
<td>
<p>See <code>optim</code>. &quot;SANN&quot; is slow but reasonably accurate.
&quot;Nelder-Mead&quot; is fast but not accurate here. &quot;BFGS&quot; is also fast but not
very stable here</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>calcTransition</code> returns a list with the element(s):
</p>

<dl>
<dt><code>psi</code></dt><dd><p>Matrix with point estimate of transition probabilities</p>
</dd>
<dt><code>r</code></dt><dd><p>Vector containing point estimate of reencounter
probabilities at each target site. Not included unless data includes
band reencounters</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+estTransition">estTransition</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nOriginSites &lt;- 4
nTargetSites &lt;- 4
originNames &lt;- LETTERS[1:nOriginSites]
targetNames &lt;- 1:nTargetSites
psiTrue &lt;- array(c(0.1, 0.2, 0.3, 0.4,
                   0.2, 0.3, 0.4, 0.1,
                   0.3, 0.4, 0.1, 0.2,
                   0.4, 0.1, 0.2, 0.3),
                 c(nOriginSites, nTargetSites),
                 dimnames = list(originNames, targetNames))
rowSums(psiTrue)
rTrue &lt;- c(0.5, 0.05, 0.3, 0.6)
banded1 &lt;- c(500, 1000, 2000, 3000)
reencountered1 &lt;- simCMRData(psiTrue, banded1, rTrue)$reencountered
psi_r_calc_sloppy &lt;- calcTransition(banded = banded1,
                             reencountered = reencountered1,
                             originNames = originNames,
                             targetNames = targetNames,
                             method = "BFGS")
psi_r_calc_sloppy

psi_r_calc &lt;- calcTransition(banded = banded1,
                             reencountered = reencountered1,
                             originNames = originNames,
                             targetNames = targetNames,
                             method = "SANN")
psi_r_calc
psi_r_mcmc &lt;- estTransition(banded = banded1, reencountered = reencountered1,
                            originNames = originNames,
                            targetNames = targetNames,
                            method = "MCMC",
                            nSamples = 45000, nBurnin = 5000, #reduced for example speed
                            nThin = 1, verbose = 0)
print(psi_r_mcmc)
psi_r_boot &lt;- estTransition(banded = banded1, reencountered = reencountered1,
                            originNames = originNames,
                            targetNames = targetNames,
                            method = "bootstrap",
                            nSamples = 200) #reduced for example speed
print(psi_r_boot)

</code></pre>

<hr>
<h2 id='diffMantel'>Pairwise differences between two or more independent Mantel correlation
estimates</h2><span id='topic+diffMantel'></span><span id='topic+diffCorr'></span>

<h3>Description</h3>

<p>Estimates mean (and median) differences in Mantel correlations (rM), and
includes measures of uncertainty (SE and CI).  For those measures of
uncertainty to be accurate, only apply this function to rM estimates where
all data sources are independent (e.g., different species).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffMantel(estimates, nSamples = 1e+05, alpha = 0.05, returnSamples = FALSE)

diffCorr(estimates, nSamples = 1e+05, alpha = 0.05, returnSamples = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffMantel_+3A_estimates">estimates</code></td>
<td>
<p>List of at least two Mantel correlation estimates, provided
by either the estMC or the estMantel functions. If this is a named list
(recommended), the function will use these names in labeling the
differences.</p>
</td></tr>
<tr><td><code id="diffMantel_+3A_nsamples">nSamples</code></td>
<td>
<p>A positive integer, number of samples (with replacement)
to draw from each pair of MC estimates (default 100000).  If set to NULL,
compares all Mantel correlation samples from each pair.</p>
</td></tr>
<tr><td><code id="diffMantel_+3A_alpha">alpha</code></td>
<td>
<p>Level for confidence/credible intervals provided.</p>
</td></tr>
<tr><td><code id="diffMantel_+3A_returnsamples">returnSamples</code></td>
<td>
<p>Should the function return all the sampled differences?
Defaults to FALSE to reduce storage requirements. Change to TRUE to
compute your own summary statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>diffMantel</code> returns a list with elements:
</p>

<dl>
<dt><code>meanDiff, medianDiff</code></dt><dd><p>Vectors with mean and medians of sampled
differences for each pairwise comparison. Estimates of difference
between rM values incorporating parametric uncertainty.</p>
</dd>
<dt><code>seDiff</code></dt><dd><p>Vector with standard errors of rM differences for each
pairwise comparison, estimated from SD of sampled differences.</p>
</dd>
<dt><code>simpleCI</code></dt><dd><p>Matrix of <code>1 - alpha</code> confidence intervals for
rM differences, estimated as <code>alpha/2</code> and <code>1 - alpha/2</code>
quantiles of <code>sampleCorr</code>.</p>
</dd>
<dt><code>bcCI</code></dt><dd><p>Matrix of bias-corrected <code>1 - alpha</code> confidence
intervals for rM differences for each pairwise comparison. Preferable
to <code>simpleCI</code> when <code>meanDiff</code> is the best estimate of the rM
difference. <code>simpleCI</code> is preferred when
<code>medianDiff</code> is a better estimator. When <code>meanDiff==medianDiff</code>,
these should be identical.  Estimated as the
<code>pnorm(2 * z0 + qnorm(alpha / 2))</code> and
<code>pnorm(2 * z0 + qnorm(1 - alpha / 2))</code> quantiles of sampled
differences, where z0 is the proportion of <code>sampleDiff &lt; meanDiff</code>.</p>
</dd>
<dt><code>sampleDiff</code></dt><dd><p>Only provided if <code>returnSamples</code> is TRUE.
List of sampled values for each pairwise rM difference.</p>
</dd>
</dl>



<h3>References</h3>

<p>Cohen, E. B., C. S. Rushing, F. R. Moore, M. T. Hallworth, J. A. Hostetler,
M. Gutierrez Ramirez, and P. P. Marra. 2019. The strength of
migratory connectivity for birds en route to breeding through the Gulf of Mexico.
</p>

<hr>
<h2 id='diffMC'>Pairwise differences between two or more independent MC estimates</h2><span id='topic+diffMC'></span><span id='topic+diffStrength'></span>

<h3>Description</h3>

<p>Estimates mean (and median) differences in MC, and includes measures of
uncertainty (SE and CI).  For those measures of uncertainty to be accurate,
only apply this function to MC estimates where all data sources are
independent (e.g., different species).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffMC(estimates, nSamples = 1e+05, alpha = 0.05, returnSamples = FALSE)

diffStrength(estimates, nSamples = 1e+05, alpha = 0.05, returnSamples = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffMC_+3A_estimates">estimates</code></td>
<td>
<p>List of at least two MC estimates, provided by the estMC
function. If this is a named list (recommended), the function will use
these names in labeling the differences.</p>
</td></tr>
<tr><td><code id="diffMC_+3A_nsamples">nSamples</code></td>
<td>
<p>A positive integer, number of samples (with replacement)
to draw from each pair of MC estimates (default 100000).  If set to NULL,
compares all MC samples from each pair.</p>
</td></tr>
<tr><td><code id="diffMC_+3A_alpha">alpha</code></td>
<td>
<p>Level for confidence/credible intervals provided.</p>
</td></tr>
<tr><td><code id="diffMC_+3A_returnsamples">returnSamples</code></td>
<td>
<p>Should the function return all the sampled differences?
Defaults to FALSE to reduce storage requirements. Change to TRUE to
compute your own summary statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>diffMC</code> returns a list with elements:
</p>

<dl>
<dt><code>meanDiff, medianDiff</code></dt><dd><p>Vectors with mean and medians of sampled
differences for each pairwise comparison. Estimates of difference
between MC values incorporating parametric uncertainty.</p>
</dd>
<dt><code>seDiff</code></dt><dd><p>Vector with standard errors of MC differences for each
pairwise comparison, estimated from SD of sampled differences.</p>
</dd>
<dt><code>simpleCI</code></dt><dd><p>Matrix of <code>1 - alpha</code> confidence intervals for
MC differences, estimated as <code>alpha/2</code> and <code>1 - alpha/2</code>
quantiles of <code>sampleMC</code>.</p>
</dd>
<dt><code>bcCI</code></dt><dd><p>Matrix of bias-corrected <code>1 - alpha</code> confidence
intervals for MC differences for each pairwise comparison. Preferable
to <code>simpleCI</code> when <code>meanDiff</code> is the best estimate of the MC
difference. <code>simpleCI</code> is preferred when
<code>medianDiff</code> is a better estimator. When <code>meanDiff==medianDiff</code>,
these should be identical.  Estimated as the
<code>pnorm(2 * z0 + qnorm(alpha / 2))</code> and
<code>pnorm(2 * z0 + qnorm(1 - alpha / 2))</code> quantiles of sampled
differences, where z0 is the proportion of <code>sampleDiff &lt; meanDiff</code>.</p>
</dd>
<dt><code>sampleDiff</code></dt><dd><p>Only provided if <code>returnSamples</code> is TRUE.
List of sampled values for each pairwise MC difference.</p>
</dd>
</dl>



<h3>References</h3>

<p>Cohen, E. B., C. S. Rushing, F. R. Moore, M. T. Hallworth, J. A. Hostetler,
M. Gutierrez Ramirez, and P. P. Marra. 2019. The strength of
migratory connectivity for birds en route to breeding through the Gulf of Mexico.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('OVENdata')
ovenPsi &lt;- estTransition(isGL = OVENdata$isGL, #Logical vector:light-level GL(T)
                 isTelemetry = !OVENdata$isGL,
                 geoBias = OVENdata$geo.bias, # Light-level GL location bias
                 geoVCov = OVENdata$geo.vcov, # Location covariance matrix
                 targetSites = OVENdata$targetSites, # Non-breeding target sites
                 originSites = OVENdata$originSites, # Breeding origin sites
                 originPoints = OVENdata$originPoints, # Capture Locations
                 targetPoints = OVENdata$targetPoints, # Device target locations
                 verbose = 0,   # output options
                 nSamples = 100, # This is set low for example
                 resampleProjection = sf::st_crs(OVENdata$targetSites))
ovenEst &lt;- estStrength(targetDist = OVENdata$targetDist, # targetSites distance matrix
                 originDist = OVENdata$originDist, # originSites distance matrix
                 originRelAbund = OVENdata$originRelAbund,#Origin relative abund
                 psi = ovenPsi,
                 verbose = 1,   # output options
                 nSamples = 1000)
fm &lt;- getCMRexample()
originPos13 &lt;- matrix(c(rep(seq(-99, -81, 2), each = 10),
                        rep(seq(49, 31, -2), 10)), 100, 2)
targetPos13 &lt;- matrix(c(rep(seq(-79, -61, 2), each = 10),
                        rep(seq(9, -9, -2), 10)), 100, 2)
originPosCMR &lt;- rowsum(originPos13, c(rep(1:2, 5, each = 5),
                                      rep(3:4, 5, each = 5))) / 25
targetPosCMR &lt;- rowsum(targetPos13, c(rep(1:2, 5, each = 5),
                                      rep(3:4, 5, each = 5))) / 25
originDist &lt;- distFromPos(originPosCMR, 'ellipsoid')
targetDist &lt;- distFromPos(targetPosCMR, 'ellipsoid')
originRelAbundTrue &lt;- rep(0.25, 4)
theorEst &lt;- estStrength(originRelAbund = originRelAbundTrue, psi = fm,
                  originDist = originDist, targetDist = targetDist,
                  originSites = 5:8, targetSites = c(3,2,1,4),
                  nSamples = 1000, verbose = 0,
                  sampleSize = length(grep("[2-5]", fm$data$data$ch)))
ovenEst
theorEst
diff1 &lt;- diffMC(estimates = list(Ovenbird = ovenEst, Theorybird = theorEst),
                nSamples = 10000, returnSamples = TRUE)


</code></pre>

<hr>
<h2 id='distFromPos'>Distance matrix from position matrix</h2><span id='topic+distFromPos'></span>

<h3>Description</h3>

<p>Distance matrix from position matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distFromPos(
  pos,
  surface = "ellipsoid",
  units = c("km", "m", "miles", "nautical miles")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distFromPos_+3A_pos">pos</code></td>
<td>
<p>Number of sites by 2 matrix with positions of each site.  If
<code>surface</code> is 'ellipsoid' or 'sphere', then column 1 should be
longitude and column 2 should be latitude. If <code>surface</code> is 'plane',
column 1 can be x-position and column 2 y-position.</p>
</td></tr>
<tr><td><code id="distFromPos_+3A_surface">surface</code></td>
<td>
<p>Surface to calculate distances on.  Either 'ellipsoid'
(default), 'sphere', or 'plane'.</p>
</td></tr>
<tr><td><code id="distFromPos_+3A_units">units</code></td>
<td>
<p>Units of return distance matrix. If <code>surface</code> is 'plane',
then this argument is ignored and the return units will be the same as the
<code>pos</code> units. Options are 'km' (kilometers, default), 'm' (meters),
'miles', and 'nautical miles'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Square matrix of distances between sites. If <code>surface</code> is
'ellipsoid' or 'sphere', then argument <code>units</code> will determine units;
if <code>surface</code> is 'plane', the units will be the same as the <code>pos</code>
units.
</p>


<h3>Note</h3>

<p>In version 0.4.3 we switched package dependencies from <code>geosphere</code>
to <code>geodist</code>. As a result, spherical distances (and possibly
ellipsoid distances) may differ slightly from those calculated with earlier
versions of our package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nBreeding &lt;- 100
nWintering &lt;- 100
breedingPos &lt;- matrix(c(rep(seq(-99, -81, 2), each = sqrt(nBreeding)),
                        rep(seq(49, 31, -2), sqrt(nBreeding))),
                      nBreeding, 2)
winteringPos &lt;- matrix(c(rep(seq(-79, -61, 2), each = sqrt(nWintering)),
                         rep(seq(9, -9, -2), sqrt(nWintering))),
                       nWintering, 2)
head(breedingPos)
tail(breedingPos)
head(winteringPos)
tail(winteringPos)

breedDist &lt;- distFromPos(breedingPos, 'ellipsoid')
nonbreedDist &lt;- distFromPos(winteringPos, 'ellipsoid')
breedDist[1:12, 1:12]
breedDist[1:12, c(1,91,100)]
</code></pre>

<hr>
<h2 id='estMantel'>Estimate Mantel correlation (rM) from geolocator, GPS, and/or raster data.</h2><span id='topic+estMantel'></span><span id='topic+estCorr'></span>

<h3>Description</h3>

<p>Resampling of uncertainty for migratory connectivity strength, as quantified
by Mantel correlation (rM), from geolocators, GPS, and/or raster (e.g.,
genoscape or isotope) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estMantel(
  targetPoints = NULL,
  originPoints = NULL,
  isGL,
  geoBias = NULL,
  geoVCov = NULL,
  targetSites = NULL,
  nBoot = 1000,
  nSim = ifelse(any(isRaster &amp; isGL), 5000, ifelse(any(isGL), 1000, ifelse(any(isRaster),
    10, 1))),
  verbose = 0,
  alpha = 0.05,
  resampleProjection = "ESRI:102010",
  maxTries = 300,
  maintainLegacyOutput = FALSE,
  originSites = NULL,
  isTelemetry = !isGL,
  isRaster = FALSE,
  captured = "origin",
  geoBiasOrigin = geoBias,
  geoVCovOrigin = geoVCov,
  targetRaster = NULL,
  originRaster = NULL,
  dataOverlapSetting = c("dummy", "none", "named"),
  originRelAbund = NULL,
  targetRelAbund = NULL
)

estCorr(
  targetPoints = NULL,
  originPoints = NULL,
  isGL,
  geoBias = NULL,
  geoVCov = NULL,
  targetSites = NULL,
  nBoot = 1000,
  nSim = ifelse(any(isRaster &amp; isGL), 5000, ifelse(any(isGL), 1000, ifelse(any(isRaster),
    10, 1))),
  verbose = 0,
  alpha = 0.05,
  resampleProjection = "ESRI:102010",
  maxTries = 300,
  maintainLegacyOutput = FALSE,
  originSites = NULL,
  isTelemetry = !isGL,
  isRaster = FALSE,
  captured = "origin",
  geoBiasOrigin = geoBias,
  geoVCovOrigin = geoVCov,
  targetRaster = NULL,
  originRaster = NULL,
  dataOverlapSetting = c("dummy", "none", "named"),
  originRelAbund = NULL,
  targetRelAbund = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estMantel_+3A_targetpoints">targetPoints</code></td>
<td>
<p>A <code>POINTS</code> from sf
object, with length number of animals tracked.  Each point indicates the
point estimate location in the non-release season.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_originpoints">originPoints</code></td>
<td>
<p>A <code>POINTS</code> from sf
object, with length number of animals tracked.  Each point indicates the
release location of an animal.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_isgl">isGL</code></td>
<td>
<p>Indicates whether or which animals were tracked with geolocators
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE for animals in  <code>targetPoints</code>
with geolocators and FALSE for animals without.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_geobias">geoBias</code></td>
<td>
<p>For GL data, vector of length 2 indicating expected bias
in longitude and latitude of <code>targetPoints</code>, in
<code>resampleProjection</code> units (default meters).</p>
</td></tr>
<tr><td><code id="estMantel_+3A_geovcov">geoVCov</code></td>
<td>
<p>For GL data, 2x2 matrix with expected variance/covariance
in longitude and latitude of <code>targetPoints</code>, in
<code>resampleProjection</code> units (default meters).</p>
</td></tr>
<tr><td><code id="estMantel_+3A_targetsites">targetSites</code></td>
<td>
<p>A <code>SpatialPolygons</code>, <code>SpatialPolygonsDataFrame</code>,
or <code>POLYGONS</code> sf object indicating valid target location(s). Not
needed unless you want to mask out certain areas (e.g. water) and
<code>captured</code> is &quot;origin&quot; or you want to use a weighted bootstrap based on
<code>targetRelAbund</code> for animals captured on the target side.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_nboot">nBoot</code></td>
<td>
<p>Number of bootstrap runs. Animals are sampled with replacement
for each, to estimate sampling uncertainty.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_nsim">nSim</code></td>
<td>
<p>Tuning parameter for GL or raster data. Affects only the speed;
1000 seems to work well with our GL data.  Should be integer &gt; 0.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_verbose">verbose</code></td>
<td>
<p>0 (default) to 3. 0 prints no output during run. 1 prints
a line every 100 bootstraps.  2 prints a line every bootstrap.
3 also prints the number of draws (for tuning nSim only).</p>
</td></tr>
<tr><td><code id="estMantel_+3A_alpha">alpha</code></td>
<td>
<p>Level for confidence/credible intervals provided.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_resampleprojection">resampleProjection</code></td>
<td>
<p>Projection when sampling from geolocator
bias/error. This projection needs units = m. Default is Equidistant
Conic. The default setting preserves distances around latitude = 0 and
longitude = 0. Other projections may work well, depending on the location
of <code>targetPoints</code>.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_maxtries">maxTries</code></td>
<td>
<p>Maximum number of times to run a single GL bootstrap before
exiting with an error.  Default is 300.  Set to NULL to never stop.  This
parameter was added to prevent GL setups where some sample points never
land on target sites from running indefinitely.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_maintainlegacyoutput">maintainLegacyOutput</code></td>
<td>
<p>version 0.4.0 of <code>MigConnectivity</code>
updated the structure of the estimates. If you have legacy code that refers
to elements within a <code>estMigConnectivity</code> object, you can set this
to TRUE to also keep the old structure. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_originsites">originSites</code></td>
<td>
<p>A <code>SpatialPolygons</code>, <code>SpatialPolygonsDataFrame</code>,
or <code>POLYGONS</code> sf object indicating valid origin location(s). Not
needed unless you want to mask out certain areas (e.g. water) and
<code>captured</code> is &quot;target&quot; or you want to use a weighted bootstrap based on
<code>originRelAbund</code> for animals captured on the origin side.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_istelemetry">isTelemetry</code></td>
<td>
<p>Indicates whether or which animals were tracked with
telemetry/GPS (no location uncertainty on either end).
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE or FALSE for each animal in data.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_israster">isRaster</code></td>
<td>
<p>Indicates whether or which animals were tracked with
intrinsic markers (e.g., genetics or isotopes), with location uncertainty
expressed as a raster of probabilities by grid cells, either in
<code>targetRaster</code> or <code>originRaster</code>. Should be either single TRUE or
FALSE value, or vector with length of number of animals tracked, with TRUE
or FALSE for each animal in data.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_captured">captured</code></td>
<td>
<p>Indicates whether or which animals were captured in the
origin sites, the target sites, or neither (another phase of the annual
cycle). Location uncertainty will only be applied where the animal was not
captured. So this doesn't matter for telemetry data. Should be either single
&quot;origin&quot; (default), &quot;target&quot;, or &quot;neither&quot; value, or a character vector with
length of number of animals tracked, with &quot;origin&quot;, &quot;target&quot;, or &quot;neither&quot;
for each animal.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_geobiasorigin">geoBiasOrigin</code></td>
<td>
<p>For GL data where <code>captured</code>!=&quot;origin&quot;, vector of
length 2 indicating expected bias in longitude and latitude of
<code>originPoints</code>, in <code>resampleProjection</code> units (default meters).</p>
</td></tr>
<tr><td><code id="estMantel_+3A_geovcovorigin">geoVCovOrigin</code></td>
<td>
<p>For GL data where <code>captured</code>!=&quot;origin&quot;, 2x2 matrix
with expected variance/covariance in longitude and latitude of
<code>targetPoints</code>, in <code>resampleProjection</code> units (default meters).</p>
</td></tr>
<tr><td><code id="estMantel_+3A_targetraster">targetRaster</code></td>
<td>
<p>For intrinsic tracking data, the results of
<code>isoAssign</code> or a similar function of class <code>intrinsicAssign</code> or
class <code>RasterBrick</code>/<code>RasterStack</code>, for example from the package
<code>assignR</code>. In any case, it expresses location uncertainty on target
range, through a raster of probabilities by grid cells.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_originraster">originRaster</code></td>
<td>
<p>For intrinsic tracking data, the results of
<code>isoAssign</code> or a similar function of class <code>intrinsicAssign</code> or
class <code>RasterBrick</code>/<code>RasterStack</code>, for example from the package
<code>assignR</code>. In any case, it expresses location uncertainty on origin
range, through a raster of probabilities by grid cells.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_dataoverlapsetting">dataOverlapSetting</code></td>
<td>
<p>When there is more than one type of data, this
setting allows the user some flexibility for clarifying which type(s) of
data apply to which animals. Setting &quot;dummy&quot; (the default) indicates that
there are dummy values within each dataset for the animals that isGL,
isTelemetry, etc. don't have that data type (FALSE values). If no animals
have a data type, no dummy values are required. If no animals have more than
one type of data, the user can simplify processing their data by choosing
setting &quot;none&quot; here. In this case, there should be no dummy values, and only
the animals with a type of data should be included in that dataset. The
third setting (&quot;named&quot;) is not yet implemented, but will eventually allow
another way to allow animals with more than one type of data with named
animals linking records. When there is only one type of data, it is fastest
to leave this on the default.</p>
</td></tr>
<tr><td><code id="estMantel_+3A_originrelabund">originRelAbund</code></td>
<td>
<p>the proportion of the total abundance in each of B
<code>originSites</code>. Used to set up the bootstrap to be weighted by relative
abundance (for animals captured on the origin side). Either a numeric vector
of length B that sums to 1, or an mcmc object (such as is produced by
<code><a href="#topic+modelCountDataJAGS">modelCountDataJAGS</a></code>) or matrix with at least B columns.
If there are more than B columns, the relevant columns should be
labeled &quot;relN[1]&quot; through &quot;relN[B]&quot;. Optional, but if you don't set it and
at least some animals are captured on the origin side, there's potential for
rM to be biased (if sampling isn't proportional to abundance).</p>
</td></tr>
<tr><td><code id="estMantel_+3A_targetrelabund">targetRelAbund</code></td>
<td>
<p>the proportion of the total abundance in each of W
<code>targetSites</code>. Used to set up the bootstrap to be weighted by relative
abundance (for animals captured on the target side). Either a numeric vector
of length W that sums to 1, or an mcmc object (such as is produced by
<code><a href="#topic+modelCountDataJAGS">modelCountDataJAGS</a></code>) or matrix with at least W columns.
If there are more than W columns, the relevant columns should be
labeled &quot;relN[1]&quot; through &quot;relN[W]&quot;. Optional, but if you don't set it and
at least some animals are captured on the target side, there's potential for
rM to be biased (if sampling isn't proportional to abundance).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>estMantel</code> returns a list with elements:
</p>

<dl>
<dt><code>corr</code></dt><dd><p>List containing estimates of rM:
</p>

<ul>
<li><p><code>sample</code> <code>nBoot</code> sampled values for Mantel
correlation. Provided to allow the user to compute own summary
statistics.
</p>
</li>
<li><p><code>mean, se, simpleCI, bcCI, median, point</code> Summary
statistics for Mantel correlation bootstraps.
</p>
</li></ul>

</dd>
<dt><code>input</code></dt><dd><p>List containing the inputs to <code>estMantel</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Cohen, E. B., J. A. Hostetler, M. T. Hallworth, C. S. Rushing, T. S. Sillett,
and P. P. Marra. 2018. Quantifying the strength of migratory connectivity.
Methods in Ecology and Evolution 9: 513 - 524.
<a href="https://doi.org/10.1111/2041-210X.12916">doi:10.1111/2041-210X.12916</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estMC">estMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('OVENdata')
rM1 &lt;- estMantel(isGL=OVENdata$isGL,#Logical vector: light-level GL(T)/GPS(F)
                 geoBias = OVENdata$geo.bias, # Geolocator location bias
                 geoVCov = OVENdata$geo.vcov, # Location covariance matrix
                 targetSites = OVENdata$targetSites,#Nonbreeding/target sites
                 originPoints = OVENdata$originPoints, # Capture Locations
                 targetPoints = OVENdata$targetPoints, # Target locations
                 verbose = 1,   # output options
                 nBoot = 10, # This is set low for example
                 resampleProjection = sf::st_crs(OVENdata$targetSites))
rM1
str(rM1, max.level = 2)

</code></pre>

<hr>
<h2 id='estMC'>Estimate migratory connectivity</h2><span id='topic+estMC'></span>

<h3>Description</h3>

<p>Resampling of uncertainty for migratory connectivity strength (MC)
and transition probabilities (psi) from RMark psi matrix estimates or
samples of psi and/or JAGS
relative abundance MCMC samples OR SpatialPoints geolocators and/or GPS
data OR intrinsic markers such as isotopes. NOTE: active development of this
function is ending. We suggest users estimate psi with
<code><a href="#topic+estTransition">estTransition</a></code>, MC with <code><a href="#topic+estStrength">estStrength</a></code>, and Mantel
correlations (rM) with <code><a href="#topic+estMantel">estMantel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estMC(
  originDist,
  targetDist = NULL,
  originRelAbund,
  psi = NULL,
  sampleSize = NULL,
  originSites = NULL,
  targetSites = NULL,
  originPoints = NULL,
  targetPoints = NULL,
  originAssignment = NULL,
  targetAssignment = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  nSim = ifelse(isTRUE(isIntrinsic), 10, 1000),
  isGL = FALSE,
  geoBias = NULL,
  geoVCov = NULL,
  row0 = 0,
  verbose = 0,
  calcCorr = FALSE,
  alpha = 0.05,
  approxSigTest = FALSE,
  sigConst = 0,
  resampleProjection = "ESRI:102010",
  maxTries = 300,
  targetIntrinsic = NULL,
  isIntrinsic = FALSE,
  maintainLegacyOutput = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estMC_+3A_origindist">originDist</code></td>
<td>
<p>Distances between the B origin sites.  Symmetric B by B
matrix</p>
</td></tr>
<tr><td><code id="estMC_+3A_targetdist">targetDist</code></td>
<td>
<p>Distances between the W target sites.  Symmetric W by W
matrix.  Optional for intrinsic data</p>
</td></tr>
<tr><td><code id="estMC_+3A_originrelabund">originRelAbund</code></td>
<td>
<p>Relative abundance estimates at B origin sites. Either
a numeric vector of length B that sums to 1 or an mcmc object with
<code>nSamples</code> rows  and columns including 'relN[1]' through 'relN[B]'.
Currently, an mcmc object doesn't work with geolocator, GPS, or intrinsic
data</p>
</td></tr>
<tr><td><code id="estMC_+3A_psi">psi</code></td>
<td>
<p>Transition probabilities between B origin and W target sites.
Either a matrix with B rows and W columns where rows sum to 1, an array with
dimensions x, B, and W (with x samples of the transition probability matrix
from another model), or a MARK object with estimates of transition
probabilities.  If you are estimating MC from GPS, geolocator, or intrinsic
data, leave this as NULL</p>
</td></tr>
<tr><td><code id="estMC_+3A_samplesize">sampleSize</code></td>
<td>
<p>Total sample size of animals that psi will be estimated
from. Should be the number of animals released in one of the origin sites
and observed in one of the target sites.  Optional, but recommended, unless
you are estimating MC from GPS, geolocator, intrinsic, or direct band return
data (in which case the function can calculate it for you)</p>
</td></tr>
<tr><td><code id="estMC_+3A_originsites">originSites</code></td>
<td>
<p>If <code>psi</code> is a MARK object, this must be a numeric
vector indicating which sites are origin.  If using GPS, geolocator, or
intrinsic data, this can be the geographic definition of sites in the
release season</p>
</td></tr>
<tr><td><code id="estMC_+3A_targetsites">targetSites</code></td>
<td>
<p>If <code>psi</code> is a MARK object, this must be a numeric
vector indicating which sites are target.  If using GPS, geolocator, or
intrinsic data, this must be the geographic definition of sites in the
non-release season.  Optional for intrinsic data; if left out, the function
will use the <code>targetSites</code> defined in <code>targetIntrinsic</code></p>
</td></tr>
<tr><td><code id="estMC_+3A_originpoints">originPoints</code></td>
<td>
<p>A <code>POINT</code> sf object, with length number of
animals tracked.  Each point indicates the release location of an animal</p>
</td></tr>
<tr><td><code id="estMC_+3A_targetpoints">targetPoints</code></td>
<td>
<p>For GL or GPS data, a <code>POINT</code> sf object, with
length number of animals tracked.  Each point indicates the point estimate
location in the non-release season</p>
</td></tr>
<tr><td><code id="estMC_+3A_originassignment">originAssignment</code></td>
<td>
<p>Assignment of <code>originPoints</code> to release season
sites. Integer vector with length number of animals tracked. Optional,
but if using GL or GPS data, either <code>originAssignment</code> or
<code>originSites</code> and <code>originPoints</code> should be defined</p>
</td></tr>
<tr><td><code id="estMC_+3A_targetassignment">targetAssignment</code></td>
<td>
<p>Optional. Point estimate assignment of
<code>targetPoints</code> to non-release season sites. Integer vector with
length number of animals tracked</p>
</td></tr>
<tr><td><code id="estMC_+3A_originnames">originNames</code></td>
<td>
<p>Optional but recommended. Vector of names for the release season sites</p>
</td></tr>
<tr><td><code id="estMC_+3A_targetnames">targetNames</code></td>
<td>
<p>Optional but recommended. Vector of names for the non-release season
sites</p>
</td></tr>
<tr><td><code id="estMC_+3A_nsamples">nSamples</code></td>
<td>
<p>Number of times to resample <code>psi</code> and/or
<code>originRelAbund</code> OR number of post-burn-in MCMC samples to store (band
data) OR number of times to resample <code>targetPoints</code>
for intrinsic data OR number of bootstrap runs for GL or GPS data. In
the last two cases, animals are sampled with replacement for each. For all,
the purpose is to estimate sampling uncertainty</p>
</td></tr>
<tr><td><code id="estMC_+3A_nsim">nSim</code></td>
<td>
<p>Tuning parameter for GL or intrinsic data. Affects only the
speed; 1000 seems to work well with our GL data and 10 for our intrinsic
data, but your results may vary.  Should be integer &gt; 0</p>
</td></tr>
<tr><td><code id="estMC_+3A_isgl">isGL</code></td>
<td>
<p>Indicates whether or which animals were tracked with geolocators.
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE for animals in
<code>targetPoints</code> with geolocators and FALSE for animals with GPS</p>
</td></tr>
<tr><td><code id="estMC_+3A_geobias">geoBias</code></td>
<td>
<p>For GL data, vector of length 2 indicating expected bias
in longitude and latitude of <code>targetPoints</code>, in
<code>resampleProjection</code> units (default meters)</p>
</td></tr>
<tr><td><code id="estMC_+3A_geovcov">geoVCov</code></td>
<td>
<p>For GL data, 2x2 matrix with expected variance/covariance
in longitude and latitude of <code>targetPoints</code>, in
<code>resampleProjection</code> units (default meters)</p>
</td></tr>
<tr><td><code id="estMC_+3A_row0">row0</code></td>
<td>
<p>If <code>originRelAbund</code> is an mcmc object, this can be set
to 0 (default) or any greater integer to specify where to stop ignoring
samples (&quot;burn-in&quot;)</p>
</td></tr>
<tr><td><code id="estMC_+3A_verbose">verbose</code></td>
<td>
<p>0 (default) to 3. 0 prints no output during run. 1 prints
a line every 100 samples or bootstraps and a summary every 10.  2 prints a
line and summary every sample or bootstrap. 3 also prints the number of
draws (for tuning nSim for GL/intrinsic data only)</p>
</td></tr>
<tr><td><code id="estMC_+3A_calccorr">calcCorr</code></td>
<td>
<p>In addition to MC, should function also estimate Mantel
correlation between release and non-release locations (GPS or GL data
only)?  Default is FALSE</p>
</td></tr>
<tr><td><code id="estMC_+3A_alpha">alpha</code></td>
<td>
<p>Level for confidence/credible intervals provided</p>
</td></tr>
<tr><td><code id="estMC_+3A_approxsigtest">approxSigTest</code></td>
<td>
<p>Should function compute approximate one-sided
significance tests (p-values) for MC from the bootstrap?  Default is
FALSE</p>
</td></tr>
<tr><td><code id="estMC_+3A_sigconst">sigConst</code></td>
<td>
<p>Value to compare MC to in significance test.
Default is 0</p>
</td></tr>
<tr><td><code id="estMC_+3A_resampleprojection">resampleProjection</code></td>
<td>
<p>Projection when sampling from geolocator
bias/error. This projection needs units = m. Default is Equidistant
Conic. The default setting preserves distances around latitude = 0 and
longitude = 0. Other projections may work well, depending on the location
of <code>targetSites</code>.  Ignored unless data are geolocator or GPS</p>
</td></tr>
<tr><td><code id="estMC_+3A_maxtries">maxTries</code></td>
<td>
<p>Maximum number of times to run a single GL/intrinsic
bootstrap before exiting with an error.  Default is 300.  Set to NULL to
never stop.  This parameter was added to prevent GL setups where some
sample points never land on target sites from running indefinitely</p>
</td></tr>
<tr><td><code id="estMC_+3A_targetintrinsic">targetIntrinsic</code></td>
<td>
<p>For intrinsic tracking data, the results of
<code>isoAssign</code> or a similar function, of class <code>intrinsicAssign</code></p>
</td></tr>
<tr><td><code id="estMC_+3A_isintrinsic">isIntrinsic</code></td>
<td>
<p>Logical indicating whether the animals are tracked via
intrinsic marker (e.g. isotopes) or not.  Currently estMC will only estimate
connectivity for all intrinsically marked animals or all extrinsic (e.g.,
bands, GL, or GPS), so isIntrinsic should be a single TRUE or FALSE</p>
</td></tr>
<tr><td><code id="estMC_+3A_maintainlegacyoutput">maintainLegacyOutput</code></td>
<td>
<p>version 0.4.0 of <code>MigConnectivity</code>
updated the structure of the estimates. If you have legacy code that refers
to elements within a <code>estMigConnectivity</code> object, you can set this
to TRUE to also keep the old structure. Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NOTE: Starting with version 0.4.0 of <code>MigConnectivity</code>, we've
updated the structure of <code>MigConnectivityEstimate</code> objects. Below we
describe the updated structure. If parameter <code>maintainLegacyOutput</code> is
set to TRUE, the list will start with the old structure: <code>sampleMC</code>,
<code>samplePsi</code>, <code>pointPsi</code>, <code>pointMC</code>, <code>meanMC</code>,
<code>medianMC</code>, <code>seMC</code>, <code>simpleCI</code>, <code>bcCI</code>, <code>hpdCI</code>,
<code>simpleP</code>, <code>bcP</code>, <code>sampleCorr</code>, <code>pointCorr</code>,
<code>meanCorr, medianCorr, seCorr, simpleCICorr, bcCICorr</code>,
<code>inputSampleSize</code>, <code>alpha</code>, and <code>sigConst</code>.
</p>
<p><code>estMC</code> returns a list with the elements:
</p>

<dl>
<dt><code>psi</code></dt><dd><p>List containing estimates of transition probabilities:
</p>

<ul>
<li><p><code>sample</code> Array of sampled values for psi. <code>nSamples</code> x
[number of origin sites] x [number of target sites]. Provided to allow
the user to compute own summary statistics.
</p>
</li>
<li><p><code>mean</code> Main estimate of psi matrix. [number of origin sites]
x [number of target sites].
</p>
</li>
<li><p><code>se</code> Standard error of psi, estimated from SD of
<code>psi$sample</code>.
</p>
</li>
<li><p><code>simpleCI</code> <code>1 - alpha</code> confidence interval for psi,
estimated as <code>alpha/2</code> and <code>1 - alpha/2</code> quantiles of
<code>psi$sample</code>.
</p>
</li>
<li><p><code>bcCI</code> Bias-corrected <code>1 - alpha</code> confidence interval
for psi.  Preferable to <code>simpleCI</code> when <code>mean</code> is the
best estimate of psi. <code>simpleCI</code> is preferred when
<code>median</code> is a better estimator. When <code>meanMC==medianMC</code>,
these should be identical.  Estimated as the
<code>pnorm(2 * z0 + qnorm(alpha / 2))</code> and
<code>pnorm(2 * z0 + qnorm(1 - alpha / 2))</code> quantiles of <code>sample</code>,
where z0 is the proportion of <code>sample &lt; mean</code>.
</p>
</li>
<li><p><code>median</code> Median estimate of psi matrix.
</p>
</li>
<li><p><code>point</code> Simple point estimate of psi matrix, not accounting
for sampling error. NULL when <code>isIntrinsic == TRUE</code>.
</p>
</li></ul>

</dd>
<dt><code>MC</code></dt><dd><p>List containing estimates of migratory connectivity
strength:
</p>

<ul>
<li><p><code>sample</code> <code>nSamples</code> sampled values for
MC. Provided to allow the user to compute own summary statistics.
</p>
</li>
<li><p><code>mean</code> Mean of <code>MC$sample</code>. Main estimate of MC,
incorporating parametric uncertainty.
</p>
</li>
<li><p><code>se</code> Standard error of MC, estimated from SD of
<code>MC$sample</code>.
</p>
</li>
<li><p><code>simpleCI</code> Default<code>1 - alpha</code> confidence interval for
MC, estimated as <code>alpha/2</code> and <code>1 - alpha/2</code> quantiles of
<code>MC$sample</code>.
</p>
</li>
<li><p><code>bcCI</code> Bias-corrected <code>1 - alpha</code> confidence interval
for MC.  Preferable to <code>MC$simpleCI</code> when <code>MC$mean</code> is the
best estimate of MC. <code>MC$simpleCI</code> is preferred when
<code>MC$median</code> is a better estimator. When <code>MC$mean==MC$median</code>,
these should be identical.  Estimated as the
<code>pnorm(2 * z0 + qnorm(alpha / 2))</code> and
<code>pnorm(2 * z0 + qnorm(1 - alpha / 2))</code> quantiles of <code>MC$sample</code>,
where z0 is the proportion of <code>MC$sample &lt; MC$mean</code>.
</p>
</li>
<li><p><code>hpdCI</code> <code>1 - alpha</code> credible interval for MC,
estimated using the highest posterior density (HPD) method.
</p>
</li>
<li><p><code>median</code> Median of MC, alternate estimator also including
parametric uncertainty.
</p>
</li>
<li><p><code>point</code> Simple point estimate of MC, using the point
estimates of <code>psi</code> and <code>originRelAbund</code>, not accounting
for sampling error. NULL when <code>isIntrinsic == TRUE</code>.
</p>
</li>
<li><p><code>simpleP</code> Approximate p-value for MC, estimated as the
proportion of bootstrap iterations where MC &lt; <code>sigConst</code> (or MC &gt;
<code>sigConst</code> if <code>pointMC &lt; sigConst</code>).  Note that if the
proportion is 0, a default value of 0.5 / <code>nSamples</code> is provided,
but this is best interpreted as p &lt; 1 / <code>nSamples</code>.  NULL when
<code>approxSigTest==FALSE</code>.
</p>
</li>
<li><p><code>bcP</code> Approximate bias-corrected p-value for MC, estimated as
<code>pnorm(qnorm(simpleP) - 2 * z0)</code>, where z0 is the proportion of
<code>sampleMC &lt; meanMC</code>.  May be a better approximation of the p-value
than <code>simpleP</code>, but many of the same limitations apply.  NULL when
<code>approxSigTest==FALSE</code>.
</p>
</li></ul>

</dd>
<dt><code>corr</code></dt><dd><p>List containing estimates of rM, an alternate measure of
migratory connectivity strength. NULL when <code>calcCorr==FALSE</code> or
<code>!is.null(psi)</code>:
</p>

<ul>
<li><p><code>sample</code> <code>nBoot</code> sampled values for continuous
correlation. Provided to allow the user to compute own summary
statistics.
</p>
</li>
<li><p><code>mean, se, simpleCI, bcCI, median, point</code> Summary
statistics for continuous correlation bootstraps.
</p>
</li></ul>

</dd>
<dt><code>input</code></dt><dd><p>List containing the inputs to <code>estMC</code>, or at least
the relevant ones, such as sampleSize.</p>
</dd>
</dl>



<h3>References</h3>

<p>Cohen, E. B., J. A. Hostetler, M. T. Hallworth, C. S. Rushing, T. S. Sillett,
and P. P. Marra. 2018. Quantifying the strength of migratory connectivity.
Methods in Ecology and Evolution 9: 513 - 524.
<a href="https://doi.org/10.1111/2041-210X.12916">doi:10.1111/2041-210X.12916</a>
</p>
<p>Cohen, E. B., C. S. Rushing, F. R. Moore, M. T. Hallworth, J. A. Hostetler,
M. Gutierrez Ramirez, and P. P. Marra. 2019. The strength of
migratory connectivity for birds en route to breeding through the Gulf of
Mexico. Ecography 42: 658–669.
<a href="https://doi.org/10.1111/ecog.03974">doi:10.1111/ecog.03974</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estStrength">estStrength</a></code>, <code><a href="#topic+estTransition">estTransition</a></code>,
<code><a href="#topic+estMantel">estMantel</a></code>, <code><a href="#topic+calcMC">calcMC</a></code>, <code><a href="#topic+projections">projections</a></code>,
<code><a href="#topic+isoAssign">isoAssign</a></code>, <code><a href="#topic+plot.estMigConnectivity">plot.estMigConnectivity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  set.seed(101)
  # Uncertainty in detection ('RMark' estimates) with equal abundances
  # Number of resampling iterations for generating confidence intervals

  nSamplesCMR &lt;- 100
  nSimulationsCMR &lt;- 10
  originPos13 &lt;- matrix(c(rep(seq(-99, -81, 2), each = 10),
                          rep(seq(49, 31, -2), 10)), 100, 2)
  targetPos13 &lt;- matrix(c(rep(seq(-79, -61, 2), each = 10),
                          rep(seq(9, -9, -2), 10)), 100, 2)
  originPosCMR &lt;- rowsum(originPos13, c(rep(1:2, 5, each = 5),
                                        rep(3:4, 5, each = 5))) / 25
  originPosCMR
  targetPosCMR &lt;- rowsum(targetPos13, c(rep(1:2, 5, each = 5),
                                        rep(3:4, 5, each = 5))) / 25
  targetPosCMR

  originDist &lt;- distFromPos(originPosCMR, 'ellipsoid')
  targetDist &lt;- distFromPos(targetPosCMR, 'ellipsoid')
  originRelAbundTrue &lt;- rep(0.25, 4)
  # the second intermediate psi scenario, the "low" level
  psiTrue &lt;- samplePsis[["Low"]]
  trueMC &lt;- calcMC(originDist, targetDist, originRelAbundTrue, psiTrue)
  trueMC

  # Storage matrix for samples
  cmrMCSample &lt;- matrix(NA, nSamplesCMR, nSimulationsCMR)
  summaryCMR &lt;- data.frame(Simulation = 1:nSimulationsCMR, True=trueMC,
                           mean=NA, se=NA, lcl=NA, ucl=NA)
  # Get RMark psi estimates and estimate MC from each
  for (r in 1:nSimulationsCMR) {
    cat("Simulation",r,"of",nSimulationsCMR,"\n")
    # Note: getCMRexample() requires a valid internet connection and that GitHub
    # is accessible
    fm &lt;- getCMRexample(r)
    results &lt;- estMC(originRelAbund = originRelAbundTrue, psi = fm,
                     originDist = originDist, targetDist = targetDist,
                     originSites = 5:8, targetSites = c(3,2,1,4),
                     nSamples = nSamplesCMR, verbose = 0,
                     sampleSize = length(grep('[2-5]', fm$data$data$ch)))
    #sampleSize argument not really needed (big sample sizes)
    cmrMCSample[ , r] &lt;- results$MC$sample
    summaryCMR$mean[r] &lt;- results$MC$mean
    summaryCMR$se[r] &lt;- results$MC$se
    # Calculate confidence intervals using quantiles of sampled MC
    summaryCMR[r, c('lcl', 'ucl')] &lt;- results$MC$simpleCI
  }

  summaryCMR &lt;- transform(summaryCMR, coverage = (True&gt;=lcl &amp; True&lt;=ucl))
  summaryCMR
  summary(summaryCMR)
  biasCMR &lt;- mean(summaryCMR$mean) - trueMC
  biasCMR
  mseCMR &lt;- mean((summaryCMR$mean - trueMC)^2)
  mseCMR
  rmseCMR &lt;- sqrt(mseCMR)
  rmseCMR


  # Simulation of BBS data to quantify uncertainty in relative abundance

  nSamplesAbund &lt;- 700 #1700 are stored
  nSimulationsAbund &lt;- 10
  # Storage matrix for samples
  abundMCSample &lt;- matrix(NA, nSamplesAbund, nSimulationsAbund)
  summaryAbund &lt;- data.frame(Simulation = 1:nSimulationsAbund, True = trueMC,
                             mean = NA, se = NA, lcl = NA, ucl = NA)
  for (r in 1:nSimulationsAbund) {
    cat("Simulation",r,"of",nSimulationsAbund,"\n")
    row0 &lt;- nrow(abundExamples[[r]]) - nSamplesAbund
    results &lt;- estMC(originRelAbund = abundExamples[[r]], psi = psiTrue,
                     originDist = originDist, targetDist = targetDist,
                     row0 = row0, nSamples = nSamplesAbund, verbose = 1)
    abundMCSample[ , r] &lt;- results$MC$sample
    summaryAbund$mean[r] &lt;- results$MC$mean
    summaryAbund$se[r] &lt;- results$MC$se
    # Calculate confidence intervals using quantiles of sampled MC
    summaryAbund[r, c('lcl', 'ucl')] &lt;- results$MC$simpleCI
  }

  summaryAbund &lt;- transform(summaryAbund,
                            coverage = (True &gt;= lcl &amp; True &lt;= ucl))
  summaryAbund
  summary(summaryAbund)
  biasAbund &lt;- mean(summaryAbund$mean) - trueMC
  biasAbund
  mseAbund &lt;- mean((summaryAbund$mean - trueMC)^2)
  mseAbund
  rmseAbund &lt;- sqrt(mseAbund)
  rmseAbund

  # Ovenbird example with GL and GPS data
  data(OVENdata) # Ovenbird

  nSamplesGLGPS &lt;- 100 # Number of bootstrap iterations

  # Estimate MC only, treat all data as geolocator
  GL_mc&lt;-estMC(isGL=TRUE, # Logical vector: light-level geolocator(T)/GPS(F)
               geoBias = OVENdata$geo.bias, #Geolocator location bias
               geoVCov = OVENdata$geo.vcov, # Location covariance matrix
               targetDist = OVENdata$targetDist, # targetSites distance matrix
               originDist = OVENdata$originDist, # originSites distance matrix
               targetSites = OVENdata$targetSites, # Non-breeding target sites
               originSites = OVENdata$originSites, # Breeding origin sites
               originPoints = OVENdata$originPoints, # Capture Locations
               targetPoints = OVENdata$targetPoints, # Device target locations
               originRelAbund = OVENdata$originRelAbund,#Origin relative abund.
               verbose = 1,   # output options
               nSamples = nSamplesGLGPS,# This is set low for example
               resampleProjection = terra::crs(OVENdata$targetSites))

  # Estimate MC and rM, treat all data as is
  Combined&lt;-estMC(isGL=OVENdata$isGL, #Logical vector:light-level GL(T)/GPS(F)
                  geoBias = OVENdata$geo.bias, # Light-level GL location bias
                  geoVCov = OVENdata$geo.vcov, # Location covariance matrix
                  targetDist = OVENdata$targetDist, # Winter distance matrix
                  originDist = OVENdata$originDist, # Breeding distance matrix
                  targetSites = OVENdata$targetSites, # Nonbreeding/target sites
                  originSites = OVENdata$originSites, # Breeding origin sites
                  originPoints = OVENdata$originPoints, # Capture Locations
                  targetPoints = OVENdata$targetPoints, #Device target locations
                  originRelAbund = OVENdata$originRelAbund,#Relative abundance
                  verbose = 1,   # output options
                  calcCorr = TRUE, # estimate rM as well
                  nSamples = nSamplesGLGPS, # This is set low for example
                  approxSigTest = TRUE,
                  resampleProjection = terra::crs(OVENdata$targetSites),
                  originNames = OVENdata$originNames,
                  targetNames = OVENdata$targetNames)

  print(Combined)

  # For treating all data as GPS,
  # Move the latitude of birds with locations that fall offshore - only change
  # Latitude
  int &lt;- sf::st_intersects(OVENdata$targetPoints, OVENdata$targetSites)
  any(lengths(int)&lt;1)
  plot(OVENdata$targetPoints)
  plot(OVENdata$targetSites,add=TRUE)
  tp&lt;-sf::st_coordinates(OVENdata$targetPoints)
  text(tp[,1], tp[,2], label=c(1:39))

  tp[5,2]&lt;- -1899469
  tp[10,2]&lt;- -1927848
  tp[1,2]&lt;- -1927930
  tp[11,2]&lt;- -2026511
  tp[15,2]&lt;- -2021268
  tp[16,2]&lt;- -1976063

  oven_targetPoints&lt;-sf::st_as_sf(as.data.frame(tp),
                                  coords = c("X","Y"),
                                  crs = sf::st_crs(OVENdata$targetPoints))
  inter &lt;- sf::st_intersects(oven_targetPoints, OVENdata$targetSites)
  any(lengths(inter)&lt;1)
  plot(oven_targetPoints,add=TRUE, col = "green")

  # Estimate MC only, treat all data as GPS
  GPS_mc&lt;-estMC(isGL=FALSE, # Logical vector: light-level geolocator(T)/GPS(F)
                targetDist = OVENdata$targetDist, # targetSites distance matrix
                originDist = OVENdata$originDist, # originSites distance matrix
                targetSites = OVENdata$targetSites, # Non-breeding target sites
                originSites = OVENdata$originSites, # Breeding origin sites
                originPoints = OVENdata$originPoints, # Capture Locations
                targetPoints = oven_targetPoints, # Device target locations
                originRelAbund = OVENdata$originRelAbund,#Origin relative abund.
                verbose = 1,   # output options
                nSamples = nSamplesGLGPS) # This is set low for example

  str(GPS_mc, max.level = 2)
  str(Combined, max.level = 2)
  str(GL_mc, max.level = 2)
  plot(Combined, legend = "top", main = "Ovenbird GL and GPS")
  text(1.1, 0.98, cex = 1,
       labels = paste("MC = ", round(Combined$MC$mean, 2), "+/-",
                      round(Combined$MC$se, 2)))


  # Generate probabilistic assignments using intrinsic markers (stable-hydrogen
  # isotopes)
  getCSV &lt;- function(filename) {
    tmp &lt;- tempdir()
    url1 &lt;- paste0('https://github.com/SMBC-NZP/MigConnectivity/blob/master/data-raw/',
                   filename, '?raw=true')
    temp &lt;- paste(tmp, filename, sep = '/')
    utils::download.file(url1, temp, mode = 'wb')
    csv &lt;- read.csv(temp)
    unlink(temp)
    return(csv)
  }

  getRDS &lt;- function(speciesDist) {
    tmp &lt;- tempdir()
    extension &lt;- '.rds'
    filename &lt;- paste0(speciesDist, extension)
    url1 &lt;- paste0(
      'https://github.com/SMBC-NZP/MigConnectivity/blob/master/data-raw/Spatial_Layers/',
                   filename, '?raw=true')
    temp &lt;- paste(tmp, filename, sep = '/')
    utils::download.file(url1, temp, mode = 'wb')
    shp &lt;- readRDS(temp)
    unlink(temp)
    return(shp)
  }
  OVENdist &lt;- getRDS("OVENdist")

  OVENvals &lt;- getCSV("deltaDvalues.csv")

  OVENvals &lt;- OVENvals[grep(x=OVENvals$Sample,"NH", invert = TRUE),]

  originSites &lt;- getRDS("originSites")
  originSites &lt;- sf::st_as_sf(originSites)

  EVER &lt;- length(grep(x=OVENvals$Sample,"EVER"))
  JAM &lt;- length(grep(x=OVENvals$Sample,"JAM"))

  originRelAbund &lt;- matrix(c(EVER,JAM),nrow = 1,byrow = TRUE)
  originRelAbund &lt;- prop.table(originRelAbund,1)

  op &lt;- sf::st_centroid(originSites)

  originPoints &lt;- array(NA,c(EVER+JAM,2), list(NULL, c("x","y")))
  originPoints[grep(x = OVENvals$Sample,"JAM"),1] &lt;- sf::st_coordinates(op)[1,1]
  originPoints[grep(x = OVENvals$Sample,"JAM"),2] &lt;- sf::st_coordinates(op)[1,2]
  originPoints[grep(x = OVENvals$Sample,"EVER"),1] &lt;-sf::st_coordinates(op)[2,1]
  originPoints[grep(x = OVENvals$Sample,"EVER"),2] &lt;-sf::st_coordinates(op)[2,2]

  originPoints &lt;- sf::st_as_sf(data.frame(originPoints),
                               coords = c("x", "y"),
                               crs = sf::st_crs(originSites))
  originDist &lt;- distFromPos(sf::st_coordinates(op))


  iso &lt;- isoAssign(isovalues = OVENvals[,2],
                   isoSTD = 12,       # this value is for demonstration only
                   intercept = -10,   # this value is for demonstration only
                   slope = 0.8,       # this value is for demonstration only
                   odds = NULL,
                   restrict2Likely = TRUE,
                   nSamples = 1000,
                   sppShapefile = OVENdist,
                   assignExtent = c(-179,-60,15,89),
                   element = "Hydrogen",
                   period = "GrowingSeason",#this setting for demonstration only
                   seed = 12345,
                   verbose=1)

  targetSites &lt;- sf::st_as_sf(iso$targetSites)
  targetSites &lt;- sf::st_make_valid(targetSites)
  targetSites &lt;- sf::st_union(targetSites, by_feature = TRUE)

  ovenMC &lt;- estMC(originRelAbund = originRelAbund,
                  targetIntrinsic = iso,
                  originPoints = originPoints,
                  originSites = originSites,
                  originDist = originDist,
                  nSamples = 50, # set very low for example speed
                  verbose = 1,
                  calcCorr = TRUE,
                  alpha = 0.05,
                  approxSigTest = FALSE,
                  isIntrinsic = TRUE,
                  targetSites = targetSites)

  ovenMC

</code></pre>

<hr>
<h2 id='estStrength'>Estimate MC, migratory connectivity strength</h2><span id='topic+estStrength'></span>

<h3>Description</h3>

<p>Resampling of uncertainty for MC (migratory connectivity strength)
from estimates of psi (transition probabilities) and/or relative abundance.
Psi estimates can come from an estMigConnectivity object, an RMark psi
matrix, MCMC samples, or other samples expressed in array form.
Abundance estimates for each origin site can be
either just point estimates (no uncertainty propagated) or MCMC samples.
Other inputs include distances between origin sites, distances between target
sites, and sample size used to estimate psi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estStrength(
  originDist,
  targetDist,
  originRelAbund,
  psi,
  sampleSize = NULL,
  originSites = NULL,
  targetSites = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  row0 = 0,
  verbose = 0,
  alpha = 0.05,
  approxSigTest = FALSE,
  sigConst = 0,
  maintainLegacyOutput = FALSE,
  returnAllInput = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estStrength_+3A_origindist">originDist</code></td>
<td>
<p>Distances between the B origin sites. Symmetric B by B
matrix</p>
</td></tr>
<tr><td><code id="estStrength_+3A_targetdist">targetDist</code></td>
<td>
<p>Distances between the W target sites. Symmetric W by W
matrix</p>
</td></tr>
<tr><td><code id="estStrength_+3A_originrelabund">originRelAbund</code></td>
<td>
<p>Relative abundance estimates at B origin sites. Either
a numeric vector of length B that sums to 1, or an mcmc object (such as is
produced by <code><a href="#topic+modelCountDataJAGS">modelCountDataJAGS</a></code>) or matrix with at least
<code>nSamples</code> rows. If there are more than B columns, the relevant columns
should be labeled &quot;relN[1]&quot; through &quot;relN[B]&quot;</p>
</td></tr>
<tr><td><code id="estStrength_+3A_psi">psi</code></td>
<td>
<p>Transition probabilities between B origin and W target sites.
Either a matrix with B rows and W columns where rows sum to 1, an array with
dimensions x, B, and W (with x samples of the transition probability matrix
from another model), an 'estPsi' object (result of calling estTransition),
or a MARK object with estimates of transition probabilities</p>
</td></tr>
<tr><td><code id="estStrength_+3A_samplesize">sampleSize</code></td>
<td>
<p>Total sample size of animals that psi will be estimated
from. Should be the number of animals released in one of the origin sites
and observed in one of the target sites (or vice-versa). Optional, but
recommended, unless psi is an estPsi object (in which case this function can
pull it from there)</p>
</td></tr>
<tr><td><code id="estStrength_+3A_originsites">originSites</code></td>
<td>
<p>If <code>psi</code> is a MARK object, this must be a numeric
vector indicating which sites are origin</p>
</td></tr>
<tr><td><code id="estStrength_+3A_targetsites">targetSites</code></td>
<td>
<p>If <code>psi</code> is a MARK object, this must be a numeric
vector indicating which sites are target</p>
</td></tr>
<tr><td><code id="estStrength_+3A_originnames">originNames</code></td>
<td>
<p>Optional. Vector of names for the origin sites. Mostly for
internal use</p>
</td></tr>
<tr><td><code id="estStrength_+3A_targetnames">targetNames</code></td>
<td>
<p>Optional. Vector of names for the target sites. Mostly for
internal use</p>
</td></tr>
<tr><td><code id="estStrength_+3A_nsamples">nSamples</code></td>
<td>
<p>Number of times to resample <code>psi</code> and/or
<code>originRelAbund</code>. The purpose is to estimate sampling uncertainty;
higher values here will do so with more precision</p>
</td></tr>
<tr><td><code id="estStrength_+3A_row0">row0</code></td>
<td>
<p>If <code>originRelAbund</code> is an mcmc object or array, this can be
set to 0 (default) or any greater integer to specify where to stop ignoring
samples (&quot;burn-in&quot;)</p>
</td></tr>
<tr><td><code id="estStrength_+3A_verbose">verbose</code></td>
<td>
<p>0 (default) to 2. 0 prints no output during run. 1 prints
a progress update and summary every 100 samples. 2 prints a
progress update and summary every sample</p>
</td></tr>
<tr><td><code id="estStrength_+3A_alpha">alpha</code></td>
<td>
<p>Level for confidence/credible intervals provided. Default (0.05)
gives 95 percent CI</p>
</td></tr>
<tr><td><code id="estStrength_+3A_approxsigtest">approxSigTest</code></td>
<td>
<p>Should function compute approximate one-sided
significance tests (p-values) for MC from the resampling? Default is
FALSE</p>
</td></tr>
<tr><td><code id="estStrength_+3A_sigconst">sigConst</code></td>
<td>
<p>Value to compare MC to in significance test. Default is 0</p>
</td></tr>
<tr><td><code id="estStrength_+3A_maintainlegacyoutput">maintainLegacyOutput</code></td>
<td>
<p>version 0.4.0 of <code>MigConnectivity</code>
updated the structure of the estimates. If you have legacy code that refers
to elements within an <code>estMigConnectivity</code> object (results of
<code>estMC</code>), you can set this to TRUE to also keep the old structure.
Defaults to FALSE</p>
</td></tr>
<tr><td><code id="estStrength_+3A_returnallinput">returnAllInput</code></td>
<td>
<p>if TRUE (the default) the output includes all of the
inputs. If FALSE, only the inputs currently used by another MigConnectivity
function are included in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>estStrength</code> returns a list with the elements:
</p>

<dl>
<dt><code>MC</code></dt><dd><p>List containing estimates of migratory connectivity
strength:
</p>

<ul>
<li><p><code>sample</code> <code>nSamples</code> sampled values for
MC. Provided to allow the user to compute own summary statistics.
</p>
</li>
<li><p><code>mean</code> Mean of <code>MC$sample</code>. Main estimate of MC,
incorporating parametric uncertainty.
</p>
</li>
<li><p><code>se</code> Standard error of MC, estimated from SD of
<code>MC$sample</code>.
</p>
</li>
<li><p><code>simpleCI</code> Default<code>1 - alpha</code> confidence interval for
MC, estimated as <code>alpha/2</code> and <code>1 - alpha/2</code> quantiles of
<code>MC$sample</code>.
</p>
</li>
<li><p><code>bcCI</code> Bias-corrected <code>1 - alpha</code> confidence interval
for MC. May be preferable to <code>MC$simpleCI</code> when <code>MC$mean</code> is
the best estimate of MC. <code>MC$simpleCI</code> is preferred when
<code>MC$median</code> is a better estimator. When <code>MC$mean==MC$median</code>,
these should be identical.  Estimated as the
<code>pnorm(2 * z0 + qnorm(alpha / 2))</code> and
<code>pnorm(2 * z0 + qnorm(1 - alpha / 2))</code> quantiles of <code>MC$sample</code>,
where z0 is the proportion of <code>MC$sample &lt; MC$mean</code>.
</p>
</li>
<li><p><code>hpdCI</code> <code>1 - alpha</code> credible interval for MC,
estimated using the highest posterior density (HPD) method.
</p>
</li>
<li><p><code>median</code> Median of MC, alternate point estimate also
including parametric uncertainty.
</p>
</li>
<li><p><code>point</code> Simple point estimate of MC, using the point
estimates of <code>psi</code> and <code>originRelAbund</code> (usually the mean
values), not accounting for sampling error.
</p>
</li>
<li><p><code>simpleP</code> Approximate p-value for MC, estimated as the
proportion of bootstrap iterations where MC &lt; <code>sigConst</code> (or MC &gt;
<code>sigConst</code> if <code>pointMC &lt; sigConst</code>).  Note that if the
proportion is 0, a default value of 0.5 / <code>nSamples</code> is provided,
but this is best interpreted as p &lt; 1 / <code>nSamples</code>.  NULL when
<code>approxSigTest==FALSE</code>.
</p>
</li>
<li><p><code>bcP</code> Approximate bias-corrected p-value for MC, estimated as
<code>pnorm(qnorm(simpleP) - 2 * z0)</code>, where z0 is the proportion of
<code>sampleMC &lt; meanMC</code>.  May be a better approximation of the p-value
than <code>simpleP</code>, but many of the same limitations apply.  NULL when
<code>approxSigTest==FALSE</code>.
</p>
</li></ul>

</dd>
<dt><code>input</code></dt><dd><p>List containing the inputs to <code>estStrength</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+calcMC">calcMC</a></code>, <code><a href="#topic+estTransition">estTransition</a></code>,
<code><a href="#topic+estMC">estMC</a></code>, <code><a href="#topic+estMantel">estMantel</a></code>,
<code><a href="#topic+plot.estMigConnectivity">plot.estMigConnectivity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  set.seed(101)
  # Uncertainty in detection (RMark estimates) with equal abundances
  # Number of resampling iterations for generating confidence intervals
  nSamplesCMR &lt;- 100
  nSimulationsCMR &lt;- 10
  originPos13 &lt;- matrix(c(rep(seq(-99, -81, 2), each = 10),
                          rep(seq(49, 31, -2), 10)), 100, 2)
  targetPos13 &lt;- matrix(c(rep(seq(-79, -61, 2), each = 10),
                          rep(seq(9, -9, -2), 10)), 100, 2)
  originPosCMR &lt;- rowsum(originPos13, c(rep(1:2, 5, each = 5),
                                        rep(3:4, 5, each = 5))) / 25
  originPosCMR
  targetPosCMR &lt;- rowsum(targetPos13, c(rep(1:2, 5, each = 5),
                                        rep(3:4, 5, each = 5))) / 25
  targetPosCMR

  originDist &lt;- distFromPos(originPosCMR, 'ellipsoid')
  targetDist &lt;- distFromPos(targetPosCMR, 'ellipsoid')
  originRelAbundTrue &lt;- rep(0.25, 4)
  # the second intermediate psi scenario, the "low" level
  psiTrue &lt;- samplePsis[["Low"]]
  trueMC &lt;- calcMC(originDist, targetDist, originRelAbundTrue, psiTrue)
  trueMC

  # Storage matrix for samples
  cmrMCSample &lt;- matrix(NA, nSamplesCMR, nSimulationsCMR)
  summaryCMR &lt;- data.frame(Simulation = 1:nSimulationsCMR, True=trueMC,
                           mean=NA, se=NA, lcl=NA, ucl=NA)
  # Get 'RMark' psi estimates and estimate MC from each
  for (r in 1:nSimulationsCMR) {
    cat("Simulation",r,"of",nSimulationsCMR,"\n")
    # Note: getCMRexample() requires a valid internet connection and that GitHub
    # is accessible
    fm &lt;- getCMRexample(r)
    results &lt;- estStrength(originRelAbund = originRelAbundTrue, psi = fm,
                     originDist = originDist, targetDist = targetDist,
                     originSites = 5:8, targetSites = c(3,2,1,4),
                     nSamples = nSamplesCMR, verbose = 0,
                     sampleSize = length(grep('[2-5]', fm$data$data$ch)))
    cmrMCSample[ , r] &lt;- results$MC$sample
    summaryCMR$mean[r] &lt;- results$MC$mean
    summaryCMR$se[r] &lt;- results$MC$se
    # Calculate confidence intervals using quantiles of sampled MC
    summaryCMR[r, c('lcl', 'ucl')] &lt;- results$MC$simpleCI
  }

  summaryCMR &lt;- transform(summaryCMR, coverage = (True&gt;=lcl &amp; True&lt;=ucl))
  summaryCMR
  summary(summaryCMR)
  biasCMR &lt;- mean(summaryCMR$mean) - trueMC
  biasCMR
  mseCMR &lt;- mean((summaryCMR$mean - trueMC)^2)
  mseCMR
  rmseCMR &lt;- sqrt(mseCMR)
  rmseCMR


  # Simulation of BBS data to quantify uncertainty in relative abundance

  nSamplesAbund &lt;- 700 #1700 are stored
  nSimulationsAbund &lt;- 10
  #\dontrun{
  #  nSamplesAbund &lt;- 1700
  #}
  # Storage matrix for samples
  abundMCSample &lt;- matrix(NA, nSamplesAbund, nSimulationsAbund)
  summaryAbund &lt;- data.frame(Simulation = 1:nSimulationsAbund, True = trueMC,
                             mean = NA, se = NA, lcl = NA, ucl = NA)
  for (r in 1:nSimulationsAbund) {
    cat("Simulation",r,"of",nSimulationsAbund,"\n")
    row0 &lt;- nrow(abundExamples[[r]]) - nSamplesAbund
    results &lt;- estStrength(originRelAbund = abundExamples[[r]], psi = psiTrue,
                     originDist = originDist, targetDist = targetDist,
                     row0 = row0, nSamples = nSamplesAbund, verbose = 1)
    abundMCSample[ , r] &lt;- results$MC$sample
    summaryAbund$mean[r] &lt;- results$MC$mean
    summaryAbund$se[r] &lt;- results$MC$se
    # Calculate confidence intervals using quantiles of sampled MC
    summaryAbund[r, c('lcl', 'ucl')] &lt;- results$MC$simpleCI
  }

  summaryAbund &lt;- transform(summaryAbund, coverage = (True &gt;= lcl &amp; True &lt;= ucl))
  summaryAbund
  summary(summaryAbund)
  biasAbund &lt;- mean(summaryAbund$mean) - trueMC
  biasAbund
  mseAbund &lt;- mean((summaryAbund$mean - trueMC)^2)
  mseAbund
  rmseAbund &lt;- sqrt(mseAbund)
  rmseAbund

  # Ovenbird example with GL and GPS data
  data(OVENdata) # Ovenbird

  nSamplesGLGPS &lt;- 100 # Number of bootstrap iterations, set low for example

  # Estimate transition probabilities
  Combined.psi&lt;-estTransition(isGL=OVENdata$isGL, #Light-level geolocator (T/F)
                              isTelemetry = !OVENdata$isGL,
                  geoBias = OVENdata$geo.bias, # Light-level GL location bias
                  geoVCov = OVENdata$geo.vcov, # Location covariance matrix
                  targetSites = OVENdata$targetSites, # Nonbreeding/target sites
                  originSites = OVENdata$originSites, # Breeding/origin sites
                  originPoints = OVENdata$originPoints, # Capture Locations
                  targetPoints = OVENdata$targetPoints, #Device target locations
                  verbose = 3,   # output options
                  nSamples = nSamplesGLGPS, # This is set low for example
                  resampleProjection = sf::st_crs(OVENdata$targetPoints),
                  nSim = 1000)

  # Can estimate MC from previous psi estimate
  Combo.MC1 &lt;- estStrength(targetDist = OVENdata$targetDist, # Distance matrix
                           originDist = OVENdata$originDist, # Distance matrix
                           targetSites = OVENdata$targetSites, # Target sites
                           originSites = OVENdata$originSites, # Breeding sites
                           psi = Combined.psi,
                           originRelAbund = OVENdata$originRelAbund,
                           nSamples = nSamplesGLGPS,
                           sampleSize = nrow(OVENdata$targetPoints))
  Combo.MC1

  # Doesn't have to be an estPsi object - can simply be array of psi samples
  Combo.MC2 &lt;- estStrength(targetDist = OVENdata$targetDist,
                           originDist = OVENdata$originDist,
                           targetSites = OVENdata$targetSites,
                           originSites = OVENdata$originSites,
                           psi = Combined.psi$psi$sample, # Array of samples
                           originRelAbund = OVENdata$originRelAbund,
                           nSamples = nSamplesGLGPS,
                           sampleSize = nrow(OVENdata$targetPoints))
  Combo.MC2

</code></pre>

<hr>
<h2 id='estTransition'>Estimate psi (transition probabilities between locations in two phases of
the annual cycle)</h2><span id='topic+estTransition'></span><span id='topic+estPsi'></span>

<h3>Description</h3>

<p>Estimation and resampling of uncertainty for psi (transition probabilities
between origin sites in one phase of the annual cycle and target sites in
another for migratory animals). Data can be from any combination of
geolocators (GL), telemetry/GPS, intrinsic markers such as isotopes and
genetics, and band/ring reencounter data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estTransition(
  originSites = NULL,
  targetSites = NULL,
  originPoints = NULL,
  targetPoints = NULL,
  originAssignment = NULL,
  targetAssignment = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  isGL = FALSE,
  isTelemetry = FALSE,
  isRaster = FALSE,
  isProb = FALSE,
  captured = "origin",
  geoBias = NULL,
  geoVCov = NULL,
  geoBiasOrigin = geoBias,
  geoVCovOrigin = geoVCov,
  targetRaster = NULL,
  originRaster = NULL,
  banded = NULL,
  reencountered = NULL,
  verbose = 0,
  alpha = 0.05,
  resampleProjection = "ESRI:102010",
  nSim = ifelse(any(isRaster &amp; isGL) || any(isRaster &amp; isProb) || any(isGL &amp; isProb),
    5000, ifelse(any(isGL), 1000, ifelse(any(isRaster), 10, 1))),
  maxTries = 300,
  nBurnin = 5000,
  nChains = 3,
  nThin = 1,
  dataOverlapSetting = c("dummy", "none", "named"),
  fixedZero = NULL,
  targetRelAbund = NULL,
  method = c("bootstrap", "MCMC", "m-out-of-n-bootstrap"),
  m = NULL,
  psiPrior = NULL,
  returnAllInput = TRUE
)

estPsi(
  originSites = NULL,
  targetSites = NULL,
  originPoints = NULL,
  targetPoints = NULL,
  originAssignment = NULL,
  targetAssignment = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  isGL = FALSE,
  isTelemetry = FALSE,
  isRaster = FALSE,
  isProb = FALSE,
  captured = "origin",
  geoBias = NULL,
  geoVCov = NULL,
  geoBiasOrigin = geoBias,
  geoVCovOrigin = geoVCov,
  targetRaster = NULL,
  originRaster = NULL,
  banded = NULL,
  reencountered = NULL,
  verbose = 0,
  alpha = 0.05,
  resampleProjection = "ESRI:102010",
  nSim = ifelse(any(isRaster &amp; isGL) || any(isRaster &amp; isProb) || any(isGL &amp; isProb),
    5000, ifelse(any(isGL), 1000, ifelse(any(isRaster), 10, 1))),
  maxTries = 300,
  nBurnin = 5000,
  nChains = 3,
  nThin = 1,
  dataOverlapSetting = c("dummy", "none", "named"),
  fixedZero = NULL,
  targetRelAbund = NULL,
  method = c("bootstrap", "MCMC", "m-out-of-n-bootstrap"),
  m = NULL,
  psiPrior = NULL,
  returnAllInput = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estTransition_+3A_originsites">originSites</code></td>
<td>
<p>A polygon spatial layer (sf - MULTIPOLYGON)
defining the geographic representation of sites in the
origin season.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_targetsites">targetSites</code></td>
<td>
<p>A polygon spatial layer (sf - MULTIPOLYGON)
defining the geographic representation of sites in the
target season.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_originpoints">originPoints</code></td>
<td>
<p>A <code>sf</code> or <code>SpatialPoints</code> object, with number
of rows or length being the number of animals tracked. Each point indicates
the origin location of an animal (or point estimate of same, for GL animals
released on target sites). Note that to simplify input of multiple
data types both between and for the same animal, if origin points are
provided for any animal, they must be provided for all except banding data
(can be dummy values), unless <code>dataOverlapSetting</code> is set to &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_targetpoints">targetPoints</code></td>
<td>
<p>For GL or telemetry data, a <code>sf</code> or
<code>SpatialPoints</code> object, with length or number of rows number of animals
tracked. Each point indicates the point estimate location of an animal in
the target season. Note that to simplify input of multiple
data types both between and for the same animal, if target points are
provided for any animal, they must be provided for all except banding data
(can be dummy values), unless <code>dataOverlapSetting</code> is set to &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_originassignment">originAssignment</code></td>
<td>
<p>Assignment of animals to origin season sites. Either
an integer vector with length number of animals tracked or a matrix of
probabilities with number of animals tracked rows and number of origin sites
columns (and rows summing to 1). The latter only applies to animals released
in the target sites where there is uncertainty about their origin site, for
example from genetic population estimates from the rubias package.
Optional, but some combination of these inputs should be defined. Note that
if <code>originAssignment</code> is a probability table, animals with known origin
sites can have 1 in that column and 0s in all others. Also note that if
<code>method</code> is &quot;MCMC&quot;, anything in <code>originAssignment</code> and
<code>targetAssignment</code> will be assumed to represent animals tracked via
telemetry, with known origin and target sites.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_targetassignment">targetAssignment</code></td>
<td>
<p>Assignment of animals to target season sites. Either
an integer vector with length number of animals tracked or a matrix of
probabilities with number of animals tracked rows and number of target sites
columns (and rows summing to 1). The latter only applies to animals released
in the origin sites where there is uncertainty about their target site, for
example from genetic population estimates from the rubias package.
Optional, but some combination of these inputs needs to be defined. Note
that if <code>targetAssignment</code> is a probability table, animals with known
target sites can have 1 in that column and 0s in all others.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_originnames">originNames</code></td>
<td>
<p>Optional, but recommended to keep track. Vector of names
for the origin sites. If not provided, the function will either try to get
these from another input or provide default names (capital letters).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_targetnames">targetNames</code></td>
<td>
<p>Optional, but recommended to keep track. Vector of names
for the target sites. If not provided, the function will either try to get
these from another input or provide default names (numbers).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_nsamples">nSamples</code></td>
<td>
<p>Number of post-burn-in MCMC samples to store (<code>method</code>
== &quot;MCMC&quot;) OR number of bootstrap runs for <code>method</code>
== &quot;bootstrap&quot;. In the latter case, animals are sampled with replacement
for each. For all, the purpose is to estimate sampling uncertainty.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_isgl">isGL</code></td>
<td>
<p>Indicates whether or which animals were tracked with geolocators.
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE or FALSE for each animal in data
(except those in <code>banded</code>, which are handled separately). For
TRUE animals, the model applies <code>geoBias</code> and <code>geoVCov</code> to
<code>targetPoints</code> where <code>captured</code> == &quot;origin&quot; or &quot;neither&quot; and
<code>geoBiasOrigin</code> and <code>geoVCovOrigin</code> to
<code>originPoints</code> where <code>captured</code> == &quot;target&quot; or &quot;neither&quot;.
Geolocator data should be entered as <code>originPoints</code> and
<code>targetPoints</code>.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_istelemetry">isTelemetry</code></td>
<td>
<p>Indicates whether or which animals were tracked with
telemetry/GPS (no location uncertainty on either end).
Should be either single TRUE or FALSE value, or vector with length of
number of animals tracked, with TRUE or FALSE for each animal in data
(except those in <code>banded</code>, which are handled separately).
Telemetry data can be entered as points or using the <code>targetAssignment</code>
and <code>originAssignment</code> arguments.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_israster">isRaster</code></td>
<td>
<p>Indicates whether or which animals were tracked with
intrinsic markers (e.g., genetics or isotopes), with location uncertainty
expressed as a raster of probabilities by grid cells, either in
<code>targetRaster</code> or <code>originRaster</code>. Should be either single TRUE or
FALSE value, or vector with length of number of animals tracked, with TRUE
or FALSE for each animal in data (except those in <code>banded</code>, which are
handled separately).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_isprob">isProb</code></td>
<td>
<p>Indicates whether or which animals were tracked with
intrinsic markers (e.g., genetics or isotopes), with location uncertainty
expressed as a probability table, either in <code>targetAssignment</code> or
<code>originAssignment</code>. Should be either single TRUE or FALSE value, or
vector with length of number of animals tracked, with TRUE or FALSE for each
animal in data (except those in <code>banded</code>, which are handled separately).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_captured">captured</code></td>
<td>
<p>Indicates whether or which animals were captured in the
origin sites, the target sites, or neither (another phase of the annual
cycle). Location uncertainty will only be applied where the animal was not
captured. So this doesn't matter for telemetry data, and is assumed to be
&quot;origin&quot; for band return data. Should be either single &quot;origin&quot; (default),
&quot;target&quot;, or &quot;neither&quot; value, or a character vector with length of number of
animals tracked, with &quot;origin&quot;, &quot;target&quot;, or &quot;neither&quot; for each animal.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_geobias">geoBias</code></td>
<td>
<p>For GL data, vector of length 2 indicating expected bias
in longitude and latitude of <code>targetPoints</code>, in
<code>resampleProjection</code> units (default meters).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_geovcov">geoVCov</code></td>
<td>
<p>For GL data, 2x2 matrix with expected variance/covariance
in longitude and latitude of <code>targetPoints</code>, in
<code>resampleProjection</code> units (default meters).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_geobiasorigin">geoBiasOrigin</code></td>
<td>
<p>For GL data where <code>captured</code>!=&quot;origin&quot;, vector of
length 2 indicating expected bias in longitude and latitude of
<code>originPoints</code>, in <code>resampleProjection</code> units (default meters).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_geovcovorigin">geoVCovOrigin</code></td>
<td>
<p>For GL data where <code>captured</code>!=&quot;origin&quot;, 2x2 matrix
with expected variance/covariance in longitude and latitude of
<code>targetPoints</code>, in <code>resampleProjection</code> units (default meters).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_targetraster">targetRaster</code></td>
<td>
<p>For intrinsic tracking data, the results of
<code>isoAssign</code> or a similar function of class <code>intrinsicAssign</code> or
class <code>RasterBrick</code>/<code>RasterStack</code>, for example from the package
<code>assignR</code>. In any case, it expresses location uncertainty on target
range, through a raster of probabilities by grid cells.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_originraster">originRaster</code></td>
<td>
<p>For intrinsic tracking data, the results of
<code>isoAssign</code> or a similar function of class <code>intrinsicAssign</code> or
class <code>RasterBrick</code>/<code>RasterStack</code>, for example from the package
<code>assignR</code>. In any case, it expresses location uncertainty on origin
range, through a raster of probabilities by grid cells.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_banded">banded</code></td>
<td>
<p>For band return data, a vector or matrix of the number of
released animals from each origin site (including those never reencountered
in a target site). If a matrix, the second dimension is taken as the number
of age classes of released animals; the model estimates reencounter
probability by age class but assumes transition probabilities are the same.
Note that this age model is currently implemented only for <code>method</code>
set to &quot;MCMC&quot;, and only when banding data is analyzed alone (no telemetry
data).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_reencountered">reencountered</code></td>
<td>
<p>For band return data, either a matrix with B rows and W
columns or a B x [number of ages] x W array. Number of animals reencountered
on each target site (by age class banded as) by origin site they came from.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_verbose">verbose</code></td>
<td>
<p>0 (default) to 3. 0 prints no output during run (except on
convergence for <code>method</code> set to &quot;MCMC&quot;). 1 prints an update every 100
samples or bootstraps (or a status bar for &quot;MCMC&quot;).  2 prints an update
every sample or bootstrap. 3 also prints the number of draws (for
tuning <code>nSim</code>).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_alpha">alpha</code></td>
<td>
<p>Level for confidence/credible intervals provided. Default (0.05)
gives 95 percent CI.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_resampleprojection">resampleProjection</code></td>
<td>
<p>Projection when sampling from location uncertainty.
Default is Equidistant Conic. The default setting preserves distances
around latitude = 0 and longitude = 0. Other projections may work well,
depending on the location of sites. Ignored unless data are entered using
sites and points and/or rasters.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_nsim">nSim</code></td>
<td>
<p>Tuning parameter for GL or intrinsic data. Affects only the
speed; 1000 seems to work well with our GL data and 10 for our intrinsic
data, but your results may vary. For data combinations, we put the default
higher (5000) to allow for more data conflicts. Should be integer &gt; 0.
Ignored when <code>method</code> is &quot;MCMC&quot;.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_maxtries">maxTries</code></td>
<td>
<p>Maximum number of times to run a single GL/intrinsic
bootstrap before exiting with an error. Default is 300; you may want to make
a little higher if your <code>nSim</code> is low and <code>nSamples</code> is high. Set
to NULL to never exit. This parameter was added to prevent setups where some
sample points never land on target sites from running indefinitely.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_nburnin">nBurnin</code></td>
<td>
<p>For <code>method</code> set to &quot;MCMC&quot;, <code>estTransition</code> runs a
<code>JAGS</code> multinomial non-Markovian transitions model, for which it needs
the number of burn-in samples before beginning to store results. Default
5000.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_nchains">nChains</code></td>
<td>
<p>For <code>method</code> set to &quot;MCMC&quot;, <code>estTransition</code> runs a
<code>JAGS</code> multinomial non-Markovian transitions model, for which it needs
the number of MCMC chains (to test for convergence). Default 3.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_nthin">nThin</code></td>
<td>
<p>For <code>method</code> set to &quot;MCMC&quot;, <code>estTransition</code> runs a
<code>JAGS</code> multinomial non-Markovian transitions model, for which it needs
the thinning rate. Default 1.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_dataoverlapsetting">dataOverlapSetting</code></td>
<td>
<p>When there is more than one type of data, this
setting allows the user some flexibility for clarifying which type(s) of
data apply to which animals. Setting &quot;dummy&quot; (the default) indicates that
there are dummy values within each dataset for the animals that isGL,
isTelemetry, etc. don't have that data type (FALSE values). If no animals
have a data type, no dummy values are required. If no animals have more than
one type of data, the user can simplify processing their data by choosing
setting &quot;none&quot; here. In this case, there should be no dummy values, and only
the animals with a type of data should be included in that dataset. The
third setting (&quot;named&quot;) is not yet implemented, but will eventually allow
another way to allow animals with more than one type of data with named
animals linking records. When there is only one type of data, it is fastest
to leave this on the default. Note that banding data entered through
<code>banded</code> and <code>reencountered</code> are assumed to have no
overlap with other data types, so none of this applies to those.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_fixedzero">fixedZero</code></td>
<td>
<p>When the user has a priori reasons to believe one or more
transition probabilities are zero, they can indicate those here, and the
model will keep them fixed at zero. This argument should be a matrix with
two columns (for row and column of the transition probability matrix) and
number of transitions being fixed to zero rows. For MCMC modeling,
substantial evidence that a transition fixed to zero isn't zero may
cause an error. For bootstrap modeling, a warning
will come up if any bootstrap runs generate the transition fixed to zero,
and the function will quit with an error if a very large number of runs do
(&gt; 10 * nSamples). Fixing transitions to zero may also slow down the
bootstrap model somewhat.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_targetrelabund">targetRelAbund</code></td>
<td>
<p>When some/all data have location error at origin sites
(i.e., GL, raster, or probability table data with captured = &quot;target&quot; or
&quot;none&quot;), unless the data were collected in proportion to abundance at target
sites, simulation work indicates substantial bias in transition probability
estimates can result. However, if these data are resampled in proportion to
target site abundance, this bias is removed. This argument allows the user
to provide an estimate of relative abundance at the target sites. Either
a numeric vector of length [number target sites] that sums to 1, or an mcmc
object (such as is produced by <code><a href="#topic+modelCountDataJAGS">modelCountDataJAGS</a></code>) or matrix
with at least <code>nSamples</code> rows. If there are more than [number target
sites] columns, the relevant columns should be labeled &quot;relN[1]&quot; through
&quot;relN[number target sites]&quot;.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_method">method</code></td>
<td>
<p>This important setting lets the user choose the estimation
method used: bootstrap or MCMC (Markov chain Monte Carlo). Bootstrap (the
default) now works with any and all types of data, whereas MCMC currently
only works with banding and telemetry data (enter telemetry data for MCMC
using <code>originAssignment</code> and <code>targetAssignment</code>, not
<code>originPoints</code> and <code>targetPoints</code>). However, MCMC is
usually faster (and may be a bit more accurate). The third option,
&quot;m-out-of-n-bootstrap&quot;, is still under development and should be left alone.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_m">m</code></td>
<td>
<p>We read that the m-out-of-n-bootstrap method may improve the
coverage of confidence intervals for parameters on or near a boundary (0 or
1 in this case). So we're testing that out. This still under development and
not for the end user. In the m-out-of-n-bootstrap, m is the number of
samples taken each time (less than the true sample size, n). If the
&quot;m-out-of-n-bootstrap&quot; is chosen under <code>method</code> but this is left blank,
currently the default is n/4, rounded up (no idea if that is reasonable).</p>
</td></tr>
<tr><td><code id="estTransition_+3A_psiprior">psiPrior</code></td>
<td>
<p>matrix with same dimensions as psi. Only relevant when
<code>method</code> is &quot;MCMC&quot;. Each row provides a Dirichlet
(https://en.wikipedia.org/wiki/Dirichlet_distribution) prior on the
transition probabilities from that origin site. The default (NULL) supplies
Dirichlet parameters of all 1s, which is a standard uninformative Dirichlet
prior. Setting these to other positive numbers is useful when you think a
priori that certain transitions are unlikely, but don't want to rule them
out altogether using <code>fixedZero</code>.</p>
</td></tr>
<tr><td><code id="estTransition_+3A_returnallinput">returnAllInput</code></td>
<td>
<p>if TRUE (the default) the output includes all of the
inputs. If FALSE, only the inputs currently used by another MigConnectivity
function are included in the output. Switch this if you're worried about
computer memory (and the output will be much slimmer).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>estTransition</code> returns a list with the elements:
</p>

<dl>
<dt><code>psi</code></dt><dd><p>List containing estimates of transition probabilities:
</p>

<ul>
<li><p><code>sample</code> Array of sampled values for psi. <code>nSamples</code> x
[number of origin sites] x [number of target sites]. Provided to allow
the user to compute own summary statistics.
</p>
</li>
<li><p><code>mean</code> Main estimate of psi matrix. [number of origin sites]
x [number of target sites].
</p>
</li>
<li><p><code>se</code> Standard error of psi, estimated from SD of
<code>psi$sample</code>.
</p>
</li>
<li><p><code>simpleCI</code> <code>1 - alpha</code> confidence interval for psi,
estimated as <code>alpha/2</code> and <code>1 - alpha/2</code> quantiles of
<code>psi$sample</code>.
</p>
</li>
<li><p><code>bcCI</code> Bias-corrected <code>1 - alpha</code> confidence interval
for psi. May be preferable to <code>simpleCI</code> when <code>mean</code> is the
best estimate of psi. <code>simpleCI</code> is preferred when
<code>median</code> is a better estimator. When the mean and median are equal,
these should be identical.  Estimated as the
<code>pnorm(2 * z0 + qnorm(alpha / 2))</code> and
<code>pnorm(2 * z0 + qnorm(1 - alpha / 2))</code> quantiles of <code>sample</code>,
where z0 is the proportion of <code>sample &lt; mean</code>.
</p>
</li>
<li><p><code>hpdCI</code> <code>1 - alpha</code> credible interval for psi,
estimated using the highest posterior density (HPD) method.
</p>
</li>
<li><p><code>median</code> Median estimate of psi matrix.
</p>
</li>
<li><p><code>point</code> Simple point estimate of psi matrix, not accounting
for sampling error.
</p>
</li></ul>

</dd>
<dt><code>r</code></dt><dd><p>List containing estimates of reencounter probabilities at
each target site. NULL except when using direct band/ring reencounter
data.</p>
</dd>
<dt><code>input</code></dt><dd><p>List containing the inputs to <code>estTransition</code>.</p>
</dd>
<dt><code>BUGSoutput</code></dt><dd><p>List containing <code>R2jags</code> output. Only present
when using <code>method</code> of &quot;MCMC&quot;.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+estStrength">estStrength</a></code>, <code><a href="#topic+plot.estMigConnectivity">plot.estMigConnectivity</a></code>,
<code><a href="#topic+estMC">estMC</a></code>, <code><a href="#topic+estMantel">estMantel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ##############################################################################
  # Examples 1 (banding data: first example is based on common tern banding
  #   data; the second is made up data to demonstrate data with two ages)
  ##############################################################################
  COTE_banded &lt;- c(10360, 1787, 2495, 336)
  COTE_reencountered &lt;- matrix(c(12, 0, 38, 15,
                                 111, 7, 6, 2,
                                 5, 0, 19, 4,
                                 1123, 40, 41, 7),
                               4, 4,
                               dimnames = list(LETTERS[1:4], 1:4))
  COTE_psi &lt;- estTransition(originNames = LETTERS[1:4],
                            targetNames = 1:4,
                            banded = COTE_banded,
                            reencountered = COTE_reencountered,
                            verbose = 1,
                            nSamples = 60000, nBurnin = 20000,
                            method = "MCMC")
  COTE_psi

  COTE_banded2 &lt;- matrix(rep(COTE_banded, 2), 4, 2)
  COTE_reencountered2 &lt;- array(c(12, 0, 38, 15, 6, 0, 17, 7,
                                 111, 7, 6, 2, 55, 3, 3, 1,
                                 5, 0, 19, 4, 2, 0, 10, 2,
                                 1123, 40, 41, 7, 660, 20, 20, 3),
                               c(4, 2, 4),
                               dimnames = list(LETTERS[1:4], c("J", "A"), 1:4))
  COTE_psi2 &lt;- estTransition(originNames = LETTERS[1:4],
                            targetNames = 1:4,
                            banded = COTE_banded2,
                            reencountered = COTE_reencountered2,
                            verbose = 0,
                            nSamples = 60000, nBurnin = 20000,
                            method = "MCMC")
  COTE_psi2

  ##############################################################################
  # Example 2 (geolocator and telemetry ovenbirds captured on origin sites)
  ##############################################################################
  data(OVENdata) # Ovenbird

  nSamplesGLGPS &lt;- 100 # Number of bootstrap iterations

  # Estimate transition probabilities; treat all data as geolocator
  GL_psi &lt;- estTransition(isGL=TRUE,
                          geoBias = OVENdata$geo.bias,
                          geoVCov = OVENdata$geo.vcov,
                          targetSites = OVENdata$targetSites,
                          originSites = OVENdata$originSites,
                          originPoints = OVENdata$originPoints,
                          targetPoints = OVENdata$targetPoints,
                          verbose = 2,
                          nSamples = nSamplesGLGPS,
                          resampleProjection=sf::st_crs(OVENdata$targetPoints))

  # Treat all data as is
  Combined.psi &lt;- estTransition(isGL=OVENdata$isGL,
                          isTelemetry = !OVENdata$isGL,
                  geoBias = OVENdata$geo.bias, # Light-level GL location bias
                  geoVCov = OVENdata$geo.vcov, # Location covariance matrix
                  targetSites = OVENdata$targetSites, # Nonbreeding/target sites
                  originSites = OVENdata$originSites, # Breeding/origin sites
                  originPoints = OVENdata$originPoints, # Capture Locations
                  targetPoints = OVENdata$targetPoints, #Device target locations
                  verbose = 2,   # output options
                  nSamples = nSamplesGLGPS, # This is set low for example
                  resampleProjection = sf::st_crs(OVENdata$targetPoints))

  print(Combined.psi)

  # For treating all data as GPS,
  # Move the latitude of birds with locations that fall offshore
  int &lt;- sf::st_intersects(OVENdata$targetPoints, OVENdata$targetSites)
  any(lengths(int)&lt;1)
  plot(OVENdata$targetPoints)
  plot(OVENdata$targetSites,add=TRUE)
  tp&lt;-sf::st_coordinates(OVENdata$targetPoints)
  text(tp[,1], tp[,2], label=c(1:39))

  tp[5,2] &lt;- 2450000
  tp[10,2]&lt;- 2240496
  tp[1,2]&lt;- 2240496
  tp[11,2]&lt;- 2026511
  tp[15,2]&lt;- 2031268
  tp[16,2]&lt;- 2031268

  oven_targetPoints&lt;-sf::st_as_sf(as.data.frame(tp),
                                  coords = c("X","Y"),
                                  crs = sf::st_crs(OVENdata$targetPoints))
  inter &lt;- sf::st_intersects(oven_targetPoints, OVENdata$targetSites)
  any(lengths(inter)&lt;1)
  plot(oven_targetPoints,add=TRUE, col = "green")
  plot(oven_targetPoints[lengths(inter)&lt;1,],add=TRUE, col = "darkblue")

  # Treat all data as GPS
  GPS_psi &lt;- estTransition(isTelemetry = TRUE,
                targetSites = OVENdata$targetSites, # Non-breeding/target sites
                originSites = OVENdata$originSites, # Breeding/origin sites
                originPoints = OVENdata$originPoints, # Capture Locations
                targetPoints = oven_targetPoints, # Device target locations
                verbose = 2,   # output options
                nSamples = nSamplesGLGPS) # This is set low for example



  ##############################################################################
  # Example 3 (all released origin; some telemetry, some GL, some probability
  # tables, some both GL and probability tables; data modified from ovenbird
  # example)
  ##############################################################################
  library(VGAM)
  nAnimals &lt;- 40
  isGL &lt;- c(OVENdata$isGL, FALSE)
  isTelemetry &lt;- c(!OVENdata$isGL, FALSE)
  isRaster &lt;- rep(FALSE, nAnimals)
  isProb &lt;- rep(FALSE, nAnimals)
  targetPoints &lt;- rbind(OVENdata$targetPoints, OVENdata$targetPoints[1,])
  targetSites &lt;- OVENdata$targetSites
  originSites &lt;- OVENdata$originSites
  resampleProjection &lt;- sf::st_crs(OVENdata$targetPoints)
  targetNames &lt;- OVENdata$targetNames
  originNames &lt;- OVENdata$originNames
  targetAssignment &lt;- array(0, dim = c(nAnimals, 3),
                            dimnames = list(NULL, targetNames))
  assignment0 &lt;- unclass(sf::st_intersects(x = targetPoints, y = targetSites,
                                           sparse = TRUE))
  assignment0[sapply(assignment0, function(x) length(x)==0)] &lt;- 0
  assignment0 &lt;- array(unlist(assignment0), nAnimals)
  for (ani in 1:nAnimals) {
    if (assignment0[ani]&gt;0)
      targetAssignment[ani, assignment0[ani]] &lt;- 1
    else{
      targetAssignment[ani, ] &lt;- rdiric(1, c(15, 1, 1))
      isProb[ani] &lt;- TRUE
    }
  }
  targetAssignment
  isProb
  nSamplesTry &lt;- 100 # Number of bootstrap iterations
  originPoints &lt;- rbind(OVENdata$originPoints,
                        OVENdata$originPoints[39,])
  system.time(psi3 &lt;-
                estTransition(isGL = isGL, isRaster = isRaster,
                              isProb = isProb,
                              isTelemetry = isTelemetry,
                              geoBias = OVENdata$geo.bias,
                              geoVCov = OVENdata$geo.vcov,
                              targetPoints = targetPoints,
                              targetAssignment = targetAssignment,
                              targetSites = targetSites,
                              resampleProjection = resampleProjection,
                              nSim = 20000, maxTries = 300,
                              originSites = originSites,
                              originPoints = originPoints,
                              captured = "origin",
                              originNames = OVENdata$originNames,
                              targetNames = OVENdata$targetNames,
                              verbose = 3,
                              nSamples = nSamplesTry))
  psi3

  nNonBreeding &lt;- nrow(OVENdata$targetSites)

  plot(psi3, legend = "top",
       main = paste("OVENlike w/", sum(isGL &amp; !isProb), "GL,",
                    sum(!isGL &amp; isProb), "probs,",
                    sum(isGL &amp; isProb), "both, and", sum(isTelemetry), "GPS"))

  ##############################################################################
  # Example 4 (add probability animals released on other end)
  ##############################################################################
  nAnimals &lt;- 45
  captured &lt;- rep(c("origin", "target"), c(40, 5))
  isGL &lt;- c(OVENdata$isGL, rep(FALSE, 6))
  isTelemetry &lt;- c(!OVENdata$isGL, rep(FALSE, 6))
  isRaster &lt;- rep(FALSE, nAnimals)
  isProb &lt;- rep(FALSE, nAnimals)
  targetPoints &lt;- rbind(OVENdata$targetPoints,
                        OVENdata$targetPoints[c(1:3,19,23,31),])
  targetAssignment &lt;- array(0, dim = c(nAnimals, 3),
                            dimnames = list(NULL, targetNames))
  assignment0 &lt;- unclass(sf::st_intersects(x = targetPoints, y = targetSites,
                                           sparse = TRUE))
  assignment0[sapply(assignment0, function(x) length(x)==0)] &lt;- 0
  assignment0 &lt;- array(unlist(assignment0), nAnimals)
  for (ani in 1:nAnimals) {
    if (assignment0[ani]&gt;0)
      targetAssignment[ani, assignment0[ani]] &lt;- 1
    else{
      targetAssignment[ani, ] &lt;- rdiric(1, c(15, 1, 1))
      isProb[ani] &lt;- TRUE
    }
  }
  targetAssignment
  isProb
  originPoints &lt;- rbind(OVENdata$originPoints,
                        OVENdata$originPoints[34:39,])

  originPoints &lt;- sf::st_transform(originPoints, crs = resampleProjection)
  originSites &lt;- sf::st_transform(OVENdata$originSites,
                                  crs = resampleProjection)

  assignment1 &lt;- unclass(sf::st_intersects(x = originPoints, y = originSites,
                                           sparse = TRUE))
  assignment1[sapply(assignment1, function(x) length(x)==0)] &lt;- 0
  assignment1 &lt;- array(unlist(assignment1), nAnimals)

  nOriginSites &lt;- nrow(originSites)

  originAssignment &lt;- array(0, dim = c(nAnimals, nOriginSites),
                            dimnames = list(NULL, originNames))
  for (ani in 1:40) {
    originAssignment[ani, assignment1[ani]] &lt;- 1
  }
  for (ani in 41:nAnimals) {
    originAssignment[ani, ] &lt;- rdiric(1, c(1, 1))
    isProb[ani] &lt;- TRUE
  }
  originAssignment
  isProb
  system.time(psi4 &lt;-
                estTransition(isGL = isGL, isRaster = isRaster,
                              isProb = isProb,
                              isTelemetry = isTelemetry,
                              geoBias = OVENdata$geo.bias,
                              geoVCov = OVENdata$geo.vcov,
                              targetPoints = targetPoints,
                              targetAssignment = targetAssignment,
                              targetSites = targetSites,
                              resampleProjection = resampleProjection,
                              nSim = 15000, maxTries = 300,
                              originSites = originSites,
                              originAssignment = originAssignment,
                              captured = captured,
                              originNames = OVENdata$originNames,
                              targetNames = OVENdata$targetNames,
                              verbose = 2,
                              nSamples = nSamplesTry,
                              targetRelAbund = c(0.1432, 0.3577, 0.4991)))
  psi4

  plot(psi4, legend = "top",
       main = paste(sum(isGL &amp; !isProb), "GL,",
                    sum(!isGL &amp; isProb &amp; captured == "origin"), "prob.,",
                    sum(isGL &amp; isProb), "both,",
                    sum(isTelemetry), "GPS (all\ncaptured origin), and",
                    sum(isProb &amp; captured == "target"),
                    "prob. (captured target)"))
  MC4 &lt;- estStrength(OVENdata$originDist, OVENdata$targetDist,
                                       OVENdata$originRelAbund, psi4,
                                       sampleSize = nAnimals)
  MC4

  ##############################################################################
  # Example 5 (all raster, from our OVEN example)
  ##############################################################################
  getCSV &lt;- function(filename) {
    tmp &lt;- tempdir()
    url1 &lt;- paste0(
      'https://github.com/SMBC-NZP/MigConnectivity/blob/master/data-raw/',
                   filename, '?raw=true')
    temp &lt;- paste(tmp, filename, sep = '/')
    utils::download.file(url1, temp, mode = 'wb')
    csv &lt;- read.csv(temp)
    unlink(temp)
    return(csv)

  }

  getRDS &lt;- function(speciesDist) {
    tmp &lt;- tempdir()
    extension &lt;- '.rds'
    filename &lt;- paste0(speciesDist, extension)
    url1 &lt;- paste0(
      'https://github.com/SMBC-NZP/MigConnectivity/blob/master/data-raw/Spatial_Layers/',
                   filename, '?raw=true')
    temp &lt;- paste(tmp, filename, sep = '/')
    utils::download.file(url1, temp, mode = 'wb')
    shp &lt;- readRDS(temp)
    unlink(temp)
    return(shp)
  }
  OVENdist &lt;- getRDS("OVENdist")

  OVENdist &lt;- sf::st_as_sf(OVENdist)

  OVENdist &lt;- sf::st_transform(OVENdist, 4326)

  OVENvals &lt;- getCSV("deltaDvalues.csv")

  OVENvals &lt;- OVENvals[grep(x=OVENvals$Sample,"NH", invert = TRUE),]

  originSites &lt;- getRDS("originSites")
  originSites &lt;- sf::st_as_sf(originSites)

  EVER &lt;- length(grep(x=OVENvals$Sample,"EVER"))
  JAM &lt;- length(grep(x=OVENvals$Sample,"JAM"))

  originRelAbund &lt;- matrix(c(EVER,JAM),nrow = 1,byrow = TRUE)
  originRelAbund &lt;- prop.table(originRelAbund,1)

  op &lt;- sf::st_centroid(originSites)

  originPoints &lt;- array(NA,c(EVER+JAM,2), list(NULL, c("x","y")))
  originPoints[grep(x = OVENvals$Sample,"JAM"),1] &lt;- sf::st_coordinates(op)[1,1]
  originPoints[grep(x = OVENvals$Sample,"JAM"),2] &lt;- sf::st_coordinates(op)[1,2]
  originPoints[grep(x = OVENvals$Sample,"EVER"),1]&lt;-sf::st_coordinates(op)[2,1]
  originPoints[grep(x = OVENvals$Sample,"EVER"),2]&lt;-sf::st_coordinates(op)[2,2]

  originPoints &lt;- sf::st_as_sf(data.frame(originPoints),
                               coords = c("x", "y"),
                               crs = sf::st_crs(originSites))

  iso &lt;- isoAssign(isovalues = OVENvals[,2],
                   isoSTD = 12,       # this value is for demonstration only
                   intercept = -10,   # this value is for demonstration only
                   slope = 0.8,       # this value is for demonstration only
                   odds = NULL,
                   restrict2Likely = FALSE,
                   nSamples = 1000,
                   sppShapefile = terra::vect(OVENdist),
                   assignExtent = c(-179,-60,15,89),
                   element = "Hydrogen",
                   period = "GrowingSeason",#this setting for demonstration only
                   seed = 12345,
                   verbose=1)


  nAnimals &lt;- dim(iso$probassign)[3]
  isGL &lt;-rep(FALSE, nAnimals); isRaster &lt;- rep(TRUE, nAnimals)
  isProb &lt;- rep(FALSE, nAnimals); isTelemetry &lt;- rep(FALSE, nAnimals)
  targetSites &lt;- sf::st_as_sf(iso$targetSites)
  targetSites &lt;- sf::st_make_valid(targetSites)
  targetSites &lt;- sf::st_union(targetSites, by_feature = TRUE)


  system.time(psi5 &lt;-
                estTransition(isGL = isGL,
                              isRaster = isRaster,
                              isProb = isProb,
                              isTelemetry = isTelemetry,
                              targetSites = targetSites,
                              resampleProjection = resampleProjection,
                              targetRaster = iso,
                              originSites = originSites,
                              originPoints = originPoints,
                              captured = rep("origin", nAnimals),
                              verbose = 2,
                              nSamples = nSamplesTry))
  psi5

</code></pre>

<hr>
<h2 id='getCMRexample'>Grab (from https://github.com/SMBC-NZP/MigConnectivity) example RMark
transition probability estimates obtained from simulated data</h2><span id='topic+getCMRexample'></span>

<h3>Description</h3>

<p>Get a dataset containing RMark transition probability estimates from
simulated mark-recapture-recovery data from Cohen et al. (2014).  These all
represent the intermediate scenario for all settings (moderate connectivity,
low re-encounter, 100,000 banded in each breeding area).  Each estimate can
be used in <code>estMC</code> function to estimate MC with uncertainty.  Requires
internet connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCMRexample(number = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCMRexample_+3A_number">number</code></td>
<td>
<p>Integer 1 - 100, which simulation and RMark estimate you want</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RMark object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estMC">estMC</a></code>
</p>

<hr>
<h2 id='getIsoMap'>Get Isoscape map
getIsoMap</h2><span id='topic+getIsoMap'></span>

<h3>Description</h3>

<p>The <code>getIsoMap</code> function downloads predicted isoscape maps from
<a href="https://wateriso.utah.edu/waterisotopes/">https://wateriso.utah.edu/waterisotopes/</a>. The function first checks
whether the isoscapes are located within the directory
<code>mapDirectory</code>. If a local copy of the isoscape is found, it's read into
the environment. If not, the isoscape is downloaded and imported
as a raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIsoMap(
  element = "Hydrogen",
  surface = FALSE,
  period = "Annual",
  mapDirectory = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getIsoMap_+3A_element">element</code></td>
<td>
<p>The elemental isotope of interest. Currently the only
elements that are implemented are 'Hydrogen' (default) and 'Oxygen'</p>
</td></tr>
<tr><td><code id="getIsoMap_+3A_surface">surface</code></td>
<td>
<p>DEPRECATED function no longer returns surface water values.
Default is 'FALSE' which returns the precipitation isotopes ratio.</p>
</td></tr>
<tr><td><code id="getIsoMap_+3A_period">period</code></td>
<td>
<p>The time period of interest. If 'Annual' (default) returns a
raster of mean annual values in precipitation for the <code>element</code>. If
'GrowingSeason' returns growing season values in precipitation for
<code>element</code> of interest.</p>
</td></tr>
<tr><td><code id="getIsoMap_+3A_mapdirectory">mapDirectory</code></td>
<td>
<p>Directory to save/read isotope map from. Can use relative
or absolute addressing. The default value (NULL) downloads to a temporary
directory, so we strongly recommend changing this from the default unless
you're sure you're not going to need these data more than once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a global <code>RasterLayer</code> (resolution = 0.333'x0.3333')
object for the <code>element</code> and <code>period</code> of interest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  map &lt;- getIsoMap(element = "Hydrogen", period = "GrowingSeason")

</code></pre>

<hr>
<h2 id='isoAssign'>Generate probabilistic isotope assignments</h2><span id='topic+isoAssign'></span>

<h3>Description</h3>

<p>The <code>isoAssign</code> function generates origin assignments using
stable-hydrogen isotopes in tissue. The function generates a probability
surface of origin assignment from a vector of stable-isotope values for each
animal/sample of interest. Probabilistic assignments are constructed by first
converting observed stable-isotope ratios (isoscape) in either precipitation
or surface waters into a 'tissuescape' using a user-provided intercept, slope
and standard deviation. See
<a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0035137">Hobson et. al. (2012)</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isoAssign(
  isovalues,
  isoSTD,
  intercept,
  slope,
  odds = 0.67,
  restrict2Likely = TRUE,
  nSamples = NULL,
  sppShapefile = NULL,
  relAbund = NULL,
  isoWeight = NULL,
  abundWeight = NULL,
  population = NULL,
  assignExtent = c(-179, -60, 15, 89),
  element = "Hydrogen",
  surface = FALSE,
  period = "Annual",
  seed = NULL,
  verbose = 1,
  generateSingleCell = FALSE,
  mapDirectory = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isoAssign_+3A_isovalues">isovalues</code></td>
<td>
<p>vector of tissue isotope values</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_isostd">isoSTD</code></td>
<td>
<p>standard deviation from calibration</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_intercept">intercept</code></td>
<td>
<p>intercept value from calibration</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_slope">slope</code></td>
<td>
<p>value from calibration</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_odds">odds</code></td>
<td>
<p>odds ratio to use to set likely and unlikely locations defaults
to 0.67</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_restrict2likely">restrict2Likely</code></td>
<td>
<p>if <code>TRUE</code> restricts locations to fall within the
'likely' assignment locations</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_nsamples">nSamples</code></td>
<td>
<p>integer specifying how many random samples to draw from a
multinomial distribution.</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_sppshapefile">sppShapefile</code></td>
<td>
<p>A polygon spatial layer (sf - MULTIPOLYGON) defining
species range. Assignments are restricted to these areas.</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_relabund">relAbund</code></td>
<td>
<p>raster (<code>SpatRast</code>) with relative abundance (must match
extent of isotope assignment)</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_isoweight">isoWeight</code></td>
<td>
<p>weighting value to apply to isotope assignment</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_abundweight">abundWeight</code></td>
<td>
<p>weighting value to apply to relative abundance prior</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_population">population</code></td>
<td>
<p>vector identifying location where animal was captured.
Same order as <code>isovalues</code></p>
</td></tr>
<tr><td><code id="isoAssign_+3A_assignextent">assignExtent</code></td>
<td>
<p>definition for the extent of the assignment. Can be used
in place of <code>sppShapefile</code> to limit assignment. Input should
follow <code>c(xmin,xmax,ymin,ymax)</code> in degrees longitude and
latitude</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_element">element</code></td>
<td>
<p>The elemental isotope of interest. Currently the only
elements that are implemented are 'Hydrogen' (default) and 'Oxygen'</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_surface">surface</code></td>
<td>
<p>DEPRECATED function no longer returns surface water values.
Default is 'FALSE' which returns the precipitation isotopes ratio.</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_period">period</code></td>
<td>
<p>The time period of interest. If 'Annual' returns a raster
of mean annual values in precipitation for the <code>element</code>. If
'GrowingSeason' returns growing season values in precipitation for
<code>element</code> of interest</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_seed">seed</code></td>
<td>
<p>numeric value fed to <code>set.seed</code> for random number
generation. Default = NULL</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_verbose">verbose</code></td>
<td>
<p>takes values 0, 1 (default) or 2. 0 prints no output during
run. 1 prints a message detailing where in the process the function
is. 2 prints the animal currently being sampled.</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_generatesinglecell">generateSingleCell</code></td>
<td>
<p>if 'TRUE' generates a single origin location using
the posterior assignment distribution - this takes a while to run.
If 'FALSE' (default), no coordinates are generated.</p>
</td></tr>
<tr><td><code id="isoAssign_+3A_mapdirectory">mapDirectory</code></td>
<td>
<p>Directory to save/read isotope map from. Can use relative
or absolute addressing. The default value (NULL) downloads to a temporary
directory, so we strongly recommend changing this from the default unless
you're sure you're not going to need these data more than once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an <code>isoAssign</code> object containing the following:
</p>

<dl>
<dt><code>probassign</code></dt><dd><p>SpatRast stack of individual probabilistic assignments</p>
</dd>
<dt><code>oddsassign</code></dt><dd><p>SpatRast stack that includes likely vs unlikely origin for each animal</p>
</dd>
<dt><code>popassign</code></dt><dd><p>a SpatRast for population level assignment (sum of <code>oodsassign</code> if <code>population</code> = NULL).
If <code>population</code> is a vector then returns a raster stack for each unique <code>population</code> provided</p>
</dd>
<dt><code>probDF</code></dt><dd><p>data.frame of individual probability surfaces</p>
</dd>
<dt><code>oddsDF</code></dt><dd><p>data.frame of likely vs unlikely surfaces</p>
</dd>
<dt><code>popDF</code></dt><dd><p>data.frame of population level assignment</p>
</dd>
<dt><code>SingeCell</code></dt><dd><p>array of coordinates (longitude,latitude) for
single cell assignment</p>
</dd>
<dt><code>targetSites</code></dt><dd><p><code>sf - MULTIPOLYGON</code> layer representing
isotope bands equivalent to <code>isoSTD</code></p>
</dd>
<dt><code>RandomSeed</code></dt><dd><p>the RNG seed used when generating locations from
the multinomial distribution</p>
</dd>
</dl>



<h3>References</h3>

<p>Cohen, E. B., C. S. Rushing, F. R. Moore, M. T. Hallworth, J. A. Hostetler,
M. Gutierrez Ramirez, and P. P. Marra. 2019. The strength of
migratory connectivity for birds en route to breeding through the Gulf of
Mexico. Ecography 42: 658-669.
</p>
<p>Hobson, K. A., S. L. Van Wilgenburg, L. I. Wassenaar, and K. Larson. 2012.
Linking hydrogen isotopes in feathers and precipitation: sources of
variance and consequences for assignment to isoscapes. PLoS ONE 7: e35137.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weightAssign">weightAssign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
extensions &lt;- c("shp", "shx", "dbf", "sbn", "sbx")
tmp &lt;- tempdir()
for (ext in extensions) {
download.file(paste0(
              "https://raw.githubusercontent.com/SMBC-NZP/MigConnectivity",
                     "/master/data-raw/Spatial_Layers/OVENdist.",
                     ext),
              destfile = paste0(tmp, "/OVENdist.", ext), mode = "wb")
}
OVENdist &lt;- sf::st_read(paste0(tmp, "/OVENdist.shp"))
OVENdist &lt;- OVENdist[OVENdist$ORIGIN==2,] # only breeding
sf::st_crs(OVENdist) &lt;- sf::st_crs(4326)

download.file(paste0(
  "https://raw.githubusercontent.com/SMBC-NZP/MigConnectivity",
                     "/master/data-raw/deltaDvalues.csv"),
              destfile = paste0(tmp, "/deltaDvalues.csv"))
OVENvals &lt;- read.csv(paste0(tmp, "/deltaDvalues.csv"))


a &lt;- Sys.time()
b &lt;- isoAssign(isovalues = OVENvals[,2],
              isoSTD = 12,
              intercept = -10,
              slope = 0.8,
              odds = NULL,
              restrict2Likely = TRUE,
              nSamples = 1000,
              sppShapefile = OVENdist,
              assignExtent = c(-179,-60,15,89),
              element = "Hydrogen",
              period = "GrowingSeason") # this setting for demonstration only
Sys.time()-a


</code></pre>

<hr>
<h2 id='MigConnectivity'>MigConnectivity: A package for quantifying migratory connectivity pattern and
strength for migratory animals</h2><span id='topic+MigConnectivity'></span>

<h3>Description</h3>

<p>The MigConnectivity package allows the user to estimate or calculate
transition probabilities for migratory animals between any two phases of the
annual cycle, using a variety of different data types, with the function
<code><a href="#topic+estTransition">estTransition</a></code>. The user can also estimate or calculate the
strength of migratory connectivity (MC), a standardized metric to quantify
the extent to which populations co-occur between two phases of the annual
cycle. MC is independent of data type and accounts for the relative abundance
of populations distributed across a seasonal range. The package includes
functions to estimate MC (<code><a href="#topic+estStrength">estStrength</a></code>) and the more traditional
metric of migratory connectivity strength (Mantel correlation; rM;
<code><a href="#topic+estMantel">estMantel</a></code>) incorporating uncertainty from multiple
sources of sampling error. Description of the MC metric can be found in Cohen
et al. (2018).
</p>


<h3>Key MigConnectivity Functions</h3>

<p><code><a href="#topic+estTransition">estTransition</a></code>: Estimate psi (transition probabilities between
locations in two phases of the annual cycle)
</p>
<p><code><a href="#topic+estStrength">estStrength</a></code>: Estimate MC, migratory connectivity strength
</p>

<hr>
<h2 id='modelCountDataJAGS'>Estimates population-level relative abundance from count data</h2><span id='topic+modelCountDataJAGS'></span>

<h3>Description</h3>

<p>Uses a Bayesian hierarchical model to estimate relative abundance of regional
populations from count-based data (e.g., Breeding Bird Survey)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelCountDataJAGS(count_data, ni = 20000, nt = 5, nb = 5000, nc = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelCountDataJAGS_+3A_count_data">count_data</code></td>
<td>
<p>List containing the following elements:
' </p>

<dl>
<dt><code>C</code></dt><dd><p>nYears by nRoutes matrix containing the observed number of individuals counted at each route in each year.</p>
</dd>
<dt><code>strat</code></dt><dd><p>Vector of length nRoutes indicating the population/region in which each route is located.</p>
</dd>
<dt><code>routesPerStrata</code></dt><dd><p>Vector of length 1 or nStrata containing the number of routes (i.e. counts) per population. If length(routesPerStrata) == 1, number of routes is identical for each population.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="modelCountDataJAGS_+3A_ni">ni</code></td>
<td>
<p>Number of MCMC iterations. Default = 20000.</p>
</td></tr>
<tr><td><code id="modelCountDataJAGS_+3A_nt">nt</code></td>
<td>
<p>Thinning rate. Default = 5.</p>
</td></tr>
<tr><td><code id="modelCountDataJAGS_+3A_nb">nb</code></td>
<td>
<p>Number of MCMC iterations to discard as burn-in. Default = 5000.</p>
</td></tr>
<tr><td><code id="modelCountDataJAGS_+3A_nc">nc</code></td>
<td>
<p>Number of chains. Default = 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>modelCountDataJAGS</code> returns an mcmc object containing posterior samples for each monitored parameter.
</p>


<h3>References</h3>

<p>Cohen, E. B., J. A. Hostetler, M. T. Hallworth, C. S. Rushing, T. S. Sillett,
and P. P. Marra. 2018. Quantifying the strength of migratory connectivity.
Methods in Ecology and Evolution 9: 513-524.
<a href="https://doi.org/10.1111/2041-210X.12916">doi:10.1111/2041-210X.12916</a>
</p>
<p>Link, W. A. and J. R. Sauer. 2002. A hierarchical analysis of population
change with application to Cerulean Warblers. Ecology 83: 2832-2840.
<a href="https://doi.org/10.1890/0012-9658%282002%29083%5B2832%3AAHAOPC%5D2.0.CO%3B2">doi:10.1890/0012-9658(2002)083[2832:AHAOPC]2.0.CO;2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(150)

### Set parameters for simulation ----

# Number of populations
nStrata. &lt;- 4
# Number of routes w/i each population (assumed to be balanced)
routePerStrat. &lt;- 30 # reduced from 90 for example speed
# Number of years
nYears. &lt;- 5 # reduced from 10 for example speed
# log(Expected number of birds counted at each route)
alphaStrat. &lt;- 1.95
# standard deviation of normal distribution assumed for route/observer random
# effects
sdRoute. &lt;- 0.6
# standard deviation of normal distribution assumed for year random effects
sdYear. &lt;- 0.18


# Number of simulated datasets to create and model
nsims &lt;- 50 # reduced from 100 for example speed
# Number of MCMC iterations
ni. &lt;- 1000 # reduced from 15000 for example speed
# Number of iterations to thin from posterior (reduced from 5)
nt. &lt;- 1
# Number of iterations to discard as burn-in
nb. &lt;- 500 # reduced from 5000 for example speed
# Number of MCMC chains
nc. &lt;- 1 # reduced from 3 for example speed

### Create empty matrix to store model output ---
sim_in &lt;- vector("list", nsims)
sim_out &lt;- vector("list", nsims)


# Simulation ---

system.time(for(s in 1:nsims){
  cat("Simulation",s,"of",nsims,"\n")

  # Simulate data
  sim_data &lt;- simCountData(nStrata = nStrata., routesPerStrata = routePerStrat.,
                           nYears = nYears., alphaStrat = alphaStrat.,
                           sdRoute = sdRoute., sdYear = sdYear.)
  sim_in[[s]] &lt;- sim_data


  # Estimate population-level abundance
  out_mcmc &lt;- modelCountDataJAGS(count_data = sim_data, ni = ni., nt = nt.,
                                 nb = nb., nc = nc.)

  # Store model output
  sim_out[[s]] &lt;- out_mcmc
  remove(out_mcmc)

})


### Check that relative abundance is, on average, equal for each population
prop.table(sapply(sim_in, function(x) return(rowsum(colSums(x$C), x$strat))), 2)

rel_names &lt;- paste0('relN[', 1:nStrata., ']')
rel_abund1 &lt;- data.frame(sim=1:nsims,
                         ra1.mean=NA, ra2.mean=NA, ra3.mean=NA, ra4.mean=NA,
                         ra1.low=NA, ra2.low=NA, ra3.low=NA, ra4.low=NA,
                         ra1.high=NA, ra2.high=NA, ra3.high=NA, ra4.high=NA,
                         ra1.cover=0, ra2.cover=0, ra3.cover=0, ra4.cover=0)
for (s in 1:nsims) {
  rel_abund1[s, 2:5] &lt;- summary(sim_out[[s]])$statistics[rel_names, "Mean"]
  rel_abund1[s, 6:9] &lt;- summary(sim_out[[s]])$quantiles[rel_names, 1]
  rel_abund1[s, 10:13] &lt;- summary(sim_out[[s]])$quantiles[rel_names, 5]
}
rel_abund1 &lt;- transform(rel_abund1,
                        ra1.cover = (ra1.low&lt;=0.25 &amp; ra1.high&gt;=0.25),
                        ra2.cover = (ra2.low&lt;=0.25 &amp; ra2.high&gt;=0.25),
                        ra3.cover = (ra3.low&lt;=0.25 &amp; ra3.high&gt;=0.25),
                        ra4.cover = (ra4.low&lt;=0.25 &amp; ra4.high&gt;=0.25))

summary(rel_abund1)


</code></pre>

<hr>
<h2 id='OVENdata'>Ovenbird light-level geolocator and GPS necessary data</h2><span id='topic+OVENdata'></span>

<h3>Description</h3>

<p>Ovenbird data from Cohen et al. (2018) and Hallworth and Marra (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OVENdata
</code></pre>


<h3>Format</h3>

<p>A named list with the necessary data to replicate the analyses
found in Cohen et al. (2018) with archival light-level geolocator and
GPS data.
The data contained in the list are:
</p>

<ul>
<li><p> geo.bias: Archival light-level geolocator bias estimates.
Location bias estimates in light-level geolocator estimates calculated
using birds captured at known locations in Florida, Jamaica and Puerto Rico.
Location bias is reported in meters and is a vector of length two with bias
estimates in geolocator locations.
Format: A vector of length two with bias estimates in geolocator locations.
</p>
</li>
<li><p> geo.vcov: Covariance estimates in light-level geolocator estimates calculated
using birds captured at known locations in Florida, Jamaica, and Puerto Rico.
Covariance is reported in meters.
Format:  A 2x2 matrix of covariance estimates.
</p>
</li>
<li><p> isGL: Archival light-level geolocator or PinPoint-10 GPS tag
<code>logical</code> vector indicating whether location estimates were obtained with a
light-level geolocator (<code>TRUE</code>) or PinPoint-10 GPS tag (<code>FALSE</code>).
Format:  <code>logical</code> of length 39
</p>
</li>
<li><p> targetPoints: Non-breeding locations for 39 Ovenbirds caught during the breeding
season who carried either a light-level geolocator or PinPoint-10 GPS tag.
Ovenbirds were captured at Hubbard Brook Experimental Forest, NH and Jug Bay Wetland
Sanctuary, MD. These data are used as <code>originPoints</code> in the <code>estMC</code> function.
<code>coords.x1</code> and <code>coords.x2</code> represent the longitude and latitude of the
capture sites, respectively. The data are projected in Lambert Conformal Conic.
Format:  <code>SpatialPoints</code>
&quot;+proj=aea +lat_1=20 +lat_2=60 +lat_0=40 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80
+datum=NAD83 +units=m +no_defs +towgs84=0,0,0&quot;
</p>
</li>
<li><p> originPoints: Capture locations for 39 Ovenbirds caught during the breeding season
who carried either a light-level geolocator or PinPoint-10 GPS tag. Ovenbirds were
captured at Hubbard Brook Experimental Forest, NH and Jug Bay Wetland Sanctuary, MD.
These data are used as <code>originPoints</code> in the <code>estMC</code> function. <code>coords.x1</code>
and <code>coords.x2</code> represent the longitude and latitude of the capture sites, respectively.
The data are projected in Lambert Conformal Conic.
Format:  <code>SpatialPoints</code>
</p>
</li>
<li><p> targetSites: Non-breeding distribution target sites used in Cohen et al. (in prep) to
estimate MC of Ovenbirds tracked with light-level geolocators and PinPoint-10 GPS tags.
There are three non-breeding target sites 1) Florida, United States, 2) Cuba, and 3) Hispaniola
(Dominican Republic and Haiti).
Format:  <code>SpatialPolygons</code>
</p>
</li>
<li><p> originSites: Breeding distribution origin sites used in Cohen et al. (in prep) to estimate
MC of Ovenbirds tracked with light-level geolocators and PinPoint-10 GPS tags. There are two breeding
origin sites, one that encompasses NH and another that encompasses MD capture deployment locations.
Format: <code>SpatialPolygons</code>
</p>
</li>
<li><p> originRelAbund: A dataset containing relative abundance estimates from BBS data reported in Cohen et al.
(in prep). These estimates can be used in <code>estMC</code> function as <code>originRelAbund</code> in conjunction
with archival light-level geolocator and GPS locations.
Format: A vector of length two with relative abundance estimates.
</p>
</li>
<li><p> originDist: The pairwise Great Circle Distance between the center of the polygons contained within
<code>originSites</code>. See &quot;Ovenbird breeding distribution origin sites&quot; or <code>originSites</code>.
Format: square distance matrix
</p>
</li>
<li><p> targetDist: The pairwise Great Circle Distance between the center of the polygons contained within
<code>targetSites</code>. See &quot;Ovenbird non-breeding distribution target sites&quot; or <code>targetSites</code>.
Format: square distance matrix
</p>
</li></ul>


<hr>
<h2 id='plot.estMigConnectivity'>Basic plot function for estMigConnectivity objects</h2><span id='topic+plot.estMigConnectivity'></span>

<h3>Description</h3>

<p>Basic plot function for estMigConnectivity objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estMigConnectivity'
plot(
  x,
  plot.which = ifelse(inherits(x, "estPsi"), "psi", ifelse(inherits(x, "estMC"), "MC",
    ifelse(inherits(x, "estGamma"), "gamma", "rM"))),
  point = c("mean", "median", "point"),
  range = c("simpleCI", "bcCI", "se"),
  xlab = NULL,
  ylab = plot.which,
  originNames = NULL,
  targetNames = NULL,
  ageNames = NULL,
  col = NULL,
  pch = NULL,
  las = 1,
  gap = 0,
  sfrac = ifelse(range == "se", 0.01, 0),
  legend = FALSE,
  map = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.estMigConnectivity_+3A_x">x</code></td>
<td>
<p>an estMigConnectivity object (output of estTransition, estStrength,
estMC, or estMantel)</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_plot.which">plot.which</code></td>
<td>
<p>which parameter (psi, MC, rM, or r) to graph. Defaults to
psi for estMC objects, to rM (Mantel correlation) otherwise</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_point">point</code></td>
<td>
<p>points on graph can represent mean, median, or point estimates
(not considering error). Defaults to mean, the standard estimate from
resampling</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_range">range</code></td>
<td>
<p>lines / error bars drawn around points can represent simple
quantile-based confidence intervals (simpleCI), bias-corrected quantile-
based confidence intervals (bcCI), or +- standard error (se). Defaults to
simpleCI</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis. Defaults to &quot;Origin&quot; for psi, otherwise &quot;&quot;</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis. Defaults to the parameter being plotted</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_originnames">originNames</code></td>
<td>
<p>names of the origin sites (for plotting psi). If left
NULL, the function attempts to get these from the estimate</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_targetnames">targetNames</code></td>
<td>
<p>names of the target sites (for plotting psi or r). If left
NULL, the function attempts to get these from the estimate</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_agenames">ageNames</code></td>
<td>
<p>names of the age classes (for plotting r with more than one
age). If left NULL, the function uses 1:[number of ages]</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_col">col</code></td>
<td>
<p>colors to use for labeling transition probabilities for
different target sites. If left NULL, defaults to 1:[number of target sites]</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_pch">pch</code></td>
<td>
<p>symbols to use for labeling transition probabilities for
different target sites. If left NULL, defaults to 21:25, then
0:([number of target sites]-5)</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_las">las</code></td>
<td>
<p>style of axis labels (0-3). We set the default at 1 (always
horizontal) here, but if you prefer your labels parallel to the axis, set
at 0</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_gap">gap</code></td>
<td>
<p>space left between the center of the error bar and the lines
marking the error bar in units of the height (width) of the letter &quot;O&quot;.
Defaults to 0</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_sfrac">sfrac</code></td>
<td>
<p>width of &quot;crossbar&quot; at the end of error bar as a fraction of the
x plotting region. Defaults to 0, unless range is set to &quot;se&quot;, in which
case it defaults to 0.01</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_legend">legend</code></td>
<td>
<p>leave as FALSE to not print a legend. Otherwise the position
of the legend (for psi or r (multi-age) only; one of &quot;bottomright&quot;,
&quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot;, or
&quot;center&quot;)</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_map">map</code></td>
<td>
<p>placeholder for eventually allowing users to plot psi estimates
on a map</p>
</td></tr>
<tr><td><code id="plot.estMigConnectivity_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>plotCI</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to generate plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estMC">estMC</a></code>, <code><a href="#topic+estMantel">estMantel</a></code>
</p>

<hr>
<h2 id='plot.intrinsicAssign'>Basic plot function for the different isoAssign outputs</h2><span id='topic+plot.intrinsicAssign'></span>

<h3>Description</h3>

<p>Generates a basic plot of the isotope assignments. If
<code>map = 'population'</code> generates a single map. If
<code>map = 'probability' or map = 'odds'</code> generates a map for each
individual is generated. User is asked for input before each individual is
drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intrinsicAssign'
plot(x, map, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.intrinsicAssign_+3A_x">x</code></td>
<td>
<p>an isoAssign object</p>
</td></tr>
<tr><td><code id="plot.intrinsicAssign_+3A_map">map</code></td>
<td>
<p>which <code>isoAssign</code> output to plot either 'probability', 'population' or 'odds'</p>
</td></tr>
<tr><td><code id="plot.intrinsicAssign_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to generate plot(s).
</p>


<h3>See Also</h3>

<p><code>isoAssign</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  extensions &lt;- c("shp", "shx", "dbf", "sbn", "sbx")
  tmp &lt;- tempdir()
  for (ext in extensions) {
  download.file(paste0(
              "https://raw.githubusercontent.com/SMBC-NZP/MigConnectivity",
                     "/master/data-raw/Spatial_Layers/OVENdist.",
                     ext),
              destfile = paste0(tmp, "/OVENdist.", ext), mode = "wb")
  }
  OVENdist &lt;- sf::st_read(paste0(tmp, "/OVENdist.shp"))
  OVENdist &lt;- OVENdist[OVENdist$ORIGIN==2,] # only breeding
  sf::st_crs(OVENdist) &lt;- sf::st_crs(4326)

  download.file(paste0(
    "https://raw.githubusercontent.com/SMBC-NZP/MigConnectivity",
                     "/master/data-raw/deltaDvalues.csv"),
              destfile = paste0(tmp, "/deltaDvalues.csv"))
  OVENvals &lt;- read.csv(paste0(tmp, "/deltaDvalues.csv"))

  b &lt;- isoAssign(isovalues = OVENvals[,2],
                 isoSTD = 12,
                 intercept = -10,
                 slope = 0.8,
                 odds = NULL,
                 restrict2Likely = TRUE,
                 nSamples = 1000,
                 sppShapefile = OVENdist,
                 assignExtent = c(-179,-60,15,89),
                 element = "Hydrogen",
                 period = "GrowingSeason") # setting for demonstration only

  plot(b, map = "population")


</code></pre>

<hr>
<h2 id='projections'>Map projections</h2><span id='topic+projections'></span>

<h3>Description</h3>

<p>Map projections used when sampling from geolocator bias/error, for
example. The argument <code>resampleProjection</code> in <code>estMC</code> and
<code>estMantel</code> need units = m, which is true of all of these except
WGS84 (the second). First item is Equidistant Conic, which preserves
distances around latitude = 0 and longitude = 0. This is a good general
purpose projection, but the ideal projection may depend on the locations of
your points.  See names in list for suggestions. Other potential projections
can be found at <a href="https://spatialreference.org/ref/">https://spatialreference.org/ref/</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projections
</code></pre>


<h3>Format</h3>

<p>A named list of strings.
</p>

<hr>
<h2 id='reverseTransition'>Reverse transition probabilities and origin relative abundance</h2><span id='topic+reverseTransition'></span><span id='topic+reversePsiRelAbund'></span><span id='topic+reverseTransitionRelAbund'></span><span id='topic+reversePi'></span>

<h3>Description</h3>

<p>Reverse transition probabilities (psi; sum to 1 for each origin site) and
origin relative abundance (originRelAbund; sum to 1 overall) estimates to
calculate or estimate target site to origin site transition probabilities
(gamma; sum to 1 for each target site), target site relative abundances
(targetRelAbund; sum to 1 overall), and origin/target site combination
probabilities (pi; sum to 1 overall). If either psi or originRelAbund is an
estimate with sampling uncertainty expressed, this function will propagate
that uncertainty to provide true estimates of gamma, targetRelAbund, and pi;
otherwise (if both are simple point estimates), it will also provide point
estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverseTransition(
  psi = NULL,
  originRelAbund = NULL,
  pi = NULL,
  originSites = NULL,
  targetSites = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  row0 = 0,
  alpha = 0.05
)

reversePsiRelAbund(
  psi = NULL,
  originRelAbund = NULL,
  pi = NULL,
  originSites = NULL,
  targetSites = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  row0 = 0,
  alpha = 0.05
)

reverseTransitionRelAbund(
  psi = NULL,
  originRelAbund = NULL,
  pi = NULL,
  originSites = NULL,
  targetSites = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  row0 = 0,
  alpha = 0.05
)

reversePi(
  psi = NULL,
  originRelAbund = NULL,
  pi = NULL,
  originSites = NULL,
  targetSites = NULL,
  originNames = NULL,
  targetNames = NULL,
  nSamples = 1000,
  row0 = 0,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverseTransition_+3A_psi">psi</code></td>
<td>
<p>Transition probabilities between B origin and W target sites.
Either a matrix with B rows and W columns where rows sum to 1, an array with
dimensions x, B, and W (with x samples of the transition probability matrix
from another model), an 'estPsi' object (result of calling estTransition),
or a MARK object with estimates of transition probabilities</p>
</td></tr>
<tr><td><code id="reverseTransition_+3A_originrelabund">originRelAbund</code></td>
<td>
<p>Relative abundance estimates at B origin sites. Either
a numeric vector of length B that sums to 1 or an mcmc object with at least
<code>nSamples</code> rows and columns including 'relN[1]' through 'relN[B]'</p>
</td></tr>
<tr><td><code id="reverseTransition_+3A_pi">pi</code></td>
<td>
<p>Migratory combination (joint) probabilities. Either a matrix with B
rows and W columns where all entries sum to 1, an array with dimensions x,
B, and W, or an 'estPi' object (currently only the results of calling this
function) Either pi or psi and originRelAbund should be specified.</p>
</td></tr>
<tr><td><code id="reverseTransition_+3A_originsites">originSites</code></td>
<td>
<p>If <code>psi</code> is a MARK object, this must be a numeric
vector indicating which sites are origin</p>
</td></tr>
<tr><td><code id="reverseTransition_+3A_targetsites">targetSites</code></td>
<td>
<p>If <code>psi</code> is a MARK object, this must be a numeric
vector indicating which sites are target</p>
</td></tr>
<tr><td><code id="reverseTransition_+3A_originnames">originNames</code></td>
<td>
<p>Vector of names for the origin sites. If not provided, the
function will try to get them from psi</p>
</td></tr>
<tr><td><code id="reverseTransition_+3A_targetnames">targetNames</code></td>
<td>
<p>Vector of names for the target sites. If not provided, the
function will try to get them from psi</p>
</td></tr>
<tr><td><code id="reverseTransition_+3A_nsamples">nSamples</code></td>
<td>
<p>Number of times to resample <code>psi</code> and/or
<code>originRelAbund</code>. The purpose is to estimate sampling uncertainty;
higher values here will do so with more precision</p>
</td></tr>
<tr><td><code id="reverseTransition_+3A_row0">row0</code></td>
<td>
<p>If <code>originRelAbund</code> is an mcmc object or array, this can be
set to 0 (default) or any greater integer to specify where to stop ignoring
samples (additional &quot;burn-in&quot;)</p>
</td></tr>
<tr><td><code id="reverseTransition_+3A_alpha">alpha</code></td>
<td>
<p>Level for confidence/credible intervals provided. Default (0.05)
gives 95 percent CI</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alternatively, can be used to reverse migratory combination (joint)
probabilities (pi; sum to 1 overall) to psi, originRelAbund, gamma, and
targetRelAbund.
</p>


<h3>Value</h3>

<p>If both psi and originRelAbund are simple point estimates,
<code>reversePsiRelAbund</code> returns a list with point estimates of gamma,
targetRelAbund, and pi. Otherwise, it returns a list with the elements:
</p>

<dl>
<dt><code>gamma</code></dt><dd><p>List containing estimates of reverse transition
probabilities:
</p>

<ul>
<li><p><code>sample</code> Array of sampled values for gamma. <code>nSamples</code> x
[number of target sites] x [number of origin sites]. Provided to allow
the user to compute own summary statistics.
</p>
</li>
<li><p><code>mean</code> Main estimate of gamma matrix. [number of target sites]
x [number of origin sites].
</p>
</li>
<li><p><code>se</code> Standard error of gamma, estimated from SD of
<code>gamma$sample</code>.
</p>
</li>
<li><p><code>simpleCI</code> <code>1 - alpha</code> confidence interval for gamma,
estimated as <code>alpha/2</code> and <code>1 - alpha/2</code> quantiles of
<code>gamma$sample</code>.
</p>
</li>
<li><p><code>bcCI</code> Bias-corrected <code>1 - alpha</code> confidence interval
for gamma. May be preferable to <code>simpleCI</code> when <code>mean</code> is the
best estimate of gamma. <code>simpleCI</code> is preferred when
<code>median</code> is a better estimator. When the mean and median are equal,
these should be identical.  Estimated as the
<code>pnorm(2 * z0 + qnorm(alpha / 2))</code> and
<code>pnorm(2 * z0 + qnorm(1 - alpha / 2))</code> quantiles of <code>sample</code>,
where z0 is the proportion of <code>sample &lt; mean</code>.
</p>
</li>
<li><p><code>median</code> Median estimate of gamma matrix.
</p>
</li>
<li><p><code>point</code> Simple point estimate of gamma matrix, not accounting
for sampling error.
</p>
</li></ul>

</dd>
<dt><code>targetRelAbund</code></dt><dd><p>List containing estimates of relative
abundance at target sites. Items within are the same as within gamma,
except for having one fewer dimension.</p>
</dd>
<dt><code>pi</code></dt><dd><p>List containing estimates of origin/target site
combination probabilities (sum to 1). Items within are the same as within
gamma, except for reversing dimensions (same order as psi).</p>
</dd>
<dt><code>input</code></dt><dd><p>List containing the inputs to <code>reversePsiRelAbund</code>.</p>
</dd>
</dl>

<p>If the input is pi instead of psi and originRelAbund, then pi is not an
output, but psi and originRelAbund are. Otherwise the same.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: sample psis and relative abundances from Cohen et al. (2018)
## (no uncertainty in psi or relative abundance)
for (i in 1:length(samplePsis)) {
 for (j in 1:length(sampleOriginRelN)){
  cat("For psi:\n")
  print(samplePsis[[i]])
  cat("and origin relative abundance:", sampleOriginRelN[[j]], "\n")
  print(reverseTransition(samplePsis[[i]], sampleOriginRelN[[j]]))
 }
}

## Example 2: Common tern banding example (uncertainty in psi, not relative
## abundance)
# Number of MCMC iterations
ni. &lt;- 1000 # reduced from 70000 for example speed
# Number of iterations to thin from posterior
nt. &lt;- 1
# Number of iterations to discard as burn-in
nb. &lt;- 500 # reduced from 20000 for example speed
# Number of MCMC chains
nc. &lt;- 1 # reduced from 3 for example speed
COTE_banded &lt;- c(10360, 1787, 2495, 336)
COTE_reencountered &lt;- matrix(c(12, 0, 38, 15,
                               111, 7, 6, 2,
                               5, 0, 19, 4,
                               1123, 40, 41, 7),
                             4, 4,
                             dimnames = list(LETTERS[1:4], 1:4))
COTE_psi &lt;- estTransition(originNames = LETTERS[1:4],
                          targetNames = 1:4,
                          banded = COTE_banded,
                          reencountered = COTE_reencountered,
                          verbose = 1,
                          nSamples = (ni. - nb.) / nt. * nc., nBurnin = nb.,
                          nThin = nt., nChains = nc.,
                          method = "MCMC")
COTE_psi
COTE_rev &lt;- reverseTransition(COTE_psi, sampleOriginRelN[[1]],
                               nSamples = 2000)
COTE_rev


## Example 3: Uncertainty in both psi and relative abundance
# Number of populations
nOriginSites &lt;- 3; originNames &lt;- LETTERS[1:nOriginSites]
nTargetSites &lt;- 4; targetNames &lt;- 1:nTargetSites

originRelAbund &lt;- c(1/3, 1/3, 1/3)

psiTrue &lt;- array(0, c(nOriginSites, nTargetSites),
                 list(originNames, targetNames))
psiTrue[1,] &lt;- c(0.22, 0.52, 0.16, 0.10)
psiTrue[2,] &lt;- c(0.41, 0.31, 0.17, 0.11)
psiTrue[3,] &lt;- c(0.10, 0.15, 0.42, 0.33)
rowSums(psiTrue)

rev &lt;- reverseTransition(psiTrue, originRelAbund)

# Simulate abundance data on origin sites
# Number of routes w/i each population (assumed to be balanced)
routePerPop. &lt;- 30 # reduced for example speed
# Number of years
nYears. &lt;- 5 # reduced for example speed
# log(Expected number of birds counted at each route)
alphaPop. &lt;- 1.95
# standard deviation of normal distribution assumed for route/observer random
# effects
sdRoute. &lt;- 0.6
# standard deviation of normal distribution assumed for year random effects
sdYear. &lt;- 0.18
# Number of MCMC iterations
ni. &lt;- 1000 # reduced from 70000 for example speed
# Number of iterations to thin from posterior
nt. &lt;- 1
# Number of iterations to discard as burn-in
nb. &lt;- 500 # reduced from 20000 for example speed
# Number of MCMC chains
nc. &lt;- 1 # reduced from 3 for example speed

sim_data &lt;- simCountData(nStrata = nOriginSites, routesPerStrata = routePerPop.,
                         nYears = nYears., alphaStrat = alphaPop.,
                         sdRoute = sdRoute., sdYear = sdYear.)
# Estimate population-level abundance
out_mcmc &lt;- modelCountDataJAGS(count_data = sim_data, ni = ni., nt = nt.,
                               nb = nb., nc = nc.)

# Simulate movement data
sampleSize &lt;- list(rep(20, nOriginSites), NULL)
captured &lt;- rep("origin", sum(sampleSize[[1]]))
isTelemetry &lt;- rep(TRUE:FALSE, c(sum(sampleSize[[1]]), sum(sampleSize[[2]])))
isProb &lt;- rep(FALSE:TRUE, c(sum(sampleSize[[1]]), sum(sampleSize[[2]])))

# Telemetry data (released origin)
data1 &lt;- simTelemetryData(psi = psiTrue,
                          sampleSize = sampleSize[[1]],
                          captured = "origin")
tt &lt;- data1$targetAssignment
oa &lt;- data1$originAssignment

# Estimate transition probabilities (psi)
est1 &lt;- estTransition(targetAssignment = tt,
                      originAssignment = oa,
                      originNames = originNames,
                      targetNames = targetNames,
                      nSamples = 500, isGL = FALSE,
                      isTelemetry = isTelemetry,
                      isRaster = FALSE,
                      isProb = isProb,
                      captured = captured,
                      nSim = 10, verbose = 0)
# Reverse estimates
rev1 &lt;- reverseTransition(psi = est1, originRelAbund = out_mcmc)
# Compare estimates of gamma, target relative abundance, and pi with calculation
# from true values
rev
rev1

</code></pre>

<hr>
<h2 id='sampleOriginN'>Example origin site abundances and relative abundances</h2><span id='topic+sampleOriginN'></span><span id='topic+sampleOriginRelN'></span>

<h3>Description</h3>

<p><code>sampleOriginN</code> is a dataset containing example origin site abundances
from 5 scenarios used in Cohen et al. (2018).  For the same 5
scenarios, <code>sampleOriginRelN</code> contains the relative abundances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleOriginN

sampleOriginRelN
</code></pre>


<h3>Format</h3>

<p>Each dataset is a named list with 5 vectors in it. Each vector has
4 elements (for the 4 origin sites).  The relative abundance vectors each
sum to 1. The 5 scenarios are:
</p>

<ul>
<li><p> Base: Equal abundance at each origin site
</p>
</li>
<li><p> B Doub: The second origin site has twice the abundance of the other
three sites
</p>
</li>
<li><p> B Half: The second origin site has half the abundance of the other
three sites
</p>
</li>
<li><p> D Doub: The last origin site has twice the abundance of the other
three sites
</p>
</li>
<li><p> D Half: The last origin site has half the abundance of the other
three sites
</p>
</li></ul>

<p>An object of class <code>list</code> of length 5.
</p>

<hr>
<h2 id='sampleOriginPos'>Example origin and target site positions and distances on a 2-D plane</h2><span id='topic+sampleOriginPos'></span><span id='topic+sampleOriginDist'></span><span id='topic+sampleTargetPos'></span><span id='topic+sampleTargetDist'></span>

<h3>Description</h3>

<p><code>sampleOriginPos</code> is a dataset containing example origin site positions
from 12 scenarios used in Cohen et al. (2018).  For the same 12
scenarios, <code>sampleOriginDist</code> contains the origin site distances,
<code>sampleTargetPos</code> contains the target site positions, and
<code>sampleTargetDist</code> contains the target site distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleOriginPos

sampleOriginDist

sampleTargetPos

sampleTargetDist
</code></pre>


<h3>Format</h3>

<p>Each dataset is a named list with 12 matrices in it, representing 12
scenarios. The position matrices each have 2 columns (x and y position) and
4 rows (for each origin or target site).  The distance matrices are
symmetrical and 4 x 4. The 12 scenarios are:
</p>

<ul>
<li><p> Linear: Both origin and target sites arranged in horizontal linear
fashion, with equal distances between each adjacent site
</p>
</li>
<li><p> B Dist BC*2: Linear, but the central origin sites are twice as far
from each other as the edge sites are from the adjacent origin sites
</p>
</li>
<li><p> B Dist BC/2: Linear, but the central origin sites are half as far
from each other as the edge sites are from the adjacent origin sites
</p>
</li>
<li><p> B Dist CD*2: Linear, but the last two origin sites are twice as far
from each other as the other adjacent origin sites
</p>
</li>
<li><p> B Dist CD/2: Linear, but the last two origin sites are half as far
from each other as the other adjacent origin sites
</p>
</li>
<li><p> B Grid: Origin sites arranged on a grid, target sites arranged
linearly, both with all adjacent sites (excluding diagonals)
equidistant
</p>
</li>
<li><p> NB Dist 23*2: Linear, but the central target sites are twice as far
from each other as the edge sites are from the adjacent target sites
</p>
</li>
<li><p> NB Dist 23/2: Linear, but the central target sites are half as far
from each other as the edge sites are from the adjacent target sites
</p>
</li>
<li><p> NB Dist 34*2: Linear, but the last two target sites are twice as far
from each other as the other adjacent target sites
</p>
</li>
<li><p> NB Dist 34/2: Linear, but the last two target sites are half as far
from each other as the other adjacent target sites
</p>
</li>
<li><p> NB Grid: Target sites arranged on a grid, origin sites arranged
linearly, both with all adjacent sites (excluding diagonals)
equidistant
</p>
</li>
<li><p> B/NB Grid: Origin and target sites each arranged on a grid, both
with all adjacent sites (excluding diagonals) equidistant
</p>
</li></ul>

<p>An object of class <code>list</code> of length 12.
</p>
<p>An object of class <code>list</code> of length 12.
</p>
<p>An object of class <code>list</code> of length 12.
</p>

<hr>
<h2 id='samplePsis'>Example transition probabilities (psis) between origin and target sites</h2><span id='topic+samplePsis'></span>

<h3>Description</h3>

<p>A dataset containing example psi matrices used in Cohen et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplePsis
</code></pre>


<h3>Format</h3>

<p>A named list with 8 transition probability matrices in it. The
direction is from origin site (rows) to target sites (columns), so each
row of each matrix sums to 1.  The psi matrices are:
</p>

<ul>
<li><p> Full Mix: Full mixing from all origin sites to all target sites
</p>
</li>
<li><p> Avoid One Site: All origin sites have the same transition
probabilities, mostly avoiding target site 4
</p>
</li>
<li><p> Full Connectivity: Each origin site transitions to only one target
site
</p>
</li>
<li><p> Half Mix: Origin sites A and B mix fully between target sites 1 and
2, but don't move to target sites 3 or 4, while origin sites C and D
mix fully between target sites 3 and 4, but don't move to target sites
1 or 2
</p>
</li>
<li><p> Low: Simulation scenario labelled &quot;Moderate Connectivity&quot; in Cohen
et al. (2014)
</p>
</li>
<li><p> Medium: Simulation scenario labelled &quot;Strong Connectivity&quot; in Cohen
et al. (2014)
</p>
</li>
<li><p> One Site Preference: Three origin sites have full mixing, but origin
site D only goes to target site 4
</p>
</li>
<li><p> Negative: Artificial transition probability scenario developed to
produce a negative MC value under some circumstances
</p>
</li></ul>


<hr>
<h2 id='simCMRData'>Simulate capture-mark-reencounter (CMR) migratory movement data</h2><span id='topic+simCMRData'></span>

<h3>Description</h3>

<p>Simulate capture-mark-reencounter (CMR) migratory movement data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simCMRData(psi, banded, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simCMRData_+3A_psi">psi</code></td>
<td>
<p>Transition probabilities between B origin sites and W target
sites. B by W matrix</p>
</td></tr>
<tr><td><code id="simCMRData_+3A_banded">banded</code></td>
<td>
<p>A vector of the number of released animals from each origin
site (including those never reencountered in a target site). Length B</p>
</td></tr>
<tr><td><code id="simCMRData_+3A_r">r</code></td>
<td>
<p>A vector (length W) of reencounter probabilities at each target site</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simCMRData</code> returns a list with the elements:
</p>

<dl>
<dt><code>reencountered</code></dt><dd><p>B by W matrix with numbers reencountered at
each target site, by origin site</p>
</dd>
<dt><code>migrated</code></dt><dd><p>B by W matrix with numbers migrated to
each target site, by origin site. Assumes survival to arrival is 1</p>
</dd>
<dt><code>input</code></dt><dd><p>List containing the inputs to function</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
originNames &lt;- c("A", "B", "C")
nOriginSites &lt;- length(originNames)
targetNames &lt;- as.character(1:4)
nTargetSites &lt;- length(targetNames)

psiTrue &lt;- matrix(c(0.5, 0.25, 0.15, 0.1,
                    0.15, 0.4, 0.25, 0.2,
                    0.1, 0.15, 0.2, 0.55), nOriginSites, nTargetSites,
                  TRUE, list(originNames, targetNames))
psiTrue
rowSums(psiTrue)
banded &lt;- c(3000, 6000, 12000); names(banded) &lt;- originNames
rTrue &lt;- c(0.5, 0.6, 0.4, 0.7) ; names(rTrue) &lt;- targetNames
nSims &lt;- 10
reencountered &lt;- psiCalc &lt;- psiEstMCMC &lt;- psiEstBoot &lt;- vector("list", nSims)

set.seed(9001)
for (i in 1:nSims) {
  dataCMR &lt;- simCMRData(psiTrue, banded, rTrue)
  reencountered[[i]] &lt;- dataCMR$reencountered
  psiCalc[[i]] &lt;- calcTransition(banded = banded, reencountered = reencountered[[i]],
                                 originNames = originNames, targetNames = targetNames)

  psiEstMCMC[[i]] &lt;- estTransition(originNames = originNames, targetNames = targetNames,
                              nSamples = 24000, banded = banded,
                              reencountered = reencountered[[i]],
                              method = "MCMC", verbose = 1)

  psiEstBoot[[i]] &lt;- estTransition(originNames = originNames, targetNames = targetNames,
                              nSamples = 400, # this is set low for demonstration
                              banded = banded,
                              reencountered = reencountered[[i]],
                              method = "bootstrap", verbose = 1)
}
psiErrorBoot &lt;- sapply(psiEstBoot, function(x) x$psi$mean - psiTrue, simplify = "array")
psiErrorMCMC &lt;- sapply(psiEstMCMC, function(x) x$psi$mean - psiTrue, simplify = "array")
psiRhat &lt;- sapply(psiEstMCMC, function(x) max(x$BUGSoutput$summary[,"Rhat"]))
psiConvergence &lt;- psiRhat &lt; 1.1
psiErrorMCMC
(psiBiasMCMC &lt;- apply(psiErrorMCMC, 1:2, mean))
(psiBiasBoot &lt;- apply(psiErrorBoot, 1:2, mean))
(psiMAEMCMC &lt;- apply(psiErrorMCMC, 1:2, function(x) mean(abs(x), na.rm = TRUE)))
(psiMAEBoot &lt;- apply(psiErrorBoot, 1:2, function(x) mean(abs(x), na.rm = TRUE)))
library(coda)
psiListsMCMC &lt;- lapply(psiEstMCMC, function(x) as.mcmc.list((x$BUGSoutput)))
for (i in 1:nSims) {
  if (!psiConvergence[i])
    plot(psiListsMCMC[[i]])
}

</code></pre>

<hr>
<h2 id='simCountData'>Simulates Breeding Bird Survey-style count data</h2><span id='topic+simCountData'></span>

<h3>Description</h3>

<p>Recently updated (version 0.4.3) to more properly match current BBS models.
<code>modelCountDataJAGS</code> has not been updated yet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simCountData(
  nStrata,
  routesPerStrata,
  nYears,
  alphaStrat,
  beta = 0,
  eta = 0,
  sdRoute = 0,
  sdYear = 0,
  sdObs = 0,
  sdCount = 0,
  model = c("S", "Sh", "D", "Dh"),
  obsSurvival = 1,
  fixedyear = round(nYears/2),
  nuCount = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simCountData_+3A_nstrata">nStrata</code></td>
<td>
<p>Number of populations/regions/strata</p>
</td></tr>
<tr><td><code id="simCountData_+3A_routesperstrata">routesPerStrata</code></td>
<td>
<p>Vector of length 1 or nStrata containing the number of
routes (i.e. counts) per stratum. If length(routesPerStrata) == 1, number of
routes is identical for each population</p>
</td></tr>
<tr><td><code id="simCountData_+3A_nyears">nYears</code></td>
<td>
<p>Number of years surveys were conducted</p>
</td></tr>
<tr><td><code id="simCountData_+3A_alphastrat">alphaStrat</code></td>
<td>
<p>Vector of length 1 or nStrata containing the log expected
number of individuals counted at each route for each population. If
length(alphaStrat) == 1, expected counts are identical for each population</p>
</td></tr>
<tr><td><code id="simCountData_+3A_beta">beta</code></td>
<td>
<p>Coefficient of linear year effect (default 0)</p>
</td></tr>
<tr><td><code id="simCountData_+3A_eta">eta</code></td>
<td>
<p>Coefficient of first time run effect (default 0)</p>
</td></tr>
<tr><td><code id="simCountData_+3A_sdroute">sdRoute</code></td>
<td>
<p>Standard deviation of random route-level variation. Default is
0, and if you're setting sdObs, it's probably best to keep it that way</p>
</td></tr>
<tr><td><code id="simCountData_+3A_sdyear">sdYear</code></td>
<td>
<p>Standard deviation of random year-level variation (default 0)</p>
</td></tr>
<tr><td><code id="simCountData_+3A_sdobs">sdObs</code></td>
<td>
<p>Standard deviation of random observer variation (default 0)</p>
</td></tr>
<tr><td><code id="simCountData_+3A_sdcount">sdCount</code></td>
<td>
<p>Standard deviation of random count-level variation (default 0)</p>
</td></tr>
<tr><td><code id="simCountData_+3A_model">model</code></td>
<td>
<p>One of &quot;S&quot; (default), &quot;Sh&quot;, &quot;D&quot;, and &quot;Dh&quot;. See Link et al.
(2020) for descriptions of these models</p>
</td></tr>
<tr><td><code id="simCountData_+3A_obssurvival">obsSurvival</code></td>
<td>
<p>Annual probability that the observer that ran a route one
year will run it the next. Default 1 (each route has only one observer)</p>
</td></tr>
<tr><td><code id="simCountData_+3A_fixedyear">fixedyear</code></td>
<td>
<p>The year within nYears that alphaStrat applies directly to
(default halfway through)</p>
</td></tr>
<tr><td><code id="simCountData_+3A_nucount">nuCount</code></td>
<td>
<p>For the &quot;h&quot; models, parameter for extra variation in counts
(default 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simCountData</code> returns a list containing:
</p>

<dl>
<dt><code>nStrata</code></dt><dd><p>Number of populations/regions.</p>
</dd>
<dt><code>nRoutes</code></dt><dd><p>Total number of routes.</p>
</dd>
<dt><code>nYears</code></dt><dd><p>Number of years.</p>
</dd>
<dt><code>routesPerStrata</code></dt><dd><p>Number of routes per population.</p>
</dd>
<dt><code>year</code></dt><dd><p>Vector of length nYears with standardized year values.</p>
</dd>
<dt><code>strat</code></dt><dd><p>Vector of length nRoutes indicating the
population/region in which each route is located.</p>
</dd>
<dt><code>alphaStrat</code></dt><dd><p>log expected count for each populations.</p>
</dd>
<dt><code>epsRoute</code></dt><dd><p>realized deviation from alphaStrat for each route.</p>
</dd>
<dt><code>epsYear</code></dt><dd><p>realized deviation from alphaStrat for each year.</p>
</dd>
<dt><code>beta</code></dt><dd><p>linear year effect.</p>
</dd>
<dt><code>sdRoute</code></dt><dd><p>standard deviation of random route-level variation.</p>
</dd>
<dt><code>sdYear</code></dt><dd><p>standard deviation of random year-level variation.</p>
</dd>
<dt><code>expectedCount</code></dt><dd><p>nRoutes by nYears matrix containing
deterministic expected counts.</p>
</dd>
<dt><code>C</code></dt><dd><p>nRoutes by nYears matrix containing observed counts.</p>
</dd>
</dl>



<h3>References</h3>

<p>Cohen, E. B., J. A. Hostetler, M. T. Hallworth, C. S. Rushing, T. S. Sillett,
and P. P. Marra. 2018. Quantifying the strength of migratory connectivity.
Methods in Ecology and Evolution 9: 513-524.
<a href="https://doi.org/10.1111/2041-210X.12916">doi:10.1111/2041-210X.12916</a>
</p>
<p>Link, W. A., J. R. Sauer, and D. K. Niven. 2020. Model selection for the
North American Breeding Bird Survey. Ecological Applications 30: e02137.
<a href="https://doi.org/10.1002/eap.2137">doi:10.1002/eap.2137</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(150)

### Set parameters for simulation ----

# Number of populations
nStrata. &lt;- 4
# Number of routes w/i each population (assumed to be balanced)
routePerStrat. &lt;- 30 # reduced from 90 for example speed
# Number of years
nYears. &lt;- 5 # reduced from 10 for example speed
# log(Expected number of birds counted at each route)
alphaStrat. &lt;- 1.95
# standard deviation of normal distribution assumed for route/observer random
# effects
sdRoute. &lt;- 0.6
# standard deviation of normal distribution assumed for year random effects
sdYear. &lt;- 0.18


# Number of simulated datasets to create and model
nsims &lt;- 50 # reduced from 100 for example speed
# Number of MCMC iterations
ni. &lt;- 1000 # reduced from 15000 for example speed
# Number of iterations to thin from posterior (reduced from 5)
nt. &lt;- 1
# Number of iterations to discard as burn-in
nb. &lt;- 500 # reduced from 5000 for example speed
# Number of MCMC chains
nc. &lt;- 1 # reduced from 3 for example speed

### Create empty matrix to store model output ---
sim_in &lt;- vector("list", nsims)
sim_out &lt;- vector("list", nsims)


# Simulation ---

system.time(for(s in 1:nsims){
  cat("Simulation",s,"of",nsims,"\n")

  # Simulate data
  sim_data &lt;- simCountData(nStrata = nStrata., routesPerStrata = routePerStrat.,
                           nYears = nYears., alphaStrat = alphaStrat.,
                           sdRoute = sdRoute., sdYear = sdYear.)
  sim_in[[s]] &lt;- sim_data


  # Estimate population-level abundance
  out_mcmc &lt;- modelCountDataJAGS(count_data = sim_data, ni = ni., nt = nt.,
                                 nb = nb., nc = nc.)

  # Store model output
  sim_out[[s]] &lt;- out_mcmc
  remove(out_mcmc)

})


### Check that relative abundance is, on average, equal for each population
prop.table(sapply(sim_in, function(x) return(rowsum(colSums(x$C), x$strat))), 2)

rel_names &lt;- paste0('relN[', 1:nStrata., ']')
rel_abund1 &lt;- data.frame(sim=1:nsims,
                         ra1.mean=NA, ra2.mean=NA, ra3.mean=NA, ra4.mean=NA,
                         ra1.low=NA, ra2.low=NA, ra3.low=NA, ra4.low=NA,
                         ra1.high=NA, ra2.high=NA, ra3.high=NA, ra4.high=NA,
                         ra1.cover=0, ra2.cover=0, ra3.cover=0, ra4.cover=0)
for (s in 1:nsims) {
  rel_abund1[s, 2:5] &lt;- summary(sim_out[[s]])$statistics[rel_names, "Mean"]
  rel_abund1[s, 6:9] &lt;- summary(sim_out[[s]])$quantiles[rel_names, 1]
  rel_abund1[s, 10:13] &lt;- summary(sim_out[[s]])$quantiles[rel_names, 5]
}
rel_abund1 &lt;- transform(rel_abund1,
                        ra1.cover = (ra1.low&lt;=0.25 &amp; ra1.high&gt;=0.25),
                        ra2.cover = (ra2.low&lt;=0.25 &amp; ra2.high&gt;=0.25),
                        ra3.cover = (ra3.low&lt;=0.25 &amp; ra3.high&gt;=0.25),
                        ra4.cover = (ra4.low&lt;=0.25 &amp; ra4.high&gt;=0.25))

summary(rel_abund1)


</code></pre>

<hr>
<h2 id='simGLData'>Simulate geolocator (GL) migratory movement data</h2><span id='topic+simGLData'></span>

<h3>Description</h3>

<p>Simulate geolocator (GL) migratory movement data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simGLData(
  psi,
  originRelAbund = NULL,
  sampleSize,
  originSites = NULL,
  targetSites = NULL,
  geoBias = NULL,
  geoVCov = NULL,
  geoBiasOrigin = geoBias,
  geoVCovOrigin = geoVCov,
  S = 1,
  p = list(1, 1),
  requireEveryOrigin = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simGLData_+3A_psi">psi</code></td>
<td>
<p>Transition probabilities between B origin and W target sites.
A matrix with B rows and W columns where rows sum to 1.</p>
</td></tr>
<tr><td><code id="simGLData_+3A_originrelabund">originRelAbund</code></td>
<td>
<p>Relative abundances at B origin sites. Numeric vector
of length B that sums to 1.</p>
</td></tr>
<tr><td><code id="simGLData_+3A_samplesize">sampleSize</code></td>
<td>
<p>List of length two. The first element is either a vector of
length B with the number of simulated animals to release with geolocators
at each of the B origin sites, a single integer with the total number of
simulated animals to release with geolocators at origin sites (in which
case, the origin sites will be sampled according to the relative
abundance), or NULL if all animals are released at target sites. The
second element is either a vector of length W with the number of simulated
animals to release with geolocators at each of the W target sites, a
single integer with the total number of simulated animals to release with
geolocators at target sites (in which case, the target sites will be
sampled according to their relative abundance), or NULL if all animals are
released at origin sites.</p>
</td></tr>
<tr><td><code id="simGLData_+3A_originsites">originSites</code></td>
<td>
<p>A polygon spatial layer (sf - MULTIPOLYGON) defining the
geographic representation of sites in the origin season.</p>
</td></tr>
<tr><td><code id="simGLData_+3A_targetsites">targetSites</code></td>
<td>
<p>A polygon spatial layer (sf - MULTIPOLYGON) defining the
geographic representation of sites in the target season.</p>
</td></tr>
<tr><td><code id="simGLData_+3A_geobias">geoBias</code></td>
<td>
<p>Vector of length 2 indicating expected bias in longitude and
latitude of animals captured and released at origin sites, in
<code>targetSites</code> units.</p>
</td></tr>
<tr><td><code id="simGLData_+3A_geovcov">geoVCov</code></td>
<td>
<p>2x2 matrix with expected variance/covariance in longitude and
latitude of animals captured and released at origin sites, in
<code>targetSites</code> units.</p>
</td></tr>
<tr><td><code id="simGLData_+3A_geobiasorigin">geoBiasOrigin</code></td>
<td>
<p>Vector of length 2 indicating expected bias in longitude
and latitude of animals captured and released at target sites, in
<code>originSites</code> units.</p>
</td></tr>
<tr><td><code id="simGLData_+3A_geovcovorigin">geoVCovOrigin</code></td>
<td>
<p>2x2 matrix with expected variance/covariance in
longitude and latitude of animals captured and released at target sites,
in <code>originSites</code> units.</p>
</td></tr>
<tr><td><code id="simGLData_+3A_s">S</code></td>
<td>
<p>Survival probabilities of released geolocator animals. Either a
matrix with B rows and W columns (if survival depends on both origin site
and target site), a vector of length W (if survival depends only on target
site), or a single number (if survival is the same for all animals).
Default 1 (all animals with geolocators survive a year).</p>
</td></tr>
<tr><td><code id="simGLData_+3A_p">p</code></td>
<td>
<p>Recapture probabilities of released geolocator animals; list of
length two. The first element is either a vector of length B (if recapture
depends on origin site), or a single number (if recapture is the same for
all animals released on origin sites). The second element is either a
vector of length W (if recapture depends on target site), or a single
number (if recapture is the same for all animals released on target
sites). Default list(1, 1) (all animals that survive are recaptured).</p>
</td></tr>
<tr><td><code id="simGLData_+3A_requireeveryorigin">requireEveryOrigin</code></td>
<td>
<p>If TRUE, the function will throw an error if it
looks like at least one origin site has no animals released in or
migrating to it, or if it can, keep simulating until representation is
met. This helps estTransition or estMC not throw an error. Default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simGLData</code> returns a list with the elements:
</p>

<dl>
<dt><code>originAssignment</code></dt><dd><p>Vector with true origin site of each animal</p>
</dd>
<dt><code>targetAssignment</code></dt><dd><p>Vector with true target site of each animal</p>
</dd>
<dt><code>originPointsTrue</code></dt><dd><p>True origin location of each animal, type sf,
same projection as originSites</p>
</dd>
<dt><code>targetPointsTrue</code></dt><dd><p>True target location of each animal, type sf,
same projection as targetSites</p>
</dd>
<dt><code>originPointsObs</code></dt><dd><p>Observed origin location of each animal that
survived and was recaptured, type sf, same projection as originSites. Same
as originPointsTrue for animals captured at origin sites when S and p==1</p>
</dd>
<dt><code>targetPointsObs</code></dt><dd><p>Observed target location of each animal that
survived and was recaptured, type sf, same projection as targetSites. Same
as targetPointsTrue for animals captured at target sites when S and p==1</p>
</dd>
<dt><code>lived</code></dt><dd><p>0/1 vector for each animal, indicating which survived</p>
</dd>
<dt><code>recaptured</code></dt><dd><p>0/1 vector for each animal, indicating which were
recaptured</p>
</dd>
<dt><code>input</code></dt><dd><p>List containing the inputs to function</p>
</dd>
</dl>


<hr>
<h2 id='simMove'>Simulates position of birds by individual, season, year, and month.</h2><span id='topic+simMove'></span>

<h3>Description</h3>

<p>Incorporates migratory connectivity, movement within season, and dispersal
between seasons. Does not incorporate births or deaths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMove(
  breedingAbund,
  breedingDist,
  winteringDist,
  psi,
  nYears = 10,
  nMonths = 3,
  winMoveRate = 0,
  sumMoveRate = 0,
  winDispRate = 0,
  sumDispRate = 0,
  natalDispRate = 0,
  breedDispRate = 0,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simMove_+3A_breedingabund">breedingAbund</code></td>
<td>
<p>Vector with number of birds to simulate starting at
each breeding site.</p>
</td></tr>
<tr><td><code id="simMove_+3A_breedingdist">breedingDist</code></td>
<td>
<p>Distances between the breeding sites. Symmetric matrix.</p>
</td></tr>
<tr><td><code id="simMove_+3A_winteringdist">winteringDist</code></td>
<td>
<p>Distances between the wintering sites. Symmetric
matrix.</p>
</td></tr>
<tr><td><code id="simMove_+3A_psi">psi</code></td>
<td>
<p>Transition probabilities between B origin and W target sites.
A matrix with B rows and W columns where rows sum to 1.</p>
</td></tr>
<tr><td><code id="simMove_+3A_nyears">nYears</code></td>
<td>
<p>Number of years to simulate movement.</p>
</td></tr>
<tr><td><code id="simMove_+3A_nmonths">nMonths</code></td>
<td>
<p>Number of months per breeding and wintering season.</p>
</td></tr>
<tr><td><code id="simMove_+3A_winmoverate">winMoveRate</code></td>
<td>
<p>Within winter movement rate.  Defaults to 0 (no
movement).</p>
</td></tr>
<tr><td><code id="simMove_+3A_summoverate">sumMoveRate</code></td>
<td>
<p>Within summer movement rate.  Defaults to 0 (no
movement).</p>
</td></tr>
<tr><td><code id="simMove_+3A_windisprate">winDispRate</code></td>
<td>
<p>Between winter dispersal rate.  Defaults to 0 (no
dispersal).</p>
</td></tr>
<tr><td><code id="simMove_+3A_sumdisprate">sumDispRate</code></td>
<td>
<p>Between summer dispersal rate.  Defaults to 0 (no
dispersal).  Setting this to a value above 0 is equivalent to setting
both natal and breeding dispersal to that same value.</p>
</td></tr>
<tr><td><code id="simMove_+3A_nataldisprate">natalDispRate</code></td>
<td>
<p>Natal dispersal rate. Controls the movement of
animals from their birthplace on their first return to the breeding
grounds.  Defaults to 0 (return to the birthplace for all).</p>
</td></tr>
<tr><td><code id="simMove_+3A_breeddisprate">breedDispRate</code></td>
<td>
<p>Breeding dispersal rate. Controls the movement of
animals between breeding sites on spring migrations after the first.
Defaults to 0 (return to the same breeding site each year).</p>
</td></tr>
<tr><td><code id="simMove_+3A_verbose">verbose</code></td>
<td>
<p>If set to a value &gt; 0, informs the user on the passage
of years and seasons during the simulation. Defaults to 0 (no output
during simulation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simMove</code> returns a list with elements:
</p>

<dl>
<dt><code>animalLoc</code></dt><dd><p><code>sum(breedingAbund)</code> (number of animals)
by 2 by <code>nYears</code> by <code>nMonths</code> array with the simulated
locations of each animal in each month of each season (summer or
winter) of each year.  Values of cells are 1...B (first column) and
1...W (second column) where B is the number of breeding sites and W is
the number of wintering sites.</p>
</dd>
<dt><code>breedDispMat</code></dt><dd><p>B by B matrix of probabilities of breeding
dispersal between each pair of 1...B breeding sites.  Direction is from
row to column, so each row sums to 1.</p>
</dd>
<dt><code>natalDispMat</code></dt><dd><p>B by B matrix of probabilities of natal
dispersal between each pair of 1...B breeding sites.  Direction is from
row to column, so each row sums to 1.</p>
</dd>
<dt><code>sumMoveMat</code></dt><dd><p>B by B matrix of probabilities of within season
movement between each pair of 1...B breeding sites.  Direction is from
row to column, so each row sums to 1.</p>
</dd>
<dt><code>winDispMat</code></dt><dd><p>W by W matrix of probabilities of dispersal
between each pair of 1...W nonbreeding sites.  Direction is from
row to column, so each row sums to 1.</p>
</dd>
<dt><code>winMoveMat</code></dt><dd><p>W by W matrix of probabilities of within season
movement between each pair of 1...W nonbreeding sites.  Direction is
from row to column, so each row sums to 1.</p>
</dd>
</dl>



<h3>References</h3>

<p>Cohen, E. B., J. A. Hostetler, M. T. Hallworth, C. S. Rushing, T. S. Sillett,
and P. P. Marra. 2018. Quantifying the strength of migratory connectivity.
Methods in Ecology and Evolution 9: 513-524.
<a href="https://doi.org/10.1111/2041-210X.12916">doi:10.1111/2041-210X.12916</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Dispersal simulation ----
## Utility functions for use in simulations

# Simple approach to estimate psi matrix and MC from simulated (or real) data
# (doesn't include uncertainty).  Only uses one year for computation
calcPsiMC &lt;- function(originDist, targetDist, originRelAbund, locations,
                      years = 1, months = 1, verbose=FALSE) {
  nOrigin &lt;- nrow(originDist)
  nTarget &lt;- nrow(targetDist)
  psiMat &lt;- matrix(0, nOrigin, nTarget)
  nInd &lt;- dim(locations)[1]
  nYears &lt;- dim(locations)[3]
  nMonths &lt;- dim(locations)[4]
  for (i in 1:nInd) {
    if (i %% 1000 == 0 &amp;&amp; verbose) #
      cat("Individual", i, "of", nInd, "\n")
    originMat &lt;- locations[i, 1, years, months]
    targetMat &lt;- locations[i, 2, years, months]
    bIndices &lt;- which(!is.na(originMat))
    wIndices &lt;- which(!is.na(targetMat))
    if (length(bIndices) &amp;&amp; length(wIndices))
      for (bi in bIndices)
        for (wi in wIndices)
          psiMat[originMat[bi], targetMat[wi]] &lt;- psiMat[originMat[bi], targetMat[wi]] + 1
  }
  psiMat &lt;- apply(psiMat, 2, "/", rowSums(psiMat))
  MC &lt;- calcMC(originDist, targetDist, psi = psiMat,
               originRelAbund = originRelAbund, sampleSize = nInd)
  return(list(psi=psiMat, MC=MC))
}

## Simulation
originNames &lt;- c("A", "B", "C")
nBreeding &lt;- length(originNames) # Number of sites reduced for example speed
targetNames &lt;- as.character(1:4)
nWintering &lt;- length(targetNames)

psi &lt;- matrix(c(0.5, 0.25, 0.15, 0.1,
                0.15, 0.4, 0.25, 0.2,
                0.1, 0.15, 0.2, 0.55), nBreeding, nWintering,
              TRUE, list(originNames, targetNames))
psi
breedingPos &lt;- matrix(c(seq(-99, -93, 3),
                        rep(40, nBreeding)), nBreeding, 2)
winteringPos &lt;- matrix(c(seq(-88, -82, 2),
                         rep(0, nWintering)), nWintering, 2)
breedingPos
winteringPos

breedDist &lt;- distFromPos(breedingPos, 'ellipsoid')
nonbreedDist &lt;- distFromPos(winteringPos, 'ellipsoid')

# Breeding Abundance
breedingN &lt;- rep(50, nBreeding) # Reduced from 5000 for example speed
breedingRelN &lt;- breedingN/sum(breedingN)


# Baseline strength of migratory connectivity

  MC &lt;- calcMC(breedDist, nonbreedDist, breedingRelN, psi, sum(breedingN))
  round(MC, 4)

# Other basic simulation parameters

## Dispersal simulations---
set.seed(1516)
nYears &lt;- 4 # Reduced from 15 for example speed
nMonths &lt;- 2 # Each season, reduced from 4 for example speed
Drates &lt;- c(0.04, 0.16) # Rates of dispersal, fewer for example speed


  birdLocDisp &lt;- vector('list', length(Drates))
  Disp.df  &lt;- data.frame(Year=rep(1:nYears, length(Drates)),
                         Rate=rep(Drates, each = nYears), MC = NA)
  for(i in 1:length(Drates)){
    cat('Dispersal Rate', Drates[i], '\n')
    birdLocDisp[[i]] &lt;- simMove(breedingN, breedDist, nonbreedDist, psi, nYears,
                                nMonths, sumDispRate = Drates[i])
    for(j in 1:nYears){
      cat('\tYear', j, '\n')
      temp.results &lt;- calcPsiMC(breedDist, nonbreedDist, breedingRelN,
                                   birdLocDisp[[i]]$animalLoc, years = j)
      Disp.df$MC[j + (i - 1) * nYears] &lt;- temp.results$MC
    }
  } # end i loop

  Disp.df$Year &lt;- Disp.df$Year - 1 #just run once!
  data.frame(Disp.df, roundMC = round(Disp.df$MC, 2),
             nearZero = Disp.df$MC &lt; 0.01)

  # Convert dispersal rates to probabilities of dispersing at least certain
  # distance
  threshold &lt;- 1000
  probFarDisp &lt;- matrix(NA, nBreeding, length(Drates),
                        dimnames = list(NULL, Drates))
  for (i in 1:length(Drates)) {
    for (k in 1:nBreeding) {
      probFarDisp[k, i] &lt;- sum(
        birdLocDisp[[i]]$natalDispMat[k, which(breedDist[k, ]&gt;= threshold)])
    }
  }
  summary(probFarDisp)

  #plot results
  with(subset(Disp.df, Rate == 0.04),
       plot(Year, MC, "l", col = "blue", ylim = c(0, 0.3), lwd = 2))
  lines(Disp.df$Year[Disp.df$Rate==0.16], Disp.df$MC[Disp.df$Rate==0.16],
        col = "darkblue", lwd = 2)
  legend("bottomleft", legend = Drates, col = c("blue", "darkblue"), lty = 1,
         lwd = 2)


</code></pre>

<hr>
<h2 id='simProbData'>Simulate Dirichlet-based probability table data</h2><span id='topic+simProbData'></span>

<h3>Description</h3>

<p>Simulate Dirichlet-based probability table data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simProbData(
  psi,
  originRelAbund,
  sampleSize,
  shapes,
  captured = "target",
  requireEveryOrigin = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simProbData_+3A_psi">psi</code></td>
<td>
<p>Transition probabilities between B origin sites and W target
sites. B by W matrix</p>
</td></tr>
<tr><td><code id="simProbData_+3A_originrelabund">originRelAbund</code></td>
<td>
<p>Vector of relative abundances at B origin sites</p>
</td></tr>
<tr><td><code id="simProbData_+3A_samplesize">sampleSize</code></td>
<td>
<p>Either the total number of data points to simulate or a
vector with the number at each target or origin site. If only the total is
provided, sampling will be done in proportion to abundance</p>
</td></tr>
<tr><td><code id="simProbData_+3A_shapes">shapes</code></td>
<td>
<p>If captured == &quot;target&quot;, a B by B matrix, each row of which is
the shape parameters for the Dirichlet distribution of an animal whose true
origin assignment is that row's. If captured == &quot;origin&quot;, a W by W matrix,
each row of which is the shape parameters for the Dirichlet distribution of
an animal whose true target assignment is that row's.</p>
</td></tr>
<tr><td><code id="simProbData_+3A_captured">captured</code></td>
<td>
<p>Either &quot;target&quot; (the default) or &quot;origin&quot;, indicating which
side animal data were collected on</p>
</td></tr>
<tr><td><code id="simProbData_+3A_requireeveryorigin">requireEveryOrigin</code></td>
<td>
<p>If TRUE, the function will throw an error if it
looks like at least one origin site has no animals released in or
migrating to it, or if it can, keep simulating until representation is
met. This helps estTransition or estMC not throw an error. Default FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simProbData</code> returns a list with the elements:
</p>

<dl>
<dt><code>originAssignment</code></dt><dd><p>Vector with true origin site of each animal</p>
</dd>
<dt><code>targetAssignment</code></dt><dd><p>Vector with true target site of each animal</p>
</dd>
<dt><code>genProbs</code></dt><dd><p>Table of assignment site probabilities for each
animal</p>
</dd>
<dt><code>input</code></dt><dd><p>List containing the inputs to function</p>
</dd>
</dl>


<hr>
<h2 id='simTelemetryData'>Simulate telemetry/GPS data</h2><span id='topic+simTelemetryData'></span>

<h3>Description</h3>

<p>Simulate telemetry/GPS data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simTelemetryData(
  psi,
  sampleSize,
  originRelAbund = NULL,
  originSites = NULL,
  targetSites = NULL,
  captured = "origin",
  S = 1,
  p = 1,
  requireEveryOrigin = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simTelemetryData_+3A_psi">psi</code></td>
<td>
<p>Transition probabilities between B origin and W target sites.
A matrix with B rows and W columns where rows sum to 1.</p>
</td></tr>
<tr><td><code id="simTelemetryData_+3A_samplesize">sampleSize</code></td>
<td>
<p>If captured is &quot;origin&quot;, either a vector of
length B with the number of simulated animals to release with geolocators
at each of the B origin sites or a single integer with the total number of
simulated animals to release with GPS at origin sites (in which
case, the origin sites will be sampled according to the relative
abundance). If captured is &quot;target&quot;, either a vector of length W with the
number of simulated animals to release with GPS at each of the W target
sites or a single integer with the total number of simulated animals to
release at target sites (in which case, the target sites will be
sampled according to their relative abundance).</p>
</td></tr>
<tr><td><code id="simTelemetryData_+3A_originrelabund">originRelAbund</code></td>
<td>
<p>Relative abundances at B origin sites. Numeric vector
of length B that sums to 1. Optional unless providing target data and/or
sample size of length 1.</p>
</td></tr>
<tr><td><code id="simTelemetryData_+3A_originsites">originSites</code></td>
<td>
<p>A polygon spatial layer (sf - MULTIPOLYGON) defining the
geographic representation of sites in the origin season. If left NULL, the
simulation won't provide origin points.</p>
</td></tr>
<tr><td><code id="simTelemetryData_+3A_targetsites">targetSites</code></td>
<td>
<p>A polygon spatial layer (sf - MULTIPOLYGON) defining the
geographic representation of sites in the target season. If left NULL, the
simulation won't provide target points.</p>
</td></tr>
<tr><td><code id="simTelemetryData_+3A_captured">captured</code></td>
<td>
<p>Either &quot;origin&quot; (the default) or &quot;target&quot;.</p>
</td></tr>
<tr><td><code id="simTelemetryData_+3A_s">S</code></td>
<td>
<p>Survival probabilities of released animals. Probably only
relevant for simulating archival tags. Either a matrix with B rows and W
columns (if survival depends on both origin site and target site), a vector
of length W (if survival depends only on target site), or a single number
(if survival is the same for all animals). Default 1 (all tagged animals
survive a year).</p>
</td></tr>
<tr><td><code id="simTelemetryData_+3A_p">p</code></td>
<td>
<p>Recapture probabilities of released animals. Only relevant for
simulating archival tags. Either a vector of length B (if captured on origin
and recapture depends on origin site), a vector of length W (if captured on
target and recapture depends on target site), or a single number (if
recapture is the same for all animals). Default 1 (all animals that survive
are recaptured).</p>
</td></tr>
<tr><td><code id="simTelemetryData_+3A_requireeveryorigin">requireEveryOrigin</code></td>
<td>
<p>If TRUE, the function will throw an error if it
looks like at least one origin site has no animals released in or
migrating to it, or if it can, keep simulating until representation is
met. This helps estTransition not throw an error. Default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>simTelemetryData</code> returns a list with the elements:
</p>

<dl>
<dt><code>originAssignment</code></dt><dd><p>Vector with true origin site of each animal</p>
</dd>
<dt><code>targetAssignment</code></dt><dd><p>Vector with true target site of each animal</p>
</dd>
<dt><code>originPointsTrue</code></dt><dd><p>True origin location of each animal, type sf,
same projection as originSites</p>
</dd>
<dt><code>targetPointsTrue</code></dt><dd><p>True target location of each animal, type sf,
same projection as targetSites</p>
</dd>
<dt><code>originPointsObs</code></dt><dd><p>Observed origin location of each animal that
survived and was recaptured, type sf, same projection as originSites. Same
as originPointsTrue when S and p==1</p>
</dd>
<dt><code>targetPointsObs</code></dt><dd><p>Observed target location of each animal that
survived and was recaptured, type sf, same projection as targetSites. Same
as targetPointsTrue when S and p==1</p>
</dd>
<dt><code>lived</code></dt><dd><p>0/1 vector for each animal, indicating which survived</p>
</dd>
<dt><code>recaptured</code></dt><dd><p>0/1 vector for each animal, indicating which were
recaptured</p>
</dd>
<dt><code>input</code></dt><dd><p>List containing the inputs to function</p>
</dd>
</dl>


<hr>
<h2 id='weightAssign'>Calculate Weights for Isotope Assignments
weightAssign</h2><span id='topic+weightAssign'></span>

<h3>Description</h3>

<p>The primary purpose of this function is to determine whether weighting likelihood based isotope assignments
and prior information, such as relative abundance can improve the model performance compared to the
isotope-only model. To do this, we raise the likelihood and prior values to powers from 0.1
to 10 and measure model performance using the assignment error rate and assignment area. Weights &lt; 1 flatten
the likelihood/prior distributions (giving relatively more weight to smaller values) and weights &gt; 1
sharpen the distributions (giving relatively less weight to smaller values. The <code>weightAssign</code> function
generates origin assignments using stable-hydrogen isotopes in tissue. If first generates
a probability surface of origin assignment from a vector of stable-isotope values for each animal/sample
captured at a known location. Probabilistic assignments are constructed by first converting observed
stable-isotope ratios (isoscape) in either precipitation or surface waters into a 'tissuescape' using
a user-provided intercept, slope and standard deviation. See
<a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0035137">Hobson et. al. (2012)</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightAssign(
  knownLocs,
  isovalues,
  isoSTD,
  intercept,
  slope,
  odds = 0.67,
  relAbund,
  weightRange = c(-1, 1),
  sppShapefile = NULL,
  assignExtent = c(-179, -60, 15, 89),
  element = "Hydrogen",
  surface = FALSE,
  period = "Annual",
  verbose = 1,
  mapDirectory = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightAssign_+3A_knownlocs">knownLocs</code></td>
<td>
<p>matrix of capture locations of the same length as
<code>isovalues</code></p>
</td></tr>
<tr><td><code id="weightAssign_+3A_isovalues">isovalues</code></td>
<td>
<p>vector of tissue isotope values from known locations</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_isostd">isoSTD</code></td>
<td>
<p>standard deviation from calibration</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_intercept">intercept</code></td>
<td>
<p>intercept value from calibration</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_slope">slope</code></td>
<td>
<p>value from calibration</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_odds">odds</code></td>
<td>
<p>odds ratio to use to set likely and unlikely locations defaults
to 0.67</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_relabund">relAbund</code></td>
<td>
<p>raster layer of relative abundance that sums to 1.</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_weightrange">weightRange</code></td>
<td>
<p>vector of length 2 within minimum and maximum values to
weight isotope and relative abundance. Default = c(-1,1)</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_sppshapefile">sppShapefile</code></td>
<td>
<p>A polygon spatial layer (sf - MULTIPOLYGON) defining
species range. Assignments are restricted to these areas.</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_assignextent">assignExtent</code></td>
<td>
<p>definition for the extent of the assignment. Can be used
in place of <code>sppShapefile</code> to limit assignment. Input should
follow <code>c(xmin,xmax,ymin,ymax)</code> in degrees longitude and latitude.</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_element">element</code></td>
<td>
<p>The elemental isotope of interest. Currently the only
elements that are implemented are 'Hydrogen' (default) and 'Oxygen'</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_surface">surface</code></td>
<td>
<p>DEPRECATED function no longer returns surface water values.
Default is 'FALSE' which returns the precipitation isotopes ratio.</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_period">period</code></td>
<td>
<p>The time period of interest. If 'Annual' returns a raster
of mean annual values in precipitation for the <code>element</code>. If
'GrowingSeason' returns growing season values in precipitation for
<code>element</code> of interest.</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_verbose">verbose</code></td>
<td>
<p>takes values 0 or 1 (default). 0 prints no output during
run. 1 prints a message detailing where in the process the function
is.</p>
</td></tr>
<tr><td><code id="weightAssign_+3A_mapdirectory">mapDirectory</code></td>
<td>
<p>Directory to save/read isotope map from. Can use relative
or absolute addressing. The default value (NULL) downloads to a temporary
directory, so we strongly recommend changing this from the default unless
you're sure you're not going to need these data more than once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an <code>weightAssign</code> object containing the following:
</p>

<dl>
<dt><code>top</code></dt><dd><p>data.frame with the optimal weightings</p>
</dd>
<dt><code>frontier</code></dt><dd><p>data.frame with values that fall along the Pareto
frontier</p>
</dd>
<dt><code>performance</code></dt><dd><p>data.frame with error rate and assignment area
for each weight combination</p>
</dd>
</dl>



<h3>References</h3>

<p>Cohen, E. B., C. S. Rushing, F. R. Moore, M. T. Hallworth, J. A. Hostetler,
M. Gutierrez Ramirez, and P. P. Marra. 2019. The strength of migratory
connectivity for birds en route to breeding through the Gulf of Mexico.
Ecography 42: 658-669.
</p>
<p>Rushing, C. S., P. P. Marra and C. E. Studds. 2017. Incorporating breeding
abundance into spatial assignments on continuous surfaces. Ecology and
Evolution 3: 3847-3855. <a href="https://doi.org/10.1002/ece3.2605">doi:10.1002/ece3.2605</a>
</p>
<p>Cohen, E. B., C. S. Rushing, F. R. Moore, M. T. Hallworth, J. A. Hostetler,
M. Gutierrez Ramirez, and P. P. Marra. 2019. The strength of
migratory connectivity for birds en route to breeding through the Gulf of
Mexico. Ecography 42: 658-669.
</p>
<p>Hobson, K. A., S. L. Van Wilgenburg, L. I. Wassenaar, and K. Larson. 2012.
Linking hydrogen isotopes in feathers and precipitation: sources of
variance and consequences for assignment to isoscapes. PLoS ONE 7: e35137.
</p>
<p>Rushing, C. S., P. P. Marra, and C. E. Studds. 2017. Incorporating breeding
abundance into spatial assignments on continuous surfaces. Ecology and
Evolution 7: 3847-3855.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
extensions &lt;- c("shp", "shx", "dbf", "sbn", "sbx")
tmp &lt;- tempdir()
for (ext in extensions) {
download.file(paste0(
              "https://raw.githubusercontent.com/SMBC-NZP/MigConnectivity",
                     "/master/data-raw/Spatial_Layers/OVENdist.",
                     ext),
              destfile = paste0(tmp, "/OVENdist.", ext), mode = "wb")
}
OVENdist &lt;- sf::st_read(paste0(tmp, "/OVENdist.shp"))
OVENdist &lt;- OVENdist[OVENdist$ORIGIN==2,] # only breeding
sf::st_crs(OVENdist) &lt;- sf::st_crs(4326)

download.file(paste0("https://raw.githubusercontent.com/SMBC-NZP/MigConnectivity",
                     "/master/data-raw/deltaDvalues.csv"),
              destfile = paste0(tmp, "/deltaDvalues.csv"))
OVENvals &lt;- read.csv(paste0(tmp, "/deltaDvalues.csv"))

HBEFbirds &lt;- OVENvals[grep("NH",OVENvals[,1]),]

# Create a spatial object of known capture sites
knownLocs &lt;- sf::st_as_sf(data.frame(Long = rep(-73,nrow(HBEFbirds)),
                                    Lat = rep(43,nrow(HBEFbirds))),
                         coords = c("Long","Lat"),
                         crs = 4326)

#Get OVEN abundance from BBS estimates and read into R #
utils::download.file("https://www.mbr-pwrc.usgs.gov/bbs/ra15/ra06740.zip",
                     destfile = paste0(tmp, "/oven.zip"))
utils::unzip(paste0(tmp, "/oven.zip"), exdir = tmp)
oven_dist &lt;- sf::st_read(paste0(tmp, "/ra06740.shp"))

# Empty raster with the same dimensions as isoscape and Ovenbird distribution

# We do this manually here but the weightedAssign function has been updated
# to ensure the isoscape and abundance rasts have the same extent using
# resampling to match  relAbund to the isoscape.
r &lt;- terra::rast(nrow = 331, ncol = 870,
                 res = c(0.0833333, 0.0833333),
                 xmin = -125.1667, xmax = -52.66672,
                 ymin = 33.49995, ymax = 61.08327,
                 crs = sf::st_crs(4326)$wkt)

# rasterize the polygons from BBS - this is not needed if working with a
# rasterized surface
relativeAbun&lt;-terra::rasterize(terra::vect(sf::st_transform(oven_dist,4326)),
                               r,
                               field = "RASTAT")

relativeAbund &lt;- relativeAbun/terra::global(relativeAbun, sum,
                                            na.rm = TRUE)$sum


BE &lt;- weightAssign(knownLocs = knownLocs,
                   isovalues = HBEFbirds[,2],
                   isoSTD = 12,
                   intercept = -10,
                   slope = 0.8,
                   odds = 0.67,
                   relAbund = relativeAbund,
                   weightRange = c(-1, 1),
                   sppShapefile = OVENdist,
                   assignExtent = c(-179,-60,15,89),
                   element = "Hydrogen",
                   period = "Annual")


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
