<!DOCTYPE html><html><head><title>Help for package cmna</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cmna}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptint'><p>Adaptive Integration</p></a></li>
<li><a href='#bezier'><p>Bezier curves</p></a></li>
<li><a href='#bilinear'><p>Bilinear interpolation</p></a></li>
<li><a href='#bisection'><p>The Bisection Method</p></a></li>
<li><a href='#bvp'><p>Boundary value problems</p></a></li>
<li><a href='#choleskymatrix'><p>Cholesky Decomposition</p></a></li>
<li><a href='#cmna-package'><p>Computational Methods for Numerical Analysis</p></a></li>
<li><a href='#cubicspline'><p>Natural cubic spline interpolation</p></a></li>
<li><a href='#detmatrix'><p>Calculate the determinant of the matrix</p></a></li>
<li><a href='#division'><p>Algorithms for divisions</p></a></li>
<li><a href='#fibonacci'><p>Fibonacci numbers</p></a></li>
<li><a href='#findiff'><p>Finite Differences</p></a></li>
<li><a href='#gaussint'><p>Gaussian integration method driver</p></a></li>
<li><a href='#gdls'><p>Least squares with graident descent</p></a></li>
<li><a href='#giniquintile'><p>Gini coefficients</p></a></li>
<li><a href='#goldsect'><p>Golden Section Search</p></a></li>
<li><a href='#gradient'><p>Gradient descent</p></a></li>
<li><a href='#heat'><p>Heat Equation via Forward-Time Central-Space</p></a></li>
<li><a href='#hillclimbing'><p>Hill climbing</p></a></li>
<li><a href='#himmelblau'><p>Himmelblau Function</p></a></li>
<li><a href='#horner'><p>Horner's rule</p></a></li>
<li><a href='#invmatrix'><p>Invert a matrix</p></a></li>
<li><a href='#isPrime'><p>Test for Primality</p></a></li>
<li><a href='#iterativematrix'><p>Solve a matrix using iterative methods</p></a></li>
<li><a href='#ivp'><p>Initial value problems</p></a></li>
<li><a href='#ivpsys'><p>Initial value problems for systems of ordinary differential equations</p></a></li>
<li><a href='#linterp'><p>Linear interpolation</p></a></li>
<li><a href='#lumatrix'><p>LU Decomposition</p></a></li>
<li><a href='#mcint'><p>Monte Carlo Integration</p></a></li>
<li><a href='#midpt'><p>rectangle method</p></a></li>
<li><a href='#newton'><p>Newton's method</p></a></li>
<li><a href='#nn'><p>Nearest interpolation</p></a></li>
<li><a href='#nthroot'><p>The n-th root formula</p></a></li>
<li><a href='#polyinterp'><p>Polynomial interpolation</p></a></li>
<li><a href='#pwiselinterp'><p>Piecewise linear interpolation</p></a></li>
<li><a href='#quadratic'><p>The quadratic equation.</p></a></li>
<li><a href='#refmatrix'><p>Matrix to Row Echelon Form</p></a></li>
<li><a href='#resizeImage'><p>Image resizing</p></a></li>
<li><a href='#revolution-solid'><p>Volumes of solids of revolution</p></a></li>
<li><a href='#romberg'><p>Romberg Integration</p></a></li>
<li><a href='#rowops'><p>Elementary row operations</p></a></li>
<li><a href='#sa'><p>Simulated annealing</p></a></li>
<li><a href='#secant'><p>Secant Method</p></a></li>
<li><a href='#simp'><p>Simpson's rule</p></a></li>
<li><a href='#simp38'><p>Simpson's 3/8 rule</p></a></li>
<li><a href='#summation'><p>Two summing algorithms</p></a></li>
<li><a href='#trap'><p>Trapezoid method</p></a></li>
<li><a href='#tridiagmatrix'><p>Solve a tridiagonal matrix</p></a></li>
<li><a href='#vecnorm'><p>Norm of a vector</p></a></li>
<li><a href='#wave'><p>Wave Equation using</p></a></li>
<li><a href='#wilkinson'><p>Wilkinson's Polynomial</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computational Methods for Numerical Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-07-14</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jameshoward.us/cmna/">https://jameshoward.us/cmna/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/k3jph/cmna-pkg/issues">https://github.com/k3jph/cmna-pkg/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the source and examples for James P. Howard, II, 
             "Computational Methods for Numerical Analysis with R," 
             <a href="https://jameshoward.us/cmna/">https://jameshoward.us/cmna/</a>, a book on numerical
             methods in R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, devtools, markdown, roxygen2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-14 13:19:15 UTC; howarjp1</td>
</tr>
<tr>
<td>Author:</td>
<td>James Howard <a href="https://orcid.org/0000-0003-4530-1547"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Howard &lt;jh@jameshoward.us&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-14 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptint'>Adaptive Integration</h2><span id='topic+adaptint'></span>

<h3>Description</h3>

<p>Adaptive integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptint(f, a, b, n = 10, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptint_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="adaptint_+3A_a">a</code></td>
<td>
<p>the a-bound of integration</p>
</td></tr>
<tr><td><code id="adaptint_+3A_b">b</code></td>
<td>
<p>the b-bound of integration</p>
</td></tr>
<tr><td><code id="adaptint_+3A_n">n</code></td>
<td>
<p>the maximum recursive depth</p>
</td></tr>
<tr><td><code id="adaptint_+3A_tol">tol</code></td>
<td>
<p>the maximum error tolerance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>adaptint</code> function uses Romberg's rule to calculate the
integral of the function <code>f</code> over the interval from <code>a</code>
to <code>b</code>.  The parameter <code>n</code> sets the number of intervals
to use when evaluating.  Additional options are passed to the
function <code>f</code> when evaluating.
</p>


<h3>Value</h3>

<p>the value of the integral
</p>


<h3>See Also</h3>

<p>Other integration: 
<code><a href="#topic+gaussint">gaussint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+mcint">mcint</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+revolution-solid">revolution-solid</a></code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>
<p>Other newton-cotes: 
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { sin(x)^2 + log(x) }
adaptint(f, 1, 10, n = 4)
adaptint(f, 1, 10, n = 5)
adaptint(f, 1, 10, n = 10)

</code></pre>

<hr>
<h2 id='bezier'>Bezier curves</h2><span id='topic+bezier'></span><span id='topic+qbezier'></span><span id='topic+cbezier'></span>

<h3>Description</h3>

<p>Find the quadratic and cubic Bezier curve for the given points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qbezier(x, y, t)

cbezier(x, y, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bezier_+3A_x">x</code></td>
<td>
<p>a vector of x values</p>
</td></tr>
<tr><td><code id="bezier_+3A_y">y</code></td>
<td>
<p>a vector of y values</p>
</td></tr>
<tr><td><code id="bezier_+3A_t">t</code></td>
<td>
<p>a vector of t values for which the curve will be computed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qbezier</code> finds the quadratic Bezier curve for the
given three points and <code>cbezier</code> finds the cubic Bezier curve
for the given four points.  The curve will be computed at all values
in the vector <code>t</code> and a list of x and y values returned.
</p>


<h3>Value</h3>

<p>a list composed of an x-vector and a y-vector
</p>


<h3>See Also</h3>

<p>Other interp: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nn">nn</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 3)
y &lt;- c(2, 3, 5)
f &lt;- qbezier(x, y, seq(0, 1, 1/100))

x &lt;- c(-1, 1, 0, -2)
y &lt;- c(-2, 2, -1, -1)
f &lt;- cbezier(x, y, seq(0, 1, 1/100))

</code></pre>

<hr>
<h2 id='bilinear'>Bilinear interpolation</h2><span id='topic+bilinear'></span>

<h3>Description</h3>

<p>Finds a bilinear interpolation bounded by four points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bilinear(x, y, z, newx, newy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bilinear_+3A_x">x</code></td>
<td>
<p>vector of two x values representing <code>x_1</code> and <code>x_2</code></p>
</td></tr>
<tr><td><code id="bilinear_+3A_y">y</code></td>
<td>
<p>vector of two y values representing <code>y_1</code> and <code>y_2</code></p>
</td></tr>
<tr><td><code id="bilinear_+3A_z">z</code></td>
<td>
<p>2x2 matrix if <code>z</code> values</p>
</td></tr>
<tr><td><code id="bilinear_+3A_newx">newx</code></td>
<td>
<p>vector of new <code>x</code> values to interpolate</p>
</td></tr>
<tr><td><code id="bilinear_+3A_newy">newy</code></td>
<td>
<p>vector of new <code>y</code> values to interpolate</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bilinear</code> finds a bilinear interpolation bounded by four corners
</p>


<h3>Value</h3>

<p>a vector of interpolated z values at (<code>x</code>, <code>y</code>)
</p>


<h3>See Also</h3>

<p>Other interp: 
<code><a href="#topic+bezier">bezier</a></code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nn">nn</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>
</p>
<p>Other algebra: 
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+division">division</a></code>,
<code><a href="#topic+fibonacci">fibonacci</a>()</code>,
<code><a href="#topic+horner">horner</a>()</code>,
<code><a href="#topic+isPrime">isPrime</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nthroot">nthroot</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>,
<code><a href="#topic+quadratic">quadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2, 4)
y &lt;- c(4, 7)
z &lt;- matrix(c(81, 84, 85, 89), nrow = 2)
newx &lt;- c(2.5, 3, 3.5)
newy &lt;- c(5, 5.5, 6)
bilinear(x, y, z, newx, newy)

</code></pre>

<hr>
<h2 id='bisection'>The Bisection Method</h2><span id='topic+bisection'></span>

<h3>Description</h3>

<p>Use the bisection method to find real roots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bisection(f, a, b, tol = 0.001, m = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bisection_+3A_f">f</code></td>
<td>
<p>function to locate a root for</p>
</td></tr>
<tr><td><code id="bisection_+3A_a">a</code></td>
<td>
<p>the a bound of the search region</p>
</td></tr>
<tr><td><code id="bisection_+3A_b">b</code></td>
<td>
<p>the b bound of the search region</p>
</td></tr>
<tr><td><code id="bisection_+3A_tol">tol</code></td>
<td>
<p>the error tolerance</p>
</td></tr>
<tr><td><code id="bisection_+3A_m">m</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bisection method functions by repeatedly halving the interval
between <code>a</code> and <code>b</code> and will return when the
interval between them is less than <code>tol</code>, the error tolerance.
However, this implementation also stops if after <code>m</code>
iterations.
</p>


<h3>Value</h3>

<p>the real root found
</p>


<h3>See Also</h3>

<p>Other optimz: 
<code><a href="#topic+goldsect">goldsect</a></code>,
<code><a href="#topic+gradient">gradient</a></code>,
<code><a href="#topic+hillclimbing">hillclimbing</a>()</code>,
<code><a href="#topic+newton">newton</a>()</code>,
<code><a href="#topic+sa">sa</a>()</code>,
<code><a href="#topic+secant">secant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { x^3 - 2 * x^2 - 159 * x - 540}
bisection(f, 0, 10)

</code></pre>

<hr>
<h2 id='bvp'>Boundary value problems</h2><span id='topic+bvp'></span><span id='topic+bvpexample'></span><span id='topic+bvpexample10'></span>

<h3>Description</h3>

<p>solve boundary value problems for ordinary differential equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvpexample(x)

bvpexample10(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvp_+3A_x">x</code></td>
<td>
<p>proposed initial <code>x</code>-value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>euler</code> method implements the Euler method for solving
differential equations.  The codemidptivp method solves initial
value problems using the second-order Runge-Kutta method.  The
<code>rungekutta4</code> method is the fourth-order Runge-Kutta method.
</p>


<h3>Value</h3>

<p>a data frame of <code>x</code> and <code>y</code> values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bvpexample(-2)
bvpexample(-1)
bvpexample(0)
bvpexample(1)
bvpexample(2)
## (bvp.b &lt;- bisection(bvpexample, 0, 1))
## (bvp.s &lt;- secant(bvpexample, 0))

</code></pre>

<hr>
<h2 id='choleskymatrix'>Cholesky Decomposition</h2><span id='topic+choleskymatrix'></span>

<h3>Description</h3>

<p>Decompose a matrix into the Cholesky
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choleskymatrix(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choleskymatrix_+3A_m">m</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>choleskymatrix</code> decomposes the matrix <code>m</code> into the LU
decomposition, such that m == L 
</p>


<h3>Value</h3>

<p>the matrix L
</p>


<h3>See Also</h3>

<p>Other linear: 
<code><a href="#topic+detmatrix">detmatrix</a>()</code>,
<code><a href="#topic+gdls">gdls</a>()</code>,
<code><a href="#topic+invmatrix">invmatrix</a>()</code>,
<code><a href="#topic+iterativematrix">iterativematrix</a></code>,
<code><a href="#topic+lumatrix">lumatrix</a>()</code>,
<code><a href="#topic+refmatrix">refmatrix</a>()</code>,
<code><a href="#topic+rowops">rowops</a></code>,
<code><a href="#topic+tridiagmatrix">tridiagmatrix</a>()</code>,
<code><a href="#topic+vecnorm">vecnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(A &lt;- matrix(c(5, 1, 2, 1, 9, 3, 2, 3, 7), 3))
(L &lt;- choleskymatrix(A))
t(L) %*% L

</code></pre>

<hr>
<h2 id='cmna-package'>Computational Methods for Numerical Analysis</h2><span id='topic+cmna'></span><span id='topic+cmna-package'></span>

<h3>Description</h3>

<p>Provides the source and examples for <em>Computational Methods for
Numerical Analysis with R</em>.
</p>


<h3>Details</h3>

<p>This package provides a suite of simple implementations of standard
methods from numerical analysis.  The collection is designed to
accompany <em>Computational Methods for Numerical Analysis with R</em>
by James P. Howard, II.  Together, these functions provide methods to
support linear algebra, interpolation, integration, root finding,
optimization, and differential equations.
</p>


<h3>Author(s)</h3>

<p>James P. Howard, II &lt;jh@jameshoward.us&gt;
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jameshoward.us/cmna/">https://jameshoward.us/cmna/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/k3jph/cmna-pkg/issues">https://github.com/k3jph/cmna-pkg/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cubicspline'>Natural cubic spline interpolation</h2><span id='topic+cubicspline'></span>

<h3>Description</h3>

<p>Finds a piecewise linear function that interpolates the data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubicspline(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubicspline_+3A_x">x</code></td>
<td>
<p>a vector of x values</p>
</td></tr>
<tr><td><code id="cubicspline_+3A_y">y</code></td>
<td>
<p>a vector of y values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cubicspline</code> finds a piecewise cubic spline function that
interpolates the data points.  For each x-y ordered pair. The function will
return a list of four vectors representing the coefficients.
</p>


<h3>Value</h3>

<p>a list of coefficient vectors
</p>


<h3>See Also</h3>

<p>Other interp: 
<code><a href="#topic+bezier">bezier</a></code>,
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nn">nn</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>
</p>
<p>Other algebra: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+division">division</a></code>,
<code><a href="#topic+fibonacci">fibonacci</a>()</code>,
<code><a href="#topic+horner">horner</a>()</code>,
<code><a href="#topic+isPrime">isPrime</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nthroot">nthroot</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>,
<code><a href="#topic+quadratic">quadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 3)
y &lt;- c(2, 3, 5)
f &lt;- cubicspline(x, y)

x &lt;- c(-1, 1, 0, -2)
y &lt;- c(-2, 2, -1, -1)
f &lt;- cubicspline(x, y)

</code></pre>

<hr>
<h2 id='detmatrix'>Calculate the determinant of the matrix</h2><span id='topic+detmatrix'></span>

<h3>Description</h3>

<p>Calculate the determinant of the matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detmatrix(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detmatrix_+3A_m">m</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>detmatrix</code> calculates the determinant of the matrix given.
</p>


<h3>Value</h3>

<p>the determinant
</p>


<h3>See Also</h3>

<p>Other linear: 
<code><a href="#topic+choleskymatrix">choleskymatrix</a>()</code>,
<code><a href="#topic+gdls">gdls</a>()</code>,
<code><a href="#topic+invmatrix">invmatrix</a>()</code>,
<code><a href="#topic+iterativematrix">iterativematrix</a></code>,
<code><a href="#topic+lumatrix">lumatrix</a>()</code>,
<code><a href="#topic+refmatrix">refmatrix</a>()</code>,
<code><a href="#topic+rowops">rowops</a></code>,
<code><a href="#topic+tridiagmatrix">tridiagmatrix</a>()</code>,
<code><a href="#topic+vecnorm">vecnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1, 2, -7, -1, -1, 1, 2, 1, 5), 3)
detmatrix(A)

</code></pre>

<hr>
<h2 id='division'>Algorithms for divisions</h2><span id='topic+division'></span><span id='topic+naivediv'></span><span id='topic+longdiv'></span>

<h3>Description</h3>

<p>Algorithms for division that provide a quotient and remainder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naivediv(m, n)

longdiv(m, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="division_+3A_m">m</code></td>
<td>
<p>the dividend</p>
</td></tr>
<tr><td><code id="division_+3A_n">n</code></td>
<td>
<p>the divisor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>naivediv</code> divides <code>m</code> by <code>n</code> by using repeated
division.  The <code>longdiv</code> function uses the long division
algorithm in binary.
</p>


<h3>Value</h3>

<p>the quotient and remainder as a list
</p>


<h3>See Also</h3>

<p>Other algebra: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+fibonacci">fibonacci</a>()</code>,
<code><a href="#topic+horner">horner</a>()</code>,
<code><a href="#topic+isPrime">isPrime</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nthroot">nthroot</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>,
<code><a href="#topic+quadratic">quadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- floor(runif(1, 1, 1000))
b &lt;- floor(runif(1, 1, 100))
naivediv(a, b)
longdiv(a, b)

</code></pre>

<hr>
<h2 id='fibonacci'>Fibonacci numbers</h2><span id='topic+fibonacci'></span>

<h3>Description</h3>

<p>Return the n-th Fibonacci number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fibonacci(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fibonacci_+3A_n">n</code></td>
<td>
<p>n</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is recursively implements the famous Fibonacci
sequence.  The function returns the <code>n</code>th member of the
sequence.
</p>


<h3>Value</h3>

<p>the sequence element
</p>


<h3>See Also</h3>

<p>Other algebra: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+division">division</a></code>,
<code><a href="#topic+horner">horner</a>()</code>,
<code><a href="#topic+isPrime">isPrime</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nthroot">nthroot</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>,
<code><a href="#topic+quadratic">quadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fibonacci(10)

</code></pre>

<hr>
<h2 id='findiff'>Finite Differences</h2><span id='topic+findiff'></span><span id='topic+symdiff'></span><span id='topic+findiff2'></span><span id='topic+rdiff'></span>

<h3>Description</h3>

<p>Finite differences formulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findiff(f, x, h = x * sqrt(.Machine$double.eps))

symdiff(f, x, h = x * .Machine$double.eps^(1/3))

findiff2(f, x, h)

rdiff(f, x, n = 10, h = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findiff_+3A_f">f</code></td>
<td>
<p>function to differentiate</p>
</td></tr>
<tr><td><code id="findiff_+3A_x">x</code></td>
<td>
<p>the <code>x</code>-value to differentiate at</p>
</td></tr>
<tr><td><code id="findiff_+3A_h">h</code></td>
<td>
<p>the step-size for evaluation</p>
</td></tr>
<tr><td><code id="findiff_+3A_n">n</code></td>
<td>
<p>the maximum number of convergence steps in <code>rdiff</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>findiff</code> formula uses the finite differences formula to
find the derivative of <code>f</code> at <code>x</code>.  The value of <code>h</code>
is the step size of the evaluation. The function <code>findiff2</code>
provides the second derivative.
</p>


<h3>Value</h3>

<p>the value of the derivative
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findiff(sin, pi, 1e-3)
symdiff(sin, pi, 1e-3)

</code></pre>

<hr>
<h2 id='gaussint'>Gaussian integration method driver</h2><span id='topic+gaussint'></span><span id='topic+gauss.legendre'></span><span id='topic+gauss.laguerre'></span><span id='topic+gauss.hermite'></span>

<h3>Description</h3>

<p>Use the Gaussian method to evaluate integrals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussint(f, x, w)

gauss.legendre(f, m = 5)

gauss.laguerre(f, m = 5)

gauss.hermite(f, m = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussint_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="gaussint_+3A_x">x</code></td>
<td>
<p>list of evaluation points</p>
</td></tr>
<tr><td><code id="gaussint_+3A_w">w</code></td>
<td>
<p>list of weights</p>
</td></tr>
<tr><td><code id="gaussint_+3A_m">m</code></td>
<td>
<p>number of evaluation points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>gaussint</code> function uses the Gaussian integration to
evaluate an integral.  The function itself is a driver and expects
the integration points and associated weights as options.
</p>


<h3>Value</h3>

<p>the value of the integral
</p>


<h3>See Also</h3>

<p>Other integration: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+mcint">mcint</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+revolution-solid">revolution-solid</a></code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w = c(1, 1)
x = c(-1 / sqrt(3), 1 / sqrt(3))
f &lt;- function(x) { x^3 + x + 1 }
gaussint(f, x, w)

</code></pre>

<hr>
<h2 id='gdls'>Least squares with graident descent</h2><span id='topic+gdls'></span>

<h3>Description</h3>

<p>Solve least squares with graident descent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdls(A, b, alpha = 0.05, tol = 1e-06, m = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdls_+3A_a">A</code></td>
<td>
<p>a square matrix representing the coefficients of a linear system</p>
</td></tr>
<tr><td><code id="gdls_+3A_b">b</code></td>
<td>
<p>a vector representing the right-hand side of the linear system</p>
</td></tr>
<tr><td><code id="gdls_+3A_alpha">alpha</code></td>
<td>
<p>the learning rate</p>
</td></tr>
<tr><td><code id="gdls_+3A_tol">tol</code></td>
<td>
<p>the expected error tolerance</p>
</td></tr>
<tr><td><code id="gdls_+3A_m">m</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gdls</code> solves a linear system using gradient descent.
</p>


<h3>Value</h3>

<p>the modified matrix
</p>


<h3>See Also</h3>

<p>Other linear: 
<code><a href="#topic+choleskymatrix">choleskymatrix</a>()</code>,
<code><a href="#topic+detmatrix">detmatrix</a>()</code>,
<code><a href="#topic+invmatrix">invmatrix</a>()</code>,
<code><a href="#topic+iterativematrix">iterativematrix</a></code>,
<code><a href="#topic+lumatrix">lumatrix</a>()</code>,
<code><a href="#topic+refmatrix">refmatrix</a>()</code>,
<code><a href="#topic+rowops">rowops</a></code>,
<code><a href="#topic+tridiagmatrix">tridiagmatrix</a>()</code>,
<code><a href="#topic+vecnorm">vecnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(b &lt;- iris$Sepal.Length)
head(A &lt;- matrix(cbind(1, iris$Sepal.Width, iris$Petal.Length, iris$Petal.Width), ncol = 4))
gdls(A, b, alpha = 0.05, m = 10000)

</code></pre>

<hr>
<h2 id='giniquintile'>Gini coefficients</h2><span id='topic+giniquintile'></span>

<h3>Description</h3>

<p>Calculate the Gini coefficient from quintile data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>giniquintile(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="giniquintile_+3A_l">L</code></td>
<td>
<p>vector of percentages at 20th, 40th, 60th, and 80th
percentiles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the Gini coefficient given the quintile data.
</p>


<h3>Value</h3>

<p>the estimated Gini coefficient
</p>


<h3>References</h3>

<p>Leon Gerber, &quot;A Quintile Rule for the Gini Coefficient&quot;,
<em>Mathematics Magazine</em>, 80:2, April 2007.
</p>


<h3>See Also</h3>

<p>Other integration: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+gaussint">gaussint</a>()</code>,
<code><a href="#topic+mcint">mcint</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+revolution-solid">revolution-solid</a></code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>
<p>Other newton-cotes: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- c(4.3, 9.8, 15.4, 22.7)
giniquintile(L)

</code></pre>

<hr>
<h2 id='goldsect'>Golden Section Search</h2><span id='topic+goldsect'></span><span id='topic+goldsectmin'></span><span id='topic+goldsectmax'></span>

<h3>Description</h3>

<p>Use golden section search to find local extrema
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goldsectmin(f, a, b, tol = 0.001, m = 100)

goldsectmax(f, a, b, tol = 0.001, m = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goldsect_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="goldsect_+3A_a">a</code></td>
<td>
<p>the a bound of the search region</p>
</td></tr>
<tr><td><code id="goldsect_+3A_b">b</code></td>
<td>
<p>the b bound of the search region</p>
</td></tr>
<tr><td><code id="goldsect_+3A_tol">tol</code></td>
<td>
<p>the error tolerance</p>
</td></tr>
<tr><td><code id="goldsect_+3A_m">m</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The golden section search  method functions by repeatedly dividing the interval
between <code>a</code> and <code>b</code> and will return when the
interval between them is less than <code>tol</code>, the error tolerance.
However, this implementation also stop if after <code>m</code>
iterations.
</p>


<h3>Value</h3>

<p>the <code>x</code> value of the minimum found
</p>


<h3>See Also</h3>

<p>Other optimz: 
<code><a href="#topic+bisection">bisection</a>()</code>,
<code><a href="#topic+gradient">gradient</a></code>,
<code><a href="#topic+hillclimbing">hillclimbing</a>()</code>,
<code><a href="#topic+newton">newton</a>()</code>,
<code><a href="#topic+sa">sa</a>()</code>,
<code><a href="#topic+secant">secant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { x^2 - 3 * x + 3 }
goldsectmin(f, 0, 5)

</code></pre>

<hr>
<h2 id='gradient'>Gradient descent</h2><span id='topic+gradient'></span><span id='topic+graddsc'></span><span id='topic+gradasc'></span><span id='topic+gd'></span>

<h3>Description</h3>

<p>Use gradient descent to find local minima
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graddsc(fp, x, h = 0.001, tol = 1e-04, m = 1000)

gradasc(fp, x, h = 0.001, tol = 1e-04, m = 1000)

gd(fp, x, h = 100, tol = 1e-04, m = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient_+3A_fp">fp</code></td>
<td>
<p>function representing the derivative of <code>f</code></p>
</td></tr>
<tr><td><code id="gradient_+3A_x">x</code></td>
<td>
<p>an initial estimate of the minima</p>
</td></tr>
<tr><td><code id="gradient_+3A_h">h</code></td>
<td>
<p>the step size</p>
</td></tr>
<tr><td><code id="gradient_+3A_tol">tol</code></td>
<td>
<p>the error tolerance</p>
</td></tr>
<tr><td><code id="gradient_+3A_m">m</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gradient descent can be used to find local minima of functions.  It
will return an approximation based on the step size <code>h</code> and
<code>fp</code>.  The <code>tol</code> is the error tolerance, <code>x</code> is the
initial guess at the minimum.  This implementation also stops after
<code>m</code> iterations.
</p>


<h3>Value</h3>

<p>the <code>x</code> value of the minimum found
</p>


<h3>See Also</h3>

<p>Other optimz: 
<code><a href="#topic+bisection">bisection</a>()</code>,
<code><a href="#topic+goldsect">goldsect</a></code>,
<code><a href="#topic+hillclimbing">hillclimbing</a>()</code>,
<code><a href="#topic+newton">newton</a>()</code>,
<code><a href="#topic+sa">sa</a>()</code>,
<code><a href="#topic+secant">secant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fp &lt;- function(x) { x^3 + 3 * x^2 - 1 }
graddsc(fp, 0)

f &lt;- function(x) { (x[1] - 1)^2 + (x[2] - 1)^2 }
fp &lt;-function(x) {
    x1 &lt;- 2 * x[1] - 2
    x2 &lt;- 8 * x[2] - 8

    return(c(x1, x2))
}
gd(fp, c(0, 0), 0.05)
</code></pre>

<hr>
<h2 id='heat'>Heat Equation via Forward-Time Central-Space</h2><span id='topic+heat'></span>

<h3>Description</h3>

<p>solve heat equation via forward-time central-space method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heat(u, alpha, xdelta, tdelta, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heat_+3A_u">u</code></td>
<td>
<p>the initial values of u</p>
</td></tr>
<tr><td><code id="heat_+3A_alpha">alpha</code></td>
<td>
<p>the thermal diffusivity coefficient</p>
</td></tr>
<tr><td><code id="heat_+3A_xdelta">xdelta</code></td>
<td>
<p>the change in <code>x</code> at each step in <code>u</code></p>
</td></tr>
<tr><td><code id="heat_+3A_tdelta">tdelta</code></td>
<td>
<p>the time step</p>
</td></tr>
<tr><td><code id="heat_+3A_n">n</code></td>
<td>
<p>the number of steps to take</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>heat</code> solves the heat equation using the forward-time
central-space method in one-dimension.
</p>


<h3>Value</h3>

<p>a matrix of u values at each time step
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 1
x0 &lt;- 0
xdelta &lt;- .05
x &lt;- seq(x0, 1, xdelta)
u &lt;- sin(x^4 * pi)
tdelta &lt;- .001
n &lt;- 25
z &lt;- heat(u, alpha, xdelta, tdelta, n)

</code></pre>

<hr>
<h2 id='hillclimbing'>Hill climbing</h2><span id='topic+hillclimbing'></span>

<h3>Description</h3>

<p>Use hill climbing to find the global minimum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hillclimbing(f, x, h = 1, m = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hillclimbing_+3A_f">f</code></td>
<td>
<p>function representing the derivative of <code>f</code></p>
</td></tr>
<tr><td><code id="hillclimbing_+3A_x">x</code></td>
<td>
<p>an initial estimate of the minimum</p>
</td></tr>
<tr><td><code id="hillclimbing_+3A_h">h</code></td>
<td>
<p>the step size</p>
</td></tr>
<tr><td><code id="hillclimbing_+3A_m">m</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hill climbing
</p>


<h3>Value</h3>

<p>the <code>x</code> value of the minimum found
</p>


<h3>See Also</h3>

<p>Other optimz: 
<code><a href="#topic+bisection">bisection</a>()</code>,
<code><a href="#topic+goldsect">goldsect</a></code>,
<code><a href="#topic+gradient">gradient</a></code>,
<code><a href="#topic+newton">newton</a>()</code>,
<code><a href="#topic+sa">sa</a>()</code>,
<code><a href="#topic+secant">secant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) {
    (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2
}
hillclimbing(f, c(0,0))
hillclimbing(f, c(-1,-1))
hillclimbing(f, c(10,10))

</code></pre>

<hr>
<h2 id='himmelblau'>Himmelblau Function</h2><span id='topic+himmelblau'></span>

<h3>Description</h3>

<p>Generate the Himmelblau function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>himmelblau(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="himmelblau_+3A_x">x</code></td>
<td>
<p>a vector of <code>x</code>-values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate the Himmelblau function
</p>


<h3>Value</h3>

<p>the value of the function at <code>x</code>.
</p>

<hr>
<h2 id='horner'>Horner's rule</h2><span id='topic+horner'></span><span id='topic+rhorner'></span><span id='topic+naivepoly'></span><span id='topic+betterpoly'></span>

<h3>Description</h3>

<p>Use Horner's rule to evaluate a polynomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horner(x, coefs)

rhorner(x, coefs)

naivepoly(x, coefs)

betterpoly(x, coefs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horner_+3A_x">x</code></td>
<td>
<p>a vector of x values to evaluate the polynomial</p>
</td></tr>
<tr><td><code id="horner_+3A_coefs">coefs</code></td>
<td>
<p>vector of coefficients of x</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements Horner's rule for fast polynomial
evaluation.  The implementation expects <code>x</code> to be a vector of x
values at which to evaluate the polynomial. The parameter <code>coefs</code>
is a vector of coefficients of <em>x</em>.  The vector order is such
that the first element is the constant term, the second element is
the coefficient of <em>x</em>, the so forth to the highest degreed
term.  Terms with a 0 coefficient should have a 0 element in the
vector.
</p>
<p>The function <code>rhorner</code> implements the the Horner algorithm
recursively.
</p>
<p>The function <code>naivepoly</code> implements a polynomial evaluator using
the straightforward algebraic approach.
</p>
<p>The function <code>betterpoly</code> implements a polynomial evaluator using
the straightforward algebraic approach with cached <em>x</em> terms.
</p>


<h3>Value</h3>

<p>the value of the function at <code>x</code>
</p>


<h3>See Also</h3>

<p>Other algebra: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+division">division</a></code>,
<code><a href="#topic+fibonacci">fibonacci</a>()</code>,
<code><a href="#topic+isPrime">isPrime</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nthroot">nthroot</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>,
<code><a href="#topic+quadratic">quadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- c(2, 10, 11)
x &lt;- 5
horner(x, b)
b &lt;- c(-1, 0, 1)
x &lt;- c(1, 2, 3, 4)
horner(x, b)
rhorner(x, b)
</code></pre>

<hr>
<h2 id='invmatrix'>Invert a matrix</h2><span id='topic+invmatrix'></span>

<h3>Description</h3>

<p>Invert the matrix using Gaussian elimination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invmatrix(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invmatrix_+3A_m">m</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>invmatrix</code> invertse the given matrix using Gaussian elimination
and returns the result.
</p>


<h3>Value</h3>

<p>the inverted matrix
</p>


<h3>See Also</h3>

<p>Other linear: 
<code><a href="#topic+choleskymatrix">choleskymatrix</a>()</code>,
<code><a href="#topic+detmatrix">detmatrix</a>()</code>,
<code><a href="#topic+gdls">gdls</a>()</code>,
<code><a href="#topic+iterativematrix">iterativematrix</a></code>,
<code><a href="#topic+lumatrix">lumatrix</a>()</code>,
<code><a href="#topic+refmatrix">refmatrix</a>()</code>,
<code><a href="#topic+rowops">rowops</a></code>,
<code><a href="#topic+tridiagmatrix">tridiagmatrix</a>()</code>,
<code><a href="#topic+vecnorm">vecnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1, 2, -7, -1, -1, 1, 2, 1, 5), 3)
refmatrix(A)

</code></pre>

<hr>
<h2 id='isPrime'>Test for Primality</h2><span id='topic+isPrime'></span>

<h3>Description</h3>

<p>Test the number given for primality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isPrime(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isPrime_+3A_n">n</code></td>
<td>
<p>n</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests <code>n</code> if it is prime through repeated division
attempts.  If a match is found, by finding a remainder of 0,
<code>FALSE</code> is returned.
</p>


<h3>Value</h3>

<p>boolean TRUE if <code>n</code> is prime, FALSE if not
</p>


<h3>See Also</h3>

<p>Other algebra: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+division">division</a></code>,
<code><a href="#topic+fibonacci">fibonacci</a>()</code>,
<code><a href="#topic+horner">horner</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nthroot">nthroot</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>,
<code><a href="#topic+quadratic">quadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isPrime(37)
isPrime(89)
isPrime(100)

</code></pre>

<hr>
<h2 id='iterativematrix'>Solve a matrix using iterative methods</h2><span id='topic+iterativematrix'></span><span id='topic+jacobi'></span><span id='topic+gaussseidel'></span><span id='topic+cgmmatrix'></span>

<h3>Description</h3>

<p>Solve a matrix using iterative methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobi(A, b, tol = 1e-06, maxiter = 100)

gaussseidel(A, b, tol = 1e-06, maxiter = 100)

cgmmatrix(A, b, tol = 1e-06, maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterativematrix_+3A_a">A</code></td>
<td>
<p>a square matrix representing the coefficients of a linear
system</p>
</td></tr>
<tr><td><code id="iterativematrix_+3A_b">b</code></td>
<td>
<p>a vector representing the right-hand side of the linear
system</p>
</td></tr>
<tr><td><code id="iterativematrix_+3A_tol">tol</code></td>
<td>
<p>is a number representing the error tolerence</p>
</td></tr>
<tr><td><code id="iterativematrix_+3A_maxiter">maxiter</code></td>
<td>
<p>is the maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>jacobi</code> finds the solution using Jacobi iteration.
Jacobi iteration depends on the matrix being diagonally-dominate.
The tolerence is specified the norm of the solution vector.
</p>
<p><code>gaussseidel</code> finds the solution using Gauss-Seidel iteration.
Gauss-Seidel iteration depends on the matrix being either
diagonally-dominate or symmetric and positive definite.
</p>
<p><code>cgmmatrix</code> finds the solution using the conjugate gradient
method.  The conjugate gradient method depends on the matrix being
symmetric and positive definite.
</p>


<h3>Value</h3>

<p>the solution vector
</p>


<h3>See Also</h3>

<p>Other linear: 
<code><a href="#topic+choleskymatrix">choleskymatrix</a>()</code>,
<code><a href="#topic+detmatrix">detmatrix</a>()</code>,
<code><a href="#topic+gdls">gdls</a>()</code>,
<code><a href="#topic+invmatrix">invmatrix</a>()</code>,
<code><a href="#topic+lumatrix">lumatrix</a>()</code>,
<code><a href="#topic+refmatrix">refmatrix</a>()</code>,
<code><a href="#topic+rowops">rowops</a></code>,
<code><a href="#topic+tridiagmatrix">tridiagmatrix</a>()</code>,
<code><a href="#topic+vecnorm">vecnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(5, 2, 1, 2, 7, 3, 3, 4, 8), 3)
b &lt;- c(40, 39, 55)
jacobi(A, b)

</code></pre>

<hr>
<h2 id='ivp'>Initial value problems</h2><span id='topic+ivp'></span><span id='topic+euler'></span><span id='topic+midptivp'></span><span id='topic+rungekutta4'></span><span id='topic+adamsbashforth'></span>

<h3>Description</h3>

<p>solve initial value problems for ordinary differential equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler(f, x0, y0, h, n)

midptivp(f, x0, y0, h, n)

rungekutta4(f, x0, y0, h, n)

adamsbashforth(f, x0, y0, h, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivp_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="ivp_+3A_x0">x0</code></td>
<td>
<p>the initial value of x</p>
</td></tr>
<tr><td><code id="ivp_+3A_y0">y0</code></td>
<td>
<p>the initial value of y</p>
</td></tr>
<tr><td><code id="ivp_+3A_h">h</code></td>
<td>
<p>selected step size</p>
</td></tr>
<tr><td><code id="ivp_+3A_n">n</code></td>
<td>
<p>the number of steps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>euler</code> method implements the Euler method for solving
differential equations.  The codemidptivp method solves initial
value problems using the second-order Runge-Kutta method.  The
<code>rungekutta4</code> method is the fourth-order Runge-Kutta method.
</p>


<h3>Value</h3>

<p>a data frame of <code>x</code> and <code>y</code> values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x, y) { y / (2 * x + 1) }
ivp.euler &lt;- euler(f, 0, 1, 1/100, 100)
ivp.midpt &lt;- midptivp(f, 0, 1, 1/100, 100)
ivp.rk4 &lt;- rungekutta4(f, 0, 1, 1/100, 100)
</code></pre>

<hr>
<h2 id='ivpsys'>Initial value problems for systems of ordinary differential equations</h2><span id='topic+ivpsys'></span><span id='topic+eulersys'></span>

<h3>Description</h3>

<p>solve initial value problems for systems ordinary differential equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eulersys(f, x0, y0, h, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivpsys_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="ivpsys_+3A_x0">x0</code></td>
<td>
<p>the initial value of x</p>
</td></tr>
<tr><td><code id="ivpsys_+3A_y0">y0</code></td>
<td>
<p>the vector initial values of y</p>
</td></tr>
<tr><td><code id="ivpsys_+3A_h">h</code></td>
<td>
<p>selected step size</p>
</td></tr>
<tr><td><code id="ivpsys_+3A_n">n</code></td>
<td>
<p>the number of steps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>euler</code> method implements the Euler method for solving
differential equations.  The codemidptivp method solves initial
value problems using the second-order Runge-Kutta method.  The
<code>rungekutta4</code> method is the fourth-order Runge-Kutta method.
</p>


<h3>Value</h3>

<p>a data frame of <code>x</code> and <code>y</code> values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x, y) { y / (2 * x + 1) }
ivp.euler &lt;- euler(f, 0, 1, 1/100, 100)
</code></pre>

<hr>
<h2 id='linterp'>Linear interpolation</h2><span id='topic+linterp'></span>

<h3>Description</h3>

<p>Finds a linear function between two points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linterp(x1, y1, x2, y2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linterp_+3A_x1">x1</code></td>
<td>
<p>x value of the first point</p>
</td></tr>
<tr><td><code id="linterp_+3A_y1">y1</code></td>
<td>
<p>y value of the first point</p>
</td></tr>
<tr><td><code id="linterp_+3A_x2">x2</code></td>
<td>
<p>x value of the second point</p>
</td></tr>
<tr><td><code id="linterp_+3A_y2">y2</code></td>
<td>
<p>y value of the second point</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>linterp</code> finds a linear function  between two points.
</p>


<h3>Value</h3>

<p>a linear equation's coefficients
</p>


<h3>See Also</h3>

<p>Other interp: 
<code><a href="#topic+bezier">bezier</a></code>,
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+nn">nn</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>
</p>
<p>Other algebra: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+division">division</a></code>,
<code><a href="#topic+fibonacci">fibonacci</a>()</code>,
<code><a href="#topic+horner">horner</a>()</code>,
<code><a href="#topic+isPrime">isPrime</a>()</code>,
<code><a href="#topic+nthroot">nthroot</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>,
<code><a href="#topic+quadratic">quadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- linterp(3, 2, 7, -2)

</code></pre>

<hr>
<h2 id='lumatrix'>LU Decomposition</h2><span id='topic+lumatrix'></span>

<h3>Description</h3>

<p>Decompose a matrix into lower- and upper-triangular matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lumatrix(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lumatrix_+3A_m">m</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lumatrix</code> decomposes the matrix <code>m</code> into the LU
decomposition, such that m == L 
</p>


<h3>Value</h3>

<p>list with matrices L and U representing the LU decomposition
</p>


<h3>See Also</h3>

<p>Other linear: 
<code><a href="#topic+choleskymatrix">choleskymatrix</a>()</code>,
<code><a href="#topic+detmatrix">detmatrix</a>()</code>,
<code><a href="#topic+gdls">gdls</a>()</code>,
<code><a href="#topic+invmatrix">invmatrix</a>()</code>,
<code><a href="#topic+iterativematrix">iterativematrix</a></code>,
<code><a href="#topic+refmatrix">refmatrix</a>()</code>,
<code><a href="#topic+rowops">rowops</a></code>,
<code><a href="#topic+tridiagmatrix">tridiagmatrix</a>()</code>,
<code><a href="#topic+vecnorm">vecnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1, 2, -7, -1, -1, 1, 2, 1, 5), 3)
lumatrix(A)

</code></pre>

<hr>
<h2 id='mcint'>Monte Carlo Integration</h2><span id='topic+mcint'></span><span id='topic+mcint2'></span>

<h3>Description</h3>

<p>Simple Monte Carlo Integraton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcint(f, a, b, m = 1000)

mcint2(f, xdom, ydom, m = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcint_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="mcint_+3A_a">a</code></td>
<td>
<p>the lower-bound of integration</p>
</td></tr>
<tr><td><code id="mcint_+3A_b">b</code></td>
<td>
<p>the upper-bound of integration</p>
</td></tr>
<tr><td><code id="mcint_+3A_m">m</code></td>
<td>
<p>the number of subintervals to calculate</p>
</td></tr>
<tr><td><code id="mcint_+3A_xdom">xdom</code></td>
<td>
<p>the domain on <code>x</code> of integration in two dimensions</p>
</td></tr>
<tr><td><code id="mcint_+3A_ydom">ydom</code></td>
<td>
<p>the domain on <code>y</code> of integration in two dimensions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mcint</code> function uses a simple Monte Carlo algorithm to
estimate the value of an integral.  The parameter <code>n</code> sets the
total number of evaluation points.  The parameter <code>max.y</code> is the
maximum expected value of the range of function <code>f</code>.  The
<code>mcint2</code> provides Monte Carlo integration in two dimensions.
</p>


<h3>Value</h3>

<p>the value of the integral
</p>


<h3>See Also</h3>

<p>Other integration: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+gaussint">gaussint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+revolution-solid">revolution-solid</a></code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { sin(x)^2 + log(x)}
mcint(f, 0, 1)
mcint(f, 0, 1, m = 10e6)

</code></pre>

<hr>
<h2 id='midpt'>rectangle method</h2><span id='topic+midpt'></span>

<h3>Description</h3>

<p>Use the rectangle method to integrate a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midpt(f, a, b, m = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midpt_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="midpt_+3A_a">a</code></td>
<td>
<p>the a-bound of integration</p>
</td></tr>
<tr><td><code id="midpt_+3A_b">b</code></td>
<td>
<p>the b-bound of integration</p>
</td></tr>
<tr><td><code id="midpt_+3A_m">m</code></td>
<td>
<p>the number of subintervals to calculate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>midpt</code> function uses the rectangle method to calculate
the integral of the function <code>f</code> over the interval from
<code>a</code> to <code>b</code>.  The parameter <code>m</code> sets the number
of intervals to use when evaluating the rectangles.  Additional
options are passed to the function <code>f</code> when evaluating.
</p>


<h3>Value</h3>

<p>the value of the integral
</p>


<h3>See Also</h3>

<p>Other integration: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+gaussint">gaussint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+mcint">mcint</a>()</code>,
<code><a href="#topic+revolution-solid">revolution-solid</a></code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>
<p>Other newton-cotes: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { sin(x)^2 + cos(x)^2 }
midpt(f, -pi, pi, m = 10)
midpt(f, -pi, pi, m = 100)
midpt(f, -pi, pi, m = 1000)

</code></pre>

<hr>
<h2 id='newton'>Newton's method</h2><span id='topic+newton'></span>

<h3>Description</h3>

<p>Use Newton's method to find real roots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newton(f, fp, x, tol = 0.001, m = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newton_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="newton_+3A_fp">fp</code></td>
<td>
<p>function representing the derivative of <code>f</code></p>
</td></tr>
<tr><td><code id="newton_+3A_x">x</code></td>
<td>
<p>an initial estimate of the root</p>
</td></tr>
<tr><td><code id="newton_+3A_tol">tol</code></td>
<td>
<p>the error tolerance</p>
</td></tr>
<tr><td><code id="newton_+3A_m">m</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Newton's method finds real roots of a function, but requires knowing
the function derivative.  It will return when the interval between
them is less than <code>tol</code>, the error tolerance.  However, this
implementation also stops after <code>m</code> iterations.
</p>


<h3>Value</h3>

<p>the real root found
</p>


<h3>See Also</h3>

<p>Other optimz: 
<code><a href="#topic+bisection">bisection</a>()</code>,
<code><a href="#topic+goldsect">goldsect</a></code>,
<code><a href="#topic+gradient">gradient</a></code>,
<code><a href="#topic+hillclimbing">hillclimbing</a>()</code>,
<code><a href="#topic+sa">sa</a>()</code>,
<code><a href="#topic+secant">secant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { x^3 - 2 * x^2 - 159 * x - 540 }
fp &lt;- function(x) {3 * x^2 - 4 * x - 159 }
newton(f, fp, 1)

</code></pre>

<hr>
<h2 id='nn'>Nearest interpolation</h2><span id='topic+nn'></span>

<h3>Description</h3>

<p>Find the nearest neighbor for a set of data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nn(p, y, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nn_+3A_p">p</code></td>
<td>
<p>matrix of variable values, each row is a data point</p>
</td></tr>
<tr><td><code id="nn_+3A_y">y</code></td>
<td>
<p>vector of values, each entry corresponds to one row in <code>p</code></p>
</td></tr>
<tr><td><code id="nn_+3A_q">q</code></td>
<td>
<p>vector of variable values, each entry corresponds to one column of <code>p</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nn</code> finds the n-dimensional nearest neighbor for given datapoint
</p>


<h3>Value</h3>

<p>an interpolated value for <var>q</var>
</p>


<h3>See Also</h3>

<p>Other interp: 
<code><a href="#topic+bezier">bezier</a></code>,
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- matrix(floor(runif(100, 0, 9)), 20)
y &lt;- floor(runif(20, 0, 9))
q &lt;- matrix(floor(runif(5, 0, 9)), 1)
nn(p, y, q)

</code></pre>

<hr>
<h2 id='nthroot'>The n-th root formula</h2><span id='topic+nthroot'></span>

<h3>Description</h3>

<p>Find the n-th root of real numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nthroot(a, n, tol = 1/1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nthroot_+3A_a">a</code></td>
<td>
<p>a positive real number</p>
</td></tr>
<tr><td><code id="nthroot_+3A_n">n</code></td>
<td>
<p>n</p>
</td></tr>
<tr><td><code id="nthroot_+3A_tol">tol</code></td>
<td>
<p>the permitted error tolerance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>nthroot</code> function finds the <code>n</code>th root of <code>a</code> via
an iterative process.
</p>


<h3>Value</h3>

<p>the root
</p>


<h3>See Also</h3>

<p>Other algebra: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+division">division</a></code>,
<code><a href="#topic+fibonacci">fibonacci</a>()</code>,
<code><a href="#topic+horner">horner</a>()</code>,
<code><a href="#topic+isPrime">isPrime</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>,
<code><a href="#topic+quadratic">quadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nthroot(100, 2)
nthroot(65536, 4)
nthroot(1000, 3)

</code></pre>

<hr>
<h2 id='polyinterp'>Polynomial interpolation</h2><span id='topic+polyinterp'></span>

<h3>Description</h3>

<p>Finds a polynomial function interpolating the given points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyinterp(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyinterp_+3A_x">x</code></td>
<td>
<p>a vector of x values</p>
</td></tr>
<tr><td><code id="polyinterp_+3A_y">y</code></td>
<td>
<p>a vector of y values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>polyinterp</code> finds a polynomial that interpolates the given points.
</p>


<h3>Value</h3>

<p>a polynomial equation's coefficients
</p>


<h3>See Also</h3>

<p>Other interp: 
<code><a href="#topic+bezier">bezier</a></code>,
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nn">nn</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>
</p>
<p>Other algebra: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+division">division</a></code>,
<code><a href="#topic+fibonacci">fibonacci</a>()</code>,
<code><a href="#topic+horner">horner</a>()</code>,
<code><a href="#topic+isPrime">isPrime</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nthroot">nthroot</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>,
<code><a href="#topic+quadratic">quadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 3)
y &lt;- x^2 + 5 * x - 3
f &lt;- polyinterp(x, y)

</code></pre>

<hr>
<h2 id='pwiselinterp'>Piecewise linear interpolation</h2><span id='topic+pwiselinterp'></span>

<h3>Description</h3>

<p>Finds a piecewise linear function that interpolates the data points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwiselinterp(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwiselinterp_+3A_x">x</code></td>
<td>
<p>a vector of x values</p>
</td></tr>
<tr><td><code id="pwiselinterp_+3A_y">y</code></td>
<td>
<p>a vector of y values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pwiselinterp</code> finds a piecewise linear function that
interpolates the data points.  For each x-y ordered pair, there
function finds the unique line interpolating them.  The function will
return a data.frame with three columns.
</p>
<p>The column <code>x</code> is the upper bound of the domain for the given
piece.  The columns <code>m</code> and <code>b</code> represent the coefficients
from the y-intercept form of the linear equation, y = mx + b.
</p>
<p>The matrix will contain length(x) rows with the first row having m
and b of NA.
</p>


<h3>Value</h3>

<p>a matrix with the linear function components
</p>


<h3>See Also</h3>

<p>Other interp: 
<code><a href="#topic+bezier">bezier</a></code>,
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nn">nn</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>
</p>
<p>Other algebra: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+division">division</a></code>,
<code><a href="#topic+fibonacci">fibonacci</a>()</code>,
<code><a href="#topic+horner">horner</a>()</code>,
<code><a href="#topic+isPrime">isPrime</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nthroot">nthroot</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+quadratic">quadratic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(5, 0, 3)
y &lt;- c(4, 0, 3)
f &lt;- pwiselinterp(x, y)

</code></pre>

<hr>
<h2 id='quadratic'>The quadratic equation.</h2><span id='topic+quadratic'></span><span id='topic+quadratic2'></span>

<h3>Description</h3>

<p>Find the zeros of a quadratic equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadratic(b2, b1, b0)

quadratic2(b2, b1, b0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadratic_+3A_b2">b2</code></td>
<td>
<p>the coefficient of the x^2 term</p>
</td></tr>
<tr><td><code id="quadratic_+3A_b1">b1</code></td>
<td>
<p>the coefficient of the x term</p>
</td></tr>
<tr><td><code id="quadratic_+3A_b0">b0</code></td>
<td>
<p>the constant term</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>quadratic</code> and <code>quadratic2</code> implement the quadratic
equation from standard algebra in two different ways.  The
<code>quadratic</code> function is susceptible to cascading numerical error
and the <code>quadratic2</code> has reduced potential error.
</p>


<h3>Value</h3>

<p>numeric vector of solutions to the equation
</p>


<h3>See Also</h3>

<p>Other algebra: 
<code><a href="#topic+bilinear">bilinear</a>()</code>,
<code><a href="#topic+cubicspline">cubicspline</a>()</code>,
<code><a href="#topic+division">division</a></code>,
<code><a href="#topic+fibonacci">fibonacci</a>()</code>,
<code><a href="#topic+horner">horner</a>()</code>,
<code><a href="#topic+isPrime">isPrime</a>()</code>,
<code><a href="#topic+linterp">linterp</a>()</code>,
<code><a href="#topic+nthroot">nthroot</a>()</code>,
<code><a href="#topic+polyinterp">polyinterp</a>()</code>,
<code><a href="#topic+pwiselinterp">pwiselinterp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quadratic(1, 0, -1)
quadratic(4, -4, 1)
quadratic2(1, 0, -1)
quadratic2(4, -4, 1)
</code></pre>

<hr>
<h2 id='refmatrix'>Matrix to Row Echelon Form</h2><span id='topic+refmatrix'></span><span id='topic+rrefmatrix'></span><span id='topic+solvematrix'></span>

<h3>Description</h3>

<p>Transform a matrix to row echelon form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refmatrix(m)

rrefmatrix(m)

solvematrix(A, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refmatrix_+3A_m">m</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="refmatrix_+3A_a">A</code></td>
<td>
<p>a square matrix representing the coefficients of a linear
system in <code>solvematrix</code></p>
</td></tr>
<tr><td><code id="refmatrix_+3A_b">b</code></td>
<td>
<p>a vector representing the right-hand side of the linear
system in <code>solvematrix</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>refmatrix</code> reduces a matrix to row echelon form.  This is not a
reduced row echelon form, though that can be easily calculated from
the diagonal.  This function works on non-square matrices.
</p>
<p><code>rrefmatrix</code> returns the reduced row echelon matrix.
</p>
<p><code>solvematrix</code> solves a linear system using <code>rrefmatrix</code>.
</p>


<h3>Value</h3>

<p>the modified matrix
</p>


<h3>See Also</h3>

<p>Other linear: 
<code><a href="#topic+choleskymatrix">choleskymatrix</a>()</code>,
<code><a href="#topic+detmatrix">detmatrix</a>()</code>,
<code><a href="#topic+gdls">gdls</a>()</code>,
<code><a href="#topic+invmatrix">invmatrix</a>()</code>,
<code><a href="#topic+iterativematrix">iterativematrix</a></code>,
<code><a href="#topic+lumatrix">lumatrix</a>()</code>,
<code><a href="#topic+rowops">rowops</a></code>,
<code><a href="#topic+tridiagmatrix">tridiagmatrix</a>()</code>,
<code><a href="#topic+vecnorm">vecnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1, 2, -7, -1, -1, 1, 2, 1, 5), 3)
refmatrix(A)

</code></pre>

<hr>
<h2 id='resizeImage'>Image resizing</h2><span id='topic+resizeImage'></span><span id='topic+resizeImageNN'></span><span id='topic+resizeImageBL'></span>

<h3>Description</h3>

<p>Resize images using nearest neighbor and
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resizeImageNN(imx, width, height)

resizeImageBL(imx, width, height)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resizeImage_+3A_imx">imx</code></td>
<td>
<p>a 3-dimensional array containing image data</p>
</td></tr>
<tr><td><code id="resizeImage_+3A_width">width</code></td>
<td>
<p>the new width</p>
</td></tr>
<tr><td><code id="resizeImage_+3A_height">height</code></td>
<td>
<p>the new height</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <var>resizeImageNN</var> function uses the nearest neighbor method to
resize the image.  Also, <var>resizeImageBL</var> uses bilinear
interpolation to resize the image.
</p>


<h3>Value</h3>

<p>a three-dimensional array containing the resized image.
</p>

<hr>
<h2 id='revolution-solid'>Volumes of solids of revolution</h2><span id='topic+revolution-solid'></span><span id='topic+shellmethod'></span><span id='topic+discmethod'></span>

<h3>Description</h3>

<p>Find the volume of a solid of revolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shellmethod(f, a, b)

discmethod(f, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revolution-solid_+3A_f">f</code></td>
<td>
<p>function of revolution</p>
</td></tr>
<tr><td><code id="revolution-solid_+3A_a">a</code></td>
<td>
<p>lower-bound of the solid</p>
</td></tr>
<tr><td><code id="revolution-solid_+3A_b">b</code></td>
<td>
<p>upper-bound of the solid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>discmethod</code> and <code>shellmethod</code> implement the
algorithms for finding the volume of solids of revolution.  The
<code>discmethod</code> function is suitable for volumes revolved around
the <code>x</code>-axis and the <code>shellmethod</code> function is suitable for
volumes revolved around the <code>y</code>-axis.
</p>


<h3>Value</h3>

<p>the volume of the solid
</p>


<h3>See Also</h3>

<p>Other integration: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+gaussint">gaussint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+mcint">mcint</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { x^2 }
shellmethod(f, 1, 2)
discmethod(f, 1, 2)

</code></pre>

<hr>
<h2 id='romberg'>Romberg Integration</h2><span id='topic+romberg'></span>

<h3>Description</h3>

<p>Romberg's adaptive integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>romberg(f, a, b, m, tab = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="romberg_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="romberg_+3A_a">a</code></td>
<td>
<p>the lowerbound of integration</p>
</td></tr>
<tr><td><code id="romberg_+3A_b">b</code></td>
<td>
<p>the upperbound of integration</p>
</td></tr>
<tr><td><code id="romberg_+3A_m">m</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
<tr><td><code id="romberg_+3A_tab">tab</code></td>
<td>
<p>if <code>TRUE</code>, return the table of values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>romberg</code> function uses Romberg's rule to calculate the
integral of the function <code>f</code> over the interval from <code>a</code>
to <code>b</code>.  The parameter <code>m</code> sets the number of intervals
to use when evaluating.  Additional options are passed to the
function <code>f</code> when evaluating.
</p>


<h3>Value</h3>

<p>the value of the integral
</p>


<h3>See Also</h3>

<p>Other integration: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+gaussint">gaussint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+mcint">mcint</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+revolution-solid">revolution-solid</a></code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>
<p>Other newton-cotes: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { sin(x)^2 + log(x)}
romberg(f, 1, 10, m = 3)
romberg(f, 1, 10, m = 5)
romberg(f, 1, 10, m = 10)

</code></pre>

<hr>
<h2 id='rowops'>Elementary row operations</h2><span id='topic+rowops'></span><span id='topic+swaprows'></span><span id='topic+replacerow'></span><span id='topic+scalerow'></span>

<h3>Description</h3>

<p>These are elementary operations for a matrix.  They do not presume a
square matrix and will work on any matrix.  They use R's internal row
addressing to function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swaprows(m, row1, row2)

replacerow(m, row1, row2, k)

scalerow(m, row, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowops_+3A_m">m</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="rowops_+3A_row1">row1</code></td>
<td>
<p>a source row</p>
</td></tr>
<tr><td><code id="rowops_+3A_row2">row2</code></td>
<td>
<p>a destination row</p>
</td></tr>
<tr><td><code id="rowops_+3A_k">k</code></td>
<td>
<p>a scaling factor</p>
</td></tr>
<tr><td><code id="rowops_+3A_row">row</code></td>
<td>
<p>a row to modify</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>replacerow</code> replaces one row with the sum of itself and the
multiple of another row.  <code>swaprows</code> swap two rows in the
matrix.  <code>scalerow</code> scales all enteries in a row by a constant.
</p>


<h3>Value</h3>

<p>the modified matrix
</p>


<h3>See Also</h3>

<p>Other linear: 
<code><a href="#topic+choleskymatrix">choleskymatrix</a>()</code>,
<code><a href="#topic+detmatrix">detmatrix</a>()</code>,
<code><a href="#topic+gdls">gdls</a>()</code>,
<code><a href="#topic+invmatrix">invmatrix</a>()</code>,
<code><a href="#topic+iterativematrix">iterativematrix</a></code>,
<code><a href="#topic+lumatrix">lumatrix</a>()</code>,
<code><a href="#topic+refmatrix">refmatrix</a>()</code>,
<code><a href="#topic+tridiagmatrix">tridiagmatrix</a>()</code>,
<code><a href="#topic+vecnorm">vecnorm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
A &lt;- matrix(sample.int(10, n^2, TRUE) - 1, n)
A &lt;- swaprows(A, 2, 4)
A &lt;- replacerow(A, 1, 3, 2)
A &lt;- scalerow(A, 5, 10)
</code></pre>

<hr>
<h2 id='sa'>Simulated annealing</h2><span id='topic+sa'></span><span id='topic+tspsa'></span>

<h3>Description</h3>

<p>Use simulated annealing to find the global minimum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sa(f, x, temp = 10000, rate = 1e-04)

tspsa(x, temp = 100, rate = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sa_+3A_f">f</code></td>
<td>
<p>function representing <code>f</code></p>
</td></tr>
<tr><td><code id="sa_+3A_x">x</code></td>
<td>
<p>an initial estimate of the minimum</p>
</td></tr>
<tr><td><code id="sa_+3A_temp">temp</code></td>
<td>
<p>the initial temperature</p>
</td></tr>
<tr><td><code id="sa_+3A_rate">rate</code></td>
<td>
<p>the cooling rate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulated annealing finds a global minimum by mimicing the
metallurgical process of annealing.
</p>


<h3>Value</h3>

<p>the <code>x</code> value of the minimum found
</p>


<h3>See Also</h3>

<p>Other optimz: 
<code><a href="#topic+bisection">bisection</a>()</code>,
<code><a href="#topic+goldsect">goldsect</a></code>,
<code><a href="#topic+gradient">gradient</a></code>,
<code><a href="#topic+hillclimbing">hillclimbing</a>()</code>,
<code><a href="#topic+newton">newton</a>()</code>,
<code><a href="#topic+secant">secant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { x^6 - 4 * x^5 - 7 * x^4 + 22 * x^3 + 24 * x^2 + 2}
sa(f, 0)

f &lt;- function(x) { (x[1] - 1)^2 + (x[2] - 1)^2 }
sa(f, c(0, 0), 0.05)

</code></pre>

<hr>
<h2 id='secant'>Secant Method</h2><span id='topic+secant'></span>

<h3>Description</h3>

<p>The secant method for root finding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secant(f, x, tol = 0.001, m = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secant_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="secant_+3A_x">x</code></td>
<td>
<p>an initial estimate of the root</p>
</td></tr>
<tr><td><code id="secant_+3A_tol">tol</code></td>
<td>
<p>the error tolerance</p>
</td></tr>
<tr><td><code id="secant_+3A_m">m</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The secant method for root finding extends Newton's method to
estimate the derivative.  It will return when the interval between
them is less than <code>tol</code>, the error tolerance.  However, this
implementation also stop if after <code>m</code> iterations.
</p>


<h3>Value</h3>

<p>the real root found
</p>


<h3>See Also</h3>

<p>Other optimz: 
<code><a href="#topic+bisection">bisection</a>()</code>,
<code><a href="#topic+goldsect">goldsect</a></code>,
<code><a href="#topic+gradient">gradient</a></code>,
<code><a href="#topic+hillclimbing">hillclimbing</a>()</code>,
<code><a href="#topic+newton">newton</a>()</code>,
<code><a href="#topic+sa">sa</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { x^3 - 2 * x^2 - 159 * x - 540 }
secant(f, 1)

</code></pre>

<hr>
<h2 id='simp'>Simpson's rule</h2><span id='topic+simp'></span>

<h3>Description</h3>

<p>Use Simpson's rule to integrate a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simp(f, a, b, m = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simp_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="simp_+3A_a">a</code></td>
<td>
<p>the a-bound of integration</p>
</td></tr>
<tr><td><code id="simp_+3A_b">b</code></td>
<td>
<p>the b-bound of integration</p>
</td></tr>
<tr><td><code id="simp_+3A_m">m</code></td>
<td>
<p>the number of subintervals to calculate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>simp</code> function uses Simpson's rule to calculate the
integral of the function <code>f</code> over the interval from <code>a</code>
to <code>b</code>.  The parameter <code>m</code> sets the number of intervals
to use when evaluating.  Additional options are passed to the
function <code>f</code> when evaluating.
</p>


<h3>Value</h3>

<p>the value of the integral
</p>


<h3>See Also</h3>

<p>Other integration: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+gaussint">gaussint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+mcint">mcint</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+revolution-solid">revolution-solid</a></code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>
<p>Other newton-cotes: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { sin(x)^2 + cos(x)^2 }
simp(f, -pi, pi, m = 10)
simp(f, -pi, pi, m = 100)
simp(f, -pi, pi, m = 1000)

</code></pre>

<hr>
<h2 id='simp38'>Simpson's 3/8 rule</h2><span id='topic+simp38'></span>

<h3>Description</h3>

<p>Use Simpson's 3/8 rule to integrate a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simp38(f, a, b, m = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simp38_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="simp38_+3A_a">a</code></td>
<td>
<p>the a-bound of integration</p>
</td></tr>
<tr><td><code id="simp38_+3A_b">b</code></td>
<td>
<p>the b-bound of integration</p>
</td></tr>
<tr><td><code id="simp38_+3A_m">m</code></td>
<td>
<p>the number of subintervals to calculate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>simp38</code> function uses Simpson's 3/8 rule to calculate the
integral of the function <code>f</code> over the interval from <code>a</code>
to <code>b</code>.  The parameter <code>m</code> sets the number of intervals
to use when evaluating.  Additional options are passed to the
function <code>f</code> when evaluating.
</p>


<h3>Value</h3>

<p>the value of the integral
</p>


<h3>See Also</h3>

<p>Other integration: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+gaussint">gaussint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+mcint">mcint</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+revolution-solid">revolution-solid</a></code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>
<p>Other newton-cotes: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>,
<code><a href="#topic+trap">trap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { sin(x)^2 + log(x) }
simp38(f, 1, 10, m = 10)
simp38(f, 1, 10, m = 100)
simp38(f, 1, 10, m = 1000)

</code></pre>

<hr>
<h2 id='summation'>Two summing algorithms</h2><span id='topic+summation'></span><span id='topic+naivesum'></span><span id='topic+kahansum'></span><span id='topic+pwisesum'></span>

<h3>Description</h3>

<p>Find the sum of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naivesum(x)

kahansum(x)

pwisesum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summation_+3A_x">x</code></td>
<td>
<p>a vector of numbers to be summed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>naivesum</code> calculates the sum of a vector by keeping a counter
and repeatedly adding the next value to the interim sum.
<code>kahansum</code> uses Kahan's algorithm to capture the low-order
precision loss and ensure that the loss is reintegrated into the
final sum.  <code>pwisesum</code> is a recursive implementation of the
piecewise summation algorithm that divides the vector in two and adds
the individual vector sums for a result.
</p>


<h3>Value</h3>

<p>the sum
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- 1:10^6
n &lt;- sample(k, 1)
bound &lt;- sample(k, 2)
bound.upper &lt;- max(bound) - 10^6 / 2
bound.lower &lt;- min(bound) - 10^6 / 2
x &lt;- runif(n, bound.lower, bound.upper)
naivesum(x)
kahansum(x)
pwisesum(x)
</code></pre>

<hr>
<h2 id='trap'>Trapezoid method</h2><span id='topic+trap'></span>

<h3>Description</h3>

<p>Use the trapezoid method to integrate a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trap(f, a, b, m = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trap_+3A_f">f</code></td>
<td>
<p>function to integrate</p>
</td></tr>
<tr><td><code id="trap_+3A_a">a</code></td>
<td>
<p>the a-bound of integration</p>
</td></tr>
<tr><td><code id="trap_+3A_b">b</code></td>
<td>
<p>the b-bound of integration</p>
</td></tr>
<tr><td><code id="trap_+3A_m">m</code></td>
<td>
<p>the number of subintervals to calculate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>trap</code> function uses the trapezoid method to calculate
the integral of the function <code>f</code> over the interval from
<code>a</code> to <code>b</code>.  The parameter <code>m</code> sets the
number of intervals to use when evaluating the trapezoids.  Additional
options are passed to the function <code>f</code> when evaluating.
</p>


<h3>Value</h3>

<p>the value of the integral
</p>


<h3>See Also</h3>

<p>Other integration: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+gaussint">gaussint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+mcint">mcint</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+revolution-solid">revolution-solid</a></code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>
</p>
<p>Other newton-cotes: 
<code><a href="#topic+adaptint">adaptint</a>()</code>,
<code><a href="#topic+giniquintile">giniquintile</a>()</code>,
<code><a href="#topic+midpt">midpt</a>()</code>,
<code><a href="#topic+romberg">romberg</a>()</code>,
<code><a href="#topic+simp38">simp38</a>()</code>,
<code><a href="#topic+simp">simp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) { sin(x)^2 + cos(x)^2 }
trap(f, -pi, pi, m = 10)
trap(f, -pi, pi, m = 100)
trap(f, -pi, pi, m = 1000)

</code></pre>

<hr>
<h2 id='tridiagmatrix'>Solve a tridiagonal matrix</h2><span id='topic+tridiagmatrix'></span>

<h3>Description</h3>

<p>use the tridiagonal matrix algorithm to solve a tridiagonal matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tridiagmatrix(L, D, U, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tridiagmatrix_+3A_l">L</code></td>
<td>
<p>vector of entries below the main diagonal</p>
</td></tr>
<tr><td><code id="tridiagmatrix_+3A_d">D</code></td>
<td>
<p>vector of entries on the main diagonal</p>
</td></tr>
<tr><td><code id="tridiagmatrix_+3A_u">U</code></td>
<td>
<p>vector of entries above the main diagonal</p>
</td></tr>
<tr><td><code id="tridiagmatrix_+3A_b">b</code></td>
<td>
<p>vector of the right-hand side of the linear system</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tridiagmatrix</code> uses the tridiagonal matrix algorithm to solve a
tridiagonal matrix.
</p>


<h3>Value</h3>

<p>the solution vector
</p>


<h3>See Also</h3>

<p>Other linear: 
<code><a href="#topic+choleskymatrix">choleskymatrix</a>()</code>,
<code><a href="#topic+detmatrix">detmatrix</a>()</code>,
<code><a href="#topic+gdls">gdls</a>()</code>,
<code><a href="#topic+invmatrix">invmatrix</a>()</code>,
<code><a href="#topic+iterativematrix">iterativematrix</a></code>,
<code><a href="#topic+lumatrix">lumatrix</a>()</code>,
<code><a href="#topic+refmatrix">refmatrix</a>()</code>,
<code><a href="#topic+rowops">rowops</a></code>,
<code><a href="#topic+vecnorm">vecnorm</a>()</code>
</p>

<hr>
<h2 id='vecnorm'>Norm of a vector</h2><span id='topic+vecnorm'></span>

<h3>Description</h3>

<p>Find the norm of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecnorm(b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecnorm_+3A_b">b</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Find the norm of a vector
</p>


<h3>Value</h3>

<p>the norm
</p>


<h3>See Also</h3>

<p>Other linear: 
<code><a href="#topic+choleskymatrix">choleskymatrix</a>()</code>,
<code><a href="#topic+detmatrix">detmatrix</a>()</code>,
<code><a href="#topic+gdls">gdls</a>()</code>,
<code><a href="#topic+invmatrix">invmatrix</a>()</code>,
<code><a href="#topic+iterativematrix">iterativematrix</a></code>,
<code><a href="#topic+lumatrix">lumatrix</a>()</code>,
<code><a href="#topic+refmatrix">refmatrix</a>()</code>,
<code><a href="#topic+rowops">rowops</a></code>,
<code><a href="#topic+tridiagmatrix">tridiagmatrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 3)
vecnorm(x)

</code></pre>

<hr>
<h2 id='wave'>Wave Equation using</h2><span id='topic+wave'></span>

<h3>Description</h3>

<p>solve heat equation via forward-time central-space method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wave(u, alpha, xdelta, tdelta, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wave_+3A_u">u</code></td>
<td>
<p>the initial values of u</p>
</td></tr>
<tr><td><code id="wave_+3A_alpha">alpha</code></td>
<td>
<p>the thermal diffusivity coefficient</p>
</td></tr>
<tr><td><code id="wave_+3A_xdelta">xdelta</code></td>
<td>
<p>the change in <code>x</code> at each step in <code>u</code></p>
</td></tr>
<tr><td><code id="wave_+3A_tdelta">tdelta</code></td>
<td>
<p>the time step</p>
</td></tr>
<tr><td><code id="wave_+3A_n">n</code></td>
<td>
<p>the number of steps to take</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>heat</code> solves the heat equation using the forward-time
central-space method in one-dimension.
</p>


<h3>Value</h3>

<p>a matrix of u values at each time step
</p>


<h3>Examples</h3>

<pre><code class='language-R'>speed &lt;- 2
x0 &lt;- 0
xdelta &lt;- .05
x &lt;- seq(x0, 1, xdelta)
m &lt;- length(x)
u &lt;- sin(x * pi * 2)
u[11:21] &lt;- 0
tdelta &lt;- .02
n &lt;- 40
z &lt;- wave(u, speed, xdelta, tdelta, n)
</code></pre>

<hr>
<h2 id='wilkinson'>Wilkinson's Polynomial</h2><span id='topic+wilkinson'></span>

<h3>Description</h3>

<p>Wilkinson's polynomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilkinson(x, w = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilkinson_+3A_x">x</code></td>
<td>
<p>the <code>x</code>-value</p>
</td></tr>
<tr><td><code id="wilkinson_+3A_w">w</code></td>
<td>
<p>the number of terms in the polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wilkinson's polynomail is a terrible joke played on numerical
analysis.  By tradition, the function is f(x) = (x - 1)(x - 2)...(x -
20), giving a function with real roots at each integer from 1 to 20.
This function is generalized and allows for <code>n</code> and the function
value is f(x) = (x - 1)(x - 2)...(x - n).  The default of <code>n</code> is
20.
</p>


<h3>Value</h3>

<p>the value of the function at <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wilkinson(0)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
