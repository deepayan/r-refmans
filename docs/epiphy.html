<!DOCTYPE html><html lang="en"><head><title>Help for package epiphy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {epiphy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a2a'><p>Easily switch between different power law formulations.</p></a></li>
<li><a href='#agg_index'><p>Several aggregation indices.</p></a></li>
<li><a href='#aphids'><p>Counts of aphids.</p></a></li>
<li><a href='#arthropods'><p>Counts of arthropods.</p></a></li>
<li><a href='#as.data.frame.intensity'><p>Coerce to a data frame.</p></a></li>
<li><a href='#BetaBinomial'><p>The beta-binomial distribution.</p></a></li>
<li><a href='#calpha.test'><p>C(alpha) test.</p></a></li>
<li><a href='#chisq.test'><p>Chi-squared test.</p></a></li>
<li><a href='#citrus_ctv'><p>Incidence of citrus tristeza virus (CTV) disease in three fields.</p></a></li>
<li><a href='#clump'><p>Regroup observational data into even clumps of individuals.</p></a></li>
<li><a href='#codling_moths'><p>Count of codling moth larvae.</p></a></li>
<li><a href='#coef.smle'><p>Extract Model Coefficients</p></a></li>
<li><a href='#dogwood_anthracnose'><p>Incidence of dogwood anthracnose.</p></a></li>
<li><a href='#epiphy'><p><a href="https://CRAN.R-project.org/package=epiphy"><span class="pkg">epiphy</span></a>: An R package to analyze plant disease epidemics.</p></a></li>
<li><a href='#fit_two_distr'><p>Maximum likelihood fitting of two distributions and goodness-of-fit</p>
comparison.</a></li>
<li><a href='#hop_viruses'><p>Incidence of three viruses in an Australian hop garden.</p></a></li>
<li><a href='#indAndSub'><p>Retrieve vector or array indices</p></a></li>
<li><a href='#intensity'><p>Construct count, incidence and severity objects.</p></a></li>
<li><a href='#is.intensity'><p>Test if an object is of class <code>intensity</code> or one of its subclasses.</p></a></li>
<li><a href='#link'><p>Some link functions.</p></a></li>
<li><a href='#logLik.smle'><p>Extract log-likelihood</p></a></li>
<li><a href='#mapcomp'><p>Map Comparison procedure.</p></a></li>
<li><a href='#mapped_var'><p>Existing variable mappings.</p></a></li>
<li><a href='#mapping'><p>Construct data mappings.</p></a></li>
<li><a href='#offspring_survival'><p>Offspring survival of rats experiencing different diets.</p></a></li>
<li><a href='#onion_bacterial_blight'><p>Incidence of bacterial blight of onion.</p></a></li>
<li><a href='#power_law'><p>Taylor's and binary power laws.</p></a></li>
<li><a href='#pyrethrum_ray_blight'><p>Incidence of ray blight disease of pyrethrum.</p></a></li>
<li><a href='#sadie'><p>Spatial Analysis by Distance IndicEs (SADIE).</p></a></li>
<li><a href='#simulated_epidemics'><p>Examples of simulated epidemic data.</p></a></li>
<li><a href='#smle'><p>Simple maximum likelihood estimation</p></a></li>
<li><a href='#smle_wrappers'><p>Wrappers using maximum likelihood estimation for some distributions</p></a></li>
<li><a href='#spatial_hier'><p>Spatial hierarchy analysis.</p></a></li>
<li><a href='#split.intensity'><p>Divide into groups and reassemble.</p></a></li>
<li><a href='#threshold'><p>To go to higher level in the hierarchy.</p></a></li>
<li><a href='#tobacco_viruses'><p>Incidence of tobacco plants infected with viruses.</p></a></li>
<li><a href='#tomato_tswv'><p>Incidence of tomato spotted wilt virus (TSWV) disease in field trials.</p></a></li>
<li><a href='#vcov.smle'><p>Calculate Variance-Covariance Matrix for a Fitted Model Object</p></a></li>
<li><a href='#z.test'><p>Z-test.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Plant Disease Epidemics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox to make it easy to analyze plant disease epidemics. It
    provides a common framework for plant disease intensity data recorded over
    time and/or space. Implemented statistical methods are currently mainly
    focused on spatial pattern analysis (e.g., aggregation indices, Taylor and
    binary power laws, distribution fitting, SADIE and 'mapcomp' methods). See
    Laurence V. Madden, Gareth Hughes, Franck van den Bosch (2007)
    &lt;<a href="https://doi.org/10.1094%2F9780890545058">doi:10.1094/9780890545058</a>&gt; for further information on these methods.
    Several data sets that were mainly published in plant disease epidemiology
    literature are also included in this package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/chgigot/epiphy">https://github.com/chgigot/epiphy</a>,
<a href="https://chgigot.github.io/epiphy/">https://chgigot.github.io/epiphy/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/chgigot/epiphy/issues">https://github.com/chgigot/epiphy/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, utils, grDevices, ggplot2, transport, msm,
pbapply, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magrittr, dplyr, tidyr, spdep, emdist, vegan, MASS, emdbook,
knitr, rmarkdown</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'betabinom.R' 'data.R' 'utils.R'
'mle-factory.R' 'epiphy.R' 'intensity-classes.R'
'distr-fitting.R' 'indices.R' 'mapcomp.R' 'power-law.R'
'sadie.R' 'spatial-hier.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-15 07:43:36 UTC; tof</td>
</tr>
<tr>
<td>Author:</td>
<td>Christophe Gigot <a href="https://orcid.org/0000-0002-1748-2902"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Adam H. Sparks [ctb],
  Katrin Leinweber [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christophe Gigot &lt;ch.gigot@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-16 11:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='a2a'>Easily switch between different power law formulations.</h2><span id='topic+a2a'></span><span id='topic+a2a.numeric'></span><span id='topic+a2a.list'></span>

<h3>Description</h3>

<p><code>a2a</code> was designed to avoid headaches that are likely to occur when
working with different formulations of the binomial power law analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2a(x, ...)

## S3 method for class 'numeric'
a2a(
  x,
  slope,
  n,
  from = c("Ai", "ai", "AI", "aI"),
  to = c("Ai", "ai", "AI", "aI"),
  ...
)

## S3 method for class 'list'
a2a(x, to = c("Ai", "ai", "AI", "aI"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a2a_+3A_x">x</code></td>
<td>
<p>Intercept parameter to be converted or a named list with the
parameter to be converted (&quot;Ai&quot;, &quot;ai&quot;, &quot;AI&quot; or &quot;aI&quot;), the slope
(&quot;slope&quot;), and the number of individual per sampling unit (&quot;n&quot;).</p>
</td></tr>
<tr><td><code id="a2a_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
<tr><td><code id="a2a_+3A_slope">slope</code></td>
<td>
<p>Slope parameter.</p>
</td></tr>
<tr><td><code id="a2a_+3A_n">n</code></td>
<td>
<p>Number of individuals per sampling unit.</p>
</td></tr>
<tr><td><code id="a2a_+3A_from">from</code></td>
<td>
<p>Kind of the input intercept parameter (&quot;Ai&quot;, &quot;ai&quot;, &quot;AI&quot; or &quot;aI&quot;).</p>
</td></tr>
<tr><td><code id="a2a_+3A_to">to</code></td>
<td>
<p>Desired kind for the ouput intercept parameter (&quot;Ai&quot;, &quot;ai&quot;, &quot;AI&quot; or
&quot;aI&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The binomial power law can be expressed as: <code class="reqn">s_y^2 = (intercept)(s_{bin}^2)^b</code>.
But different forms of (intercept) are possible depending on the formulation of the
binomial power law.
</p>

<table>
<tr>
 <td style="text-align: center;">
      </td><td style="text-align: center;"> Ai         </td><td style="text-align: center;"> ai      </td><td style="text-align: center;"> AI         </td><td style="text-align: center;"> aI      </td>
</tr>
<tr>
 <td style="text-align: center;">
   Ai </td><td style="text-align: center;"> 1          </td><td style="text-align: center;"> n^b     </td><td style="text-align: center;"> n^(2(b-1)) </td><td style="text-align: center;"> n^(b-2) </td>
</tr>
<tr>
 <td style="text-align: center;">
   ai </td><td style="text-align: center;"> n^(-b)     </td><td style="text-align: center;"> 1       </td><td style="text-align: center;"> n^(b-2)    </td><td style="text-align: center;"> n^(-2)  </td>
</tr>
<tr>
 <td style="text-align: center;">
   AI </td><td style="text-align: center;"> n^(2(1-b)) </td><td style="text-align: center;"> n^(2-b) </td><td style="text-align: center;"> 1          </td><td style="text-align: center;"> n^(-b)  </td>
</tr>
<tr>
 <td style="text-align: center;">
   aI </td><td style="text-align: center;"> n^(2-b)    </td><td style="text-align: center;"> n^2     </td><td style="text-align: center;"> n^b        </td><td style="text-align: center;"> 1       </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Values from the power_law() example:
Ai    &lt;- 38.6245
slope &lt;- 1.9356
n     &lt;- 9

# Usual function call syntax:
a2a(Ai, slope, n, from = "Ai", to = "ai")

# Other syntaxes:
inputs &lt;- list(Ai = Ai, slope = slope, n = n)
a2a(inputs, "ai")
require(magrittr)
inputs %&gt;% a2a("ai")

</code></pre>

<hr>
<h2 id='agg_index'>Several aggregation indices.</h2><span id='topic+agg_index'></span>

<h3>Description</h3>

<p>This function can compute different aggregation indices. See &quot;Details&quot;
section for more information about the available indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_index(
  x,
  method = c("fisher", "lloyd", "morisita"),
  flavor = c("count", "incidence"),
  n = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agg_index_+3A_x">x</code></td>
<td>
<p>A numeric vector or a <code>count</code>/<code>incidence</code> object.</p>
</td></tr>
<tr><td><code id="agg_index_+3A_method">method</code></td>
<td>
<p>The name of the method to be used. &quot;fisher&quot; method is used by
default. See details below.</p>
</td></tr>
<tr><td><code id="agg_index_+3A_flavor">flavor</code></td>
<td>
<p>Which flavor of this index must be calculated (&quot;count&quot; or
&quot;incidence&quot;)?</p>
</td></tr>
<tr><td><code id="agg_index_+3A_n">n</code></td>
<td>
<p>Number of individuals per sampling unit. If <code>n</code> is provided,
the &quot;incidence&quot; flavor is calculated whatever the value of <code>flavor</code>.
Note that current implementation only deals with equal size sampling
units.</p>
</td></tr>
<tr><td><code id="agg_index_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are currently three implemented methods to compute indices of
aggregation.
</p>
<p><code>fisher</code>: Fisher's index of aggregation. In case of a count, this index
corresponds to the ratio of the observed variance to the observed mean, and
this is why this index is also known as the variance to mean ratio. For a
binary variable, a similar index can be calculated using instead the ratio of
the observed variance to the theoretical variance if data follow a binomial
law (i.e. a reference distribution for a random pattern of individuals within
sampling units).
</p>
<p><code>lloyd</code>: Lloyd's index of patchiness. The value of this index increases
with the degree of aggregation. Note that Lloyd's mean crowding can also be
returned if <code>type = "mean-crowding"</code> is provided as parameter.
</p>
<p><code>morisita</code>: Morisita's coefficient of dispersion. This index can be
computed for either count or incidence data, but its interpretation can be
uncertain.
</p>
<p>Values of Fisher's and Lloyd's indices can be interpreted as follows:
</p>

<ul>
<li><p> index &lt; 1: uniform pattern;
</p>
</li>
<li><p> index = 1: random pattern;
</p>
</li>
<li><p> index &gt; 1: aggregated pattern.
</p>
</li></ul>

<p>The following table gives information about the applicability of the various
methods.
</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> count </td><td style="text-align: left;"> incidence </td><td style="text-align: left;"> severity </td>
</tr>
<tr>
 <td style="text-align: left;">
    fisher   </td><td style="text-align: left;"> + </td><td style="text-align: left;"> + </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
    lloyd    </td><td style="text-align: left;"> + </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
    morisita </td><td style="text-align: left;"> + </td><td style="text-align: left;"> + </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>where + means implemented, and -, not implemented (or not possible). At the
moment, there is no index of aggregation for severity data.
</p>


<h3>Value</h3>

<p>An object of class <code>agg_index</code>, which is a list containing the following
components:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>index</code>  </td><td style="text-align: left;"> The value of the index. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>name</code>   </td><td style="text-align: left;"> The name of the index. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>flavor</code> </td><td style="text-align: left;"> The flavor of the calculated index ("count" or "incidence"). </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>N</code>      </td><td style="text-align: left;"> The number of sampling units. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>n</code>      </td><td style="text-align: left;"> The number of individuals in each sampling unit (if relevant). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Fisher RA. 1925. Statistical methods for research workers. Oliver and Boyd,
Edinburgh.
</p>
<p>Lloyd M. 1967. Mean crowding. The Journal of Animal Ecology 36, 1–30.
</p>
<p>Morisita M. 1962. I<code class="reqn">\delta</code>-Index, a measure of dispersion of
individuals. Researches on Population Ecology 4, 1–7.
<a href="https://doi.org/10.1007/BF02533903">doi:10.1007/BF02533903</a>
</p>
<p>Madden LV, Hughes G. 1995. Plant disease incidence: Distributions,
heterogeneity, and temporal analysis. Annual Review of Phytopathology 33(1):
529–564.
<a href="https://doi.org/10.1146/annurev.py.33.090195.002525">doi:10.1146/annurev.py.33.090195.002525</a>
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+vegdist">vegdist</a></code> in <strong>vegan</strong> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Count flavor of Fisher's index:
my_fisher_count &lt;- agg_index(aphids$i)
my_fisher_count

# And incidence flavor of Fisher's index:
my_fisher_incidence &lt;- agg_index(tobacco_viruses$i, n = tobacco_viruses$n)
my_fisher_incidence

# Either standard R or epiphy idioms can be used:
identical(my_fisher_count, agg_index(count(aphids)))
identical(my_fisher_incidence, agg_index(incidence(tobacco_viruses)))

# Lloyd's index (only for count data):
agg_index(aphids$i, method = "lloyd")
# Lloyd's mean crowding:
agg_index(aphids$i, method = "lloyd", type = "mean-crowding")

# Count flavor of Morisita's index:
agg_index(aphids$i,  method = "morisita")
# Incidence flavor of Morisita's index:
agg_index(tobacco_viruses$i, n = tobacco_viruses$n, method = "morisita")

</code></pre>

<hr>
<h2 id='aphids'>Counts of aphids.</h2><span id='topic+aphids'></span>

<h3>Description</h3>

<p>Counts of 554 aphids of the species Sitobion avenae, sampled on 28 June 1996
in a 250 x 180-m field of winter wheat near Wimborne, Dorset, UK. The 63
sampling units, made of the inspection of five tillers each, were located on
a 9 x 7 rectangular grid at intervals of 30 m.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aphids
</code></pre>


<h3>Format</h3>

<p>A data frame with 63 rows and 3 variables:
</p>

<table>
<tr>
 <td style="text-align: left;">
    [, 1:2] </td><td style="text-align: left;"> x,y   </td><td style="text-align: left;"> Grid spatial coordinates. </td>
</tr>
<tr>
 <td style="text-align: left;">
    [, 3:4] </td><td style="text-align: left;"> xm,ym </td><td style="text-align: left;"> Metric spatial coordonates. </td>
</tr>
<tr>
 <td style="text-align: left;">
    [, 5]   </td><td style="text-align: left;"> i     </td><td style="text-align: left;"> Counts of aphids. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Perry JN, Winder L, Holland JM, Alston RD. 1999. Red-blue plots for
detecting clusters in count data. Ecology Letters 2, 106-13.
<a href="https://doi.org/10.1046/j.1461-0248.1999.22057.x">doi:10.1046/j.1461-0248.1999.22057.x</a>
</p>

<hr>
<h2 id='arthropods'>Counts of arthropods.</h2><span id='topic+arthropods'></span>

<h3>Description</h3>

<p>A sampling unit was made of a pitfall to collect arthropods in a field of
organic winter wheat, near Wimborne, Dorset, UK in 1996. The sampling units
were located on a 9 x 7 rectangular grid at intervals of 30 m. There were
six sampling dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arthropods
</code></pre>


<h3>Format</h3>

<p>A data frame with 378 rows and 4 variables:
</p>

<table>
<tr>
 <td style="text-align: left;">
    [, 1:2] </td><td style="text-align: left;"> x,y   </td><td style="text-align: left;"> Grid spatial coordinates. </td>
</tr>
<tr>
 <td style="text-align: left;">
    [, 3:4] </td><td style="text-align: left;"> xm,ym </td><td style="text-align: left;"> Metric spatial coordonates. </td>
</tr>
<tr>
 <td style="text-align: left;">
    [, 5]   </td><td style="text-align: left;"> t     </td><td style="text-align: left;"> Sampling date. 1: 7 Jun, 2: 14 Jun, 3: 21 Jun, 4:
                            28 Jun, 5: 5 Jul, 6: 12 Jul 1996. </td>
</tr>
<tr>
 <td style="text-align: left;">
    [, 6]   </td><td style="text-align: left;"> i     </td><td style="text-align: left;"> Counts of arthropods. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Holland JM, Winder L, Perry JN. 1999. Arthropod prey of farmland
birds: Their spatial distribution within a sprayed field with and without
buffer zones. Aspects of Applied Biology 54: 53-60.
</p>

<hr>
<h2 id='as.data.frame.intensity'>Coerce to a data frame.</h2><span id='topic+as.data.frame.intensity'></span>

<h3>Description</h3>

<p>Functions to coerce an <code>intensity</code> object to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intensity'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  ...,
  stringsAsFactors = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.intensity_+3A_x">x</code></td>
<td>
<p>An <code>intensity</code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.intensity_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row
names for the data frame.  Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.intensity_+3A_optional">optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and
converting column names (to syntactic names: see
<code><a href="base.html#topic+make.names">make.names</a></code>) is optional.  Note that all of <span class="rlang"><b>R</b></span>'s
<span class="pkg">base</span> package <code>as.data.frame()</code> methods use
<code>optional</code> only for column names treatment, basically with the
meaning of <code><a href="base.html#topic+data.frame">data.frame</a>(*, check.names = !optional)</code>.
See also the <code>make.names</code> argument of the <code>matrix</code> method.</p>
</td></tr>
<tr><td><code id="as.data.frame.intensity_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="as.data.frame.intensity_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical: should the character vector be converted
to a factor?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_data &lt;- incidence(tomato_tswv$field_1929)
head(as.data.frame(my_data))

</code></pre>

<hr>
<h2 id='BetaBinomial'>The beta-binomial distribution.</h2><span id='topic+BetaBinomial'></span><span id='topic+dbetabinom'></span><span id='topic+pbetabinom'></span><span id='topic+qbetabinom'></span><span id='topic+rbetabinom'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for
the beta-binomial distribution with parameters <code>size</code>, <code>prob</code>,
<code>theta</code>, <code>shape1</code>, <code>shape2</code>. This distribution corresponds to
an overdispersed binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbetabinom(x, size, prob, theta, shape1, shape2, log = FALSE)

pbetabinom(
  q,
  size,
  prob,
  theta,
  shape1,
  shape2,
  lower.tail = TRUE,
  log.p = FALSE
)

qbetabinom(
  p,
  size,
  prob,
  theta,
  shape1,
  shape2,
  lower.tail = TRUE,
  log.p = FALSE
)

rbetabinom(n, size, prob, theta, shape1, shape2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BetaBinomial_+3A_x">x</code>, <code id="BetaBinomial_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_size">size</code></td>
<td>
<p>Number of trials.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_prob">prob</code></td>
<td>
<p>Probability of success on each trial.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_theta">theta</code></td>
<td>
<p>Aggregation parameter (theta = 1 / (shape1 + shape2)).</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_shape1">shape1</code>, <code id="BetaBinomial_+3A_shape2">shape2</code></td>
<td>
<p>Shape parameters.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_log">log</code>, <code id="BetaBinomial_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="BetaBinomial_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be aware that in this implementation <code>theta</code> = 1 / (<code>shape1</code> +
<code>shape2</code>). <code>prob</code> and <code>theta</code>, or <code>shape1</code> and
<code>shape2</code> must be specified. if <code>theta</code> = 0, use *binom family
instead.
</p>


<h3>Value</h3>

<p><code>dbetabinom</code> gives the density, <code>pbetabinom</code> gives the distribution
function, <code>qbetabinom</code> gives the quantile function and <code>rbetabinom</code>
generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="emdbook.html#topic+dbetabinom">dbetabinom</a></code> in the package <strong>emdbook</strong>
where the definition of theta is different.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute P(25 &lt; X &lt; 50) for X following the Beta-Binomial distribution
# with parameters size = 100, prob = 0.5 and theta = 0.35:
sum(dbetabinom(25:50, size = 100, prob = 0.5, theta = 0.35))

# When theta tends to 0, dbetabinom outputs tends to dbinom outputs:
sum(dbetabinom(25:50, size = 100, prob = 0.5, theta = 1e-7))
sum(dbetabinom(25:50, size = 100, shape1 = 1e7, shape2 = 1e7))
sum(dbinom(25:50, size = 100, prob = 0.5))

# Example of binomial and beta-binomial frequency distributions:
n   &lt;- 15
q   &lt;- 0:n
p1  &lt;- dbinom(q, size = n, prob = 0.33)
p2  &lt;- dbetabinom(q, size = n, prob = 0.33, theta = 0.22)
res &lt;- rbind(p1, p2)
dimnames(res) &lt;- list(c("Binomial", "Beta-binomial"), q)
barplot(res, beside = TRUE, legend.text = TRUE, ylab = "Frequency")

# Effect of the aggregation parameter theta on probability density:
thetas &lt;- seq(0.001, 2.5, by = 0.001)
density1 &lt;- rep(sum(dbinom(25:50, size = 100, prob = 0.5)), length(thetas))
density2 &lt;- sapply(thetas, function(theta) {
    sum(dbetabinom(25:50, size = 100, prob = 0.5, theta = theta))
})
plot(thetas, density2, type = "l",
     xlab = expression("Aggregation parameter ("*theta*")"),
     ylab = "Probability density between 25 and 50 (size = 100)")
lines(thetas, density1, lty = 2)

</code></pre>

<hr>
<h2 id='calpha.test'>C(alpha) test.</h2><span id='topic+calpha.test'></span><span id='topic+calpha.test.fisher'></span>

<h3>Description</h3>

<p>The C(alpha) test is a test of the binomial distribution against the
alternative of the beta-binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calpha.test(x, ...)

## S3 method for class 'fisher'
calpha.test(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calpha.test_+3A_x">x</code></td>
<td>
<p>The output of the <code><a href="#topic+agg_index">agg_index</a></code> function with
<code>method = "fisher"</code> as parameter.</p>
</td></tr>
<tr><td><code id="calpha.test_+3A_...">...</code></td>
<td>
<p>Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is based on calculation of a test statistic, z, that has an asymptotic
standard normal distribution under the null hypothesis. It is one-sided (in
the way that the alternative is aggregation, not just &quot;non-randomness&quot;), thus
with a confidence level of 95
1.64. When all the sampling units contain the same total number of
individuals, n, the test statistic is calculated from:
</p>
<p>z = (n(N - 1)I - Nn)/(2Nn(n - 1))^(1/2)
</p>
<p>where N is the number of sampling units, and I, Fisher's index of aggregation
for incidence data.
</p>


<h3>Value</h3>

<p>Same kind of object as the one returns by the stats
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code> function for example.
</p>


<h3>References</h3>

<p>Neyman J. 1959. Optimal asymptotic tests of composite statistical hypotheses.
In: Probability and Statistics, 213-234. Wiley, New York.
</p>
<p>Tarone RE. 1979. Testing the goodness of fit of the binomial distribution.
Biometrika, 66(3): 585-590.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chisq.test">chisq.test</a></code>, <code><a href="#topic+z.test">z.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For incidence data:
my_incidence &lt;- incidence(tobacco_viruses)
my_fisher &lt;- agg_index(my_incidence, method = "fisher")
calpha.test(my_fisher)

</code></pre>

<hr>
<h2 id='chisq.test'>Chi-squared test.</h2><span id='topic+chisq.test'></span><span id='topic+chisq.test.default'></span><span id='topic+chisq.test.fisher'></span>

<h3>Description</h3>

<p>Performs chi-squared tests for Fisher's aggregation indices (computed with
either count or incidence data). If another kind of data is provided, the R
standard <code>chisq.test</code> function is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisq.test(x, ...)

## Default S3 method:
chisq.test(x, ...)

## S3 method for class 'fisher'
chisq.test(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chisq.test_+3A_x">x</code></td>
<td>
<p>Either the output of the <code><a href="#topic+agg_index">agg_index</a></code> function with
<code>method = "fisher"</code> as parameter, or another R object. In the latter
case, stats::<code><a href="stats.html#topic+chisq.test">chisq.test</a></code> is called.</p>
</td></tr>
<tr><td><code id="chisq.test_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to
stats::<code><a href="stats.html#topic+chisq.test">chisq.test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the null hypothesis for Fisher's aggregation index (index = 1, i.e. a
random pattern is observed), (N - 1)*index follows a chi-squared distribution
with N - 1 degrees of freedom. N is the number of sampling units.
</p>


<h3>Value</h3>

<p>Same kind of object as the one returns by the stats
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code> function.
</p>


<h3>References</h3>

<p>For count and incidence data:
</p>
<p>Madden LV, Hughes G. 1995. Plant disease incidence: Distributions,
heterogeneity, and temporal analysis. Annual Review of Phytopathology 33(1):
529–564.
<a href="https://doi.org/10.1146/annurev.py.33.090195.002525">doi:10.1146/annurev.py.33.090195.002525</a>
</p>
<p>Patil GP, Stiteler WM. 1973. Concepts of aggregation and their
quantification: a critical review with some new results and applications.
Researches on Population Ecology, 15(1): 238-254.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calpha.test">calpha.test</a></code>, <code><a href="#topic+z.test">z.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For incidence data:
my_incidence &lt;- incidence(tobacco_viruses)
my_fisher &lt;- agg_index(my_incidence, method = "fisher")
chisq.test(my_fisher)

</code></pre>

<hr>
<h2 id='citrus_ctv'>Incidence of citrus tristeza virus (CTV) disease in three fields.</h2><span id='topic+citrus_ctv'></span>

<h3>Description</h3>

<p>CTV incidence data for three orchards in eastern Spain reported for
consecutive years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>citrus_ctv
</code></pre>


<h3>Format</h3>

<p>There are three data frames:
</p>

<ul>
<li> <p><code>IVI3and4</code>: A data frame with 864 rows and 5 variables.
</p>
</li>
<li> <p><code>IVI6and7</code>: A data frame with 648 rows and 5 variables.
</p>
</li>
<li> <p><code>El_Realengo</code>: A data frame with 2000 rows and 5 variables.
</p>
</li></ul>

<p>The structure is the same for all the data frames:
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1:2] </td><td style="text-align: left;"> x,y </td><td style="text-align: left;"> Grid spatial coordinates. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 3]   </td><td style="text-align: left;"> t   </td><td style="text-align: left;"> Year of disease assessments. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 4]   </td><td style="text-align: left;"> i   </td><td style="text-align: left;"> Disease incidence. 0: Healthy, 1: Diseased. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 5]   </td><td style="text-align: left;"> n   </td><td style="text-align: left;"> Sampling unit size. n = 1 means that the sampling
                          unit size is the plant. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>Both <code>IVI3and4</code> and <code>IVI6and7</code> orchards consisted of 216 trees each
of Washington navel orange on Troyer citrange planted in 1978 on a 2 x 6-m
spacing. <code>El_Realengo</code> orchard consisted of 400 Marsh seedless
grapefruit on Troyer citrange planted in 1973 on a 5.5 x 5.5-m spacing.
</p>


<h3>Source</h3>

<p>Gottwald TR, Cambra M, Moreno P, Camarasa E, Piquer J. 1996. Spatial
and temporal analyses of citrus tristeza virus in eastern Spain.
Phytopathology 86, 45–55.
</p>
<p>Gibson GJ. 1997. Investigating mechanisms of spatiotemporal epidemic
spread using stochastic models. Phytopathology 87, 139-46.
<a href="https://doi.org/10.1094/PHYTO.1997.87.2.139">doi:10.1094/PHYTO.1997.87.2.139</a>
</p>

<hr>
<h2 id='clump'>Regroup observational data into even clumps of individuals.</h2><span id='topic+clump'></span><span id='topic+clump.intensity'></span>

<h3>Description</h3>

<p>This function provides a easy way to regroup recorded data into groups of
same number of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clump(object, ...)

## S3 method for class 'intensity'
clump(object, unit_size, fun = sum, inclusive_unspecified = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clump_+3A_object">object</code></td>
<td>
<p>An <code>intensity</code> object.</p>
</td></tr>
<tr><td><code id="clump_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="clump_+3A_unit_size">unit_size</code></td>
<td>
<p>Size of a group unit. It must be a named vector, with names
corresponding to non-observational variables (i.e. space and time
variables). If the size of a variable in the data set is not a multiple
of the provided value in <code>unit_size</code>, some sampling units (the last
ones) will be dropped so that clumps of individuals remain even
throughout the data set.</p>
</td></tr>
<tr><td><code id="clump_+3A_fun">fun</code></td>
<td>
<p>Function used to group observational data together.</p>
</td></tr>
<tr><td><code id="clump_+3A_inclusive_unspecified">inclusive_unspecified</code></td>
<td>
<p>Not yet implemented. Do unspecified mapped
variables (different from i and n) need to be included into the bigger
possible sampling unit (TRUE) or splited into as many sampling units as
possible (FALSE, default)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+intensity">intensity</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_incidence &lt;- incidence(tomato_tswv$field_1929)
plot(my_incidence, type = "all")

# Different spatial size units:
my_incidence_clumped_1 &lt;- clump(my_incidence, unit_size = c(x = 3, y = 3))
plot(my_incidence_clumped_1, type = "all")

my_incidence_clumped_2 &lt;- clump(my_incidence, unit_size = c(x = 4, y = 5))
plot(my_incidence_clumped_2, type = "all")

# To get mean disease incidence for each plant over the 3 scoring dates:
my_incidence_clumped_3 &lt;- clump(my_incidence, unit_size = c(t = 3), fun = mean)
plot(my_incidence_clumped_3)


</code></pre>

<hr>
<h2 id='codling_moths'>Count of codling moth larvae.</h2><span id='topic+codling_moths'></span>

<h3>Description</h3>

<p>Codling moth diapausing larvae were collected in an apple orchard in
south-eastern France. Larvae were caught on strip traps wrapped around tree
trunks in July 2008 and collected the following October. 30 traps were used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codling_moths
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows and 3 variables:
</p>

<table>
<tr>
 <td style="text-align: left;">
    [, 1:2] </td><td style="text-align: left;"> x,y </td><td style="text-align: left;"> Metric spatial coordonates. </td>
</tr>
<tr>
 <td style="text-align: left;">
    [, 3]   </td><td style="text-align: left;"> i   </td><td style="text-align: left;"> Counts of codling moth larvae. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Lavigne C, Ricci B, Franck P, Senoussi R. 2010. Spatial analyses of
ecological count data: A density map comparison approach. Basic and
Applied Ecology 11: 734-42.
<a href="https://doi.org/10.1016/j.baae.2010.08.011">doi:10.1016/j.baae.2010.08.011</a>
</p>

<hr>
<h2 id='coef.smle'>Extract Model Coefficients</h2><span id='topic+coef.smle'></span>

<h3>Description</h3>

<p><code>coef</code> is a generic function which extracts model coefficients
from objects returned by modeling functions.  <code>coefficients</code> is
an <em>alias</em> for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smle'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.smle_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model coefficients is
meaningful.</p>
</td></tr>
<tr><td><code id="coef.smle_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients extracted from the model object <code>object</code>.
</p>
<p>For standard model fitting classes this will be a named numeric vector.
For <code>"maov"</code> objects (produced by <code><a href="stats.html#topic+aov">aov</a></code>) it will be a matrix.
</p>

<hr>
<h2 id='dogwood_anthracnose'>Incidence of dogwood anthracnose.</h2><span id='topic+dogwood_anthracnose'></span>

<h3>Description</h3>

<p>Incidence data from the Dogwood Anthracnose Impact Assessment Program for
1990 and 1991, in the Southeast of the USA, reported by Zarnoch et al (1995).
Only plots with exactly n = 10 dogwood trees are present in the data set (168
and 161 plots in 1990 and 1991, respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dogwood_anthracnose
</code></pre>


<h3>Format</h3>

<p>A data frame with 329 rows and 3 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1] </td><td style="text-align: left;"> t </td><td style="text-align: left;"> Year of disease assessments (1990 or 1991).. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 2] </td><td style="text-align: left;"> i </td><td style="text-align: left;"> Number of diseased plants (from 0 to 10). </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 3] </td><td style="text-align: left;"> n </td><td style="text-align: left;"> Sampling unit size. Here, n = 10 plants per sampling
                      unit (or plot). </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Zarnoch SJ, Anderson RL, Sheffield RM. 1995. Using the <code class="reqn">\beta</code>-binomial
distribution to characterize forest health. Canadian journal of forest
research 25, 462–469.
</p>

<hr>
<h2 id='epiphy'><a href="https://CRAN.R-project.org/package=epiphy"><span class="pkg">epiphy</span></a>: An R package to analyze plant disease epidemics.</h2><span id='topic+epiphy'></span>

<h3>Description</h3>

<p><a href="https://CRAN.R-project.org/package=epiphy"><span class="pkg">epiphy</span></a> makes it easy to analyze plant disease epidemics. It provides
a common framework for plant disease intensity data recorded over time and/or
space. Implemented statistical methods are currently mainly focused on
spatial pattern analysis (e.g., aggregation indices, Taylor and binary power
laws, distribution fitting, SADIE and mapcomp methods). Several data sets
that were mainly published in plant disease epidemiology literature are also
included in this package
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer:</strong> Christophe Gigot <a href="mailto:ch.gigot@gmail.com">ch.gigot@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful references:
</p>
<p>Gosme M. 2008. Comment analyser la structure spatiale et modéliser le
développement spatio-temporel des épiphyties? Canadian Journal of Plant
Pathology, 30:4-23.
</p>
<p>Madden LV, Hughes G, van den Bosch F. 2007. Spatial aspects of epidemics -
III: Patterns of plant disease. In: The study of plant disease epidemics,
235–278. American Phytopathological Society, St Paul, MN.
</p>

<hr>
<h2 id='fit_two_distr'>Maximum likelihood fitting of two distributions and goodness-of-fit
comparison.</h2><span id='topic+fit_two_distr'></span><span id='topic+fit_two_distr.default'></span><span id='topic+fit_two_distr.count'></span><span id='topic+fit_two_distr.incidence'></span>

<h3>Description</h3>

<p>Different distributions may be used depending on the kind of provided data.
By default, the Poisson and negative binomial distributions are fitted to
count data, whereas the binomial and beta-binomial distributions are used
with incidence data. Either Randomness assumption (Poisson or binomial
distributions) or aggregation assumption (negative binomial or beta-binomial)
are made, and then, a goodness-of-fit comparison of both distributions is
made using a log-likelihood ratio test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_two_distr(data, ...)

## Default S3 method:
fit_two_distr(data, random, aggregated, ...)

## S3 method for class 'count'
fit_two_distr(
  data,
  random = smle_pois,
  aggregated = smle_nbinom,
  n_est = c(random = 1, aggregated = 2),
  ...
)

## S3 method for class 'incidence'
fit_two_distr(
  data,
  random = smle_binom,
  aggregated = smle_betabinom,
  n_est = c(random = 1, aggregated = 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_two_distr_+3A_data">data</code></td>
<td>
<p>An <code>intensity</code> object.</p>
</td></tr>
<tr><td><code id="fit_two_distr_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
<tr><td><code id="fit_two_distr_+3A_random">random</code></td>
<td>
<p>Distribution to describe random patterns.</p>
</td></tr>
<tr><td><code id="fit_two_distr_+3A_aggregated">aggregated</code></td>
<td>
<p>Distribution to describe aggregated patterns.</p>
</td></tr>
<tr><td><code id="fit_two_distr_+3A_n_est">n_est</code></td>
<td>
<p>Number of estimated parameters for both distributions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the hood, <code>distr_fit</code> relies on the <code><a href="#topic+smle">smle</a></code> utility
which is a wrapped around the <code><a href="stats.html#topic+optim">optim</a></code> procedure.
</p>
<p>Note that there may appear warnings about chi-squared goodness-of-fit tests
if any expected count is less than 5 (Cochran's rule of thumb).
</p>


<h3>Value</h3>

<p>An object of class <code>fit_two_distr</code>, which is a list containing at least
the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>call</code>  </td><td style="text-align: left;"> The function <code><a href="base.html#topic+call">call</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>name</code>  </td><td style="text-align: left;"> The names of both distributions. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>model</code> </td><td style="text-align: left;"> The outputs of fitting process for both distributions. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>llr</code>   </td><td style="text-align: left;"> The result of the log-likelihood ratio test. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Other components can be present such as:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>param</code> </td><td style="text-align: left;"> A numeric matrix of estimated parameters (that can be
                      printed using <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>). </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>freq</code>  </td><td style="text-align: left;"> A data frame or a matrix with the observed and expected
                      frequencies for both distributions for the different
                      categories. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gof</code>   </td><td style="text-align: left;"> Goodness-of-fit tests for both distributions (which are
                      typically chi-squared goodness-of-fit tests). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Madden LV, Hughes G. 1995. Plant disease incidence: Distributions,
heterogeneity, and temporal analysis. Annual Review of Phytopathology 33(1):
529–564.
<a href="https://doi.org/10.1146/annurev.py.33.090195.002525">doi:10.1146/annurev.py.33.090195.002525</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple workflow for incidence data:
my_data &lt;- count(arthropods)
my_data &lt;- split(my_data, by = "t")[[3]]
my_res  &lt;- fit_two_distr(my_data)
summary(my_res)
plot(my_res)

# Simple workflow for incidence data:
my_data &lt;- incidence(tobacco_viruses)
my_res  &lt;- fit_two_distr(my_data)
summary(my_res)
plot(my_res)

# Note that there are other methods to fit some common distributions.
# For example for the Poisson distribution, one can use glm:
my_arthropods &lt;- arthropods[arthropods$t == 3, ]
my_model &lt;- glm(my_arthropods$i ~ 1, family = poisson)
lambda &lt;- exp(coef(my_model)[[1]]) # unique(my_model$fitted.values) works also.
lambda
# ... or the fitdistr function in MASS package:
require(MASS)
fitdistr(my_arthropods$i, "poisson")

# For the binomial distribution, glm still works:
my_model &lt;- with(tobacco_viruses, glm(i/n ~ 1, family = binomial, weights = n))
prob &lt;- logit(coef(my_model)[[1]], rev = TRUE)
prob
# ... but the binomial distribution is not yet recognized by MASS::fitdistr.

# Examples featured in Madden et al. (2007).
# p. 242-243
my_data &lt;- incidence(dogwood_anthracnose)
my_data &lt;- split(my_data, by = "t")
my_fit_two_distr &lt;- lapply(my_data, fit_two_distr)
lapply(my_fit_two_distr, function(x) x$param$aggregated[c("prob", "theta"), ])
lapply(my_fit_two_distr, plot)

my_agg_index &lt;- lapply(my_data, agg_index)
lapply(my_agg_index, function(x) x$index)
lapply(my_agg_index, chisq.test)

</code></pre>

<hr>
<h2 id='hop_viruses'>Incidence of three viruses in an Australian hop garden.</h2><span id='topic+hop_viruses'></span>

<h3>Description</h3>

<p>Three viruses, i.e. Hop latent virus (HpLV), Hop mosaic virus (HpMV), and
Apple mosaic virus (ApMV), were monitored in an Australian hop garden for two
consecutive years (1996 and 1997). The hop garden was established in 1989
with the variety Victoria in a commercial hop farm at Bushy Park, Tasmania,
Australia. It consisted of 25 rows containing 51 plants each, so that there
were 1275 hop plants in total. There were 2.1 m between rows, and 1.8 m
between plants within rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hop_viruses
</code></pre>


<h3>Format</h3>

<p>There are three data frames, one for each virus (<code>HpLV</code>, <code>HpMV</code> and
<code>ApMV</code>). Each data frame consists of 2550 rows and 7 variables:
</p>

<table>
<tr>
 <td style="text-align: left;">
    [, 1:2] </td><td style="text-align: left;"> x,y   </td><td style="text-align: left;"> Grid spatial coordinates. </td>
</tr>
<tr>
 <td style="text-align: left;">
    [, 3:4] </td><td style="text-align: left;"> xm,ym </td><td style="text-align: left;"> Metric spatial coordinates. </td>
</tr>
<tr>
 <td style="text-align: left;">
    [, 5]   </td><td style="text-align: left;"> t     </td><td style="text-align: left;"> Year of disease assessments. </td>
</tr>
<tr>
 <td style="text-align: left;">
    [, 6]   </td><td style="text-align: left;"> i     </td><td style="text-align: left;"> Incidence. 0: Healthy, 1: Diseased. </td>
</tr>
<tr>
 <td style="text-align: left;">
    [, 7]   </td><td style="text-align: left;"> n     </td><td style="text-align: left;"> Sampling unit size. n = 1 means that the sampling
                            unit size is the plant. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Pethybridge SJ, Madden LV. 2003. Analysis of spatiotemporal dynamics
of virus spread in an Australian hop garden by stochastic modeling. Plant
Disease 87:56-62.
<a href="https://doi.org/10.1094/PDIS.2003.87.1.56">doi:10.1094/PDIS.2003.87.1.56</a>
</p>

<hr>
<h2 id='indAndSub'>Retrieve vector or array indices</h2><span id='topic+indAndSub'></span><span id='topic+ind2sub'></span><span id='topic+sub2ind'></span>

<h3>Description</h3>

<p><code>ind2sub</code> is just an alias for <code><a href="base.html#topic+arrayInd">arrayInd</a></code>.
<code>sub2ind</code> is the reverse of <code>ind2sub</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind2sub(ind, .dim, .dimnames = NULL, useNames = FALSE)

sub2ind(sub, .dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indAndSub_+3A_ind">ind</code></td>
<td>
<p>Vector indices.</p>
</td></tr>
<tr><td><code id="indAndSub_+3A_.dim">.dim</code></td>
<td>
<p><code><a href="base.html#topic+dim">dim</a>(.)</code> integer vector</p>
</td></tr>
<tr><td><code id="indAndSub_+3A_.dimnames">.dimnames</code></td>
<td>
<p>optional list of character <code><a href="base.html#topic+dimnames">dimnames</a>(.)</code>.
If <code>useNames</code> is true, to be used for constructing dimnames for
<code>arrayInd()</code> (and hence, <code>which(*, arr.ind=TRUE)</code>).
If <code><a href="base.html#topic+names">names</a>(.dimnames)</code> is not empty, these are used as
column names.  <code>.dimnames[[1]]</code> is used as row names.</p>
</td></tr>
<tr><td><code id="indAndSub_+3A_usenames">useNames</code></td>
<td>
<p>logical indicating if the value of <code>arrayInd()</code>
should have (non-null) dimnames at all.</p>
</td></tr>
<tr><td><code id="indAndSub_+3A_sub">sub</code></td>
<td>
<p>Array/matrix indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="base.html#topic+arrayInd">arrayInd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
mat &lt;- matrix(round(runif(6, min = 0, max = 10)), nrow = 2, ncol = 3)
ind2sub(4, dim(mat))
sub2ind(c(2, 2), dim(mat))
subs &lt;- as.matrix(expand.grid(1:2,2:3))
sub2ind(subs, dim(mat))

</code></pre>

<hr>
<h2 id='intensity'>Construct count, incidence and severity objects.</h2><span id='topic+intensity'></span><span id='topic+count'></span><span id='topic+count_data'></span><span id='topic+incidence'></span><span id='topic+incidence_data'></span><span id='topic+severity'></span><span id='topic+severity_data'></span>

<h3>Description</h3>

<p><code>count()</code>, <code>incidence()</code> and <code>severity()</code> create eponym
objects. All of these classes inherit from the base class <code>intensity</code>.
The choice of the class depends on the nature of the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(data, mapping, keep_only_std = TRUE)

incidence(data, mapping, keep_only_std = TRUE)

severity(data, mapping, keep_only_std = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intensity_+3A_data">data</code></td>
<td>
<p>A data frame. Each line corresponds to a record (or case, or
entry).</p>
</td></tr>
<tr><td><code id="intensity_+3A_mapping">mapping</code></td>
<td>
<p>A <code>mapping</code> object, created with <code>mapping()</code> or
<code>mapping_()</code> functions. ... A vector with all the corresponding variables. The different
elements can be named (names of the elements) of the data frame in the
incidence object), or unamed. In the latter case, elements must be
correctly ordered, i.e. x, y, z, t, r and then n. If variables in NULL,
then only the 6 first ... will be take into account in the following (1, 2,
...), i.e. the id of the value. All the 'parameters' need to be specified.</p>
</td></tr>
<tr><td><code id="intensity_+3A_keep_only_std">keep_only_std</code></td>
<td>
<p>Are only standard names kept when proceeding to mapping?
Setting <code>keep_only_std</code> to TRUE may be useful for subsequent data splitting
using extra labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>incidence</code> reads disease incidence data from a data frame and return an
incidence object. All of these classes inherit from <code>intensity</code> class.
</p>

<ul>
<li><p> count: Each sampling unit contains from 0 to theoreticaly an infinity of data.
Number are positive integers.
</p>
</li>
<li><p> incidence: Each sampling unit contains an number of diseased plants,
ranging from 0 to <code>n</code> which is the total amount of plants per sampling
unit.
</p>
</li>
<li><p> severity: Each sampling unit contain a percentage of disease, a positive
real number ranging from 0.0 to 1.0.
</p>
</li></ul>

<p>Class intensity and inherited classes
</p>
<p>All the classes recording disease intensity measurements inherit from this
class. The class <code>intensity</code> is virtual which means that no object of a
class <code>intensity</code> can be constructed. This class only describes common
features of all the different disease intensity measurements implemented in
this package (<code><a href="#topic+count">count</a></code>, <code><a href="#topic+incidence">incidence</a></code> and
<code><a href="#topic+severity">severity</a></code>). You should call one of these inherited classes
instead, depending on the nature of your data.
</p>
<p>By convention, the first columns of the different data frames of each slots
have names, but the spatial, temporal or even disease information do not need
to fit to these conventions or may be less straightforward and need more
columns to record correctly all the information. In such unusual situations,
the automatic options of the analysis tools would need to be overridden to be
able to work in the desired way.
</p>
<p>The differences between the different inherited classes regard only the
<code>obs</code> slot. In the case of <code><a href="#topic+count">count</a></code>, the data expected for
each record are positive integers (N+). For <code><a href="#topic+incidence">incidence</a></code>, the data
sets are supposed to be two information set per records, the number of
diseased unit per sampling unit (r) and the total number of units per
sampling unit (n). Note that in its current implementation, n is supposed to
be the same for a whole data set. Unequal sampling units are not implemented
yet. Finally, for <code><a href="#topic+severity">severity</a></code>, r is positive real ranging from 0
to 1 and depecting a percentage.
</p>
<p>space A data frame containing only spatial information. Each row
corresponds to a sampling unit. By convention, the first 3 columns are
names <code>x</code>, <code>y</code>, <code>z</code>.
</p>
<p>time A data frame containing temporal information. By convention, the
first column is named <code>t</code>.
</p>
<p>obs A data frame containing disease observations themselves. The name
of the columns may differ between the sub-class chosed to record the data.
</p>
<p>Note that it is possible to create a &quot;severity&quot; object but no statistical
tools are currently implemented to deal with such an object.
</p>
<p>An <code>intensity</code> object contains at very least the &quot;pure&quot; intensity
records (column <code>r</code>) which is a so-called observational variable.
Another observational variable, the number of individuals in a sampling unit
(<code>n</code>), is present in the case of a <code>incidence</code> object. Very often
in addition to observational variables, there are spatial (columns <code>x</code>,
<code>y</code> and/or <code>z</code>) and/or temporal (column <code>t</code>) variables.
</p>
<p>Note that the <code>severity</code> class and the <code>z</code> variable (the 3rd
spatial dimension) are implemented but no statistical methods use them at
this point.
</p>


<h3>Value</h3>

<p>An <code>intensity</code> object.
</p>
<p>When printed, difference information are available:
</p>

<ul>
<li><p> The number of sampling units.
</p>
</li>
<li><p> The time.
</p>
</li>
<li><p> Is it georeferenced (TRUE/FALSE)
</p>
</li>
<li><p> Are there any NA data (TRUE/FALSE)
</p>
</li>
<li><p> Is it a complet array (TRUE/FALSE)? A complete array means that all the recorded values allow to
display an array (even if some data are not available), but this was explicitelly specified. To
complete a dataset, just use <code>complete(data)</code>. You can also remove NA, which is necessary to use
some analysis technics, using <code>replaceNA(data)</code> or <code>replace.na(data)</code>. Note that using both
commands will results in modifying the original data sets which will be specified.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Create intensity objects
# Implicite call: The variable mapping does not need to be specified if the
# column names of the input data frame follow the default names.
colnames(tomato_tswv$field_1929) # Returns c("x", "y", "t", "i", "n")
my_incidence_1 &lt;- incidence(tomato_tswv$field_1929)
my_incidence_1
my_incidence_2 &lt;- incidence(tomato_tswv$field_1929,
                            mapping(x = x, y = y, t = t, i = i, n = n))
identical(my_incidence_1, my_incidence_2)

# Explicite call: Otherwise, the variable mapping need to be specified, at
# least for column names that do not correspond to default names.
colnames(aphids) # Returns c("xm", "ym", "i")
my_count_1 &lt;- count(aphids, mapping(x = xm, y = ym, i = i))
my_count_1
# We can drop the "i = i" in the mapping.
my_count_2 &lt;- count(aphids, mapping(x = xm, y = ym))
identical(my_count_1, my_count_2)

# It is possible to change the variable mapping after the creation of an
# intensity object:
another_incidence &lt;- incidence(hop_viruses$HpLV)
another_incidence
remap(another_incidence, mapping(x = xm, y = ym))

## Plotting data
plot(my_incidence_1) # Same as: plot(my_incidence_1, type = "spatial")
plot(my_incidence_1, type = "temporal")

plot(my_count_1, tile = FALSE, size = 5)
plot(my_count_1, type = "temporal") # Not possible: there is only 1 date.

# Using grayscale:
plot(my_count_1, grayscale = TRUE)
plot(my_count_1, grayscale = TRUE, tile = FALSE, size = 5)

</code></pre>

<hr>
<h2 id='is.intensity'>Test if an object is of class <code>intensity</code> or one of its subclasses.</h2><span id='topic+is.intensity'></span><span id='topic+is.count'></span><span id='topic+is.incidence'></span><span id='topic+is.severity'></span>

<h3>Description</h3>

<p>Test if an object is of class <code>intensity</code> or one of its subclasses
(i.e. <code>count</code>, <code>incidence</code> or <code>severity</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.intensity(x)

is.count(x)

is.incidence(x)

is.severity(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.intensity_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if its argument's value is the corresponding <code>intensity</code>
object and FALSE otherwise.
</p>

<hr>
<h2 id='link'>Some link functions.</h2><span id='topic+link'></span><span id='topic+logit'></span><span id='topic+probit'></span><span id='topic+cloglog'></span>

<h3>Description</h3>

<p>Logit, probit and cloglog functions are available.
The logit and the logistic (with rev = TRUE), i.e. the inverse-logit functions.
Probit is a wrapper around <code>qnorm</code> (for <code class="reqn">probit</code>) and <code>pnorm</code> (for <code class="reqn">probit^{-1}</code>)
Complementary log-log transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x, rev = FALSE)

probit(x, rev = FALSE)

cloglog(x, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="link_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="link_+3A_rev">rev</code></td>
<td>
<p>The inverse of the function?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>

<hr>
<h2 id='logLik.smle'>Extract log-likelihood</h2><span id='topic+logLik.smle'></span>

<h3>Description</h3>

<p>This function returns the maximal log-likelihood estimated with
<code><a href="#topic+smle">smle</a></code>, if <code>f</code> returned log-likelihood value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smle'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.smle_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="logLik.smle_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>logLik</code>.  This is a number with at
least one attribute, <code>"df"</code> (<b>d</b>egrees of <b>f</b>reedom),
giving the number of (estimated) parameters in the model.
</p>
<p>There is a simple <code>print</code> method for <code>"logLik"</code> objects.
</p>
<p>There may be other attributes depending on the method used: see the
appropriate documentation.  One that is used by several methods is
<code>"nobs"</code>, the number of observations used in estimation (after
the restrictions if <code>REML = TRUE</code>).
</p>

<hr>
<h2 id='mapcomp'>Map Comparison procedure.</h2><span id='topic+mapcomp'></span><span id='topic+mapcomp.data.frame'></span><span id='topic+mapcomp.matrix'></span><span id='topic+mapcomp.count'></span><span id='topic+mapcomp.incidence'></span>

<h3>Description</h3>

<p><code>mapcomp</code> performs a spatial pattern analysis based on the calculation
of a formal distance (the Hellinger distance) between the density map of
count or incidence data, and the density map of sampling effort. Statistical
tests of spatial homogeneity are based on permutations across sampling sites
and on valuable properties of the Hellinger distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapcomp(data, ...)

## S3 method for class 'data.frame'
mapcomp(
  data,
  delta,
  bandwidth,
  nperm = 100,
  edge_correction = FALSE,
  threads = 1,
  verbose = TRUE,
  ...
)

## S3 method for class 'matrix'
mapcomp(
  data,
  delta,
  bandwidth,
  nperm = 100,
  edge_correction = FALSE,
  threads = 1,
  verbose = TRUE,
  ...
)

## S3 method for class 'count'
mapcomp(
  data,
  delta,
  bandwidth,
  nperm = 100,
  edge_correction = FALSE,
  threads = 1,
  verbose = TRUE,
  ...
)

## S3 method for class 'incidence'
mapcomp(
  data,
  delta,
  bandwidth,
  nperm = 100,
  edge_correction = FALSE,
  threads = 1,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapcomp_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix with only three columns: the two first
ones must be the x and y coordinates of the sampling units, and the last
one, the corresponding disease intensity observations. It can also be a
<code><a href="#topic+count">count</a></code> or an <code><a href="#topic+incidence">incidence</a></code> object.</p>
</td></tr>
<tr><td><code id="mapcomp_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
<tr><td><code id="mapcomp_+3A_delta">delta</code></td>
<td>
<p>Mesh size of the grid over the geographical domain of the
sampling units used to compute the integral Hellinger distance between
the probability density function of observations and the probability
density function of sampling effort.</p>
</td></tr>
<tr><td><code id="mapcomp_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Bandwidth parameter for smoothing. It allows to test the
spatial extent of heterogeneity if any.</p>
</td></tr>
<tr><td><code id="mapcomp_+3A_nperm">nperm</code></td>
<td>
<p>Number of random permutations to assess probabilities.</p>
</td></tr>
<tr><td><code id="mapcomp_+3A_edge_correction">edge_correction</code></td>
<td>
<p>Apply edge correction to account for the fact that
bordering points intrinsically suffer from a lack of neighboring
observation sites. FALSE by default.</p>
</td></tr>
<tr><td><code id="mapcomp_+3A_threads">threads</code></td>
<td>
<p>Number of threads to perform the computations.</p>
</td></tr>
<tr><td><code id="mapcomp_+3A_verbose">verbose</code></td>
<td>
<p>Explain what is being done (TRUE by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mapcomp</code>, which is a list containing the following
components:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>data</code>       </td><td style="text-align: left;"> The input data. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>coord</code>      </td><td style="text-align: left;"> The coordinates and normalized intensity for each point of the full grid. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>object</code>     </td><td style="text-align: left;"> The class of <code>data</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>bandwidth</code>  </td><td style="text-align: left;"> The <code>bandwidth</code> parameter. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>stat, pval</code> </td><td style="text-align: left;"> The statistic and corresponding p-value (see references for more details). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Lavigne C, Ricci B, Franck P, Senoussi R. 2010. Spatial analyses of
ecological count data: A density map comparison approach. Basic and Applied
Ecology. 11:734–742.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
my_res &lt;- mapcomp(codling_moths, delta = 1, bandwidth = 11,
                  edge_correction = FALSE, nperm = 20)
my_res
plot(my_res)

set.seed(123)
my_count &lt;- count(codling_moths, mapping(x = xm, y = ym))
my_res &lt;- mapcomp(my_count, delta = 1, bandwidth = 11,
                  edge_correction = FALSE, nperm = 20)
my_res
plot(my_res, bins = 10)

</code></pre>

<hr>
<h2 id='mapped_var'>Existing variable mappings.</h2><span id='topic+mapped_var'></span><span id='topic+mapped_var+3C-'></span>

<h3>Description</h3>

<p>Get or set existing variable mappings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapped_var(x)

mapped_var(x, keep = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapped_var_+3A_x">x</code></td>
<td>
<p>An <code>intensity</code> object.</p>
</td></tr>
<tr><td><code id="mapped_var_+3A_keep">keep</code></td>
<td>
<p>Logical. Do we keep any previous mapped variables that are not
redifined in the <code>mapping</code> object?</p>
</td></tr>
<tr><td><code id="mapped_var_+3A_value">value</code></td>
<td>
<p>A <code>mapping</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mapped_var</code> returns the list of current mapped names of the object
<code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mapping">mapping</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_data &lt;- count(aphids)
my_data
mapped_var(my_data)
mapped_var(my_data) &lt;- mapping(x = X, y = Y)
mapped_var(my_data)
mapped_var(my_data) &lt;- mapping(x = x, r = r, keep = FALSE)
mapped_var(my_data)

</code></pre>

<hr>
<h2 id='mapping'>Construct data mappings.</h2><span id='topic+mapping'></span><span id='topic+mapping_'></span><span id='topic+remap'></span>

<h3>Description</h3>

<p>Data mappings describe how variables in the data are mapped to standard names
used throughout <code>epiphy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapping(...)

mapping_(x)

remap(data, mapping, keep_only_std = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapping_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions separated by commas.</p>
</td></tr>
<tr><td><code id="mapping_+3A_x">x</code></td>
<td>
<p>Vector of one or more character strings.</p>
</td></tr>
<tr><td><code id="mapping_+3A_data">data</code></td>
<td>
<p>An <code>intensity</code> object.</p>
</td></tr>
<tr><td><code id="mapping_+3A_mapping">mapping</code></td>
<td>
<p>A <code>mapping</code> object.</p>
</td></tr>
<tr><td><code id="mapping_+3A_keep_only_std">keep_only_std</code></td>
<td>
<p>Keep only standard variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard names are <code>x</code>, <code>y</code> and <code>z</code> for the three spatial
dimensions, and <code>t</code> for the time. <code>r</code> corresponds to the records
of (disease) intensity, and <code>n</code>, the number of individuals in a sampling
unit (if applicable).
</p>
<p><code>mapping()</code> works with expressions, and <code>mapping_()</code>, with a vector
of characters.
</p>


<h3>Value</h3>

<p>A list of mapped names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mapped_var">mapped_var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mapping(x = col1, y = col2)
mapping_(c("x = col1", "y = col2"))

</code></pre>

<hr>
<h2 id='offspring_survival'>Offspring survival of rats experiencing different diets.</h2><span id='topic+offspring_survival'></span>

<h3>Description</h3>

<p>Results of an experiment where two groups of 16 female rats were fed
different diets during pregnancy and lactation periods. One group's diet
contained a chemical under review, and the other one was a control. For each
litter, the number of pups alive at 4 days, and the number of pups weaned
(i.e. that survived the 21-day lactation period) were recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>offspring_survival
</code></pre>


<h3>Format</h3>

<p>A data frame with 32 rows and 3 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1]   </td><td style="text-align: left;"> group </td><td style="text-align: left;"> Either control or treated group. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 2]   </td><td style="text-align: left;"> i     </td><td style="text-align: left;"> Pups weaned. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 3]   </td><td style="text-align: left;"> n     </td><td style="text-align: left;"> Pups alive at 4 days. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Weil CS. 1970. Selection of the valid number of sampling units and a
consideration of their combination in toxicological studies involving
reproduction, teratogenesis or carcinogenesis. Food and Cosmetics
Toxicology 8: 177-182.
</p>

<hr>
<h2 id='onion_bacterial_blight'>Incidence of bacterial blight of onion.</h2><span id='topic+onion_bacterial_blight'></span>

<h3>Description</h3>

<p>Assessments of bacterial blight of onion at two dates. The experimental plot
was sown with naturally X. axonopodis pv. allii-contaminated onion (A. cepa
L. cv. Chateau-vieux) seed lot, with a contamination rate of about 0.04%.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onion_bacterial_blight
</code></pre>


<h3>Format</h3>

<p>A data frame with 1134 rows and 5 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1:2] </td><td style="text-align: left;"> x,y </td><td style="text-align: left;"> Grid spatial coordinates. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 3]   </td><td style="text-align: left;"> t   </td><td style="text-align: left;"> Date of disease assessments. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 4]   </td><td style="text-align: left;"> i   </td><td style="text-align: left;"> Disease incidence. 0: Healthy, 1: Diseased. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 5]   </td><td style="text-align: left;"> n   </td><td style="text-align: left;"> Sampling unit size. n = 1 means that the sampling
                          unit size is the plant. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Roumagnac P, Pruvost O, Chiroleu F, Hughes G. 2004. Spatial and
temporal analyses of bacterial blight of onion caused by Xanthomonas
axonopodis pv. allii. Phytopathology 94, 138–146.
<a href="https://doi.org/10.1094/PHYTO.2004.94.2.138">doi:10.1094/PHYTO.2004.94.2.138</a>
</p>

<hr>
<h2 id='power_law'>Taylor's and binary power laws.</h2><span id='topic+power_law'></span>

<h3>Description</h3>

<p>Assesses the overall degree of heterogeneity in a collection of data sets at
the sampling-unit scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_law(data, log_base = exp(1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_law_+3A_data">data</code></td>
<td>
<p>A list of <code>intensity</code> objects (<code>count</code> or
<code>incidence</code> objects).</p>
</td></tr>
<tr><td><code id="power_law_+3A_log_base">log_base</code></td>
<td>
<p>Logarithm base to be used.</p>
</td></tr>
<tr><td><code id="power_law_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power law describes the relationship between the observed variance of
individuals within a data set (<code>s^2</code>) and the corresponding variance
under the assumption of no aggregation (<code>s\'^2</code>). It can be expressed
under its logarithmic form as: <code>log(s^2) = log(a) + b log(Y)</code>, with:
</p>

<ul>
<li> <p><code>Y = p</code> in the case of count data (Taylor's power law).
</p>
</li>
<li> <p><code>Y = p(1 - p)</code> in the case of incidence data (binary power law).
</p>
</li></ul>

<p><code>p</code> corresponds to the mean proportion of recorded individuals in case
of incidence data, and the absolute value in case of count data.
</p>


<h3>Value</h3>

<p>A <code>power_law</code> object.
</p>


<h3>References</h3>

<p>Taylor LR. 1961. Aggregation, variance and the mean. Nature 189: 732–35.
</p>
<p>Hughes G, Madden LV. 1992. Aggregation and incidence of disease. Plant
Pathology 41 (6): 657–660.
<a href="https://doi.org/10.1111/j.1365-3059.1992.tb02549.x">doi:10.1111/j.1365-3059.1992.tb02549.x</a>
</p>
<p>Madden LV, Hughes G, van den Bosch F. 2007. Spatial aspects of epidemics -
III: Patterns of plant disease. In: The study of plant disease epidemics,
235–278. American Phytopathological Society, St Paul, MN.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(magrittr)
my_data &lt;- do.call(c, lapply(citrus_ctv, function(citrus_field) {
   incidence(citrus_field) %&gt;%
       clump(unit_size = c(x = 3, y = 3)) %&gt;%
       split(by = "t")
}))
# my_data is a list of incidence object, each one corresponding to a given
# time at a given location.
my_power_law &lt;- power_law(my_data)
my_power_law
summary(my_power_law)
plot(my_power_law) # Same as: plot(my_power_law, scale = "log")
plot(my_power_law, scale = "lin")

</code></pre>

<hr>
<h2 id='pyrethrum_ray_blight'>Incidence of ray blight disease of pyrethrum.</h2><span id='topic+pyrethrum_ray_blight'></span>

<h3>Description</h3>

<p>An assessment of the incidence of ray blight disease of pyrethrum in 62
sampling units, containing 6 plants each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pyrethrum_ray_blight
</code></pre>


<h3>Format</h3>

<p>A data frame with 62 rows and 2 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1] </td><td style="text-align: left;"> i </td><td style="text-align: left;"> Number of diseased plants (from 0 to 6). </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 2] </td><td style="text-align: left;"> n </td><td style="text-align: left;"> Sampling unit size. Here, n = 6 plants per sampling
                      unit. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Pethybridge SJ, Esker P, Hay F, Wilson C, Nutter FW. 2005.
Spatiotemporal description of epidemics caused by Phoma ligulicola in
Tasmanian pyrethrum fields. <em>Phytopathology</em> 95, 648–658.
<a href="https://doi.org/10.1094/PHYTO-95-0648">doi:10.1094/PHYTO-95-0648</a>
</p>

<hr>
<h2 id='sadie'>Spatial Analysis by Distance IndicEs (SADIE).</h2><span id='topic+sadie'></span><span id='topic+sadie.data.frame'></span><span id='topic+sadie.matrix'></span><span id='topic+sadie.count'></span><span id='topic+sadie.incidence'></span>

<h3>Description</h3>

<p><code>sadie</code> performs the SADIE procedure. It computes different indices and
probabilities based on the distance to regularity for the observed spatial
pattern and a specified number of random permutations of this pattern. Both
kind of clustering indices described by Perry et al. (1999) and Li et al.
(2012) can be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sadie(data, ...)

## S3 method for class 'data.frame'
sadie(
  data,
  index = c("Perry", "Li-Madden-Xu", "all"),
  nperm = 100,
  seed = NULL,
  threads = 1,
  ...,
  method = "shortsimplex",
  verbose = TRUE
)

## S3 method for class 'matrix'
sadie(
  data,
  index = c("Perry", "Li-Madden-Xu", "all"),
  nperm = 100,
  seed = NULL,
  threads = 1,
  ...,
  method = "shortsimplex",
  verbose = TRUE
)

## S3 method for class 'count'
sadie(
  data,
  index = c("Perry", "Li-Madden-Xu", "all"),
  nperm = 100,
  seed = NULL,
  threads = 1,
  ...,
  method = "shortsimplex",
  verbose = TRUE
)

## S3 method for class 'incidence'
sadie(
  data,
  index = c("Perry", "Li-Madden-Xu", "all"),
  nperm = 100,
  seed = NULL,
  threads = 1,
  ...,
  method = "shortsimplex",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sadie_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix with only three columns: the two first
ones must be the x and y coordinates of the sampling units, and the last
one, the corresponding disease intensity observations. It can also be a
<code><a href="#topic+count">count</a></code> or an <code><a href="#topic+incidence">incidence</a></code> object.</p>
</td></tr>
<tr><td><code id="sadie_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
<tr><td><code id="sadie_+3A_index">index</code></td>
<td>
<p>The index to be calculated: &quot;Perry&quot;, &quot;Li-Madden-Xu&quot; or &quot;all&quot;.
By default, only Perry's index is computed for each sampling unit.</p>
</td></tr>
<tr><td><code id="sadie_+3A_nperm">nperm</code></td>
<td>
<p>Number of random permutations to assess probabilities.</p>
</td></tr>
<tr><td><code id="sadie_+3A_seed">seed</code></td>
<td>
<p>Fixed seed to be used for randomizations (only useful for
checking purposes). Not fixed by default (= NULL).</p>
</td></tr>
<tr><td><code id="sadie_+3A_threads">threads</code></td>
<td>
<p>Number of threads to perform the computations.</p>
</td></tr>
<tr><td><code id="sadie_+3A_method">method</code></td>
<td>
<p>Method for the transportation algorithm.</p>
</td></tr>
<tr><td><code id="sadie_+3A_verbose">verbose</code></td>
<td>
<p>Explain what is being done (TRUE by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By convention in the SADIE procedure, clustering indices for a donor unit
(outflow) and a receiver unit (inflow) are positive and negative in sign,
respectively.
</p>


<h3>Value</h3>

<p>A <code>sadie</code> object.
</p>


<h3>References</h3>

<p>Perry JN. 1995. Spatial analysis by distance indices. Journal of Animal
Ecology 64, 303–314. <a href="https://doi.org/10.2307/5892">doi:10.2307/5892</a>
</p>
<p>Perry JN, Winder L, Holland JM, Alston RD. 1999. Red–blue plots for detecting
clusters in count data. Ecology Letters 2, 106–113.
<a href="https://doi.org/10.1046/j.1461-0248.1999.22057.x">doi:10.1046/j.1461-0248.1999.22057.x</a>
</p>
<p>Li B, Madden LV, Xu X. 2012. Spatial analysis by distance indices: an
alternative local clustering index for studying spatial patterns. Methods in
Ecology and Evolution 3, 368–377.
<a href="https://doi.org/10.1111/j.2041-210X.2011.00165.x">doi:10.1111/j.2041-210X.2011.00165.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Create an intensity object:
my_count &lt;- count(aphids, mapping(x = xm, y = ym))
# Only compute Perry's indices:
my_res &lt;- sadie(my_count)
my_res
summary(my_res)
plot(my_res)
plot(my_res, isoclines = TRUE)

set.seed(123)
# Compute both Perry's and Li-Madden-Xu's indices (using multithreading):
my_res &lt;- sadie(my_count, index = "all", threads = 2, nperm = 20)
my_res
summary(my_res)
plot(my_res) # Identical to: plot(my_res, index = "Perry")
plot(my_res, index = "Li-Madden-Xu")

set.seed(123)
# Using usual data frames instead of intensity objects:
my_df &lt;- aphids[, c("xm", "ym", "i")]
sadie(my_df)

</code></pre>

<hr>
<h2 id='simulated_epidemics'>Examples of simulated epidemic data.</h2><span id='topic+simulated_epidemics'></span>

<h3>Description</h3>

<p>Epidemics were generated using the stochastic simulator from Xu and Madden
(2004). The data consist of the numbers of diseased plants per sampling
unit (out of a total of n = 100 plants in each sampling unit). N = 144
sampling units, and different values for the parameters <code>pattern</code> and
<code>mu</code> were used for the simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulated_epidemics
</code></pre>


<h3>Format</h3>

<p>A data frame with 864 rows and 6 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1]   </td><td style="text-align: left;"> pattern </td><td style="text-align: left;"> Either clumped (i.e. aggregated), random or
                              regular. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 2]   </td><td style="text-align: left;"> mu      </td><td style="text-align: left;"> Median spore dispersal parameter. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 3:4] </td><td style="text-align: left;"> x,y     </td><td style="text-align: left;"> Grid spatial coordinates. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 5]   </td><td style="text-align: left;"> i       </td><td style="text-align: left;"> Number of diseased plants (from 0 to 100). </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 6]   </td><td style="text-align: left;"> n       </td><td style="text-align: left;"> Sampling unit size. Here, n = 100 plants per
                              sampling unit. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Xu XM, Madden LV. 2004. Use of SADIE statistics to study spatial
dynamics of plant disease epidemics. Plant Pathology 53, 38–49.
<a href="https://doi.org/10.1111/j.1365-3059.2004.00949.x">doi:10.1111/j.1365-3059.2004.00949.x</a>
</p>

<hr>
<h2 id='smle'>Simple maximum likelihood estimation</h2><span id='topic+smle'></span><span id='topic+smle.default'></span><span id='topic+smle.intensity'></span>

<h3>Description</h3>

<p>By default, this function performs a maximum likelihood estimation for one or
several parameters, but it can be used for any other optimization problems.
The interface is intented to be rather simple while allowing more advanced
parametrizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smle(data, ...)

## Default S3 method:
smle(data, f, param_init, max = TRUE, ...)

## S3 method for class 'intensity'
smle(data, f, param_init, max = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smle_+3A_data">data</code></td>
<td>
<p>The data set to work with. It can be a vector (if there is only
one variable), a data frame (if there is one or more variables) or an
<code><a href="#topic+intensity">intensity</a></code> object.</p>
</td></tr>
<tr><td><code id="smle_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="smle_+3A_f">f</code></td>
<td>
<p>A function to be maximized, typically a log-likelihood function.
This function must have only two arguments: <code>data</code> and <code>param</code>,
which must correspond to the <code>data</code> argument of <code>smle</code> and a
named vector of the parameter(s) to be estimated.</p>
</td></tr>
<tr><td><code id="smle_+3A_param_init">param_init</code></td>
<td>
<p>Either a named vector with proposed initial values of the
parameter(s), or a function that returns such a vector. This parameter
is not needed if the parameter <code>param</code> of <code>f</code> is already
provided with such a named vector.</p>
</td></tr>
<tr><td><code id="smle_+3A_max">max</code></td>
<td>
<p>Does <code>f</code> need to be maximized? Set to <code>FALSE</code> to require
a minimization of <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="stats.html#topic+optim">optim</a></code> tool does the hard work under the hood. Extra
arguments (e.g. method of optimization to be used) can be passed to
<code><a href="stats.html#topic+optim">optim</a></code> through the <code>...</code> argument. Note that
contrary to the default <code><a href="stats.html#topic+optim">optim</a></code> arguments, <code>smle</code>
tries to solve a maximization problem using the method &quot;L-BFGS-B&quot; by default
(see <code><a href="stats.html#topic+optim">optim</a></code> documentation for more information).
</p>


<h3>Value</h3>

<p>An object of class <code>smle</code>, which is a list containing the following
components:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>call</code>                    </td><td style="text-align: left;"> The call. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>coef</code>                    </td><td style="text-align: left;"> The estimated coefficients. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>coef_se</code>                 </td><td style="text-align: left;"> The standard errors of the estimated coefficients. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>vcov</code>                    </td><td style="text-align: left;"> The variance-covariance matrix of the estimated coefficients. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>data</code>                    </td><td style="text-align: left;"> The <code>data</code> parameter. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>f</code>                       </td><td style="text-align: left;"> The <code>f</code> parameter. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>nobs</code>                    </td><td style="text-align: left;"> The number of observations. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>full_input, full_output</code> </td><td style="text-align: left;"> The full input and output of the <code>optim</code> function. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
data &lt;- rlogis(100, location = 5, scale = 2)
ll_logis &lt;- function(data, param = c(location = 0, scale = 1)) {
    sum(dlogis(x = data, location = param[["location"]],
               scale = param[["scale"]], log = TRUE))
}
res &lt;- smle(data, ll_logis)
res
summary(res)

# Using the magrittr syntax:
require(magrittr)
data %&gt;% smle(ll_logis)

# Comparision with the output of fitdistr (MASS package), which works for a
# limited number of predefined distributions:
require(MASS)
fitdistr(data, "logistic")

# Example with an intensity object:
require(magrittr)
require(dplyr)
data &lt;- tomato_tswv$field_1929 %&gt;%
    filter(t == 1) %&gt;%
    incidence() %&gt;%
    clump(unit_size = c(x = 3, y = 3))
ll_betabinom &lt;- function(data, param) {
    sum(dbetabinom(x = data[["i"]], size = data[["n"]],
                   prob = param[["prob"]], theta = param[["theta"]],
                   log = TRUE))
}
epsilon &lt;- 1e-7
res &lt;- smle(data, ll_betabinom, param_init = c(prob = 0.5, theta = 0.5),
            lower = c(prob  = 0 + epsilon,
                      theta = 0 + epsilon),
            upper = c(prob = 1 - epsilon,
                      theta = Inf))
res
summary(res)

param_init &lt;- data.frame(lower = c(0 + epsilon, 0 + epsilon),
                         start = c(0.5, 0.5),
                         upper = c(1 - epsilon, Inf))
rownames(param_init) &lt;- c("prob", "theta")
res &lt;- smle(data, ll_betabinom, param_init)
res
summary(res)

</code></pre>

<hr>
<h2 id='smle_wrappers'>Wrappers using maximum likelihood estimation for some distributions</h2><span id='topic+smle_wrappers'></span><span id='topic+smle_pois'></span><span id='topic+smle_nbinom'></span><span id='topic+smle_binom'></span><span id='topic+smle_betabinom'></span>

<h3>Description</h3>

<p>These functions are the core of the fitting processes performed in
<code><a href="#topic+fit_two_distr">fit_two_distr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smle_pois(data)

smle_nbinom(data)

smle_binom(data)

smle_betabinom(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smle_wrappers_+3A_data">data</code></td>
<td>
<p>The data set to work with. It can be a vector (if there is only
one variable), a data frame (if there is one or more variables) or an
<code><a href="#topic+intensity">intensity</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="#topic+smle">smle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
data &lt;- rpois(100, lambda = 5)
res &lt;- smle_pois(data)
res
summary(res)

data &lt;- count(aphids)
res &lt;- smle_pois(data)
res
summary(res)

</code></pre>

<hr>
<h2 id='spatial_hier'>Spatial hierarchy analysis.</h2><span id='topic+spatial_hier'></span>

<h3>Description</h3>

<p>The manner in which the data are collected provides information about
aggregation of disease at different levels in a spatial hierarchy (Hughes et
al. 1997). For example, a sampling unit (upper level) can be reported as
&quot;healthy&quot;, if no diseased leaves (lower level) were found within the sampling
unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_hier(low, high)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial_hier_+3A_low">low</code></td>
<td>
<p>An list of <code>intensity</code> objects.</p>
</td></tr>
<tr><td><code id="spatial_hier_+3A_high">high</code></td>
<td>
<p>An list of <code>intensity</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a pairwise comparison between levels, the probability that an individual
at the lower hierarchical level is diseased is denoted plow, and phigh refers
to the probability of disease at the higher level. The relationship between
these two probabilities can be written as
</p>
<p>phigh = 1 - (1 - plow)^nu
</p>
<p>where n is a parameter ranging from 0 to the corresponding number of
individuals at the hierarchical level referenced by plow. If the value of n
is equal to the number of individuals at the lower hierarchical level
contained in a unit of the higher level (n low ), this suggests that there is
no aggregation of disease incidence at the lower level. Conversely, a value
of n less than n low is indicative of aggregation at that level. The value of
n can be interpreted as an effective sample size (Hughes and Gottwald 1999;
Madden and Hughes 1999) in the statistical sense that its value indicates the
number of independent pieces of information at the lower level. Here, the
effective sample size concerns the equating of the zero-term of the binomial
distribution with the zero-term of an overdispersed distribution, as
described in Madden and Hughes (1999). Using the complementary log-log
transformation, CLL(x) = ln(-ln(1-x)), one can rewrite the Equation 5 as
follows (Madden et al. 2007):
</p>
<p>CLL(phigh) = ln(nu) + CLL(plow)
</p>
<p>from which the value of ln(n) can be obtained as the intercept of a linear
regression when the slope is constrained to 1.
</p>


<h3>Value</h3>

<p>A <code>spatial_hier</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_data_low &lt;- incidence(tomato_tswv$field_1929)
my_data_low &lt;- clump(my_data_low, c(x = 3, y = 3))
my_data_high &lt;- my_data_low
my_data_high$data$n &lt;- 1
my_data_high$data$i &lt;- ifelse(my_data_high$data$i &gt; 0, 1, 0)
my_data_low  &lt;- split(my_data_low, by = "t")
my_data_high &lt;- split(my_data_high, by = "t")
res &lt;- spatial_hier(my_data_low, my_data_high)

res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='split.intensity'>Divide into groups and reassemble.</h2><span id='topic+split.intensity'></span>

<h3>Description</h3>

<p>Divide into groups and reassemble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intensity'
split(x, f, drop = FALSE, ..., by, unit_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split.intensity_+3A_x">x</code></td>
<td>
<p>vector or data frame containing values to be divided into groups.</p>
</td></tr>
<tr><td><code id="split.intensity_+3A_f">f</code></td>
<td>
<p>a &lsquo;factor&rsquo; in the sense that <code><a href="base.html#topic+as.factor">as.factor</a>(f)</code>
defines the grouping, or a list of such factors in which case their
interaction is used for the grouping. If <code>x</code> is a data frame,
<code>f</code> can also be a formula of the form <code> ~ g</code> to split by
the variable <code>g</code>, or more generally of the form <code> ~ g1 +
      ... + gk</code> to split by the interaction of the variables
<code>g1</code>, ..., <code>gk</code>, where these variables are evaluated in
the data frame <code>x</code> using the usual non-standard evaluation
rules.</p>
</td></tr>
<tr><td><code id="split.intensity_+3A_drop">drop</code></td>
<td>
<p>logical indicating if levels that do not occur should be dropped
(if <code>f</code> is a <code>factor</code> or a list).</p>
</td></tr>
<tr><td><code id="split.intensity_+3A_...">...</code></td>
<td>
<p>further potential arguments passed to methods.</p>
</td></tr>
<tr><td><code id="split.intensity_+3A_by">by</code></td>
<td>
<p>The name(s) of the variable(s) which define(s) the grouping.</p>
</td></tr>
<tr><td><code id="split.intensity_+3A_unit_size">unit_size</code></td>
<td>
<p>Size of a group unit. It must be a named vector, with names
corresponding to non-observational variables (i.e. space and time
variables). If the size of a variable in the data set is not a multiple
of the provided value in <code>unit_size</code>, some sampling units (the last
ones) will be dropped so that clumps of individuals remain even
throughout the data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="#topic+intensity">intensity</a></code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_incidence &lt;- incidence(tomato_tswv$field_1929)
plot(my_incidence, type = "all")
my_incidence_spl1 &lt;- split(my_incidence, by = "t")
my_incidence_spl2 &lt;- split(my_incidence, unit_size = c(x = 8, y = 20, t = 1))

</code></pre>

<hr>
<h2 id='threshold'>To go to higher level in the hierarchy.</h2><span id='topic+threshold'></span>

<h3>Description</h3>

<p>This function transforms the current numeric vector or <code>intensity</code> data
set into a &quot;simplified black and white image&quot; of this same data set: every
value of disease intensity below and above a given threshold is given the
value 0 and 1, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(data, value, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold_+3A_data">data</code></td>
<td>
<p>A numeric vector or an <code><a href="#topic+intensity">intensity</a></code> object.</p>
</td></tr>
<tr><td><code id="threshold_+3A_value">value</code></td>
<td>
<p>All the intensity values lower or equal to this value  are set
to 0. The other values are set to 1.</p>
</td></tr>
<tr><td><code id="threshold_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, everything above 0 is given 1, and 0 stays at 0. <code>threshold</code>
is thus useful to report a whole sampling unit as &quot;healthy&quot; (0), if no
diseased individual at all was found within the sampling unit, or &quot;diseased&quot;
(1) if at least one diseased individual was found.
</p>


<h3>Value</h3>

<p>A numeric vector or an <code><a href="#topic+intensity">intensity</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_incidence &lt;- incidence(tomato_tswv$field_1929)
plot(my_incidence, type = "all")
my_incidence_clumped_1 &lt;- clump(my_incidence, unit_size = c(x = 3, y = 3))
plot(my_incidence_clumped_1, type = "all")
my_incidence_thr &lt;- threshold(my_incidence_clumped_1, value = 4)
plot(my_incidence_thr, type = "all")

</code></pre>

<hr>
<h2 id='tobacco_viruses'>Incidence of tobacco plants infected with viruses.</h2><span id='topic+tobacco_viruses'></span>

<h3>Description</h3>

<p>Experimental plot consisted of 75 sampling units with 40 tobacco plants in
each one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tobacco_viruses
</code></pre>


<h3>Format</h3>

<p>A data frame with 75 rows and 2 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1] </td><td style="text-align: left;"> i </td><td style="text-align: left;"> Number of diseased plants (from 0 to 40). </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 2] </td><td style="text-align: left;"> n </td><td style="text-align: left;"> Sampling unit size. Here, n = 40 plants per sampling
                      unit. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Madden LV, Pirone TP, Raccah B. 1987. Analysis of spatial patterns of
virus-diseased tobacco plants. Phytopathology 77, 1409–1417.
</p>

<hr>
<h2 id='tomato_tswv'>Incidence of tomato spotted wilt virus (TSWV) disease in field trials.</h2><span id='topic+tomato_tswv'></span>

<h3>Description</h3>

<p>Intensively mapped TSWV incidence data reported by Cochran (1936) and Bald
(1937). The disease assessments were performed in field trials at the Waite
Institute (Australia) in 1928 and 1929. TSWV is a virus disease spread by
thrips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tomato_tswv
</code></pre>


<h3>Format</h3>

<p>There are two data frames:
</p>
<p><code>field_1928</code>: A data frame with 11088 rows and 8 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1]   </td><td style="text-align: left;"> plot       </td><td style="text-align: left;"> Plot id. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 2]   </td><td style="text-align: left;"> variety    </td><td style="text-align: left;"> Variety name. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 3]   </td><td style="text-align: left;"> irrigation </td><td style="text-align: left;"> Irrigation system. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 4:5] </td><td style="text-align: left;"> x,y        </td><td style="text-align: left;"> Grid spatial coordinates. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 6]   </td><td style="text-align: left;"> t          </td><td style="text-align: left;"> Date of disease assessments. 1: 6 Nov, 2: 14
                                 Nov, 3: 21 Nov, 4: 28-29 Nov, 5: 5 Dec, 6:
                                 12 Dec 1928. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 7]   </td><td style="text-align: left;"> i          </td><td style="text-align: left;"> Disease incidence. 0: Healthy, 1: Diseased. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 8]   </td><td style="text-align: left;"> n          </td><td style="text-align: left;"> Sampling unit size. n = 1 means that the
                                 sampling unit size is the plant. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><code>field_1929</code>: A data frame with 4320 rows and 5 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
    [, 1:2] </td><td style="text-align: left;"> x,y </td><td style="text-align: left;"> Grid spatial coordinates. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 3]   </td><td style="text-align: left;"> t   </td><td style="text-align: left;"> Date of disease assessments. 1: 18 Dec, 2: 31 Dec
                          1929, 3: 22 Jan 1930. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 4]   </td><td style="text-align: left;"> i   </td><td style="text-align: left;"> Disease incidence. 0: Healthy, 1: Diseased. </td>
</tr>
<tr>
 <td style="text-align: right;">
    [, 5]   </td><td style="text-align: left;"> n   </td><td style="text-align: left;"> Sampling unit size. n = 1 means that the sampling
                          unit size is the plant. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>The data set <code>field_1928</code>, reported by Bald (1937), was a set of four
plots. Each plot consisted of 14 rows containing 33 plants each, so that
there were 462 plants in each plot. The tomato variety Early Dwarf Red was
used in two plots, and the variety Burwood Prize in the other two. The
tomatoes were planted out on 15th October 1928. The two plots dedicated to a
given variety experienced different irrigation practices, using either
overhead sprays or trenches. Otherwise, all were treated alike. Weekly
records of TSWV incidence were performed from 6th November to 12th December.
</p>
<p>The data set <code>field_1929</code>, reported by Cochran (1936), was a field of 24
rows containing 60 plants each, so that there were 1440 plants. The tomatoes
were planted out in 26th November 1929. TSWV incidence records made on 18th
December 1929, 31st December 1929 and 22nd January 1930 are reported in this
data set.
</p>


<h3>Source</h3>

<p>Cochran WG. 1936. The statistical analysis of field counts of
diseased plants. Supplement to the Journal of the Royal Statistical
Society 3, 49–67. <a href="https://doi.org/10.2307/2983677">doi:10.2307/2983677</a>
</p>
<p>Bald JG. 1937. Investigations on &quot;spotted wilt&quot; of tomatoes. III.
Infection in field plots. Bulletin 106. Melbourne, Australia: Council for
Scientific and Industrial Research.
</p>

<hr>
<h2 id='vcov.smle'>Calculate Variance-Covariance Matrix for a Fitted Model Object</h2><span id='topic+vcov.smle'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the main parameters of
a fitted model object.  The &ldquo;main&rdquo; parameters of model
correspond to those returned by <code><a href="stats.html#topic+coef">coef</a></code>, and typically do
not contain a nuisance scale parameter (<code><a href="stats.html#topic+sigma">sigma</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smle'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.smle_+3A_object">object</code></td>
<td>

<p>a fitted model object, typically.  Sometimes also a
<code><a href="base.html#topic+summary">summary</a>()</code> object of such a fitted model.
</p>
</td></tr>
<tr><td><code id="vcov.smle_+3A_...">...</code></td>
<td>

<p>additional arguments for method functions.  For the
<code><a href="stats.html#topic+glm">glm</a></code> method this can be used to pass a
<code>dispersion</code> parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the estimated covariances between the parameter estimates
in the linear or non-linear predictor of the model.  This should have
row and column names corresponding to the parameter names given by the
<code><a href="stats.html#topic+coef">coef</a></code> method.
</p>
<p>When some coefficients of the (linear) model are undetermined and
hence <code>NA</code> because of linearly dependent terms (or an
&ldquo;over specified&rdquo; model), also called
&ldquo;aliased&rdquo;, see <code><a href="stats.html#topic+alias">alias</a></code>, then since <span class="rlang"><b>R</b></span> version 3.5.0,
<code>vcov()</code> (iff <code>complete = TRUE</code>, i.e., by default for
<code>lm</code> etc, but not for <code>aov</code>) contains corresponding rows and
columns of <code>NA</code>s, wherever <code><a href="stats.html#topic+coef">coef</a>()</code> has always
contained such <code>NA</code>s.
</p>

<hr>
<h2 id='z.test'>Z-test.</h2><span id='topic+z.test'></span><span id='topic+z.test.default'></span><span id='topic+z.test.fisher'></span>

<h3>Description</h3>

<p>Performs z-tests for Fisher's aggregation indices (computed with either count
or incidence data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z.test(x, ...)

## Default S3 method:
z.test(x, ...)

## S3 method for class 'fisher'
z.test(
  x,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z.test_+3A_x">x</code></td>
<td>
<p>The output of the <code><a href="#topic+agg_index">agg_index</a></code> function with
<code>method = "fisher"</code> as parameter.</p>
</td></tr>
<tr><td><code id="z.test_+3A_...">...</code></td>
<td>
<p>Not yet implemented.</p>
</td></tr>
<tr><td><code id="z.test_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.
It must be one of &quot;two.sided&quot; (default), &quot;less&quot; or &quot;greater&quot;.</p>
</td></tr>
<tr><td><code id="z.test_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level of the interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two-sided tests with a confidence level of 95
the spatial pattern would be random. If z &lt; -1.96 or z &gt; 1.96, it would be
uniform or aggregated, respectively.
</p>


<h3>Value</h3>

<p>Same kind of object as the one returns by the stats
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code> function for example.
</p>


<h3>References</h3>

<p>For count and incidence data:
</p>
<p>Moradi-Vajargah M, Golizadeh A, Rafiee-Dastjerdi H, Zalucki MP, Hassanpour M,
Naseri B. 2011. Population density and spatial distribution pattern of Hypera
postica (Coleoptera: Curculionidae) in Ardabil, Iran. Notulae Botanicae Horti
Agrobotanici Cluj-Napoca, 39(2): 42-48.
</p>
<p>Sun P, Madden LV. 1997. Using a normal approximation to test for the binomial
distribution. Biometrical journal, 39(5): 533-544.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calpha.test">calpha.test</a></code>, <code><a href="#topic+chisq.test">chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For incidence data:
my_incidence &lt;- incidence(tobacco_viruses)
my_fisher &lt;- agg_index(my_incidence, method = "fisher")
z.test(my_fisher)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
