<!DOCTYPE html><html lang="en"><head><title>Help for package gtexture</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gtexture}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#autocorrelation'><p>Autocorrelation Metric for a GLCM or GLCM equivalent matrix</p></a></li>
<li><a href='#cluster_prom'><p>Cluster Prominence Metric for a GLCM</p></a></li>
<li><a href='#cluster_shade'><p>Cluster Shade Metric for a GLCM</p></a></li>
<li><a href='#comat'><p>Calculate Co-Occurrence Matrix</p></a></li>
<li><a href='#compute_all_metrics'><p>Convenience function to compute all haralick texture features</p></a></li>
<li><a href='#contrast'><p>Contrast Metric for a GLCM</p></a></li>
<li><a href='#correlation'><p>Correlation Metric for a GLCM</p></a></li>
<li><a href='#differenceEntropy.matrix'><p>Difference entropy is the entropy of marginal distribution of the</p>
difference in gray-level value equivalents x-y</a></li>
<li><a href='#discretize'><p>Discretize Numeric Variable Into Categories</p></a></li>
<li><a href='#dissimilarity.matrix'><p>Dissimilarity of a co-occurrence matrix</p></a></li>
<li><a href='#energy'><p>Energy Metric for a GLCM</p></a></li>
<li><a href='#entropy'><p>Entropy Metric for a GLCM</p></a></li>
<li><a href='#equal_discrete'><p>Function Factory for Even Discretization Functions</p></a></li>
<li><a href='#euclidean'><p>Euclidean Distance Function Factory</p></a></li>
<li><a href='#glcm_marginals'><p>Marginal distributions of the GLCM</p></a></li>
<li><a href='#glcm_statistics'><p>Statistics of GLCM</p></a></li>
<li><a href='#homogeneity'><p>Homogeneity Metric for a GLCM</p></a></li>
<li><a href='#inv_diff'><p>Inverse Difference Metric for a GLCM</p></a></li>
<li><a href='#kmeans_discrete'><p>Kmeans clustering discretization</p></a></li>
<li><a href='#manhattan'><p>Manhattan Distance Function Factory</p></a></li>
<li><a href='#max_prob'><p>Maximum Probability Metric for a GLCM</p></a></li>
<li><a href='#normalize_glcm'><p>Normalize a GLCM</p></a></li>
<li><a href='#quantile_discrete'><p>Function to discretize based on quantiles</p></a></li>
<li><a href='#sum_squares'><p>Sum of Squares Metric for a GLCM</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Generalized Application of Co-Occurrence Matrices and Haralick
Texture</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Generalizes application of gray-level co-occurrence matrix
    (GLCM) metrics to objects outside of images. The current focus is to
    apply GLCM metrics to the study of biological networks and fitness
    landscapes that are used in studying evolutionary medicine and
    biology, particularly the evolution of cancer resistance. The package was
    developed as part of the author's publication in Physics in Medicine and Biology
    Barker-Clarke et al. (2023) &lt;<a href="https://doi.org/10.1088%2F1361-6560%2Face305">doi:10.1088/1361-6560/ace305</a>&gt;. 
    A general reference to learn more about mathematical oncology can be found at
    Rockne et al. (2019) &lt;<a href="https://doi.org/10.1088%2F1478-3975%2Fab1a09">doi:10.1088/1478-3975/ab1a09</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://rbarkerclarke.github.io/gtexture/&amp;gt;">https://rbarkerclarke.github.io/gtexture/&gt;</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rbarkerclarke/gtexture/issues">https://github.com/rbarkerclarke/gtexture/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dlookr, dplyr (&ge; 1.0), fitscape (&ge; 0.1), igraph, magrittr
(&ge; 2.0), rlang, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stats, testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-08 03:55:44 UTC; stephbc</td>
</tr>
<tr>
<td>Author:</td>
<td>Rowan Barker-Clarke
    <a href="https://orcid.org/0000-0003-1961-7919"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Raoul Wadhwa <a href="https://orcid.org/0000-0003-0503-9580"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Davis Weaver [aut],
  Jacob Scott <a href="https://orcid.org/0000-0003-2971-7673"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rowan Barker-Clarke &lt;rowanbarkerclarke@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-08 15:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='autocorrelation'>Autocorrelation Metric for a GLCM or GLCM equivalent matrix</h2><span id='topic+autocorrelation'></span><span id='topic+autocorrelation.default'></span><span id='topic+autocorrelation.matrix'></span><span id='topic+autocorrelation.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the autocorrelation feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorrelation(x, ...)

## Default S3 method:
autocorrelation(x, ...)

## S3 method for class 'matrix'
autocorrelation(x, ...)

## S3 method for class 'FitLandDF'
autocorrelation(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autocorrelation_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="autocorrelation_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="autocorrelation_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate autocorrelation of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate autocorrelation
autocorrelation(n_x)

## calculate autocorrelation of arbitrary fitness landscape
# create fitness landscape using FitLandDF object
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

# calculate autocorrelation of fitness landscape, assuming 2 discrete gray levels
autocorrelation(my_landscape, nlevels = 2)

## confirm value of autocorrelation for fitness landscape
# extract normalized GLCM from fitness landscape
my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))

# calculate autocorrelation of extracted GLCM
autocorrelation(my_glcm)  # should match value of above autocorrelation function call
</code></pre>

<hr>
<h2 id='cluster_prom'>Cluster Prominence Metric for a GLCM</h2><span id='topic+cluster_prom'></span><span id='topic+cluster_prom.default'></span><span id='topic+cluster_prom.matrix'></span><span id='topic+cluster_prom.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the cluster prominence feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_prom(x, ...)

## Default S3 method:
cluster_prom(x, ...)

## S3 method for class 'matrix'
cluster_prom(x, ...)

## S3 method for class 'FitLandDF'
cluster_prom(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_prom_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="cluster_prom_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="cluster_prom_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate cluster prominence of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate cluster prominence
cluster_prom(n_x)

## calculate cluster prominence of arbitrary fitness landscape
# create fitness landscape using FitLandDF object
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

# calculate cluster prominence of fitness landscape, assuming 2 discrete gray levels
cluster_prom(my_landscape, nlevels = 2)

## confirm value of cluster prominence for fitness landscape
# extract normalized GLCM from fitness landscape
my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))

# calculate cluster prominence of extracted GLCM
cluster_prom(my_glcm)  # should match value of above cluster_prom function call
</code></pre>

<hr>
<h2 id='cluster_shade'>Cluster Shade Metric for a GLCM</h2><span id='topic+cluster_shade'></span><span id='topic+cluster_shade.default'></span><span id='topic+cluster_shade.matrix'></span><span id='topic+cluster_shade.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the cluster shade feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_shade(x, ...)

## Default S3 method:
cluster_shade(x, ...)

## S3 method for class 'matrix'
cluster_shade(x, ...)

## S3 method for class 'FitLandDF'
cluster_shade(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_shade_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="cluster_shade_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="cluster_shade_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate cluster shade of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate cluster shade
cluster_shade(n_x)

## calculate cluster shade of arbitrary fitness landscape
# create fitness landscape using FitLandDF object
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

# calculate cluster shade of fitness landscape, assuming 2 discrete gray levels
cluster_shade(my_landscape, nlevels = 2)

## confirm value of cluster shade for fitness landscape
# extract normalized GLCM from fitness landscape
my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))

# calculate cluster shade of extracted GLCM
cluster_shade(my_glcm)  # should match value of above cluster_shade function call
</code></pre>

<hr>
<h2 id='comat'>Calculate Co-Occurrence Matrix</h2><span id='topic+comat'></span><span id='topic+get_comatrix'></span><span id='topic+get_comatrix.default'></span><span id='topic+get_comatrix.FitLandDF'></span><span id='topic+get_comatrix.igraph'></span>

<h3>Description</h3>

<p>Calculate generalized co-occurrence matrix from a variety of objects,
currently including fitness landscapes stored as a <code>FitLandDF</code> instance from
the <code>fitscape</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_comatrix(x, ...)

## Default S3 method:
get_comatrix(x, ...)

## S3 method for class 'FitLandDF'
get_comatrix(
  x,
  discrete = equal_discrete(2),
  neighbor = manhattan(1),
  normalize = normalize_glcm,
  ...
)

## S3 method for class 'igraph'
get_comatrix(
  x,
  values,
  nlevels = length(unique(values)),
  normalize = normalize_glcm,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comat_+3A_x">x</code></td>
<td>
<p>object upon which co-occurrence matrix will be calculated</p>
</td></tr>
<tr><td><code id="comat_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="comat_+3A_discrete">discrete</code></td>
<td>
<p>function that discretizes object</p>
</td></tr>
<tr><td><code id="comat_+3A_neighbor">neighbor</code></td>
<td>
<p>function that returns TRUE if two numeric vectors are within
acceptable distance of one another or a single-element <code>character</code> vector
that describes how to identify acceptable neighbors/offsets</p>
</td></tr>
<tr><td><code id="comat_+3A_normalize">normalize</code></td>
<td>
<p>function that normalizes the co-occurrence matrix</p>
</td></tr>
<tr><td><code id="comat_+3A_values">values</code></td>
<td>
<p>named numeric with values corresponding to the nodes in x.</p>
</td></tr>
<tr><td><code id="comat_+3A_nlevels">nlevels</code></td>
<td>
<p>int number of levels to discretize into</p>
</td></tr>
<tr><td><code id="comat_+3A_verbose">verbose</code></td>
<td>
<p>bool</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (co-occurrence matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create fitness landscape as instance of FitLandDF object
a &lt;- round(runif(64))
a &lt;- array(a, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(a)

# calculate co-occurrence matrix using:
#   Manhattan distance of 1
#   discretization into 2 equal-sized buckets
#   normalization: multiply all elements so that sum of matrix equals unity
comat &lt;- get_comatrix(my_landscape,
                      discrete = equal_discrete(2),
                      neighbor = manhattan(1))

# print co-occurrence matrix
print(comat)

</code></pre>

<hr>
<h2 id='compute_all_metrics'>Convenience function to compute all haralick texture features</h2><span id='topic+compute_all_metrics'></span>

<h3>Description</h3>

<p>Calculate set of the following Haralick texture features; contrast, entropy, energy,
autocorrelation, correlation, cluster prominence, cluster shade, homogeneity,
inverse difference, max probability, and sum of squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_all_metrics(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_all_metrics_+3A_x">x</code></td>
<td>
<p>Input glcm matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with 11 columns
</p>

<hr>
<h2 id='contrast'>Contrast Metric for a GLCM</h2><span id='topic+contrast'></span><span id='topic+contrast.default'></span><span id='topic+contrast.matrix'></span><span id='topic+contrast.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the contrast feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contrast(x, ...)

## Default S3 method:
contrast(x, ...)

## S3 method for class 'matrix'
contrast(x, ...)

## S3 method for class 'FitLandDF'
contrast(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contrast_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="contrast_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="contrast_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate contrast of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate contrast
contrast(n_x)

# calculate contrast of fitness landscape, assuming 2 discrete gray levels
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))
contrast(my_landscape, nlevels = 2)

## confirm value of contrast for fitness landscape
# extract normalized GLCM from fitness landscape

contrast(my_glcm)  # should match value of above contrast function call
</code></pre>

<hr>
<h2 id='correlation'>Correlation Metric for a GLCM</h2><span id='topic+correlation'></span><span id='topic+correlation.default'></span><span id='topic+correlation.matrix'></span><span id='topic+correlation.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the correlation feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation(x, ...)

## Default S3 method:
correlation(x, ...)

## S3 method for class 'matrix'
correlation(x, ...)

## S3 method for class 'FitLandDF'
correlation(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correlation_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="correlation_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="correlation_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate correlation of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate correlation
correlation(n_x)

## calculate autocorrelation of arbitrary fitness landscape
# create fitness landscape using FitLandDF object
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

# calculate correlation of fitness landscape, assuming 2 discrete gray levels
correlation(my_landscape, nlevels = 2)

## confirm value of correlation for fitness landscape
# extract normalized GLCM from fitness landscape
my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))

# calculate correlation of extracted GLCM
correlation(my_glcm)  # should match value of above correlation function call
</code></pre>

<hr>
<h2 id='differenceEntropy.matrix'>Difference entropy is the entropy of marginal distribution of the
difference in gray-level value equivalents x-y</h2><span id='topic+differenceEntropy.matrix'></span>

<h3>Description</h3>

<p>Difference entropy is the entropy of marginal distribution of the
difference in gray-level value equivalents x-y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>differenceEntropy.matrix(glcm, base = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="differenceEntropy.matrix_+3A_glcm">glcm</code></td>
<td>
<p>gray level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="differenceEntropy.matrix_+3A_base">base</code></td>
<td>
<p>Base of the logarithm in differenceEntropy.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>float (single value: the entropy of the marginal distribution)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate difference entropy of a given glcm (e.g. uniform matrix)
differenceEntropy.matrix(matrix(1,3,3))

</code></pre>

<hr>
<h2 id='discretize'>Discretize Numeric Variable Into Categories</h2><span id='topic+discretize'></span><span id='topic+discretize.numeric'></span><span id='topic+discretize.list'></span><span id='topic+discretize.integer'></span><span id='topic+discretize.FitLandDF'></span>

<h3>Description</h3>

<p>Takes a numeric variable (could be of class <code>numeric</code> or <code>integer</code>) and
returns a discretized version, in which each element has been replaced by a
single integer between <code>1</code> and <code>nlevels</code>, inclusive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize(x, ...)

## S3 method for class 'numeric'
discretize(x, nlevels, method = "equal", ...)

## S3 method for class 'list'
discretize(x, nlevels, ...)

## S3 method for class 'integer'
discretize(x, nlevels, ...)

## S3 method for class 'FitLandDF'
discretize(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discretize_+3A_x">x</code></td>
<td>
<p>either a vector (<code>numeric</code> or <code>integer</code>) or <code>FitLandDF</code> object</p>
</td></tr>
<tr><td><code id="discretize_+3A_...">...</code></td>
<td>
<p>potential additional arguments, currently unnecessary</p>
</td></tr>
<tr><td><code id="discretize_+3A_nlevels">nlevels</code></td>
<td>
<p>positive integer indicating number of discrete categories</p>
</td></tr>
<tr><td><code id="discretize_+3A_method">method</code></td>
<td>
<p>method by which to discretize; split into equal sections by
default (<code>"equal"</code> value for parameter)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>discretized form of <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## discretize a numeric vector
vec &lt;- 1:10
discretize(vec, nlevels = 5) # discretize into 5 categories
discretize(vec, 2)           # discretize into 2 categories

## discretize a fitness landscape
# create a 3x3x3 fitness landscape with values 1 through 27
fl_data &lt;- array(1:27, dim = rep(3, 3))
my_fl &lt;- fitscape::FitLandDF(fl_data)
discretize(my_fl, nlevels = 2) # discretize landscape into 2 categories
discretize(my_fl, 5)           # discretize landscape into 5 categories
</code></pre>

<hr>
<h2 id='dissimilarity.matrix'>Dissimilarity of a co-occurrence matrix</h2><span id='topic+dissimilarity.matrix'></span>

<h3>Description</h3>

<p>Dissimilarity is the weighted sum of all of the absolute differences in the gray-levels assigned
to neighboring nodes across the network or graph. For example, a diagonal matrix would represent
only identical neighbors and no dissimilarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissimilarity.matrix(glcm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dissimilarity.matrix_+3A_glcm">glcm</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>int or double (the weighted sum of differences)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate dissimilarity of a 2x2 uniform matrix
dissimilarity.matrix(matrix(1,2,2))

# Calculate dissimilarity of a diagonal matrix
dissimilarity.matrix(diag(1,5,5))

# Calculate dissimilarity of a sequential matrix
dissimilarity.matrix(matrix(1:16,4,4))

</code></pre>

<hr>
<h2 id='energy'>Energy Metric for a GLCM</h2><span id='topic+energy'></span><span id='topic+energy.default'></span><span id='topic+energy.matrix'></span><span id='topic+energy.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the energy feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>energy(x, ...)

## Default S3 method:
energy(x, ...)

## S3 method for class 'matrix'
energy(x, ...)

## S3 method for class 'FitLandDF'
energy(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="energy_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="energy_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="energy_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate energy of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate energy
energy(n_x)

## calculate energy of arbitrary fitness landscape
# create fitness landscape using FitLandDF object
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

# calculate energy of fitness landscape, assuming 2 discrete gray levels
energy(my_landscape, nlevels = 2)

## confirm value of energy for fitness landscape
# extract normalized GLCM from fitness landscape
my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))

# calculate energy of extracted GLCM
energy(my_glcm)  # should match value of above energy function call
</code></pre>

<hr>
<h2 id='entropy'>Entropy Metric for a GLCM</h2><span id='topic+entropy'></span><span id='topic+entropy.default'></span><span id='topic+entropy.matrix'></span><span id='topic+entropy.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the entropy feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(x, ...)

## Default S3 method:
entropy(x, ...)

## S3 method for class 'matrix'
entropy(x, ...)

## S3 method for class 'FitLandDF'
entropy(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="entropy_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="entropy_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="entropy_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate entropy of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate entropy
entropy(n_x)

## calculate entropy of arbitrary fitness landscape
# create fitness landscape using FitLandDF object
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

# calculate entropy of fitness landscape, assuming 2 discrete gray levels
entropy(my_landscape, nlevels = 2)

## confirm value of entropy for fitness landscape
# extract normalized GLCM from fitness landscape
my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))

# calculate entropy of extracted GLCM
entropy(my_glcm)  # should match value of above entropy function call
</code></pre>

<hr>
<h2 id='equal_discrete'>Function Factory for Even Discretization Functions</h2><span id='topic+equal_discrete'></span>

<h3>Description</h3>

<p>Returns a function that converts a continuous numeric vector into an integer
vector with discrete levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equal_discrete(nlevels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="equal_discrete_+3A_nlevels">nlevels</code></td>
<td>
<p>number of levels to split continuous vector into</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function that makes a numeric vector discrete
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test data
x &lt;- 1:10

# create and apply function to split x into 2 discrete levels
split_2 &lt;- equal_discrete(2)
split_2(x)

# create and apply function to split x into 5 discrete levels
split_5 &lt;- equal_discrete(5)
split_5(x)
</code></pre>

<hr>
<h2 id='euclidean'>Euclidean Distance Function Factory</h2><span id='topic+euclidean'></span>

<h3>Description</h3>

<p>Returns a function that checks whether the Euclidean distance between two
numeric vectors is less than or equal to a given threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean(dist = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euclidean_+3A_dist">dist</code></td>
<td>
<p>threshold above which the function will return <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>function that checks if Euclidean distance between two vectors
exceeds <code>dist</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test data: Euclidean distance equals sqrt(2) ~ 1.414
x &lt;- rep(0, 5)
y &lt;- c(0, 1, 0, 0, 1)

# should return TRUE when checking Manhattan distance &lt;= 2
dist_2 &lt;- euclidean(2)
dist_2(x, y)

# should return FALSE when checking Manhattan distance &lt;= 1
dist_1 &lt;- euclidean(1)
dist_1(x, y)

</code></pre>

<hr>
<h2 id='glcm_marginals'>Marginal distributions of the GLCM</h2><span id='topic+glcm_marginals'></span><span id='topic+xplusy_k'></span><span id='topic+xminusy_k'></span>

<h3>Description</h3>

<p>Functions for the calculation of marginal distributions from the GLCM matrix.
</p>
<p>The partial sum of the matrix is used to determine the distribution over
the sum of neighbor pairs, returns a value for a given sum k.
</p>
<p>The partial sum of the matrix is used to determine the distribution over
the sum of neighbor pairs, returns a value for a given difference of k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xplusy_k(glcm, k)

xminusy_k(glcm, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcm_marginals_+3A_glcm">glcm</code></td>
<td>
<p>square co-occurrence matrix</p>
</td></tr>
<tr><td><code id="glcm_marginals_+3A_k">k</code></td>
<td>
<p>real integer (given difference)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>int or double (xplusy_k: sum of matrix entries with given index sum)
</p>
<p>int or double (sum of matrix entries with given index difference)
</p>

<hr>
<h2 id='glcm_statistics'>Statistics of GLCM</h2><span id='topic+glcm_statistics'></span><span id='topic+glcm_mean'></span><span id='topic+mu_x.matrix'></span><span id='topic+mu_y.matrix'></span><span id='topic+glcm_variance'></span>

<h3>Description</h3>

<p>Functions for the calculation of summary statistics upon the GLCM matrix.
</p>
<p>glcm_mean: GLCM mean of a symmetric GLCM matrix.
The GLCM Mean is not simply the average of all the original node values
in the network/graph. It is expressed in terms of the GLCM. The node
value is weighted not by its frequency of occurrence by itself (as in a
&quot;regular&quot; or familiar mean but by its frequency of its occurrence in
combination with a certain neighbour node value; see
<a href="https://prism.ucalgary.ca/server/api/core/bitstreams/8f9de234-cc94-401d-b701-f08ceee6cfdf/content">https://prism.ucalgary.ca/server/api/core/bitstreams/8f9de234-cc94-401d-b701-f08ceee6cfdf/content</a>
</p>
<p>glcm_variance: The variance of the GLCM values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glcm_mean(glcm)

mu_x.matrix(glcm)

mu_y.matrix(glcm)

glcm_variance(glcm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glcm_statistics_+3A_glcm">glcm</code></td>
<td>
<p>gray level co-occurrence matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>int or double (glcm_mean: single value, mean of symmetric glcm)
</p>
<p>int or double (mu_x: weighted mean of reference node values)
</p>
<p>int or double (mu_y: weighted mean of neighbor node values)
</p>
<p>int or double (glcm_variance: glcm variance)
</p>

<hr>
<h2 id='homogeneity'>Homogeneity Metric for a GLCM</h2><span id='topic+homogeneity'></span><span id='topic+homogeneity.default'></span><span id='topic+homogeneity.matrix'></span><span id='topic+homogeneity.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the homogeneity feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homogeneity(x, ...)

## Default S3 method:
homogeneity(x, ...)

## S3 method for class 'matrix'
homogeneity(x, ...)

## S3 method for class 'FitLandDF'
homogeneity(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="homogeneity_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="homogeneity_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="homogeneity_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate homogeneity of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate homogeneity
homogeneity(n_x)

## calculate homogeneity of arbitrary fitness landscape
# create fitness landscape using FitLandDF object
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

# calculate homogeneity of fitness landscape, assuming 2 discrete gray levels
homogeneity(my_landscape, nlevels = 2)

## confirm value of homogeneity for fitness landscape
# extract normalized GLCM from fitness landscape
my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))

# calculate homogeneity of extracted GLCM
homogeneity(my_glcm)  # should match value of above homogeneity function call
</code></pre>

<hr>
<h2 id='inv_diff'>Inverse Difference Metric for a GLCM</h2><span id='topic+inv_diff'></span><span id='topic+inv_diff.default'></span><span id='topic+inv_diff.matrix'></span><span id='topic+inv_diff.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the inverse difference feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_diff(x, ...)

## Default S3 method:
inv_diff(x, ...)

## S3 method for class 'matrix'
inv_diff(x, ...)

## S3 method for class 'FitLandDF'
inv_diff(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv_diff_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="inv_diff_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="inv_diff_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate inverse difference of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate inverse difference
inv_diff(n_x)

## calculate inverse difference of arbitrary fitness landscape
# create fitness landscape using FitLandDF object
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

# calculate inverse difference of fitness landscape, assuming 2 discrete gray levels
inv_diff(my_landscape, nlevels = 2)

## confirm value of inverse difference for fitness landscape
# extract normalized GLCM from fitness landscape
my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))

# calculate inverse difference of extracted GLCM
inv_diff(my_glcm)  # should match value of above inv_diff function call
</code></pre>

<hr>
<h2 id='kmeans_discrete'>Kmeans clustering discretization</h2><span id='topic+kmeans_discrete'></span>

<h3>Description</h3>

<p>Splitting of a vector of continuous values into k groups
using kmeans. Used to discretize node labels/weights of a fitness landscape
or node-weighted graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeans_discrete(nlevels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmeans_discrete_+3A_nlevels">nlevels</code></td>
<td>
<p>number of levels to split continuous vector into</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function that makes a numeric vector discrete
</p>

<hr>
<h2 id='manhattan'>Manhattan Distance Function Factory</h2><span id='topic+manhattan'></span>

<h3>Description</h3>

<p>Returns a function that checks whether the Manhattan distance between two
numeric vectors is less than or equal to a given threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattan(dist = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manhattan_+3A_dist">dist</code></td>
<td>
<p>threshold above which the function will return <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>function that checks if Manhattan distance between two vectors
exceeds <code>dist</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test data: Manhattan distance equals 2
x &lt;- rep(0, 5)
y &lt;- c(0, 1, 0, 0, 1)

# should return TRUE when checking Manhattan distance &lt;= 3
dist_3 &lt;- manhattan(3)
dist_3(x, y)

# should return FALSE when checking Manhattan distance &lt;= 1
dist_1 &lt;- manhattan(1)
dist_1(x, y)

</code></pre>

<hr>
<h2 id='max_prob'>Maximum Probability Metric for a GLCM</h2><span id='topic+max_prob'></span><span id='topic+max_prob.default'></span><span id='topic+max_prob.matrix'></span><span id='topic+max_prob.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the maximum probability feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_prob(x, ...)

## Default S3 method:
max_prob(x, ...)

## S3 method for class 'matrix'
max_prob(x, ...)

## S3 method for class 'FitLandDF'
max_prob(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_prob_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="max_prob_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="max_prob_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate maximum probability of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate maximum probability
max_prob(n_x)

## calculate maximum probability of arbitrary fitness landscape
# create fitness landscape using FitLandDF object
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

# calculate maximum probability of fitness landscape, assuming 2 discrete gray levels
max_prob(my_landscape, nlevels = 2)

## confirm value of maximum probability for fitness landscape
# extract normalized GLCM from fitness landscape
my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))

# calculate maximum probability of extracted GLCM
max_prob(my_glcm)  # should match value of above max_prob function call
</code></pre>

<hr>
<h2 id='normalize_glcm'>Normalize a GLCM</h2><span id='topic+normalize_glcm'></span>

<h3>Description</h3>

<p>Function that normalizes a gray-level co-occurrence matrix (GLCM) so that the
sum of all the elements equals unity. This has the added benefit of
converting the GLCM to a probability distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_glcm(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_glcm_+3A_mat">mat</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix (same dimensions as input GLCM)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># normalize an arbitrary matrix
a &lt;- matrix(1:9, nrow = 3)
n_a &lt;- normalize_glcm(a)

print(a)
print(n_a)
</code></pre>

<hr>
<h2 id='quantile_discrete'>Function to discretize based on quantiles</h2><span id='topic+quantile_discrete'></span>

<h3>Description</h3>

<p>Function to discretize based on quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_discrete(nlevels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile_discrete_+3A_nlevels">nlevels</code></td>
<td>
<p>number of levels to split continuous vector into</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function that makes a numeric vector discrete
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test data
</code></pre>

<hr>
<h2 id='sum_squares'>Sum of Squares Metric for a GLCM</h2><span id='topic+sum_squares'></span><span id='topic+sum_squares.default'></span><span id='topic+sum_squares.matrix'></span><span id='topic+sum_squares.FitLandDF'></span>

<h3>Description</h3>

<p>Calculate the sum of squares feature or metric for a gray-level co-occurrence
matrix. For definition and application, see Lofstedt et al. (2019)
<a href="https://doi.org/10.1371/journal.pone.0212110">doi:10.1371/journal.pone.0212110</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_squares(x, ...)

## Default S3 method:
sum_squares(x, ...)

## S3 method for class 'matrix'
sum_squares(x, ...)

## S3 method for class 'FitLandDF'
sum_squares(x, nlevels, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum_squares_+3A_x">x</code></td>
<td>
<p>gray-level co-occurrence matrix</p>
</td></tr>
<tr><td><code id="sum_squares_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="sum_squares_+3A_nlevels">nlevels</code></td>
<td>
<p>desired number of discrete gray levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>double
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## calculate sum of squares of arbitrary GLCM
# define arbitrary GLCM
x &lt;- matrix(1:16, nrow = 4)

# normalize
n_x &lt;- normalize_glcm(x)

# calculate sum of squares
sum_squares(n_x)

## calculate sum of squares of arbitrary fitness landscape
# create fitness landscape using FitLandDF object
vals &lt;- runif(64)
vals &lt;- array(vals, dim = rep(4, 3))
my_landscape &lt;- fitscape::FitLandDF(vals)

# calculate sum of squares of fitness landscape, assuming 2 discrete gray levels
sum_squares(my_landscape, nlevels = 2)

## confirm value of sum of squares for fitness landscape
# extract normalized GLCM from fitness landscape
my_glcm &lt;- get_comatrix(my_landscape, discrete = equal_discrete(2))

# calculate sum of squares of extracted GLCM
sum_squares(my_glcm)  # should match value of above sum_squares function call
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
