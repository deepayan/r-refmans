<!DOCTYPE html><html><head><title>Help for package MultiPhen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MultiPhen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mPhen'>
<p>A function for the genetic association testing of multiple phenotypes</p></a></li>
<li><a href='#mPhen.assoc'>
<p>A function for the genetic association testing of multiple phenotypes</p></a></li>
<li><a href='#mPhen.cca'><p>Sparse canonical correlation analysis</p></a></li>
<li><a href='#mPhen.defineOptions'><p>Defines and modifies  options.</p></a></li>
<li><a href='#mPhen.options'><p>Retrieves default mPhen options, and descriptions.</p></a></li>
<li><a href='#mPhen.plotCorrelation'><p>Plots correlation between phenotype values conditional on genotype</p></a></li>
<li><a href='#mPhen.preparePheno'><p>Prepare phenotype data for analysis</p></a></li>
<li><a href='#mPhen.readGenotypes'><p>Open, and read from a read connection to a genotype file</p></a></li>
<li><a href='#mPhen.readPhenoFiles'><p>Read and merge phenotype files</p></a></li>
<li><a href='#mPhen.sampleCovar'><p>Generates a covariance matrix.</p></a></li>
<li><a href='#mPhen.sampleGeno'><p>Sample genotypes</p></a></li>
<li><a href='#mPhen.simulate'><p>Simulates phenotypes according to a correlation structure.</p></a></li>
<li><a href='#mPhen.writeOutput'><p>Prepares output files and plots from MultiPhen results</p></a></li>
<li><a href='#MultiPhen-internal'><p>Internal MultiPhen objects</p></a></li>
<li><a href='#MultiPhen-package'>
<p>MultiPhen, a package for the genetic association testing of multiple phenotypes</p></a></li>
<li><a href='#pheno'>
<p>A dummy phenotype dataset that provides an example of the input phenotype data used by the package</p></a></li>
<li><a href='#read.plink'>
<p>A function to read (small) binary PLINK binary files in a R session</p></a></li>
<li><a href='#snps'>
<p>A dummy snp dataset that provides an example of the input snp data used by the package</p></a></li>
<li><a href='#snps.imputed'>
<p>Imputed SNP dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Package to Test for Multi-Trait Association</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Lachlan Coin, Paul O'Reilly, Yotsawat Pompyen, Clive Hoggart
        and Federico Calboli</td>
</tr>
<tr>
<td>Depends:</td>
<td>MASS, abind, epitools, meta</td>
</tr>
<tr>
<td>Imports:</td>
<td>HardyWeinberg, RColorBrewer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lachlan Coin &lt;l.coin@imb.uq.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs genetic association tests between SNPs
        (one-at-a-time) and multiple phenotypes (separately or in joint
        model).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-09 12:36:27 UTC; lcoin</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-09 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mPhen'>
A function for the genetic association testing of multiple phenotypes
</h2><span id='topic+mPhen'></span>

<h3>Description</h3>

<p>mPhen performs association testing between genetic variants (SNPs; CNVs) and multiple phenotypes. The primary purpose is for modelling and testing multiple phenotypes jointly by performing an ordinal regression where SNPs are treated as the outcome and multiple phenotypes are predictors; this can have large increases in statistical power to detect genotype-phenotype associations over the univariate approach (method described in O'Reilly et al. 2012, see below). However, mPhen can also be used to perform standard univariate linear regression (SNP as predictor) and univariate ordinal regression (SNP as outcome) on the phenotypes under study. mPhen can be applied to directly genotyped or imputed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen(genoData, phenoData, phenotypes = "all",
      covariates = NULL, resids = NULL, strats = NULL, 
      opts = mPhen.options(c("regression","pheno.input")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen_+3A_genodata">genoData</code></td>
<td>

<p>Either a matrix (for directly measured genotypes) or 3 dimensional array (for imputed genotypes). The first dimension (rows) corresponds to individuals, and row.names are inidividual IDs. The second dimension corresponds to SNPS, with col.names equal to the snp identifiers. For directly measured genotypes, the value in each cell is a numeric genotype( i.e. AA = 0, AB=1, BB = 2).  For imputed genotypes, the 3rd dimension corresponds to genotypes (with dimnames(genoData)[[3]]) equal to a numeric vector corresponding to genotype values. The values in these cells are the probability of each genotype multiplied by 1000.  For copy number genotypes the numeric values correspond to numbers of copies.  An example provided by 'snps' and 'snps.imputed'
</p>
</td></tr>
<tr><td><code id="mPhen_+3A_phenodata">phenoData</code></td>
<td>

<p>Matrix containing phenotype data, where each row corresponds to an individual and row.names are individual IDs. Each column contains data on a certain phenotype across the sample of individuals (can be quantitative, case/control or ordinal. Must be numeric); the column header provides the phenotype name. An example is provided by 'pheno'. 
</p>
</td></tr>
<tr><td><code id="mPhen_+3A_phenotypes">phenotypes</code></td>
<td>

<p>Vector of phenotype names, to be tested.  If value is 'all' then all phenotypes are included after removing covariates and residuals.
</p>
</td></tr>
<tr><td><code id="mPhen_+3A_covariates">covariates</code></td>
<td>

<p>Vector of phenotypes, from phenoData, to be considered as covariates to be controlled for in the regression (Default is no covariates).
</p>
</td></tr>
<tr><td><code id="mPhen_+3A_resids">resids</code></td>
<td>

<p>Vector of residuals, from phenoData, alternative way to adjust for covariates, which pre-calculates offset terms to use in the per SNP regression (Default is no residuals).
</p>
</td></tr>
<tr><td><code id="mPhen_+3A_strats">strats</code></td>
<td>

<p>Statification vector (i.e. cases/controls, exposed/not exposed, male/female etc), from phenoData (Default is no stratification).
</p>
</td></tr>



<tr><td><code id="mPhen_+3A_opts">opts</code></td>
<td>
<p>A list of options, which is obtained from mPhen.options(c(&quot;regression&quot;,&quot;pheno.input&quot;)).  To get more information about these options, type 
mPhen.options(c(&quot;regression&quot;,&quot;pheno.input&quot;),descr=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with two items.  The first item (Results) is a  Results is a 4 dimensional matrix, with
dimensions [strata, snps, phenotypes, result_type], where result_type includes beta, pvalue and Nobs.  The second item is a vector of minor allele frequencies.
</p>


<h3>Note</h3>

<p>The user should remember that the genotype data file is always a matrix of at least a column, hence if taking a subset of 1 SNP in the non-imputed genotype data matrix, the option drop = FALSE should be used (see the example below)
</p>


<h3>Author(s)</h3>

<p>Lachlan Coin, Federico Calboli, Clive Hoggart, Paul O'Reilly, Yotsawat Pomyen.
</p>
<p>Maintainer, Federico Calboli <a href="mailto:f.calboli@imperial.ac.uk">f.calboli@imperial.ac.uk</a> 
</p>


<h3>References</h3>

<p>O'Reilly et al. 2012. MultiPhen: Joint model of multiple phenotypes can increase discovery in GWAS. http://dx.plos.org/10.1371/journal.pone.0034861</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(snps); data(snps.imputed); data(pheno)
opts = mPhen.options(c("regression","pheno.input"))
res = mPhen(snps, pheno, phenotypes = "all",
      covariates = c('testPheno3', 'testPheno4'),opts = opts) 
# performs a MultiPhen analysis, with snp as outcome,
# and phenotypes testPheno1, testPheno2 as predictors, 
#with testPheno3 and testPheno4 as covariates using ordinal regression

res = mPhen(snps, pheno, phenotypes = c('testPheno1', 'testPheno2'), 
      covariates = c('testPheno3', 'testPheno4'), resids = 'testPheno5', opts = opts) 
# the same as above, with the fifth phenotype as residual 

res = mPhen(snps[,2, drop = FALSE], pheno, phenotypes = c('testPheno1', 'testPheno2'), 
      covariates = 'testPheno3',  opts = opts) 
# please note the use use of drop = FALSE if analysing only one SNP


res = mPhen(snps.imputed, pheno, phenotypes = c('testPheno1', 'testPheno2'), 
      covariates = 'testPheno3',  opts = opts) 
# for imputed data
</code></pre>

<hr>
<h2 id='mPhen.assoc'>
A function for the genetic association testing of multiple phenotypes
</h2><span id='topic+mPhen.assoc'></span><span id='topic+mPhen.assoc'></span>

<h3>Description</h3>

<p>This function is called by mPhen.  If you are doing association on multiple batches 
of genotype data, it is more efficient to use this function, and to pre-prepare a 'phenoObject' object once and then use this function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.assoc(genoData, phenoObject,opts = mPhen.options("regression"),
		 subinds =1:(dim(genoData)[1]))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.assoc_+3A_phenoobject">phenoObject</code></td>
<td>

<p>A phenotype object prepared by mPhen.preparePheno
</p>
</td></tr>
<tr><td><code id="mPhen.assoc_+3A_genodata">genoData</code></td>
<td>

<p>This can be obtained from mPhen.readGenoConnection(...)$genoData.
It is either a matrix (for directly measured genotypes) or 3 dimensional array (for imputed genotypes). The first dimension (rows) corresponds to individuals, and row.names are inidividual IDs. The second dimension corresponds to SNPS, with col.names equal to the snp identifiers. For directly measured genotypes, the value in each cell is a numeric genotype( i.e. AA = 0, AB=1, BB = 2).  For imputed genotypes, the 3rd dimension corresponds to genotypes (with dimnames(genoData)[[3]]) equal to a numeric vector corresponding to genotype values. The values in these cells are the probability of each genotype multiplied by 1000.  For copy number genotypes the numeric values correspond to numbers of copies.  An example provided by 'snps'.</p>
</td></tr>
<tr><td><code id="mPhen.assoc_+3A_opts">opts</code></td>
<td>
<p>A list of options, which is obtained from mPhen.options(&quot;regression&quot;).  To get more information about these options, type 
mPhen.options(&quot;regression&quot;,descr=TRUE)</p>
</td></tr>
<tr><td><code id="mPhen.assoc_+3A_subinds">subinds</code></td>
<td>
<p>This indicates the indices of individuals to include in the analysis. It is possible to have repeat indices (i.e. for bootstrap)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with two items.  The first item (Results) is a  Results is a 4 dimensional matrix, with
dimensions [strata, snps, phenotypes, result_type], where result_type includes beta, pvalue and Nobs.  The second item is a vector of minor allele frequencies.  
</p>

<hr>
<h2 id='mPhen.cca'>Sparse canonical correlation analysis</h2><span id='topic+mPhen.cca'></span>

<h3>Description</h3>

<p>Carries out a sparse canonical correlation analysis</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.cca(genoData, phenoObject, opts =mPhen.options("regression"), 
		         subinds = 1:(dim(genoData)[1]),
		vs.G = opts$mPhen.variable.selection,
                 vs.P = opts$mPhen.variable.selection
)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.cca_+3A_genodata">genoData</code></td>
<td>
<p>A 2 dimensional array. The first dimension (rows) corresponds to individuals, and row.names are inidividual IDs. The second dimension corresponds to SNPS, with col.names equal to the snp identifiers. The entries are either genotypes, or expected genotypes.</p>
</td></tr>
<tr><td><code id="mPhen.cca_+3A_phenoobject">phenoObject</code></td>
<td>
<p>A phenotype object prepared by mPhen.preparePheno.</p>
</td></tr>
<tr><td><code id="mPhen.cca_+3A_opts">opts</code></td>
<td>
<p>A list of options, which is obtained from mPhen.options(&quot;regression&quot;).  To get more information about these options, type 
mPhen.options(&quot;regression&quot;,descr=TRUE).  </p>
</td></tr>
<tr><td><code id="mPhen.cca_+3A_vs.g">vs.G</code></td>
<td>
<p>If true performs variable selection on genotypes.  Is equal to  opts$mPhen.variable_selection by default</p>
</td></tr>
<tr><td><code id="mPhen.cca_+3A_vs.p">vs.P</code></td>
<td>
<p>If true performs variable selection on phenotypes.  Is equal to  opts$mPhen.variable_selection by default</p>
</td></tr>
<tr><td><code id="mPhen.cca_+3A_subinds">subinds</code></td>
<td>
<p>This indicates the indices of individuals to include in the analysis. It is possible to have repeat indices (i.e. for bootstrap)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following elements
</p>
<table>
<tr><td><code>betasp</code></td>
<td>
<p>Phenotype weights</p>
</td></tr>
<tr><td><code>betasg</code></td>
<td>
<p>Genotype weights</p>
</td></tr>
<tr><td><code>resultsGeno</code></td>
<td>
<p>Single (combined) phenotype analysis results against all genotypes</p>
</td></tr>
<tr><td><code>resultsPheno</code></td>
<td>
<p>Multiple phenotype analysis results against single (combined) genotype</p>
</td></tr>
</table>

<hr>
<h2 id='mPhen.defineOptions'>Defines and modifies  options. </h2><span id='topic+mPhen.defineOptions'></span>

<h3>Description</h3>

<p> This reads options from the command-line, if provided.  Also it can replace references to system variables in option values, such as '*' or \$WORK, with fully qualified values.  Also translates coordinates which use Gb, Mb, Kb to integer values.  All defined options of the form mPhen.xxx are examined and modified.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.defineOptions(file = NULL, getOptionsFromCommandLine = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.defineOptions_+3A_file">file</code></td>
<td>
<p>specified if the options are in a script file and not set manually</p>
</td></tr>
<tr><td><code id="mPhen.defineOptions_+3A_getoptionsfromcommandline">getOptionsFromCommandLine</code></td>
<td>
<p>If running from a script using command Rscript, then this will read in command line options, such as \'&ndash;mPhen.logp=FALSE\'</p>
</td></tr>

</table>


<h3>Value</h3>

<p>None</p>

<hr>
<h2 id='mPhen.options'>Retrieves default mPhen options, and descriptions.</h2><span id='topic+mPhen.options'></span>

<h3>Description</h3>

<p> This command is used to get options which can be modified to control the behaviour of MultiPhen commands.
It provides a list of options which are relevant to a particular command.  For example, mPhen.assoc() has its behavioiur controlled by options
in mPhen.options(&quot;regression&quot;).  In order to get a list of all options, you can type mPhen.options(descr=TRUE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.options(type=c("regression", "plot", "geno.input",
"pheno.input","meta.analysis","misc"), descr = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.options_+3A_type">type</code></td>
<td>
<p>A value which can take any of the following values: &quot;regression&quot;, &quot;plot&quot;,&quot;geno.input&quot;,&quot;pheno.input&quot;,&quot;meta.analysis&quot;,&quot;misc&quot;.</p>
</td></tr>
<tr><td><code id="mPhen.options_+3A_descr">descr</code></td>
<td>
<p>If set to TRUE, then returns descriptions of all the options.  If FALSE, then returns the values of all the options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of default option values.  Note, the default value for opts = mPhen.options(&quot;regression&quot;), has opts$inverseRegress =TRUE, opts$JointModel = TRUE and opts$geno.link = &quot;ordinal&quot;, which is the standard multiPhen model. </p>

<hr>
<h2 id='mPhen.plotCorrelation'>Plots correlation between phenotype values conditional on genotype</h2><span id='topic+mPhen.plotCorrelation'></span>

<h3>Description</h3>

<p>Plots the corrleation between phenotype values, with different genotypes coloured differently.  Note that this will plot (dim(pheno_to_plot)[2] -1 )* dim(geno)[2] plots</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.plotCorrelation(pheno_to_plot,geno,title="",cex=0.25, cols =c(1, 2, 3))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.plotCorrelation_+3A_pheno_to_plot">pheno_to_plot</code></td>
<td>
<p>the phenotype to plot</p>
</td></tr>
<tr><td><code id="mPhen.plotCorrelation_+3A_geno">geno</code></td>
<td>
<p>Genotypes to use for stratifying samples</p>
</td></tr>
<tr><td><code id="mPhen.plotCorrelation_+3A_title">title</code></td>
<td>
<p>Title of plots</p>
</td></tr>
<tr><td><code id="mPhen.plotCorrelation_+3A_cex">cex</code></td>
<td>
<p>Scaling of points</p>
</td></tr>
<tr><td><code id="mPhen.plotCorrelation_+3A_cols">cols</code></td>
<td>
<p>thre colours to be used in the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None</p>

<hr>
<h2 id='mPhen.preparePheno'>Prepare phenotype data for analysis</h2><span id='topic+mPhen.preparePheno'></span>

<h3>Description</h3>

<p>This harmonises the phenotype data with genotype data, and
also extract the relevant columns from a larger phenotype matrix, and also pre-calculates stratification indices and residuals.  This is called by mPhen function, but quicker to do this just once for batched genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.preparePheno(phenoData,
pcs = NULL, indiv = if (is.null(pcs)) rownames(phenoData) else rownames(pcs), 
    opts = mPhen.options("regression"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.preparePheno_+3A_phenodata">phenoData</code></td>
<td>

<p>This is typically the output of mPhen.readPhenoFiles(...) or mPhen.simulate(...). It is a list containing the elements phenoData$pheno and phenoData$limit.  The element phenoData$pheno is a matrix containing phenotype data, where each row corresponds to an individual and row.names are individual IDs. Each column contains data on a certain phenotype across the sample of individuals (can be quantitative, case/control or ordinal. Must be numeric); the column header provides the phenotype name. An example is provided by 'pheno'.   The element phenoData$limit is a list which specifies which of the phenotypes to use as covariates, variables to associate, etc, in the following way:
</p>
<p>limit$phenotypes - vector of phenotypes to be tested. If set to 'all' then all phenotypes are used.
limit$covariates - vector of phenotypes to be considered as covariates to be controlled for in the regression ,
limit$resids - vector of phenotypes to be considered as residuals, which is an alternative way to adjust for covariates, which pre-calculates offset terms to use in the per SNP regression 
limit$strats - statification vector (i.e. cases/controls, exposed/not exposed, male/female etc).
limit$excls - Exclusion vector, ie.  names of phenotypes which should be used as  exclusion criteria respectively.  Rows will be excluded if the value in any of exclusion columns is NA or 1
</p>
<p>Alternatively, phenoData can simply be a matrix containing phenotype data, in which case, the default value of limit used is limit = list(phenotypes=&quot;all&quot;)
</p>
</td></tr>
<tr><td><code id="mPhen.preparePheno_+3A_pcs">pcs</code></td>
<td>
<p>This is the genotype pcs which should be used in the analysis.  If specified it should be in the same sample order as 'inidv'.  The user still needs to specify in the phenoData$limit$covariate or phenoData$limit$resids the names of the PCs they wish to include (i.e. covariate = c(&quot;PC1&quot;,&quot;PC2&quot;)).  These would typically be obtained from mPhen.readGenotypes.</p>
</td></tr>
<tr><td><code id="mPhen.preparePheno_+3A_indiv">indiv</code></td>
<td>
<p>individuals to be used.  If unspecified the fucntion defaults to using all individuals</p>
</td></tr>  
<tr><td><code id="mPhen.preparePheno_+3A_opts">opts</code></td>
<td>
<p>A list of options, which is obtained from mPhen.options(&quot;regression&quot;).  To get more information about these options, type 
mPhen.options(&quot;regression&quot;,descr=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, which can then be used in mPhen.assoc.</p>

<hr>
<h2 id='mPhen.readGenotypes'>Open, and read from a read connection to a genotype file</h2><span id='topic+mPhen.readGenotypes'></span>

<h3>Description</h3>

<p>Opens a read connection to a list of files which have a VCF-like format. Can read a .gz file. Also supports
plink bed format. Also supports cnvPipe format.  Also supports a .zip file format used by cnvHap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.readGenotypes(genoConnection, indiv = NULL,opts =mPhen.options("geno.input" ))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.readGenotypes_+3A_genoconnection">genoConnection</code></td>
<td>

<p>A list of paths to genotype files.  Each file might represent a different cohort with overlapping snp set. 
These files can be .vcf .vcf.gz and .zip files.  They can also be plink bed files.  In the case that bed files are used, the root name of the file should be given (i.e. hapmap2 instead of hapmap2.bed).
</p>
<p>Alternatively, this can also be the object returned by  mPhen.readGenotypes(...).  This means that the connection only has to be established once, and can be read from multiple times in batches.
</p>
</td></tr>
<tr><td><code id="mPhen.readGenotypes_+3A_indiv">indiv</code></td>
<td>
<p>A list of individual ids.  If provided the results will be in this order.  If not provided the results will be in the order given by the genotype file</p>
</td></tr>
<tr><td><code id="mPhen.readGenotypes_+3A_opts">opts</code></td>
<td>
<p>A list of options, which is obtained from mPhen.options(&quot;geno.input&quot;).  To get more information about these options, type 
mPhen.options(&quot;geno.input&quot;,descr=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list object which can be used by subsequent calls to readGenotypes(..).  This list also includes a value genoData, which contains the genotypes which have been read.  This  includes a connection to the underlying file (conn), a list of sample ids, and a flag indicating whether the file is zipped.  It also includes 'pcs', which is a matrix of genotype pcs.  These are only calculated is opts$mPhen.numGenoPCs&gt;0, and are only calculated once all batches have been read (but will include all genotypes which have been read previously using the same connection).</p>

<hr>
<h2 id='mPhen.readPhenoFiles'>Read and merge phenotype files</h2><span id='topic+mPhen.readPhenoFiles'></span>

<h3>Description</h3>

<p>This helper function merges multiple phenotype files into a single phenotype matrix, and applies missing value and exclusion criteria</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.readPhenoFiles(phenoFiles,
	limitFile = getOption("mPhen.limitFile","./limit.txt"),
	 excludeFile =getOption("mPhen.excludeFile","./exclude.txt"),	
		opts = mPhen.options("pheno.input"),
		indiv = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.readPhenoFiles_+3A_phenofiles">phenoFiles</code></td>
<td>
<p>A list of paths to phenotype files (can be more than 1)</p>
</td></tr>
<tr><td><code id="mPhen.readPhenoFiles_+3A_excludefile">excludeFile</code></td>
<td>
<p> A path to a file which lists ids to exclude from further analysis, or
alternatively is a two column file, with the first column of ids and a second column
of numberical values which are used in conjunction with opts$quantileThresh</p>
</td></tr>
<tr><td><code id="mPhen.readPhenoFiles_+3A_limitfile">limitFile</code></td>
<td>

<p>As an alternative to specifying covariates, resids,strats and excl in mPhen.preparePheno(..), you can also specify this information via a limitfile, which is tab delimited file in which the first column specifies the type of variable to set (pheno,covar,resid,strat,excl), the second 
column specifies the phenotype name, and the third column optionally specifies a transformation
Different lines can then be used for different values.  
The transformation syntax includes 'quantile' and 'factor', and also 'thresh_x_y' in which values less than x are coded 0 and greater than y are coded 1; and also 'toptail_x_y' where values less than x percentile are coded 0 and greater than y percentile are coded 1.
</p>
</td></tr>
<tr><td><code id="mPhen.readPhenoFiles_+3A_opts">opts</code></td>
<td>
<p>A list of options, which is obtained from mPhen.options(&quot;pheno.input&quot;).  To get more information about these options, type 
mPhen.options(&quot;pheno.input&quot;,descr=TRUE)</p>
</td></tr>
<tr><td><code id="mPhen.readPhenoFiles_+3A_indiv">indiv</code></td>
<td>
<p>A list of individual ids. If provided the phenotype matrix will be re-ordered to match</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object consisting of a  single merged phenotype matrix, and also a 'limit' object which specifies phenotypes to include in analyses.  The limit is a list with the following entries.
phenotypes - vector of phenotypes to be tested. If set to 'all' then all phenotypes are used.
covariates - vector of phenotypes to be considered as covariates to be controlled for in the regression ,
resids - vector of phenotypes to be considered as residuals, which is an alternative way to adjust for covariates, which pre-calculates offset terms to use in the per SNP regression 
strats - statification vector (i.e. cases/controls, exposed/not exposed, male/female etc).
</p>
<p>excls - Exclusion vector, ie.  names of phenotypes which should be used as  exclusion criteria respectively.  Rows will be excluded if the value in any of exclusion columns is NA or 1
</p>

<hr>
<h2 id='mPhen.sampleCovar'>Generates a covariance matrix.</h2><span id='topic+mPhen.sampleCovar'></span>

<h3>Description</h3>

<p>This function can be use to sample covariance matrices.  This is useful when simulating data to test Multiphenotype based association strategies. This function lets the user decide on the orthoganality within 'blocks' and between 'blocks' of correlated variables/</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.sampleCovar(noPhenos,blockSize, orthogAll = c(0.9,0.5),
dirichletScale = 50,  resample = FALSE, 
sd = rgamma(noPhenos,shape=10,rate = 10))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.sampleCovar_+3A_nophenos">noPhenos</code></td>
<td>
<p>The number of phenotypes to simulate</p>
</td></tr>
<tr><td><code id="mPhen.sampleCovar_+3A_blocksize">blockSize</code></td>
<td>
<p>The number of phenotypes per covariance block</p>
</td></tr>
<tr><td><code id="mPhen.sampleCovar_+3A_orthogall">orthogAll</code></td>
<td>
<p>The orthogonality relationships between and within blocks expressed as a number on the interval (0,1).  A number closer to one indicates closer to orthogonality, whereas 0 indicates non-orthogonality.  First number is orthogonality between blocks, second is orthogonality within blocks.</p>
</td></tr>
<tr><td><code id="mPhen.sampleCovar_+3A_dirichletscale">dirichletScale</code></td>
<td>
<p>When sampling off diagonal elements of the cholesky decomposition, how much deviation from uniform to allow. Should be a number in interval (0,+Inf).  Smaller value leads to greater variation</p>
</td></tr>
<tr><td><code id="mPhen.sampleCovar_+3A_resample">resample</code></td>
<td>
<p>Whether to randomly shuffle phenotype columns after sampling. </p>
</td></tr>
<tr><td><code id="mPhen.sampleCovar_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for each phenotype</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated covariance matrix</p>

<hr>
<h2 id='mPhen.sampleGeno'>Sample genotypes</h2><span id='topic+mPhen.sampleGeno'></span>

<h3>Description</h3>

<p>...</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.sampleGeno(n = 100, sampSize = 100, chr="0",pos = 1:n, 
snpids = paste(chr,pos,sep="_"),meanAlleleFreq=0.2, mu = 10,
samples =paste("id",1:sampSize,sep="_"),imputed = FALSE, dirichlet = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.sampleGeno_+3A_n">n</code></td>
<td>
<p>Number of genotypes to sample</p>
</td></tr>
<tr><td><code id="mPhen.sampleGeno_+3A_sampsize">sampSize</code></td>
<td>
<p>Number of individuals to sample</p>
</td></tr>
<tr><td><code id="mPhen.sampleGeno_+3A_chr">chr</code></td>
<td>
<p>Name of chromosome</p>
</td></tr>
<tr><td><code id="mPhen.sampleGeno_+3A_pos">pos</code></td>
<td>
<p>Positions of genotypes on chromosome</p>
</td></tr>
<tr><td><code id="mPhen.sampleGeno_+3A_snpids">snpids</code></td>
<td>
<p>Ids of genotypes</p>
</td></tr>
<tr><td><code id="mPhen.sampleGeno_+3A_meanallelefreq">meanAlleleFreq</code></td>
<td>
<p>The mean allele frequency to simulate</p>
</td></tr>
<tr><td><code id="mPhen.sampleGeno_+3A_mu">mu</code></td>
<td>
<p>A weight parameter which controls how close to the meanAlleleFreq the allele frequencies are sampled, via a beta distribution.  A higher number implies allele frequencies stay closer to mean</p>
</td></tr>
<tr><td><code id="mPhen.sampleGeno_+3A_samples">samples</code></td>
<td>
<p>The sample ids</p>
</td></tr>
<tr><td><code id="mPhen.sampleGeno_+3A_imputed">imputed</code></td>
<td>
<p>Whether to simulate imputed data</p>
</td></tr>
<tr><td><code id="mPhen.sampleGeno_+3A_dirichlet">dirichlet</code></td>
<td>
<p>The weight of a dirichlet distribution used to simulated imputed data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns matrix of genotypes, with individuals by rows, and snps by column, or a 3 dimensional array if imputed is TRUE</p>

<hr>
<h2 id='mPhen.simulate'>Simulates phenotypes according to a correlation structure.</h2><span id='topic+mPhen.simulate'></span>

<h3>Description</h3>

<p>This function simulates phenotypes based on a pre-defined correlation structure (which can also be obtained from 
mPhen.sampleCovar), and a genetic effect x.  The function works by sampling a phenotype from a correlation matrix in a linearly 
transformed space such that the genetic effect direction is only in the direction of the x-axis, then transforming back into the
original space.  If inverse is TRUE,  then the phenotypes are sampled first with no genetic effect, then the genotype is sampled 
according to the effect direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.simulate(x,sample_names, covar,effDir,
varexp,inverse=FALSE, geno.link="gaussian",
effDirInReverseEigenspace=FALSE, freq = 0.1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.simulate_+3A_x">x</code></td>
<td>
<p>A vector of genotype effect. If a single SNP has an effect, this will just be genotypes at this SNP</p>
</td></tr>
<tr><td><code id="mPhen.simulate_+3A_sample_names">sample_names</code></td>
<td>
<p>Vector of sample names, should have same length as x</p>
</td></tr>
<tr><td><code id="mPhen.simulate_+3A_covar">covar</code></td>
<td>
<p>Covariance of phenotypes, should be an n by n matrix, where n is the number of phenotypes to simulate.</p>
</td></tr>
<tr><td><code id="mPhen.simulate_+3A_effdir">effDir</code></td>
<td>
<p>Direction in phenotype space in which to simulate the effect</p>
</td></tr>
<tr><td><code id="mPhen.simulate_+3A_varexp">varexp</code></td>
<td>
<p>The proportion of variance of phenotype variation in the target direction explained by the genotypic effect overall.</p>
</td></tr>
<tr><td><code id="mPhen.simulate_+3A_inverse">inverse</code></td>
<td>
<p>If TRUE, then simulates correlated phenotypes, and then simulates genotypes from phenotypes in specified direction.  Otherwise, simulates correlated phenotypes with direction of effect based on input genotypes.</p>
</td></tr>
<tr><td><code id="mPhen.simulate_+3A_geno.link">geno.link</code></td>
<td>
<p>Only applicable if inverse = TRUE, in which case it specifies a link function for genotypes.  Can be binomial, gaussian or ordinal.</p>
</td></tr>
<tr><td><code id="mPhen.simulate_+3A_effdirinreverseeigenspace">effDirInReverseEigenspace</code></td>
<td>
<p>If TRUE, then effDir is interpreted as eigenvector weights, ordered from eigenvector with smallest eigenvalue to eigenvector with biggest eigenvector (i.e. in reverse direction).  This is useful if you want to simulate directs which are in the least variable axis of variation.</p>
</td></tr>
<tr><td><code id="mPhen.simulate_+3A_freq">freq</code></td>
<td>
<p>If inverse = TRUE, then this is target allele frequency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of three elements: pheno - a matrix of phenotype values, with phenotypes in columns and samples in rows; and geno- a vector genotypes, either sampled if inverse=TRUE, or the original genetic effect x; and limit - this is a default list of phenotypes to include in subsequent association analysis, as well as covariates (empty) and residuals (empty). This object can then be used by mPhen.preparePheno</p>

<hr>
<h2 id='mPhen.writeOutput'>Prepares output files and plots from MultiPhen results</h2><span id='topic+mPhen.writeOutput'></span>

<h3>Description</h3>

<p>Writes output to files defined in mPhen.openOutputConnection, and extracts pvalues and betas for
further plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPhen.writeOutput(results,
output = getOption("mPhen.resultsName","resultsDir/"),geno = NULL,
towrite = list(long.txt = getOption("mPhen.writeLong",TRUE),
qc.txt =  getOption("mPhen.writeQC",FALSE), 
wide.txt = getOption("mPhen.writeWide",TRUE)),
toplot = list(.manh = TRUE, .qq = TRUE,.heatm = TRUE,
              
              .fprint = !is.null(geno)),
opts = mPhen.options("plot"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPhen.writeOutput_+3A_results">results</code></td>
<td>
<p>Output of mPhen.assoc</p>
</td></tr>
<tr><td><code id="mPhen.writeOutput_+3A_output">output</code></td>
<td>
<p>Directory to write results, or object returned by mPhen.writeOutput(..)</p>
</td></tr>
<tr><td><code id="mPhen.writeOutput_+3A_towrite">towrite</code></td>
<td>
<p>List specifying which formats to write output - long.txt and wide.txt for standard results; qc.txt for per-sample qc output.</p>
</td></tr>
<tr><td><code id="mPhen.writeOutput_+3A_toplot">toplot</code></td>
<td>
<p>List specifying which formats to plot  output - .qq for qq plot, .manh for manhattan; .heatm for pvalue heatmap; .fprint for fingerprint plot</p>
</td></tr>
<tr><td><code id="mPhen.writeOutput_+3A_geno">geno</code></td>
<td>
<p>Genotype matrix.  Note that attr(geno,&quot;closeConnection&quot;) controls whether plots are produced, as this indicates whether all batches of genotype data have been analysed</p>
</td></tr>
<tr><td><code id="mPhen.writeOutput_+3A_opts">opts</code></td>
<td>
<p>A list of options, which is obtained from mPhen.options(&quot;plot&quot;).  To get more information about these options, type
mPhen.options(&quot;plot&quot;,descr=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an outputConnection, which can be used to write further results.</p>

<hr>
<h2 id='MultiPhen-internal'>Internal MultiPhen objects</h2><span id='topic+MultiPhen-internal'></span>

<h3>Description</h3>

<p>Internal MultiPhen objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='MultiPhen-package'>
MultiPhen, a package for the genetic association testing of multiple phenotypes
</h2><span id='topic+MultiPhen-package'></span><span id='topic+MultiPhen'></span>

<h3>Description</h3>

<p>MultiPhen is the package containing the function mPhen, which performs association testing between genetic variants (SNPs; CNVs to be added soon) and multiple phenotypes. The primary purpose is for modelling and testing multiple phenotypes jointly by performing an ordinal regression where SNPs are treated as the outcome and multiple phenotypes are predictors; this can have large increases in statistical power to detect genotype-phenotype associations over the univariate approach. However, mPhen can also be used to perform standard univariate linear regression (SNP as predictor) and univariate ordinal regression (SNP as outcome) on the phenotypes under study. mPhen can be applied to genotyped or imputed data. From version 0.4 the option &ldquo;multiPhenTest&rdquo; is now called &ldquo;JointModel&rdquo;, and its default is now &ldquo;TRUE&rdquo;
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MultiPhen</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.0.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2013-12-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Lachlan Coin, Federico Calboli, Clive Hoggart, Paul O'Reilly, Yotsawat Pomyen.
</p>
<p>Maintainer: Federico Calboli &lt;f.calboli@imperial.ac.uk&gt;</p>


<h3>References</h3>

<p>O'Reilly et al. 2012. MultiPhen: Joint model of multiple phenotypes can increase discovery in GWAS. http://dx.plos.org/10.1371/journal.pone.0034861
</p>

<hr>
<h2 id='pheno'>
A dummy phenotype dataset that provides an example of the input phenotype data used by the package
</h2><span id='topic+pheno'></span>

<h3>Description</h3>

<p>A dummy dataset of 5 phenotypes measured in 150 individuals. The data has been generated to yield significant results for SNP1 and SNP2 of the snps dataset.  The first two columns have been generated as alpha + beta1*snp + beta2*snp2 + error (with different alphas, betas and errors for each phenotype), the third has been generated as alpha + beta1*testPheno2 + beta2*snp3 + error, the fourth column is the results of sample of a binomial distributioni correlated with testPheno3, and the final column is the 1st PC of the principal component analysis of the snps matrix.
</p>


<h3>Format</h3>

<p>A matrix with 150 phenotype observations.
</p>

<dl>
<dt><code>testPheno1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>testPheno2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>testPheno3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>testPheno4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>testPheno5</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Please note the following IMPORTANT issue: the 'pheno' matrix has both column names and row names! the column names MUST be the names of the phenotypes and the row names MUST be the codes representing each individual in the pheno matrix, one individual for each row. Both row names and column names are extracted by the main function and are therefore mandatory</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pheno)
head(pheno)
dimnames(pheno)[[1]] # the row names
dimnames(pheno)[[2]] # the column names
</code></pre>

<hr>
<h2 id='read.plink'>
A function to read (small) binary PLINK binary files in a R session
</h2><span id='topic+read.plink'></span>

<h3>Description</h3>

<p><code>read.plink</code> is a convenience function designed to read PLINK binary files (i.e. files that end with the suffix &ldquo;.bed&rdquo;) in a R session.  Please be aware that binary PLINK files are binary for a reason, i.e. to store genotype data in a compact way.  Once they are imported in R they exist in R in a un &ldquo;unpacked&rdquo; form, and can therefore be very big.  If the .bed file is big, or very big, the result will be that R will run out of memory and crash, or make the whole system slow or unresponsive.  It is MANDATORY that in the directory containing the binary file also reside two accesory files, with the same name as the binary file but with extensions .fam and .bim, both produced by PLINK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.plink(root,indiv = NULL, opts = mPhen.options("geno.input"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.plink_+3A_root">root</code></td>
<td>

<p>filename of the dataset in PLINK binary format, WITHOUT the .bed extension.  </p>
</td></tr>
<tr><td><code id="read.plink_+3A_indiv">indiv</code></td>
<td>
<p>List of individuals, results will be in this order</p>
</td></tr>
<tr><td><code id="read.plink_+3A_opts">opts</code></td>
<td>
<p>List of options, use mPhen.options(&quot;geno.input&quot;,descr=TRUE) for more details of each option.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that, if the binary file is listed a &ldquo;mydata.bed&rdquo;, the filename is &ldquo;mydata&rdquo;, and the extension is &ldquo;.bed&rdquo;.  In this case &ldquo;mydata&rdquo; would be used as <code>root</code> value.
</p>


<h3>Value</h3>

<p>A matrix of dimesions n by m, with n rows corresponding to the n individuals in the dataset, and m columns corresponding to the m markers.  The colnames are retrived from the .fam file, and (should) correspond to the markers' names.
</p>


<h3>Note</h3>

<p>Please do note that the concept of a &ldquo;big&rdquo; binary file, or a binary file that is &ldquo;too big&rdquo; is purely dependent on the computer on which the code is running.  A computer with 512MB of RAM will stop being able to read in a whole binary file well before a 16GB RAM machine.
</p>


<h3>Author(s)</h3>

<p>Federico Calboli <a href="mailto:f.calboli@imperial.ac.uk">f.calboli@imperial.ac.uk</a>  
</p>


<h3>References</h3>

<p>The plink homepage is at: <a href="https://www.cog-genomics.org/plink2">https://www.cog-genomics.org/plink2</a>
</p>

<hr>
<h2 id='snps'>
A dummy snp dataset that provides an example of the input snp data used by the package
</h2><span id='topic+snps'></span>

<h3>Description</h3>

<p>A dummy dataset of three SNPs, as a matrix of 3 column and 150 rows. The genotypes are in 0/1/2 format (0 for &ldquo;AA&rdquo;, 1 for &ldquo;Aa&rdquo; and 2 for &ldquo;aa&rdquo;, where A and a correspond, arbitrarily, to the two alleles). The data has been randomly generated, for instructional purposes only, and do not yield a significant association with any of the example phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(snps)</code></pre>


<h3>Format</h3>

<p>A data frame with 150 genotype observations.
</p>

<dl>
<dt><code>rsID1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rsID2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>rsID3</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The 150 genotypes in 'snp' correspond to the phenotype data on 150 individuals in &lsquo;pheno&rsquo;, i.e. one individual for each line. Please note the following important points: genotype data must be in matrix format, with one row for each individual and as many columns for each SNP. In the case of one single genotype the data must still conform to this format, as a matrix of as many rows as individuals and one single column for the one genotype present. A second important point is that the column names must be the rsID of the SNP for genotypes in the 0/1/2 format. Further options of genotype format (incorporating raw genotype data, and CNV genotypes) will be available and documented in future releases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(snps)
dim(snps)
colnames(snps)
</code></pre>

<hr>
<h2 id='snps.imputed'>
Imputed SNP dataset
</h2><span id='topic+snps.imputed'></span>

<h3>Description</h3>

<p>A toy dataset of three imputed SNP, for 150 individuals. For each individuals, and for each SNP, the first column is the probability of a minor allele homozygote genotype (genotype &ldquo;0&rdquo;), the second column is the probability of an heterozygote genotype (genotype &ldquo;1&rdquo;) and the third and last column is the probability of a major allele homozygote (genotype &ldquo;2&rdquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(snps.imputed)</code></pre>


<h3>Format</h3>

<p>A matrix of 150 rows and nine columns. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(snps.imputed)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
