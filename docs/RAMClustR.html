<!DOCTYPE html><html><head><title>Help for package RAMClustR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RAMClustR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adap.to.rc'><p>adap.to.rc</p></a></li>
<li><a href='#add_params'><p>add_params</p></a></li>
<li><a href='#annotate'><p>evaluate ramSearch, MSFinder mssearch, MSFinder Structure, MSFinder Formula, and findmain output to annotate spectra of ramclustR object</p></a></li>
<li><a href='#annotation.summary'><p>annotation.summary()</p></a></li>
<li><a href='#assign.z'><p>assign.z</p></a></li>
<li><a href='#change.annotation'><p>evaluate ramSearch, MSFinder mssearch, MSFinder Structure, MSFinder Formula, and findmain output to annotate spectra of ramclustR object</p></a></li>
<li><a href='#check_arguments_filter.blanks'><p>check_arguments_filter.blanks</p></a></li>
<li><a href='#check_arguments_filter.cv'><p>check_arguments_filter.cv</p></a></li>
<li><a href='#check_arguments_replace.na'><p>check_arguments_replace.na</p></a></li>
<li><a href='#checks'><p>checks</p></a></li>
<li><a href='#cmpd.summary'><p>cmpd.summary</p></a></li>
<li><a href='#compute_do.sets'><p>compute_do.sets</p></a></li>
<li><a href='#compute_SpecAbundAve'><p>compute_SpecAbundAve</p></a></li>
<li><a href='#compute_wt_mean'><p>compute_wt_mean</p></a></li>
<li><a href='#create_ramclustObj'><p>create_ramclustObj</p></a></li>
<li><a href='#define_samples'><p>define_samples</p></a></li>
<li><a href='#defineExperiment'><p>defineExperiment</p></a></li>
<li><a href='#do.findmain'><p>do.findmain</p></a></li>
<li><a href='#export.msfinder.formulas'><p>export MSFinder formula prediction results in tabular format.</p></a></li>
<li><a href='#exportDataset'><p>exportDataset</p></a></li>
<li><a href='#filter_blanks'><p>filter_blanks</p></a></li>
<li><a href='#filter_good_features'><p>filter_good_features</p></a></li>
<li><a href='#filter_signal'><p>filter_signal</p></a></li>
<li><a href='#find_good_features'><p>find_good_features</p></a></li>
<li><a href='#findfeature'><p>findfeature</p></a></li>
<li><a href='#findmass'><p>findmass</p></a></li>
<li><a href='#fooddb2msfinder'><p>foodb2msfinder</p></a></li>
<li><a href='#get_ExpDes'><p>get_ExpDes</p></a></li>
<li><a href='#get_instrument_platform'><p>get_instrument_platform</p></a></li>
<li><a href='#get.taxon.cids'><p>get.taxon.cids</p></a></li>
<li><a href='#getData'><p>getData</p></a></li>
<li><a href='#getSmilesInchi'><p>getSmilesInchi</p></a></li>
<li><a href='#import.adap.kdb'><p>import.adap.kdb</p></a></li>
<li><a href='#import.msfinder.formulas'><p>import.msfinder.formulas</p></a></li>
<li><a href='#import.msfinder.mssearch'><p>import.MSFinder.mssearch</p></a></li>
<li><a href='#import.msfinder.structures'><p>write.methods</p></a></li>
<li><a href='#import.sirius'><p>import.sirius</p></a></li>
<li><a href='#impRamSearch'><p>impRamSearch</p></a></li>
<li><a href='#manual.annotation.template'><p>manual.annotation.template</p></a></li>
<li><a href='#mean_signal_intensities'><p>mean_signal_intensities</p></a></li>
<li><a href='#mergeRCobjects'><p>mergeRCobjects</p></a></li>
<li><a href='#normalized_data_batch_qc'><p>normalized_data_batch_qc</p></a></li>
<li><a href='#normalized_data_tic'><p>normalized_data_tic</p></a></li>
<li><a href='#order_datasets'><p>order_datasets</p></a></li>
<li><a href='#ramclustR'><p>ramclustR</p></a></li>
<li><a href='#rc.calibrate.ri'><p>rc.calibrate.ri</p></a></li>
<li><a href='#rc.cmpd.filter.blanks'><p>rc.cmpd.filter.blanks</p></a></li>
<li><a href='#rc.cmpd.filter.cv'><p>rc.cmpd.filter.cv</p></a></li>
<li><a href='#rc.cmpd.get.classyfire'><p>getClassyFire</p></a></li>
<li><a href='#rc.cmpd.get.pubchem'><p>rc.cmpd.get.pubchem</p></a></li>
<li><a href='#rc.cmpd.get.smiles.inchi'><p>getSmilesInchi</p></a></li>
<li><a href='#rc.cmpd.replace.na'><p>rc.cmpd.replace.na</p></a></li>
<li><a href='#rc.expand.sample.names'><p>rc.expand.sample.names</p></a></li>
<li><a href='#rc.export.msp.rc'><p>rc.export.msp.rc</p></a></li>
<li><a href='#rc.feature.filter.blanks'><p>rc.feature.filter.blanks</p></a></li>
<li><a href='#rc.feature.filter.cv'><p>rc.feature.filter.cv</p></a></li>
<li><a href='#rc.feature.normalize.batch.qc'><p>rc.feature.normalize.batch.qc</p></a></li>
<li><a href='#rc.feature.normalize.qc'><p>rc.feature.normalize.qc</p></a></li>
<li><a href='#rc.feature.normalize.quantile'><p>rc.feature.normalize.quantile</p></a></li>
<li><a href='#rc.feature.normalize.tic'><p>rc.feature.normalize.tic</p></a></li>
<li><a href='#rc.feature.replace.na'><p>rc.feature.replace.na</p></a></li>
<li><a href='#rc.get.csv.data'><p>rc.get.csv.data</p></a></li>
<li><a href='#rc.get.df.data'><p>rc.get.df.data</p></a></li>
<li><a href='#rc.get.xcms.data'><p>rc.get.xcms.data</p></a></li>
<li><a href='#rc.qc'><p>rc.qc</p></a></li>
<li><a href='#rc.ramclustr'><p>rc.ramclustr</p></a></li>
<li><a href='#rc.remove.qc'><p>rc.remove.qc</p></a></li>
<li><a href='#rc.restore.qc.samples'><p>rc.restore.qc.samples</p></a></li>
<li><a href='#RCQC'><p>RCQC</p></a></li>
<li><a href='#remove_blanks'><p>remove_blanks</p></a></li>
<li><a href='#replace_na'><p>replace_na</p></a></li>
<li><a href='#write_csv'><p>write_csv</p></a></li>
<li><a href='#write.methods'><p>write.methods</p></a></li>
<li><a href='#write.msp'><p>write.msp</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mass Spectrometry Metabolomics Feature Clustering and
Interpretation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-20</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dynamicTreeCut, fastcluster, httr, jsonlite, e1071, gplots,
pcaMethods, stringr, utils, webchem, ggplot2, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, xcms, testthat, patrick, MSnbase,
InterpretMSSpectrum (&ge; 1.3.8), BiocManager, xml2, stringi,
readxl, curl, rentrez</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Description:</td>
<td>A feature clustering algorithm for non-targeted mass spectrometric metabolomics data. This method is compatible with gas and liquid chromatography coupled mass spectrometry, including indiscriminant tandem mass spectrometry data &lt;<a href="https://doi.org/10.1021%2Fac501530d">doi:10.1021/ac501530d</a>&gt;. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cbroeckl/RAMClustR">https://github.com/cbroeckl/RAMClustR</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>biocViews:</td>
<td>MassSpectrometry, Metabolomics</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-20 13:56:38 UTC; hechth</td>
</tr>
<tr>
<td>Author:</td>
<td>Corey D. Broeckling
    <a href="https://orcid.org/0000-0002-6158-827X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Fayyaz Afsar [aut],
  Steffen Neumann [aut],
  Asa Ben-Hur [aut],
  Jessica Prenni [aut],
  Helge Hecht <a href="https://orcid.org/0000-0001-6744-996X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre],
  Matej Trojak [ctb],
  Zargham Ahmad [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Helge Hecht &lt;helge.hecht@recetox.muni.cz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-20 15:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='adap.to.rc'>adap.to.rc</h2><span id='topic+adap.to.rc'></span>

<h3>Description</h3>

<p>use pubchem rest and view APIs to retreive structures, CIDs (if a name or inchikey is given), synonyms, and optionally vendor data, when available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adap.to.rc(
  seq = "seq.csv",
  spec.abund = "signal.csv",
  msp = "spectra.msp",
  annotations = "annotations.xlsx",
  mzdec = 1,
  min.score = 700,
  manual.name = FALSE,
  qc.tag = "qc",
  blank.tag = "blank",
  factor.names = c()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adap.to.rc_+3A_seq">seq</code></td>
<td>
<p>file name/path to sequence file - expect filenames in column 1 and sample names in column 2.  filenames should match those in spec.abund</p>
</td></tr>
<tr><td><code id="adap.to.rc_+3A_spec.abund">spec.abund</code></td>
<td>
<p>file name/path to adap-big export of signal intensities. .csv file expected</p>
</td></tr>
<tr><td><code id="adap.to.rc_+3A_msp">msp</code></td>
<td>
<p>file name/path to .msp file created by adap-big</p>
</td></tr>
<tr><td><code id="adap.to.rc_+3A_annotations">annotations</code></td>
<td>
<p>file name/path to annotations .xlsx file.  generally 'simple_export.xlsx'</p>
</td></tr>
<tr><td><code id="adap.to.rc_+3A_mzdec">mzdec</code></td>
<td>
<p>mz decimals to report for internal storage/reporting.  generally we want 0 for adap kdb</p>
</td></tr>
<tr><td><code id="adap.to.rc_+3A_min.score">min.score</code></td>
<td>
<p>700 (out of 1000) by default</p>
</td></tr>
<tr><td><code id="adap.to.rc_+3A_manual.name">manual.name</code></td>
<td>
<p>when looking up inchikey/names, should manual input be used to fill ambiguous names? generally recommend TRUE</p>
</td></tr>
<tr><td><code id="adap.to.rc_+3A_qc.tag">qc.tag</code></td>
<td>
<p>a character string by which to recognize a sample as a qc sample.  i.e. 'QC' or 'qc'.</p>
</td></tr>
<tr><td><code id="adap.to.rc_+3A_blank.tag">blank.tag</code></td>
<td>
<p>a character string by which to recognize a sample as a blank sample.  i.e. 'blank' or 'Blank'.</p>
</td></tr>
<tr><td><code id="adap.to.rc_+3A_factor.names">factor.names</code></td>
<td>
<p>factor names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>useful for moving from chemical name to digital structure represtation. greek letters are assumed to be 'UTF-8' encoded, and are converted to latin text before searching.   if you are reading in your compound name list, do so with 'encoding' set to 'UTF-8'.
</p>


<h3>Value</h3>

<p>returns a ramclustR structured object suitable for down stream processing steps.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>

<hr>
<h2 id='add_params'>add_params</h2><span id='topic+add_params'></span>

<h3>Description</h3>

<p>add rc.feature.replace.na params in ramclustObj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_params(ramclustObj, params, param_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_params_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="add_params_+3A_params">params</code></td>
<td>
<p>vector containing parameters to add</p>
</td></tr>
<tr><td><code id="add_params_+3A_param_name">param_name</code></td>
<td>
<p>name of the parameter/step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ramclustR object with rc.feature.replace.na params added.
</p>

<hr>
<h2 id='annotate'>evaluate ramSearch, MSFinder mssearch, MSFinder Structure, MSFinder Formula, and findmain output to annotate spectra of ramclustR object</h2><span id='topic+annotate'></span>

<h3>Description</h3>

<p>After running RAMSearch (msp) and MSFinder on .mat or .msp files, import the spectral search results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate(
  ramclustObj = NULL,
  standardize.names = FALSE,
  min.msms.score = 0.8,
  database.priority = NULL,
  database.priority.factor = 0.1,
  find.inchikey = TRUE,
  taxonomy.inchi = NULL,
  taxonomy.inchi.factor = 0.1,
  use.ri = TRUE,
  sri = 300,
  ri.na.factor = 0.6,
  reset = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object - the ramclustR object which was used to write the .mat or .msp files</p>
</td></tr>
<tr><td><code id="annotate_+3A_standardize.names">standardize.names</code></td>
<td>
<p>logical: if TRUE, use inchikey for standardized chemical name lookup (http://cts.fiehnlab.ucdavis.edu/)</p>
</td></tr>
<tr><td><code id="annotate_+3A_min.msms.score">min.msms.score</code></td>
<td>
<p>numerical: what is the minimum MSFinder similarity score acceptable.  default = 6.5</p>
</td></tr>
<tr><td><code id="annotate_+3A_database.priority">database.priority</code></td>
<td>
<p>character.  Formula assignment prioritization based on presence in one or more (structure) databases.  Can be set to a single or multiple database names.  must match database names as they are listed in MSFinder precisely. Can also be set to 'all' (note that MSFinder reports all databases matched, not just databases in MSFinder parameters).  If any database is set, the best formula match to any of those databases is selected, rather than the best formula match overall.  If NULL, this will be set to include all selected databases (from ramclustObj$msfinder.dbs, retrieved from search output during import.msfinder.formulas(), when available) or 'all'.</p>
</td></tr>
<tr><td><code id="annotate_+3A_database.priority.factor">database.priority.factor</code></td>
<td>
<p>numeric, between 0 and 1.  0.1 by default.  The proportion by which scores for structures not in priority database are assessed</p>
</td></tr>
<tr><td><code id="annotate_+3A_find.inchikey">find.inchikey</code></td>
<td>
<p>logical.  default = TRUE. use chemical translation service to try to look up inchikey for chemical name.</p>
</td></tr>
<tr><td><code id="annotate_+3A_taxonomy.inchi">taxonomy.inchi</code></td>
<td>
<p>vector or data frame.  Only when rescore.structure = TRUE.  user can supply a vector of inchikeys.  If used, structures which match first block of inchikey retain full score, while all other structures are penalized.</p>
</td></tr>
<tr><td><code id="annotate_+3A_taxonomy.inchi.factor">taxonomy.inchi.factor</code></td>
<td>
<p>numeric, between 0 and 1.  0.1 by default.  The proportion by which scores for structures not in taxonomy.inchi vector are assessed</p>
</td></tr>
<tr><td><code id="annotate_+3A_use.ri">use.ri</code></td>
<td>
<p>logical.  default = TRUE.  If retention index is available in ramclustObj (set by 'rc.calibrate.ri') and in library spectra from MSFinder, use RI similiarity to rescore.</p>
</td></tr>
<tr><td><code id="annotate_+3A_sri">sri</code></td>
<td>
<p>numeric.  sigma value for retention index. controls decay rate of retention index curve. decay rate between 0 and 1 exported, and multiplied by spectrum score, totalscore.</p>
</td></tr>
<tr><td><code id="annotate_+3A_ri.na.factor">ri.na.factor</code></td>
<td>
<p>numeric. between 0 and 1.  0.5 by default.  how should spectrum scores be treated when no retention index is available?  NA values are replaced by retention index similarities of ri.na.factor when use.ri = TRUE.</p>
</td></tr>
<tr><td><code id="annotate_+3A_reset">reset</code></td>
<td>
<p>logical.  If TRUE, removes any previously assigned annotations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function imports the output from the MSFinder program to annotate the ramclustR object
</p>


<h3>Value</h3>

<p>an updated ramclustR object, with the at $msfinder.formula, $msfinder.formula.score,  $ann, and $ann.conf slots updated to annotated based on output from 1. ramsearch output, 2. msfinder mssearch, 3. msfinder predicted structure, 4. msfinder predicted formula, and 5. interpretMSSpectrum inferred molecular weight, with listed order as priority.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>
<p>Tsugawa H, Kind T, Nakabayashi R, Yukihira D, Tanaka W, Cajka T, Saito K, Fiehn O, Arita M. Hydrogen Rearrangement Rules: Computational MS/MS Fragmentation and Structure Elucidation Using MS-FINDER Software. Anal Chem. 2016 Aug 16;88(16):7946-58. doi: 10.1021/acs.analchem.6b00770. Epub 2016 Aug 4. PubMed PMID: 27419259.
</p>
<p>http://cts.fiehnlab.ucdavis.edu/static/download/CTS2-MS2015.pdf
</p>

<hr>
<h2 id='annotation.summary'>annotation.summary()</h2><span id='topic+annotation.summary'></span>

<h3>Description</h3>

<p>Write a .csv file containing a summary of the annotations in the ramclustR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation.summary(ramclustObj = NULL, outfile = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation.summary_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object - the ramclustR object which was used to write the .mat or .msp files</p>
</td></tr>
<tr><td><code id="annotation.summary_+3A_outfile">outfile</code></td>
<td>
<p>file path/name of output csv summary file.  if NULL (default) will be exported to spectra/annotaionSummary.csv</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function exports a csv file summarizing annotation evidence for each compound
</p>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='assign.z'>assign.z</h2><span id='topic+assign.z'></span>

<h3>Description</h3>

<p>infer charge state of features in ramclustR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign.z(
  ramclustObj = NULL,
  chargestate = c(1:5),
  mzError = 0.02,
  nEvents = 2,
  minPercentSignal = 10,
  assume1 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign.z_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to annotate</p>
</td></tr>
<tr><td><code id="assign.z_+3A_chargestate">chargestate</code></td>
<td>
<p>integer vector. vector of integers of charge states to look for.  default = c(1:5)</p>
</td></tr>
<tr><td><code id="assign.z_+3A_mzerror">mzError</code></td>
<td>
<p>numeric. the error allowed in charge state m/z filtering.  absolute mass units</p>
</td></tr>
<tr><td><code id="assign.z_+3A_nevents">nEvents</code></td>
<td>
<p>integer. the number of isotopes necessary to assign a charnge state &gt; 1.  default = 2.</p>
</td></tr>
<tr><td><code id="assign.z_+3A_minpercentsignal">minPercentSignal</code></td>
<td>
<p>numeric.  the ratio of isotope signal (all isotopes) divided by total spectrum signal * 100 much be greater than minPercentSignal to evaluate charge state. Value should be between 0 and 100.</p>
</td></tr>
<tr><td><code id="assign.z_+3A_assume1">assume1</code></td>
<td>
<p>logical.  when TRUE, m/z values for which no isotopes are found are assumed to be at z = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Annotation of ramclustR spectra. looks at isotope spacing for clustered features to infer charge state for each feature and a max charge state for each compound
</p>


<h3>Value</h3>

<p>returns a ramclustR object.  new slots holding:
</p>
<p>zmax. vector with length equal to number of compounds.  max charge state detected for that compound
</p>
<p>fm. vector of inferred 'm', m/z value * z value
</p>
<p>fz. vector of inferred 'z' values based on analysis of isotopes in spectrum.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='change.annotation'>evaluate ramSearch, MSFinder mssearch, MSFinder Structure, MSFinder Formula, and findmain output to annotate spectra of ramclustR object</h2><span id='topic+change.annotation'></span>

<h3>Description</h3>

<p>After running RAMSearch (msp) and MSFinder on .mat or .msp files, import the spectral search results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change.annotation(
  ramclustObj = NULL,
  msfinder.dir = "C:/MSFinder/MSFINDER ver 3.22",
  standardize.names = FALSE,
  min.msms.score = 3.5,
  database.priority = "all",
  any.database.priority = TRUE,
  reset = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change.annotation_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object - the ramclustR object which was used to write the .mat or .msp files</p>
</td></tr>
<tr><td><code id="change.annotation_+3A_msfinder.dir">msfinder.dir</code></td>
<td>
<p>full path to MSFinder directory - used for naming refinement</p>
</td></tr>
<tr><td><code id="change.annotation_+3A_standardize.names">standardize.names</code></td>
<td>
<p>logical: if TRUE, use inchikey for standardized chemical name lookup (http://cts.fiehnlab.ucdavis.edu/)</p>
</td></tr>
<tr><td><code id="change.annotation_+3A_min.msms.score">min.msms.score</code></td>
<td>
<p>numerical: what is the minimum MSFinder similarity score acceptable.  default = 3.5</p>
</td></tr>
<tr><td><code id="change.annotation_+3A_database.priority">database.priority</code></td>
<td>
<p>character.  Formula assignment prioritization based on presence in one or more databases.  Can be set to a single or multiple database names.  must match database names as they are listed in MSFinder precisely. Can also be set to 'all' (note that MSFinder reports all databases matched, not just selected databases).  If any database is set, the best formula match to that (those) database(s) is selected, rather than the best formula match overall.</p>
</td></tr>
<tr><td><code id="change.annotation_+3A_any.database.priority">any.database.priority</code></td>
<td>
<p>logical.  First priority in formula assignment is based on any of the 'database.priority' values.  Secondary priority from all other databases (determined in original MSFinder search) if TRUE.  If false, formula assignment score from MSFinder used independent of structure search results.</p>
</td></tr>
<tr><td><code id="change.annotation_+3A_reset">reset</code></td>
<td>
<p>logical.  If TRUE, removes any previously assigned annotations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function imports the output from the MSFinder program to annotate the ramclustR object
</p>


<h3>Value</h3>

<p>an updated ramclustR object, with the at $msfinder.formula, $msfinder.formula.score,  $ann, and $ann.conf slots updated to annotated based on output from 1. ramsearch output, 2. msfinder mssearch, 3. msfinder predicted structure, 4. msfinder predicted formula, and 5. interpretMSSpectrum inferred molecular weight, with listed order as priority.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>
<p>Tsugawa H, Kind T, Nakabayashi R, Yukihira D, Tanaka W, Cajka T, Saito K, Fiehn O, Arita M. Hydrogen Rearrangement Rules: Computational MS/MS Fragmentation and Structure Elucidation Using MS-FINDER Software. Anal Chem. 2016 Aug 16;88(16):7946-58. doi: 10.1021/acs.analchem.6b00770. Epub 2016 Aug 4. PubMed PMID: 27419259.
</p>
<p>http://cts.fiehnlab.ucdavis.edu/static/download/CTS2-MS2015.pdf
</p>

<hr>
<h2 id='check_arguments_filter.blanks'>check_arguments_filter.blanks</h2><span id='topic+check_arguments_filter.blanks'></span>

<h3>Description</h3>

<p>check provided arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_arguments_filter.blanks(ramclustObj, sn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_arguments_filter.blanks_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="check_arguments_filter.blanks_+3A_sn">sn</code></td>
<td>
<p>numeric defines the ratio for 'signal'.  i.e. sn = 3 indicates that signal intensity must be 3 fold higher in sample than in blanks, on average, to be retained.</p>
</td></tr>
</table>

<hr>
<h2 id='check_arguments_filter.cv'>check_arguments_filter.cv</h2><span id='topic+check_arguments_filter.cv'></span>

<h3>Description</h3>

<p>check provided arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_arguments_filter.cv(ramclustObj, qc.tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_arguments_filter.cv_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="check_arguments_filter.cv_+3A_qc.tag">qc.tag</code></td>
<td>
<p>character vector of length one or two.  If length is two, enter search string and factor name in $phenoData slot (i.e. c(&quot;QC&quot;, &quot;sample.type&quot;). If length one (i.e. &quot;QC&quot;), will search for this string in the 'sample.names' slot by default.</p>
</td></tr>
</table>

<hr>
<h2 id='check_arguments_replace.na'>check_arguments_replace.na</h2><span id='topic+check_arguments_replace.na'></span>

<h3>Description</h3>

<p>check provided arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_arguments_replace.na(
  ramclustObj,
  replace.int,
  replace.noise,
  replace.zero
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_arguments_replace.na_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="check_arguments_replace.na_+3A_replace.int">replace.int</code></td>
<td>
<p>default = 0.1.  proportion of minimum feature value to replace NA (or zero) values with</p>
</td></tr>
<tr><td><code id="check_arguments_replace.na_+3A_replace.noise">replace.noise</code></td>
<td>
<p>default = 0.1.  proportion ofreplace.int value by which noise is added via 'jitter'</p>
</td></tr>
<tr><td><code id="check_arguments_replace.na_+3A_replace.zero">replace.zero</code></td>
<td>
<p>logical if TRUE, any zero values are replaced with noise as if they were NA values</p>
</td></tr>
</table>

<hr>
<h2 id='checks'>checks</h2><span id='topic+checks'></span>

<h3>Description</h3>

<p>check if MS data contains mz and rt, and if MSMS data is present feature names and sample names are identical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checks(
  ms1_featureDefinitions = NULL,
  ms1_featureValues = NULL,
  ms2_featureValues = NULL,
  feature_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checks_+3A_ms1_featuredefinitions">ms1_featureDefinitions</code></td>
<td>
<p>dataframe with metadata with columns: mz, rt, feature names containing MS data</p>
</td></tr>
<tr><td><code id="checks_+3A_ms1_featurevalues">ms1_featureValues</code></td>
<td>
<p>dataframe with rownames = sample names, colnames = feature names containing MS data</p>
</td></tr>
<tr><td><code id="checks_+3A_ms2_featurevalues">ms2_featureValues</code></td>
<td>
<p>dataframe with rownames = sample names, colnames = feature names containing MSMS data</p>
</td></tr>
<tr><td><code id="checks_+3A_feature_names">feature_names</code></td>
<td>
<p>feature names extracted from the data</p>
</td></tr>
</table>

<hr>
<h2 id='cmpd.summary'>cmpd.summary</h2><span id='topic+cmpd.summary'></span>

<h3>Description</h3>

<p>a bit of reporting for compounds, quick access summary and plot (if available)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmpd.summary(ramclustObj = NULL, cmpd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmpd.summary_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to annotate</p>
</td></tr>
<tr><td><code id="cmpd.summary_+3A_cmpd">cmpd</code></td>
<td>
<p>integer. compound number to report.  i.e. 459.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reports name, annotation, retention time, number of features in spectrum, median and mean signal intensity, and if interpretMSSpectrum (do.findmain) has been run, plots an annotated MS level spectrum.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='compute_do.sets'>compute_do.sets</h2><span id='topic+compute_do.sets'></span>

<h3>Description</h3>

<p>compute data frame to use in ramclustObj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_do.sets(ramclustObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_do.sets_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector which is used to select data frame to use in ramclustObj
</p>

<hr>
<h2 id='compute_SpecAbundAve'>compute_SpecAbundAve</h2><span id='topic+compute_SpecAbundAve'></span>

<h3>Description</h3>

<p>further aggregate by sample names for 'SpecAbundAve' dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_SpecAbundAve(ramclustObj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_SpecAbundAve_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ramclustR object with aggregate by sample names for 'SpecAbundAve' dataset
</p>

<hr>
<h2 id='compute_wt_mean'>compute_wt_mean</h2><span id='topic+compute_wt_mean'></span>

<h3>Description</h3>

<p>compute weighted.mean intensity of feature in ms/msms level data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_wt_mean(data, global.min, fmz, ensure.no.na)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_wt_mean_+3A_data">data</code></td>
<td>
<p>feature in ms/msms level data</p>
</td></tr>
<tr><td><code id="compute_wt_mean_+3A_global.min">global.min</code></td>
<td>
<p>minimum intensity in ms/msms level data</p>
</td></tr>
<tr><td><code id="compute_wt_mean_+3A_fmz">fmz</code></td>
<td>
<p>feature retention time</p>
</td></tr>
<tr><td><code id="compute_wt_mean_+3A_ensure.no.na">ensure.no.na</code></td>
<td>
<p>logical: if TRUE, any 'NA' values in msint and/or msmsint are replaced with numerical values based on 10 percent of feature min plus noise.  Used to ensure that spectra are not written with NA values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>weighted.mean intensity of feature in ms/msms level data
</p>

<hr>
<h2 id='create_ramclustObj'>create_ramclustObj</h2><span id='topic+create_ramclustObj'></span>

<h3>Description</h3>

<p>create ramclustr Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_ramclustObj(
  ExpDes = NULL,
  input_history = NULL,
  MSdata = NULL,
  MSMSdata = NULL,
  frt = NULL,
  fmz = NULL,
  st = NULL,
  phenoData = NULL,
  feature_names = NULL,
  sample_names = NULL,
  xcmsOrd = NULL,
  ensure.no.na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_ramclustObj_+3A_expdes">ExpDes</code></td>
<td>
<p>either an R object created by R ExpDes object: data used for record keeping and labelling msp spectral output</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_input_history">input_history</code></td>
<td>
<p>input history</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_msdata">MSdata</code></td>
<td>
<p>dataframe containing MS Data</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_msmsdata">MSMSdata</code></td>
<td>
<p>dataframe containing MSMS Data</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_frt">frt</code></td>
<td>
<p>feature retention time, in whatever units were fed in</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_fmz">fmz</code></td>
<td>
<p>feature retention time</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_st">st</code></td>
<td>
<p>numeric: sigma t - time similarity decay value</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_phenodata">phenoData</code></td>
<td>
<p>dataframe containing phenoData</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_feature_names">feature_names</code></td>
<td>
<p>feature names extracted from the data</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_sample_names">sample_names</code></td>
<td>
<p>sample names extracted from the data</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_xcmsord">xcmsOrd</code></td>
<td>
<p>original xcms order of features, for back-referencing when necessary</p>
</td></tr>
<tr><td><code id="create_ramclustObj_+3A_ensure.no.na">ensure.no.na</code></td>
<td>
<p>logical: if TRUE, any 'NA' values in msint and/or msmsint are replaced with numerical values based on 10 percent of feature min plus noise.  Used to ensure that spectra are not written with NA values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ramclustR object. this object is formatted as an hclust object with additional slots for holding feature and compound data.
</p>

<hr>
<h2 id='define_samples'>define_samples</h2><span id='topic+define_samples'></span>

<h3>Description</h3>

<p>define samples in each set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_samples(ramclustObj, tag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_samples_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="define_samples_+3A_tag">tag</code></td>
<td>
<p>character vector of length one or two.  If length is two, enter search string and factor name in $phenoData slot (i.e. c(&quot;QC&quot;, &quot;sample.type&quot;). If length one (i.e. &quot;QC&quot;), will search for this string in the 'sample.names' slot by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>samples found using the tag
</p>

<hr>
<h2 id='defineExperiment'>defineExperiment</h2><span id='topic+defineExperiment'></span>

<h3>Description</h3>

<p>Create an Experimental Design R object for record-keeping and msp output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineExperiment(csv = FALSE, force.skip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defineExperiment_+3A_csv">csv</code></td>
<td>
<p>logical or filepath.  If   csv = TRUE , csv template called &quot;ExpDes.csv&quot; will be written to your working directory.  you will fill this in manually, ensuring that when you save you retain csv format.  ramclustR will then read this file in and and format appropriately.  If csv = FALSE, a pop up window will appear (in windows, at least) asking for input.  If a character string with full path (and file name) to a csv file is given, this will allow you to read in a previously edited csv file.</p>
</td></tr>
<tr><td><code id="defineExperiment_+3A_force.skip">force.skip</code></td>
<td>
<p>logical.  If TRUE, ramclustR creates a pseudo-filled ExpDes object to enable testing of functionality. Not recommended for real data, as your exported spectra will be improperly labelled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an Exp Des R object which will be used for record keeping and writing spectra data.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='do.findmain'>do.findmain</h2><span id='topic+do.findmain'></span>

<h3>Description</h3>

<p>Cluster annotation function: inference of 'M' - molecular weight of the compound giving rise to each spectrum - using the InterpretMSSpectrum::findMain function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.findmain(
  ramclustObj = NULL,
  cmpd = NULL,
  mode = "positive",
  mzabs.error = 0.005,
  ppm.error = 10,
  ads = NULL,
  nls = NULL,
  scoring = "auto",
  plot.findmain = TRUE,
  writeMat = TRUE,
  writeMS = TRUE,
  use.z = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do.findmain_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to annotate.</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_cmpd">cmpd</code></td>
<td>
<p>integer: vector defining compound numbers to annotated.  if NULL (default), all compounds</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_mode">mode</code></td>
<td>
<p>character: &quot;positive&quot; or &quot;negative&quot;</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_mzabs.error">mzabs.error</code></td>
<td>
<p>numeric: absolute mass deviation allowd, default = 0.01</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_ppm.error">ppm.error</code></td>
<td>
<p>numeric: ppm mass error _added_ to mzabs.error, default = 10</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_ads">ads</code></td>
<td>
<p>character: vector of allowed adducts, i.e. c(&quot;[M+H]+&quot;). if NULL, default positive mode values of H+, Na+, K+, and NH4+, as monomer, dimer, and trimer, are assigned. Negative mode include &quot;[M-H]-&quot;, &quot;[M+Na-2H]-&quot;, &quot;[M+K-2H]-&quot;, &quot;[M+CH2O2-H]-&quot; as monomer, dimer, and trimer.</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_nls">nls</code></td>
<td>
<p>character: vector of allowed neutral losses, i.e. c(&quot;[M+H-H2O]+&quot;).  if NULL, an extensive list derived from CAMERA's will be used.</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_scoring">scoring</code></td>
<td>
<p>character: one of 'imss' , 'ramclustr', or 'auto'. default = 'auto'. see details.</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_plot.findmain">plot.findmain</code></td>
<td>
<p>logical: should pdf polts be generated for evaluation? detfault = TRUE. PDF saved to working.directory/spectra</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_writemat">writeMat</code></td>
<td>
<p>logical: should individual .mat files (for MSFinder) be generated in a 'mat' subdirectory in the 'spectra' folder? default = TRUE.</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_writems">writeMS</code></td>
<td>
<p>logical: should individual .ms files (for Sirius) be generated in a 'ms' subdirectory in the 'spectra' folder? default = TRUE.  Note that no import functions are yet written for Sirius output.</p>
</td></tr>
<tr><td><code id="do.findmain_+3A_use.z">use.z</code></td>
<td>
<p>logical: if you have previously run the 'assign.z' function from ramclustR, there will be a slot reflecting the feature mass after accounting for charge (fm) - if TRUE this is used instead of feature m/z (fmz) in interpreting MS data and exporting spectra for annotation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a partially annotated ramclustR object.  base structure is that of a standard R heirarchical clustering output, with additional slots described in ramclustR documentation (?ramclustR).  New slots added after using the interpretMSSpectrum functionality include those described below.
</p>


<h3>Value</h3>

<p>$M:  The inferred molecular weight of the compound giving rise to the each spectrum
</p>
<p>$M.ppm:  The ppm error of all the MS signals annotated, high error values should be considered 'red flags'.
</p>
<p>$M.ann:  The annotated spectrum supporting the interpretation of M
</p>
<p>$use.findmain:  Logical vector indicating whether findmain scoring (TRUE) or ramclustR scoring (FALSE) was used to support inference of M.  By default, findmain scoring is used.  When ramclustR scoring differs from findmain scoring, the scoring metric which predicts higher M is selected.
</p>
<p>$M.ramclustr:  M selected using ramclustR scoring
</p>
<p>$M.ppm.ramclustr:  ppm error of M selected using ramclustR scoring. Used to resolve concflicts between ramclustR and findmain M assignment when scoring = auto.
</p>
<p>$M.ann.ramclustr:  annotated spectrum supporting M using ramclustR scoring
</p>
<p>$M.nann.ramclustr:  number of masses annotated using ramclustR scoring. Used to resolve concflicts between ramclustR and findmain M assignment when scoring = auto.
</p>
<p>$M.space.ramclustr:  the 'space' of scores between the best and second best ramclustR scores. Calculated as a ratio. Used to resolve concflicts between ramclustR and findmain M assignment when scoring = auto.
</p>
<p>$M.findmain:  M selected using findmain scoring
</p>
<p>$M.ppm.findmain:  ppm error of M selected using findmain scoring. Used to resolve concflicts between ramclustR and findmain M assignment when scoring = auto.
</p>
<p>$M.ann.findmain:  annotated spectrum supporting M using findmain scoring
</p>
<p>$M.nann.findmain:  number of masses annotated using findmain scoring. Used to resolve concflicts between ramclustR and findmain M assignment when scoring = auto.
</p>
<p>$M.space.findmain:  the 'space' of scores between the best and second best findmain scores. Calculated as a ratio. Used to resolve concflicts between ramclustR and findmain M assignment when scoring = auto.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Jaeger C, ... Lisec J. Compound annotation in liquid chromatography/high-resolution mass spectrometry based metabolomics: robust adduct ion determination as a prerequisite to structure prediction in electrospray ionization mass spectra. Rapid Commun Mass Spectrom. 2017 Aug 15;31(15):1261-1266. doi: 10.1002/rcm.7905. PubMed PMID: 28499062.
</p>
<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='export.msfinder.formulas'>export MSFinder formula prediction results in tabular format.</h2><span id='topic+export.msfinder.formulas'></span>

<h3>Description</h3>

<p>After running MSFinder, results have been imported to the ramclustR object.  This function exports as a .csv file for ease of viewing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.msfinder.formulas(
  ramclustObj = NULL,
  export.all = FALSE,
  output.directory = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export.msfinder.formulas_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object - the ramclustR object which was used to write the .mat or .msp files</p>
</td></tr>
<tr><td><code id="export.msfinder.formulas_+3A_export.all">export.all</code></td>
<td>
<p>logical: default = FALSE.  If TRUE, export all columns, if FALSE, only columns 1: &quot;exactmass&quot;</p>
</td></tr>
<tr><td><code id="export.msfinder.formulas_+3A_output.directory">output.directory</code></td>
<td>
<p>valid path: default = NULL.  If NULL, results are exported to spectra/mat directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function exports a .csv file containing all returned MSFinder molecular formula hypotheses. this file is saved (by default) to the working directory spectra/mat/ directory
</p>


<h3>Value</h3>

<p>an updated ramclustR object, with the RC$ann and RC$ann.conf slots updated to annotated based on output from 1. ramsearch output, 2. msfinder mssearch, 3. msfinder predicted structure, 4. msfinder predicted formula, and 5. interpretMSSpectrum inferred molecular weight, with listed order as priority.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>
<p>Tsugawa H, Kind T, Nakabayashi R, Yukihira D, Tanaka W, Cajka T, Saito K, Fiehn O, Arita M. Hydrogen Rearrangement Rules: Computational MS/MS Fragmentation and Structure Elucidation Using MS-FINDER Software. Anal Chem. 2016 Aug 16;88(16):7946-58. doi: 10.1021/acs.analchem.6b00770. Epub 2016 Aug 4. PubMed PMID: 27419259.
</p>

<hr>
<h2 id='exportDataset'>exportDataset</h2><span id='topic+exportDataset'></span>

<h3>Description</h3>

<p>export one of 'SpecAbund', 'SpecAbundAve', 'MSdata' or 'MSMSdata' from an RC object to csv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportDataset(
  ramclustObj = NULL,
  which.data = "SpecAbund",
  label.by = "ann",
  appendFactors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportDataset_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to export from</p>
</td></tr>
<tr><td><code id="exportDataset_+3A_which.data">which.data</code></td>
<td>
<p>name of dataset to export.  SpecAbund, SpecAbundAve, MSdata, or MSMSdata</p>
</td></tr>
<tr><td><code id="exportDataset_+3A_label.by">label.by</code></td>
<td>
<p>either 'ann' or 'cmpd', generally.  name of ramclustObj slot used as csv header for each column (compound)</p>
</td></tr>
<tr><td><code id="exportDataset_+3A_appendfactors">appendFactors</code></td>
<td>
<p>logical.  If TRUE (default) the factor data frame is appended to the left side of the dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful for exporting the processed signal intensity matrix to csv for analysis elsewhere.
</p>


<h3>Value</h3>

<p>nothing is returned.  file exported as csf to 'datasets/*.csv'
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='filter_blanks'>filter_blanks</h2><span id='topic+filter_blanks'></span>

<h3>Description</h3>

<p>filter blanks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_blanks(ramclustObj, keep, d1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_blanks_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="filter_blanks_+3A_keep">keep</code></td>
<td>
<p>union of which signal is at least 3x larger, output of filter_signal()</p>
</td></tr>
<tr><td><code id="filter_blanks_+3A_d1">d1</code></td>
<td>
<p>MS Data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ramclustObj object with feature.filter.blanks
</p>

<hr>
<h2 id='filter_good_features'>filter_good_features</h2><span id='topic+filter_good_features'></span>

<h3>Description</h3>

<p>filter to keep only 'good' features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_good_features(ramclustObj, keep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_good_features_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="filter_good_features_+3A_keep">keep</code></td>
<td>
<p>features to keep. output of find_good_features().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ramclustR object filtered to keep only 'good' features
</p>

<hr>
<h2 id='filter_signal'>filter_signal</h2><span id='topic+filter_signal'></span>

<h3>Description</h3>

<p>filter signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_signal(ms.qc.mean, ms.blank.mean, sn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_signal_+3A_ms.qc.mean">ms.qc.mean</code></td>
<td>
<p>ms qc mean signal intensities</p>
</td></tr>
<tr><td><code id="filter_signal_+3A_ms.blank.mean">ms.blank.mean</code></td>
<td>
<p>ms blank mean signal intensities</p>
</td></tr>
<tr><td><code id="filter_signal_+3A_sn">sn</code></td>
<td>
<p>numeric defines the ratio for 'signal'.  i.e. sn = 3 indicates that signal intensity must be 3 fold higher in sample than in blanks, on average, to be retained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>union of which signal is at least 3x larger
</p>

<hr>
<h2 id='find_good_features'>find_good_features</h2><span id='topic+find_good_features'></span>

<h3>Description</h3>

<p>find 'good' features, acceptable CV at either MS or MSMS level results in keeping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_good_features(ramclustObj, do.sets, max.cv, qc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_good_features_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="find_good_features_+3A_do.sets">do.sets</code></td>
<td>
<p>select data frame to use.</p>
</td></tr>
<tr><td><code id="find_good_features_+3A_max.cv">max.cv</code></td>
<td>
<p>numeric maximum allowable cv for any feature.  default = 0.5</p>
</td></tr>
<tr><td><code id="find_good_features_+3A_qc">qc</code></td>
<td>
<p>QC samples found by define_samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ramclustR object
</p>
<p>features to keep
</p>

<hr>
<h2 id='findfeature'>findfeature</h2><span id='topic+findfeature'></span>

<h3>Description</h3>

<p>see if any features match a given mass, and whether they are plausibly M0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findfeature(
  ramclustObj = NULL,
  mz = NULL,
  mztol = 0.02,
  rt = NULL,
  rttol = 2,
  iso.rttol = 2,
  zmax = 6,
  m.check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findfeature_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object: the ramclustR object to explore</p>
</td></tr>
<tr><td><code id="findfeature_+3A_mz">mz</code></td>
<td>
<p>numeric: mz value to search for</p>
</td></tr>
<tr><td><code id="findfeature_+3A_mztol">mztol</code></td>
<td>
<p>numeric: absolute mass tolerance around mz</p>
</td></tr>
<tr><td><code id="findfeature_+3A_rt">rt</code></td>
<td>
<p>numeric: optional rt value to search for (generally in seconds, though use whatever units your data is in)</p>
</td></tr>
<tr><td><code id="findfeature_+3A_rttol">rttol</code></td>
<td>
<p>numeric: absolute retention time tolerance around rt.</p>
</td></tr>
<tr><td><code id="findfeature_+3A_iso.rttol">iso.rttol</code></td>
<td>
<p>numeric: when examining isotope patterns, feature retention time tolerance around features matching mz +- mztol</p>
</td></tr>
<tr><td><code id="findfeature_+3A_zmax">zmax</code></td>
<td>
<p>integer: maximum charge state to consider.  default is 6.</p>
</td></tr>
<tr><td><code id="findfeature_+3A_m.check">m.check</code></td>
<td>
<p>logical:  check whether the matching masses are plausibly M0.  That is, we look for ions 1 proton mass (from charge state 1:zmax) below the target m/z at the same time that have intensities consistent with target ion being a non-M0 isotope.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a convenience function to perform a targeted search of all features for a mass of interest.  Also performs a crude plausibility check as to whether the matched feature could be M0, based on the assumption of approximately 1 carbon per 17 m/z units and natural isotopic abundance of 1.1
</p>


<h3>Value</h3>

<p>returns a table to the console listing masses which match, their retention time and intensity, and whether it appears to be plausible as M0
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>

<hr>
<h2 id='findmass'>findmass</h2><span id='topic+findmass'></span>

<h3>Description</h3>

<p>see if any features match a given mass, and whether they are plausibly M0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findmass(
  ramclustObj = NULL,
  mz = NULL,
  mztol = 0.02,
  rttol = 2,
  zmax = 6,
  m.check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findmass_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object: the ramclustR object to explore</p>
</td></tr>
<tr><td><code id="findmass_+3A_mz">mz</code></td>
<td>
<p>numeric: mz value to search for</p>
</td></tr>
<tr><td><code id="findmass_+3A_mztol">mztol</code></td>
<td>
<p>numeric: absolute mass tolerance around mz</p>
</td></tr>
<tr><td><code id="findmass_+3A_rttol">rttol</code></td>
<td>
<p>numeric: when examining isotope patterns, feature retention time tolerance around features matching mz +- mztol</p>
</td></tr>
<tr><td><code id="findmass_+3A_zmax">zmax</code></td>
<td>
<p>integer: maximum charge state to consider.  default is 6.</p>
</td></tr>
<tr><td><code id="findmass_+3A_m.check">m.check</code></td>
<td>
<p>logical:  check whether the matching masses are plausibly M0.  That is, we look for ions 1 proton mass (from charge state 1:zmax) below the target m/z at the same time that have intensities consistent with target ion being a non-M0 isotope.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a convenience function to perform a targeted search of all feaures for a mass of interest.  Also performs a crude plausibility check as to whether the matched feature could be M0, based on the assumption of approximately 1 carbon per 17 m/z units and natural isotopic abundance of 1.1
</p>


<h3>Value</h3>

<p>returns a table to the console listing masses which match, their retention time and intensity, and whether it appears to be plausible as M0
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>

<hr>
<h2 id='fooddb2msfinder'>foodb2msfinder</h2><span id='topic+fooddb2msfinder'></span>

<h3>Description</h3>

<p>convenience function for converting FoodDB database export format to MSFinder custom database import format. Before running this, please have downloaded .csv files from FoodDB with the appropriate Display Field Headers (see details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fooddb2msfinder(
  foodb.files = NULL,
  out.dir = NULL,
  out.name = "FoodDB_for_MSFinder.txt"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fooddb2msfinder_+3A_foodb.files">foodb.files</code></td>
<td>
<p>default = NULL, if path is set, will read automatically.  If NULL, direcory selection by user.</p>
</td></tr>
<tr><td><code id="fooddb2msfinder_+3A_out.dir">out.dir</code></td>
<td>
<p>default = NULL.  Can set to exiseting directory with full path name.  If NULL, direcory selection by user.</p>
</td></tr>
<tr><td><code id="fooddb2msfinder_+3A_out.name">out.name</code></td>
<td>
<p>default = &quot;FoodDB_for_MSFinder.txt&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input file(s) should be csv formatted, with required headers of 'Name',	'Smiles',	'Inchikey',	'Chemical formula', and 'Mono mass' - case sensitive.  Output will be in tab delimited text format in directory of choice.
</p>


<h3>Value</h3>

<p>Nothing is returned - output file written to directory set by 'out.dir' and name set by 'out.name'
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='get_ExpDes'>get_ExpDes</h2><span id='topic+get_ExpDes'></span>

<h3>Description</h3>

<p>get Experimental Design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ExpDes(csv.in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ExpDes_+3A_csv.in">csv.in</code></td>
<td>
<p>Experimental Design read from csv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing design and instrument
</p>

<hr>
<h2 id='get_instrument_platform'>get_instrument_platform</h2><span id='topic+get_instrument_platform'></span>

<h3>Description</h3>

<p>get instrument platform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_instrument_platform(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_instrument_platform_+3A_design">design</code></td>
<td>
<p>data frame containing Experimental Design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>instrument platform
</p>

<hr>
<h2 id='get.taxon.cids'>get.taxon.cids</h2><span id='topic+get.taxon.cids'></span>

<h3>Description</h3>

<p>use pubchem rest to retreive pubchem CIDS known to be found in a given species.  NCBI taxid should be used as input.  i.e. Homo sapiens subsp. 'Denisova' is taxid 741158
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.taxon.cids(
  taxid = NULL,
  taxstring = NULL,
  sub.taxa.n = 1000,
  get.inchikey = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.taxon.cids_+3A_taxid">taxid</code></td>
<td>
<p>integer NCBI taxid for the taxon to search.</p>
</td></tr>
<tr><td><code id="get.taxon.cids_+3A_taxstring">taxstring</code></td>
<td>
<p>taxonomy string for the taxon of interest.</p>
</td></tr>
<tr><td><code id="get.taxon.cids_+3A_sub.taxa.n">sub.taxa.n</code></td>
<td>
<p>integer value for the number of subtaxa to consider.  Note that if the sub.taxa.n value is less the the availabe number of subtaxa, only the first sub.taxa.n values, as reported by rentrez, are returned.  If you require specific subtaxa, you should call those taxids explicitly to ensure those results are returned.</p>
</td></tr>
<tr><td><code id="get.taxon.cids_+3A_get.inchikey">get.inchikey</code></td>
<td>
<p>logical whether to get the InChIKeys as well (default TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function enables return of a list of pubchem CIDs which can be used for prioritizing annotations.  If a genus level taxid is selected, setting the sub.taxa.n option &gt; 0 will return metabolites associated with that taxid and all (assuming n is large enough) subtaxa.  i.e. seting taxid to 9605 (genus = 'Homo') will return metabolites associated with Homo sapiens, Homo heidelbergensis, Homo sapiens subsp. 'Denisova', etc.
</p>


<h3>Value</h3>

<p>returns a vector of integer pubchem cids (and optionally inchikeys if get.inchikey was set to TRUE)
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>

<hr>
<h2 id='getData'>getData</h2><span id='topic+getData'></span>

<h3>Description</h3>

<p>retrieve and parse sample names, retrieve metabolite data.  returns as list of two data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getData(
  ramclustObj = NULL,
  which.data = "SpecAbund",
  delim = "-",
  cmpdlabel = "cmpd",
  filter = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getData_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to retrieve data from</p>
</td></tr>
<tr><td><code id="getData_+3A_which.data">which.data</code></td>
<td>
<p>character; which dataset (SpecAbund or SpecAbundAve) to reference</p>
</td></tr>
<tr><td><code id="getData_+3A_delim">delim</code></td>
<td>
<p>character; &quot;-&quot; by default - the delimiter for parsing sample names to factors</p>
</td></tr>
<tr><td><code id="getData_+3A_cmpdlabel">cmpdlabel</code></td>
<td>
<p>= &quot;cmpd&quot;;  label the data with the annotation. can also be set to 'ann' for column names assigned as annotatins.</p>
</td></tr>
<tr><td><code id="getData_+3A_filter">filter</code></td>
<td>
<p>= TRUE; logical, if TRUE, checks for $cmpd.use slot generated by rc.cmpd.cv.filter() function, and only gets acceptable compounds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>convenience function for parsing sample names and returning a dataset.
</p>


<h3>Value</h3>

<p>returns a list of length 3: $design is the experimental sample factors after parsing by the delim, $data is the dataset, $full.data is merged $des and $data data.frames.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>

<hr>
<h2 id='getSmilesInchi'>getSmilesInchi</h2><span id='topic+getSmilesInchi'></span>

<h3>Description</h3>

<p>use PubChem API to look up full smiles and inchi notation for each inchikey
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSmilesInchi(ramclustObj = NULL, inchikey = NULL, ignore.stereo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSmilesInchi_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to look up smiles and inchi for each inchikey (without a smiles/inchi). Must provide one of ramclustObj or inchikey.</p>
</td></tr>
<tr><td><code id="getSmilesInchi_+3A_inchikey">inchikey</code></td>
<td>
<p>character vector of inchikey strings.  Must provide one of ramclustObj or inchikey.</p>
</td></tr>
<tr><td><code id="getSmilesInchi_+3A_ignore.stereo">ignore.stereo</code></td>
<td>
<p>logical.  default = TRUE. If the Pubchem databases does not have the full inchikey string, should we search by the first (non-stereo) block of the inchikey?  When true, returns the first pubchem match to the inchikey block one string.  If the full inchikey is present, that is used preferentially.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The $inchikey slot is used to look up parameters from pubchem. PubChem CID, a pubchem URL, smiles (canonical) and inchi are returned.  if smiles and inchi slots are alread present (from MSFinder, for example) pubchem smiles and inchi are used to fill in missing values only, not replace.
</p>


<h3>Value</h3>

<p>returns a ramclustR object.  new vector of $smiles and $inchi with length equal to number of compounds.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Kim S, Thiessen PA, Bolton EE, Bryant SH. PUG-SOAP and PUG-REST: web services for programmatic access to chemical information in PubChem. Nucleic Acids Res. 2015;43(W1):W605-11.
</p>

<hr>
<h2 id='import.adap.kdb'>import.adap.kdb</h2><span id='topic+import.adap.kdb'></span>

<h3>Description</h3>

<p>use pubchem rest and view APIs to retrieve structures, CIDs (if a name or inchikey is given), synonyms, and optionally vendor data, when available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.adap.kdb(
  ramclustObj = NULL,
  annotations = NULL,
  min.score = 700,
  annotate = TRUE,
  manual.name = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import.adap.kdb_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to be annotated.</p>
</td></tr>
<tr><td><code id="import.adap.kdb_+3A_annotations">annotations</code></td>
<td>
<p>file name/path to annotations .xlsx file.  generally 'simple_export.xlsx'</p>
</td></tr>
<tr><td><code id="import.adap.kdb_+3A_min.score">min.score</code></td>
<td>
<p>700 (out of 1000) by default</p>
</td></tr>
<tr><td><code id="import.adap.kdb_+3A_annotate">annotate</code></td>
<td>
<p>logical.  TRUE by default.  for now please leave default</p>
</td></tr>
<tr><td><code id="import.adap.kdb_+3A_manual.name">manual.name</code></td>
<td>
<p>when looking up inchikey/names, should manual input be used to fill ambiguous names? generally recommend TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>useful for moving from chemical name to digital structure representation. greek letters are assumed to be 'UTF-8' encoded, and are converted to latin text before searching.   if you are reading in your compound name list, do so with 'encoding' set to 'UTF-8'.
</p>


<h3>Value</h3>

<p>returns a ramclustR structured object suitable for down stream processing steps.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>

<hr>
<h2 id='import.msfinder.formulas'>import.msfinder.formulas</h2><span id='topic+import.msfinder.formulas'></span>

<h3>Description</h3>

<p>After running MSFinder on .mat or .msp files, import the formulas that were predicted and their scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.msfinder.formulas(ramclustObj = NULL, mat.dir = NULL, msp.dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import.msfinder.formulas_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object - the ramclustR object which was used to write the .mat or .msp files</p>
</td></tr>
<tr><td><code id="import.msfinder.formulas_+3A_mat.dir">mat.dir</code></td>
<td>
<p>optional path to .mat directory</p>
</td></tr>
<tr><td><code id="import.msfinder.formulas_+3A_msp.dir">msp.dir</code></td>
<td>
<p>optional path to .msp directory</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function imports the output from the MSFinder program to support annotation of the ramclustR object
</p>


<h3>Value</h3>

<p>new slot at $msfinder.formula.details
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>
<p>Tsugawa H, Kind T, Nakabayashi R, Yukihira D, Tanaka W, Cajka T, Saito K, Fiehn O, Arita M. Hydrogen Rearrangement Rules: Computational MS/MS Fragmentation and Structure Elucidation Using MS-FINDER Software. Anal Chem. 2016 Aug 16;88(16):7946-58. doi: 10.1021/acs.analchem.6b00770. Epub 2016 Aug 4. PubMed PMID: 27419259.
</p>

<hr>
<h2 id='import.msfinder.mssearch'>import.MSFinder.mssearch</h2><span id='topic+import.msfinder.mssearch'></span>

<h3>Description</h3>

<p>After running MSFinder on .mat or .msp files, import the spectral search results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.msfinder.mssearch(
  ramclustObj = NULL,
  mat.dir = NULL,
  msp.dir = NULL,
  dir.extension = ".mssearch"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import.msfinder.mssearch_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object - the ramclustR object which was used to write the .mat or .msp files</p>
</td></tr>
<tr><td><code id="import.msfinder.mssearch_+3A_mat.dir">mat.dir</code></td>
<td>
<p>optional path to .mat directory</p>
</td></tr>
<tr><td><code id="import.msfinder.mssearch_+3A_msp.dir">msp.dir</code></td>
<td>
<p>optional path to .msp directory</p>
</td></tr>
<tr><td><code id="import.msfinder.mssearch_+3A_dir.extension">dir.extension</code></td>
<td>
<p>optional directory name code specifying subset of results to use.  Useful if running MSFinder from the command line for both spectral searching and interpretation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function imports the output from the MSFinder program to annotate the ramclustR object
</p>


<h3>Value</h3>

<p>an updated ramclustR object, with new slots at $msfinder.mssearch.details and $msfinder.mssearch.scores
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>
<p>Tsugawa H, Kind T, Nakabayashi R, Yukihira D, Tanaka W, Cajka T, Saito K, Fiehn O, Arita M. Hydrogen Rearrangement Rules: Computational MS/MS Fragmentation and Structure Elucidation Using MS-FINDER Software. Anal Chem. 2016 Aug 16;88(16):7946-58. doi: 10.1021/acs.analchem.6b00770. Epub 2016 Aug 4. PubMed PMID: 27419259.
</p>

<hr>
<h2 id='import.msfinder.structures'>write.methods</h2><span id='topic+import.msfinder.structures'></span>

<h3>Description</h3>

<p>write RAMClustR processing methods and citations to text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.msfinder.structures(ramclustObj = NULL, mat.dir = NULL, msp.dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import.msfinder.structures_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object - the ramclustR object which was used to write the .mat or .msp files</p>
</td></tr>
<tr><td><code id="import.msfinder.structures_+3A_mat.dir">mat.dir</code></td>
<td>
<p>directory in which to look for mat file MSFinder output - by default the /spectra/mat in the working directory</p>
</td></tr>
<tr><td><code id="import.msfinder.structures_+3A_msp.dir">msp.dir</code></td>
<td>
<p>directory in which to look for msp file MSFinder output - by default the /spectra/msp in the working directory</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function exports a file called ramclustr_methods.txt which contains the processing history, parameters used, and relevant citations.
</p>


<h3>Value</h3>

<p>an annotated ramclustR object
</p>
<p>nothing - new file written to working director
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='import.sirius'>import.sirius</h2><span id='topic+import.sirius'></span>

<h3>Description</h3>

<p>After running Sirius on .ms files, import the annotation results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.sirius(ramclustObj = NULL, ms.dir = NULL, ion.mode = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import.sirius_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object - the ramclustR object which was used to write the .mat or .msp files</p>
</td></tr>
<tr><td><code id="import.sirius_+3A_ms.dir">ms.dir</code></td>
<td>
<p>optional path to .mat directory. default = &quot;spectra/ms/out&quot; subdirectory in working directory</p>
</td></tr>
<tr><td><code id="import.sirius_+3A_ion.mode">ion.mode</code></td>
<td>
<p>specify either &quot;N&quot; for negative ionization mode or &quot;P&quot; for positive ionization mode</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function imports the output from the Sirius program to annotate the ramclustR object
</p>


<h3>Value</h3>

<p>an updated ramclustR object, with new slots at $msfinder.sirius
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='impRamSearch'>impRamSearch</h2><span id='topic+impRamSearch'></span>

<h3>Description</h3>

<p>import ramsearch output for annotating an RC object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impRamSearch(ramclustObj = NULL, ramsearchout = "spectra/results.rse")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impRamSearch_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to annotate</p>
</td></tr>
<tr><td><code id="impRamSearch_+3A_ramsearchout">ramsearchout</code></td>
<td>
<p>path to .rse file to import</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Annotation of ramclustR exported .msp spectra is accomplished using RAMSearch.  Exported ramsearch annotations (.rse) can be imported with this function
</p>


<h3>Value</h3>

<p>returns a ramclustR object.  new slots holding .rse data
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='manual.annotation.template'>manual.annotation.template</h2><span id='topic+manual.annotation.template'></span>

<h3>Description</h3>

<p>export a .csv formatted template for manually editing MSFinder annotations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manual.annotation.template(
  ramclustObj = NULL,
  outfile = "manual.annotation.template.csv"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manual.annotation.template_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to annotate</p>
</td></tr>
<tr><td><code id="manual.annotation.template_+3A_outfile">outfile</code></td>
<td>
<p>output file directory and name.  default = 'manual.annotation.template.csv'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While unsupervised annotation is rapid and objective, subjective knowledge can be used to improve annotations.  This function writes a template file containing compound name, computationally assigned inchikey, and an empty column for your manually inferred inchikey.  Upon completion of manual annotation, you can reimport this file and update your ramclustR object to reflect your manual input.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Tsugawa H, Kind T, Nakabayashi R, Yukihira D, Tanaka W, Cajka T, Saito K, Fiehn O, Arita M. Hydrogen Rearrangement Rules: Computational MS/MS Fragmentation and Structure Elucidation Using MS-FINDER Software. Anal Chem. 2016 Aug 16;88(16):7946-58. doi: 10.1021/acs.analchem.6b00770. Epub 2016 Aug 4. PubMed PMID: 27419259.
</p>

<hr>
<h2 id='mean_signal_intensities'>mean_signal_intensities</h2><span id='topic+mean_signal_intensities'></span>

<h3>Description</h3>

<p>calculate MS mean signal intensities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_signal_intensities(data, sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_signal_intensities_+3A_data">data</code></td>
<td>
<p>MS/MSMS data</p>
</td></tr>
<tr><td><code id="mean_signal_intensities_+3A_sample">sample</code></td>
<td>
<p>sample found using the tag, output of define_samples()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean signal intensities
</p>

<hr>
<h2 id='mergeRCobjects'>mergeRCobjects</h2><span id='topic+mergeRCobjects'></span>

<h3>Description</h3>

<p>merge two ramclustR objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeRCobjects(
  ramclustObj.1 = NULL,
  ramclustObj.2 = NULL,
  mztol = 0.02,
  rttol = 30,
  course.rt.adj = NULL,
  mzwt = 2,
  rtwt = 1,
  intwt = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeRCobjects_+3A_ramclustobj.1">ramclustObj.1</code></td>
<td>
<p>ramclustR object 1: this object will be the base for the new object.  That is all the features from ramclustObj.1 will be retained.</p>
</td></tr>
<tr><td><code id="mergeRCobjects_+3A_ramclustobj.2">ramclustObj.2</code></td>
<td>
<p>ramclustR object 2: this object will mapped and appended to racmlustObj1.  That is only features which appear consistent with those from ramclustObj.1 will be retained.</p>
</td></tr>
<tr><td><code id="mergeRCobjects_+3A_mztol">mztol</code></td>
<td>
<p>numeric: absolute mass tolerance around mz</p>
</td></tr>
<tr><td><code id="mergeRCobjects_+3A_rttol">rttol</code></td>
<td>
<p>numeric: feature retention time tolerance.  Value set by this option will be used during the initial anchor mapping phase.  Two times the standard error of the rt loess correction will be used for the full mapping.</p>
</td></tr>
<tr><td><code id="mergeRCobjects_+3A_course.rt.adj">course.rt.adj</code></td>
<td>
<p>numeric: default = NULL. optional approximate retention time shift between ramclustObj.1 and ramclustObj.2.  i.e if the retention time of ramclustObj.1 is on average 15 seconds longer than that of ramclustobj.2, enter '15'.  if 1 is less than 2, enter a negative number.  This is applied before mapping to enable a smaller 'rttol' value to be used.</p>
</td></tr>
<tr><td><code id="mergeRCobjects_+3A_mzwt">mzwt</code></td>
<td>
<p>numeric: when mapping features, weighting value used for similarities between feature mass values (see rtwt, intwt)</p>
</td></tr>
<tr><td><code id="mergeRCobjects_+3A_rtwt">rtwt</code></td>
<td>
<p>numeric: when mapping features, weighting value used for similarities between feature retention time values (see mzwt, intwt)</p>
</td></tr>
<tr><td><code id="mergeRCobjects_+3A_intwt">intwt</code></td>
<td>
<p>numeric: when mapping features, weighting value used for similarities between ranked signal intensity values (see rtwt, mzwt)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two ramclustR objects are merged with this function, mapping features between them.  The first (ramclustObj.1) object use used as the template - all data in it is retained.  ramclustObj.2 is mapped to ramclustObj.1 feature by feature - only mapped features are retained.  A new ramlcustObj is returned, with a new SpecAbund dataset with the same column number as the ramclustObj.1$SpecAbund set.
</p>


<h3>Value</h3>

<p>returns a ramclustR object.  All values from ramclustObj.1 are retained.  SpecAbund dataset from ramclustObj.1 is moved to RC$SpecAbund.1, where RC is the new ramclustObj.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>

<hr>
<h2 id='normalized_data_batch_qc'>normalized_data_batch_qc</h2><span id='topic+normalized_data_batch_qc'></span>

<h3>Description</h3>

<p>normalize data using batch.qc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalized_data_batch_qc(
  data = NULL,
  batch = NULL,
  order = NULL,
  qc = NULL,
  qc.inj.range = 20,
  output.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalized_data_batch_qc_+3A_data">data</code></td>
<td>
<p>feature in ms/msms level data</p>
</td></tr>
<tr><td><code id="normalized_data_batch_qc_+3A_batch">batch</code></td>
<td>
<p>integer vector with length equal to number of injections in xset or csv file or dataframe</p>
</td></tr>
<tr><td><code id="normalized_data_batch_qc_+3A_order">order</code></td>
<td>
<p>integer vector with length equal to number of injections in xset or csv file or dataframe</p>
</td></tr>
<tr><td><code id="normalized_data_batch_qc_+3A_qc">qc</code></td>
<td>
<p>logical vector with length equal to number of injections in xset or csv file or dataframe</p>
</td></tr>
<tr><td><code id="normalized_data_batch_qc_+3A_qc.inj.range">qc.inj.range</code></td>
<td>
<p>integer: how many injections around each injection are to be scanned for presence of QC samples when using batch.qc normalization?  A good rule of thumb is between 1 and 3 times the typical injection span between QC injections.  i.e. if you inject QC ever 7 samples, set this to between 7 and 21.  smaller values provide more local precision but make normalization sensitive to individual poor outliers (though these are first removed using the boxplot function outlier detection), while wider values provide less local precision in normalization but better stability to individual peak areas.</p>
</td></tr>
<tr><td><code id="normalized_data_batch_qc_+3A_output.plot">output.plot</code></td>
<td>
<p>logical set to TRUE to store plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalized data.
</p>

<hr>
<h2 id='normalized_data_tic'>normalized_data_tic</h2><span id='topic+normalized_data_tic'></span>

<h3>Description</h3>

<p>normalize data using TIC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalized_data_tic(ramclustObj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalized_data_tic_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ramclustR object with total extracted ion normalized data.
</p>

<hr>
<h2 id='order_datasets'>order_datasets</h2><span id='topic+order_datasets'></span>

<h3>Description</h3>

<p>order the datasets first by batch and run order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_datasets(order = NULL, batch = NULL, qc = NULL, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_datasets_+3A_order">order</code></td>
<td>
<p>integer vector with length equal to number of injections in xset or csv file or dataframe</p>
</td></tr>
<tr><td><code id="order_datasets_+3A_batch">batch</code></td>
<td>
<p>integer vector with length equal to number of injections in xset or csv file or dataframe</p>
</td></tr>
<tr><td><code id="order_datasets_+3A_qc">qc</code></td>
<td>
<p>logical vector with length equal to number of injections in xset or csv file or dataframe</p>
</td></tr>
<tr><td><code id="order_datasets_+3A_data">data</code></td>
<td>
<p>feature in ms/msms level data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ordered feature in ms/msms level data, order, batch, qc
</p>

<hr>
<h2 id='ramclustR'>ramclustR</h2><span id='topic+ramclustR'></span>

<h3>Description</h3>

<p>Main clustering function for grouping features based on their analytical behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ramclustR(
  xcmsObj = NULL,
  ms = NULL,
  pheno_csv = NULL,
  idmsms = NULL,
  taglocation = "filepaths",
  MStag = NULL,
  idMSMStag = NULL,
  featdelim = "_",
  timepos = 2,
  st = NULL,
  sr = NULL,
  maxt = NULL,
  deepSplit = FALSE,
  blocksize = 2000,
  mult = 5,
  hmax = NULL,
  sampNameCol = 1,
  collapse = TRUE,
  mspout = TRUE,
  ExpDes = NULL,
  normalize = "TIC",
  qc.inj.range = 20,
  order = NULL,
  batch = NULL,
  qc = NULL,
  minModuleSize = 2,
  linkage = "average",
  mzdec = 3,
  cor.method = "pearson",
  rt.only.low.n = TRUE,
  replace.zeros = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ramclustR_+3A_xcmsobj">xcmsObj</code></td>
<td>
<p>xcmsObject: containing grouped feature data for clustering by ramclustR</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_ms">ms</code></td>
<td>
<p>filepath: optional csv input. Features as columns, rows as samples. Column header mz_rt</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_pheno_csv">pheno_csv</code></td>
<td>
<p>filepath: optional csv input containing phenoData</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_idmsms">idmsms</code></td>
<td>
<p>filepath: optional idMSMS / MSe csv data.  same dim and names as ms required</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_taglocation">taglocation</code></td>
<td>
<p>character: &quot;filepaths&quot; by default, &quot;phenoData[,1]&quot; is another option. refers to xcms slot</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_mstag">MStag</code></td>
<td>
<p>character: character string in 'taglocation' to designat MS / MSe files e.g. &quot;01.cdf&quot;</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_idmsmstag">idMSMStag</code></td>
<td>
<p>character: character string in 'taglocation' to designat idMSMS / MSe files e.g. &quot;02.cdf&quot;</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_featdelim">featdelim</code></td>
<td>
<p>character: how feature mz and rt are delimited in csv import column header e.g. =&quot;-&quot;</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_timepos">timepos</code></td>
<td>
<p>integer: which position in delimited column header represents the retention time (csv only)</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_st">st</code></td>
<td>
<p>numeric: sigma t - time similarity decay value</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_sr">sr</code></td>
<td>
<p>numeric: sigma r - correlational similarity decay value</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_maxt">maxt</code></td>
<td>
<p>numeric: maximum time difference to calculate retention similarity for - all values beyond this are assigned similarity of zero</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_deepsplit">deepSplit</code></td>
<td>
<p>logical: controls how agressively the HCA tree is cut - see ?cutreeDynamicTree</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_blocksize">blocksize</code></td>
<td>
<p>integer: number of features (scans?) processed in one block  =1000,</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_mult">mult</code></td>
<td>
<p>numeric: internal value, can be used to influence processing speed/ram usage</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_hmax">hmax</code></td>
<td>
<p>numeric: precut the tree at this height, default 0.3 - see ?cutreeDynamicTree</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_sampnamecol">sampNameCol</code></td>
<td>
<p>integer: which column from the csv file contains sample names?</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_collapse">collapse</code></td>
<td>
<p>logical: reduce feature intensities to spectrum intensities?</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_mspout">mspout</code></td>
<td>
<p>logical: write msp formatted spectra to file?</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_expdes">ExpDes</code></td>
<td>
<p>either an R object created by R ExpDes object: data used for record keeping and labelling msp spectral output</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_normalize">normalize</code></td>
<td>
<p>character: either &quot;none&quot;, &quot;TIC&quot;, &quot;quantile&quot;, or &quot;batch.qc&quot; normalization of feature intensities.  see batch.qc overview in details.</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_qc.inj.range">qc.inj.range</code></td>
<td>
<p>integer: how many injections around each injection are to be scanned for presence of QC samples when using batch.qc normalization?  A good rule of thumb is between 1 and 3 times the typical injection span between QC injections.  i.e. if you inject QC ever 7 samples, set this to between 7 and 21.  smaller values provide more local precision but make normalization sensitive to individual poor outliers (though these are first removed using the boxplot function outlier detection), while wider values provide less local precision in normalization but better stability to individual peak areas.</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_order">order</code></td>
<td>
<p>integer vector with length equal to number of injections in xset or csv file</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_batch">batch</code></td>
<td>
<p>integer vector with length equal to number of injections in xset or csv file</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_qc">qc</code></td>
<td>
<p>logical vector with length equal to number of injections in xset or csv file.</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_minmodulesize">minModuleSize</code></td>
<td>
<p>integer: how many features must be part of a cluster to be returned? default = 2</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_linkage">linkage</code></td>
<td>
<p>character: heirarchical clustering linkage method - see ?hclust</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_mzdec">mzdec</code></td>
<td>
<p>integer: number of decimal places used in printing m/z values</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_cor.method">cor.method</code></td>
<td>
<p>character: which correlational method used to calculate 'r' - see ?cor</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_rt.only.low.n">rt.only.low.n</code></td>
<td>
<p>logical: default = TRUE  At low injection numbers, correlational relationships of peak intensities may be unreliable.  by defualt ramclustR will simply ignore the correlational r value and cluster on retention time alone.  if you wish to use correlation with at n &lt; 5, set this value to FALSE.</p>
</td></tr>
<tr><td><code id="ramclustR_+3A_replace.zeros">replace.zeros</code></td>
<td>
<p>logical: TRUE by default.  NA, NaN, and Inf values are replaced with zero, and zero values are sometimes returned from peak peaking.  When TRUE, zero values will be replaced with a small amount of noise, with noise level set based on the detected signal intensities for that feature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Main clustering function output - see citation for algorithm description or vignette('RAMClustR') for a walk through.  batch.qc. normalization requires input of three vectors (1) batch (2) order (3) qc.   This is a feature centric normalization approach which adjusts signal intensities first by comparing batch median intensity of each feature (one feature at a time) QC signal intensity to full dataset median to correct for systematic batch effects and then secondly to apply a local QC median vs global median sample correction to correct for run order effects.
</p>


<h3>Value</h3>

<p>$featclus: integer vector of cluster membership for each feature
</p>
<p>$frt: feature retention time, in whatever units were fed in (xcms uses seconds, by default)
</p>
<p>$fmz: feature retention time, reported in number of decimal points selected in ramclustR function
</p>
<p>$xcmsOrd: the original XCMS (or csv) feature order for cross referencing, if need be
</p>
<p>$clrt: cluster retention time
</p>
<p>$clrtsd: retention time standard deviation of all the features that comprise that cluster
</p>
<p>$nfeat: number of features in the cluster
</p>
<p>$nsing: number of 'singletons' - that is the number of features which clustered with no other feature
</p>
<p>$ExpDes: the experimental design object used when running ramclustR.  List of two dataframes.
</p>
<p>$cmpd: compound name.  C#### are assigned in order of output by dynamicTreeCut.  Compound with the most features is classified as C0001...
</p>
<p>$ann: annotation.  By default, annotation names are identical to 'cmpd' names.  This slot is a placeholder for when annotations are provided
</p>
<p>$MSdata:  the MSdataset provided by either xcms or csv input
</p>
<p>$MSMSdata: the (optional) MSe/idMSMS dataset provided be either xcms or csv input
</p>
<p>$SpecAbund: the cluster intensities after collapsing features to clusters
</p>
<p>$SpecAbundAve: the cluster intensities after averaging all samples with identical sample names
</p>
<p>- 'spectra' directory is created in the working directory.  In this directory a .msp is (optionally) created, which contains the spectra for all compounds in the dataset following clustering.  if MSe/idMSMS data are provided, they are listed width he same compound name as the MS spectrum, with the collision energy provided in the ExpDes object provided to distinguish low from high CE spectra.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Choose input file with feature column names `mz_rt` (expected by default).
## Column with sample name is expected to be first (by default).
## These can be adjusted with the `featdelim` and `sampNameCol` parameters.
wd &lt;- getwd()
filename &lt;- system.file("extdata", "peaks.csv", package = "RAMClustR", mustWork = TRUE)
print(filename)
head(data.frame(read.csv(filename)), c(6L, 5L))

## If the file contains features from MS1, assign those to the `ms` parameter.
## If the file contains features from MS2, assign those to the `idmsms` parameter.
## If you ran `xcms` for the feature detection, the assign the output to the `xcmsObj` parameter.
## In this example we use a MS1 feature table stored in a `csv` file.
setwd(tempdir())
ramclustobj &lt;- ramclustR(ms = filename, st = 5, maxt = 1, blocksize = 1000)

## Investigate the deconvoluted features in the `spectra` folder in MSP format
## or inspect the `ramclustobj` for feature retention times, annotations etc.
print(ramclustobj$ann)
print(ramclustobj$nfeat)
print(ramclustobj$SpecAbund[, 1:6])
setwd(wd)

</code></pre>

<hr>
<h2 id='rc.calibrate.ri'>rc.calibrate.ri</h2><span id='topic+rc.calibrate.ri'></span>

<h3>Description</h3>

<p>extractor for xcms objects in preparation for clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.calibrate.ri(ramclustObj = NULL, calibrant.data = "", poly.order = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.calibrate.ri_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="rc.calibrate.ri_+3A_calibrant.data">calibrant.data</code></td>
<td>
<p>character vector defining the file path/name to a csv file containing columns including 'rt', and 'ri'.  Alternatively, a data.frame with those columnn names (case sensitive)</p>
</td></tr>
<tr><td><code id="rc.calibrate.ri_+3A_poly.order">poly.order</code></td>
<td>
<p>integer default = 3.  polynomical order used to fit rt vs ri data, and calculate ri for all feature and metabolite rt values. poly.order should be apprciably smaller than the number of calibrant points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a new slot in the ramclustR object for retention index.  Calibration is performed using a polynomial fit of order poly.order.  It is the user's responsibility to ensure that the number and span of calibrant points is sufficient to calibrate the full range of feature and compound retention times.  i.e. if the last calibration point is at 1000 seconds, but the last eluting peak is at 1300 seconds, the calibration will be very poor for the late eluting compound.
</p>


<h3>Value</h3>

<p>ramclustR object with retention index assigned for features ($fri) and compounds ($clri).
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='rc.cmpd.filter.blanks'>rc.cmpd.filter.blanks</h2><span id='topic+rc.cmpd.filter.blanks'></span>

<h3>Description</h3>

<p>used to remove compounds which are found at similar intensity in blank samples.  Only applied after clustering.  see also rc.feature.filter.blanks for filtering at the feature level (only done before clustering).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.cmpd.filter.blanks(
  ramclustObj = NULL,
  qc.tag = "QC",
  blank.tag = "blank",
  sn = 3,
  remove.blanks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.cmpd.filter.blanks_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing SpecAbund dataframe.</p>
</td></tr>
<tr><td><code id="rc.cmpd.filter.blanks_+3A_qc.tag">qc.tag</code></td>
<td>
<p>character vector of length one or two.  If length is two, enter search string and factor name in $phenoData slot (i.e. c(&quot;QC&quot;, &quot;sample.type&quot;). If length one (i.e. &quot;QC&quot;), will search for this string in the 'sample.names' slot by default.</p>
</td></tr>
<tr><td><code id="rc.cmpd.filter.blanks_+3A_blank.tag">blank.tag</code></td>
<td>
<p>see 'qc.tag' , but for blanks to use as background.</p>
</td></tr>
<tr><td><code id="rc.cmpd.filter.blanks_+3A_sn">sn</code></td>
<td>
<p>numeric defines the ratio for 'signal'.  i.e. sn = 3 indicates that signal intensity must be 3 fold higher in sample than in blanks, on average, to be retained.</p>
</td></tr>
<tr><td><code id="rc.cmpd.filter.blanks_+3A_remove.blanks">remove.blanks</code></td>
<td>
<p>logical. TRUE by default.  this removes any recognized blanks samples from the SpecAbund sets after they are used to filter contaminant compounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function removes compounds which contain signal in QC samples comparable to blanks.
</p>


<h3>Value</h3>

<p>ramclustR object with normalized data.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='rc.cmpd.filter.cv'>rc.cmpd.filter.cv</h2><span id='topic+rc.cmpd.filter.cv'></span>

<h3>Description</h3>

<p>extractor for xcms objects in preparation for clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.cmpd.filter.cv(ramclustObj = NULL, qc.tag = "QC", max.cv = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.cmpd.filter.cv_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="rc.cmpd.filter.cv_+3A_qc.tag">qc.tag</code></td>
<td>
<p>character vector of length one or two.  If length is two, enter search string and factor name in $phenoData slot (i.e. c(&quot;QC&quot;, &quot;sample.type&quot;). If length one (i.e. &quot;QC&quot;), will search for this string in the 'sample.names' slot by default.</p>
</td></tr>
<tr><td><code id="rc.cmpd.filter.cv_+3A_max.cv">max.cv</code></td>
<td>
<p>numeric maximum allowable cv for any feature.  default = 0.3</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers normalization by total extracted ion signal.  it is recommended to first run 'rc.feature.filter.blanks' to remove non-sample derived signal.
</p>


<h3>Value</h3>

<p>ramclustR object with total extracted ion normalized data.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='rc.cmpd.get.classyfire'>getClassyFire</h2><span id='topic+rc.cmpd.get.classyfire'></span>

<h3>Description</h3>

<p>use classyfire web API to look up full ClassyFire hirarchy for each inchikey
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.cmpd.get.classyfire(
  ramclustObj = NULL,
  inchikey = NULL,
  get.all = TRUE,
  max.wait = 10,
  posts.per.minute = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.cmpd.get.classyfire_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to ClassyFy.  Must supply one of either ramclustObj or inchikey (see below)</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.classyfire_+3A_inchikey">inchikey</code></td>
<td>
<p>vector of text inchikeys to ClassyFy.  Must supply one of either ramclustObj or inchikey.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.classyfire_+3A_get.all">get.all</code></td>
<td>
<p>logical; if TRUE, when inchikey classyfire lookup fails, submits for classyfication.  Can be slow. max.wait (below) sets max time to spend on each compound before moving on. default = FALSE.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.classyfire_+3A_max.wait">max.wait</code></td>
<td>
<p>numeric; maximum time (seconds) to wait per compound when 'get.all' = TRUE.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.classyfire_+3A_posts.per.minute">posts.per.minute</code></td>
<td>
<p>integer; a limit set when 'get.all' is true.  ClassyFire server accepts no more than 5 posts per minute when calculating new ClassyFire results.  Slows down submission process to keep server from denying access.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The $inchikey slot is used to look up the
</p>


<h3>Value</h3>

<p>returns a ramclustR object.  new dataframe in $classyfire slot with rows equal to number of compounds.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Djoumbou Feunang Y, Eisner R, Knox C, Chepelev L, Hastings J, Owen G, Fahy E, Steinbeck C, Subramanian S, Bolton E, Greiner R, and Wishart DS. ClassyFire: Automated Chemical Classification With A Comprehensive, Computable Taxonomy. Journal of Cheminformatics, 2016, 8:61. DOI: 10.1186/s13321-016-0174-y
</p>

<hr>
<h2 id='rc.cmpd.get.pubchem'>rc.cmpd.get.pubchem</h2><span id='topic+rc.cmpd.get.pubchem'></span>

<h3>Description</h3>

<p>use pubchem rest and view APIs to retrieve structures, CIDs (if a name or inchikey is given), synonyms, and optionally vendor data, when available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.cmpd.get.pubchem(
  ramclustObj = NULL,
  search.name = NULL,
  cmpd.names = NULL,
  cmpd.cid = NULL,
  cmpd.inchikey = NULL,
  cmpd.smiles = NULL,
  use.parent.cid = FALSE,
  manual.entry = FALSE,
  get.vendors = FALSE,
  priority.vendors = c("Sigma Aldrich", "Alfa Chemistry", "Acros Organics", "VWR",
    "Alfa Aesar", "molport", "Key Organics", "BLD Pharm"),
  get.properties = TRUE,
  all.props = FALSE,
  get.synonyms = TRUE,
  find.short.lipid.name = TRUE,
  find.short.synonym = TRUE,
  max.name.length = 30,
  assign.short.name = TRUE,
  get.bioassays = TRUE,
  get.pathways = TRUE,
  write.csv = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>RAMClust Object input.  if used, ramclustObj$CID, ramclustObj$inchikey, and ramclustObj$ann are used as input, in that order, and ramclustObj is returned with $pubchem slot appended.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_search.name">search.name</code></td>
<td>
<p>character.  optional name to assign to pubchem search to name output .csv files.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_cmpd.names">cmpd.names</code></td>
<td>
<p>character vector.  i.e. c(&quot;caffeine&quot;, &quot;theobromine&quot;, &quot;glucose&quot;)</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_cmpd.cid">cmpd.cid</code></td>
<td>
<p>numeric integer vector.  i.e. c(2519, 5429, 107526)</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_cmpd.inchikey">cmpd.inchikey</code></td>
<td>
<p>character vector.  i.e. c(&quot;RYYVLZVUVIJVGH-UHFFFAOYSA-N&quot;, &quot;YAPQBXQYLJRXSA-UHFFFAOYSA-N&quot;, &quot;GZCGUPFRVQAUEE-SLPGGIOYSA-N&quot;)</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_cmpd.smiles">cmpd.smiles</code></td>
<td>
<p>character vector.  i.e. c(&quot;CN1C=NC2=C1C(=O)N(C(=O)N2C)C&quot;, &quot;CN1C=NC2=C1C(=O)NC(=O)N2C&quot;)</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_use.parent.cid">use.parent.cid</code></td>
<td>
<p>logical.  If TRUE, the CID for each supplied name/inchikey is used to retrieve its parent CID (i.e. the parent of sodium palmitate is palmitic acid).  The parent CID is used to retrieve all other names, properties.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_manual.entry">manual.entry</code></td>
<td>
<p>logical.  if TRUE, user input is enabled for compounds not matched by name. A browser window will open with the pubchem search results in your default browser.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_get.vendors">get.vendors</code></td>
<td>
<p>logical.  if TRUE, vendor data is returned for each compound with a matched CID.  Includes vendor count and vendor product URL, if available</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_priority.vendors">priority.vendors</code></td>
<td>
<p>charachter vector.  i.e. c(&quot;MyFavoriteCompany&quot;, &quot;MySecondFavoriteCompany&quot;).  If these vendors are found, the URL returned is from priority vendors. Priority is given by order input by user.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_get.properties">get.properties</code></td>
<td>
<p>logical.  if TRUE, physicochemical property data are returned for each compound with a matched CID.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_all.props">all.props</code></td>
<td>
<p>logical.  If TRUE, all pubchem properties (https://pubchemdocs.ncbi.nlm.nih.gov/pug-rest$_Toc494865567) are returned.  If false, only a subset (faster).</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_get.synonyms">get.synonyms</code></td>
<td>
<p>= TRUE. logical.  if TRUE, retrieve pubchem synonyms.  returned to $synonyms slot</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_find.short.lipid.name">find.short.lipid.name</code></td>
<td>
<p>= TRUE. logical.  If TRUE, and get.synonyms = TRUE, looks for lipid short hand names in synonyms list (i.e. PC(36:6)). returned to $short.name slot.  Short names are assigned only if assign.short.names = TRUE.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_find.short.synonym">find.short.synonym</code></td>
<td>
<p>= TRUE. logical.  If TRUE, and get.synonyms = TRUE, looks for lipid short synonyms, with prioritization for names with fewer numeric characters (i.e. database accession numbers or CAS numbers). returned to $short.name slot.  Short names are assigned only if assign.short.names = TRUE.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_max.name.length">max.name.length</code></td>
<td>
<p>= 20.  integer.  If names are longer than this value, short names will be searched for, else, retain original name.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_assign.short.name">assign.short.name</code></td>
<td>
<p>= TRUE.  If TRUE, short names from find.short.lipid.name and/or find.short.synonym = TRUE, short names are assigned the be the default annotation name ($ann slot), and original annotations are moved to $long.name slot.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_get.bioassays">get.bioassays</code></td>
<td>
<p>logical. If TRUE, return a table summarizing existing bioassay data for that CID.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_get.pathways">get.pathways</code></td>
<td>
<p>logical.  If TRUE, return a table of metabolic pathways for that CID.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.pubchem_+3A_write.csv">write.csv</code></td>
<td>
<p>logical.  If TRUE, write csv files of all returned pubchem data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>useful for moving from chemical name to digital structure representation. greek letters are assumed to be 'UTF-8' encoded, and are converted to latin text before searching.   if you are reading in your compound name list, do so with 'encoding' set to 'UTF-8'.
</p>


<h3>Value</h3>

<p>returns a list with one or more of $pubchem (compound name and identifiers) - one row in dataframe per CID; $properties contains physicochemical properties - one row in dataframe per CID; $vendors contains the number of vendors for a given compound and selects a vendor based on 'priority.vendors' supplied, or randomly choses a vendor with a HTML link - one row in dataframe per CID;  $bioassays contains a summary of bioassay activity data from pubchem - zero to many rows in dataframe per CID
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>

<hr>
<h2 id='rc.cmpd.get.smiles.inchi'>getSmilesInchi</h2><span id='topic+rc.cmpd.get.smiles.inchi'></span>

<h3>Description</h3>

<p>use PubChem API to look up full smiles and inchi notation for each inchikey
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.cmpd.get.smiles.inchi(
  ramclustObj = NULL,
  inchikey = NULL,
  ignore.stereo = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.cmpd.get.smiles.inchi_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to look up smiles and inchi for each inchikey (without a smiles/inchi). Must provide one of ramclustObj or inchikey.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.smiles.inchi_+3A_inchikey">inchikey</code></td>
<td>
<p>character vector of inchikey strings.  Must provide one of ramclustObj or inchikey.</p>
</td></tr>
<tr><td><code id="rc.cmpd.get.smiles.inchi_+3A_ignore.stereo">ignore.stereo</code></td>
<td>
<p>logical.  default = TRUE. If the Pubchem databases does not have the full inchikey string, should we search by the first (non-stereo) block of the inchikey?  When true, returns the first pubchem match to the inchikey block one string.  If the full inchikey is present, that is used preferentially.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The $inchikey slot is used to look up parameters from pubchem. PubChem CID, a pubchem URL, smiles (canonical) and inchi are returned.  if smiles and inchi slots are alread present (from MSFinder, for example) pubchem smiles and inchi are used to fill in missing values only, not replace.
</p>


<h3>Value</h3>

<p>returns a ramclustR object.  new vector of $smiles and $inchi with length equal to number of compounds.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Kim S, Thiessen PA, Bolton EE, Bryant SH. PUG-SOAP and PUG-REST: web services for programmatic access to chemical information in PubChem. Nucleic Acids Res. 2015;43(W1):W605-11.
</p>

<hr>
<h2 id='rc.cmpd.replace.na'>rc.cmpd.replace.na</h2><span id='topic+rc.cmpd.replace.na'></span>

<h3>Description</h3>

<p>replaces any NA (and optionally zero) values with small signal (20
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.cmpd.replace.na(
  ramclustObj = NULL,
  replace.int = 0.1,
  replace.noise = 0.1,
  replace.zero = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.cmpd.replace.na_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing SpecAbund dataset</p>
</td></tr>
<tr><td><code id="rc.cmpd.replace.na_+3A_replace.int">replace.int</code></td>
<td>
<p>default = 0.2.  proportion of minimum feature value to replace NA (or zero) values with</p>
</td></tr>
<tr><td><code id="rc.cmpd.replace.na_+3A_replace.noise">replace.noise</code></td>
<td>
<p>default = 0.2.  proportion ofreplace.int value by which noise is added via 'jitter'</p>
</td></tr>
<tr><td><code id="rc.cmpd.replace.na_+3A_replace.zero">replace.zero</code></td>
<td>
<p>logical if TRUE, any zero values are replaced with noise as if they were NA values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>noise is added by finding for each feature the minimum detected value, multiplying that value by replace.int, then adding (replace.int*replace.noise) noise.  abs() is used to ensure no negative values result.
</p>


<h3>Value</h3>

<p>ramclustR object with NA and zero values removed.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='rc.expand.sample.names'>rc.expand.sample.names</h2><span id='topic+rc.expand.sample.names'></span>

<h3>Description</h3>

<p>turn concatenated sample names into factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.expand.sample.names(
  ramclustObj = NULL,
  delim = "-",
  factor.names = TRUE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.expand.sample.names_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="rc.expand.sample.names_+3A_delim">delim</code></td>
<td>
<p>what delimiter should be used to separate names into factors?  '-' by default</p>
</td></tr>
<tr><td><code id="rc.expand.sample.names_+3A_factor.names">factor.names</code></td>
<td>
<p>logical or character vector.  if TRUE, user will enter names one by on in console.  If character vector (i.e. c(&quot;trt&quot;, &quot;time&quot;)) names are assigned to table</p>
</td></tr>
<tr><td><code id="rc.expand.sample.names_+3A_quiet">quiet</code></td>
<td>
<p>logical .  if TRUE, user will not be prompted to enter names one by on in console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>THis function only works on newer format ramclustObjects with a $phenoData slot.
</p>
<p>This function will split sample names by a delimiter, and enable users to name factors
</p>


<h3>Value</h3>

<p>ramclustR object with normalized data.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='rc.export.msp.rc'>rc.export.msp.rc</h2><span id='topic+rc.export.msp.rc'></span>

<h3>Description</h3>

<p>Cluster annotation function: inference of 'M' - molecular weight of the compound giving rise to each spectrum - using the InterpretMSSpectrum::findMain function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.export.msp.rc(ramclustObj = NULL, one.file = TRUE, mzdec = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.export.msp.rc_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to annotate.</p>
</td></tr>
<tr><td><code id="rc.export.msp.rc_+3A_one.file">one.file</code></td>
<td>
<p>logical, should all msp spectra be written to one file? If false, each spectrum is an individual file.</p>
</td></tr>
<tr><td><code id="rc.export.msp.rc_+3A_mzdec">mzdec</code></td>
<td>
<p>integer.  Number of decimal points to export mass values with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>exports files to a directory called 'spectra'.  If one.file = FALSE, a new directory 'spectra/msp' is created to hold the individual msp files. if do.findman has been run, spectra are written as ms2 spectra, else as ms1.
</p>


<h3>Value</h3>

<p>nothing, just exports files to the working directory
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>

<hr>
<h2 id='rc.feature.filter.blanks'>rc.feature.filter.blanks</h2><span id='topic+rc.feature.filter.blanks'></span>

<h3>Description</h3>

<p>used to remove features which are found at similar intensity in blank samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.feature.filter.blanks(
  ramclustObj = NULL,
  qc.tag = "QC",
  blank.tag = "blank",
  sn = 3,
  remove.blanks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.feature.filter.blanks_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="rc.feature.filter.blanks_+3A_qc.tag">qc.tag</code></td>
<td>
<p>character vector of length one or two.  If length is two, enter search string and factor name in $phenoData slot (i.e. c(&quot;QC&quot;, &quot;sample.type&quot;). If length one (i.e. &quot;QC&quot;), will search for this string in the 'sample.names' slot by default.</p>
</td></tr>
<tr><td><code id="rc.feature.filter.blanks_+3A_blank.tag">blank.tag</code></td>
<td>
<p>see 'qc.tag' , but for blanks to use as background.</p>
</td></tr>
<tr><td><code id="rc.feature.filter.blanks_+3A_sn">sn</code></td>
<td>
<p>numeric defines the ratio for 'signal'.  i.e. sn = 3 indicates that signal intensity must be 3 fold higher in sample than in blanks, on average, to be retained.</p>
</td></tr>
<tr><td><code id="rc.feature.filter.blanks_+3A_remove.blanks">remove.blanks</code></td>
<td>
<p>logical. TRUE by default.  this removes any recognized blanks samples from the MSdata and MSMSdata sets after they are used to filter contaminant features.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers normalization by run order, batch number, and QC sample signal intensity.
</p>
<p>Each input vector should be the same length, and equal to the number of samples in the $MSdata set.
</p>
<p>Input vector order is assumed to be the same as the sample order in the $MSdata set.
</p>


<h3>Value</h3>

<p>ramclustR object with normalized data.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='rc.feature.filter.cv'>rc.feature.filter.cv</h2><span id='topic+rc.feature.filter.cv'></span>

<h3>Description</h3>

<p>extractor for xcms objects in preparation for clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.feature.filter.cv(ramclustObj = NULL, qc.tag = "QC", max.cv = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.feature.filter.cv_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="rc.feature.filter.cv_+3A_qc.tag">qc.tag</code></td>
<td>
<p>character vector of length one or two.  If length is two, enter search string and factor name in $phenoData slot (i.e. c(&quot;QC&quot;, &quot;sample.type&quot;). If length one (i.e. &quot;QC&quot;), will search for this string in the 'sample.names' slot by default.</p>
</td></tr>
<tr><td><code id="rc.feature.filter.cv_+3A_max.cv">max.cv</code></td>
<td>
<p>numeric maximum allowable cv for any feature.  default = 0.5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers normalization by total extracted ion signal.  it is recommended to first run 'rc.feature.filter.blanks' to remove non-sample derived signal.
</p>


<h3>Value</h3>

<p>ramclustR object with total extracted ion normalized data.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='rc.feature.normalize.batch.qc'>rc.feature.normalize.batch.qc</h2><span id='topic+rc.feature.normalize.batch.qc'></span>

<h3>Description</h3>

<p>normalize data using batch.qc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.feature.normalize.batch.qc(
  order = NULL,
  batch = NULL,
  qc = NULL,
  ramclustObj = NULL,
  qc.inj.range = 20,
  output.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.feature.normalize.batch.qc_+3A_order">order</code></td>
<td>
<p>integer vector with length equal to number of injections in xset or csv file or dataframe</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.batch.qc_+3A_batch">batch</code></td>
<td>
<p>integer vector with length equal to number of injections in xset or csv file or dataframe</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.batch.qc_+3A_qc">qc</code></td>
<td>
<p>logical vector with length equal to number of injections in xset or csv file or dataframe</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.batch.qc_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.batch.qc_+3A_qc.inj.range">qc.inj.range</code></td>
<td>
<p>integer: how many injections around each injection are to be scanned for presence of QC samples when using batch.qc normalization?  A good rule of thumb is between 1 and 3 times the typical injection span between QC injections.  i.e. if you inject QC ever 7 samples, set this to between 7 and 21.  smaller values provide more local precision but make normalization sensitive to individual poor outliers (though these are first removed using the boxplot function outlier detection), while wider values provide less local precision in normalization but better stability to individual peak areas.</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.batch.qc_+3A_output.plot">output.plot</code></td>
<td>
<p>logical set to TRUE to store plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ramclustR object with normalized data.
</p>

<hr>
<h2 id='rc.feature.normalize.qc'>rc.feature.normalize.qc</h2><span id='topic+rc.feature.normalize.qc'></span>

<h3>Description</h3>

<p>extractor for xcms objects in preparation for clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.feature.normalize.qc(
  ramclustObj = NULL,
  order = NULL,
  batch = NULL,
  qc = NULL,
  output.plot = FALSE,
  p.cut = 0.05,
  rsq.cut = 0.1,
  p.adjust = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.feature.normalize.qc_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.qc_+3A_order">order</code></td>
<td>
<p>integer vector with length equal to number of injections in xset or csv file</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.qc_+3A_batch">batch</code></td>
<td>
<p>integer vector with length equal to number of injections in xset or csv file</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.qc_+3A_qc">qc</code></td>
<td>
<p>logical vector with length equal to number of injections in xset or csv file or dataframe</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.qc_+3A_output.plot">output.plot</code></td>
<td>
<p>logical: if TRUE (default), plots are output to PDF.</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.qc_+3A_p.cut">p.cut</code></td>
<td>
<p>numeric when run order correction is applied, only features showing a run order vs signal with a linear p-value (after FDR correction) &lt; p.cut will be adjusted.  also requires r-squared &lt; rsq.cut.</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.qc_+3A_rsq.cut">rsq.cut</code></td>
<td>
<p>numeric when run order correction is applied, only features showing a run order vs signal with a linear r-squared &gt; rsq.cut will be adjusted. also requires p values &lt; p.cut.</p>
</td></tr>
<tr><td><code id="rc.feature.normalize.qc_+3A_p.adjust">p.adjust</code></td>
<td>
<p>which p-value adjustment should be used? default = &quot;none&quot;, see ?p.adjust</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers normalization by run order, batch number, and QC sample signal intensity.
</p>
<p>Each input vector should be the same length, and equal to the number of samples in the $MSdata set.
</p>
<p>Input vector order is assumed to be the same as the sample order in the $MSdata set.
</p>


<h3>Value</h3>

<p>ramclustR object with normalized data.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='rc.feature.normalize.quantile'>rc.feature.normalize.quantile</h2><span id='topic+rc.feature.normalize.quantile'></span>

<h3>Description</h3>

<p>normalize data using quantile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.feature.normalize.quantile(ramclustObj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.feature.normalize.quantile_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ramclustR object with normalized data.
</p>

<hr>
<h2 id='rc.feature.normalize.tic'>rc.feature.normalize.tic</h2><span id='topic+rc.feature.normalize.tic'></span>

<h3>Description</h3>

<p>extractor for xcms objects in preparation for clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.feature.normalize.tic(ramclustObj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.feature.normalize.tic_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function offers normalization by total extracted ion signal.  it is recommended to first run 'rc.feature.filter.blanks' to remove non-sample derived signal.
</p>


<h3>Value</h3>

<p>ramclustR object with total extracted ion normalized data.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='rc.feature.replace.na'>rc.feature.replace.na</h2><span id='topic+rc.feature.replace.na'></span>

<h3>Description</h3>

<p>replaces any NA (and optionally zero) values with small signal (20
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.feature.replace.na(
  ramclustObj = NULL,
  replace.int = 0.1,
  replace.noise = 0.1,
  replace.zero = TRUE,
  which.data = c("MSdata", "MSMSdata")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.feature.replace.na_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="rc.feature.replace.na_+3A_replace.int">replace.int</code></td>
<td>
<p>default = 0.1.  proportion of minimum feature value to replace NA (or zero) values with</p>
</td></tr>
<tr><td><code id="rc.feature.replace.na_+3A_replace.noise">replace.noise</code></td>
<td>
<p>default = 0.1.  proportion ofreplace.int value by which noise is added via 'jitter'</p>
</td></tr>
<tr><td><code id="rc.feature.replace.na_+3A_replace.zero">replace.zero</code></td>
<td>
<p>logical if TRUE, any zero values are replaced with noise as if they were NA values</p>
</td></tr>
<tr><td><code id="rc.feature.replace.na_+3A_which.data">which.data</code></td>
<td>
<p>name of dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>noise is added by finding for each feature the minimum detected value, multiplying that value by replace.int, then adding (replace.int*replace.noise) noise.  abs() is used to ensure no negative values result.
</p>


<h3>Value</h3>

<p>ramclustR object with NA and zero values removed.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='rc.get.csv.data'>rc.get.csv.data</h2><span id='topic+rc.get.csv.data'></span>

<h3>Description</h3>

<p>extractor for csv objects in preparation for normalization and clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.get.csv.data(
  csv = NULL,
  phenoData = NULL,
  idmsms = NULL,
  ExpDes = NULL,
  sampNameCol = 1,
  st = NULL,
  timepos = 2,
  featdelim = "_",
  ensure.no.na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.get.csv.data_+3A_csv">csv</code></td>
<td>
<p>filepath: csv input. Features as columns, rows as samples. Column header mz_rt</p>
</td></tr>
<tr><td><code id="rc.get.csv.data_+3A_phenodata">phenoData</code></td>
<td>
<p>character: character string in 'taglocation' to designate files as either MS / DIA(MSe, MSall, AIF, etc) e.g. &quot;01.mzML&quot;</p>
</td></tr>
<tr><td><code id="rc.get.csv.data_+3A_idmsms">idmsms</code></td>
<td>
<p>filepath: optional idMSMS / MSe csv data.  same dim and names as ms required</p>
</td></tr>
<tr><td><code id="rc.get.csv.data_+3A_expdes">ExpDes</code></td>
<td>
<p>either an R object created by R ExpDes object: data used for record keeping and labelling msp spectral output</p>
</td></tr>
<tr><td><code id="rc.get.csv.data_+3A_sampnamecol">sampNameCol</code></td>
<td>
<p>integer: which column from the csv file contains sample names?</p>
</td></tr>
<tr><td><code id="rc.get.csv.data_+3A_st">st</code></td>
<td>
<p>numeric: sigma t - time similarity decay value</p>
</td></tr>
<tr><td><code id="rc.get.csv.data_+3A_timepos">timepos</code></td>
<td>
<p>integer: which position in delimited column header represents the retention time</p>
</td></tr>
<tr><td><code id="rc.get.csv.data_+3A_featdelim">featdelim</code></td>
<td>
<p>character: how feature mz and rt are delimited in csv import column header e.g. =&quot;-&quot;</p>
</td></tr>
<tr><td><code id="rc.get.csv.data_+3A_ensure.no.na">ensure.no.na</code></td>
<td>
<p>logical: if TRUE, any 'NA' values in msint and/or msmsint are replaced with numerical values based on 10 percent of feature min plus noise.  Used to ensure that spectra are not written with NA values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a ramclustObj which will be used as input for clustering.
</p>


<h3>Value</h3>

<p>an empty ramclustR object.  this object is formatted as an hclust object with additional slots for holding feature and compound data. details on these found below.
</p>
<p>$frt: feature retention time, in whatever units were fed in
</p>
<p>$fmz: feature retention time, reported in number of decimal points selected in ramclustR function
</p>
<p>$ExpDes: the experimental design object used when running ramclustR.  List of two dataframes.
</p>
<p>$MSdata:  the MSdataset provided by either xcms or csv input
</p>
<p>$MSMSdata: the (optional) DIA(MSe, MSall, AIF etc) dataset
</p>
<p>$xcmsOrd: original xcms order of features, for back-referencing when necessary
</p>
<p>$msint: weighted.mean intensity of feature in ms level data
</p>
<p>$msmsint:weighted.mean intensity of feature in msms level data
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Choose csv input file. Features as columns, rows as samples
## Choose csv input file phenoData 
filename &lt;- system.file("extdata", "peaks.csv", package = "RAMClustR", mustWork = TRUE)
phenoData &lt;- system.file("extdata", "phenoData.csv", package = "RAMClustR", mustWork = TRUE)

ramclustobj &lt;- rc.get.csv.data(csv = filename, phenoData = phenoData, st = 5)

</code></pre>

<hr>
<h2 id='rc.get.df.data'>rc.get.df.data</h2><span id='topic+rc.get.df.data'></span>

<h3>Description</h3>

<p>extractor for dataframe input in preparation for normalization and clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.get.df.data(
  ms1_featureDefinitions = NULL,
  ms1_featureValues = NULL,
  ms2_featureDefinitions = NULL,
  ms2_featureValues = NULL,
  phenoData = NULL,
  ExpDes = NULL,
  featureNamesColumnIndex = 1,
  st = NULL,
  ensure.no.na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.get.df.data_+3A_ms1_featuredefinitions">ms1_featureDefinitions</code></td>
<td>
<p>dataframe with metadata with columns: mz, rt, feature names containing MS data</p>
</td></tr>
<tr><td><code id="rc.get.df.data_+3A_ms1_featurevalues">ms1_featureValues</code></td>
<td>
<p>dataframe with rownames = sample names, colnames = feature names containing MS data</p>
</td></tr>
<tr><td><code id="rc.get.df.data_+3A_ms2_featuredefinitions">ms2_featureDefinitions</code></td>
<td>
<p>dataframe with metadata with columns: mz, rt, feature names containing MSMS data</p>
</td></tr>
<tr><td><code id="rc.get.df.data_+3A_ms2_featurevalues">ms2_featureValues</code></td>
<td>
<p>dataframe with rownames = sample names, colnames = feature names containing MSMS data</p>
</td></tr>
<tr><td><code id="rc.get.df.data_+3A_phenodata">phenoData</code></td>
<td>
<p>dataframe containing phenoData</p>
</td></tr>
<tr><td><code id="rc.get.df.data_+3A_expdes">ExpDes</code></td>
<td>
<p>either an R object created by R ExpDes object: data used for record keeping and labelling msp spectral output</p>
</td></tr>
<tr><td><code id="rc.get.df.data_+3A_featurenamescolumnindex">featureNamesColumnIndex</code></td>
<td>
<p>integer: which column in 'ms1_featureDefinitions' contains feature names?</p>
</td></tr>
<tr><td><code id="rc.get.df.data_+3A_st">st</code></td>
<td>
<p>numeric: sigma t - time similarity decay value</p>
</td></tr>
<tr><td><code id="rc.get.df.data_+3A_ensure.no.na">ensure.no.na</code></td>
<td>
<p>logical: if TRUE, any 'NA' values in msint and/or msmsint are replaced with numerical values based on 10 percent of feature min plus noise.  Used to ensure that spectra are not written with NA values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a ramclustObj which will be used as input for clustering.
</p>


<h3>Value</h3>

<p>an empty ramclustR object.  this object is formatted as an hclust object with additional slots for holding feature and compound data. details on these found below.
</p>
<p>$frt: feature retention time, in whatever units were fed in
</p>
<p>$fmz: feature retention time, reported in number of decimal points selected in ramclustR function
</p>
<p>$ExpDes: the experimental design object used when running ramclustR.  List of two dataframes.
</p>
<p>$MSdata:  the MSdataset provided by either xcms or csv input
</p>
<p>$MSMSdata: the (optional) DIA(MSe, MSall, AIF etc) dataset
</p>
<p>$xcmsOrd: original xcms order of features, for back-referencing when necessary
</p>
<p>$msint: weighted.mean intensity of feature in ms level data
</p>
<p>$msmsint:weighted.mean intensity of feature in msms level data
</p>


<h3>Author(s)</h3>

<p>Zargham Ahmad, Helge Hecht, Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Choose dataframe with metadata with columns: mz, rt, feature names containing MS data
## Choose dataframe with rownames = sample names, colnames = feature names containing MS data
## Choose dataframe containing phenoData 
df1 &lt;- readRDS(system.file("extdata", "featDefinition.rds", package = "RAMClustR", mustWork = TRUE))
df2 &lt;- readRDS(system.file("extdata", "featValues.rds", package = "RAMClustR", mustWork = TRUE))
df3 &lt;- readRDS(system.file("extdata", "phenoData_df.rds", package = "RAMClustR", mustWork = TRUE))

ramclustr &lt;- rc.get.df.data(ms1_featureDefinitions=df1, ms1_featureValues=df2, phenoData=df3, st=5)

</code></pre>

<hr>
<h2 id='rc.get.xcms.data'>rc.get.xcms.data</h2><span id='topic+rc.get.xcms.data'></span>

<h3>Description</h3>

<p>extractor for xcms objects in preparation for normalization and clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.get.xcms.data(
  xcmsObj = NULL,
  taglocation = "filepaths",
  MStag = NULL,
  MSMStag = NULL,
  ExpDes = NULL,
  mzdec = 3,
  ensure.no.na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.get.xcms.data_+3A_xcmsobj">xcmsObj</code></td>
<td>
<p>xcmsObject: containing grouped feature data for clustering by ramclustR</p>
</td></tr>
<tr><td><code id="rc.get.xcms.data_+3A_taglocation">taglocation</code></td>
<td>
<p>character: &quot;filepaths&quot; by default, &quot;phenoData[,1]&quot; is another option. refers to xcms slot</p>
</td></tr>
<tr><td><code id="rc.get.xcms.data_+3A_mstag">MStag</code></td>
<td>
<p>character: character string in 'taglocation' to designate files as either MS / DIA(MSe, MSall, AIF, etc) e.g. &quot;01.mzML&quot;</p>
</td></tr>
<tr><td><code id="rc.get.xcms.data_+3A_msmstag">MSMStag</code></td>
<td>
<p>character: character string in 'taglocation' to designate files as either MS / DIA(MSe, MSall, AIF, etc) e.g. &quot;02.mzML&quot;</p>
</td></tr>
<tr><td><code id="rc.get.xcms.data_+3A_expdes">ExpDes</code></td>
<td>
<p>either an R object created by R ExpDes object: data used for record keeping and labelling msp spectral output</p>
</td></tr>
<tr><td><code id="rc.get.xcms.data_+3A_mzdec">mzdec</code></td>
<td>
<p>integer: number of decimal places for storing m/z values</p>
</td></tr>
<tr><td><code id="rc.get.xcms.data_+3A_ensure.no.na">ensure.no.na</code></td>
<td>
<p>logical: if TRUE, any 'NA' values in msint and/or msmsint are replaced with numerical values based on 10 percent of feature min plus noise.  Used to ensure that spectra are not written with NA values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a ramclustObj which will be used as input for clustering.
</p>


<h3>Value</h3>

<p>an empty ramclustR object.  this object is formatted as an hclust object with additional slots for holding feature and compound data. details on these found below.
</p>
<p>$frt: feature retention time, in whatever units were fed in (xcms uses seconds, by default)
</p>
<p>$fmz: feature retention time, reported in number of decimal points selected in ramclustR function
</p>
<p>$ExpDes: the experimental design object used when running ramclustR.  List of two dataframes.
</p>
<p>$MSdata:  the MSdataset provided by either xcms or csv input
</p>
<p>$MSMSdata: the (optional) DIA(MSe, MSall, AIF etc) dataset provided be either xcms or csv input
</p>
<p>$xcmsOrd: original xcms order of features, for back-referencing when necessary
</p>
<p>$msint: weighted.mean intensity of feature in ms level data
</p>
<p>$msmsint:weighted.mean intensity of feature in msms level data
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='rc.qc'>rc.qc</h2><span id='topic+rc.qc'></span>

<h3>Description</h3>

<p>summarize quality control for clustering and for quality control sample variation based on compound ($SpecAbund) and feature ($MSdata and $MSMSdata, if present)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.qc(
  ramclustObj = NULL,
  qc.tag = "QC",
  remove.qc = FALSE,
  npc = 4,
  scale = "pareto",
  outfile.basename = "ramclustQC",
  view.hist = TRUE,
  do.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.qc_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to analyze</p>
</td></tr>
<tr><td><code id="rc.qc_+3A_qc.tag">qc.tag</code></td>
<td>
<p>qc.tag character vector of length one or two.  If length is two, enter search string and factor name in $phenoData slot (i.e. c(&quot;QC&quot;, &quot;sample.type&quot;). If length one (i.e. &quot;QC&quot;), will search for this string in the 'sample.names' slot by default.</p>
</td></tr>
<tr><td><code id="rc.qc_+3A_remove.qc">remove.qc</code></td>
<td>
<p>logical - if TRUE (default) QC injections will be removed from the returned ramclustObj (applies to $MSdata, $MSMSdata, $SpecAbund, $phenoData, as appropriate). If FALSE, QC samples remain.</p>
</td></tr>
<tr><td><code id="rc.qc_+3A_npc">npc</code></td>
<td>
<p>number of Principle components to calcuate and plot</p>
</td></tr>
<tr><td><code id="rc.qc_+3A_scale">scale</code></td>
<td>
<p>&quot;pareto&quot; by default: PCA scaling method used</p>
</td></tr>
<tr><td><code id="rc.qc_+3A_outfile.basename">outfile.basename</code></td>
<td>
<p>base name of output files. Extensions added internally. default = &quot;ramclustQC&quot;</p>
</td></tr>
<tr><td><code id="rc.qc_+3A_view.hist">view.hist</code></td>
<td>
<p>logical.  should histograms be plotted?</p>
</td></tr>
<tr><td><code id="rc.qc_+3A_do.plot">do.plot</code></td>
<td>
<p>logical should plots be shown/plotted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plots a ramclustR summary plot.  first page represents the correlation of each cluster to all other clusters, sorted by retention time.  large blocks of yellow along the diaganol indicate either poor clustering or a group of coregulated metabolites with similar retention time.  It is an imperfect diagnostic, particularly with lipids on reverse phase LC or sugars on HILIC LC systems.  Page 2: histogram of r values from page 1 - only r values one position from the diagonal are used.  Pages 3:5 - PCA results, with QC samples colored red.  relative standard deviation calculated as sd(QC PC scores) / sd(all PC scores).  Page 6: histogram of CV values for each compound int he dataset, QC samples only.
</p>


<h3>Value</h3>

<p>new RC object. Saves output summary plots to pdf and .csv summary tables to new 'QC' directory. If remove.qc = TRUE, moves QC samples to new $QC slot from original position.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='rc.ramclustr'>rc.ramclustr</h2><span id='topic+rc.ramclustr'></span>

<h3>Description</h3>

<p>Main clustering function for grouping features based on their analytical behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.ramclustr(
  ramclustObj = NULL,
  st = NULL,
  sr = NULL,
  maxt = NULL,
  deepSplit = FALSE,
  blocksize = 2000,
  mult = 5,
  hmax = NULL,
  collapse = TRUE,
  minModuleSize = 2,
  linkage = "average",
  cor.method = "pearson",
  rt.only.low.n = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.ramclustr_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object: containing ungrouped features.  constructed by rc.get.xcms.data, for example</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_st">st</code></td>
<td>
<p>numeric: sigma t - time similarity decay value</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_sr">sr</code></td>
<td>
<p>numeric: sigma r - correlational similarity decay value</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_maxt">maxt</code></td>
<td>
<p>numeric: maximum time difference to calculate retention similarity for - all values beyond this are assigned similarity of zero</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_deepsplit">deepSplit</code></td>
<td>
<p>logical: controls how agressively the HCA tree is cut - see ?cutreeDynamicTree</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_blocksize">blocksize</code></td>
<td>
<p>integer: number of features (scans?) processed in one block  =1000,</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_mult">mult</code></td>
<td>
<p>numeric: internal value, can be used to influence processing speed/ram usage</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_hmax">hmax</code></td>
<td>
<p>numeric: precut the tree at this height, default 0.3 - see ?cutreeDynamicTree</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_collapse">collapse</code></td>
<td>
<p>logical: if true (default), feature quantitative values are collapsed into spectra quantitative values.</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_minmodulesize">minModuleSize</code></td>
<td>
<p>integer: how many features must be part of a cluster to be returned? default = 2</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_linkage">linkage</code></td>
<td>
<p>character: heirarchical clustering linkage method - see ?hclust</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_cor.method">cor.method</code></td>
<td>
<p>character: which correlational method used to calculate 'r' - see ?cor</p>
</td></tr>
<tr><td><code id="rc.ramclustr_+3A_rt.only.low.n">rt.only.low.n</code></td>
<td>
<p>logical: default = TRUE  At low injection numbers, correlational relationships of peak intensities may be unreliable.  by defualt ramclustR will simply ignore the correlational r value and cluster on retention time alone.  if you wish to use correlation with at n &lt; 5, set this value to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Main clustering function output - see citation for algorithm description or vignette('RAMClustR') for a walk through.  batch.qc. normalization requires input of three vectors (1) batch (2) order (3) qc.   This is a feature centric normalization approach which adjusts signal intensities first by comparing batch median intensity of each feature (one feature at a time) QC signal intensity to full dataset median to correct for systematic batch effects and then secondly to apply a local QC median vs global median sample correction to correct for run order effects.
</p>


<h3>Value</h3>

<p>$featclus: integer vector of cluster membership for each feature
</p>
<p>$clrt: cluster retention time
</p>
<p>$clrtsd: retention time standard deviation of all the features that comprise that cluster
</p>
<p>$nfeat: number of features in the cluster
</p>
<p>$nsing: number of 'singletons' - that is the number of features which clustered with no other feature
</p>
<p>$cmpd: compound name.  C#### are assigned in order of output by dynamicTreeCut.  Compound with the most features is classified as C0001...
</p>
<p>$ann: annotation.  By default, annotation names are identical to 'cmpd' names.  This slot is a placeholder for when annotations are provided
</p>
<p>$SpecAbund: the cluster intensities after collapsing features to clusters
</p>
<p>$SpecAbundAve: the cluster intensities after averaging all samples with identical sample names
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='rc.remove.qc'>rc.remove.qc</h2><span id='topic+rc.remove.qc'></span>

<h3>Description</h3>

<p>summarize quality control for clustering and for quality control sample variation based on compound ($SpecAbund) and feature ($MSdata and $MSMSdata, if present)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.remove.qc(ramclustObj = NULL, qc.tag = "QC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.remove.qc_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to analyze</p>
</td></tr>
<tr><td><code id="rc.remove.qc_+3A_qc.tag">qc.tag</code></td>
<td>
<p>qc.tag character vector of length one or two.  If length is two, enter search string and factor name in $phenoData slot (i.e. c(&quot;QC&quot;, &quot;sample.type&quot;). If length one (i.e. &quot;QC&quot;), will search for this string in the 'sample.names' slot by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>simply moves QC samples out of the way for downstream processing. moved to a $qc slot.
</p>


<h3>Value</h3>

<p>new RC object. moves QC samples to new $qc slot from original position.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='rc.restore.qc.samples'>rc.restore.qc.samples</h2><span id='topic+rc.restore.qc.samples'></span>

<h3>Description</h3>

<p>summarize quality control for clustering and for quality control sample variation based on compound ($SpecAbund) and feature ($MSdata and $MSMSdata, if present)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.restore.qc.samples(ramclustObj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc.restore.qc.samples_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to analyze</p>
</td></tr>
</table>


<h3>Details</h3>

<p>moves all of $phenoData, $MSdata, $MSMSdata, $SpecAbund back to original positions from $qc slot
</p>


<h3>Value</h3>

<p>RC object
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='RCQC'>RCQC</h2><span id='topic+RCQC'></span>

<h3>Description</h3>

<p>filter RC object and summarize quality control sample variation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCQC(
  ramclustObj = NULL,
  qctag = "QC",
  npc = 4,
  scale = "pareto",
  which.data = "SpecAbund",
  outfile = "ramclustQC.pdf"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RCQC_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to analyze</p>
</td></tr>
<tr><td><code id="RCQC_+3A_qctag">qctag</code></td>
<td>
<p>&quot;QC&quot; by default - rowname tag to identify QC samples</p>
</td></tr>
<tr><td><code id="RCQC_+3A_npc">npc</code></td>
<td>
<p>number of Principle components to calcuate and plot</p>
</td></tr>
<tr><td><code id="RCQC_+3A_scale">scale</code></td>
<td>
<p>&quot;pareto&quot; by default: PCA scaling method used</p>
</td></tr>
<tr><td><code id="RCQC_+3A_which.data">which.data</code></td>
<td>
<p>which dataset to use.  &quot;SpecAbund&quot; by default</p>
</td></tr>
<tr><td><code id="RCQC_+3A_outfile">outfile</code></td>
<td>
<p>name of output pdf file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plots a ramclustR summary plot.  first page represents the correlation of each cluster to all other clusters, sorted by retention time.  large blocks of yellow along the diaganol indicate either poor clustering or a group of coregulated metabolites with similar retention time.  It is an imperfect diagnostic, particularly with lipids on reverse phase LC or sugars on HILIC LC systems.  Page 2: histogram of r values from page 1 - only r values one position from the diagonal are used.  Pages 3:5 - PCA results, with QC samples colored red.  relative standard deviation calculated as sd(QC PC scores) / sd(all PC scores).  Page 6: histogram of CV values for each compound int he dataset, QC samples only.
</p>


<h3>Value</h3>

<p>new RC object, with QC samples moved to new slot.  prints output summary plots to pdf.
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>
<p>Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
</p>

<hr>
<h2 id='remove_blanks'>remove_blanks</h2><span id='topic+remove_blanks'></span>

<h3>Description</h3>

<p>remove blanks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_blanks(ramclustObj, blank)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_blanks_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustObj containing MSdata with optional MSMSdata (MSe, DIA, idMSMS)</p>
</td></tr>
<tr><td><code id="remove_blanks_+3A_blank">blank</code></td>
<td>
<p>blank samples found by define_samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ramclustObj object with blanks removed
</p>

<hr>
<h2 id='replace_na'>replace_na</h2><span id='topic+replace_na'></span>

<h3>Description</h3>

<p>add rc.feature.replace.na params in ramclustObj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_na(data, replace.int, replace.zero, replace.noise)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_na_+3A_data">data</code></td>
<td>
<p>selected data frame to use</p>
</td></tr>
<tr><td><code id="replace_na_+3A_replace.int">replace.int</code></td>
<td>
<p>default = 0.1.  proportion of minimum feature value to replace NA (or zero) values with</p>
</td></tr>
<tr><td><code id="replace_na_+3A_replace.zero">replace.zero</code></td>
<td>
<p>logical if TRUE, any zero values are replaced with noise as if they were NA values</p>
</td></tr>
<tr><td><code id="replace_na_+3A_replace.noise">replace.noise</code></td>
<td>
<p>default = 0.1.  proportion ofreplace.int value by which noise is added via 'jitter'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>selected ramclustR data frame with NA and zero values removed.
</p>
<p>number of features replaced
</p>

<hr>
<h2 id='write_csv'>write_csv</h2><span id='topic+write_csv'></span>

<h3>Description</h3>

<p>write csv template called &quot;ExpDes.csv&quot; to your working directory. you will fill this in manually, ensuring that when you save you retain csv format. ramclustR will then read this file in and and format appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_csv(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_csv_+3A_data">data</code></td>
<td>
<p>csv template to write</p>
</td></tr>
</table>


<h3>Value</h3>

<p>read ExpDes.csv file
</p>

<hr>
<h2 id='write.methods'>write.methods</h2><span id='topic+write.methods'></span>

<h3>Description</h3>

<p>write RAMClustR processing methods and citations to text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.methods(ramclustObj = NULL, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.methods_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>R object - the ramclustR object which was used to write the .mat or .msp files</p>
</td></tr>
<tr><td><code id="write.methods_+3A_filename">filename</code></td>
<td>
<p>define filename/path to write.  uses 'ramclustr_methods.txt' and the working directory by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function exports a file called ramclustr_methods.txt which contains the processing history, parameters used, and relevant citations.
</p>


<h3>Value</h3>

<p>an annotated ramclustR object
</p>
<p>nothing - new file written to working director
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>


<h3>References</h3>

<p>Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
</p>

<hr>
<h2 id='write.msp'>write.msp</h2><span id='topic+write.msp'></span>

<h3>Description</h3>

<p>Cluster annotation function: inference of 'M' - molecular weight of the compound giving rise to each spectrum - using the InterpretMSSpectrum::findMain function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.msp(ramclustObj = NULL, one.file = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.msp_+3A_ramclustobj">ramclustObj</code></td>
<td>
<p>ramclustR object to annotate.</p>
</td></tr>
<tr><td><code id="write.msp_+3A_one.file">one.file</code></td>
<td>
<p>logical, should all msp spectra be written to one file? If false, each spectrum is an individual file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>exports files to a directory called 'spectra'.  If one.file = FALSE, a new directory 'spectra/msp' is created to hold the individual msp files. if do.findman has been run, spectra are written as ms2 spectra, else as ms1.
</p>


<h3>Value</h3>

<p>nothing, just exports files to the working directory
</p>


<h3>Author(s)</h3>

<p>Corey Broeckling
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
