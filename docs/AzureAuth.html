<!DOCTYPE html><html><head><title>Help for package AzureAuth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AzureAuth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AzureR_dir'><p>Data directory for AzureR packages</p></a></li>
<li><a href='#AzureToken'><p>Azure OAuth authentication</p></a></li>
<li><a href='#build_authorization_uri'><p>Standalone OAuth authorization functions</p></a></li>
<li><a href='#cert_assertion'><p>Create a client assertion for certificate authentication</p></a></li>
<li><a href='#decode_jwt'><p>Get raw access token (which is a JWT object)</p></a></li>
<li><a href='#format_auth_header'><p>Format an AzureToken object</p></a></li>
<li><a href='#get_managed_token'><p>Manage Azure Active Directory OAuth 2.0 tokens</p></a></li>
<li><a href='#normalize_tenant'><p>Normalize GUID and tenant values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Authentication Services for Azure Active Directory</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides Azure Active Directory (AAD) authentication functionality for R users of Microsoft's 'Azure' cloud <a href="https://azure.microsoft.com/">https://azure.microsoft.com/</a>. Use this package to obtain 'OAuth' 2.0 tokens for services including Azure Resource Manager, Azure Storage and others. It supports both AAD v1.0 and v2.0, as well as multiple authentication methods, including device code and resource owner grant. Tokens are cached in a user-specific directory obtained using the 'rappdirs' package. The interface is based on the 'OAuth' framework in the 'httr' package, but customised and streamlined for Azure. Part of the 'AzureR' family of packages.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Azure/AzureAuth">https://github.com/Azure/AzureAuth</a> <a href="https://github.com/Azure/AzureR">https://github.com/Azure/AzureR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Azure/AzureAuth/issues">https://github.com/Azure/AzureAuth/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, httr (&ge; 1.3), openssl, jsonlite, jose, R6, rappdirs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, httpuv, shiny, shinyjs, AzureRMR,
AzureGraph</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-13 08:32:03 UTC; hongo</td>
</tr>
<tr>
<td>Author:</td>
<td>Hong Ooi [aut, cre],
  Tyler Littlefield [ctb],
  httr development team [ctb] (Original OAuth listener code),
  Scott Holden [ctb] (Advice on AAD authentication),
  Chris Stone [ctb] (Advice on AAD authentication),
  Microsoft [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hong Ooi &lt;hongooi73@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-13 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AzureR_dir'>Data directory for AzureR packages</h2><span id='topic+AzureR_dir'></span><span id='topic+create_AzureR_dir'></span>

<h3>Description</h3>

<p>Data directory for AzureR packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AzureR_dir()

create_AzureR_dir()
</code></pre>


<h3>Details</h3>

<p>AzureAuth can save your authentication credentials in a user-specific directory, using the rappdirs package. On recent Windows versions, this will usually be in the location <code style="white-space: pre;">&#8288;C:\\Users\\(username)\\AppData\\Local\\AzureR&#8288;</code>. On Unix/Linux, it will be in <code style="white-space: pre;">&#8288;~/.local/share/AzureR&#8288;</code>, and on MacOS, it will be in <code style="white-space: pre;">&#8288;~/Library/Application Support/AzureR&#8288;</code>.Alternatively, you can specify the location of the directory in the environment variable <code>R_AZURE_DATA_DIR</code>. AzureAuth does not modify R's working directory, which significantly lessens the risk of accidentally introducing cached tokens into source control.
</p>
<p>On package startup, if this directory does not exist, AzureAuth will prompt you for permission to create it. It's recommended that you allow the directory to be created, as otherwise you will have to reauthenticate with Azure every time. Note that many cloud engineering tools, including the <a href="https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest">Azure CLI</a>, save authentication credentials in this way. The prompt only appears in an interactive session (in the sense that <code>interactive()</code> returns TRUE); if AzureAuth is loaded in a batch script, the directory is not created if it doesn't already exist.
</p>
<p><code>create_AzureR_dir</code> is a utility function to create the caching directory manually. This can be useful not just for non-interactive sessions, but also Jupyter and R notebooks, which are not <em>technically</em> interactive in that <code>interactive()</code> returns FALSE.
</p>
<p>The caching directory is also used by other AzureR packages, notably AzureRMR (for storing Resource Manager logins) and AzureGraph (for Microsoft Graph logins). You should not save your own files in it; instead, treat it as something internal to the AzureR packages.
</p>


<h3>Value</h3>

<p>A string containing the data directory.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_azure_token">get_azure_token</a>
</p>
<p><a href="rappdirs.html#topic+user_data_dir">rappdirs::user_data_dir</a>
</p>

<hr>
<h2 id='AzureToken'>Azure OAuth authentication</h2><span id='topic+AzureToken'></span><span id='topic+AzureTokenAuthCode'></span><span id='topic+AzureTokenDeviceCode'></span><span id='topic+AzureTokenClientCreds'></span><span id='topic+AzureTokenOnBehalfOf'></span><span id='topic+AzureTokenResOwner'></span><span id='topic+AzureTokenManaged'></span>

<h3>Description</h3>

<p>Azure OAuth 2.0 token classes, with an interface based on the <a href="httr.html#topic+Token-class">Token2.0 class</a> in httr. Rather than calling the initialization methods directly, tokens should be created via <code><a href="#topic+get_azure_token">get_azure_token()</a></code>.
</p>


<h3>Format</h3>

<p>An R6 object representing an Azure Active Directory token and its associated credentials. <code>AzureToken</code> is the base class, and the others inherit from it.
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>refresh</code>: Refreshes the token. For expired tokens without an associated refresh token, refreshing really means requesting a new token.
</p>
</li>
<li> <p><code>validate</code>: Checks if the token has not yet expired. Note that a token may be invalid for reasons other than having expired, eg if it is revoked on the server.
</p>
</li>
<li> <p><code>hash</code>: Computes an MD5 hash on the input fields of the object. Used internally for identification purposes when caching.
</p>
</li>
<li> <p><code>cache</code>: Stores the token on disk for use in future sessions.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+get_azure_token">get_azure_token</a>, <a href="httr.html#topic+Token-class">httr::Token</a>
</p>

<hr>
<h2 id='build_authorization_uri'>Standalone OAuth authorization functions</h2><span id='topic+build_authorization_uri'></span><span id='topic+get_device_creds'></span>

<h3>Description</h3>

<p>Standalone OAuth authorization functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_authorization_uri(
  resource,
  tenant,
  app,
  username = NULL,
  ...,
  aad_host = "https://login.microsoftonline.com/",
  version = 1
)

get_device_creds(
  resource,
  tenant,
  app,
  aad_host = "https://login.microsoftonline.com/",
  version = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_authorization_uri_+3A_resource">resource</code>, <code id="build_authorization_uri_+3A_tenant">tenant</code>, <code id="build_authorization_uri_+3A_app">app</code>, <code id="build_authorization_uri_+3A_aad_host">aad_host</code>, <code id="build_authorization_uri_+3A_version">version</code></td>
<td>
<p>See the corresponding arguments for <a href="#topic+get_azure_token">get_azure_token</a>.</p>
</td></tr>
<tr><td><code id="build_authorization_uri_+3A_username">username</code></td>
<td>
<p>For <code>build_authorization_uri</code>, an optional login hint to be sent to the authorization endpoint.</p>
</td></tr>
<tr><td><code id="build_authorization_uri_+3A_...">...</code></td>
<td>
<p>Named arguments that will be added to the authorization URI as query parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are mainly for use in embedded scenarios, such as within a Shiny web app. In this case, the interactive authentication flows (authorization code and device code) need to be split up so that the authorization step is handled separately from the token acquisition step. You should not need to use these functions inside a regular R session, or when executing an R batch script.
</p>


<h3>Value</h3>

<p>For <code>build_authorization_uri</code>, the authorization URI as a string. This can be set as a redirect from within a Shiny app's UI component.
</p>
<p>For <code>get_device_creds</code>, a list containing the following components:
</p>

<ul>
<li> <p><code>user_code</code>: A short string to be shown to the user
</p>
</li>
<li> <p><code>device_code</code>: A long string to verify the session with the AAD server
</p>
</li>
<li> <p><code>verification_uri</code>: The URI the user should browse to in order to login
</p>
</li>
<li> <p><code>expires_in</code>: The duration in seconds for which the user and device codes are valid
</p>
</li>
<li> <p><code>interval</code>: The interval between polling requests to the AAD token endpoint
</p>
</li>
<li> <p><code>message</code>: A string with login instructions for the user
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>build_authorization_uri("https://myresource", "mytenant", "app_id",
                        redirect_uri="http://localhost:8100")

## Not run: 

## obtaining an authorization code separately to acquiring the token
# first, get the authorization URI
auth_uri &lt;- build_authorization_uri("https://management.azure.com/", "mytenant", "app_id")
# browsing to the URI will log you in and redirect to another URI containing the auth code
browseURL(auth_uri)
# use the code to acquire the token
get_azure_token("https://management.azure.com/", "mytenant", "app_id",
    auth_code="code-from-redirect")


## obtaining device credentials separately to acquiring the token
# first, contact the authorization endpoint to get the user and device codes
creds &lt;- get_device_creds("https://management.azure.com/", "mytenant", "app_id")
# print the login instructions
creds$message
# use the creds to acquire the token
get_azure_token("https://management.azure.com/", "mytenant", "app_id",
    auth_type="device_code", device_creds=creds)


## End(Not run)
</code></pre>

<hr>
<h2 id='cert_assertion'>Create a client assertion for certificate authentication</h2><span id='topic+cert_assertion'></span>

<h3>Description</h3>

<p>Create a client assertion for certificate authentication
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cert_assertion(certificate, duration = 3600, signature_size = 256, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cert_assertion_+3A_certificate">certificate</code></td>
<td>
<p>An Azure Key Vault certificate object, or the name of a PEM or PFX file containing <em>both</em> a private key and a public certificate.</p>
</td></tr>
<tr><td><code id="cert_assertion_+3A_duration">duration</code></td>
<td>
<p>The requested validity period of the token, in seconds. The default is 1 hour.</p>
</td></tr>
<tr><td><code id="cert_assertion_+3A_signature_size">signature_size</code></td>
<td>
<p>The size of the SHA2 signature.</p>
</td></tr>
<tr><td><code id="cert_assertion_+3A_...">...</code></td>
<td>
<p>Other named arguments which will be treated as custom claims.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to customise a client assertion for authenticating with a certificate.
</p>


<h3>Value</h3>

<p>An object of S3 class <code>cert_assertion</code>, which is a list representing the assertion.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_azure_token">get_azure_token</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

cert_assertion("mycert.pem", duration=2*3600)
cert_assertion("mycert.pem", custom_data="some text")

# using a cert stored in Azure Key Vault
cert &lt;- AzureKeyVault::key_vault("myvault")$certificates$get("mycert")
cert_assertion(cert, duration=2*3600)


## End(Not run)
</code></pre>

<hr>
<h2 id='decode_jwt'>Get raw access token (which is a JWT object)</h2><span id='topic+decode_jwt'></span><span id='topic+decode_jwt.AzureToken'></span><span id='topic+decode_jwt.Token'></span><span id='topic+decode_jwt.character'></span><span id='topic+extract_jwt'></span><span id='topic+extract_jwt.AzureToken'></span><span id='topic+extract_jwt.Token'></span><span id='topic+extract_jwt.character'></span>

<h3>Description</h3>

<p>Get raw access token (which is a JWT object)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_jwt(token, ...)

## S3 method for class 'AzureToken'
decode_jwt(token, type = c("access", "id"), ...)

## S3 method for class 'Token'
decode_jwt(token, type = c("access", "id"), ...)

## S3 method for class 'character'
decode_jwt(token, ...)

extract_jwt(token, ...)

## S3 method for class 'AzureToken'
extract_jwt(token, type = c("access", "id"), ...)

## S3 method for class 'Token'
extract_jwt(token, type = c("access", "id"), ...)

## S3 method for class 'character'
extract_jwt(token, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_jwt_+3A_token">token</code></td>
<td>
<p>A token object. This can be an object of class <code>AzureToken</code>, of class <code>httr::Token</code>, or a character string containing the encoded token.</p>
</td></tr>
<tr><td><code id="decode_jwt_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="decode_jwt_+3A_type">type</code></td>
<td>
<p>For the <code>AzureToken</code> and <code>httr::Token</code> methods, the token to decode/retrieve: either the access token or ID token.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An OAuth token is a <em>JSON Web Token</em>, which is a set of base64URL-encoded JSON objects containing the token credentials along with an optional (opaque) verification signature. <code>decode_jwt</code> decodes the credentials into an R object so they can be viewed. <code>extract_jwt</code> extracts the credentials from an R object of class <code>AzureToken</code> or <code>httr::Token</code>.
</p>
<p>Note that <code>decode_jwt</code> does not touch the token signature or attempt to verify the credentials. You should not rely on the decoded information without verifying it independently. Passing the token itself to Azure is safe, as Azure will carry out its own verification procedure.
</p>


<h3>Value</h3>

<p>For <code>extract_jwt</code>, the character string containing the encoded token, suitable for including in a HTTP query. For <code>decode_jwt</code>, a list containing up to 3 components: <code>header</code>, <code>payload</code> and <code>signature</code>.
</p>


<h3>See Also</h3>

<p><a href="https://jwt.io">jwt.io</a>, the main JWT informational site
</p>
<p><a href="https://jwt.ms">jwt.ms</a>, Microsoft site to decode and explain JWTs
</p>
<p><a href="https://en.wikipedia.org/wiki/JSON_Web_Token">JWT Wikipedia entry</a>
</p>

<hr>
<h2 id='format_auth_header'>Format an AzureToken object</h2><span id='topic+format_auth_header'></span>

<h3>Description</h3>

<p>Format an AzureToken object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_auth_header(token)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_auth_header_+3A_token">token</code></td>
<td>
<p>An Azure OAuth token.</p>
</td></tr>
</table>

<hr>
<h2 id='get_managed_token'>Manage Azure Active Directory OAuth 2.0 tokens</h2><span id='topic+get_managed_token'></span><span id='topic+get_azure_token'></span><span id='topic+delete_azure_token'></span><span id='topic+load_azure_token'></span><span id='topic+clean_token_directory'></span><span id='topic+list_azure_tokens'></span><span id='topic+token_hash'></span><span id='topic+is_azure_token'></span><span id='topic+is_azure_v1_token'></span><span id='topic+is_azure_v2_token'></span>

<h3>Description</h3>

<p>Use these functions to authenticate with Azure Active Directory (AAD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_managed_token(resource, token_args = list(), use_cache = NULL)

get_azure_token(
  resource,
  tenant,
  app,
  password = NULL,
  username = NULL,
  certificate = NULL,
  auth_type = NULL,
  aad_host = "https://login.microsoftonline.com/",
  version = 1,
  authorize_args = list(),
  token_args = list(),
  use_cache = NULL,
  on_behalf_of = NULL,
  auth_code = NULL,
  device_creds = NULL
)

delete_azure_token(
  resource,
  tenant,
  app,
  password = NULL,
  username = NULL,
  certificate = NULL,
  auth_type = NULL,
  aad_host = "https://login.microsoftonline.com/",
  version = 1,
  authorize_args = list(),
  token_args = list(),
  on_behalf_of = NULL,
  hash = NULL,
  confirm = TRUE
)

load_azure_token(hash)

clean_token_directory(confirm = TRUE)

list_azure_tokens()

token_hash(
  resource,
  tenant,
  app,
  password = NULL,
  username = NULL,
  certificate = NULL,
  auth_type = NULL,
  aad_host = "https://login.microsoftonline.com/",
  version = 1,
  authorize_args = list(),
  token_args = list(),
  on_behalf_of = NULL
)

is_azure_token(object)

is_azure_v1_token(object)

is_azure_v2_token(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_managed_token_+3A_resource">resource</code></td>
<td>
<p>For AAD v1.0, the URL of your resource host, or a GUID. For AAD v2.0, a character vector of scopes, each consisting of a URL or GUID along with a path designating the access scope. See 'Details' below.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_token_args">token_args</code></td>
<td>
<p>An optional list of further parameters for the token endpoint. These will be included in the body of the request for <code>get_azure_token</code>, or as URI query parameters for <code>get_managed_token</code>.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_use_cache">use_cache</code></td>
<td>
<p>If TRUE and cached credentials exist, use them instead of obtaining a new token. The default value of NULL means to use the cache only if AzureAuth is not running inside a Shiny app.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_tenant">tenant</code></td>
<td>
<p>Your tenant. This can be a name (&quot;myaadtenant&quot;), a fully qualified domain name (&quot;myaadtenant.onmicrosoft.com&quot; or &quot;mycompanyname.com&quot;), or a GUID. It can also be one of the generic tenants &quot;common&quot;, &quot;organizations&quot; or &quot;consumers&quot;; see 'Generic tenants' below.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_app">app</code></td>
<td>
<p>The client/app ID to use to authenticate with.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_password">password</code></td>
<td>
<p>For most authentication flows, this is the password for the <em>app</em> where needed, also known as the client secret. For the resource owner grant, this is your personal account password. See 'Details' below.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_username">username</code></td>
<td>
<p>Your AAD username, if using the resource owner grant. See 'Details' below.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_certificate">certificate</code></td>
<td>
<p>A file containing the certificate for authenticating with (including the private key), an Azure Key Vault certificate object, or a call to the <code>cert_assertion</code> function to build a client assertion with a certificate. See 'Certificate authentication' below.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_auth_type">auth_type</code></td>
<td>
<p>The authentication type. See 'Details' below.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_aad_host">aad_host</code></td>
<td>
<p>URL for your AAD host. For the public Azure cloud, this is <code style="white-space: pre;">&#8288;https://login.microsoftonline.com/&#8288;</code>. Change this if you are using a government or private cloud. Can also be a full URL, eg <code style="white-space: pre;">&#8288;https://mydomain.b2clogin.com/mydomain/other/path/names/oauth2&#8288;</code> (this is relevant mainly for Azure B2C logins).</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_version">version</code></td>
<td>
<p>The AAD version, either 1 or 2. Authenticating with a personal account as opposed to a work or school account requires AAD 2.0. The default is AAD 1.0 for compatibility reasons, but you should use AAD 2.0 if possible.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_authorize_args">authorize_args</code></td>
<td>
<p>An optional list of further parameters for the AAD authorization endpoint. These will be included in the request URI as query parameters. Only used if <code>auth_type="authorization_code"</code>.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_on_behalf_of">on_behalf_of</code></td>
<td>
<p>For the on-behalf-of authentication type, a token. This should be either an AzureToken object, or a string containing the JWT-encoded token itself.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_auth_code">auth_code</code></td>
<td>
<p>For the <code>authorization_code</code> flow, the code. Only used if <code>auth_type == "authorization_code"</code>.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_device_creds">device_creds</code></td>
<td>
<p>For the <code>device_code</code> flow, the device credentials used to verify the session between the client and the server. Only used if <code>auth_type == "device_code"</code>.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_hash">hash</code></td>
<td>
<p>The MD5 hash of this token, computed from the above inputs. Used by <code>load_azure_token</code> and <code>delete_azure_token</code> to identify a cached token to load and delete, respectively.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_confirm">confirm</code></td>
<td>
<p>For <code>delete_azure_token</code>, whether to prompt for confirmation before deleting a token.</p>
</td></tr>
<tr><td><code id="get_managed_token_+3A_object">object</code></td>
<td>
<p>For <code>is_azure_token</code>, <code>is_azure_v1_token</code> and <code>is_azure_v2_token</code>, an R object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_azure_token</code> does much the same thing as <code><a href="httr.html#topic+oauth2.0_token">httr::oauth2.0_token()</a></code>, but customised for Azure. It obtains an OAuth token, first by checking if a cached value exists on disk, and if not, acquiring it from the AAD server. <code>load_azure_token</code> loads a token given its hash, <code>delete_azure_token</code> deletes a cached token given either the credentials or the hash, and <code>list_azure_tokens</code> lists currently cached tokens.
</p>
<p><code>get_managed_token</code> is a specialised function to acquire tokens for a <em>managed identity</em>. This is an Azure service, such as a VM or container, that has been assigned its own identity and can be granted access permissions like a regular user. The advantage of managed identities over the other authentication methods (see below) is that you don't have to store a secret password, which improves security. Note that <code>get_managed_token</code> can only be used from within the managed identity itself.
</p>
<p>By default <code>get_managed_token</code> retrieves a token using the system-assigned identity for the resource. To obtain a token with a user-assigned identity, pass either the client, object or Azure resource ID in the <code>token_args</code> argument. See the examples below.
</p>
<p>The <code>resource</code> arg should be a single URL or GUID for AAD v1.0. For AAD v2.0, it should be a vector of <em>scopes</em>, where each scope consists of a URL or GUID along with a path that designates the type of access requested. If a v2.0 scope doesn't have a path, <code>get_azure_token</code> will append the <code style="white-space: pre;">&#8288;/.default&#8288;</code> path with a warning. A special scope is <code>offline_access</code>, which requests a refresh token from AAD along with the access token: without this scope, you will have to reauthenticate if you want to refresh the token.
</p>
<p>The <code>auth_code</code> and <code>device_creds</code> arguments are intended for use in embedded scenarios, eg when AzureAuth is loaded from within a Shiny web app. They enable the flow authorization step to be separated from the token acquisition step, which is necessary within an app; you can generally ignore these arguments when using AzureAuth interactively or as part of an R script. See the help for <a href="#topic+build_authorization_uri">build_authorization_uri</a> for examples on their use.
</p>
<p><code>token_hash</code> computes the MD5 hash of its arguments. This is used by AzureAuth to identify tokens for caching purposes. Note that tokens are only cached if you allowed AzureAuth to create a data directory at package startup.
</p>
<p>One particular use of the <code>authorize_args</code> argument is to specify a different redirect URI to the default; see the examples below.
</p>


<h3>Authentication methods</h3>


<ol>
<li><p> Using the <strong>authorization_code</strong> method is a multi-step process. First, <code>get_azure_token</code> opens a login window in your browser, where you can enter your AAD credentials. In the background, it loads the <a href="https://github.com/rstudio/httpuv">httpuv</a> package to listen on a local port. Once you have logged in, the AAD server redirects your browser to a local URL that contains an authorization code. <code>get_azure_token</code> retrieves this authorization code and sends it to the AAD access endpoint, which returns the OAuth token.
</p>
</li>
<li><p> The <strong>device_code</strong> method is similar in concept to authorization_code, but is meant for situations where you are unable to browse the Internet &ndash; for example if you don't have a browser installed or your computer has input constraints. First, <code>get_azure_token</code> contacts the AAD devicecode endpoint, which responds with a login URL and an access code. You then visit the URL and enter the code, possibly using a different computer. Meanwhile, <code>get_azure_token</code> polls the AAD access endpoint for a token, which is provided once you have entered the code.
</p>
</li>
<li><p> The <strong>client_credentials</strong> method is much simpler than the above methods, requiring only one step. <code>get_azure_token</code> contacts the access endpoint, passing it either the app secret or the certificate assertion (which you supply in the <code>password</code> or <code>certificate</code> argument respectively). Once the credentials are verified, the endpoint returns the token. This is the method typically used by service accounts.
</p>
</li>
<li><p> The <strong>resource_owner</strong> method also requires only one step. In this method, <code>get_azure_token</code> passes your (personal) username and password to the AAD access endpoint, which validates your credentials and returns the token.
</p>
</li>
<li><p> The <strong>on_behalf_of</strong> method is used to authenticate with an Azure resource by passing a token obtained beforehand. It is mostly used by intermediate apps to authenticate for users. In particular, you can use this method to obtain tokens for multiple resources, while only requiring the user to authenticate once: see the examples below.
</p>
</li></ol>

<p>If the authentication method is not specified, it is chosen based on the presence or absence of the other arguments, and whether httpuv is installed.
</p>
<p>The httpuv package must be installed to use the authorization_code method, as this requires a web server to listen on the (local) redirect URI. See <a href="httr.html#topic+oauth2.0_token">httr::oauth2.0_token</a> for more information; note that Azure does not support the <code>use_oob</code> feature of the httr OAuth 2.0 token class.
</p>
<p>Similarly, since the authorization_code method opens a browser to load the AAD authorization page, your machine must have an Internet browser installed that can be run from inside R. In particular, if you are using a Linux <a href="https://azure.microsoft.com/en-us/services/virtual-machines/data-science-virtual-machines/">Data Science Virtual Machine</a> in Azure, you may run into difficulties; use one of the other methods instead.
</p>


<h3>Certificate authentication</h3>

<p>OAuth tokens can be authenticated via an SSL/TLS certificate, which is considered more secure than a client secret. To do this, use the <code>certificate</code> argument, which can contain any of the following:
</p>

<ul>
<li><p> The name of a PEM or PFX file, containing <em>both</em> the private key and the public certificate.
</p>
</li>
<li><p> A certificate object from the AzureKeyVault package, representing a cert stored in the Key Vault service.
</p>
</li>
<li><p> A call to the <code>cert_assertion()</code> function to customise details of the requested token, eg the duration, expiry date, custom claims, etc. See the examples below.
</p>
</li></ul>



<h3>Generic tenants</h3>

<p>There are 3 generic values that can be used as tenants when authenticating:</p>

<table>
<tr>
 <td style="text-align: left;">
   Tenant </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>common</code> </td><td style="text-align: left;"> Allows users with both personal Microsoft accounts and work/school accounts from Azure AD to sign into the application. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>organizations</code> </td><td style="text-align: left;"> Allows only users with work/school accounts from Azure AD to sign into the application. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>consumers</code> </td><td style="text-align: left;"> Allows only users with personal Microsoft accounts (MSA) to sign into the application. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Authentication vs authorization</h3>

<p>Azure Active Directory can be used for two purposes: <em>authentication</em> (verifying that a user is who they claim they are) and <em>authorization</em> (granting a user permission to access a resource). In AAD, a successful authorization process concludes with the granting of an OAuth 2.0 access token, as discussed above. Authentication uses the same process but concludes by granting an ID token, as defined in the OpenID Connect protocol.
</p>
<p><code>get_azure_token</code> can be used to obtain ID tokens along with regular OAuth access tokens, when using an interactive flow (authorization_code or device_code). The behaviour depends on the AAD version:
</p>
<p>When retrieving ID tokens, the behaviour depends on the AAD version:
</p>

<ul>
<li><p> AAD v1.0 will return an ID token as well as the access token by default; you don't have to do anything extra. However, AAD v1.0 will not <em>refresh</em> the ID token when it expires; you must reauthenticate to get a new one. To ensure you don't pull the cached version of the credentials, specify <code>use_cache=FALSE</code> in the calls to <code>get_azure_token</code>.
</p>
</li>
<li><p> Unlike AAD v1.0, AAD v2.0 does not return an ID token by default. To get a token, include <code>openid</code> as a scope. On the other hand it <em>does</em> refresh the ID token, so bypassing the cache is not needed. It's recommended to use AAD v2.0 if you only want an ID token.
</p>
</li></ul>

<p>If you <em>only</em> want to do authentication and not authorization (for example if your app does not use any Azure resources), specify the <code>resource</code> argument as follows:
</p>

<ul>
<li><p> For AAD v1.0, use a blank resource (<code>resource=""</code>).
</p>
</li>
<li><p> For AAD v2.0, use <code>resource="openid"</code> without any other elements. Optionally you can add <code>"offline_access"</code> as a 2nd element if you want a refresh token as well.
</p>
</li></ul>

<p>See also the examples below.
</p>


<h3>Caching</h3>

<p>AzureAuth caches tokens based on all the inputs to <code>get_azure_token</code> as listed above. Tokens are cached in a custom, user-specific directory, created with the rappdirs package. On recent Windows versions, this will usually be in the location <code style="white-space: pre;">&#8288;C:\\Users\\(username)\\AppData\\Local\\AzureR&#8288;</code>. On Linux, it will be in <code style="white-space: pre;">&#8288;~/.config/AzureR&#8288;</code>, and on MacOS, it will be in <code style="white-space: pre;">&#8288;~/Library/Application Support/AzureR&#8288;</code>. Alternatively, you can specify the location of the directory in the environment variable <code>R_AZURE_DATA_DIR</code>. Note that a single directory is used for all tokens, and the working directory is not touched (which significantly lessens the risk of accidentally introducing cached tokens into source control).
</p>
<p>To list all cached tokens on disk, use <code>list_azure_tokens</code>. This returns a list of token objects, named according to their MD5 hashes.
</p>
<p>To delete a cached token, use <code>delete_azure_token</code>. This takes the same inputs as <code>get_azure_token</code>, or you can specify the MD5 hash directly in the <code>hash</code> argument.
</p>
<p>To delete all files in the caching directory, use <code>clean_token_directory</code>.
</p>


<h3>Refreshing</h3>

<p>A token object can be refreshed by calling its <code>refresh()</code> method. If the token's credentials contain a refresh token, this is used; otherwise a new access token is obtained by reauthenticating.
</p>
<p>Note that in AAD, a refresh token can be used to obtain an access token for any resource or scope that you have permissions for. Thus, for example, you could use a refresh token issued on a request for Azure Resource Manager (<code style="white-space: pre;">&#8288;https://management.azure.com/&#8288;</code>) to obtain a new access token for Microsoft Graph (<code style="white-space: pre;">&#8288;https://graph.microsoft.com/&#8288;</code>).
</p>
<p>To obtain an access token for a new resource, change the object's <code>resource</code> (for an AAD v1.0 token) or <code>scope</code> field (for an AAD v2.0 token) before calling <code>refresh()</code>. If you <em>also</em> want to retain the token for the old resource, you should call the <code>clone()</code> method first to create a copy. See the examples below.
</p>


<h3>Value</h3>

<p>For <code>get_azure_token</code>, an object inheriting from <code>AzureToken</code>. The specific class depends on the authentication flow: <code>AzureTokenAuthCode</code>, <code>AzureTokenDeviceCode</code>, <code>AzureTokenClientCreds</code>, <code>AzureTokenOnBehalfOf</code>, <code>AzureTokenResOwner</code>. For <code>get_managed_token</code>, a similar object of class <code>AzureTokenManaged</code>.
</p>
<p>For <code>list_azure_tokens</code>, a list of such objects retrieved from disk.
</p>
<p>The actual credentials that are returned from the authorization endpoint can be found in the <code>credentials</code> field, the same as with a <code>httr::Token</code> object. The access token (if present) will be <code>credentials$access_token</code>, and the ID token (if present) will be <code>credentials$id_token</code>. Use these if you are manually constructing a HTTP request and need to insert an &quot;Authorization&quot; header, for example.
</p>


<h3>See Also</h3>

<p><a href="#topic+AzureToken">AzureToken</a>, <a href="httr.html#topic+oauth2.0_token">httr::oauth2.0_token</a>, <a href="httr.html#topic+Token-class">httr::Token</a>, <a href="#topic+cert_assertion">cert_assertion</a>,
<a href="#topic+build_authorization_uri">build_authorization_uri</a>, <a href="#topic+get_device_creds">get_device_creds</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/">Azure Active Directory for developers</a>,
<a href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview">Managed identities overview</a>
<a href="https://www.oauth.com/oauth2-servers/device-flow/token-request/">Device code flow on OAuth.com</a>,
<a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0 RFC</a> for the gory details on how OAuth works
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# authenticate with Azure Resource Manager:
# no user credentials are supplied, so this will use the authorization_code
# method if httpuv is installed, and device_code if not
get_azure_token("https://management.azure.com/", tenant="mytenant", app="app_id")

# you can force a specific authentication method with the auth_type argument
get_azure_token("https://management.azure.com/", tenant="mytenant", app="app_id",
    auth_type="device_code")

# to default to the client_credentials method, supply the app secret as the password
get_azure_token("https://management.azure.com/", tenant="mytenant", app="app_id",
    password="app_secret")

# authenticate to your resource with the resource_owner method: provide your username and password
get_azure_token("https://myresource/", tenant="mytenant", app="app_id",
    username="user", password="abcdefg")

# obtaining multiple tokens: authenticate (interactively) once...
tok0 &lt;- get_azure_token("serviceapp_id", tenant="mytenant", app="clientapp_id",
    auth_type="authorization_code")
# ...then get tokens for each resource (Resource Manager and MS Graph) with on_behalf_of
tok1 &lt;- get_azure_token("https://management.azure.com/", tenant="mytenant", app="serviceapp_id",
    password="serviceapp_secret", on_behalf_of=tok0)
tok2 &lt;- get_azure_token("https://graph.microsoft.com/", tenant="mytenant", app="serviceapp_id",
    password="serviceapp_secret", on_behalf_of=tok0)


# authorization_code flow with app registered in AAD as a web rather than a native client:
# supply the client secret in the password arg
get_azure_token("https://management.azure.com/", "mytenant", "app_id",
    password="app_secret", auth_type="authorization_code")


# use a different redirect URI to the default localhost:1410
get_azure_token("https://management.azure.com/", tenant="mytenant", app="app_id",
    authorize_args=list(redirect_uri="http://localhost:8000"))


# request an AAD v1.0 token for Resource Manager (the default)
token1 &lt;- get_azure_token("https://management.azure.com/", "mytenant", "app_id")

# same request to AAD v2.0, along with a refresh token
token2 &lt;- get_azure_token(c("https://management.azure.com/.default", "offline_access"),
    "mytenant", "app_id", version=2)

# requesting multiple scopes (Microsoft Graph) with AAD 2.0
get_azure_token(c("https://graph.microsoft.com/User.Read.All",
                  "https://graph.microsoft.com/User.ReadWrite.All",
                  "https://graph.microsoft.com/Directory.ReadWrite.All",
                  "offline_access"),
    "mytenant", "app_id", version=2)


# list saved tokens
list_azure_tokens()

# delete a saved token from disk
delete_azure_token(resource="https://myresource/", tenant="mytenant", app="app_id",
    username="user", password="abcdefg")

# delete a saved token by specifying its MD5 hash
delete_azure_token(hash="7ea491716e5b10a77a673106f3f53bfd")


# authenticating for B2C logins (custom AAD host)
get_azure_token("https://mydomain.com", "mytenant", "app_id", "password",
    aad_host="https://mytenant.b2clogin.com/tfp/mytenant.onmicrosoft.com/custom/oauth2")


# authenticating with a certificate
get_azure_token("https://management.azure.com/", "mytenant", "app_id",
    certificate="mycert.pem")

# authenticating with a certificate stored in Azure Key Vault
cert &lt;- AzureKeyVault::key_vault("myvault")$certificates$get("mycert")
get_azure_token("https://management.azure.com/", "mytenant", "app_id",
    certificate=cert)

# get a token valid for 2 hours (default is 1 hour)
get_azure_token("https://management.azure.com/", "mytenant", "app_id",
    certificate=cert_assertion("mycert.pem", duration=2*3600))


# ID token with AAD v1.0
# if you only want an ID token, set the resource to blank ("")
tok &lt;- get_azure_token("", "mytenant", "app_id", use_cache=FALSE)
extract_jwt(tok, "id")

# ID token with AAD v2.0 (recommended)
tok2 &lt;- get_azure_token(c("openid", "offline_access"), "mytenant", "app_id", version=2)
extract_jwt(tok2, "id")


# get a token from within a managed identity (VM, container or service)
get_managed_token("https://management.azure.com/")

# get a token from a managed identity, with a user-defined identity:
# specify one of the identity's object_id, client_id and mi_res_id (Azure resource ID)
# you can get these values via the Azure Portal or Azure CLI
get_managed_token("https://management.azure.com/", token_args=list(
    mi_res_id="/subscriptions/zzzz-zzzz/resourceGroups/resgroupname/..."
))

# use a refresh token from one resource to get an access token for another resource
tok &lt;- get_azure_token("https://myresource", "mytenant", "app_id")
tok2 &lt;- tok$clone()
tok2$resource &lt;- "https://anotherresource"
tok2$refresh()

# same for AAD v2.0
tok &lt;- get_azure_token(c("https://myresource/.default", "offline_access"),
    "mytenant", "app_id", version=2)
tok2 &lt;- tok$clone()
tok2$scope &lt;- c("https://anotherresource/.default", "offline_access")
tok2$refresh()


# manually adding auth header for a HTTP request
tok &lt;- get_azure_token("https://myresource", "mytenant", "app_id")
header &lt;- httr::add_headers(Authorization=paste("Bearer", tok$credentials$access_token))
httr::GET("https://myresource/path/for/call", header, ...)


## End(Not run)
</code></pre>

<hr>
<h2 id='normalize_tenant'>Normalize GUID and tenant values</h2><span id='topic+normalize_tenant'></span><span id='topic+normalize_guid'></span><span id='topic+is_guid'></span>

<h3>Description</h3>

<p>These functions are used by <code>get_azure_token</code> to recognise and properly format tenant and app IDs. <code>is_guid</code> can also be used generically for identifying GUIDs/UUIDs in any context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_tenant(tenant)

normalize_guid(x)

is_guid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_tenant_+3A_tenant">tenant</code></td>
<td>
<p>For <code>normalize_tenant</code>, a string containing an Azure Active Directory tenant. This can be a name (&quot;myaadtenant&quot;), a fully qualified domain name (&quot;myaadtenant.onmicrosoft.com&quot; or &quot;mycompanyname.com&quot;), or a valid GUID.</p>
</td></tr>
<tr><td><code id="normalize_tenant_+3A_x">x</code></td>
<td>
<p>For <code>is_guid</code>, a character string; for <code>normalize_guid</code>, a string containing a <em>validly formatted</em> GUID.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tenant can be identified either by a GUID, or its name, or a fully-qualified domain name (FQDN). The rules for normalizing a tenant are:
</p>

<ol>
<li><p> If <code>tenant</code> is recognised as a valid GUID, return its canonically formatted value
</p>
</li>
<li><p> Otherwise, if it is a FQDN, return it
</p>
</li>
<li><p> Otherwise, if it is one of the generic tenants &quot;common&quot;, &quot;organizations&quot; or &quot;consumers&quot;, return it
</p>
</li>
<li><p> Otherwise, append &quot;.onmicrosoft.com&quot; to it
</p>
</li></ol>

<p>These functions are vectorised. See the link below for the GUID formats they accept.
</p>


<h3>Value</h3>

<p>For <code>is_guid</code>, a logical vector indicating which values of <code>x</code> are validly formatted GUIDs.
</p>
<p>For <code>normalize_guid</code>, a vector of GUIDs in canonical format. If any values of <code>x</code> are not recognised as GUIDs, it throws an error.
</p>
<p>For <code>normalize_tenant</code>, the normalized tenant IDs or names.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_azure_token">get_azure_token</a>
</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.guid.parse">Parsing rules for GUIDs in .NET</a>. <code>is_guid</code> and <code>normalize_guid</code> recognise the &quot;N&quot;, &quot;D&quot;, &quot;B&quot; and &quot;P&quot; formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
is_guid("72f988bf-86f1-41af-91ab-2d7cd011db47")    # TRUE
is_guid("{72f988bf-86f1-41af-91ab-2d7cd011db47}")  # TRUE
is_guid("72f988bf-86f1-41af-91ab-2d7cd011db47}")   # FALSE (unmatched brace)
is_guid("microsoft")                               # FALSE

# all of these return the same value
normalize_guid("72f988bf-86f1-41af-91ab-2d7cd011db47")
normalize_guid("{72f988bf-86f1-41af-91ab-2d7cd011db47}")
normalize_guid("(72f988bf-86f1-41af-91ab-2d7cd011db47)")
normalize_guid("72f988bf86f141af91ab2d7cd011db47")

normalize_tenant("microsoft")     # returns 'microsoft.onmicrosoft.com'
normalize_tenant("microsoft.com") # returns 'microsoft.com'
normalize_tenant("72f988bf-86f1-41af-91ab-2d7cd011db47") # returns the GUID

# vector arguments are accepted
ids &lt;- c("72f988bf-86f1-41af-91ab-2d7cd011db47", "72f988bf86f141af91ab2d7cd011db47")
is_guid(ids)
normalize_guid(ids)
normalize_tenant(c("microsoft", ids))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
