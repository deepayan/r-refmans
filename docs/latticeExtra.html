<!DOCTYPE html><html lang="en"><head><title>Help for package latticeExtra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {latticeExtra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ancestry'><p> Modal ancestry by County according to US 2000 Census</p></a></li>
<li><a href='#as.layer'><p> Overlay panels of Trellis plots on same or different scales</p></a></li>
<li><a href='#biocAccess'><p> Hourly access attempts to Bioconductor website</p></a></li>
<li><a href='#c.trellis'><p> Merge trellis objects, using same or different scales</p></a></li>
<li><a href='#combineLimits'><p>Combine axis limits across margins</p></a></li>
<li><a href='#custom.theme'><p> Create a lattice theme based on specified colors</p></a></li>
<li><a href='#dendrogramGrob'><p> Create a Grob Representing a Dendrogram</p></a></li>
<li><a href='#doubleYScale'><p> Draw two plot series with different y scales</p></a></li>
<li><a href='#EastAuClimate'><p> Climate of the East Coast of Australia</p></a></li>
<li><a href='#ecdfplot'><p>Trellis Displays of Empirical CDF</p></a></li>
<li><a href='#ggplot2like.theme'><p>A ggplot2-like theme for Lattice</p></a></li>
<li><a href='#gvhd10'><p> Flow cytometry data from five samples from a patient</p></a></li>
<li><a href='#horizonplot'><p>Plot many time series in parallel</p></a></li>
<li><a href='#layer'><p> Add layers to a lattice plot, optionally using a new data source</p></a></li>
<li><a href='#mapplot'><p> Trellis displays on Maps a.k.a. Choropleth maps</p></a></li>
<li><a href='#marginal.plot'><p> Display marginal distributions</p></a></li>
<li><a href='#panel.2dsmoother'>
<p>Plot a smooth approximation of z over x and y.</p></a></li>
<li><a href='#panel.3dmisc'><p>Miscellanous panel utilities for three dimensional Trellis Displays</p></a></li>
<li><a href='#panel.ellipse'>
<p>Lattice panel function to fit and draw a confidence ellipsoid from</p>
bivariate data.</a></li>
<li><a href='#panel.key'>
<p>Draw a simple key inside a panel of a lattice plot.</p></a></li>
<li><a href='#panel.lmlineq'>
<p>Draw a line with a label, by default its equation</p></a></li>
<li><a href='#panel.qqmath.tails'>
<p>Approximate distribution in qqmath but keep points on tails.</p></a></li>
<li><a href='#panel.quantile'>
<p>Plot a quantile regression line with standard error bounds.</p></a></li>
<li><a href='#panel.scaleArrow'>
<p>Draw a scale bar as an arrow, labelled with its length in plot units.</p></a></li>
<li><a href='#panel.segplot'><p> Default prepanel and panel functions for segplot</p></a></li>
<li><a href='#panel.smoother'>
<p>Plot a smoothing line with standard error bounds.</p></a></li>
<li><a href='#panel.tskernel'>
<p>Calculate and plot smoothed time series.</p></a></li>
<li><a href='#panel.voronoi'><p> Panel functions for level-coded irregular points</p></a></li>
<li><a href='#panel.xblocks'>
<p>Plot contiguous blocks along x axis.</p></a></li>
<li><a href='#panel.xyarea'>
<p>Plot series as filled polygons.</p></a></li>
<li><a href='#panel.xyimage'>
<p>Scatter plots using emoji-like images</p></a></li>
<li><a href='#postdoc'><p> Reasons for Taking First Postdoctoral Appointment</p></a></li>
<li><a href='#resizePanels'><p> Resize panels to match data scales</p></a></li>
<li><a href='#rootogram'><p>Trellis Displays of Tukey's Hanging Rootograms</p></a></li>
<li><a href='#scale.components'><p> Custom lattice axis scales</p></a></li>
<li><a href='#SeatacWeather'><p> Daily Rainfall and Temperature at the Seattle-Tacoma Airport</p></a></li>
<li><a href='#segplot'><p> Plot segments using the Trellis framework</p></a></li>
<li><a href='#theEconomist.theme'>
<p>Generate plots with style like The Economist.</p></a></li>
<li><a href='#tileplot'><p> Plot a spatial mosaic from irregular 2D points</p></a></li>
<li><a href='#USAge'><p> US national population estimates</p></a></li>
<li><a href='#USCancerRates'><p> Rate of Death Due to Cancer in US Counties</p></a></li>
<li><a href='#useOuterStrips'><p> Put Strips on the Boundary of a Lattice Display</p></a></li>
<li><a href='#xyplot.stl'><p> Display stl fits with Lattice</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.6-30</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Extra Graphical Utilities Based on Lattice</td>
</tr>
<tr>
<td>Author:</td>
<td>Deepayan Sarkar &lt;deepayan.sarkar@r-project.org&gt;, Felix Andrews &lt;felix@nfrac.org&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Deepayan Sarkar &lt;deepayan.sarkar@r-project.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Building on the infrastructure provided by the lattice
	     package, this package provides several new high-level
	     functions and methods, as well as additional utilities
	     such as panel and axis annotation functions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, stats, utils, grDevices, png, jpeg, RColorBrewer,
interp, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>maps, mapproj, deldir, quantreg, zoo, mgcv</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://latticeextra.r-forge.r-project.org/">http://latticeextra.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-30 07:04:00 UTC; deepayan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-04 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ancestry'> Modal ancestry by County according to US 2000 Census </h2><span id='topic+ancestry'></span>

<h3>Description</h3>

<p>This data set records the population and the three most frequently
reported ancestries by US county, according to the 2000 census.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ancestry)</code></pre>


<h3>Format</h3>

<p>A data frame with 3219 observations on the following 5 variables.
</p>

<dl>
<dt><code>county</code></dt><dd><p> A factor. An attempt has been made to make the
levels look similar to the county names used in the <code>maps</code>
package.  </p>
</dd>
<dt><code>population</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>top</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>second</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>third</code></dt><dd><p>a character vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>U.S. Census Bureau.  The ancestry data were extracted from Summary
File 3, available from
</p>
<p><a href="https://web.archive.org/web/20100703053258/http://www.census.gov/census2000/sumfile3.html">https://web.archive.org/web/20100703053258/http://www.census.gov/census2000/sumfile3.html</a>
</p>
<p>which is based on the &lsquo;long form&rsquo; questionnaire (asked to 1 in
6 households surveyed).
</p>


<h3>References</h3>

<p><a href="https://web.archive.org/web/20100707180939/http://www.census.gov/prod/cen2000/doc/sf3.pdf">https://web.archive.org/web/20100707180939/http://www.census.gov/prod/cen2000/doc/sf3.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mapplot">mapplot</a></code>, for examples.
</p>

<hr>
<h2 id='as.layer'> Overlay panels of Trellis plots on same or different scales </h2><span id='topic+as.layer'></span><span id='topic+as.layer.layer'></span><span id='topic+as.layer.trellis'></span>

<h3>Description</h3>

<p>Allows overlaying of Trellis plots, drawn on the same scales or on
different scales in each of the x and y dimensions.
There are options for custom axes and graphical styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.layer(x, ...)

## S3 method for class 'trellis'
as.layer(x, x.same = TRUE, y.same = TRUE,
         axes = c(if (!x.same) "x", if (!y.same) "y"), opposite = TRUE,
         outside = FALSE, theme = x$par.settings, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.layer_+3A_x">x</code></td>
<td>
<p> a trellis object. </p>
</td></tr>
<tr><td><code id="as.layer_+3A_x.same">x.same</code></td>
<td>
<p> retains the existing panel x scale for the new layer,
rather than using the layer's native x scale. </p>
</td></tr>
<tr><td><code id="as.layer_+3A_y.same">y.same</code></td>
<td>
<p> retains the existing panel y scale. </p>
</td></tr>
<tr><td><code id="as.layer_+3A_axes">axes</code></td>
<td>
<p> which of the axes to draw (<code>NULL</code> for neither).
Axes might not be drawn anyway, such as if
<code>scales$draw == FALSE</code>. </p>
</td></tr>
<tr><td><code id="as.layer_+3A_opposite">opposite</code></td>
<td>
<p> whether to draw axes on the opposite side to normal:
that is, the top and/or right sides rather than bottom and/or
left. May be a vector of length 2 to specify for x and y axes
separately. </p>
</td></tr>
<tr><td><code id="as.layer_+3A_outside">outside</code></td>
<td>
<p> whether to draw the axes outside the plot region. Note
that space for outside axes will not be allocated
automatically. May be a vector of length 2 to specify for x and y axes
separately. </p>
</td></tr>
<tr><td><code id="as.layer_+3A_theme">theme</code></td>
<td>
<p> passed to <code><a href="#topic+layer">layer</a></code>. </p>
</td></tr>
<tr><td><code id="as.layer_+3A_...">...</code></td>
<td>
<p> passed to <code><a href="#topic+layer">layer</a></code>: typically
the <code>style</code> argument would be specified. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Panels from the trellis object <code>x</code> will be drawn in the
corresponding panel of another trellis object, so packet numbers match
(see examples).
</p>
<p>Axis setting are taken from the trellis object <code>x</code>, so most
<code>scales</code> arguments such as <code>draw</code>, <code>at</code>, <code>labels</code> etc will
carry over to the overlaid axes. Only the main axis settings are used
(i.e. left or bottom), even when <code>opposite = TRUE</code>.
</p>
<p>Currently, outside top axes will be drawn in the strip if there are strips.
</p>


<h3>Value</h3>

<p>an updated trellis object.
</p>


<h3>Author(s)</h3>

<p> Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+doubleYScale">doubleYScale</a></code>,
<code><a href="#topic+layer">layer</a></code>,
<code><a href="lattice.html#topic+panel.axis">panel.axis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b1 &lt;- barley
b2 &lt;- barley
b2$yield &lt;- b2$yield + 10

## panels are matched up by packet number
dotplot(variety ~ yield | site * year, b1) +
  as.layer(dotplot(variety ~ yield | site * year, b2, col = "red"))

## which gives the same result as:
dotplot(variety ~ yield | site * year, data = b1, subscripts = TRUE) +
  layer(panel.dotplot(yield[subscripts], variety[subscripts], col = "red"),
        data = b2)


## example with all same scales (the default):
xyplot(fdeaths ~ mdeaths) +
  as.layer(xyplot(fdeaths ~ mdeaths, col = 2, subset = ldeaths &gt; 2000))

## same x scales, different y scales:
xyplot(fdeaths ~ mdeaths) +
  as.layer(bwplot(~ mdeaths, box.ratio = 0.2), y.same = FALSE)

## same y scales, different x scales:
xyplot(fdeaths ~ mdeaths) +
  as.layer(bwplot(fdeaths ~ factor(mdeaths*0), box.ratio = 0.2), x.same = FALSE)

## as.layer() is called automatically if two plots are added:
histogram(~ ldeaths, type = "density") + densityplot(~ ldeaths, lwd = 3)

## applying one panel layer to several panels of another object
xyplot(Sepal.Length + Sepal.Width ~ Petal.Length + Petal.Width | Species,
       data = iris, scales = "free") +
   as.layer(levelplot(volcano), x.same = FALSE, y.same = FALSE, under = TRUE)
</code></pre>

<hr>
<h2 id='biocAccess'> Hourly access attempts to Bioconductor website </h2><span id='topic+biocAccess'></span>

<h3>Description</h3>

<p>This data set records the hourly number of access attempts to
the Bioconductor website (<a href="https://www.bioconductor.org">https://www.bioconductor.org</a>) during
January through May of 2007.  The counts are essentially an
aggregation of the number of entries in the access log.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(biocAccess)</code></pre>


<h3>Format</h3>

<p>A data frame with 3623 observations on the following 7 variables.
</p>

<dl>
<dt><code>counts</code></dt><dd><p> the number of access attempts</p>
</dd>
<dt><code>day</code></dt><dd><p> the day of the month </p>
</dd>
<dt><code>month</code></dt><dd><p>a factor with levels <code>Jan</code>, <code>Feb</code>,
..., <code>Dec</code></p>
</dd>
<dt><code>year</code></dt><dd><p> the year (all 2007) </p>
</dd>
<dt><code>hour</code></dt><dd><p> hour of the day, a numeric vector</p>
</dd>
<dt><code>weekday</code></dt><dd><p> a factor with levels <code>Monday</code>,
<code>Tuesday</code>, ..., <code>Sunday</code></p>
</dd>
<dt><code>time</code></dt><dd><p>a POSIXt representation of the start of the hour</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(biocAccess)
xyplot(stl(ts(biocAccess$counts[1:(24 * 30)], frequency = 24), "periodic"))
</code></pre>

<hr>
<h2 id='c.trellis'> Merge trellis objects, using same or different scales </h2><span id='topic+c.trellis'></span><span id='topic+xyplot.list'></span><span id='topic+mergedTrellisLegendGrob'></span>

<h3>Description</h3>

<p>Combine the panels of multiple trellis objects into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trellis'
c(..., x.same = NA, y.same = NA,
    layout = NULL, merge.legends = FALSE, recursive = FALSE)

xyplot.list(x, data = NULL, ..., FUN = xyplot,
    y.same = TRUE, x.same = NA, layout = NULL,
    merge.legends = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.trellis_+3A_...">...</code></td>
<td>
<p> two or more trellis objects. If these are
named arguments, the names will be used in the corresponding
panel strips.
</p>
</td></tr>
<tr><td><code id="c.trellis_+3A_x.same">x.same</code></td>
<td>
<p> if <code>TRUE</code>, set the x scale relation to
<code>"same"</code> and recalculate panel limits using data
from all panels. Otherwise, the x scales in each panel
will be as they were in the original objects
(so in general not the same), the default behaviour.
</p>
</td></tr>
<tr><td><code id="c.trellis_+3A_y.same">y.same</code></td>
<td>
<p> as above, for y scales.
Note that <code>xyplot.list</code> defaults to same y scales. Set to
<code>NA</code> to leave them alone. </p>
</td></tr>
<tr><td><code id="c.trellis_+3A_layout">layout</code></td>
<td>
<p> value for <code>layout</code> of the new plot; see
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="c.trellis_+3A_merge.legends">merge.legends</code></td>
<td>
<p> to keep keys or legends from all plots, not just
the first. If multiple legends share the same <code>"space"</code>, they are
packed together horizontally or vertically. </p>
</td></tr>
<tr><td><code id="c.trellis_+3A_recursive">recursive</code></td>
<td>
<p> for consistency with the generic method, ignored. </p>
</td></tr>
<tr><td><code id="c.trellis_+3A_x">x</code></td>
<td>
<p> a <code>list</code> of objects to plot individually, and then
be combined into one final plot. </p>
</td></tr>
<tr><td><code id="c.trellis_+3A_fun">FUN</code>, <code id="c.trellis_+3A_data">data</code></td>
<td>
<p> a lattice plot function, to be called on each element of
the list <code>x</code>, along with <code>data</code> and <code>...</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This mechanism attempts to merge the panels from multiple trellis
objects into one. The same effect could generally be achieved by
either a custom panel function (where the display depends on
<code>packet.number()</code>), or using <code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>
to display multiple trellis objects. However, in some cases it is more
convenient to use <code>c()</code>. Furthermore, it can be useful to
maintain the display as a standard lattice display, rather than a
composite using <code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>, to simplify
further interaction.
</p>
<p>Many properties of the display, such as titles, axis settings
and aspect ratio will be taken from the first object only.
</p>
<p>Note that combining panels from different types of plots does not
really fit the trellis model. Some features of the plot may not work
as expected. In particular, some work may be needed to
show or hide scales on selected panels. An example is given below.
</p>
<p>Any trellis object with more than one conditioning variable will be
&quot;flattened&quot; to one dimension, eliminating the multi-variate
conditioning structure.
</p>


<h3>Value</h3>

<p>a new trellis object.
</p>


<h3>Author(s)</h3>

<p> Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+marginal.plot">marginal.plot</a></code> was the original motivating application,
<code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>,
<code><a href="lattice.html#topic+update.trellis">update.trellis</a></code>,
<code><a href="lattice.html#topic+trellis.object">trellis.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Combine different types of plots.
c(wireframe(volcano), contourplot(volcano))

## Merging levelplot with xyplot
levObj &lt;- levelplot(prop.table(WorldPhones, 1) * 100)
xyObj &lt;- xyplot(Phones ~ Year, data.frame(Phones = rowSums(WorldPhones),
      Year = row.names(WorldPhones)), type="b", ylim = c(0, 150000))
## NOTE: prepanel.levelplot (from first object) is used for entire plot.
cObj &lt;- c(levObj, xyObj, layout = 1:2)
update(cObj, scales = list(y = list(rot = 0)),
       ylab = c("proportional distribution", "number of phones"))

## Combine two xyplots.
sepals &lt;- xyplot(Sepal.Length ~ Sepal.Width, iris, groups = Species,
    xlab = "Width", ylab = "Height")
petals &lt;- xyplot(Petal.Length ~ Petal.Width, iris, groups = Species)
c(Sepals = sepals, Petals = petals)

## Force same scales (re-calculate panel limits from merged data):
c(Sepals = sepals, Petals = petals, x.same = TRUE, y.same = TRUE)

## Or - create xyplots from a list of formulas
xyplot.list(list(Sepals = Sepal.Length ~ Sepal.Width,
                 Petals = Petal.Length ~ Petal.Width),
             data = iris, groups = Species, x.same = TRUE,
             xlab = "Width", ylab = "Height")

## Create histograms from a list of objects, and merge them.
xyplot.list(iris, FUN = histogram)

## Create cumulative distribution plots from a list of objects
xyplot.list(iris[1:4], FUN = qqmath, groups = iris$Species,
            auto.key = TRUE)

## Display a table as both frequencies and proportions:
data(postdoc)
## remove last row (containing totals)
postdoc &lt;- postdoc[1:(nrow(postdoc)-1),]
pdprops &lt;- barchart(prop.table(postdoc, margin = 1),
                    auto.key = list(adj = 1))
pdmargin &lt;- barchart(margin.table(postdoc, 1))
pdboth &lt;- c(pdprops, pdmargin)
update(pdboth, xlab = c("Proportion", "Freq"))

## Conditioned 'quakes' plot combined with histogram.
qua &lt;- xyplot(lat ~ long | equal.count(depth, 3), quakes,
    aspect = "iso", pch = ".", cex = 2, xlab = NULL, ylab = NULL)
qua &lt;- c(qua, depth = histogram(quakes$depth), layout = c(4, 1))
## suppress scales on the first 3 panels
update(qua, scales = list(at = list(NULL, NULL, NULL, NA),
                          y = list(draw = FALSE)))

## Demonstrate merging of legends and par.settings.
## Note that par.settings can conflict, thus need col.line=...
mypoints &lt;- 
    xyplot(1:10 ~ 1:10, groups = factor(rep(1:2, each = 5)),
        par.settings = simpleTheme(pch = 16), auto.key = TRUE)
mylines &lt;-
    xyplot(1:10 ~ 1:10, groups = factor(rep(1:5, each = 2)),
        type = "l", par.settings = simpleTheme(col.line = 1:5),
        auto.key = list(lines = TRUE, points = FALSE, columns = 5))
c(mypoints, mylines)

## Visualise statistical and spatial distributions
## (advanced!). Requires the 'maps' package to be installed

if (require(maps)) {
    vars &lt;- as.data.frame(state.x77)
    StateName &lt;- tolower(state.name)
    form &lt;- StateName ~ Population + Income + Illiteracy +
        `Life Exp` + Murder + `HS Grad` + Frost + sqrt(Area)
    ## construct independent maps of each variable
    statemap &lt;- map("state", plot = FALSE, fill = TRUE)
    colkey &lt;- draw.colorkey(list(col = heat.colors(100), at = 0:100,
                                 labels = list(labels = c("min","max"), at = c(0,100))))
    panel.mapplot.each &lt;- function(x, breaks, ...)
        panel.mapplot(x = x, breaks = quantile(x), ...)
    vmaps &lt;- mapplot(form, vars, map = statemap, colramp = heat.colors,
                     panel = panel.mapplot.each, colorkey = FALSE,
                     legend = list(right = list(fun = colkey)), xlab = NULL)
    ## construct independent densityplots of each variable
    vdens &lt;- densityplot(form[-2], vars, outer = TRUE, cut = 0, 
                         scales = list(relation = "free"), ylim = c(0, NA),
                         cex = 0.5, ref = TRUE) +
        layer(panel.axis("top", half = FALSE, text.cex = 0.7))
    ## combine panels from both plots
    combo &lt;- c(vmaps, vdens)
    ## rearrange in pairs
    n &lt;- length(vars)
    npairs &lt;- rep(1:n, each = 2) + c(0, n)
    update(combo[npairs], scales = list(draw = FALSE),
           layout = c(4, 4), between = list(x = c(0, 0.5), y = 0.5))
}
</code></pre>

<hr>
<h2 id='combineLimits'>Combine axis limits across margins</h2><span id='topic+combineLimits'></span>

<h3>Description</h3>

<p>Modifies a <code>"trellis"</code> object with <code>"free"</code> scales so that
panel limits are extended to be the same across selected conditioning
variables (typically rows and columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineLimits(x, margin.x = 2L, margin.y = 1L,
              extend = TRUE, adjust.labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combineLimits_+3A_x">x</code></td>
<td>
<p> An object of class <code>"trellis"</code>. </p>
</td></tr>
<tr><td><code id="combineLimits_+3A_margin.x">margin.x</code></td>
<td>

<p>Integer vector specifying which conditioning variables to combine
the x-axis limits over.  Defaults to the second conditioning
variable (rows in the default layout); that is, the limit of each
packet is extended to include the limits of all other packets
obtained by varying the level of the second conditioning variable
(row).  More than one variable can be specified; for example,
<code>margin.x = c(1, 2)</code> would ensure that limits are extended to
include all levels in both the first and second conditioning
variables.  In case there is a third conditioning variable, this
would have the effect of per-page x-axis limits with the default
layout.
</p>
</td></tr>
<tr><td><code id="combineLimits_+3A_margin.y">margin.y</code></td>
<td>

<p>Integer vector specifying which conditioning variables to combine
the x-axis limits over.  Similar to <code>margin.x</code>, but defaults to
the first conditioning variable (columns in the default layout).
</p>
</td></tr>
<tr><td><code id="combineLimits_+3A_extend">extend</code></td>
<td>

<p>Logical flag indicating whether the limits should be extended after
being combined.  Usually a good idea.
</p>
</td></tr>
<tr><td><code id="combineLimits_+3A_adjust.labels">adjust.labels</code></td>
<td>

<p>Logical flag indicating whether labels should be removed from all
but the boundaries.  This may give misleading plots with non-default
layouts.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>combineLimits</code> is useful mainly for plots with two conditioning
variables with the default layout (columns and rows correspond to the
first and second conditioning variables), when per-row and per-column
limits are desired.
</p>
<p>The lattice approach does not tie levels of the conditioning variables
to the plot layout, so it is possible that all panels in a row (or
column) do not represent the same level.  It should be noted that
<code>combineLimits</code> actually combines limits across levels, and not
across rows and columns.  Results are likely to be misleading unless
the default layout is used.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>; essentially the same as <code>x</code>,
but with certain properties modified.
</p>


<h3>Note</h3>

<p>Does not work for all <code>"trellis"</code> objects.  In particular,
log-scales do not yet work.  Fancy layouts with <code>skip</code>-ped panels
and unusual packet-to-panel mappings will probably also not work.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar </p>


<h3>See Also</h3>

 <p><code><a href="lattice.html#topic+Lattice">Lattice</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Cars93, package = "MASS")

## FIXME: log scales don't yet work

pcars &lt;- 
    xyplot(Price ~ EngineSize | reorder(AirBags, Price) + Cylinders,
           data = Cars93, 
           subset = Cylinders != "rotary" &amp; Cylinders != "5", 
           scales = list(relation = "free",
                         y = list(log = FALSE, tick.number = 3, rot = 0)),
           xlab = "Engine Size (litres)", 
           ylab = "Average Price (1000 USD)",
           as.table = TRUE) 

combineLimits(pcars)

useOuterStrips(combineLimits(update(pcars, grid = TRUE),
                             margin.x = c(1, 2), adjust.labels = FALSE))

useOuterStrips(combineLimits(update(pcars, grid = TRUE)))

</code></pre>

<hr>
<h2 id='custom.theme'> Create a lattice theme based on specified colors </h2><span id='topic+custom.theme'></span><span id='topic+custom.theme.2'></span>

<h3>Description</h3>

<p>Creates a lattice theme given a few colors.  Non-color settings
are not included.  The colors are typically used to define the
standard grouping (superposition) colors, and the first color is used
for ungrouped displays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom.theme(symbol = RColorBrewer::brewer.pal(n = 8, name = "Dark2"),
             fill = RColorBrewer::brewer.pal(n = 12, name = "Set3"),
             region = RColorBrewer::brewer.pal(n = 11, name = "Spectral"),
             reference = "#e8e8e8",
             bg = "transparent",
             fg = "black",
             ...)

## different defaults ("Set1", "Accent", "RdBu"):
custom.theme.2(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="custom.theme_+3A_symbol">symbol</code></td>
<td>
<p> a vector of symbol colors.   </p>
</td></tr>
<tr><td><code id="custom.theme_+3A_fill">fill</code></td>
<td>
<p> a vector of fill colors (for barcharts, etc.) </p>
</td></tr>
<tr><td><code id="custom.theme_+3A_region">region</code></td>
<td>
<p> a vector of colors that is used to define a continuous
color gradient using <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code></p>
</td></tr>
<tr><td><code id="custom.theme_+3A_reference">reference</code></td>
<td>
<p> a color for reference lines and such  </p>
</td></tr>
<tr><td><code id="custom.theme_+3A_bg">bg</code></td>
<td>
<p> a background color </p>
</td></tr>
<tr><td><code id="custom.theme_+3A_fg">fg</code></td>
<td>
<p> a foreground color, primarily for annotation </p>
</td></tr>
<tr><td><code id="custom.theme_+3A_...">...</code></td>
<td>
<p> further arguments passed to <code><a href="lattice.html#topic+simpleTheme">simpleTheme</a></code>
and used to modify the theme. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that can be supplied to
<code><a href="lattice.html#topic+trellis.par.get">trellis.par.get</a></code> or as the
<code>theme</code> argument to
<code><a href="lattice.html#topic+trellis.device">trellis.device</a></code>.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)

## create a plot to demonstrate graphical settings
obj &lt;-
xyplot(Sepal.Length + Sepal.Width ~ Petal.Length + Petal.Width, iris,
       type = c("p", "r"), jitter.x = TRUE, jitter.y = TRUE, factor = 5,
       auto.key = list(lines = TRUE, rectangles = TRUE))
obj &lt;- update(obj, legend = list(right =
         list(fun = "draw.colorkey", args = list(list(at = 0:100)))))

## draw with default theme
obj

## draw with custom.theme()
update(obj, par.settings = custom.theme())

## create a theme with paired colours, filled points, etc
update(obj, par.settings =
  custom.theme(symbol = RColorBrewer::brewer.pal(12, "Paired"),
               fill = RColorBrewer::brewer.pal(12, "Paired"),
               region = RColorBrewer::brewer.pal(9, "Blues"),
               bg = "grey90", fg = "grey20", pch = 16))

## draw with custom.theme.2()
update(obj, par.settings = custom.theme.2())
</code></pre>

<hr>
<h2 id='dendrogramGrob'> Create a Grob Representing a Dendrogram </h2><span id='topic+dendrogramGrob'></span>

<h3>Description</h3>

<p>This function creates a grob (a grid graphics object) that can be
manipulated as such.  In particular, it can be used as a legend in a
lattice display like <code>levelplot</code> to form heatmaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dendrogramGrob(x, ord = order.dendrogram(x),
               side = c("right", "top"),
               add = list(), size = 5, size.add = 1,
               type = c("rectangle", "triangle"),
               ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dendrogramGrob_+3A_x">x</code></td>
<td>
<p> An object of class <code>"dendrogram"</code>.  See
<code><a href="stats.html#topic+dendrogram">dendrogram</a></code> for details </p>
</td></tr>
<tr><td><code id="dendrogramGrob_+3A_ord">ord</code></td>
<td>
<p> A vector of integer indices giving the order in which the
terminal leaves are to be plotted.  If this is not the same as
<code>order.dendrogram(x)</code>, then the leaves may not cluster together
and branches of the dendrogram may intersect.  </p>
</td></tr>
<tr><td><code id="dendrogramGrob_+3A_side">side</code></td>
<td>
<p> Intended position of the dendrogram when added in a
heatmap.  Currently allowed positions are <code>"right"</code> and
<code>"top"</code>. </p>
</td></tr>
<tr><td><code id="dendrogramGrob_+3A_add">add</code></td>
<td>
<p> Additional annotation.  Currently, it is only possible to
add one or more rows of rectangles at the base of the dendrogram.
See details below.  </p>
</td></tr>
<tr><td><code id="dendrogramGrob_+3A_size">size</code></td>
<td>
<p> Total height of the dendrogram in <code>"lines"</code> (see
<code><a href="grid.html#topic+unit">unit</a></code>)
</p>
</td></tr>
<tr><td><code id="dendrogramGrob_+3A_size.add">size.add</code></td>
<td>
<p> Size of each additional row, also in <code>"lines"</code> </p>
</td></tr>
<tr><td><code id="dendrogramGrob_+3A_type">type</code></td>
<td>
<p> Whether a child node is joined to its parent  directly
with a straight line (<code>"triangle"</code>) or as a &ldquo;stair&rdquo; with
two lines (<code>"rectangle"</code>)
</p>
</td></tr>
<tr><td><code id="dendrogramGrob_+3A_...">...</code></td>
<td>
<p> Extra arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>add</code> argument can be used for additional annotation at the
base of the dendrogram.  It should be a list with one component for
each row, with names specifying the type of annotation and components
specifying the contents.  Currently, the only supported name is
<code>"rect"</code> (which can be repeated), producing rectangles.  The
components in such a case is a list of graphical parameters, possibly
vectorized, that are passed on to <code><a href="grid.html#topic+gpar">gpar</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"grob"</code>
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan.sarkar@r-project.org">deepayan.sarkar@r-project.org</a> </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+heatmap">heatmap</a></code>, <code><a href="lattice.html#topic+levelplot">levelplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
x  &lt;- t(as.matrix(scale(mtcars)))
dd.row &lt;- as.dendrogram(hclust(dist(x)))
row.ord &lt;- order.dendrogram(dd.row)

dd.col &lt;- as.dendrogram(hclust(dist(t(x))))
col.ord &lt;- order.dendrogram(dd.col)

library(lattice)

levelplot(x[row.ord, col.ord],
          aspect = "fill",
          scales = list(x = list(rot = 90)),
          colorkey = list(space = "left"),
          legend =
          list(right =
               list(fun = dendrogramGrob,
                    args =
                    list(x = dd.col, ord = col.ord,
                         side = "right",
                         size = 10)),
               top =
               list(fun = dendrogramGrob,
                    args =
                    list(x = dd.row, 
                         side = "top",
                         type = "triangle"))))


## Version with unsorted rows.

## For illustration, MPG ploted again at foot of dendrogram

mpg &lt;- x["mpg", col.ord]
mpg.col &lt;- level.colors(mpg, at = do.breaks(range(mpg), 10),
                        col.regions = terrain.colors)

levelplot(x[, col.ord],
          aspect = "iso",
          scales = list(x = list(rot = 90)),
          colorkey = FALSE,
          legend =
          list(right =
               list(fun = dendrogramGrob,
                    args =
                    list(x = dd.col, ord = col.ord,
                         side = "right",
                         add = list(rect = list(fill = mpg.col)),
                         size = 10)),
               top =
               list(fun = dendrogramGrob,
                    args =
                    list(x = dd.row, ord = sort(row.ord),
                         side = "top", size = 10,
                         type = "triangle"))))

</code></pre>

<hr>
<h2 id='doubleYScale'> Draw two plot series with different y scales </h2><span id='topic+doubleYScale'></span>

<h3>Description</h3>

<p>Overplot two trellis objects with different y scales,
optionally in different styles, adding a second y axis, and/or a
second y axis label.
</p>
<p><em>Note:</em> drawing plots with multiple scales is often a bad idea
as it can be misleading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleYScale(obj1, obj2, use.style = TRUE,
             style1 = if (use.style) 1, style2 = if (use.style) 2,
             add.axis = TRUE, add.ylab2 = FALSE,
             text = NULL, auto.key = if (!is.null(text))
               list(text, points = points, lines = lines, ...),
             points = FALSE, lines = TRUE, ..., under = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doubleYScale_+3A_obj1">obj1</code>, <code id="doubleYScale_+3A_obj2">obj2</code></td>
<td>

<p>trellis objects. Note that most settings, like main/sub/legend/etc
are taken only from <code>obj1</code>; only the panel, axis and ylab are
taken from obj2.
</p>
</td></tr>
<tr><td><code id="doubleYScale_+3A_use.style">use.style</code>, <code id="doubleYScale_+3A_style1">style1</code>, <code id="doubleYScale_+3A_style2">style2</code></td>
<td>

<p><code>style1</code> and <code>style2</code> give the &lsquo;group number&rsquo; for obj1
and obj2 respectively. The style is taken from these indices into
the values of <code>trellis.par.get("superpose.line")</code>.
Therefore these should be integers between 1 and 6;
a value of 0 or NULL can be given to leave the default settings.
These will also be applied to the y-axes and ylab, if relevant.
<code>use.style</code> simply changes the defaults of the style arguments.
</p>
</td></tr>
<tr><td><code id="doubleYScale_+3A_add.axis">add.axis</code></td>
<td>

<p>if TRUE, draw a second y axis (for the <code>obj2</code> series) on the
right side of the plot.
</p>
</td></tr>
<tr><td><code id="doubleYScale_+3A_add.ylab2">add.ylab2</code></td>
<td>

<p>if TRUE, draw a second y axis label (from <code>obj2$ylab</code>) on the
right side of the plot. Note, this will replace any existing key or
legend on the right side, i.e. with <code>space = "right"</code>.
</p>
</td></tr>
<tr><td><code id="doubleYScale_+3A_text">text</code>, <code id="doubleYScale_+3A_auto.key">auto.key</code>, <code id="doubleYScale_+3A_points">points</code>, <code id="doubleYScale_+3A_lines">lines</code>, <code id="doubleYScale_+3A_...">...</code></td>
<td>

<p>if non-NULL, add a <code>key</code> to the display, using entries named by
<code>text</code>. Further arguments are passed on to
<code><a href="lattice.html#topic+simpleKey">simpleKey</a></code> at plot time.
</p>
</td></tr>
<tr><td><code id="doubleYScale_+3A_under">under</code></td>
<td>

<p>if TRUE, draw <code>obj2</code> under <code>obj1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Panels from the trellis object <code>obj2</code> will be drawn in the
corresponding panel of <code>obj1</code>.
</p>
<p>Axis settings are taken from the trellis objects, so most
<code>scales</code> arguments such as <code>draw</code>, <code>at</code>, <code>labels</code>
etc from <code>obj2</code> will carry over to the second y axis.
</p>


<h3>Value</h3>

<p>a merged trellis object.
</p>


<h3>Author(s)</h3>

<p> Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+as.layer">as.layer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
foo &lt;- list(x = 1:100, y = cumsum(rnorm(100)))
## show original data
xyplot(y + y^2 ~ x, foo, type = "l")
## construct separate plots for each series
obj1 &lt;- xyplot(y ~ x, foo, type = "l")
obj2 &lt;- xyplot(y^2 ~ x, foo, type = "l")
## simple case: no axis for the overlaid plot
doubleYScale(obj1, obj2, add.axis = FALSE)
## draw second y axis
doubleYScale(obj1, obj2)
## ...with second ylab
doubleYScale(obj1, obj2, add.ylab2 = TRUE)
## ...or with a key
doubleYScale(obj1, obj2, text = c("obj1", "obj2"))
## ...with custom styles
update(doubleYScale(obj1, obj2, text = c("obj1", "obj2")),
  par.settings = simpleTheme(col = c('red','black'), lty = 1:2))

## different plot types
x &lt;- rnorm(60)
doubleYScale(histogram(x), densityplot(x), use.style = FALSE)
## (but see ?as.layer for a better way to do this)

## multi-panel example
## a variant of Figure 5.13 from Sarkar (2008)
## http://lmdvr.r-forge.r-project.org/figures/figures.html?chapter=05;figure=05_13
data(SeatacWeather)
temp &lt;- xyplot(min.temp + max.temp ~ day | month,
               data = SeatacWeather, type = "l", layout = c(3, 1))
rain &lt;- xyplot(precip ~ day | month, data = SeatacWeather, type = "h")

doubleYScale(temp, rain, style1 = 0, style2 = 3, add.ylab2 = TRUE,
   text = c("min. T", "max. T", "rain"), columns = 3)

## re-plot with different styles
update(trellis.last.object(),
   par.settings = simpleTheme(col = c("black", "red", "blue")))
</code></pre>

<hr>
<h2 id='EastAuClimate'> Climate of the East Coast of Australia </h2><span id='topic+EastAuClimate'></span>

<h3>Description</h3>

<p>A set of climate statistics for 16 coastal locations along Eastern
Australia. These sites were chosen to be approximately equally
spaced to cover the whole eastern coast of Australia.
For each site, climate statistics were calculated for the standard
30-year period 1971-2000. Only sites with nearly-complete data were
chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EastAuClimate)</code></pre>


<h3>Format</h3>

<p>A data frame with the following 10 variables and 5 items of metadata
for each of 16 sites.
</p>

<dl>
<dt><code>SummerMaxTemp</code></dt><dd><p> average daily maximum air
temperature (degrees C) in February. </p>
</dd>
<dt><code>SummerMinTemp</code></dt><dd><p> average daily minimum air
temperature (degrees C) in February. </p>
</dd>
<dt><code>WinterMaxTemp</code></dt><dd><p> average daily maximum air
temperature (degrees C) in July. </p>
</dd>
<dt><code>WinterMinTemp</code></dt><dd><p> average daily minimum air
temperature (degrees C) in July. </p>
</dd>
<dt><code>SummerRain</code></dt><dd><p> median total precipitation in February
(mm/month). </p>
</dd>
<dt><code>WinterRain</code></dt><dd><p> median total precipitation in July
(mm/month). </p>
</dd>
<dt><code>MeanAnnRain</code></dt><dd><p> average total amount of precipitation
recorded in a year (mm/year). </p>
</dd>
<dt><code>RainDays</code></dt><dd><p> average number of days in a year with at
least 1 mm of precipitation. </p>
</dd>
<dt><code>ClearDays</code></dt><dd><p> average number of clear days in a
year. This statistic is derived from cloud cover observations,
which are measured in oktas (eighths). A clear day is recorded
when the mean of the 9 am and 3 pm cloud observations is less than
or equal to 2 oktas. </p>
</dd>
<dt><code>CloudyDays</code></dt><dd><p> average number of clear days in a
year. A cloudy day is recorded when the mean of the 9 am and 3 pm
cloud observations is greater than or equal to 6 oktas. </p>
</dd>
<dt><code>ID</code></dt><dd><p> BOM Site number. </p>
</dd>
<dt><code>Latitude</code></dt><dd><p> Site latitude (degrees North). </p>
</dd>
<dt><code>Longitude</code></dt><dd><p> Site longitude (degrees East). </p>
</dd>
<dt><code>Elevation</code></dt><dd><p> Site elevation (m). </p>
</dd>
<dt><code>State</code></dt><dd><p> Australian state:
TAS = Tasmania, VIC = Victoria, NSW = New
South Wales, QLD = Queensland. </p>
</dd>
</dl>

<p>The row names of the data frame give the location names. Note: these
are not the official names of the climate stations.
</p>


<h3>Source</h3>

<p>Sites were chosen by hand from maps on the Bureau of Meteorology
website. The data were extracted manually from web pages under
<a href="http://www.bom.gov.au/climate/">http://www.bom.gov.au/climate/</a>
and processed to extract a subset of statistics.
- by Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>
<p>Bureau of Meteorology, Commonwealth of Australia.
Product IDCJCM0026 Prepared at Wed 31 Dec 2008.
</p>
<p>Definitions of statistics adapted from
<a href="http://www.bom.gov.au/climate/cdo/about/about-stats.shtml">http://www.bom.gov.au/climate/cdo/about/about-stats.shtml</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EastAuClimate)

## Compare the climates of state capital cities
EastAuClimate[c("Hobart", "Melbourne", "Sydney", "Brisbane"),]

## A function to plot maps (a Lattice version of maps::map)
lmap &lt;-
   function(database = "world", regions = ".", exact = FALSE,
            boundary = TRUE, interior = TRUE, projection = "",
            parameters = NULL, orientation = NULL,
            aspect = "iso", type = "l",
            par.settings = list(axis.line = list(col = "transparent")),
            xlab = NULL, ylab = NULL, ...)
{
   theMap &lt;- map(database, regions, exact = exact,
                 boundary = boundary, interior = interior,
                 projection = projection, parameters = parameters,
                 orientation = orientation, plot = FALSE)
   xyplot(y ~ x, theMap, type = type, aspect = aspect,
          par.settings = par.settings, xlab = xlab, ylab = ylab,
          default.scales = list(draw = FALSE), ...)
}

## Plot the sites on a map of Australia
if (require("maps")) {
  lmap(regions = c("Australia", "Australia:Tasmania"),
       exact = TRUE, projection = "rectangular",
       parameters = 150, xlim = c(130, 170),
       panel = function(...) {
          panel.xyplot(...)
          with(EastAuClimate, {
            panel.points(Longitude, Latitude, pch = 16)
            txt &lt;- row.names(EastAuClimate)
            i &lt;- c(3, 4)
            panel.text(Longitude[ i], Latitude[ i], txt[ i], pos = 2)
            panel.text(Longitude[-i], Latitude[-i], txt[-i], pos = 4)
          })
       })
}

## Average daily maximum temperature in July (Winter).
xyplot(WinterMaxTemp ~ Latitude, EastAuClimate, aspect = "xy",
       type = c("p", "a"), ylab = "Temperature (degrees C)")

## (Make a factor with levels in order - by coastal location)
siteNames &lt;- factor(row.names(EastAuClimate),
           levels = row.names(EastAuClimate))
## Plot temperature ranges (as bars), color-coded by RainDays
segplot(siteNames ~ WinterMinTemp + SummerMaxTemp, EastAuClimate,
        level = RainDays, sub = "Color scale: number of rainy days per year",
        xlab = "Temperature (degrees C)",
        main = paste("Typical temperature range and wetness",
           "of coastal Australian cities", sep = "\n"))

## Show Winter and Summer temperature ranges separately
segplot(Latitude ~ WinterMinTemp + SummerMaxTemp, EastAuClimate,
   main = "Average daily temperature ranges \n of coastal Australian sites",
   ylab = "Latitude", xlab = "Temperature (degrees C)",
   par.settings = simpleTheme(lwd = 3, alpha = 0.5),
   key = list(text = list(c("July (Winter)", "February (Summer)")),
              lines = list(col = c("blue", "red"))),
   panel = function(x, y, z, ..., col) {
      with(EastAuClimate, {
         panel.segplot(WinterMinTemp, WinterMaxTemp, z, ..., col = "blue")
         panel.segplot(SummerMinTemp, SummerMaxTemp, z, ..., col = "red")
      })
   })

## Northern sites have Summer-dominated rainfall;
## Southern sites have Winter-dominated rainfall.
xyplot(SummerRain + WinterRain ~ Latitude, EastAuClimate,
       type = c("p", "a"), auto.key = list(lines = TRUE),
       ylab = "Rainfall (mm / month)")

## Clear days are most frequent in the mid latitudes.
xyplot(RainDays + CloudyDays + ClearDays ~ Latitude, EastAuClimate,
       type = c("p", "a"), auto.key = list(lines = TRUE),
       ylab = "Days per year")
</code></pre>

<hr>
<h2 id='ecdfplot'>Trellis Displays of Empirical CDF</h2><span id='topic+ecdfplot'></span><span id='topic+ecdfplot.formula'></span><span id='topic+ecdfplot.numeric'></span><span id='topic+panel.ecdfplot'></span><span id='topic+prepanel.ecdfplot'></span>

<h3>Description</h3>

<p>Conditional displays of Empirical Cumulative Distribution Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecdfplot(x, data, ...)

## S3 method for class 'formula'
ecdfplot(x, data,
         prepanel = "prepanel.ecdfplot", 
         panel = "panel.ecdfplot",
         ylab,
         ...)
## S3 method for class 'numeric'
ecdfplot(x, data = NULL, xlab, ...)

prepanel.ecdfplot(x, f.value = NULL, ...)

panel.ecdfplot(x, f.value = NULL, type = "s",
               groups = NULL, qtype = 7,
               ref = TRUE,
               ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ecdfplot_+3A_x">x</code></td>
<td>
<p> For <code>ecdfplot</code>, <code>x</code> is the object on which
method dispatch is carried out.  For the <code>"formula"</code> method,
<code>x</code> is a formula describing the form of conditioning plot, and
has to be of the form <code>~x</code>, where <code>x</code> is assumed to be a
numeric vector.  Further conditioning variables are allowed as
usual.
</p>
<p>A similar interpretation holds for <code>x</code> in the <code>"numeric"</code>
method as well as <code>prepanel.ecdfplot</code> and
<code>panel.ecdfplot</code>.
</p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_data">data</code></td>
<td>
<p> For the <code>"formula"</code> method, a data frame containing
values for any variables in the formula, as well as those in
<code>groups</code> and <code>subset</code> if applicable. </p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_prepanel">prepanel</code>, <code id="ecdfplot_+3A_panel">panel</code></td>
<td>
<p> panel and prepanel function used to create the
display.  </p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_xlab">xlab</code>, <code id="ecdfplot_+3A_ylab">ylab</code></td>
<td>
<p> axis labels; typically a character string or an
expression. </p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_groups">groups</code></td>
<td>
<p> a grouing variable of the same length as <code>x</code>.  If
specified, ECDF plots are computed for each subset defined by unique
values of <code>groups</code> and the resulting functions superposed
within each panel.
</p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_f.value">f.value</code>, <code id="ecdfplot_+3A_qtype">qtype</code></td>
<td>
<p> Defines how quantiles are calculated. See
<code><a href="lattice.html#topic+panel.qqmath">panel.qqmath</a></code>. </p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_ref">ref</code></td>
<td>
<p> logical, whether a reference line should be drawn at 0 and
1</p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_type">type</code></td>
<td>
<p> how the plot is rendered; see
<code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code> </p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_...">...</code></td>
<td>
<p> extra arguments, passed on as appropriate.  Standard
lattice arguments as well as arguments to <code>panel.ecdfplot</code>
can be supplied directly in the high level <code>ecdfplot</code> call.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ecdfplot</code> produces an object of class <code>"trellis"</code>. The
<code>update</code> method can be used to update components of the object and
the <code>print</code> method (usually called by default) will plot it on an
appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan.sarkar@r-project.org">deepayan.sarkar@r-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+qqmath">qqmath</a></code> for Quantile plots which are
more generally useful, especially when comparing with a theoretical
distribution other than uniform.  An ECDF plot is essentially a
transposed version (i.e., with axes switched) of a uniform quantile
plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(singer, package = "lattice")
ecdfplot(~height | voice.part, data = singer)

</code></pre>

<hr>
<h2 id='ggplot2like.theme'>A ggplot2-like theme for Lattice</h2><span id='topic+ggplot2like.theme'></span><span id='topic+ggplot2like.opts'></span><span id='topic+ggplot2like'></span><span id='topic+axis.grid'></span>

<h3>Description</h3>

<p>A theme for Lattice based on some of the default styles used in the
<span class="pkg">ggplot2</span> package by Hadley Wickham. Specifically, parts of the
functions <code>scale_colour_hue</code>, <code>scale_colour_gradient</code> and
<code>theme_gray</code> were copied. Although superficially similar, the
implementation here lacks much of the flexibility of the <span class="pkg">ggplot2</span>
functions: see <a href="http://had.co.nz/ggplot2/">http://had.co.nz/ggplot2/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot2like(..., n = 6, h = c(0,360) + 15, l = 65, c = 100,
            h.start = 0, direction = 1,
            low = "#3B4FB8", high = "#B71B1A", space = "rgb")

ggplot2like.opts()

axis.grid(side = c("top", "bottom", "left", "right"),
          ..., ticks = c("default", "yes", "no"),
          scales, components, line.col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggplot2like.theme_+3A_...">...</code></td>
<td>

<p>further arguments passed on to <code><a href="lattice.html#topic+simpleTheme">simpleTheme</a></code> to
over-ride defaults.
</p>
</td></tr>
<tr><td><code id="ggplot2like.theme_+3A_n">n</code></td>
<td>

<p>number of <code>superpose</code> styles to generate, with equally spaced hues.
</p>
</td></tr>
<tr><td><code id="ggplot2like.theme_+3A_h">h</code>, <code id="ggplot2like.theme_+3A_c">c</code>, <code id="ggplot2like.theme_+3A_l">l</code>, <code id="ggplot2like.theme_+3A_h.start">h.start</code>, <code id="ggplot2like.theme_+3A_direction">direction</code></td>
<td>

<p>range of hues, starting hue and direction to generate a discrete
colour sequence with <code><a href="grDevices.html#topic+hcl">hcl</a></code>.
</p>
</td></tr>
<tr><td><code id="ggplot2like.theme_+3A_low">low</code>, <code id="ggplot2like.theme_+3A_high">high</code>, <code id="ggplot2like.theme_+3A_space">space</code></td>
<td>

<p>extreme colors to interpolate with <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>
for a continuous color scale.
</p>
</td></tr>
<tr><td><code id="ggplot2like.theme_+3A_side">side</code>, <code id="ggplot2like.theme_+3A_ticks">ticks</code>, <code id="ggplot2like.theme_+3A_scales">scales</code>, <code id="ggplot2like.theme_+3A_components">components</code>, <code id="ggplot2like.theme_+3A_line.col">line.col</code></td>
<td>

<p>see <code><a href="lattice.html#topic+axis.default">axis.default</a></code>. Typically <code>axis.grid</code> is not
called directly so these should not be needed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2like()</code> produces a list of settings which can be
passed as the <code>par.settings</code> argument to a high-level Lattice
plot, or to <code><a href="lattice.html#topic+trellis.par.set">trellis.par.set</a></code>.
<code>ggplot2like.opts()</code> produces a list which can be passed as the
<code>lattice.options</code> argument to a high-level Lattice plot, or to
<code><a href="lattice.html#topic+lattice.options">lattice.options</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>;
copied and adapted from <span class="pkg">ggplot2</span> by Hadley Wickham.
</p>


<h3>See Also</h3>

<p>the <span class="pkg">ggplot2</span> package: <a href="http://had.co.nz/ggplot2/">http://had.co.nz/ggplot2/</a>.
</p>
<p><code><a href="#topic+custom.theme">custom.theme</a></code>, <code><a href="#topic+scale.components">scale.components</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)

## basic theme does not include white grid lines
xyplot(exp(1:10) ~ 1:10, type = "b", 
    par.settings = ggplot2like())

## add lines for axis ticks with custom axis function
xyplot(exp(1:10) ~ 1:10, type = "b", 
    par.settings = ggplot2like(), axis = axis.grid)
    
## this can be used together with scale.components
## (minor lines only visible on devices supporting translucency)
xyplot(exp(rnorm(500)) ~ rnorm(500),
    scales = list(y = list(log = TRUE)),
    yscale.components = yscale.components.log10ticks,
    par.settings = ggplot2like(), axis = axis.grid)

## ggplotlike.opts() specifies axis = axis.grid as well as
## xscale.components.subticks / yscale.components.subticks

xyg &lt;- make.groups(
    "group one" = rnorm(80, 1),
    "group two" = rnorm(80, 5),
    "group three" = rnorm(80, 2))
xyg$x &lt;- rev(xyg$data)

## group styles: specify number of equi-spaced hues
xyplot(data ~ x, xyg, groups = which, auto.key = TRUE, 
    par.settings = ggplot2like(n = 3),
    lattice.options = ggplot2like.opts()) +
  glayer(panel.smoother(...))

## or set it as the default:
opar &lt;- trellis.par.get()
trellis.par.set(ggplot2like(n = 4, h.start = 180))
oopt &lt;- lattice.options(ggplot2like.opts())

bwplot(voice.part ~ height, data = singer)

histogram(rnorm(100))

barchart(Titanic[,,,"No"], main = "Titanic deaths",
    layout = c(1, 2), auto.key = list(columns = 2))

## reset
trellis.par.set(opar)
lattice.options(oopt)

## axis.grid and scale.components.subticks can be used alone:
## (again, lines for minor ticks need transculency-support to show up)
xyplot(exp(1:10) ~ 1:10, type = "b", 
    lattice.options = ggplot2like.opts(),
    par.settings = list(axis.line = list(col = NA),
        reference.line = list(col = "grey")),
    scales = list(tck = c(0,0)))
</code></pre>

<hr>
<h2 id='gvhd10'> Flow cytometry data from five samples from a patient  </h2><span id='topic+gvhd10'></span>

<h3>Description</h3>

<p>Flow cytometry data from blood samples taken from a Leukemia patient
before and after allogenic bone marrow transplant.  The data spans
five visits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gvhd10)</code></pre>


<h3>Format</h3>

<p>A data frame with 113896 observations on the following 8 variables.
</p>

<dl>
<dt><code>FSC.H</code></dt><dd><p> forward scatter height values</p>
</dd>
<dt><code>SSC.H</code></dt><dd><p> side scatter height values </p>
</dd>
<dt><code>FL1.H</code></dt><dd><p> intensity (height) in the FL1 channel </p>
</dd>
<dt><code>FL2.H</code></dt><dd><p> intensity (height) in the FL2 channel </p>
</dd>
<dt><code>FL3.H</code></dt><dd><p> intensity (height) in the FL3 channel </p>
</dd>
<dt><code>FL2.A</code></dt><dd><p> intensity (area) in the FL2 channel </p>
</dd>
<dt><code>FL4.H</code></dt><dd><p> intensity (height) in the FL4 channel </p>
</dd>
<dt><code>Days</code></dt><dd><p>a factor with levels <code>-6</code> <code>0</code> <code>6</code> <code>13</code> <code>20</code> <code>27</code> <code>34</code></p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://web.archive.org/web/20070427103026/http://www.ficcs.org/software.html#Data_Files">https://web.archive.org/web/20070427103026/http://www.ficcs.org/software.html#Data_Files</a>
</p>


<h3>References</h3>

<p>Brinkman, R.R., et al. (2007).  High-Content Flow Cytometry and
Temporal Data Analysis for Defining a
Cellular Signature of Graft-Versus-Host Disease.
<em>Biology of Blood and Marrow Transplantation</em> <b>13&ndash;6</b>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Figure 3.4 from Sarkar (2008)
data(gvhd10)
histogram(~log2(FSC.H) | Days, gvhd10, xlab = "log Forward Scatter",
          type = "density", nint = 50, layout = c(2, 4))
</code></pre>

<hr>
<h2 id='horizonplot'>Plot many time series in parallel</h2><span id='topic+horizonplot'></span><span id='topic+horizonplot.default'></span><span id='topic+panel.horizonplot'></span><span id='topic+prepanel.horizonplot'></span>

<h3>Description</h3>

<p>Plot many time series in parallel by cutting the y range into segments
and overplotting them with color representing the magnitude and
direction of deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horizonplot(x, data, ...)

## Default S3 method:
horizonplot(x, data = NULL, ...,
            nbands = 3L,
            horizonscale = NA,
            origin = function(y) na.omit(y)[1],
            colorkey = FALSE, legend = NULL,
            panel = panel.horizonplot,
            prepanel = prepanel.horizonplot,
            col.regions = hcl.colors(2 * nbands, palette="RdYlBu"),
            strip = FALSE, strip.left = TRUE,
            par.strip.text = list(cex = 0.6),
            colorkey.digits = 3,
            layout = c(1, NA),
            groups = NULL,
            default.scales =
              list(y = list(relation = "free", axs = "i", 
                            draw = FALSE, tick.number = 2)))

panel.horizonplot(x, y, ..., border = NA,
                  nbands = 3L,
                  col.regions = hcl.colors(2 * nbands, palette="RdYlBu"),
                  origin)

prepanel.horizonplot(x, y, ..., horizonscale = NA,
                     nbands = 3L,
                     origin = function(y) na.omit(y)[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="horizonplot_+3A_x">x</code>, <code id="horizonplot_+3A_y">y</code></td>
<td>
<p> Argument on which argument dispatch is carried
out. Typically this will be a multivariate time series.
In the panel and prepanel functions, these are the data
coordinates. 
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_data">data</code></td>
<td>

<p>Not used (at least, not used by <code>xyplot.ts</code>).
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_...">...</code></td>
<td>

<p>further arguments.  Arguments to <code>xyplot</code> as
well as to the default panel function <code><a href="#topic+panel.horizonplot">panel.horizonplot</a></code>
can be supplied directly to <code>horizonplot</code>.
In typical usage, the method of <code>xyplot</code> called will be
<code><a href="lattice.html#topic+xyplot.ts">xyplot.ts</a></code>.
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_nbands">nbands</code></td>
<td>
<p> Integer giving the number of discrete color bands used
(for both negative and positive deviations from the origin). </p>
</td></tr>
<tr><td><code id="horizonplot_+3A_horizonscale">horizonscale</code></td>
<td>

<p>the scale of each color segment. There are 3 positive
segments and 3 negative segments. If this is a given as a
number then all panels will have comparable distances, though not
necessarily the same actual values (similar in concept to
<code>scales$relation = "sliced"</code>). If <code>NA</code>, as it is by
default, then the scale is chosen in each panel to cover the range
of the data (unless overridden by <code>ylim</code>); see Details.
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_origin">origin</code></td>
<td>

<p>the baseline y value for the first (positive) segment
(i.e. the value at which red changes to blue). This can be a
number, which is then fixed across all panels, or it can be a
function, which is evaluated with the <code>y</code> values in each
panel. The default is the first non-missing y value in each
panel. See the Details section.
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_colorkey">colorkey</code>, <code id="horizonplot_+3A_legend">legend</code></td>
<td>

<p>if <code>colorkey = TRUE</code> a suitable color scale bar is constructed
using the values of <code>origin</code> and <code>horizonscale</code>. Further
options can be passed to <code>colorkey</code> in list form, as with
<code><a href="lattice.html#topic+levelplot">levelplot</a></code>. 
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_panel">panel</code></td>
<td>
<p> function to render the graphic given the data.  This is
the function that actually implements the display.  </p>
</td></tr>
<tr><td><code id="horizonplot_+3A_prepanel">prepanel</code></td>
<td>
<p> function determining range of the data rectangle from
data to be used in a panel. </p>
</td></tr>
<tr><td><code id="horizonplot_+3A_col.regions">col.regions</code></td>
<td>

<p>color scale, with at least 6 colors. This should be a divergent
color scale (typically with white as the central color).
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_strip">strip</code>, <code id="horizonplot_+3A_strip.left">strip.left</code></td>
<td>

<p>by default strips are only drawn on the left, to save space.
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_par.strip.text">par.strip.text</code></td>
<td>

<p>graphical parameters for the strip text; see
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>. One notable argument here is
<code>lines</code>, allowing multi-line text.
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_colorkey.digits">colorkey.digits</code></td>
<td>

<p>digits for rounding values in colorkey labels.
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_layout">layout</code></td>
<td>

<p>Numeric vector of length 2 (or 3) specifying number of columns and
rows (and pages) in the plot. The default is to have one column and
as many rows as there are panels.
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_default.scales">default.scales</code></td>
<td>

<p>sets default values of <code>scales</code>; leave this alone, pass
<code>scales</code> instead.
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_groups">groups</code></td>
<td>

<p>not applicable to this type of plot.
</p>
</td></tr>
<tr><td><code id="horizonplot_+3A_border">border</code></td>
<td>

<p>border color for the filled polygons, defaults to no border.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function draws time series as filled areas, with modifications
to effectively visualise many time series in parallel. Data that would
be drawn off the top of each panel is redrawn from the bottom of the
panel in a darker color. Values below the origin are inverted and
drawn in the opposite color. There are up to three shades (typically
in blue) for data above the baseline and up to three shades (typically
in red) for data below the baseline. See the article referenced below
for an introduction to Horizon plots.
</p>
<p>There are three different cases of using this function:
</p>

<ol>
<li> <p><code>horizonscale</code> unspecified (default case): then each
panel will have different scales, and the colors represent
deviations from the origin up to the maximum deviation from the
origin in that panel. If <code>origin</code> is specified then that will
be constant across panels; otherwise it defaults to the initial
value.
</p>
</li>
<li> <p><code>horizonscale</code> specified but <code>origin</code> unspecified:
the origin defaults to the initial value in each panel, and colors
represent deviations from it in steps of <code>horizonscale</code> (up to
3 steps each way).
</p>
</li>
<li><p> both <code>horizonscale</code> and <code>origin</code> specified: each
panel will have the same scales, and colors represent fixed ranges
of values. 
</p>
</li></ol>

<p>In each of these cases the <code>colorkey</code> is labelled slightly
differently (see examples).
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="lattice.html#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="lattice.html#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Warning</h3>

<p>Note that the y scale in each panel defines the actual origin and
scale used. The <code>origin</code> and <code>horizonscale</code> arguments are
only used in the <code>prepanel</code> function to choose an appropriate y
scale. The <code>ylim</code> argument therefore over-rides 
<code>origin</code> and <code>horizonscale</code>. This also implies that choices
of <code>scales$y$relation</code> other than <code>"free"</code> may have
unexpected effects, particularly <code>"sliced"</code>, as these change the
y limits from those requested by the prepanel function.
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>


<h3>References</h3>

<p>Stephen Few (2008). Time on the Horizon.
<em>Visual Business Intelligence Newsletter</em>, June/July 2008
<a href="https://www.perceptualedge.com/articles/visual_business_intelligence/time_on_the_horizon.pdf">https://www.perceptualedge.com/articles/visual_business_intelligence/time_on_the_horizon.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+Lattice">Lattice</a></code>,
<code><a href="lattice.html#topic+xyplot.ts">xyplot.ts</a></code>,
<code><a href="#topic+panel.xyarea">panel.xyarea</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a random time series object with 12 columns
set.seed(1)
dat &lt;- ts(matrix(cumsum(rnorm(200 * 12)), ncol = 12))
colnames(dat) &lt;- paste("series", LETTERS[1:12])

## show simple line plot first, for reference.
xyplot(dat, scales = list(y = "same"))

## these layers show scale and origin in each panel...
infolayers &lt;-
  layer(panel.scaleArrow(x = 0.99, digits = 1, col = "grey",
                         srt = 90, cex = 0.7)) +
  layer(lim &lt;- current.panel.limits(),
    panel.text(lim$x[1], lim$y[1], round(lim$y[1],1), font = 2,
        cex = 0.7, adj = c(-0.5,-0.5), col = "#9FC8DC"))

## Case 1: each panel has a different origin and scale:
## ('origin' default is the first data value in each series).
horizonplot(dat, layout = c(1,12), colorkey = TRUE) +
  infolayers
 
## Case 2: fixed scale but different origin (baseline):
## (similar in concept to scales = "sliced")
horizonplot(dat, layout = c(1,12), horizonscale = 10, colorkey = TRUE) +
  infolayers

## Case 3: fixed scale and constant origin (all same scales):
horizonplot(dat, layout = c(1,12), origin = 0, horizonscale = 10, colorkey = TRUE) +
  infolayers

## same effect using ylim (but colorkey does not know limits):
horizonplot(dat, layout = c(1,12), ylim = c(0, 10), colorkey = TRUE) +
  infolayers

## same scales with full coverage of color scale:
horizonplot(dat, layout = c(1,12), origin = 0,
            scales = list(y = list(relation = "same")),
            colorkey = TRUE, colorkey.digits = 1) +
  infolayers


## use ylab rather than strip.left, for readability.
## also shade any times with missing data values.
horizonplot(dat, horizonscale = 10, colorkey = TRUE,
            layout = c(1,12), strip.left = FALSE,
            ylab = list(rev(colnames(dat)), rot = 0, cex = 0.7)) +
  layer_(panel.fill(col = "gray90"), panel.xblocks(..., col = "white"))


## illustration of the cut points used in the following plot
xyplot(EuStockMarkets, scales = list(y = "same"),
  panel = function(x, y, ...) {
    col &lt;-
    c("#B41414","#E03231","#F7A99C","#9FC8DC","#468CC8","#0165B3")
    for (i in c(-3:-1, 2:0)) {
      if (i &gt;= 0)
        yi &lt;- pmax(4000, pmin(y, 4000 + 1000 * (i+1)))
      if (i &lt; 0)
        yi &lt;- pmin(4000, pmax(y, 4000 + 1000 * i))
      panel.xyarea(x, yi, origin = 4000,
        col = col[i+4], border = NA)
    }
    panel.lines(x, y)
    panel.abline(h = 4000, lty = 2)
  })

## compare with previous plot
horizonplot(EuStockMarkets, colorkey = TRUE,
            origin = 4000, horizonscale = 1000) +
  infolayers

## a cut-and-stack plot; use constant y scales!
horizonplot(sunspots, cut = list(n = 23, overlap = 0),
  scales = list(draw = FALSE, y = list(relation = "same")),
  origin = 100, colorkey = TRUE,
  strip.left = FALSE, layout = c(1,23)) +
layer(grid::grid.text(round(x[1]), x = 0, just = "left"))
</code></pre>

<hr>
<h2 id='layer'> Add layers to a lattice plot, optionally using a new data source </h2><span id='topic+layer'></span><span id='topic+layer_'></span><span id='topic+glayer'></span><span id='topic+glayer_'></span><span id='topic++2B.trellis'></span><span id='topic+drawLayer'></span><span id='topic+flattenPanel'></span><span id='topic++5B.layer'></span><span id='topic+print.layer'></span>

<h3>Description</h3>

<p>A mechanism to add new layers to a trellis object, optionally using a
new data source. This is an alternative to modifying the
panel function. Note the non-standard evaluation in <code>layer()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer(..., data, magicdots, exclude,
      packets, rows, columns, groups,
      style, force, theme, under, superpose)

layer_(...)
glayer(...)
glayer_(...)

## S3 method for class 'trellis'
object + lay

drawLayer(lay, panelArgs = trellis.panelArgs())

flattenPanel(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layer_+3A_...">...</code></td>
<td>

<p>expressions as they would appear in a panel function. These can
refer to the panel function arguments (such as <code>x</code>, <code>y</code>
and <code>subscripts</code>), and also to any named objects passed in
through the <code>data</code> argument. The calls can also include the
special argument &ldquo;<code>...</code>&rdquo;; in the default case of
<code>magicdots = TRUE</code>, only those arguments which are not already
named in a call are passed on through &ldquo;<code>...</code>&rdquo;.
Otherwise, &ldquo;<code>...</code>&rdquo; simply represents all panel
function arguments. See Details, below.
</p>
</td></tr>
<tr><td><code id="layer_+3A_data">data</code></td>
<td>

<p>optional. A named <code>list</code> containing objects needed when
evaluating (drawing) the layer.
</p>
</td></tr>
<tr><td><code id="layer_+3A_magicdots">magicdots</code>, <code id="layer_+3A_exclude">exclude</code></td>
<td>

<p>if <code>magicdots = TRUE</code>, the default, any reference to
&ldquo;<code>...</code>&rdquo; 
in the layer expressions will only pass on those arguments from the
panel function which are not named in the call (thus avoiding 
duplicate argument errors). If the first argument in a call is not
named, it is assumed to be named <code>"x"</code>, and if the second
argument is not named it is assumed to be named
<code>"y"</code>. Furthermore, any argument names given in <code>exclude</code>
will not be passed on through &ldquo;<code>...</code>&rdquo;.
</p>
</td></tr>
<tr><td><code id="layer_+3A_packets">packets</code>, <code id="layer_+3A_rows">rows</code>, <code id="layer_+3A_columns">columns</code>, <code id="layer_+3A_groups">groups</code></td>
<td>

<p>restricts the layer to draw only in specified packets (which refer
to individual panels, but are independent of their layout), or rows
or columns of the trellis layout (<code><a href="lattice.html#topic+trellis.currentLayout">trellis.currentLayout</a></code>).
For group layers (using <code>glayer</code> or <code>superpose = TRUE</code>),
the groups can be restricted also, by specifying group numbers (or
group values, as character strings). Negative values exclude the
given items. 
</p>
</td></tr>
<tr><td><code id="layer_+3A_style">style</code></td>
<td>

<p>style index of the layer, used only to set lattice graphical
parameters (same effect as in grouped displays). Note that this will
use the theme settings in effect in the existing plot, which may or
may not be what is desired. It may be necessary to use <code>force =
      TRUE</code> to escape from the plot's settings and use the current
theme. 
</p>
</td></tr>
<tr><td><code id="layer_+3A_force">force</code></td>
<td>

<p><code>force = TRUE</code> is just a shorthand for
<code>theme = trellis.par.get()</code>, which is useful for over-riding
the theme settings in effect in an existing plot. For instance, if
the original plot specified <code>par.settings = simpleTheme(col =
      "red")</code> then the theme settings in effect will be entirely
red. Use <code>force = TRUE</code> to reset the current theme for this
layer, or use <code>theme</code> directly.
</p>
</td></tr>
<tr><td><code id="layer_+3A_theme">theme</code></td>
<td>

<p>a style specification to be passed to <code><a href="lattice.html#topic+trellis.par.set">trellis.par.set</a></code>
which has effect only while drawing the layer. One can pass a whole
theme specification list, such as <code>theme = custom.theme()</code>, or
a more specific list, such as <code>theme = simpleTheme(col = "red")</code>.
</p>
</td></tr>
<tr><td><code id="layer_+3A_under">under</code></td>
<td>

<p>whether the layer should be drawn before the existing panel
function. This defaults to <code>TRUE</code> in the convenience functions
<code>layer_()</code> and <code>glayer_()</code>.
</p>
</td></tr>
<tr><td><code id="layer_+3A_superpose">superpose</code></td>
<td>

<p>if <code>TRUE</code>, the layer will be drawn once for
each level of any <code>groups</code> in the plot, using
<code><a href="lattice.html#topic+panel.superpose">panel.superpose</a></code>. This defaults to <code>TRUE</code> in the
convenience functions <code>glayer()</code> and <code>glayer_()</code>.
</p>
</td></tr>
<tr><td><code id="layer_+3A_object">object</code></td>
<td>
<p> a trellis object. </p>
</td></tr>
<tr><td><code id="layer_+3A_lay">lay</code></td>
<td>
<p> a layer object. </p>
</td></tr>
<tr><td><code id="layer_+3A_panelargs">panelArgs</code></td>
<td>
<p> list of arguments to the panel function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>layer</code> mechanism is a method for augmenting a panel
function. It allows expressions to be added to the panel function
without knowing what the original panel function was. In this way it
can be useful for convenient augmentation of trellis plots.
</p>
<p>Note that the evaluation used in <code>layer</code> is non-standard, and can
be confusing at first: you typically refer to variables as if inside
the panel function (<code>x</code>, <code>y</code>, etc); you can usually refer to
objects which exist in the global environment (workspace), but it is
safer to pass them in by name in the <code>data</code> argument to
<code>layer</code>. (And this should not to be confused with the <code>data</code>
argument to the original <code>xyplot</code>.)
</p>
<p>A simple example is adding a reference line to each panel:
<code>layer(panel.refline(h = 0))</code>. Note that the expressions are
quoted, so if you have local variables they will need to be either
accessible globally, or passed in via the <code>data</code> argument. For
example:
</p>
<p><code>layer(panel.refline(h = myVal)) ## if myVal is global</code>
</p>
<p><code>layer(panel.refline(h = h), data = list(h = myVal))</code>
</p>
<p>Another non-standard aspect is that the special argument
&ldquo;<code>...</code>&rdquo; will, by default, only pass through those
argument not already named. For example, this will over-ride the
<code>x</code> argument and pass on the remaining arguments:
</p>
<p><code>layer(panel.xyplot(x = jitter(x), ...))</code>
</p>
<p>The first un-named argument is assumed to be &quot;x&quot;, so that is the same as
</p>
<p><code>layer(panel.xyplot(jitter(x), ...))</code>
</p>
<p>The layer mechanism should probably still be considered experimental.
</p>
<p><code>drawLayer()</code> actually draws the given layer object, applying the
panel specification, style settings and so on. It should only be
called while a panel is in focus.
</p>
<p>The <code>flattenPanel</code> function will construct a human-readable
function incorporating code from all layers (and the original panel
function). Note that this does not return a usable function, as it
lacks the correct argument list and ignores any extra data sources
that layers might use. It is intended be edited manually.
</p>


<h3>Value</h3>

<p>a <code>layer</code> object is defined as a list of expression objects,
each of which may have a set of attributes. The result of &quot;adding&quot;
a layer to a trellis object (<code>+.trellis</code>) is the updated trellis
object.
</p>


<h3>Author(s)</h3>

<p> Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a> </p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+update.trellis">update.trellis</a></code>,
<code><a href="#topic+as.layer">as.layer</a></code> for overlaying entire plots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- xyplot(ozone ~ wind, environmental)
foo

## overlay reference lines
foo &lt;- foo + layer(panel.abline(h = 0)) +
             layer(panel.lmline(x, y, lty = 2))

## underlay a flat color
foo &lt;- foo + layer(panel.fill(grey(.95)), under = TRUE)
foo

## layers can access the panel function arguments
foo &lt;- foo + layer({ ok &lt;- (y&gt;100);
            panel.text(x[ok], y[ok], y[ok], pos = 1) })
foo

## over-ride arguments by name
foo &lt;- foo +
  layer(panel.xyplot(y = ave(y, x, FUN = max), type = "a", ...))
foo

## see a sketch of the complete panel function
flattenPanel(foo)


## group layers, drawn for each group in each panel
dotplot(VADeaths, type = "o") +
  glayer(ltext(x[5], y[5], group.value, srt = 40))

## a quick way to print out the panel.groups arguments:
dotplot(VADeaths, type = "o") + glayer(str(list(...)))


## layers with superposed styles
xyplot(ozone ~ wind | equal.count(temperature, 2),
       data = environmental) +
   layer(panel.loess(x, y, span = 0.5), style = 1) +
   layer(panel.loess(x, y, span = 1.0), style = 2) +
   layer(panel.key(c("span = 0.5", "span = 1.0"), corner = c(1,.98),
                   lines = TRUE, points = FALSE), packets = 1)

## note that styles come from the settings in effect in the plot,
## which is not always what you want:
xyplot(1:10 ~ 1:10, type = "b", par.settings = simpleTheme(col = "red")) +
  layer(panel.lines(x = jitter(x, 2), ...)) +  ## drawn in red
  layer(panel.lines(x = jitter(x, 2), ...), force = TRUE)  ## reset theme


## using other variables from the original `data` object
## NOTE: need subscripts = TRUE in original call!
zoip &lt;- xyplot(wind ~ temperature | equal.count(radiation, 2),
   data = environmental, subscripts = TRUE)
zoip + layer(panel.points(..., pch = 19,
             col = grey(1 - ozone[subscripts] / max(ozone))),
       data = environmental)


## restrict drawing to specified panels
barchart(yield ~ variety | site, data = barley,
         groups = year, layout = c(1,6), as.table = TRUE,
         scales = list(x = list(rot = 45))) +
layer(ltext(tapply(y, x, max), lab = abbreviate(levels(x)),
      pos = 3), rows = 1)


## example of a new data source
qua &lt;- xyplot(lat ~ long | cut(depth, 2), quakes,
    aspect = "iso", pch = ".", cex = 2)
qua
## add layer showing distance from Auckland
newdat &lt;- with(quakes, expand.grid(
            gridlat = seq(min(lat), max(lat), length = 60),
            gridlon = seq(min(long), max(long), length = 60)))
newdat$dist &lt;- with(newdat, sqrt((gridlat - -36.87)^2 +
                                 (gridlon - 174.75)^2))
qua + layer_(panel.contourplot(x = gridlon, y = gridlat, z = dist,
   contour = TRUE, subscripts = TRUE), data = newdat)
</code></pre>

<hr>
<h2 id='mapplot'> Trellis displays on Maps a.k.a. Choropleth maps </h2><span id='topic+mapplot'></span><span id='topic+mapplot.formula'></span><span id='topic+panel.mapplot'></span><span id='topic+prepanel.mapplot'></span>

<h3>Description</h3>

<p>Produces Trellis displays of numeric (and eventually categorical) data
on a map.  This is largely meant as a demonstration, and users looking
for serious map drawing capabilities should look elsewhere (see below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
mapplot(x, data, ...)

## S3 method for class 'formula'
mapplot(x, data, map, outer = TRUE,
        prepanel = prepanel.mapplot,
        panel = panel.mapplot,
        aspect = "iso",
        legend = NULL,
        breaks, cuts = 30,
        colramp = colorRampPalette(hcl.colors(n = 11, palette = "Spectral")),
        colorkey = TRUE,
        ...)

prepanel.mapplot(x, y, map, ...)
panel.mapplot(x, y, map, breaks, colramp, exact = FALSE, lwd = 0.5, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapplot_+3A_x">x</code>, <code id="mapplot_+3A_y">y</code></td>
<td>
<p> For <code>mapplot</code>, an object on which method dispatch is
carried out.  For the formula method, a formula of the form <code>y
      ~ x</code>, with additional conditioning variables as desired.  The
extended form of conditioning using <code>y ~ x1 + x2</code> etc. is also
allowed.  The formula might be interpreted as in a dot plot, except
that <code>y</code> is taken to be the names of geographical units in
<code>map</code>.
</p>
<p>Suitable subsets (packets) of <code>x</code> and <code>y</code> are passed to
the prepanel and panel functions.
</p>
</td></tr>
<tr><td><code id="mapplot_+3A_data">data</code></td>
<td>
<p> A data source where names in the formula are evaluated </p>
</td></tr>
<tr><td><code id="mapplot_+3A_map">map</code></td>
<td>
<p> An object of class <code>"map"</code> (package <code>maps</code>),
containing boundary information.  The names of the geographical
units must match the <code>y</code> variable in the formula.  </p>
</td></tr>
</table>
<p>The remaining arguments are standard lattice arguments, relevant here
mostly because they have different defaults than usual:
</p>
<table role = "presentation">
<tr><td><code id="mapplot_+3A_outer">outer</code></td>
<td>
<p> Logical flag specifying how variables separated by
<code>+</code> in the formula are interpreted.  It is not advisable to
change the default.  </p>
</td></tr>
<tr><td><code id="mapplot_+3A_prepanel">prepanel</code></td>
<td>
<p> The prepanel function. </p>
</td></tr>
<tr><td><code id="mapplot_+3A_panel">panel</code></td>
<td>
<p> The panel function. </p>
</td></tr>
<tr><td><code id="mapplot_+3A_aspect">aspect</code></td>
<td>
<p> The aspect ratio. </p>
</td></tr>
<tr><td><code id="mapplot_+3A_breaks">breaks</code>, <code id="mapplot_+3A_cuts">cuts</code>, <code id="mapplot_+3A_colramp">colramp</code></td>
<td>
<p> controls conversion of numeric <code>x</code>
values to a false color.  <code>colramp</code> should be
a function that produces colors (such as <code><a href="grDevices.html#topic+cm.colors">cm.colors</a></code>).
If it is <code>NULL</code>, colors are taken from
<code>trellis.par.get("regions")</code>. </p>
</td></tr>
<tr><td><code id="mapplot_+3A_exact">exact</code></td>
<td>
<p> the default <code>exact = FALSE</code> allows the given
<code>y</code> values to match sub-regions of <code>map</code>,
i.e. region names with a qualifier following <code>":"</code>, like
<code>"michigan:north", "michigan:south"</code>. These will both match a
<code>y</code> value of <code>"Michigan"</code>. </p>
</td></tr>
<tr><td><code id="mapplot_+3A_legend">legend</code>, <code id="mapplot_+3A_colorkey">colorkey</code></td>
<td>
<p> controls legends; usually just a color key
giving the association between numeric values of <code>x</code> and
color.  </p>
</td></tr>
<tr><td><code id="mapplot_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr> 
<tr><td><code id="mapplot_+3A_...">...</code></td>
<td>
<p> Further arguments passed on to the underlying engine.
See <code><a href="lattice.html#topic+xyplot">xyplot</a></code> for details.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>.
</p>


<h3>Note</h3>

<p>This function is meant to demonstrate how maps can be incorporated in
a Trellis display.  Users seriously interested in geographical data
should consider using software written by people who know what they
are doing.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar </p>


<h3>References</h3>

 <p><a href="https://en.wikipedia.org/wiki/Choropleth_map">https://en.wikipedia.org/wiki/Choropleth_map</a> </p>


<h3>See Also</h3>

 <p><code><a href="lattice.html#topic+Lattice">Lattice</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Requires the 'maps' and 'mapproj' packages:

if (require(maps) &amp;&amp; require(mapproj)) {

    ## Note: Alaska, Hawaii and others are not included in county map;
    ## this generates warnings with both USCancerRates and ancestry.

    data(USCancerRates)

    suppressWarnings(print(
        mapplot(rownames(USCancerRates) ~ log(rate.male) + log(rate.female),
                data = USCancerRates,
                map = map("county", plot = FALSE, fill = TRUE,
                          projection = "mercator"))
    ))

    suppressWarnings(print(
        mapplot(rownames(USCancerRates) ~ log(rate.male) + log(rate.female),
                data = USCancerRates,
                map = map("county", plot = FALSE, fill = TRUE,
                          projection = "tetra"),
                scales = list(draw = FALSE))
    ))

    data(ancestry)

    county.map &lt;- 
        map('county', plot = FALSE, fill = TRUE, 
            projection = "azequalarea")

    ## set a sequential color palette as current theme, and use it
    opar &lt;- trellis.par.get()
    trellis.par.set(custom.theme(region = rev(hcl.colors(9, "Purp")),
                                 alpha.line = 0.5))
    suppressWarnings(print(
        mapplot(county ~ log10(population), ancestry, map = county.map,
                colramp = NULL, border = "transparent")
    ))
    trellis.par.set(opar)
}

## Not run: 

## this may take a while (should get better area records)

if (require(maps) &amp;&amp; require(mapproj)) {

    county.areas &lt;- 
        area.map(county.map, regions = county.map$names, sqmi = FALSE)
    
    ancestry$density &lt;- 
        with(ancestry, population / county.areas[as.character(county)])

    mapplot(county ~ log(density), ancestry,
            map = county.map, border = NA,
            colramp = colorRampPalette(c("white", "black")))

}

## End(Not run)
</code></pre>

<hr>
<h2 id='marginal.plot'> Display marginal distributions </h2><span id='topic+marginal.plot'></span>

<h3>Description</h3>

<p>Display marginal distributions of several variables,
which may be numeric and/or categorical, on one plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.plot(x,
              data = NULL,
              groups = NULL,
              reorder = !is.table(x),
              plot.points = FALSE,
              ref = TRUE, cut = 0,
              origin = 0, 
              xlab = NULL, ylab = NULL,
              type = c("p", if (is.null(groups)) "h"),
              ...,
              subset = TRUE,
              as.table = TRUE,
              subscripts = TRUE,
              default.scales = list(
                relation = "free",
                abbreviate = TRUE, minlength = 5,
                rot = 30, cex = 0.75, tick.number = 3,
                y = list(draw = FALSE)),
             layout = NULL,
             lattice.options = list(
               layout.heights = list(
                 axis.xlab.padding = list(x = 0),
                 xlab.key.padding = list(x = 0))))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marginal.plot_+3A_x">x</code></td>
<td>
<p> a data frame or table, or a formula of which the first term
is a data frame or table. Otherwise coerced with
<code>as.data.frame</code>. </p>
</td></tr>
<tr><td><code id="marginal.plot_+3A_data">data</code></td>
<td>
<p> an optional data source in which groups and subset may be
be evaluated. </p>
</td></tr>
<tr><td><code id="marginal.plot_+3A_groups">groups</code></td>
<td>
<p> term, to be evaluated in <code>data</code>, that is used as a
grouping variable. </p>
</td></tr>
<tr><td><code id="marginal.plot_+3A_reorder">reorder</code></td>
<td>
<p> whether to reorder factor variables by frequency. </p>
</td></tr>
<tr><td><code id="marginal.plot_+3A_subset">subset</code></td>
<td>
<p> data subset expression, evaluated in <code>data</code>. </p>
</td></tr>
<tr><td><code id="marginal.plot_+3A_plot.points">plot.points</code>, <code id="marginal.plot_+3A_ref">ref</code>, <code id="marginal.plot_+3A_cut">cut</code></td>
<td>
<p> passed to <code>panel.densityplot</code>. </p>
</td></tr>
<tr><td><code id="marginal.plot_+3A_origin">origin</code>, <code id="marginal.plot_+3A_type">type</code></td>
<td>
<p> passed to <code>panel.dotplot</code>. </p>
</td></tr>
<tr><td><code id="marginal.plot_+3A_xlab">xlab</code>, <code id="marginal.plot_+3A_ylab">ylab</code>, <code id="marginal.plot_+3A_as.table">as.table</code>, <code id="marginal.plot_+3A_subscripts">subscripts</code></td>
<td>

<p>see <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="marginal.plot_+3A_default.scales">default.scales</code>, <code id="marginal.plot_+3A_layout">layout</code>, <code id="marginal.plot_+3A_lattice.options">lattice.options</code></td>
<td>

<p>see <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="marginal.plot_+3A_...">...</code></td>
<td>
<p> passed to <code><a href="lattice.html#topic+panel.densityplot">panel.densityplot</a></code> and/or
<code><a href="lattice.html#topic+panel.dotplot">panel.dotplot</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of mixed numeric and categorical variables,
the trellis objects from <code>dotplot()</code> and <code>densityplot()</code>
are merged.
</p>


<h3>Value</h3>

<p>a trellis object.
</p>


<h3>Author(s)</h3>

<p> Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a> </p>


<h3>See Also</h3>

 <p><code><a href="lattice.html#topic+panel.dotplot">panel.dotplot</a></code>,
<code><a href="lattice.html#topic+panel.densityplot">panel.densityplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>enviro &lt;- environmental
## make an ordered factor (so it will not be reordered)
enviro$smell &lt;- cut(enviro$ozone, breaks = c(0, 30, 50, Inf),
    labels = c("ok", "hmmm", "yuck"), ordered = TRUE)
marginal.plot(enviro)

## using groups
enviro$is.windy &lt;- factor(enviro$wind &gt; 10,
    levels = c(TRUE, FALSE), labels = c("windy", "calm"))
marginal.plot(enviro[,1:5], data = enviro, groups = is.windy,
    auto.key = list(lines = TRUE))

## support for tables
marginal.plot(Titanic)
## table with groups
marginal.plot(~ Titanic, data = Titanic, groups = Survived,
    type = "b", auto.key = list(title = "Survived?"))
</code></pre>

<hr>
<h2 id='panel.2dsmoother'>
Plot a smooth approximation of z over x and y.
</h2><span id='topic+panel.2dsmoother'></span>

<h3>Description</h3>

<p>Plot a smooth approximation, using <code><a href="stats.html#topic+loess">loess</a></code> by default, of
one variable (<code>z</code>) against two others (<code>x</code> and <code>y</code>).
</p>
<p>This panel function should be used with a <code><a href="lattice.html#topic+levelplot">levelplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.2dsmoother(x, y, z, subscripts = TRUE,
    form = z ~ x * y, method = "loess", ...,
    args = list(), n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.2dsmoother_+3A_x">x</code>, <code id="panel.2dsmoother_+3A_y">y</code>, <code id="panel.2dsmoother_+3A_z">z</code></td>
<td>

<p>data points. If these are missing, they will be looked for in the
environment of <code>form</code>. So in many cases you can skip these if
passing <code>form</code>. In fact, for convenience, the formula
can be passed as the first argument (i.e. <code>x</code>).
</p>
</td></tr>
<tr><td><code id="panel.2dsmoother_+3A_form">form</code>, <code id="panel.2dsmoother_+3A_method">method</code></td>
<td>

<p>the smoothing model is constructed (approximately) as
<code>method(form, data = list(x=x, y=y, z=z), {args})</code>.
See the Examples section for common choices.
</p>
</td></tr>
<tr><td><code id="panel.2dsmoother_+3A_subscripts">subscripts</code></td>
<td>

<p>data indices for the current packet, as passed in by <code>levelplot</code>.
</p>
</td></tr>
<tr><td><code id="panel.2dsmoother_+3A_...">...</code></td>
<td>

<p>further arguments passed on to <code><a href="lattice.html#topic+panel.levelplot">panel.levelplot</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.2dsmoother_+3A_args">args</code></td>
<td>

<p>a list of further arguments to the model function (<code>method</code>).
</p>
</td></tr>
<tr><td><code id="panel.2dsmoother_+3A_n">n</code></td>
<td>

<p>number of equi-spaced points along each of x and y on which to evaluate the smooth function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This should work with any model function that takes a formula
argument, and has a <code>predict</code> method argument.
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+loess">loess</a></code>,
<code><a href="#topic+panel.smoother">panel.smoother</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
xyz &lt;- data.frame(x = rnorm(100), y = rnorm(100))
xyz$z &lt;- with(xyz, x * y + rnorm(100, sd = 1))

levelplot(z ~ x * y, xyz, panel = panel.2dsmoother)

## showing data points on the same color scale
levelplot(z ~ x * y, xyz,
          panel = panel.levelplot.points, cex = 1.2) +
  layer_(panel.2dsmoother(..., n = 200))

## simple linear regression model
levelplot(z ~ x * y, xyz,
          panel = panel.levelplot.points) +
  layer_(panel.2dsmoother(..., method = "lm"))

## GAM smoother with smoothness by cross validation
if (require("mgcv"))
  levelplot(z ~ x * y, xyz, panel = panel.2dsmoother,
            form = z ~ s(x, y), method = "gam")
</code></pre>

<hr>
<h2 id='panel.3dmisc'>Miscellanous panel utilities for three dimensional Trellis Displays</h2><span id='topic+panel.3dmisc'></span><span id='topic+panel.3dtext'></span><span id='topic+panel.3dbars'></span><span id='topic+panel.3dpolygon'></span>

<h3>Description</h3>

<p>Miscellanous panel functions for use with  three dimensional Lattice
functions such as cloud and wireframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
panel.3dbars(x, y, z,
             rot.mat = diag(4), distance,
             xbase = 1, ybase = 1,
             xlim, xlim.scaled,
             ylim, ylim.scaled,
             zlim, zlim.scaled,
             zero.scaled,
             col = "black",
             lty = 1, lwd = 1,
             alpha,
             ...,
             col.facet = "white",
             alpha.facet = 1)


panel.3dpolygon(x, y, z, rot.mat = diag(4), distance,
                xlim.scaled,
                ylim.scaled,
                zlim.scaled,
                zero.scaled,
                col = "white",
                border = "black",
                font, fontface,
                ...)

panel.3dtext(x, y, z, labels = seq_along(x),
             rot.mat = diag(4), distance, ...)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.3dmisc_+3A_x">x</code>, <code id="panel.3dmisc_+3A_y">y</code>, <code id="panel.3dmisc_+3A_z">z</code></td>
<td>

<p>data to be plotted
</p>
</td></tr>
<tr><td><code id="panel.3dmisc_+3A_rot.mat">rot.mat</code>, <code id="panel.3dmisc_+3A_distance">distance</code></td>
<td>

<p>arguments controlling projection
</p>
</td></tr>
<tr><td><code id="panel.3dmisc_+3A_labels">labels</code></td>
<td>
<p> character or expression vectors to be uses as labels </p>
</td></tr>
<tr><td><code id="panel.3dmisc_+3A_xlim">xlim</code>, <code id="panel.3dmisc_+3A_ylim">ylim</code>, <code id="panel.3dmisc_+3A_zlim">zlim</code></td>
<td>

<p>limits in the original scale
</p>
</td></tr>
<tr><td><code id="panel.3dmisc_+3A_xlim.scaled">xlim.scaled</code>, <code id="panel.3dmisc_+3A_ylim.scaled">ylim.scaled</code>, <code id="panel.3dmisc_+3A_zlim.scaled">zlim.scaled</code></td>
<td>

<p>limits after scaling
</p>
</td></tr>
<tr><td><code id="panel.3dmisc_+3A_zero.scaled">zero.scaled</code></td>
<td>

<p>the value of z = 0 after scaling
</p>
</td></tr>
<tr><td><code id="panel.3dmisc_+3A_xbase">xbase</code>, <code id="panel.3dmisc_+3A_ybase">ybase</code></td>
<td>

<p>length of the sides of the bars (which are always centered on the
<code>x</code> and <code>y</code> values).  Can not be vectorized.
</p>
</td></tr>
<tr><td><code id="panel.3dmisc_+3A_col">col</code>, <code id="panel.3dmisc_+3A_lty">lty</code>, <code id="panel.3dmisc_+3A_lwd">lwd</code>, <code id="panel.3dmisc_+3A_alpha">alpha</code>, <code id="panel.3dmisc_+3A_border">border</code></td>
<td>

<p>Graphical parameters for the border lines.  These can be vectors, in
which case each component will be associated with one bar in
<code>panel.3dbars</code>. 
</p>
</td></tr>
<tr><td><code id="panel.3dmisc_+3A_font">font</code>, <code id="panel.3dmisc_+3A_fontface">fontface</code></td>
<td>
<p> unused graphical parameters, present in the
argument list only so that they can be captured and ignored  </p>
</td></tr>
<tr><td><code id="panel.3dmisc_+3A_col.facet">col.facet</code>, <code id="panel.3dmisc_+3A_alpha.facet">alpha.facet</code></td>
<td>

<p>Graphical parameters for surfaces of the bars . These can be
vectors, in which case each component will be associated with one
bar.
</p>
</td></tr>
<tr><td><code id="panel.3dmisc_+3A_...">...</code></td>
<td>

<p>extra arguments, passed on as appropriate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>panel.3dbars</code> and <code>panel.3dpolygon</code> are both suitable for
use as (components of) the <code>panel.3d.cloud</code> argument of
<code>panel.cloud</code>.  The first one produces three dimensional bars,
and the second one draws three dimensional polygons.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan.sarkar@gmail.com">deepayan.sarkar@gmail.com</a></p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+cloud">cloud</a></code>,
<code><a href="lattice.html#topic+panel.cloud">panel.cloud</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lattice)

cloud(VADeaths, panel.3d.cloud = panel.3dbars,
      col.facet = "grey", xbase = 0.4, ybase = 0.4,
      screen = list(z = 40, x = -30))

cloud(VADeaths, panel.3d.cloud = panel.3dbars,
      xbase = 0.4, ybase = 0.4, zlim = c(0, max(VADeaths)),
      scales = list(arrows = FALSE, just = "right"), xlab = NULL, ylab = NULL,
      col.facet = level.colors(VADeaths, at = do.breaks(range(VADeaths), 20),
                               col.regions = terrain.colors,
                               colors = TRUE),
      colorkey = list(col = terrain.colors, at = do.breaks(range(VADeaths), 20)),
      screen = list(z = 40, x = -30))


cloud(as.table(prop.table(Titanic, margin = 1:3)[,,,2]),
      type = c("p", "h"),
      zlab = "Proportion\nSurvived",
      panel.3d.cloud = panel.3dbars,
      xbase = 0.4, ybase = 0.4,
      aspect = c(1, 0.3),
      scales = list(distance = 2),
      panel.aspect = 0.5)

</code></pre>

<hr>
<h2 id='panel.ellipse'>
Lattice panel function to fit and draw a confidence ellipsoid from
bivariate data.  
</h2><span id='topic+panel.ellipse'></span>

<h3>Description</h3>

<p>A lattice panel function that computes and draws a confidence
ellipsoid from bivariate data, possibly grouped by a third variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.ellipse(x, y, groups = NULL,
              level = 0.68, segments = 50, robust = FALSE,
              center.pch = 3, center.cex = 2, ...,
              type, pch, cex)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.ellipse_+3A_x">x</code>, <code id="panel.ellipse_+3A_y">y</code></td>
<td>

<p>Numeric vectors of same length giving the bivariate data.
Non-numeric variables will be coerced to be numeric.
</p>
</td></tr>
<tr><td><code id="panel.ellipse_+3A_groups">groups</code></td>
<td>

<p>Optional grouping variable.
</p>
</td></tr>
<tr><td><code id="panel.ellipse_+3A_level">level</code></td>
<td>

<p>Confidence level for the ellipse.
</p>
</td></tr>
<tr><td><code id="panel.ellipse_+3A_segments">segments</code></td>
<td>

<p>Number of segments used to approximate the ellipse. 
</p>
</td></tr>
<tr><td><code id="panel.ellipse_+3A_robust">robust</code></td>
<td>

<p>Logical indicating whether a robust method should be used.  If
<code>TRUE</code>, the confidence ellipse is based on a bivariate
t-distribution using the <code><a href="MASS.html#topic+cov.trob">cov.trob</a></code> function in
the <span class="pkg">MASS</span> package.
</p>
</td></tr>
<tr><td><code id="panel.ellipse_+3A_center.pch">center.pch</code></td>
<td>

<p>Plotting character for the center (fitted mean).  If <code>NULL</code>,
the center will not be shown on the plot.
</p>
</td></tr>
<tr><td><code id="panel.ellipse_+3A_center.cex">center.cex</code></td>
<td>

<p>Character expansion (size) multipler for the symbol indicating the
center.
</p>
</td></tr>
<tr><td><code id="panel.ellipse_+3A_...">...</code></td>
<td>

<p>Further arguments, typically graphical parameters.  Passed on to
<code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.  
</p>
</td></tr>
<tr><td><code id="panel.ellipse_+3A_type">type</code>, <code id="panel.ellipse_+3A_pch">pch</code>, <code id="panel.ellipse_+3A_cex">cex</code></td>
<td>

<p>Parameters that are ignored; these are present only to make sure
they are not inadvertently passed on to <code>panel.xyplot</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Deepayan Sarkar, extending code contributed by Michael Friendly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xyplot(Sepal.Length ~ Petal.Length, groups=Species,
       data = iris, scales = "free",
       par.settings = list(superpose.symbol = list(pch=c(15:17)),
                           superpose.line = list(lwd=2, lty=1:3)),
       panel = function(x, y, ...) {
           panel.xyplot(x, y, ...)
           panel.ellipse(x, y, ...)
       },
       auto.key = list(x = .1, y = .8, corner = c(0, 0)))

## Without groups
xyplot(Sepal.Length ~ Petal.Length, 
       data = iris, scales = "free",
       par.settings = list(plot.symbol = list(cex = 1.1, pch=16)),
       panel = function(x, y, ...) {
           panel.xyplot(x, y, ...)
           panel.ellipse(x, y, lwd = 2, ...)
       },
       auto.key = list(x = .1, y = .8, corner = c(0, 0)))


## With conditioning
xyplot(Sepal.Length ~ Petal.Length | Species, 
       data = iris, scales = "free",
       par.settings = list(plot.symbol = list(cex = 1.1, pch=16)),
       layout=c(2,2),
       panel = function(x, y, ...) {
           panel.xyplot(x, y, ...)
           panel.ellipse(x, y, lwd = 2, ...)
       },
       auto.key = list(x = .6, y = .8, corner = c(0, 0)))


## Compare classical with robust 
xyplot(Sepal.Length ~ Petal.Length | Species, 
       data = iris, scales = "free",
       par.settings = list(plot.symbol = list(cex = 1.1, pch=16)),
       layout=c(2,2),
       panel = function(x, y, ...) {
           panel.xyplot(x, y, ...)
           panel.ellipse(x, y, lwd = 2, ...)
           panel.ellipse(x, y, lwd = 2, col="red", robust=TRUE,  ...)
       })

</code></pre>

<hr>
<h2 id='panel.key'>
Draw a simple key inside a panel of a lattice plot.
</h2><span id='topic+panel.key'></span>

<h3>Description</h3>

<p>Draw a <code><a href="lattice.html#topic+simpleKey">simpleKey</a></code> inside a panel of a lattice plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.key(text, ..., corner = c(0, 1), x = corner[1], y = corner[2])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.key_+3A_text">text</code>, <code id="panel.key_+3A_...">...</code></td>
<td>

<p>entries in the <code><a href="lattice.html#topic+simpleKey">simpleKey</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.key_+3A_corner">corner</code>, <code id="panel.key_+3A_x">x</code>, <code id="panel.key_+3A_y">y</code></td>
<td>

<p>defines the position of the key within the panel viewport. These are
given in normalised coordinates between 0 and 1. The two elements
of <code>corner</code> specify the x and y positions respectively.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+simpleKey">simpleKey</a></code>,
<code><a href="lattice.html#topic+draw.key">draw.key</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyplot(ozone ~ wind | equal.count(temperature, 2),
       data = environmental) +
   layer(panel.loess(x, y, span = 0.5), style = 1) +
   layer(panel.loess(x, y, span = 1.0), style = 2) +
   layer(panel.key(c("span = 0.5", "span = 1.0"), corner = c(1,.98),
                   lines = TRUE, points = FALSE), packets = 1)
</code></pre>

<hr>
<h2 id='panel.lmlineq'>
Draw a line with a label, by default its equation
</h2><span id='topic+panel.lmlineq'></span><span id='topic+panel.ablineq'></span>

<h3>Description</h3>

<p>This is an extension of the panel functions <code><a href="lattice.html#topic+panel.abline">panel.abline</a></code> and
<code><a href="lattice.html#topic+panel.lmline">panel.lmline</a></code> to also draw a label on the line. The
default label is the line equation, and optionally the R squared value
of its fit to the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.ablineq(a = NULL, b = 0,
              h = NULL, v = NULL,
              reg = NULL, coef = NULL,
              pos = if (rotate) 1 else NULL,
              offset = 0.5, adj = NULL,
              at = 0.5, x, y,
              rotate = FALSE, srt = 0,
              label = NULL,
              varNames = alist(y = y, x = x),
              varStyle = "italic",
              fontfamily = "serif",
              digits = 3,
              r.squared = FALSE, sep = ", ", sep.end = "",
              col, col.text, col.line,
              ..., reference = FALSE)

panel.lmlineq(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.lmlineq_+3A_a">a</code>, <code id="panel.lmlineq_+3A_b">b</code>, <code id="panel.lmlineq_+3A_h">h</code>, <code id="panel.lmlineq_+3A_v">v</code>, <code id="panel.lmlineq_+3A_reg">reg</code>, <code id="panel.lmlineq_+3A_coef">coef</code></td>
<td>

<p>specification of the line.
The simplest usage is to give <code>a</code> and <code>b</code> to describe the
line <em>y = a + b x</em>.
Horizontal or vertical lines can be specified as
arguments <code>h</code> or <code>v</code>, respectively.
The first argument (<code>a</code>) can also be a model object produced by
<code><a href="stats.html#topic+lm">lm</a></code>.
See <code><a href="lattice.html#topic+panel.abline">panel.abline</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_pos">pos</code>, <code id="panel.lmlineq_+3A_offset">offset</code></td>
<td>

<p>passed on to <code><a href="lattice.html#topic+panel.text">panel.text</a></code>.
For <code>pos</code>: 1 = below, 2 = left, 3 = above, 4 = right,
and the <code>offset</code> (in character widths) is applied.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_adj">adj</code></td>
<td>

<p>passed on to <code><a href="lattice.html#topic+panel.text">panel.text</a></code>.
c(0,0) = above right, c(1,0) = above left,
c(0,1) = below right, c(1,1) = below left;
offset does not apply when using <code>adj</code>.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_fontfamily">fontfamily</code></td>
<td>

<p>passed on to <code><a href="lattice.html#topic+panel.text">panel.text</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_at">at</code></td>
<td>

<p>position of the equation as a fractional distance along the line.
This should be in the range 0 to 1.
When a vertical line is drawn, this gives the vertical position of
the equation.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_x">x</code>, <code id="panel.lmlineq_+3A_y">y</code></td>
<td>

<p>position of the equation in native units. If given, this over-rides
<code>at</code>.
For <code>panel.lmlineq</code> this is the data, passed on as <code>lm(y ~ x)</code>.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_rotate">rotate</code>, <code id="panel.lmlineq_+3A_srt">srt</code></td>
<td>

<p>set <code>rotate = TRUE</code> to align the equation with the line.
This will over-ride <code>srt</code>, which otherwise gives the rotation
angle.
Note that the calculated angle depends on the current device size;
this will be wrong if you change the device aspect ratio after plotting.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_label">label</code></td>
<td>

<p>the text to draw along with the line. If specified, this will be
used instead of an equation.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_varnames">varNames</code></td>
<td>

<p>names to display for <code>x</code> and/or <code>y</code>.
This should be a list
like <code>list(y = "Q", x = "X")</code>
or, for mathematical symbols,
<code>alist(y = (alpha + beta), x = sqrt(x[t]))</code>.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_varstyle">varStyle</code></td>
<td>

<p>the name of a <code><a href="grDevices.html#topic+plotmath">plotmath</a></code> function to wrap around the
equation expression, or <code>NULL</code>. E.g. <code>"bolditalic"</code>,
<code>"displaystyle"</code>.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_digits">digits</code></td>
<td>

<p>number of decimal places to show for coefficients in equation.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_r.squared">r.squared</code></td>
<td>

<p>the <code class="reqn">R^2</code> statistic to display along with the equation of a line.
This can be given directly as a number, or <code>TRUE</code>, in which
case the function expects a model object (typically
<code><a href="stats.html#topic+lm">lm</a></code>) and extracts the <code class="reqn">R^2</code> statistic from it.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_sep">sep</code>, <code id="panel.lmlineq_+3A_sep.end">sep.end</code></td>
<td>

<p>The <code class="reqn">R^2</code> (<code>r.squared</code>) value is separated from the
equation by the string <code>sep</code>, and also <code>sep.end</code> is added
to the end. For example: 
<code>panel.ablineq(lm(y ~ x), r.squared = TRUE,
      sep = " (", sep.end = ")")</code>.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_...">...</code>, <code id="panel.lmlineq_+3A_col">col</code>, <code id="panel.lmlineq_+3A_col.text">col.text</code>, <code id="panel.lmlineq_+3A_col.line">col.line</code></td>
<td>

<p>passed on to <code><a href="lattice.html#topic+panel.abline">panel.abline</a></code> and
<code><a href="lattice.html#topic+panel.text">panel.text</a></code>.
Note that <code>col</code> applies to both text and line; <code>col.text</code>
applies to the equation only, and <code>col.line</code> applies to line only.
</p>
</td></tr>
<tr><td><code id="panel.lmlineq_+3A_reference">reference</code></td>
<td>

<p>whether to draw the line in a &quot;reference line&quot; style, like that used
for grid lines.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation is constructed as an expression using <code><a href="grDevices.html#topic+plotmath">plotmath</a></code>.
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+panel.abline">panel.abline</a></code>,
<code><a href="lattice.html#topic+panel.text">panel.text</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="grDevices.html#topic+plotmath">plotmath</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
xsim &lt;- rnorm(50, mean = 3)
ysim &lt;- (0 + 2 * xsim) * (1 + rnorm(50, sd = 0.3))

## basic use as a panel function
xyplot(ysim ~ xsim, panel = function(x, y, ...) {
  panel.xyplot(x, y, ...)
  panel.ablineq(a = 0, b = 2, adj = c(0,1))
  panel.lmlineq(x, y, adj = c(1,0), lty = 2,
                col.line = "grey", digits = 1)
})

## using layers:
xyplot(ysim^2 ~ xsim) +
  layer(panel.ablineq(lm(y ~ x, subset = x &lt;= 3),
    varNames = alist(y = y^2, x = x[x &lt;= 3]), pos = 4))

## rotated equation (depends on device aspect at plotting time)
xyplot(ysim ~ xsim) +
  layer(panel.ablineq(lm(y ~ x), rotate = TRUE, at = 0.8))

## horizontal and vertical lines
xyplot(ysim ~ xsim) +
  layer(panel.ablineq(v = 3, pos = 4, at = 0.1, lty = 2,
                      label = "3.0 (critical value)")) +
  layer(panel.ablineq(h = mean(ysim), pos = 3, at = 0.15, lty = 2,
                      varNames = alist(y = plain(mean)(y))))

## using layer styles, r.squared
xyplot(ysim ~ xsim) +
  layer(panel.ablineq(lm(y ~ x), r.sq = TRUE,
                      at = 0.4, adj=0:1), style = 1) +
  layer(panel.ablineq(lm(y ~ x + 0), r.sq = TRUE,
                      at = 0.6, adj=0:1), style = 2)

## alternative placement of equations
xyplot(ysim ~ xsim) +
  layer(panel.ablineq(lm(y ~ x), r.sq = TRUE, rot = TRUE,
                      at = 0.8, pos = 3), style = 1) +
  layer(panel.ablineq(lm(y ~ x + 0), r.sq = TRUE, rot = TRUE,
                      at = 0.8, pos = 1), style = 2)

update(trellis.last.object(),
  auto.key = list(text = c("intercept", "no intercept"),
                  points = FALSE, lines = TRUE))
</code></pre>

<hr>
<h2 id='panel.qqmath.tails'>
Approximate distribution in qqmath but keep points on tails.
</h2><span id='topic+panel.qqmath.tails'></span>

<h3>Description</h3>

<p>Panel function for <code><a href="lattice.html#topic+qqmath">qqmath</a></code> to reduce the number of points
plotted by sampling along the specified distribution. The usual method
for such sampling is to use the <code>f.value</code> argument to
<code><a href="lattice.html#topic+panel.qqmath">panel.qqmath</a></code>. However, this panel function differs in
two ways:
(1) a specified number of data points are retained (not
interpolated) on each tail of the distribution.
(2) the sampling is evenly spaced along the specified
distribution automatically (whereas <code>f.value = ppoints(100)</code> is
evenly spaced along the uniform distribution only).
</p>
<p><em>
This function is deprecated as of <span class="pkg">lattice</span> 0.18-4 (available for
R 2.11.0). Use the <code>tails.n</code> argument of
<code><a href="lattice.html#topic+panel.qqmath">panel.qqmath</a></code> instead.
</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.qqmath.tails(x, f.value = NULL, distribution = qnorm,
                    groups = NULL, ..., approx.n = 100, tails.n = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.qqmath.tails_+3A_x">x</code>, <code id="panel.qqmath.tails_+3A_f.value">f.value</code>, <code id="panel.qqmath.tails_+3A_distribution">distribution</code>, <code id="panel.qqmath.tails_+3A_groups">groups</code></td>
<td>

<p>see <code><a href="lattice.html#topic+panel.qqmath">panel.qqmath</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.qqmath.tails_+3A_...">...</code></td>
<td>

<p>further arguments passed on to <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.qqmath.tails_+3A_approx.n">approx.n</code></td>
<td>

<p>number of points to use in approximating the distribution.
Points will be equally spaced in the distribution space.
</p>
</td></tr>
<tr><td><code id="panel.qqmath.tails_+3A_tails.n">tails.n</code></td>
<td>

<p>number of points to retain (untouched) at both the high and low tails.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+panel.qqmath">panel.qqmath</a></code> which should be used instead (as of <span class="pkg">lattice</span> 0.18-4).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see ?panel.qqmath

</code></pre>

<hr>
<h2 id='panel.quantile'>
Plot a quantile regression line with standard error bounds.
</h2><span id='topic+panel.quantile'></span>

<h3>Description</h3>

<p>Plot a quantile regression line with standard error bounds, using the
<span class="pkg">quantreg</span> package. This is based on the
<code><a href="ggplot2.html#topic+stat_quantile">stat_quantile</a></code> function from <span class="pkg">ggplot2</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.quantile(x, y, form = y ~ x, method = "rq", ...,
    tau = 0.5, ci = FALSE, ci.type = "default", level = 0.95,
    n = 100, col = plot.line$col, col.se = col,
    lty = plot.line$lty, lwd = plot.line$lwd,
    alpha = plot.line$alpha, alpha.se = 0.25, border = NA,
    superpose = FALSE,
    ## ignored: ##
    subscripts, group.number, group.value,
    type, col.line, col.symbol, fill,
    pch, cex, font, fontface, fontfamily)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.quantile_+3A_x">x</code>, <code id="panel.quantile_+3A_y">y</code></td>
<td>

<p>data points. If these are missing, they will be looked for in the
environment of <code>form</code>. So in many cases you can skip these if
passing <code>form</code>. In fact, for convenience, the formula
can be passed as the first argument (i.e. <code>x</code>).
</p>
</td></tr>
<tr><td><code id="panel.quantile_+3A_form">form</code>, <code id="panel.quantile_+3A_method">method</code></td>
<td>

<p>Formula and the name of a modeling function (as a character
string). The model is constructed (approximately) as
<code>method(form, tau = tau, data = list(x=x, y=y), ...)</code>.
Currently, <code>method</code> is expected to be either <code>"rq"</code> or
<code>"rqss"</code>, and for these the corresponding functions in the
<span class="pkg">quantreg</span> package is used. In principle, any other function
that supports the same interface can also be specified by name.
</p>
</td></tr>
<tr><td><code id="panel.quantile_+3A_...">...</code></td>
<td>

<p>further arguments passed on to the model function (<code>method</code>),
typically <code><a href="quantreg.html#topic+rq">rq</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.quantile_+3A_tau">tau</code></td>
<td>

<p><var>p</var> values for the quantiles to estimate.
</p>
<p>Note: only one value for <code>tau</code> can be specified if
estimating confidence intervals with <code>ci</code>.
</p>
</td></tr>
<tr><td><code id="panel.quantile_+3A_ci">ci</code>, <code id="panel.quantile_+3A_ci.type">ci.type</code>, <code id="panel.quantile_+3A_level">level</code></td>
<td>

<p>estimate a confidence interval at level <code>level</code> using the
method <code>ci.type</code>; see <code><a href="quantreg.html#topic+predict.rq">predict.rq</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.quantile_+3A_n">n</code></td>
<td>

<p>number of equi-spaced points on which to evaluate the function.
</p>
</td></tr>
<tr><td><code id="panel.quantile_+3A_col">col</code>, <code id="panel.quantile_+3A_col.se">col.se</code>, <code id="panel.quantile_+3A_lty">lty</code>, <code id="panel.quantile_+3A_lwd">lwd</code>, <code id="panel.quantile_+3A_alpha">alpha</code>, <code id="panel.quantile_+3A_alpha.se">alpha.se</code>, <code id="panel.quantile_+3A_border">border</code></td>
<td>

<p>graphical parameters. <code>col</code> and <code>alpha</code> apply to the
line(s), while <code>col.se</code> and <code>alpha.se</code>
apply to the shaded <code>ci</code> region.
</p>
</td></tr>
<tr><td><code id="panel.quantile_+3A_superpose">superpose</code></td>
<td>

<p>if <code>TRUE</code>, plot each quantile line (<code>tau</code>) in a
different style (using <code>trellis.par.get("superpose.line")</code>).
</p>
</td></tr>
<tr><td><code id="panel.quantile_+3A_subscripts">subscripts</code>, <code id="panel.quantile_+3A_group.number">group.number</code>, <code id="panel.quantile_+3A_group.value">group.value</code>, <code id="panel.quantile_+3A_type">type</code>, <code id="panel.quantile_+3A_col.line">col.line</code>, <code id="panel.quantile_+3A_col.symbol">col.symbol</code>, <code id="panel.quantile_+3A_fill">fill</code>, <code id="panel.quantile_+3A_pch">pch</code>, <code id="panel.quantile_+3A_cex">cex</code>, <code id="panel.quantile_+3A_font">font</code>, <code id="panel.quantile_+3A_fontface">fontface</code>, <code id="panel.quantile_+3A_fontfamily">fontfamily</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to look at <code>vignette("rq", package="quantreg")</code>.
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>
<p>Based on <code><a href="ggplot2.html#topic+stat_quantile">stat_quantile</a></code> by Hadley Wickham.
</p>


<h3>See Also</h3>

<p><code><a href="quantreg.html#topic+rq">rq</a></code>,
<code><a href="#topic+panel.smoother">panel.smoother</a></code>,
<code><a href="ggplot2.html#topic+stat_quantile">stat_quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## library("quantreg")

set.seed(1)
xy &lt;- data.frame(x = runif(100), y = rt(100, df = 5))
xyplot(y ~ x, xy) +
    layer(panel.quantile(x, y, tau = c(.95, .5, .05)))

if (require("splines")) {
    xyplot(y ~ x, xy) +
        layer(panel.quantile(y ~ ns(x, 3), tau = 0.9))

    xyplot(y ~ x, xy) +
        layer(panel.quantile(y ~ ns(x, 3), tau = 0.9, ci = TRUE))
}

xyplot(y ~ x, xy) +
    layer(panel.quantile(x, y, tau = c(.5, .9, .1), superpose = TRUE))

update(trellis.last.object(),
       auto.key = list(text = paste(c(50,90,10), "% quantile"),
                  points = FALSE, lines = TRUE))

xyplot(y ~ x, xy) +
    layer(panel.quantile(y ~ qss(x, lambda=1), method = "rqss"))

</code></pre>

<hr>
<h2 id='panel.scaleArrow'>
Draw a scale bar as an arrow, labelled with its length in plot units.
</h2><span id='topic+panel.scaleArrow'></span>

<h3>Description</h3>

<p>Draw a scale bar as an arrow, labelled with its length in plot units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.scaleArrow(x = unit(0:1, "npc"), y = unit(0:1, "npc"),
                 default.units = "npc",
                 digits = 0, append = "", label = NULL,
                 angle = 30, length = 0.5, unit = "char",
                 type = "open", ends = "both",
                 ...,
                 col = add.line$col, fill = col, alpha = add.line$alpha,
                 lty = add.line$lty, lwd = add.line$lwd,
                 col.text = add.text$col, alpha.text = add.text$alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.scaleArrow_+3A_x">x</code>, <code id="panel.scaleArrow_+3A_y">y</code>, <code id="panel.scaleArrow_+3A_default.units">default.units</code></td>
<td>

<p>coordinates of the line ends as <span class="pkg">grid</span> <code><a href="grid.html#topic+unit">unit</a></code>s or
otherwise interpreted in <code>default.units</code>.
</p>
</td></tr>
<tr><td><code id="panel.scaleArrow_+3A_digits">digits</code></td>
<td>

<p>number of decimal places to keep for the distance measure.
</p>
</td></tr>
<tr><td><code id="panel.scaleArrow_+3A_append">append</code></td>
<td>

<p>a string to append to the distance for the label.
</p>
</td></tr>
<tr><td><code id="panel.scaleArrow_+3A_label">label</code></td>
<td>

<p>label to place on the mid point of the scale, over-riding the default.
</p>
</td></tr>
<tr><td><code id="panel.scaleArrow_+3A_angle">angle</code>, <code id="panel.scaleArrow_+3A_length">length</code>, <code id="panel.scaleArrow_+3A_unit">unit</code>, <code id="panel.scaleArrow_+3A_type">type</code>, <code id="panel.scaleArrow_+3A_ends">ends</code></td>
<td>

<p>specification of the arrow style; see <code><a href="lattice.html#topic+panel.arrows">panel.arrows</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.scaleArrow_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code><a href="lattice.html#topic+panel.text">panel.text</a></code>.
You will need at least the <code>pos</code> or <code>adj</code> arguments.
</p>
</td></tr>
<tr><td><code id="panel.scaleArrow_+3A_col">col</code>, <code id="panel.scaleArrow_+3A_fill">fill</code>, <code id="panel.scaleArrow_+3A_alpha">alpha</code>, <code id="panel.scaleArrow_+3A_lty">lty</code>, <code id="panel.scaleArrow_+3A_lwd">lwd</code></td>
<td>

<p>graphical parameters relevant to the line.
</p>
</td></tr>
<tr><td><code id="panel.scaleArrow_+3A_col.text">col.text</code>, <code id="panel.scaleArrow_+3A_alpha.text">alpha.text</code></td>
<td>

<p>graphical parameters relevant to the text label. Others like
<code>cex</code> and <code>font</code> can be passed though <code>...</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+panel.abline">panel.abline</a></code>,
<code><a href="grid.html#topic+grid.text">grid.text</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyplot(EuStockMarkets) +
  layer(panel.scaleArrow(x = 0.99, append = " units",
          col = "grey", srt = 90, cex = 0.8))
</code></pre>

<hr>
<h2 id='panel.segplot'> Default prepanel and panel functions for segplot  </h2><span id='topic+prepanel.segplot'></span><span id='topic+panel.segplot'></span>

<h3>Description</h3>

<p>Draws line segments or rectangles.  Mainly intended to be used in
conjunction with the <code>segplot</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepanel.segplot(x, y, z, subscripts, horizontal = TRUE, ...)

panel.segplot(x, y, z, level = NULL, subscripts, 
              at,
              draw.bands = is.factor(z),
              col, alpha, 
              lty, lwd,
              border,
              col.symbol = col, alpha.symbol = alpha,
              col.regions = regions$col,
              band.height = 0.6,
              horizontal = TRUE, 
              ...,
              segments.fun = panel.segments,
              centers = NULL,
              pch = 16)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.segplot_+3A_x">x</code>, <code id="panel.segplot_+3A_y">y</code>, <code id="panel.segplot_+3A_z">z</code></td>
<td>
<p> Vectors corresponding to <code>x1</code>, <code>x2</code> and
<code>y</code> respectively in the <code>segplot</code> formula.  The names are
different for compatibility with <code>panel.levelplot</code>.  These are
all the original vectors in <code>data</code>, not subsetted for
particular panels.  </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_level">level</code></td>
<td>
<p> optional vector controlling color of segments </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_centers">centers</code></td>
<td>
<p> optional vector of &lsquo;centers&rsquo; of the segments.
If specified, points will be plotted at these <code>y</code>-locations.  </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_pch">pch</code></td>
<td>
<p> plotting character used for <code>centers</code>. </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_subscripts">subscripts</code></td>
<td>
<p> integer subscript to be used as an indexing vector
for <code>x</code>, <code>y</code>, <code>z</code> and <code>level</code>, giving the packet
for the current panel. </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_horizontal">horizontal</code></td>
<td>
<p> logical, whether the segments are to be drawn
horizontally (the default) or vertically.  This essentially swaps
the role of the x- and y-axes in each panel. </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_at">at</code></td>
<td>
<p> values of <code>level</code> where color code changes </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_draw.bands">draw.bands</code></td>
<td>
<p> logical, whether to draw rectangles instead of
lines </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_col">col</code>, <code id="panel.segplot_+3A_alpha">alpha</code>, <code id="panel.segplot_+3A_lty">lty</code>, <code id="panel.segplot_+3A_lwd">lwd</code>, <code id="panel.segplot_+3A_border">border</code></td>
<td>
<p> Graphical parameters for the
segment.  Defaults to parameter settings for <code>"plot.line"</code> or
<code>"plot.polygon"</code> for segments and rectangles respectively.
<code>col</code> is overridden by <code>col.regions</code> if <code>level</code> is
not null. </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_col.symbol">col.symbol</code>, <code id="panel.segplot_+3A_alpha.symbol">alpha.symbol</code></td>
<td>
<p> Graphical parameters for the point if
<code>centers</code> are plotted.  Defaults to the corresponding
parameters for the segment.
</p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_col.regions">col.regions</code></td>
<td>
<p> vector of colors as in <code><a href="lattice.html#topic+levelplot">levelplot</a></code> </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_band.height">band.height</code></td>
<td>
<p> height of rectangles (applicable if
<code>draw.bands</code> is <code>TRUE</code> </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_...">...</code></td>
<td>
<p> Other arguments, passed on to <code>panel.rect</code> (when
<code>draw.bands=TRUE</code>), <code>segments.fun</code> (otherwise),
<code>panel.points</code> (if <code>centers</code> is not <code>NULL</code>), etc. as
appropriate. </p>
</td></tr>
<tr><td><code id="panel.segplot_+3A_segments.fun">segments.fun</code></td>
<td>
<p> function used to plot segments when
<code>draw.bands</code> is <code>FALSE</code>.  The default is to use
<code><a href="lattice.html#topic+panel.segments">panel.segments</a></code>, but <code><a href="lattice.html#topic+panel.arrows">panel.arrows</a></code> is a
useful alternative (arguments to <code>segments.fun</code> can be provided
via the <code>...</code> argument, see example for
<code><a href="#topic+segplot">segplot</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>prepanel.segplot</code> a list with components <code>xlim</code> and
<code>ylim</code>.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan.sarkar@r-project.org">deepayan.sarkar@r-project.org</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+segplot">segplot</a></code> </p>

<hr>
<h2 id='panel.smoother'>
Plot a smoothing line with standard error bounds.
</h2><span id='topic+panel.smoother'></span>

<h3>Description</h3>

<p>Plot a smoothing line with standard error bounds.
This is based on the <code><a href="ggplot2.html#topic+stat_smooth">stat_smooth</a></code>
function from <span class="pkg">ggplot2</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.smoother(x, y, form = y ~ x, method = "loess", ...,
    se = TRUE, level = 0.95, n = 100,
    col = plot.line$col, col.se = col,
    lty = plot.line$lty, lwd = plot.line$lwd,
    alpha = plot.line$alpha, alpha.se = 0.25, border = NA,
    ## ignored: ##
    subscripts, group.number, group.value,
    type, col.line, col.symbol, fill,
    pch, cex, font, fontface, fontfamily)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.smoother_+3A_x">x</code>, <code id="panel.smoother_+3A_y">y</code></td>
<td>

<p>data points. If these are missing, they will be looked for in the
environment of <code>form</code>. So in many cases you can skip these if
passing <code>form</code>. In fact, for convenience, the formula
can be passed as the first argument (i.e. <code>x</code>).
</p>
</td></tr>
<tr><td><code id="panel.smoother_+3A_form">form</code>, <code id="panel.smoother_+3A_method">method</code></td>
<td>

<p>the smoothing model is constructed (approximately) as
<code>method(form, data = list(x=x, y=y), ...)</code>.
See the Examples section for common choices.
</p>
</td></tr>
<tr><td><code id="panel.smoother_+3A_...">...</code></td>
<td>

<p>further arguments passed on to the model function (<code>method</code>).
</p>
</td></tr>
<tr><td><code id="panel.smoother_+3A_se">se</code>, <code id="panel.smoother_+3A_level">level</code></td>
<td>

<p>estimate standard errors on the smoother, at the given <code>level</code>,
and plot these as a band.
</p>
</td></tr>
<tr><td><code id="panel.smoother_+3A_n">n</code></td>
<td>

<p>number of equi-spaced points on which to evaluate the smooth function.
</p>
</td></tr>
<tr><td><code id="panel.smoother_+3A_col">col</code>, <code id="panel.smoother_+3A_col.se">col.se</code>, <code id="panel.smoother_+3A_lty">lty</code>, <code id="panel.smoother_+3A_lwd">lwd</code>, <code id="panel.smoother_+3A_alpha">alpha</code>, <code id="panel.smoother_+3A_alpha.se">alpha.se</code>, <code id="panel.smoother_+3A_border">border</code></td>
<td>

<p>graphical parameters. <code>col</code> and <code>alpha</code> apply to the
smoothing line, while <code>col.se</code> and <code>alpha.se</code>
apply to the shaded <code>se</code> region.
</p>
</td></tr>
<tr><td><code id="panel.smoother_+3A_subscripts">subscripts</code>, <code id="panel.smoother_+3A_group.number">group.number</code>, <code id="panel.smoother_+3A_group.value">group.value</code>, <code id="panel.smoother_+3A_type">type</code>, <code id="panel.smoother_+3A_col.line">col.line</code>, <code id="panel.smoother_+3A_col.symbol">col.symbol</code>, <code id="panel.smoother_+3A_fill">fill</code>, <code id="panel.smoother_+3A_pch">pch</code>, <code id="panel.smoother_+3A_cex">cex</code>, <code id="panel.smoother_+3A_font">font</code>, <code id="panel.smoother_+3A_fontface">fontface</code>, <code id="panel.smoother_+3A_fontfamily">fontfamily</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This should work with any model function that takes a formula
argument, and has a <code>predict</code> method with a <code>se</code> argument.
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>
<p>Based on <code><a href="ggplot2.html#topic+stat_smooth">stat_smooth</a></code> by Hadley Wickham.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+panel.loess">panel.loess</a></code>,
<code><a href="#topic+panel.quantile">panel.quantile</a></code>,
<code><a href="ggplot2.html#topic+stat_smooth">stat_smooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
xy &lt;- data.frame(x = runif(100),
                 y = rt(100, df = 5),
                 y2 = rt(100, df = 5) + 1)

xyplot(y ~ x, xy, panel = function(...) {
       panel.xyplot(...)
       panel.smoother(..., span = 0.9)
})

## per-group layers with glayer (pass `...` to get styles)
xyplot(y + y2 ~ x, xy) +
  glayer(panel.smoother(...))

## natural spline with 5 degrees of freedom
if (require("splines"))
  xyplot(y ~ x, xy) +
    layer(panel.smoother(y ~ ns(x,5), method = "lm"))

## thin plate regression spline with smoothness
## chosen by cross validation (see ?mgcv::gam)
if (require("mgcv"))
  xyplot(y ~ x, xy) +
    layer(panel.smoother(y ~ s(x), method = "gam"))

## simple linear regression with standard errors:
xyplot(y ~ x, xy) +
  layer(panel.smoother(x, y, method = "lm"), style = 2)
</code></pre>

<hr>
<h2 id='panel.tskernel'>
Calculate and plot smoothed time series.
</h2><span id='topic+panel.tskernel'></span><span id='topic+simpleSmoothTs'></span><span id='topic+simpleSmoothTs.default'></span><span id='topic+simpleSmoothTs.zoo'></span>

<h3>Description</h3>

<p>Plot time series smoothed by discrete symmetric smoothing kernels.
These kernels can be used to smooth time series objects.
Options include moving averages, triangular filters, or
approximately Gaussian filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.tskernel(x, y, ...,
    width = NROW(x) %/% 10 + 1, n = 300,
    c = 1, sides = 2, circular = FALSE,
    kern = kernel("daniell",
           rep(floor((width/sides) / sqrt(c)), c)))

simpleSmoothTs(x, ...)

## Default S3 method:
simpleSmoothTs(x, ...,
    width = NROW(x) %/% 10 + 1, n = NROW(x),
    c = 1, sides = 2, circular = FALSE,
    kern = kernel("daniell",
           rep(floor((width/sides)/sqrt(c)), c)))

## S3 method for class 'zoo'
simpleSmoothTs(x, ..., n = NROW(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.tskernel_+3A_x">x</code>, <code id="panel.tskernel_+3A_y">y</code></td>
<td>

<p>data points. Should define a regular, ordered series.
A time series object can be passed as the first argument, in which
case <code>y</code> can be omitted. The <code>x</code> argument given to
<code>simpleSmoothTs</code> is allowed to be a multivariate time series,
i.e. to have multiple columns.
</p>
</td></tr>
<tr><td><code id="panel.tskernel_+3A_...">...</code></td>
<td>

<p>further arguments passed on to <code><a href="lattice.html#topic+panel.lines">panel.lines</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.tskernel_+3A_width">width</code></td>
<td>

<p>nominal width of the smoothing kernel in time steps. In the default
case, which is a simple moving average, this is the actual width.
When <code>c &gt; 1</code> the number of time steps used in the kernel
increases but the equivalent bandwidth stays the same.
If only past values are used (with <code>sides = 1</code>) then
<code>width</code> refers to one side of the symmetric kernel.
</p>
</td></tr>
<tr><td><code id="panel.tskernel_+3A_n">n</code></td>
<td>

<p>approximate number of time steps desired for the result. If this is
less than the length of <code>x</code>, the smoothed time series will be
aggregated by averaging blocks of (an integer number of) time
steps, and this aggregated series will be centered with respect to
the original series.
</p>
</td></tr>
<tr><td><code id="panel.tskernel_+3A_c">c</code></td>
<td>

<p>smoothness of the kernel: <code>c = 1</code> is a moving average,
<code>c = 2</code> is a triangular kernel, <code>c = 3</code> and higher
approximate smooth Gaussian kernels.
<code>c</code> is actually the number of times to
recursively convolve a simple moving average kernel with itself.
The kernel size is adjusted to maintain a constant equivalent
bandwidth as <code>c</code> increases.
</p>
</td></tr>
<tr><td><code id="panel.tskernel_+3A_sides">sides</code></td>
<td>

<p>if <code>sides=1</code> the smoothed series is calculed from past values
only (using one half of the symmetric kernel); if <code>sides=2</code> it
is centred around lag 0.
</p>
</td></tr>
<tr><td><code id="panel.tskernel_+3A_circular">circular</code></td>
<td>

<p>to treat the data as circular (periodic).
</p>
</td></tr>
<tr><td><code id="panel.tskernel_+3A_kern">kern</code></td>
<td>

<p>a <code>tskernel</code> object; if given, this over-rides <code>width</code> and
<code>c</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The author is not an expert on time series theory.
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kernel">kernel</a></code>,
<code><a href="stats.html#topic+filter">filter</a></code>,
<code><a href="lattice.html#topic+xyplot.ts">xyplot.ts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a Gaussian-like filter (contrast with c = 1 or c = 2)
xyplot(sunspot.year) +
layer(panel.tskernel(x, y, width = 20, c = 3, col = 1, lwd = 2))

## example from ?kernel:
## long and short moving averages, backwards in time
xyplot(EuStockMarkets[,1]) +
  layer(panel.tskernel(x, y, width = 100, col = 1, sides = 1)) +
  layer(panel.tskernel(x, y, width = 20, col = 2, sides = 1))

## per group, with a triangular filter
xyplot(EuStockMarkets, superpose = TRUE) +
  glayer(panel.tskernel(..., width = 100, c = 2),
         theme = simpleTheme(lwd = 2))

## plot the actual kernels used; note adjustment of width
width = 100
kdat &lt;- lapply(1:4, function(c) {
    k &lt;- kernel("daniell", rep(floor(0.5*width / sqrt(c)), c))
    ## demonstrate that the effective bandwidth stays the same:
    message("c = ", c, ": effective bandwidth = ", bandwidth.kernel(k))
    ## represent the kernel as a time series, for plotting
    ts(k[-k$m:k$m], start = -k$m)
})
names(kdat) &lt;- paste("c =", 1:4)
xyplot(do.call(ts.union, kdat), type = "h",
    scales = list(y = list(relation = "same")))
</code></pre>

<hr>
<h2 id='panel.voronoi'> Panel functions for level-coded irregular points </h2><span id='topic+panel.voronoi'></span><span id='topic+panel.levelplot.points'></span>

<h3>Description</h3>

<p>These panel functions for <code><a href="lattice.html#topic+levelplot">levelplot</a></code>
can represent irregular (x, y) points with a color covariate.
<code>panel.levelplot.points</code> simply draws color-coded points.
<code>panel.voronoi</code> uses the <span class="pkg">interp</span> or <span class="pkg">deldir</span> package to
calculate the spatial extension of a set of points in 2 dimensions.
This is known variously as a Voronoi mosaic, a Dirichlet tesselation,
or Thiessen polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.voronoi(x, y, z, subscripts = TRUE, at = pretty(z),
   points = TRUE, border = "transparent",
   na.rm = FALSE, win.expand = 0.07, use.tripack = FALSE,
   backend = c("interp", "deldir"),
   ...,
   col.regions = regions$col, alpha.regions = regions$alpha)

panel.levelplot.points(x, y, z, subscripts = TRUE, at = pretty(z),
   shrink, labels, label.style, contour, region,
   pch = 21, col.symbol = "#00000044",
   ...,
   col.regions = regions$col, fill = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.voronoi_+3A_x">x</code>, <code id="panel.voronoi_+3A_y">y</code>, <code id="panel.voronoi_+3A_z">z</code></td>
<td>
<p> an irregular set of points at locations (x, y) with
value z. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_subscripts">subscripts</code></td>
<td>
<p> integer vector indicating what subset of x, y and z
to draw. Typically passed by <code><a href="lattice.html#topic+levelplot">levelplot</a></code>. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_at">at</code>, <code id="panel.voronoi_+3A_col.regions">col.regions</code>, <code id="panel.voronoi_+3A_alpha.regions">alpha.regions</code></td>
<td>
<p> color scale definition;
see <code><a href="lattice.html#topic+panel.levelplot">panel.levelplot</a></code>. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_points">points</code></td>
<td>
<p> whether to draw the (x, y) points. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_border">border</code></td>
<td>
<p> color for polygon borders. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_na.rm">na.rm</code></td>
<td>
<p> if <code>TRUE</code>, points with missing <code>z</code> values will
be excluded from the calculation of polygons. If <code>FALSE</code>,
those polygons are calculated but are not drawn (i.e. are
transparent). </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_win.expand">win.expand</code></td>
<td>

<p>Defines the rectangular window bounding the polygons. This is a
factor by which to expand the range of the data. Set to 0 to limit
drawing at the furthest data point locations. Applies only for the
<code>"deldir"</code> backend (see Details).
</p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_use.tripack">use.tripack</code></td>
<td>
<p> Ignored, with a warning if a value is
specified. See Details. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_backend">backend</code></td>
<td>
<p> Character string specifying backend package to use to
calculate the Voronoi mosaic. Defaults to <code>"interp"</code>.</p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_...">...</code></td>
<td>
<p>Additional arguments; passed to
<code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code> if <code>points = TRUE</code>. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_pch">pch</code>, <code id="panel.voronoi_+3A_col.symbol">col.symbol</code></td>
<td>
<p> symbol and border color for points.
A filled symbol should be used, i.e. in the range 21-25. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_shrink">shrink</code></td>
<td>
<p> Ignored. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_labels">labels</code></td>
<td>
<p> Ignored. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_label.style">label.style</code></td>
<td>
<p> Ignored. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_contour">contour</code></td>
<td>
<p> Ignored. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_region">region</code></td>
<td>
<p> Ignored. </p>
</td></tr>
<tr><td><code id="panel.voronoi_+3A_fill">fill</code></td>
<td>
<p> Ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Up to version 0.6-29, latticeExtra used the <span class="pkg">deldir</span> package to
compute the Voronoi mosaic by default, while offering the choice of
using the faster but non-free ACM licensed implementation in the
<span class="pkg">tripack</span> package by setting <code>use.tripack = TRUE</code>. Later
versions use the FOSS replacements in <span class="pkg">interp</span> by default, and
deprecates the <code>use.tripack</code> argument. The <span class="pkg">deldir</span>
implementation, which allows polygons to be clipped to a rectangular
window (the <code>win.expand</code> argument), can still be used using
<code>backend = "deldir"</code>.
</p>


<h3>Author(s)</h3>

<p> Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+tileplot">tileplot</a></code>,
<code><a href="lattice.html#topic+panel.levelplot">panel.levelplot</a></code>,
<code><a href="deldir.html#topic+deldir">deldir</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## a variant of Figure 5.6 from Sarkar (2008)
## http://lmdvr.r-forge.r-project.org/figures/figures.html?chapter=05;figure=05_06

depth.ord &lt;- rev(order(quakes$depth))
quakes$Magnitude &lt;- equal.count(quakes$mag, 4)
quakes.ordered &lt;- quakes[depth.ord, ]

levelplot(depth ~ long + lat | Magnitude, data = quakes.ordered,
         panel = panel.levelplot.points, type = c("p", "g"),
         aspect = "iso", prepanel = prepanel.default.xyplot)

## a levelplot with jittered cells

xyz &lt;- expand.grid(x = 0:9, y = 0:9)
xyz[] &lt;- jitter(as.matrix(xyz))
xyz$z &lt;- with(xyz, sqrt((x - 5)^2 + (y - 5)^2))
levelplot(z ~ x * y, xyz, panel = panel.voronoi, points = FALSE)

## hexagonal cells

xyz$y &lt;- xyz$y + c(0, 0.5)
levelplot(z ~ x * y, xyz, panel = panel.voronoi, points = FALSE)
</code></pre>

<hr>
<h2 id='panel.xblocks'>
Plot contiguous blocks along x axis.
</h2><span id='topic+panel.xblocks'></span><span id='topic+panel.xblocks.default'></span><span id='topic+panel.xblocks.ts'></span><span id='topic+panel.xblocks.zoo'></span>

<h3>Description</h3>

<p>Plot contiguous blocks along x axis. A typical use would be to
highlight events or periods of missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.xblocks(x, ...)

## Default S3 method:
panel.xblocks(x, y, ..., col = NULL, border = NA, 
              height = unit(1, "npc"),
              block.y = unit(0, "npc"), vjust = 0,
              name = "xblocks", gaps = FALSE,
              last.step = median(diff(tail(x))))

## S3 method for class 'ts'
panel.xblocks(x, y = x, ...)
## S3 method for class 'zoo'
panel.xblocks(x, y = x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.xblocks_+3A_x">x</code>, <code id="panel.xblocks_+3A_y">y</code></td>
<td>

<p>In the default method, <code>x</code> gives the ordinates along the x axis and
must be in increasing order. <code>y</code> gives the color values to plot as
contiguous blocks. If <code>y</code> is numeric, data coverage is plotted,
by converting it into a logical (<code>!is.na(y)</code>). Finally, if
<code>y</code> is a function, it is applied to <code>x</code> (<code>time(x)</code> in
the time series methods). 
</p>
<p>If <code>y</code> has character (or factor) values, these are interpreted
as colors &ndash; and should therefore be color names or hex
codes. Missing values in <code>y</code> are not plotted.  The default
color is taken from the current theme:
<code>trellis.par.get("plot.line")$col</code>. If <code>col</code> is given,
this over-rides the block colors.
</p>
<p>The <code>ts</code> and <code>zoo</code> methods plot the <code>y</code> values
against the time index <code>time(x)</code>. 
</p>
</td></tr>
<tr><td><code id="panel.xblocks_+3A_...">...</code></td>
<td>

<p>In the default method, further arguments are graphical parameters
passed on to <code><a href="grid.html#topic+gpar">gpar</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.xblocks_+3A_col">col</code></td>
<td>

<p>if <code>col</code> is specified, it determines the colors of the blocks
defined by <code>y</code>. If multiple colors are specified they will be
repeated to cover the total number of blocks.
</p>
</td></tr>
<tr><td><code id="panel.xblocks_+3A_border">border</code></td>
<td>

<p>border color.
</p>
</td></tr>
<tr><td><code id="panel.xblocks_+3A_height">height</code></td>
<td>

<p>height of blocks, defaulting to the full panel height. Numeric
values are interpreted as native units.
</p>
</td></tr>
<tr><td><code id="panel.xblocks_+3A_block.y">block.y</code></td>
<td>

<p>y axis position of the blocks. Numeric values are interpreted as
native units.
</p>
</td></tr>
<tr><td><code id="panel.xblocks_+3A_vjust">vjust</code></td>
<td>

<p>vertical justification of the blocks relative to <code>block.y</code>. See
<code><a href="grid.html#topic+rectGrob">rectGrob</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.xblocks_+3A_name">name</code></td>
<td>

<p>a name for the grob (<span class="pkg">grid</span> object).
</p>
</td></tr>
<tr><td><code id="panel.xblocks_+3A_gaps">gaps</code></td>
<td>

<p>Deprecated.
Use <code>panel.xblocks(time(z), is.na(z))</code> instead.
</p>
</td></tr>
<tr><td><code id="panel.xblocks_+3A_last.step">last.step</code></td>
<td>

<p>width (in native units) of the final block. Defaults to the median of
the last 5 time steps (assuming steps are regular).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Blocks are drawn forward in &quot;time&quot; from the specified x locations,
up until the following value. Contiguous blocks are calculated using
<code><a href="base.html#topic+rle">rle</a></code>.
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot.ts">xyplot.ts</a></code>,
<code><a href="lattice.html#topic+panel.rect">panel.rect</a></code>,
<code><a href="grid.html#topic+grid.rect">grid.rect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example of highlighting peaks in a time series.
set.seed(0)
flow &lt;- ts(filter(rlnorm(200, mean = 1), 0.8, method = "r"))

## using an explicit panel function
xyplot(flow, panel = function(x, y, ...) {
  panel.xblocks(x, y &gt; mean(y), col = "lightgray")
  panel.xyplot(x, y, ...)
})
## using layers; this is the `ts` method because `&gt;` keeps it as ts.
xyplot(flow) +
  layer_(panel.xblocks(flow &gt; mean(flow), col = "lightgray"))

## Example of alternating colors, here showing calendar months
flowdates &lt;- as.Date("2000-01-01") + as.numeric(time(flow))
xyplot(flow ~ flowdates, type = "l") +
  layer_(panel.xblocks(x, months,
         col = c("lightgray", "#e6e6e6"), border = "darkgray"))

## highlight values above and below thresholds.
## blue, gray, red colors:
bgr &lt;- hcl(c(0, 0, 260), c = c(100, 0, 100), l = c(90, 90, 90))
dflow &lt;- cut(flow, c(0,15,30,Inf), labels = bgr)
xyplot(flow) + layer_(panel.xblocks(time(flow), dflow))

## Example of highlighting gaps (NAs) in time series.
## set up example data
z &lt;- ts(cbind(A = 0:5, B = c(6:7, NA, NA, 10:11), C = c(NA, 13:17)))

## show data coverage only (highlighting gaps)
xyplot(z, panel = panel.xblocks,
       scales = list(y = list(draw = FALSE)))

## draw gaps in darkgray
xyplot(z, type = c("p","s")) +
  layer_(panel.xblocks(x, is.na(y), col = "darkgray"))

## Example of overlaying blocks from a different series.
## Are US presidential approval ratings linked to sunspot activity?
## Set block height, default justification is along the bottom.
xyplot(presidents) + layer(panel.xblocks(sunspot.year &gt; 50, height = 2))
</code></pre>

<hr>
<h2 id='panel.xyarea'>
Plot series as filled polygons.
</h2><span id='topic+panel.xyarea'></span><span id='topic+panel.xyarea.default'></span><span id='topic+panel.xyarea.ts'></span><span id='topic+panel.xyarea.zoo'></span><span id='topic+panel.qqmath.xyarea'></span>

<h3>Description</h3>

<p>Plot series as filled polygons connected at given origin level (on y axis).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.xyarea(x, ...)

## Default S3 method:
panel.xyarea(x, y, groups = NULL, origin = NULL, horizontal = FALSE,
             col, col.line, border, lty, lwd, alpha, ...,
             fill, panel.groups = panel.xyarea)

## S3 method for class 'ts'
panel.xyarea(x, y = x, ...)
## S3 method for class 'zoo'
panel.xyarea(x, y = x, ...)

panel.qqmath.xyarea(x, y = NULL, f.value = NULL, distribution = qnorm,
                    qtype = 7, groups = NULL, ..., tails.n = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.xyarea_+3A_x">x</code>, <code id="panel.xyarea_+3A_y">y</code></td>
<td>

<p>data vectors.
</p>
</td></tr>
<tr><td><code id="panel.xyarea_+3A_groups">groups</code></td>
<td>

<p>a factor defining groups.
</p>
</td></tr>
<tr><td><code id="panel.xyarea_+3A_origin">origin</code></td>
<td>

<p>level on y axis to connect the start and end of the series.
If <code>NULL</code>, the polygon is filled to the bottom of the panel.
It is flipped if <code>horizontal = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="panel.xyarea_+3A_horizontal">horizontal</code></td>
<td>

<p>if this is set to <code>TRUE</code>, then the origin is a level on the x
axis, rather than the default which is on the y axis. This is the
opposite of what you might expect, but is for consistency with
<code>panel.xyplot</code>. 
</p>
</td></tr>
<tr><td><code id="panel.xyarea_+3A_col">col</code>, <code id="panel.xyarea_+3A_col.line">col.line</code>, <code id="panel.xyarea_+3A_border">border</code>, <code id="panel.xyarea_+3A_lty">lty</code>, <code id="panel.xyarea_+3A_lwd">lwd</code>, <code id="panel.xyarea_+3A_alpha">alpha</code></td>
<td>

<p>graphical parameters taken from
<code>trellis.par.get("plot.polygon")</code> or
<code>trellis.par.get("superpose.polygon")</code> (when groups defined).
<code>col.line</code> overrides <code>col</code>.
</p>
</td></tr>
<tr><td><code id="panel.xyarea_+3A_...">...</code></td>
<td>

<p>further arguments passed on to <code><a href="lattice.html#topic+panel.polygon">panel.polygon</a></code>.
For <code>panel.qqmath.xyarea</code>, passed to <code>panel.xyarea</code>.
</p>
</td></tr>
<tr><td><code id="panel.xyarea_+3A_fill">fill</code></td>
<td>

<p>ignored; use <code>col</code> instead.
</p>
</td></tr>
<tr><td><code id="panel.xyarea_+3A_panel.groups">panel.groups</code></td>
<td>

<p>used in <code><a href="lattice.html#topic+panel.superpose">panel.superpose</a></code>.
</p>
</td></tr>
<tr><td><code id="panel.xyarea_+3A_f.value">f.value</code>, <code id="panel.xyarea_+3A_distribution">distribution</code>, <code id="panel.xyarea_+3A_qtype">qtype</code>, <code id="panel.xyarea_+3A_tails.n">tails.n</code></td>
<td>

<p>as in <code><a href="lattice.html#topic+panel.qqmath">panel.qqmath</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>none yet.
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>,
<code><a href="lattice.html#topic+panel.polygon">panel.polygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyplot(sunspot.year, panel = panel.xyarea, origin = 0,
  aspect = "xy", cut = list(n = 3, overlap = 0))

## two series superposed: one filled, one as a line.
xyplot(ts.union(data = sunspot.year, lag10 = lag(sunspot.year, 10)),
  aspect = "xy", cut = list(n = 3, overlap = 0),
  superpose = TRUE,
  panel = panel.superpose,
  panel.groups = function(..., group.number) {
    if (group.number == 1)
      panel.xyarea(...) else panel.xyplot(...)
  }, border = NA, 
  par.settings = simpleTheme(col = c("grey", "black"), lwd = c(5,2)))

## missing values are handled by splitting the series
tmp &lt;- window(sunspot.year, start = 1900)
tmp[c(1:2, 50:60)] &lt;- NA
xyplot(tmp, panel = panel.xyarea, origin = 0)

set.seed(0)
qqmath(~ data, make.groups(baseline = rnorm(100),
                           other = rnorm(100) * 2 - 0.5),
  groups = which, distribution = qunif,
  panel = panel.qqmath.xyarea, xlim = 0:1,
  auto.key = list(points = FALSE, rectangles = TRUE),
  par.settings = simpleTheme(col = c("blue", "green"),
                             alpha = 0.5))
</code></pre>

<hr>
<h2 id='panel.xyimage'>
Scatter plots using emoji-like images
</h2><span id='topic+panel.xyimage'></span>

<h3>Description</h3>

<p>Panel function that create scatter plots with emoji-like images for
plotting character. Images can be local files or URLs. Only PNG and
JPEG images are currently supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.xyimage(x, y, 
              subscripts,
              groups = NULL,
              pch = NULL,
              cex = 1,
              ...,
              grid = FALSE, abline = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.xyimage_+3A_x">x</code>, <code id="panel.xyimage_+3A_y">y</code></td>
<td>

<p>Data vectors to be plotted.
</p>
</td></tr>
<tr><td><code id="panel.xyimage_+3A_subscripts">subscripts</code></td>
<td>

<p>An integer vector of subscripts giving indices of the <code>x</code> and
<code>y</code> values in the original data source.  See the corresponding
entry in <code><a href="lattice.html#topic+xyplot">xyplot</a></code> for details.
</p>
</td></tr>
<tr><td><code id="panel.xyimage_+3A_groups">groups</code></td>
<td>

<p>A factor defining groups.
</p>
</td></tr>
<tr><td><code id="panel.xyimage_+3A_pch">pch</code></td>
<td>

<p>A character vector giving path(s) or URL(s) of PNG or JPEG files. If 
<code>groups</code> is specified, there should be one value for each
level, otherwise this should have length 1. Recycled as necessary.
</p>
</td></tr>
<tr><td><code id="panel.xyimage_+3A_cex">cex</code></td>
<td>

<p>A numeric multiplier for the size of the symbols. As with
<code>pch</code>, this can be a vector corresponding to levels of
<code>groups</code>.
</p>
</td></tr>
<tr><td><code id="panel.xyimage_+3A_...">...</code></td>
<td>

<p>Further arguments are accepted but ignored.
</p>
</td></tr>
<tr><td><code id="panel.xyimage_+3A_grid">grid</code></td>
<td>

<p>A logical flag, character string, or list specifying whether and how
a background grid should be drawn. See <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>
for details.
</p>
</td></tr>
<tr><td><code id="panel.xyimage_+3A_abline">abline</code></td>
<td>

<p>A numeric vector or list, specifying arguments arguments for
<code><a href="lattice.html#topic+panel.abline">panel.abline</a></code>, which is called with those
arguments. See <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>
for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The image sources given by <code>pch</code> are downloaded if necessary and
read in every time the panel function is called. If the same images
are to be used in multiple panels, it may be more efficient to
download them once and provide the file paths rather than provide
URLs.
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
alive &lt;- "https://twemoji.maxcdn.com/72x72/1f60a.png"
dead &lt;- "https://twemoji.maxcdn.com/72x72/1f480.png"

dotplot(Titanic,
        scales = list(x = "free"),
        between = list(x = 1),
        panel = panel.xyimage,
        pch = c(dead, alive), grid = "h", 
        main = "Survival on the Titanic",
        xlab = "Number of persons")

## End(Not run)
</code></pre>

<hr>
<h2 id='postdoc'> Reasons for Taking First Postdoctoral Appointment </h2><span id='topic+postdoc'></span>

<h3>Description</h3>

<p>Reasons for Taking First Postdoctoral Appointment, by Field of
Doctrate, 1997
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(postdoc)</code></pre>


<h3>Format</h3>

<p>The data set is avaliable as a two-way table of counts.  
</p>


<h3>Source</h3>

<p>Survey of Doctorate Recipients, 1997
</p>


<h3>References</h3>

<p>Enhancing the Postdoctoral Experience for Scientists and Engineers:
A Guide for Postdoctoral Scholars, Advisers, Institutions, Funding
Organizations, and Disciplinary Societies
</p>
<p><a href="https://www.nap.edu/catalog/9831/enhancing-the-postdoctoral-experience-for-scientists-and-engineers-a-guide">https://www.nap.edu/catalog/9831/enhancing-the-postdoctoral-experience-for-scientists-and-engineers-a-guide</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(postdoc)
library(lattice)
barchart(prop.table(postdoc, margin = 1),
         auto.key = TRUE, xlab = "Proportion")
</code></pre>

<hr>
<h2 id='resizePanels'> Resize panels to match data scales </h2><span id='topic+resizePanels'></span>

<h3>Description</h3>

<p>Modify a <code>"trellis"</code> object so that when
plotted, the panels have the specified relative width and height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
resizePanels(x, h = 1, w = 1)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resizePanels_+3A_x">x</code></td>
<td>
<p> An object of class <code>"trellis"</code>. </p>
</td></tr>
<tr><td><code id="resizePanels_+3A_h">h</code></td>
<td>
<p> numeric vector specifying panel heights</p>
</td></tr>
<tr><td><code id="resizePanels_+3A_w">w</code></td>
<td>
<p> numeric vector specifying of panel widths</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>resizePanels</code> modifies a <code>"trellis"</code> object so that when
plotted, the panels have the specified relative width and height; this
is only interesting when <code>h</code> or <code>w</code> are vectors with unequal
entries.  <code>resizePanels</code> can be called with no arguments, in
which case the currently plotted <code>"trellis"</code> object (if any) is
used for <code>x</code>, and a suitable <code>h</code> or <code>w</code> (based on the
current panel layout) is chosen so that sizes are relative to the
current panel ranges in the native coordinate system.  This is only
interesting when <code>scales="free"</code>; the resulting object, when
plotted again, will have varying panel sizes but the same number of
data units per inch in all panels.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>; essentially the same as <code>x</code>,
but with certain properties modified.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar </p>


<h3>See Also</h3>

 <p><code><a href="lattice.html#topic+Lattice">Lattice</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
state &lt;- data.frame(state.x77, state.region, state.name)
state$state.name &lt;-
    with(state, reorder(reorder(state.name, Frost),
                        as.numeric(state.region)))
dpfrost &lt;-
    dotplot(state.name ~ Frost | reorder(state.region, Frost),
            data = state, layout = c(1, 4),
            scales = list(y = list(relation = "free")))

## approximate
resizePanels(dpfrost,
             h = with(state, table(reorder(state.region, Frost))))

## exact (including boundary padding)
resizePanels()

</code></pre>

<hr>
<h2 id='rootogram'>Trellis Displays of Tukey's Hanging Rootograms</h2><span id='topic+rootogram'></span><span id='topic+rootogram.formula'></span><span id='topic+panel.rootogram'></span><span id='topic+prepanel.rootogram'></span>

<h3>Description</h3>

<p>Displays hanging rootograms. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rootogram(x, ...)

## S3 method for class 'formula'
rootogram(x, data = parent.frame(),
          ylab = expression(sqrt(P(X == x))),
          prepanel = prepanel.rootogram,
          panel = panel.rootogram,
          ...,
          probability = TRUE)

prepanel.rootogram(x, y = table(x),
                   dfun = NULL,
                   transformation = sqrt,
                   hang = TRUE,
                   probability = TRUE,
                   ...)

panel.rootogram(x, y = table(x),
                dfun = NULL,
                col = plot.line$col,
                lty = plot.line$lty,
                lwd = plot.line$lwd,
                alpha = plot.line$alpha,
                transformation = sqrt,
                hang = TRUE,
                probability = TRUE,
                type = "l", pch = 16,
                ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rootogram_+3A_x">x</code>, <code id="rootogram_+3A_y">y</code></td>
<td>
<p> For <code>rootogram</code>, <code>x</code> is the object on which
method dispatch is carried out.  For the <code>"formula"</code> method,
<code>x</code> is a formula describing the form of conditioning plot.  The
formula can be either of the form <code>~x</code> or of the form
<code>y~x</code>.  In the first case, <code>x</code> is assumed to be a vector
of raw observations, and an observed frequency distribution is
computed from it.  In the second case, <code>x</code> is assumed to be
unique values and <code>y</code> the corresponding frequencies.  In either
case, further conditioning variables are allowed.
</p>
<p>A similar interpretation holds for <code>x</code> and <code>y</code> in
<code>prepanel.rootogram</code> and <code>panel.rootogram</code>.
</p>
<p>Note that the data are assumed to arise from a discrete distribution
with some probability mass function.  See details below.
</p>
</td></tr>
<tr><td><code id="rootogram_+3A_data">data</code></td>
<td>
<p> For the <code>"formula"</code> method, a data frame containing
values for any variables in the formula, as well as those in
<code>groups</code> and <code>subset</code> if applicable (<code>groups</code> is
currently ignored by the default panel function).  By default the
environment where the function was called from is used.  </p>
</td></tr>
<tr><td><code id="rootogram_+3A_dfun">dfun</code></td>
<td>
<p> a probability mass function, to be evaluated at unique x
values </p>
</td></tr>
<tr><td><code id="rootogram_+3A_prepanel">prepanel</code>, <code id="rootogram_+3A_panel">panel</code></td>
<td>
<p> panel and prepanel function used to create the
display.  </p>
</td></tr>
<tr><td><code id="rootogram_+3A_ylab">ylab</code></td>
<td>
<p> the y-axis label; typically a character string or an
expression. </p>
</td></tr>
<tr><td><code id="rootogram_+3A_col">col</code>, <code id="rootogram_+3A_lty">lty</code>, <code id="rootogram_+3A_lwd">lwd</code>, <code id="rootogram_+3A_alpha">alpha</code></td>
<td>
<p> graphical parameters </p>
</td></tr>
<tr><td><code id="rootogram_+3A_transformation">transformation</code></td>
<td>
<p> a vectorized function.  Relative frequencies
(observed) and theoretical probabilities (<code>dfun</code>) are
transformed by this function before being plotted. </p>
</td></tr>
<tr><td><code id="rootogram_+3A_hang">hang</code></td>
<td>
<p>logical, whether lines representing observed relative
freuqncies should &ldquo;hang&rdquo; from the curve representing the
theoretical probabilities. </p>
</td></tr>
<tr><td><code id="rootogram_+3A_probability">probability</code></td>
<td>
<p> A logical flag, controlling whether the y-values
are to be standardized to be probabilities by dividing by their sum.
</p>
</td></tr>
<tr><td><code id="rootogram_+3A_type">type</code></td>
<td>
<p> A character vector consisting of one or both of
<code>"p"</code> and <code>"l"</code>. If <code>"p"</code> is included, the evaluated
values of <code>dfun</code> will be denoted by points, and if <code>"l"</code>
is included, they will be joined by lines. </p>
</td></tr>
<tr><td><code id="rootogram_+3A_pch">pch</code></td>
<td>
<p> The plotting character to be used for the <code>"p"</code>
type. </p>
</td></tr>
<tr><td><code id="rootogram_+3A_...">...</code></td>
<td>
<p> extra arguments, passed on as appropriate.  Standard
lattice arguments as well as arguments to <code>panel.rootogram</code>
can be supplied directly in the high level <code>rootogram</code> call.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements Tukey's hanging rootograms.  As implemented,
<code>rootogram</code> assumes that the data arise from a discrete
distribution (either supplied in raw form, when <code>y</code> is
unspecified, or in terms of the frequency distribution) with some
unknown probability mass function (p.m.f.).  The purpose of the plot
is to check whether the supplied theoretical p.m.f. <code>dfun</code> is a
reasonable fit for the data.
</p>
<p>It is reasonable to consider rootograms for continuous data by
discretizing it (similar to a histogram), but this must be done by the
user before calling <code>rootogram</code>.  An example is given below.
</p>
<p>Also consider the <code>rootogram</code> function in the <code>vcd</code> package,
especially if the number of unique values is small.
</p>


<h3>Value</h3>

<p><code>rootogram</code> produces an object of class <code>"trellis"</code>.  The
<code>update</code> method can be used to update components of the object and
the <code>print</code> method (usually called by default) will plot it on an
appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan.sarkar@gmail.com">deepayan.sarkar@gmail.com</a></p>


<h3>References</h3>

<p>John W. Tukey (1972) Some graphic and semi-graphic displays. In
T. A. Bancroft (Ed) <em>Statistical Papers in Honor of George
W. Snedecor</em>, pp. 293&ndash;316.  Available online at
<a href="https://www.edwardtufte.com/tufte/tukey">https://www.edwardtufte.com/tufte/tukey</a>
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lattice)

x &lt;- rpois(1000, lambda = 50)

p &lt;- rootogram(~x, dfun = function(x) dpois(x, lambda = 50))
p

lambdav &lt;- c(30, 40, 50, 60, 70)

update(p[rep(1, length(lambdav))],
       aspect = "xy",
       panel = function(x, ...) {
           panel.rootogram(x,
                           dfun = function(x)
                           dpois(x, lambda = lambdav[panel.number()]))
       })


lambdav &lt;- c(46, 48, 50, 52, 54)

update(p[rep(1, length(lambdav))],
       aspect = "xy",
       prepanel = function(x, ...) {
           tmp &lt;-
               lapply(lambdav,
                      function(lambda) {
                          prepanel.rootogram(x,
                                             dfun = function(x)
                                             dpois(x, lambda = lambda))
                      })
           list(xlim = range(sapply(tmp, "[[", "xlim")),
                ylim = range(sapply(tmp, "[[", "ylim")),
                dx = do.call("c", lapply(tmp, "[[", "dx")),
                dy = do.call("c", lapply(tmp, "[[", "dy")))
       },
       panel = function(x, ...) {
           panel.rootogram(x,
                           dfun = function(x)
                           dpois(x, lambda = lambdav[panel.number()]))
           grid::grid.text(bquote(Poisson(lambda == .(foo)),
                                  where = list(foo = lambdav[panel.number()])),
                           y = 0.15,
                           gp = grid::gpar(cex = 1.5))
       },
       xlab = "",
       sub = "Random sample from Poisson(50)")


## Example using continuous data

xnorm &lt;- rnorm(1000)

## 'discretize' by binning and replacing data by bin midpoints

h &lt;- hist(xnorm, plot = FALSE)

## Option 1: Assume bin probabilities proportional to dnorm()

norm.factor &lt;- sum(dnorm(h$mids, mean(xnorm), sd(xnorm)))

rootogram(counts ~ mids, data = h,
          dfun = function(x) {
              dnorm(x, mean(xnorm), sd(xnorm)) / norm.factor
          })

## Option 2: Compute probabilities explicitly using pnorm()

pdisc &lt;- diff(pnorm(h$breaks, mean = mean(xnorm), sd = sd(xnorm)))
pdisc &lt;- pdisc / sum(pdisc)

rootogram(counts ~ mids, data = h,
          dfun = function(x) {
              f &lt;- factor(x, levels = h$mids)
              pdisc[f]
          })

</code></pre>

<hr>
<h2 id='scale.components'> Custom lattice axis scales </h2><span id='topic+scale.components'></span><span id='topic+xscale.components.logpower'></span><span id='topic+yscale.components.logpower'></span><span id='topic+xscale.components.fractions'></span><span id='topic+yscale.components.fractions'></span><span id='topic+xscale.components.log10ticks'></span><span id='topic+yscale.components.log10ticks'></span><span id='topic+xscale.components.log'></span><span id='topic+yscale.components.log'></span><span id='topic+xscale.components.log10.3'></span><span id='topic+yscale.components.log10.3'></span><span id='topic+xscale.components.subticks'></span><span id='topic+yscale.components.subticks'></span>

<h3>Description</h3>

<p>Convenience functions for drawing axes with various non-default tick
positions and labels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xscale.components.logpower(lim, ...)
yscale.components.logpower(lim, ...)

xscale.components.fractions(lim, logsc = FALSE, ...)
yscale.components.fractions(lim, logsc = FALSE, ...)

xscale.components.log10ticks(lim, logsc = FALSE, at = NULL, ...)
yscale.components.log10ticks(lim, logsc = FALSE, at = NULL, ...)

xscale.components.log(lim, logsc = FALSE, at = NULL, loc = NULL, ...)
yscale.components.log(lim, logsc = FALSE, at = NULL, loc = NULL, ...)

xscale.components.log10.3(lim, logsc = FALSE, at = NULL, ...)
yscale.components.log10.3(lim, logsc = FALSE, at = NULL, ...)

xscale.components.subticks(lim, ..., n = 5, n2 = n * 5, min.n2 = n + 5)
yscale.components.subticks(lim, ..., n = 5, n2 = n * 5, min.n2 = n + 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale.components_+3A_lim">lim</code></td>
<td>
<p> scale limits. </p>
</td></tr>
<tr><td><code id="scale.components_+3A_...">...</code></td>
<td>

<p>passed on to <code><a href="lattice.html#topic+xscale.components.default">xscale.components.default</a></code> or
<code>yscale.components.default</code>. 
</p>
</td></tr>
<tr><td><code id="scale.components_+3A_logsc">logsc</code></td>
<td>

<p><code>log</code> base, typically specified in the <code>scales</code>
argument to a high-level lattice plot.
</p>
</td></tr>
<tr><td><code id="scale.components_+3A_at">at</code></td>
<td>

<p>this is ignored unless it is <code>NULL</code>, in which case nothing is
drawn. 
</p>
</td></tr>
<tr><td><code id="scale.components_+3A_loc">loc</code></td>
<td>

<p>Ignored if <code>NULL</code>.  Otherwise, vector of values between 1 and
9 that form the template for tick mark locations after being scaled
appropriately.  For example, <code>loc = c(1, 3)</code> leads to tick
marks at <code>c(0.1, 0.3, 1, 3, 10, 30)</code> and so on.
</p>
</td></tr>
<tr><td><code id="scale.components_+3A_n">n</code></td>
<td>

<p>desired number of intervals between major axis ticks (passed to
<code><a href="base.html#topic+pretty">pretty</a></code>.
</p>
</td></tr>
<tr><td><code id="scale.components_+3A_n2">n2</code>, <code id="scale.components_+3A_min.n2">min.n2</code></td>
<td>

<p>desired, and minimum, number of intervals between minor axis ticks
(passed to <code><a href="base.html#topic+pretty">pretty</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are intended to be passed to the
<code>xscale.components</code> or <code>yscale.components</code> arguments of
high-level lattice plots. See <code><a href="lattice.html#topic+xscale.components.default">xscale.components.default</a></code>.
</p>
<p><code>xscale.components.logpower</code> draws tickmarks at the same
locations as the default, but labels them more smartly using
superscripts for the power (using expressions).
</p>
<p><code>xscale.components.fractions</code> labels the tickmarks as fractions.
</p>
<p><code>xscale.components.log10ticks</code> puts major tick marks at powers of
10, and minor tickmarks in between.
</p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) &ldquo;Lattice: Multivariate Data
Visualization with R&rdquo;, Springer.  ISBN: 978-0-387-75968-5
<a href="http://lmdvr.r-forge.r-project.org/figures/figures.html?chapter=08;figure=08_04">http://lmdvr.r-forge.r-project.org/figures/figures.html?chapter=08;figure=08_04</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyplot((1:200)/20 ~ (1:200)/20, type = c("p", "g"),
  scales = list(x = list(log = 2), y = list(log = 10)),
  xscale.components = xscale.components.fractions,
  yscale.components = yscale.components.log10ticks)

xyplot((1:200)/20 ~ (1:200)/20, type = c("p", "g"),
  scales = list(x = list(log = 2), y = list(log = 10)),
  xscale.components = xscale.components.logpower,
  yscale.components = yscale.components.log10.3)

dd &lt;- as.Date("2000-01-01") + 0:365
xyplot(0:365 ~ dd, type = c("p", "g"),
  xscale.components = xscale.components.subticks,
  yscale.components = yscale.components.subticks)
</code></pre>

<hr>
<h2 id='SeatacWeather'> Daily Rainfall and Temperature at the Seattle-Tacoma Airport </h2><span id='topic+SeatacWeather'></span>

<h3>Description</h3>

<p>Daily Rainfall and Temperature at the Seattle-Tacoma Airport between 
January through March of 2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SeatacWeather)</code></pre>


<h3>Format</h3>

<p>A data frame with 90 observations on the following 14 variables.
</p>

<dl>
<dt><code>month</code></dt><dd><p>a factor with levels <code>January</code>,
<code>February</code>, and <code>March</code></p>
</dd>
<dt><code>day</code></dt><dd><p> day of the month </p>
</dd>
<dt><code>year</code></dt><dd><p> year, all 2007 </p>
</dd>
<dt><code>max.temp</code></dt><dd><p> maximum temperature (Fahrenheit) </p>
</dd>
<dt><code>record.max</code></dt><dd><p> record maximum temperature </p>
</dd>
<dt><code>normal.max</code></dt><dd><p> normal maximum temperature </p>
</dd>
<dt><code>min.temp</code></dt><dd><p> minimum temperature </p>
</dd>
<dt><code>record.min</code></dt><dd><p> record minimum temperature </p>
</dd>
<dt><code>normal.min</code></dt><dd><p> normal minimum temperature </p>
</dd>
<dt><code>precip</code></dt><dd><p> precipitation (inches) </p>
</dd>
<dt><code>record.precip</code></dt><dd><p> record precipitation </p>
</dd>
<dt><code>normal.precip</code></dt><dd><p> normal precipitation </p>
</dd>
<dt><code>time.max</code></dt><dd><p> time of maximum temperature </p>
</dd>
<dt><code>time.min</code></dt><dd><p> time of minimum temperature </p>
</dd>
</dl>



<h3>Details</h3>

<p>The time of minimum and maximum temperatures should be interpreted as
follows: the least two significant digits denote minutes (out of 60)
and the next two significant digits denote hout (out of 24).
</p>


<h3>Source</h3>

<p><a href="https://www.atmos.washington.edu/cgi-bin/list_climate.cgi?clisea">https://www.atmos.washington.edu/cgi-bin/list_climate.cgi?clisea</a>
</p>

<hr>
<h2 id='segplot'> Plot segments using the Trellis framework </h2><span id='topic+segplot'></span><span id='topic+segplot.formula'></span>

<h3>Description</h3>

<p> This function can be used to systematically draw segments
using a formula interface to produce Trellis displays using the
lattice package.  Segments can be drawn either as lines or bars, and
can be color coded by the value of a covariate, with a suitable
legend.</p>


<h3>Usage</h3>

<pre><code class='language-R'>segplot(x, data, ...)

## S3 method for class 'formula'
segplot(x, data,
        level = NULL, centers = NULL,
        prepanel = prepanel.segplot,
        panel = panel.segplot,
        xlab = NULL, ylab = NULL,
        horizontal = TRUE,
        ...,
        at, cuts = 30, colorkey = !is.null(level))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segplot_+3A_x">x</code></td>
<td>
<p> Argument on which argument dispatch is carried out.  For the
<code>"formula"</code> method, a formula of the form <code>y ~ x1 + x2</code>
(with further conditioning variables appended if necessary).  The
terms in the formula must all be vectors of the same length.  Each
element causes a line segment or rectangle to be drawn, with the
vertical location determined by <code>y</code> and horizontal endpoints
determined by <code>x1</code> and <code>x2</code>.  </p>
</td></tr>
<tr><td><code id="segplot_+3A_data">data</code></td>
<td>
<p> An optional data frame, list or environment where
variables in the formula, as well as <code>level</code>, will be
evaluated.
</p>
</td></tr>
<tr><td><code id="segplot_+3A_level">level</code></td>
<td>
<p> An optional covariate that determines color coding of
the segments</p>
</td></tr>
<tr><td><code id="segplot_+3A_centers">centers</code></td>
<td>
<p> optional vector of &lsquo;centers&rsquo; of the segments.
If specified, points will be plotted at these <code>y</code>-locations.  </p>
</td></tr>
<tr><td><code id="segplot_+3A_prepanel">prepanel</code></td>
<td>
<p> function determining range of the data rectangle from
data to be used in a panel. </p>
</td></tr>
<tr><td><code id="segplot_+3A_panel">panel</code></td>
<td>
<p> function to render the graphic given the data.  This is
the function that actually implements the display.  </p>
</td></tr>
<tr><td><code id="segplot_+3A_xlab">xlab</code>, <code id="segplot_+3A_ylab">ylab</code></td>
<td>
<p> Labels for the axes.  By default both are
missing. </p>
</td></tr>
<tr><td><code id="segplot_+3A_horizontal">horizontal</code></td>
<td>
<p> logical, whether the segments are to be drawn
horizontally (the default) or vertically.  This essentially swaps
the role of the x- and y-axes in each panel. </p>
</td></tr>
<tr><td><code id="segplot_+3A_...">...</code></td>
<td>
<p> further arguments.  Arguments to <code>levelplot</code> as
well as to the default panel function <code><a href="#topic+panel.segplot">panel.segplot</a></code>
can be supplied directly to <code>segplot</code>. </p>
</td></tr>
<tr><td><code id="segplot_+3A_colorkey">colorkey</code></td>
<td>
<p> logical indicating whether a legend showing
association of segment colors to values of <code>level</code> should be
shown, or a list to control details of such a color key.  See
details below. </p>
</td></tr>
<tr><td><code id="segplot_+3A_at">at</code>, <code id="segplot_+3A_cuts">cuts</code></td>
<td>
 <p><code>at</code> specifies the values of <code>level</code> where
the color code changes.  If <code>at</code> is missing, it defaults to
<code>cuts</code> equispaced locations spanning the range of <code>levels</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>levelplot</code> function from the lattice package is used to
internally to implement this function.  In particular, the colorkey
mechanism is used as it is, and documentation for
<code><a href="lattice.html#topic+levelplot">levelplot</a></code> should be consulted to learn how to
fine tune it.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="lattice.html#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="lattice.html#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Note</h3>

<p> Currently only horizontal segments are supported.  Vertical
segments can be obtained by modifying the prepanel and panel functions
suitably. </p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan.sarkar@r-project.org">deepayan.sarkar@r-project.org</a> </p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+Lattice">Lattice</a></code>,
<code><a href="#topic+panel.segplot">panel.segplot</a></code>,
<code><a href="lattice.html#topic+levelplot">levelplot</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
segplot(factor(1:10) ~ rnorm(10) + rnorm(10), level = runif(10))

data(USCancerRates)

segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
        data = subset(USCancerRates, state == "Washington"))

segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
        data = subset(USCancerRates, state == "Washington"),
        draw.bands = FALSE, centers = rate.male)

segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
        data = subset(USCancerRates, state == "Washington"),
        level = rate.female, col.regions = terrain.colors)

segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,
        data = subset(USCancerRates, state == "Washington"),
        draw.bands = FALSE, centers = rate.male, 
        segments.fun = panel.arrows, ends = "both", 
        angle = 90, length = 1, unit = "mm")

</code></pre>

<hr>
<h2 id='theEconomist.theme'>
Generate plots with style like The Economist.
</h2><span id='topic+theEconomist.theme'></span><span id='topic+theEconomist.opts'></span><span id='topic+theEconomist.axis'></span><span id='topic+asTheEconomist'></span>

<h3>Description</h3>

<p>Uses colors, drawing styles, axis settings, etc, to produce plots
inspired by those in The Economist magazine.
(<a href="https://www.economist.com/">https://www.economist.com/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theEconomist.theme(win.fontfamily = NULL,
    with.bg = FALSE, box = "black", ...)

theEconomist.opts()

asTheEconomist(x, ...,
    type = "l",
    ylab = expression(NULL),
    xlab = expression(NULL),
    par.settings =
      theEconomist.theme(with.bg = with.bg, box = "transparent"),
    with.bg = FALSE,
    par.strip.text = list(font = 2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theEconomist.theme_+3A_win.fontfamily">win.fontfamily</code></td>
<td>

<p>on Windows systems, sets the font by name.
</p>
</td></tr>
<tr><td><code id="theEconomist.theme_+3A_with.bg">with.bg</code></td>
<td>

<p>if <code>TRUE</code>, uses a light blue background and a few other
corresponding changes; otherwise white.
</p>
</td></tr>
<tr><td><code id="theEconomist.theme_+3A_box">box</code></td>
<td>

<p>color for panel boxes, strip outlines, and axis ticks.
</p>
</td></tr>
<tr><td><code id="theEconomist.theme_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code><a href="lattice.html#topic+simpleTheme">simpleTheme</a></code>
and used to modify the theme.
</p>
</td></tr>
<tr><td><code id="theEconomist.theme_+3A_x">x</code></td>
<td>

<p>a <code>trellis</code> object, i.e. the result of a high-level plot
function in the Lattice framework.
</p>
</td></tr>
<tr><td><code id="theEconomist.theme_+3A_type">type</code></td>
<td>

<p>plot type, relevant for <code>xyplot</code>s, see <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="theEconomist.theme_+3A_ylab">ylab</code>, <code id="theEconomist.theme_+3A_xlab">xlab</code></td>
<td>

<p>axis labels, blank by default.
</p>
</td></tr>
<tr><td><code id="theEconomist.theme_+3A_par.settings">par.settings</code></td>
<td>

<p>style settings, defaulting to <code>theEconomist.theme</code>.
</p>
</td></tr>
<tr><td><code id="theEconomist.theme_+3A_par.strip.text">par.strip.text</code></td>
<td>

<p>see <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can just use <code>par.settings = theEconomist.theme()</code>, which
gives you some colors and styles, but it does not do the
grid lines or axis settings.
</p>


<h3>Author(s)</h3>

<p>Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a>
</p>


<h3>References</h3>

<p><a href="https://www.economist.com/displayStory.cfm?story_id=15065782">https://www.economist.com/displayStory.cfm?story_id=15065782</a>
</p>
<p><a href="https://www.economist.com/displayStory.cfm?story_id=14941181">https://www.economist.com/displayStory.cfm?story_id=14941181</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+custom.theme">custom.theme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyplot(window(sunspot.year, start = 1900),
  main = "Sunspot cycles", sub = "Number per year",
  par.settings = theEconomist.theme(box = "transparent"),
  lattice.options = theEconomist.opts())

asTheEconomist(xyplot(window(sunspot.year, start = 1900),
  main = "Sunspot cycles", sub = "Number per year"))

trellis.last.object() +
  layer_(panel.xblocks(x, x &gt;= 1980, col = "#6CCFF6", alpha = .5)) +
  layer(panel.text(1988, 180, "Forecast", font = 3, pos = 2))

## set as defaults -- remember to set back when finished.
opar &lt;- trellis.par.get()
trellis.par.set(theEconomist.theme(box = "transparent"))
oopt &lt;- lattice.options(theEconomist.opts())

barchart(Titanic[,,,"No"], main = "Titanic deaths", layout = 1:2,
    sub = "by sex and class", auto.key = list(columns = 2),
    scales = list(y = list(alternating = 2)))

asTheEconomist(
  dotplot(VADeaths, main = "Death Rates in Virginia (1940)",
    auto.key = list(corner = c(.9,0.1))),
  type = "b", with.bg = TRUE)

dotplot(VADeaths, auto.key = TRUE, type = "b",
  par.settings = theEconomist.theme(with.bg = TRUE))

asTheEconomist(
  densityplot(~ height, groups = voice.part, data = singer,
    subset = grep("1", voice.part), plot.points = FALSE)) +
glayer(d &lt;- density(x), i &lt;- which.max(d$y),
  ltext(d$x[i], d$y[i], paste("Group", group.number), pos = 3))

## reset
trellis.par.set(opar)
lattice.options(oopt)
</code></pre>

<hr>
<h2 id='tileplot'> Plot a spatial mosaic from irregular 2D points </h2><span id='topic+tileplot'></span>

<h3>Description</h3>

<p>Represents an irregular set of (x, y) points with a color covariate.
Polygons are drawn enclosing the area closest to each point.
This is known variously as a Voronoi mosaic, a Dirichlet tesselation,
or Thiessen polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tileplot(x, data = NULL, aspect = "iso",
         prepanel = "prepanel.default.xyplot",
         panel = "panel.voronoi", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tileplot_+3A_x">x</code>, <code id="tileplot_+3A_data">data</code></td>
<td>
<p> formula and data as in
<code><a href="lattice.html#topic+levelplot">levelplot</a></code>, except that it expects irregularly
spaced points rather than a regular grid. </p>
</td></tr>
<tr><td><code id="tileplot_+3A_aspect">aspect</code></td>
<td>
<p> aspect ratio: &quot;iso&quot; is recommended as it reproduces the
distances used in the triangulation calculations. </p>
</td></tr>
<tr><td><code id="tileplot_+3A_panel">panel</code>, <code id="tileplot_+3A_prepanel">prepanel</code></td>
<td>
<p> see <code><a href="lattice.html#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="tileplot_+3A_...">...</code></td>
<td>
<p> further arguments to the panel function, which defaults to
<code><a href="#topic+panel.voronoi">panel.voronoi</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+panel.voronoi">panel.voronoi</a></code> for further options and details.
</p>


<h3>Author(s)</h3>

<p> Felix Andrews <a href="mailto:felix@nfrac.org">felix@nfrac.org</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+panel.voronoi">panel.voronoi</a></code>, <code><a href="lattice.html#topic+levelplot">levelplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz &lt;- data.frame(x = rnorm(100), y = rnorm(100), z = rnorm(100))
tileplot(z ~ x * y, xyz)

## Alternative backend using 'deldir' package
## Not run: 
tileplot(z ~ x * y, xyz, backend = "deldir")

## End(Not run)

## showing rectangular window boundary
tileplot(z ~ x * y, xyz, xlim = c(-2, 4), ylim = c(-2, 4))

## insert some missing values
xyz$z[1:10] &lt;- NA
## the default na.rm = FALSE shows missing polygons
tileplot(z ~ x * y, xyz, border = "black",
  col.regions = grey.colors(100),
  pch = ifelse(is.na(xyz$z), 4, 21),
  panel = function(...) {
    panel.fill("hotpink")
    panel.voronoi(...)
  })
## use na.rm = TRUE to ignore points with missing values
update(trellis.last.object(), na.rm = TRUE)

## a quick and dirty approximation to US state boundaries
tmp &lt;- state.center
tmp$Income &lt;- state.x77[,"Income"]
tileplot(Income ~ x * y, tmp, border = "black",
  panel = function(x, y, ...) {
    panel.voronoi(x, y, ..., points = FALSE)
    panel.text(x, y, state.abb, cex = 0.6)
  })
</code></pre>

<hr>
<h2 id='USAge'> US national population estimates </h2><span id='topic+USAge'></span><span id='topic+USAge.table'></span><span id='topic+USAge.df'></span>

<h3>Description</h3>

<p>US national population estimates by age and sex from 1900 to 1979.
The data is available both as a (3-dimensional) table and a data
frame.  The second form omits the 75+ age group to keep age numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USAge.table)
data(USAge.df)
</code></pre>


<h3>Format</h3>

<p><code>USAge.table</code> is a 3-dimensional array with dimensions 
</p>

<table>
<tr>
 <td style="text-align: right;">
    No </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Levels</td>
</tr>
<tr>
 <td style="text-align: right;">
    1 </td><td style="text-align: left;"> Age </td><td style="text-align: left;"> 0, 1, 2, ..., 74, 75+</td>
</tr>
<tr>
 <td style="text-align: right;">
    2 </td><td style="text-align: left;"> Sex </td><td style="text-align: left;"> Male, Female</td>
</tr>
<tr>
 <td style="text-align: right;">
    3 </td><td style="text-align: left;"> Year </td><td style="text-align: left;"> 1900, 1901, ..., 1979 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p>Cells contain raw counts of estimated population.
</p>
<p><code>USAge.df</code> is a data frame with 12000 observations on the
following 4 variables.
</p>

<dl>
<dt><code>Age</code></dt><dd><p>a numeric vector, giving age in years</p>
</dd>
<dt><code>Sex</code></dt><dd><p>a factor with levels <code>Male</code> <code>Female</code></p>
</dd>
<dt><code>Year</code></dt><dd><p>a numeric vector, giving year</p>
</dd>
<dt><code>Population</code></dt><dd><p>a numeric vector, giving population in
millions</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data for 1900-1929 are rounded to thousands.  The data for
1900-1939 exclude the Armed Forces overseas and the population
residing in Alaska and Hawaii.  The data for 1940-1949 represent the
resident population plus Armed Forces overseas, but exclude the
population residing in Alaska and Hawaii.  The data for 1950-1979
represent the resident population plus Armed Forces overseas, and
also include the population residing in Alaska and Hawaii.
</p>


<h3>Source</h3>

<p>U.S. Census Bureau website: <a href="https://www.census.gov/">https://www.census.gov/</a>
</p>


<p>The data were available as individual files for each year, with
varying levels for the margins.  The preprocessing steps used to
reduce the data to the form given here are described in the scripts
directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USAge.df)
head(USAge.df)

## Figure 10.7 from Sarkar (2008)
xyplot(Population ~ Age | factor(Year), USAge.df,
       groups = Sex, type = c("l", "g"),
       auto.key = list(points = FALSE, lines = TRUE, columns = 2),
       aspect = "xy", ylab = "Population (millions)",
       subset = Year %in% seq(1905, 1975, by = 10))
</code></pre>

<hr>
<h2 id='USCancerRates'> Rate of Death Due to Cancer in US Counties </h2><span id='topic+USCancerRates'></span>

<h3>Description</h3>

<p>This data set records the annual rates of death (1999-2003) due to
cancer by sex in US counties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USCancerRates)</code></pre>


<h3>Format</h3>

<p>A data frame with 3041 observations on the following 8 variables.
</p>

<dl>
<dt><code>rate.male</code></dt><dd><p>a numeric vector, giving rate of death per
100,000 due to cancer among males</p>
</dd>
<dt><code>LCL95.male</code></dt><dd><p>a 95% lower confidence limit for <code>rate.male</code> </p>
</dd>
<dt><code>UCL95.male</code></dt><dd><p>a 95% upper confidence limit for <code>rate.male</code> </p>
</dd>
<dt><code>rate.female</code></dt><dd><p>a numeric vector, giving rate of death per
100,000 due to cancer among females</p>
</dd>
<dt><code>LCL95.female</code></dt><dd><p>a 95% lower confidence limit for <code>rate.female</code></p>
</dd>
<dt><code>UCL95.female</code></dt><dd><p>a 95% upper confidence limit for <code>rate.female</code></p>
</dd>
<dt><code>state</code></dt><dd><p> a factor with levels giving name of US state </p>
</dd>
<dt><code>county</code></dt><dd><p> a character vector giving county names, in a
format similar to that used for county map boundaries in the
<code>maps</code> package. </p>
</dd>
</dl>



<h3>Details</h3>

<p>See the scripts directory for details of data preprocessing steps.
</p>
<p>From the website: Death data provided by the National Vital Statistics
System public use data file.  Death rates calculated by the National
Cancer Institute using SEER*Stat. Death rates are age-adjusted to the
2000 US standard population
[<a href="https://seer.cancer.gov/stdpopulations/stdpop.19ages.html">https://seer.cancer.gov/stdpopulations/stdpop.19ages.html</a>].
Population counts for denominators are based on Census populations as
modified by NCI.
</p>


<h3>Source</h3>

<p><a href="https://statecancerprofiles.cancer.gov/">https://statecancerprofiles.cancer.gov/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USCancerRates)
</code></pre>

<hr>
<h2 id='useOuterStrips'> Put Strips on the Boundary of a Lattice Display </h2><span id='topic+useOuterStrips'></span>

<h3>Description</h3>

<p>Try to update a <code>"trellis"</code> object so that strips are only
shown on the top and left boundaries when printed, instead of in every
panel as is usual.  This is only meaningful when there are exactly two
conditioning variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
useOuterStrips(x,
               strip = strip.default,
               strip.left = strip.custom(horizontal = FALSE),
               strip.lines = 1,
               strip.left.lines = strip.lines)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="useOuterStrips_+3A_x">x</code></td>
<td>
<p> An object of class <code>"trellis"</code>. </p>
</td></tr>
<tr><td><code id="useOuterStrips_+3A_strip">strip</code>, <code id="useOuterStrips_+3A_strip.left">strip.left</code></td>
<td>
<p> A function, character string or logical that
would be appropriate <code>strip</code> and <code>strip.left</code> arguments
respectively in a high level lattice function call (see
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>) </p>
</td></tr>
<tr><td><code id="useOuterStrips_+3A_strip.lines">strip.lines</code>, <code id="useOuterStrips_+3A_strip.left.lines">strip.left.lines</code></td>
<td>
<p> height of strips in number of
lines; helpful for multi-line text or mathematical annotation in
strips. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>useOuterStrips</code> modifies a <code>"trellis"</code> object with
<code>length(dim(x)) == 2</code> so that when plotted, strips are only shown
on the top and left boundaries of the panel layout, rather than on top
of every panel, as is the usual behaviour.
</p>
<p>If the original <code>"trellis"</code> object <code>x</code> includes non-default
<code>strip</code> and <code>strip.left</code> arguments, they will be ignored.
To provide customized strip behaviour, specify the custom strip
functions directly as arguments to <code>useOuterStrips</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>; essentially the same as <code>x</code>,
but with certain properties modified.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar </p>


<h3>See Also</h3>

 <p><code><a href="lattice.html#topic+Lattice">Lattice</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lattice)

mtcars$HP &lt;- equal.count(mtcars$hp)

useOuterStrips(xyplot(mpg ~ disp | HP + factor(cyl), mtcars))

useOuterStrips(xyplot(mpg ~ disp | factor(cyl) + HP, mtcars),
               strip.left = FALSE,
               strip = strip.custom(style = 4))

</code></pre>

<hr>
<h2 id='xyplot.stl'> Display stl fits with Lattice </h2><span id='topic+xyplot.stl'></span>

<h3>Description</h3>

<p>Display <code><a href="stats.html#topic+stl">stl</a></code> decomposition (seasonal, trend and irregular
components using loess) with Lattice, like the base graphics function
<code><a href="stats.html#topic+plot.stl">plot.stl</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stl'
xyplot(x, data = NULL,
       outer = TRUE,
       layout = c(1, 4),
       strip = FALSE,
       strip.left = TRUE,
       as.table = TRUE,
       ylab = "",
       between = list(y = 0.5),
       panel =
       function(..., type) {
           if (packet.number() == 4) type &lt;- "h"
           panel.xyplot(..., type = type)
       },
       ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xyplot.stl_+3A_x">x</code></td>
<td>
<p> an <code><a href="stats.html#topic+stl">stl</a></code> object. </p>
</td></tr>
<tr><td><code id="xyplot.stl_+3A_data">data</code></td>
<td>
<p> ignored. </p>
</td></tr>
<tr><td><code id="xyplot.stl_+3A_outer">outer</code>, <code id="xyplot.stl_+3A_layout">layout</code>, <code id="xyplot.stl_+3A_strip">strip</code>, <code id="xyplot.stl_+3A_strip.left">strip.left</code></td>
<td>

<p>passed to <code><a href="lattice.html#topic+xyplot.ts">xyplot.ts</a></code>.
</p>
</td></tr>
<tr><td><code id="xyplot.stl_+3A_as.table">as.table</code>, <code id="xyplot.stl_+3A_ylab">ylab</code>, <code id="xyplot.stl_+3A_between">between</code>, <code id="xyplot.stl_+3A_panel">panel</code>, <code id="xyplot.stl_+3A_...">...</code></td>
<td>

<p>passed to <code><a href="lattice.html#topic+xyplot.ts">xyplot.ts</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unless <code>strip.left</code> is passed in explicitly, a custom strip will
be drawn, where shaded bars are comparable across panels (representing
the same data range).
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="lattice.html#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="lattice.html#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan.sarkar@r-project.org">deepayan.sarkar@r-project.org</a> </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stl">stl</a></code>,
<code><a href="lattice.html#topic+xyplot.ts">xyplot.ts</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from ?stl
xyplot(stl(log(co2), s.window=21),
       main = "STL decomposition of CO2 data")

## alternative display
data(biocAccess)
xyplot(stl(ts(biocAccess$counts[1:(24 * 30)], frequency = 24), "periodic"),
       strip.left = "strip.default")
resizePanels()

## two different spans
xyplot(stl(nottem, s.window = 4)) +
as.layer(xyplot(stl(nottem, s.window = "periodic")), style = 2)

## components superposed
xyplot(stl(nottem, s.window = 4), superpose=TRUE,
  screens = list(data = "trend", trend = "trend", "residuals"),
  strip.left = TRUE, layout = c(1,2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
