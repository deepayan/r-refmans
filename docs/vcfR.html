<!DOCTYPE html><html lang="en"><head><title>Help for package vcfR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vcfR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vcfR-package'><p>vcfR: Manipulate and Visualize VCF Data</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#AD_frequency'><p>AD_frequency</p></a></li>
<li><a href='#addID'><p>Populate the ID column of VCF data</p></a></li>
<li><a href='#check_keys'><p>Check that INFO and FORMAT keys are unique</p></a></li>
<li><a href='#chromo_plot'><p>Plot chromR object</p></a></li>
<li><a href='#chromR+20functions'><p>chromR_functions</p></a></li>
<li><a href='#chromR_example'><p>Example chromR object.</p></a></li>
<li><a href='#chromR-class'><p>chromR class</p></a></li>
<li><a href='#chromR2vcfR'><p>Convert chrom objects to vcfR objects</p></a></li>
<li><a href='#Convert+20to+20tidy+20data+20frames'><p>Convert vcfR objects to tidy data frames</p></a></li>
<li><a href='#create.chromR'><p>Create chromR object</p></a></li>
<li><a href='#dr.plot+20elements'><p>dr.plot elements</p></a></li>
<li><a href='#extract.gt'><p>Extract elements from vcfR objects</p></a></li>
<li><a href='#Format+20conversion'><p>Convert vcfR objects to other formats</p></a></li>
<li><a href='#freq_peak'><p>freq_peak</p></a></li>
<li><a href='#freq_peak_plot'><p>Plot freq_peak object</p></a></li>
<li><a href='#genetic_diff'><p>Genetic differentiation</p></a></li>
<li><a href='#Genotype+20matrix+20functions'><p>Genotype matrix functions</p></a></li>
<li><a href='#getFIX'><p>Get elements from the fixed region of a VCF file</p></a></li>
<li><a href='#gt2popsum'><p>Population genetics summaries</p></a></li>
<li><a href='#heatmap.bp'><p>Heatmap with barplots</p></a></li>
<li><a href='#INFO2df'><p>Reformat INFO data as a data.frame</p></a></li>
<li><a href='#is_het'><p>Query genotypes for heterozygotes</p></a></li>
<li><a href='#maf'><p>Minor allele frequency</p></a></li>
<li><a href='#masplit'><p>masplit</p></a></li>
<li><a href='#ordisample'><p>Ordinate a sample's data</p></a></li>
<li><a href='#pairwise_genetic_diff'><p>Pairwise genetic differentiation across populations</p></a></li>
<li><a href='#peak_to_ploid'><p>Convert allele balance peaks to ploidy</p></a></li>
<li><a href='#Process+20chromR+20objects'><p>Process chromR object</p></a></li>
<li><a href='#query.gt'><p>Query the gt slot</p></a></li>
<li><a href='#queryMETA'><p>Query the META section of VCF data</p></a></li>
<li><a href='#Ranking'><p>Ranking variants within windows</p></a></li>
<li><a href='#rePOS'><p>Create non-overlapping positions (POS) for VCF data</p></a></li>
<li><a href='#show+2CchromR-method'><p>chromR-method</p></a></li>
<li><a href='#show+2CvcfR-method'><p>show</p></a></li>
<li><a href='#VCF+20input+20and+20output'><p>Read and write vcf format files</p></a></li>
<li><a href='#vcfR_example'><p>Example data for vcfR.</p></a></li>
<li><a href='#vcfR_test'><p>Test data for vcfR.</p></a></li>
<li><a href='#vcfR-class'><p>vcfR class</p></a></li>
<li><a href='#vcfR2DNAbin'><p>Convert vcfR to DNAbin</p></a></li>
<li><a href='#vcfR2hapmap'><p>Convert a vcfR object to hapmap</p></a></li>
<li><a href='#vcfR2migrate'><p>Convert a vcfR object to MigrateN input file</p></a></li>
<li><a href='#vep'><p>Example data from the Variant Effect Predictor (VEP).</p></a></li>
<li><a href='#Windowing'><p>Create window summaries of data</p></a></li>
<li><a href='#write.fasta'><p>Create fasta format output</p></a></li>
<li><a href='#write.var.info'><p>Write summary tables from chromR objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Manipulate and Visualize VCF Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates easy manipulation of variant call format (VCF) data.
    Functions are provided to rapidly read from and write to VCF files. Once
    VCF data is read into R a parser function extracts matrices of data. This
    information can then be used for quality control or other purposes. Additional
    functions provide visualization of genomic data. Once processing is complete
    data may be written to a VCF file (*.vcf.gz). It also may be converted into
    other popular R objects (e.g., genlight, DNAbin). VcfR provides a link between
    VCF data and familiar R software.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.15.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian J. Knaus &lt;briank.lists@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/knausb/vcfR">https://github.com/knausb/vcfR</a>,
<a href="https://knausb.github.io/vcfR_documentation/">https://knausb.github.io/vcfR_documentation/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, dplyr, graphics, grDevices, magrittr, memuse, methods,
pinfsc50, Rcpp, stats, stringr, tibble, utils, vegan,
viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adegenet, ggplot2, knitr, poppr, reshape2, rmarkdown, scales,
testthat, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 15:46:41 UTC; knausb</td>
</tr>
<tr>
<td>Author:</td>
<td>Brian J. Knaus <a href="https://orcid.org/0000-0003-1665-4343"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Niklaus J. Grunwald
    <a href="https://orcid.org/0000-0003-1656-7602"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Eric C. Anderson <a href="https://orcid.org/0000-0003-1326-0840"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  David J. Winter [ctb],
  Zhian N. Kamvar <a href="https://orcid.org/0000-0003-1458-7108"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Javier F. Tabima <a href="https://orcid.org/0000-0002-3603-2691"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 00:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='vcfR-package'>vcfR: Manipulate and Visualize VCF Data</h2><span id='topic+vcfR'></span><span id='topic+vcfR-package'></span>

<h3>Description</h3>

<p>Facilitates easy manipulation of variant call format (VCF) data. Functions are provided to rapidly read from and write to VCF files. Once VCF data is read into R a parser function extracts matrices of data. This information can then be used for quality control or other purposes. Additional functions provide visualization of genomic data. Once processing is complete data may be written to a VCF file (*.vcf.gz). It also may be converted into other popular R objects (e.g., genlight, DNAbin). VcfR provides a link between VCF data and familiar R software.
</p>
<p>vcfR provides a suite of tools for input and output of variant call format (VCF) files, manipulation of their content and visualization.
</p>


<h3>Details</h3>

<p><strong>File input and output</strong> is facilitated with the functions <code>read.vcfR</code> and <code>write.vcf</code>.
Input of vcf format data results in an S4 <code><a href="#topic+vcfR-class">vcfR-class</a></code> object.
Objects of class vcfR can be manipulated with <a href="#topic+vcfR-method">vcfR-method</a> and <code>extract.gt</code>.
Contents of the vcfR object can be visualized with the <code><a href="base.html#topic+plot">plot</a></code> method.
More complex visualizations can be created using a series of functions.
See <code>vignette(topic="sequence_coverage")</code> for an example.
Once manipulations are complete the object may be written to a *.vcf.gz format file using <code>write.vcf</code> or exported to objects supported by other R packages with <code>vcfR2genind</code> or <code>vcfR2loci</code>.
</p>
<p>More complex visualization can be accomplished by converting a vcfR object to a <code><a href="#topic+chromR-class">chromR-class</a></code> object.
An example exists on the <code>create.chromR</code> man page.
</p>
<p>A <strong>complete list of functions</strong> can be displayed with: library(help = vcfR).
</p>
<p><strong>Vignettes</strong> (documentation) can be listed with: <code>browseVignettes('vcfR')</code>.
</p>
<p>Several example <strong>datasets</strong> are included in vcfR.
<strong>vcfR_test</strong> comes from the VCF specification and provides a vcfR object with a diversity of examples in a small dataset.
<strong>vcfR_example</strong> is a subset of the pinfsc50 dataset that includes VCF, GFF and FASTA data for moderate sized testing.
The <a href="https://cran.r-project.org/package=pinfsc50">pinfsc50</a> dataset is available as a separate package and includes VCF, GFF and FASTA data for testing and benchmarking.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Brian J. Knaus <a href="mailto:briank.lists@gmail.com">briank.lists@gmail.com</a> (<a href="https://orcid.org/0000-0003-1665-4343">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Niklaus J. Grunwald <a href="mailto:grunwaln@science.oregonstate.edu">grunwaln@science.oregonstate.edu</a> (<a href="https://orcid.org/0000-0003-1656-7602">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Eric C. Anderson <a href="mailto:eric.anderson@noaa.gov">eric.anderson@noaa.gov</a> (<a href="https://orcid.org/0000-0003-1326-0840">ORCID</a>) [contributor]
</p>
</li>
<li><p> David J. Winter <a href="mailto:david.winter@gmail.com">david.winter@gmail.com</a> [contributor]
</p>
</li>
<li><p> Zhian N. Kamvar <a href="mailto:zkamvar@gmail.com">zkamvar@gmail.com</a> (<a href="https://orcid.org/0000-0003-1458-7108">ORCID</a>) [contributor]
</p>
</li>
<li><p> Javier F. Tabima <a href="mailto:caifaz01@gmail.com">caifaz01@gmail.com</a> (<a href="https://orcid.org/0000-0002-3603-2691">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/knausb/vcfR">https://github.com/knausb/vcfR</a>
</p>
</li>
<li> <p><a href="https://knausb.github.io/vcfR_documentation/">https://knausb.github.io/vcfR_documentation/</a>
</p>
</li></ul>

<p>More documentation for vcfR can be found at the <a href="https://knausb.github.io/vcfR_documentation/">vcfR documentation</a> website.
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='AD_frequency'>AD_frequency</h2><span id='topic+AD_frequency'></span>

<h3>Description</h3>

<p>Create allele frequencies from matrices of allelic depths (AD)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AD_frequency(ad, delim = ",", allele = 1L, sum_type = 0L, decreasing = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AD_frequency_+3A_ad">ad</code></td>
<td>
<p>a matrix of allele depths (e.g., &quot;7,2&quot;)</p>
</td></tr>
<tr><td><code id="AD_frequency_+3A_delim">delim</code></td>
<td>
<p>character that delimits values</p>
</td></tr>
<tr><td><code id="AD_frequency_+3A_allele">allele</code></td>
<td>
<p>which (1-based) allele to report frequency for</p>
</td></tr>
<tr><td><code id="AD_frequency_+3A_sum_type">sum_type</code></td>
<td>
<p>type of sum to calculate, see details</p>
</td></tr>
<tr><td><code id="AD_frequency_+3A_decreasing">decreasing</code></td>
<td>
<p>should the values be sorted decreasing (1) or increasing (0)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Files containing VCF data frequently include data on allelic depth (e.g., AD).
This is the number of times each allele has been sequenced.
Our naive assumption for diploids is that these alleles should be observed at a frequency of 1 or zero for homozygous positions and near 0.5 for heterozygous positions.
Deviations from this expectation may indicate allelic imbalance or ploidy differences.
This function is intended to facilitate the exploration of allele frequencies for all positions in a sample.
</p>
<p>The alleles are sorted by their frequency within the function.
The user can then specify is the would like to calculate the frequency of the most frequent allele (allele = 1), the second most frequent allele (allele = 2) and so one.
If an allele is requested that does not exist it should result in NA for that position and sample.
</p>
<p>There are two methods to calculate a sum for the denominator of the frequency.
When sum_type = 0 the alleles are sorted decendingly and the first two allele counts are used for the sum.
This may be useful when a state of diploidy may be known to be appropriate and other alleles may be interpreted as erroneous.
When sum_type = 1 a sum is taken over all the observed alleles for a variant.
</p>


<h3>Value</h3>

<p>A numeric matrix of frequencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x1 &lt;- round(rnorm(n=9, mean=10, sd=2))
x2 &lt;- round(rnorm(n=9, mean=20, sd=2))
ad &lt;- matrix(paste(x1, x2, sep=","), nrow=3, ncol=3)
colnames(ad) &lt;- paste('Sample', 1:3, sep="_")
rownames(ad) &lt;- paste('Variant', 1:3, sep="_")
ad[1,1] &lt;- "9,23,12"
AD_frequency(ad=ad)


</code></pre>

<hr>
<h2 id='addID'>Populate the ID column of VCF data</h2><span id='topic+addID'></span>

<h3>Description</h3>

<p>Populate the ID column of VCF data by concatenating the chromosome, position and optionally an index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addID(x, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addID_+3A_x">x</code></td>
<td>
<p>an object of class vcfR or chromR.</p>
</td></tr>
<tr><td><code id="addID_+3A_sep">sep</code></td>
<td>
<p>a character string to separate the terms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variant callers typically leave the ID column empty in VCF data.
However, the VCF data may potentially include variants with IDs as well as variants without.
This function populates the missing elements by concatenating the chromosome and position.
When this concatenation results in non-unique names, an index is added to force uniqueness.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_test)
head(vcfR_test)
vcfR_test &lt;- addID(vcfR_test)
head(vcfR_test)


</code></pre>

<hr>
<h2 id='check_keys'>Check that INFO and FORMAT keys are unique</h2><span id='topic+check_keys'></span>

<h3>Description</h3>

<p>The INFO and FORMAT columns contain information in key-value pairs.
If for some reason a key is not unique it will create issues in retrieving this information.
This function checks the keys defined in the meta section to make sure they are unique.
Note that it does not actually check the INFO and FORMAT columns, just their definitions in the meta section.
This is because each variant can have different information in their INFO and META cells.
Checking these on large files will therefore come with a performance cost.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_keys(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_keys_+3A_x">x</code></td>
<td>
<p>an oblect of class vcfR</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>queryMETA()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_test)
check_keys(vcfR_test)
queryMETA(vcfR_test)
queryMETA(vcfR_test, element = 'DP')
# Note that DP occurs as unique in INFO and FORMAT but they may be different.


</code></pre>

<hr>
<h2 id='chromo_plot'>Plot chromR object</h2><span id='topic+chromo_plot'></span><span id='topic+chromo'></span><span id='topic+chromoqc'></span>

<h3>Description</h3>

<p>plot chromR objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chromo(
  chrom,
  boxp = TRUE,
  dp.alpha = TRUE,
  chrom.s = 1,
  chrom.e = NULL,
  drlist1 = NULL,
  drlist2 = NULL,
  drlist3 = NULL,
  ...
)

chromoqc(chrom, boxp = TRUE, dp.alpha = 255, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chromo_plot_+3A_chrom">chrom</code></td>
<td>
<p>an object of class chrom.</p>
</td></tr>
<tr><td><code id="chromo_plot_+3A_boxp">boxp</code></td>
<td>
<p>logical specifying whether marginal boxplots should be plotted [T/F].</p>
</td></tr>
<tr><td><code id="chromo_plot_+3A_dp.alpha">dp.alpha</code></td>
<td>
<p>degree of transparency applied to points in dot plots [0-255].</p>
</td></tr>
<tr><td><code id="chromo_plot_+3A_chrom.s">chrom.s</code></td>
<td>
<p>start position for the chromosome. (Deprecated. use xlim)</p>
</td></tr>
<tr><td><code id="chromo_plot_+3A_chrom.e">chrom.e</code></td>
<td>
<p>end position for the chromosome. (Deprecated. use xlim)</p>
</td></tr>
<tr><td><code id="chromo_plot_+3A_drlist1">drlist1</code></td>
<td>
<p>a named list containing elements to create a drplot</p>
</td></tr>
<tr><td><code id="chromo_plot_+3A_drlist2">drlist2</code></td>
<td>
<p>a named list containing elements to create a drplot</p>
</td></tr>
<tr><td><code id="chromo_plot_+3A_drlist3">drlist3</code></td>
<td>
<p>a named list containing elements to create a drplot</p>
</td></tr>
<tr><td><code id="chromo_plot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each <strong>drlist</strong> parameter is a list containing elements necessarry to plot a dr.plot.
This list should contain up to seven elements named title, dmat, rlist, dcol, rcol, rbcol and bwcol.
These elements are documented in the dr.plot page where they are presented as individual parameters.
The one exception is bwcol which is a vector of colors for the marginal box and whisker plot.
This is provided so that different colors may be used in the dot plot and the box and whisker plot.
For example, transparency may be desired in the dot plot but not the box and whisker plot.
When one (or more) of these elements is omitted an attempt to use default values is made.
</p>


<h3>Value</h3>

<p>Returns an invisible NULL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dr.plot">dr.plot</a></code>
</p>

<hr>
<h2 id='chromR+20functions'>chromR_functions</h2><span id='topic+chromR+20functions'></span><span id='topic+masker'></span><span id='topic+variant.table'></span><span id='topic+win.table'></span>

<h3>Description</h3>

<p>Functions which act on chromR objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>masker(
  x,
  min_QUAL = 1,
  min_DP = 1,
  max_DP = 10000,
  min_MQ = 20,
  max_MQ = 100,
  preserve = FALSE,
  ...
)

variant.table(x)

win.table(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chromR+2B20functions_+3A_x">x</code></td>
<td>
<p>object of class chromR</p>
</td></tr>
<tr><td><code id="chromR+2B20functions_+3A_min_qual">min_QUAL</code></td>
<td>
<p>minimum variant quality</p>
</td></tr>
<tr><td><code id="chromR+2B20functions_+3A_min_dp">min_DP</code></td>
<td>
<p>minimum cumulative depth</p>
</td></tr>
<tr><td><code id="chromR+2B20functions_+3A_max_dp">max_DP</code></td>
<td>
<p>maximum cumulative depth</p>
</td></tr>
<tr><td><code id="chromR+2B20functions_+3A_min_mq">min_MQ</code></td>
<td>
<p>minimum mapping quality</p>
</td></tr>
<tr><td><code id="chromR+2B20functions_+3A_max_mq">max_MQ</code></td>
<td>
<p>maximum mapping quality</p>
</td></tr>
<tr><td><code id="chromR+2B20functions_+3A_preserve">preserve</code></td>
<td>
<p>a logical indicating whether or not to preserve the state of
the current mask field. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="chromR+2B20functions_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <strong>masker</strong> creates a logical vector that determines which variants are masked.
By masking certain variants, instead of deleting them, it preserves the dimensions of the data structure until a change needs to be committed.
Variants can be masked based on the value of the QUAL column of the vcf object.
Experience seems to show that this value is either at its maximum (999) or a rather low value.
The maximum and minimum sequence depth can also be used (mindp and maxdp).
The default is to mask all variants with depths of less than the 0.25 quantile and greater than the 0.75 quantile (these are also known as the lower and upper quartile).
The minimum and maximum mapping qualities (minmq, maxmq) can also be used.
</p>
<p>This vector is stored in the var.info$mask slot of a chromR object.
</p>
<p>The function <strong>variant.table</strong> creates a data.frame containing information about variants.
</p>
<p>The funciton <strong>win.table</strong>
</p>

<hr>
<h2 id='chromR_example'>Example chromR object.</h2><span id='topic+chromR_example'></span><span id='topic+chrom'></span>

<h3>Description</h3>

<p>An example chromR object containing parts of the *Phytophthora infestans* genome.
</p>


<h3>Format</h3>

<p>A chromR object
</p>


<h3>Details</h3>

<p>This data is a subset of the pinfsc50 dataset.
It has been subset to positions between 500 and 600 kbp.
The coordinate systems of the vcf and gff file have been altered by subtracting 500,000.
This results in a 100 kbp section of supercontig_1.50 that has positional data ranging from 1 to 100 kbp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chromR_example)




</code></pre>

<hr>
<h2 id='chromR-class'>chromR class</h2><span id='topic+chromR-class'></span>

<h3>Description</h3>

<p>A class for representing chromosomes (or supercontigs, contigs, scaffolds, etc.).
</p>


<h3>Details</h3>

<p>Defines a class for chromosomal or contig data.
This
</p>
<p>This object has a number of slots.
</p>

<ul>
<li> <p><strong>name</strong> name of the object (character)
</p>
</li>
<li> <p><strong>len</strong> length of the sequence (integer)
</p>
</li>
<li> <p><strong>window_size</strong> window size for windowing analyses (integer)
</p>
</li>
<li> <p><strong>seq</strong> object of class ape::DNAbin
</p>
</li>
<li> <p><strong>vcf</strong> object of class vcfR
</p>
</li>
<li> <p><strong>ann</strong> annotation data in a gff-like data.frame
</p>
</li>
<li> <p><strong>var.info</strong> a data.frame containing information on variants
</p>
</li>
<li> <p><strong>win.info</strong> a data.frame containing information on windows
</p>
</li>
<li> <p><strong>seq.info</strong> a list containing information on the sequence
</p>
</li></ul>

<p>The <strong>seq</strong> slot contains an object of class ape::DNAbin.
A DNAbin object is typically either a matrix or list of DNAbin objects.
The matrix form appears to be better behaved than the list form.
Because of this behavior this slot should be the matrix form.
When this slot is not populated it is of class &quot;NULL&quot; instead of &quot;DNAbin&quot;.
Note that characters need to be lower case when inserted into an object of class DNAbin.
The function <code><a href="base.html#topic+tolower">tolower</a></code> can facilitate this.
</p>
<p>The <strong>vcf</strong> slot is an object of class vcfR <code><a href="#topic+vcfR-class">vcfR-class</a></code>.
</p>
<p>The <strong>ann</strong> slot is a data.frame containing <a href="https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md">gff format</a> data.
When this slot is not populated it has nrows equal to zero.
</p>
<p>The <strong>var.info</strong> slot contains a data.frame containing information about variants.
Every row of this data.frame is a variant.
Columns will typically contain the chromosome name, the position of the variant (POS), the mask as well as any other per variant information.
</p>
<p>The <strong>win.info</strong> slot contains a data.frame containing information about windows.
For example, window, start, end, length, A, C, G, T, N, other, variants and genic fields are stored here.
</p>
<p>The <strong>seq.info</strong> slot is a list containing two matrices.
The first matrix describes rectangles for called nucleotides and the second describes rectangles for 'N' calls.
Within each matrix, the first column indicates the start position and the second column indicates the end position of each rectangle.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcfR-class">vcfR-class</a></code>, <code><a href="ape.html#topic+DNAbin">DNAbin</a></code>,
<a href="https://github.com/samtools/hts-specs">VCF specification</a>
<a href="https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md">gff3 format</a>
</p>

<hr>
<h2 id='chromR2vcfR'>Convert chrom objects to vcfR objects</h2><span id='topic+chromR2vcfR'></span>

<h3>Description</h3>

<p>Convert chrom objects to vcfR objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chromR2vcfR(x, use.mask = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chromR2vcfR_+3A_x">x</code></td>
<td>
<p>Object of class chrom</p>
</td></tr>
<tr><td><code id="chromR2vcfR_+3A_use.mask">use.mask</code></td>
<td>
<p>Logical, determine if mask from chrom object should be used to subset vcf data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chrom object is subset and recast as a vcfR object.  When use.mask is set 
to TRUE (the default), the object is subset to only the variants (rows) indicated
to include by the mask.  When use.mask is set to FALSE, all variants (rows) from 
the chrom object are included in the new vcfR object.
</p>


<h3>Value</h3>

<p>Returns an object of class vcfR.
</p>

<hr>
<h2 id='Convert+20to+20tidy+20data+20frames'>Convert vcfR objects to tidy data frames</h2><span id='topic+Convert+20to+20tidy+20data+20frames'></span><span id='topic+vcfR2tidy'></span><span id='topic+extract_info_tidy'></span><span id='topic+extract_gt_tidy'></span><span id='topic+vcf_field_names'></span>

<h3>Description</h3>

<p>Convert the information in a vcfR object to a long-format data frame
suitable for analysis or use with Hadley Wickham's packages, 
<a href="https://cran.r-project.org/package=dplyr">dplyr</a>,
<a href="https://cran.r-project.org/package=tidyr">tidyr</a>, and
<a href="https://cran.r-project.org/package=ggplot2">ggplot2</a>.
These packages have been
optimized for operation on large data frames, and, though they can bog down
with very large data sets, they provide a good framework for handling and filtering
large variant data sets.  For some background
on the benefits of such &quot;tidy&quot; data frames, see 
<a href="https://doi.org/10.18637/jss.v059.i10">doi:10.18637/jss.v059.i10</a>.
</p>
<p>For some filtering operations, such as those where one wants to filter genotypes
upon GT fields in combination with INFO fields, or more complex 
operations in which one wants to filter
loci based upon the number of individuals having greater than a certain quality score,
it will be advantageous to put all the information into a long format data frame 
and use <code>dplyr</code> to perform the operations.  Additionally, a long data format is
required for using <code>ggplot2</code>.  These functions convert vcfR objects to long format
data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcfR2tidy(
  x,
  info_only = FALSE,
  single_frame = FALSE,
  toss_INFO_column = TRUE,
  ...
)

extract_info_tidy(x, info_fields = NULL, info_types = TRUE, info_sep = ";")

extract_gt_tidy(
  x,
  format_fields = NULL,
  format_types = TRUE,
  dot_is_NA = TRUE,
  alleles = TRUE,
  allele.sep = "/",
  gt_column_prepend = "gt_",
  verbose = TRUE
)

vcf_field_names(x, tag = "INFO")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_x">x</code></td>
<td>
<p>an object of class vcfR</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_info_only">info_only</code></td>
<td>
<p>if TRUE return a list with only a <code>fix</code> component
(a single data frame that has the parsed INFO information) and 
a <code>meta</code> component. Don't extract any of the FORMAT fields.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_single_frame">single_frame</code></td>
<td>
<p>return a single tidy data frame in list component
<code>dat</code> rather returning it in components
<code>fix</code> and/or <code>gt</code>.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_toss_info_column">toss_INFO_column</code></td>
<td>
<p>if TRUE (the default) the INFO column will be removed from output as
its consituent parts will have been parsed into separate columns.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_...">...</code></td>
<td>
<p>more options to pass to <code><a href="#topic+extract_info_tidy">extract_info_tidy</a></code> and 
<code><a href="#topic+extract_gt_tidy">extract_gt_tidy</a></code>.  See parameters listed below.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_info_fields">info_fields</code></td>
<td>
<p>names of the fields to be extracted from the INFO column
into a long format data frame.  If this is left as NULL (the default) then
the function returns a column for every INFO field listed in the metadata.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_info_types">info_types</code></td>
<td>
<p>named vector of &quot;i&quot; or &quot;n&quot; if you want the fields extracted from the INFO column to be converted to integer or numeric types, respectively.
When set to NULL they will be characters.  
The names have to be the exact names of the fields.  
For example <code>info_types = c(AF = "n", DP = "i")</code> will convert column AF to numeric and DP to integer.
If you would like the function to try to figure out the conversion from the metadata information, then set <code>info_types = TRUE</code>.  
Anything with Number == 1 and (Type == Integer or Type == Numeric) will then be converted accordingly.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_info_sep">info_sep</code></td>
<td>
<p>the delimiter used in the data portion of the INFO fields to 
separate different entries.  By default it is &quot;;&quot;, but earlier versions of the VCF
standard apparently used &quot;:&quot; as a delimiter.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_format_fields">format_fields</code></td>
<td>
<p>names of the fields in the FORMAT column to be extracted from 
each individual in the vcfR object into 
a long format data frame.  If left as NULL, the function will extract all the FORMAT
columns that were documented in the meta section of the VCF file.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_format_types">format_types</code></td>
<td>
<p>named vector of &quot;i&quot; or &quot;n&quot; if you want the fields extracted according to the FORMAT column to be converted to integer or numeric types, respectively.
When set to TRUE an attempt to determine their type will be made from the meta information.
When set to NULL they will be characters.  
The names have to be the exact names of the format_fields.  
Works equivalently to the <code>info_types</code> argument in 
<code><a href="#topic+extract_info_tidy">extract_info_tidy</a></code>, i.e., if you set it to TRUE then it uses the information in the
meta section of the VCF to coerce to types as indicated.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_dot_is_na">dot_is_NA</code></td>
<td>
<p>if TRUE then a single &quot;.&quot; in a character field will be set to NA.  If FALSE
no conversion is done.  Note that &quot;.&quot; in a numeric or integer field 
(according to format_types) with Number == 1 is always
going to be set to NA.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_alleles">alleles</code></td>
<td>
<p>if TRUE (the default) then this will return a column, <code>gt_GT_alleles</code> that
has the genotype of the individual expressed as the alleles rather than as 0/1.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_allele.sep">allele.sep</code></td>
<td>
<p>character which delimits the alleles in a genotype (/ or |) to be passed to
<code><a href="#topic+extract.gt">extract.gt</a></code>. Here this is not used for a regex (as it is in other functions), but merely
for output formatting.</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_gt_column_prepend">gt_column_prepend</code></td>
<td>
<p>string to prepend to the names of the FORMAT columns</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_verbose">verbose</code></td>
<td>
<p>logical to specify if verbose output should be produced
in the output so that they
do not conflict with any INFO columns in the output.  Default is &quot;gt_&quot;. Should be a 
valid R name. (i.e. don't start with a number, have a space in it, etc.)</p>
</td></tr>
<tr><td><code id="Convert+2B20to+2B20tidy+2B20data+2B20frames_+3A_tag">tag</code></td>
<td>
<p>name of the lines in the metadata section of the VCF file to parse out.
Default is &quot;INFO&quot;.  The only other one tested and supported, currently is, &quot;FORMAT&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <strong>vcfR2tidy</strong> is the main function in this series.  It takes a vcfR
object and converts the information to a list of long-format data frames.  The user can
specify whether only the INFO or both the INFO and the FORMAT columns should be extracted, and also
which INFO and FORMAT fields to extract.  If no specific INFO or FORMAT fields are asked
for, then they will all be returned.  If <code>single_frame == FALSE</code> and 
<code>info_only == FALSE</code> (the default), 
the function returns a list with three components: <code>fix</code>, <code>gt</code>, and <code>meta</code> as follows:
</p>

<ol>
<li> <p><code>fix</code> A data frame of the fixed information columns and the parsed INFO columns, and 
an additional column, <code>ChromKey</code>&mdash;an integer identifier
for each locus, ordered by their appearance in the original data frame&mdash;that serves
together with POS as a key back to rows in <code>gt</code>.  
</p>
</li>
<li> <p><code>gt</code> A data frame of the genotype-related fields. Column names are the names of the 
FORMAT fields with <code>gt_column_prepend</code> (by default, &quot;gt_&quot;) prepended to them.  Additionally
there are columns <code>ChromKey</code>, and <code>POS</code> that can be used to associate
each row in <code>gt</code> with a row in <code>fix</code>.
</p>
</li>
<li><p><code>meta</code> The meta-data associated with the columns that were extracted from the INFO and FORMAT
columns in a tbl_df-ed data frame.  
</p>
</li></ol>

<p>This is the default return object because it might be space-inefficient to
return a single tidy data frame if there are many individuals and the CHROM names are
long and/or there are many INFO fields.  However, if
<code>single_frame = TRUE</code>, then the results are returned as a list with component <code>meta</code>
as before, but rather than having <code>fix</code> and <code>gt</code> as before, both those data frames
have been joined into component <code>dat</code> and a ChromKey column is not returned, because
the CHROM column is available.
</p>
<p>If <code>info_only == FALSE</code>, then just the fixed columns and the parsed INFO columns are 
returned, and the FORMAT fields are not parsed at all.  The return value is a list with
components <code>fix</code> and <code>meta</code>.  No column ChromKey appears.
</p>
<p>The following functions are called by <strong>vcfR2tidy</strong> but are documented below because
they may be useful individually.
</p>
<p>The function <strong>extract_info_tidy</strong> let's you pass in a vector of the INFO fields that
you want extracted to a long format data frame. If you don't tell it which fields to 
extract it will extract all the INFO columns detailed in the VCF meta section.
The function returns a tbl_df data frame of the INFO fields along with with an additional
integer column <code>Key</code> that associates
each row in the output data frame with each row (i.e. each CHROM-POS combination) 
in the original vcfR object <code>x</code>.  
</p>
<p>The function <strong>extract_gt_tidy</strong> let's you pass in a vector of the FORMAT fields that
you want extracted to a long format data frame. If you don't tell it which fields to 
extract it will extract all the FORMAT columns detailed in the VCF meta section.
The function returns a tbl_df data frame of the FORMAT fields with an additional
integer column <code>Key</code> that associates
each row in the output data frame with each row (i.e. each CHROM-POS combination),
in the original vcfR object <code>x</code>, and an additional column <code>Indiv</code> that gives
the name of the individual.  
</p>
<p>The function <strong>vcf_field_names</strong> is a helper function that
parses information from the metadata section of the
VCF file to return a data frame with the <em>metadata</em> information about either the INFO 
or FORMAT tags.  It
returns a <code>tbl_df</code>-ed data frame with column names: &quot;Tag&quot;, &quot;ID&quot;, &quot;Number&quot;,&quot;Type&quot;,
&quot;Description&quot;, &quot;Source&quot;, and &quot;Version&quot;.
</p>


<h3>Value</h3>

<p>An object of class tidy::data_frame or a list where every element is of class tidy::data_frame.
</p>


<h3>Note</h3>

<p>To run all the examples, you can issue this:
<code>example("vcfR2tidy")</code>
</p>


<h3>Author(s)</h3>

<p>Eric C. Anderson &lt;eric.anderson@noaa.gov&gt;
</p>


<h3>See Also</h3>

<p><a href="https://cran.r-project.org/package=dplyr">dplyr</a>,
<a href="https://cran.r-project.org/package=tidyr">tidyr</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the data
data("vcfR_test")
vcf &lt;- vcfR_test


# extract all the INFO and FORMAT fields into a list of tidy
# data frames: fix, gt, and meta. Here we don't coerce columns
# to integer or numeric types...
Z &lt;- vcfR2tidy(vcf)
names(Z)


# here is the meta data in a table
Z$meta


# here is the fixed info
Z$fix


# here are the GT fields.  Note that ChromKey and POS are keys
# back to Z$fix
Z$gt


# Note that if you wanted to tidy this data set even further
# you could break up the comma-delimited columns easily
# using tidyr::separate




# here we put the data into a single, joined data frame (list component
# dat in the returned list) and the meta data.  Let's just pick out a 
# few fields:
vcfR2tidy(vcf, 
          single_frame = TRUE, 
          info_fields = c("AC", "AN", "MQ"), 
          format_fields = c("GT", "PL"))


# note that the "gt_GT_alleles" column is always returned when any
# FORMAT fields are extracted.




# Here we extract a single frame with all fields but we automatically change
# types of the columns according to the entries in the metadata.
vcfR2tidy(vcf, single_frame = TRUE, info_types = TRUE, format_types = TRUE)




# for comparison, here note that all the INFO and FORMAT fields that were
# extracted are left as character ("chr" in the dplyr summary)
vcfR2tidy(vcf, single_frame = TRUE)





# Below are some examples with the vcfR2tidy "subfunctions"


# extract the AC, AN, and MQ fields from the INFO column into
# a data frame and convert the AN values integers and the MQ
# values into numerics.
extract_info_tidy(vcf, info_fields = c("AC", "AN", "MQ"), info_types = c(AN = "i", MQ = "n"))

# extract all fields from the INFO column but leave 
# them as character vectors
extract_info_tidy(vcf)

# extract all fields from the INFO column and coerce 
# types according to metadata info
extract_info_tidy(vcf, info_types = TRUE)

# get the INFO field metadata in a data frame
vcf_field_names(vcf, tag = "INFO")

# get the FORMAT field metadata in a data frame
vcf_field_names(vcf, tag = "FORMAT")



</code></pre>

<hr>
<h2 id='create.chromR'>Create chromR object</h2><span id='topic+create.chromR'></span><span id='topic+vcfR2chromR'></span><span id='topic+vcf2chromR'></span><span id='topic+seq2chromR'></span><span id='topic+ann2chromR'></span>

<h3>Description</h3>

<p>Creates and populates an object of class chromR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.chromR(vcf, name = "CHROM", seq = NULL, ann = NULL, verbose = TRUE)

vcfR2chromR(x, vcf)

seq2chromR(x, seq = NULL)

ann2chromR(x, gff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.chromR_+3A_vcf">vcf</code></td>
<td>
<p>an object of class vcfR</p>
</td></tr>
<tr><td><code id="create.chromR_+3A_name">name</code></td>
<td>
<p>a name for the chromosome (for plotting purposes)</p>
</td></tr>
<tr><td><code id="create.chromR_+3A_seq">seq</code></td>
<td>
<p>a sequence as a DNAbin object</p>
</td></tr>
<tr><td><code id="create.chromR_+3A_ann">ann</code></td>
<td>
<p>an annotation file (gff-like)</p>
</td></tr>
<tr><td><code id="create.chromR_+3A_verbose">verbose</code></td>
<td>
<p>should verbose output be printed to the console?</p>
</td></tr>
<tr><td><code id="create.chromR_+3A_x">x</code></td>
<td>
<p>an object of class chromR</p>
</td></tr>
<tr><td><code id="create.chromR_+3A_gff">gff</code></td>
<td>
<p>a data.frame containing annotation data in the gff format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates and names a chromR object from a name, a chromosome (an ape::DNAbin object), variant data (a vcfR object) and annotation data (gff-like).
The function <strong>create.chromR</strong> is a wrapper which calls functions to populate the slots of the chromR object.
</p>
<p>The function <strong>vcf2chromR</strong> is called by create.chromR and transfers the data from the slots of a vcfR object to the slots of a chromR object.
It also tries to extract the 'DP' and 'MQ' fileds (when present) from the fix slot's INFO column.
It is not anticipated that a user would need to use this function directly, but its placed here in case they do.
</p>
<p>The function <strong>seq2chromR</strong> is currently defined as a generic function.
This may change in the future.
This function takes an object of class DNAbin and assigns it to the 'seq' slot of a chromR object.
</p>
<p>The function <strong>ann2chromR</strong> is called by create.chromR and transfers the information from a gff-like object to the 'ann' slot of a chromR object.
It is not anticipated that a user would need to use this function directly, but its placed here in case they do.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chromR-class">chromR-class</a></code>,
<code><a href="#topic+vcfR-class">vcfR-class</a></code>,
<code><a href="ape.html#topic+DNAbin">DNAbin</a></code>,
<a href="https://github.com/samtools/hts-specs">VCF specification</a>
<a href="https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md">gff3 format</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vcfR)
data(vcfR_example)
chrom &lt;- create.chromR('sc50', seq=dna, vcf=vcf, ann=gff)
head(chrom)
chrom
plot(chrom)

chrom &lt;- masker(chrom, min_QUAL = 1, min_DP = 300, max_DP = 700, min_MQ = 59, max_MQ = 61)
chrom &lt;- proc.chromR(chrom, win.size=1000)

plot(chrom)
chromoqc(chrom)




</code></pre>

<hr>
<h2 id='dr.plot+20elements'>dr.plot elements</h2><span id='topic+dr.plot+20elements'></span><span id='topic+dr.plot'></span><span id='topic+null.plot'></span>

<h3>Description</h3>

<p>Plot chromR objects and their components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr.plot(
  dmat = NULL,
  rlst = NULL,
  chrom.s = 1,
  chrom.e = NULL,
  title = NULL,
  hline = NULL,
  dcol = NULL,
  rcol = NULL,
  rbcol = NULL,
  ...
)

null.plot()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dr.plot+2B20elements_+3A_dmat">dmat</code></td>
<td>
<p>a numeric matrix for dot plots where the first column is position (POS) and subsequent columns are y-values.</p>
</td></tr>
<tr><td><code id="dr.plot+2B20elements_+3A_rlst">rlst</code></td>
<td>
<p>a list containing numeric matrices containing rectangle coordinates.</p>
</td></tr>
<tr><td><code id="dr.plot+2B20elements_+3A_chrom.s">chrom.s</code></td>
<td>
<p>start position for the chromosome</p>
</td></tr>
<tr><td><code id="dr.plot+2B20elements_+3A_chrom.e">chrom.e</code></td>
<td>
<p>end position for the chromosome</p>
</td></tr>
<tr><td><code id="dr.plot+2B20elements_+3A_title">title</code></td>
<td>
<p>optional string to be used for the plot title.</p>
</td></tr>
<tr><td><code id="dr.plot+2B20elements_+3A_hline">hline</code></td>
<td>
<p>vector of positions to be used for horizontal lines.</p>
</td></tr>
<tr><td><code id="dr.plot+2B20elements_+3A_dcol">dcol</code></td>
<td>
<p>vector of colors to be used for dot plots.</p>
</td></tr>
<tr><td><code id="dr.plot+2B20elements_+3A_rcol">rcol</code></td>
<td>
<p>vector of colors to be used for rectangle plots.</p>
</td></tr>
<tr><td><code id="dr.plot+2B20elements_+3A_rbcol">rbcol</code></td>
<td>
<p>vector of colors to be used for rectangle borders.</p>
</td></tr>
<tr><td><code id="dr.plot+2B20elements_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot details
The parameter <strong>rlist</strong> is list of numeric matrices containing rectangle coordinates.
The first column of each matrix is the left positions, the second column is the bottom coordinates, the third column is the right coordinates and the fourth column is the top coordinates.
</p>


<h3>Value</h3>

<p>Returns the y-axis minimum and maximum values invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+rect">rect</a></code>
<code><a href="#topic+chromo">chromo</a></code>
</p>

<hr>
<h2 id='extract.gt'>Extract elements from vcfR objects</h2><span id='topic+extract.gt'></span><span id='topic+extract.haps'></span><span id='topic+is.indel'></span><span id='topic+extract.indels'></span><span id='topic+extract.info'></span>

<h3>Description</h3>

<p>Extract elements from the 'gt' slot, convert extracted genotypes to their allelic state, extract indels from the data structure or extract elements from the INFO column of the 'fix' slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.gt(
  x,
  element = "GT",
  mask = FALSE,
  as.numeric = FALSE,
  return.alleles = FALSE,
  IDtoRowNames = TRUE,
  extract = TRUE,
  convertNA = TRUE
)

extract.haps(x, mask = FALSE, unphased_as_NA = TRUE, verbose = TRUE)

is.indel(x)

extract.indels(x, return.indels = FALSE)

extract.info(x, element, as.numeric = FALSE, mask = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract.gt_+3A_x">x</code></td>
<td>
<p>An object of class chromR or vcfR</p>
</td></tr>
<tr><td><code id="extract.gt_+3A_element">element</code></td>
<td>
<p>element to extract from vcf genotype data. Common options include &quot;DP&quot;, &quot;GT&quot; and &quot;GQ&quot;</p>
</td></tr>
<tr><td><code id="extract.gt_+3A_mask">mask</code></td>
<td>
<p>a logical indicating whether to apply the mask (TRUE) or return all variants (FALSE). Alternatively, a vector of logicals may be provided.</p>
</td></tr>
<tr><td><code id="extract.gt_+3A_as.numeric">as.numeric</code></td>
<td>
<p>logical, should the matrix be converted to numerics</p>
</td></tr>
<tr><td><code id="extract.gt_+3A_return.alleles">return.alleles</code></td>
<td>
<p>logical indicating whether to return the genotypes (0/1) or alleles (A/T)</p>
</td></tr>
<tr><td><code id="extract.gt_+3A_idtorownames">IDtoRowNames</code></td>
<td>
<p>logical specifying whether to use the ID column from the FIX region as rownames</p>
</td></tr>
<tr><td><code id="extract.gt_+3A_extract">extract</code></td>
<td>
<p>logical indicating whether to return the extracted element or the remaining string</p>
</td></tr>
<tr><td><code id="extract.gt_+3A_convertna">convertNA</code></td>
<td>
<p>logical indicating whether to convert &quot;.&quot; to NA.</p>
</td></tr>
<tr><td><code id="extract.gt_+3A_unphased_as_na">unphased_as_NA</code></td>
<td>
<p>logical specifying how to handle unphased genotypes</p>
</td></tr>
<tr><td><code id="extract.gt_+3A_verbose">verbose</code></td>
<td>
<p>should verbose output be generated</p>
</td></tr>
<tr><td><code id="extract.gt_+3A_return.indels">return.indels</code></td>
<td>
<p>logical indicating whether to return indels or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <strong>extract.gt</strong> isolates elements from the 'gt' portion of vcf data.
Fields available for extraction are listed in the FORMAT column of the 'gt' slot.
Because different vcf producing software produce different fields the options will vary by software.
The mask parameter allows the mask to be implemented when using a chromR object.
The 'as.numeric' option will convert the results from a character to a numeric.
Note that if the data is not actually numeric, it will result in a numeric result which may not be interpretable.
The 'return.alleles' option allows the default behavior of numerically encoded genotypes (e.g., 0/1) to be converted to their nucleic acid representation (e.g., A/T).
Note that this is not used for a regular expression as similar parameters are used in other functions.
Extract allows the user to extract just the specified element (TRUE) or every element except the one specified.
</p>
<p>Note that when 'as.numeric' is set to 'TRUE' but the data are not actually numeric, unexpected results will likely occur.
For example, the genotype field will typically be populated with values such as &quot;0/1&quot; or &quot;1|0&quot;.
Although these may appear numeric, they contain a delimiter (the forward slash or the pipe) that is non-numeric.
This means that there is no straight forward conversion to a numeric and unexpected values should be expected.
</p>
<p>The function <strong>extract.haps</strong> uses extract.gt to isolate genotypes.
It then uses the information in the REF and ALT columns as well as an allele delimiter (gt_split) to split genotypes into their allelic state.
Ploidy is determined by the first non-NA genotype in the first sample.
</p>
<p>The VCF specification allows for genotypes to be delimited with a '|' when they are phased and a '/' when unphased.
This becomes important when dividing a genotype into two haplotypes.
When the alleels are phased this is straight forward.
When the alleles are unphased it presents a decision.
The default is to handle unphased data by converting them to NAs.
When unphased_as_NA is set to TRUE the alleles will be returned in the order they appear in the genotype.
This does not assign each allele to it's correct chromosome.
It becomes the user's responsibility to make informed decisions at this point.
</p>
<p>The function <strong>is.indel</strong> returns a logical vector indicating which variants are indels (variants where an allele is greater than one character).
</p>
<p>The function <strong>extract.indels</strong> is used to remove indels from SNPs.
The function queries the 'REF' and 'ALT' columns of the 'fix' slot to see if any alleles are greater than one character in length.
When the parameter return_indels is FALSE only SNPs will be returned.
When the parameter return_indels is TRUE only indels will be returned.
</p>
<p>The function <strong>extract.info</strong> is used to isolate elements from the INFO column of vcf data.
</p>


<h3>See Also</h3>

<p><code>is.polymorphic</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_test)
gt &lt;- extract.gt(vcfR_test)
gt &lt;- extract.gt(vcfR_test, return.alleles = TRUE)

data(vcfR_test)
is.indel(vcfR_test)


data(vcfR_test)
getFIX(vcfR_test)
vcf &lt;- extract.indels(vcfR_test)
getFIX(vcf)
vcf@fix[nrow(vcf@fix),'ALT'] &lt;- ".,A"
vcf &lt;- extract.indels(vcf)
getFIX(vcf)

data(vcfR_test)
vcfR_test@fix[1,'ALT'] &lt;- "&lt;NON_REF&gt;"
vcf &lt;- extract.indels(vcfR_test)
getFIX(vcf)

data(vcfR_test)
extract.haps(vcfR_test, unphased_as_NA = FALSE)
extract.haps(vcfR_test)


</code></pre>

<hr>
<h2 id='Format+20conversion'>Convert vcfR objects to other formats</h2><span id='topic+Format+20conversion'></span><span id='topic+vcfR2genind'></span><span id='topic+vcfR2loci'></span><span id='topic+vcfR2genlight'></span>

<h3>Description</h3>

<p>Convert vcfR objects to objects supported by other R packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcfR2genind(x, sep = "[|/]", return.alleles = FALSE, ...)

vcfR2loci(x, return.alleles = FALSE)

vcfR2genlight(x, n.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Format+2B20conversion_+3A_x">x</code></td>
<td>
<p>an object of class chromR or vcfR</p>
</td></tr>
<tr><td><code id="Format+2B20conversion_+3A_sep">sep</code></td>
<td>
<p>character (to be used in a regular expression) to delimit the alleles of genotypes</p>
</td></tr>
<tr><td><code id="Format+2B20conversion_+3A_return.alleles">return.alleles</code></td>
<td>
<p>should the VCF encoding of the alleles be returned (FALSE) or the actual alleles (TRUE).</p>
</td></tr>
<tr><td><code id="Format+2B20conversion_+3A_...">...</code></td>
<td>
<p>pass other parameters to adegenet::df2genlight</p>
</td></tr>
<tr><td><code id="Format+2B20conversion_+3A_n.cores">n.cores</code></td>
<td>
<p>integer specifying the number of cores to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After processing vcf data in vcfR, one will likely proceed to an analysis step.
Within R, three obvious choices are:
<a href="https://cran.r-project.org/package=pegas">pegas</a>,
<a href="https://cran.r-project.org/package=adegenet">adegenet</a> 
and <a href="https://cran.r-project.org/package=poppr">poppr</a>.
The package pegas uses objects of type loci.
The function <strong>vcfR2loci</strong> calls extract.gt to create a matrix of genotypes which is then converted into an object of type loci.
</p>
<p>The packages adegenet and poppr use the genind object.
The function <strong>vcfR2genind</strong> uses extract.gt to create a matrix of genotypes and uses the adegenet function df2genind to create a genind object.
The package poppr additionally uses objects of class genclone which can be created from genind objects using poppr::as.genclone.
A genind object can be converted to a genclone object with the function poppr::as.genclone.
</p>
<p>The function vcfR2genlight calls the 'new' method for the genlight object.
This method implements multi-threading through calls to the function <code>parallel::mclapply</code>.
Because 'forks' do not exist in the windows environment, this will only work for windows users when n.cores=1.
In the Unix environment, users may increase this number to allow the use of multiple threads (i.e., cores).
</p>
<p>The parameter <strong>...</strong> is used to pass parameters to other functions.
In <code>vcfR2genind</code> it is used to pass parameters to <code>adegenet::df2genind</code>.
For example, setting <code>check.ploidy=FALSE</code> may improve the performance of <code>adegenet::df2genind</code>, as long as you know the ploidy.
See <code>?adegenet::df2genind</code> to see these options.
</p>


<h3>Note</h3>



<h4>For users of <span class="pkg">poppr</span></h4>

<p>If you wish to use <code>vcfR2genind()</code>, it is <strong>strongly recommended</strong> to use it with the option <code>return.alleles = TRUE</code>.
The reason for this is because the <span class="pkg">poppr</span> package accomodates mixed-ploidy data by interpreting &quot;0&quot; alleles <em>in genind objects</em> to be NULL alleles in both <code>poppr::poppr.amova()</code> and <code>poppr::locus_table()</code>.
</p>



<h3>See Also</h3>

<p><code>extract.gt</code>,
<code>alleles2consensus</code>,
<code>adegenet::df2genind</code>,
<code>adegenet::genind</code>,
<a href="https://cran.r-project.org/package=pegas">pegas</a>,
<a href="https://cran.r-project.org/package=adegenet">adegenet</a>,
and 
<a href="https://cran.r-project.org/package=poppr">poppr</a>.
To convert to objects of class <strong>DNAbin</strong> see <code>vcfR2DNAbin</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adegenet_installed &lt;- require("adegenet")
if (adegenet_installed) {
  data(vcfR_test)
  # convert to genlight (preferred method with bi-allelic SNPs)
  gl &lt;- vcfR2genlight(vcfR_test)
  
  # convert to genind, keeping information about allelic state
  # (slightly slower, but preferred method for use with the "poppr" package)
  gid &lt;- vcfR2genind(vcfR_test, return.alleles = TRUE) 

  # convert to genind, returning allelic states as 0, 1, 2, etc.
  # (not preferred, but slightly faster)
  gid2 &lt;- vcfR2genind(vcfR_test, return.alleles = FALSE)
}

</code></pre>

<hr>
<h2 id='freq_peak'>freq_peak</h2><span id='topic+freq_peak'></span>

<h3>Description</h3>

<p>Find density peaks in frequency data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq_peak(myMat, pos, winsize = 10000L, bin_width = 0.02, lhs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freq_peak_+3A_mymat">myMat</code></td>
<td>
<p>a matrix of frequencies [0-1].</p>
</td></tr>
<tr><td><code id="freq_peak_+3A_pos">pos</code></td>
<td>
<p>a numeric vector describing the position of variants in myMat.</p>
</td></tr>
<tr><td><code id="freq_peak_+3A_winsize">winsize</code></td>
<td>
<p>sliding window size.</p>
</td></tr>
<tr><td><code id="freq_peak_+3A_bin_width">bin_width</code></td>
<td>
<p>Width of bins to summarize ferequencies in (0-1].</p>
</td></tr>
<tr><td><code id="freq_peak_+3A_lhs">lhs</code></td>
<td>
<p>logical specifying whether the search for the bin of greatest density should favor values from the left hand side.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Noisy data, such as genomic data, lack a clear consensus.
Summaries may be made in an attempt to 'clean it up.'
Common summaries, such as the mean, rely on an assumption of normalicy.
An assumption that frequently can be violated.
This leaves a conundrum as to how to effectively summarize these data.
</p>
<p>Here we implement an attempt to summarize noisy data through binning the data and selecting the bin containing the greatest density of data.
The data are first divided into parameter sized windows.
Next the data are categorized by parameterizable bin widths.
Finally, the bin with the greatest density, the greatest count of data, is used as a summary.
Because this method is based on binning the data it does not rely on a distributional assumption.
</p>
<p>The parameter <code>lhs</code> specifyies whether the search for the bin of greatest density should be performed from the left hand side.
The default value of TRUE starts at the left hand side, or zero, and selects a new bin as having the greatest density only if a new bin has a greater density.
If the new bin has an equal density then no update is made.
This causees the analysis to select lower frequencies.
When this parameter is set to FALSE ties result in an update of the bin of greatest density.
This causes the analysis to select higher frequencies.
It is recommended that when testing the most abundant allele (typically [0.5-1]) to use the default of TRUE so that a low value is preferred.
Similarly, when testing the less abundant alleles it is recommended to set this value at FALSE to preferentially select high values.
</p>


<h3>Value</h3>

<p>A freq_peak object (a list) containing:
</p>

<ul>
<li><p> The window size
</p>
</li>
<li><p> The binwidth used for peak binning
</p>
</li>
<li><p> a matrix containing window coordinates
</p>
</li>
<li><p> a matrix containing peak locations
</p>
</li>
<li><p> a matrix containing the counts of variants for each sample in each window
</p>
</li></ul>

<p>The window matrix contains start and end coordinates for each window, the rows of the original matrix that demarcate each window and the position of the variants that begin and end each window.
</p>
<p>The matrix of peak locations contains the midpoint for the bin of greatest density for each sample and each window.
Alternatively, if 'count = TRUE' the number of non-missing values in each window is reported.
The number of non-mising values in each window may be used to censor windows containing low quantities of data.
</p>


<h3>See Also</h3>

<p>peak_to_ploid,
freq_peak_plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_example)
gt &lt;- extract.gt(vcf)
hets &lt;- is_het(gt)
# Censor non-heterozygous positions.
is.na(vcf@gt[,-1][!hets]) &lt;- TRUE
# Extract allele depths.
ad &lt;- extract.gt(vcf, element = "AD")
ad1 &lt;- masplit(ad, record = 1)
ad2 &lt;- masplit(ad, record = 2)
freq1 &lt;- ad1/(ad1+ad2)
freq2 &lt;- ad2/(ad1+ad2)
myPeaks1 &lt;- freq_peak(freq1, getPOS(vcf))
is.na(myPeaks1$peaks[myPeaks1$counts &lt; 20]) &lt;- TRUE
myPeaks2 &lt;- freq_peak(freq2, getPOS(vcf), lhs = FALSE)
is.na(myPeaks2$peaks[myPeaks2$counts &lt; 20]) &lt;- TRUE
myPeaks1

# Visualize
mySample &lt;- "P17777us22"
myWin &lt;- 2
hist(freq1[myPeaks1$wins[myWin,'START_row']:myPeaks1$wins[myWin,'END_row'], mySample], 
     breaks=seq(0,1,by=0.02), col="#A6CEE3", main="", xlab="", xaxt="n")
hist(freq2[myPeaks2$wins[myWin,'START_row']:myPeaks2$wins[myWin,'END_row'], mySample], 
     breaks=seq(0,1,by=0.02), col="#1F78B4", main="", xlab="", xaxt="n", add = TRUE)
axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), 
     labels=c(0,'1/4','1/3','1/2','2/3','3/4',1), las=3)
abline(v=myPeaks1$peaks[myWin,mySample], col=2, lwd=2)
abline(v=myPeaks2$peaks[myWin,mySample], col=2, lwd=2)

# Visualize #2
mySample &lt;- "P17777us22"
plot(getPOS(vcf), freq1[,mySample], ylim=c(0,1), type="n", yaxt='n', 
     main = mySample, xlab = "POS", ylab = "Allele balance")
axis(side=2, at=c(0,0.25,0.333,0.5,0.666,0.75,1), 
     labels=c(0,'1/4','1/3','1/2','2/3','3/4',1), las=1)
abline(h=c(0.25,0.333,0.5,0.666,0.75), col=8)
points(getPOS(vcf), freq1[,mySample], pch = 20, col= "#A6CEE3")
points(getPOS(vcf), freq2[,mySample], pch = 20, col= "#1F78B4")
segments(x0=myPeaks1$wins[,'START_pos'], y0=myPeaks1$peaks[,mySample],
         x1=myPeaks1$wins[,'END_pos'], lwd=3)
segments(x0=myPeaks1$wins[,'START_pos'], y0=myPeaks2$peaks[,mySample],
         x1=myPeaks1$wins[,'END_pos'], lwd=3)



</code></pre>

<hr>
<h2 id='freq_peak_plot'>Plot freq_peak object</h2><span id='topic+freq_peak_plot'></span>

<h3>Description</h3>

<p>Converts allele balance data produced by <code>freq_peak()</code> to a copy number by assinging the allele balance data (frequencies) to its closest expected ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq_peak_plot(
  pos,
  posUnits = "bp",
  ab1 = NULL,
  ab2 = NULL,
  fp1 = NULL,
  fp2 = NULL,
  mySamp = 1,
  col1 = "#A6CEE3",
  col2 = "#1F78B4",
  alpha = 44,
  main = NULL,
  mhist = TRUE,
  layout = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freq_peak_plot_+3A_pos">pos</code></td>
<td>
<p>chromosomal position of variants</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_posunits">posUnits</code></td>
<td>
<p>units ('bp', 'Kbp', 'Mbp', 'Gbp') for 'pos' to be converted to in the main plot</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_ab1">ab1</code></td>
<td>
<p>matrix of allele balances for allele 1</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_ab2">ab2</code></td>
<td>
<p>matrix of allele balances for allele 2</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_fp1">fp1</code></td>
<td>
<p>freq_peak object for allele 1</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_fp2">fp2</code></td>
<td>
<p>freq_peak object for allele 2</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_mysamp">mySamp</code></td>
<td>
<p>sample indicator</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_col1">col1</code></td>
<td>
<p>color 1</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_col2">col2</code></td>
<td>
<p>color 2</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_alpha">alpha</code></td>
<td>
<p>sets the transparency for dot plot (0-255)</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_main">main</code></td>
<td>
<p>main plot title.</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_mhist">mhist</code></td>
<td>
<p>logical indicating to include a marginal histogram</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_layout">layout</code></td>
<td>
<p>call layout</p>
</td></tr>
<tr><td><code id="freq_peak_plot_+3A_...">...</code></td>
<td>
<p>parameters passed on to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a visualization of allele balance data consisting of a dot plot with position as the x-axis and frequency on the y-axis and an optional marginal histogram.
The only required information is a vector of chromosomal positions, however this is probably not going to create an interesting plot.
</p>


<h3>Value</h3>

<p>An invisible NULL.
</p>


<h3>See Also</h3>

<p>freq_peak,
peak_to_ploid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# An empty plot.
freq_peak_plot(pos=1:40)

data(vcfR_example)
gt &lt;- extract.gt(vcf)
hets &lt;- is_het(gt)
# Censor non-heterozygous positions.
is.na(vcf@gt[,-1][!hets]) &lt;- TRUE
# Extract allele depths.
ad &lt;- extract.gt(vcf, element = "AD")
ad1 &lt;- masplit(ad, record = 1)
ad2 &lt;- masplit(ad, record = 2)
freq1 &lt;- ad1/(ad1+ad2)
freq2 &lt;- ad2/(ad1+ad2)
myPeaks1 &lt;- freq_peak(freq1, getPOS(vcf))
is.na(myPeaks1$peaks[myPeaks1$counts &lt; 20]) &lt;- TRUE
myPeaks2 &lt;- freq_peak(freq2, getPOS(vcf), lhs = FALSE)
is.na(myPeaks2$peaks[myPeaks2$counts &lt; 20]) &lt;- TRUE
freq_peak_plot(pos = getPOS(vcf), ab1 = freq1, ab2 = freq2, fp1 = myPeaks1, fp2=myPeaks2)



</code></pre>

<hr>
<h2 id='genetic_diff'>Genetic differentiation</h2><span id='topic+genetic_diff'></span>

<h3>Description</h3>

<p>Calculate measures of genetic differentiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genetic_diff(vcf, pops, method = "nei")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genetic_diff_+3A_vcf">vcf</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="genetic_diff_+3A_pops">pops</code></td>
<td>
<p>factor indicating populations</p>
</td></tr>
<tr><td><code id="genetic_diff_+3A_method">method</code></td>
<td>
<p>the method to measure differentiation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Measures of genetic differentiation, or fixation indicies, are commonly reported population genetic parameters.
This function reports genetic differentiation for all variants presented to it.
</p>
<p>The method <strong>nei</strong> returns Nei's Gst as well as Hedrick's G'st, a correction for high alleleism (Hedrick 2005).
Here it is calculated as in equation 2 from Hedrick (2005) with the exception that the heterozygosities are weighted by the number of alleles observed in each subpopulation.
This is similar to <code>hierfstat::pairwise.fst()</code> but by using the number of alleles instead of the number of individuals it avoids making an assumption about how many alleles are contributed by each individual.
G'st is calculated as in equation 4b from Hedrick (2005).
This method is based on heterozygosity where all of the alleles in a population are used to calculate allele frequecies.
This may make this a good choice when there is a mixture of ploidies in the sample.
</p>
<p>The method <strong>jost</strong> return's Jost's D as a measure of differentiation.
This is calculated as in equation 13 from Jost (2008).
Examples are available at Jost's website: <a href="http://www.loujost.com">http://www.loujost.com</a>.
</p>
<p>A nice review of Fst and some of its analogues can be found in Holsinger and Weir (2009).
</p>


<h3>References</h3>

<p>Hedrick, Philip W. &quot;A standardized genetic differentiation measure.&quot; Evolution 59.8 (2005): 1633-1638.
</p>
<p>Holsinger, Kent E., and Bruce S. Weir. &quot;Genetics in geographically structured populations: defining, estimating and interpreting FST.&quot; Nature Reviews Genetics 10.9 (2009): 639-650.
</p>
<p>Jost, Lou. &quot;GST and its relatives do not measure differentiation.&quot; Molecular ecology 17.18 (2008): 4015-4026.
</p>
<p>Whitlock, Michael C. &quot;G'ST and D do not replace FST.&quot; Molecular Ecology 20.6 (2011): 1083-1091.
</p>


<h3>See Also</h3>

<p>poppr.amova in <a href="https://cran.r-project.org/package=poppr">poppr</a>, amova in <a href="https://cran.r-project.org/package=ade4">ade4</a>, amova in <a href="https://cran.r-project.org/package=pegas">pegas</a>, <a href="https://cran.r-project.org/package=hierfstat">hierfstat</a>, <a href="https://cran.r-project.org/package=DEMEtics">DEMEtics</a>, and, <a href="https://cran.r-project.org/package=mmod">mmod</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_example)
myPops &lt;- as.factor(rep(c('a','b'), each = 9))
myDiff &lt;- genetic_diff(vcf, myPops, method = "nei")
colMeans(myDiff[,c(3:8,11)], na.rm = TRUE)
hist(myDiff$Gprimest, xlab = expression(italic("G'"["ST"])), 
     col='skyblue', breaks = seq(0, 1, by = 0.01))


</code></pre>

<hr>
<h2 id='Genotype+20matrix+20functions'>Genotype matrix functions</h2><span id='topic+Genotype+20matrix+20functions'></span><span id='topic+alleles2consensus'></span><span id='topic+get.alleles'></span>

<h3>Description</h3>

<p>Functions which modify a matrix or vector of genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alleles2consensus(x, sep = "/", NA_to_n = TRUE)

get.alleles(x2, split = "/", na.rm = FALSE, as.numeric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Genotype+2B20matrix+2B20functions_+3A_x">x</code></td>
<td>
<p>a matrix of alleles as genotypes (e.g., A/A, C/G, etc.)</p>
</td></tr>
<tr><td><code id="Genotype+2B20matrix+2B20functions_+3A_sep">sep</code></td>
<td>
<p>a character which delimits the alleles in a genotype (/ or |)</p>
</td></tr>
<tr><td><code id="Genotype+2B20matrix+2B20functions_+3A_na_to_n">NA_to_n</code></td>
<td>
<p>logical indicating whether NAs should be scores as n</p>
</td></tr>
<tr><td><code id="Genotype+2B20matrix+2B20functions_+3A_x2">x2</code></td>
<td>
<p>a vector of genotypes</p>
</td></tr>
<tr><td><code id="Genotype+2B20matrix+2B20functions_+3A_split">split</code></td>
<td>
<p>character passed to strsplit to split the genotype into alleles</p>
</td></tr>
<tr><td><code id="Genotype+2B20matrix+2B20functions_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether to remove NAs</p>
</td></tr>
<tr><td><code id="Genotype+2B20matrix+2B20functions_+3A_as.numeric">as.numeric</code></td>
<td>
<p>logical specifying whether to convert to a numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <strong>alleles2consensus</strong> converts genotypes to a single consensus allele using IUPAC ambiguity codes for heterozygotes. 
Note that some functions, such as ape::seg.sites do not recognize ambiguity characters (other than 'n').
This means that these functions, as well as functions that depend on them (e.g., pegas::tajima.test), will produce unexpected results.
</p>
<p>Missing data are handled in a number of steps.
When both alleles are missing ('.') the genotype is converted to NA.
Secondly, if one of the alleles is missing ('.') the genotype is converted to NA&gt;
Lastly, NAs can be optionally converted to 'n' for compatibility with DNAbin objects.
</p>
<p>The function <strong>get.alleles</strong> takes a vector of genotypes and returns the unique alleles.
</p>

<hr>
<h2 id='getFIX'>Get elements from the fixed region of a VCF file</h2><span id='topic+getFIX'></span><span id='topic+getFIX+2CchromR-method'></span><span id='topic+getFIX+2CvcfR-method'></span><span id='topic+getCHROM'></span><span id='topic+getCHROM+2CchromR-method'></span><span id='topic+getCHROM+2CvcfR-method'></span><span id='topic+getPOS'></span><span id='topic+getPOS+2CchromR-method'></span><span id='topic+getPOS+2CvcfR-method'></span><span id='topic+getQUAL'></span><span id='topic+getQUAL+2CchromR-method'></span><span id='topic+getQUAL+2CvcfR-method'></span><span id='topic+getALT'></span><span id='topic+getALT+2CchromR-method'></span><span id='topic+getALT+2CvcfR-method'></span><span id='topic+getREF'></span><span id='topic+getREF+2CchromR-method'></span><span id='topic+getREF+2CvcfR-method'></span><span id='topic+getID'></span><span id='topic+getID+2CchromR-method'></span><span id='topic+getID+2CvcfR-method'></span><span id='topic+getFILTER'></span><span id='topic+getFILTER+2CchromR-method'></span><span id='topic+getFILTER+2CvcfR-method'></span><span id='topic+getINFO'></span><span id='topic+getINFO+2CchromR-method'></span><span id='topic+getINFO+2CvcfR-method'></span>

<h3>Description</h3>

<p>Both chromR objects and vcfR objects contain a region with fixed variables.
These accessors allow you to isolate these variables from these objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFIX(x, getINFO = FALSE)

getCHROM(x)

getPOS(x)

getQUAL(x)

getALT(x)

getREF(x)

getID(x)

getFILTER(x)

getINFO(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFIX_+3A_x">x</code></td>
<td>
<p>a vcfR or chromR object</p>
</td></tr>
<tr><td><code id="getFIX_+3A_getinfo">getINFO</code></td>
<td>
<p>logical specifying whether getFIX should return the INFO column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("vcfR")
data("vcfR_example")
data("chromR_example")
getFIX(vcf) %&gt;% head
getFIX(chrom) %&gt;% head

getCHROM(vcf) %&gt;% head
getCHROM(chrom) %&gt;% head

getPOS(vcf) %&gt;% head
getPOS(chrom) %&gt;% head

getID(vcf) %&gt;% head
getID(chrom) %&gt;% head

getREF(vcf) %&gt;% head
getREF(chrom) %&gt;% head

getALT(vcf) %&gt;% head
getALT(chrom) %&gt;% head

getQUAL(vcf) %&gt;% head
getQUAL(chrom) %&gt;% head

getFILTER(vcf) %&gt;% head
getFILTER(chrom) %&gt;% head

getINFO(vcf) %&gt;% head
getINFO(chrom) %&gt;% head

</code></pre>

<hr>
<h2 id='gt2popsum'>Population genetics summaries</h2><span id='topic+gt2popsum'></span><span id='topic+Population+20genetics+20summaries'></span><span id='topic+gt.to.popsum'></span>

<h3>Description</h3>

<p>Functions that make population genetics summaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gt2popsum(x, deprecated = TRUE)

gt.to.popsum(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gt2popsum_+3A_x">x</code></td>
<td>
<p>object of class chromR or vcfR</p>
</td></tr>
<tr><td><code id="gt2popsum_+3A_deprecated">deprecated</code></td>
<td>
<p>logical specifying whether to run the function (FALSE) or present deprecation message (TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function 'gt2popsum' was deprecated in vcfR 1.8.0.
This was because it was written entirely in R and did not perform well.
Users should use 'gt.to.popsum()' instead because it has similar
functionality but includes calls to C++ to increase its performance.
</p>
<p>This function creates common population genetic summaries from either a chromR or vcfR object.
The default is to return a matrix containing allele counts, He, and Ne.
<strong>Allele_counts</strong> is the a comma delimited string of counts.
The first position is the count of reference alleles, the second positions is the count of the first alternate alleles, the third is the count of second alternate alleles, and so on.
<strong>He</strong> is the gene diversity, or heterozygosity, of the population.
This is <code class="reqn">1 - \sum x^{2}_{i}</code>, or the probability that two alleles sampled from the population are different, following Nei (1973).
<strong>Ne</strong> is the effective number of alleles in the population.
This is <code class="reqn">1/\sum x^{2}_{i}</code> or one minus the homozygosity, from Nei (1987) equation 8.17.
</p>
<p>Nei, M., 1973. Analysis of gene diversity in subdivided populations. Proceedings of the National Academy of Sciences, 70(12), pp.3321-3323.
</p>
<p>Nei, M., 1987. Molecular evolutionary genetics. Columbia University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_test)
# Check the genotypes.
extract.gt(vcfR_test)
# Summarize the genotypes.
gt.to.popsum(vcfR_test)

</code></pre>

<hr>
<h2 id='heatmap.bp'>Heatmap with barplots</h2><span id='topic+heatmap.bp'></span>

<h3>Description</h3>

<p>Heatmap of a numeric matrix with barplots summarizing columns and rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap.bp(
  x,
  cbarplot = TRUE,
  rbarplot = TRUE,
  legend = TRUE,
  clabels = TRUE,
  rlabels = TRUE,
  na.rm = TRUE,
  scale = c("row", "column", "none"),
  col.ramp = viridisLite::viridis(n = 100, alpha = 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmap.bp_+3A_x">x</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
<tr><td><code id="heatmap.bp_+3A_cbarplot">cbarplot</code></td>
<td>
<p>a logical indicating whether the columns should be summarized with a barplot.</p>
</td></tr>
<tr><td><code id="heatmap.bp_+3A_rbarplot">rbarplot</code></td>
<td>
<p>a logical indicating whether the rows should be summarized with a barplot.</p>
</td></tr>
<tr><td><code id="heatmap.bp_+3A_legend">legend</code></td>
<td>
<p>a logical indicating whether a legend should be plotted.</p>
</td></tr>
<tr><td><code id="heatmap.bp_+3A_clabels">clabels</code></td>
<td>
<p>a logical indicating whether column labels should be included.</p>
</td></tr>
<tr><td><code id="heatmap.bp_+3A_rlabels">rlabels</code></td>
<td>
<p>a logical indicating whether row labels should be included.</p>
</td></tr>
<tr><td><code id="heatmap.bp_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be removed.</p>
</td></tr>
<tr><td><code id="heatmap.bp_+3A_scale">scale</code></td>
<td>
<p>character indicating if the values should be centered and scaled in either the row direction or the column direction, or none. The default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="heatmap.bp_+3A_col.ramp">col.ramp</code></td>
<td>
<p>vector of colors to be used for the color ramp.</p>
</td></tr>
<tr><td><code id="heatmap.bp_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function heatmap.bp creates a heatmap from a numeric matrix with optional barplots to summarize the rows and columns.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+heatmap">heatmap</a></code>, <code><a href="graphics.html#topic+image">image</a></code>, heatmap2 in <a href="https://cran.r-project.org/package=gplots">gplots</a>, <a href="https://cran.r-project.org/package=pheatmap">pheatmap</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vcfR)

x  &lt;- as.matrix(mtcars)

heatmap.bp(x)
heatmap.bp(x, scale="col")
# Use an alternate color ramp
heatmap.bp(x, col.ramp = colorRampPalette(c("red", "yellow", "#008000"))(100))
heatmap.bp(x)

## Not run: 
heatmap.bp(x, cbarplot = FALSE, rbarplot = FALSE, legend = FALSE)
heatmap.bp(x, cbarplot = FALSE, rbarplot = TRUE, legend = FALSE)
heatmap.bp(x, cbarplot = FALSE, rbarplot = FALSE, legend = TRUE)
heatmap.bp(x, cbarplot = FALSE, rbarplot = TRUE, legend = TRUE)

heatmap.bp(x, cbarplot = TRUE, rbarplot = FALSE, legend = FALSE)
heatmap.bp(x, cbarplot = TRUE, rbarplot = TRUE, legend = FALSE)
heatmap.bp(x, cbarplot = TRUE, rbarplot = FALSE, legend = TRUE)
heatmap.bp(x, cbarplot = TRUE, rbarplot = TRUE, legend = TRUE)

## End(Not run)

 
</code></pre>

<hr>
<h2 id='INFO2df'>Reformat INFO data as a data.frame</h2><span id='topic+INFO2df'></span><span id='topic+metaINFO2df'></span>

<h3>Description</h3>

<p>Reformat INFO data as a data.frame and handle class when possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INFO2df(x)

metaINFO2df(x, field = "INFO")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="INFO2df_+3A_x">x</code></td>
<td>
<p>an object of class vcfR or chromR.</p>
</td></tr>
<tr><td><code id="INFO2df_+3A_field">field</code></td>
<td>
<p>should either the INFo or FORMAT data be returned?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The INFO column of VCF data contains descriptors for each variant.
Because this column may contain many comma delimited descriptors it may be difficult to interpret.
The function INFO2df converts the data into a data.frame.
The function metaINFO2df extracts the information in the meta section that describes the INFO descriptors.
This function is called by INFO2df to help it handle the class of the data.
</p>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_test)
metaINFO2df(vcfR_test)
getINFO(vcfR_test)
INFO2df(vcfR_test)


</code></pre>

<hr>
<h2 id='is_het'>Query genotypes for heterozygotes</h2><span id='topic+is_het'></span><span id='topic+is.het'></span>

<h3>Description</h3>

<p>Query a matrix of genotypes for heterozygotes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_het(x, na_is_false = TRUE)

is.het(x, na_is_false = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_het_+3A_x">x</code></td>
<td>
<p>a matrix of genotypes</p>
</td></tr>
<tr><td><code id="is_het_+3A_na_is_false">na_is_false</code></td>
<td>
<p>should missing data be returned as NA (FALSE) or FALSE (TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was designed to identify heterozygous positions in a matrix of genotypes.
The matrix of genotypes can be created with <code><a href="#topic+extract.gt">extract.gt</a></code>.
Because the goal was to identify heterozygotes it may be reasonable to ignore missing values by setting na_is_false to TRUE so that the resulting matrix will consist of only TRUE and FALSE.
In order to preserve missing data as missing na_is_false can be set to FALSE where if at least one allele is missing NA is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract.gt">extract.gt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_test)
gt &lt;- extract.gt(vcfR_test)
hets &lt;- is_het(gt)
# Censor non-heterozygous positions.
is.na(vcfR_test@gt[,-1][!hets]) &lt;- TRUE

</code></pre>

<hr>
<h2 id='maf'>Minor allele frequency</h2><span id='topic+maf'></span>

<h3>Description</h3>

<p>Calculate the minor (or other) allele frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maf(x, element = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maf_+3A_x">x</code></td>
<td>
<p>an object of class vcfR or chromR</p>
</td></tr>
<tr><td><code id="maf_+3A_element">element</code></td>
<td>
<p>specify the allele number to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function maf() calculates the counts and frequency for an allele.
A variant may contain more than two alleles.
Rare alleles may be true rare alleles or the result of genotyping error.
In an attempt to address these competing issues we sort the alleles by their frequency and the report statistics based on their position.
For example, setting element=1 would return information about the major (most common) allele.
Setting element=2 returns information about the second allele.
</p>


<h3>Value</h3>

<p>a matrix of four columns.
The first column is the total number of alleles, the second is the number of NA genotypes, the third is the count and fourth the frequency.
</p>

<hr>
<h2 id='masplit'>masplit</h2><span id='topic+masplit'></span>

<h3>Description</h3>

<p>Split a matrix of delimited strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>masplit(
  myMat,
  delim = ",",
  count = 0L,
  record = 1L,
  sort = 1L,
  decreasing = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="masplit_+3A_mymat">myMat</code></td>
<td>
<p>a matrix of delimited strings (e.g., &quot;7,2&quot;).</p>
</td></tr>
<tr><td><code id="masplit_+3A_delim">delim</code></td>
<td>
<p>character that delimits values.</p>
</td></tr>
<tr><td><code id="masplit_+3A_count">count</code></td>
<td>
<p>return the count of delimited records.</p>
</td></tr>
<tr><td><code id="masplit_+3A_record">record</code></td>
<td>
<p>which (1-based) record to return.</p>
</td></tr>
<tr><td><code id="masplit_+3A_sort">sort</code></td>
<td>
<p>should the records be sorted prior to selecting the element (0,1)?</p>
</td></tr>
<tr><td><code id="masplit_+3A_decreasing">decreasing</code></td>
<td>
<p>should the values be sorted decreasing (1) or increasing (0)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Split a matrix of delimited strings that represent numerics into numerics.
The parameter <strong>count</strong> returns a matrix of integers indicating how many delimited records exist in each element.
This is intended to help if you do not know how many records are in each element particularly if there is a mixture of numbers of records.
The parameter <strong>record</strong> indicates which record to return (first, second, third, ...).
The parameter <strong>sort</strong> indicates whether the records in each element should be sorted (1) or not (0) prior to selection.
When sorting has been selected <strong>decreasing</strong> indicates if the sorting should be performed in a decreasing (1) or increasing (0) manner prior to selection.
</p>


<h3>Value</h3>

<p>A numeric matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x1 &lt;- round(rnorm(n=9, mean=10, sd=2))
x2 &lt;- round(rnorm(n=9, mean=20, sd=2))
ad &lt;- matrix(paste(x1, x2, sep=","), nrow=3, ncol=3)
colnames(ad) &lt;- paste('Sample', 1:3, sep="_")
rownames(ad) &lt;- paste('Variant', 1:3, sep="_")
ad[1,1] &lt;- "9,23,12"
is.na(ad[3,1]) &lt;- TRUE

ad
masplit(ad, count = 1)
masplit(ad, sort = 0)
masplit(ad, sort = 0, record = 2)
masplit(ad, sort = 0, record = 3)
masplit(ad, sort = 1, decreasing = 0)


</code></pre>

<hr>
<h2 id='ordisample'>Ordinate a sample's data</h2><span id='topic+ordisample'></span>

<h3>Description</h3>

<p>Ordinate information from a sample's GT region and INFO column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordisample(
  x,
  sample,
  distance = "bray",
  plot = TRUE,
  alpha = 88,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordisample_+3A_x">x</code></td>
<td>
<p>an object of class vcfR or chromR.</p>
</td></tr>
<tr><td><code id="ordisample_+3A_sample">sample</code></td>
<td>
<p>a sample number where the first sample (column) is 2</p>
</td></tr>
<tr><td><code id="ordisample_+3A_distance">distance</code></td>
<td>
<p>metric to be used for ordination, options are in <code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>
</td></tr>
<tr><td><code id="ordisample_+3A_plot">plot</code></td>
<td>
<p>logical specifying whether to plot the ordination</p>
</td></tr>
<tr><td><code id="ordisample_+3A_alpha">alpha</code></td>
<td>
<p>alpha channel (transparency) ranging from 0-255</p>
</td></tr>
<tr><td><code id="ordisample_+3A_verbose">verbose</code></td>
<td>
<p>logical specifying whether to produce verbose output</p>
</td></tr>
<tr><td><code id="ordisample_+3A_...">...</code></td>
<td>
<p>parameters to be passed to child processes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The INFO column of VCF data contains descriptors for each variant.
Each sample typically includes several descriptors of each variant in the GT region as well.
This can present an overwhelming amount of information.
Ordination is used in this function to reduce this complexity.
</p>
<p>The ordination procedure can be rather time consuming depending on how much data is used.
I good recommendation  is to always start with a small subset of your full dataset and slowly scale up.
There are several steps in this function that attempt to eliminate variants or characters that have missing values in them.
This that while starting with a small number is good, you will need to have a large enough number so that a substantial amount of the data make it to the ordination step.
In the example I use 100 variants which appears to be a reasonable compromise.
</p>
<p>The data contained in VCF files can frequently contain a large fraction of missing data.
I advovate censoring data that does not meet quality control thresholds as missing which compounds the problem.
An attempt is made to omit these missing data by querying the GT and INFO data for missingness and omitting the missing variants.
The data may also include characters (columns) that contain all missing values which are omitted as well.
When verbose == TRUE these omissions are reported as messages.
</p>
<p>Some data may contain multiple values.
For example, AD is the sequence depth for each observed allele.
In these instances the values are sorted and the largest value is used.
</p>
<p>Several of the steps of this ordination make distributional assumptions.
That is, they assume the data to be normally distributed.
There is no real reason to assume this assumption to be valid with VCF data.
It has been my experience that this assumption is frequently violated with VCF data.
It is therefore suggested to use this funciton as an exploratory tool that may help inform other decisions.
These analyst may be able to address these issues through data transformation or other topics beyond the scope of this function.
This function is intended to provide a rapid assessment of the data which may help determine if more elegant handling of the data may be required.
Interpretation of the results of this function need to take into account that assumptions may have been violated.
</p>


<h3>Value</h3>

<p>A list consisting of two objects.
</p>

<ul>
<li><p> an object of class 'metaMDS' created by the function vegan::metaMDS
</p>
</li>
<li><p> an object of class 'envfit' created by the function vegan::envfit
</p>
</li></ul>

<p>This list is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+metaMDS">metaMDS</a></code>,
<code><a href="vegan.html#topic+vegdist">vegdist</a></code>,
<code><a href="vegan.html#topic+monoMDS">monoMDS</a></code>,
<code><a href="MASS.html#topic+isoMDS">isoMDS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Example of normally distributed, random data.
set.seed(9)
x1 &lt;- rnorm(500)
set.seed(99)
y1 &lt;- rnorm(500)
plot(x1, y1, pch=20, col="#8B451388", main="Normal, random, bivariate data")

data(vcfR_example)
ordisample(vcf[1:100,], sample = "P17777us22")

vars &lt;- 1:100
myOrd &lt;- ordisample(vcf[vars,], sample = "P17777us22", plot = FALSE)
names(myOrd)
plot(myOrd$metaMDS, type = "n")
points(myOrd$metaMDS, display = "sites", pch=20, col="#8B451366")
text(myOrd$metaMDS, display = "spec", col="blue")
plot(myOrd$envfit, col = "#008000", add = TRUE)
head(myOrd$metaMDS$points)
myOrd$envfit
pairs(myOrd$data1)

# Seperate heterozygotes and homozygotes.
gt &lt;- extract.gt(vcf)
hets &lt;- is_het(gt, na_is_false = FALSE)
vcfhe &lt;- vcf
vcfhe@gt[,-1][ !hets &amp; !is.na(hets)  ] &lt;- NA
vcfho &lt;- vcf
vcfho@gt[,-1][ hets &amp; !is.na(hets) ] &lt;- NA

myOrdhe &lt;- ordisample(vcfhe[vars,], sample = "P17777us22", plot = FALSE)
myOrdho &lt;- ordisample(vcfho[vars,], sample = "P17777us22", plot = FALSE)
pairs(myOrdhe$data1)
pairs(myOrdho$data1)
hist(myOrdho$data1$PL, breaks = seq(0,9000, by=100), col="#8B4513")

## End(Not run)


</code></pre>

<hr>
<h2 id='pairwise_genetic_diff'>Pairwise genetic differentiation across populations</h2><span id='topic+pairwise_genetic_diff'></span>

<h3>Description</h3>

<p><code>pairwise_genetic_diff</code> Calculate measures of genetic differentiation across all population pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_genetic_diff(vcf, pops, method = "nei")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_genetic_diff_+3A_vcf">vcf</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="pairwise_genetic_diff_+3A_pops">pops</code></td>
<td>
<p>factor indicating populations</p>
</td></tr>
<tr><td><code id="pairwise_genetic_diff_+3A_method">method</code></td>
<td>
<p>the method to measure differentiation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the pairwise population differentiation indices of interest across all pairs of populations in the population factor.
</p>


<h3>Author(s)</h3>

<p>Javier F. Tabima
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genetic_diff">genetic_diff</a></code> in  <code><a href="#topic+vcfR">vcfR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_example)
pops &lt;- as.factor(rep(c('a','b'), each = 9))
myDiff &lt;- pairwise_genetic_diff(vcf, pops, method = "nei")
colMeans(myDiff[,c(4:ncol(myDiff))], na.rm = TRUE)
pops &lt;- as.factor(rep(c('a','b','c'), each = 6))
myDiff &lt;- pairwise_genetic_diff(vcf, pops, method = "nei")
colMeans(myDiff[,c(4:ncol(myDiff))], na.rm = TRUE)

</code></pre>

<hr>
<h2 id='peak_to_ploid'>Convert allele balance peaks to ploidy</h2><span id='topic+peak_to_ploid'></span>

<h3>Description</h3>

<p>Converts allele balance data produced by <code>freq_peak()</code> to a copy number by assinging the allele balance data (frequencies) to its closest expected ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peak_to_ploid(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peak_to_ploid_+3A_x">x</code></td>
<td>
<p>an object produced by <code>freq_peak()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts allele balance data produced by <code>freq_peak()</code> to copy number.
See the examples section for a graphical representation of the expectations and the bins around them.
Once a copy number has called a distance from expectation (dfe) is calculated as a form of confidence.
The bins around different copy numbers are of different width, so the dfe is scaled by its respective bin width.
This results in a dfe that is 0 when it is exactly at our expectation (high confidence) and at 1 when it is half way between two expectations (low confidence).
</p>


<h3>Value</h3>

<p>A list consisting of two matrices containing the calls and the distance from expectation (i.e., confidence).
</p>


<h3>See Also</h3>

<p><code>freq_peak</code>, <code>freq_peak_plot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Thresholds.
plot(c(0.0, 1), c(0,1), type = "n", xaxt = "n", xlab = "Expectation", ylab = "Allele balance")
myCalls &lt;-  c(1/5, 1/4, 1/3, 1/2, 2/3, 3/4, 4/5)
axis(side = 1, at = myCalls, labels = c('1/5', '1/4', '1/3','1/2', '2/3', '3/4', '4/5'), las=2)
abline(v=myCalls)
abline(v=c(7/40, 9/40, 7/24, 5/12), lty=3, col ="#B22222")
abline(v=c(7/12, 17/24, 31/40, 33/40), lty=3, col ="#B22222")
text(x=7/40, y=0.1, labels = "7/40", srt = 90)
text(x=9/40, y=0.1, labels = "9/40", srt = 90)
text(x=7/24, y=0.1, labels = "7/24", srt = 90)
text(x=5/12, y=0.1, labels = "5/12", srt = 90)
text(x=7/12, y=0.1, labels = "7/12", srt = 90)
text(x=17/24, y=0.1, labels = "17/24", srt = 90)
text(x=31/40, y=0.1, labels = "31/40", srt = 90)
text(x=33/40, y=0.1, labels = "33/40", srt = 90)

# Prepare data and visualize
data(vcfR_example)
gt &lt;- extract.gt(vcf)
# Censor non-heterozygous positions.
hets &lt;- is_het(gt)
is.na(vcf@gt[,-1][!hets]) &lt;- TRUE
# Extract allele depths.
ad &lt;- extract.gt(vcf, element = "AD")
ad1 &lt;- masplit(ad, record = 1)
ad2 &lt;- masplit(ad, record = 2)
freq1 &lt;- ad1/(ad1+ad2)
freq2 &lt;- ad2/(ad1+ad2)
myPeaks1 &lt;- freq_peak(freq1, getPOS(vcf))
# Censor windows with fewer than 20 heterozygous positions
is.na(myPeaks1$peaks[myPeaks1$counts &lt; 20]) &lt;- TRUE
# Convert peaks to ploidy call
peak_to_ploid(myPeaks1)


</code></pre>

<hr>
<h2 id='Process+20chromR+20objects'>Process chromR object</h2><span id='topic+Process+20chromR+20objects'></span><span id='topic+proc.chromR'></span><span id='topic+regex.win'></span><span id='topic+seq2rects'></span><span id='topic+var.win'></span>

<h3>Description</h3>

<p>Functions which process chromR objects
</p>
<p>Create representation of a sequence.
Begining and end points are determined for stretches of nucleotides.
Stretches are determined by querying each nucleotides in a sequence to determine if it is represented in the database of characters (chars).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proc.chromR(x, win.size = 1000, verbose = TRUE)

regex.win(x, max.win = 1000, regex = "[acgtwsmkrybdhv]")

seq2rects(x, chars = "acgtwsmkrybdhv", lower = TRUE)

var.win(x, win.size = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Process+2B20chromR+2B20objects_+3A_x">x</code></td>
<td>
<p>object of class chromR</p>
</td></tr>
<tr><td><code id="Process+2B20chromR+2B20objects_+3A_win.size">win.size</code></td>
<td>
<p>integer indicating size for windowing processes</p>
</td></tr>
<tr><td><code id="Process+2B20chromR+2B20objects_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether verbose output should be reported</p>
</td></tr>
<tr><td><code id="Process+2B20chromR+2B20objects_+3A_max.win">max.win</code></td>
<td>
<p>maximum window size</p>
</td></tr>
<tr><td><code id="Process+2B20chromR+2B20objects_+3A_regex">regex</code></td>
<td>
<p>a regular expression to indicate nucleotides to be searched for</p>
</td></tr>
<tr><td><code id="Process+2B20chromR+2B20objects_+3A_chars">chars</code></td>
<td>
<p>a vector of characters to be used as a database for inclusion in rectangles</p>
</td></tr>
<tr><td><code id="Process+2B20chromR+2B20objects_+3A_lower">lower</code></td>
<td>
<p>converts the sequence and database to lower case, making the search case insensitive</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <strong>proc_chromR()</strong> calls helper functions to process the data present in a chromR object into summaries statistics.
</p>
<p>The function <strong>regex.win()</strong> is used to generate coordinates to define rectangles to represent regions of the chromosome containing called nucleotides (acgtwsmkrybdhv).
It is then called a second time to generate coordinates to define rectangles to represent regions called as uncalled nucleotides (n, but not gaps).
</p>
<p>The function <strong>gt2popsum</strong> is called to create summaries of the variant data.
</p>
<p>The function <strong>var.win</strong> is called to create windowized summaries of the chromR object.
</p>
<p>Each <strong>window</strong> receives a <strong>name</strong> and its coordinates.
Several attempts are made to name the windows appropriately.
First, the CHROM column of vcfR@fix is queried for a name.
Next, the label of the sequence is queried for a name.
Next, the first cell of the annotation matrix is queried.
If an appropriate name was not found in the above locations the chromR object's 'name' slot is used.
Note that the 'name' slot has a default value.
If this default value is not updated then all of your windows may receive the same name.
</p>

<hr>
<h2 id='query.gt'>Query the gt slot</h2><span id='topic+query.gt'></span><span id='topic+is.polymorphic'></span><span id='topic+is.biallelic'></span><span id='topic+is_biallelic'></span>

<h3>Description</h3>

<p>Query the 'gt' slot of objects of class vcfR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.polymorphic(x, na.omit = FALSE)

is.biallelic(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="query.gt_+3A_x">x</code></td>
<td>
<p>an object of class vcfR</p>
</td></tr>
<tr><td><code id="query.gt_+3A_na.omit">na.omit</code></td>
<td>
<p>logical to omit missing data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <strong>is_polymorphic</strong> returns a vector of logicals indicating whether a variant is polymorphic.
Only variable sites are reported in vcf files.
However, once someone manipulates a vcfR object, a site may become invariant.
For example, if a sample is removed it may result in a site becoming invariant.
This function queries the sites in a vcfR object and returns a vector of logicals (TRUE/FALSE) to indicate if they are actually variable.
</p>
<p>The function <strong>is_bialleleic</strong> returns a vector of logicals indicating whether a variant is biallelic.
Some analyses or downstream analyses only work with biallelic loci.
This function can help manage this.
</p>
<p>Note that <strong>is_bialleleic</strong> queries the ALT column in the fix slot to count alleles.
If you remove samples from the gt slot you may invalidate the information in the fix slot.
For example, if you remove the samples with the alternate allele you will make the position invariant and this function will provide inaccurate information.
So use caution if you've made many modifications to your data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract.gt">extract.gt</a></code>
</p>

<hr>
<h2 id='queryMETA'>Query the META section of VCF data</h2><span id='topic+queryMETA'></span>

<h3>Description</h3>

<p>Query the META section of VCF data for information about acronyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queryMETA(x, element = NULL, nice = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="queryMETA_+3A_x">x</code></td>
<td>
<p>an object of class vcfR or chromR.</p>
</td></tr>
<tr><td><code id="queryMETA_+3A_element">element</code></td>
<td>
<p>an acronym to search for in the META portion of the VCF data.</p>
</td></tr>
<tr><td><code id="queryMETA_+3A_nice">nice</code></td>
<td>
<p>logical indicating whether to format the data in a 'nice' manner.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The META portion of VCF data defines acronyms that are used elsewhere in the data.
In order to better understand these acronyms they should be referenced.
This function facilitates looking up of acronyms to present their relevant information.
When 'element' is 'NULL' (the default), all acronyms from the META region are returned.
When 'element' is specified an attempt is made to return information about the provided element.
The function <code>grep</code> is used to perform this query.
If 'nice' is set to FALSE then the data is presented as it was in the file.
If 'nice' is set to TRUE the data is processed to make it appear more 'nice'.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="base.html#topic+regex">regex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_test)
queryMETA(vcfR_test)
queryMETA(vcfR_test, element = "DP")


</code></pre>

<hr>
<h2 id='Ranking'>Ranking variants within windows</h2><span id='topic+Ranking'></span><span id='topic+rank.variants.chromR'></span>

<h3>Description</h3>

<p>Rank variants within windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank.variants.chromR(x, scores)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ranking_+3A_x">x</code></td>
<td>
<p>an object of class Crhom or a data.frame containing...</p>
</td></tr>
<tr><td><code id="Ranking_+3A_scores">scores</code></td>
<td>
<p>a vector of scores for each variant to be used to rank the data</p>
</td></tr>
</table>

<hr>
<h2 id='rePOS'>Create non-overlapping positions (POS) for VCF data</h2><span id='topic+rePOS'></span>

<h3>Description</h3>

<p>Converts allele balance data produced by <code>freq_peak()</code> to a copy number by assinging the allele balance data (frequencies) to its closest expected ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rePOS(x, lens, ret.lens = FALSE, buff = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rePOS_+3A_x">x</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="rePOS_+3A_lens">lens</code></td>
<td>
<p>a data.frame describing the reference</p>
</td></tr>
<tr><td><code id="rePOS_+3A_ret.lens">ret.lens</code></td>
<td>
<p>logical specifying whether lens should be returned</p>
</td></tr>
<tr><td><code id="rePOS_+3A_buff">buff</code></td>
<td>
<p>an integer indicating buffer length</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each chromosome in a genome typically begins with position one.
This creates a problem when plotting the data associated with each chromosome because the information will overlap.
This function uses the information in the data.frame <code>lens</code> to create a new coordinate system where chromosomes do not overlap.
</p>
<p>The data.frame <strong>lens</strong> should have a row for each chromosome and two columns.
The first column is the name of each chromosome as it appears in the vcfR object.
The second column is the length of each chromosome.
</p>
<p>The parameter <strong>buff</strong> indicates the length of a buffer to put in between each chromosome.
This buffer may help distinguish chromosomes from one another.
</p>
<p>In order to create the new coordinates the <code>lens</code> data.frame is updated with the new start positions.
The parameter 
</p>


<h3>Value</h3>

<p>Either a vector of integers that represent the new coordinate system or a list containing the vector of integers and the lens data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some VCF data.
data(vcfR_example)
vcf1 &lt;-vcf[1:500,]
vcf2 &lt;-vcf[500:1500,]
vcf3 &lt;- vcf[1500:2533]
vcf1@fix[,'CHROM'] &lt;- 'chrom1'
vcf2@fix[,'CHROM'] &lt;- 'chrom2'
vcf3@fix[,'CHROM'] &lt;- 'chrom3'
vcf2@fix[,'POS'] &lt;- as.character(getPOS(vcf2) - 21900)
vcf3@fix[,'POS'] &lt;- as.character(getPOS(vcf3) - 67900)
vcf &lt;- rbind2(vcf1, vcf2)
vcf &lt;- rbind2(vcf, vcf3)
rm(vcf1, vcf2, vcf3)

# Create lens
lens &lt;- data.frame(matrix(nrow=3, ncol=2))
lens[1,1] &lt;- 'chrom1'
lens[2,1] &lt;- 'chrom2'
lens[3,1] &lt;- 'chrom3'
lens[1,2] &lt;- 22000
lens[2,2] &lt;- 47000
lens[3,2] &lt;- 32089

# Illustrate the issue.
dp &lt;- extract.info(vcf, element="DP", as.numeric=TRUE)
plot(getPOS(vcf), dp, col=as.factor(getCHROM(vcf)))

# Resolve the issue.
newPOS &lt;- rePOS(vcf, lens)
dp &lt;- extract.info(vcf, element="DP", as.numeric=TRUE)
plot(newPOS, dp, col=as.factor(getCHROM(vcf)))

# Illustrate the buffer
newPOS &lt;- rePOS(vcf, lens, buff=10000)
dp &lt;- extract.info(vcf, element="DP", as.numeric=TRUE)
plot(newPOS, dp, col=as.factor(getCHROM(vcf)))


</code></pre>

<hr>
<h2 id='show+2CchromR-method'>chromR-method</h2><span id='topic+show+2CchromR-method'></span><span id='topic+chromR+2CchromR-method'></span><span id='topic+plot+2CchromR-method'></span><span id='topic+print+2CchromR-method'></span><span id='topic+head+2CchromR-method'></span><span id='topic+names+3C-+2CchromR+2Ccharacter-method'></span><span id='topic+length+2CchromR-method'></span>

<h3>Description</h3>

<p>Methods that act on objects of class chromR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'chromR'
show(object)

## S4 method for signature 'chromR'
plot(x, y, ...)

## S4 method for signature 'chromR'
print(x, y, ...)

## S4 method for signature 'chromR'
head(x, n = 6)

## S4 replacement method for signature 'chromR,character'
names(x) &lt;- value

## S4 method for signature 'chromR'
length(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2CchromR-method_+3A_object">object</code></td>
<td>
<p>an object of class chromR</p>
</td></tr>
<tr><td><code id="show+2B2CchromR-method_+3A_x">x</code></td>
<td>
<p>an object of class chromR</p>
</td></tr>
<tr><td><code id="show+2B2CchromR-method_+3A_y">y</code></td>
<td>
<p>not currently used</p>
</td></tr>
<tr><td><code id="show+2B2CchromR-method_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
<tr><td><code id="show+2B2CchromR-method_+3A_n">n</code></td>
<td>
<p>integer indicating the number of elements to be printed from an object</p>
</td></tr>
<tr><td><code id="show+2B2CchromR-method_+3A_value">value</code></td>
<td>
<p>a character containing a name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods that act on objects of class chromR.
</p>

<hr>
<h2 id='show+2CvcfR-method'>show</h2><span id='topic+show+2CvcfR-method'></span><span id='topic+head'></span><span id='topic+head+2CvcfR-method'></span><span id='topic++5B+2CvcfR+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CvcfR-method'></span><span id='topic+plot+2CvcfR-method'></span><span id='topic+rbind2+2CvcfR+2Cmissing-method'></span><span id='topic+rbind2.vcfR'></span><span id='topic+rbind2+2CvcfR+2CANY-method'></span><span id='topic+rbind2+2CvcfR+2CvcfR-method'></span><span id='topic+dim+2CvcfR-method'></span><span id='topic+dim.vcfR'></span><span id='topic+nrow+2CvcfR-method'></span><span id='topic+nrow.vcfR'></span>

<h3>Description</h3>

<p>Display a summary of a vcfR object.
</p>
<p><strong>head</strong> returns the first parts of an object of class vcfR.
</p>
<p>The brackets ('[]') subset objects of class vcfR
</p>
<p>The <strong>plot</strong> method visualizes objects of class vcfR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'vcfR'
show(object)

## S4 method for signature 'vcfR'
head(x, n = 6, maxchar = 80)

## S4 method for signature 'vcfR,ANY,ANY,ANY'
x[i, j, samples = NULL, ..., drop]

## S4 method for signature 'vcfR'
plot(x, y, ...)

## S4 method for signature 'vcfR,missing'
rbind2(x, y, ...)

## S4 method for signature 'vcfR,ANY'
rbind2(x, y, ...)

## S4 method for signature 'vcfR,vcfR'
rbind2(x, y, ...)

## S4 method for signature 'vcfR'
dim(x)

## S4 method for signature 'vcfR'
nrow(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2CvcfR-method_+3A_object">object</code></td>
<td>
<p>a vcfR object</p>
</td></tr>
<tr><td><code id="show+2B2CvcfR-method_+3A_x">x</code></td>
<td>
<p>object of class vcfR</p>
</td></tr>
<tr><td><code id="show+2B2CvcfR-method_+3A_n">n</code></td>
<td>
<p>number of rows to print</p>
</td></tr>
<tr><td><code id="show+2B2CvcfR-method_+3A_maxchar">maxchar</code></td>
<td>
<p>maximum number of characters to print per line</p>
</td></tr>
<tr><td><code id="show+2B2CvcfR-method_+3A_i">i</code></td>
<td>
<p>vector of rows (variants) to include</p>
</td></tr>
<tr><td><code id="show+2B2CvcfR-method_+3A_j">j</code></td>
<td>
<p>vector of columns (samples) to include</p>
</td></tr>
<tr><td><code id="show+2B2CvcfR-method_+3A_samples">samples</code></td>
<td>
<p>vector (numeric, character or logical) specifying samples, see details</p>
</td></tr>
<tr><td><code id="show+2B2CvcfR-method_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods</p>
</td></tr>
<tr><td><code id="show+2B2CvcfR-method_+3A_drop">drop</code></td>
<td>
<p>delete the dimensions of an array which only has one level</p>
</td></tr>
<tr><td><code id="show+2B2CvcfR-method_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method <strong>show</strong> is used to display an object.
Because vcf data are relatively large, this has been abbreviated.
Here we display the first four lines of the meta section, and truncate them to no more than 80 characters.
The first eight columns and six rows of the fix section are also displayed.
</p>
<p>The method <strong>head</strong> is similar to show, but is more flexible.
The number of rows displayed is parameterized by  the variable n.
And the maximum number of characters to print per line (row) is also parameterized.
In contract to show, head includes a summary of the gt portion of the vcfR object.
</p>
<p>The <strong>square brackets ([])</strong> are used to subset objects of class vcfR.
Rows are subset by providing a vector i to specify which rows to use.
The columns in the fix slot will not be subset by j.
The parameter j is a vector used to subset the columns of the gt slot.
Note that it is essential to include the first column here (FORMAT) or downsream processes will encounter trouble.
</p>
<p>The <strong>samples</strong> parameter allows another way to select samples.
Because the first column of the gt section is the FORMAT column you typically need to include that column and sample numbers therefore begin at two.
Use of the samples parameter allows you to select columns by a vector of numerics, logicals or characters.
When numerics are used the samples can be selected starting at one.
The function will then add one to this vector and include one to select the desired samples and the FORMAT column.
When a vector of characters is used it should contain the desired sample names.
The function will add the FORMAT column if it is not the first element.
When a vector of logicals is used a TRUE will be added to the vector to ensure the FORMAT column is selected.
Note that specification of samples will override specification of j.
</p>
<p>The <strong>plot</strong> method generates a histogram from data found in the 'QUAL' column from the 'fix' slot.
</p>

<hr>
<h2 id='VCF+20input+20and+20output'>Read and write vcf format files</h2><span id='topic+VCF+20input+20and+20output'></span><span id='topic+read.vcfR'></span><span id='topic+write.vcf'></span>

<h3>Description</h3>

<p>Read and files in the *.vcf structured text format, as well as the compressed *.vcf.gz format.
Write objects of class vcfR to *.vcf.gz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.vcfR(
  file,
  limit = 1e+07,
  nrows = -1,
  skip = 0,
  cols = NULL,
  convertNA = TRUE,
  checkFile = TRUE,
  check_keys = TRUE,
  verbose = TRUE
)

write.vcf(x, file = "", mask = FALSE, APPEND = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_file">file</code></td>
<td>
<p>A filename for a variant call format (vcf) file.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_limit">limit</code></td>
<td>
<p>amount of memory (in bytes) not to exceed when reading in a file.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_nrows">nrows</code></td>
<td>
<p>integer specifying the maximum number of rows (variants) to read in.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_skip">skip</code></td>
<td>
<p>integer specifying the number of rows (variants) to skip before beginning to read data.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_cols">cols</code></td>
<td>
<p>vector of column numbers to extract from file.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_convertna">convertNA</code></td>
<td>
<p>logical specifying to convert VCF missing data to NA.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_checkfile">checkFile</code></td>
<td>
<p>test if the first line follows the VCF specification.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_check_keys">check_keys</code></td>
<td>
<p>logical determining if <code>check_keys()</code> is called to test if INFO and FORMAT keys are unique.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_verbose">verbose</code></td>
<td>
<p>report verbose progress.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_x">x</code></td>
<td>
<p>An object of class vcfR or chromR.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_mask">mask</code></td>
<td>
<p>logical vector indicating rows to use.</p>
</td></tr>
<tr><td><code id="VCF+2B20input+2B20and+2B20output_+3A_append">APPEND</code></td>
<td>
<p>logical indicating whether to append to existing vcf file or write a new file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <strong>read.vcfR</strong> reads in files in *.vcf (text) and *.vcf.gz (gzipped text) format and returns an object of class vcfR.
The parameter 'limit' is an attempt to keep the user from trying to read in a file which contains more data than there is memory to hold.
Based on the dimensions of the data matrix, an estimate of how much memory needed is made.
If this estimate exceeds the value of 'limit' an error is thrown and execution stops.
The user may increase this limit to any value, but is encourages to compare that value to the amout of available physical memory.
</p>
<p>It is possible to input part of a VCF file by using the parameters nrows, skip and cols.
The first eight columns (the fix region) are part of the definition and will always be included.
Any columns beyond eight are optional (the gt region).
You can specify which of these columns you would like to input by setting the cols parameter.
If you want a usable vcfR object you will want to always include nine (the FORMAT column).
If you do not include column nine you may experience reduced functionality.
</p>
<p>According to the VCF specification <strong>missing data</strong> are encoded by a period (&quot;.&quot;).
Within the R language, missing data can be encoded as NA.
The parameter 'convertNA' allows the user to either retain the VCF representation or the R representation of missing data.
Note that the conversion only takes place when the entire value can be determined to be missing.
For example, &quot;.|.:48:8:51,51&quot; would be retained because the missing genotype is accompanied by other delimited information.
In contrast, &quot;.|.&quot; should be converted to NA when <code>convertNA = TRUE</code>.
</p>
<p>If file begins with http://, https://, ftp://, or ftps:// it is interpreted as a link.
When this happens, file is split on the delimiter '/' and the last element is used as the filename.
A check is performed to determine if this file exists in the working directory.
If a local file is found it is used.
If a local file is not found the remote file is downloaded to the working directory and read in.
</p>
<p>The function <strong>write.vcf</strong> takes an object of either class vcfR or chromR and writes the vcf data to a vcf.gz file (gzipped text).
If the parameter 'mask' is set to FALSE, the entire object is written to file.
If the parameter 'mask' is set to TRUE and the object is of class chromR (which has a mask slot), this mask is used to subset the data.
If an index is supplied as 'mask', then this index is used, and recycled as necessary, to subset the data.
</p>
<p>Because vcfR provides the opportunity to manipulate VCF data, it also provides the opportunity for the user to create invalid VCF files.
If there is a question regarding the validity of a file you have created one option is the <a href="https://vcftools.github.io/perl_module.html#vcf-validator">VCF validator</a> from VCF tools.
</p>


<h3>Value</h3>

<p>read.vcfR returns an object of class <code><a href="#topic+vcfR-class">vcfR-class</a></code>.
See the <strong>vignette:</strong> <code>vignette('vcf_data')</code>.
The function write.vcf creates a gzipped VCF file.
</p>


<h3>See Also</h3>

<p>CRAN:
<a href="https://cran.r-project.org/package=pegas">pegas</a>::read.vcf,
<a href="https://cran.r-project.org/package=PopGenome">PopGenome</a>::readVCF,
<a href="https://cran.r-project.org/package=data.table">data.table</a>::fread
</p>
<p>Bioconductor:
<a href="https://www.bioconductor.org/packages/release/bioc/html/VariantAnnotation.html">VariantAnnotation</a>::readVcf
</p>
<p>Use: browseVignettes('vcfR') to find examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_test)
vcfR_test
head(vcfR_test)
# CRAN requires developers to us a tempdir when writing to the filesystem.
# You may want to implement this example elsewhere.
orig_dir &lt;- getwd()
temp_dir &lt;- tempdir()
setwd( temp_dir )
write.vcf( vcfR_test, file = "vcfR_test.vcf.gz" )
vcf &lt;- read.vcfR( file = "vcfR_test.vcf.gz", verbose = FALSE )
vcf
setwd( orig_dir )


</code></pre>

<hr>
<h2 id='vcfR_example'>Example data for vcfR.</h2><span id='topic+vcfR_example'></span><span id='topic+dna'></span><span id='topic+gff'></span><span id='topic+vcf'></span>

<h3>Description</h3>

<p>An example dataset containing parts of the *Phytophthora infestans* genome.
</p>


<h3>Format</h3>

<p>A DNAbin object, a data.frame and a vcfR object
</p>


<h3>Details</h3>


<ul>
<li><p> dna DNAbin object
</p>
</li>
<li><p> gff gff format data.frame
</p>
</li>
<li><p> vcf vcfR object
</p>
</li></ul>

<p>This data is a subset of the pinfsc50 dataset.
It has been subset to positions between 500 and 600 kbp.
The coordinate systems of the vcf and gff file have been altered by subtracting 500,000.
This results in a 100 kbp section of supercontig_1.50 that has positional data ranging from 1 to 100 kbp. 
</p>
<p>Note that it is encouraged to keep package contents small to facilitate easy
downloading and installation.  This is why a mitochondrion was chosen as an
example.  In practice I've used this package on supercontigs.  This package
was designed for much larger datasets in mind than in this example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_example)




</code></pre>

<hr>
<h2 id='vcfR_test'>Test data for vcfR.</h2><span id='topic+vcfR_test'></span><span id='topic+vcf_test'></span>

<h3>Description</h3>

<p>A test file containing a diversity of examples intended to test functionality.
</p>


<h3>Format</h3>

<p>A vcfR object
</p>


<h3>Details</h3>


<ul>
<li><p> vcfR_test vcfR object
</p>
</li></ul>

<p>This data set began as the example (section 1.1) from The Variant Call Format Specification <a href="http://samtools.github.io/hts-specs/">VCFv4.3</a> .
This data consisted of 3 samples and 5 variants.
As I encounter examples that challenge the code in vcfR they can be added to this data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_test)


## Not run: 
  # When I add data it can be saved with this command.
  save(vcfR_test, file="data/vcfR_test.RData") 
  
## End(Not run)


</code></pre>

<hr>
<h2 id='vcfR-class'>vcfR class</h2><span id='topic+vcfR-class'></span>

<h3>Description</h3>

<p>An S4 class for storing VCF data.
</p>


<h3>Details</h3>

<p>Defines a class for variant call format data.
A vcfR object contains three slots.
The first slot is a character vector which holds the meta data.
The second slot holds an eight column matrix to hold the fixed data.
The third slot is a matrix which holds the genotype data.
The genotype data is optional according to the VCF definition.
When it is missing the gt slot should consist of a character matrix with zero rows and columns.
</p>
<p>See <code>vignette('vcf_data')</code> for more information.
See the <a href="http://samtools.github.io/hts-specs/">VCF specification</a> for the file specification.
</p>


<h3>Slots</h3>


<dl>
<dt><code>meta</code></dt><dd><p>character vector for the meta information</p>
</dd>
<dt><code>fix</code></dt><dd><p>matrix for the fixed information</p>
</dd>
<dt><code>gt</code></dt><dd><p>matrix for the genotype information</p>
</dd>
</dl>

<hr>
<h2 id='vcfR2DNAbin'>Convert vcfR to DNAbin</h2><span id='topic+vcfR2DNAbin'></span>

<h3>Description</h3>

<p>Convert objects of class vcfR to objects of class ape::DNAbin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcfR2DNAbin(
  x,
  extract.indels = TRUE,
  consensus = FALSE,
  extract.haps = TRUE,
  unphased_as_NA = TRUE,
  asterisk_as_del = FALSE,
  ref.seq = NULL,
  start.pos = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcfR2DNAbin_+3A_x">x</code></td>
<td>
<p>an object of class chromR or vcfR</p>
</td></tr>
<tr><td><code id="vcfR2DNAbin_+3A_extract.indels">extract.indels</code></td>
<td>
<p>logical indicating to remove indels (TRUE) or to include them while retaining alignment</p>
</td></tr>
<tr><td><code id="vcfR2DNAbin_+3A_consensus">consensus</code></td>
<td>
<p>logical, indicates whether an IUPAC ambiguity code should be used for diploid heterozygotes</p>
</td></tr>
<tr><td><code id="vcfR2DNAbin_+3A_extract.haps">extract.haps</code></td>
<td>
<p>logical specifying whether to separate each genotype into alleles based on a delimiting character</p>
</td></tr>
<tr><td><code id="vcfR2DNAbin_+3A_unphased_as_na">unphased_as_NA</code></td>
<td>
<p>logical indicating how to handle alleles in unphased genotypes</p>
</td></tr>
<tr><td><code id="vcfR2DNAbin_+3A_asterisk_as_del">asterisk_as_del</code></td>
<td>
<p>logical indicating that the asterisk allele should be converted to a deletion (TRUE) or NA (FALSE)</p>
</td></tr>
<tr><td><code id="vcfR2DNAbin_+3A_ref.seq">ref.seq</code></td>
<td>
<p>reference sequence (DNAbin) for the region being converted</p>
</td></tr>
<tr><td><code id="vcfR2DNAbin_+3A_start.pos">start.pos</code></td>
<td>
<p>chromosomal position for the start of the ref.seq</p>
</td></tr>
<tr><td><code id="vcfR2DNAbin_+3A_verbose">verbose</code></td>
<td>
<p>logical specifying whether to produce verbose output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <strong>DNAbin</strong>, from the package ape, store nucleotide sequence information.
Typically, nucleotide sequence information contains all the nucleotides within a region, for example, a gene.
Because most sites are typically invariant, this results in a large amount of redundant data.
This is why files in the vcf format only contain information on variant sites, it results in a smaller file.
Nucleotide sequences can be generated which only contain variant sites.
However, some applications require the invariant sites.
For example, inference of phylogeny based on maximum likelihood or Bayesian methods requires invariant sites.
The function vcfR2DNAbin therefore includes a number of options in attempt to accomodate various scenarios.
</p>
<p>The presence of indels (insertions or deletions)in a sequence typically presents a data analysis problem.
Mutation models typically do not accomodate this data well.
For now, the only option is for indels to be omitted from the conversion of vcfR to DNAbin objects.
The option <strong>extract.indels</strong> was included to remind us of this, and to provide a placeholder in case we wish to address this in the future.
</p>
<p>The <strong>ploidy</strong> of the samples is inferred from the first non-missing genotype.
All samples and all variants within each sample are assumed to be of the same ploid.
</p>
<p>Conversion of <strong>haploid data</strong> is fairly straight forward.
The options <code>consensus</code> and <code>extract.haps</code> are not relevant here.
When vcfR2DNAbin encounters missing data in the vcf data (NA) it is coded as an ambiguous nucleotide (n) in the DNAbin object.
When no reference sequence is provided (option <code>ref.seq</code>), a DNAbin object consisting only of variant sites is created.
When a reference sequence and a starting position are provided the entire sequence, including invariant sites, is returned.
The reference sequence is used as a starting point and variable sitees are added to this.
Because the data in the vcfR object will be using a chromosomal coordinate system, we need to tell the function where on this chromosome the reference sequence begins.
</p>
<p>Conversion of <strong>diploid data</strong> presents a number of scenarios.
When the option <code>consensus</code> is TRUE and <code>extract.haps</code> is FALSE, each genotype is split into two alleles and the two alleles are converted into their IUPAC ambiguity code.
This results in one sequence for each diploid sample.
This may be an appropriate path when you have unphased data.
Note that functions called downstream of this choice may handle IUPAC ambiguity codes in unexpected manners.
When extract.haps is set to TRUE, each genotype is split into two alleles.
These alleles are inserted into two sequences.
This results in two sequences per diploid sample.
Note that this really only makes sense if you have phased data.
The options ref.seq and start.pos are used as in halpoid data.
</p>
<p>When a variant overlaps a deletion it may be encoded by an <strong>asterisk allele (*)</strong>.
The GATK site covers this in a post on <a href="https://gatk.broadinstitute.org/hc/en-us/articles/360035531912-Spanning-or-overlapping-deletions-allele-">Spanning or overlapping deletions</a> ].
This is handled in vcfR by allowing the user to decide how it is handled with the paramenter <code>asterisk_as_del</code>.
When <code>asterisk_as_del</code> is TRUE this allele is converted into a deletion ('-').
When <code>asterisk_as_del</code> is FALSE the asterisk allele is converted to NA.
If <code>extract.indels</code> is set to FALSE it should override this decision.
</p>
<p>Conversion of <strong>polyploid data</strong> is currently not supported.
However, I have made some attempts at accomodating polyploid data.
If you have polyploid data and are interested in giving this a try, feel free.
But be prepared to scrutinize the output to make sure it appears reasonable.
</p>
<p>Creation of DNAbin objects from large chromosomal regions may result in objects which occupy large amounts of memory.
If in doubt, begin by subsetting your data and the scale up to ensure you do not run out of memory.
</p>


<h3>See Also</h3>

<p><a href="https://cran.r-project.org/package=ape">ape</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
data(vcfR_test)

# Create an example reference sequence.
nucs &lt;- c('a','c','g','t')
set.seed(9)
myRef &lt;- as.DNAbin(matrix(nucs[round(runif(n=20, min=0.5, max=4.5))], nrow=1))

# Recode the POS data for a smaller example.
set.seed(99)
vcfR_test@fix[,'POS'] &lt;- sort(sample(10:20, size=length(getPOS(vcfR_test))))

# Just vcfR
myDNA &lt;- vcfR2DNAbin(vcfR_test)
seg.sites(myDNA)
image(myDNA)

# ref.seq, no start.pos
myDNA &lt;- vcfR2DNAbin(vcfR_test, ref.seq = myRef)
seg.sites(myDNA)
image(myDNA)

# ref.seq, start.pos = 4.
# Note that this is the same as the previous example but the variants are shifted.
myDNA &lt;- vcfR2DNAbin(vcfR_test, ref.seq = myRef, start.pos = 4)
seg.sites(myDNA)
image(myDNA)

# ref.seq, no start.pos, unphased_as_NA = FALSE
myDNA &lt;- vcfR2DNAbin(vcfR_test, unphased_as_NA = FALSE, ref.seq = myRef)
seg.sites(myDNA)
image(myDNA)



</code></pre>

<hr>
<h2 id='vcfR2hapmap'>Convert a vcfR object to hapmap</h2><span id='topic+vcfR2hapmap'></span>

<h3>Description</h3>

<p>Converts a vcfR object to hapmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcfR2hapmap(vcf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcfR2hapmap_+3A_vcf">vcf</code></td>
<td>
<p>a vcfR object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a vcfR object to a hapmap format.
</p>


<h3>Value</h3>

<p>a data.frame that can be used as an input for GAPIT.
</p>


<h3>Author(s)</h3>

<p>Brian J. Knaus
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vcfR_test)
myHapMap &lt;- vcfR2hapmap(vcfR_test)
class(myHapMap)
## Not run: 
# Example of how to create a (GAPIT compliant) HapMap file.
write.table(myHapMap, 
            file = "myHapMap.hmp.txt",
            sep = "\t", 
            row.names = FALSE,
            col.names = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='vcfR2migrate'>Convert a vcfR object to MigrateN input file</h2><span id='topic+vcfR2migrate'></span>

<h3>Description</h3>

<p>The function converts a vcfR object to a text format that can be used as an infile for MigrateN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcfR2migrate(
  vcf,
  pop,
  in_pop,
  out_file = "MigrateN_infile.txt",
  method = c("N", "H")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcfR2migrate_+3A_vcf">vcf</code></td>
<td>
<p>a vcfR object.</p>
</td></tr>
<tr><td><code id="vcfR2migrate_+3A_pop">pop</code></td>
<td>
<p>factor indicating population membership for each sample.</p>
</td></tr>
<tr><td><code id="vcfR2migrate_+3A_in_pop">in_pop</code></td>
<td>
<p>vector of population names indicating which population to include in migrate output file.</p>
</td></tr>
<tr><td><code id="vcfR2migrate_+3A_out_file">out_file</code></td>
<td>
<p>name of output file.</p>
</td></tr>
<tr><td><code id="vcfR2migrate_+3A_method">method</code></td>
<td>
<p>should 'N' or 'H' format data be generated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a vcfR object to a text file which can be used as input for MigrateN.
The function will remove loci with missing data, indels, and loci that are not bialleleic (loci with more than two alleles). 
Thus, only SNP data analysed where the length of each locus (inmutational steps) is 1 (as opposed to microsatellites or indels).
</p>
<p>The output file should contain Unix line endings (&quot;\n&quot;).
Note that opening the output file in a Windows text editor (just to validate number of markers, individuals or populations) might change the end of line character (eol) to a Windows line ending (&quot;\r\n&quot;). 
This may produce an error running migrate-n.
Because these are typically non-printing characters, this may be a difficult problem to troubleshoot.
The easiest way to circumvent the problem is to transfer the output file to Unix machine and view it there.
If you do introduce Windows line endings you can convert them back to Unix with a program such as 'dos2unix' or 'fromdos' to change the line endings.
</p>


<h3>Value</h3>

<p>a text file that can be used as an input for MigrateN software (SNP format).
</p>


<h3>Author(s)</h3>

<p>Shankar Shakya and Brian J. Knaus
</p>


<h3>See Also</h3>

<p><a href="http://popgen.sc.fsu.edu/Migrate/Migrate-n.html">Migrate-N</a> website.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(vcfR_example)
my_pop &lt;- as.factor(paste("pop_", rep(c("A", "B", "C"), each = 6), sep = ""))
vcfR2migrate(vcf = vcf , pop = my_pop , in_pop = c("pop_A","pop_C"),
             out_file = "my2pop.txt", method = 'H')

## End(Not run)


</code></pre>

<hr>
<h2 id='vep'>Example data from the Variant Effect Predictor (VEP).</h2><span id='topic+vep'></span>

<h3>Description</h3>

<p>Example data to use with unit tests.
</p>


<h3>Format</h3>

<p>A vcfR object
</p>


<h3>Details</h3>


<ul>
<li><p> vep vcfR object
</p>
</li></ul>

<p>Output from the <a href="https://useast.ensembl.org/info/docs/tools/vep/index.html">VEP</a> may include values with multiple equals signs.
This does not appear to conform with the VCF specification (at the time of writing this <a href="http://samtools.github.io/hts-specs/">VCF v4.3</a>).
But it appears fairly easy to accomodate.
This example data can be used to make unit tests to validate functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vep)
vcfR2tidy(vep, info_only = TRUE)$fix


</code></pre>

<hr>
<h2 id='Windowing'>Create window summaries of data</h2><span id='topic+Windowing'></span><span id='topic+NM2winNM'></span><span id='topic+z.score'></span><span id='topic+windowize.NM'></span>

<h3>Description</h3>

<p>Create windows of non-overlapping data and summarize.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NM2winNM(x, pos, maxbp, winsize = 100L, depr = TRUE)

z.score(x)

windowize.NM(x, pos, starts, ends, summary = "mean", depr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Windowing_+3A_x">x</code></td>
<td>
<p>A NumericMatrix</p>
</td></tr>
<tr><td><code id="Windowing_+3A_pos">pos</code></td>
<td>
<p>A vector of chromosomal positions for each row of data (variants)</p>
</td></tr>
<tr><td><code id="Windowing_+3A_maxbp">maxbp</code></td>
<td>
<p>Length of chromosome</p>
</td></tr>
<tr><td><code id="Windowing_+3A_winsize">winsize</code></td>
<td>
<p>Size (in bp) for windows</p>
</td></tr>
<tr><td><code id="Windowing_+3A_depr">depr</code></td>
<td>
<p>logical (T/F), this function has been deprecated, set to FALSE to override.</p>
</td></tr>
<tr><td><code id="Windowing_+3A_starts">starts</code></td>
<td>
<p>integer vector of starting positions for windows</p>
</td></tr>
<tr><td><code id="Windowing_+3A_ends">ends</code></td>
<td>
<p>integer vector of ending positions for windows</p>
</td></tr>
<tr><td><code id="Windowing_+3A_summary">summary</code></td>
<td>
<p>string indicating type of summary (mean, median, sum)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numeric matrix where samples are in columns and variant data are in rows.
The windowing process therefore occurs along columns of data.
This matrix could be created with <code><a href="#topic+extract.gt">extract.gt</a></code>.
</p>
<p>The chromosome is expected to contain positions 1 though maxbp.
If maxbp is not specified this can be inferred from the last element in pos.
</p>

<hr>
<h2 id='write.fasta'>Create fasta format output</h2><span id='topic+write.fasta'></span>

<h3>Description</h3>

<p>Generate fasta format output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fasta(
  x,
  file = "",
  rowlength = 80,
  tolower = TRUE,
  verbose = TRUE,
  APPEND = FALSE,
  depr = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.fasta_+3A_x">x</code></td>
<td>
<p>object of class chromR</p>
</td></tr>
<tr><td><code id="write.fasta_+3A_file">file</code></td>
<td>
<p>name for output file</p>
</td></tr>
<tr><td><code id="write.fasta_+3A_rowlength">rowlength</code></td>
<td>
<p>number of characters each row should not exceed</p>
</td></tr>
<tr><td><code id="write.fasta_+3A_tolower">tolower</code></td>
<td>
<p>convert all characters to lowercase (T/F)</p>
</td></tr>
<tr><td><code id="write.fasta_+3A_verbose">verbose</code></td>
<td>
<p>should verbose output be generated (T/F)</p>
</td></tr>
<tr><td><code id="write.fasta_+3A_append">APPEND</code></td>
<td>
<p>should data be appended to an existing file (T/F)</p>
</td></tr>
<tr><td><code id="write.fasta_+3A_depr">depr</code></td>
<td>
<p>logical (T/F), this function has been deprecated, set to FALSE to override.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <strong>write_fasta</strong> takes an object of class chromR and writes it to a fasta.gz (gzipped text) format file.
The sequence in the seq slot of the chromR object is used to fill in the invariant sites.
The parameter 'tolower', when set to TRUE, converts all the characters in teh sequence to lower case.
This is important because some software, such as ape::DNAbin, requires sequences to be in lower case.
</p>

<hr>
<h2 id='write.var.info'>Write summary tables from chromR objects</h2><span id='topic+write.var.info'></span><span id='topic+write.win.info'></span>

<h3>Description</h3>

<p>Write summary tables from chromR objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.var.info(x, file = "", mask = FALSE, APPEND = FALSE)

write.win.info(x, file = "", APPEND = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.var.info_+3A_x">x</code></td>
<td>
<p>An object of class chromR</p>
</td></tr>
<tr><td><code id="write.var.info_+3A_file">file</code></td>
<td>
<p>A filename for the output file</p>
</td></tr>
<tr><td><code id="write.var.info_+3A_mask">mask</code></td>
<td>
<p>logical vector indicating rows to use</p>
</td></tr>
<tr><td><code id="write.var.info_+3A_append">APPEND</code></td>
<td>
<p>logical indicating whether to append to existing file (omitting the header) or write a new file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <strong>write.var.info</strong> takes the variant information table from a chromR object and writes it as a comma delimited file.
</p>
<p>The function <strong>write.win.info</strong> takes the window information table from a chromR object and writes it as a comma delimited file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.vcf">write.vcf</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
