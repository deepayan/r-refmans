<!DOCTYPE html><html><head><title>Help for package GPCERF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPCERF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GPCERF-package'><p>The 'GPCERF' package.</p></a></li>
<li><a href='#autoplot.cerf_gp'><p>A helper function for cerf_gp object</p></a></li>
<li><a href='#autoplot.cerf_nngp'><p>A helper function for cerf_nngp object</p></a></li>
<li><a href='#compute_deriv_nn'><p>Calculate derivatives of CERF for nnGP</p></a></li>
<li><a href='#compute_deriv_weights_gp'><p>Calculate derivatives of CERF</p></a></li>
<li><a href='#compute_inverse'><p>Compute matrix inverse for a covariate matrix</p></a></li>
<li><a href='#compute_m_sigma'><p>Compute mean, credible interval, and covariate balance in standard Gaussian</p>
process (GP)</a></li>
<li><a href='#compute_posterior_m_nn'><p>Calculate posterior means for nnGP model</p></a></li>
<li><a href='#compute_posterior_sd_nn'><p>Calculate posterior standard deviations for nnGP model</p></a></li>
<li><a href='#compute_rl_deriv_gp'><p>Detect change-point in standard GP</p></a></li>
<li><a href='#compute_rl_deriv_nn'><p>Calculate right minus left derivatives for change-point detection in nnGP</p></a></li>
<li><a href='#compute_sd_gp'><p>Compute posterior credible interval</p></a></li>
<li><a href='#compute_w_corr'><p>Compute  weighted covariate balance</p></a></li>
<li><a href='#compute_weight_gp'><p>Calculate weights for estimation of a point on CERF</p></a></li>
<li><a href='#estimate_cerf_gp'><p>Estimate the conditional exposure response function using Gaussian process</p></a></li>
<li><a href='#estimate_cerf_nngp'><p>Estimate the conditional exposure response function using nearest neighbor</p>
Gaussian process</a></li>
<li><a href='#estimate_gps'><p>Estimate a model for generalized propensity score</p></a></li>
<li><a href='#estimate_mean_sd_nn'><p>Estimate the CERF with the nnGP model</p></a></li>
<li><a href='#estimate_noise_gp'><p>Estimate the standard deviation of the nugget term in standard Gaussian</p>
process</a></li>
<li><a href='#estimate_noise_nn'><p>Estimate the standard deviation (noise) of the nugget term in nnGP</p></a></li>
<li><a href='#find_optimal_nn'><p>Find the optimal hyper-parameter for the nearest neighbor Gaussian process</p></a></li>
<li><a href='#generate_synthetic_data'><p>Generate synthetic data for the GPCERF package</p></a></li>
<li><a href='#get_logger'><p>Get logger settings</p></a></li>
<li><a href='#log_system_info'><p>Log system information</p></a></li>
<li><a href='#plot.cerf_gp'><p>Extend generic plot functions for cerf_gp class</p></a></li>
<li><a href='#plot.cerf_nngp'><p>Extend generic plot functions for cerf_nngp class</p></a></li>
<li><a href='#print.cerf_gp'><p>Extend print function for cerf_gp object</p></a></li>
<li><a href='#print.cerf_nngp'><p>Extend print function for cerf_nngp object</p></a></li>
<li><a href='#set_logger'><p>Set logger settings</p></a></li>
<li><a href='#summary.cerf_gp'><p>print summary of cerf_gp object</p></a></li>
<li><a href='#summary.cerf_nngp'><p>print summary of cerf_nngp object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Gaussian Processes for Estimating Causal Exposure Response
Curves</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Boyu Ren &lt;bren@mgb.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a non-parametric Bayesian framework based on Gaussian process priors for estimating causal effects of a continuous exposure and detecting change points in the causal exposure response curves using observational data. Ren, B., Wu, X., Braun, D., Pillai, N., &amp; Dominici, F.(2021). "Bayesian modeling for exposure response curve via gaussian processes: Causal effects of exposure to air pollution on health outcomes." arXiv preprint &lt;<a href="https://doi.org/10.48550%2FarXiv.2105.03454">doi:10.48550/arXiv.2105.03454</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/NSAPH-Software/GPCERF">https://github.com/NSAPH-Software/GPCERF</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/NSAPH-Software/GPCERF/issues">https://github.com/NSAPH-Software/GPCERF/issues</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>Harvard University</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, xgboost, stats, MASS, spatstat.geom, logger, Rcpp,
RcppArmadillo, ggplot2, cowplot, rlang, Rfast, SuperLearner,
wCorr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-15 13:52:18 UTC; Boyu</td>
</tr>
<tr>
<td>Author:</td>
<td>Naeem Khoshnevis <a href="https://orcid.org/0000-0003-4315-1426"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (HUIT),
  Boyu Ren <a href="https://orcid.org/0000-0002-5300-1184"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre] (McLean Hospital),
  Tanujit Dey <a href="https://orcid.org/0000-0001-5559-211X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (HMS),
  Danielle Braun <a href="https://orcid.org/0000-0002-5177-8598"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (HSPH)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-15 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='GPCERF-package'>The 'GPCERF' package.</h2><span id='topic+GPCERF-package'></span><span id='topic+GPCERF'></span>

<h3>Description</h3>

<p>Provides a non-parametric Bayesian framework based on Gaussian process priors
for estimating causal effects of a continuous exposure and detecting change
points in the causal exposure response curves using observational data.
</p>


<h3>Author(s)</h3>

<p>Naeem Khoshnevis
</p>
<p>Boyu Ren
</p>
<p>Danielle Braun
</p>


<h3>References</h3>

<p>Ren, B., Wu, X., Braun, D., Pillai, N. and Dominici, F., 2021. Bayesian
modeling for exposure response curve via gaussian processes: Causal effects
of exposure to air pollution on health outcomes. arXiv preprint
arXiv:2105.03454.
</p>

<hr>
<h2 id='autoplot.cerf_gp'>A helper function for cerf_gp object</h2><span id='topic+autoplot.cerf_gp'></span>

<h3>Description</h3>

<p>A helper function to plot cerf_gp object using ggplot2 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cerf_gp'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.cerf_gp_+3A_object">object</code></td>
<td>
<p>A cerf_gp object.</p>
</td></tr>
<tr><td><code id="autoplot.cerf_gp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object.
</p>

<hr>
<h2 id='autoplot.cerf_nngp'>A helper function for cerf_nngp object</h2><span id='topic+autoplot.cerf_nngp'></span>

<h3>Description</h3>

<p>A helper function to plot cerf_nngp object using ggplot2 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cerf_nngp'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.cerf_nngp_+3A_object">object</code></td>
<td>
<p>A cerf_nngp object.</p>
</td></tr>
<tr><td><code id="autoplot.cerf_nngp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object.
</p>

<hr>
<h2 id='compute_deriv_nn'>Calculate derivatives of CERF for nnGP</h2><span id='topic+compute_deriv_nn'></span>

<h3>Description</h3>

<p>Calculates the posterior mean of the derivative of CERF at a given
exposure level with nnGP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_deriv_nn(
  w,
  w_obs,
  gps_m,
  y_obs,
  hyperparam,
  n_neighbor,
  block_size,
  kernel_fn = function(x) exp(-x),
  kernel_deriv_fn = function(x) -exp(-x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_deriv_nn_+3A_w">w</code></td>
<td>
<p>A scalar of exposure level of interest.</p>
</td></tr>
<tr><td><code id="compute_deriv_nn_+3A_w_obs">w_obs</code></td>
<td>
<p>A vector of observed exposure levels of all samples.</p>
</td></tr>
<tr><td><code id="compute_deriv_nn_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FALSE</p>
</td></tr>
<tr><td><code id="compute_deriv_nn_+3A_y_obs">y_obs</code></td>
<td>
<p>A vector of observed outcome values.</p>
</td></tr>
<tr><td><code id="compute_deriv_nn_+3A_hyperparam">hyperparam</code></td>
<td>
<p>A vector of hyper-parameters in the GP model.</p>
</td></tr>
<tr><td><code id="compute_deriv_nn_+3A_n_neighbor">n_neighbor</code></td>
<td>
<p>The number of nearest neighbors on one side.</p>
</td></tr>
<tr><td><code id="compute_deriv_nn_+3A_block_size">block_size</code></td>
<td>
<p>The number of samples included in a computation block.
Mainly used to balance the speed and memory requirement. Larger
<code>block_size</code> is faster, but requires more memory.</p>
</td></tr>
<tr><td><code id="compute_deriv_nn_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function. The input is the square of
Euclidean distance.</p>
</td></tr>
<tr><td><code id="compute_deriv_nn_+3A_kernel_deriv_fn">kernel_deriv_fn</code></td>
<td>
<p>The partial derivative of the covariance function.
The input is the square of Euclidean distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar of estimated derivative of CERF at <code>w</code> in nnGP.
</p>

<hr>
<h2 id='compute_deriv_weights_gp'>Calculate derivatives of CERF</h2><span id='topic+compute_deriv_weights_gp'></span>

<h3>Description</h3>

<p>Calculates the weights assigned to each observed outcome when deriving the
posterior mean of the first derivative of CERF at a given exposure level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_deriv_weights_gp(
  w,
  w_obs,
  gps_m,
  hyperparam,
  kernel_fn = function(x) exp(-x),
  kernel_deriv_fn = function(x) -exp(-x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_deriv_weights_gp_+3A_w">w</code></td>
<td>
<p>A scalar of exposure level of interest.</p>
</td></tr>
<tr><td><code id="compute_deriv_weights_gp_+3A_w_obs">w_obs</code></td>
<td>
<p>A vector of observed exposure levels of all samples.</p>
</td></tr>
<tr><td><code id="compute_deriv_weights_gp_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FALSE</p>
</td></tr>
<tr><td><code id="compute_deriv_weights_gp_+3A_hyperparam">hyperparam</code></td>
<td>
<p>A vector of hyper-parameters in the GP model.</p>
</td></tr>
<tr><td><code id="compute_deriv_weights_gp_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function.</p>
</td></tr>
<tr><td><code id="compute_deriv_weights_gp_+3A_kernel_deriv_fn">kernel_deriv_fn</code></td>
<td>
<p>The partial derivative of the covariance function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of weights for all samples, based on which the posterior mean of
the derivative of CERF at the exposure level of interest is calculated.
</p>

<hr>
<h2 id='compute_inverse'>Compute matrix inverse for a covariate matrix</h2><span id='topic+compute_inverse'></span>

<h3>Description</h3>

<p>Computes inverse of a covariate matrix using Choleski decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_inverse(mtrx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_inverse_+3A_mtrx">mtrx</code></td>
<td>
<p>An <code>n * n</code> covariate matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that represent the inverse of the input matrix.
</p>

<hr>
<h2 id='compute_m_sigma'>Compute mean, credible interval, and covariate balance in standard Gaussian
process (GP)</h2><span id='topic+compute_m_sigma'></span>

<h3>Description</h3>

<p>Calculates the induced covariate balance associated with one hyper-parameter
configuration in standard GP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_m_sigma(
  hyperparam,
  outcome_data,
  treatment_data,
  covariates_data,
  w,
  gps_m,
  tuning,
  kernel_fn = function(x) exp(-x^2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_m_sigma_+3A_hyperparam">hyperparam</code></td>
<td>
<p>A vector of values of hyper-parameters.
</p>

<ul>
<li><p> First element: alpha
</p>
</li>
<li><p> Second element: beta
</p>
</li>
<li><p> Third element: g_sigma (gamma / sigma)
</p>
</li></ul>
</td></tr>
<tr><td><code id="compute_m_sigma_+3A_outcome_data">outcome_data</code></td>
<td>
<p>A  vector of outcome data.</p>
</td></tr>
<tr><td><code id="compute_m_sigma_+3A_treatment_data">treatment_data</code></td>
<td>
<p>A vector of treatment data.</p>
</td></tr>
<tr><td><code id="compute_m_sigma_+3A_covariates_data">covariates_data</code></td>
<td>
<p>A data frame of covariates data.</p>
</td></tr>
<tr><td><code id="compute_m_sigma_+3A_w">w</code></td>
<td>
<p>A vector of exposure levels at which the CERF is estimated.</p>
</td></tr>
<tr><td><code id="compute_m_sigma_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FLASE</p>
</td></tr>
<tr><td><code id="compute_m_sigma_+3A_tuning">tuning</code></td>
<td>
<p>The function is used for parameter tuning (default = TRUE)
or estimation (FALSE)</p>
</td></tr>
<tr><td><code id="compute_m_sigma_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function of GP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two elements:
</p>

<ul>
<li><p> A vector of absolute weighted correlation of each covariate to the
exposure, which is the metric for covariate balance
</p>
</li>
<li><p> An estimated CERF at <code>w_all</code> based on the hyper-parameter values in
<code>param</code>.
</p>
</li></ul>


<hr>
<h2 id='compute_posterior_m_nn'>Calculate posterior means for nnGP model</h2><span id='topic+compute_posterior_m_nn'></span>

<h3>Description</h3>

<p>Calculates the posterior mean of a point on the CERF based on the nnGP model.
This function also returns the weights assigned to all nearest neighbors when
calculating the posterior mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_posterior_m_nn(
  hyperparam,
  w,
  gps_w,
  obs_ord,
  y_obs_ord,
  kernel_fn = function(x) exp(-x^2),
  n_neighbor = 10,
  block_size = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_posterior_m_nn_+3A_hyperparam">hyperparam</code></td>
<td>
<p>A set of hyperparameters in the GP model.</p>
</td></tr>
<tr><td><code id="compute_posterior_m_nn_+3A_w">w</code></td>
<td>
<p>A scaler representing the exposure level for the point of interest
on the CERF.</p>
</td></tr>
<tr><td><code id="compute_posterior_m_nn_+3A_gps_w">gps_w</code></td>
<td>
<p>The GPS for all samples when their exposure levels are set
at <code>w</code>.</p>
</td></tr>
<tr><td><code id="compute_posterior_m_nn_+3A_obs_ord">obs_ord</code></td>
<td>
<p>A matrix of two columns. First column is the observed
exposure levels of all samples; second is the GPS at the observed exposure
levels. The rows are in ascending order for the first column.</p>
</td></tr>
<tr><td><code id="compute_posterior_m_nn_+3A_y_obs_ord">y_obs_ord</code></td>
<td>
<p>A vector of observed outcome values. The vector is ordered
as <code>obs_ord</code>.</p>
</td></tr>
<tr><td><code id="compute_posterior_m_nn_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function of the GP.</p>
</td></tr>
<tr><td><code id="compute_posterior_m_nn_+3A_n_neighbor">n_neighbor</code></td>
<td>
<p>The number of nearest neighbors on one side.</p>
</td></tr>
<tr><td><code id="compute_posterior_m_nn_+3A_block_size">block_size</code></td>
<td>
<p>Number of samples included in a computation block.
Mainly used to balance the speed and memory requirement.
Larger <code>block_size</code> is faster, but requires more memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TODO: The first column is the selected index and the second column is weight.
A two-column matrix. The first column is the weights assigned to each
nearest neighbor. The second column is the corresponding observed outcome
value. The weight in the last row of this matrix is NA and the observed
outcome value is the estimated posterior mean of the CERF at point <code>w</code>,
which is the weighted sum of all observed outcome values of the neighbors.
</p>

<hr>
<h2 id='compute_posterior_sd_nn'>Calculate posterior standard deviations for nnGP model</h2><span id='topic+compute_posterior_sd_nn'></span>

<h3>Description</h3>

<p>Calculates the posterior standard deviation of a point on the CERF based on
the nnGP model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_posterior_sd_nn(
  hyperparam,
  w,
  gps_w,
  obs_ord,
  sigma2,
  kernel_fn = function(x) exp(-x^2),
  n_neighbor = 10,
  block_size = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_posterior_sd_nn_+3A_hyperparam">hyperparam</code></td>
<td>
<p>The values of hyperparameters in the GP model.</p>
</td></tr>
<tr><td><code id="compute_posterior_sd_nn_+3A_w">w</code></td>
<td>
<p>The exposure level for the point of interest on the CERF.</p>
</td></tr>
<tr><td><code id="compute_posterior_sd_nn_+3A_gps_w">gps_w</code></td>
<td>
<p>The GPS for all samples when their exposure levels are set
at <code>w</code>.</p>
</td></tr>
<tr><td><code id="compute_posterior_sd_nn_+3A_obs_ord">obs_ord</code></td>
<td>
<p>A matrix of two columns. The first column is the observed
exposure levels of all samples; the second is the GPS at the observed
exposure levels. The rows are in ascending order for the first column.</p>
</td></tr>
<tr><td><code id="compute_posterior_sd_nn_+3A_sigma2">sigma2</code></td>
<td>
<p>A scaler representing <code>sigma^2</code>.</p>
</td></tr>
<tr><td><code id="compute_posterior_sd_nn_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function of the GP.</p>
</td></tr>
<tr><td><code id="compute_posterior_sd_nn_+3A_n_neighbor">n_neighbor</code></td>
<td>
<p>Number of nearest neighbors on one side.</p>
</td></tr>
<tr><td><code id="compute_posterior_sd_nn_+3A_block_size">block_size</code></td>
<td>
<p>Number of samples included in a computation block.
Mainly used to balance the speed and memory requirement.
Larger <code>block_size</code> is faster, but requires more memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The posterior standard deviation of the estimated CERF at <code>w</code>.
</p>

<hr>
<h2 id='compute_rl_deriv_gp'>Detect change-point in standard GP</h2><span id='topic+compute_rl_deriv_gp'></span>

<h3>Description</h3>

<p>Calculates the posterior mean of the difference between left- and
right-derivatives at an exposure level for the detection of change points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_rl_deriv_gp(
  w,
  w_obs,
  y_obs,
  gps_m,
  hyperparam,
  kernel_fn = function(x) exp(-x),
  kernel_deriv_fn = function(x) -exp(-x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_rl_deriv_gp_+3A_w">w</code></td>
<td>
<p>A scalar of exposure level of interest.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_gp_+3A_w_obs">w_obs</code></td>
<td>
<p>A vector of observed exposure levels of all samples.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_gp_+3A_y_obs">y_obs</code></td>
<td>
<p>A vector of observed outcome values of all samples.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_gp_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FLASE</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_gp_+3A_hyperparam">hyperparam</code></td>
<td>
<p>A vector of hyper-parameters in the GP model.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_gp_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_gp_+3A_kernel_deriv_fn">kernel_deriv_fn</code></td>
<td>
<p>The partial derivative of the covariance function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of the posterior mean of the difference between two one-sided
derivatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(847)
data &lt;- generate_synthetic_data(sample_size = 100)
gps_m &lt;- estimate_gps(cov_mt = data[,-(1:2)],
                      w_all = data$treat,
                      sl_lib = c("SL.xgboost"),
                      dnorm_log = FALSE)

wi &lt;- 8.6

val &lt;- compute_rl_deriv_gp(w = wi,
                           w_obs = data$treat,
                           y_obs = data$Y,
                           gps_m = gps_m,
                           hyperparam = c(1,1,2))

</code></pre>

<hr>
<h2 id='compute_rl_deriv_nn'>Calculate right minus left derivatives for change-point detection in nnGP</h2><span id='topic+compute_rl_deriv_nn'></span>

<h3>Description</h3>

<p>Calculates the posterior mean of the difference between left- and
right-derivatives at an exposure level for the detection of change points.
nnGP approximation is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_rl_deriv_nn(
  w,
  w_obs,
  gps_m,
  y_obs,
  hyperparam,
  n_neighbor,
  block_size,
  kernel_fn = function(x) exp(-x),
  kernel_deriv_fn = function(x) -exp(-x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_rl_deriv_nn_+3A_w">w</code></td>
<td>
<p>A scalar of exposure level of interest.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_nn_+3A_w_obs">w_obs</code></td>
<td>
<p>A vector of observed exposure levels of all samples.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_nn_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FLASE</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_nn_+3A_y_obs">y_obs</code></td>
<td>
<p>A vector of observed outcome values.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_nn_+3A_hyperparam">hyperparam</code></td>
<td>
<p>A vector of hyper-parameters in the GP model.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_nn_+3A_n_neighbor">n_neighbor</code></td>
<td>
<p>The number of nearest neighbors on one side.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_nn_+3A_block_size">block_size</code></td>
<td>
<p>The number of samples included in a computation block.
Mainly used to balance the speed and memory requirement. Larger
<code>block_size</code> is faster, but requires more memory.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_nn_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function. The input is the square of
Euclidean distance.</p>
</td></tr>
<tr><td><code id="compute_rl_deriv_nn_+3A_kernel_deriv_fn">kernel_deriv_fn</code></td>
<td>
<p>The partial derivative of the covariance function.
The input is the square of Euclidean distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of the posterior mean of the difference between two one-sided
derivatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(325)
data &lt;- generate_synthetic_data(sample_size = 200)
gps_m &lt;- estimate_gps(cov_mt = data[,-(1:2)],
                      w_all = data$treat,
                      sl_lib = c("SL.xgboost"),
                      dnorm_log = FALSE)

wi &lt;- 12.2

deriv_val &lt;- compute_rl_deriv_nn(w = wi,
                                 w_obs = data$treat,
                                 gps_m = gps_m,
                                 y_obs = data$Y,
                                 hyperparam = c(0.2,0.4,1.2),
                                 n_neighbor = 20,
                                 block_size = 10)

</code></pre>

<hr>
<h2 id='compute_sd_gp'>Compute posterior credible interval</h2><span id='topic+compute_sd_gp'></span>

<h3>Description</h3>

<p>Computes posterior credible interval for requested exposure level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_sd_gp(
  w,
  scaled_obs,
  hyperparam,
  sigma,
  gps_m,
  kernel_fn = function(x) exp(-x^2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_sd_gp_+3A_w">w</code></td>
<td>
<p>A scalar of exposure level of interest.</p>
</td></tr>
<tr><td><code id="compute_sd_gp_+3A_scaled_obs">scaled_obs</code></td>
<td>
<p>A matrix of two columns.
</p>

<ul>
<li><p> First column is the scaled GPS value of all samples (GPS * 1/sqrt(alpha))
</p>
</li>
<li><p> Second column is the scaled exposure value of all samples
(w * 1/sqrt(beta))
</p>
</li></ul>
</td></tr>
<tr><td><code id="compute_sd_gp_+3A_hyperparam">hyperparam</code></td>
<td>
<p>A vector of hyper-parameters for the GP.
</p>

<ul>
<li><p> First element: alpha
</p>
</li>
<li><p> Second element: beta
</p>
</li>
<li><p> Third element: gamma/sigma
</p>
</li></ul>
</td></tr>
<tr><td><code id="compute_sd_gp_+3A_sigma">sigma</code></td>
<td>
<p>A scaler that represents noise.</p>
</td></tr>
<tr><td><code id="compute_sd_gp_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FLASE</p>
</td></tr>
<tr><td><code id="compute_sd_gp_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function of GP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Posterior credible interval (scaler) for the requested exposure level (w).
</p>

<hr>
<h2 id='compute_w_corr'>Compute  weighted covariate balance</h2><span id='topic+compute_w_corr'></span>

<h3>Description</h3>

<p>Computes weighted covariate balance for given data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_w_corr(w, covariate, weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_w_corr_+3A_w">w</code></td>
<td>
<p>A vector of observed continuous exposure variable.</p>
</td></tr>
<tr><td><code id="compute_w_corr_+3A_covariate">covariate</code></td>
<td>
<p>A data frame of observed covariates variable.</p>
</td></tr>
<tr><td><code id="compute_w_corr_+3A_weight">weight</code></td>
<td>
<p>A vector of weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list saved the measure related to covariate balance
<code>absolute_corr</code>: the absolute correlations for each pre-exposure
covairates;
<code>mean_absolute_corr</code>: the average absolute correlations for all
pre-exposure covairates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(639)
n &lt;- 100
mydata &lt;- generate_synthetic_data(sample_size=100)
year &lt;- sample(x=c("2001","2002","2003","2004","2005"),size = n,
 replace = TRUE)
region &lt;- sample(x=c("North", "South", "East", "West"),size = n,
 replace = TRUE)
mydata$year &lt;- as.factor(year)
mydata$region &lt;- as.factor(region)
mydata$cf5 &lt;- as.factor(mydata$cf5)
cor_val &lt;- compute_w_corr(mydata[,2],
                          mydata[, 3:length(mydata)],
                          runif(n))

print(cor_val$mean_absolute_corr)

</code></pre>

<hr>
<h2 id='compute_weight_gp'>Calculate weights for estimation of a point on CERF</h2><span id='topic+compute_weight_gp'></span>

<h3>Description</h3>

<p>Calculates the weights of observed outcomes which is then used to estimate
the posterior mean of CERF at a given exposure level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_weight_gp(
  w,
  w_obs,
  scaled_obs,
  hyperparam,
  inv_sigma_obs,
  gps_m,
  est_sd = FALSE,
  kernel_fn = function(x) exp(-x^2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_weight_gp_+3A_w">w</code></td>
<td>
<p>A scalar of exposure level of interest.</p>
</td></tr>
<tr><td><code id="compute_weight_gp_+3A_w_obs">w_obs</code></td>
<td>
<p>A vector of observed exposure levels of all samples.</p>
</td></tr>
<tr><td><code id="compute_weight_gp_+3A_scaled_obs">scaled_obs</code></td>
<td>
<p>A matrix of two columns.
</p>

<ul>
<li><p> First column is the scaled GPS value of all samples
(GPS * 1 / sqrt(alpha))
</p>
</li>
<li><p> Second column is the scaled exposure value of all samples
(w * 1/sqrt(beta))
</p>
</li></ul>
</td></tr>
<tr><td><code id="compute_weight_gp_+3A_hyperparam">hyperparam</code></td>
<td>
<p>A vector of hyper-parameters for the GP.
</p>

<ul>
<li><p> First element: alpha
</p>
</li>
<li><p> Second element: beta
</p>
</li>
<li><p> Third element: gamma/sigma
</p>
</li></ul>
</td></tr>
<tr><td><code id="compute_weight_gp_+3A_inv_sigma_obs">inv_sigma_obs</code></td>
<td>
<p>Inverse of the covariance matrix between observed
samples.</p>
</td></tr>
<tr><td><code id="compute_weight_gp_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FLASE</p>
</td></tr>
<tr><td><code id="compute_weight_gp_+3A_est_sd">est_sd</code></td>
<td>
<p>Should the posterior se be computed (default=FALSE)</p>
</td></tr>
<tr><td><code id="compute_weight_gp_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function of GP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements, weight and standard deviation.
</p>

<hr>
<h2 id='estimate_cerf_gp'>Estimate the conditional exposure response function using Gaussian process</h2><span id='topic+estimate_cerf_gp'></span>

<h3>Description</h3>

<p>Estimates the conditional exposure response function (cerf) using Gaussian
Process (gp). The function tune the best match (the lowest covariate balance)
for the provided set of hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_cerf_gp(
  data,
  w,
  gps_m,
  params,
  outcome_col,
  treatment_col,
  covariates_col,
  nthread = 1,
  kernel_fn = function(x) exp(-x^2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_cerf_gp_+3A_data">data</code></td>
<td>
<p>A data.frame of observation data.</p>
</td></tr>
<tr><td><code id="estimate_cerf_gp_+3A_w">w</code></td>
<td>
<p>A vector of exposure level to compute CERF (please also see the
notes).</p>
</td></tr>
<tr><td><code id="estimate_cerf_gp_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FLASE</p>
</td></tr>
<tr><td><code id="estimate_cerf_gp_+3A_params">params</code></td>
<td>
<p>A list of parameters that is required to run the process.
These parameters include:
</p>

<ul>
<li><p> alpha: A scaling factor for the GPS value.
</p>
</li>
<li><p> beta: A scaling factor for the exposure value.
</p>
</li>
<li><p> g_sigma: A scaling factor for kernel function (gamma/sigma).
</p>
</li>
<li><p> tune_app: A tuning approach. Available approaches:
</p>

<ul>
<li><p> all: try all combinations of hyperparameters.
alpha, beta, and g_sigma can be a vector of parameters.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="estimate_cerf_gp_+3A_outcome_col">outcome_col</code></td>
<td>
<p>An outcome column name in <code>data</code>.</p>
</td></tr>
<tr><td><code id="estimate_cerf_gp_+3A_treatment_col">treatment_col</code></td>
<td>
<p>A treatment column name in <code>data</code>.</p>
</td></tr>
<tr><td><code id="estimate_cerf_gp_+3A_covariates_col">covariates_col</code></td>
<td>
<p>Covariates columns name in <code>data</code>.</p>
</td></tr>
<tr><td><code id="estimate_cerf_gp_+3A_nthread">nthread</code></td>
<td>
<p>An integer value that represents the number of threads to be
used by internal packages.</p>
</td></tr>
<tr><td><code id="estimate_cerf_gp_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>A kernel function. A default value is a Gaussian Kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cerf_gp object that includes the following values:
</p>

<ul>
<li><p> w, the vector of exposure levels.
</p>
</li>
<li><p> pst_mean, Computed mean for the w vector.
</p>
</li>
<li><p> pst_sd, Computed credible interval for the w vector.
</p>
</li></ul>



<h3>Note</h3>

<p>Please note that <code>w</code> is a vector representing a grid of exposure levels at
which the CERF is to be estimated. This grid can include both observed and
hypothetical values of the exposure variable. The purpose of defining this
grid is to provide a structured set of points across the exposure spectrum
for estimating the CERF. This approach is essential in nonparametric models
like Gaussian Processes (GPs), where the CERF is evaluated at specific points
to understand the relationship between the exposure and outcome variables
across a continuum. It facilitates a comprehensive analysis by allowing
practitioners to examine the effect of varying exposure levels, including
those not directly observed in the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(129)
data &lt;- generate_synthetic_data(sample_size = 100, gps_spec = 3)


# Estimate GPS function
gps_m &lt;- estimate_gps(cov_mt = data[,-(1:2)],
                      w_all = data$treat,
                      sl_lib = c("SL.xgboost"),
                      dnorm_log = FALSE)

# exposure values
w_all &lt;- seq(0,10,1)


cerf_gp_obj &lt;- estimate_cerf_gp(data,
                                w_all,
                                gps_m,
                                params = list(alpha = c(0.1),
                                              beta=0.2,
                                              g_sigma = 1,
                                              tune_app = "all"),
                                outcome_col = "Y",
                                treatment_col = "treat",
                                covariates_col = paste0("cf", seq(1,6)),
                                nthread = 1)


</code></pre>

<hr>
<h2 id='estimate_cerf_nngp'>Estimate the conditional exposure response function using nearest neighbor
Gaussian process</h2><span id='topic+estimate_cerf_nngp'></span>

<h3>Description</h3>

<p>Estimates the conditional exposure response function (cerf) using
the nearest neighbor (nn) Gaussian Process (gp). The function tune the best
match (the lowest covariate balance) for the provided set of hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_cerf_nngp(
  data,
  w,
  gps_m,
  params,
  outcome_col,
  treatment_col,
  covariates_col,
  kernel_fn = function(x) exp(-x^2),
  nthread = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_cerf_nngp_+3A_data">data</code></td>
<td>
<p>A data.frame of observation data.</p>
</td></tr>
<tr><td><code id="estimate_cerf_nngp_+3A_w">w</code></td>
<td>
<p>A vector of exposure level to compute CERF (please also see the
notes).</p>
</td></tr>
<tr><td><code id="estimate_cerf_nngp_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FLASE</p>
</td></tr>
<tr><td><code id="estimate_cerf_nngp_+3A_params">params</code></td>
<td>
<p>A list of parameters that is required to run the process.
These parameters include:
</p>

<ul>
<li><p> alpha: A scaling factor for the GPS value.
</p>
</li>
<li><p> beta: A scaling factor for the exposure value.
</p>
</li>
<li><p> g_sigma: A scaling factor for kernel function (gamma/sigma).
</p>
</li>
<li><p> tune_app: A tuning approach. Available approaches:
</p>

<ul>
<li><p> all: try all combinations of hyperparameters.
</p>
</li></ul>

</li>
<li><p> n_neighbor: Number of nearest neighbors on one side.
</p>
</li>
<li><p> block_size: Number of samples included in a computation block. Mainly
used to balance the speed and memory requirement. Larger <code>block_size</code>
is faster, but requires more memory.
alpha, beta, and g_sigma can be a vector of parameters.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate_cerf_nngp_+3A_outcome_col">outcome_col</code></td>
<td>
<p>An outcome column name in <code>data</code>.</p>
</td></tr>
<tr><td><code id="estimate_cerf_nngp_+3A_treatment_col">treatment_col</code></td>
<td>
<p>A treatment column name in <code>data</code>.</p>
</td></tr>
<tr><td><code id="estimate_cerf_nngp_+3A_covariates_col">covariates_col</code></td>
<td>
<p>Covariates columns name in <code>data</code>.</p>
</td></tr>
<tr><td><code id="estimate_cerf_nngp_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>A kernel function. A default value is a Gaussian Kernel.</p>
</td></tr>
<tr><td><code id="estimate_cerf_nngp_+3A_nthread">nthread</code></td>
<td>
<p>An integer value that represents the number of threads to be
used by internal packages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cerf_nngp object that includes the following values:
</p>

<ul>
<li><p> w, the vector of exposure levels.
</p>
</li>
<li><p> pst_mean, the computed mean for the w vector.
</p>
</li>
<li><p> pst_sd, the computed credible interval for the w vector.
</p>
</li></ul>



<h3>Note</h3>

<p>Please note that <code>w</code> is a vector representing a grid of exposure levels at
which the CERF is to be estimated. This grid can include both observed and
hypothetical values of the exposure variable. The purpose of defining this
grid is to provide a structured set of points across the exposure spectrum
for estimating the CERF. This approach is essential in nonparametric models
like Gaussian Processes (GPs), where the CERF is evaluated at specific points
to understand the relationship between the exposure and outcome variables
across a continuum. It facilitates a comprehensive analysis by allowing
practitioners to examine the effect of varying exposure levels, including
those not directly observed in the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(19)
data &lt;- generate_synthetic_data(sample_size = 120, gps_spec = 3)
# Estimate GPS function
gps_m &lt;- estimate_gps(cov_mt = data[,-(1:2)],
                      w_all = data$treat,
                      sl_lib = c("SL.xgboost"),
                      dnorm_log = FALSE)
# exposure values
w.all &lt;- seq(0,20,2)
cerf_nngp_obj &lt;- estimate_cerf_nngp(data,
                                    w.all,
                                    gps_m,
                                    params = list(alpha = c(0.1),
                                                  beta = 0.2,
                                                  g_sigma = 1,
                                                  tune_app = "all",
                                                  n_neighbor = 20,
                                                  block_size = 1e4),
                                    outcome_col = "Y",
                                    treatment_col = "treat",
                                    covariates_col = paste0("cf", seq(1,6)),
                                    nthread = 1)


</code></pre>

<hr>
<h2 id='estimate_gps'>Estimate a model for generalized propensity score</h2><span id='topic+estimate_gps'></span>

<h3>Description</h3>

<p>Estimates a model for generalized propensity score (GPS) using parametric
approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_gps(cov_mt, w_all, sl_lib, dnorm_log)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_gps_+3A_cov_mt">cov_mt</code></td>
<td>
<p>A covariate matrix containing all covariates. Each row is a
data sample and each column is a covariate.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_w_all">w_all</code></td>
<td>
<p>A vector of observed exposure levels.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_sl_lib">sl_lib</code></td>
<td>
<p>A vector of SuperLearner's package libraries.</p>
</td></tr>
<tr><td><code id="estimate_gps_+3A_dnorm_log">dnorm_log</code></td>
<td>
<p>Logical, if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame that includes:
</p>

<ul>
<li><p> a vector of estimated GPS at the observed exposure levels;
</p>
</li>
<li><p> a vector of estimated conditional means of exposure levels when the
covariates are fixed
at the observed values;
</p>
</li>
<li><p> estimated standard deviation of exposure levels
</p>
</li>
<li><p> a vector of observed exposure levels.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- generate_synthetic_data(sample_size = 200)
gps_m &lt;- estimate_gps(cov_mt = data[,-(1:2)],
                      w_all = data$treat,
                      sl_lib = c("SL.xgboost"),
                      dnorm_log = FALSE)

</code></pre>

<hr>
<h2 id='estimate_mean_sd_nn'>Estimate the CERF with the nnGP model</h2><span id='topic+estimate_mean_sd_nn'></span>

<h3>Description</h3>

<p>Estimates the posterior mean of the conditional exposure response function
at specified exposure levels with nnGP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_mean_sd_nn(
  hyperparam,
  sigma2,
  w_obs,
  w,
  y_obs,
  gps_m,
  kernel_fn = function(x) exp(-x^2),
  n_neighbor = 50,
  block_size = 2000,
  nthread = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_mean_sd_nn_+3A_hyperparam">hyperparam</code></td>
<td>
<p>A set of hyperparameters for the nnGP.</p>
</td></tr>
<tr><td><code id="estimate_mean_sd_nn_+3A_sigma2">sigma2</code></td>
<td>
<p>A scaler representing <code>sigma^2</code>.</p>
</td></tr>
<tr><td><code id="estimate_mean_sd_nn_+3A_w_obs">w_obs</code></td>
<td>
<p>A vector of observed exposure levels.</p>
</td></tr>
<tr><td><code id="estimate_mean_sd_nn_+3A_w">w</code></td>
<td>
<p>A vector of exposure levels at which the CERF is estimated.</p>
</td></tr>
<tr><td><code id="estimate_mean_sd_nn_+3A_y_obs">y_obs</code></td>
<td>
<p>A vector of observed outcome values.</p>
</td></tr>
<tr><td><code id="estimate_mean_sd_nn_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FLASE</p>
</td></tr>
<tr><td><code id="estimate_mean_sd_nn_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function of the GP.</p>
</td></tr>
<tr><td><code id="estimate_mean_sd_nn_+3A_n_neighbor">n_neighbor</code></td>
<td>
<p>The number of nearest neighbors on one side.</p>
</td></tr>
<tr><td><code id="estimate_mean_sd_nn_+3A_block_size">block_size</code></td>
<td>
<p>The number of samples included in a computation block.
Mainly used to balance the speed and memory requirement. Larger
<code>block_size</code> is faster, but requires more memory.</p>
</td></tr>
<tr><td><code id="estimate_mean_sd_nn_+3A_nthread">nthread</code></td>
<td>
<p>An integer value that represents the number of threads to be
used by internal packages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of returned value from <code>compute_posterior_sd_nn</code>.
</p>

<hr>
<h2 id='estimate_noise_gp'>Estimate the standard deviation of the nugget term in standard Gaussian
process</h2><span id='topic+estimate_noise_gp'></span>

<h3>Description</h3>

<p>Estimates the standard deviations of the nugget term in standard GP by
calculating the standard deviations of the residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_noise_gp(data, sigma_obs, inv_sigma_obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_noise_gp_+3A_data">data</code></td>
<td>
<p>A vector of outcome data.</p>
</td></tr>
<tr><td><code id="estimate_noise_gp_+3A_sigma_obs">sigma_obs</code></td>
<td>
<p>Covariance matrix between observed covariates.</p>
</td></tr>
<tr><td><code id="estimate_noise_gp_+3A_inv_sigma_obs">inv_sigma_obs</code></td>
<td>
<p>Inverse of the covariance matrix between observed
covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar of estimated standard deviation of the nugget term in standard GP.
</p>

<hr>
<h2 id='estimate_noise_nn'>Estimate the standard deviation (noise) of the nugget term in nnGP</h2><span id='topic+estimate_noise_nn'></span>

<h3>Description</h3>

<p>Estimates the standard deviations of the nugget term (noise) in nnGP by
calculating the standard deviations of the residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_noise_nn(
  hyperparam,
  w_obs,
  GPS_obs,
  y_obs,
  n_neighbor,
  nthread,
  kernel_fn = function(x) exp(-x^2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_noise_nn_+3A_hyperparam">hyperparam</code></td>
<td>
<p>A vector of hyper-parameter values.</p>
</td></tr>
<tr><td><code id="estimate_noise_nn_+3A_w_obs">w_obs</code></td>
<td>
<p>A vector of observed exposure levels.</p>
</td></tr>
<tr><td><code id="estimate_noise_nn_+3A_gps_obs">GPS_obs</code></td>
<td>
<p>A vector of estimated GPS evaluated at the observed exposure
levels.</p>
</td></tr>
<tr><td><code id="estimate_noise_nn_+3A_y_obs">y_obs</code></td>
<td>
<p>A vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="estimate_noise_nn_+3A_n_neighbor">n_neighbor</code></td>
<td>
<p>A number of nearest neighbors on one side.</p>
</td></tr>
<tr><td><code id="estimate_noise_nn_+3A_nthread">nthread</code></td>
<td>
<p>A number of cores used in the estimation.</p>
</td></tr>
<tr><td><code id="estimate_noise_nn_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function of the GP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar of estimated standard deviation of the nugget term in nnGP.
</p>

<hr>
<h2 id='find_optimal_nn'>Find the optimal hyper-parameter for the nearest neighbor Gaussian process</h2><span id='topic+find_optimal_nn'></span>

<h3>Description</h3>

<p>Computes covariate balance for each combination of provided hyper-parameters
and selects the hyper-parameter values that minimizes the covariate balance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_optimal_nn(
  w_obs,
  w,
  y_obs,
  gps_m,
  design_mt,
  hyperparams = expand.grid(seq(0.5, 4.5, 1), seq(0.5, 4.5, 1), seq(0.5, 4.5, 1)),
  kernel_fn = function(x) exp(-x^2),
  n_neighbor = 50,
  block_size = 2000,
  nthread = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_optimal_nn_+3A_w_obs">w_obs</code></td>
<td>
<p>A vector of the observed exposure levels.</p>
</td></tr>
<tr><td><code id="find_optimal_nn_+3A_w">w</code></td>
<td>
<p>A vector of exposure levels at which CERF will be estimated.</p>
</td></tr>
<tr><td><code id="find_optimal_nn_+3A_y_obs">y_obs</code></td>
<td>
<p>A vector of observed outcomes</p>
</td></tr>
<tr><td><code id="find_optimal_nn_+3A_gps_m">gps_m</code></td>
<td>
<p>An S3 gps object including:
gps: A data.frame of GPS vectors.
- Column 1: GPS
- Column 2: Prediction of exposure for covariate of each data sample
(e_gps_pred).
- Column 3: Standard deviation of  e_gps (e_gps_std)
used_params:
- dnorm_log: TRUE or FLASE</p>
</td></tr>
<tr><td><code id="find_optimal_nn_+3A_design_mt">design_mt</code></td>
<td>
<p>The covariate matrix of all samples (intercept excluded).</p>
</td></tr>
<tr><td><code id="find_optimal_nn_+3A_hyperparams">hyperparams</code></td>
<td>
<p>A matrix of candidate values of the hyper-parameters,
each row contains a set of values of all hyper-parameters.</p>
</td></tr>
<tr><td><code id="find_optimal_nn_+3A_kernel_fn">kernel_fn</code></td>
<td>
<p>The covariance function of the GP.</p>
</td></tr>
<tr><td><code id="find_optimal_nn_+3A_n_neighbor">n_neighbor</code></td>
<td>
<p>The number of nearest neighbors on one side.</p>
</td></tr>
<tr><td><code id="find_optimal_nn_+3A_block_size">block_size</code></td>
<td>
<p>The number of samples included in a computation block.
Mainly used to balance the speed and memory requirement. Larger
<code>block_size</code> is faster, but requires more memory.</p>
</td></tr>
<tr><td><code id="find_optimal_nn_+3A_nthread">nthread</code></td>
<td>
<p>An integer value that represents the number of threads to be
used by internal packages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated covariate balance scores for the grid of hyper-parameter values
considered in <code>hyperparams</code>.
</p>

<hr>
<h2 id='generate_synthetic_data'>Generate synthetic data for the GPCERF package</h2><span id='topic+generate_synthetic_data'></span>

<h3>Description</h3>

<p>Generates synthetic data set based on different GPS models and covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_synthetic_data(
  sample_size = 1000,
  outcome_sd = 10,
  gps_spec = 1,
  cova_spec = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_synthetic_data_+3A_sample_size">sample_size</code></td>
<td>
<p>A number of data samples.</p>
</td></tr>
<tr><td><code id="generate_synthetic_data_+3A_outcome_sd">outcome_sd</code></td>
<td>
<p>Standard deviation used to generate the outcome in the
synthetic data set.</p>
</td></tr>
<tr><td><code id="generate_synthetic_data_+3A_gps_spec">gps_spec</code></td>
<td>
<p>A numeric value (1-6) that indicates the GPS model used to
generate the continuous exposure.</p>
</td></tr>
<tr><td><code id="generate_synthetic_data_+3A_cova_spec">cova_spec</code></td>
<td>
<p>A numeric value (1-2) to modify the covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of the synthetic data. Outcome is labeled as Y, exposure as w,
and covariates cf1-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(351)
data &lt;- generate_synthetic_data(sample_size = 200)

</code></pre>

<hr>
<h2 id='get_logger'>Get logger settings</h2><span id='topic+get_logger'></span>

<h3>Description</h3>

<p>Returns current logger settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_logger()
</code></pre>


<h3>Value</h3>

<p>Returns a list that includes <strong>logger_file_path</strong> and <strong>logger_level</strong>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set_logger("mylogger.log", "INFO")
log_meta &lt;- get_logger()

</code></pre>

<hr>
<h2 id='log_system_info'>Log system information</h2><span id='topic+log_system_info'></span>

<h3>Description</h3>

<p>Logs system related information into the log file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_system_info()
</code></pre>


<h3>Value</h3>

<p>No return value. This function is called for side effects.
</p>

<hr>
<h2 id='plot.cerf_gp'>Extend generic plot functions for cerf_gp class</h2><span id='topic+plot.cerf_gp'></span>

<h3>Description</h3>

<p>A wrapper function to extend generic plot functions for cerf_gp class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cerf_gp'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cerf_gp_+3A_x">x</code></td>
<td>
<p>A cerf_gp object.</p>
</td></tr>
<tr><td><code id="plot.cerf_gp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 object, invisibly. This function is called for side
effects.
</p>

<hr>
<h2 id='plot.cerf_nngp'>Extend generic plot functions for cerf_nngp class</h2><span id='topic+plot.cerf_nngp'></span>

<h3>Description</h3>

<p>A wrapper function to extend generic plot functions for cerf_nngp class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cerf_nngp'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cerf_nngp_+3A_x">x</code></td>
<td>
<p>A cerf_nngp object.</p>
</td></tr>
<tr><td><code id="plot.cerf_nngp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 object, invisibly. This function is called for side
effects.
</p>

<hr>
<h2 id='print.cerf_gp'>Extend print function for cerf_gp object</h2><span id='topic+print.cerf_gp'></span>

<h3>Description</h3>

<p>Extend print function for cerf_gp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cerf_gp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cerf_gp_+3A_x">x</code></td>
<td>
<p>A cerf_gp object.</p>
</td></tr>
<tr><td><code id="print.cerf_gp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This function is called for side effects.
</p>

<hr>
<h2 id='print.cerf_nngp'>Extend print function for cerf_nngp object</h2><span id='topic+print.cerf_nngp'></span>

<h3>Description</h3>

<p>Extend print function for cerf_nngp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cerf_nngp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cerf_nngp_+3A_x">x</code></td>
<td>
<p>A cerf_nngp object.</p>
</td></tr>
<tr><td><code id="print.cerf_nngp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This function is called for side effects.
</p>

<hr>
<h2 id='set_logger'>Set logger settings</h2><span id='topic+set_logger'></span>

<h3>Description</h3>

<p>Updates logger settings, including log level and location of the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_logger(logger_file_path = "GPCERF.log", logger_level = "INFO")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_logger_+3A_logger_file_path">logger_file_path</code></td>
<td>
<p>A path (including file name) to log the messages.
(Default: GPCERF.log)</p>
</td></tr>
<tr><td><code id="set_logger_+3A_logger_level">logger_level</code></td>
<td>
<p>The log level. Available levels include:
</p>

<ul>
<li><p> TRACE
</p>
</li>
<li><p> DEBUG
</p>
</li>
<li><p> INFO (Default)
</p>
</li>
<li><p> SUCCESS
</p>
</li>
<li><p> WARN
</p>
</li>
<li><p> ERROR
</p>
</li>
<li><p> FATAL
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This function is called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set_logger("mylogger.log", "INFO")

</code></pre>

<hr>
<h2 id='summary.cerf_gp'>print summary of cerf_gp object</h2><span id='topic+summary.cerf_gp'></span>

<h3>Description</h3>

<p>print summary of cerf_gp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cerf_gp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cerf_gp_+3A_object">object</code></td>
<td>
<p>A cerf_gp object.</p>
</td></tr>
<tr><td><code id="summary.cerf_gp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns summary of data
</p>

<hr>
<h2 id='summary.cerf_nngp'>print summary of cerf_nngp object</h2><span id='topic+summary.cerf_nngp'></span>

<h3>Description</h3>

<p>print summary of cerf_nngp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cerf_nngp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cerf_nngp_+3A_object">object</code></td>
<td>
<p>A cerf_nngp object.</p>
</td></tr>
<tr><td><code id="summary.cerf_nngp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to customize the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns summary of data.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
