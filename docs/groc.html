<!DOCTYPE html><html><head><title>Help for package groc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {groc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cookie'><p>Near-Infrared (NIR) Spectroscopy of Biscuit Doughs</p></a></li>
<li><a href='#corrob'><p>Robust correlation measure</p></a></li>
<li><a href='#covrob'><p>Robust covariance measure</p></a></li>
<li><a href='#covRob'>
<p>Robust Covariance/Correlation Matrix Estimation</p></a></li>
<li><a href='#covRob.control'>
<p>Control Parameters for Robust Covariance Estimation</p></a></li>
<li><a href='#dcov'><p>Distance covariance matrix.</p></a></li>
<li><a href='#delete.intercept'><p>Delete intercept from model matrix</p></a></li>
<li><a href='#groc'><p>groc method</p></a></li>
<li><a href='#grocCrossval'><p>Cross-validation of groc models</p></a></li>
<li><a href='#grocfit'><p>Fitting a groc model</p></a></li>
<li><a href='#model.frame.groc'><p>Extract Information From a Fitted groc Model</p></a></li>
<li><a href='#plot.groc'><p>Plot groc objects.</p></a></li>
<li><a href='#predict.groc'><p>Predict Method for groc</p></a></li>
<li><a href='#prim7'><p>prim7 Dataset</p></a></li>
<li><a href='#summary.groc'><p>Summary and Print Methods for groc objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Regression on Orthogonal Components</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierre Lafaye De Micheaux [aut, cre],
  Martin Bilodeau [aut],
  Jiahui Wang [cph] (covRob and related functions from orphaned package
    robust),
  Ruben Zamar [cph] (covRob and related functions from orphaned package
    robust),
  Alfio Marazzi [cph] (covRob and related functions from orphaned package
    robust),
  Victor Yohai [cph] (covRob and related functions from orphaned package
    robust),
  Matias Salibian-Barrera [cph] (covRob and related functions from
    orphaned package robust),
  Ricardo Maronna [cph] (covRob and related functions from orphaned
    package robust),
  Eric Zivot [cph] (covRob and related functions from orphaned package
    robust),
  David Rocke [cph] (covRob and related functions from orphaned package
    robust),
  Doug Martin [cph] (covRob and related functions from orphaned package
    robust),
  Martin Maechler [cph] (covRob and related functions from orphaned
    package robust),
  Kjell Konis [cph] (covRob and related functions from orphaned package
    robust)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre Lafaye De Micheaux &lt;lafaye@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>pls, mgcv, robustbase, MASS</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), rrcov</td>
</tr>
<tr>
<td>Description:</td>
<td>Robust multiple or multivariate linear regression, nonparametric regression on orthogonal components, classical or robust partial least squares models as described in Bilodeau, Lafaye De Micheaux and Mahdi (2015) &lt;<a href="https://doi.org/10.18637%2Fjss.v065.i01">doi:10.18637/jss.v065.i01</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-25 04:48:14 UTC; lafaye</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-25 05:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cookie'>Near-Infrared (NIR) Spectroscopy of Biscuit Doughs</h2><span id='topic+cookie'></span>

<h3>Description</h3>

<p>This data set contains measurements from quantitative NIR spectroscopy. The example studied arises from an experiment done to test the feasibility of NIR spectroscopy to measure the composition of biscuit dough pieces (formed but unbaked biscuits). Two similar sample sets were made up, with the standard recipe varied to provide a large 
range for each of the four constituents under investigation: 
fat, sucrose, dry flour, and water. The calculated percentages 
of these four ingredients represent the 4 responses. There 
are 40 samples in the calibration or training set (with 
sample 23 being an outlier) and 
a further 32 samples in the separate prediction or validation set (with example 21 considered as an outlier). 
</p>
<p>An NIR reflectance spectrum is available for each dough 
piece. The spectral data consist of 700 points measured 
from 1100 to 2498 nanometers (nm) in steps of 2 nm. (Note: I took this
data set from the orphaned package ppls.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cookie)</code></pre>


<h3>Format</h3>

<p>A data frame of dimension 72 x 704. The first 700 columns correspond to the NIR reflectance spectrum, the last four columns correspond to the four constituents fat, sucrose, dry flour, and water. The first 40 rows correspond to the calibration data, the last 32 rows correspond to the prediction data.</p>


<h3>References</h3>

<p>Please cite the following papers if you use this data set.
</p>
<p>P.J. Brown, T. Fearn, and M. Vannucci (2001) <em>Bayesian Wavelet Regression on Curves with Applications to a Spectroscopic Calibration Problem</em>. Journal of the American Statistical Association, 96, pp. 398-408. 
</p>
<p>B.G. Osborne, T. Fearn, A.R. Miller, and S. Douglas (1984) <em>Application of Near-Infrared Reflectance Spectroscopy to Compositional Analysis of Biscuits and Biscuit Dough</em>. Journal of the Science of Food and Agriculture, 35, pp. 99 - 105.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(cookie) # load data
    X&lt;-as.matrix(cookie[,1:700]) # extract NIR spectra
    Y&lt;-as.matrix(cookie[,701:704]) # extract constituents
    Xtrain&lt;-X[1:40,] # extract training data
    Ytrain&lt;-Y[1:40,] # extract training data
    Xtest&lt;-X[41:72,] # extract test data
    Ytest&lt;-Y[41:72,] # extract test data
    </code></pre>

<hr>
<h2 id='corrob'>Robust correlation measure</h2><span id='topic+corrob'></span>

<h3>Description</h3>

<p>Compute robust estimates of the correlation between two variables using the Orthogonalized Gnanadesikan-Kettenring pairwise estimator. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrob(t, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrob_+3A_t">t</code></td>
<td>

<p>a numeric vector containing the data for the fisrt variable.
</p>
</td></tr>
<tr><td><code id="corrob_+3A_u">u</code></td>
<td>

<p>a numeric vector containing the data for the second variable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code><a href="#topic+covRob">covRob</a></code> function from the <span class="pkg">robust</span> package.
</p>


<h3>Value</h3>

<p>Value of the robust correlation.
</p>


<h3>Author(s)</h3>

<p>Martin Bilodeau (<a href="mailto:bilodeau@dms.umontreal.ca">bilodeau@dms.umontreal.ca</a>) and Pierre Lafaye de
Micheaux (<a href="mailto:lafaye@unsw.edu.au">lafaye@unsw.edu.au</a>)
</p>


<h3>References</h3>

<p>Jiahui Wang, Ruben Zamar, Alfio Marazzi, Victor Yohai, Matias
Salibian-Barrera, Ricardo Maronna, Eric Zivot, David Rocke, Doug
Martin, Martin Maechler and Kjell Konis. (2013). robust: Robust
Library. R package version 0.4-11.
<a href="https://CRAN.R-project.org/package=robust">https://CRAN.R-project.org/package=robust</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covrob">covrob</a></code>, <code><a href="#topic+dcov">dcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stackloss)
corrob(stackloss$Air.Flow,stackloss$Water.Temp)
</code></pre>

<hr>
<h2 id='covrob'>Robust covariance measure</h2><span id='topic+covrob'></span>

<h3>Description</h3>

<p>Compute robust estimates of the covariance between two variables using
the robust tau estimate of univariate scale, as proposed by Maronna and Zamar (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covrob(t, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covrob_+3A_t">t</code></td>
<td>

<p>a numeric vector containing the data for the fisrt variable.
</p>
</td></tr>
<tr><td><code id="covrob_+3A_u">u</code></td>
<td>

<p>a numeric vector containing the data for the second variable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code><a href="robustbase.html#topic+scaleTau2">scaleTau2</a></code> function from the <span class="pkg">robustbase</span> package.
</p>


<h3>Value</h3>

<p>Value of the robust covariance.
</p>


<h3>Author(s)</h3>

<p>Martin Bilodeau (<a href="mailto:bilodeau@dms.umontreal.ca">bilodeau@dms.umontreal.ca</a>) and Pierre Lafaye de
Micheaux (<a href="mailto:lafaye@unsw.edu.au">lafaye@unsw.edu.au</a>)
</p>


<h3>References</h3>

<p>Maronna, R.A. and Zamar, R.H. (2002)
Robust estimates of location and dispersion of high-dimensional datasets;
<em>Technometrics</em> <b>44</b>(4), 307&ndash;317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corrob">corrob</a></code>, <code><a href="#topic+dcov">dcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stackloss)
covrob(stackloss$Air.Flow,stackloss$Water.Temp)
</code></pre>

<hr>
<h2 id='covRob'>
Robust Covariance/Correlation Matrix Estimation
</h2><span id='topic+covRob'></span>

<h3>Description</h3>

<p>Compute robust estimates of multivariate location and scatter. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covRob(data, corr = FALSE, distance = TRUE, na.action = na.fail,
       estim = "auto", control = covRob.control(estim, ...), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covRob_+3A_data">data</code></td>
<td>
<p>a numeric matrix or data frame containing the data.</p>
</td></tr>
<tr><td><code id="covRob_+3A_corr">corr</code></td>
<td>
<p>a logical flag. If <code>corr = TRUE</code> then the estimated correlation matrix is computed.</p>
</td></tr>
<tr><td><code id="covRob_+3A_distance">distance</code></td>
<td>
<p>a logical flag. If <code>distance = TRUE</code> the squared Mahalanobis distances are computed.</p>
</td></tr>
<tr><td><code id="covRob_+3A_na.action">na.action</code></td>
<td>
<p>a function to filter missing data. The default <code>na.fail</code> produces an error if missing values are present. An alternative is <code>na.omit</code> which deletes observations that contain one or more missing values.</p>
</td></tr>
<tr><td><code id="covRob_+3A_estim">estim</code></td>
<td>
<p>a character string specifying the robust estimator to be used. The choices are: &quot;mcd&quot; for the Fast MCD algorithm of Rousseeuw and Van Driessen, &quot;weighted&quot; for the Reweighted MCD, &quot;donostah&quot; for the Donoho-Stahel projection based estimator, &quot;M&quot; for the constrained M estimator provided by Rocke, &quot;pairwiseQC&quot; for the orthogonalized quadrant correlation pairwise estimator, and &quot;pairwiseGK&quot; for the Orthogonalized Gnanadesikan-Kettenring pairwise estimator. The default &quot;auto&quot; selects from &quot;donostah&quot;, &quot;mcd&quot;, and &quot;pairwiseQC&quot; with the goal of producing a good estimate in a reasonable amount of time.</p>
</td></tr>
<tr><td><code id="covRob_+3A_control">control</code></td>
<td>
<p>a list of control parameters to be used in the numerical algorithms. See <code>covRob.control</code> for the possible control parameters and their default settings. This argument is ignored when <code>estim = "auto"</code>.</p>
</td></tr>
<tr><td><code id="covRob_+3A_...">...</code></td>
<td>
<p>control parameters may be passed directly when <code>estim != "auto"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This
function was part of the 'robust' package and it has been copied to the
current package due to an ORPHANED Maintainer.
</p>
<p>The <code>covRob</code> function selects a robust covariance estimator that is likely to provide a <em>good</em> estimate in a reasonable amount of time. Presently this selection is based on the problem size. The Donoho-Stahel estimator is used if there are less than 1000 observations and less than 10 variables or less than 5000 observations and less than 5 variables. If there are less than 50000 observations and less than 20 variables then the MCD is used. For larger problems, the Orthogonalized Quadrant Correlation estimator is used.
</p>
<p>The MCD and Reweighted-MCD estimates (<code>estim = "mcd"</code> and <code>estim = "weighted"</code> respectively) are computed using the <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> function in the robustbase package. By default, <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> returns the reweighted estimate; the actual MCD estimate is contained in the components of the output list prefixed with <code>raw</code>.
</p>
<p>The M estimate (<code>estim = "M"</code>) is computed using the <code><a href="rrcov.html#topic+covMest">covMest</a></code> function in the rrcov package. For historical reasons the Robust Library uses the MCD to compute the initial estimate.
</p>
<p>The Donoho-Stahel (<code>estim = "donostah"</code>) estimator is computed using the <code><a href="rrcov.html#topic+CovSde">CovSde</a></code> function provided in the rrcov package.
</p>
<p>The pairwise estimators (<code>estim = "pairwisegk"</code> and <code>estim = "pairwiseqc"</code>) are computed using the <code><a href="rrcov.html#topic+CovOgk">CovOgk</a></code> function in the rrcov package.
</p>


<h3>Value</h3>

<p>an object of class &quot;<code>covRob</code>&quot; with components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>an image of the call that produced the object with all the arguments named.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>a numeric matrix containing the final robust estimate of the covariance/correlation matrix.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>a numeric vector containing the final robust estimate of the location vector.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>a numeric vector containing the squared Mahalanobis distances computed using robust estimates of covariance and location contained in <code>cov</code> and <code>center</code>. If <code>distance = FALSE</code> this element will me missing.</p>
</td></tr>
<tr><td><code>raw.cov</code></td>
<td>
<p>a numeric matrix containing the initial robust estimate of the covariance/correlation matrix. If there is no initial robust estimate then this element is set to <code>NA</code>.</p>
</td></tr>
<tr><td><code>raw.center</code></td>
<td>
<p>a numeric vector containing the initial robust estimate of the location vector. If there is no initial robust estimate then this element is set to <code>NA</code>.</p>
</td></tr>
<tr><td><code>raw.dist</code></td>
<td>
<p>a numeric vector containing the squared Mahalanobis distances computed using the initial robust estimates of covariance and location contained in <code>raw.cov</code> and <code>raw.center</code>. If <code>distance = FALSE</code> or if there is no initial robust estimate then this element is set to <code>NA</code>.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>a logical flag. If <code>corr = TRUE</code> then <code>cov</code> and <code>raw.cov</code> contain robust estimates of the correlation matrix of <code>data</code>.</p>
</td></tr>
<tr><td><code>estim</code></td>
<td>
<p>a character string containing the name of the robust estimator.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a list containing the control parameters used by the robust estimator.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Version 0.3-8 of the Robust Library: all of the functions origianlly contributed by the S-Plus Robust Library have been replaced by dependencies on the robustbase and rrcov packages. Computed results may differ from earlier versions of the Robust Library. In particular, the MCD estimators are now adjusted by a small sample size correction factor. Additionally, a bug was fixed where the final MCD covariance estimate produced with <code>estim = "mcd"</code> was not rescaled for consistency.
</p>


<h3>References</h3>

<p>R. A. Maronna and V. J. Yohai (1995) The Behavior of the Stahel-Donoho Robust Multivariate Estimator. <em>Journal of the American Statistical Association</em> <b>90</b> (429), 330&ndash;341.
</p>
<p>P. J. Rousseeuw and K. van Driessen (1999) A fast algorithm for the minimum covariance determinant estimator. <em>Technometrics</em> <b>41</b>, 212&ndash;223.
</p>
<p>D. L. Woodruff and D. M. Rocke (1994) Computable robust estimation of multivariate location and shape on high dimension using compound estimators. <em>Journal of the American Statistical Association</em>, <b>89</b>, 888&ndash;896.
</p>
<p>R. A. Maronna and R. H. Zamar (2002) Robust estimates of location and dispersion of high-dimensional datasets. <em>Technometrics</em> <b>44</b> (4), 307&ndash;317.
</p>

<hr>
<h2 id='covRob.control'>
Control Parameters for Robust Covariance Estimation
</h2><span id='topic+covRob.control'></span>

<h3>Description</h3>

<p>This function is used to create a list of control parameters for the underlying robust estimator used in the <code>covRob</code> function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  covRob.control(estim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covRob.control_+3A_estim">estim</code></td>
<td>
<p>a character vector of length one giving the name of the estimator to generate the control parameters for.</p>
</td></tr>
<tr><td><code id="covRob.control_+3A_...">...</code></td>
<td>
<p>control parameters appropriate for the robust estimator specified in <code>estim</code> in the form <code>name = value</code> and separated by commas.  Omitted parameters receive their default values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was part of the 'robust' package and it has been copied to the
current package due to an ORPHANED Maintainer.
</p>
<p>The control parameters are estimator specific.  Information on the control parameters (and their default values) can be found in the help files of each of the robust covariance estimators.
</p>


<h3>Value</h3>

<p>a list of control parameters appropriate for the robust estimator given in <code>estim</code>.  The value of <code>estim</code> occupies the first element of the list.</p>


<h3>See Also</h3>

<p>This function is a utility function for <code><a href="#topic+covRob">covRob</a></code>.&lt;br&gt;
</p>
<p>The underlying robust estimators are: <code><a href="rrcov.html#topic+CovSde">CovSde</a></code>, <code><a href="robustbase.html#topic+covMcd">covMcd</a></code> and <code><a href="rrcov.html#topic+CovOgk">CovOgk</a></code>.  Power-users should consider calling these functions directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  mcd.control &lt;- covRob.control("mcd", quan = 0.75, ntrial = 1000)

  ds.control &lt;- covRob.control("donostah", prob = 0.95)

  qc.control &lt;- covRob.control("pairwiseqc")
</code></pre>

<hr>
<h2 id='dcov'>Distance covariance matrix.
</h2><span id='topic+dcov'></span>

<h3>Description</h3>

<p>Compute the distance covariance measure of Szekely, Rizzo, and Bakirov
(2007) between two samples. Warning: Only valid to compute the distance
covariance for two random variables X and Y. This means that X and Y
cannot be random Vectors. If this is the case, consider the package <span class="pkg">energy</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcov(x, y, Cpp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcov_+3A_x">x</code></td>
<td>

<p>data of first sample
</p>
</td></tr>
<tr><td><code id="dcov_+3A_y">y</code></td>
<td>

<p>data of second sample
</p>
</td></tr>
<tr><td><code id="dcov_+3A_cpp">Cpp</code></td>
<td>

<p>logical. If TRUE (the default), computations are performed using a C version of the code.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <span class="pkg">energy</span>.
</p>


<h3>Value</h3>

<p>returns the sample distance covariance.
</p>


<h3>Author(s)</h3>

<p>Martin Bilodeau (<a href="mailto:bilodeau@dms.umontreal.ca">bilodeau@dms.umontreal.ca</a>) and Pierre Lafaye de
Micheaux (<a href="mailto:lafaye@unsw.edu.au">lafaye@unsw.edu.au</a>)
</p>


<h3>References</h3>

<p>Szekely, G.J., Rizzo, M.L., and Bakirov, N.K. (2007), 
Measuring and Testing Dependence by Correlation of Distances, 
<em>Annals of Statistics</em>, Vol. 35 No. 6, pp. 2769-2794.
<br /> <a href="https://doi.org/10.1214/009053607000000505">doi:10.1214/009053607000000505</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covrob">covrob</a></code>, <code><a href="#topic+corrob">corrob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stackloss)
dcov(stackloss$Air.Flow,stackloss$Water.Temp)
</code></pre>

<hr>
<h2 id='delete.intercept'>Delete intercept from model matrix</h2><span id='topic+delete.intercept'></span>

<h3>Description</h3>

<p>A utility function to delete any intercept column from a model matrix,
and adjust the <code>"assign"</code> attribute correspondingly.  It is used
by formula handling functions like <code>mvr</code> and <code>model.matrix.mvr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.intercept(mm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete.intercept_+3A_mm">mm</code></td>
<td>
<p>Model matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model matrix without intercept column.
</p>


<h3>Author(s)</h3>

<p>Bjorn-Helge Mevik and Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+mvr">mvr</a></code>, <code>model.matrix.mvr</code></p>

<hr>
<h2 id='groc'>groc method</h2><span id='topic+groc'></span><span id='topic+groc.default'></span>

<h3>Description</h3>

<p>Generalized regression on orthogonal components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
groc(formula, ncomp, data, subset, na.action, plsrob =
                 FALSE, method = c("lm", "lo", "s", "lts"), D = NULL,
                 gamma = 0.75, Nc = 10, Ng = 20, scale = FALSE, Cpp =
                 TRUE, model = TRUE, x = FALSE, y = FALSE, sp = NULL, ...)
groc(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groc_+3A_formula">formula</code></td>
<td>
<p>a model formula.  Most of the <code>lm</code> formula
constructs are supported.  See below.</p>
</td></tr>
<tr><td><code id="groc_+3A_ncomp">ncomp</code></td>
<td>
<p>the number of components (orthogonal components) to include in the model.</p>
</td></tr>
<tr><td><code id="groc_+3A_data">data</code></td>
<td>
<p>an optional data frame with the data to fit the model from.</p>
</td></tr>
<tr><td><code id="groc_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="groc_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain missing values.</p>
</td></tr>
<tr><td><code id="groc_+3A_plsrob">plsrob</code></td>
<td>
<p>logical. If <code>TRUE</code>, we use the <code>D=covrob</code> measure of
dependence with the least trimmed squares method=&quot;lts&quot;.</p>
</td></tr>
<tr><td><code id="groc_+3A_method">method</code></td>
<td>
<p>character giving the name of the method to use. The
user can supply his own function. The methods available are linear
models, &quot;lm&quot;, local polynomials, &quot;lo&quot;, smoothing splines, &quot;s&quot;, and least trimmed squares, &quot;lts&quot;.</p>
</td></tr>
<tr><td><code id="groc_+3A_d">D</code></td>
<td>
<p>function with two arguments, each one being a vector, which
measures the dependence between two variables using n observations from them. If <code>NULL</code>, the covariance measure will be used. The user can supply his own function.</p>
</td></tr>
<tr><td><code id="groc_+3A_gamma">gamma</code></td>
<td>
<p>parameter used with the option <code>plsrob=TRUE</code>. It defines the quantile used to compute the &quot;lts&quot; regression. The default <code>gamma=0.75</code> gives a breakdown of 25% for a good compromise between robustness and efficiency. The value <code>gamma=0.5</code> gives the maximal breakdown of 50%.</p>
</td></tr>
<tr><td><code id="groc_+3A_nc">Nc</code></td>
<td>
<p>Integer, Number of cycles in the grid algorithm.</p>
</td></tr>
<tr><td><code id="groc_+3A_ng">Ng</code></td>
<td>
<p>Integer, Number of points for the grid in the grid algorithm.</p>
</td></tr>
<tr><td><code id="groc_+3A_scale">scale</code></td>
<td>
<p>Logical, Should we scale the data.</p>
</td></tr>
<tr><td><code id="groc_+3A_cpp">Cpp</code></td>
<td>
<p>Logical, if <code>TRUE</code> this function will use a C++
implementation of the grid algorithm. The <code>FALSE</code> value should not be
used, unless to get a better understanding of the grid algorithm
or to compare the speed of computation between R and C++ versions of
this algorithm</p>
</td></tr>
<tr><td><code id="groc_+3A_model">model</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="groc_+3A_x">x</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="groc_+3A_y">y</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, the response is returned.</p>
</td></tr>
<tr><td><code id="groc_+3A_sp">sp</code></td>
<td>

<p>A vector of smoothing parameters can be provided here.
Smoothing parameters must be supplied in the order that the
smooth terms appear in the model formula. Negative elements
indicate that the parameter should be estimated, and hence a
mixture of fixed and estimated parameters is
possible. 'length(sp)' should be equal to 'ncomp' and
corresponds 
to the number of underlying smoothing parameters.
</p>
</td></tr>
<tr><td><code id="groc_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Y</code></td>
<td>
<p>vector or matrix of responses.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>an array of fitted values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>a matrix of orthogonal components (scores). Each column corresponds to a component.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>a matrix of directions (loadings). Each column is a direction used to obtain the corresponding component (scores).</p>
</td></tr>
<tr><td><code>Gobjects</code></td>
<td>
<p>contain the objects produced by the fit of the responses on the orthogonal components.</p>
</td></tr>
<tr><td><code>Hobjects</code></td>
<td>
<p>contain the objects produced by the &quot;lts&quot; fit of each deflated predictors on the orthogonal components. <code>Hobjects</code> are produced when <code>plsrob=TRUE</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>matrix of coefficients produced by the &quot;lm&quot; fit of  each deflated predictors on the last component. <code>B</code> is produced when <code>plsrob=FALSE</code>.</p>
</td></tr>
<tr><td><code>Xmeans</code></td>
<td>
<p>a vector of means of the X variables.</p>
</td></tr>
<tr><td><code>Ymeans</code></td>
<td>
<p>a vector of means of the Y variables.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dependence measure used.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>a matrix whose columns contain the right singular vectors of
the data. Computed in the preprocessing to principal component scores when the number of
observations is less than the number of predictors.</p>
</td></tr>
<tr><td><code>dnnames</code></td>
<td>
<p>dimnames of 'fitted.values'</p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
<p>the number of components used in the modelling.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>Logical. <code>TRUE</code> if the responses have been scaled.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the model terms.</p>
</td></tr>
<tr><td><code>plsrob</code></td>
<td>
<p>Logical. If <code>plsrob=TRUE</code>, a robust partial least squares fit.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if <code>model=TRUE</code>, the model frame.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Bilodeau (<a href="mailto:bilodeau@dms.umontreal.ca">bilodeau@dms.umontreal.ca</a>) and Pierre Lafaye de Micheaux (<a href="mailto:lafaye@unsw.edu.au">lafaye@unsw.edu.au</a>) and
Smail Mahdi (<a href="mailto:smail.mahdi@cavehill.uwi.edu">smail.mahdi@cavehill.uwi.edu</a>)
</p>


<h3>References</h3>

<p>Martin Bilodeau, Pierre Lafaye de Micheaux, Smail Mahdi (2015), The R
Package groc for Generalized Regression on Orthogonal Components,
<em>Journal of Statistical Software</em>, 65(1), 1-29, <br /> <a href="https://www.jstatsoft.org/v65/i01/">https://www.jstatsoft.org/v65/i01/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(MASS)
########################
# Codes for Example 1  #
########################
require("groc")
data("wood")
out &lt;- groc(y ~ x1 + x2 + x3 + x4 + x5, ncomp = 1, data = wood, 
             D = corrob, method = "lts")
corrob(wood$y, fitted(out)) ^ 2
plot(out)

########################
# Codes for Example 2  #
########################
data("trees")
out &lt;- groc(Volume ~ Height + Girth, ncomp = 1, D = spearman, 
             method = "s", data = trees)
cor(trees$Volume, fitted(out)) ^ 2
plot(out$T, trees$Volume, xlab = "First component",
     ylab = "Volume", pch = 20)
lines(sort(out$T), fitted(out)[order(out$T)])
out &lt;- boxcox(Volume ~ Height + Girth, data = trees, 
              lambda = seq(-0.5, 0.5, length = 100), plotit = FALSE)
lambda &lt;- out$x[which.max(out$y)]
out &lt;- lm(Volume ^ lambda ~ Height + Girth, data = trees)
cor(trees$Volume, fitted(out)^(1/lambda)) ^ 2

########################
# Codes for Example 3  #
########################
data("wood")
plsr.out &lt;- plsr(y ~ x1 + x2 + x3 + x4 + x5, data = wood)
groc.out &lt;- groc(y ~ x1 + x2 + x3 + x4 + x5, data = wood)
apply(abs((fitted(plsr.out) - fitted(groc.out)) / 
          fitted(plsr.out)), 3, max) * 100

########################
# Codes for Example 4  #
########################
set.seed(1)
n &lt;- 200
x1 &lt;- runif(n, -1, 1)
x2 &lt;- runif(n, -1, 1)
y &lt;- x1 * x2 + rnorm(n, 0, sqrt(.04))
data &lt;- data.frame(x1 = x1, x2 = x2, y = y)
plsr.out &lt;- plsr(y ~ x1 + x2, data = data)
groc.out &lt;- groc(y ~ x1 + x2, D = dcov, method = "s", data = data)
plsr.v &lt;- crossval(plsr.out, segment.type = "consecutive")
groc.v &lt;- grocCrossval(groc.out, segment.type = "consecutive")
groc.v$validation$PRESS
plsr.v$validation$PRESS
gam.data &lt;- data.frame(y = y, t1 = groc.out$T[, 1], t2 = groc.out$T[, 2])
gam.out &lt;- gam(y ~ s(t1) + s(t2), data = gam.data)
par(mfrow = c(1, 2))
plot(gam.out)
par(mfrow = c(1, 1))
PRESS &lt;- 0
for(i in 1 : 10){
  data.in &lt;- data[-(((i - 1) * 20 + 1) : (i * 20)), ]
  data.out &lt;- data[((i - 1) * 20 + 1) : (i * 20), ]
  ppr.out &lt;- ppr(y ~ x1 + x2, nterms = 2, optlevel = 3, data = data.in)
  PRESS &lt;- PRESS + sum((predict(ppr.out, newdata = data.out)-data.out$y) ^ 2)
}
PRESS

########################
# Codes for Example 5  #
########################
data("yarn")
dim(yarn$NIR)
n &lt;- nrow(yarn)
system.time(plsr.out &lt;- plsr(density ~ NIR, ncomp = n - 2, data = yarn))
system.time(groc.out &lt;- groc(density ~ NIR, Nc = 20, ncomp = n - 2, data = yarn))
max(abs((fitted(plsr.out) - fitted(groc.out)) / fitted(plsr.out))) * 100
plsr.v &lt;- crossval(plsr.out, segments = n, trace = FALSE)
plsr.v$validation$PRESS
groc.v &lt;- grocCrossval(groc.out, segments = n, trace = FALSE)
groc.v$validation$PRESS
groc.v$validation$PREMAD

########################
# Codes for Example 6  #
########################
data("prim7")
prim7.out &lt;- groc(X1 ~ ., ncomp = 3, D = dcov, method = "s", data = prim7)
prim7.out$R
pca &lt;- princomp(~ ., data = as.data.frame(prim7[, -1]))
prim7.pca &lt;- data.frame(X1 = prim7$X1, scores = pca$scores)
prim7.pca.out &lt;- groc(X1 ~ ., ncomp = 3, D = dcov, method = "s", 
                       data = prim7.pca)
pca$loadings 
groc.v &lt;- grocCrossval(prim7.out, segment.type = "consecutive")
groc.v$validation$PRESS
plsr.out &lt;- plsr(X1 ~ ., ncomp = 3, data = prim7)
plsr.v &lt;- crossval(plsr.out, segment.type = "consecutive")
plsr.v$validation$PRESS
PRESS &lt;- 0
for(i in 1 : 10){
  data.in &lt;- prim7[-(((i - 1) * 50 + 1) : (i * 50)), ]
  data.out &lt;- prim7[((i - 1) * 50 + 1) : (i * 50), ]
  ppr.out &lt;- ppr(X1 ~ ., nterms = 3, optlevel = 3, data = data.in)
  PRESS &lt;- PRESS + sum((predict(ppr.out, newdata = data.out) - data.out$X1) ^ 2)
}
PRESS

########################
# Codes for Example 7  #
########################
n &lt;- 50 ; B &lt;- 30
mat.cor &lt;- matrix(0, nrow = B, ncol = 3) ; mat.time &lt;- matrix(0, nrow = B, ncol = 3)
for (i in 1:B) {
 X &lt;- matrix(runif(n * 5, -1, 1), ncol = 5)
 A &lt;- matrix(runif(n * 50, -1, 1), nrow = 5)
 y &lt;- (X[,1] + X[,2])^2 + (X[,1] + 5 * X[,2])^2 + rnorm(n)
 X &lt;- cbind(X, X 
 D &lt;- data.frame(X = X, y = y)
 mat.time[i,1] &lt;- system.time(out1 &lt;- plsr(y ~ X, , ncomp = 2, data = D))[1]
 mat.time[i,2] &lt;- system.time(out2 &lt;- ppr(y ~ X, , nterms = 2, data = D))[1]
 mat.time[i,3] &lt;- system.time(out3 &lt;- groc(y ~ X, D = dcov, method = "s", ncomp = 2, data = D))[1]
 mat.cor[i,] &lt;- cor(y, cbind(fitted(out1)[,,2], fitted(out2), fitted(out3)[,,2]))
}
colMeans(mat.cor)
colMeans(mat.time)

########################
# Codes for Example 8  #
########################
data("oliveoil")
n &lt;- nrow(oliveoil)
plsr.out &lt;- plsr(sensory ~ chemical, data = oliveoil, method = "simpls")
groc.out &lt;- groc(sensory ~ chemical, data = oliveoil)
max(abs((fitted(plsr.out) - fitted(groc.out)) / fitted(plsr.out))) * 100
groc.v &lt;- grocCrossval(groc.out, segments = n)
groc.v$validation$PRESS
colMeans(groc.v$validation$PRESS)
Y &lt;- oliveoil$sensory
for (j in 1 : ncol(Y)) print(cor(Y[, j], fitted(groc.out)[, j, 2]))

########################
# Codes for Example 9  #
########################
require("ppls")
data("cookie")
X &lt;- as.matrix(log(cookie[1 : 40, 51 : 651]))
Y &lt;- as.matrix(cookie[1 : 40, 701 : 704])
X &lt;- X[, 2 : 601] - X[, 1 : 600]
data &lt;- data.frame(Y = I(Y), X = I(X))
n &lt;- nrow(data)
q &lt;- ncol(Y)
xl &lt;- "Wavelength index"
yl &lt;- "First differences of log(1/reflectance)"
matplot(1:ncol(X), t(X), lty = 1, xlab = xl, ylab = yl, type = "l")
out1 &lt;- plsr(Y ~ X, ncomp = n - 2, data = data)
cv &lt;- crossval(out1, segments = n)
cv.mean &lt;- colMeans(cv$validation$PRESS)
plot(cv.mean, xlab = "h", ylab = "Average PRESS", pch = 20)
h &lt;- 3
for (j in 1 : q) print(cor(Y[, j], fitted(out1)[, j, h]))
set.seed(1)
out2 &lt;- groc(Y ~ X, ncomp = h, data = data, plsrob = TRUE)
for (j in 1 : q) print(corrob(Y[, j], fitted(out2)[, j, h]))
plot(out2)

########################
# Codes for Example 10 #
########################
set.seed(2)
n &lt;- 30
t1 &lt;- sort(runif(n, -1, 1))
y &lt;- t1 + rnorm(n, mean = 0, sd = .05)
y[c(14, 15, 16)] &lt;- y[c(14, 15, 16)] + .5
data &lt;- data.frame(x1 = t1, x2 = 2 * t1, x3 = -1.5 * t1, y = y)
out &lt;- groc(y ~ x1 + x2 + x3, ncomp = 1, data = data, plsrob = TRUE)
tau &lt;- scaleTau2(residuals(out), mu.too = TRUE)
std.res &lt;- scale(residuals(out), center = tau[1], scale = tau[2])
index &lt;- which(abs(std.res)&gt;3)
prm.res &lt;- read.table("prmresid.txt")
plot(t1, y, pch = 20)
matlines(t1, cbind(t1,fitted(out), y - prm.res), lty = 1 : 3)
legend(.4, -.5 , legend = c("true model","groc", "prm"), lty = 1 : 3)
text(t1[index], y[index], index, cex = .8, pos = 3)

########################
# Codes for Example 11 #
########################
data("pulpfiber")
X &lt;- as.matrix(pulpfiber[, 1:4])
Y &lt;- as.matrix(pulpfiber[, 5:8])
data &lt;- data.frame(X = I(X), Y = I(Y))
set.seed(55481)
out.rob &lt;- groc(Y ~ X, data = data, plsrob = TRUE)
plot(out.rob, cex = .6)
out.simpls &lt;- groc(Y ~ X, data = data)
cv.rob &lt;- grocCrossval(out.rob,segment.type = "consecutive")
PREMAD.rob &lt;- cv.rob$validation$PREMAD[,4]
PREMAD.rob
cv.simpls &lt;- grocCrossval(out.simpls,segment.type = "consecutive")
PREMAD.simpls &lt;- cv.simpls$validation$PREMAD[,4]
PREMAD.simpls
(PREMAD.rob - PREMAD.simpls) / PREMAD.simpls * 100

## End(Not run)

</code></pre>

<hr>
<h2 id='grocCrossval'>Cross-validation of groc models
</h2><span id='topic+grocCrossval'></span>

<h3>Description</h3>

<p>A &ldquo;stand alone&rdquo; cross-validation function for <code>groc</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grocCrossval(object, segments = 10, segment.type = c("random",
      "consecutive","interleaved"), length.seg, trace = 15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grocCrossval_+3A_object">object</code></td>
<td>

<p>a <code>groc</code> object; the regression to cross-validate.
</p>
</td></tr>
<tr><td><code id="grocCrossval_+3A_segments">segments</code></td>
<td>

<p>the number of segments to use, or a list with segments (see below).
</p>
</td></tr>
<tr><td><code id="grocCrossval_+3A_segment.type">segment.type</code></td>
<td>

<p>the type of segments to use.
</p>
</td></tr>
<tr><td><code id="grocCrossval_+3A_length.seg">length.seg</code></td>
<td>

<p>Positive integer.  The length of the segments to use.
</p>
</td></tr>
<tr><td><code id="grocCrossval_+3A_trace">trace</code></td>
<td>

<p>if <code>TRUE</code>, tracing is turned on.  If numeric, it
denotes a time limit (in seconds).  If the estimated total time of
the cross-validation exceeds this limit, tracing is turned on.
</p>
</td></tr>
<tr><td><code id="grocCrossval_+3A_...">...</code></td>
<td>

<p>additional arguments, sent to the underlying fit function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs cross-validation on a model fit by <code>groc</code>.
It can handle models such as <code>groc(Y ~ X, ...)</code>.
</p>
<p>Note that to use <code>grocCrossval</code>, the data <em>must</em> be specified
with a <code>data</code> argument when fitting <code>object</code>.
</p>
<p>If <code>segments</code> is a list, the arguments <code>segment.type</code> and
<code>length.seg</code> are ignored.  The elements of the list should be
integer vectors specifying the indices of the segments.  
</p>
<p>Otherwise, segments of type <code>segment.type</code> are generated.  How
many segments to generate is selected by specifying the number of
segments in <code>segments</code>, or giving the segment length in
<code>length.seg</code>.  If both are specified, <code>segments</code> is
ignored.
</p>
<p>When tracing is turned on, the segment number is printed for each segment.
</p>


<h3>Value</h3>

<p>The supplied <code>object</code> is returned, with an additional component
<code>validation</code>, which is a list with components
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>equals <code>"CV"</code> for cross-validation.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>an array with the cross-validated predictions.</p>
</td></tr>
<tr><td><code>PRESS</code></td>
<td>
<p>a matrix of PRESS values for models with 1, ...,
<code>ncomp</code> components.  Each row corresponds to one response variable.</p>
</td></tr>
<tr><td><code>PREMAD</code></td>
<td>
<p>a matrix of PREMAD values for models with 1, ...,
<code>ncomp</code> components.  Each row corresponds to one response variable.</p>
</td></tr>
<tr><td><code>RMSEP</code></td>
<td>
<p>a matrix of sqrt(PRESS/nobj) values for models with 1, ...,
<code>ncomp</code> components.  Each row corresponds to one response variable.</p>
</td></tr>
<tr><td><code>segments</code></td>
<td>
<p>the list of segments used in the cross-validation.</p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
<p>the number of components.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Bilodeau (<a href="mailto:bilodeau@dms.umontreal.ca">bilodeau@dms.umontreal.ca</a>) and Pierre Lafaye de
Micheaux (<a href="mailto:lafaye@unsw.edu.au">lafaye@unsw.edu.au</a>)
</p>


<h3>References</h3>

<p>Martin Bilodeau, Pierre Lafaye de Micheaux, Smail Mahdi (2015), The R
Package groc for Generalized Regression on Orthogonal Components,
<em>Journal of Statistical Software</em>, 65(1), 1-29, <br /> <a href="https://www.jstatsoft.org/v65/i01/">https://www.jstatsoft.org/v65/i01/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(yarn,package="pls")
yarn.groc &lt;- groc(density ~ NIR, 6, data = yarn)
yarn.cv &lt;- grocCrossval(yarn.groc, segments = 10)

yarn.cv$validation$PRESS
yarn.cv$validation$PREMAD
</code></pre>

<hr>
<h2 id='grocfit'>Fitting a groc model</h2><span id='topic+grocfit'></span><span id='topic+groc.fit'></span>

<h3>Description</h3>

<p>Fits a groc model with the grid algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grocfit(X, Y, ncomp = min(nrow(X) - 1, ncol(X)), D = NULL, gamma =
                 0.75, method = NULL, plsrob = FALSE, Nc = 10, Ng = 20,
                 scale = FALSE, Cpp = TRUE, stripped = FALSE, maxiter =
                 100, sp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grocfit_+3A_x">X</code></td>
<td>

<p>a matrix of predictors.  <code>NA</code>s and <code>Inf</code>s are not allowed.
</p>
</td></tr>
<tr><td><code id="grocfit_+3A_y">Y</code></td>
<td>

<p>a vector or matrix of responses.  <code>NA</code>s and <code>Inf</code>s are not allowed.
</p>
</td></tr>
<tr><td><code id="grocfit_+3A_ncomp">ncomp</code></td>
<td>

<p>the number of components to be used in the modelling.
</p>
</td></tr>
<tr><td><code id="grocfit_+3A_d">D</code></td>
<td>

<p>Dependence measure.</p>
</td></tr>
<tr><td><code id="grocfit_+3A_gamma">gamma</code></td>
<td>

<p>Used to set the breakdown value when <code>method="lts"</code>.
</p>
</td></tr>
<tr><td><code id="grocfit_+3A_method">method</code></td>
<td>

<p>the method to be used. Currently only 'lm', 'lo', 's', and 'lts'.
</p>
</td></tr>
<tr><td><code id="grocfit_+3A_plsrob">plsrob</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the function sets <code>D=covrov</code> and <code>method="lts"</code> for a robust partial least squares fit.
</p>
</td></tr>
<tr><td><code id="grocfit_+3A_nc">Nc</code></td>
<td>

<p>Integer. Number of cycles in the grid algorithm</p>
</td></tr>
<tr><td><code id="grocfit_+3A_ng">Ng</code></td>
<td>

<p>Integer. Number of points for the grid in the grid algorithm.</p>
</td></tr>
<tr><td><code id="grocfit_+3A_scale">scale</code></td>
<td>

<p>Logical. If <code>TRUE</code> the responses are scaled.
</p>
</td></tr>
<tr><td><code id="grocfit_+3A_cpp">Cpp</code></td>
<td>

<p>Logical. If <code>TRUE</code>, compuations are performed in a faster way using
a C code.</p>
</td></tr>
<tr><td><code id="grocfit_+3A_stripped">stripped</code></td>
<td>

<p>logical.  If <code>TRUE</code> the calculations are stripped
as much as possible for speed; this is meant for use with
cross-validation or simulations when only the coefficients are
needed.  Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="grocfit_+3A_maxiter">maxiter</code></td>
<td>

<p>Integer. Maximal number of iterations in the grid algorithm. Used only when there are more than one response.
</p>
</td></tr>
<tr><td><code id="grocfit_+3A_sp">sp</code></td>
<td>

<p>A vector of smoothing parameters can be provided here.
Smoothing parameters must be supplied in the order that the
smooth terms appear in the model formula. Negative elements
indicate that the parameter should be estimated, and hence a
mixture of fixed and estimated parameters is
possible. 'length(sp)' should be equal to 'ncomp' and
corresponds 
to the number of underlying smoothing parameters.
</p>
</td></tr>
<tr><td><code id="grocfit_+3A_...">...</code></td>
<td>

<p>other arguments.  Currently ignored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Y</code></td>
<td>
<p>data used as response.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>an array of fitted values. Its element [i,j,k] is the fitted value for observation i, response j, and when  k components are used.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>an array of regression residuals.  It has the same
dimensions as <code>fitted.values</code>.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>a matrix of orthogonal components (scores). Each column corresponds to a component.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>a matrix of directions (loadings). Each column is a direction used to obtain the corresponding component (scores).</p>
</td></tr>
<tr><td><code>Gobjects</code></td>
<td>
<p>contain the objects produced by the fit of the responses on the orthogonal components.</p>
</td></tr>
<tr><td><code>Hobjects</code></td>
<td>
<p>contain the objects produced by the &quot;lts&quot; fit of each deflated predictors on the orthogonal components. <code>Hobjects</code> are produced when <code>plsrob=TRUE</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>matrix of coefficients produced by the &quot;lm&quot; fit of  each deflated predictors on the last component. <code>B</code> is produced when <code>plsrob=FALSE</code>.</p>
</td></tr>
<tr><td><code>Xmeans</code></td>
<td>
<p>a vector of means of the X variables.</p>
</td></tr>
<tr><td><code>Ymeans</code></td>
<td>
<p>a vector of means of the Y variables.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dependence measure used.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>a matrix whose columns contain the right singular vectors of the data.
Computed in the preprocessing to principal component scores when the number of
observations is less than the number of predictors.</p>
</td></tr>
<tr><td><code>dnnames</code></td>
<td>
<p>dimnames of 'fitted.values'</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Bilodeau (<a href="mailto:bilodeau@dms.umontreal.ca">bilodeau@dms.umontreal.ca</a>) and Pierre Lafaye de
Micheaux (<a href="mailto:lafaye@unsw.edu.au">lafaye@unsw.edu.au</a>)</p>


<h3>References</h3>

<p>Martin Bilodeau, Pierre Lafaye de Micheaux, Smail Mahdi (2015), The R
Package groc for Generalized Regression on Orthogonal Components,
<em>Journal of Statistical Software</em>, 65(1), 1-29, <br /> <a href="https://www.jstatsoft.org/v65/i01/">https://www.jstatsoft.org/v65/i01/</a>
</p>

<hr>
<h2 id='model.frame.groc'>Extract Information From a Fitted groc Model</h2><span id='topic+model.frame.groc'></span><span id='topic+model.matrix.groc'></span>

<h3>Description</h3>

<p>Functions to extract information from <code>groc</code> objects:  the model frame, the model
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groc'
model.matrix(object, ...)
## S3 method for class 'groc'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.groc_+3A_object">object</code>, <code id="model.frame.groc_+3A_formula">formula</code></td>
<td>
<p>a <code>groc</code> object.  The fitted model.</p>
</td></tr>
<tr><td><code id="model.frame.groc_+3A_...">...</code></td>
<td>
<p>other arguments sent to underlying functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model.frame.groc</code> returns the model frame; i.e. a data frame with
all variables necessary to generate the model matrix.  See
<code><a href="stats.html#topic+model.frame">model.frame</a></code> for details.
</p>
<p><code>model.matrix.groc</code> returns the (possibly coded) matrix used as
<code class="reqn">X</code> in the fitting.  See <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> for
details.
</p>


<h3>Value</h3>

<p><code>model.frame.groc</code> returns a data frame with
all variables neccessary to generate the model matrix.
</p>
<p><code>model.matrix.groc</code> returns the <code class="reqn">X</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens and Bjørn-Helge Mevik</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>,
<code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>
</p>

<hr>
<h2 id='plot.groc'>Plot groc objects.
</h2><span id='topic+plot.groc'></span>

<h3>Description</h3>

<p>A function to plot groc objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groc'
plot(x, h=x$ncomp, cex=0.8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.groc_+3A_x">x</code></td>
<td>

<p>A groc object.
</p>
</td></tr>
<tr><td><code id="plot.groc_+3A_h">h</code></td>
<td>

<p>Number of components in the model.
</p>
</td></tr>
<tr><td><code id="plot.groc_+3A_cex">cex</code></td>
<td>

<p>Character expansion factor for point labels.</p>
</td></tr>
<tr><td><code id="plot.groc_+3A_...">...</code></td>
<td>

<p>Further arguments passed to internal <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plsrob=FALSE</code>, a plot of robust Mahalanobis distances for residuals versus robust Mahalanobis distances for components. Useful for identification of good points, vertical outliers, good and bad leverage points.
</p>
<p>If <code>plsrob=TRUE</code>, the previous plot is done with another similar plot of classical Mahalanobis distances to compare the identification
of the various type of points obtained by classical or robust partial least squares. 
</p>


<h3>Author(s)</h3>


<p>Martin Bilodeau (<a href="mailto:bilodeau@dms.umontreal.ca">bilodeau@dms.umontreal.ca</a>) and Pierre Lafaye de
Micheaux (<a href="mailto:lafaye@unsw.edu.au">lafaye@unsw.edu.au</a>)
</p>


<h3>References</h3>

<p>Martin Bilodeau, Pierre Lafaye de Micheaux, Smail Mahdi (2015), The R
Package groc for Generalized Regression on Orthogonal Components,
<em>Journal of Statistical Software</em>, 65(1), 1-29, <br /> <a href="https://www.jstatsoft.org/v65/i01/">https://www.jstatsoft.org/v65/i01/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example takes some time:
## Not run: 
data("pulpfiber",package="robustbase")
X &lt;- as.matrix(pulpfiber[, 1:4])
Y &lt;- as.matrix(pulpfiber[, 5:8])
data &lt;- data.frame(X=I(X), Y=I(Y))
set.seed(55481)
out.rob &lt;- groc(Y ~ X, data=data, plsrob=TRUE)
plot(out.rob, cex=.6)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.groc'>Predict Method for groc
</h2><span id='topic+predict.groc'></span>

<h3>Description</h3>

<p>Prediction for groc models.  New responses or scores are
predicted using a fitted model and a new matrix of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groc'
predict(object, newdata, ncomp = object$ncomp, na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.groc_+3A_object">object</code></td>
<td>

<p>a <code>groc</code> object.  The fitted model
</p>
</td></tr>
<tr><td><code id="predict.groc_+3A_newdata">newdata</code></td>
<td>

<p>a data frame.  The new data.  If missing, the training
data is used.
</p>
</td></tr>
<tr><td><code id="predict.groc_+3A_ncomp">ncomp</code></td>
<td>

<p>vector of positive integers.  The components to use in
the prediction.</p>
</td></tr>
<tr><td><code id="predict.groc_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing
values in <code>newdata</code>. By default, nothing is done.
</p>
</td></tr>
<tr><td><code id="predict.groc_+3A_...">...</code></td>
<td>

<p>further arguments.  Currently not used
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A three dimensional array of
predicted response values is returned.  The dimensions correspond to
the observations, the response variables and the model sizes,
respectively.
</p>


<h3>Author(s)</h3>


<p>Martin Bilodeau (<a href="mailto:bilodeau@dms.umontreal.ca">bilodeau@dms.umontreal.ca</a>) and Pierre Lafaye de
Micheaux (<a href="mailto:lafaye@unsw.edu.au">lafaye@unsw.edu.au</a>)
</p>


<h3>References</h3>

<p>Martin Bilodeau, Pierre Lafaye de Micheaux, Smail Mahdi (2015), The R
Package groc for Generalized Regression on Orthogonal Components,
<em>Journal of Statistical Software</em>, 65(1), 1-29, <br /> <a href="https://www.jstatsoft.org/v65/i01/">https://www.jstatsoft.org/v65/i01/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.groc">plot.groc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("wood",package="robustbase")
out &lt;- groc(y ~ x1+x2+x3+x4+x5, ncomp=1, data=wood,D=corrob, method="lts")
predict(out)

newdata&lt;- data.frame(x1= 0.5, x2=0.1, x3=0.4, x4=0.5, x5=0.8)
predict(out,newdata)
</code></pre>

<hr>
<h2 id='prim7'>prim7 Dataset</h2><span id='topic+prim7'></span>

<h3>Description</h3>

<p>The data prim7 is a particle physics experiment analyzed
by projection pursuit regression in Friedman and Stuetzle (1981). It has 7 variables on 500
observations. The data set is described in Friedman and Tukey (1974).
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>X1</dt><dd><p>First variable.
</p>
</dd>
<dt>X2</dt><dd><p>Second variable.
</p>
</dd>
<dt>X3</dt><dd><p>Third variable.
</p>
</dd>
<dt>X4</dt><dd><p>Fourth variable.
</p>
</dd>
<dt>X5</dt><dd><p>Fifth variable.
</p>
</dd>
<dt>X6</dt><dd><p>Sixth variable.
</p>
</dd>
<dt>X7</dt><dd><p>Seventh variable.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Friedman and Tukey (1974),
A Projection Pursuit Algorithm for Exploratory Data Analysis,
<em>IEEE Transactions on Computers</em> (Volume:C-23,  Issue: 9)
</p>
<p>Friedman, Jerome H.; Stuetzle, Werner (1981),
Projection pursuit regression.
<em>J. Amer. Statist. Assoc.</em> 76, no. 376, 817&ndash;823. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(prim7)
</code></pre>

<hr>
<h2 id='summary.groc'>Summary and Print Methods for groc objects</h2><span id='topic+summary.groc'></span><span id='topic+print.groc'></span>

<h3>Description</h3>

<p>Summary and print methods for <code>groc</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groc'
summary(object, what = "validation",
        digits = 4, print.gap = 2, ...)
## S3 method for class 'groc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.groc_+3A_x">x</code>, <code id="summary.groc_+3A_object">object</code></td>
<td>
<p>a <code>groc</code> object</p>
</td></tr>
<tr><td><code id="summary.groc_+3A_what">what</code></td>
<td>
<p>character, only <code>"validation"</code> for the moment</p>
</td></tr>
<tr><td><code id="summary.groc_+3A_digits">digits</code></td>
<td>
<p>integer.  Minimum number of significant digits in the
output.  Default is 4.</p>
</td></tr>
<tr><td><code id="summary.groc_+3A_print.gap">print.gap</code></td>
<td>
<p>Integer.  Gap between coloumns of the printed tables.</p>
</td></tr>
<tr><td><code id="summary.groc_+3A_...">...</code></td>
<td>
<p>Other arguments sent to underlying methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>what</code> is <code>"validation"</code>, the cross-validated PRESS,
RPEMAD and RMSEPs (if
available) are given.
</p>


<h3>Value</h3>

<p><code>print.groc</code> return the object invisibly.
</p>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux</p>


<h3>References</h3>

<p>Martin Bilodeau, Pierre Lafaye de Micheaux, Smail Mahdi (2015), The R
Package groc for Generalized Regression on Orthogonal Components,
<em>Journal of Statistical Software</em>, 65(1), 1-29, <br /> <a href="https://www.jstatsoft.org/v65/i01/">https://www.jstatsoft.org/v65/i01/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groc">groc</a></code>, <code><a href="#topic+grocCrossval">grocCrossval</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("yarn",package="pls")
yarn.groc &lt;- groc(density ~ NIR, 6, data = yarn)
yarn.cv &lt;- grocCrossval(yarn.groc, segments = 10)
print(yarn.groc)
summary(yarn.cv)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
