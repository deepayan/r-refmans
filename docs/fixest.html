<!DOCTYPE html><html><head><title>Help for package fixest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fixest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.fixest_multi'><p>Subsets a fixest_multi object</p></a></li>
<li><a href='#[.fixest_panel'><p>Method to subselect from a <code>fixest_panel</code></p></a></li>
<li><a href='#[[.fixest_multi'><p>Extracts one element from a <code>fixest_multi</code> object</p></a></li>
<li><a href='#aggregate.fixest'><p>Aggregates the values of DiD coefficients a la Sun and Abraham</p></a></li>
<li><a href='#AIC.fixest'><p>Aikake's an information criterion</p></a></li>
<li><a href='#as.dict'><p>Transforms a character string into a dictionary</p></a></li>
<li><a href='#as.list.fixest_multi'><p>Transforms a fixest_multi object into a list</p></a></li>
<li><a href='#base_did'><p>Sample data for difference in difference</p></a></li>
<li><a href='#base_stagg'><p>Sample data for staggered difference in difference</p></a></li>
<li><a href='#BIC.fixest'><p>Bayesian information criterion</p></a></li>
<li><a href='#bin'><p>Bins the values of a variable (typically a factor)</p></a></li>
<li><a href='#bread.fixest'><p>Extracts the bread matrix from fixest objects</p></a></li>
<li><a href='#check_conv_feols'><p>Check the fixed-effects convergence of a <code>feols</code> estimation</p></a></li>
<li><a href='#coef.fixest'><p>Extracts the coefficients from a <code>fixest</code> estimation</p></a></li>
<li><a href='#coef.fixest_multi'><p>Extracts the coefficients of fixest_multi objects</p></a></li>
<li><a href='#coefplot'><p>Plots confidence intervals and point estimates</p></a></li>
<li><a href='#coeftable'><p>Extracts the coefficients table from an estimation</p></a></li>
<li><a href='#coeftable.default'><p>Extracts the coefficients table from an estimation</p></a></li>
<li><a href='#coeftable.fixest'><p>Obtain various statistics from an estimation</p></a></li>
<li><a href='#coeftable.fixest_multi'><p>Extracts the coefficients tables from <code>fixest_multi</code> estimations</p></a></li>
<li><a href='#collinearity'><p>Collinearity diagnostics for <code>fixest</code> objects</p></a></li>
<li><a href='#confint.fixest'><p>Confidence interval for parameters estimated with <code>fixest</code></p></a></li>
<li><a href='#confint.fixest_multi'><p>Confidence intervals for <code>fixest_multi</code> objects</p></a></li>
<li><a href='#degrees_freedom'><p>Gets the degrees of freedom of a <code>fixest</code> estimation</p></a></li>
<li><a href='#demean'><p>Centers a set of variables around a set of factors</p></a></li>
<li><a href='#deviance.fixest'><p>Extracts the deviance of a fixest estimation</p></a></li>
<li><a href='#did_means'><p>Treated and control sample descriptives</p></a></li>
<li><a href='#dsb'><p>Simple and powerful string manipulation with the dot square bracket operator</p></a></li>
<li><a href='#est_env'><p>Estimates a <code>fixest</code> estimation from a <code>fixest</code> environment</p></a></li>
<li><a href='#estfun.fixest'><p>Extracts the scores from a fixest estimation</p></a></li>
<li><a href='#etable'><p>Estimations table (export the results of multiples estimations to a DF or to Latex)</p></a></li>
<li><a href='#extralines_register'><p>Register <code>extralines</code> macros to be used in <code>etable</code></p></a></li>
<li><a href='#f'><p>Lags a variable in a <code>fixest</code> estimation</p></a></li>
<li><a href='#fdim'><p>Formatted dimension</p></a></li>
<li><a href='#feglm'><p>Fixed-effects GLM estimations</p></a></li>
<li><a href='#femlm'><p>Fixed-effects maximum likelihood models</p></a></li>
<li><a href='#feNmlm'><p>Fixed effects nonlinear maximum likelihood models</p></a></li>
<li><a href='#feols'><p>Fixed-effects OLS estimation</p></a></li>
<li><a href='#fitstat'><p>Computes fit statistics of fixest objects</p></a></li>
<li><a href='#fitstat_register'><p>Register custom fit statistics</p></a></li>
<li><a href='#fitted.fixest'><p>Extracts fitted values from a <code>fixest</code> fit</p></a></li>
<li><a href='#fixef_reexported'><p>Functions exported from <span class="pkg">nlme</span> to implement <span class="pkg">fixest</span> methods</p></a></li>
<li><a href='#fixef.fixest'><p>Extract the Fixed-Effects from a <code>fixest</code> estimation.</p></a></li>
<li><a href='#fixest_startup_msg'><p>Permanently removes the fixest package startup message</p></a></li>
<li><a href='#fixest-package'><p>Fast and User-Friendly Fixed-Effects Estimations</p></a></li>
<li><a href='#formula.fixest'><p>Extract the formula of a <code>fixest</code> fit</p></a></li>
<li><a href='#hatvalues.fixest'><p>Hat values for <code>fixest</code> objects</p></a></li>
<li><a href='#i'><p>Create, or interact variables with, factors</p></a></li>
<li><a href='#lag.formula'><p>Lags a variable using a formula</p></a></li>
<li><a href='#logLik.fixest'><p>Extracts the log-likelihood</p></a></li>
<li><a href='#model.matrix.fixest'><p>Design matrix of a <code>fixest</code> object</p></a></li>
<li><a href='#models'><p>Extracts the models tree from a <code>fixest_multi</code> object</p></a></li>
<li><a href='#n_unik'><p>Prints the number of unique elements in a data set</p></a></li>
<li><a href='#nobs.fixest'><p>Extracts the number of observations form a <code>fixest</code> object</p></a></li>
<li><a href='#obs'><p>Extracts the observations used for the estimation</p></a></li>
<li><a href='#osize'><p>Formatted object size</p></a></li>
<li><a href='#panel'><p>Constructs a <code>fixest</code> panel data base</p></a></li>
<li><a href='#plot.fixest.fixef'><p>Displaying the most notable fixed-effects</p></a></li>
<li><a href='#predict.fixest'><p>Predict method for <code>fixest</code> fits</p></a></li>
<li><a href='#print.fixest'><p>A print facility for <code>fixest</code> objects.</p></a></li>
<li><a href='#print.fixest_fitstat'><p>Print method for fit statistics of fixest estimations</p></a></li>
<li><a href='#print.fixest_multi'><p>Print method for fixest_multi objects</p></a></li>
<li><a href='#r2'><p>R2s of <code>fixest</code> models</p></a></li>
<li><a href='#ref'><p>Refactors a variable</p></a></li>
<li><a href='#rep.fixest'><p>Replicates <code>fixest</code> objects</p></a></li>
<li><a href='#resid.fixest'><p>Extracts residuals from a <code>fixest</code> object</p></a></li>
<li><a href='#resid.fixest_multi'><p>Extracts the residuals from a <code>fixest_multi</code> object</p></a></li>
<li><a href='#sample_df'><p>Randomly draws observations from a data set</p></a></li>
<li><a href='#sandwich_reexported'><p>Functions exported from <span class="pkg">sandwich</span> to implement <span class="pkg">fixest</span> methods</p></a></li>
<li><a href='#setFixest_coefplot'><p>Sets the defaults of coefplot</p></a></li>
<li><a href='#setFixest_dict'><p>Sets/gets the dictionary relabeling the variables</p></a></li>
<li><a href='#setFixest_estimation'><p>Default arguments for fixest estimations</p></a></li>
<li><a href='#setFixest_fml'><p>Sets/gets formula macros</p></a></li>
<li><a href='#setFixest_notes'><p>Sets/gets whether to display notes in <code>fixest</code> estimation functions</p></a></li>
<li><a href='#setFixest_nthreads'><p>Sets/gets the number of threads to use in <code>fixest</code> functions</p></a></li>
<li><a href='#setFixest_vcov'><p>Sets the default type of standard errors to be used</p></a></li>
<li><a href='#sigma.fixest'><p>Residual standard deviation of <code>fixest</code> estimations</p></a></li>
<li><a href='#ssc'><p>Governs the small sample correction in <code>fixest</code> VCOVs</p></a></li>
<li><a href='#stepwise'><p>Stepwise estimation tools</p></a></li>
<li><a href='#style.df'><p>Style of data.frames created by etable</p></a></li>
<li><a href='#style.tex'><p>Style definitions for Latex tables</p></a></li>
<li><a href='#summary.fixest'><p>Summary of a <code>fixest</code> object. Computes different types of standard errors.</p></a></li>
<li><a href='#summary.fixest_multi'><p>Summary for fixest_multi objects</p></a></li>
<li><a href='#summary.fixest.fixef'><p>Summary method for fixed-effects coefficients</p></a></li>
<li><a href='#sunab'><p>Sun and Abraham interactions</p></a></li>
<li><a href='#terms.fixest'><p>Extract the terms</p></a></li>
<li><a href='#to_integer'><p>Fast transform of any type of vector(s) into an integer vector</p></a></li>
<li><a href='#trade'><p>Trade data sample</p></a></li>
<li><a href='#unpanel'><p>Dissolves a <code>fixest</code> panel</p></a></li>
<li><a href='#update.fixest'><p>Updates a <code>fixest</code> estimation</p></a></li>
<li><a href='#vcov_cluster'><p>Clustered VCOV</p></a></li>
<li><a href='#vcov_conley'><p>Conley VCOV</p></a></li>
<li><a href='#vcov_hac'><p>HAC VCOVs</p></a></li>
<li><a href='#vcov.fixest'><p>Computes the variance/covariance of a <code>fixest</code> object</p></a></li>
<li><a href='#wald'><p>Wald test of nullity of coefficients</p></a></li>
<li><a href='#weights.fixest'><p>Extracts the weights from a <code>fixest</code> object</p></a></li>
<li><a href='#xpd'><p>Expands formula macros</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Fixed-Effects Estimations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, tools, utils, methods, numDeriv,
nlme, sandwich, Rcpp(&ge; 1.0.5), dreamerr(&ge; 1.2.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, data.table, plm, MASS, pander, ggplot2,
lfe, tinytex, pdftools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast and user-friendly estimation of econometric models with multiple fixed-effects. Includes ordinary least squares (OLS), generalized linear models (GLM) and the negative binomial.
    The core of the package is based on optimized parallel C++ code, scaling especially well for large data sets. The method to obtain the fixed-effects coefficients is based on Berge (2018) <a href="https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf">https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf</a>.
    Further provides tools to export and view the results of several estimations with intuitive design to cluster the standard-errors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lrberge/fixest/issues">https://github.com/lrberge/fixest/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lrberge.github.io/fixest/">https://lrberge.github.io/fixest/</a>,
<a href="https://github.com/lrberge/fixest">https://github.com/lrberge/fixest</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-23 20:52:55 UTC; lrberge</td>
</tr>
<tr>
<td>Author:</td>
<td>Laurent Berge [aut, cre],
  Sebastian Krantz [ctb],
  Grant McDermott <a href="https://orcid.org/0000-0001-7883-8573"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laurent Berge &lt;laurent.berge@u-bordeaux.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-24 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.fixest_multi'>Subsets a fixest_multi object</h2><span id='topic++5B.fixest_multi'></span>

<h3>Description</h3>

<p>Subsets a fixest_multi object using different keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_multi'
x[i, sample, lhs, rhs, fixef, iv, I, reorder = TRUE, drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.fixest_multi_+3A_x">x</code></td>
<td>
<p>A <code>fixest_multi</code> object, obtained from a <code>fixest</code> estimation leading to multiple results.</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_multi_+3A_i">i</code></td>
<td>
<p>An integer vector. Represents the estimations to extract.</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_multi_+3A_sample">sample</code></td>
<td>
<p>An integer vector, a logical scalar, or a character vector. It represents the <code>sample</code> identifiers for which the results should be extracted. Only valid when the <code>fixest</code> estimation was a split sample. You can use <code>.N</code> to refer to the last element. If logical, all elements are selected in both cases, but <code>FALSE</code> leads <code>sample</code> to become the rightmost key (just try it out).</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_multi_+3A_lhs">lhs</code></td>
<td>
<p>An integer vector, a logical scalar, or a character vector. It represents the left-hand-sides identifiers for which the results should be extracted. Only valid when the <code>fixest</code> estimation contained multiple left-hand-sides. You can use <code>.N</code> to refer to the last element. If logical, all elements are selected in both cases, but <code>FALSE</code> leads <code>lhs</code> to become the rightmost key (just try it out).</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_multi_+3A_rhs">rhs</code></td>
<td>
<p>An integer vector or a logical scalar. It represents the right-hand-sides identifiers for which the results should be extracted. Only valid when the <code>fixest</code> estimation contained multiple right-hand-sides. You can use <code>.N</code> to refer to the last element. If logical, all elements are selected in both cases, but <code>FALSE</code> leads <code>rhs</code> to become the rightmost key (just try it out).</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_multi_+3A_fixef">fixef</code></td>
<td>
<p>An integer vector or a logical scalar. It represents the fixed-effects identifiers for which the results should be extracted. Only valid when the <code>fixest</code> estimation contained fixed-effects in a stepwise fashion. You can use <code>.N</code> to refer to the last element. If logical, all elements are selected in both cases, but <code>FALSE</code> leads <code>fixef</code> to become the rightmost key (just try it out).</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_multi_+3A_iv">iv</code></td>
<td>
<p>An integer vector or a logical scalar. It represent the stages of the IV. Note that the length can be greater than 2 when there are multiple endogenous regressors (the first stage corresponding to multiple estimations). Note that the order of the stages depends on the <code>stage</code> argument from <code><a href="#topic+summary.fixest">summary.fixest</a></code>. If logical, all elements are selected in both cases, but <code>FALSE</code> leads <code>iv</code> to become the rightmost key (just try it out).</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_multi_+3A_i">I</code></td>
<td>
<p>An integer vector. Represents the root element to extract.</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_multi_+3A_reorder">reorder</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Indicates whether reordering of the results should be performed depending on the user input.</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_multi_+3A_drop">drop</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If the result contains only one estimation, then if <code>drop = TRUE</code> it will be transformed into a <code>fixest</code> object (instead of <code>fixest_multi</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order with we we use the keys matter. Every time a key <code>sample</code>, <code>lhs</code>, <code>rhs</code>, <code>fixef</code> or <code>iv</code> is used, a reordering is performed to consider the leftmost-side key to be the new root.
</p>
<p>Use logical keys to easily reorder. For example, say the object <code>res</code> contains a multiple estimation with multiple left-hand-sides, right-hand-sides and fixed-effects. By default the results are ordered as follows: <code>lhs</code>, <code>fixef</code>, <code>rhs</code>. If you use <code>res[lhs = FALSE]</code>, then the new order is: <code>fixef</code>, <code>rhs</code>, <code>lhs</code>. With <code>res[rhs = TRUE, lhs = FALSE]</code> it becomes: <code>rhs</code>, <code>fixef</code>, <code>lhs</code>. In both cases you keep all estimations.
</p>


<h3>Value</h3>

<p>It returns a <code>fixest_multi</code> object. If there is only one estimation left in the object, then the result is simplified into a <code>fixest</code> object.
</p>


<h3>See Also</h3>

<p>The main fixest estimation functions: <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">fepois</a></code>, <code><a href="#topic+femlm">fenegbin</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>. Tools for mutliple fixest estimations: <code><a href="#topic+summary.fixest_multi">summary.fixest_multi</a></code>, <code><a href="#topic+print.fixest_multi">print.fixest_multi</a></code>, <code><a href="#topic+as.list.fixest_multi">as.list.fixest_multi</a></code>, <code><a href="#topic+sub-sub-.fixest_multi">sub-sub-.fixest_multi</a></code>, <code><a href="#topic+sub-.fixest_multi">sub-.fixest_multi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Estimation with multiple samples/LHS/RHS
aq = airquality[airquality$Month %in% 5:6, ]
est_split = feols(c(Ozone, Solar.R) ~ sw(poly(Wind, 2), poly(Temp, 2)),
                  aq, split = ~ Month)

# By default: sample is the root
etable(est_split)

# Let's reorder, by considering lhs the root
etable(est_split[lhs = 1:.N])

# Selecting only one LHS and RHS
etable(est_split[lhs = "Ozone", rhs = 1])

# Taking the first root (here sample = 5)
etable(est_split[I = 1])

# The first and last estimations
etable(est_split[i = c(1, .N)])

</code></pre>

<hr>
<h2 id='+5B.fixest_panel'>Method to subselect from a <code>fixest_panel</code></h2><span id='topic++5B.fixest_panel'></span>

<h3>Description</h3>

<p>Subselection from a <code>fixest_panel</code> which has been created with the function <code><a href="#topic+panel">panel</a></code>. Also allows to create lag/lead variables with functions <code><a href="#topic+l">l</a></code>/<code><a href="#topic+l">f</a></code> if the <code>fixest_panel</code> is also a <code><a href="data.table.html#topic+data.table">data.table::data.table</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_panel'
x[i, j, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.fixest_panel_+3A_x">x</code></td>
<td>
<p>A <code>fixest_panel</code> object, created with the function <code><a href="#topic+panel">panel</a></code>.</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_panel_+3A_i">i</code></td>
<td>
<p>Row subselection. Allows <code><a href="data.table.html#topic+data.table">data.table::data.table</a></code> style selection (provided the data is also a data.table).</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_panel_+3A_j">j</code></td>
<td>
<p>Variable selection. Allows <code><a href="data.table.html#topic+data.table">data.table::data.table</a></code> style selection/variable creation (provided the data is also a data.table).</p>
</td></tr>
<tr><td><code id="+2B5B.fixest_panel_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code style="white-space: pre;">&#8288;[.data.frame&#8288;</code> or <code><a href="data.table.html#topic+data.table">data.table::data.table</a></code> (or whatever the class of the initial data).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the original data was also a data.table, some calls to <code style="white-space: pre;">&#8288;[.fixest_panel&#8288;</code> may dissolve the <code>fixest_panel</code> object and return a regular data.table. This is the case for subselections with additional arguments. If so, a note is displayed on the console.
</p>


<h3>Value</h3>

<p>It returns a <code>fixest_panel</code> data base, with the attributes allowing to create lags/leads properly bookkeeped.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>Alternatively, the function <code><a href="#topic+panel">panel</a></code> changes a <code>data.frame</code> into a panel from which the functions <code>l</code> and <code>f</code> (creating leads and lags) can be called. Otherwise you can set the panel 'live' during the estimation using the argument <code>panel.id</code> (see for example in the function <code><a href="#topic+feols">feols</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(base_did)

# Creating a fixest_panel object
pdat = panel(base_did, ~id+period)

# Subselections of fixest_panel objects bookkeeps the leads/lags engine
pdat_small = pdat[!pdat$period %in% c(2, 4), ]
a = feols(y~l(x1, 0:1), pdat_small)

# we obtain the same results, had we created the lags "on the fly"
base_small = base_did[!base_did$period %in% c(2, 4), ]
b = feols(y~l(x1, 0:1), base_small, panel.id = ~id+period)
etable(a, b)


# Using data.table to create new lead/lag variables
if(require("data.table")){
  pdat_dt = panel(as.data.table(base_did), ~id+period)

  # Variable creation
  pdat_dt[, x_l1 := l(x1)]
  pdat_dt[, c("x_l1", "x_f1_2") := .(l(x1), f(x1)**2)]

  # Estimation on a subset of the data
  #  (the lead/lags work appropriately)
  feols(y~l(x1, 0:1), pdat_dt[!period %in% c(2, 4)])
}


</code></pre>

<hr>
<h2 id='+5B+5B.fixest_multi'>Extracts one element from a <code>fixest_multi</code> object</h2><span id='topic++5B+5B.fixest_multi'></span>

<h3>Description</h3>

<p>Extracts single elements from multiple <code>fixest</code> estimations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_multi'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B.fixest_multi_+3A_x">x</code></td>
<td>
<p>A <code>fixest_multi</code> object, obtained from a <code>fixest</code> estimation leading to multiple results.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.fixest_multi_+3A_i">i</code></td>
<td>
<p>An integer scalar. The identifier of the estimation to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fixest</code> object is returned.
</p>


<h3>See Also</h3>

<p>The main fixest estimation functions: <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">fepois</a></code>, <code><a href="#topic+femlm">fenegbin</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>. Tools for mutliple fixest estimations: <code><a href="#topic+summary.fixest_multi">summary.fixest_multi</a></code>, <code><a href="#topic+print.fixest_multi">print.fixest_multi</a></code>, <code><a href="#topic+as.list.fixest_multi">as.list.fixest_multi</a></code>, <code><a href="#topic+sub-sub-.fixest_multi">sub-sub-.fixest_multi</a></code>, <code><a href="#topic+sub-.fixest_multi">sub-.fixest_multi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

# Multiple estimation
res = feols(y ~ csw(x1, x2, x3), base, split = ~species)

# The first estimation
res[[1]]

# The second one, etc
res[[2]]

</code></pre>

<hr>
<h2 id='aggregate.fixest'>Aggregates the values of DiD coefficients a la Sun and Abraham</h2><span id='topic+aggregate.fixest'></span>

<h3>Description</h3>

<p>Simple tool that aggregates the value of CATT coefficients in staggered difference-in-difference setups (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
aggregate(x, agg, full = FALSE, use_weights = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate.fixest_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object.</p>
</td></tr>
<tr><td><code id="aggregate.fixest_+3A_agg">agg</code></td>
<td>
<p>A character scalar describing the variable names to be aggregated, it is pattern-based. For <code><a href="#topic+sunab">sunab</a></code> estimations, the following keywords work: &quot;att&quot;, &quot;period&quot;, &quot;cohort&quot; and <code>FALSE</code> (to have full disaggregation). All variables that match the pattern will be aggregated. It must be of the form <code>"(root)"</code>, the parentheses must be there and the resulting variable name will be <code>"root"</code>. You can add another root with parentheses: <code>"(root1)regex(root2)"</code>, in which case the resulting name is <code>"root1::root2"</code>. To name the resulting variable differently you can pass a named vector: <code>c("name" = "pattern")</code> or <code>c("name" = "pattern(root2)")</code>. It's a bit intricate sorry, please see the examples.</p>
</td></tr>
<tr><td><code id="aggregate.fixest_+3A_full">full</code></td>
<td>
<p>Logical scalar, defaults to <code>FALSE</code>. If <code>TRUE</code>, then all coefficients are returned, not only the aggregated coefficients.</p>
</td></tr>
<tr><td><code id="aggregate.fixest_+3A_use_weights">use_weights</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If the estimation was weighted, whether the aggregation should take into account the weights. Basically if the weights reflected frequency it should be <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aggregate.fixest_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+summary.fixest">summary.fixest</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function helping to replicate the estimator from Sun and Abraham (2020). You first need to perform an estimation with cohort and relative periods dummies (typically using the function <code><a href="#topic+i">i</a></code>), this leads to estimators of the cohort average treatment effect on the treated (CATT). Then you can use this function to retrieve the average treatment effect on each relative period, or for any other way you wish to aggregate the CATT.
</p>
<p>Note that contrary to the SA article, here the cohort share in the sample is considered to be a perfect measure for the cohort share in the population.
</p>


<h3>Value</h3>

<p>It returns a matrix representing a table of coefficients.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>References</h3>

<p>Liyang Sun and Sarah Abraham, forthcoming, &quot;Estimating Dynamic Treatment Effects in Event Studies with Heterogeneous Treatment Effects&quot;. Journal of Econometrics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# DiD example
#

data(base_stagg)

# 2 kind of estimations:
# - regular TWFE model
# - estimation with cohort x time_to_treatment interactions, later aggregated

# Note: the never treated have a time_to_treatment equal to -1000

# Now we perform the estimation
res_twfe = feols(y ~ x1 + i(time_to_treatment, treated,
                            ref = c(-1, -1000)) | id + year, base_stagg)

# we use the "i." prefix to force year_treated to be considered as a factor
res_cohort = feols(y ~ x1 + i(time_to_treatment, i.year_treated,
                              ref = c(-1, -1000)) | id + year, base_stagg)

# Displaying the results
iplot(res_twfe, ylim = c(-6, 8))
att_true = tapply(base_stagg$treatment_effect_true,
                  base_stagg$time_to_treatment, mean)[-1]
points(-9:8 + 0.15, att_true, pch = 15, col = 2)

# The aggregate effect for each period
agg_coef = aggregate(res_cohort, "(ti.*nt)::(-?[[:digit:]]+)")
x = c(-9:-2, 0:8) + .35
points(x, agg_coef[, 1], pch = 17, col = 4)
ci_low = agg_coef[, 1] - 1.96 * agg_coef[, 2]
ci_up = agg_coef[, 1] + 1.96 * agg_coef[, 2]
segments(x0 = x, y0 = ci_low, x1 = x, y1 = ci_up, col = 4)

legend("topleft", col = c(1, 2, 4), pch = c(20, 15, 17),
       legend = c("TWFE", "True", "Sun &amp; Abraham"))


# The ATT
aggregate(res_cohort, c("ATT" = "treatment::[^-]"))
with(base_stagg, mean(treatment_effect_true[time_to_treatment &gt;= 0]))

# The total effect for each cohort
aggregate(res_cohort, c("cohort" = "::[^-].*year_treated::([[:digit:]]+)"))


</code></pre>

<hr>
<h2 id='AIC.fixest'>Aikake's an information criterion</h2><span id='topic+AIC.fixest'></span>

<h3>Description</h3>

<p>This function computes the AIC (Aikake's, an information criterion) from a <code>fixest</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="AIC.fixest_+3A_...">...</code></td>
<td>
<p>Optionally, more fitted objects.</p>
</td></tr>
<tr><td><code id="AIC.fixest_+3A_k">k</code></td>
<td>
<p>A numeric, the penalty per parameter to be used; the default k = 2 is the classical AIC (i.e. <code>AIC=-2*LL+k*nparams</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AIC is computed as:
</p>
<p style="text-align: center;"><code class="reqn">AIC = -2\times LogLikelihood + k\times nbParams</code>
</p>

<p>with k the penalty parameter.
</p>
<p>You can have more information on this criterion on <code><a href="stats.html#topic+AIC">AIC</a></code>.
</p>


<h3>Value</h3>

<p>It return a numeric vector, with length the same as the number of objects taken as arguments.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. Other statictics methods: <code><a href="#topic+BIC.fixest">BIC.fixest</a></code>, <code><a href="#topic+logLik.fixest">logLik.fixest</a></code>, <code><a href="#topic+nobs.fixest">nobs.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# two fitted models with different expl. variables:
res1 = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
             Petal.Width | Species, iris)
res2 = femlm(Sepal.Length ~ Petal.Width | Species, iris)

AIC(res1, res2)
BIC(res1, res2)


</code></pre>

<hr>
<h2 id='as.dict'>Transforms a character string into a dictionary</h2><span id='topic+as.dict'></span>

<h3>Description</h3>

<p>Transforms a single character string containing a dictionary in a textual format into a proper dictionary, that is a named character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.dict(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.dict_+3A_x">x</code></td>
<td>
<p>A character scalar of the form <code>"variable 1: definition \n variable 2: definition"</code> etc. Each line of this character must contain at most one definition with, on the left the variable name, and on the right its definition. The separation between the variable and its definition must be a colon followed with a single space (i.e. &quot;: &quot;). You can stack definitions within a single line by making use of a semi colon: <code>"var1: def; var2: def"</code>. White spaces on the left and right are ignored. You can add commented lines with a <code>"#"</code>. Non-empty, non-commented lines that don't have the proper format witll raise an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mostly used in combination with <code><a href="#topic+setFixest_dict">setFixest_dict</a></code> to set the dictionary to be used in the function <code><a href="#topic+etable">etable</a></code>.
</p>


<h3>Value</h3>

<p>It returns a named character vector.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+etable">etable</a></code>, <code><a href="#topic+setFixest_dict">setFixest_dict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = "# Main vars
     mpg: Miles per gallon
     hp: Horsepower

     # Categorical variables
     cyl: Number of cylinders; vs: Engine"

as.dict(x)



</code></pre>

<hr>
<h2 id='as.list.fixest_multi'>Transforms a fixest_multi object into a list</h2><span id='topic+as.list.fixest_multi'></span>

<h3>Description</h3>

<p>Extracts the results from a <code>fixest_multi</code> object and place them into a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_multi'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.fixest_multi_+3A_x">x</code></td>
<td>
<p>A <code>fixest_multi</code> object, obtained from a <code>fixest</code> estimation leading to multiple results.</p>
</td></tr>
<tr><td><code id="as.list.fixest_multi_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing all the results of the multiple estimations.
</p>


<h3>See Also</h3>

<p>The main fixest estimation functions: <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">fepois</a></code>, <code><a href="#topic+femlm">fenegbin</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>. Tools for mutliple fixest estimations: <code><a href="#topic+summary.fixest_multi">summary.fixest_multi</a></code>, <code><a href="#topic+print.fixest_multi">print.fixest_multi</a></code>, <code><a href="#topic+as.list.fixest_multi">as.list.fixest_multi</a></code>, <code><a href="#topic+sub-sub-.fixest_multi">sub-sub-.fixest_multi</a></code>, <code><a href="#topic+sub-.fixest_multi">sub-.fixest_multi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

# Multiple estimation
res = feols(y ~ csw(x1, x2, x3), base, split = ~species)

# All the results at once
as.list(res)


</code></pre>

<hr>
<h2 id='base_did'>Sample data for difference in difference</h2><span id='topic+base_did'></span>

<h3>Description</h3>

<p>This data has been generated to illustrate the use of difference in difference functions in package <span class="pkg">fixest</span>. This is a balanced panel of 104 individuals and 10 periods. About half the individuals are treated, the treatment having a positive effect on the dependent variable <code>y</code> after the 5th period. The effect of the treatment on <code>y</code> is gradual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(base_did)
</code></pre>


<h3>Format</h3>

<p><code>base_did</code> is a data frame with 1,040 observations and 6 variables named <code>y</code>, <code>x1</code>, <code>id</code>, <code>period</code>, <code>post</code> and <code>treat</code>.
</p>

<dl>
<dt>y</dt><dd><p>The dependent variable affected by the treatment.</p>
</dd>
<dt>x1</dt><dd><p> An explanatory variable.</p>
</dd>
<dt>id</dt><dd><p> Identifier of the individual.</p>
</dd>
<dt>period</dt><dd><p> From 1 to 10</p>
</dd>
<dt>post</dt><dd><p> Indicator taking value 1 if the period is strictly greater than 5, 0 otherwise.</p>
</dd>
<dt>treat</dt><dd><p> Indicator taking value 1 if the individual is treated, 0 otherwise.</p>
</dd>
</dl>



<h3>Source</h3>

<p>This data has been generated from <span class="pkg">R</span>.
</p>

<hr>
<h2 id='base_stagg'>Sample data for staggered difference in difference</h2><span id='topic+base_stagg'></span>

<h3>Description</h3>

<p>This data has been generated to illustrate the Sun and Abraham (Journal of Econometrics, forthcoming) method for staggered difference-in-difference. This is a balanced panel of 95 individuals and 10 periods. Half the individuals are treated. For those treated, the treatment date can vary from the second to the last period. The effect of the treatment depends on the time since the treatment: it is first negative and then increasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(base_stagg)
</code></pre>


<h3>Format</h3>

<p><code>base_stagg</code> is a data frame with 950 observations and 7 variables:
</p>

<ul>
<li><p> id: panel identifier.
</p>
</li>
<li><p> year: from 1 to 10.
</p>
</li>
<li><p> year_treated: the period at which the individual is treated.
</p>
</li>
<li><p> time_to_treatment: different between the year and the treatment year.
</p>
</li>
<li><p> treated: indicator taking value 1 if the individual is treated, 0 otherwise.
</p>
</li>
<li><p> treatment_effect_true: true effect of the treatment.
</p>
</li>
<li><p> x1: explanatory variable, correlated with the period.
</p>
</li>
<li><p> y: the dependent variable affected by the treatment.
</p>
</li></ul>



<h3>Source</h3>

<p>This data has been generated from <span class="pkg">R</span>.
</p>

<hr>
<h2 id='BIC.fixest'>Bayesian information criterion</h2><span id='topic+BIC.fixest'></span>

<h3>Description</h3>

<p>This function computes the BIC (Bayesian information criterion) from a <code>fixest</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="BIC.fixest_+3A_...">...</code></td>
<td>
<p>Optionally, more fitted objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BIC is computed as follows:
</p>
<p style="text-align: center;"><code class="reqn">BIC = -2\times LogLikelihood + \log(nobs)\times nbParams</code>
</p>

<p>with k the penalty parameter.
</p>
<p>You can have more information on this criterion on <code><a href="stats.html#topic+AIC">AIC</a></code>.
</p>


<h3>Value</h3>

<p>It return a numeric vector, with length the same as the number of objects taken as arguments.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. Other statistics functions: <code><a href="#topic+AIC.fixest">AIC.fixest</a></code>, <code><a href="#topic+logLik.fixest">logLik.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# two fitted models with different expl. variables:
res1 = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)
res2 = femlm(Sepal.Length ~ Petal.Width | Species, iris)

AIC(res1, res2)
BIC(res1, res2)

</code></pre>

<hr>
<h2 id='bin'>Bins the values of a variable (typically a factor)</h2><span id='topic+bin'></span>

<h3>Description</h3>

<p>Tool to easily group the values of a given variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin(x, bin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_+3A_x">x</code></td>
<td>
<p>A vector whose values have to be grouped. Can be of any type but must be atomic.</p>
</td></tr>
<tr><td><code id="bin_+3A_bin">bin</code></td>
<td>
<p>A list of values to be grouped, a vector, a formula, or the special values <code>"bin::digit"</code> or <code>"cut::values"</code>. To create a new value from old values, use <code>bin = list("new_value"=old_values)</code> with <code>old_values</code> a vector of existing values. You can use <code>.()</code> for <code>list()</code>.
It accepts regular expressions, but they must start with an <code>"@"</code>, like in <code>bin="@Aug|Dec"</code>. It accepts one-sided formulas which must contain the variable <code>x</code>, e.g. <code>bin=list("&lt;2" = ~x &lt; 2)</code>.
The names of the list are the new names. If the new name is missing, the first value matched becomes the new name. In the name, adding <code>"@d"</code>, with <code>d</code> a digit, will relocate the value in position <code>d</code>: useful to change the position of factors. Use <code>"@"</code> as first item to make subsequent items be located first in the factor.
Feeding in a vector is like using a list without name and only a single element. If the vector is numeric, you can use the special value <code>"bin::digit"</code> to group every <code>digit</code> element.
For example if <code>x</code> represents years, using <code>bin="bin::2"</code> creates bins of two years.
With any data, using <code>"!bin::digit"</code> groups every digit consecutive values starting from the first value.
Using <code>"!!bin::digit"</code> is the same but starting from the last value.
With numeric vectors you can: a) use <code>"cut::n"</code> to cut the vector into <code>n</code> equal parts, b) use <code>"cut::a]b["</code> to create the following bins: <code style="white-space: pre;">&#8288;[min, a]&#8288;</code>, <code style="white-space: pre;">&#8288;]a, b[&#8288;</code>, <code style="white-space: pre;">&#8288;[b, max]&#8288;</code>.
The latter syntax is a sequence of number/quartile (q0 to q4)/percentile (p0 to p100) followed by an open or closed square bracket. You can add custom bin names by adding them in the character vector after <code>'cut::values'</code>. See details and examples. Dot square bracket expansion (see <code><a href="#topic+dsb">dsb</a></code>) is enabled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a vector of the same length as <code>x</code>.
</p>


<h3>&quot;Cutting&quot; a numeric vector</h3>

<p>Numeric vectors can be cut easily into: a) equal parts, b) user-specified bins.
</p>
<p>Use <code>"cut::n"</code> to cut the vector into <code>n</code> (roughly) equal parts. Percentiles are used to partition the data, hence some data distributions can lead to create less than <code>n</code> parts (for example if P0 is the same as P50).
</p>
<p>The user can specify custom bins with the following syntax: <code>"cut::a]b]c]"</code>. Here the numbers <code>a</code>, <code>b</code>, <code>c</code>, etc, are a sequence of increasing numbers, each followed by an open or closed square bracket. The numbers can be specified as either plain numbers (e.g. <code>"cut::5]12[32["</code>), quartiles (e.g. <code>"cut::q1]q3["</code>), or percentiles (e.g. <code>"cut::p10]p15]p90]"</code>). Values of different types can be mixed: <code>"cut::5]q2[p80["</code> is valid provided the median (<code>q2</code>) is indeed greater than <code>5</code>, otherwise an error is thrown.
</p>
<p>The square bracket right of each number tells whether the numbers should be included or excluded from the current bin. For example, say <code>x</code> ranges from 0 to 100, then <code>"cut::5]"</code> will create two  bins: one from 0 to 5 and a second from 6 to 100. With <code>"cut::5["</code> the bins would have been 0-4 and 5-100.
</p>
<p>A factor is always returned. The labels always report the min and max values in each bin.
</p>
<p>To have user-specified bin labels, just add them in the character vector following <code>'cut::values'</code>. You don't need to provide all of them, and <code>NA</code> values fall back to the default label. For example, <code>bin = c("cut::4", "Q1", NA, "Q3")</code> will modify only the first and third label that will be displayed as <code>"Q1"</code> and <code>"Q3"</code>.
</p>


<h3><code>bin</code> vs <code>ref</code></h3>

<p>The functions <code><a href="#topic+bin">bin</a></code> and <code><a href="#topic+ref">ref</a></code> are able to do the same thing, then why use one instead of the other? Here are the differences:
</p>

<ul>
<li> <p><code>ref</code> always returns a factor. This is in contrast with <code>bin</code> which returns, when possible, a vector of the same type as the vector in input.
</p>
</li>
<li> <p><code>ref</code> always places the values modified in the first place of the factor levels. On the other hand, <code>bin</code> tries to not modify the ordering of the levels. It is possible to make <code>bin</code> mimic the behavior of <code>ref</code> by adding an <code>"@"</code> as the first element of the list in the argument <code>bin</code>.
</p>
</li>
<li><p> when a vector (and not a list) is given in input, <code>ref</code> will place each element of the vector in the first place of the factor levels. The behavior of <code>bin</code> is totally different, <code>bin</code> will transform all the values in the vector into a single value in <code>x</code> (i.e. it's binning).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>To re-factor variables: <code><a href="#topic+ref">ref</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(airquality)
month_num = airquality$Month
table(month_num)

# Grouping the first two values
table(bin(month_num, 5:6))

# ... plus changing the name to '10'
table(bin(month_num, list("10" = 5:6)))

# ... and grouping 7 to 9
table(bin(month_num, list("g1" = 5:6, "g2" = 7:9)))

# Grouping every two months
table(bin(month_num, "bin::2"))

# ... every 2 consecutive elements
table(bin(month_num, "!bin::2"))

# ... idem starting from the last one
table(bin(month_num, "!!bin::2"))

# Using .() for list():
table(bin(month_num, .("g1" = 5:6)))


#
# with non numeric data
#

month_lab = c("may", "june", "july", "august", "september")
month_fact = factor(month_num, labels = month_lab)

# Grouping the first two elements
table(bin(month_fact, c("may", "jun")))

# ... using regex
table(bin(month_fact, "@may|jun"))

# ...changing the name
table(bin(month_fact, list("spring" = "@may|jun")))

# Grouping every 2 consecutive months
table(bin(month_fact, "!bin::2"))

# ...idem but starting from the last
table(bin(month_fact, "!!bin::2"))

# Relocating the months using "@d" in the name
table(bin(month_fact, .("@5" = "may", "@1 summer" = "@aug|jul")))

# Putting "@" as first item means subsequent items will be placed first
table(bin(month_fact, .("@", "aug", "july")))

#
# "Cutting" numeric data
#

data(iris)
plen = iris$Petal.Length

# 3 parts of (roughly) equal size
table(bin(plen, "cut::3"))

# Three custom bins
table(bin(plen, "cut::2]5]"))

# .. same, excluding 5 in the 2nd bin
table(bin(plen, "cut::2]5["))

# Using quartiles
table(bin(plen, "cut::q1]q2]q3]"))

# Using percentiles
table(bin(plen, "cut::p20]p50]p70]p90]"))

# Mixing all
table(bin(plen, "cut::2[q2]p90]"))

# NOTA:
# -&gt; the labels always contain the min/max values in each bin

# Custom labels can be provided, just give them in the char. vector
# NA values lead to the default label
table(bin(plen, c("cut::2[q2]p90]", "&lt;2", "]2; Q2]", NA, "&gt;90%")))



#
# With a formula
#

data(iris)
plen = iris$Petal.Length

# We need to use "x"
table(bin(plen, list("&lt; 2" = ~x &lt; 2, "&gt;= 2" = ~x &gt;= 2)))


</code></pre>

<hr>
<h2 id='bread.fixest'>Extracts the bread matrix from fixest objects</h2><span id='topic+bread.fixest'></span>

<h3>Description</h3>

<p>Extracts the bread matrix from fixest objects to be used to compute sandwich variance-covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
bread(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bread.fixest_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object, obtained for instance from <code><a href="#topic+feols">feols</a></code>.</p>
</td></tr>
<tr><td><code id="bread.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of the same dimension as the number of variables used in the estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
est = feols(Petal.Length ~ Petal.Width + Sepal.Width, iris)
bread(est)

</code></pre>

<hr>
<h2 id='check_conv_feols'>Check the fixed-effects convergence of a <code>feols</code> estimation</h2><span id='topic+check_conv_feols'></span><span id='topic+summary.fixest_check_conv'></span>

<h3>Description</h3>

<p>Checks the convergence of a <code>feols</code> estimation by computing the first-order conditions of all fixed-effects (all should be close to 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_conv_feols(x)

## S3 method for class 'fixest_check_conv'
summary(object, type = "short", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_conv_feols_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+feols">feols</a></code> estimation that should contain fixed-effects.</p>
</td></tr>
<tr><td><code id="check_conv_feols_+3A_object">object</code></td>
<td>
<p>An object returned by <code>check_conv_feols</code>.</p>
</td></tr>
<tr><td><code id="check_conv_feols_+3A_type">type</code></td>
<td>
<p>Either &quot;short&quot; (default) or &quot;detail&quot;. If &quot;short&quot;, only the maximum absolute FOC are displayed, otherwise the 2 smallest and the 2 largest FOC are reported for each fixed-effect and each variable.</p>
</td></tr>
<tr><td><code id="check_conv_feols_+3A_...">...</code></td>
<td>
<p>Not currently used.
</p>
<p>Note that this function first re-demeans the variables, thus possibly incurring some extra computation time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list of <code>N</code> elements, <code>N</code> being the number of variables in the estimation (dependent variable + explanatory variables +, if IV, endogenous variables and instruments). For each variable, all the first-order conditions for each fixed-effect are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = setNames(iris, c("y", "x1", "x2", "x3", "species"))
base$FE = rep(1:30, 5)

# one estimation with fixed-effects + varying slopes
est = feols(y ~ x1 | species[x2] + FE[x3], base)

# Checking the convergence
conv = check_conv_feols(est)

# We can check that al values are close to 0
summary(conv)

summary(conv, "detail")



</code></pre>

<hr>
<h2 id='coef.fixest'>Extracts the coefficients from a <code>fixest</code> estimation</h2><span id='topic+coef.fixest'></span><span id='topic+coefficients.fixest'></span>

<h3>Description</h3>

<p>This function extracts the coefficients obtained from a model estimated with <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
coef(object, keep, drop, order, collin = FALSE, agg = TRUE, ...)

## S3 method for class 'fixest'
coefficients(object, keep, drop, order, collin = FALSE, agg = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="coef.fixest_+3A_keep">keep</code></td>
<td>
<p>Character vector. This element is used to display only a subset of variables. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be kept. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code>keep = "x[[:digit:]]$"</code>. If the first character is an exclamation mark, the effect is reversed (e.g. keep = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is kept). See details.</p>
</td></tr>
<tr><td><code id="coef.fixest_+3A_drop">drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be discarded. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code style="white-space: pre;">&#8288;drop = "x[[:digit:]]{2}&#8288;</code>&quot;. If the first character is an exclamation mark, the effect is reversed (e.g. drop = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is dropped). See details.</p>
</td></tr>
<tr><td><code id="coef.fixest_+3A_order">order</code></td>
<td>
<p>Character vector. This element is used if the user wants the variables to be ordered in a certain way. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). The variables satisfying the first regular expression will be placed first, then the order follows the sequence of regular expressions. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the following variables: <code>month1</code> to <code>month6</code>, then <code>x1</code> to <code>x5</code>, then <code>year1</code> to <code>year6</code>. If you want to display first the x's, then the years, then the months you could use: <code>order = c("x", "year")</code>. If the first character is an exclamation mark, the effect is reversed (e.g. order = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; goes first).  See details.</p>
</td></tr>
<tr><td><code id="coef.fixest_+3A_collin">collin</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether the coefficients removed because of collinearity should be also returned as <code>NA</code>. It cannot be used when coefficients aggregation is also used.</p>
</td></tr>
<tr><td><code id="coef.fixest_+3A_agg">agg</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. If the coefficients of the estimation have been aggregated, whether to report the aggregated coefficients. If <code>FALSE</code>, the raw coefficients will be returned.</p>
</td></tr>
<tr><td><code id="coef.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficients are the ones that have been found to maximize the log-likelihood of the specified model. More information can be found on the models from the estimations help pages: <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.
</p>
<p>Note that if the model has been estimated with fixed-effects, to obtain the fixed-effect coefficients, you need to use the function <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>.
</p>


<h3>Value</h3>

<p>This function returns a named numeric vector.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. <code><a href="#topic+summary.fixest">summary.fixest</a></code>, <code><a href="#topic+confint.fixest">confint.fixest</a></code>, <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>, <code><a href="#topic+etable">etable</a></code>, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, using "Species" fixed-effects
res = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)

# the coefficients of the variables:
coef(res)

# the fixed-effects coefficients:
fixef(res)


</code></pre>

<hr>
<h2 id='coef.fixest_multi'>Extracts the coefficients of fixest_multi objects</h2><span id='topic+coef.fixest_multi'></span><span id='topic+coefficients.fixest_multi'></span>

<h3>Description</h3>

<p>Utility to extract the coefficients of multiple estimations and rearrange them into a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_multi'
coef(
  object,
  keep,
  drop,
  order,
  collin = FALSE,
  long = FALSE,
  na.rm = TRUE,
  ...
)

## S3 method for class 'fixest_multi'
coefficients(
  object,
  keep,
  drop,
  order,
  collin = FALSE,
  long = FALSE,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.fixest_multi_+3A_object">object</code></td>
<td>
<p>A <code>fixest_multi</code> object. Obtained from a multiple estimation.</p>
</td></tr>
<tr><td><code id="coef.fixest_multi_+3A_keep">keep</code></td>
<td>
<p>Character vector. This element is used to display only a subset of variables. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be kept. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code>keep = "x[[:digit:]]$"</code>. If the first character is an exclamation mark, the effect is reversed (e.g. keep = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is kept). See details.</p>
</td></tr>
<tr><td><code id="coef.fixest_multi_+3A_drop">drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be discarded. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code style="white-space: pre;">&#8288;drop = "x[[:digit:]]{2}&#8288;</code>&quot;. If the first character is an exclamation mark, the effect is reversed (e.g. drop = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is dropped). See details.</p>
</td></tr>
<tr><td><code id="coef.fixest_multi_+3A_order">order</code></td>
<td>
<p>Character vector. This element is used if the user wants the variables to be ordered in a certain way. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). The variables satisfying the first regular expression will be placed first, then the order follows the sequence of regular expressions. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the following variables: <code>month1</code> to <code>month6</code>, then <code>x1</code> to <code>x5</code>, then <code>year1</code> to <code>year6</code>. If you want to display first the x's, then the years, then the months you could use: <code>order = c("x", "year")</code>. If the first character is an exclamation mark, the effect is reversed (e.g. order = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; goes first).  See details.</p>
</td></tr>
<tr><td><code id="coef.fixest_multi_+3A_collin">collin</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether the coefficients removed because of collinearity should be also returned as <code>NA</code>. It cannot be used when coefficients aggregation is also used.</p>
</td></tr>
<tr><td><code id="coef.fixest_multi_+3A_long">long</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether the results should be displayed in a long format.</p>
</td></tr>
<tr><td><code id="coef.fixest_multi_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Only applies when <code>long = TRUE</code>: whether to remove the coefficients with <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="coef.fixest_multi_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

# A multiple estimation
est = feols(y ~ x1 + csw0(x2, x3), base)

# Getting all the coefficients at once,
# each row is a model
coef(est)

# Example of keep/drop/order
coef(est, keep = "Int|x1", order = "x1")


# To change the order of the model, use fixest_multi
# extraction tools:
coef(est[rhs = .N:1])

# collin + long + na.rm
base$x1_bis = base$x1 # =&gt; collinear
est = feols(y ~ x1_bis + csw0(x1, x2, x3), base, split = ~species)

# does not display x1 since it is always collinear
coef(est)
# now it does
coef(est, collin = TRUE)

# long
coef(est, long = TRUE)

# long but balanced (with NAs then)
coef(est, long = TRUE, na.rm = FALSE)


</code></pre>

<hr>
<h2 id='coefplot'>Plots confidence intervals and point estimates</h2><span id='topic+coefplot'></span><span id='topic+iplot'></span>

<h3>Description</h3>

<p>This function plots the results of estimations (coefficients and confidence intervals).
The function <code>iplot</code> restricts the output to variables created with <code><a href="#topic+i">i</a></code>, either
interactions with factors or raw factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefplot(
  object,
  ...,
  style = NULL,
  sd,
  ci_low,
  ci_high,
  df.t = NULL,
  x,
  x.shift = 0,
  horiz = FALSE,
  dict = getFixest_dict(),
  keep,
  drop,
  order,
  ci.width = "1%",
  ci_level = 0.95,
  add = FALSE,
  pt.pch = c(20, 17, 15, 21, 24, 22),
  pt.bg = NULL,
  cex = 1,
  pt.cex = cex,
  col = 1:8,
  pt.col = col,
  ci.col = col,
  lwd = 1,
  pt.lwd = lwd,
  ci.lwd = lwd,
  ci.lty = 1,
  grid = TRUE,
  grid.par = list(lty = 3, col = "gray"),
  zero = TRUE,
  zero.par = list(col = "black", lwd = 1),
  pt.join = FALSE,
  pt.join.par = list(col = pt.col, lwd = lwd),
  ci.join = FALSE,
  ci.join.par = list(lwd = lwd, col = col, lty = 2),
  ci.fill = FALSE,
  ci.fill.par = list(col = "lightgray", alpha = 0.5),
  ref = "auto",
  ref.line = "auto",
  ref.line.par = list(col = "black", lty = 2),
  lab.cex,
  lab.min.cex = 0.85,
  lab.max.mar = 0.25,
  lab.fit = "auto",
  xlim.add,
  ylim.add,
  only.params = FALSE,
  sep,
  as.multiple = FALSE,
  bg,
  group = "auto",
  group.par = list(lwd = 2, line = 3, tcl = 0.75),
  main = "Effect on __depvar__",
  value.lab = "Estimate and __ci__ Conf. Int.",
  ylab = NULL,
  xlab = NULL,
  sub = NULL
)

iplot(
  object,
  ...,
  i.select = 1,
  style = NULL,
  sd,
  ci_low,
  ci_high,
  df.t = NULL,
  x,
  x.shift = 0,
  horiz = FALSE,
  dict = getFixest_dict(),
  keep,
  drop,
  order,
  ci.width = "1%",
  ci_level = 0.95,
  add = FALSE,
  pt.pch = c(20, 17, 15, 21, 24, 22),
  pt.bg = NULL,
  cex = 1,
  pt.cex = cex,
  col = 1:8,
  pt.col = col,
  ci.col = col,
  lwd = 1,
  pt.lwd = lwd,
  ci.lwd = lwd,
  ci.lty = 1,
  grid = TRUE,
  grid.par = list(lty = 3, col = "gray"),
  zero = TRUE,
  zero.par = list(col = "black", lwd = 1),
  pt.join = FALSE,
  pt.join.par = list(col = pt.col, lwd = lwd),
  ci.join = FALSE,
  ci.join.par = list(lwd = lwd, col = col, lty = 2),
  ci.fill = FALSE,
  ci.fill.par = list(col = "lightgray", alpha = 0.5),
  ref = "auto",
  ref.line = "auto",
  ref.line.par = list(col = "black", lty = 2),
  lab.cex,
  lab.min.cex = 0.85,
  lab.max.mar = 0.25,
  lab.fit = "auto",
  xlim.add,
  ylim.add,
  only.params = FALSE,
  sep,
  as.multiple = FALSE,
  bg,
  group = "auto",
  group.par = list(lwd = 2, line = 3, tcl = 0.75),
  main = "Effect on __depvar__",
  value.lab = "Estimate and __ci__ Conf. Int.",
  ylab = NULL,
  xlab = NULL,
  sub = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefplot_+3A_object">object</code></td>
<td>
<p>Can be either: i) an estimation object (obtained for example from
<code><a href="#topic+feols">feols</a></code>, ii) a list of estimation objects (several results will be plotted at
once), iii) a matrix of coefficients table, iv) a numeric vector of the point
estimates &ndash; the latter requiring the extra arguments <code>sd</code> or <code>ci_low</code> and <code>ci_high</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>summary</code>, if <code>object</code> is an estimation,
and/or to the function <code>plot</code> or <code>lines</code> (if <code>add = TRUE</code>).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_style">style</code></td>
<td>
<p>A character scalar giving the style of the plot to be used. You
can set styles with the function <code><a href="#topic+setFixest_coefplot">setFixest_coefplot</a></code>, setting all the default
values of the function. If missing, then it switches to either &quot;default&quot; or &quot;iplot&quot;,
depending on the calling function.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_sd">sd</code></td>
<td>
<p>The standard errors of the estimates. It may be missing.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci_low">ci_low</code></td>
<td>
<p>If <code>sd</code> is not provided, the lower bound of the confidence interval.
For each estimate.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci_high">ci_high</code></td>
<td>
<p>If <code>sd</code> is not provided, the upper bound of the confidence interval.
For each estimate.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_df.t">df.t</code></td>
<td>
<p>Integer scalar or <code>NULL</code> (default). The degrees of freedom (DoF) to use
when computing the confidence intervals with the Student t. By default it
tries to capture the DoF from the estimation. To use a Normal law to compute the
confidence interval, use <code>df.t = Inf</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_x">x</code></td>
<td>
<p>The value of the x-axis. If missing, the names of the argument <code>estimate</code>
are used.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_x.shift">x.shift</code></td>
<td>
<p>Shifts the confidence intervals bars to the left or right, depending
on the value of <code>x.shift</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_horiz">horiz</code></td>
<td>
<p>A logical scalar, default is <code>FALSE</code>. Whether to display the confidence
intervals horizontally instead of vertically.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_dict">dict</code></td>
<td>
<p>A named character vector or a logical scalar. It changes the original variable names to the ones contained in the <code>dict</code>ionary. E.g. to change the variables named <code>a</code> and <code>b3</code> to (resp.) &ldquo;$log(a)$&rdquo; and to &ldquo;$bonus^3$&rdquo;, use <code>dict=c(a="$log(a)$",b3="$bonus^3$")</code>. By default, it is equal to <code>getFixest_dict()</code>, a default dictionary which can be set with <code><a href="#topic+setFixest_dict">setFixest_dict</a></code>. You can use <code>dict = FALSE</code> to disable it. By default <code>dict</code> modifies the entries in the global dictionary, to disable this behavior, use &quot;reset&quot; as the first element (ex: <code>dict=c("reset", mpg="Miles per gallon")</code>).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_keep">keep</code></td>
<td>
<p>Character vector. This element is used to display only a subset of variables. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be kept. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code>keep = "x[[:digit:]]$"</code>. If the first character is an exclamation mark, the effect is reversed (e.g. keep = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is kept). See details.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_drop">drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be discarded. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code style="white-space: pre;">&#8288;drop = "x[[:digit:]]{2}&#8288;</code>&quot;. If the first character is an exclamation mark, the effect is reversed (e.g. drop = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is dropped). See details.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_order">order</code></td>
<td>
<p>Character vector. This element is used if the user wants the variables to be ordered in a certain way. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). The variables satisfying the first regular expression will be placed first, then the order follows the sequence of regular expressions. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the following variables: <code>month1</code> to <code>month6</code>, then <code>x1</code> to <code>x5</code>, then <code>year1</code> to <code>year6</code>. If you want to display first the x's, then the years, then the months you could use: <code>order = c("x", "year")</code>. If the first character is an exclamation mark, the effect is reversed (e.g. order = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; goes first).  See details.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci.width">ci.width</code></td>
<td>
<p>The width of the extremities of the confidence intervals. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci_level">ci_level</code></td>
<td>
<p>Scalar between 0 and 1: the level of the CI. By default it is equal to 0.95.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_add">add</code></td>
<td>
<p>Default is <code>FALSE</code>, if the intervals are to be added to an existing
graph. Note that if it is the case, then the argument <code>x</code> MUST be numeric.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_pt.pch">pt.pch</code></td>
<td>
<p>The patch of the coefficient estimates. Default is 1 (circle).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_pt.bg">pt.bg</code></td>
<td>
<p>The background color of the point estimate (when the <code>pt.pch</code> is
in 21 to 25). Defaults to NULL.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_cex">cex</code></td>
<td>
<p>Numeric, default is 1. Expansion factor for the points</p>
</td></tr>
<tr><td><code id="coefplot_+3A_pt.cex">pt.cex</code></td>
<td>
<p>The size of the coefficient estimates. Default is the other argument <code>cex</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_col">col</code></td>
<td>
<p>The color of the points and the confidence intervals. Default is 1
(&quot;black&quot;). Note that you can set the colors separately for each of them with <code>pt.col</code> and <code>ci.col</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_pt.col">pt.col</code></td>
<td>
<p>The color of the coefficient estimates. Default is equal to the other argument <code>col</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci.col">ci.col</code></td>
<td>
<p>The color of the confidence intervals. Default is equal to the other argument <code>col</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lwd">lwd</code></td>
<td>
<p>General line with. Default is 1.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_pt.lwd">pt.lwd</code></td>
<td>
<p>The line width of the coefficient estimates. Default is equal to
the other argument <code>lwd</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci.lwd">ci.lwd</code></td>
<td>
<p>The line width of the confidence intervals. Default is equal to
the other argument <code>lwd</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci.lty">ci.lty</code></td>
<td>
<p>The line type of the confidence intervals. Default is 1.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_grid">grid</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether a grid should be displayed. You
can set the display of the grid with the argument <code>grid.par</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_grid.par">grid.par</code></td>
<td>
<p>List. Parameters of the grid. The default values are: <code>lty =  3</code> and <code>col = "gray"</code>. You can add any graphical parameter that will be passed
to <code><a href="graphics.html#topic+abline">graphics::abline</a></code>. You also have two additional arguments: use <code>horiz =  FALSE</code> to disable the horizontal lines, and use <code>vert = FALSE</code> to disable the
vertical lines. Eg: <code>grid.par = list(vert = FALSE, col = "red", lwd = 2)</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_zero">zero</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether the 0-line should be emphasized.
You can set the parameters of that line with the argument <code>zero.par</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_zero.par">zero.par</code></td>
<td>
<p>List. Parameters of the zero-line. The default values are
<code>col = "black"</code> and <code>lwd = 1</code>. You can add any graphical parameter that will be passed
to <code><a href="graphics.html#topic+abline">graphics::abline</a></code>. Example: <code>zero.par = list(col = "darkblue", lwd = 3)</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_pt.join">pt.join</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then the coefficient estimates
are joined with a line.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_pt.join.par">pt.join.par</code></td>
<td>
<p>List. Parameters of the line joining the coefficients. The
default values are: <code>col = pt.col</code> and <code>lwd = lwd</code>. You can add any graphical
parameter that will be passed to <code><a href="graphics.html#topic+lines">lines</a></code>. Eg: <code>pt.join.par = list(lty = 2)</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci.join">ci.join</code></td>
<td>
<p>Logical default to <code>FALSE</code>. Whether to join the extremities of
the confidence intervals. If <code>TRUE</code>, then you can set the graphical parameters
with the argument <code>ci.join.par</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci.join.par">ci.join.par</code></td>
<td>
<p>A list of parameters to be passed to <code><a href="graphics.html#topic+lines">graphics::lines</a></code>.
Only used if <code>ci.join=TRUE</code>. By default it is equal to <code>list(lwd = lwd, col = col, lty = 2)</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci.fill">ci.fill</code></td>
<td>
<p>Logical default to <code>FALSE</code>. Whether to fill the confidence intervals
with a color. If <code>TRUE</code>, then you can set the graphical parameters with the argument <code>ci.fill.par</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ci.fill.par">ci.fill.par</code></td>
<td>
<p>A list of parameters to be passed to <code><a href="graphics.html#topic+polygon">graphics::polygon</a></code>.
Only used if <code>ci.fill=TRUE</code>. By default it is equal to <code>list(col = "lightgray", alpha = 0.5)</code>.
Note that <code>alpha</code> is a special parameter that adds transparency to the color (ranges from 0 to 1).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ref">ref</code></td>
<td>
<p>Used to add points equal to 0 (typically to visualize reference points).
Either: i) &quot;auto&quot; (default), ii) a character vector of length 1, iii) a list
of length 1, iv) a named integer vector of length 1, or v) a numeric vector.
By default, in <code>iplot</code>, if the argument <code>ref</code> has been used in the estimation,
these references are automatically added. If ii), ie a character scalar, then
that coefficient equal to zero is added as the first coefficient. If a list or
a named integer vector of length 1, then the integer gives the position of the
reference among the coefficients and the name gives the coefficient name. A non-named
numeric value of <code>ref</code> only works if the x-axis is also numeric (which can happen
in <code>iplot</code>).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ref.line">ref.line</code></td>
<td>
<p>Logical or numeric, default is &quot;auto&quot;, whose behavior depends
on the situation. It is <code>TRUE</code> only if: i) interactions are plotted, ii) the
x values are numeric and iii) a reference is found. If <code>TRUE</code>, then a vertical
line is drawn at the level of the reference value. Otherwise, if numeric a vertical
line will be drawn at that specific value.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ref.line.par">ref.line.par</code></td>
<td>
<p>List. Parameters of the vertical line on the reference. The
default values are: <code>col = "black"</code> and <code>lty = 2</code>. You can add any graphical
parameter that will be passed to <code><a href="graphics.html#topic+abline">graphics::abline</a></code>. Eg: <code>ref.line.par = list(lty = 1, lwd = 3)</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lab.cex">lab.cex</code></td>
<td>
<p>The size of the labels of the coefficients. Default is missing.
It is automatically set by an internal algorithm which can go as low as <code>lab.min.cex</code>
(another argument).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lab.min.cex">lab.min.cex</code></td>
<td>
<p>The minimum size of the coefficients labels, as set by the
internal algorithm. Default is 0.85.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lab.max.mar">lab.max.mar</code></td>
<td>
<p>The maximum size the left margin can take when trying to fit
the coefficient labels into it (only when <code>horiz = TRUE</code>). This is used in the
internal algorithm fitting the coefficient labels. Default is <code>0.25</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lab.fit">lab.fit</code></td>
<td>
<p>The method to fit the coefficient labels into the plotting region
(only when <code>horiz = FALSE</code>). Can be <code>"auto"</code> (the default), <code>"simple"</code>, <code>"multi"</code>
or <code>"tilted"</code>. If <code>"simple"</code>, then the classic axis is drawn. If <code>"multi"</code>, then
the coefficient labels are fit horizontally across several lines, such that they
don't collide. If <code>"tilted"</code>, then the labels are tilted. If <code>"auto"</code>, an automatic
choice between the three is made.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_xlim.add">xlim.add</code></td>
<td>
<p>A numeric vector of length 1 or 2. It represents an extension
factor of xlim, in percentage. Eg: <code>xlim.add = c(0, 0.5)</code> extends <code>xlim</code> of 50%
on the right. If of length 1, positive values represent the right, and negative
values the left (Eg: <code>xlim.add = -0.5</code> is equivalent to <code>xlim.add = c(0.5, 0)</code>).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ylim.add">ylim.add</code></td>
<td>
<p>A numeric vector of length 1 or 2. It represents an extension
factor of ylim, in percentage. Eg: <code>ylim.add = c(0, 0.5)</code> extends <code>ylim</code> of 50%
on the top. If of length 1, positive values represent the top, and negative values
the bottom (Eg: <code>ylim.add = -0.5</code> is equivalent to <code>ylim.add = c(0.5, 0)</code>).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_only.params">only.params</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> no graphic is displayed,
only the values of <code>x</code> and <code>y</code> used in the plot are returned.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_sep">sep</code></td>
<td>
<p>The distance between two estimates &ndash; only when argument <code>object</code>
is a list of estimation results.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_as.multiple">as.multiple</code></td>
<td>
<p>Logical: default is <code>FALSE</code>. Only when <code>object</code> is a single
estimation result: whether each coefficient should have a different color, line
type, etc. By default they all get the same style.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_bg">bg</code></td>
<td>
<p>Background color for the plot. By default it is white.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_group">group</code></td>
<td>
<p>A list, default is missing. Each element of the list reports the
coefficients to be grouped while the name of the element is the group name. Each
element of the list can be either: i) a character vector of length 1, ii) of
length 2, or ii) a numeric vector. If equal to: i) then it is interpreted as
a pattern: all element fitting the regular expression will be grouped (note that
you can use the special character &quot;^^&quot; to clean the beginning of the names, see
example), if ii) it corrsponds to the first and last elements to be grouped,
if iii) it corresponds to the coefficients numbers to be grouped. If equal to
a character vector, you can use a percentage to tell the algorithm to look at
the coefficients before aliasing (e.g. <code>"%varname"</code>). Example of valid uses:
<code style="white-space: pre;">&#8288;group=list(group_name=\"pattern\")&#8288;</code>, <code style="white-space: pre;">&#8288;group=list(group_name=c(\"var_start\", \"var_end\"))&#8288;</code>,
<code style="white-space: pre;">&#8288;group=list(group_name=1:2))&#8288;</code>. See details.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_group.par">group.par</code></td>
<td>
<p>A list of parameters controlling the display of the group. The
parameters controlling the line are: <code>lwd</code>, <code>tcl</code> (length of the tick), <code>line.adj</code>
(adjustment of the position, default is 0), <code>tick</code> (whether to add the ticks),
<code>lwd.ticks</code>, <code>col.ticks</code>. Then the parameters controlling the text: <code>text.adj</code>
(adjustment of the position, default is 0), <code>text.cex</code>, <code>text.font</code>, <code>text.col</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_main">main</code></td>
<td>
<p>The title of the plot. Default is <code>"Effect on __depvar__"</code>. You can
use the special variable <code style="white-space: pre;">&#8288;__depvar__&#8288;</code> to set the title (useful when you set the
plot default with <code><a href="#topic+setFixest_coefplot">setFixest_coefplot</a></code>).</p>
</td></tr>
<tr><td><code id="coefplot_+3A_value.lab">value.lab</code></td>
<td>
<p>The label to appear on the side of the coefficient values. If
<code>horiz = FALSE</code>, the label appears in the y-axis. If <code>horiz = TRUE</code>, then it
appears on the x-axis. The default is equal to <code>"Estimate and __ci__ Conf. Int."</code>,
with <code style="white-space: pre;">&#8288;__ci__&#8288;</code> a special variable giving the value of the confidence interval.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_ylab">ylab</code></td>
<td>
<p>The label of the y-axis, default is <code>NULL</code>. Note that if <code>horiz =  FALSE</code>, it overrides the value of the argument <code>value.lab</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_xlab">xlab</code></td>
<td>
<p>The label of the x-axis, default is <code>NULL</code>. Note that if <code>horiz =  TRUE</code>, it overrides the value of the argument <code>value.lab</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_sub">sub</code></td>
<td>
<p>A subtitle, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_i.select">i.select</code></td>
<td>
<p>Integer scalar, default is 1. In <code>iplot</code>, used to select which
variable created with <code>i()</code> to select. Only used when there are several variables
created with <code><a href="#topic+i">i</a></code>. This is an index, just try increasing numbers to hopefully
obtain what you want. Note that it works much better when the variables are &quot;pure&quot;
<code>i()</code> variables and not interacted with other variables. For example: <code>i(species, x1)</code>
is good while <code>i(species):x1</code> isn't. The latter will also work but the index
may feel weird in case there are many <code>i()</code> variables.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>iplot()</code>: Plots the coefficients generated with i()
</p>
</li></ul>


<h3>Setting custom default values</h3>

<p>The function <code>coefplot</code> dispose of many arguments to parametrize the plots. Most
of these arguments can be set once an for all using the function <code><a href="#topic+setFixest_coefplot">setFixest_coefplot</a></code>.
See Example 3 below for a demonstration.
</p>


<h3>iplot</h3>

<p>The function <code>iplot</code> restricts <code>coefplot</code> to interactions or factors created
with the function <code><a href="#topic+i">i</a></code>. Only <em>one</em> of the i-variables will be plotted at a time.
If you have several i-variables, you can navigate through them with the <code>i.select</code> argument.
</p>
<p>The argument <code>i.select</code> is an index that will go through all the i-variables.
It will work well if the variables are pure, meaning not interacted with other
variables. If the i-variables are interacted, the index may have an odd behavior
but will (in most cases) work all the same, just try some numbers up until you
(hopefully) obtain the graph you want.
</p>
<p>Note, importantly, that interactions of two factor variables are (in general)
disregarded since they would require a 3-D plot to be properly represented.
</p>


<h3>Arguments keep, drop and order</h3>

<p>The arguments <code>keep</code>, <code>drop</code> and <code>order</code> use regular expressions. If you are not aware of regular expressions, I urge you to learn it, since it is an extremely powerful way to manipulate character strings (and it exists across most programming languages).
</p>
<p>For example drop = &quot;Wind&quot; would drop any variable whose name contains &quot;Wind&quot;. Note that variables such as &quot;Temp:Wind&quot; or &quot;StrongWind&quot; do contain &quot;Wind&quot;, so would be dropped. To drop only the variable named &quot;Wind&quot;, you need to use <code>drop = "^Wind$"</code> (with &quot;^&quot; meaning beginning, resp. &quot;$&quot; meaning end, of the string =&gt; this is the language of regular expressions).
</p>
<p>Although you can combine several regular expressions in a single character string using pipes, <code>drop</code> also accepts a vector of regular expressions.
</p>
<p>You can use the special character &quot;!&quot; (exclamation mark) to reverse the effect of the regular expression (this feature is specific to this function). For example <code>drop = "!Wind"</code> would drop any variable that does not contain &quot;Wind&quot;.
</p>
<p>You can use the special character &quot;%&quot; (percentage) to make reference to the original variable name instead of the aliased name. For example, you have a variable named <code>"Month6"</code>, and use a dictionary <code>dict = c(Month6="June")</code>. Thus the variable will be displayed as <code>"June"</code>. If you want to delete that variable, you can use either <code>drop="June"</code>, or <code>drop="%Month6"</code> (which makes reference to its original name).
</p>
<p>The argument <code>order</code> takes in a vector of regular expressions, the order will follow the elements of this vector. The vector gives a list of priorities, on the left the elements with highest priority. For example, order = c(&quot;Wind&quot;, &quot;!Inter&quot;, &quot;!Temp&quot;) would give highest priorities to the variables containing &quot;Wind&quot; (which would then appear first), second highest priority is the variables not containing &quot;Inter&quot;, last, with lowest priority, the variables not containing &quot;Temp&quot;. If you had the following variables: (Intercept), Temp:Wind, Wind, Temp you would end up with the following order: Wind, Temp:Wind, Temp, (Intercept).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+setFixest_coefplot">setFixest_coefplot</a></code> to set the default values of <code>coefplot</code>, and the estimation
functions: e.g. <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">fepois</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+femlm">fenegbin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Example 1: Stacking two sets of results on the same graph
#

# Estimation on Iris data with one fixed-effect (Species)
est = feols(Petal.Length ~ Petal.Width + Sepal.Length +
            Sepal.Width | Species, iris)

# Estimation results with clustered standard-errors
# (the default when fixed-effects are present)
est_clu = summary(est)
# Now with "regular" standard-errors
est_std = summary(est, se = "iid")

# You can plot the two results at once
coefplot(list(est_clu, est_std))


# Alternatively, you can use the argument x.shift
# to do it sequentially:

# First graph with clustered standard-errors
coefplot(est, x.shift = -.2)

# 'x.shift' was used to shift the coefficients on the left.

# Second set of results: this time with
#  standard-errors that are not clustered.
coefplot(est, se = "iid", x.shift = .2,
         add = TRUE, col = 2, ci.lty = 2, pch=15)

 # Note that we used 'se', an argument that will
 #  be passed to summary.fixest

legend("topright", col = 1:2, pch = 20, lwd = 1, lty = 1:2,
       legend = c("Clustered", "IID"), title = "Standard-Errors")


#
# Example 2: Interactions
#


# Now we estimate and plot the "yearly" treatment effects

data(base_did)
base_inter = base_did

# We interact the variable 'period' with the variable 'treat'
est_did = feols(y ~ x1 + i(period, treat, 5) | id+period, base_inter)

# In the estimation, the variable treat is interacted
#  with each value of period but 5, set as a reference

# coefplot will show all the coefficients:
coefplot(est_did)

# Note that the grouping of the coefficients is due to 'group = "auto"'

# If you want to keep only the coefficients
# created with i() (ie the interactions), use iplot
iplot(est_did)

# When estimations contain interactions, as before,
#  the default behavior of coefplot changes,
#  it now only plots interactions:
coefplot(est_did)

# We can see that the graph is different from before:
#  - only interactions are shown,
#  - the reference is present,
# =&gt; this is fully flexible

iplot(est_did, ref.line = FALSE, pt.join = TRUE)


#
# What if the interacted variable is not numeric?

# Let's create a "month" variable
all_months = c("aug", "sept", "oct", "nov", "dec", "jan",
               "feb", "mar", "apr", "may", "jun", "jul")
base_inter$period_month = all_months[base_inter$period]

# The new estimation
est = feols(y ~ x1 + i(period_month, treat, "oct") | id+period, base_inter)
# Since 'period_month' of type character, coefplot sorts it
iplot(est)

# To respect a plotting order, use a factor
base_inter$month_factor = factor(base_inter$period_month, levels = all_months)
est = feols(y ~ x1 + i(month_factor, treat, "oct") | id+period, base_inter)
iplot(est)


#
# Example 3: Setting defaults
#

# coefplot has many arguments, which makes it highly flexible.
# If you don't like the default style of coefplot. No worries,
# you can set *your* default by using the function
# setFixest_coefplot()

dict = c("Petal.Length"="Length (Petal)", "Petal.Width"="Width (Petal)",
         "Sepal.Length"="Length (Sepal)", "Sepal.Width"="Width (Sepal)")

setFixest_coefplot(ci.col = 2, pt.col = "darkblue", ci.lwd = 3,
                   pt.cex = 2, pt.pch = 15, ci.width = 0, dict = dict)

est = feols(Petal.Length ~ Petal.Width + Sepal.Length +
                Sepal.Width + i(Species), iris)

# And that's it
coefplot(est)

# You can set separate default values for iplot
setFixest_coefplot("iplot", pt.join = TRUE, pt.join.par = list(lwd = 2, lty = 2))
iplot(est)

# To reset to the default settings:
setFixest_coefplot("all", reset = TRUE)
coefplot(est)

#
# Example 4: group + cleaning
#

# You can use the argument group to group variables
# You can further use the special character "^^" to clean
#  the beginning of the coef. name: particularly useful for factors

est = feols(Petal.Length ~ Petal.Width + Sepal.Length +
                Sepal.Width + Species, iris)

# No grouping:
coefplot(est)

# now we group by Sepal and Species
coefplot(est, group = list(Sepal = "Sepal", Species = "Species"))

# now we group + clean the beginning of the names using the special character ^^
coefplot(est, group = list(Sepal = "^^Sepal.", Species = "^^Species"))


</code></pre>

<hr>
<h2 id='coeftable'>Extracts the coefficients table from an estimation</h2><span id='topic+coeftable'></span><span id='topic+se'></span><span id='topic+pvalue'></span><span id='topic+tstat'></span>

<h3>Description</h3>

<p>Methods to extracts the coefficients table and its sub-components from an estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeftable(object, ...)

se(object, ...)

pvalue(object, ...)

tstat(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeftable_+3A_object">object</code></td>
<td>
<p>An estimation (fitted model object), e.g. a <code>fixest</code> object.</p>
</td></tr>
<tr><td><code id="coeftable_+3A_...">...</code></td>
<td>
<p>Other arguments to the methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix (<code>coeftable</code>) or vectors.
</p>


<h3>See Also</h3>

<p>Please look at the <code><a href="#topic+coeftable.fixest">coeftable.fixest</a></code> page for more detailed information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
est = lm(mpg ~ cyl, mtcars)
coeftable(est)

</code></pre>

<hr>
<h2 id='coeftable.default'>Extracts the coefficients table from an estimation</h2><span id='topic+coeftable.default'></span><span id='topic+se.default'></span><span id='topic+tstat.default'></span><span id='topic+pvalue.default'></span><span id='topic+se.matrix'></span>

<h3>Description</h3>

<p>Default method to extracts the coefficients table and its sub-components from an estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
coeftable(object, keep, drop, order, ...)

## Default S3 method:
se(object, keep, drop, order, ...)

## Default S3 method:
tstat(object, keep, drop, order, ...)

## Default S3 method:
pvalue(object, keep, drop, order, ...)

## S3 method for class 'matrix'
se(object, keep, drop, order, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeftable.default_+3A_object">object</code></td>
<td>
<p>The result of an estimation (a fitted model object). Note that this function is made to work with <code>fixest</code> objects so it may not work for the specific model you provide.</p>
</td></tr>
<tr><td><code id="coeftable.default_+3A_keep">keep</code></td>
<td>
<p>Character vector. This element is used to display only a subset of variables. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be kept. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code>keep = "x[[:digit:]]$"</code>. If the first character is an exclamation mark, the effect is reversed (e.g. keep = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is kept). See details.</p>
</td></tr>
<tr><td><code id="coeftable.default_+3A_drop">drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be discarded. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code style="white-space: pre;">&#8288;drop = "x[[:digit:]]{2}&#8288;</code>&quot;. If the first character is an exclamation mark, the effect is reversed (e.g. drop = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is dropped). See details.</p>
</td></tr>
<tr><td><code id="coeftable.default_+3A_order">order</code></td>
<td>
<p>Character vector. This element is used if the user wants the variables to be ordered in a certain way. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). The variables satisfying the first regular expression will be placed first, then the order follows the sequence of regular expressions. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the following variables: <code>month1</code> to <code>month6</code>, then <code>x1</code> to <code>x5</code>, then <code>year1</code> to <code>year6</code>. If you want to display first the x's, then the years, then the months you could use: <code>order = c("x", "year")</code>. If the first character is an exclamation mark, the effect is reversed (e.g. order = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; goes first).  See details.</p>
</td></tr>
<tr><td><code id="coeftable.default_+3A_...">...</code></td>
<td>
<p>Other arguments that will be passed to <code>summary</code>.
</p>
<p>First the method summary is applied if needed, then the coefficients table is extracted from its output.
</p>
<p>The default method is very naive and hopes that the resulting coefficients table contained in the summary of the fitted model is well formed: this assumption is very often wrong. Anyway, there is no development intended since the coeftable/se/pvalue/tstat series of methods is only intended to work well with <code>fixest</code> objects. To extract the coefficients table from fitted models in a general way, it's better to use <a href="https://broom.tidymodels.org/">tidy from broom</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix (<code>coeftable</code>) or vectors.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>se(default)</code>: Extracts the standard-errors from an estimation
</p>
</li>
<li> <p><code>tstat(default)</code>: Extracts the standard-errors from an estimation
</p>
</li>
<li> <p><code>pvalue(default)</code>: Extracts the p-values from an estimation
</p>
</li>
<li> <p><code>se(matrix)</code>: Extracts the standard-errors from a VCOV matrix
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# NOTA: This function is really made to handle fixest objects
# The default methods works for simple structures, but you'd be
# likely better off with broom::tidy for other models

est = lm(mpg ~ cyl, mtcars)
coeftable(est)

se(est)





</code></pre>

<hr>
<h2 id='coeftable.fixest'>Obtain various statistics from an estimation</h2><span id='topic+coeftable.fixest'></span><span id='topic+se.fixest'></span><span id='topic+tstat.fixest'></span><span id='topic+pvalue.fixest'></span>

<h3>Description</h3>

<p>Set of functions to directly extract some commonly used statistics, like the p-value or the table of coefficients, from estimations. This was first implemented for <code>fixest</code> estimations, but has some support for other models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
coeftable(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  list = FALSE,
  ...
)

## S3 method for class 'fixest'
se(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  ...
)

## S3 method for class 'fixest'
tstat(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  ...
)

## S3 method for class 'fixest'
pvalue(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeftable.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. For example an estimation obtained from <code><a href="#topic+feols">feols</a></code>.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_+3A_vcov">vcov</code></td>
<td>
<p>A function to be used to compute the standard-errors of each fixest object. You can pass extra arguments to this function using the argument <code>.vcov_args</code>. See the example.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code style="white-space: pre;">&#8288;cluster = base[, c("var1, "var2")]&#8288;</code>, <code style="white-space: pre;">&#8288;cluster = c("var1, "var2")&#8288;</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as clusters in the estimation, you could further use <code>cluster = 1:2</code> or leave it blank with <code>se = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] cluster).</p>
</td></tr>
<tr><td><code id="coeftable.fixest_+3A_keep">keep</code></td>
<td>
<p>Character vector. This element is used to display only a subset of variables. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be kept. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code>keep = "x[[:digit:]]$"</code>. If the first character is an exclamation mark, the effect is reversed (e.g. keep = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is kept). See details.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_+3A_drop">drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be discarded. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code style="white-space: pre;">&#8288;drop = "x[[:digit:]]{2}&#8288;</code>&quot;. If the first character is an exclamation mark, the effect is reversed (e.g. drop = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is dropped). See details.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_+3A_order">order</code></td>
<td>
<p>Character vector. This element is used if the user wants the variables to be ordered in a certain way. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). The variables satisfying the first regular expression will be placed first, then the order follows the sequence of regular expressions. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the following variables: <code>month1</code> to <code>month6</code>, then <code>x1</code> to <code>x5</code>, then <code>year1</code> to <code>year6</code>. If you want to display first the x's, then the years, then the months you could use: <code>order = c("x", "year")</code>. If the first character is an exclamation mark, the effect is reversed (e.g. order = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; goes first).  See details.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_+3A_list">list</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then a nested list is returned, the first layer is accessed with the coefficients names; the second layer with the following values: <code>coef</code>, <code>se</code>, <code>tstat</code>, <code>pvalue</code>. Note that the variable <code>"(Intercept)"</code> is renamed into <code>"constant"</code>.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+summary.fixest">summary.fixest</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This set of tiny functions is primarily constructed for <code>fixest</code> estimations.
</p>


<h3>Value</h3>

<p>Returns a table of coefficients, with in rows the variables and four columns: the estimate, the standard-error, the t-statistic and the p-value.
</p>
<p>If <code>list = TRUE</code> then a nested list is returned, the first layer is accessed with the coefficients names; the second layer with the following values: <code>coef</code>, <code>se</code>, <code>tstat</code>, <code>pvalue</code>. For example, with <code>res = coeftable(est, list = TRUE)</code> you can access the SE of the coefficient <code>x1</code> with <code>res$x1$se</code>; and its coefficient with <code>res$x1$coef</code>, etc.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>se(fixest)</code>: Extracts the standard-error of an estimation
</p>
</li>
<li> <p><code>tstat(fixest)</code>: Extracts the t-statistics of an estimation
</p>
</li>
<li> <p><code>pvalue(fixest)</code>: Extracts the p-value of an estimation
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Some data and estimation
data(trade)
est = fepois(Euros ~ log(dist_km) | Origin^Product + Year, trade)

#
# Coeftable/se/tstat/pvalue
#

# Default is clustering along Origin^Product
coeftable(est)
se(est)
tstat(est)
pvalue(est)

# Now with two-way clustered standard-errors
#  and using coeftable()

coeftable(est, cluster = ~Origin + Product)
se(est, cluster = ~Origin + Product)
pvalue(est, cluster = ~Origin + Product)
tstat(est, cluster = ~Origin + Product)

# Or you can cluster only once:
est_sum = summary(est, cluster = ~Origin + Product)
coeftable(est_sum)
se(est_sum)
tstat(est_sum)
pvalue(est_sum)

# You can use the arguments keep, drop, order
# to rearrange the results

base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

est_iv = feols(y ~ x1 | x2 ~ x3, base)

tstat(est_iv, keep = "x1")
coeftable(est_iv, keep = "x1|Int")

coeftable(est_iv, order = "!Int")

#
# Using lists
#

# Returning the coefficients table as a list can be useful for quick
# reference in markdown documents.
# Note that the "(Intercept)" is renamed into "constant"

res = coeftable(est_iv, list = TRUE)

# coefficient of the constant:
res$constant$coef

# pvalue of x1
res$x1$pvalue



</code></pre>

<hr>
<h2 id='coeftable.fixest_multi'>Extracts the coefficients tables from <code>fixest_multi</code> estimations</h2><span id='topic+coeftable.fixest_multi'></span><span id='topic+se.fixest_multi'></span><span id='topic+tstat.fixest_multi'></span><span id='topic+pvalue.fixest_multi'></span>

<h3>Description</h3>

<p>Series of methods to extract the coefficients table or its sub-components from a <code>fixest_multi</code> objects (i.e. the outcome of multiple estimations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_multi'
coeftable(
  object,
  vcov = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  long = FALSE,
  wide = FALSE,
  ...
)

## S3 method for class 'fixest_multi'
se(
  object,
  vcov = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  long = FALSE,
  ...
)

## S3 method for class 'fixest_multi'
tstat(
  object,
  vcov = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  long = FALSE,
  ...
)

## S3 method for class 'fixest_multi'
pvalue(
  object,
  vcov = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  long = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeftable.fixest_multi_+3A_object">object</code></td>
<td>
<p>A <code>fixest_multi</code> object, coming from a <code>fixest</code> multiple estimation.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_multi_+3A_vcov">vcov</code></td>
<td>
<p>A function to be used to compute the standard-errors of each fixest object. You can pass extra arguments to this function using the argument <code>.vcov_args</code>. See the example.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_multi_+3A_keep">keep</code></td>
<td>
<p>Character vector. This element is used to display only a subset of variables. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be kept. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code>keep = "x[[:digit:]]$"</code>. If the first character is an exclamation mark, the effect is reversed (e.g. keep = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is kept). See details.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_multi_+3A_drop">drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be discarded. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code style="white-space: pre;">&#8288;drop = "x[[:digit:]]{2}&#8288;</code>&quot;. If the first character is an exclamation mark, the effect is reversed (e.g. drop = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is dropped). See details.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_multi_+3A_order">order</code></td>
<td>
<p>Character vector. This element is used if the user wants the variables to be ordered in a certain way. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). The variables satisfying the first regular expression will be placed first, then the order follows the sequence of regular expressions. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the following variables: <code>month1</code> to <code>month6</code>, then <code>x1</code> to <code>x5</code>, then <code>year1</code> to <code>year6</code>. If you want to display first the x's, then the years, then the months you could use: <code>order = c("x", "year")</code>. If the first character is an exclamation mark, the effect is reversed (e.g. order = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; goes first).  See details.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_multi_+3A_long">long</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then all the information is stacked, with two columns containing the information: <code>"param"</code> and <code>"value"</code>. The column <code>param</code> contains the values <code>coef</code>/<code>se</code>/<code>tstat</code>/<code>pvalue</code>.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_multi_+3A_wide">wide</code></td>
<td>
<p>A logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then a list is returned: the elements of the list are coef/se/tstat/pvalue. Each element of the list is a wide table with a column per coefficient.</p>
</td></tr>
<tr><td><code id="coeftable.fixest_multi_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+summary.fixest">summary.fixest</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a <code>data.frame</code> containing the coefficients tables (or just the se/pvalue/tstat) along with the information on which model was estimated.
</p>
<p>If <code>wide = TRUE</code>, then a list is returned. The elements of the list are coef/se/tstat/pvalue. Each element of the list is a wide table with a column per coefficient.
</p>
<p>If <code>long = TRUE</code>, then all the information is stacked. This removes the 4 columns containing the coefficient estimates to the p-values, and replace them with two new columns: <code>"param"</code> and <code>"value"</code>. The column <code>param</code> contains the values <code>coef</code>/<code>se</code>/<code>tstat</code>/<code>pvalue</code>, and the column <code>values</code> the associated numerical information.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>se(fixest_multi)</code>: Extracts the standard-errors from <code>fixest_multi</code> estimations
</p>
</li>
<li> <p><code>tstat(fixest_multi)</code>: Extracts the t-stats from <code>fixest_multi</code> estimations
</p>
</li>
<li> <p><code>pvalue(fixest_multi)</code>: Extracts the p-values from <code>fixest_multi</code> estimations
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
base = setNames(iris, c("y", "x1", "x2", "x3", "species"))
est_multi = feols(y~ csw(x.[,1:3]), base, split = ~species)

# we get all the coefficient tables at once
coeftable(est_multi)

# Now just the standard-errors
se(est_multi)

# wide = TRUE =&gt; leads toa  list of wide tables
coeftable(est_multi, wide = TRUE)

# long = TRUE, all the information is stacked
coeftable(est_multi, long = TRUE)



</code></pre>

<hr>
<h2 id='collinearity'>Collinearity diagnostics for <code>fixest</code> objects</h2><span id='topic+collinearity'></span>

<h3>Description</h3>

<p>In some occasions, the optimization algorithm of <code><a href="#topic+femlm">femlm</a></code> may fail to converge, or the variance-covariance matrix may not be available. The most common reason of why this happens is collinearity among variables. This function helps to find out which set of variables is problematic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collinearity(x, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collinearity_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object obtained from, e.g. functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="collinearity_+3A_verbose">verbose</code></td>
<td>
<p>An integer. If higher than or equal to 1, then a note is prompted at each step of the algorithm. By default <code>verbose = 0</code> for small problems and to 1 for large problems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests: 1) collinearity with the fixed-effect variables, 2) perfect multi-collinearity between the variables, 4) perfect multi-collinearity between several variables and the fixed-effects, and 4) identification issues when there are non-linear in parameters parts.
</p>


<h3>Value</h3>

<p>It returns a text message with the identified diagnostics.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creating an example data base:
set.seed(1)
fe_1 = sample(3, 100, TRUE)
fe_2 = sample(20, 100, TRUE)
x = rnorm(100, fe_1)**2
y = rnorm(100, fe_2)**2
z = rnorm(100, 3)**2
dep = rpois(100, x*y*z)
base = data.frame(fe_1, fe_2, x, y, z, dep)

# creating collinearity problems:
base$v1 = base$v2 = base$v3 = base$v4 = 0
base$v1[base$fe_1 == 1] = 1
base$v2[base$fe_1 == 2] = 1
base$v3[base$fe_1 == 3] = 1
base$v4[base$fe_2 == 1] = 1

# Estimations:

# Collinearity with the fixed-effects:
res_1 = femlm(dep ~ log(x) + v1 + v2 + v4 | fe_1 + fe_2, base)
collinearity(res_1)

# =&gt; collinearity with the first fixed-effect identified, we drop v1 and v2
res_1bis = femlm(dep ~ log(x) + v4 | fe_1 + fe_2, base)
collinearity(res_1bis)

# Multi-Collinearity:
res_2 =  femlm(dep ~ log(x) + v1 + v2 + v3 + v4, base)
collinearity(res_2)


</code></pre>

<hr>
<h2 id='confint.fixest'>Confidence interval for parameters estimated with <code>fixest</code></h2><span id='topic+confint.fixest'></span>

<h3>Description</h3>

<p>This function computes the confidence interval of parameter estimates obtained from a model estimated with <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
confint(
  object,
  parm,
  level = 0.95,
  vcov,
  se,
  cluster,
  ssc = NULL,
  coef.col = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="confint.fixest_+3A_parm">parm</code></td>
<td>
<p>The parameters for which to compute the confidence interval (either an integer vector OR a character vector with the parameter name). If missing, all parameters are used.</p>
</td></tr>
<tr><td><code id="confint.fixest_+3A_level">level</code></td>
<td>
<p>The confidence level. Default is 0.95.</p>
</td></tr>
<tr><td><code id="confint.fixest_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="confint.fixest_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="confint.fixest_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="confint.fixest_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="confint.fixest_+3A_coef.col">coef.col</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> the column <code>coefficient</code> is inserted in the first position containing the coefficient names.</p>
</td></tr>
<tr><td><code id="confint.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with two columns giving respectively the lower and upper bound of the confidence interval. There is as many rows as parameters.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load trade data
data(trade)

# We estimate the effect of distance on trade (with 3 fixed-effects)
est_pois = femlm(Euros ~ log(dist_km) + log(Year) | Origin + Destination +
                 Product, trade)

# confidence interval with "normal" VCOV
confint(est_pois)

# confidence interval with "clustered" VCOV (w.r.t. the Origin factor)
confint(est_pois, se = "cluster")


</code></pre>

<hr>
<h2 id='confint.fixest_multi'>Confidence intervals for <code>fixest_multi</code> objects</h2><span id='topic+confint.fixest_multi'></span>

<h3>Description</h3>

<p>Computes the confidence intervals of parameter estimates for <code>fixest</code>'s multiple estimation objects (aka <code>fixest_multi</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_multi'
confint(
  object,
  parm,
  level = 0.95,
  vcov = NULL,
  se = NULL,
  cluster = NULL,
  ssc = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.fixest_multi_+3A_object">object</code></td>
<td>
<p>A <code>fixest_multi</code> object obtained from a multiple estimation in <code>fixest</code>.</p>
</td></tr>
<tr><td><code id="confint.fixest_multi_+3A_parm">parm</code></td>
<td>
<p>The parameters for which to compute the confidence interval (either an integer vector OR a character vector with the parameter name). If missing, all parameters are used.</p>
</td></tr>
<tr><td><code id="confint.fixest_multi_+3A_level">level</code></td>
<td>
<p>The confidence level. Default is 0.95.</p>
</td></tr>
<tr><td><code id="confint.fixest_multi_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="confint.fixest_multi_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="confint.fixest_multi_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="confint.fixest_multi_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="confint.fixest_multi_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a data frame whose first columns indicate which model has been estimated. The last three columns indicate the coefficient name, and the lower and upper confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = setNames(iris, c("y", "x1", "x2", "x3", "species"))
est = feols(y ~ csw(x.[,1:3]) | sw0(species), base, vcov = "iid")

confint(est)

# focusing only on the coefficient 'x3'
confint(est, "x3")

# the 'id' provides the index of the estimation
est[c(3, 6)]

</code></pre>

<hr>
<h2 id='degrees_freedom'>Gets the degrees of freedom of a <code>fixest</code> estimation</h2><span id='topic+degrees_freedom'></span><span id='topic+degrees_freedom_iid'></span>

<h3>Description</h3>

<p>Simple utility to extract the degrees of freedom from a <code>fixest</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degrees_freedom(
  x,
  type,
  vars = NULL,
  vcov = NULL,
  se = NULL,
  cluster = NULL,
  ssc = NULL,
  stage = 2
)

degrees_freedom_iid(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degrees_freedom_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> estimation.</p>
</td></tr>
<tr><td><code id="degrees_freedom_+3A_type">type</code></td>
<td>
<p>Character scalar, equal to &quot;k&quot;, &quot;resid&quot;, &quot;t&quot;. If &quot;k&quot;, then the number of regressors is returned. If &quot;resid&quot;, then it is the &quot;residuals degree of freedom&quot;, i.e. the number of observations minus the number of regressors. If &quot;t&quot;, it is the degrees of freedom used in the t-test. Note that these values are affected by how the VCOV of <code>x</code> is computed, in particular when the VCOV is clustered.</p>
</td></tr>
<tr><td><code id="degrees_freedom_+3A_vars">vars</code></td>
<td>
<p>A vector of variable names, of the regressors. This is optional. If provided, then <code>type</code> is set to 1 by default and the number of regressors contained in <code>vars</code> is returned. This is only useful in the presence of collinearity and we want a subset of the regressors only. (Mostly for internal use.)</p>
</td></tr>
<tr><td><code id="degrees_freedom_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="degrees_freedom_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="degrees_freedom_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="degrees_freedom_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="degrees_freedom_+3A_stage">stage</code></td>
<td>
<p>Either 1 or 2. Only concerns IV regressions, which stage to look at.
</p>
<p>The type of VCOV can have an influence on the degrees of freedom. In particular, when the VCOV is clustered, the DoF returned will be in accordance with the way the small sample correction was performed when computing the VCOV. That type of value is in general not what we have in mind when we think of &quot;degrees of freedom&quot;. To obtain the ones that are more intuitive, please use <code>degrees_freedom_iid</code> instead.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>degrees_freedom_iid()</code>: Gets the degrees of freedom of a <code>fixest</code> estimation
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# First: an estimation

base = iris
names(base) = c("y", "x1", "x2", "x3", "species")
est = feols(y ~ x1 + x2 | species, base)

# "Normal" standard-errors (SE)
est_standard = summary(est, se = "st")

# Clustered SEs
est_clustered = summary(est, se = "clu")

# The different degrees of freedom

# =&gt; different type 1 DoF (because of the clustering)
degrees_freedom(est_standard, type = "k")
degrees_freedom(est_clustered, type = "k") # fixed-effects are excluded

# =&gt; different type 2 DoF (because of the clustering)
degrees_freedom(est_standard, type = "resid") # =&gt; equivalent to the df.residual from lm
degrees_freedom(est_clustered, type = "resid")



</code></pre>

<hr>
<h2 id='demean'>Centers a set of variables around a set of factors</h2><span id='topic+demean'></span>

<h3>Description</h3>

<p>User-level access to internal demeaning algorithm of <code>fixest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demean(
  X,
  f,
  slope.vars,
  slope.flag,
  data,
  weights,
  nthreads = getFixest_nthreads(),
  notes = getFixest_notes(),
  iter = 2000,
  tol = 1e-06,
  fixef.reorder = TRUE,
  na.rm = TRUE,
  as.matrix = is.atomic(X),
  im_confident = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demean_+3A_x">X</code></td>
<td>
<p>A matrix, vector, data.frame or a list OR a formula OR a <code><a href="#topic+feols">feols</a></code> estimation. If equal to a formula, then the argument <code>data</code> is required, and it must be of the type: <code>x1 + x2 ~ f1 + fe2</code> with on the LHS the variables to be centered, and on the RHS the factors used for centering. Note that you can use variables with varying slopes with the syntax <code>fe[v1, v2]</code> (see details in <code><a href="#topic+feols">feols</a></code>). If a <code>feols</code> estimation, all variables (LHS+RHS) are demeaned and then returned (only if it was estimated with fixed-effects). Otherwise, it must represent the data to be centered. Of course the number of observations of that data must be the same as the factors used for centering (argument <code>f</code>).</p>
</td></tr>
<tr><td><code id="demean_+3A_f">f</code></td>
<td>
<p>A matrix, vector, data.frame or list. The factors used to center the variables in argument <code>X</code>. Matrices will be coerced using <code>as.data.frame</code>.</p>
</td></tr>
<tr><td><code id="demean_+3A_slope.vars">slope.vars</code></td>
<td>
<p>A vector, matrix or list representing the variables with varying slopes. Matrices will be coerced using <code>as.data.frame</code>. Note that if this argument is used it MUST be in conjunction with the argument <code>slope.flag</code> that maps the factors to which the varying slopes are attached. See examples.</p>
</td></tr>
<tr><td><code id="demean_+3A_slope.flag">slope.flag</code></td>
<td>
<p>An integer vector of the same length as the number of variables in <code>f</code> (the factors used for centering). It indicates for each factor the number of variables with varying slopes to which it is associated. Positive values mean that the raw factor should also be included in the centering, negative values that it should be excluded. Sorry it's complicated... but see the examples it may get clearer.</p>
</td></tr>
<tr><td><code id="demean_+3A_data">data</code></td>
<td>
<p>A data.frame containing all variables in the argument <code>X</code>. Only used if <code>X</code> is a formula, in which case <code>data</code> is mandatory.</p>
</td></tr>
<tr><td><code id="demean_+3A_weights">weights</code></td>
<td>
<p>Vector, can be missing or NULL. If present, it must contain the same number of observations as in <code>X</code>.</p>
</td></tr>
<tr><td><code id="demean_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to be used. By default it is equal to <code>getFixest_nthreads()</code>.</p>
</td></tr>
<tr><td><code id="demean_+3A_notes">notes</code></td>
<td>
<p>Logical, whether to display a message when NA values are removed. By default it is equal to <code>getFixest_notes()</code>.</p>
</td></tr>
<tr><td><code id="demean_+3A_iter">iter</code></td>
<td>
<p>Number of iterations, default is 2000.</p>
</td></tr>
<tr><td><code id="demean_+3A_tol">tol</code></td>
<td>
<p>Stopping criterion of the algorithm. Default is <code>1e-6</code>. The algorithm stops when the maximum absolute increase in the coefficients values is lower than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="demean_+3A_fixef.reorder">fixef.reorder</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether to reorder the fixed-effects by frequencies before feeding them into the algorithm. If <code>FALSE</code>, the original fixed-effects order provided by the user is maintained. In general, reordering leads to faster and more precise performance.</p>
</td></tr>
<tr><td><code id="demean_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>TRUE</code> and the input data contains any NA value, then any observation with NA will be discarded leading to an output with less observations than the input. If <code>FALSE</code>, if NAs are present the output will also be filled with NAs for each NA observation in input.</p>
</td></tr>
<tr><td><code id="demean_+3A_as.matrix">as.matrix</code></td>
<td>
<p>Logical, if <code>TRUE</code> a matrix is returned, if <code>FALSE</code> it will be a data.frame. The default depends on the input, if atomic then a matrix will be returned.</p>
</td></tr>
<tr><td><code id="demean_+3A_im_confident">im_confident</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. FOR EXPERT USERS ONLY! This argument allows to skip some of the preprocessing of the arguments given in input. If <code>TRUE</code>, then <code>X</code> MUST be a numeric vector/matrix/list (not a formula!), <code>f</code> MUST be a list, <code>slope.vars</code> MUST be a list, <code>slope.vars</code> MUST be consistent with <code>slope.flag</code>, and <code>weights</code>, if given, MUST be numeric (not integer!). Further there MUST be not any NA value, and the number of observations of each element MUST be consistent. Non compliance to these rules may simply lead your R session to break.</p>
</td></tr>
<tr><td><code id="demean_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a data.frame of the same number of columns as the number of variables to be centered.
</p>
<p>If <code>na.rm = TRUE</code>, then the number of rows is equal to the number of rows in input minus the number of NA values (contained in <code>X</code>, <code>f</code>, <code>slope.vars</code> or <code>weights</code>). The default is to have an output of the same number of observations as the input (filled with NAs where appropriate).
</p>
<p>A matrix can be returned if <code>as.matrix = TRUE</code>.
</p>


<h3>Varying slopes</h3>

<p>You can add variables with varying slopes in the fixed-effect part of the formula. The syntax is as follows: <code>fixef_var[var1, var2]</code>. Here the variables var1 and var2 will be with varying slopes (one slope per value in fixef_var) and the fixed-effect fixef_var will also be added.
</p>
<p>To add only the variables with varying slopes and not the fixed-effect, use double square brackets: <code>fixef_var[[var1, var2]]</code>.
</p>
<p>In other words:
</p>

<ul>
<li> <p><code>fixef_var[var1, var2]</code> is equivalent to <code>fixef_var + fixef_var[[var1]] + fixef_var[[var2]]</code>
</p>
</li>
<li> <p><code>fixef_var[[var1, var2]]</code> is equivalent to <code>fixef_var[[var1]] + fixef_var[[var2]]</code>
</p>
</li></ul>

<p>In general, for convergence reasons, it is recommended to always add the fixed-effect and avoid using only the variable with varying slope (i.e. use single square brackets).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Illustration of the FWL theorem
data(trade)

base = trade
base$ln_dist = log(base$dist_km)
base$ln_euros = log(base$Euros)

# We center the two variables ln_dist and ln_euros
#  on the factors Origin and Destination
X_demean = demean(X = base[, c("ln_dist", "ln_euros")],
                  f = base[, c("Origin", "Destination")])
base[, c("ln_dist_dm", "ln_euros_dm")] = X_demean

est = feols(ln_euros_dm ~ ln_dist_dm, base)
est_fe = feols(ln_euros ~ ln_dist | Origin + Destination, base)

# The results are the same as if we used the two factors
# as fixed-effects
etable(est, est_fe, se = "st")

#
# Variables with varying slopes
#

# You can center on factors but also on variables with varying slopes

# Let's have an illustration
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

#
# We center y and x1 on species and x2 * species

# using a formula
base_dm = demean(y + x1 ~ species[x2], data = base)

# using vectors
base_dm_bis = demean(X = base[, c("y", "x1")], f = base$species,
                     slope.vars = base$x2, slope.flag = 1)

# Let's look at the equivalences
res_vs_1 = feols(y ~ x1 + species + x2:species, base)
res_vs_2 = feols(y ~ x1, base_dm)
res_vs_3 = feols(y ~ x1, base_dm_bis)

# only the small sample adj. differ in the SEs
etable(res_vs_1, res_vs_2, res_vs_3, keep = "x1")

#
# center on x2 * species and on another FE

base$fe = rep(1:5, 10)

# using a formula =&gt; double square brackets!
base_dm = demean(y + x1 ~ fe + species[[x2]], data = base)

# using vectors =&gt; note slope.flag!
base_dm_bis = demean(X = base[, c("y", "x1")], f = base[, c("fe", "species")],
                     slope.vars = base$x2, slope.flag = c(0, -1))

# Explanations slope.flag = c(0, -1):
# - the first 0: the first factor (fe) is associated to no variable
# - the "-1":
#    * |-1| = 1: the second factor (species) is associated to ONE variable
#    *   -1 &lt; 0: the second factor should not be included as such

# Let's look at the equivalences
res_vs_1 = feols(y ~ x1 + i(fe) + x2:species, base)
res_vs_2 = feols(y ~ x1, base_dm)
res_vs_3 = feols(y ~ x1, base_dm_bis)

# only the small sample adj. differ in the SEs
etable(res_vs_1, res_vs_2, res_vs_3, keep = "x1")




</code></pre>

<hr>
<h2 id='deviance.fixest'>Extracts the deviance of a fixest estimation</h2><span id='topic+deviance.fixest'></span>

<h3>Description</h3>

<p>Returns the deviance from a <code>fixest</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object.</p>
</td></tr>
<tr><td><code id="deviance.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric scalar equal to the deviance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">fepois</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+femlm">fenegbin</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
est = feols(Petal.Length ~ Petal.Width, iris)
deviance(est)

est_pois = fepois(Petal.Length ~ Petal.Width, iris)
deviance(est_pois)

</code></pre>

<hr>
<h2 id='did_means'>Treated and control sample descriptives</h2><span id='topic+did_means'></span>

<h3>Description</h3>

<p>This function shows the means and standard-deviations of several variables conditional on whether they are from the treated or the control group. The groups can further be split according to a pre/post variable. Results can be seamlessly be exported to Latex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>did_means(
  fml,
  base,
  treat_var,
  post_var,
  tex = FALSE,
  treat_dict,
  dict = getFixest_dict(),
  file,
  replace = FALSE,
  title,
  label,
  raw = FALSE,
  indiv,
  treat_first,
  prepostnames = c("Before", "After"),
  diff.inv = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="did_means_+3A_fml">fml</code></td>
<td>
<p>Either a formula of the type <code>var1 + ... + varN ~ treat</code> or <code>var1 + ... + varN ~ treat | post</code>. Either a data.frame/matrix containing all the variables for which the means are to be computed (they must be numeric of course). Both the treatment and the post variables must contain only exactly two values. You can use a point to select all the variables of the data set: <code>. ~ treat</code>.</p>
</td></tr>
<tr><td><code id="did_means_+3A_base">base</code></td>
<td>
<p>A data base containing all the variables in the formula <code>fml</code>.</p>
</td></tr>
<tr><td><code id="did_means_+3A_treat_var">treat_var</code></td>
<td>
<p>Only if argument <code>fml</code> is <em>not</em> a formula. The vector identifying the treated and the control observations (the vector can be of any type but must contain only two possible values). Must be of the same length as the data.</p>
</td></tr>
<tr><td><code id="did_means_+3A_post_var">post_var</code></td>
<td>
<p>Only if argument <code>fml</code> is <em>not</em> a formula. The vector identifying the periods (pre/post) of the observations (the vector can be of any type but must contain only two possible values). The first value (in the sorted sense) of the vector is taken as the pre period. Must be of the same length as the data.</p>
</td></tr>
<tr><td><code id="did_means_+3A_tex">tex</code></td>
<td>
<p>Should the result be displayed in Latex? Default is <code>FALSE</code>. Automatically set to <code>TRUE</code> if the table is to be saved in a file using the argument <code>file</code>.</p>
</td></tr>
<tr><td><code id="did_means_+3A_treat_dict">treat_dict</code></td>
<td>
<p>A character vector of length two. What are the names of the treated and the control? This should be a dictionary: e.g. <code>c("1"="Treated", "0" = "Control")</code>.</p>
</td></tr>
<tr><td><code id="did_means_+3A_dict">dict</code></td>
<td>
<p>A named character vector. A dictionary between the variables names and an alias. For instance <code>dict=c("x"="Inflation Rate")</code> would replace the variable name <code>x</code> by &ldquo;Inflation Rate&rdquo;.</p>
</td></tr>
<tr><td><code id="did_means_+3A_file">file</code></td>
<td>
<p>A file path. If given, the table is written in Latex into this file.</p>
</td></tr>
<tr><td><code id="did_means_+3A_replace">replace</code></td>
<td>
<p>Default is <code>TRUE</code>, which means that when the table is exported, the existing file is not erased.</p>
</td></tr>
<tr><td><code id="did_means_+3A_title">title</code></td>
<td>
<p>Character string giving the Latex title of the table. (Only if exported.)</p>
</td></tr>
<tr><td><code id="did_means_+3A_label">label</code></td>
<td>
<p>Character string giving the Latex label of the table. (Only if exported.)</p>
</td></tr>
<tr><td><code id="did_means_+3A_raw">raw</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, it returns the information without formatting.</p>
</td></tr>
<tr><td><code id="did_means_+3A_indiv">indiv</code></td>
<td>
<p>Either the variable name of individual identifiers, a one sided formula, or a vector. If the data is that of a panel, this can be used to track the number of individuals per group.</p>
</td></tr>
<tr><td><code id="did_means_+3A_treat_first">treat_first</code></td>
<td>
<p>Which value of the 'treatment' vector should appear on the left? By default the max value appears first (e.g. if the treatment variable is a 0/1 vector, 1 appears first).</p>
</td></tr>
<tr><td><code id="did_means_+3A_prepostnames">prepostnames</code></td>
<td>
<p>Only if there is a 'post' variable. The names of the pre and post periods to be displayed in Latex. Default is <code>c("Before", "After")</code>.</p>
</td></tr>
<tr><td><code id="did_means_+3A_diff.inv">diff.inv</code></td>
<td>
<p>Logical, default to <code>FALSE</code>. Whether to inverse the difference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, when the user tries to apply this function to nun-numeric variables, an error is raised. The exception is when the all variables are selected with the dot (like in <code>. ~ treat</code>. In this case, non-numeric variables are automatically omitted (with a message).
</p>
<p>NAs are removed automatically: if the data contains NAs an information message will be prompted. First all observations containing NAs relating to the treatment or post variables are removed. Then if there are still NAs for the variables, they are excluded separately for each variable, and a new message detailing the NA breakup is prompted.
</p>


<h3>Value</h3>

<p>It returns a data.frame or a Latex table with the conditional means and statistical differences between the groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Playing around with the DiD data
data(base_did)

# means of treat/control
did_means(y+x1+period~treat, base_did)

# same but inverting the difference
did_means(y+x1+period~treat, base_did, diff.inv = TRUE)

# now treat/control, before/after
did_means(y+x1+period~treat|post, base_did)

# same but with a new line giving the number of unique "indiv" for each case
did_means(y+x1+period~treat|post, base_did, indiv = "id")

# same but with the treat case "0" coming first
did_means(y+x1+period~treat|post, base_did, indiv = ~id, treat_first = 0)

# Selecting all the variables with "."
did_means(.~treat|post, base_did, indiv = "id")


</code></pre>

<hr>
<h2 id='dsb'>Simple and powerful string manipulation with the dot square bracket operator</h2><span id='topic+dsb'></span>

<h3>Description</h3>

<p>Compactly performs many low level string operations. Advanced support for pluralization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsb(
  ...,
  frame = parent.frame(),
  sep = "",
  vectorize = FALSE,
  nest = TRUE,
  collapse = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsb_+3A_...">...</code></td>
<td>
<p>Character scalars that will be collapsed with the argument <code>sep</code>. You can use <code>".[x]"</code> within each character string to insert the value of <code>x</code> in the string. You can add string operations in each <code>".[]"</code> instance with the syntax <code>"'arg'op ? x"</code> (resp. <code>"'arg'op ! x"</code>) to apply the operation <code>'op'</code> with the argument <code>'arg'</code> to <code>x</code> (resp. the verbatim of <code>x</code>). Otherwise, what to say? Ah, nesting is enabled, and since there's over 30 operators, it's a bit complicated to sort you out in this small space. But type <code>dsb("--help")</code> to prompt an (almost) extensive help.</p>
</td></tr>
<tr><td><code id="dsb_+3A_frame">frame</code></td>
<td>
<p>An environment used to evaluate the variables in <code>".[]"</code>.</p>
</td></tr>
<tr><td><code id="dsb_+3A_sep">sep</code></td>
<td>
<p>Character scalar, default is <code>""</code>. It is used to collapse all the elements in <code>...</code>.</p>
</td></tr>
<tr><td><code id="dsb_+3A_vectorize">vectorize</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, Further, elements in <code>...</code> are NOT collapsed together, but instead vectorised.</p>
</td></tr>
<tr><td><code id="dsb_+3A_nest">nest</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether the original character strings should be nested into a <code>".[]"</code>. If <code>TRUE</code>, then things like <code>dsb("S!one, two")</code> are equivalent to <code>dsb(".[S!one, two]")</code> and hence create the vector <code>c("one", "two")</code>.</p>
</td></tr>
<tr><td><code id="dsb_+3A_collapse">collapse</code></td>
<td>
<p>Character scalar or <code>NULL</code> (default). If provided, the resulting character vector will be collapsed into a character scalar using this value as a separator.
</p>
<p>There are over 30 basic string operations, it supports pluralization, it's fast (e.g. faster than <code>glue</code> in the benchmarks), string operations can be nested (it may be the most powerful feature), operators have sensible defaults.
</p>
<p>See detailed help on the console with <code>dsb("--help")</code>. The real help is in fact in the &quot;Examples&quot; section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a character vector whose length depends on the elements and operations in <code>".[]"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# BASIC USAGE ####
#

x = c("Romeo", "Juliet")

# .[x] inserts x
dsb("Hello .[x]!")

# elements in ... are collapsed with "" (default)
dsb("Hello .[x[1]], ",
    "how is .[x[2]] doing?")

# Splitting a comma separated string
# The mechanism is explained later
dsb("/J. Mills, David, Agnes, Dr Strong")

# Nota: this is equivalent to (explained later)
dsb("', *'S !J. Mills, David, Agnes, Dr Strong")

#
# Applying low level operations to strings
#

# Two main syntax:

# A) expression evaluation
# .[operation ? x]
#             | |
#             |  \-&gt; the expression to be evaluated
#              \-&gt; ? means that the expression will be evaluated

# B) verbatim
# .[operation ! x]
#             | |
#             |  \-&gt; the expression taken as verbatim (here ' x')
#              \-&gt; ! means that the expression is taken as verbatim

# operation: usually 'arg'op with op an operation code.

# Example: splitting
x = "hello dear"
dsb(".[' 's ? x]")
# x is split by ' '

dsb(".[' 's !hello dear]")
# 'hello dear' is split by ' '
# had we used ?, there would have been an error

# By default, the string is nested in .[], so in that case no need to use .[]:
dsb("' 's ? x")
dsb("' 's !hello dear")

# There are 35 string operators
# Operators usually have a default value
# Operations can be chained by separating them with a comma

# Example: default of 's' is ' ' + chaining with collapse
dsb("s, ' my 'c!hello dear")

#
# Nesting
#

# .[operations ! s1.[expr]s2]
#              |    |
#              |     \-&gt; expr will be evaluated then added to the string
#               \-&gt; nesting requires verbatim evaluation: '!'

dsb("The variables are: .[C!x.[1:4]].")

# This one is a bit ugly but it shows triple nesting
dsb("The variables are: .[w, C!.[2* ! x.[1:4]].[S, 4** ! , _sq]].")

#
# Splitting
#

# s: split with fixed pattern, default is ' '
dsb("s !a b c")
dsb("' b 's !a b c")

# S: split with regex pattern, default is ', *'
dsb("S !a, b, c")
dsb("'[[:punct:] ]'S !a! b; c")

#
# Collapsing
#

# c and C do the same, their default is different
# syntax: 's1||s2' with
# - s1 the string used for collapsing
# - s2 (optional) the string used for the last collapse

# c: default is ' '
dsb("c?1:3")

# C: default is ', || and '
dsb("C?1:3")

dsb("', || or 'c?1:4")

#
# Extraction
#

# x: extracts the first pattern
# X: extracts all patterns
# syntax: 'pattern'x
# Default is '[[:alnum:]]+'

x = "This years is... 2020"
dsb("x ? x")
dsb("X ? x")

dsb("'\\d+'x ? x")

#
# STRING FORMATTING ####
#

#
# u, U: uppercase first/all letters

# first letter
dsb("u!julia mills")

# title case: split -&gt; upper first letter -&gt; collapse
dsb("s, u, c!julia mills")

# upper all letters
dsb("U!julia mills")

#
# L: lowercase

dsb("L!JULIA MILLS")

#
# q, Q: single or double quote

dsb("S, q, C!Julia, David, Wilkins")
dsb("S, Q, C!Julia, David, Wilkins")

#
# f, F: formats the string to fit the same length


score = c(-10, 2050)
nm = c("Wilkins", "David")
dsb("Monopoly scores:\n.['\n'c ! - .[f ? nm]: .[F ? score] US$]")

# OK that example may have been a bit too complex,
# let's make it simple:

dsb("Scores: .[f ? score]")
dsb("Names: .[F ? nm]")

#
# w, W: reformat the white spaces
# w: suppresses trimming white spaces + normalizes successive white spaces
# W: same but also includes punctuation

dsb("w ! The   white  spaces are now clean.  ")

dsb("W ! I, really -- truly; love punctuation!!!")

#
# %: applies sprintf formatting

dsb("pi = .['.2f'% ? pi]")

#
# a: appends text on each item
# syntax: 's1|s2'a, adds s1 at the beginning and s2 at the end of the string
# It accepts the special values :1:, :i:, :I:, :a:, :A:
# These values create enumerations (only one such value is accepted)

# appending square brackets
dsb("'[|]'a, ' + 'c!x.[1:4]")

# Enumerations
acad = dsb("/you like admin, you enjoy working on weekends, you really love emails")
dsb("Main reasons to pursue an academic career:\n .[':i:) 'a, C ? acad].")

#
# A: same as 'a' but adds at the begging/end of the full string (not on the elements)
# special values: :n:, :N:, give the number of elements

characters = dsb("/David, Wilkins, Dora, Agnes")
dsb("There are .[':N: characters: 'A, C ? characters].")


#
# stop: removes basic English stopwords
# the list is from the Snowball project: http://snowball.tartarus.org/algorithms/english/stop.txt

dsb("stop, w!It is a tale told by an idiot, full of sound and fury, signifying nothing.")

#
# k: keeps the first n characters
# syntax: nk: keeps the first n characters
#         'n|s'k: same + adds 's' at the end of shortened strings
#         'n||s'k: same but 's' counts in the n characters kept

words = dsb("/short, constitutional")
dsb("5k ? words")

dsb("'5|..'k ? words")

dsb("'5||..'k ? words")

#
# K: keeps the first n elements
# syntax: nK: keeps the first n elements
#         'n|s'K: same + adds the element 's' at the end
#         'n||s'K: same but 's' counts in the n elements kept
#
# Special values :rest: and :REST:, give the number of items dropped

bx = dsb("/Pessac Leognan, Saint Emilion, Marguaux, Saint Julien, Pauillac")
dsb("Bordeaux wines I like: .[3K, ', 'C ? bx].")

dsb("Bordeaux wines I like: .['3|etc..'K, ', 'C ? bx].")

dsb("Bordeaux wines I like: .['3||etc..'K, ', 'C ? bx].")

dsb("Bordeaux wines I like: .['3|and at least :REST: others'K, ', 'C ? bx].")

#
# Ko, KO: special operator which keeps the first n elements and adds "others"
# syntax: nKo
# KO gives the rest in letters

dsb("Bordeaux wines I like: .[4KO, C ? bx].")

#
# r, R: string replacement
# syntax: 's'R: deletes the content in 's' (replaces with the empty string)
#         's1 =&gt; s2'R replaces s1 into s2
# r: fixed / R: perl = TRUE

dsb("'e'r !The letter e is deleted")

# adding a perl look-behind
dsb("'(?&lt;! )e'R !The letter e is deleted")

dsb("'e =&gt; a'r !The letter e becomes a")

dsb("'([[:alpha:]]{3})[[:alpha:]]+ =&gt; \\1.'R !Trimming the words")

#
# *, *c, **, **c: replication, replication + collapse
# syntax: n* or n*c
# ** is the same as * but uses "each" in the replication

dsb("N.[10*c!o]!")

dsb("3*c ? 1:3")
dsb("3**c ? 1:3")

#
# d: replaces the items by the empty string
# -&gt; useful in conditions

dsb("d!I am going to be annihilated")

#
# ELEMENT MANIPULATION ####
#

#
# D: deletes all elements
# -&gt; useful in conditions

x = dsb("/I'll, be, deleted")
dsb("D ? x")

#
# i, I: inserts an item
# syntax: 's1|s2'i: inserts s1 first and s2 last
# I: is the same as i but is 'invisibly' included

characters = dsb("/David, Wilkins, Dora, Agnes, Trotwood")
dsb("'Heep|Spenlow'i, C ? characters")

dsb("'Heep|Spenlow'I, C ? characters")


#
# PLURALIZATION ####
#

# There is support for pluralization

#
# *s, *s_: adds 's' or 's ' depending on the number of elements

nb = 1:5
dsb("Number.[*s, D ? nb]: .[C ? nb]")
dsb("Number.[*s, D ? 2 ]: .[C ? 2 ]")

# or
dsb("Number.[*s, ': 'A, C ? nb]")


#
# v, V: adds a verb at the beginning/end of the string
# syntax: 'verb'v

# Unpopular opinion?
brand = c("Apple", "Samsung")
dsb(".[V, C ? brand] overrated.")
dsb(".[V, C ? brand[1]] overrated.")

win = dsb("/Peggoty, Agnes, Emily")
dsb("The winner.[*s_, v, C ? win].")
dsb("The winner.[*s_, v, C ? win[1]].")

# Other verbs
dsb(".[' have'V, C ? win] won a prize.")
dsb(".[' have'V, C ? win[1]] won a prize.")

dsb(".[' was'V, C ? win] unable to come.")
dsb(".[' was'V, C ? win[1]] unable to come.")

#
# *A: appends text depending on the length of the vector
# syntax: 's1|s2 / s3|s4'
#         if length == 1: applies 's1|s2'A
#         if length &gt;  1: applies 's3|s4'A

win = dsb("/Barkis, Micawber, Murdstone")
dsb("The winner.[' is /s are '*A, C ? win].")
dsb("The winner.[' is /s are '*A, C ? win[1]].")

#
# CONDITIONS ####
#

# Conditions can be applied with 'if' statements.",
# The syntax is 'type comp value'if(true : false), with
# - type: either 'len', 'char', 'fixed' or 'regex'
#   + len: number of elements in the vector
#   + char: number of characters
#   + fixed: fixed pattern
#   + regex: regular expression pattern
# - comp: a comparator:
#   + valid for len/char: &gt;, &lt;, &gt;=, &lt;=, !=, ==
#   + valid for fixed/regex: !=, ==
# - value: a value for which the comparison is applied.
# - true: operations to be applied if true (can be void)
# - false: operations to be applied if false (can be void)

dsb("'char &lt;= 2'if('(|)'a : '[|]'a), ' + 'c ? c(1, 12, 123)")

sentence = "This is a sentence with some longish words."
dsb("s, 'char&lt;=4'if(D), c ? sentence")

dsb("s, 'fixed == e'if(:D), c ! Only words with an e are selected.")

#
# ARGUMENTS FROM THE FRAME ####
#

# Arguments can be evaluated from the calling frame.
# Simply use backticks instead of quotes.

dollar = 6
reason = "glory"
dsb("Why do you develop packages? For .[`dollar`*c!$]?",
    "For money? No... for .[U,''s, c?reason]!", sep = "\n")





</code></pre>

<hr>
<h2 id='est_env'>Estimates a <code>fixest</code> estimation from a <code>fixest</code> environment</h2><span id='topic+est_env'></span>

<h3>Description</h3>

<p>This is a function advanced users which allows to estimate any <code>fixest</code> estimation from a <code>fixest</code> environment obtained with <code>only.env = TRUE</code> in a <code>fixest</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_env(env, y, X, weights, endo, inst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_env_+3A_env">env</code></td>
<td>
<p>An environment obtained from a <code>fixest</code> estimation with <code>only.env = TRUE</code>. This is intended for advanced users so there is no error handling: any other kind of input will fail with a poor error message.</p>
</td></tr>
<tr><td><code id="est_env_+3A_y">y</code></td>
<td>
<p>A vector representing the dependent variable. Should be of the same length as the number of observations in the initial estimation.</p>
</td></tr>
<tr><td><code id="est_env_+3A_x">X</code></td>
<td>
<p>A matrix representing the independent variables. Should be of the same dimension as in the initial estimation.</p>
</td></tr>
<tr><td><code id="est_env_+3A_weights">weights</code></td>
<td>
<p>A vector of weights (i.e. with only positive values). Should be of the same length as the number of observations in the initial estimation. If identical to the scalar 1, this will mean that no weights will be used in the estimation.</p>
</td></tr>
<tr><td><code id="est_env_+3A_endo">endo</code></td>
<td>
<p>A matrix representing the endogenous regressors in IV estimations. It should be of the same dimension as the original endogenous regressors.</p>
</td></tr>
<tr><td><code id="est_env_+3A_inst">inst</code></td>
<td>
<p>A matrix representing the instruments in IV estimations. It should be of the same dimension as the original instruments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been created for advanced users, mostly to avoid overheads when making simulations with <code>fixest</code>.
</p>
<p>How can it help you make simulations? First make a core estimation with <code>only.env = TRUE</code>, and usually with <code>only.coef = TRUE</code> (to avoid having extra things that take time to compute). Then loop while modifying the appropriate things directly in the environment. Beware that if you make a mistake here (typically giving stuff of the wrong length), then you can make the R session crash because there is no more error-handling! Finally estimate with <code>est_env(env = core_env)</code> and store the results.
</p>
<p>Instead of <code>est_env</code>, you could use directly <code>fixest</code> estimations too, like <code>feols</code>, since they accept the <code>env</code> argument. The function <code>est_env</code> is only here to add a bit of generality to avoid the trouble to the user to write conditions (look at the source, it's just a one liner).
</p>
<p>Objects of main interest in the environment are:
</p>

<dl>
<dt>lhs</dt><dd><p>The left hand side, or dependent variable.</p>
</dd>
<dt>linear.mat</dt><dd><p>The matrix of the right-hand-side, or explanatory variables.</p>
</dd>
<dt>iv_lhs</dt><dd><p>The matrix of the endogenous variables in IV regressions.</p>
</dd>
<dt>iv.mat</dt><dd><p>The matrix of the instruments in IV regressions.</p>
</dd>
<dt>weights.value</dt><dd><p>The vector of weights.</p>
</dd>
</dl>

<p>I strongly discourage changing the dimension of any of these elements, or else crash can occur. However, you can change their values at will (given the dimension stay the same). The only exception is the weights, which tolerates changing its dimension: it can be identical to the scalar <code>1</code> (meaning no weights), or to something of the length the number of observations.
</p>
<p>I also discourage changing anything in the fixed-effects (even their value) since this will almost surely lead to a crash.
</p>
<p>Note that this function is mostly useful when the overheads/estimation ratio is high. This means that OLS will benefit the most from this function. For GLM/Max.Lik. estimations, the ratio is small since the overheads is only a tiny portion of the total estimation time. Hence this function will be less useful for these models.
</p>


<h3>Value</h3>

<p>It returns the results of a <code>fixest</code> estimation: the one that was summoned when obtaining the environment.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's make a short simulation
# Inspired from Grant McDermott bboot function
# See https://twitter.com/grant_mcdermott/status/1487528757418102787

# Simple function that computes a Bayesian bootstrap
bboot = function(x, n_sim = 100){
  # We bootstrap on the weights
  # Works with fixed-effects/IVs
  #  and with any fixest function that accepts weights

  core_env = update(x, only.coef = TRUE, only.env = TRUE)
  n_obs = x$nobs

  res_all = vector("list", n_sim)
  for(i in 1:n_sim){
    # # begin: NOT RUN
    # # We could directly assign in the environment:
    # assign("weights.value", rexp(n_obs, rate = 1), core_env)
    # res_all[[i]] = est_env(env = core_env)
    #   end: NOT RUN

    # Instead we can use the argument weights, which does the same
    res_all[[i]] = est_env(env = core_env, weights = rexp(n_obs, rate = 1))
  }

  do.call(rbind, res_all)
}


est = feols(mpg ~ wt + hp, mtcars)

boot_res = bboot(est)
coef = colMeans(boot_res)
std_err = apply(boot_res, 2, sd)

# Comparing the results with the main estimation
coeftable(est)
cbind(coef, std_err)





</code></pre>

<hr>
<h2 id='estfun.fixest'>Extracts the scores from a fixest estimation</h2><span id='topic+estfun.fixest'></span>

<h3>Description</h3>

<p>Extracts the scores from a fixest estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
estfun(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estfun.fixest_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object, obtained for instance from <code><a href="#topic+feols">feols</a></code>.</p>
</td></tr>
<tr><td><code id="estfun.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of the same number of rows as the number of observations used for the estimation, and the same number of columns as there were variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
est = feols(Petal.Length ~ Petal.Width + Sepal.Width, iris)
head(estfun(est))

</code></pre>

<hr>
<h2 id='etable'>Estimations table (export the results of multiples estimations to a DF or to Latex)</h2><span id='topic+etable'></span><span id='topic+setFixest_etable'></span><span id='topic+getFixest_etable'></span><span id='topic+print.etable_tex'></span><span id='topic+print.etable_df'></span><span id='topic+log_etable'></span><span id='topic+esttable'></span><span id='topic+esttex'></span>

<h3>Description</h3>

<p>Aggregates the results of multiple estimations and displays them in the form of either a Latex table or a <code>data.frame</code>. Note that you will need the <code>booktabs</code> package for the Latex table to render properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etable(
  ...,
  vcov = NULL,
  stage = 2,
  agg = NULL,
  se = NULL,
  ssc = NULL,
  cluster = NULL,
  .vcov = NULL,
  .vcov_args = NULL,
  digits = 4,
  digits.stats = 5,
  tex,
  fitstat = NULL,
  title = NULL,
  coefstat = "se",
  ci = 0.95,
  se.row = NULL,
  se.below = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  dict = TRUE,
  file = NULL,
  replace = FALSE,
  convergence = NULL,
  signif.code = NULL,
  label = NULL,
  float = NULL,
  headers = list("auto"),
  fixef_sizes = FALSE,
  fixef_sizes.simplify = TRUE,
  keepFactors = TRUE,
  family = NULL,
  powerBelow = -5,
  interaction.combine = NULL,
  interaction.order = NULL,
  i.equal = NULL,
  depvar = TRUE,
  style.tex = NULL,
  style.df = NULL,
  notes = NULL,
  group = NULL,
  extralines = NULL,
  fixef.group = NULL,
  placement = "htbp",
  drop.section = NULL,
  poly_dict = c("", " square", " cube"),
  postprocess.tex = NULL,
  postprocess.df = NULL,
  tpt = FALSE,
  arraystretch = NULL,
  adjustbox = NULL,
  fontsize = NULL,
  fit_format = "__var__",
  coef.just = NULL,
  tabular = "normal",
  highlight = NULL,
  coef.style = NULL,
  meta = NULL,
  meta.time = NULL,
  meta.author = NULL,
  meta.sys = NULL,
  meta.call = NULL,
  meta.comment = NULL,
  view = FALSE,
  export = NULL,
  markdown = NULL,
  page.width = "fit",
  div.class = "etable"
)

setFixest_etable(
  digits = 4,
  digits.stats = 5,
  fitstat,
  coefstat = c("se", "tstat", "confint"),
  ci = 0.95,
  se.below = TRUE,
  keep,
  drop,
  order,
  dict,
  float,
  fixef_sizes = FALSE,
  fixef_sizes.simplify = TRUE,
  family,
  powerBelow = -5,
  interaction.order = NULL,
  depvar,
  style.tex = NULL,
  style.df = NULL,
  notes = NULL,
  group = NULL,
  extralines = NULL,
  fixef.group = NULL,
  placement = "htbp",
  drop.section = NULL,
  view = FALSE,
  markdown = NULL,
  view.cache = FALSE,
  page.width = "fit",
  postprocess.tex = NULL,
  postprocess.df = NULL,
  fit_format = "__var__",
  meta.time = NULL,
  meta.author = NULL,
  meta.sys = NULL,
  meta.call = NULL,
  meta.comment = NULL,
  reset = FALSE,
  save = FALSE
)

getFixest_etable()

## S3 method for class 'etable_tex'
print(x, ...)

## S3 method for class 'etable_df'
print(x, ...)

log_etable(type = "pdflatex")

esttable(
  ...,
  vcov = NULL,
  stage = 2,
  agg = NULL,
  se = NULL,
  ssc = NULL,
  cluster = NULL,
  .vcov = NULL,
  .vcov_args = NULL,
  digits = 4,
  digits.stats = 5,
  fitstat = NULL,
  coefstat = "se",
  ci = 0.95,
  se.row = NULL,
  se.below = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  dict = TRUE,
  file = NULL,
  replace = FALSE,
  convergence = NULL,
  signif.code = NULL,
  headers = list("auto"),
  fixef_sizes = FALSE,
  fixef_sizes.simplify = TRUE,
  keepFactors = TRUE,
  family = NULL,
  powerBelow = -5,
  interaction.combine = NULL,
  interaction.order = NULL,
  i.equal = NULL,
  depvar = TRUE,
  style.df = NULL,
  group = NULL,
  extralines = NULL,
  fixef.group = NULL,
  drop.section = NULL,
  poly_dict = c("", " square", " cube"),
  postprocess.df = NULL,
  fit_format = "__var__",
  coef.just = NULL,
  highlight = NULL,
  coef.style = NULL,
  export = NULL,
  page.width = "fit",
  div.class = "etable"
)

esttex(
  ...,
  vcov = NULL,
  stage = 2,
  agg = NULL,
  se = NULL,
  ssc = NULL,
  cluster = NULL,
  .vcov = NULL,
  .vcov_args = NULL,
  digits = 4,
  digits.stats = 5,
  fitstat = NULL,
  title = NULL,
  coefstat = "se",
  ci = 0.95,
  se.row = NULL,
  se.below = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  dict = TRUE,
  file = NULL,
  replace = FALSE,
  convergence = NULL,
  signif.code = NULL,
  label = NULL,
  float = NULL,
  headers = list("auto"),
  fixef_sizes = FALSE,
  fixef_sizes.simplify = TRUE,
  keepFactors = TRUE,
  family = NULL,
  powerBelow = -5,
  interaction.combine = NULL,
  interaction.order = NULL,
  i.equal = NULL,
  depvar = TRUE,
  style.tex = NULL,
  notes = NULL,
  group = NULL,
  extralines = NULL,
  fixef.group = NULL,
  placement = "htbp",
  drop.section = NULL,
  poly_dict = c("", " square", " cube"),
  postprocess.tex = NULL,
  tpt = FALSE,
  arraystretch = NULL,
  adjustbox = NULL,
  fontsize = NULL,
  fit_format = "__var__",
  tabular = "normal",
  highlight = NULL,
  coef.style = NULL,
  meta = NULL,
  meta.time = NULL,
  meta.author = NULL,
  meta.sys = NULL,
  meta.call = NULL,
  meta.comment = NULL,
  view = FALSE,
  export = NULL,
  markdown = NULL,
  page.width = "fit",
  div.class = "etable"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etable_+3A_...">...</code></td>
<td>
<p>Used to capture different <code>fixest</code> estimation objects (obtained with <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>). Note that any other type of element is discarded. Note that you can give a list of <code>fixest</code> objects.</p>
</td></tr>
<tr><td><code id="etable_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="etable_+3A_stage">stage</code></td>
<td>
<p>Can be equal to <code>2</code> (default), <code>1</code>, <code>1:2</code> or <code>2:1</code>. Only used if the object is an IV estimation: defines the stage to which <code>summary</code> should be applied. If <code>stage = 1</code> and there are multiple endogenous regressors or if <code>stage</code> is of length 2, then an object of class <code>fixest_multi</code> is returned.</p>
</td></tr>
<tr><td><code id="etable_+3A_agg">agg</code></td>
<td>
<p>A character scalar describing the variable names to be aggregated, it is pattern-based. For <code><a href="#topic+sunab">sunab</a></code> estimations, the following keywords work: &quot;att&quot;, &quot;period&quot;, &quot;cohort&quot; and <code>FALSE</code> (to have full disaggregation). All variables that match the pattern will be aggregated. It must be of the form <code>"(root)"</code>, the parentheses must be there and the resulting variable name will be <code>"root"</code>. You can add another root with parentheses: <code>"(root1)regex(root2)"</code>, in which case the resulting name is <code>"root1::root2"</code>. To name the resulting variable differently you can pass a named vector: <code>c("name" = "pattern")</code> or <code>c("name" = "pattern(root2)")</code>. It's a bit intricate sorry, please see the examples.</p>
</td></tr>
<tr><td><code id="etable_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="etable_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="etable_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_.vcov">.vcov</code></td>
<td>
<p>A function to be used to compute the standard-errors of each fixest object. You can pass extra arguments to this function using the argument <code>.vcov_args</code>. See the example.</p>
</td></tr>
<tr><td><code id="etable_+3A_.vcov_args">.vcov_args</code></td>
<td>
<p>A list containing arguments to be passed to the function <code>.vcov</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_digits">digits</code></td>
<td>
<p>Integer or character scalar. Default is 4 and represents the number of significant digits to be displayed for the coefficients and standard-errors. To apply rounding instead of significance use, e.g., <code>digits = "r3"</code> which will round at the first 3 decimals. If character, it must be of the form <code>"rd"</code> or <code>"sd"</code> with <code>d</code> a digit (<code>r</code> is for round and <code>s</code> is for significance). For the number of digits for the fit statistics, use <code>digits.stats</code>. Note that when significance is used it does not exactly display the number of significant digits: see details for its exact meaning.</p>
</td></tr>
<tr><td><code id="etable_+3A_digits.stats">digits.stats</code></td>
<td>
<p>Integer or character scalar. Default is 5 and represents the number of significant digits to be displayed for the fit statistics. To apply rounding instead of significance use, e.g., <code>digits = "r3"</code> which will round at the first 3 decimals. If character, it must be of the form <code>"rd"</code> or <code>"sd"</code> with <code>d</code> a digit (<code>r</code> is for round and <code>s</code> is for significance). Note that when significance is used it does not exactly display the number of significant digits: see details for its exact meaning.</p>
</td></tr>
<tr><td><code id="etable_+3A_tex">tex</code></td>
<td>
<p>Logical: whether the results should be a data.frame or a Latex table. By default, this argument is <code>TRUE</code> if the argument <code>file</code> (used for exportation) is not missing; it is equal to <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="etable_+3A_fitstat">fitstat</code></td>
<td>
<p>A character vector or a one sided formula (both with only lowercase letters). A vector listing which fit statistics to display. The valid types are 'n', 'll', 'aic', 'bic' and r2 types like 'r2', 'pr2', 'war2', etc (see all valid types in <code><a href="#topic+r2">r2</a></code>). Also accepts valid types from the function <code><a href="#topic+fitstat">fitstat</a></code>. The default value depends on the models to display. Example of use: <code>fitstat=c('n', 'cor2', 'ar2', 'war2')</code>, or <code>fitstat=~n+cor2+ar2+war2</code> using a formula. You can use the dot to refer to default values:<code> ~ . + ll</code> would add the log-likelihood to the default fit statistics.</p>
</td></tr>
<tr><td><code id="etable_+3A_title">title</code></td>
<td>
<p>(Tex only.) Character scalar. The title of the Latex table.</p>
</td></tr>
<tr><td><code id="etable_+3A_coefstat">coefstat</code></td>
<td>
<p>One of <code>"se"</code> (default), <code>"tstat"</code> or <code>"confint"</code>. The statistic to report for each coefficient: the standard-error, the t-statistics or the confidence interval. You can adjust the confidence interval with the argument <code>ci</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_ci">ci</code></td>
<td>
<p>Level of the confidence interval, defaults to <code>0.95</code>. Only used if <code>coefstat = confint</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_se.row">se.row</code></td>
<td>
<p>Logical scalar, default is <code>NULL</code>. Whether should be displayed the row with the type of standard-error for each model. When <code>tex = FALSE</code>, the default is <code>TRUE</code>. When <code>tex = FALSE</code>, the row is showed only when there is a table-footer and the types of standard-errors differ across models.</p>
</td></tr>
<tr><td><code id="etable_+3A_se.below">se.below</code></td>
<td>
<p>Logical or <code>NULL</code> (default). Should the standard-errors be displayed below the coefficients? If <code>NULL</code>, then this is <code>TRUE</code> for Latex and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="etable_+3A_keep">keep</code></td>
<td>
<p>Character vector. This element is used to display only a subset of variables. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be kept. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code>keep = "x[[:digit:]]$"</code>. If the first character is an exclamation mark, the effect is reversed (e.g. keep = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is kept). See details.</p>
</td></tr>
<tr><td><code id="etable_+3A_drop">drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be discarded. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code style="white-space: pre;">&#8288;drop = "x[[:digit:]]{2}&#8288;</code>&quot;. If the first character is an exclamation mark, the effect is reversed (e.g. drop = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is dropped). See details.</p>
</td></tr>
<tr><td><code id="etable_+3A_order">order</code></td>
<td>
<p>Character vector. This element is used if the user wants the variables to be ordered in a certain way. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). The variables satisfying the first regular expression will be placed first, then the order follows the sequence of regular expressions. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the following variables: <code>month1</code> to <code>month6</code>, then <code>x1</code> to <code>x5</code>, then <code>year1</code> to <code>year6</code>. If you want to display first the x's, then the years, then the months you could use: <code>order = c("x", "year")</code>. If the first character is an exclamation mark, the effect is reversed (e.g. order = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; goes first).  See details.</p>
</td></tr>
<tr><td><code id="etable_+3A_dict">dict</code></td>
<td>
<p>A named character vector or a logical scalar. It changes the original variable names to the ones contained in the <code>dict</code>ionary. E.g. to change the variables named <code>a</code> and <code>b3</code> to (resp.) &ldquo;$log(a)$&rdquo; and to &ldquo;$bonus^3$&rdquo;, use <code>dict=c(a="$log(a)$",b3="$bonus^3$")</code>. By default, it is equal to <code>getFixest_dict()</code>, a default dictionary which can be set with <code><a href="#topic+setFixest_dict">setFixest_dict</a></code>. You can use <code>dict = FALSE</code> to disable it. By default <code>dict</code> modifies the entries in the global dictionary, to disable this behavior, use &quot;reset&quot; as the first element (ex: <code>dict=c("reset", mpg="Miles per gallon")</code>).</p>
</td></tr>
<tr><td><code id="etable_+3A_file">file</code></td>
<td>
<p>A character scalar. If provided, the Latex (or data frame) table will be saved in a file whose path is <code>file</code>. If you provide this argument, then a Latex table will be exported, to export a regular <code>data.frame</code>, use argument <code>tex = FALSE</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_replace">replace</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only used if option <code>file</code> is used. Should the exported table be written in a new file that replaces any existing file?</p>
</td></tr>
<tr><td><code id="etable_+3A_convergence">convergence</code></td>
<td>
<p>Logical, default is missing. Should the convergence state of the algorithm be displayed? By default, convergence information is displayed if at least one model did not converge.</p>
</td></tr>
<tr><td><code id="etable_+3A_signif.code">signif.code</code></td>
<td>
<p>Named numeric vector, used to provide the significance codes with respect to the p-value of the coefficients. Default is <code>c("***"=0.01, "**"=0.05, "*"=0.10)</code> for a Latex table and <code>c("***"=0.001, "**"=0.01, "*"=0.05, "."=0.10)</code> for a data.frame (to conform with R's default). To suppress the significance codes, use <code>signif.code=NA</code> or <code>signif.code=NULL</code>. Can also be equal to <code>"letters"</code>, then the default becomes <code>c("a"=0.01, "b"=0.05, "c"=0.10)</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_label">label</code></td>
<td>
<p>(Tex only.) Character scalar. The label of the Latex table.</p>
</td></tr>
<tr><td><code id="etable_+3A_float">float</code></td>
<td>
<p>(Tex only.) Logical. By default, if the argument <code>title</code> or <code>label</code> is provided, it is set to <code>TRUE</code>. Otherwise, it is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_headers">headers</code></td>
<td>
<p>Character vector or list. Adds one or more header lines in the table. A header line can be represented by a character vector or a named list of numbers where the names are the cell values and the numbers are the span. Example: <code>headers=list("M"=2, "F"=3)</code> will create a row with 2 times &quot;M&quot; and three time &quot;F&quot; (this is identical to <code>headers=rep(c("M", "F"), c(2, 3))</code>). You can stack header lines within a list, in that case the list names will be displayed in the leftmost cell. Example: <code style="white-space: pre;">&#8288;headers=list(Gender=list("M"=2, "F"=3), Country="US"&#8288;</code> will create two header lines. When <code>tex = TRUE</code>, you can add a rule to separate groups by using <code>":_:"</code> somewhere in the row name (ex: <code>headers=list(":_:Gender"=list("M"=2, "F"=3))</code>. You can monitor the placement by inserting a special character in the row name: &quot;^&quot; means at the top, &quot;-&quot; means in the middle (default) and &quot;_&quot; means at the bottom. Example: <code>headers=list("_Country"="US")</code> will add the country row as the very last header row (after the model row). Finally, you can use the special value &quot;auto&quot; to include automatic headers when the data contains split sample estimations. By default it is equal to <code>list("auto")</code>. You can use <code>.()</code> instead of <code>list()</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_fixef_sizes">fixef_sizes</code></td>
<td>
<p>(Tex only.) Logical, default is <code>FALSE</code>. If <code>TRUE</code> and fixed-effects were used in the models, then the number of &quot;units&quot; per fixed-effect dimension is also displayed.</p>
</td></tr>
<tr><td><code id="etable_+3A_fixef_sizes.simplify">fixef_sizes.simplify</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Only used if <code>fixef_sizes = TRUE</code>. If <code>TRUE</code>, the fixed-effects sizes will be displayed in parentheses instead of in a separate line if there is no ambiguity (i.e. if the size is constant across models).</p>
</td></tr>
<tr><td><code id="etable_+3A_keepfactors">keepFactors</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>FALSE</code>, then factor variables are displayed as fixed-effects and no coefficient is shown.</p>
</td></tr>
<tr><td><code id="etable_+3A_family">family</code></td>
<td>
<p>Logical, default is missing. Whether to display the families of the models. By default this line is displayed when at least two models are from different families.</p>
</td></tr>
<tr><td><code id="etable_+3A_powerbelow">powerBelow</code></td>
<td>
<p>(Tex only.) Integer, default is -5. A coefficient whose value is below <code>10**(powerBelow+1)</code> is written with a power in Latex. For example <code>0.0000456</code> would be written <code style="white-space: pre;">&#8288;4.56$\\times 10^{-5}$&#8288;</code> by default. Setting <code>powerBelow = -6</code> would lead to <code>0.00004</code> in Latex.</p>
</td></tr>
<tr><td><code id="etable_+3A_interaction.combine">interaction.combine</code></td>
<td>
<p>Character scalar, defaults to <code>" $\\times$ "</code> for Tex and to <code>" = "</code> otherwise. When the estimation contains interactions, then the variables names (after aliasing) are combined with this argument. For example: if <code>dict = c(x1="Wind", x2="Rain")</code> and you have the following interaction <code>x1:x2</code>, then it will be renamed (by default) <code style="white-space: pre;">&#8288;Wind $\\times$ Rain&#8288;</code> &ndash; using <code>interaction.combine = "*"</code> would lead to <code>Wind*Rain</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_interaction.order">interaction.order</code></td>
<td>
<p>Character vector of regular expressions. Only affects variables that are interacted like x1 and x2 in <code>feols(y ~ x1*x2, data)</code>. You can change the order in which the interacted variables are displayed: e.g. <code>interaction.order = "x2"</code> would lead to &quot;x1 x x2&quot; instead of &quot;x1 x x2&quot;. Please look at the argument 'order' and the dedicated section in the help page for more information.</p>
</td></tr>
<tr><td><code id="etable_+3A_i.equal">i.equal</code></td>
<td>
<p>Character scalar, defaults to <code>" $=$ "</code> when <code>tex = TRUE</code> and <code>" = "</code> otherwise. Only affects factor variables created with the function <code><a href="#topic+i">i</a></code>, tells how the variable should be linked to its value. For example if you have the <code>Species</code> factor from the <code>iris</code> data set, by default the display of the variable is <code>Species = Setosa</code>, etc. If <code>i.equal = ": "</code> the display becomes <code>Species: Setosa</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_depvar">depvar</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether a first line containing the dependent variables should be shown.</p>
</td></tr>
<tr><td><code id="etable_+3A_style.tex">style.tex</code></td>
<td>
<p>An object created by the function <code><a href="#topic+style.tex">style.tex</a></code>. It represents the style of the Latex table, see the documentation of <code><a href="#topic+style.tex">style.tex</a></code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_style.df">style.df</code></td>
<td>
<p>An object created by the function <code><a href="#topic+style.df">style.df</a></code> It represents the style of the data frame returned (if <code>tex = FALSE</code>), see the documentation of <code><a href="#topic+style.df">style.df</a></code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_notes">notes</code></td>
<td>
<p>(Tex only.) Character vector. If provided, a <code>"notes"</code> section will be added at the end right after the end of the table, containing the text of this argument. If it is a vector, it will be collapsed with new lines. If <code>tpt = TRUE</code>, the behavior is different: each element of the vector is an item. If the first element of the vector starts with <code>"@"</code>, then it will be included verbatim, and in case of <code>tpt = TRUE</code>, right before the first item. If that element is provided, it will replace the value defined in <code>style.tex(notes.intro)</code> or <code>style.tex(notes.tpt.intro)</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_group">group</code></td>
<td>
<p>A list. The list elements should be vectors of regular expressions. For each elements of this list: A new line in the table is created, all variables that are matched by the regular expressions are discarded (same effect as the argument <code>drop</code>) and <code>TRUE</code> or <code>FALSE</code> will appear in the model cell, depending on whether some of the previous variables were found in the model. Example: <code>group=list("Controls: personal traits"=c("gender", "height", "weight"))</code> will create an new line with <code>"Controls: personal traits"</code> in the leftmost cell, all three variables gender, height and weight are discarded, <code>TRUE</code> appearing in each model containing at least one of the three variables (the style of <code>TRUE</code>/<code>FALSE</code> is governed by the argument <code>yesNo</code>). You can control the placement of the new row by using 1 or 2 special characters at the start of the row name. The meaning of these special characters are: 1) <code>"^"</code>: coef., <code>"-"</code>: fixed-effect, <code>"_"</code>: stats, section; 2) <code>"^"</code>: 1st, <code>"_"</code>: last, row. For example: <code>group=list("_^Controls"=stuff)</code> will place the line at the top of the 'stats' section, and using <code>group=list("^_Controls"=stuff)</code> will make the row appear at the bottom of the coefficients section. For details, see the dedicated section.</p>
</td></tr>
<tr><td><code id="etable_+3A_extralines">extralines</code></td>
<td>
<p>A vector, a list or a one sided formula. The list elements should be either a vector representing the value of each cell, a list of the form <code style="white-space: pre;">&#8288;list("item1" = #item1, "item2" = #item2, etc)&#8288;</code>, or a function. This argument can be many things, please have a look at the dedicated help section; a simplified description follows. For each elements of this list: A new line in the table is created, the list name being the row name and the vector being the content of the cells. Example: <code>extralines=list("Sub-sample"=c("&lt;20 yo", "all", "&gt;50 yo"))</code> will create an new line with <code>"Sub-sample"</code> in the leftmost cell, the vector filling the content of the cells for the three models. You can control the placement of the new row by using 1 or 2 special characters at the start of the row name. The meaning of these special characters are: 1) <code>"^"</code>: coef., <code>"-"</code>: fixed-effect, <code>"_"</code>: stats, section; 2) <code>"^"</code>: 1st, <code>"_"</code>: last, row. For example: <code>extralines=list("__Controls"=stuff)</code> will place the line at the bottom of the stats section, and using <code>extralines=list("^^Controls"=stuff)</code> will make the row appear at the top of the 'coefficients' section. For details, see the dedicated section. You can use <code>.()</code> instead of <code>list()</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_fixef.group">fixef.group</code></td>
<td>
<p>Logical scalar or list (default is <code>NULL</code>). If equal to <code>TRUE</code>, then all fixed-effects always appearing jointly in models will be grouped in one row. If a list, its elements must be character vectors of regular expressions and the list names will be the row names. For ex. <code>fixef.group=list("Dates fixed-effects"="Month|Day")</code> will remove the <code>"Month"</code> and <code>"Day"</code> fixed effects from the display and replace them with a single row named &quot;Dates fixed-effects&quot;. You can monitor the placement of the new row with two special characters telling where to place the row within a section: first in which section it should appear: <code>"^"</code> (coef.), <code>"-"</code> (fixed-effects), or <code>"_"</code> (stat.) section; then whether the row should be <code>"^"</code> (first), or <code>"_"</code> (last). These two special characters must appear first in the row names. Please see the dedicated section</p>
</td></tr>
<tr><td><code id="etable_+3A_placement">placement</code></td>
<td>
<p>(Tex only.) Character string giving the position of the float in Latex. Default is &quot;htbp&quot;. It must consist of only the characters 'h', 't', 'b', 'p', 'H' and '!'. Reminder: h: here; t: top; b: bottom; p: float page; H: definitely here; !: prevents Latex to look for other positions. Note that it can be equal to the empty string (and you'll get the default placement).</p>
</td></tr>
<tr><td><code id="etable_+3A_drop.section">drop.section</code></td>
<td>
<p>Character vector which can be of length 0 (i.e. equal to <code>NULL</code>). Can contain the values &quot;coef&quot;, &quot;fixef&quot;, &quot;slopes&quot; or &quot;stats&quot;. It would drop, respectively, the coefficients section, fixed-effects section, the variables with varying slopes section or the fit statistics section.</p>
</td></tr>
<tr><td><code id="etable_+3A_poly_dict">poly_dict</code></td>
<td>
<p>Character vector, default is <code>c("", " square", " cube")</code>. When raw polynomials (<code>x^2</code>, etc) are used, the variables are automatically renamed and <code>poly_dict</code> rules the display of the power. For powers greater than the number of elements of the vector, the value displayed is <code style="white-space: pre;">&#8288;$^{pow}$&#8288;</code> in Latex and <code style="white-space: pre;">&#8288;^ pow&#8288;</code> in the R console.</p>
</td></tr>
<tr><td><code id="etable_+3A_postprocess.tex">postprocess.tex</code></td>
<td>
<p>A function that will postprocess the character vector defining the latex table. Only when <code>tex = TRUE</code>. By default it is equal to <code>NULL</code>, meaning that there is no postprocessing. When <code>tex = FALSE</code>, see the argument <code>postprocess.df</code>. See details.</p>
</td></tr>
<tr><td><code id="etable_+3A_postprocess.df">postprocess.df</code></td>
<td>
<p>A function that will postprocess.tex the resulting data.frame. Only when <code>tex = FALSE</code>. By default it is equal to <code>NULL</code>, meaning that there is no postprocessing. When <code>tex = TRUE</code>, see the argument <code>postprocess.tex</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_tpt">tpt</code></td>
<td>
<p>(Tex only.) Logical scalar, default is FALSE. Whether to use the <code>threeparttable</code> environment. If so, the <code>notes</code> will be integrated into the <code>tablenotes</code> environment.</p>
</td></tr>
<tr><td><code id="etable_+3A_arraystretch">arraystretch</code></td>
<td>
<p>(Tex only.) A numeric scalar, default is <code>NULL</code>. If provided, the command <code style="white-space: pre;">&#8288;\\renewcommand*{\\arraystretch{x}}&#8288;</code> is inserted, replacing <code>x</code> by the value of <code>arraystretch</code>. The changes are specific to the current table and do not affect the rest of the document.</p>
</td></tr>
<tr><td><code id="etable_+3A_adjustbox">adjustbox</code></td>
<td>
<p>(Tex only.) A logical, numeric or character scalar, default is <code>NULL</code>. If not <code>NULL</code>, the table is inserted within the <code>adjustbox</code> environment. By default the options are <code style="white-space: pre;">&#8288;width = 1\\textwidth, center&#8288;</code> (if <code>TRUE</code>). A numeric value changes the value before <code style="white-space: pre;">&#8288;\\textwidth&#8288;</code>. You can also add a character of the form <code>"x tw"</code> or <code>"x th"</code> with <code>x</code> a number and where tw (th) stands for text-width (text-height). Finally any other character value is passed verbatim as an <code>adjustbox</code> option.</p>
</td></tr>
<tr><td><code id="etable_+3A_fontsize">fontsize</code></td>
<td>
<p>(Tex only.) A character scalar, default is <code>NULL</code>. Can be equal to <code>tiny</code>, <code>scriptsize</code>, <code>footnotesize</code>, <code>small</code>, <code>normalsize</code>, <code>large</code>, or <code>Large</code>. The change affect the table only (and not the rest of the document).</p>
</td></tr>
<tr><td><code id="etable_+3A_fit_format">fit_format</code></td>
<td>
<p>Character scalar, default is <code>"__var__"</code>. Only used in the presence of IVs. By default the endogenous regressors are named <code>fit_varname</code> in the second stage. The format of the endogenous regressor to appear in the table is governed by <code>fit_format</code>. For instance, by default, the prefix <code>"fit_"</code> is removed, leading to only <code>varname</code> to appear. If <code style="white-space: pre;">&#8288;fit_format = "$\\\\hat{__var__$"}&#8288;</code>, then <code style="white-space: pre;">&#8288;"$\\hat{varname$"}&#8288;</code> will appear in the table.</p>
</td></tr>
<tr><td><code id="etable_+3A_coef.just">coef.just</code></td>
<td>
<p>(DF only.) Either <code>"."</code>, <code>"("</code>, <code>"l"</code>, <code>"c"</code> or <code>"r"</code>, default is <code>NULL</code>. How the coefficients should be justified. If <code>NULL</code> then they are right aligned if <code>se.below = FALSE</code> and aligned to the dot if <code>se.below = TRUE</code>. The keywords stand respectively for dot-, parenthesis-, left-, center- and right-aligned.</p>
</td></tr>
<tr><td><code id="etable_+3A_tabular">tabular</code></td>
<td>
<p>(Tex only.) Character scalar equal to &quot;normal&quot; (default), <code>"*"</code> or <code>"X"</code>. Represents the type of tabular environment to use: either <code>tabular</code>, <code style="white-space: pre;">&#8288;tabular*&#8288;</code> or <code>tabularx</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_highlight">highlight</code></td>
<td>
<p>List containing coefficients to highlight. Highlighting is of the form <code>.("options1" = "coefs1", "options2" = "coefs2", etc)</code>.
The coefficients to be highlighted can be written in three forms: 1) row, eg <code>"x1"</code> will highlight the full row of the variable <code>x1</code>; 2) cells, use <code>'@'</code> after the coefficient name to give the column, it accepts ranges, eg <code>"x1@2, 4-6, 8"</code> will highlight only the columns 2, 4, 5, 6, and 8 of the variable <code>x1</code>; 3) range, by giving the top-left and bottom-right values separated with a semi-colon, eg <code>"x1@2 ; x3@5"</code> will highlight from the column 2 of <code>x1</code> to the 5th column of <code>x3</code>. Coefficient names are partially matched, use a <code>'%'</code> first to refer to the original name (before dictionary) and use <code>'@'</code> first to use a regular expression. You can add a vector of row/cell/range.
The options are a comma-separated list of items. By default the highlighting is done with a frame (a thick box) around the coefficient, use <code>'rowcol'</code> to highlight with a row color instead. Here are the other options: <code>'se'</code> to highlight the standard-errors too; <code>'square'</code> to have a square box (instead of rounded); <code>'thick1'</code> to <code>'thick6'</code> to monitor the width of the box; <code>'sep0'</code> to <code>'sep9'</code> to monitor the inner spacing. Finally the remaining option is the color: simply add an R color (it must be a valid R color!). You can use <code>"color!alpha"</code> with &quot;alpha&quot; a number between 0 to 100 to change the alpha channel of the color.</p>
</td></tr>
<tr><td><code id="etable_+3A_coef.style">coef.style</code></td>
<td>
<p>Named list containing styles to be applied to the coefficients. It must be of the form <code>.("style1" = "coefs1", "style2" = "coefs2", etc)</code>. The style must contain the string <code>":coef:"</code> (or <code>":coef_se:"</code> to style both the coefficient and its standard-error). The string <code style="white-space: pre;">&#8288;:coef:&#8288;</code> will be replaced verbatim by the coefficient value. For example use <code>"\\textbf{:coef:}"</code> to put the coefficient in bold. Note that markdown markup is enabled so <code>"**:coef:**"</code> would also put it in bold. The coefficients to be styled can be written in three forms: 1) row, eg <code>"x1"</code> will style the full row of the variable <code>x1</code>; 2) cells, use <code>'@'</code> after the coefficient name to give the column, it accepts ranges, eg <code>"x1@2, 4-6, 8"</code> will style only the columns 2, 4, 5, 6, and 8 of the variable <code>x1</code>; 3) range, by giving the top-left and bottom-right values separated with a semi-colon, eg <code>"x1@2 ; x3@5"</code> will style from the column 2 of <code>x1</code> to the 5th column of <code>x3</code>. Coefficient names are partially matched, use a <code>'%'</code> first to refer to the original name (before dictionary) and use <code>'@'</code> first to use a regular expression. You can add a vector of row/cell/range.</p>
</td></tr>
<tr><td><code id="etable_+3A_meta">meta</code></td>
<td>
<p>(Tex only.) A one-sided formula that shall contain the following elements: date or time, sys, author, comment and call. Default is <code>NULL</code>. This argument is a shortcut to controlling the meta information that can be displayed in comments before the table. Typically if the element is in the formula, it means that the argument will be equal to <code>TRUE</code>. Example: <code>meta = ~time+call</code> is equivalent to <code>meta.time = TRUE</code> and <code>meta.call = TRUE</code>. The &quot;author&quot; and &quot;comment&quot; elements are a bit special. Using <code>meta = ~author("Mark")</code> is equivalent to <code>meta.author = "Mark"</code> while <code>meta=~author</code> is equiv. to <code>meta.author = TRUE</code>. The &quot;comment&quot; must be used with a character string inside: <code>meta = ~comment("this is a comment")</code>. The order in the formula controls the order of appearance of the meta elements. It also has precedence over the <code>meta.XX</code> arguments.</p>
</td></tr>
<tr><td><code id="etable_+3A_meta.time">meta.time</code></td>
<td>
<p>(Tex only.) Either a logical scalar (default is <code>FALSE</code>) or &quot;time&quot; or &quot;date&quot;. Whether to include the time (if <code>TRUE</code> or &quot;time&quot;) or the date (if &quot;date&quot;) of creation of the table in a comment right before the table.</p>
</td></tr>
<tr><td><code id="etable_+3A_meta.author">meta.author</code></td>
<td>
<p>(Tex only.) A logical scalar (default is <code>FALSE</code>) or a character vector. If <code>TRUE</code> then the identity of the author (deduced from the system user in <code>Sys.info()</code>) is inserted in a comment right before the table. If a character vector, then it should contain author names that will be inserted as comments before the table, prefixed with <code>"Created by:"</code>. For free-form comments see the argument <code>meta.comment</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_meta.sys">meta.sys</code></td>
<td>
<p>(Tex only.) A logical scalar, default is <code>FALSE</code>. Whether to include system information (from <code>Sys.info()</code>) in a comment right before the table.</p>
</td></tr>
<tr><td><code id="etable_+3A_meta.call">meta.call</code></td>
<td>
<p>(Tex only.) Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then the call to the function is inserted right before the table in a comment.</p>
</td></tr>
<tr><td><code id="etable_+3A_meta.comment">meta.comment</code></td>
<td>
<p>(Tex only.) A character vector containing free-form comments to be inserted right before the table.</p>
</td></tr>
<tr><td><code id="etable_+3A_view">view</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then the table generated in Latex by <code>etable</code> and then is displayed in the viewer pane. Note that for this option to work you need i) pdflatex, ii) imagemagick and iii) ghostscript. All three software must be installed and on the path.</p>
</td></tr>
<tr><td><code id="etable_+3A_export">export</code></td>
<td>
<p>Character scalar giving the path to a PNG file to be created, default is <code>NULL</code>. If provided, the Latex table will be converted to PNG and copied to the <code>export</code> location. Note that for this option to work you need a working distribution of <code>pdflatex</code>, <code>imagemagick</code> and <code>ghostscript</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_markdown">markdown</code></td>
<td>
<p>Character scalar giving the location of a directory, or a logical scalar. Default is <code>NULL</code>. This argument only works in Rmarkdown documents, when knitting the document. If provided: two behaviors depending on context. A) if the output document is Latex, the table is exported in Latex. B) if the output document is not Latex, the table will be exported to PNG at the desired location and inserted in the document via a markdown link. If equal to <code>TRUE</code>, the default location of the PNGs is a temporary folder for <code style="white-space: pre;">&#8288;R &gt; 4.0.0&#8288;</code>, or to <code>"images/etable/"</code> for earlier versions.</p>
</td></tr>
<tr><td><code id="etable_+3A_page.width">page.width</code></td>
<td>
<p>Character scalar equal to <code>'fit'</code> (default), <code>'a4'</code> or <code>'us'</code>; or a single Latex measure (like <code>'17cm'</code>) or a double one (like <code>"21, 2cm"</code>). Only used when the Latex table is to be viewed (<code>view = TRUE</code>), exported (<code>export != NULL</code>) or displayed in Rmarkdown (<code>markdown != NULL</code>). It represents the text width of the page in which the Latex table will be inserted. By default, <code>'fit'</code>, the page fits exactly the table (i.e. text width = table width). If <code>'a4'</code> or <code>'us'</code>, two times 2cm is removed from the page width to account for margins. Providing a page width and a margin width, like in <code>"17in, 1in"</code>, enables a correct display of the argument <code>adjustbox</code>. Note that the margin width represent the width of a single side margin (and hence will be doubled).</p>
</td></tr>
<tr><td><code id="etable_+3A_div.class">div.class</code></td>
<td>
<p>Character scalar, default is <code>"etable"</code>. Only used in Rmarkdown documents when <code>markdown = TRUE</code>. The table in an image format is embedded in a <code style="white-space: pre;">&#8288;&lt;div&gt;&#8288;</code> container, and that container is of class <code>div.class</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_view.cache">view.cache</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only used when <code>view = TRUE</code>. Whether the PNGs of the tables should be cached.</p>
</td></tr>
<tr><td><code id="etable_+3A_reset">reset</code></td>
<td>
<p>(<code>setFixest_etable</code> only.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, this will reset all the default values that were already set by the user in previous calls.</p>
</td></tr>
<tr><td><code id="etable_+3A_save">save</code></td>
<td>
<p>Either a logical or equal to <code>"reset"</code>. Default is <code>FALSE</code>. If <code>TRUE</code> then the value is set permanently at the project level, this means that if you restart R, you will still obtain the previously saved defaults. This is done by writing in the <code>".Renviron"</code> file, located in the project's working directory, hence we must have write permission there for this to work, and only works with Rstudio. If equal to &quot;reset&quot;, the default at the project level is erased. Since there is writing in a file involved, permission is asked to the user.</p>
</td></tr>
<tr><td><code id="etable_+3A_x">x</code></td>
<td>
<p>An object returned by <code>etable</code>.</p>
</td></tr>
<tr><td><code id="etable_+3A_type">type</code></td>
<td>
<p>Character scalar equal to 'pdflatex' (default), 'magick', 'dir' or 'tex'. Which log file to report; if 'tex', the full source code of the tex file is returned, if 'dir': the directory of the log files is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>esttex</code> is equivalent to the function <code>etable</code> with argument <code>tex = TRUE</code>.
</p>
<p>The function <code>esttable</code> is equivalent to the function <code>etable</code> with argument <code>tex = FALSE</code>.
</p>
<p>To display the table, you will need the Latex package <code>booktabs</code> which contains the <code style="white-space: pre;">&#8288;\\toprule&#8288;</code>, <code style="white-space: pre;">&#8288;\\midrule&#8288;</code> and <code style="white-space: pre;">&#8288;\\bottomrule&#8288;</code> commands.
</p>
<p>You can permanently change the way your table looks in Latex by using <code>setFixest_etable</code>. The following vignette gives an example as well as illustrates how to use the <code>style</code> and postprocessing functions: <a href="https://lrberge.github.io/fixest/articles/exporting_tables.html">Exporting estimation tables</a>.
</p>
<p>When the argument <code>postprocessing.tex</code> is not missing, two additional tags will be included in the character vector returned by <code>etable</code>: <code>"%start:tab\\n"</code> and <code>"%end:tab\\n"</code>. These can be used to identify the start and end of the tabular and are useful to insert code within the <code>table</code> environment.
</p>


<h3>Value</h3>

<p>If <code>tex = TRUE</code>, the lines composing the Latex table are returned invisibly while the table is directly prompted on the console.
</p>
<p>If <code>tex = FALSE</code>, the data.frame is directly returned. If the argument <code>file</code> is not missing, the <code>data.frame</code> is printed and returned invisibly.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>esttable()</code>: Exports the results of multiple <code>fixest</code> estimations in a Latex table.
</p>
</li>
<li> <p><code>esttex()</code>: Exports the results of multiple <code>fixest</code> estimations in a Latex table.
</p>
</li></ul>


<h3>How does <code>digits</code> handle the number of decimals displayed?</h3>

<p>The default display of decimals is the outcome of an algorithm. Let's take the example of <code>digits = 3</code> which &quot;kind of&quot; requires 3 significant digits to be displayed.
</p>
<p>For numbers greater than 1 (in absolute terms), their integral part is always displayed and the number of decimals shown is equal to <code>digits</code> minus the number of digits in the integral part. This means that <code>12.345</code> will be displayed as <code>12.3</code>. If the number of decimals should be 0, then a single decimal is displayed to suggest that the number is not whole. This means that <code>1234.56</code> will be displayed as <code>1234.5</code>. Note that if the number is whole, no decimals are shown.
</p>
<p>For numbers lower than 1 (in absolute terms), the number of decimals displayed is equal to <code>digits</code> except if there are only 0s in which case the first significant digit is shown. This means that <code>0.01234</code> will be displayed as <code>0.012</code> (first rule), and that 0.000123 will be displayed as <code>0.0001</code> (second rule).
</p>


<h3>Arguments keep, drop and order</h3>

<p>The arguments <code>keep</code>, <code>drop</code> and <code>order</code> use regular expressions. If you are not aware of regular expressions, I urge you to learn it, since it is an extremely powerful way to manipulate character strings (and it exists across most programming languages).
</p>
<p>For example drop = &quot;Wind&quot; would drop any variable whose name contains &quot;Wind&quot;. Note that variables such as &quot;Temp:Wind&quot; or &quot;StrongWind&quot; do contain &quot;Wind&quot;, so would be dropped. To drop only the variable named &quot;Wind&quot;, you need to use <code>drop = "^Wind$"</code> (with &quot;^&quot; meaning beginning, resp. &quot;$&quot; meaning end, of the string =&gt; this is the language of regular expressions).
</p>
<p>Although you can combine several regular expressions in a single character string using pipes, <code>drop</code> also accepts a vector of regular expressions.
</p>
<p>You can use the special character &quot;!&quot; (exclamation mark) to reverse the effect of the regular expression (this feature is specific to this function). For example <code>drop = "!Wind"</code> would drop any variable that does not contain &quot;Wind&quot;.
</p>
<p>You can use the special character &quot;%&quot; (percentage) to make reference to the original variable name instead of the aliased name. For example, you have a variable named <code>"Month6"</code>, and use a dictionary <code>dict = c(Month6="June")</code>. Thus the variable will be displayed as <code>"June"</code>. If you want to delete that variable, you can use either <code>drop="June"</code>, or <code>drop="%Month6"</code> (which makes reference to its original name).
</p>
<p>The argument <code>order</code> takes in a vector of regular expressions, the order will follow the elements of this vector. The vector gives a list of priorities, on the left the elements with highest priority. For example, order = c(&quot;Wind&quot;, &quot;!Inter&quot;, &quot;!Temp&quot;) would give highest priorities to the variables containing &quot;Wind&quot; (which would then appear first), second highest priority is the variables not containing &quot;Inter&quot;, last, with lowest priority, the variables not containing &quot;Temp&quot;. If you had the following variables: (Intercept), Temp:Wind, Wind, Temp you would end up with the following order: Wind, Temp:Wind, Temp, (Intercept).
</p>


<h3>The argument <code>extralines</code></h3>

<p>The argument <code>extralines</code> adds well... extra lines to the table. It accepts either a list, or a one-sided formula.
</p>
<p>For each line, you can define the values taken by each cell using 4 different ways: a) a vector, b) a list, c) a function, and d) a formula.
</p>
<p>If a vector, it should represent the values taken by each cell. Note that if the length of the vector is smaller than the number of models, its values are recycled across models, but the length of the vector is required to be a divisor of the number of models.
</p>
<p>If a list, it should be of the form <code style="white-space: pre;">&#8288;list("item1" = #item1, "item2" = #item2, etc)&#8288;</code>. For example <code>list("A"=2, "B"=3)</code> leads to <code>c("A", "A", "B", "B", "B")</code>. Note that if the number of items is 1, you don't need to add <code style="white-space: pre;">&#8288;= 1&#8288;</code>. For example <code>list("A"=2, "B")</code> is valid and leads to <code style="white-space: pre;">&#8288;c("A", "A", "B"&#8288;</code>. As for the vector the values are recycled if necessary.
</p>
<p>If a function, it will be applied to each model and should return a scalar (<code>NA</code> values returned are accepted).
</p>
<p>If a formula, it must be one-sided and the elements in the formula must represent either <code>extralines</code> macros, either fit statistics (i.e. valid types of the function <code><a href="#topic+fitstat">fitstat</a></code>). One new line will be added for each element of the formula. To register <code>extralines</code> macros, you must first register them in <code><a href="#topic+extralines_register">extralines_register</a></code>.
</p>
<p>Finally, you can combine as many lines as wished by nesting them in a list. The names of the nesting list are the row titles (values in the leftmost cell). For example <code>extralines = list(~r2, Controls = TRUE, Group = list("A"=2, "B"))</code> will add three lines, the titles of which are &quot;R2&quot;, &quot;Controls&quot; and &quot;Group&quot;.
</p>


<h3>Controlling the placement of extra lines</h3>

<p>The arguments <code>group</code>, <code>extralines</code> and <code>fixef.group</code> allow to add customized lines in the table. They can be defined via a list where the list name will be the row name. By default, the placement of the extra line is right after the coefficients (except for <code>fixef.group</code>, covered in the last paragraph). For instance, <code>group = list("Controls" = "x[[:digit:]]")</code> will create a line right after the coefficients telling which models contain the control variables.
</p>
<p>But the placement can be customized. The previous example (of the controls) will be used for illustration (the mechanism for <code>extralines</code> and <code>fixef.group</code> is identical).
</p>
<p>The row names accept 2 special characters at the very start. The first character tells in which section the line should appear: it can be equal to <code>"^"</code>, <code>"-"</code>, or <code>"_"</code>, meaning respectively the coefficients, the fixed-effects and the statistics section (which typically appear at the top, mid and bottom of the table). The second one governs the placement of the new line within the section: it can be equal to <code>"^"</code>, meaning first line, or <code>"_"</code>, meaning last line.
</p>
<p>Let's have some examples. Using the previous example, writing <code>"_^Controls"</code> would place the new line at the top of the statistics section. Writing <code>"-_Controls"</code> places it as the last row of the fixed-effects section; <code>"^^Controls"</code> at the top row of the coefficients section; etc...
</p>
<p>The second character is optional, the default placement being in the bottom. This means that <code>"_Controls"</code> would place it at the bottom of the statistics section.
</p>
<p>The placement in <code>fixef.group</code> is defined similarly, only the default placement is different. Its default placement is at the top of the fixed-effects section.
</p>


<h3>Escaping special Latex characters</h3>

<p>By default on all instances (with the notable exception of the elements of <code><a href="#topic+style.tex">style.tex</a></code>) special Latex characters are escaped. This means that <code>title="Exports in million $."</code> will be exported as <code>"Exports in million \\$."</code>: the dollar sign will be escaped. This is true for the following characters: &amp;, <code>$</code>, %, _, ^ and #.
</p>
<p>Note, importantly, that equations are NOT escaped. This means that <code>title="Functional form $a_i \\times x^b$, variation in %."</code> will be displayed as: <code>"Functional form $a_i \\times x^b$, variation in \\%."</code>: only the last percentage will be escaped.
</p>
<p>If for some reason you don't want the escaping to take place, the arguments <code>headers</code> and <code>extralines</code> are the only ones allowing that. To disable escaping, add the special token &quot;:tex:&quot; in the row names. Example: in <code>headers=list(":tex:Row title"="weird &amp; &amp; %\\n tex stuff\\\\")</code>, the elements will be displayed verbatim. Of course, since it can easily ruin your table, it is only recommended to super users.
</p>


<h3>Markdown markup</h3>

<p>Within anything that is Latex-escaped (see previous section), you can use a markdown-style markup to put the text in italic and/or bold. Use <code style="white-space: pre;">&#8288;*text*&#8288;</code>, <code style="white-space: pre;">&#8288;**text**&#8288;</code> or <code style="white-space: pre;">&#8288;***text***&#8288;</code> to put some text in, respectively, italic (with <code style="white-space: pre;">&#8288;\\textit&#8288;</code>), bold (with <code style="white-space: pre;">&#8288;\\textbf&#8288;</code>) and italic-bold.
</p>
<p>The markup can be escaped by using an backslash first. For example <code>"***This: \\***, are three stars***"</code> will leave the three stars in the middle untouched.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. Use <code><a href="#topic+summary.fixest">summary.fixest</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> to extract the fixed-effects coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

est1 = feols(Ozone ~ i(Month) / Wind + Temp, data = airquality)
est2 = feols(Ozone ~ i(Month, Wind) + Temp | Month, data = airquality)

# Displaying the two results in a single table
etable(est1, est2)

# keep/drop: keeping only interactions
etable(est1, est2, keep = " x ")
# or using drop  (see regexp help):
etable(est1, est2, drop = "^(Month|Temp|\\()")

# keep/drop: dropping interactions
etable(est1, est2, drop = " x ")
# or using keep ("!" reverses the effect):
etable(est1, est2, keep = "! x ")

# order: Wind variable first, intercept last (note the "!" to reverse the effect)
etable(est1, est2, order = c("Wind", "!Inter"))
# Month, then interactions, then the rest
etable(est1, est2, order = c("^Month", " x "))

#
# dict
#

# You can rename variables with dict = c(var1 = alias1, var2 = alias2, etc)
# You can also rename values taken by factors.
# Here's a full example:
dict = c(Temp = "Temperature", "Month::5"="May", "6"="Jun")
etable(est1, est2, dict = dict)
# Note the difference of treatment between Jun and May

# Assume the following dictionary:
dict = c("Month::5"="May", "Month::6"="Jun", "Month::7"="Jul",
         "Month::8"="Aug", "Month::9"="Sep")

# We would like to keep only the Months, but now the names are all changed...
# How to do?
# We can use the special character '%' to make reference to the original names.

etable(est1, est2, dict = dict, keep = "%Month")

#
# signif.code
#

etable(est1, est2, signif.code = c(" A"=0.01, " B"=0.05, " C"=0.1, " D"=0.15, " F"=1))

#
# Using the argument style to customize Latex exports
#

# If you don't like the default layout of the table, no worries!
# You can modify many parameters with the argument style

# To drop the headers before each section, use:
# Note that a space adds an extra line
style_noHeaders = style.tex(var.title = "", fixef.title = "", stats.title = " ")
etable(est1, est2, dict = dict, tex = TRUE, style.tex = style_noHeaders)

# To change the lines of the table + dropping the table footer
style_lines = style.tex(line.top = "\\toprule", line.bottom = "\\bottomrule",
                    tablefoot = FALSE)
etable(est1, est2, dict = dict, tex = TRUE, style.tex = style_lines)

# Or you have the predefined type "aer"
etable(est1, est2, dict = dict, tex = TRUE, style.tex = style.tex("aer"))

#
# Group and extralines
#

# Sometimes it's useful to group control variables into a single line
# You can achieve that with the group argument

setFixest_fml(..ctrl = ~ poly(Wind, 2) + poly(Temp, 2))
est_c0 = feols(Ozone ~ Solar.R, data = airquality)
est_c1 = feols(Ozone ~ Solar.R + ..ctrl, data = airquality)
est_c2 = feols(Ozone ~ Solar.R + Solar.R^2 + ..ctrl, data = airquality)

etable(est_c0, est_c1, est_c2, group = list(Controls = "poly"))

# 'group' here does the same as drop = "poly", but adds an extra line
# with TRUE/FALSE where the variables were found

# 'extralines' adds an extra line, where you can add the value for each model
est_all  = feols(Ozone ~ Solar.R + Temp + Wind, data = airquality)
est_sub1 = feols(Ozone ~ Solar.R + Temp + Wind, data = airquality,
                 subset = ~ Month %in% 5:6)
est_sub2 = feols(Ozone ~ Solar.R + Temp + Wind, data = airquality,
                 subset = ~ Month %in% 7:8)
est_sub3 = feols(Ozone ~ Solar.R + Temp + Wind, data = airquality,
                 subset = ~ Month == 9)

etable(est_all, est_sub1, est_sub2, est_sub3,
       extralines = list("Sub-sample" = c("All", "May-June", "Jul.-Aug.", "Sept.")))

# You can monitor the placement of the new lines with two special characters
# at the beginning of the row name.
# 1) "^", "-" or "_" which mean the coefficients, the fixed-effects or the
# statistics section.
# 2) "^" or "_" which mean first or last line of the section
#
# Ex: starting with "_^" will place the line at the top of the stat. section
#     starting with "-_" will place the line at the bottom of the FEs section
#     etc.
#
# You can use a single character which will represent the section,
# the line would then appear at the bottom of the section.

# Examples
etable(est_c0, est_c1, est_c2, group = list("_Controls" = "poly"))
etable(est_all, est_sub1, est_sub2, est_sub3,
       extralines = list("^^Sub-sample" = c("All", "May-June", "Jul.-Aug.", "Sept.")))


#
# headers
#


# You can add header lines with 'headers'
# These lines will appear at the top of the table

# first, 3 estimations
est_header = feols(c(Ozone, Solar.R, Wind) ~  poly(Temp, 2), airquality)

# header =&gt; vector: adds a line w/t title
etable(est_header, headers = c("A", "A", "B"))

# header =&gt; list: identical way to do the previous header
# The form is: list(item1 = #item1, item2 = #item2,  etc)
etable(est_header, headers = list("A" = 2, "B" = 1))

# Adding a title +
# when an element is to be repeated only once, you can avoid the "= 1":
etable(est_header, headers = list(Group = list("A" = 2, "B")))

# To change the placement, add as first character:
# - "^" =&gt; top
# - "-" =&gt; mid (default)
# - "_" =&gt; bottom
# Note that "mid" and "top" are only distinguished when tex = TRUE

# Placing the new header line at the bottom
etable(est_header, headers = list("_Group" = c("A", "A", "B"),
                                  "^Currency" = list("US $" = 2, "CA $" = 1)))


# In Latex, you can add "grouped underlines" (cmidrule from the booktabs package)
# by adding ":_:" in the title:
etable(est_header, tex = TRUE,
       headers = list("^:_:Group" = c("A", "A", "B")))

#
# extralines and headers: .() for list()
#

# In the two arguments extralines and headers, .() can be used for list()
# For example:
etable(est_header, headers = .("^Currency" = .("US $" = 2, "CA $" = 1)))



#
# fixef.group
#

# You can group the fixed-effects line with fixef.group

est_0fe = feols(Ozone ~ Solar.R + Temp + Wind, airquality)
est_1fe = feols(Ozone ~ Solar.R + Temp + Wind | Month, airquality)
est_2fe = feols(Ozone ~ Solar.R + Temp + Wind | Month + Day, airquality)

# A) automatic way =&gt; simply use fixef.group = TRUE

etable(est_0fe, est_2fe, fixef.group = TRUE)

# Note that when grouping would lead to inconsistencies across models,
# it is avoided

etable(est_0fe, est_1fe, est_2fe, fixef.group = TRUE)

# B) customized way =&gt; use a list

etable(est_0fe, est_2fe, fixef.group = list("Dates" = "Month|Day"))

# Note that when a user grouping would lead to inconsistencies,
# the term partial replaces yes/no and the fixed-effects are not removed.

etable(est_0fe, est_1fe, est_2fe, fixef.group = list("Dates" = "Month|Day"))

# Using customized placement =&gt; as with 'group' and 'extralines',
# the user can control the placement of the new line.
# See the previous 'group' examples and the dedicated section in the help.

# On top of the coefficients:
etable(est_0fe, est_2fe, fixef.group = list("^^Dates" = "Month|Day"))

# Last line of the statistics
etable(est_0fe, est_2fe, fixef.group = list("_Dates" = "Month|Day"))



#
# Using custom functions to compute the standard errors
#

# You can use external functions to compute the VCOVs
# by feeding functions in the 'vcov' argument.
# Let's use some covariances from the sandwich package

etable(est_c0, est_c1, est_c2, vcov = sandwich::vcovHC)

# To add extra arguments to vcovHC, you need to write your wrapper:
etable(est_c0, est_c1, est_c2, vcov = function(x) sandwich::vcovHC(x, type = "HC0"))


#
# Customize which fit statistic to display
#

# You can change the fit statistics with the argument fitstat
# and you can rename them with the dictionary
etable(est1, est2, fitstat = ~ r2 + n + G)

# If you use a formula, '.' means the default:
etable(est1, est2, fitstat = ~ ll + .)


#
# Computing a different SE for each model
#

est = feols(Ozone ~ Solar.R + Wind + Temp, data = airquality)

#
# Method 1: use summary

s1 = summary(est, "iid")
s2 = summary(est, cluster = ~ Month)
s3 = summary(est, cluster = ~ Day)
s4 = summary(est, cluster = ~ Day + Month)

etable(list(s1, s2, s3, s4))

#
# Method 2: using a list in the argument 'vcov'

est_bis = feols(Ozone ~ Solar.R + Wind + Temp | Month, data = airquality)
etable(est, est_bis, vcov = list("hetero", ~ Month))

# When you have only one model, this model is replicated
# along the elements of the vcov list.
etable(est, vcov = list("hetero", ~ Month))

#
# Method 3: Using "each" or "times" in vcov

# If the first element of the list in 'vcov' is "each" or "times",
# then all models will be replicated and all the VCOVs will be
# applied to each model. The order in which they are replicated
# are governed by the each/times keywords.


# each
etable(est, est_bis, vcov = list("each", "iid", ~ Month, ~ Day))

# times
etable(est, est_bis, vcov = list("times", "iid", ~ Month, ~ Day))

#
# Notes and markup
#

# Notes can be also be set in a dictionary
# You can use markdown markup to put text into italic/bold

dict = c("note 1" = "*Notes:* This data is not really random.",
         "source 1" = "**Source:** the internet?")

est = feols(Ozone ~ csw(Solar.R, Wind, Temp), data = airquality)

etable(est, dict = dict, tex = TRUE, notes = c("note 1", "source 1"))



</code></pre>

<hr>
<h2 id='extralines_register'>Register <code>extralines</code> macros to be used in <code>etable</code></h2><span id='topic+extralines_register'></span>

<h3>Description</h3>

<p>This function is used to create <code>extralines</code> (which is an argument of <code><a href="#topic+etable">etable</a></code>) macros that can be easily summoned in <code><a href="#topic+etable">etable</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extralines_register(type, fun, alias)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extralines_register_+3A_type">type</code></td>
<td>
<p>A character scalar giving the type-name.</p>
</td></tr>
<tr><td><code id="extralines_register_+3A_fun">fun</code></td>
<td>
<p>A function to be applied to a <code>fixest</code> estimation. It must return a scalar.</p>
</td></tr>
<tr><td><code id="extralines_register_+3A_alias">alias</code></td>
<td>
<p>A character scalar. This is the alias to be used in lieu of the type name to form the row name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can register as many macros as you wish, the only constraint is that the type name should not conflict with a <code><a href="#topic+fitstat">fitstat</a></code> type name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# We register a function computing the standard-deviation of the dependent variable
my_fun = function(x) sd(model.matrix(x, type = "lhs"))
extralines_register("sdy", my_fun, "SD(y)")

# An estimation
data(iris)
est = feols(Petal.Length ~ Sepal.Length | Species, iris)

# Now we can easily create a row with the SD of y.
# We just "summon" it in a one-sided formula
etable(est, extralines = ~ sdy)

# We can change the alias on the fly:
etable(est, extralines = list("_Standard deviation of the dep. var." = ~ sdy))




</code></pre>

<hr>
<h2 id='f'>Lags a variable in a <code>fixest</code> estimation</h2><span id='topic+f'></span><span id='topic+d'></span><span id='topic+l'></span>

<h3>Description</h3>

<p>Produce lags or leads in the formulas of <code>fixest</code> estimations or when creating variables in a <code><a href="data.table.html#topic+data.table">data.table::data.table</a></code>. The data must be set as a panel beforehand (either with the function <code><a href="#topic+panel">panel</a></code> or with the argument <code>panel.id</code> in the estimation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f(x, lead = 1, fill = NA)

d(x, lag = 1, fill = NA)

l(x, lag = 1, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_+3A_x">x</code></td>
<td>
<p>The variable.</p>
</td></tr>
<tr><td><code id="f_+3A_lead">lead</code></td>
<td>
<p>A vector of integers giving the number of leads. Negative values lead to lags. This argument can be a vector when using it in fixest estimations. When creating variables in a <code><a href="data.table.html#topic+data.table">data.table::data.table</a></code>, it <strong>must</strong> be of length one.</p>
</td></tr>
<tr><td><code id="f_+3A_fill">fill</code></td>
<td>
<p>A scalar, default is <code>NA</code>. How to fill the missing values due to the lag/lead? Note that in a <code>fixest</code> estimation, 'fill' must be numeric (not required when creating new variables).</p>
</td></tr>
<tr><td><code id="f_+3A_lag">lag</code></td>
<td>
<p>A vector of integers giving the number of lags. Negative values lead to leads. This argument can be a vector when using it in fixest estimations. When creating variables in a <code><a href="data.table.html#topic+data.table">data.table::data.table</a></code>, it <strong>must</strong> be of length one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions can only be used i) in a formula of a <code>fixest</code> estimation, or ii) when creating variables within a <code>fixest_panel</code> object (obtained with function <code><a href="#topic+panel">panel</a></code>) which is alaos a <code><a href="data.table.html#topic+data.table">data.table::data.table</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f()</code>: Forwards a variable (inverse of lagging) in a <code>fixest</code> estimation
</p>
</li>
<li> <p><code>d()</code>: Creates differences (i.e. x - lag(x)) in a <code>fixest</code> estimation
</p>
</li></ul>


<h3>See Also</h3>

<p>The function <code><a href="#topic+panel">panel</a></code> changes <code>data.frames</code> into a panel from which the functions <code>l</code> and <code>f</code> can be called. Otherwise you can set the panel 'live' during the estimation using the argument <code>panel.id</code> (see for example in the function <code><a href="#topic+feols">feols</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(base_did)

# Setting a data set as a panel...
pdat = panel(base_did, ~ id + period)

# ...then using the functions l and f
est1 = feols(y ~ l(x1, 0:1), pdat)
est2 = feols(f(y) ~ l(x1, -1:1), pdat)
est3 = feols(l(y) ~ l(x1, 0:3), pdat)
etable(est1, est2, est3, order = c("f", "^x"), drop = "Int")

# or using the argument panel.id
feols(f(y) ~ l(x1, -1:1), base_did, panel.id = ~id + period)
feols(d(y) ~ d(x1), base_did, panel.id = ~id + period)

# l() and f() can also be used within a data.table:
if(require("data.table")){
  pdat_dt = panel(as.data.table(base_did), ~id+period)
  # Now since pdat_dt is also a data.table
  #   you can create lags/leads directly
  pdat_dt[, x1_l1 := l(x1)]
  pdat_dt[, x1_d1 := d(x1)]
  pdat_dt[, c("x1_l1_fill0", "y_f2") := .(l(x1, fill = 0), f(y, 2))]
}



</code></pre>

<hr>
<h2 id='fdim'>Formatted dimension</h2><span id='topic+fdim'></span>

<h3>Description</h3>

<p>Prints the dimension of a data set, in an user-readable way
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdim_+3A_x">x</code></td>
<td>
<p>An R object, usually a data.frame (but can also be a vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It does not return anything, the output is directly printed on the console.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fdim(iris)

fdim(iris$Species)



</code></pre>

<hr>
<h2 id='feglm'>Fixed-effects GLM estimations</h2><span id='topic+feglm'></span><span id='topic+feglm.fit'></span><span id='topic+fepois'></span>

<h3>Description</h3>

<p>Estimates GLM models with any number of fixed-effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feglm(
  fml,
  data,
  family = "gaussian",
  vcov,
  offset,
  weights,
  subset,
  split,
  fsplit,
  split.keep,
  split.drop,
  cluster,
  se,
  ssc,
  panel.id,
  start = NULL,
  etastart = NULL,
  mustart = NULL,
  fixef,
  fixef.rm = "perfect",
  fixef.tol = 1e-06,
  fixef.iter = 10000,
  collin.tol = 1e-10,
  glm.iter = 25,
  glm.tol = 1e-08,
  nthreads = getFixest_nthreads(),
  lean = FALSE,
  warn = TRUE,
  notes = getFixest_notes(),
  verbose = 0,
  only.coef = FALSE,
  combine.quick,
  mem.clean = FALSE,
  only.env = FALSE,
  env,
  ...
)

feglm.fit(
  y,
  X,
  fixef_df,
  family = "gaussian",
  vcov,
  offset,
  split,
  fsplit,
  split.keep,
  split.drop,
  cluster,
  se,
  ssc,
  weights,
  subset,
  start = NULL,
  etastart = NULL,
  mustart = NULL,
  fixef.rm = "perfect",
  fixef.tol = 1e-06,
  fixef.iter = 10000,
  collin.tol = 1e-10,
  glm.iter = 25,
  glm.tol = 1e-08,
  nthreads = getFixest_nthreads(),
  lean = FALSE,
  warn = TRUE,
  notes = getFixest_notes(),
  mem.clean = FALSE,
  verbose = 0,
  only.env = FALSE,
  only.coef = FALSE,
  env,
  ...
)

fepois(
  fml,
  data,
  vcov,
  offset,
  weights,
  subset,
  split,
  fsplit,
  split.keep,
  split.drop,
  cluster,
  se,
  ssc,
  panel.id,
  start = NULL,
  etastart = NULL,
  mustart = NULL,
  fixef,
  fixef.rm = "perfect",
  fixef.tol = 1e-06,
  fixef.iter = 10000,
  collin.tol = 1e-10,
  glm.iter = 25,
  glm.tol = 1e-08,
  nthreads = getFixest_nthreads(),
  lean = FALSE,
  warn = TRUE,
  notes = getFixest_notes(),
  verbose = 0,
  combine.quick,
  mem.clean = FALSE,
  only.env = FALSE,
  only.coef = FALSE,
  env,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feglm_+3A_fml">fml</code></td>
<td>
<p>A formula representing the relation to be estimated. For example: <code>fml = z~x+y</code>. To include fixed-effects, insert them in this formula using a pipe: e.g. <code>fml = z~x+y|fixef_1+fixef_2</code>. Multiple estimations can be performed at once: for multiple dep. vars, wrap them in <code>c()</code>: ex <code>c(y1, y2)</code>. For multiple indep. vars, use the stepwise functions: ex <code>x1 + csw(x2, x3)</code>. The formula <code>fml = c(y1, y2) ~ x1 + cw0(x2, x3)</code> leads to 6 estimation, see details. Square brackets starting with a dot can be used to call global variables: <code>y.[i] ~ x.[1:2]</code> will lead to <code>y3 ~ x1 + x2</code> if <code>i</code> is equal to 3 in the current environment (see details in <code><a href="#topic+xpd">xpd</a></code>).</p>
</td></tr>
<tr><td><code id="feglm_+3A_data">data</code></td>
<td>
<p>A data.frame containing the necessary variables to run the model. The variables of the non-linear right hand side of the formula are identified with this <code>data.frame</code> names. Can also be a matrix.</p>
</td></tr>
<tr><td><code id="feglm_+3A_family">family</code></td>
<td>
<p>Family to be used for the estimation. Defaults to <code>gaussian()</code>. See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.</p>
</td></tr>
<tr><td><code id="feglm_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="feglm_+3A_offset">offset</code></td>
<td>
<p>A formula or a numeric vector. An offset can be added to the estimation. If equal to a formula, it should be of the form (for example) <code>~0.5*x**2</code>. This offset is linearly added to the elements of the main formula 'fml'.</p>
</td></tr>
<tr><td><code id="feglm_+3A_weights">weights</code></td>
<td>
<p>A formula or a numeric vector. Each observation can be weighted, the weights must be greater than 0. If equal to a formula, it should be one-sided: for example <code>~ var_weight</code>.</p>
</td></tr>
<tr><td><code id="feglm_+3A_subset">subset</code></td>
<td>
<p>A vector (logical or numeric) or a one-sided formula. If provided, then the estimation will be performed only on the observations defined by this argument.</p>
</td></tr>
<tr><td><code id="feglm_+3A_split">split</code></td>
<td>
<p>A one sided formula representing a variable (eg <code>split = ~var</code>) or a vector. If provided, the sample is split according to the variable and one estimation is performed for each value of that variable. If you also want to include the estimation for the full sample, use the argument <code>fsplit</code> instead. You can use the special operators <code style="white-space: pre;">&#8288;%keep%&#8288;</code> and <code style="white-space: pre;">&#8288;%drop%&#8288;</code> to select only a subset of values for which to split the sample. E.g. <code>split = ~var %keep% c("v1", "v2")</code> will split the sample only according to the values <code>v1</code> and <code>v2</code> of the variable <code>var</code>; it is equivalent to supplying the argument <code>split.keep = c("v1", "v2")</code>. By default there is partial matching on each value, you can trigger a regular expression evaluation by adding a <code>'@'</code> first, as in: <code>~var %drop% "@^v[12]"</code> which will drop values starting with <code>"v1"</code> or <code>"v2"</code> (of course you need to know regexes!).</p>
</td></tr>
<tr><td><code id="feglm_+3A_fsplit">fsplit</code></td>
<td>
<p>A one sided formula representing a variable (eg <code>split = ~var</code>) or a vector. If provided, the sample is split according to the variable and one estimation is performed for each value of that variable. This argument is the same as split but also includes the full sample as the first estimation. You can use the special operators <code style="white-space: pre;">&#8288;%keep%&#8288;</code> and <code style="white-space: pre;">&#8288;%drop%&#8288;</code> to select only a subset of values for which to split the sample. E.g. <code>split = ~var %keep% c("v1", "v2")</code> will split the sample only according to the values <code>v1</code> and <code>v2</code> of the variable <code>var</code>; it is equivalent to supplying the argument <code>split.keep = c("v1", "v2")</code>. By default there is partial matching on each value, you can trigger a regular expression evaluation by adding an <code>'@'</code> first, as in: <code>~var %drop% "@^v[12]"</code> which will drop values starting with <code>"v1"</code> or <code>"v2"</code> (of course you need to know regexes!).</p>
</td></tr>
<tr><td><code id="feglm_+3A_split.keep">split.keep</code></td>
<td>
<p>A character vector. Only used when <code>split</code>, or <code>fsplit</code>, is supplied. If provided, then the sample will be split only on the values of <code>split.keep</code>. The values in <code>split.keep</code> will be partially matched to the values of <code>split</code>. To enable regular expressions, you need to add an <code>'@'</code> first. For example <code>split.keep = c("v1", "@other|var")</code> will keep only the value in <code>split</code> partially matched by <code>"v1"</code> or the values containing <code>"other"</code> or <code>"var"</code>.</p>
</td></tr>
<tr><td><code id="feglm_+3A_split.drop">split.drop</code></td>
<td>
<p>A character vector. Only used when <code>split</code>, or <code>fsplit</code>, is supplied. If provided, then the sample will be split only on the values that are not in <code>split.drop</code>. The values in <code>split.drop</code> will be partially matched to the values of <code>split</code>. To enable regular expressions, you need to add an <code>'@'</code> first. For example <code>split.drop = c("v1", "@other|var")</code> will drop only the value in <code>split</code> partially matched by <code>"v1"</code> or the values containing <code>"other"</code> or <code>"var"</code>.</p>
</td></tr>
<tr><td><code id="feglm_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="feglm_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="feglm_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="feglm_+3A_panel.id">panel.id</code></td>
<td>
<p>The panel identifiers. Can either be: i) a one sided formula (e.g. <code>panel.id = ~id+time</code>), ii) a character vector of length 2 (e.g. <code>panel.id=c('id', 'time')</code>, or iii) a character scalar of two variables separated by a comma (e.g. <code>panel.id='id,time'</code>). Note that you can combine variables with <code>^</code> only inside formulas (see the dedicated section in <code><a href="#topic+feols">feols</a></code>).</p>
</td></tr>
<tr><td><code id="feglm_+3A_start">start</code></td>
<td>
<p>Starting values for the coefficients. Can be: i) a numeric of length 1 (e.g. <code>start = 0</code>), ii) a numeric vector of the exact same length as the number of variables, or iii) a named vector of any length (the names will be used to initialize the appropriate coefficients). Default is missing.</p>
</td></tr>
<tr><td><code id="feglm_+3A_etastart">etastart</code></td>
<td>
<p>Numeric vector of the same length as the data. Starting values for the linear predictor. Default is missing.</p>
</td></tr>
<tr><td><code id="feglm_+3A_mustart">mustart</code></td>
<td>
<p>Numeric vector of the same length as the data. Starting values for the vector of means. Default is missing.</p>
</td></tr>
<tr><td><code id="feglm_+3A_fixef">fixef</code></td>
<td>
<p>Character vector. The names of variables to be used as fixed-effects. These variables should contain the identifier of each observation (e.g., think of it as a panel identifier). Note that the recommended way to include fixed-effects is to insert them directly in the formula.</p>
</td></tr>
<tr><td><code id="feglm_+3A_fixef.rm">fixef.rm</code></td>
<td>
<p>Can be equal to &quot;perfect&quot; (default), &quot;singleton&quot;, &quot;both&quot; or &quot;none&quot;. Controls which observations are to be removed. If &quot;perfect&quot;, then observations having a fixed-effect with perfect fit (e.g. only 0 outcomes in Poisson estimations) will be removed. If &quot;singleton&quot;, all observations for which a fixed-effect appears only once will be removed. The meaning of &quot;both&quot; and &quot;none&quot; is direct.</p>
</td></tr>
<tr><td><code id="feglm_+3A_fixef.tol">fixef.tol</code></td>
<td>
<p>Precision used to obtain the fixed-effects. Defaults to <code>1e-6</code>. It corresponds to the maximum absolute difference allowed between two coefficients of successive iterations.</p>
</td></tr>
<tr><td><code id="feglm_+3A_fixef.iter">fixef.iter</code></td>
<td>
<p>Maximum number of iterations in fixed-effects algorithm (only in use for 2+ fixed-effects). Default is 10000.</p>
</td></tr>
<tr><td><code id="feglm_+3A_collin.tol">collin.tol</code></td>
<td>
<p>Numeric scalar, default is <code>1e-10</code>. Threshold deciding when variables should be considered collinear and subsequently removed from the estimation. Higher values means more variables will be removed (if there is presence of collinearity). One signal of presence of collinearity is t-stats that are extremely low (for instance when t-stats &lt; 1e-3).</p>
</td></tr>
<tr><td><code id="feglm_+3A_glm.iter">glm.iter</code></td>
<td>
<p>Number of iterations of the glm algorithm. Default is 25.</p>
</td></tr>
<tr><td><code id="feglm_+3A_glm.tol">glm.tol</code></td>
<td>
<p>Tolerance level for the glm algorithm. Default is <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="feglm_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than, or equal to, the maximum number of threads; b) 0: meaning all available threads will be used; c) a number strictly between 0 and 1 which represents the fraction of all threads to use. The default is to use 50% of all threads. You can set permanently the number of threads used within this package using the function <code><a href="#topic+setFixest_nthreads">setFixest_nthreads</a></code>.</p>
</td></tr>
<tr><td><code id="feglm_+3A_lean">lean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> then all large objects are removed from the returned result: this will save memory but will block the possibility to use many methods. It is recommended to use the arguments <code>se</code> or <code>cluster</code> to obtain the appropriate standard-errors at estimation time, since obtaining different SEs won't be possible afterwards.</p>
</td></tr>
<tr><td><code id="feglm_+3A_warn">warn</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether warnings should be displayed (concerns warnings relating to convergence state).</p>
</td></tr>
<tr><td><code id="feglm_+3A_notes">notes</code></td>
<td>
<p>Logical. By default, three notes are displayed: when NAs are removed, when some fixed-effects are removed because of only 0 (or 0/1) outcomes, or when a variable is dropped because of collinearity. To avoid displaying these messages, you can set <code>notes = FALSE</code>. You can remove these messages permanently by using <code>setFixest_notes(FALSE)</code>.</p>
</td></tr>
<tr><td><code id="feglm_+3A_verbose">verbose</code></td>
<td>
<p>Integer. Higher values give more information. In particular, it can detail the number of iterations in the demeaning algoritmh (the first number is the left-hand-side, the other numbers are the right-hand-side variables). It can also detail the step-halving algorithm.</p>
</td></tr>
<tr><td><code id="feglm_+3A_only.coef">only.coef</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then only the estimated coefficients are returned. Note that the length of the vector returned is always the length of the number of coefficients to be estimated: this means that the variables found to be collinear are returned with an NA value.</p>
</td></tr>
<tr><td><code id="feglm_+3A_combine.quick">combine.quick</code></td>
<td>
<p>Logical. When you combine different variables to transform them into a single fixed-effects you can do e.g. <code>y ~ x | paste(var1, var2)</code>. The algorithm provides a shorthand to do the same operation: <code>y ~ x | var1^var2</code>. Because pasting variables is a costly operation, the internal algorithm may use a numerical trick to hasten the process. The cost of doing so is that you lose the labels. If you are interested in getting the value of the fixed-effects coefficients after the estimation, you should use <code>combine.quick = FALSE</code>. By default it is equal to <code>FALSE</code> if the number of observations is lower than 50,000, and to <code>TRUE</code> otherwise.</p>
</td></tr>
<tr><td><code id="feglm_+3A_mem.clean">mem.clean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only to be used if the data set is large compared to the available RAM. If <code>TRUE</code> then intermediary objects are removed as much as possible and <code><a href="base.html#topic+gc">gc</a></code> is run before each substantial C++ section in the internal code to avoid memory issues.</p>
</td></tr>
<tr><td><code id="feglm_+3A_only.env">only.env</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then only the environment used to make the estimation is returned.</p>
</td></tr>
<tr><td><code id="feglm_+3A_env">env</code></td>
<td>
<p>(Advanced users.) A <code>fixest</code> environment created by a <code>fixest</code> estimation with <code>only.env = TRUE</code>. Default is missing. If provided, the data from this environment will be used to perform the estimation.</p>
</td></tr>
<tr><td><code id="feglm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="feglm_+3A_y">y</code></td>
<td>
<p>Numeric vector/matrix/data.frame of the dependent variable(s). Multiple dependent variables will return a <code>fixest_multi</code> object.</p>
</td></tr>
<tr><td><code id="feglm_+3A_x">X</code></td>
<td>
<p>Numeric matrix of the regressors.</p>
</td></tr>
<tr><td><code id="feglm_+3A_fixef_df">fixef_df</code></td>
<td>
<p>Matrix/data.frame of the fixed-effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The core of the GLM are the weighted OLS estimations. These estimations are performed with <code><a href="#topic+feols">feols</a></code>. The method used to demean each variable along the fixed-effects is based on Berge (2018), since this is the same problem to solve as for the Gaussian case in a ML setup.
</p>


<h3>Value</h3>

<p>A <code>fixest</code> object. Note that <code>fixest</code> objects contain many elements and most of them are for internal use, they are presented here only for information. To access them, it is safer to use the user-level methods (e.g. <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>, <code><a href="#topic+resid.fixest">resid.fixest</a></code>, etc) or functions (like for instance <code><a href="#topic+fitstat">fitstat</a></code> to access any fit statistic).
</p>
<table>
<tr><td><code>nobs</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code>fml</code></td>
<td>
<p>The linear formula of the call.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used to estimate the model.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The family used to estimate the model.</p>
</td></tr>
<tr><td><code>fml_all</code></td>
<td>
<p>A list containing different parts of the formula. Always contain the linear formula. Then, if relevant: <code>fixef</code>: the fixed-effects.</p>
</td></tr>
<tr><td><code>nparams</code></td>
<td>
<p>The number of parameters of the model.</p>
</td></tr>
<tr><td><code>fixef_vars</code></td>
<td>
<p>The names of each fixed-effect dimension.</p>
</td></tr>
<tr><td><code>fixef_id</code></td>
<td>
<p>The list (of length the number of fixed-effects) of the fixed-effects identifiers for each observation.</p>
</td></tr>
<tr><td><code>fixef_sizes</code></td>
<td>
<p>The size of each fixed-effect (i.e. the number of unique identifierfor each fixed-effect dimension).</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>(When relevant.) The dependent variable (used to compute the within-R2 when fixed-effects are present).</p>
</td></tr>
<tr><td><code>convStatus</code></td>
<td>
<p>Logical, convergence status of the IRWLS algorithm.</p>
</td></tr>
<tr><td><code>irls_weights</code></td>
<td>
<p>The weights of the last iteration of the IRWLS algorithm.</p>
</td></tr>
<tr><td><code>obs_selection</code></td>
<td>
<p>(When relevant.) List containing vectors of integers. It represents the sequential selection of observation vis a vis the original data set.</p>
</td></tr>
<tr><td><code>fixef_removed</code></td>
<td>
<p>(When relevant.) In the case there were fixed-effects and some observations were removed because of only 0/1 outcome within a fixed-effect, it gives the list (for each fixed-effect dimension) of the fixed-effect identifiers that were removed.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>The named vector of estimated coefficients.</p>
</td></tr>
<tr><td><code>coeftable</code></td>
<td>
<p>The table of the coefficients with their standard errors, z-values and p-values.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The loglikelihood.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the fitted model.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of iterations of the algorithm.</p>
</td></tr>
<tr><td><code>ll_null</code></td>
<td>
<p>Log-likelihood of the null model (i.e. with the intercept only).</p>
</td></tr>
<tr><td><code>ssr_null</code></td>
<td>
<p>Sum of the squared residuals of the null model (containing only with the intercept).</p>
</td></tr>
<tr><td><code>pseudo_r2</code></td>
<td>
<p>The adjusted pseudo R2.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values are the expected value of the dependent variable for the fitted model: that is <code class="reqn">E(Y|X)</code>.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>The linear predictors.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The residuals (y minus the fitted values).</p>
</td></tr>
<tr><td><code>sq.cor</code></td>
<td>
<p>Squared correlation between the dependent variable and the expected predictor (i.e. fitted.values) obtained by the estimation.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian of the parameters.</p>
</td></tr>
<tr><td><code>cov.iid</code></td>
<td>
<p>The variance-covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The standard-error of the parameters.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>The matrix of the scores (first derivative for each observation).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The difference between the dependent variable and the expected predictor.</p>
</td></tr>
<tr><td><code>sumFE</code></td>
<td>
<p>The sum of the fixed-effects coefficients for each observation.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>(When relevant.) The offset formula.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>(When relevant.) The weights formula.</p>
</td></tr>
<tr><td><code>collin.var</code></td>
<td>
<p>(When relevant.) Vector containing the variables removed because of collinearity.</p>
</td></tr>
<tr><td><code>collin.coef</code></td>
<td>
<p>(When relevant.) Vector of coefficients, where the values of the variables removed because of collinearity are NA.</p>
</td></tr>
</table>


<h3>Combining the fixed-effects</h3>

<p>You can combine two variables to make it a new fixed-effect using <code>^</code>. The syntax is as follows: <code>fe_1^fe_2</code>. Here you created a new variable which is the combination of the two variables fe_1 and fe_2. This is identical to doing <code>paste0(fe_1, "_", fe_2)</code> but more convenient.
</p>
<p>Note that pasting is a costly operation, especially for large data sets. Thus, the internal algorithm uses a numerical trick which is fast, but the drawback is that the identity of each observation is lost (i.e. they are now equal to a meaningless number instead of being equal to <code>paste0(fe_1, "_", fe_2)</code>). These &ldquo;identities&rdquo; are useful only if you're interested in the value of the fixed-effects (that you can extract with <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>). If you're only interested in coefficients of the variables, it doesn't matter. Anyway, you can use <code>combine.quick = FALSE</code> to tell the internal algorithm to use <code>paste</code> instead of the numerical trick. By default, the numerical trick is performed only for large data sets.
</p>


<h3>Varying slopes</h3>

<p>You can add variables with varying slopes in the fixed-effect part of the formula. The syntax is as follows: <code>fixef_var[var1, var2]</code>. Here the variables var1 and var2 will be with varying slopes (one slope per value in fixef_var) and the fixed-effect fixef_var will also be added.
</p>
<p>To add only the variables with varying slopes and not the fixed-effect, use double square brackets: <code>fixef_var[[var1, var2]]</code>.
</p>
<p>In other words:
</p>

<ul>
<li> <p><code>fixef_var[var1, var2]</code> is equivalent to <code>fixef_var + fixef_var[[var1]] + fixef_var[[var2]]</code>
</p>
</li>
<li> <p><code>fixef_var[[var1, var2]]</code> is equivalent to <code>fixef_var[[var1]] + fixef_var[[var2]]</code>
</p>
</li></ul>

<p>In general, for convergence reasons, it is recommended to always add the fixed-effect and avoid using only the variable with varying slope (i.e. use single square brackets).
</p>


<h3>Lagging variables</h3>

<p>To use leads/lags of variables in the estimation, you can: i) either provide the argument <code>panel.id</code>, ii) either set your data set as a panel with the function <code><a href="#topic+panel">panel</a></code>, <code><a href="#topic+l">f</a></code> and <code><a href="#topic+l">d</a></code>.
</p>
<p>You can provide several leads/lags/differences at once: e.g. if your formula is equal to <code>f(y) ~ l(x, -1:1)</code>, it means that the dependent variable is equal to the lead of <code>y</code>, and you will have as explanatory variables the lead of <code>x1</code>, <code>x1</code> and the lag of <code>x1</code>. See the examples in function <code><a href="#topic+l">l</a></code> for more details.
</p>


<h3>Interactions</h3>

<p>You can interact a numeric variable with a &quot;factor-like&quot; variable by using <code>i(factor_var, continuous_var, ref)</code>, where <code>continuous_var</code> will be interacted with each value of <code>factor_var</code> and the argument <code>ref</code> is a value of <code>factor_var</code> taken as a reference (optional).
</p>
<p>Using this specific way to create interactions leads to a different display of the interacted values in <code><a href="#topic+etable">etable</a></code>. See examples.
</p>
<p>It is important to note that <em>if you do not care about the standard-errors of the interactions</em>, then you can add interactions in the fixed-effects part of the formula, it will be incomparably faster (using the syntax <code>factor_var[continuous_var]</code>, as explained in the section &ldquo;Varying slopes&rdquo;).
</p>
<p>The function <code><a href="#topic+i">i</a></code> has in fact more arguments, please see details in its associated help page.
</p>


<h3>On standard-errors</h3>

<p>Standard-errors can be computed in different ways, you can use the arguments <code>se</code> and <code>ssc</code> in <code><a href="#topic+summary.fixest">summary.fixest</a></code> to define how to compute them. By default, in the presence of fixed-effects, standard-errors are automatically clustered.
</p>
<p>The following vignette: <a href="https://lrberge.github.io/fixest/articles/standard_errors.html">On standard-errors</a> describes in details how the standard-errors are computed in <code>fixest</code> and how you can replicate standard-errors from other software.
</p>
<p>You can use the functions <code><a href="#topic+setFixest_vcov">setFixest_vcov</a></code> and <code><a href="#topic+ssc">setFixest_ssc</a></code> to permanently set the way the standard-errors are computed.
</p>


<h3>Multiple estimations</h3>

<p>Multiple estimations can be performed at once, they just have to be specified in the formula. Multiple estimations yield a <code>fixest_multi</code> object which is &lsquo;kind of&rsquo; a list of all the results but includes specific methods to access the results in a handy way. Please have a look at the dedicated vignette: <a href="https://lrberge.github.io/fixest/articles/multiple_estimations.html">Multiple estimations</a>.
</p>
<p>To include multiple dependent variables, wrap them in <code>c()</code> (<code>list()</code> also works). For instance <code>fml = c(y1, y2) ~ x1</code> would estimate the model <code>fml = y1 ~ x1</code> and then the model <code>fml = y2 ~ x1</code>.
</p>
<p>To include multiple independent variables, you need to use the stepwise functions. There are 4 stepwise functions: <code>sw</code>, <code>sw0</code>, <code>csw</code>, <code>csw0</code>, and <code>mvsw</code>. Of course <code>sw</code> stands for stepwise, and <code>csw</code> for cumulative stepwise. Finally <code>mvsw</code> is a bit special, it stands for multiverse stepwise. Let's explain that.
Assume you have the following formula: <code>fml = y ~ x1 + sw(x2, x3)</code>. The stepwise function <code>sw</code> will estimate the following two models: <code>y ~ x1 + x2</code> and <code>y ~ x1 + x3</code>. That is, each element in <code>sw()</code> is sequentially, and separately, added to the formula. Would have you used <code>sw0</code> in lieu of <code>sw</code>, then the model <code>y ~ x1</code> would also have been estimated. The <code>0</code> in the name means that the model without any stepwise element also needs to be estimated.
The prefix <code>c</code> means cumulative: each stepwise element is added to the next. That is, <code>fml = y ~ x1 + csw(x2, x3)</code> would lead to the following models <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>. The <code>0</code> has the same meaning and would also lead to the model without the stepwise elements to be estimated: in other words, <code>fml = y ~ x1 + csw0(x2, x3)</code> leads to the following three models: <code>y ~ x1</code>, <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>.
Finally <code>mvsw</code> will add, in a stepwise fashion all possible combinations of the variables in its arguments. For example <code>mvsw(x1, x2, x3)</code> is equivalent to <code>sw0(x1, x2, x3, x1 + x2, x1 + x3, x2 + x3, x1 + x2 + x3)</code>. The number of models to estimate grows at a factorial rate: so be cautious!
</p>
<p>Multiple independent variables can be combined with multiple dependent variables, as in <code>fml = c(y1, y2) ~ cw(x1, x2, x3)</code> which would lead to 6 estimations. Multiple estimations can also be combined to split samples (with the arguments <code>split</code>, <code>fsplit</code>).
</p>
<p>You can also add fixed-effects in a stepwise fashion. Note that you cannot perform stepwise estimations on the IV part of the formula (<code>feols</code> only).
</p>
<p>If NAs are present in the sample, to avoid too many messages, only NA removal concerning the variables common to all estimations is reported.
</p>
<p>A note on performance. The feature of multiple estimations has been highly optimized for <code>feols</code>, in particular in the presence of fixed-effects. It is faster to estimate multiple models using the formula rather than with a loop. For non-<code>feols</code> models using the formula is roughly similar to using a loop performance-wise.
</p>


<h3>Argument sliding</h3>

<p>When the data set has been set up globally using <code><a href="#topic+setFixest_estimation">setFixest_estimation</a></code><code>(data = data_set)</code>, the argument <code>vcov</code> can be used implicitly. This means that calls such as <code>feols(y ~ x, "HC1")</code>, or <code>feols(y ~ x, ~id)</code>, are valid: i) the data is automatically deduced from the global settings, and ii) the <code>vcov</code> is deduced to be the second argument.
</p>


<h3>Piping</h3>

<p>Although the argument 'data' is placed in second position, the data can be piped to the estimation functions. For example, with R &gt;= 4.1, <code>mtcars |&gt; feols(mpg ~ cyl)</code> works as <code>feols(mpg ~ cyl, mtcars)</code>.
</p>


<h3>Tricks to estimate multiple LHS</h3>

<p>To use multiple dependent variables in <code>fixest</code> estimations, you need to include them in a vector: like in <code>c(y1, y2, y3)</code>.
</p>
<p>First, if names are stored in a vector, they can readily be inserted in a formula to perform multiple estimations using the dot square bracket operator. For instance if <code>my_lhs = c("y1", "y2")</code>, calling <code>fixest</code> with, say <code>feols(.[my_lhs] ~ x1, etc)</code> is equivalent to using <code>feols(c(y1, y2) ~ x1, etc)</code>. Beware that this is a special feature unique to the <em>left-hand-side</em> of <code>fixest</code> estimations (the default behavior of the DSB operator is to aggregate with sums, see <code><a href="#topic+xpd">xpd</a></code>).
</p>
<p>Second, you can use a regular expression to grep the left-hand-sides on the fly. When the <code>..("regex")</code> feature is used naked on the LHS, the variables grepped are inserted into <code>c()</code>. For example <code style="white-space: pre;">&#8288;..("Pe") ~ Sepal.Length, iris&#8288;</code> is equivalent to <code style="white-space: pre;">&#8288;c(Petal.Length, Petal.Width) ~ Sepal.Length, iris&#8288;</code>. Beware that this is a special feature unique to the <em>left-hand-side</em> of <code>fixest</code> estimations (the default behavior of <code>..("regex")</code> is to aggregate with sums, see <code><a href="#topic+xpd">xpd</a></code>).
</p>


<h3>Dot square bracket operator in formulas</h3>

<p>In a formula, the dot square bracket (DSB) operator can: i) create manifold variables at once, or ii) capture values from the current environment and put them verbatim in the formula.
</p>
<p>Say you want to include the variables <code>x1</code> to <code>x3</code> in your formula. You can use <code>xpd(y ~ x.[1:3])</code> and you'll get <code>y ~ x1 + x2 + x3</code>.
</p>
<p>To summon values from the environment, simply put the variable in square brackets. For example: <code>for(i in 1:3) xpd(y.[i] ~ x)</code> will create the formulas <code>y1 ~ x</code> to <code>y3 ~ x</code> depending on the value of <code>i</code>.
</p>
<p>You can include a full variable from the environment in the same way: <code>for(y in c("a", "b")) xpd(.[y] ~ x)</code> will create the two formulas <code>a ~ x</code> and <code>b ~ x</code>.
</p>
<p>The DSB can even be used within variable names, but then the variable must be nested in character form. For example <code>y ~ .["x.[1:2]_sq"]</code> will create <code>y ~ x1_sq + x2_sq</code>. Using the character form is important to avoid a formula parsing error. Double quotes must be used. Note that the character string that is nested will be parsed with the function <code><a href="#topic+dsb">dsb</a></code>, and thus it will return a vector.
</p>
<p>By default, the DSB operator expands vectors into sums. You can add a comma, like in <code>.[, x]</code>, to expand with commas&ndash;the content can then be used within functions. For instance: <code>c(x.[, 1:2])</code> will create <code>c(x1, x2)</code> (and <em>not</em> <code>c(x1 + x2)</code>).
</p>
<p>In all <code>fixest</code> estimations, this special parsing is enabled, so you don't need to use <code>xpd</code>.
</p>
<p>One-sided formulas can be expanded with the DSB operator: let <code>x = ~sepal + petal</code>, then <code>xpd(y ~ .[x])</code> leads to <code>color ~ sepal + petal</code>.
</p>
<p>You can even use multiple square brackets within a single variable, but then the use of nesting is required. For example, the following <code>xpd(y ~ .[".[letters[1:2]]_.[1:2]"])</code> will create <code>y ~ a_1 + b_2</code>. Remember that the nested character string is parsed with <code><a href="#topic+dsb">dsb</a></code>, which explains this behavior.
</p>
<p>When the element to be expanded i) is equal to the empty string or, ii) is of length 0, it is replaced with a neutral element, namely <code>1</code>. For example, <code style="white-space: pre;">&#8288;x = "" ; xpd(y ~ .[x])&#8288;</code> leads to <code>y ~ 1</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>References</h3>

<p>Berge, Laurent, 2018, &quot;Efficient estimation of maximum likelihood models with multiple fixed-effects: the R package FENmlm.&quot; CREA Discussion Papers, 13 (<a href="https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf"></a>).
</p>
<p>For models with multiple fixed-effects:
</p>
<p>Gaure, Simen, 2013, &quot;OLS with multiple high dimensional category variables&quot;, Computational Statistics &amp; Data Analysis 66 pp. 8&ndash;18
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+summary.fixest">summary.fixest</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> to extract the fixed-effects coefficients, and the function <code><a href="#topic+etable">etable</a></code> to visualize the results of multiple estimations.
And other estimation methods: <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+fenegbin">fenegbin</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Poisson estimation
res = feglm(Sepal.Length ~ Sepal.Width + Petal.Length | Species, iris, "poisson")

# You could also use fepois
res_pois = fepois(Sepal.Length ~ Sepal.Width + Petal.Length | Species, iris)

# With the fit method:
res_fit = feglm.fit(iris$Sepal.Length, iris[, 2:3], iris$Species, "poisson")

# All results are identical:
etable(res, res_pois, res_fit)

# Note that you have many more examples in feols

#
# Multiple estimations:
#

# 6 estimations
est_mult = fepois(c(Ozone, Solar.R) ~ Wind + Temp + csw0(Wind:Temp, Day), airquality)

# We can display the results for the first lhs:
etable(est_mult[lhs = 1])

# And now the second (access can be made by name)
etable(est_mult[lhs = "Solar.R"])

# Now we focus on the two last right hand sides
# (note that .N can be used to specify the last item)
etable(est_mult[rhs = 2:.N])

# Combining with split
est_split = fepois(c(Ozone, Solar.R) ~ sw(poly(Wind, 2), poly(Temp, 2)),
                  airquality, split = ~ Month)

# You can display everything at once with the print method
est_split

# Different way of displaying the results with "compact"
summary(est_split, "compact")

# You can still select which sample/LHS/RHS to display
est_split[sample = 1:2, lhs = 1, rhs = 1]


</code></pre>

<hr>
<h2 id='femlm'>Fixed-effects maximum likelihood models</h2><span id='topic+femlm'></span><span id='topic+fenegbin'></span>

<h3>Description</h3>

<p>This function estimates maximum likelihood models with any number of fixed-effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>femlm(
  fml,
  data,
  family = c("poisson", "negbin", "logit", "gaussian"),
  vcov,
  start = 0,
  fixef,
  fixef.rm = "perfect",
  offset,
  subset,
  split,
  fsplit,
  split.keep,
  split.drop,
  cluster,
  se,
  ssc,
  panel.id,
  fixef.tol = 1e-05,
  fixef.iter = 10000,
  nthreads = getFixest_nthreads(),
  lean = FALSE,
  verbose = 0,
  warn = TRUE,
  notes = getFixest_notes(),
  theta.init,
  combine.quick,
  mem.clean = FALSE,
  only.env = FALSE,
  only.coef = FALSE,
  env,
  ...
)

fenegbin(
  fml,
  data,
  vcov,
  theta.init,
  start = 0,
  fixef,
  fixef.rm = "perfect",
  offset,
  subset,
  split,
  fsplit,
  split.keep,
  split.drop,
  cluster,
  se,
  ssc,
  panel.id,
  fixef.tol = 1e-05,
  fixef.iter = 10000,
  nthreads = getFixest_nthreads(),
  lean = FALSE,
  verbose = 0,
  warn = TRUE,
  notes = getFixest_notes(),
  combine.quick,
  mem.clean = FALSE,
  only.env = FALSE,
  only.coef = FALSE,
  env,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="femlm_+3A_fml">fml</code></td>
<td>
<p>A formula representing the relation to be estimated. For example: <code>fml = z~x+y</code>. To include fixed-effects, insert them in this formula using a pipe: e.g. <code>fml = z~x+y|fixef_1+fixef_2</code>. Multiple estimations can be performed at once: for multiple dep. vars, wrap them in <code>c()</code>: ex <code>c(y1, y2)</code>. For multiple indep. vars, use the stepwise functions: ex <code>x1 + csw(x2, x3)</code>. The formula <code>fml = c(y1, y2) ~ x1 + cw0(x2, x3)</code> leads to 6 estimation, see details. Square brackets starting with a dot can be used to call global variables: <code>y.[i] ~ x.[1:2]</code> will lead to <code>y3 ~ x1 + x2</code> if <code>i</code> is equal to 3 in the current environment (see details in <code><a href="#topic+xpd">xpd</a></code>).</p>
</td></tr>
<tr><td><code id="femlm_+3A_data">data</code></td>
<td>
<p>A data.frame containing the necessary variables to run the model. The variables of the non-linear right hand side of the formula are identified with this <code>data.frame</code> names. Can also be a matrix.</p>
</td></tr>
<tr><td><code id="femlm_+3A_family">family</code></td>
<td>
<p>Character scalar. It should provide the family. The possible values are &quot;poisson&quot; (Poisson model with log-link, the default), &quot;negbin&quot; (Negative Binomial model with log-link), &quot;logit&quot; (LOGIT model with log-link), &quot;gaussian&quot; (Gaussian model).</p>
</td></tr>
<tr><td><code id="femlm_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_start">start</code></td>
<td>
<p>Starting values for the coefficients. Can be: i) a numeric of length 1 (e.g. <code>start = 0</code>, the default), ii) a numeric vector of the exact same length as the number of variables, or iii) a named vector of any length (the names will be used to initialize the appropriate coefficients).</p>
</td></tr>
<tr><td><code id="femlm_+3A_fixef">fixef</code></td>
<td>
<p>Character vector. The names of variables to be used as fixed-effects. These variables should contain the identifier of each observation (e.g., think of it as a panel identifier). Note that the recommended way to include fixed-effects is to insert them directly in the formula.</p>
</td></tr>
<tr><td><code id="femlm_+3A_fixef.rm">fixef.rm</code></td>
<td>
<p>Can be equal to &quot;perfect&quot; (default), &quot;singleton&quot;, &quot;both&quot; or &quot;none&quot;. Controls which observations are to be removed. If &quot;perfect&quot;, then observations having a fixed-effect with perfect fit (e.g. only 0 outcomes in Poisson estimations) will be removed. If &quot;singleton&quot;, all observations for which a fixed-effect appears only once will be removed. The meaning of &quot;both&quot; and &quot;none&quot; is direct.</p>
</td></tr>
<tr><td><code id="femlm_+3A_offset">offset</code></td>
<td>
<p>A formula or a numeric vector. An offset can be added to the estimation. If equal to a formula, it should be of the form (for example) <code>~0.5*x**2</code>. This offset is linearly added to the elements of the main formula 'fml'.</p>
</td></tr>
<tr><td><code id="femlm_+3A_subset">subset</code></td>
<td>
<p>A vector (logical or numeric) or a one-sided formula. If provided, then the estimation will be performed only on the observations defined by this argument.</p>
</td></tr>
<tr><td><code id="femlm_+3A_split">split</code></td>
<td>
<p>A one sided formula representing a variable (eg <code>split = ~var</code>) or a vector. If provided, the sample is split according to the variable and one estimation is performed for each value of that variable. If you also want to include the estimation for the full sample, use the argument <code>fsplit</code> instead. You can use the special operators <code style="white-space: pre;">&#8288;%keep%&#8288;</code> and <code style="white-space: pre;">&#8288;%drop%&#8288;</code> to select only a subset of values for which to split the sample. E.g. <code>split = ~var %keep% c("v1", "v2")</code> will split the sample only according to the values <code>v1</code> and <code>v2</code> of the variable <code>var</code>; it is equivalent to supplying the argument <code>split.keep = c("v1", "v2")</code>. By default there is partial matching on each value, you can trigger a regular expression evaluation by adding a <code>'@'</code> first, as in: <code>~var %drop% "@^v[12]"</code> which will drop values starting with <code>"v1"</code> or <code>"v2"</code> (of course you need to know regexes!).</p>
</td></tr>
<tr><td><code id="femlm_+3A_fsplit">fsplit</code></td>
<td>
<p>A one sided formula representing a variable (eg <code>split = ~var</code>) or a vector. If provided, the sample is split according to the variable and one estimation is performed for each value of that variable. This argument is the same as split but also includes the full sample as the first estimation. You can use the special operators <code style="white-space: pre;">&#8288;%keep%&#8288;</code> and <code style="white-space: pre;">&#8288;%drop%&#8288;</code> to select only a subset of values for which to split the sample. E.g. <code>split = ~var %keep% c("v1", "v2")</code> will split the sample only according to the values <code>v1</code> and <code>v2</code> of the variable <code>var</code>; it is equivalent to supplying the argument <code>split.keep = c("v1", "v2")</code>. By default there is partial matching on each value, you can trigger a regular expression evaluation by adding an <code>'@'</code> first, as in: <code>~var %drop% "@^v[12]"</code> which will drop values starting with <code>"v1"</code> or <code>"v2"</code> (of course you need to know regexes!).</p>
</td></tr>
<tr><td><code id="femlm_+3A_split.keep">split.keep</code></td>
<td>
<p>A character vector. Only used when <code>split</code>, or <code>fsplit</code>, is supplied. If provided, then the sample will be split only on the values of <code>split.keep</code>. The values in <code>split.keep</code> will be partially matched to the values of <code>split</code>. To enable regular expressions, you need to add an <code>'@'</code> first. For example <code>split.keep = c("v1", "@other|var")</code> will keep only the value in <code>split</code> partially matched by <code>"v1"</code> or the values containing <code>"other"</code> or <code>"var"</code>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_split.drop">split.drop</code></td>
<td>
<p>A character vector. Only used when <code>split</code>, or <code>fsplit</code>, is supplied. If provided, then the sample will be split only on the values that are not in <code>split.drop</code>. The values in <code>split.drop</code> will be partially matched to the values of <code>split</code>. To enable regular expressions, you need to add an <code>'@'</code> first. For example <code>split.drop = c("v1", "@other|var")</code> will drop only the value in <code>split</code> partially matched by <code>"v1"</code> or the values containing <code>"other"</code> or <code>"var"</code>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="femlm_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="femlm_+3A_panel.id">panel.id</code></td>
<td>
<p>The panel identifiers. Can either be: i) a one sided formula (e.g. <code>panel.id = ~id+time</code>), ii) a character vector of length 2 (e.g. <code>panel.id=c('id', 'time')</code>, or iii) a character scalar of two variables separated by a comma (e.g. <code>panel.id='id,time'</code>). Note that you can combine variables with <code>^</code> only inside formulas (see the dedicated section in <code><a href="#topic+feols">feols</a></code>).</p>
</td></tr>
<tr><td><code id="femlm_+3A_fixef.tol">fixef.tol</code></td>
<td>
<p>Precision used to obtain the fixed-effects. Defaults to <code>1e-5</code>. It corresponds to the maximum absolute difference allowed between two coefficients of successive iterations. Argument <code>fixef.tol</code> cannot be lower than <code>10000*.Machine$double.eps</code>. Note that this parameter is dynamically controlled by the algorithm.</p>
</td></tr>
<tr><td><code id="femlm_+3A_fixef.iter">fixef.iter</code></td>
<td>
<p>Maximum number of iterations in fixed-effects algorithm (only in use for 2+ fixed-effects). Default is 10000.</p>
</td></tr>
<tr><td><code id="femlm_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than, or equal to, the maximum number of threads; b) 0: meaning all available threads will be used; c) a number strictly between 0 and 1 which represents the fraction of all threads to use. The default is to use 50% of all threads. You can set permanently the number of threads used within this package using the function <code><a href="#topic+setFixest_nthreads">setFixest_nthreads</a></code>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_lean">lean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> then all large objects are removed from the returned result: this will save memory but will block the possibility to use many methods. It is recommended to use the arguments <code>se</code> or <code>cluster</code> to obtain the appropriate standard-errors at estimation time, since obtaining different SEs won't be possible afterwards.</p>
</td></tr>
<tr><td><code id="femlm_+3A_verbose">verbose</code></td>
<td>
<p>Integer, default is 0. It represents the level of information that should be reported during the optimisation process. If <code>verbose=0</code>: nothing is reported. If <code>verbose=1</code>: the value of the coefficients and the likelihood are reported. If <code>verbose=2</code>: <code>1</code> + information on the computing time of the null model, the fixed-effects coefficients and the hessian are reported.</p>
</td></tr>
<tr><td><code id="femlm_+3A_warn">warn</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether warnings should be displayed (concerns warnings relating to convergence state).</p>
</td></tr>
<tr><td><code id="femlm_+3A_notes">notes</code></td>
<td>
<p>Logical. By default, two notes are displayed: when NAs are removed (to show additional information) and when some observations are removed because of only 0 (or 0/1) outcomes in a fixed-effect setup (in Poisson/Neg. Bin./Logit models). To avoid displaying these messages, you can set <code>notes = FALSE</code>. You can remove these messages permanently by using <code>setFixest_notes(FALSE)</code>.</p>
</td></tr>
<tr><td><code id="femlm_+3A_theta.init">theta.init</code></td>
<td>
<p>Positive numeric scalar. The starting value of the dispersion parameter if <code>family="negbin"</code>. By default, the algorithm uses as a starting value the theta obtained from the model with only the intercept.</p>
</td></tr>
<tr><td><code id="femlm_+3A_combine.quick">combine.quick</code></td>
<td>
<p>Logical. When you combine different variables to transform them into a single fixed-effects you can do e.g. <code>y ~ x | paste(var1, var2)</code>. The algorithm provides a shorthand to do the same operation: <code>y ~ x | var1^var2</code>. Because pasting variables is a costly operation, the internal algorithm may use a numerical trick to hasten the process. The cost of doing so is that you lose the labels. If you are interested in getting the value of the fixed-effects coefficients after the estimation, you should use <code>combine.quick = FALSE</code>. By default it is equal to <code>FALSE</code> if the number of observations is lower than 50,000, and to <code>TRUE</code> otherwise.</p>
</td></tr>
<tr><td><code id="femlm_+3A_mem.clean">mem.clean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only to be used if the data set is large compared to the available RAM. If <code>TRUE</code> then intermediary objects are removed as much as possible and <code><a href="base.html#topic+gc">gc</a></code> is run before each substantial C++ section in the internal code to avoid memory issues.</p>
</td></tr>
<tr><td><code id="femlm_+3A_only.env">only.env</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then only the environment used to make the estimation is returned.</p>
</td></tr>
<tr><td><code id="femlm_+3A_only.coef">only.coef</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then only the estimated coefficients are returned. Note that the length of the vector returned is always the length of the number of coefficients to be estimated: this means that the variables found to be collinear are returned with an NA value.</p>
</td></tr>
<tr><td><code id="femlm_+3A_env">env</code></td>
<td>
<p>(Advanced users.) A <code>fixest</code> environment created by a <code>fixest</code> estimation with <code>only.env = TRUE</code>. Default is missing. If provided, the data from this environment will be used to perform the estimation.</p>
</td></tr>
<tr><td><code id="femlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the functions <code><a href="#topic+feglm">feglm</a></code> and <code><a href="#topic+femlm">femlm</a></code> provide the same results when using the same families but differ in that the latter is a direct maximum likelihood optimization (so the two can really have different convergence rates).
</p>


<h3>Value</h3>

<p>A <code>fixest</code> object. Note that <code>fixest</code> objects contain many elements and most of them are for internal use, they are presented here only for information. To access them, it is safer to use the user-level methods (e.g. <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>, <code><a href="#topic+resid.fixest">resid.fixest</a></code>, etc) or functions (like for instance <code><a href="#topic+fitstat">fitstat</a></code> to access any fit statistic).
</p>
<table>
<tr><td><code>nobs</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code>fml</code></td>
<td>
<p>The linear formula of the call.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used to estimate the model.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The family used to estimate the model.</p>
</td></tr>
<tr><td><code>fml_all</code></td>
<td>
<p>A list containing different parts of the formula. Always contain the linear formula. Then, if relevant: <code>fixef</code>: the fixed-effects; <code>NL</code>: the non linear part of the formula.</p>
</td></tr>
<tr><td><code>nparams</code></td>
<td>
<p>The number of parameters of the model.</p>
</td></tr>
<tr><td><code>fixef_vars</code></td>
<td>
<p>The names of each fixed-effect dimension.</p>
</td></tr>
<tr><td><code>fixef_id</code></td>
<td>
<p>The list (of length the number of fixed-effects) of the fixed-effects identifiers for each observation.</p>
</td></tr>
<tr><td><code>fixef_sizes</code></td>
<td>
<p>The size of each fixed-effect (i.e. the number of unique identifierfor each fixed-effect dimension).</p>
</td></tr>
<tr><td><code>convStatus</code></td>
<td>
<p>Logical, convergence status.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>The convergence message from the optimization procedures.</p>
</td></tr>
<tr><td><code>obs_selection</code></td>
<td>
<p>(When relevant.) List containing vectors of integers. It represents the sequential selection of observation vis a vis the original data set.</p>
</td></tr>
<tr><td><code>fixef_removed</code></td>
<td>
<p>(When relevant.) In the case there were fixed-effects and some observations were removed because of only 0/1 outcome within a fixed-effect, it gives the list (for each fixed-effect dimension) of the fixed-effect identifiers that were removed.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>The named vector of estimated coefficients.</p>
</td></tr>
<tr><td><code>coeftable</code></td>
<td>
<p>The table of the coefficients with their standard errors, z-values and p-values.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The log-likelihood.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of iterations of the algorithm.</p>
</td></tr>
<tr><td><code>ll_null</code></td>
<td>
<p>Log-likelihood of the null model (i.e. with the intercept only).</p>
</td></tr>
<tr><td><code>ll_fe_only</code></td>
<td>
<p>Log-likelihood of the model with only the fixed-effects.</p>
</td></tr>
<tr><td><code>ssr_null</code></td>
<td>
<p>Sum of the squared residuals of the null model (containing only with the intercept).</p>
</td></tr>
<tr><td><code>pseudo_r2</code></td>
<td>
<p>The adjusted pseudo R2.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values are the expected value of the dependent variable for the fitted model: that is <code class="reqn">E(Y|X)</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The residuals (y minus the fitted values).</p>
</td></tr>
<tr><td><code>sq.cor</code></td>
<td>
<p>Squared correlation between the dependent variable and the expected predictor (i.e. fitted.values) obtained by the estimation.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian of the parameters.</p>
</td></tr>
<tr><td><code>cov.iid</code></td>
<td>
<p>The variance-covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The standard-error of the parameters.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>The matrix of the scores (first derivative for each observation).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The difference between the dependent variable and the expected predictor.</p>
</td></tr>
<tr><td><code>sumFE</code></td>
<td>
<p>The sum of the fixed-effects coefficients for each observation.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>(When relevant.) The offset formula.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>(When relevant.) The weights formula.</p>
</td></tr>
</table>


<h3>Combining the fixed-effects</h3>

<p>You can combine two variables to make it a new fixed-effect using <code>^</code>. The syntax is as follows: <code>fe_1^fe_2</code>. Here you created a new variable which is the combination of the two variables fe_1 and fe_2. This is identical to doing <code>paste0(fe_1, "_", fe_2)</code> but more convenient.
</p>
<p>Note that pasting is a costly operation, especially for large data sets. Thus, the internal algorithm uses a numerical trick which is fast, but the drawback is that the identity of each observation is lost (i.e. they are now equal to a meaningless number instead of being equal to <code>paste0(fe_1, "_", fe_2)</code>). These &ldquo;identities&rdquo; are useful only if you're interested in the value of the fixed-effects (that you can extract with <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>). If you're only interested in coefficients of the variables, it doesn't matter. Anyway, you can use <code>combine.quick = FALSE</code> to tell the internal algorithm to use <code>paste</code> instead of the numerical trick. By default, the numerical trick is performed only for large data sets.
</p>


<h3>Lagging variables</h3>

<p>To use leads/lags of variables in the estimation, you can: i) either provide the argument <code>panel.id</code>, ii) either set your data set as a panel with the function <code><a href="#topic+panel">panel</a></code>, <code><a href="#topic+l">f</a></code> and <code><a href="#topic+l">d</a></code>.
</p>
<p>You can provide several leads/lags/differences at once: e.g. if your formula is equal to <code>f(y) ~ l(x, -1:1)</code>, it means that the dependent variable is equal to the lead of <code>y</code>, and you will have as explanatory variables the lead of <code>x1</code>, <code>x1</code> and the lag of <code>x1</code>. See the examples in function <code><a href="#topic+l">l</a></code> for more details.
</p>


<h3>Interactions</h3>

<p>You can interact a numeric variable with a &quot;factor-like&quot; variable by using <code>i(factor_var, continuous_var, ref)</code>, where <code>continuous_var</code> will be interacted with each value of <code>factor_var</code> and the argument <code>ref</code> is a value of <code>factor_var</code> taken as a reference (optional).
</p>
<p>Using this specific way to create interactions leads to a different display of the interacted values in <code><a href="#topic+etable">etable</a></code>. See examples.
</p>
<p>It is important to note that <em>if you do not care about the standard-errors of the interactions</em>, then you can add interactions in the fixed-effects part of the formula, it will be incomparably faster (using the syntax <code>factor_var[continuous_var]</code>, as explained in the section &ldquo;Varying slopes&rdquo;).
</p>
<p>The function <code><a href="#topic+i">i</a></code> has in fact more arguments, please see details in its associated help page.
</p>


<h3>On standard-errors</h3>

<p>Standard-errors can be computed in different ways, you can use the arguments <code>se</code> and <code>ssc</code> in <code><a href="#topic+summary.fixest">summary.fixest</a></code> to define how to compute them. By default, in the presence of fixed-effects, standard-errors are automatically clustered.
</p>
<p>The following vignette: <a href="https://lrberge.github.io/fixest/articles/standard_errors.html">On standard-errors</a> describes in details how the standard-errors are computed in <code>fixest</code> and how you can replicate standard-errors from other software.
</p>
<p>You can use the functions <code><a href="#topic+setFixest_vcov">setFixest_vcov</a></code> and <code><a href="#topic+ssc">setFixest_ssc</a></code> to permanently set the way the standard-errors are computed.
</p>


<h3>Multiple estimations</h3>

<p>Multiple estimations can be performed at once, they just have to be specified in the formula. Multiple estimations yield a <code>fixest_multi</code> object which is &lsquo;kind of&rsquo; a list of all the results but includes specific methods to access the results in a handy way. Please have a look at the dedicated vignette: <a href="https://lrberge.github.io/fixest/articles/multiple_estimations.html">Multiple estimations</a>.
</p>
<p>To include multiple dependent variables, wrap them in <code>c()</code> (<code>list()</code> also works). For instance <code>fml = c(y1, y2) ~ x1</code> would estimate the model <code>fml = y1 ~ x1</code> and then the model <code>fml = y2 ~ x1</code>.
</p>
<p>To include multiple independent variables, you need to use the stepwise functions. There are 4 stepwise functions: <code>sw</code>, <code>sw0</code>, <code>csw</code>, <code>csw0</code>, and <code>mvsw</code>. Of course <code>sw</code> stands for stepwise, and <code>csw</code> for cumulative stepwise. Finally <code>mvsw</code> is a bit special, it stands for multiverse stepwise. Let's explain that.
Assume you have the following formula: <code>fml = y ~ x1 + sw(x2, x3)</code>. The stepwise function <code>sw</code> will estimate the following two models: <code>y ~ x1 + x2</code> and <code>y ~ x1 + x3</code>. That is, each element in <code>sw()</code> is sequentially, and separately, added to the formula. Would have you used <code>sw0</code> in lieu of <code>sw</code>, then the model <code>y ~ x1</code> would also have been estimated. The <code>0</code> in the name means that the model without any stepwise element also needs to be estimated.
The prefix <code>c</code> means cumulative: each stepwise element is added to the next. That is, <code>fml = y ~ x1 + csw(x2, x3)</code> would lead to the following models <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>. The <code>0</code> has the same meaning and would also lead to the model without the stepwise elements to be estimated: in other words, <code>fml = y ~ x1 + csw0(x2, x3)</code> leads to the following three models: <code>y ~ x1</code>, <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>.
Finally <code>mvsw</code> will add, in a stepwise fashion all possible combinations of the variables in its arguments. For example <code>mvsw(x1, x2, x3)</code> is equivalent to <code>sw0(x1, x2, x3, x1 + x2, x1 + x3, x2 + x3, x1 + x2 + x3)</code>. The number of models to estimate grows at a factorial rate: so be cautious!
</p>
<p>Multiple independent variables can be combined with multiple dependent variables, as in <code>fml = c(y1, y2) ~ cw(x1, x2, x3)</code> which would lead to 6 estimations. Multiple estimations can also be combined to split samples (with the arguments <code>split</code>, <code>fsplit</code>).
</p>
<p>You can also add fixed-effects in a stepwise fashion. Note that you cannot perform stepwise estimations on the IV part of the formula (<code>feols</code> only).
</p>
<p>If NAs are present in the sample, to avoid too many messages, only NA removal concerning the variables common to all estimations is reported.
</p>
<p>A note on performance. The feature of multiple estimations has been highly optimized for <code>feols</code>, in particular in the presence of fixed-effects. It is faster to estimate multiple models using the formula rather than with a loop. For non-<code>feols</code> models using the formula is roughly similar to using a loop performance-wise.
</p>


<h3>Argument sliding</h3>

<p>When the data set has been set up globally using <code><a href="#topic+setFixest_estimation">setFixest_estimation</a></code><code>(data = data_set)</code>, the argument <code>vcov</code> can be used implicitly. This means that calls such as <code>feols(y ~ x, "HC1")</code>, or <code>feols(y ~ x, ~id)</code>, are valid: i) the data is automatically deduced from the global settings, and ii) the <code>vcov</code> is deduced to be the second argument.
</p>


<h3>Piping</h3>

<p>Although the argument 'data' is placed in second position, the data can be piped to the estimation functions. For example, with R &gt;= 4.1, <code>mtcars |&gt; feols(mpg ~ cyl)</code> works as <code>feols(mpg ~ cyl, mtcars)</code>.
</p>


<h3>Tricks to estimate multiple LHS</h3>

<p>To use multiple dependent variables in <code>fixest</code> estimations, you need to include them in a vector: like in <code>c(y1, y2, y3)</code>.
</p>
<p>First, if names are stored in a vector, they can readily be inserted in a formula to perform multiple estimations using the dot square bracket operator. For instance if <code>my_lhs = c("y1", "y2")</code>, calling <code>fixest</code> with, say <code>feols(.[my_lhs] ~ x1, etc)</code> is equivalent to using <code>feols(c(y1, y2) ~ x1, etc)</code>. Beware that this is a special feature unique to the <em>left-hand-side</em> of <code>fixest</code> estimations (the default behavior of the DSB operator is to aggregate with sums, see <code><a href="#topic+xpd">xpd</a></code>).
</p>
<p>Second, you can use a regular expression to grep the left-hand-sides on the fly. When the <code>..("regex")</code> feature is used naked on the LHS, the variables grepped are inserted into <code>c()</code>. For example <code style="white-space: pre;">&#8288;..("Pe") ~ Sepal.Length, iris&#8288;</code> is equivalent to <code style="white-space: pre;">&#8288;c(Petal.Length, Petal.Width) ~ Sepal.Length, iris&#8288;</code>. Beware that this is a special feature unique to the <em>left-hand-side</em> of <code>fixest</code> estimations (the default behavior of <code>..("regex")</code> is to aggregate with sums, see <code><a href="#topic+xpd">xpd</a></code>).
</p>


<h3>Dot square bracket operator in formulas</h3>

<p>In a formula, the dot square bracket (DSB) operator can: i) create manifold variables at once, or ii) capture values from the current environment and put them verbatim in the formula.
</p>
<p>Say you want to include the variables <code>x1</code> to <code>x3</code> in your formula. You can use <code>xpd(y ~ x.[1:3])</code> and you'll get <code>y ~ x1 + x2 + x3</code>.
</p>
<p>To summon values from the environment, simply put the variable in square brackets. For example: <code>for(i in 1:3) xpd(y.[i] ~ x)</code> will create the formulas <code>y1 ~ x</code> to <code>y3 ~ x</code> depending on the value of <code>i</code>.
</p>
<p>You can include a full variable from the environment in the same way: <code>for(y in c("a", "b")) xpd(.[y] ~ x)</code> will create the two formulas <code>a ~ x</code> and <code>b ~ x</code>.
</p>
<p>The DSB can even be used within variable names, but then the variable must be nested in character form. For example <code>y ~ .["x.[1:2]_sq"]</code> will create <code>y ~ x1_sq + x2_sq</code>. Using the character form is important to avoid a formula parsing error. Double quotes must be used. Note that the character string that is nested will be parsed with the function <code><a href="#topic+dsb">dsb</a></code>, and thus it will return a vector.
</p>
<p>By default, the DSB operator expands vectors into sums. You can add a comma, like in <code>.[, x]</code>, to expand with commas&ndash;the content can then be used within functions. For instance: <code>c(x.[, 1:2])</code> will create <code>c(x1, x2)</code> (and <em>not</em> <code>c(x1 + x2)</code>).
</p>
<p>In all <code>fixest</code> estimations, this special parsing is enabled, so you don't need to use <code>xpd</code>.
</p>
<p>One-sided formulas can be expanded with the DSB operator: let <code>x = ~sepal + petal</code>, then <code>xpd(y ~ .[x])</code> leads to <code>color ~ sepal + petal</code>.
</p>
<p>You can even use multiple square brackets within a single variable, but then the use of nesting is required. For example, the following <code>xpd(y ~ .[".[letters[1:2]]_.[1:2]"])</code> will create <code>y ~ a_1 + b_2</code>. Remember that the nested character string is parsed with <code><a href="#topic+dsb">dsb</a></code>, which explains this behavior.
</p>
<p>When the element to be expanded i) is equal to the empty string or, ii) is of length 0, it is replaced with a neutral element, namely <code>1</code>. For example, <code style="white-space: pre;">&#8288;x = "" ; xpd(y ~ .[x])&#8288;</code> leads to <code>y ~ 1</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>References</h3>

<p>Berge, Laurent, 2018, &quot;Efficient estimation of maximum likelihood models with multiple fixed-effects: the R package FENmlm.&quot; CREA Discussion Papers, 13 (<a href="https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf"></a>).
</p>
<p>For models with multiple fixed-effects:
</p>
<p>Gaure, Simen, 2013, &quot;OLS with multiple high dimensional category variables&quot;, Computational Statistics &amp; Data Analysis 66 pp. 8&ndash;18
</p>
<p>On the unconditionnal Negative Binomial model:
</p>
<p>Allison, Paul D and Waterman, Richard P, 2002, &quot;Fixed-Effects Negative Binomial Regression Models&quot;, Sociological Methodology 32(1) pp. 247&ndash;265
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+summary.fixest">summary.fixest</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> to extract the fixed-effects coefficients, and the function <code><a href="#topic+etable">etable</a></code> to visualize the results of multiple estimations.
And other estimation methods: <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+fepois">fepois</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load trade data
data(trade)

# We estimate the effect of distance on trade =&gt; we account for 3 fixed-effects
# 1) Poisson estimation
est_pois = femlm(Euros ~ log(dist_km) | Origin + Destination + Product, trade)

# 2) Log-Log Gaussian estimation (with same FEs)
est_gaus = update(est_pois, log(Euros+1) ~ ., family = "gaussian")

# Comparison of the results using the function etable
etable(est_pois, est_gaus)
# Now using two way clustered standard-errors
etable(est_pois, est_gaus, se = "twoway")

# Comparing different types of standard errors
sum_hetero   = summary(est_pois, se = "hetero")
sum_oneway   = summary(est_pois, se = "cluster")
sum_twoway   = summary(est_pois, se = "twoway")
sum_threeway = summary(est_pois, se = "threeway")

etable(sum_hetero, sum_oneway, sum_twoway, sum_threeway)


#
# Multiple estimations:
#

# 6 estimations
est_mult = femlm(c(Ozone, Solar.R) ~ Wind + Temp + csw0(Wind:Temp, Day), airquality)

# We can display the results for the first lhs:
etable(est_mult[lhs = 1])

# And now the second (access can be made by name)
etable(est_mult[lhs = "Solar.R"])

# Now we focus on the two last right hand sides
# (note that .N can be used to specify the last item)
etable(est_mult[rhs = 2:.N])

# Combining with split
est_split = fepois(c(Ozone, Solar.R) ~ sw(poly(Wind, 2), poly(Temp, 2)),
                  airquality, split = ~ Month)

# You can display everything at once with the print method
est_split

# Different way of displaying the results with "compact"
summary(est_split, "compact")

# You can still select which sample/LHS/RHS to display
est_split[sample = 1:2, lhs = 1, rhs = 1]




</code></pre>

<hr>
<h2 id='feNmlm'>Fixed effects nonlinear maximum likelihood models</h2><span id='topic+feNmlm'></span>

<h3>Description</h3>

<p>This function estimates maximum likelihood models (e.g., Poisson or Logit) with non-linear in parameters right-hand-sides and is efficient to handle any number of fixed effects. If you do not use non-linear in parameters right-hand-side, use <code><a href="#topic+femlm">femlm</a></code> or <code><a href="#topic+feglm">feglm</a></code> instead (their design is simpler).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feNmlm(
  fml,
  data,
  family = c("poisson", "negbin", "logit", "gaussian"),
  NL.fml,
  vcov,
  fixef,
  fixef.rm = "perfect",
  NL.start,
  lower,
  upper,
  NL.start.init,
  offset,
  subset,
  split,
  fsplit,
  split.keep,
  split.drop,
  cluster,
  se,
  ssc,
  panel.id,
  start = 0,
  jacobian.method = "simple",
  useHessian = TRUE,
  hessian.args = NULL,
  opt.control = list(),
  nthreads = getFixest_nthreads(),
  lean = FALSE,
  verbose = 0,
  theta.init,
  fixef.tol = 1e-05,
  fixef.iter = 10000,
  deriv.tol = 1e-04,
  deriv.iter = 1000,
  warn = TRUE,
  notes = getFixest_notes(),
  combine.quick,
  mem.clean = FALSE,
  only.env = FALSE,
  only.coef = FALSE,
  env,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feNmlm_+3A_fml">fml</code></td>
<td>
<p>A formula. This formula gives the linear formula to be estimated (it is similar to a <code>lm</code> formula), for example: <code>fml = z~x+y</code>. To include fixed-effects variables, insert them in this formula using a pipe (e.g. <code>fml = z~x+y|fixef_1+fixef_2</code>). To include a non-linear in parameters element, you must use the argment <code>NL.fml</code>. Multiple estimations can be performed at once: for multiple dep. vars, wrap them in <code>c()</code>: ex <code>c(y1, y2)</code>. For multiple indep. vars, use the stepwise functions: ex <code>x1 + csw(x2, x3)</code>. This leads to 6 estimation <code>fml = c(y1, y2) ~ x1 + cw0(x2, x3)</code>. See details. Square brackets starting with a dot can be used to call global variables: <code>y.[i] ~ x.[1:2]</code> will lead to <code>y3 ~ x1 + x2</code> if <code>i</code> is equal to 3 in the current environment (see details in <code><a href="#topic+xpd">xpd</a></code>).</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_data">data</code></td>
<td>
<p>A data.frame containing the necessary variables to run the model. The variables of the non-linear right hand side of the formula are identified with this <code>data.frame</code> names. Can also be a matrix.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_family">family</code></td>
<td>
<p>Character scalar. It should provide the family. The possible values are &quot;poisson&quot; (Poisson model with log-link, the default), &quot;negbin&quot; (Negative Binomial model with log-link), &quot;logit&quot; (LOGIT model with log-link), &quot;gaussian&quot; (Gaussian model).</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_nl.fml">NL.fml</code></td>
<td>
<p>A formula. If provided, this formula represents the non-linear part of the right hand side (RHS). Note that contrary to the <code>fml</code> argument, the coefficients must explicitly appear in this formula. For instance, it can be <code>~a*log(b*x + c*x^3)</code>, where <code>a</code>, <code>b</code>, and <code>c</code> are the coefficients to be estimated. Note that only the RHS of the formula is to be provided, and NOT the left hand side.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_fixef">fixef</code></td>
<td>
<p>Character vector. The names of variables to be used as fixed-effects. These variables should contain the identifier of each observation (e.g., think of it as a panel identifier). Note that the recommended way to include fixed-effects is to insert them directly in the formula.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_fixef.rm">fixef.rm</code></td>
<td>
<p>Can be equal to &quot;perfect&quot; (default), &quot;singleton&quot;, &quot;both&quot; or &quot;none&quot;. Controls which observations are to be removed. If &quot;perfect&quot;, then observations having a fixed-effect with perfect fit (e.g. only 0 outcomes in Poisson estimations) will be removed. If &quot;singleton&quot;, all observations for which a fixed-effect appears only once will be removed. The meaning of &quot;both&quot; and &quot;none&quot; is direct.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_nl.start">NL.start</code></td>
<td>
<p>(For NL models only) A list of starting values for the non-linear parameters. ALL the parameters are to be named and given a staring value. Example: <code>NL.start=list(a=1,b=5,c=0)</code>. Though, there is an exception: if all parameters are to be given the same starting value, you can use a numeric scalar.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_lower">lower</code></td>
<td>
<p>(For NL models only) A list. The lower bound for each of the non-linear parameters that requires one. Example: <code>lower=list(b=0,c=0)</code>. Beware, if the estimated parameter is at his lower bound, then asymptotic theory cannot be applied and the standard-error of the parameter cannot be estimated because the gradient will not be null. In other words, when at its upper/lower bound, the parameter is considered as 'fixed'.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_upper">upper</code></td>
<td>
<p>(For NL models only) A list. The upper bound for each of the non-linear parameters that requires one. Example: <code>upper=list(a=10,c=50)</code>. Beware, if the estimated parameter is at his upper bound, then asymptotic theory cannot be applied and the standard-error of the parameter cannot be estimated because the gradient will not be null. In other words, when at its upper/lower bound, the parameter is considered as 'fixed'.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_nl.start.init">NL.start.init</code></td>
<td>
<p>(For NL models only) Numeric scalar. If the argument <code>NL.start</code> is not provided, or only partially filled (i.e. there remain non-linear parameters with no starting value), then the starting value of all remaining non-linear parameters is set to <code>NL.start.init</code>.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_offset">offset</code></td>
<td>
<p>A formula or a numeric vector. An offset can be added to the estimation. If equal to a formula, it should be of the form (for example) <code>~0.5*x**2</code>. This offset is linearly added to the elements of the main formula 'fml'.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_subset">subset</code></td>
<td>
<p>A vector (logical or numeric) or a one-sided formula. If provided, then the estimation will be performed only on the observations defined by this argument.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_split">split</code></td>
<td>
<p>A one sided formula representing a variable (eg <code>split = ~var</code>) or a vector. If provided, the sample is split according to the variable and one estimation is performed for each value of that variable. If you also want to include the estimation for the full sample, use the argument <code>fsplit</code> instead. You can use the special operators <code style="white-space: pre;">&#8288;%keep%&#8288;</code> and <code style="white-space: pre;">&#8288;%drop%&#8288;</code> to select only a subset of values for which to split the sample. E.g. <code>split = ~var %keep% c("v1", "v2")</code> will split the sample only according to the values <code>v1</code> and <code>v2</code> of the variable <code>var</code>; it is equivalent to supplying the argument <code>split.keep = c("v1", "v2")</code>. By default there is partial matching on each value, you can trigger a regular expression evaluation by adding a <code>'@'</code> first, as in: <code>~var %drop% "@^v[12]"</code> which will drop values starting with <code>"v1"</code> or <code>"v2"</code> (of course you need to know regexes!).</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_fsplit">fsplit</code></td>
<td>
<p>A one sided formula representing a variable (eg <code>split = ~var</code>) or a vector. If provided, the sample is split according to the variable and one estimation is performed for each value of that variable. This argument is the same as split but also includes the full sample as the first estimation. You can use the special operators <code style="white-space: pre;">&#8288;%keep%&#8288;</code> and <code style="white-space: pre;">&#8288;%drop%&#8288;</code> to select only a subset of values for which to split the sample. E.g. <code>split = ~var %keep% c("v1", "v2")</code> will split the sample only according to the values <code>v1</code> and <code>v2</code> of the variable <code>var</code>; it is equivalent to supplying the argument <code>split.keep = c("v1", "v2")</code>. By default there is partial matching on each value, you can trigger a regular expression evaluation by adding an <code>'@'</code> first, as in: <code>~var %drop% "@^v[12]"</code> which will drop values starting with <code>"v1"</code> or <code>"v2"</code> (of course you need to know regexes!).</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_split.keep">split.keep</code></td>
<td>
<p>A character vector. Only used when <code>split</code>, or <code>fsplit</code>, is supplied. If provided, then the sample will be split only on the values of <code>split.keep</code>. The values in <code>split.keep</code> will be partially matched to the values of <code>split</code>. To enable regular expressions, you need to add an <code>'@'</code> first. For example <code>split.keep = c("v1", "@other|var")</code> will keep only the value in <code>split</code> partially matched by <code>"v1"</code> or the values containing <code>"other"</code> or <code>"var"</code>.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_split.drop">split.drop</code></td>
<td>
<p>A character vector. Only used when <code>split</code>, or <code>fsplit</code>, is supplied. If provided, then the sample will be split only on the values that are not in <code>split.drop</code>. The values in <code>split.drop</code> will be partially matched to the values of <code>split</code>. To enable regular expressions, you need to add an <code>'@'</code> first. For example <code>split.drop = c("v1", "@other|var")</code> will drop only the value in <code>split</code> partially matched by <code>"v1"</code> or the values containing <code>"other"</code> or <code>"var"</code>.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_panel.id">panel.id</code></td>
<td>
<p>The panel identifiers. Can either be: i) a one sided formula (e.g. <code>panel.id = ~id+time</code>), ii) a character vector of length 2 (e.g. <code>panel.id=c('id', 'time')</code>, or iii) a character scalar of two variables separated by a comma (e.g. <code>panel.id='id,time'</code>). Note that you can combine variables with <code>^</code> only inside formulas (see the dedicated section in <code><a href="#topic+feols">feols</a></code>).</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_start">start</code></td>
<td>
<p>Starting values for the coefficients in the linear part (for the non-linear part, use NL.start). Can be: i) a numeric of length 1 (e.g. <code>start = 0</code>, the default), ii) a numeric vector of the exact same length as the number of variables, or iii) a named vector of any length (the names will be used to initialize the appropriate coefficients).</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_jacobian.method">jacobian.method</code></td>
<td>
<p>(For NL models only) Character scalar. Provides the method used to numerically compute the Jacobian of the non-linear part. Can be either <code>"simple"</code> or <code>"Richardson"</code>. Default is <code>"simple"</code>. See the help of <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code> for more information.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_usehessian">useHessian</code></td>
<td>
<p>Logical. Should the Hessian be computed in the optimization stage? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_hessian.args">hessian.args</code></td>
<td>
<p>List of arguments to be passed to function <code><a href="numDeriv.html#topic+genD">genD</a></code>. Defaults is missing. Only used with the presence of <code>NL.fml</code>.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_opt.control">opt.control</code></td>
<td>
<p>List of elements to be passed to the optimization method <code><a href="stats.html#topic+nlminb">nlminb</a></code>. See the help page of <code><a href="stats.html#topic+nlminb">nlminb</a></code> for more information.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than, or equal to, the maximum number of threads; b) 0: meaning all available threads will be used; c) a number strictly between 0 and 1 which represents the fraction of all threads to use. The default is to use 50% of all threads. You can set permanently the number of threads used within this package using the function <code><a href="#topic+setFixest_nthreads">setFixest_nthreads</a></code>.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_lean">lean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> then all large objects are removed from the returned result: this will save memory but will block the possibility to use many methods. It is recommended to use the arguments <code>se</code> or <code>cluster</code> to obtain the appropriate standard-errors at estimation time, since obtaining different SEs won't be possible afterwards.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_verbose">verbose</code></td>
<td>
<p>Integer, default is 0. It represents the level of information that should be reported during the optimisation process. If <code>verbose=0</code>: nothing is reported. If <code>verbose=1</code>: the value of the coefficients and the likelihood are reported. If <code>verbose=2</code>: <code>1</code> + information on the computing time of the null model, the fixed-effects coefficients and the hessian are reported.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_theta.init">theta.init</code></td>
<td>
<p>Positive numeric scalar. The starting value of the dispersion parameter if <code>family="negbin"</code>. By default, the algorithm uses as a starting value the theta obtained from the model with only the intercept.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_fixef.tol">fixef.tol</code></td>
<td>
<p>Precision used to obtain the fixed-effects. Defaults to <code>1e-5</code>. It corresponds to the maximum absolute difference allowed between two coefficients of successive iterations. Argument <code>fixef.tol</code> cannot be lower than <code>10000*.Machine$double.eps</code>. Note that this parameter is dynamically controlled by the algorithm.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_fixef.iter">fixef.iter</code></td>
<td>
<p>Maximum number of iterations in fixed-effects algorithm (only in use for 2+ fixed-effects). Default is 10000.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_deriv.tol">deriv.tol</code></td>
<td>
<p>Precision used to obtain the fixed-effects derivatives. Defaults to <code>1e-4</code>. It corresponds to the maximum absolute difference allowed between two coefficients of successive iterations. Argument <code>deriv.tol</code> cannot be lower than <code>10000*.Machine$double.eps</code>.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_deriv.iter">deriv.iter</code></td>
<td>
<p>Maximum number of iterations in the algorithm to obtain the derivative of the fixed-effects (only in use for 2+ fixed-effects). Default is 1000.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_warn">warn</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether warnings should be displayed (concerns warnings relating to convergence state).</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_notes">notes</code></td>
<td>
<p>Logical. By default, two notes are displayed: when NAs are removed (to show additional information) and when some observations are removed because of only 0 (or 0/1) outcomes in a fixed-effect setup (in Poisson/Neg. Bin./Logit models). To avoid displaying these messages, you can set <code>notes = FALSE</code>. You can remove these messages permanently by using <code>setFixest_notes(FALSE)</code>.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_combine.quick">combine.quick</code></td>
<td>
<p>Logical. When you combine different variables to transform them into a single fixed-effects you can do e.g. <code>y ~ x | paste(var1, var2)</code>. The algorithm provides a shorthand to do the same operation: <code>y ~ x | var1^var2</code>. Because pasting variables is a costly operation, the internal algorithm may use a numerical trick to hasten the process. The cost of doing so is that you lose the labels. If you are interested in getting the value of the fixed-effects coefficients after the estimation, you should use <code>combine.quick = FALSE</code>. By default it is equal to <code>FALSE</code> if the number of observations is lower than 50,000, and to <code>TRUE</code> otherwise.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_mem.clean">mem.clean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only to be used if the data set is large compared to the available RAM. If <code>TRUE</code> then intermediary objects are removed as much as possible and <code><a href="base.html#topic+gc">gc</a></code> is run before each substantial C++ section in the internal code to avoid memory issues.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_only.env">only.env</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then only the environment used to make the estimation is returned.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_only.coef">only.coef</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then only the estimated coefficients are returned. Note that the length of the vector returned is always the length of the number of coefficients to be estimated: this means that the variables found to be collinear are returned with an NA value.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_env">env</code></td>
<td>
<p>(Advanced users.) A <code>fixest</code> environment created by a <code>fixest</code> estimation with <code>only.env = TRUE</code>. Default is missing. If provided, the data from this environment will be used to perform the estimation.</p>
</td></tr>
<tr><td><code id="feNmlm_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates maximum likelihood models where the conditional expectations are as follows:
</p>
<p>Gaussian likelihood:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=X\beta</code>
</p>

<p>Poisson and Negative Binomial likelihoods:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=\exp(X\beta)</code>
</p>

<p>where in the Negative Binomial there is the parameter <code class="reqn">\theta</code> used to model the variance as <code class="reqn">\mu+\mu^2/\theta</code>, with <code class="reqn">\mu</code> the conditional expectation.
Logit likelihood:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=\frac{\exp(X\beta)}{1+\exp(X\beta)}</code>
</p>

<p>When there are one or more fixed-effects, the conditional expectation can be written as:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X) = h(X\beta+\sum_{k}\sum_{m}\gamma_{m}^{k}\times C_{im}^{k}),</code>
</p>

<p>where <code class="reqn">h(.)</code> is the function corresponding to the likelihood function as shown before. <code class="reqn">C^k</code> is the matrix associated to fixed-effect dimension <code class="reqn">k</code> such that <code class="reqn">C^k_{im}</code> is equal to 1 if observation <code class="reqn">i</code> is of category <code class="reqn">m</code> in the fixed-effect dimension <code class="reqn">k</code> and 0 otherwise.
</p>
<p>When there are non linear in parameters functions, we can schematically split the set of regressors in two:
</p>
<p style="text-align: center;"><code class="reqn">f(X,\beta)=X^1\beta^1 + g(X^2,\beta^2)</code>
</p>

<p>with first a linear term and then a non linear part expressed by the function g. That is, we add a non-linear term to the linear terms (which are <code class="reqn">X*beta</code> and the fixed-effects coefficients). It is always better (more efficient) to put into the argument <code>NL.fml</code> only the non-linear in parameter terms, and add all linear terms in the <code>fml</code> argument.
</p>
<p>To estimate only a non-linear formula without even the intercept, you must exclude the intercept from the linear formula by using, e.g., <code>fml = z~0</code>.
</p>
<p>The over-dispersion parameter of the Negative Binomial family, theta, is capped at 10,000. If theta reaches this high value, it means that there is no overdispersion.
</p>


<h3>Value</h3>

<p>A <code>fixest</code> object. Note that <code>fixest</code> objects contain many elements and most of them are for internal use, they are presented here only for information. To access them, it is safer to use the user-level methods (e.g. <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>, <code><a href="#topic+resid.fixest">resid.fixest</a></code>, etc) or functions (like for instance <code><a href="#topic+fitstat">fitstat</a></code> to access any fit statistic).
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>The named vector of coefficients.</p>
</td></tr>
<tr><td><code>coeftable</code></td>
<td>
<p>The table of the coefficients with their standard errors, z-values and p-values.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The loglikelihood.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of iterations of the algorithm.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code>nparams</code></td>
<td>
<p>The number of parameters of the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call.</p>
</td></tr>
<tr><td><code>fml</code></td>
<td>
<p>The linear formula of the call.</p>
</td></tr>
<tr><td><code>fml_all</code></td>
<td>
<p>A list containing different parts of the formula. Always contain the linear formula. Then, if relevant: <code>fixef</code>: the fixed-effects; <code>NL</code>: the non linear part of the formula.</p>
</td></tr>
<tr><td><code>ll_null</code></td>
<td>
<p>Log-likelihood of the null model (i.e. with the intercept only).</p>
</td></tr>
<tr><td><code>pseudo_r2</code></td>
<td>
<p>The adjusted pseudo R2.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>The convergence message from the optimization procedures.</p>
</td></tr>
<tr><td><code>sq.cor</code></td>
<td>
<p>Squared correlation between the dependent variable and the expected predictor (i.e. fitted.values) obtained by the estimation.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian of the parameters.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values are the expected value of the dependent variable for the fitted model: that is <code class="reqn">E(Y|X)</code>.</p>
</td></tr>
<tr><td><code>cov.iid</code></td>
<td>
<p>The variance-covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The standard-error of the parameters.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>The matrix of the scores (first derivative for each observation).</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The ML family that was used for the estimation.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The difference between the dependent variable and the expected predictor.</p>
</td></tr>
<tr><td><code>sumFE</code></td>
<td>
<p>The sum of the fixed-effects for each observation.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>The offset formula.</p>
</td></tr>
<tr><td><code>NL.fml</code></td>
<td>
<p>The nonlinear formula of the call.</p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p>Whether the coefficients were upper or lower bounded. &ndash; This can only be the case when a non-linear formula is included and the arguments 'lower' or 'upper' are provided.</p>
</td></tr>
<tr><td><code>isBounded</code></td>
<td>
<p>The logical vector that gives for each coefficient whether it was bounded or not. This can only be the case when a non-linear formula is included and the arguments 'lower' or 'upper' are provided.</p>
</td></tr>
<tr><td><code>fixef_vars</code></td>
<td>
<p>The names of each fixed-effect dimension.</p>
</td></tr>
<tr><td><code>fixef_id</code></td>
<td>
<p>The list (of length the number of fixed-effects) of the fixed-effects identifiers for each observation.</p>
</td></tr>
<tr><td><code>fixef_sizes</code></td>
<td>
<p>The size of each fixed-effect (i.e. the number of unique identifierfor each fixed-effect dimension).</p>
</td></tr>
<tr><td><code>obs_selection</code></td>
<td>
<p>(When relevant.) List containing vectors of integers. It represents the sequential selection of observation vis a vis the original data set.</p>
</td></tr>
<tr><td><code>fixef_removed</code></td>
<td>
<p>In the case there were fixed-effects and some observations were removed because of only 0/1 outcome within a fixed-effect, it gives the list (for each fixed-effect dimension) of the fixed-effect identifiers that were removed.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>In the case of a negative binomial estimation: the overdispersion parameter.</p>
</td></tr>
</table>
<p>@seealso
See also <code><a href="#topic+summary.fixest">summary.fixest</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> to extract the fixed-effects coefficients, and the function <code><a href="#topic+etable">etable</a></code> to visualize the results of multiple estimations.
</p>
<p>And other estimation methods: <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+feglm">fepois</a></code>, <code><a href="#topic+femlm">fenegbin</a></code>.
</p>


<h3>Lagging variables</h3>

<p>To use leads/lags of variables in the estimation, you can: i) either provide the argument <code>panel.id</code>, ii) either set your data set as a panel with the function <code><a href="#topic+panel">panel</a></code>, <code><a href="#topic+l">f</a></code> and <code><a href="#topic+l">d</a></code>.
</p>
<p>You can provide several leads/lags/differences at once: e.g. if your formula is equal to <code>f(y) ~ l(x, -1:1)</code>, it means that the dependent variable is equal to the lead of <code>y</code>, and you will have as explanatory variables the lead of <code>x1</code>, <code>x1</code> and the lag of <code>x1</code>. See the examples in function <code><a href="#topic+l">l</a></code> for more details.
</p>


<h3>Interactions</h3>

<p>You can interact a numeric variable with a &quot;factor-like&quot; variable by using <code>i(factor_var, continuous_var, ref)</code>, where <code>continuous_var</code> will be interacted with each value of <code>factor_var</code> and the argument <code>ref</code> is a value of <code>factor_var</code> taken as a reference (optional).
</p>
<p>Using this specific way to create interactions leads to a different display of the interacted values in <code><a href="#topic+etable">etable</a></code>. See examples.
</p>
<p>It is important to note that <em>if you do not care about the standard-errors of the interactions</em>, then you can add interactions in the fixed-effects part of the formula, it will be incomparably faster (using the syntax <code>factor_var[continuous_var]</code>, as explained in the section &ldquo;Varying slopes&rdquo;).
</p>
<p>The function <code><a href="#topic+i">i</a></code> has in fact more arguments, please see details in its associated help page.
</p>


<h3>On standard-errors</h3>

<p>Standard-errors can be computed in different ways, you can use the arguments <code>se</code> and <code>ssc</code> in <code><a href="#topic+summary.fixest">summary.fixest</a></code> to define how to compute them. By default, in the presence of fixed-effects, standard-errors are automatically clustered.
</p>
<p>The following vignette: <a href="https://lrberge.github.io/fixest/articles/standard_errors.html">On standard-errors</a> describes in details how the standard-errors are computed in <code>fixest</code> and how you can replicate standard-errors from other software.
</p>
<p>You can use the functions <code><a href="#topic+setFixest_vcov">setFixest_vcov</a></code> and <code><a href="#topic+ssc">setFixest_ssc</a></code> to permanently set the way the standard-errors are computed.
</p>


<h3>Multiple estimations</h3>

<p>Multiple estimations can be performed at once, they just have to be specified in the formula. Multiple estimations yield a <code>fixest_multi</code> object which is &lsquo;kind of&rsquo; a list of all the results but includes specific methods to access the results in a handy way. Please have a look at the dedicated vignette: <a href="https://lrberge.github.io/fixest/articles/multiple_estimations.html">Multiple estimations</a>.
</p>
<p>To include multiple dependent variables, wrap them in <code>c()</code> (<code>list()</code> also works). For instance <code>fml = c(y1, y2) ~ x1</code> would estimate the model <code>fml = y1 ~ x1</code> and then the model <code>fml = y2 ~ x1</code>.
</p>
<p>To include multiple independent variables, you need to use the stepwise functions. There are 4 stepwise functions: <code>sw</code>, <code>sw0</code>, <code>csw</code>, <code>csw0</code>, and <code>mvsw</code>. Of course <code>sw</code> stands for stepwise, and <code>csw</code> for cumulative stepwise. Finally <code>mvsw</code> is a bit special, it stands for multiverse stepwise. Let's explain that.
Assume you have the following formula: <code>fml = y ~ x1 + sw(x2, x3)</code>. The stepwise function <code>sw</code> will estimate the following two models: <code>y ~ x1 + x2</code> and <code>y ~ x1 + x3</code>. That is, each element in <code>sw()</code> is sequentially, and separately, added to the formula. Would have you used <code>sw0</code> in lieu of <code>sw</code>, then the model <code>y ~ x1</code> would also have been estimated. The <code>0</code> in the name means that the model without any stepwise element also needs to be estimated.
The prefix <code>c</code> means cumulative: each stepwise element is added to the next. That is, <code>fml = y ~ x1 + csw(x2, x3)</code> would lead to the following models <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>. The <code>0</code> has the same meaning and would also lead to the model without the stepwise elements to be estimated: in other words, <code>fml = y ~ x1 + csw0(x2, x3)</code> leads to the following three models: <code>y ~ x1</code>, <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>.
Finally <code>mvsw</code> will add, in a stepwise fashion all possible combinations of the variables in its arguments. For example <code>mvsw(x1, x2, x3)</code> is equivalent to <code>sw0(x1, x2, x3, x1 + x2, x1 + x3, x2 + x3, x1 + x2 + x3)</code>. The number of models to estimate grows at a factorial rate: so be cautious!
</p>
<p>Multiple independent variables can be combined with multiple dependent variables, as in <code>fml = c(y1, y2) ~ cw(x1, x2, x3)</code> which would lead to 6 estimations. Multiple estimations can also be combined to split samples (with the arguments <code>split</code>, <code>fsplit</code>).
</p>
<p>You can also add fixed-effects in a stepwise fashion. Note that you cannot perform stepwise estimations on the IV part of the formula (<code>feols</code> only).
</p>
<p>If NAs are present in the sample, to avoid too many messages, only NA removal concerning the variables common to all estimations is reported.
</p>
<p>A note on performance. The feature of multiple estimations has been highly optimized for <code>feols</code>, in particular in the presence of fixed-effects. It is faster to estimate multiple models using the formula rather than with a loop. For non-<code>feols</code> models using the formula is roughly similar to using a loop performance-wise.
</p>


<h3>Argument sliding</h3>

<p>When the data set has been set up globally using <code><a href="#topic+setFixest_estimation">setFixest_estimation</a></code><code>(data = data_set)</code>, the argument <code>vcov</code> can be used implicitly. This means that calls such as <code>feols(y ~ x, "HC1")</code>, or <code>feols(y ~ x, ~id)</code>, are valid: i) the data is automatically deduced from the global settings, and ii) the <code>vcov</code> is deduced to be the second argument.
</p>


<h3>Piping</h3>

<p>Although the argument 'data' is placed in second position, the data can be piped to the estimation functions. For example, with R &gt;= 4.1, <code>mtcars |&gt; feols(mpg ~ cyl)</code> works as <code>feols(mpg ~ cyl, mtcars)</code>.
</p>


<h3>Tricks to estimate multiple LHS</h3>

<p>To use multiple dependent variables in <code>fixest</code> estimations, you need to include them in a vector: like in <code>c(y1, y2, y3)</code>.
</p>
<p>First, if names are stored in a vector, they can readily be inserted in a formula to perform multiple estimations using the dot square bracket operator. For instance if <code>my_lhs = c("y1", "y2")</code>, calling <code>fixest</code> with, say <code>feols(.[my_lhs] ~ x1, etc)</code> is equivalent to using <code>feols(c(y1, y2) ~ x1, etc)</code>. Beware that this is a special feature unique to the <em>left-hand-side</em> of <code>fixest</code> estimations (the default behavior of the DSB operator is to aggregate with sums, see <code><a href="#topic+xpd">xpd</a></code>).
</p>
<p>Second, you can use a regular expression to grep the left-hand-sides on the fly. When the <code>..("regex")</code> feature is used naked on the LHS, the variables grepped are inserted into <code>c()</code>. For example <code style="white-space: pre;">&#8288;..("Pe") ~ Sepal.Length, iris&#8288;</code> is equivalent to <code style="white-space: pre;">&#8288;c(Petal.Length, Petal.Width) ~ Sepal.Length, iris&#8288;</code>. Beware that this is a special feature unique to the <em>left-hand-side</em> of <code>fixest</code> estimations (the default behavior of <code>..("regex")</code> is to aggregate with sums, see <code><a href="#topic+xpd">xpd</a></code>).
</p>


<h3>Dot square bracket operator in formulas</h3>

<p>In a formula, the dot square bracket (DSB) operator can: i) create manifold variables at once, or ii) capture values from the current environment and put them verbatim in the formula.
</p>
<p>Say you want to include the variables <code>x1</code> to <code>x3</code> in your formula. You can use <code>xpd(y ~ x.[1:3])</code> and you'll get <code>y ~ x1 + x2 + x3</code>.
</p>
<p>To summon values from the environment, simply put the variable in square brackets. For example: <code>for(i in 1:3) xpd(y.[i] ~ x)</code> will create the formulas <code>y1 ~ x</code> to <code>y3 ~ x</code> depending on the value of <code>i</code>.
</p>
<p>You can include a full variable from the environment in the same way: <code>for(y in c("a", "b")) xpd(.[y] ~ x)</code> will create the two formulas <code>a ~ x</code> and <code>b ~ x</code>.
</p>
<p>The DSB can even be used within variable names, but then the variable must be nested in character form. For example <code>y ~ .["x.[1:2]_sq"]</code> will create <code>y ~ x1_sq + x2_sq</code>. Using the character form is important to avoid a formula parsing error. Double quotes must be used. Note that the character string that is nested will be parsed with the function <code><a href="#topic+dsb">dsb</a></code>, and thus it will return a vector.
</p>
<p>By default, the DSB operator expands vectors into sums. You can add a comma, like in <code>.[, x]</code>, to expand with commas&ndash;the content can then be used within functions. For instance: <code>c(x.[, 1:2])</code> will create <code>c(x1, x2)</code> (and <em>not</em> <code>c(x1 + x2)</code>).
</p>
<p>In all <code>fixest</code> estimations, this special parsing is enabled, so you don't need to use <code>xpd</code>.
</p>
<p>One-sided formulas can be expanded with the DSB operator: let <code>x = ~sepal + petal</code>, then <code>xpd(y ~ .[x])</code> leads to <code>color ~ sepal + petal</code>.
</p>
<p>You can even use multiple square brackets within a single variable, but then the use of nesting is required. For example, the following <code>xpd(y ~ .[".[letters[1:2]]_.[1:2]"])</code> will create <code>y ~ a_1 + b_2</code>. Remember that the nested character string is parsed with <code><a href="#topic+dsb">dsb</a></code>, which explains this behavior.
</p>
<p>When the element to be expanded i) is equal to the empty string or, ii) is of length 0, it is replaced with a neutral element, namely <code>1</code>. For example, <code style="white-space: pre;">&#8288;x = "" ; xpd(y ~ .[x])&#8288;</code> leads to <code>y ~ 1</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>References</h3>

<p>Berge, Laurent, 2018, &quot;Efficient estimation of maximum likelihood models with multiple fixed-effects: the R package FENmlm.&quot; CREA Discussion Papers, 13 (<a href="https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf"></a>).
</p>
<p>For models with multiple fixed-effects:
</p>
<p>Gaure, Simen, 2013, &quot;OLS with multiple high dimensional category variables&quot;, Computational Statistics &amp; Data Analysis 66 pp. 8&ndash;18
</p>
<p>On the unconditionnal Negative Binomial model:
</p>
<p>Allison, Paul D and Waterman, Richard P, 2002, &quot;Fixed-Effects Negative Binomial Regression Models&quot;, Sociological Methodology 32(1) pp. 247&ndash;265
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This section covers only non-linear in parameters examples
# For linear relationships: use femlm or feglm instead

# Generating data for a simple example
set.seed(1)
n = 100
x = rnorm(n, 1, 5)**2
y = rnorm(n, -1, 5)**2
z1 = rpois(n, x*y) + rpois(n, 2)
base = data.frame(x, y, z1)

# Estimating a 'linear' relation:
est1_L = femlm(z1 ~ log(x) + log(y), base)
# Estimating the same 'linear' relation using a 'non-linear' call
est1_NL = feNmlm(z1 ~ 1, base, NL.fml = ~a*log(x)+b*log(y), NL.start = list(a=0, b=0))
# we compare the estimates with the function esttable (they are identical)
etable(est1_L, est1_NL)

# Now generating a non-linear relation (E(z2) = x + y + 1):
z2 = rpois(n, x + y) + rpois(n, 1)
base$z2 = z2

# Estimation using this non-linear form
est2_NL = feNmlm(z2 ~ 0, base, NL.fml = ~log(a*x + b*y),
               NL.start = 2, lower = list(a=0, b=0))
# we can't estimate this relation linearily
# =&gt; closest we can do:
est2_L = femlm(z2 ~ log(x) + log(y), base)

# Difference between the two models:
etable(est2_L, est2_NL)

# Plotting the fits:
plot(x, z2, pch = 18)
points(x, fitted(est2_L), col = 2, pch = 1)
points(x, fitted(est2_NL), col = 4, pch = 2)


</code></pre>

<hr>
<h2 id='feols'>Fixed-effects OLS estimation</h2><span id='topic+feols'></span><span id='topic+feols.fit'></span>

<h3>Description</h3>

<p>Estimates OLS with any number of fixed-effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feols(
  fml,
  data,
  vcov,
  weights,
  offset,
  subset,
  split,
  fsplit,
  split.keep,
  split.drop,
  cluster,
  se,
  ssc,
  panel.id,
  fixef,
  fixef.rm = "none",
  fixef.tol = 1e-06,
  fixef.iter = 10000,
  collin.tol = 1e-10,
  nthreads = getFixest_nthreads(),
  lean = FALSE,
  verbose = 0,
  warn = TRUE,
  notes = getFixest_notes(),
  only.coef = FALSE,
  combine.quick,
  demeaned = FALSE,
  mem.clean = FALSE,
  only.env = FALSE,
  env,
  ...
)

feols.fit(
  y,
  X,
  fixef_df,
  vcov,
  offset,
  split,
  fsplit,
  split.keep,
  split.drop,
  cluster,
  se,
  ssc,
  weights,
  subset,
  fixef.rm = "perfect",
  fixef.tol = 1e-06,
  fixef.iter = 10000,
  collin.tol = 1e-10,
  nthreads = getFixest_nthreads(),
  lean = FALSE,
  warn = TRUE,
  notes = getFixest_notes(),
  mem.clean = FALSE,
  verbose = 0,
  only.env = FALSE,
  only.coef = FALSE,
  env,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feols_+3A_fml">fml</code></td>
<td>
<p>A formula representing the relation to be estimated. For example: <code>fml = z~x+y</code>. To include fixed-effects, insert them in this formula using a pipe: e.g. <code>fml = z~x+y | fe_1+fe_2</code>. You can combine two fixed-effects with <code>^</code>: e.g. <code>fml = z~x+y|fe_1^fe_2</code>, see details. You can also use variables with varying slopes using square brackets: e.g. in <code>fml = z~y|fe_1[x] + fe_2</code>, see details. To add IVs, insert the endogenous vars./instruments after a pipe, like in <code>y ~ x | x_endo1 + x_endo2 ~ x_inst1 + x_inst2</code>. Note that it should always be the last element, see details. Multiple estimations can be performed at once: for multiple dep. vars, wrap them in <code>c()</code>: ex <code>c(y1, y2)</code>. For multiple indep. vars, use the stepwise functions: ex <code>x1 + csw(x2, x3)</code>. The formula <code>fml = c(y1, y2) ~ x1 + cw0(x2, x3)</code> leads to 6 estimation, see details. Square brackets starting with a dot can be used to call global variables: <code>y.[i] ~ x.[1:2]</code> will lead to <code>y3 ~ x1 + x2</code> if <code>i</code> is equal to 3 in the current environment (see details in <code><a href="#topic+xpd">xpd</a></code>).</p>
</td></tr>
<tr><td><code id="feols_+3A_data">data</code></td>
<td>
<p>A data.frame containing the necessary variables to run the model. The variables of the non-linear right hand side of the formula are identified with this <code>data.frame</code> names. Can also be a matrix.</p>
</td></tr>
<tr><td><code id="feols_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="feols_+3A_weights">weights</code></td>
<td>
<p>A formula or a numeric vector. Each observation can be weighted, the weights must be greater than 0. If equal to a formula, it should be one-sided: for example <code>~ var_weight</code>.</p>
</td></tr>
<tr><td><code id="feols_+3A_offset">offset</code></td>
<td>
<p>A formula or a numeric vector. An offset can be added to the estimation. If equal to a formula, it should be of the form (for example) <code>~0.5*x**2</code>. This offset is linearly added to the elements of the main formula 'fml'.</p>
</td></tr>
<tr><td><code id="feols_+3A_subset">subset</code></td>
<td>
<p>A vector (logical or numeric) or a one-sided formula. If provided, then the estimation will be performed only on the observations defined by this argument.</p>
</td></tr>
<tr><td><code id="feols_+3A_split">split</code></td>
<td>
<p>A one sided formula representing a variable (eg <code>split = ~var</code>) or a vector. If provided, the sample is split according to the variable and one estimation is performed for each value of that variable. If you also want to include the estimation for the full sample, use the argument <code>fsplit</code> instead. You can use the special operators <code style="white-space: pre;">&#8288;%keep%&#8288;</code> and <code style="white-space: pre;">&#8288;%drop%&#8288;</code> to select only a subset of values for which to split the sample. E.g. <code>split = ~var %keep% c("v1", "v2")</code> will split the sample only according to the values <code>v1</code> and <code>v2</code> of the variable <code>var</code>; it is equivalent to supplying the argument <code>split.keep = c("v1", "v2")</code>. By default there is partial matching on each value, you can trigger a regular expression evaluation by adding a <code>'@'</code> first, as in: <code>~var %drop% "@^v[12]"</code> which will drop values starting with <code>"v1"</code> or <code>"v2"</code> (of course you need to know regexes!).</p>
</td></tr>
<tr><td><code id="feols_+3A_fsplit">fsplit</code></td>
<td>
<p>A one sided formula representing a variable (eg <code>split = ~var</code>) or a vector. If provided, the sample is split according to the variable and one estimation is performed for each value of that variable. This argument is the same as split but also includes the full sample as the first estimation. You can use the special operators <code style="white-space: pre;">&#8288;%keep%&#8288;</code> and <code style="white-space: pre;">&#8288;%drop%&#8288;</code> to select only a subset of values for which to split the sample. E.g. <code>split = ~var %keep% c("v1", "v2")</code> will split the sample only according to the values <code>v1</code> and <code>v2</code> of the variable <code>var</code>; it is equivalent to supplying the argument <code>split.keep = c("v1", "v2")</code>. By default there is partial matching on each value, you can trigger a regular expression evaluation by adding an <code>'@'</code> first, as in: <code>~var %drop% "@^v[12]"</code> which will drop values starting with <code>"v1"</code> or <code>"v2"</code> (of course you need to know regexes!).</p>
</td></tr>
<tr><td><code id="feols_+3A_split.keep">split.keep</code></td>
<td>
<p>A character vector. Only used when <code>split</code>, or <code>fsplit</code>, is supplied. If provided, then the sample will be split only on the values of <code>split.keep</code>. The values in <code>split.keep</code> will be partially matched to the values of <code>split</code>. To enable regular expressions, you need to add an <code>'@'</code> first. For example <code>split.keep = c("v1", "@other|var")</code> will keep only the value in <code>split</code> partially matched by <code>"v1"</code> or the values containing <code>"other"</code> or <code>"var"</code>.</p>
</td></tr>
<tr><td><code id="feols_+3A_split.drop">split.drop</code></td>
<td>
<p>A character vector. Only used when <code>split</code>, or <code>fsplit</code>, is supplied. If provided, then the sample will be split only on the values that are not in <code>split.drop</code>. The values in <code>split.drop</code> will be partially matched to the values of <code>split</code>. To enable regular expressions, you need to add an <code>'@'</code> first. For example <code>split.drop = c("v1", "@other|var")</code> will drop only the value in <code>split</code> partially matched by <code>"v1"</code> or the values containing <code>"other"</code> or <code>"var"</code>.</p>
</td></tr>
<tr><td><code id="feols_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="feols_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="feols_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="feols_+3A_panel.id">panel.id</code></td>
<td>
<p>The panel identifiers. Can either be: i) a one sided formula (e.g. <code>panel.id = ~id+time</code>), ii) a character vector of length 2 (e.g. <code>panel.id=c('id', 'time')</code>, or iii) a character scalar of two variables separated by a comma (e.g. <code>panel.id='id,time'</code>). Note that you can combine variables with <code>^</code> only inside formulas (see the dedicated section in <code><a href="#topic+feols">feols</a></code>).</p>
</td></tr>
<tr><td><code id="feols_+3A_fixef">fixef</code></td>
<td>
<p>Character vector. The names of variables to be used as fixed-effects. These variables should contain the identifier of each observation (e.g., think of it as a panel identifier). Note that the recommended way to include fixed-effects is to insert them directly in the formula.</p>
</td></tr>
<tr><td><code id="feols_+3A_fixef.rm">fixef.rm</code></td>
<td>
<p>Can be equal to &quot;perfect&quot; (default), &quot;singleton&quot;, &quot;both&quot; or &quot;none&quot;. Controls which observations are to be removed. If &quot;perfect&quot;, then observations having a fixed-effect with perfect fit (e.g. only 0 outcomes in Poisson estimations) will be removed. If &quot;singleton&quot;, all observations for which a fixed-effect appears only once will be removed. The meaning of &quot;both&quot; and &quot;none&quot; is direct.</p>
</td></tr>
<tr><td><code id="feols_+3A_fixef.tol">fixef.tol</code></td>
<td>
<p>Precision used to obtain the fixed-effects. Defaults to <code>1e-5</code>. It corresponds to the maximum absolute difference allowed between two coefficients of successive iterations. Argument <code>fixef.tol</code> cannot be lower than <code>10000*.Machine$double.eps</code>. Note that this parameter is dynamically controlled by the algorithm.</p>
</td></tr>
<tr><td><code id="feols_+3A_fixef.iter">fixef.iter</code></td>
<td>
<p>Maximum number of iterations in fixed-effects algorithm (only in use for 2+ fixed-effects). Default is 10000.</p>
</td></tr>
<tr><td><code id="feols_+3A_collin.tol">collin.tol</code></td>
<td>
<p>Numeric scalar, default is <code>1e-10</code>. Threshold deciding when variables should be considered collinear and subsequently removed from the estimation. Higher values means more variables will be removed (if there is presence of collinearity). One signal of presence of collinearity is t-stats that are extremely low (for instance when t-stats &lt; 1e-3).</p>
</td></tr>
<tr><td><code id="feols_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than, or equal to, the maximum number of threads; b) 0: meaning all available threads will be used; c) a number strictly between 0 and 1 which represents the fraction of all threads to use. The default is to use 50% of all threads. You can set permanently the number of threads used within this package using the function <code><a href="#topic+setFixest_nthreads">setFixest_nthreads</a></code>.</p>
</td></tr>
<tr><td><code id="feols_+3A_lean">lean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> then all large objects are removed from the returned result: this will save memory but will block the possibility to use many methods. It is recommended to use the arguments <code>se</code> or <code>cluster</code> to obtain the appropriate standard-errors at estimation time, since obtaining different SEs won't be possible afterwards.</p>
</td></tr>
<tr><td><code id="feols_+3A_verbose">verbose</code></td>
<td>
<p>Integer. Higher values give more information. In particular, it can detail the number of iterations in the demeaning algorithm (the first number is the left-hand-side, the other numbers are the right-hand-side variables).</p>
</td></tr>
<tr><td><code id="feols_+3A_warn">warn</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether warnings should be displayed (concerns warnings relating to convergence state).</p>
</td></tr>
<tr><td><code id="feols_+3A_notes">notes</code></td>
<td>
<p>Logical. By default, two notes are displayed: when NAs are removed (to show additional information) and when some observations are removed because of collinearity. To avoid displaying these messages, you can set <code>notes = FALSE</code>. You can remove these messages permanently by using <code>setFixest_notes(FALSE)</code>.</p>
</td></tr>
<tr><td><code id="feols_+3A_only.coef">only.coef</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then only the estimated coefficients are returned. Note that the length of the vector returned is always the length of the number of coefficients to be estimated: this means that the variables found to be collinear are returned with an NA value.</p>
</td></tr>
<tr><td><code id="feols_+3A_combine.quick">combine.quick</code></td>
<td>
<p>Logical. When you combine different variables to transform them into a single fixed-effects you can do e.g. <code>y ~ x | paste(var1, var2)</code>. The algorithm provides a shorthand to do the same operation: <code>y ~ x | var1^var2</code>. Because pasting variables is a costly operation, the internal algorithm may use a numerical trick to hasten the process. The cost of doing so is that you lose the labels. If you are interested in getting the value of the fixed-effects coefficients after the estimation, you should use <code>combine.quick = FALSE</code>. By default it is equal to <code>FALSE</code> if the number of observations is lower than 50,000, and to <code>TRUE</code> otherwise.</p>
</td></tr>
<tr><td><code id="feols_+3A_demeaned">demeaned</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only used in the presence of fixed-effects: should the centered variables be returned? If <code>TRUE</code>, it creates the items <code>y_demeaned</code> and <code>X_demeaned</code>.</p>
</td></tr>
<tr><td><code id="feols_+3A_mem.clean">mem.clean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only to be used if the data set is large compared to the available RAM. If <code>TRUE</code> then intermediary objects are removed as much as possible and <code><a href="base.html#topic+gc">gc</a></code> is run before each substantial C++ section in the internal code to avoid memory issues.</p>
</td></tr>
<tr><td><code id="feols_+3A_only.env">only.env</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then only the environment used to make the estimation is returned.</p>
</td></tr>
<tr><td><code id="feols_+3A_env">env</code></td>
<td>
<p>(Advanced users.) A <code>fixest</code> environment created by a <code>fixest</code> estimation with <code>only.env = TRUE</code>. Default is missing. If provided, the data from this environment will be used to perform the estimation.</p>
</td></tr>
<tr><td><code id="feols_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="feols_+3A_y">y</code></td>
<td>
<p>Numeric vector/matrix/data.frame of the dependent variable(s). Multiple dependent variables will return a <code>fixest_multi</code> object.</p>
</td></tr>
<tr><td><code id="feols_+3A_x">X</code></td>
<td>
<p>Numeric matrix of the regressors.</p>
</td></tr>
<tr><td><code id="feols_+3A_fixef_df">fixef_df</code></td>
<td>
<p>Matrix/data.frame of the fixed-effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method used to demean each variable along the fixed-effects is based on Berge (2018), since this is the same problem to solve as for the Gaussian case in a ML setup.
</p>


<h3>Value</h3>

<p>A <code>fixest</code> object. Note that <code>fixest</code> objects contain many elements and most of them are for internal use, they are presented here only for information. To access them, it is safer to use the user-level methods (e.g. <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>, <code><a href="#topic+resid.fixest">resid.fixest</a></code>, etc) or functions (like for instance <code><a href="#topic+fitstat">fitstat</a></code> to access any fit statistic).
</p>
<table>
<tr><td><code>nobs</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code>fml</code></td>
<td>
<p>The linear formula of the call.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used to estimate the model.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The family used to estimate the model.</p>
</td></tr>
<tr><td><code>fml_all</code></td>
<td>
<p>A list containing different parts of the formula. Always contain the linear formula. Then depending on the cases: <code>fixef</code>: the fixed-effects, <code>iv</code>: the IV part of the formula.</p>
</td></tr>
<tr><td><code>fixef_vars</code></td>
<td>
<p>The names of each fixed-effect dimension.</p>
</td></tr>
<tr><td><code>fixef_id</code></td>
<td>
<p>The list (of length the number of fixed-effects) of the fixed-effects identifiers for each observation.</p>
</td></tr>
<tr><td><code>fixef_sizes</code></td>
<td>
<p>The size of each fixed-effect (i.e. the number of unique identifierfor each fixed-effect dimension).</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>The named vector of estimated coefficients.</p>
</td></tr>
<tr><td><code>multicol</code></td>
<td>
<p>Logical, if multicollinearity was found.</p>
</td></tr>
<tr><td><code>coeftable</code></td>
<td>
<p>The table of the coefficients with their standard errors, z-values and p-values.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The loglikelihood.</p>
</td></tr>
<tr><td><code>ssr_null</code></td>
<td>
<p>Sum of the squared residuals of the null model (containing only with the intercept).</p>
</td></tr>
<tr><td><code>ssr_fe_only</code></td>
<td>
<p>Sum of the squared residuals of the model estimated with fixed-effects only.</p>
</td></tr>
<tr><td><code>ll_null</code></td>
<td>
<p>The log-likelihood of the null model (containing only with the intercept).</p>
</td></tr>
<tr><td><code>ll_fe_only</code></td>
<td>
<p>The log-likelihood of the model estimated with fixed-effects only.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>The linear predictors.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The residuals (y minus the fitted values).</p>
</td></tr>
<tr><td><code>sq.cor</code></td>
<td>
<p>Squared correlation between the dependent variable and the expected predictor (i.e. fitted.values) obtained by the estimation.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian of the parameters.</p>
</td></tr>
<tr><td><code>cov.iid</code></td>
<td>
<p>The variance-covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The standard-error of the parameters.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>The matrix of the scores (first derivative for each observation).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The difference between the dependent variable and the expected predictor.</p>
</td></tr>
<tr><td><code>sumFE</code></td>
<td>
<p>The sum of the fixed-effects coefficients for each observation.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>(When relevant.) The offset formula.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>(When relevant.) The weights formula.</p>
</td></tr>
<tr><td><code>obs_selection</code></td>
<td>
<p>(When relevant.) List containing vectors of integers. It represents the sequential selection of observation vis a vis the original data set.</p>
</td></tr>
<tr><td><code>collin.var</code></td>
<td>
<p>(When relevant.) Vector containing the variables removed because of collinearity.</p>
</td></tr>
<tr><td><code>collin.coef</code></td>
<td>
<p>(When relevant.) Vector of coefficients, where the values of the variables removed because of collinearity are NA.</p>
</td></tr>
<tr><td><code>collin.min_norm</code></td>
<td>
<p>The minimal diagonal value of the Cholesky decomposition. Small values indicate possible presence collinearity.</p>
</td></tr>
<tr><td><code>y_demeaned</code></td>
<td>
<p>Only when <code>demeaned = TRUE</code>: the centered dependent variable.</p>
</td></tr>
<tr><td><code>X_demeaned</code></td>
<td>
<p>Only when <code>demeaned = TRUE</code>: the centered explanatory variable.</p>
</td></tr>
</table>


<h3>Combining the fixed-effects</h3>

<p>You can combine two variables to make it a new fixed-effect using <code>^</code>. The syntax is as follows: <code>fe_1^fe_2</code>. Here you created a new variable which is the combination of the two variables fe_1 and fe_2. This is identical to doing <code>paste0(fe_1, "_", fe_2)</code> but more convenient.
</p>
<p>Note that pasting is a costly operation, especially for large data sets. Thus, the internal algorithm uses a numerical trick which is fast, but the drawback is that the identity of each observation is lost (i.e. they are now equal to a meaningless number instead of being equal to <code>paste0(fe_1, "_", fe_2)</code>). These &ldquo;identities&rdquo; are useful only if you're interested in the value of the fixed-effects (that you can extract with <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>). If you're only interested in coefficients of the variables, it doesn't matter. Anyway, you can use <code>combine.quick = FALSE</code> to tell the internal algorithm to use <code>paste</code> instead of the numerical trick. By default, the numerical trick is performed only for large data sets.
</p>


<h3>Varying slopes</h3>

<p>You can add variables with varying slopes in the fixed-effect part of the formula. The syntax is as follows: <code>fixef_var[var1, var2]</code>. Here the variables var1 and var2 will be with varying slopes (one slope per value in fixef_var) and the fixed-effect fixef_var will also be added.
</p>
<p>To add only the variables with varying slopes and not the fixed-effect, use double square brackets: <code>fixef_var[[var1, var2]]</code>.
</p>
<p>In other words:
</p>

<ul>
<li> <p><code>fixef_var[var1, var2]</code> is equivalent to <code>fixef_var + fixef_var[[var1]] + fixef_var[[var2]]</code>
</p>
</li>
<li> <p><code>fixef_var[[var1, var2]]</code> is equivalent to <code>fixef_var[[var1]] + fixef_var[[var2]]</code>
</p>
</li></ul>

<p>In general, for convergence reasons, it is recommended to always add the fixed-effect and avoid using only the variable with varying slope (i.e. use single square brackets).
</p>


<h3>Lagging variables</h3>

<p>To use leads/lags of variables in the estimation, you can: i) either provide the argument <code>panel.id</code>, ii) either set your data set as a panel with the function <code><a href="#topic+panel">panel</a></code>, <code><a href="#topic+l">f</a></code> and <code><a href="#topic+l">d</a></code>.
</p>
<p>You can provide several leads/lags/differences at once: e.g. if your formula is equal to <code>f(y) ~ l(x, -1:1)</code>, it means that the dependent variable is equal to the lead of <code>y</code>, and you will have as explanatory variables the lead of <code>x1</code>, <code>x1</code> and the lag of <code>x1</code>. See the examples in function <code><a href="#topic+l">l</a></code> for more details.
</p>


<h3>Interactions</h3>

<p>You can interact a numeric variable with a &quot;factor-like&quot; variable by using <code>i(factor_var, continuous_var, ref)</code>, where <code>continuous_var</code> will be interacted with each value of <code>factor_var</code> and the argument <code>ref</code> is a value of <code>factor_var</code> taken as a reference (optional).
</p>
<p>Using this specific way to create interactions leads to a different display of the interacted values in <code><a href="#topic+etable">etable</a></code>. See examples.
</p>
<p>It is important to note that <em>if you do not care about the standard-errors of the interactions</em>, then you can add interactions in the fixed-effects part of the formula, it will be incomparably faster (using the syntax <code>factor_var[continuous_var]</code>, as explained in the section &ldquo;Varying slopes&rdquo;).
</p>
<p>The function <code><a href="#topic+i">i</a></code> has in fact more arguments, please see details in its associated help page.
</p>


<h3>On standard-errors</h3>

<p>Standard-errors can be computed in different ways, you can use the arguments <code>se</code> and <code>ssc</code> in <code><a href="#topic+summary.fixest">summary.fixest</a></code> to define how to compute them. By default, in the presence of fixed-effects, standard-errors are automatically clustered.
</p>
<p>The following vignette: <a href="https://lrberge.github.io/fixest/articles/standard_errors.html">On standard-errors</a> describes in details how the standard-errors are computed in <code>fixest</code> and how you can replicate standard-errors from other software.
</p>
<p>You can use the functions <code><a href="#topic+setFixest_vcov">setFixest_vcov</a></code> and <code><a href="#topic+ssc">setFixest_ssc</a></code> to permanently set the way the standard-errors are computed.
</p>


<h3>Instrumental variables</h3>

<p>To estimate two stage least square regressions, insert the relationship between the endogenous regressor(s) and the instruments in a formula, after a pipe.
</p>
<p>For example, <code>fml = y ~ x1 | x_endo ~ x_inst</code> will use the variables <code>x1</code> and <code>x_inst</code> in the first stage to explain <code>x_endo</code>. Then will use the fitted value of <code>x_endo</code> (which will be named <code>fit_x_endo</code>) and <code>x1</code> to explain <code>y</code>.
To include several endogenous regressors, just use &quot;+&quot;, like in: <code>fml = y ~ x1 | x_endo1 + x_end2 ~ x_inst1 + x_inst2</code>.
</p>
<p>Of course you can still add the fixed-effects, but the IV formula must always come last, like in <code>fml = y ~ x1 | fe1 + fe2 | x_endo ~ x_inst</code>.
</p>
<p>If you want to estimate a model without exogenous variables, use <code>"1"</code> as a placeholder: e.g. <code>fml = y ~ 1 | x_endo + x_inst</code>.
</p>
<p>By default, the second stage regression is returned. You can access the first stage(s) regressions either directly in the slot <code>iv_first_stage</code> (not recommended), or using the argument <code>stage = 1</code> from the function <code><a href="#topic+summary.fixest">summary.fixest</a></code>. For example <code>summary(iv_est, stage = 1)</code> will give the first stage(s). Note that using summary you can display both the second and first stages at the same time using, e.g., <code>stage = 1:2</code> (using <code>2:1</code> would reverse the order).
</p>


<h3>Multiple estimations</h3>

<p>Multiple estimations can be performed at once, they just have to be specified in the formula. Multiple estimations yield a <code>fixest_multi</code> object which is &lsquo;kind of&rsquo; a list of all the results but includes specific methods to access the results in a handy way. Please have a look at the dedicated vignette: <a href="https://lrberge.github.io/fixest/articles/multiple_estimations.html">Multiple estimations</a>.
</p>
<p>To include multiple dependent variables, wrap them in <code>c()</code> (<code>list()</code> also works). For instance <code>fml = c(y1, y2) ~ x1</code> would estimate the model <code>fml = y1 ~ x1</code> and then the model <code>fml = y2 ~ x1</code>.
</p>
<p>To include multiple independent variables, you need to use the stepwise functions. There are 4 stepwise functions: <code>sw</code>, <code>sw0</code>, <code>csw</code>, <code>csw0</code>, and <code>mvsw</code>. Of course <code>sw</code> stands for stepwise, and <code>csw</code> for cumulative stepwise. Finally <code>mvsw</code> is a bit special, it stands for multiverse stepwise. Let's explain that.
Assume you have the following formula: <code>fml = y ~ x1 + sw(x2, x3)</code>. The stepwise function <code>sw</code> will estimate the following two models: <code>y ~ x1 + x2</code> and <code>y ~ x1 + x3</code>. That is, each element in <code>sw()</code> is sequentially, and separately, added to the formula. Would have you used <code>sw0</code> in lieu of <code>sw</code>, then the model <code>y ~ x1</code> would also have been estimated. The <code>0</code> in the name means that the model without any stepwise element also needs to be estimated.
The prefix <code>c</code> means cumulative: each stepwise element is added to the next. That is, <code>fml = y ~ x1 + csw(x2, x3)</code> would lead to the following models <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>. The <code>0</code> has the same meaning and would also lead to the model without the stepwise elements to be estimated: in other words, <code>fml = y ~ x1 + csw0(x2, x3)</code> leads to the following three models: <code>y ~ x1</code>, <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>.
Finally <code>mvsw</code> will add, in a stepwise fashion all possible combinations of the variables in its arguments. For example <code>mvsw(x1, x2, x3)</code> is equivalent to <code>sw0(x1, x2, x3, x1 + x2, x1 + x3, x2 + x3, x1 + x2 + x3)</code>. The number of models to estimate grows at a factorial rate: so be cautious!
</p>
<p>Multiple independent variables can be combined with multiple dependent variables, as in <code>fml = c(y1, y2) ~ cw(x1, x2, x3)</code> which would lead to 6 estimations. Multiple estimations can also be combined to split samples (with the arguments <code>split</code>, <code>fsplit</code>).
</p>
<p>You can also add fixed-effects in a stepwise fashion. Note that you cannot perform stepwise estimations on the IV part of the formula (<code>feols</code> only).
</p>
<p>If NAs are present in the sample, to avoid too many messages, only NA removal concerning the variables common to all estimations is reported.
</p>
<p>A note on performance. The feature of multiple estimations has been highly optimized for <code>feols</code>, in particular in the presence of fixed-effects. It is faster to estimate multiple models using the formula rather than with a loop. For non-<code>feols</code> models using the formula is roughly similar to using a loop performance-wise.
</p>


<h3>Tricks to estimate multiple LHS</h3>

<p>To use multiple dependent variables in <code>fixest</code> estimations, you need to include them in a vector: like in <code>c(y1, y2, y3)</code>.
</p>
<p>First, if names are stored in a vector, they can readily be inserted in a formula to perform multiple estimations using the dot square bracket operator. For instance if <code>my_lhs = c("y1", "y2")</code>, calling <code>fixest</code> with, say <code>feols(.[my_lhs] ~ x1, etc)</code> is equivalent to using <code>feols(c(y1, y2) ~ x1, etc)</code>. Beware that this is a special feature unique to the <em>left-hand-side</em> of <code>fixest</code> estimations (the default behavior of the DSB operator is to aggregate with sums, see <code><a href="#topic+xpd">xpd</a></code>).
</p>
<p>Second, you can use a regular expression to grep the left-hand-sides on the fly. When the <code>..("regex")</code> feature is used naked on the LHS, the variables grepped are inserted into <code>c()</code>. For example <code style="white-space: pre;">&#8288;..("Pe") ~ Sepal.Length, iris&#8288;</code> is equivalent to <code style="white-space: pre;">&#8288;c(Petal.Length, Petal.Width) ~ Sepal.Length, iris&#8288;</code>. Beware that this is a special feature unique to the <em>left-hand-side</em> of <code>fixest</code> estimations (the default behavior of <code>..("regex")</code> is to aggregate with sums, see <code><a href="#topic+xpd">xpd</a></code>).
</p>


<h3>Argument sliding</h3>

<p>When the data set has been set up globally using <code><a href="#topic+setFixest_estimation">setFixest_estimation</a></code><code>(data = data_set)</code>, the argument <code>vcov</code> can be used implicitly. This means that calls such as <code>feols(y ~ x, "HC1")</code>, or <code>feols(y ~ x, ~id)</code>, are valid: i) the data is automatically deduced from the global settings, and ii) the <code>vcov</code> is deduced to be the second argument.
</p>


<h3>Piping</h3>

<p>Although the argument 'data' is placed in second position, the data can be piped to the estimation functions. For example, with R &gt;= 4.1, <code>mtcars |&gt; feols(mpg ~ cyl)</code> works as <code>feols(mpg ~ cyl, mtcars)</code>.
</p>


<h3>Dot square bracket operator in formulas</h3>

<p>In a formula, the dot square bracket (DSB) operator can: i) create manifold variables at once, or ii) capture values from the current environment and put them verbatim in the formula.
</p>
<p>Say you want to include the variables <code>x1</code> to <code>x3</code> in your formula. You can use <code>xpd(y ~ x.[1:3])</code> and you'll get <code>y ~ x1 + x2 + x3</code>.
</p>
<p>To summon values from the environment, simply put the variable in square brackets. For example: <code>for(i in 1:3) xpd(y.[i] ~ x)</code> will create the formulas <code>y1 ~ x</code> to <code>y3 ~ x</code> depending on the value of <code>i</code>.
</p>
<p>You can include a full variable from the environment in the same way: <code>for(y in c("a", "b")) xpd(.[y] ~ x)</code> will create the two formulas <code>a ~ x</code> and <code>b ~ x</code>.
</p>
<p>The DSB can even be used within variable names, but then the variable must be nested in character form. For example <code>y ~ .["x.[1:2]_sq"]</code> will create <code>y ~ x1_sq + x2_sq</code>. Using the character form is important to avoid a formula parsing error. Double quotes must be used. Note that the character string that is nested will be parsed with the function <code><a href="#topic+dsb">dsb</a></code>, and thus it will return a vector.
</p>
<p>By default, the DSB operator expands vectors into sums. You can add a comma, like in <code>.[, x]</code>, to expand with commas&ndash;the content can then be used within functions. For instance: <code>c(x.[, 1:2])</code> will create <code>c(x1, x2)</code> (and <em>not</em> <code>c(x1 + x2)</code>).
</p>
<p>In all <code>fixest</code> estimations, this special parsing is enabled, so you don't need to use <code>xpd</code>.
</p>
<p>One-sided formulas can be expanded with the DSB operator: let <code>x = ~sepal + petal</code>, then <code>xpd(y ~ .[x])</code> leads to <code>color ~ sepal + petal</code>.
</p>
<p>You can even use multiple square brackets within a single variable, but then the use of nesting is required. For example, the following <code>xpd(y ~ .[".[letters[1:2]]_.[1:2]"])</code> will create <code>y ~ a_1 + b_2</code>. Remember that the nested character string is parsed with <code><a href="#topic+dsb">dsb</a></code>, which explains this behavior.
</p>
<p>When the element to be expanded i) is equal to the empty string or, ii) is of length 0, it is replaced with a neutral element, namely <code>1</code>. For example, <code style="white-space: pre;">&#8288;x = "" ; xpd(y ~ .[x])&#8288;</code> leads to <code>y ~ 1</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>References</h3>

<p>Berge, Laurent, 2018, &quot;Efficient estimation of maximum likelihood models with multiple fixed-effects: the R package FENmlm.&quot; CREA Discussion Papers, 13 (<a href="https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf"></a>).
</p>
<p>For models with multiple fixed-effects:
</p>
<p>Gaure, Simen, 2013, &quot;OLS with multiple high dimensional category variables&quot;, Computational Statistics &amp; Data Analysis 66 pp. 8&ndash;18
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+summary.fixest">summary.fixest</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> to extract the fixed-effects coefficients, and the function <code><a href="#topic+etable">etable</a></code> to visualize the results of multiple estimations. For plotting coefficients: see <code><a href="#topic+coefplot">coefplot</a></code>.
</p>
<p>And other estimation methods: <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+fepois">fepois</a></code>, <code><a href="#topic+fenegbin">fenegbin</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Basic estimation
#

res = feols(Sepal.Length ~ Sepal.Width + Petal.Length, iris)
# You can specify clustered standard-errors in summary:
summary(res, cluster = ~Species)

#
# Just one set of fixed-effects:
#

res = feols(Sepal.Length ~ Sepal.Width + Petal.Length | Species, iris)
# By default, the SEs are clustered according to the first fixed-effect
summary(res)

#
# Varying slopes:
#

res = feols(Sepal.Length ~ Petal.Length | Species[Sepal.Width], iris)
summary(res)

#
# Combining the FEs:
#

base = iris
base$fe_2 = rep(1:10, 15)
res_comb = feols(Sepal.Length ~ Petal.Length | Species^fe_2, base)
summary(res_comb)
fixef(res_comb)[[1]]

#
# Using leads/lags:
#

data(base_did)
# We need to set up the panel with the arg. panel.id
est1 = feols(y ~ l(x1, 0:1), base_did, panel.id = ~id+period)
est2 = feols(f(y) ~ l(x1, -1:1), base_did, panel.id = ~id+period)
etable(est1, est2, order = "f", drop="Int")

#
# Using interactions:
#

data(base_did)
# We interact the variable 'period' with the variable 'treat'
est_did = feols(y ~ x1 + i(period, treat, 5) | id+period, base_did)

# Now we can plot the result of the interaction with coefplot
coefplot(est_did)
# You have many more example in coefplot help

#
# Instrumental variables
#

# To estimate Two stage least squares,
# insert a formula describing the endo. vars./instr. relation after a pipe:

base = iris
names(base) = c("y", "x1", "x2", "x3", "fe1")
base$x_inst1 = 0.2 * base$x1 + 0.7 * base$x2 + rpois(150, 2)
base$x_inst2 = 0.2 * base$x2 + 0.7 * base$x3 + rpois(150, 3)
base$x_endo1 = 0.5 * base$y + 0.5 * base$x3 + rnorm(150, sd = 2)
base$x_endo2 = 1.5 * base$y + 0.5 * base$x3 + 3 * base$x_inst1 + rnorm(150, sd = 5)

# Using 2 controls, 1 endogenous var. and 1 instrument
res_iv = feols(y ~ x1 + x2 | x_endo1 ~ x_inst1, base)

# The second stage is the default
summary(res_iv)

# To show the first stage:
summary(res_iv, stage = 1)

# To show both the first and second stages:
summary(res_iv, stage = 1:2)

# Adding a fixed-effect =&gt; IV formula always last!
res_iv_fe = feols(y ~ x1 + x2 | fe1 | x_endo1 ~ x_inst1, base)

# With two endogenous regressors
res_iv2 = feols(y ~ x1 + x2 | x_endo1 + x_endo2 ~ x_inst1 + x_inst2, base)

# Now there's two first stages =&gt; a fixest_multi object is returned
sum_res_iv2 = summary(res_iv2, stage = 1)

# You can navigate through it by subsetting:
sum_res_iv2[iv = 1]

# The stage argument also works in etable:
etable(res_iv, res_iv_fe, res_iv2, order = "endo")

etable(res_iv, res_iv_fe, res_iv2, stage = 1:2, order = c("endo", "inst"),
       group = list(control = "!endo|inst"))

#
# Multiple estimations:
#

# 6 estimations
est_mult = feols(c(Ozone, Solar.R) ~ Wind + Temp + csw0(Wind:Temp, Day), airquality)

# We can display the results for the first lhs:
etable(est_mult[lhs = 1])

# And now the second (access can be made by name)
etable(est_mult[lhs = "Solar.R"])

# Now we focus on the two last right hand sides
# (note that .N can be used to specify the last item)
etable(est_mult[rhs = 2:.N])

# Combining with split
est_split = feols(c(Ozone, Solar.R) ~ sw(poly(Wind, 2), poly(Temp, 2)),
                  airquality, split = ~ Month)

# You can display everything at once with the print method
est_split

# Different way of displaying the results with "compact"
summary(est_split, "compact")

# You can still select which sample/LHS/RHS to display
est_split[sample = 1:2, lhs = 1, rhs = 1]

#
# Split sample estimations
#

base = setNames(iris, c("y", "x1", "x2", "x3", "species"))

est  = feols(y ~ x.[1:3], base, split = ~species)
etable(est)

# You can select specific values with the %keep% and %drop% operators
# By default, partial matching is enabled. It should refer to a single variable.
est  = feols(y ~ x.[1:3], base, split = ~species %keep% c("set", "vers"))
etable(est)

# You can supply regular expression by using an @ first.
# regex can match several values.
est  = feols(y ~ x.[1:3], base, split = ~species %keep% c("@set|vers"))
etable(est)

#
# Argument sliding
#

# When the data set is set up globally, you can use the vcov argument implicitly

base = setNames(iris, c("y", "x1", "x2", "x3", "species"))

no_sliding = feols(y ~ x1 + x2, base, ~species)

# With sliding
setFixest_estimation(data = base)

# ~species is implicitly deduced to be equal to 'vcov'
sliding = feols(y ~ x1 + x2, ~species)

etable(no_sliding, sliding)

# Resetting the global options
setFixest_estimation(data = NULL)


#
# Formula expansions
#

# By default, the features of the xpd function are enabled in
# all fixest estimations
# Here's a few examples

base = setNames(iris, c("y", "x1", "x2", "x3", "species"))

# dot square bracket operator
feols(y ~ x.[1:3], base)

# fetching variables via regular expressions: ..("regex")
feols(y ~ ..("1|2"), base)

# NOTA: it also works for multiple LHS
mult1 = feols(x.[1:2] ~ y + species, base)
mult2 = feols(..("y|3") ~ x.[1:2] + species, base)
etable(mult1, mult2)


# Use .[, stuff] to include variables in functions:
feols(y ~ csw(x.[, 1:3]), base)

# Same for ..(, "regex")
feols(y ~ csw(..(,"x")), base)



</code></pre>

<hr>
<h2 id='fitstat'>Computes fit statistics of fixest objects</h2><span id='topic+fitstat'></span>

<h3>Description</h3>

<p>Computes various fit statistics for <code>fixest</code> estimations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitstat(
  x,
  type,
  simplify = FALSE,
  verbose = TRUE,
  show_types = FALSE,
  frame = parent.frame(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitstat_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> estimation.</p>
</td></tr>
<tr><td><code id="fitstat_+3A_type">type</code></td>
<td>
<p>Character vector or one sided formula. The type of fit statistic to be computed. The classic ones are: n, rmse, r2, pr2, f, wald, ivf, ivwald. You have the full list in the details section or use <code>show_types = TRUE</code>. Further, you can register your own types with <code><a href="#topic+fitstat_register">fitstat_register</a></code>.</p>
</td></tr>
<tr><td><code id="fitstat_+3A_simplify">simplify</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. By default a list is returned whose names are the selected types. If <code>simplify = TRUE</code> and only one type is selected, then the element is directly returned (ie will not be nested in a list).</p>
</td></tr>
<tr><td><code id="fitstat_+3A_verbose">verbose</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>TRUE</code>, an object of class <code>fixest_fitstat</code> is returned (so its associated print method will be triggered). If <code>FALSE</code> a simple list is returned instead.</p>
</td></tr>
<tr><td><code id="fitstat_+3A_show_types">show_types</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, only prompts all available types.</p>
</td></tr>
<tr><td><code id="fitstat_+3A_frame">frame</code></td>
<td>
<p>An environment in which to evaluate variables, default is <code>parent.frame()</code>. Only used if the argument <code>type</code> is a formula and some values in the formula have to be extended with the dot square bracket operator. Mostly for internal use.</p>
</td></tr>
<tr><td><code id="fitstat_+3A_...">...</code></td>
<td>
<p>Other elements to be passed to other methods and may be used to compute the statistics (for example you can pass on arguments to compute the VCOV when using <code>type = "g"</code> or <code>type = "wald"</code>.).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default an object of class <code>fixest_fitstat</code> is returned. Using <code>verbose = FALSE</code> returns a simple a list. Finally, if only one type is selected, <code>simplify = TRUE</code> leads to the selected type to be returned.
</p>


<h3>Registering your own types</h3>

<p>You can register custom fit statistics with the function <code>fitstat_register</code>.
</p>


<h3>Available types</h3>

<p>The types are case sensitive, please use lower case only. The types available are:
</p>

<dl>
<dt><code>n</code>, <code>ll</code>, <code>aic</code>, <code>bic</code>, <code>rmse</code>: </dt><dd><p>The number of observations, the log-likelihood, the AIC, the BIC and the root mean squared error, respectively.</p>
</dd>
<dt><code>my</code>: </dt><dd><p>Mean of the dependent variable.</p>
</dd>
<dt><code>g</code>: </dt><dd><p>The degrees of freedom used to compute the t-test (it influences the p-values of the coefficients). When the VCOV is clustered, this value is equal to the minimum cluster size, otherwise, it is equal to the sample size minus the number of variables.</p>
</dd>
<dt><code>r2</code>, <code>ar2</code>, <code>wr2</code>, <code>awr2</code>, <code>pr2</code>, <code>apr2</code>, <code>wpr2</code>, <code>awpr2</code>: </dt><dd><p>All r2 that can be obtained with the function <code><a href="#topic+r2">r2</a></code>. The <code>a</code> stands for 'adjusted', the <code>w</code> for 'within' and the <code>p</code> for 'pseudo'. Note that the order of the letters <code>a</code>, <code>w</code> and <code>p</code> does not matter. The pseudo R2s are McFadden's R2s (ratios of log-likelihoods).</p>
</dd>
<dt><code>theta</code>: </dt><dd><p>The over-dispersion parameter in Negative Binomial models. Low values mean high overdispersion.</p>
</dd>
<dt><code>f</code>, <code>wf</code>: </dt><dd><p>The F-tests of nullity of the coefficients. The <code>w</code> stands for 'within'. These types return the following values: <code>stat</code>, <code>p</code>, <code>df1</code> and <code>df2</code>. If you want to display only one of these, use their name after a dot: e.g. <code>f.stat</code> will give the statistic of the F-test, or <code>wf.p</code> will give the p-values of the F-test on the projected model (i.e. projected onto the fixed-effects).</p>
</dd>
<dt><code>wald</code>: </dt><dd><p>Wald test of joint nullity of the coefficients. This test always excludes the intercept and the fixed-effects. These type returns the following values: <code>stat</code>, <code>p</code>, <code>df1</code>, <code>df2</code> and <code>vcov</code>. The element <code>vcov</code> reports the way the VCOV matrix was computed since it directly influences this statistic.</p>
</dd>
<dt><code>ivf</code>, <code>ivf1</code>, <code>ivf2</code>, <code>ivfall</code>: </dt><dd><p>These statistics are specific to IV estimations. They report either the IV F-test (namely the Cragg-Donald F statistic in the presence of only one endogenous regressor) of the first stage (<code>ivf</code> or <code>ivf1</code>), of the second stage (<code>ivf2</code>) or of both (<code>ivfall</code>). The F-test of the first stage is commonly named weak instrument test. The value of <code>ivfall</code> is only useful in <code><a href="#topic+etable">etable</a></code> when both the 1st and 2nd stages are displayed (it leads to the 1st stage F-test(s) to be displayed on the 1st stage estimation(s), and the 2nd stage one on the 2nd stage estimation &ndash; otherwise, <code>ivf1</code> would also be displayed on the 2nd stage estimation). These types return the following values: <code>stat</code>, <code>p</code>, <code>df1</code> and <code>df2</code>.</p>
</dd>
<dt><code>ivwald</code>, <code>ivwald1</code>, <code>ivwald2</code>, <code>ivwaldall</code>: </dt><dd><p>These statistics are specific to IV estimations. They report either the IV Wald-test of the first stage (<code>ivwald</code> or <code>ivwald1</code>), of the second stage (<code>ivwald2</code>) or of both (<code>ivwaldall</code>). The Wald-test of the first stage is commonly named weak instrument test. Note that if the estimation was done with a robust VCOV and there is only one endogenous regressor, this is equivalent to the Kleibergen-Paap statistic. The value of <code>ivwaldall</code> is only useful in <code><a href="#topic+etable">etable</a></code> when both the 1st and 2nd stages are displayed (it leads to the 1st stage Wald-test(s) to be displayed on the 1st stage estimation(s), and the 2nd stage one on the 2nd stage estimation &ndash; otherwise, <code>ivwald1</code> would also be displayed on the 2nd stage estimation). These types return the following values: <code>stat</code>, <code>p</code>, <code>df1</code>, <code>df2</code>, and <code>vcov</code>.</p>
</dd>
<dt><code>cd</code>: </dt><dd><p>The Cragg-Donald test for weak instruments.</p>
</dd>
<dt><code>kpr</code>: </dt><dd><p>The Kleibergen-Paap test for weak instruments.</p>
</dd>
<dt><code>wh</code>: </dt><dd><p>This statistic is specific to IV estimations. Wu-Hausman endogeneity test. H0 is the absence of endogeneity of the instrumented variables. It returns the following values: <code>stat</code>, <code>p</code>, <code>df1</code>, <code>df2</code>.</p>
</dd>
<dt><code>sargan</code>: </dt><dd><p>Sargan test of overidentifying restrictions. H0: the instruments are not correlated with the second stage residuals. It returns the following values: <code>stat</code>, <code>p</code>, <code>df</code>.</p>
</dd>
<dt><code>lr</code>, <code>wlr</code>: </dt><dd><p>Likelihood ratio and within likelihood ratio tests. It returns the following elements: <code>stat</code>, <code>p</code>, <code>df</code>. Concerning the within-LR test, note that, contrary to estimations with <code>femlm</code> or <code>feNmlm</code>, estimations with <code>feglm</code>/<code>fepois</code> need to estimate the model with fixed-effects only which may prove time-consuming (depending on your model). Bottom line, if you really need the within-LR and estimate a Poisson model, use <code>femlm</code> instead of <code>fepois</code> (the former uses direct ML maximization for which the only FEs model is a by product).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(trade)
gravity = feols(log(Euros) ~ log(dist_km) | Destination + Origin, trade)

# Extracting the 'working' number of observations used to compute the pvalues
fitstat(gravity, "g", simplify = TRUE)

# Some fit statistics
fitstat(gravity, ~ rmse + r2 + wald + wf)

# You can use them in etable
etable(gravity, fitstat = ~ rmse + r2 + wald + wf)

# For wald and wf, you could show the pvalue instead:
etable(gravity, fitstat = ~ rmse + r2 + wald.p + wf.p)

# Now let's display some statistics that are not built-in
# =&gt; we use fitstat_register to create them

# We need: a) type name, b) the function to be applied
#          c) (optional) an alias

fitstat_register("tstand", function(x) tstat(x, se = "stand")[1], "t-stat (regular)")
fitstat_register("thc", function(x) tstat(x, se = "heter")[1], "t-stat (HC1)")
fitstat_register("t1w", function(x) tstat(x, se = "clus")[1], "t-stat (clustered)")
fitstat_register("t2w", function(x) tstat(x, se = "twow")[1], "t-stat (2-way)")

# Now we can use these keywords in fitstat:
etable(gravity, fitstat = ~ . + tstand + thc + t1w + t2w)

# Note that the custom stats we created are can easily lead
# to errors, but that's another story!


</code></pre>

<hr>
<h2 id='fitstat_register'>Register custom fit statistics</h2><span id='topic+fitstat_register'></span>

<h3>Description</h3>

<p>Enables the registration of custom fi statistics that can be easily summoned with the function <code><a href="#topic+fitstat">fitstat</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitstat_register(type, fun, alias = NULL, subtypes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitstat_register_+3A_type">type</code></td>
<td>
<p>A character scalar giving the type-name.</p>
</td></tr>
<tr><td><code id="fitstat_register_+3A_fun">fun</code></td>
<td>
<p>A function to be applied to a <code>fixest</code> estimation. It must return either a scalar, or a list of unitary elements. If the number of elements returned is greater than 1, then each element must be named! If the fit statistic is not valid for a given estimation, a plain <code>NA</code> value should be returned.</p>
</td></tr>
<tr><td><code id="fitstat_register_+3A_alias">alias</code></td>
<td>
<p>A (named) character vector. An alias to be used in lieu of the type name in the display methods (ie when used in <code><a href="#topic+print.fixest_fitstat">print.fixest_fitstat</a></code> or <code><a href="#topic+etable">etable</a></code>). If the function returns several values, i.e. sub-types, you can give an alias to these sub-types. The syntax is <code>c("type" = "alias", "subtype_i" = "alias_i")</code>, with &quot;type&quot; (resp. &quot;subtype&quot;) the value of the argument <code>type</code> resp. (<code>subtypes</code>). You can also give an alias encompassing the type and sub-type with the syntax <code>c("type.subtype_i" = "alias")</code>.</p>
</td></tr>
<tr><td><code id="fitstat_register_+3A_subtypes">subtypes</code></td>
<td>
<p>A character vector giving the name of each element returned by the function <code>fun</code>. This is only used when the function returns more than one value. Note that you can use the shortcut &quot;test&quot; when the sub-types are &quot;stat&quot;, &quot;p&quot; and &quot;df&quot;; and &quot;test2&quot; when these are &quot;stat&quot;, &quot;p&quot;, &quot;df1&quot; and &quot;df2&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are several components to the computed statistics (i.e. the function returns several elements), then using the argument <code>subtypes</code>, giving the names of each of these components, is mandatory. This is to ensure that the statistic can be used as any other built-in statistic (and there are too many edge cases impeding automatic deduction).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# An estimation
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")
est = feols(y ~ x1 + x2 | species, base)

#
# single valued tests
#

# say you want to add the coefficient of variation of the dependent variable
cv = function(est){
  y = model.matrix(est, type = "lhs")
  sd(y)/mean(y)
}

# Now we register the routine
fitstat_register("cvy", cv, "Coef. of Variation (dep. var.)")

# now we can summon the registered routine with its type ("cvy")
fitstat(est, "cvy")

#
# Multi valued tests
#

# Let's say you want a Wald test with an heteroskedasticiy robust variance

# First we create the function
hc_wald = function(est){
  w = wald(est, keep = "!Intercept", print = FALSE, se = "hetero")
  head(w, 4)
}
# This test returns a vector of 4 elements: stat, p, df1 and df2

# Now we register the routine
fitstat_register("hc_wald", hc_wald, "Wald (HC1)", "test2")

# You can access the statistic, as before
fitstat(est, "hc_wald")

# But you can also access the sub elements
fitstat(est, "hc_wald.p")

</code></pre>

<hr>
<h2 id='fitted.fixest'>Extracts fitted values from a <code>fixest</code> fit</h2><span id='topic+fitted.fixest'></span><span id='topic+fitted.values.fixest'></span>

<h3>Description</h3>

<p>This function extracts the fitted values from a model estimated with <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. The fitted values that are returned are the <em>expected predictor</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
fitted(object, type = c("response", "link"), na.rm = TRUE, ...)

## S3 method for class 'fixest'
fitted.values(object, type = c("response", "link"), na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.fixest_+3A_type">type</code></td>
<td>
<p>Character either equal to <code>"response"</code> (default) or <code>"link"</code>. If <code>type="response"</code>, then the output is at the level of the response variable, i.e. it is the expected predictor <code class="reqn">E(Y|X)</code>. If <code>"link"</code>, then the output is at the level of the explanatory variables, i.e. the linear predictor <code class="reqn">X\cdot \beta</code>.</p>
</td></tr>
<tr><td><code id="fitted.fixest_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>FALSE</code> the number of observation returned will be the number of observations in the original data set, otherwise it will be the number of observations used in the estimation.</p>
</td></tr>
<tr><td><code id="fitted.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the <em>expected predictor</em> of a <code>fixest</code> fit. The likelihood functions are detailed in <code><a href="#topic+femlm">femlm</a></code> help page.
</p>


<h3>Value</h3>

<p>It returns a numeric vector of length the number of observations used to estimate the model.
</p>
<p>If <code>type = "response"</code>, the value returned is the expected predictor, i.e. the expected value of the dependent variable for the fitted model: <code class="reqn">E(Y|X)</code>.
If <code>type = "link"</code>, the value returned is the linear predictor of the fitted model, that is <code class="reqn">X\cdot \beta</code> (remind that <code class="reqn">E(Y|X) = f(X\cdot \beta)</code>).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. <code><a href="#topic+resid.fixest">resid.fixest</a></code>, <code><a href="#topic+predict.fixest">predict.fixest</a></code>, <code><a href="#topic+summary.fixest">summary.fixest</a></code>, <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, using "Species" fixed-effects
res_poisson = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
                    Petal.Width | Species, iris)

# we extract the fitted values
y_fitted_poisson = fitted(res_poisson)

# Same estimation but in OLS (Gaussian family)
res_gaussian = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
                    Petal.Width | Species, iris, family = "gaussian")

y_fitted_gaussian = fitted(res_gaussian)

# comparison of the fit for the two families
plot(iris$Sepal.Length, y_fitted_poisson)
points(iris$Sepal.Length, y_fitted_gaussian, col = 2, pch = 2)


</code></pre>

<hr>
<h2 id='fixef_reexported'>Functions exported from <span class="pkg">nlme</span> to implement <span class="pkg">fixest</span> methods</h2><span id='topic+fixef_reexported'></span><span id='topic+fixef'></span>

<h3>Description</h3>

<p>The package <span class="pkg">fixest</span> uses the <code>fixef</code> method from <span class="pkg">nlme</span>. Unfortunately, re-exporting this method is required in order not to attach package <span class="pkg">nlme</span>.
</p>


<h3>Details</h3>


<ul>
<li><p> Here is the help from package <span class="pkg">nlme</span>: <code><a href="nlme.html#topic+fixed.effects">fixef</a></code>. The help from package <span class="pkg">fixest</span> is here: <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>.
</p>
</li></ul>



<h3>Note</h3>

<p>I could find this workaround thanks to the package <span class="pkg">plm</span>.
</p>

<hr>
<h2 id='fixef.fixest'>Extract the Fixed-Effects from a <code>fixest</code> estimation.</h2><span id='topic+fixef.fixest'></span>

<h3>Description</h3>

<p>This function retrieves the fixed effects from a <code>fixest</code> estimation. It is useful only when there are one or more fixed-effect dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
fixef(
  object,
  notes = getFixest_notes(),
  sorted = TRUE,
  nthreads = getFixest_nthreads(),
  fixef.tol = 1e-05,
  fixef.iter = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> estimation (e.g. obtained using <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>).</p>
</td></tr>
<tr><td><code id="fixef.fixest_+3A_notes">notes</code></td>
<td>
<p>Logical. Whether to display a note when the fixed-effects coefficients are not regular.</p>
</td></tr>
<tr><td><code id="fixef.fixest_+3A_sorted">sorted</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether to order the fixed-effects by their names. If <code>FALSE</code>, then the order used in the demeaning algorithm is used.</p>
</td></tr>
<tr><td><code id="fixef.fixest_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than, or equal to, the maximum number of threads; b) 0: meaning all available threads will be used; c) a number strictly between 0 and 1 which represents the fraction of all threads to use. The default is to use 50% of all threads. You can set permanently the number of threads used within this package using the function <code><a href="#topic+setFixest_nthreads">setFixest_nthreads</a></code>.</p>
</td></tr>
<tr><td><code id="fixef.fixest_+3A_fixef.tol">fixef.tol</code></td>
<td>
<p>Precision used to obtain the fixed-effects. Defaults to <code>1e-5</code>. It corresponds to the maximum absolute difference allowed between two coefficients of successive iterations. Argument <code>fixef.tol</code> cannot be lower than <code>10000*.Machine$double.eps</code>. Note that this parameter is dynamically controlled by the algorithm.</p>
</td></tr>
<tr><td><code id="fixef.fixest_+3A_fixef.iter">fixef.iter</code></td>
<td>
<p>Maximum number of iterations in fixed-effects algorithm (only in use for 2+ fixed-effects). Default is 10000.</p>
</td></tr>
<tr><td><code id="fixef.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the fixed-effect coefficients are not regular, then several reference points need to be set: this means that the fixed-effects coefficients cannot be directly interpreted. If this is the case, then a warning is raised.
</p>


<h3>Value</h3>

<p>A list containing the vectors of the fixed effects.
</p>
<p>If there is more than 1 fixed-effect, then the attribute &ldquo;references&rdquo; is created. This is a vector of length the number of fixed-effects, each element contains the number of coefficients set as references. By construction, the elements of the first fixed-effect dimension are never set as references. In the presence of regular fixed-effects, there should be Q-1 references (with Q the number of fixed-effects).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fixest.fixef">plot.fixest.fixef</a></code>. See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. Use <code><a href="#topic+summary.fixest">summary.fixest</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> to extract the fixed-effect coefficients, and the function <code><a href="#topic+etable">etable</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(trade)

# We estimate the effect of distance on trade =&gt; we account for 3 fixed-effects
est_pois = femlm(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# Obtaining the fixed-effects coefficients:
fe_trade = fixef(est_pois)

# The fixed-effects of the first fixed-effect dimension:
head(fe_trade$Origin)

# Summary information:
summary(fe_trade)

# Plotting them:
plot(fe_trade)

</code></pre>

<hr>
<h2 id='fixest_startup_msg'>Permanently removes the fixest package startup message</h2><span id='topic+fixest_startup_msg'></span>

<h3>Description</h3>

<p>Package startup messages can be very annoying, although sometimes they can be necessary. Use this function to prevent <code>fixest</code>'s package startup message from popping when loading. This will be specific to your current project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixest_startup_msg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixest_startup_msg_+3A_x">x</code></td>
<td>
<p>Logical, no default. If <code>FALSE</code>, the package startup message is removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function is introduced to cope with the first <code>fixest</code> startup message (in version 0.9.0).
</p>
<p>This function works only with R &gt;= 4.0.0. There are no startup messages for R &lt; 4.0.0.
</p>

<hr>
<h2 id='fixest-package'>Fast and User-Friendly Fixed-Effects Estimations</h2><span id='topic+fixest'></span><span id='topic+fixest-package'></span>

<h3>Description</h3>

<p>The package <span class="pkg">fixest</span> provides a family of functions to perform estimations with multiple fixed-effects. Standard-errors can be easily and intuitively clustered. It also includes tools to seamlessly export the results of various estimations.
</p>

<ul>
<li><p> To get started, look at the <a href="https://cran.r-project.org/package=fixest/vignettes/fixest_walkthrough.html">introduction</a>.
</p>
</li></ul>



<h3>Details</h3>

<p>The main features are:
</p>

<ul>
<li><p> Estimation. The core functions are: <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">feglm</a></code> and <code><a href="#topic+femlm">femlm</a></code> to estimate, respectively, linear models, generalized linear models and maximum likelihood models with multiple fixed-effects. The function <code><a href="#topic+feNmlm">feNmlm</a></code> allows the inclusion of non-linear in parameters right hand sides. Finally <code><a href="#topic+feglm">fepois</a></code> and <code><a href="#topic+femlm">fenegbin</a></code> are shorthands to estimate Poisson and Negative Binomial models.
</p>
</li>
<li><p> Multiple estimations: You can perform multiple estimations at once with the <code><a href="#topic+stepwise">stepwise</a></code> functions. It's then very easy to manipulate multiple results with the associated methods. See an introduction in the dedicated vignette: <a href="https://cran.r-project.org/package=fixest/vignettes/multiple_estimations.html">Multiple estimations</a>
</p>
</li>
<li><p> Easy and flexible clustering of standard-errors. By using the arguments <code>vcov</code> and <code>ssc</code> (see <code><a href="#topic+summary.fixest">summary.fixest</a></code>). To have a sense of how the standard errors are computed, see the vignette <a href="https://lrberge.github.io/fixest/articles/standard_errors.html">On standard-errors</a>.
</p>
</li>
<li><p> Visualization and exportation of results. You can visualize the results of multiple estimations in R, or export them in Latex using the function <code><a href="#topic+etable">etable</a></code>. This vignette details how to customize the Latex tables: <a href="https://lrberge.github.io/fixest/articles/exporting_tables.html">Exporting estimation tables</a>.
</p>
</li>
<li><p> Plot multiple results. You can plot the coefficients and confidence intervals of estimations easily with the function <code><a href="#topic+coefplot">coefplot</a></code>. This function also offers a specific layout for interactions.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Laurent Berge <a href="mailto:laurent.berge@u-bordeaux.fr">laurent.berge@u-bordeaux.fr</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Sebastian Krantz [contributor]
</p>
</li>
<li><p> Grant McDermott <a href="mailto:grantmcd@uoregon.edu">grantmcd@uoregon.edu</a> (<a href="https://orcid.org/0000-0001-7883-8573">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Berge, Laurent, 2018, &quot;Efficient estimation of maximum likelihood models with multiple fixed-effects: the R package FENmlm.&quot; CREA Discussion Papers, 13 (<a href="https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf"></a>).
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://lrberge.github.io/fixest/">https://lrberge.github.io/fixest/</a>
</p>
</li>
<li> <p><a href="https://github.com/lrberge/fixest">https://github.com/lrberge/fixest</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/lrberge/fixest/issues">https://github.com/lrberge/fixest/issues</a>
</p>
</li></ul>


<hr>
<h2 id='formula.fixest'>Extract the formula of a <code>fixest</code> fit</h2><span id='topic+formula.fixest'></span>

<h3>Description</h3>

<p>This function extracts the formula from a <code>fixest</code> estimation (obtained with <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>). If the estimation was done with fixed-effects, they are added in the formula after a pipe (&ldquo;|&rdquo;). If the estimation was done with a non linear in parameters part, then this will be added in the formula in between <code>I()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
formula(x, type = c("full", "linear", "iv", "NL"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.fixest_+3A_x">x</code></td>
<td>
<p>An object of class <code>fixest</code>. Typically the result of a <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code> estimation.</p>
</td></tr>
<tr><td><code id="formula.fixest_+3A_type">type</code></td>
<td>
<p>A character scalar. Default is <code>type = "full"</code> which gives back a formula containing the linear part of the model along with the fixed-effects (if any) and the IV part (if any). If <code>type = "linear"</code> then only the linear formula is returned. If <code>type = "NL"</code> then only the non linear in parameters part is returned.</p>
</td></tr>
<tr><td><code id="formula.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a formula.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. <code><a href="#topic+model.matrix.fixest">model.matrix.fixest</a></code>, <code><a href="#topic+update.fixest">update.fixest</a></code>, <code><a href="#topic+summary.fixest">summary.fixest</a></code>, <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, using "Species" fixed-effects
res = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)

# formula with the fixed-effect variable
formula(res)

# linear part without the fixed-effects
formula(res, "linear")


</code></pre>

<hr>
<h2 id='hatvalues.fixest'>Hat values for <code>fixest</code> objects</h2><span id='topic+hatvalues.fixest'></span>

<h3>Description</h3>

<p>Computes the hat values for <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code> estimations. Only works when there are no fixed-effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
hatvalues(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hatvalues.fixest_+3A_model">model</code></td>
<td>
<p>A fixest object. For instance from feols or feglm.</p>
</td></tr>
<tr><td><code id="hatvalues.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hat values are not available for <code><a href="#topic+femlm">fenegbin</a></code>, <code><a href="#topic+femlm">femlm</a></code> and <code><a href="#topic+feNmlm">feNmlm</a></code> estimations.
</p>
<p>When there are fixed-effects, the hat values of the reduced form are different from the hat values of the full model. And we cannot get costlessly the hat values of the full model from the reduced form. It would require to reestimate the model with the fixed-effects as regular variables.
</p>


<h3>Value</h3>

<p>Returns a vector of the same length as the number of observations used in the estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
est = feols(Petal.Length ~ Petal.Width + Sepal.Width, iris)
head(hatvalues(est))


</code></pre>

<hr>
<h2 id='i'>Create, or interact variables with, factors</h2><span id='topic+i'></span>

<h3>Description</h3>

<p>Treat a variable as a factor, or interacts a variable with a factor. Values to be dropped/kept from the factor can be easily set. Note that to interact fixed-effects, this function should not be used: instead use directly the syntax <code>fe1^fe2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i(factor_var, var, ref, keep, bin, ref2, keep2, bin2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="i_+3A_factor_var">factor_var</code></td>
<td>
<p>A vector (of any type) that will be treated as a factor. You can set references (i.e. exclude values for which to create dummies) with the <code>ref</code> argument.</p>
</td></tr>
<tr><td><code id="i_+3A_var">var</code></td>
<td>
<p>A variable of the same length as <code>factor_var</code>. This variable will be interacted with the factor in <code>factor_var</code>. It can be numeric or factor-like. To force a numeric variable to be treated as a factor, you can add the <code>i.</code> prefix to a variable name. For instance take a numeric variable <code>x_num</code>: <code>i(x_fact, x_num)</code> will treat <code>x_num</code> as numeric while <code>i(x_fact, i.x_num)</code> will treat <code>x_num</code> as a factor (it's a shortcut to <code>as.factor(x_num)</code>).</p>
</td></tr>
<tr><td><code id="i_+3A_ref">ref</code></td>
<td>
<p>A vector of values to be taken as references from <code>factor_var</code>. Can also be a logical: if <code>TRUE</code>, then the first value of <code>factor_var</code> will be removed. If <code>ref</code> is a character vector, partial matching is applied to values; use &quot;@&quot; as the first character to enable regular expression matching. See examples.</p>
</td></tr>
<tr><td><code id="i_+3A_keep">keep</code></td>
<td>
<p>A vector of values to be kept from <code>factor_var</code> (all others are dropped). By default they should be values from <code>factor_var</code> and if <code>keep</code> is a character vector partial matching is applied. Use &quot;@&quot; as the first character to enable regular expression matching instead.</p>
</td></tr>
<tr><td><code id="i_+3A_bin">bin</code></td>
<td>
<p>A list of values to be grouped, a vector, a formula, or the special values <code>"bin::digit"</code> or <code>"cut::values"</code>. To create a new value from old values, use <code>bin = list("new_value"=old_values)</code> with <code>old_values</code> a vector of existing values. You can use <code>.()</code> for <code>list()</code>.
It accepts regular expressions, but they must start with an <code>"@"</code>, like in <code>bin="@Aug|Dec"</code>. It accepts one-sided formulas which must contain the variable <code>x</code>, e.g. <code>bin=list("&lt;2" = ~x &lt; 2)</code>.
The names of the list are the new names. If the new name is missing, the first value matched becomes the new name. In the name, adding <code>"@d"</code>, with <code>d</code> a digit, will relocate the value in position <code>d</code>: useful to change the position of factors. Use <code>"@"</code> as first item to make subsequent items be located first in the factor.
Feeding in a vector is like using a list without name and only a single element. If the vector is numeric, you can use the special value <code>"bin::digit"</code> to group every <code>digit</code> element.
For example if <code>x</code> represents years, using <code>bin="bin::2"</code> creates bins of two years.
With any data, using <code>"!bin::digit"</code> groups every digit consecutive values starting from the first value.
Using <code>"!!bin::digit"</code> is the same but starting from the last value.
With numeric vectors you can: a) use <code>"cut::n"</code> to cut the vector into <code>n</code> equal parts, b) use <code>"cut::a]b["</code> to create the following bins: <code style="white-space: pre;">&#8288;[min, a]&#8288;</code>, <code style="white-space: pre;">&#8288;]a, b[&#8288;</code>, <code style="white-space: pre;">&#8288;[b, max]&#8288;</code>.
The latter syntax is a sequence of number/quartile (q0 to q4)/percentile (p0 to p100) followed by an open or closed square bracket. You can add custom bin names by adding them in the character vector after <code>'cut::values'</code>. See details and examples. Dot square bracket expansion (see <code><a href="#topic+dsb">dsb</a></code>) is enabled.</p>
</td></tr>
<tr><td><code id="i_+3A_ref2">ref2</code></td>
<td>
<p>A vector of values to be dropped from <code>var</code>. By default they should be values from <code>var</code> and if <code>ref2</code> is a character vector partial matching is applied. Use &quot;@&quot; as the first character to enable regular expression matching instead.</p>
</td></tr>
<tr><td><code id="i_+3A_keep2">keep2</code></td>
<td>
<p>A vector of values to be kept from <code>var</code> (all others are dropped). By default they should be values from <code>var</code> and if <code>keep2</code> is a character vector partial matching is applied. Use &quot;@&quot; as the first character to enable regular expression matching instead.</p>
</td></tr>
<tr><td><code id="i_+3A_bin2">bin2</code></td>
<td>
<p>A list or vector defining the binning of the second variable. See help for the argument <code>bin</code> for details (or look at the help of the function <code><a href="#topic+bin">bin</a></code>). You can use <code>.()</code> for <code>list()</code>.</p>
</td></tr>
<tr><td><code id="i_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To interact fixed-effects, this function should not be used: instead use directly the syntax <code>fe1^fe2</code> in the fixed-effects part of the formula. Please see the details and examples in the help page of <code><a href="#topic+feols">feols</a></code>.
</p>


<h3>Value</h3>

<p>It returns a matrix with number of rows the length of <code>factor_var</code>. If there is no interacted variable or it is interacted with a numeric variable, the number of columns is equal to the number of cases contained in <code>factor_var</code> minus the reference(s). If the interacted variable is a factor, the number of columns is the number of combined cases between <code>factor_var</code> and <code>var</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coefplot">iplot</a></code> to plot interactions or factors created with <code>i()</code>, <code><a href="#topic+feols">feols</a></code> for OLS estimation with multiple fixed-effects.
</p>
<p>See the function <code><a href="#topic+bin">bin</a></code> for binning variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Simple illustration
#

x = rep(letters[1:4], 3)[1:10]
y = rep(1:4, c(1, 2, 3, 4))

# interaction
data.frame(x, y, i(x, y, ref = TRUE))

# without interaction
data.frame(x, i(x, "b"))

# you can interact factors too
z = rep(c("e", "f", "g"), c(5, 3, 2))
data.frame(x, z, i(x, z))

# to force a numeric variable to be treated as a factor: use i.
data.frame(x, y, i(x, i.y))

# Binning
data.frame(x, i(x, bin = list(ab = c("a", "b"))))

# Same as before but using .() for list() and a regular expression
# note that to trigger a regex, you need to use an @ first
data.frame(x, i(x, bin = .(ab = "@a|b")))

#
# In fixest estimations
#

data(base_did)
# We interact the variable 'period' with the variable 'treat'
est_did = feols(y ~ x1 + i(period, treat, 5) | id + period, base_did)

# =&gt; plot only interactions with iplot
iplot(est_did)

# Using i() for factors
est_bis = feols(y ~ x1 + i(period, keep = 3:6) + i(period, treat, 5) | id, base_did)

# we plot the second set of variables created with i()
# =&gt; we need to use keep (otherwise only the first one is represented)
coefplot(est_bis, keep = "trea")

# =&gt; special treatment in etable
etable(est_bis, dict = c("6" = "six"))

#
# Interact two factors
#

# We use the i. prefix to consider week as a factor
data(airquality)
aq = airquality
aq$week = aq$Day %/% 7 + 1

# Interacting Month and week:
res_2F = feols(Ozone ~ Solar.R + i(Month, i.week), aq)

# Same but dropping the 5th Month and 1st week
res_2F_bis = feols(Ozone ~ Solar.R + i(Month, i.week, ref = 5, ref2 = 1), aq)

etable(res_2F, res_2F_bis)

#
# Binning
#

data(airquality)

feols(Ozone ~ i(Month, bin = "bin::2"), airquality)

feols(Ozone ~ i(Month, bin = list(summer = 7:9)), airquality)



</code></pre>

<hr>
<h2 id='lag.formula'>Lags a variable using a formula</h2><span id='topic+lag.formula'></span><span id='topic+lag_fml'></span>

<h3>Description</h3>

<p>Lags a variable using panel id + time identifiers in a formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
lag(
  x,
  k = 1,
  data,
  time.step = NULL,
  fill = NA,
  duplicate.method = c("none", "first"),
  ...
)

lag_fml(
  x,
  k = 1,
  data,
  time.step = NULL,
  fill = NA,
  duplicate.method = c("none", "first"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag.formula_+3A_x">x</code></td>
<td>
<p>A formula of the type <code>var ~ id + time</code> where <code>var</code> is the variable to be lagged, <code>id</code> is a variable representing the panel id, and <code>time</code> is the time variable of the panel.</p>
</td></tr>
<tr><td><code id="lag.formula_+3A_k">k</code></td>
<td>
<p>An integer giving the number of lags. Default is 1. For leads, just use a negative number.</p>
</td></tr>
<tr><td><code id="lag.formula_+3A_data">data</code></td>
<td>
<p>Optional, the data.frame in which to evaluate the formula. If not provided, variables will be fetched in the current environment.</p>
</td></tr>
<tr><td><code id="lag.formula_+3A_time.step">time.step</code></td>
<td>
<p>The method to compute the lags, default is <code>NULL</code> (which means automatically set). Can be equal to: <code>"unitary"</code>, <code>"consecutive"</code>, <code>"within.consecutive"</code>, or to a number. If <code>"unitary"</code>, then the largest common divisor between consecutive time periods is used (typically if the time variable represents years, it will be 1). This method can apply only to integer (or convertible to integer) variables. If <code>"consecutive"</code>, then the time variable can be of any type: two successive time periods represent a lag of 1. If <code>"witihn.consecutive"</code> then <strong>within a given id</strong>, two successive time periods represent a lag of 1. Finally, if the time variable is numeric, you can provide your own numeric time step.</p>
</td></tr>
<tr><td><code id="lag.formula_+3A_fill">fill</code></td>
<td>
<p>Scalar. How to fill the observations without defined lead/lag values. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="lag.formula_+3A_duplicate.method">duplicate.method</code></td>
<td>
<p>If several observations have the same id and time values, then the notion of lag is not defined for them. If <code>duplicate.method = "none"</code> (default) and duplicate values are found, this leads to an error. You can use <code>duplicate.method = "first"</code> so that the first occurrence of identical id/time observations will be used as lag.</p>
</td></tr>
<tr><td><code id="lag.formula_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a vector of the same type and length as the variable to be lagged in the formula.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>lag_fml()</code>: Lags a variable using a formula syntax
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>Alternatively, the function <code><a href="#topic+panel">panel</a></code> changes a <code>data.frame</code> into a panel from which the functions <code>l</code> and <code>f</code> (creating leads and lags) can be called. Otherwise you can set the panel 'live' during the estimation using the argument <code>panel.id</code> (see for example in the function <code><a href="#topic+feols">feols</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple example with an unbalanced panel
base = data.frame(id = rep(1:2, each = 4),
                  time = c(1, 2, 3, 4, 1, 4, 6, 9), x = 1:8)

base$lag1 = lag(x~id+time,  1, base) # lag 1
base$lead1 = lag(x~id+time, -1, base) # lead 1
base$lag2_fill0 = lag(x~id+time, 2, base, fill = 0)
# with time.step = "consecutive"
base$lag1_consecutive = lag(x~id+time, 1, base, time.step = "consecutive")
#   =&gt; works for indiv. 2 because 9 (resp. 6) is consecutive to 6 (resp. 4)
base$lag1_within.consecutive = lag(x~id+time, 1, base, time.step = "within")
#   =&gt; now two consecutive years within each indiv is one lag

print(base)

# Argument time.step = "consecutive" is
# mostly useful when the time variable is not a number:
# e.g. c("1991q1", "1991q2", "1991q3") etc

# with duplicates
base_dup = data.frame(id = rep(1:2, each = 4),
                      time = c(1, 1, 1, 2, 1, 2, 2, 3), x = 1:8)

# Error because of duplicate values for (id, time)
try(lag(x~id+time, 1, base_dup))


# Error is bypassed, lag corresponds to first occurence of (id, time)
lag(x~id+time, 1, base_dup, duplicate.method = "first")


# Playing with time steps
base = data.frame(id = rep(1:2, each = 4),
                  time = c(1, 2, 3, 4, 1, 4, 6, 9), x = 1:8)

# time step: 0.5 (here equivalent to lag of 1)
lag(x~id+time, 2, base, time.step = 0.5)

# Error: wrong time step
try(lag(x~id+time, 2, base, time.step = 7))

# Adding NAs + unsorted IDs
base = data.frame(id = rep(1:2, each = 4),
                  time = c(4, NA, 3, 1, 2, NA, 1, 3), x = 1:8)

base$lag1 = lag(x~id+time, 1, base)
base$lag1_within = lag(x~id+time, 1, base, time.step = "w")
base_bis = base[order(base$id, base$time),]

print(base_bis)

# You can create variables without specifying the data within data.table:
if(require("data.table")){
  base = data.table(id = rep(1:2, each = 3), year = 1990 + rep(1:3, 2), x = 1:6)
  base[, x.l1 := lag(x~id+year, 1)]
}



</code></pre>

<hr>
<h2 id='logLik.fixest'>Extracts the log-likelihood</h2><span id='topic+logLik.fixest'></span>

<h3>Description</h3>

<p>This function extracts the log-likelihood from a <code>fixest</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the log-likelihood based on the model fit. You can have more information on the likelihoods in the details of the function <code><a href="#topic+femlm">femlm</a></code>.
</p>


<h3>Value</h3>

<p>It returns a numeric scalar.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. Other statistics functions: <code><a href="#topic+AIC.fixest">AIC.fixest</a></code>, <code><a href="#topic+BIC.fixest">BIC.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data with "Species" fixed-effects
res = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)

nobs(res)
logLik(res)


</code></pre>

<hr>
<h2 id='model.matrix.fixest'>Design matrix of a <code>fixest</code> object</h2><span id='topic+model.matrix.fixest'></span>

<h3>Description</h3>

<p>This function creates the left-hand-side or the right-hand-side(s) of a <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
model.matrix(
  object,
  data,
  type = "rhs",
  na.rm = TRUE,
  subset = FALSE,
  as.matrix = FALSE,
  as.df = FALSE,
  collin.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="model.matrix.fixest_+3A_data">data</code></td>
<td>
<p>If missing (default) then the original data is obtained by evaluating the <code>call</code>. Otherwise, it should be a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="model.matrix.fixest_+3A_type">type</code></td>
<td>
<p>Character vector or one sided formula, default is &quot;rhs&quot;. Contains the type of matrix/data.frame to be returned. Possible values are: &quot;lhs&quot;, &quot;rhs&quot;, &quot;fixef&quot;, &quot;iv.rhs1&quot; (1st stage RHS), &quot;iv.rhs2&quot; (2nd stage RHS), &quot;iv.endo&quot; (endogenous vars.), &quot;iv.exo&quot; (exogenous vars), &quot;iv.inst&quot; (instruments).</p>
</td></tr>
<tr><td><code id="model.matrix.fixest_+3A_na.rm">na.rm</code></td>
<td>
<p>Default is <code>TRUE</code>. Should observations with NAs be removed from the matrix?</p>
</td></tr>
<tr><td><code id="model.matrix.fixest_+3A_subset">subset</code></td>
<td>
<p>Logical or character vector. Default is <code>FALSE</code>. If <code>TRUE</code>, then the matrix created will be restricted only to the variables contained in the argument <code>data</code>, which can then contain a subset of the variables used in the estimation. If a character vector, then only the variables matching the elements of the vector via regular expressions will be created.</p>
</td></tr>
<tr><td><code id="model.matrix.fixest_+3A_as.matrix">as.matrix</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to coerce the result to a matrix.</p>
</td></tr>
<tr><td><code id="model.matrix.fixest_+3A_as.df">as.df</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to coerce the result to a data.frame.</p>
</td></tr>
<tr><td><code id="model.matrix.fixest_+3A_collin.rm">collin.rm</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Whether to remove variables that were found to be collinear during the estimation. Beware: it does not perform a collinearity check.</p>
</td></tr>
<tr><td><code id="model.matrix.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns either a vector, a matrix or a data.frame. It returns a vector for the dependent variable (&quot;lhs&quot;), a data.frame for the fixed-effects (&quot;fixef&quot;) and a matrix for any other type.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. <code><a href="#topic+formula.fixest">formula.fixest</a></code>, <code><a href="#topic+update.fixest">update.fixest</a></code>, <code><a href="#topic+summary.fixest">summary.fixest</a></code>, <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

est = feols(y ~ poly(x1, 2) + x2, base)
head(model.matrix(est))

# Illustration of subset

# subset =&gt; character vector
head(model.matrix(est, subset = "x1"))

# subset =&gt; TRUE, only works with data argument!!
head(model.matrix(est, data = base[, "x1", drop = FALSE], subset = TRUE))



</code></pre>

<hr>
<h2 id='models'>Extracts the models tree from a <code>fixest_multi</code> object</h2><span id='topic+models'></span>

<h3>Description</h3>

<p>Extracts the meta information on all the models contained in a <code>fixest_multi</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>models(x, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="models_+3A_x">x</code></td>
<td>
<p>A <code>fixest_multi</code> object, obtained from a <code>fixest</code> estimation leading to multiple results.</p>
</td></tr>
<tr><td><code id="models_+3A_simplify">simplify</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. The default behavior is to display all the meta information, even if they are identical across models. By using <code>simplify = TRUE</code>, only the information with some variation is kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a <code>data.frame</code> whose first column (named <code>id</code>) is the index of the models and the other columns contain the information specific to each model (e.g. which sample, which RHS,  which dependent variable, etc).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a multiple estimation
base = setNames(iris, c("y", "x1", "x2", "x3", "species"))
est = feols(y ~ csw(x.[, 1:3]), base, fsplit = ~species)

# All the meta information
models(est)

# Illustration: Why use simplify
est_sub = est[sample = 2]
models(est_sub)
models(est_sub, simplify = TRUE)



</code></pre>

<hr>
<h2 id='n_unik'>Prints the number of unique elements in a data set</h2><span id='topic+n_unik'></span><span id='topic+print.vec_n_unik'></span><span id='topic+print.list_n_unik'></span>

<h3>Description</h3>

<p>This utility tool displays the number of unique elements in one or multiple data.frames as well as their number of NA values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_unik(x)

## S3 method for class 'vec_n_unik'
print(x, ...)

## S3 method for class 'list_n_unik'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_unik_+3A_x">x</code></td>
<td>
<p>A formula, with data set names on the LHS and variables on the RHS, like <code>data1 + data2 ~ var1 + var2</code>. The following special variables are admitted: <code>"."</code> to get default values, <code>".N"</code> for the number of observations, <code>".U"</code> for the number of unique rows, <code>".NA"</code> for the number of rows with at least one NA. Variables can be combined with <code>"^"</code>, e.g. <code>df~id^period</code>; use <code>id%^%period</code> to also include the terms on both sides. Note that using <code>:</code> and <code>*</code> is equivalent to <code>^</code> and <code style="white-space: pre;">&#8288;%^%&#8288;</code>. Sub select with <code>id[cond]</code>, when doing so <code>id</code> is automatically included. Conditions can be chained, as in <code>id[cond1, cond2]</code>. Use <code>NA(x, y)</code> in conditions instead of <code>is.na(x) | is.na(y)</code>. Use the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator to have both a condition and its opposite. To compare the keys in two data sets, use <code>data1:data2</code>. If not a formula, <code>x</code> can be: a vector (displays the # of unique values); a <code>data.frame</code> (default values are displayed), or a &quot;sum&quot; of data sets like in <code>x = data1 + data2</code>, in that case it is equivalent to <code>data1 + data2 ~ .</code>.</p>
</td></tr>
<tr><td><code id="n_unik_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a vector containing the number of unique values per element. If several data sets were provided, a list is returned, as long as the number of data sets, each element being a vector of unique values.
</p>


<h3>Special values and functions</h3>

<p>In the formula, you can use the following special values: <code>"."</code>, <code>".N"</code>, <code>".U"</code>, and <code>".NA"</code>.
</p>

<dl>
<dt><code>"."</code></dt><dd><p>Accesses the default values. If there is only one data set and the data set is <em>not</em> a <code>data.table</code>, then the default is to display the number of observations and the number of unique rows. If the data is a <code>data.table</code>, the number of unique items in the key(s) is displayed instead of the number of unique rows (if the table has keys of course). If there are two or more data sets, then the default is to display the unique items for: a) the variables common across all data sets, if there's less than 4, and b) if no variable is shown in a), the number of variables common across at least two data sets, provided there are less than 5. If the data sets are data tables, the keys are also displayed on top of the common variables. In any case, the number of observations is always displayed.</p>
</dd>
<dt><code>".N"</code></dt><dd><p>Displays the number of observations.</p>
</dd>
<dt><code>".U"</code></dt><dd><p>Displays the number of unique rows.</p>
</dd>
<dt><code>".NA"</code></dt><dd><p>Displays the number of rows with at least one NA.</p>
</dd>
</dl>



<h3>The <code>NA</code> function</h3>

<p>The special function <code>NA</code> is an equivalent to <code>is.na</code> but can handle several variables. For instance, <code>NA(x, y)</code> is equivalent to <code>is.na(x) | is.na(y)</code>. You can add as many variables as you want as arguments. If no argument is provided, as in <code>NA()</code>, it is identical to having all the variables of the data set as argument.
</p>


<h3>Combining variables</h3>

<p>Use the &quot;hat&quot;, <code>"^"</code>, operator to combine several variables. For example <code>id^period</code> will display the number of unique values of id x period combinations.
</p>
<p>Use the &quot;super hat&quot;, <code>"%^%"</code>, operator to also include the terms on both sides. For example, instead of writing <code>id + period + id^period</code>, you can simply write <code>id%^%period</code>.
</p>
<p>Alternatively, you can use <code>:</code> for <code>^</code> and <code>*</code> for <code style="white-space: pre;">&#8288;%^%&#8288;</code>.
</p>


<h3>Sub-selections</h3>

<p>To show the number of unique values for sub samples, simply use <code style="white-space: pre;">&#8288;[]&#8288;</code>. For example, <code>id[x &gt; 10]</code> will display the number of unique <code>id</code> for which <code>x &gt; 10</code>.
</p>
<p>Simple square brackets lead to the inclusion of both the variable and its subset. For example <code>id[x &gt; 10]</code> is equivalent to <code>id + id[x &gt; 10]</code>. To include only the sub selection, use double square brackets, as in <code>id[[x &gt; 10]]</code>.
</p>
<p>You can add multiple sub selections at once, only separate them with a comma. For example <code>id[x &gt; 10, NA(y)]</code> is equivalent to <code>id[x &gt; 10] + id[NA(y)]</code>.
</p>
<p>Use the double negative operator, i.e. <code style="white-space: pre;">&#8288;!!&#8288;</code>, to include both a condition and its opposite at once. For example <code>id[!!x &gt; 10]</code> is equivalent to <code>id[x &gt; 10, !x &gt; 10]</code>. Double negative operators can be chained, like in <code>id[!!cond1 &amp; !!cond2]</code>, then the cardinal product of all double negatived conditions is returned.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data = base_did
data$x1.L1 = round(lag(x1~id+period, 1, data))

# By default, just the formatted number of observations
n_unik(data)

# Or the nber of unique elements of a vector
n_unik(data$id)

# number of unique id values and id x period pairs
n_unik(data ~.N + id + id^period)

# use the %^% operator to include the terms on the two sides at once
# =&gt; same as id*period
n_unik(data ~.N + id %^% period)

# using sub selection with []
n_unik(data ~.N + period[!NA(x1.L1)])

# to show only the sub selection: [[]]
n_unik(data ~.N + period[[!NA(x1.L1)]])

# you can have multiple values in [],
# just separate them with a comma
n_unik(data ~.N + period[!NA(x1.L1), x1 &gt; 7])

# to have both a condition and its opposite,
# use the !! operator
n_unik(data ~.N[!!NA(x1.L1)])

# the !! operator works within condition chains
n_unik(data ~.N[!!NA(x1.L1) &amp; !!x1 &gt; 7])

# Conditions can be distributed
n_unik(data ~ (id + period)[x1 &gt; 7])

#
# Several data sets
#

# Typical use case: merging
# Let's create two data sets and merge them

data(base_did)
base_main = base_did
base_extra = sample_df(base_main[, c("id", "period")], 100)
base_extra$id[1:10] = 111:120
base_extra$period[11:20] = 11:20
base_extra$z = rnorm(100)

# You can use db1:db2 to compare the common keys in two data sets
 n_unik(base_main:base_extra)

tmp = merge(base_main, base_extra, all.x = TRUE, by = c("id", "period"))

# You can show unique values for any variable, as before
n_unik(tmp + base_main + base_extra ~ id[!!NA(z)] + id^period)



</code></pre>

<hr>
<h2 id='nobs.fixest'>Extracts the number of observations form a <code>fixest</code> object</h2><span id='topic+nobs.fixest'></span>

<h3>Description</h3>

<p>This function simply extracts the number of observations form a <code>fixest</code> object, obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="nobs.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an interger.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. Use <code><a href="#topic+summary.fixest">summary.fixest</a></code> to see the results with the appropriate standard-errors, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> to extract the fixed-effects coefficients, and the function <code><a href="#topic+etable">etable</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data with "Species" fixed-effects
res = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
            Petal.Width | Species, iris)

nobs(res)
logLik(res)


</code></pre>

<hr>
<h2 id='obs'>Extracts the observations used for the estimation</h2><span id='topic+obs'></span>

<h3>Description</h3>

<p>This function extracts the observations used in <code>fixest</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obs_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a simple vector of integers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")
base$y[1:5] = NA

# Split sample estimations
est_split = feols(y ~ x1, base, split = ~species)
(obs_setosa = obs(est_split[[1]]))
(obs_versi = obs(est_split[sample = "versi", drop = TRUE]))

est_versi = feols(y ~ x1, base, subset = obs_versi)

etable(est_split, est_versi)




</code></pre>

<hr>
<h2 id='osize'>Formatted object size</h2><span id='topic+osize'></span><span id='topic+print.osize'></span>

<h3>Description</h3>

<p>Tools that returns a formatted object size, where the appropriate unit is automatically chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osize(x)

## S3 method for class 'osize'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osize_+3A_x">x</code></td>
<td>
<p>Any R object.</p>
</td></tr>
<tr><td><code id="osize_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character scalar.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
osize(iris)

data(trade)
osize(trade)


</code></pre>

<hr>
<h2 id='panel'>Constructs a <code>fixest</code> panel data base</h2><span id='topic+panel'></span>

<h3>Description</h3>

<p>Constructs a <code>fixest</code> panel data base out of a data.frame which allows to use leads and lags in <code>fixest</code> estimations and to create new variables from leads and lags if the data.frame was also a <code><a href="data.table.html#topic+data.table">data.table::data.table</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel(data, panel.id, time.step = NULL, duplicate.method = c("none", "first"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel_+3A_data">data</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="panel_+3A_panel.id">panel.id</code></td>
<td>
<p>The panel identifiers. Can either be: i) a one sided formula (e.g. <code>panel.id = ~id+time</code>), ii) a character vector of length 2 (e.g. <code>panel.id=c('id', 'time')</code>, or iii) a character scalar of two variables separated by a comma (e.g. <code>panel.id='id,time'</code>). Note that you can combine variables with <code>^</code> only inside formulas (see the dedicated section in <code><a href="#topic+feols">feols</a></code>).</p>
</td></tr>
<tr><td><code id="panel_+3A_time.step">time.step</code></td>
<td>
<p>The method to compute the lags, default is <code>NULL</code> (which means automatically set). Can be equal to: <code>"unitary"</code>, <code>"consecutive"</code>, <code>"within.consecutive"</code>, or to a number. If <code>"unitary"</code>, then the largest common divisor between consecutive time periods is used (typically if the time variable represents years, it will be 1). This method can apply only to integer (or convertible to integer) variables. If <code>"consecutive"</code>, then the time variable can be of any type: two successive time periods represent a lag of 1. If <code>"witihn.consecutive"</code> then <strong>within a given id</strong>, two successive time periods represent a lag of 1. Finally, if the time variable is numeric, you can provide your own numeric time step.</p>
</td></tr>
<tr><td><code id="panel_+3A_duplicate.method">duplicate.method</code></td>
<td>
<p>If several observations have the same id and time values, then the notion of lag is not defined for them. If <code>duplicate.method = "none"</code> (default) and duplicate values are found, this leads to an error. You can use <code>duplicate.method = "first"</code> so that the first occurrence of identical id/time observations will be used as lag.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows you to use leads and lags in a <code>fixest</code> estimation without having to provide the argument <code>panel.id</code>. It also offers more options on how to set the panel (with the additional arguments 'time.step' and 'duplicate.method').
</p>
<p>When the initial data set was also a <code>data.table</code>, not all operations are supported and some may dissolve the <code>fixest_panel</code>. This is the case when creating subselections of the initial data with additional attributes (e.g. <code>pdt[x&gt;0, .(x, y, z)]</code> would dissolve the <code>fixest_panel</code>, meaning only a data.table would be the result of the call).
</p>
<p>If the initial data set was also a <code>data.table</code>, then you can create new variables from lags and leads using the functions <code><a href="#topic+l">l</a></code> and <code><a href="#topic+l">f</a></code>. See the example.
</p>


<h3>Value</h3>

<p>It returns a data base identical to the one given in input, but with an additional attribute: &ldquo;panel_info&rdquo;. This attribute contains vectors used to efficiently create lags/leads of the data. When the data is subselected, some bookeeping is performed on the attribute &ldquo;panel_info&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>The estimation methods <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">fepois</a></code> and <code><a href="#topic+feglm">feglm</a></code>.
</p>
<p>The functions <code><a href="#topic+l">l</a></code> and <code><a href="#topic+l">f</a></code> to create lags and leads within <code>fixest_panel</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(base_did)

# Setting a data set as a panel...
pdat = panel(base_did, ~id+period)

# ...then using the functions l and f
est1 = feols(y~l(x1, 0:1), pdat)
est2 = feols(f(y)~l(x1, -1:1), pdat)
est3 = feols(l(y)~l(x1, 0:3), pdat)
etable(est1, est2, est3, order = c("f", "^x"), drop="Int")

# or using the argument panel.id
feols(f(y)~l(x1, -1:1), base_did, panel.id = ~id+period)

# You can use panel.id in various ways:
pdat = panel(base_did, ~id+period)
# is identical to:
pdat = panel(base_did, c("id", "period"))
# and also to:
pdat = panel(base_did, "id,period")

# l() and f() can also be used within a data.table:
if(require("data.table")){
  pdat_dt = panel(as.data.table(base_did), ~id+period)
  # Now since pdat_dt is also a data.table
  #   you can create lags/leads directly
  pdat_dt[, x1_l1 := l(x1)]
  pdat_dt[, c("x1_l1_fill0", "y_f2") := .(l(x1, fill = 0), f(y, 2))]
}


</code></pre>

<hr>
<h2 id='plot.fixest.fixef'>Displaying the most notable fixed-effects</h2><span id='topic+plot.fixest.fixef'></span>

<h3>Description</h3>

<p>This function plots the 5 fixed-effects with the highest and lowest values, for each of the fixed-effect dimension. It takes as an argument the fixed-effects obtained from the function <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> after an estimation using <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest.fixef'
plot(x, n = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fixest.fixef_+3A_x">x</code></td>
<td>
<p>An object obtained from the function <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fixest.fixef_+3A_n">n</code></td>
<td>
<p>The number of fixed-effects to be drawn. Defaults to 5.</p>
</td></tr>
<tr><td><code id="plot.fixest.fixef_+3A_...">...</code></td>
<td>
<p>Not currently used.
</p>
<p>Note that the fixed-effect coefficients might NOT be interpretable. This function is useful only for fully regular panels.
</p>
<p>If the data are not regular in the fixed-effect coefficients, this means that several &lsquo;reference points&rsquo; are set to obtain the fixed-effects, thereby impeding their interpretation. In this case a warning is raised.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.fixest">fixef.fixest</a></code> to extract clouster coefficients. See also the main estimation function <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. Use <code><a href="#topic+summary.fixest">summary.fixest</a></code> to see the results with the appropriate standard-errors, the function <code><a href="#topic+etable">etable</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(trade)

# We estimate the effect of distance on trade
# =&gt; we account for 3 fixed-effects
est_pois = femlm(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# obtaining the fixed-effects coefficients
fe_trade = fixef(est_pois)

# plotting them
plot(fe_trade)


</code></pre>

<hr>
<h2 id='predict.fixest'>Predict method for <code>fixest</code> fits</h2><span id='topic+predict.fixest'></span>

<h3>Description</h3>

<p>This function obtains prediction from a fitted model estimated with <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
predict(
  object,
  newdata,
  type = c("response", "link"),
  se.fit = FALSE,
  interval = "none",
  level = 0.95,
  fixef = FALSE,
  vs.coef = FALSE,
  sample = c("estimation", "original"),
  vcov = NULL,
  ssc = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame containing the variables used to make the prediction. If not provided, the fitted expected (or linear if <code>type = "link"</code>) predictors are returned.</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_type">type</code></td>
<td>
<p>Character either equal to <code>"response"</code> (default) or <code>"link"</code>. If <code>type="response"</code>, then the output is at the level of the response variable, i.e. it is the expected predictor <code class="reqn">E(Y|X)</code>. If <code>"link"</code>, then the output is at the level of the explanatory variables, i.e. the linear predictor <code class="reqn">X\cdot \beta</code>.</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_se.fit">se.fit</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, the standard-error of the predicted value is computed and returned in a column named <code>se.fit</code>. This feature is only available for OLS models not containing fixed-effects.</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_interval">interval</code></td>
<td>
<p>Either &quot;none&quot; (default), &quot;confidence&quot; or &quot;prediction&quot;. What type of confidence interval to compute. Note that this feature is only available for OLS models not containing fixed-effects (GLM/ML models are not covered).</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_level">level</code></td>
<td>
<p>A numeric scalar in between 0.5 and 1, defaults to 0.95. Only used when the argument 'interval' is requested, it corresponds to the width of the confidence interval.</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_fixef">fixef</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, a data.frame is returned, with each column representing the fixed-effects coefficients for each observation in <code>newdata</code> &ndash; with as many columns as fixed-effects. Note that when there are variables with varying slopes, the slope coefficients are returned (i.e. they are not multiplied by the variable).</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_vs.coef">vs.coef</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Only used when <code>fixef = TRUE</code> and when variables with varying slopes are present. If <code>TRUE</code>, the coefficients of the variables with varying slopes are returned instead of the coefficient multiplied by the value of the variables (default).</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_sample">sample</code></td>
<td>
<p>Either &quot;estimation&quot; (default) or &quot;original&quot;. This argument is only used when arg. 'newdata' is missing, and is ignored otherwise. If equal to &quot;estimation&quot;, the vector returned matches the sample used for the estimation. If equal to &quot;original&quot;, it matches the original data set (the observations not used for the estimation being filled with NAs).</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="predict.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a numeric vector of length equal to the number of observations in argument <code>newdata</code>.
If <code>newdata</code> is missing, it returns a vector of the same length as the estimation sample, except if <code>sample = "original"</code>, in which case the length of the vector will match the one of the original data set (which can, but also cannot, be the estimation sample).
If <code>fixef = TRUE</code>, a <code>data.frame</code> is returned.
If <code>se.fit = TRUE</code> or <code>interval != "none"</code>, the object returned is a data.frame with the following columns: <code>fit</code>, <code>se.fit</code>, and, if CIs are requested, <code>ci_low</code> and <code>ci_high</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. <code><a href="#topic+update.fixest">update.fixest</a></code>, <code><a href="#topic+summary.fixest">summary.fixest</a></code>, <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Estimation on iris data
res = fepois(Sepal.Length ~ Petal.Length | Species, iris)

# what would be the prediction if the data was all setosa?
newdata = data.frame(Petal.Length = iris$Petal.Length, Species = "setosa")
pred_setosa = predict(res, newdata = newdata)

# Let's look at it graphically
plot(c(1, 7), c(3, 11), type = "n", xlab = "Petal.Length",
     ylab = "Sepal.Length")

newdata = iris[order(iris$Petal.Length), ]
newdata$Species = "setosa"
lines(newdata$Petal.Length, predict(res, newdata))

# versicolor
newdata$Species = "versicolor"
lines(newdata$Petal.Length, predict(res, newdata), col=2)

# virginica
newdata$Species = "virginica"
lines(newdata$Petal.Length, predict(res, newdata), col=3)

# The original data
points(iris$Petal.Length, iris$Sepal.Length, col = iris$Species, pch = 18)
legend("topleft", lty = 1, col = 1:3, legend = levels(iris$Species))


#
# Getting the fixed-effect coefficients for each obs.
#

data(trade)
est_trade = fepois(Euros ~ log(dist_km) | Destination^Product +
                                           Origin^Product + Year, trade)
obs_fe = predict(est_trade, fixef = TRUE)
head(obs_fe)

# can we check we get the right sum of fixed-effects
head(cbind(rowSums(obs_fe), est_trade$sumFE))


#
# Standard-error of the prediction
#

base = setNames(iris, c("y", "x1", "x2", "x3", "species"))

est = feols(y ~ x1 + species, base)

head(predict(est, se.fit = TRUE))

# regular confidence interval
head(predict(est, interval = "conf"))

# adding the residual to the CI
head(predict(est, interval = "predi"))

# You can change the type of SE on the fly
head(predict(est, interval = "conf", vcov = ~species))



</code></pre>

<hr>
<h2 id='print.fixest'>A print facility for <code>fixest</code> objects.</h2><span id='topic+print.fixest'></span><span id='topic+setFixest_print'></span><span id='topic+getFixest_print'></span>

<h3>Description</h3>

<p>This function is very similar to usual <code>summary</code> functions as it
provides the table of coefficients along with other information on the fit of
the estimation. The type of output can be customized by the user (using
function <code>setFixest_print</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
print(x, n, type = "table", fitstat = NULL, ...)

setFixest_print(type = "table", fitstat = NULL)

getFixest_print()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fixest_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the methods
<code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or
<code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="print.fixest_+3A_n">n</code></td>
<td>
<p>Integer, number of coefficients to display. By default, only the
first 8 coefficients are displayed if <code>x</code> does not come from
<code><a href="#topic+summary.fixest">summary.fixest</a></code>.</p>
</td></tr>
<tr><td><code id="print.fixest_+3A_type">type</code></td>
<td>
<p>Either <code>"table"</code> (default) to display the coefficients table
or <code>"coef"</code> to display only the coefficients.</p>
</td></tr>
<tr><td><code id="print.fixest_+3A_fitstat">fitstat</code></td>
<td>
<p>A formula or a character vector representing which fit
statistic to display. The types must be valid types of the function
<code><a href="#topic+fitstat">fitstat</a></code>. The default fit statistics depend on the
type of estimation (OLS, GLM, IV, with/without fixed-effect). Providing the
argument <code>fitstat</code> overrides the default fit statistics, you can
however use the point &quot;.&quot; to summon them back. Ex 1: <code>fitstat = ~ . + ll</code> adds the log-likelihood to the default values. Ex 2: <code>fitstat = ~ ll + pr2</code> only displays the log-likelihood and the pseudo-R2.</p>
</td></tr>
<tr><td><code id="print.fixest_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to set the default values for the arguments
<code>type</code> and <code>fitstat</code> by using the function <code>setFixest_print</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>,
<code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. Use
<code><a href="#topic+summary.fixest">summary.fixest</a></code> to see the results with the appropriate
standard-errors, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> to extract the
fixed-effects coefficients, and the function <code><a href="#topic+etable">etable</a></code> to
visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load trade data
data(trade)

# We estimate the effect of distance on trade
#   =&gt; we account for 3 fixed-effects (FEs)
est_pois = fepois(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# displaying the results
#  (by default SEs are clustered if FEs are used)
print(est_pois)

# By default the coefficient table is displayed.
#  If the user wished to display only the coefficents, use option type:
print(est_pois, type = "coef")

# To permanently display coef. only, use setFixest_print:
setFixest_print(type = "coef")
est_pois
# back to default:
setFixest_print(type = "table")

#
# fitstat
#

# We modify which fit statistic to display
print(est_pois, fitstat = ~ . + lr)

# We add the LR test to the default (represented by the ".")

# to show only the LR stat:
print(est_pois, fitstat = ~ . + lr.stat)

# To modify the defaults:
setFixest_print(fitstat = ~ . + lr.stat + rmse)
est_pois

# Back to default (NULL == default)
setFixest_print(fitstat = NULL)


</code></pre>

<hr>
<h2 id='print.fixest_fitstat'>Print method for fit statistics of fixest estimations</h2><span id='topic+print.fixest_fitstat'></span>

<h3>Description</h3>

<p>Displays a brief summary of selected fit statistics from the function <code><a href="#topic+fitstat">fitstat</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_fitstat'
print(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fixest_fitstat_+3A_x">x</code></td>
<td>
<p>An object resulting from the <code><a href="#topic+fitstat">fitstat</a></code> function.</p>
</td></tr>
<tr><td><code id="print.fixest_fitstat_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, the statistics that are missing are not displayed.</p>
</td></tr>
<tr><td><code id="print.fixest_fitstat_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(trade)
gravity = feols(log(Euros) ~ log(dist_km) | Destination + Origin, trade)

# Extracting the 'working' number of observations used to compute the pvalues
fitstat(gravity, "g", simplify = TRUE)

# Some fit statistics
fitstat(gravity, ~ rmse + r2 + wald + wf)

# You can use them in etable
etable(gravity, fitstat = ~ rmse + r2 + wald + wf)

# For wald and wf, you could show the pvalue instead:
etable(gravity, fitstat = ~ rmse + r2 + wald.p + wf.p)

# Now let's display some statistics that are not built-in
# =&gt; we use fitstat_register to create them

# We need: a) type name, b) the function to be applied
#          c) (optional) an alias

fitstat_register("tstand", function(x) tstat(x, se = "stand")[1], "t-stat (regular)")
fitstat_register("thc", function(x) tstat(x, se = "heter")[1], "t-stat (HC1)")
fitstat_register("t1w", function(x) tstat(x, se = "clus")[1], "t-stat (clustered)")
fitstat_register("t2w", function(x) tstat(x, se = "twow")[1], "t-stat (2-way)")

# Now we can use these keywords in fitstat:
etable(gravity, fitstat = ~ . + tstand + thc + t1w + t2w)

# Note that the custom stats we created are can easily lead
# to errors, but that's another story!


</code></pre>

<hr>
<h2 id='print.fixest_multi'>Print method for fixest_multi objects</h2><span id='topic+print.fixest_multi'></span>

<h3>Description</h3>

<p>Displays summary information on fixest_multi objects in the R console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_multi'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fixest_multi_+3A_x">x</code></td>
<td>
<p>A <code>fixest_multi</code> object, obtained from a <code>fixest</code> estimation leading to multiple results.</p>
</td></tr>
<tr><td><code id="print.fixest_multi_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+summary.fixest_multi">summary.fixest_multi</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The main fixest estimation functions: <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">fepois</a></code>, <code><a href="#topic+femlm">fenegbin</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>. Tools for mutliple fixest estimations: <code><a href="#topic+summary.fixest_multi">summary.fixest_multi</a></code>, <code><a href="#topic+print.fixest_multi">print.fixest_multi</a></code>, <code><a href="#topic+as.list.fixest_multi">as.list.fixest_multi</a></code>, <code><a href="#topic+sub-sub-.fixest_multi">sub-sub-.fixest_multi</a></code>, <code><a href="#topic+sub-.fixest_multi">sub-.fixest_multi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

# Multiple estimation
res = feols(y ~ csw(x1, x2, x3), base, split = ~species)

# Let's print all that
res

</code></pre>

<hr>
<h2 id='r2'>R2s of <code>fixest</code> models</h2><span id='topic+r2'></span>

<h3>Description</h3>

<p>Reports different R2s for <code>fixest</code> estimations (e.g. <code><a href="#topic+feglm">feglm</a></code> or <code><a href="#topic+feols">feols</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2(x, type = "all", full_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r2_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object, e.g. obtained with function <code><a href="#topic+feglm">feglm</a></code> or <code><a href="#topic+feols">feols</a></code>.</p>
</td></tr>
<tr><td><code id="r2_+3A_type">type</code></td>
<td>
<p>A character vector representing the R2 to compute. The R2 codes are of the form: &quot;wapr2&quot; with letters &quot;w&quot; (within), &quot;a&quot; (adjusted) and &quot;p&quot; (pseudo) possibly missing. E.g. to get the regular R2: use <code>type = "r2"</code>, the within adjusted R2: use <code>type = "war2"</code>, the pseudo R2: use <code>type = "pr2"</code>, etc. Use <code>"cor2"</code> for the squared correlation. By default, all R2s are computed.</p>
</td></tr>
<tr><td><code id="r2_+3A_full_names">full_names</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code> then names of the vector in output will have full names instead of keywords (e.g. <code style="white-space: pre;">&#8288;Squared Correlation&#8288;</code> instead of <code>cor2</code>, etc).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pseudo R2s are the McFaddens R2s, that is the ratio of log-likelihoods.
</p>
<p>For R2s with no theoretical justification, like e.g. regular R2s for maximum likelihood models &ndash; or within R2s for models without fixed-effects, NA is returned. The single measure to possibly compare all kinds of models is the squared correlation between the dependent variable and the expected predictor.
</p>
<p>The pseudo-R2 is also returned in the OLS case, it corresponds to the pseudo-R2 of the equivalent GLM model with a Gaussian family.
</p>
<p>For the adjusted within-R2s, the adjustment factor is <code>(n - nb_fe) / (n - nb_fe - K)</code> with <code>n</code> the number of observations, <code>nb_fe</code> the number of fixed-effects and <code>K</code> the number of variables.
</p>


<h3>Value</h3>

<p>Returns a named vector.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load trade data
data(trade)

# We estimate the effect of distance on trade (with 3 fixed-effects)
est = feols(log(Euros) ~ log(dist_km)|Origin+Destination+Product, trade)

# Squared correlation:
r2(est, "cor2")

# "regular" r2:
r2(est, "r2")

# pseudo r2 (equivalent to GLM with Gaussian family)
r2(est, "pr2")

# adjusted within r2
r2(est, "war2")

# all four at once
r2(est, c("cor2", "r2", "pr2", "war2"))

# same with full names instead of codes
r2(est, c("cor2", "r2", "pr2", "war2"), full_names = TRUE)

</code></pre>

<hr>
<h2 id='ref'>Refactors a variable</h2><span id='topic+ref'></span>

<h3>Description</h3>

<p>Takes a variables of any types, transforms it into a factors, and modifies the values of the factors. Useful in estimations when you want to set some value of a vector as a reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref(x, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref_+3A_x">x</code></td>
<td>
<p>A vector of any type (must be atomic though).</p>
</td></tr>
<tr><td><code id="ref_+3A_ref">ref</code></td>
<td>
<p>A vector or a list, or special binning values (explained later). If a vector, it must correspond to (partially matched) values of the vector <code>x</code>. The vector <code>x</code> which will be transformed into a factor and these values will be placed first in the levels. That's the main usage of this function. You can also bin on-the-fly the values of <code>x</code>, using the same syntax as the function <code><a href="#topic+bin">bin</a></code>. To create a new value from old values, use <code>ref = list("new_value"=old_values)</code> with <code>old_values</code> a vector of existing values. You can use <code>.()</code> for <code>list()</code>.
It accepts regular expressions, but they must start with an <code>"@"</code>, like in <code>ref="@Aug|Dec"</code>. It accepts one-sided formulas which must contain the variable <code>x</code>, e.g. <code>ref=list("&lt;2" = ~x &lt; 2)</code>.
The names of the list are the new names. If the new name is missing, the first value matched becomes the new name. In the name, adding <code>"@d"</code>, with <code>d</code> a digit, will relocate the value in position <code>d</code>: useful to change the position of factors.
If the vector <code>x</code> is numeric, you can use the special value <code>"bin::digit"</code> to group every <code>digit</code> element.
For example if <code>x</code> represents years, using <code>ref="bin::2"</code> creates bins of two years.
With any data, using <code>"!bin::digit"</code> groups every digit consecutive values starting from the first value.
Using <code>"!!bin::digit"</code> is the same but starting from the last value.
With numeric vectors you can: a) use <code>"cut::n"</code> to cut the vector into <code>n</code> equal parts, b) use <code>"cut::a]b["</code> to create the following bins: <code style="white-space: pre;">&#8288;[min, a]&#8288;</code>, <code style="white-space: pre;">&#8288;]a, b[&#8288;</code>, <code style="white-space: pre;">&#8288;[b, max]&#8288;</code>.
The latter syntax is a sequence of number/quartile (q0 to q4)/percentile (p0 to p100) followed by an open or closed square bracket. You can add custom bin names by adding them in the character vector after <code>'cut::values'</code>. See details and examples. Dot square bracket expansion (see <code><a href="#topic+dsb">dsb</a></code>) is enabled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a factor of the same length as <code>x</code>, where levels have been modified according to the argument <code>ref</code>.
</p>


<h3>&quot;Cutting&quot; a numeric vector</h3>

<p>Numeric vectors can be cut easily into: a) equal parts, b) user-specified bins.
</p>
<p>Use <code>"cut::n"</code> to cut the vector into <code>n</code> (roughly) equal parts. Percentiles are used to partition the data, hence some data distributions can lead to create less than <code>n</code> parts (for example if P0 is the same as P50).
</p>
<p>The user can specify custom bins with the following syntax: <code>"cut::a]b]c]"</code>. Here the numbers <code>a</code>, <code>b</code>, <code>c</code>, etc, are a sequence of increasing numbers, each followed by an open or closed square bracket. The numbers can be specified as either plain numbers (e.g. <code>"cut::5]12[32["</code>), quartiles (e.g. <code>"cut::q1]q3["</code>), or percentiles (e.g. <code>"cut::p10]p15]p90]"</code>). Values of different types can be mixed: <code>"cut::5]q2[p80["</code> is valid provided the median (<code>q2</code>) is indeed greater than <code>5</code>, otherwise an error is thrown.
</p>
<p>The square bracket right of each number tells whether the numbers should be included or excluded from the current bin. For example, say <code>x</code> ranges from 0 to 100, then <code>"cut::5]"</code> will create two  bins: one from 0 to 5 and a second from 6 to 100. With <code>"cut::5["</code> the bins would have been 0-4 and 5-100.
</p>
<p>A factor is always returned. The labels always report the min and max values in each bin.
</p>
<p>To have user-specified bin labels, just add them in the character vector following <code>'cut::values'</code>. You don't need to provide all of them, and <code>NA</code> values fall back to the default label. For example, <code>bin = c("cut::4", "Q1", NA, "Q3")</code> will modify only the first and third label that will be displayed as <code>"Q1"</code> and <code>"Q3"</code>.
</p>


<h3><code>bin</code> vs <code>ref</code></h3>

<p>The functions <code><a href="#topic+bin">bin</a></code> and <code><a href="#topic+ref">ref</a></code> are able to do the same thing, then why use one instead of the other? Here are the differences:
</p>

<ul>
<li> <p><code>ref</code> always returns a factor. This is in contrast with <code>bin</code> which returns, when possible, a vector of the same type as the vector in input.
</p>
</li>
<li> <p><code>ref</code> always places the values modified in the first place of the factor levels. On the other hand, <code>bin</code> tries to not modify the ordering of the levels. It is possible to make <code>bin</code> mimic the behavior of <code>ref</code> by adding an <code>"@"</code> as the first element of the list in the argument <code>bin</code>.
</p>
</li>
<li><p> when a vector (and not a list) is given in input, <code>ref</code> will place each element of the vector in the first place of the factor levels. The behavior of <code>bin</code> is totally different, <code>bin</code> will transform all the values in the vector into a single value in <code>x</code> (i.e. it's binning).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>To bin the values of a vector: <code><a href="#topic+bin">bin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(airquality)

# A vector of months
month_num = airquality$Month
month_lab = c("may", "june", "july", "august", "september")
month_fact = factor(month_num, labels = month_lab)
table(month_num)
table(month_fact)

#
# Main use
#

# Without argument: equivalent to as.factor
ref(month_num)

# Main usage: to set a level first:
# (Note that partial matching is enabled.)
table(ref(month_fact, "aug"))

# You can rename the level on-the-fly
# (Northern hemisphere specific!)
table(ref(month_fact, .("Hot month"="aug",
                        "Late summer" = "sept")))


# Main use is in estimations:
a = feols(Petal.Width ~ Petal.Length + Species, iris)

# We change the reference
b = feols(Petal.Width ~ Petal.Length + ref(Species, "vers"), iris)

etable(a, b)


#
# Binning
#

# You can also bin factor values on the fly
# Using @ first means a regular expression will be used to match the values.
# Note that the value created is placed first.
# To avoid that behavior =&gt; use the function "bin"
table(ref(month_fact, .(summer = "@jul|aug|sep")))

# Please refer to the example in the bin help page for more example.
# The syntax is the same.


#
# Precise relocation
#

# You can place a factor at the location you want
#  by adding "@digit" in the name first:
table(ref(month_num, .("@5"=5)))

# Same with renaming
table(ref(month_num, .("@5 five"=5)))


</code></pre>

<hr>
<h2 id='rep.fixest'>Replicates <code>fixest</code> objects</h2><span id='topic+rep.fixest'></span><span id='topic+rep.fixest_list'></span><span id='topic+.l'></span>

<h3>Description</h3>

<p>Simple function that replicates <code>fixest</code> objects while (optionally) computing different standard-errors. Useful mostly in combination with <code><a href="#topic+etable">etable</a></code> or <code><a href="#topic+coefplot">coefplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
rep(x, times = 1, each = 1, vcov, ...)

## S3 method for class 'fixest_list'
rep(x, times = 1, each = 1, vcov, ...)

.l(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep.fixest_+3A_x">x</code></td>
<td>
<p>Either a <code>fixest</code> object, either a list of <code>fixest</code> objects created with <code>.l()</code>.</p>
</td></tr>
<tr><td><code id="rep.fixest_+3A_times">times</code></td>
<td>
<p>Integer vector giving the number of repetitions of the vector of elements. By default <code>times = 1</code>. It must be either of length 1, either of the same length as the argument <code>x</code>.</p>
</td></tr>
<tr><td><code id="rep.fixest_+3A_each">each</code></td>
<td>
<p>Integer scalar indicating the repetition of each element. Default is 1.</p>
</td></tr>
<tr><td><code id="rep.fixest_+3A_vcov">vcov</code></td>
<td>
<p>A list containing the types of standard-error to be computed, default is missing. If not missing, it must be of the same length as <code>times</code>, <code>each</code>, or the final vector. Note that if the arguments <code>times</code> and <code>each</code> are missing, then <code>times</code> becomes equal to the length of <code>vcov</code>. To see how to summon a VCOV, see the dedicated section in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="rep.fixest_+3A_...">...</code></td>
<td>
<p>In <code>.l()</code>: <code>fixest</code> objects. In <code>rep()</code>: not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To apply <code>rep.fixest</code> on a list of <code>fixest</code> objects, it is absolutely necessary to use <code>.l()</code> and not <code>list()</code>.
</p>


<h3>Value</h3>

<p>Returns a list of the appropriate length. Each element of the list is a <code>fixest</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's show results with different standard-errors

est = feols(Ozone ~ Solar.R + Wind + Temp, data = airquality)

my_vcov = list(~ Month, ~ Day, ~ Day + Month)

etable(rep(est, vcov = my_vcov))

coefplot(rep(est, vcov = my_vcov), drop = "Int")

#
# To rep multiple objects, you need to use .l()
#

est_bis = feols(Ozone ~ Solar.R + Wind + Temp | Month, airquality)

etable(rep(.l(est, est_bis), vcov = my_vcov))

# using each
etable(rep(.l(est, est_bis), each = 3, vcov = my_vcov))


</code></pre>

<hr>
<h2 id='resid.fixest'>Extracts residuals from a <code>fixest</code> object</h2><span id='topic+resid.fixest'></span><span id='topic+residuals.fixest'></span>

<h3>Description</h3>

<p>This function extracts residuals from a fitted model estimated with <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
resid(
  object,
  type = c("response", "deviance", "pearson", "working"),
  na.rm = TRUE,
  ...
)

## S3 method for class 'fixest'
residuals(
  object,
  type = c("response", "deviance", "pearson", "working"),
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="resid.fixest_+3A_type">type</code></td>
<td>
<p>A character scalar, either <code>"response"</code> (default), <code>"deviance"</code>, <code>"pearson"</code>, or <code>"working"</code>. Note that the <code>"working"</code> corresponds to the residuals from the weighted least square and only applies to <code><a href="#topic+feglm">feglm</a></code> models.</p>
</td></tr>
<tr><td><code id="resid.fixest_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether to remove the observations with NAs from the original data set. If <code>FALSE</code>, then the vector returned is always of the same length as the original data set.</p>
</td></tr>
<tr><td><code id="resid.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a numeric vector of the length the number of observations used for the estimation (if <code>na.rm = TRUE</code>) or of the length of the original data set (if <code>na.rm = FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. <code><a href="#topic+fitted.fixest">fitted.fixest</a></code>, <code><a href="#topic+predict.fixest">predict.fixest</a></code>, <code><a href="#topic+summary.fixest">summary.fixest</a></code>, <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, using "Species" fixed-effects
res_poisson = femlm(Sepal.Length ~ Sepal.Width + Petal.Length +
                    Petal.Width | Species, iris)

# we plot the residuals
plot(resid(res_poisson))

</code></pre>

<hr>
<h2 id='resid.fixest_multi'>Extracts the residuals from a <code>fixest_multi</code> object</h2><span id='topic+resid.fixest_multi'></span><span id='topic+residuals.fixest_multi'></span>

<h3>Description</h3>

<p>Utility to extract the residuals from multiple <code>fixest</code> estimations. If possible, all the residuals are coerced into a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_multi'
resid(
  object,
  type = c("response", "deviance", "pearson", "working"),
  na.rm = FALSE,
  ...
)

## S3 method for class 'fixest_multi'
residuals(
  object,
  type = c("response", "deviance", "pearson", "working"),
  na.rm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid.fixest_multi_+3A_object">object</code></td>
<td>
<p>A <code>fixes_multi</code> object.</p>
</td></tr>
<tr><td><code id="resid.fixest_multi_+3A_type">type</code></td>
<td>
<p>A character scalar, either <code>"response"</code> (default), <code>"deviance"</code>, <code>"pearson"</code>, or <code>"working"</code>. Note that the <code>"working"</code> corresponds to the residuals from the weighted least square and only applies to <code><a href="#topic+feglm">feglm</a></code> models.</p>
</td></tr>
<tr><td><code id="resid.fixest_multi_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Should the NAs be kept? If <code>TRUE</code>, they are removed.</p>
</td></tr>
<tr><td><code id="resid.fixest_multi_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all the models return residuals of the same length, a matrix is returned. Otherwise, a <code>list</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

# A multiple estimation
est = feols(y ~ x1 + csw0(x2, x3), base)

# We can get all the residuals at once,
# each column is a model
head(resid(est))

# We can select/order the model using fixest_multi extraction
head(resid(est[rhs = .N:1]))

</code></pre>

<hr>
<h2 id='sample_df'>Randomly draws observations from a data set</h2><span id='topic+sample_df'></span>

<h3>Description</h3>

<p>This function is useful to check a data set. It gives a random number of rows of the input data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_df(x, n = 10, previous = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_df_+3A_x">x</code></td>
<td>
<p>A data set: either a vector, a matrix or a data frame.</p>
</td></tr>
<tr><td><code id="sample_df_+3A_n">n</code></td>
<td>
<p>The number of random rows/elements to sample randomly.</p>
</td></tr>
<tr><td><code id="sample_df_+3A_previous">previous</code></td>
<td>
<p>Logical scalar. Whether the results of the previous draw should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data base (resp vector) with <code>n</code> rows (resp elements).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sample_df(iris)

sample_df(iris, previous = TRUE)

</code></pre>

<hr>
<h2 id='sandwich_reexported'>Functions exported from <span class="pkg">sandwich</span> to implement <span class="pkg">fixest</span> methods</h2><span id='topic+sandwich_reexported'></span><span id='topic+estfun'></span><span id='topic+bread'></span>

<h3>Description</h3>

<p>The package <span class="pkg">fixest</span> does not use <code>estfun</code> or <code>bread</code> from <span class="pkg">sandwich</span>, but these methods have been implemented to allow users to leverage the variances from <span class="pkg">sandwich</span>.
</p>


<h3>Details</h3>


<ul>
<li><p> Here is the help from package <span class="pkg">sandwich</span>: <code><a href="sandwich.html#topic+estfun">estfun</a></code> and <code><a href="sandwich.html#topic+bread">bread</a></code>. The help from package <span class="pkg">fixest</span> is here: <code><a href="#topic+estfun.fixest">estfun.fixest</a></code> and <code><a href="#topic+bread.fixest">bread.fixest</a></code>.
</p>
</li></ul>


<hr>
<h2 id='setFixest_coefplot'>Sets the defaults of coefplot</h2><span id='topic+setFixest_coefplot'></span><span id='topic+getFixest_coefplot'></span>

<h3>Description</h3>

<p>You can set the default values of most arguments of <code><a href="#topic+coefplot">coefplot</a></code> with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFixest_coefplot(
  style,
  horiz = FALSE,
  dict = getFixest_dict(),
  keep,
  ci.width = "1%",
  ci_level = 0.95,
  pt.pch = 20,
  pt.bg = NULL,
  cex = 1,
  pt.cex = cex,
  col = 1:8,
  pt.col = col,
  ci.col = col,
  lwd = 1,
  pt.lwd = lwd,
  ci.lwd = lwd,
  ci.lty = 1,
  grid = TRUE,
  grid.par = list(lty = 3, col = "gray"),
  zero = TRUE,
  zero.par = list(col = "black", lwd = 1),
  pt.join = FALSE,
  pt.join.par = list(col = pt.col, lwd = lwd),
  ci.join = FALSE,
  ci.join.par = list(lwd = lwd, col = col, lty = 2),
  ci.fill = FALSE,
  ci.fill.par = list(col = "lightgray", alpha = 0.5),
  ref.line = "auto",
  ref.line.par = list(col = "black", lty = 2),
  lab.cex,
  lab.min.cex = 0.85,
  lab.max.mar = 0.25,
  lab.fit = "auto",
  xlim.add,
  ylim.add,
  sep,
  bg,
  group = "auto",
  group.par = list(lwd = 2, line = 3, tcl = 0.75),
  main = "Effect on __depvar__",
  value.lab = "Estimate and __ci__ Conf. Int.",
  ylab = NULL,
  xlab = NULL,
  sub = NULL,
  reset = FALSE
)

getFixest_coefplot()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFixest_coefplot_+3A_style">style</code></td>
<td>
<p>A character scalar giving the style of the plot to be used. You
can set styles with the function <code><a href="#topic+setFixest_coefplot">setFixest_coefplot</a></code>, setting all the default
values of the function. If missing, then it switches to either &quot;default&quot; or &quot;iplot&quot;,
depending on the calling function.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_horiz">horiz</code></td>
<td>
<p>A logical scalar, default is <code>FALSE</code>. Whether to display the confidence
intervals horizontally instead of vertically.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_dict">dict</code></td>
<td>
<p>A named character vector or a logical scalar. It changes the original variable names to the ones contained in the <code>dict</code>ionary. E.g. to change the variables named <code>a</code> and <code>b3</code> to (resp.) &ldquo;$log(a)$&rdquo; and to &ldquo;$bonus^3$&rdquo;, use <code>dict=c(a="$log(a)$",b3="$bonus^3$")</code>. By default, it is equal to <code>getFixest_dict()</code>, a default dictionary which can be set with <code><a href="#topic+setFixest_dict">setFixest_dict</a></code>. You can use <code>dict = FALSE</code> to disable it. By default <code>dict</code> modifies the entries in the global dictionary, to disable this behavior, use &quot;reset&quot; as the first element (ex: <code>dict=c("reset", mpg="Miles per gallon")</code>).</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_keep">keep</code></td>
<td>
<p>Character vector. This element is used to display only a subset of variables. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be kept. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code>keep = "x[[:digit:]]$"</code>. If the first character is an exclamation mark, the effect is reversed (e.g. keep = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is kept). See details.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ci.width">ci.width</code></td>
<td>
<p>The width of the extremities of the confidence intervals. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ci_level">ci_level</code></td>
<td>
<p>Scalar between 0 and 1: the level of the CI. By default it is equal to 0.95.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_pt.pch">pt.pch</code></td>
<td>
<p>The patch of the coefficient estimates. Default is 1 (circle).</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_pt.bg">pt.bg</code></td>
<td>
<p>The background color of the point estimate (when the <code>pt.pch</code> is
in 21 to 25). Defaults to NULL.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_cex">cex</code></td>
<td>
<p>Numeric, default is 1. Expansion factor for the points</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_pt.cex">pt.cex</code></td>
<td>
<p>The size of the coefficient estimates. Default is the other argument <code>cex</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_col">col</code></td>
<td>
<p>The color of the points and the confidence intervals. Default is 1
(&quot;black&quot;). Note that you can set the colors separately for each of them with <code>pt.col</code> and <code>ci.col</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_pt.col">pt.col</code></td>
<td>
<p>The color of the coefficient estimates. Default is equal to the other argument <code>col</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ci.col">ci.col</code></td>
<td>
<p>The color of the confidence intervals. Default is equal to the other argument <code>col</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_lwd">lwd</code></td>
<td>
<p>General line with. Default is 1.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_pt.lwd">pt.lwd</code></td>
<td>
<p>The line width of the coefficient estimates. Default is equal to
the other argument <code>lwd</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ci.lwd">ci.lwd</code></td>
<td>
<p>The line width of the confidence intervals. Default is equal to
the other argument <code>lwd</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ci.lty">ci.lty</code></td>
<td>
<p>The line type of the confidence intervals. Default is 1.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_grid">grid</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether a grid should be displayed. You
can set the display of the grid with the argument <code>grid.par</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_grid.par">grid.par</code></td>
<td>
<p>List. Parameters of the grid. The default values are: <code>lty =  3</code> and <code>col = "gray"</code>. You can add any graphical parameter that will be passed
to <code><a href="graphics.html#topic+abline">graphics::abline</a></code>. You also have two additional arguments: use <code>horiz =  FALSE</code> to disable the horizontal lines, and use <code>vert = FALSE</code> to disable the
vertical lines. Eg: <code>grid.par = list(vert = FALSE, col = "red", lwd = 2)</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_zero">zero</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether the 0-line should be emphasized.
You can set the parameters of that line with the argument <code>zero.par</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_zero.par">zero.par</code></td>
<td>
<p>List. Parameters of the zero-line. The default values are
<code>col = "black"</code> and <code>lwd = 1</code>. You can add any graphical parameter that will be passed
to <code><a href="graphics.html#topic+abline">graphics::abline</a></code>. Example: <code>zero.par = list(col = "darkblue", lwd = 3)</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_pt.join">pt.join</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then the coefficient estimates
are joined with a line.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_pt.join.par">pt.join.par</code></td>
<td>
<p>List. Parameters of the line joining the coefficients. The
default values are: <code>col = pt.col</code> and <code>lwd = lwd</code>. You can add any graphical
parameter that will be passed to <code><a href="graphics.html#topic+lines">lines</a></code>. Eg: <code>pt.join.par = list(lty = 2)</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ci.join">ci.join</code></td>
<td>
<p>Logical default to <code>FALSE</code>. Whether to join the extremities of
the confidence intervals. If <code>TRUE</code>, then you can set the graphical parameters
with the argument <code>ci.join.par</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ci.join.par">ci.join.par</code></td>
<td>
<p>A list of parameters to be passed to <code><a href="graphics.html#topic+lines">graphics::lines</a></code>.
Only used if <code>ci.join=TRUE</code>. By default it is equal to <code>list(lwd = lwd, col = col, lty = 2)</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ci.fill">ci.fill</code></td>
<td>
<p>Logical default to <code>FALSE</code>. Whether to fill the confidence intervals
with a color. If <code>TRUE</code>, then you can set the graphical parameters with the argument <code>ci.fill.par</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ci.fill.par">ci.fill.par</code></td>
<td>
<p>A list of parameters to be passed to <code><a href="graphics.html#topic+polygon">graphics::polygon</a></code>.
Only used if <code>ci.fill=TRUE</code>. By default it is equal to <code>list(col = "lightgray", alpha = 0.5)</code>.
Note that <code>alpha</code> is a special parameter that adds transparency to the color (ranges from 0 to 1).</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ref.line">ref.line</code></td>
<td>
<p>Logical or numeric, default is &quot;auto&quot;, whose behavior depends
on the situation. It is <code>TRUE</code> only if: i) interactions are plotted, ii) the
x values are numeric and iii) a reference is found. If <code>TRUE</code>, then a vertical
line is drawn at the level of the reference value. Otherwise, if numeric a vertical
line will be drawn at that specific value.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ref.line.par">ref.line.par</code></td>
<td>
<p>List. Parameters of the vertical line on the reference. The
default values are: <code>col = "black"</code> and <code>lty = 2</code>. You can add any graphical
parameter that will be passed to <code><a href="graphics.html#topic+abline">graphics::abline</a></code>. Eg: <code>ref.line.par = list(lty = 1, lwd = 3)</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_lab.cex">lab.cex</code></td>
<td>
<p>The size of the labels of the coefficients. Default is missing.
It is automatically set by an internal algorithm which can go as low as <code>lab.min.cex</code>
(another argument).</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_lab.min.cex">lab.min.cex</code></td>
<td>
<p>The minimum size of the coefficients labels, as set by the
internal algorithm. Default is 0.85.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_lab.max.mar">lab.max.mar</code></td>
<td>
<p>The maximum size the left margin can take when trying to fit
the coefficient labels into it (only when <code>horiz = TRUE</code>). This is used in the
internal algorithm fitting the coefficient labels. Default is <code>0.25</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_lab.fit">lab.fit</code></td>
<td>
<p>The method to fit the coefficient labels into the plotting region
(only when <code>horiz = FALSE</code>). Can be <code>"auto"</code> (the default), <code>"simple"</code>, <code>"multi"</code>
or <code>"tilted"</code>. If <code>"simple"</code>, then the classic axis is drawn. If <code>"multi"</code>, then
the coefficient labels are fit horizontally across several lines, such that they
don't collide. If <code>"tilted"</code>, then the labels are tilted. If <code>"auto"</code>, an automatic
choice between the three is made.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_xlim.add">xlim.add</code></td>
<td>
<p>A numeric vector of length 1 or 2. It represents an extension
factor of xlim, in percentage. Eg: <code>xlim.add = c(0, 0.5)</code> extends <code>xlim</code> of 50%
on the right. If of length 1, positive values represent the right, and negative
values the left (Eg: <code>xlim.add = -0.5</code> is equivalent to <code>xlim.add = c(0.5, 0)</code>).</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ylim.add">ylim.add</code></td>
<td>
<p>A numeric vector of length 1 or 2. It represents an extension
factor of ylim, in percentage. Eg: <code>ylim.add = c(0, 0.5)</code> extends <code>ylim</code> of 50%
on the top. If of length 1, positive values represent the top, and negative values
the bottom (Eg: <code>ylim.add = -0.5</code> is equivalent to <code>ylim.add = c(0.5, 0)</code>).</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_sep">sep</code></td>
<td>
<p>The distance between two estimates &ndash; only when argument <code>object</code>
is a list of estimation results.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_bg">bg</code></td>
<td>
<p>Background color for the plot. By default it is white.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_group">group</code></td>
<td>
<p>A list, default is missing. Each element of the list reports the
coefficients to be grouped while the name of the element is the group name. Each
element of the list can be either: i) a character vector of length 1, ii) of
length 2, or ii) a numeric vector. If equal to: i) then it is interpreted as
a pattern: all element fitting the regular expression will be grouped (note that
you can use the special character &quot;^^&quot; to clean the beginning of the names, see
example), if ii) it corrsponds to the first and last elements to be grouped,
if iii) it corresponds to the coefficients numbers to be grouped. If equal to
a character vector, you can use a percentage to tell the algorithm to look at
the coefficients before aliasing (e.g. <code>"%varname"</code>). Example of valid uses:
<code style="white-space: pre;">&#8288;group=list(group_name=\"pattern\")&#8288;</code>, <code style="white-space: pre;">&#8288;group=list(group_name=c(\"var_start\", \"var_end\"))&#8288;</code>,
<code style="white-space: pre;">&#8288;group=list(group_name=1:2))&#8288;</code>. See details.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_group.par">group.par</code></td>
<td>
<p>A list of parameters controlling the display of the group. The
parameters controlling the line are: <code>lwd</code>, <code>tcl</code> (length of the tick), <code>line.adj</code>
(adjustment of the position, default is 0), <code>tick</code> (whether to add the ticks),
<code>lwd.ticks</code>, <code>col.ticks</code>. Then the parameters controlling the text: <code>text.adj</code>
(adjustment of the position, default is 0), <code>text.cex</code>, <code>text.font</code>, <code>text.col</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_main">main</code></td>
<td>
<p>The title of the plot. Default is <code>"Effect on __depvar__"</code>. You can
use the special variable <code style="white-space: pre;">&#8288;__depvar__&#8288;</code> to set the title (useful when you set the
plot default with <code><a href="#topic+setFixest_coefplot">setFixest_coefplot</a></code>).</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_value.lab">value.lab</code></td>
<td>
<p>The label to appear on the side of the coefficient values. If
<code>horiz = FALSE</code>, the label appears in the y-axis. If <code>horiz = TRUE</code>, then it
appears on the x-axis. The default is equal to <code>"Estimate and __ci__ Conf. Int."</code>,
with <code style="white-space: pre;">&#8288;__ci__&#8288;</code> a special variable giving the value of the confidence interval.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_ylab">ylab</code></td>
<td>
<p>The label of the y-axis, default is <code>NULL</code>. Note that if <code>horiz =  FALSE</code>, it overrides the value of the argument <code>value.lab</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_xlab">xlab</code></td>
<td>
<p>The label of the x-axis, default is <code>NULL</code>. Note that if <code>horiz =  TRUE</code>, it overrides the value of the argument <code>value.lab</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_sub">sub</code></td>
<td>
<p>A subtitle, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="setFixest_coefplot_+3A_reset">reset</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>TRUE</code>, then the arguments that <em>are not</em> set during the call are reset to their &quot;factory&quot;-default values. If <code>FALSE</code>, on the other hand, arguments that have already been modified are not changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return anything.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coefplot">coefplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# coefplot has many arguments, which makes it highly flexible.
# If you don't like the default style of coefplot. No worries,
# you can set *your* default by using the function
# setFixest_coefplot()

# Estimation
est = feols(Petal.Length ~ Petal.Width + Sepal.Length +
                Sepal.Width | Species, iris)

# Plot with default style
coefplot(est)

# Now we permanently change some arguments
dict = c("Petal.Length"="Length (Petal)", "Petal.Width"="Width (Petal)",
         "Sepal.Length"="Length (Sepal)", "Sepal.Width"="Width (Sepal)")

setFixest_coefplot(ci.col = 2, pt.col = "darkblue", ci.lwd = 3,
                   pt.cex = 2, pt.pch = 15, ci.width = 0, dict = dict)

# Tadaaa!
coefplot(est)

# To reset to the default settings:
setFixest_coefplot("all", reset = TRUE)
coefplot(est)

</code></pre>

<hr>
<h2 id='setFixest_dict'>Sets/gets the dictionary relabeling the variables</h2><span id='topic+setFixest_dict'></span><span id='topic+getFixest_dict'></span>

<h3>Description</h3>

<p>Sets/gets the default dictionary used in the function <code><a href="#topic+etable">etable</a></code>, <code><a href="#topic+did_means">did_means</a></code> and <code><a href="#topic+coefplot">coefplot</a></code>. The dictionaries are used to relabel variables (usually towards a fancier, more explicit formatting) when exporting them into a Latex table or displaying in graphs. By setting the dictionary with <code>setFixest_dict</code>, you can avoid providing the argument <code>dict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFixest_dict(dict = NULL, ..., reset = FALSE)

getFixest_dict()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFixest_dict_+3A_dict">dict</code></td>
<td>
<p>A named character vector or a character scalar. E.g. to change my variable named &quot;a&quot; and &quot;b&quot; to (resp.) &quot;$log(a)$&quot; and &quot;$bonus^3$&quot;, then use <code>dict = c(a="$log(a)$", b3="$bonus^3$")</code>. Alternatively you can feed a character scalar containing the dictionary in the form <code>"variable 1: definition \n variable 2: definition"</code>. In that case the function <code><a href="#topic+as.dict">as.dict</a></code> will be applied to get a proper dictionary. This dictionary is used in Latex tables or in graphs by the function <code><a href="#topic+coefplot">coefplot</a></code>. If you want to separate Latex rendering from rendering in graphs, use an ampersand first to make the variable specific to <code>coefplot</code>.</p>
</td></tr>
<tr><td><code id="setFixest_dict_+3A_...">...</code></td>
<td>
<p>You can add arguments of the form: <code>variable_name = "Definition"</code>. This is an alternative to using a named vector in the argument <code>dict</code>.</p>
</td></tr>
<tr><td><code id="setFixest_dict_+3A_reset">reset</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then the dictionary is reset. Note that the default dictionary always relabels the variable &quot;(Intercept)&quot; in to &quot;Constant&quot;. To overwrite it, you need to add &quot;(Intercept)&quot; explicitly in your dictionary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the dictionary only grows. This means that successive calls with not erase the previous definitions unless the argument <code>reset</code> has been set to <code>TRUE</code>.
</p>
<p>The default dictionary is equivalent to having <code>setFixest_dict("(Intercept)" = "Constant")</code>. To change this default, you need to provide a new definition to <code>"(Intercept)"</code> explicitly.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(trade)
est = feols(log(Euros) ~ log(dist_km)|Origin+Destination+Product, trade)
# we export the result &amp; rename some variables
etable(est, dict = c("log(Euros)"="Euros (ln)", Origin="Country of Origin"))

# If you export many tables, it can be more convenient to use setFixest_dict:
setFixest_dict(c("log(Euros)"="Euros (ln)", Origin="Country of Origin"))
etable(est) # variables are properly relabeled

# The dictionary only 'grows'
# Here you get the previous two variables + the new one that are relabeled
# Btw you set the dictionary directly using the argument names:
setFixest_dict(Destination = "Country of Destination")
etable(est)

# Another way to set a dictionary: with a character string:
# See the help page of as.dict
dict = "log(dist_km): Distance (ln); Product: Type of Good"
setFixest_dict(dict)
etable(est)

# And now we reset:
setFixest_dict(reset = TRUE)
etable(est)

</code></pre>

<hr>
<h2 id='setFixest_estimation'>Default arguments for fixest estimations</h2><span id='topic+setFixest_estimation'></span><span id='topic+getFixest_estimation'></span>

<h3>Description</h3>

<p>This function sets globally the default arguments of fixest estimations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFixest_estimation(
  data = NULL,
  panel.id = NULL,
  fixef.rm = "perfect",
  fixef.tol = 1e-06,
  fixef.iter = 10000,
  collin.tol = 1e-10,
  lean = FALSE,
  verbose = 0,
  warn = TRUE,
  combine.quick = NULL,
  demeaned = FALSE,
  mem.clean = FALSE,
  glm.iter = 25,
  glm.tol = 1e-08,
  reset = FALSE
)

getFixest_estimation()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFixest_estimation_+3A_data">data</code></td>
<td>
<p>A data.frame containing the necessary variables to run the model. The variables of the non-linear right hand side of the formula are identified with this <code>data.frame</code> names. Can also be a matrix.</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_panel.id">panel.id</code></td>
<td>
<p>The panel identifiers. Can either be: i) a one sided formula (e.g. <code>panel.id = ~id+time</code>), ii) a character vector of length 2 (e.g. <code>panel.id=c('id', 'time')</code>, or iii) a character scalar of two variables separated by a comma (e.g. <code>panel.id='id,time'</code>). Note that you can combine variables with <code>^</code> only inside formulas (see the dedicated section in <code><a href="#topic+feols">feols</a></code>).</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_fixef.rm">fixef.rm</code></td>
<td>
<p>Can be equal to &quot;perfect&quot; (default), &quot;singleton&quot;, &quot;both&quot; or &quot;none&quot;. Controls which observations are to be removed. If &quot;perfect&quot;, then observations having a fixed-effect with perfect fit (e.g. only 0 outcomes in Poisson estimations) will be removed. If &quot;singleton&quot;, all observations for which a fixed-effect appears only once will be removed. The meaning of &quot;both&quot; and &quot;none&quot; is direct.</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_fixef.tol">fixef.tol</code></td>
<td>
<p>Precision used to obtain the fixed-effects. Defaults to <code>1e-5</code>. It corresponds to the maximum absolute difference allowed between two coefficients of successive iterations. Argument <code>fixef.tol</code> cannot be lower than <code>10000*.Machine$double.eps</code>. Note that this parameter is dynamically controlled by the algorithm.</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_fixef.iter">fixef.iter</code></td>
<td>
<p>Maximum number of iterations in fixed-effects algorithm (only in use for 2+ fixed-effects). Default is 10000.</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_collin.tol">collin.tol</code></td>
<td>
<p>Numeric scalar, default is <code>1e-10</code>. Threshold deciding when variables should be considered collinear and subsequently removed from the estimation. Higher values means more variables will be removed (if there is presence of collinearity). One signal of presence of collinearity is t-stats that are extremely low (for instance when t-stats &lt; 1e-3).</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_lean">lean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> then all large objects are removed from the returned result: this will save memory but will block the possibility to use many methods. It is recommended to use the arguments <code>se</code> or <code>cluster</code> to obtain the appropriate standard-errors at estimation time, since obtaining different SEs won't be possible afterwards.</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_verbose">verbose</code></td>
<td>
<p>Integer. Higher values give more information. In particular, it can detail the number of iterations in the demeaning algorithm (the first number is the left-hand-side, the other numbers are the right-hand-side variables).</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_warn">warn</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether warnings should be displayed (concerns warnings relating to convergence state).</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_combine.quick">combine.quick</code></td>
<td>
<p>Logical. When you combine different variables to transform them into a single fixed-effects you can do e.g. <code>y ~ x | paste(var1, var2)</code>. The algorithm provides a shorthand to do the same operation: <code>y ~ x | var1^var2</code>. Because pasting variables is a costly operation, the internal algorithm may use a numerical trick to hasten the process. The cost of doing so is that you lose the labels. If you are interested in getting the value of the fixed-effects coefficients after the estimation, you should use <code>combine.quick = FALSE</code>. By default it is equal to <code>FALSE</code> if the number of observations is lower than 50,000, and to <code>TRUE</code> otherwise.</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_demeaned">demeaned</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only used in the presence of fixed-effects: should the centered variables be returned? If <code>TRUE</code>, it creates the items <code>y_demeaned</code> and <code>X_demeaned</code>.</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_mem.clean">mem.clean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only to be used if the data set is large compared to the available RAM. If <code>TRUE</code> then intermediary objects are removed as much as possible and <code><a href="base.html#topic+gc">gc</a></code> is run before each substantial C++ section in the internal code to avoid memory issues.</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_glm.iter">glm.iter</code></td>
<td>
<p>Number of iterations of the glm algorithm. Default is 25.</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_glm.tol">glm.tol</code></td>
<td>
<p>Tolerance level for the glm algorithm. Default is <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="setFixest_estimation_+3A_reset">reset</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to reset all values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>getFixest_estimation</code> returns the currently set global defaults.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Example: removing singletons is FALSE by default
#

# =&gt; changing this default

# Let's create data with singletons
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")
base$fe_singletons = as.character(base$species)
base$fe_singletons[1:5] = letters[1:5]

res          = feols(y ~ x1 + x2 | fe_singletons, base)
res_noSingle = feols(y ~ x1 + x2 | fe_singletons, base, fixef.rm = "single")

# New defaults
setFixest_estimation(fixef.rm = "single")
res_newDefault = feols(y ~ x1 + x2 | fe_singletons, base)

etable(res, res_noSingle, res_newDefault)

# Resetting the defaults
setFixest_estimation(reset = TRUE)



</code></pre>

<hr>
<h2 id='setFixest_fml'>Sets/gets formula macros</h2><span id='topic+setFixest_fml'></span><span id='topic+getFixest_fml'></span>

<h3>Description</h3>

<p>You can set formula macros globally with <code>setFixest_fml</code>. These macros can then be used in <code>fixest</code> estimations or when using the function <code><a href="#topic+setFixest_fml">xpd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFixest_fml(..., reset = FALSE)

getFixest_fml()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFixest_fml_+3A_...">...</code></td>
<td>
<p>Definition of the macro variables. Each argument name corresponds to the name of the macro variable. It is required that each macro variable name starts with two dots (e.g. <code>..ctrl</code>). The value of each argument must be a one-sided formula or a character vector, it is the definition of the macro variable. Example of a valid call: <code>setFixest_fml(..ctrl = ~ var1 + var2)</code>. In the function <code>xpd</code>, the default macro variables are taken from <code>getFixest_fml</code>, any variable in <code>...</code> will replace these values. You can enclose values in <code>.[]</code>, if so they will be evaluated from the current environment. For example <code>..ctrl = ~ x.[1:2] + .[z]</code> will lead to <code>~x1 + x2 + var</code> if <code>z</code> is equal to <code>"var"</code>.</p>
</td></tr>
<tr><td><code id="setFixest_fml_+3A_reset">reset</code></td>
<td>
<p>A logical scalar, defaults to <code>FALSE</code>. If <code>TRUE</code>, all macro variables are first reset (i.e. deleted).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>xpd</code>, the default macro variables are taken from <code>getFixest_fml</code>. Any value in the <code>...</code> argument of <code>xpd</code> will replace these default values.
</p>
<p>The definitions of the macro variables will replace in verbatim the macro variables. Therefore, you can include multipart formulas if you wish but then beware of the order the the macros variable in the formula. For example, using the airquality data, say you want to set as controls the variable <code>Temp</code> and <code>Day</code> fixed-effects, you can do <code>setFixest_fml(..ctrl = ~Temp | Day)</code>, but then <code>feols(Ozone ~ Wind + ..ctrl, airquality)</code> will be quite different from <code>feols(Ozone ~ ..ctrl + Wind, airquality)</code>, so beware!
</p>


<h3>Value</h3>

<p>The function <code>getFixest_fml()</code> returns a list of character strings, the names corresponding to the macro variable names, the character strings corresponding to their definition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xpd">xpd</a></code> to make use of formula macros.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Small examples with airquality data
data(airquality)
# we set two macro variables
setFixest_fml(..ctrl = ~ Temp + Day,
              ..ctrl_long = ~ poly(Temp, 2) + poly(Day, 2))

# Using the macro in lm with xpd:
lm(xpd(Ozone ~ Wind + ..ctrl), airquality)
lm(xpd(Ozone ~ Wind + ..ctrl_long), airquality)

# You can use the macros without xpd() in fixest estimations
a = feols(Ozone ~ Wind + ..ctrl, airquality)
b = feols(Ozone ~ Wind + ..ctrl_long, airquality)
etable(a, b, keep = "Int|Win")


# Using .[]

base = setNames(iris, c("y", "x1", "x2", "x3", "species"))
i = 2:3
z = "species"
lm(xpd(y ~ x.[2:3] + .[z]), base)

# No xpd() needed in feols
feols(y ~ x.[2:3] + .[z], base)

#
# Auto completion with '..' suffix
#

# You can trigger variables autocompletion with the '..' suffix
# You need to provide the argument data
base = setNames(iris, c("y", "x1", "x2", "x3", "species"))
xpd(y ~ x.., data = base)

# In fixest estimations, this is automatically taken care of
feols(y ~ x.., data = base)


#
# You can use xpd for stepwise estimations
#

# Note that for stepwise estimations in fixest, you can use
# the stepwise functions: sw, sw0, csw, csw0
# -&gt; see help in feols or in the dedicated vignette

# we want to look at the effect of x1 on y
# controlling for different variables

base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

# We first create a matrix with all possible combinations of variables
my_args = lapply(names(base)[-(1:2)], function(x) c("", x))
(all_combs = as.matrix(do.call("expand.grid", my_args)))

res_all = list()
for(i in 1:nrow(all_combs)){
  res_all[[i]] = feols(xpd(y ~ x1 + ..v, ..v = all_combs[i, ]), base)
}

etable(res_all)
coefplot(res_all, group = list(Species = "^^species"))

#
# You can use macros to grep variables in your data set
#

# Example 1: setting a macro variable globally

data(longley)
setFixest_fml(..many_vars = grep("GNP|ployed", names(longley), value = TRUE))
feols(Armed.Forces ~ Population + ..many_vars, longley)

# Example 2: using ..("regex") or regex("regex") to grep the variables "live"

feols(Armed.Forces ~ Population + ..("GNP|ployed"), longley)

# Example 3: same as Ex.2 but without using a fixest estimation

# Here we need to use xpd():
lm(xpd(Armed.Forces ~ Population + regex("GNP|ployed"), data = longley), longley)

# Stepwise estimation with regex: use a comma after the parenthesis
feols(Armed.Forces ~ Population + sw(regex(,"GNP|ployed")), longley)

# Multiple LHS
etable(feols(..("GNP|ployed") ~ Population, longley))


#
# lhs and rhs arguments
#

# to create a one sided formula from a character vector
vars = letters[1:5]
xpd(rhs = vars)

# Alternatively, to replace the RHS
xpd(y ~ 1, rhs = vars)

# To create a two sided formula
xpd(lhs = "y", rhs = vars)

#
# argument 'add'
#

xpd(~x1, add = ~ x2 + x3)

# also works with character vectors
xpd(~x1, add = c("x2", "x3"))

# only adds to the RHS
xpd(y ~ x, add = ~bon + jour)

#
# Dot square bracket operator
#

# The basic use id to add variables in the formula
x = c("x1", "x2")
xpd(y ~ .[x])

# Alternatively, one-sided formulas can be used and their content will be inserted verbatim
x = ~x1 + x2
xpd(y ~ .[x])

# You can create multiple variables at once
xpd(y ~ x.[1:5] + z.[2:3])

# You can summon variables from the environment to complete variables names
var = "a"
xpd(y ~ x.[var])

# ... the variables can be multiple
vars = LETTERS[1:3]
xpd(y ~ x.[vars])

# You can have "complex" variable names but they must be nested in character form
xpd(y ~ .["x.[vars]_sq"])

# DSB can be used within regular expressions
re = c("GNP", "Pop")
xpd(Unemployed ~ regex(".[re]"), data = longley)

# =&gt; equivalent to regex("GNP|Pop")

# Use .[,var] (NOTE THE COMMA!) to expand with commas
# !! can break the formula if missused
vars = c("wage", "unemp")
xpd(c(y.[,1:3]) ~ csw(.[,vars]))


# Example of use of .[] within a loop
res_all = list()
for(p in 1:3){
  res_all[[p]] = feols(Ozone ~ Wind + poly(Temp, .[p]), airquality)
}

etable(res_all)

# The former can be compactly estimated with:
res_compact = feols(Ozone ~ Wind + sw(.[, "poly(Temp, .[1:3])"]), airquality)

etable(res_compact)

# How does it work?
# 1)  .[, stuff] evaluates stuff and, if a vector, aggregates it with commas
#     Comma aggregation is done thanks to the comma placed after the square bracket
#     If .[stuff], then aggregation is with sums.
# 2) stuff is evaluated, and if it is a character string, it is evaluated with
# the function dsb which expands values in .[]
#
# Wrapping up:
# 2) evaluation of dsb("poly(Temp, .[1:3])") leads to the vector:
#    c("poly(Temp, 1)", "poly(Temp, 2)", "poly(Temp, 3)")
# 1) .[, c("poly(Temp, 1)", "poly(Temp, 2)", "poly(Temp, 3)")] leads to
#    poly(Temp, 1), poly(Temp, 2), poly(Temp, 3)
#
# Hence sw(.[, "poly(Temp, .[1:3])"]) becomes:
#       sw(poly(Temp, 1), poly(Temp, 2), poly(Temp, 3))


#
# In non-fixest functions: guessing the data allows to use regex
#

# When used in non-fixest functions, the algorithm tries to "guess" the data
# so that ..("regex") can be directly evaluated without passing the argument 'data'
data(longley)
lm(xpd(Armed.Forces ~ Population + ..("GNP|ployed")), longley)

# same for the auto completion with '..'
lm(xpd(Armed.Forces ~ Population + GN..), longley)


</code></pre>

<hr>
<h2 id='setFixest_notes'>Sets/gets whether to display notes in <code>fixest</code> estimation functions</h2><span id='topic+setFixest_notes'></span><span id='topic+getFixest_notes'></span>

<h3>Description</h3>

<p>Sets/gets the default values of whether notes (informing for NA and observations removed) should be displayed in <code>fixest</code> estimation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFixest_notes(x)

getFixest_notes()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFixest_notes_+3A_x">x</code></td>
<td>
<p>A logical. If <code>FALSE</code>, then notes are permanently removed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Change default with
setFixest_notes(FALSE)
feols(Ozone ~ Solar.R, airquality)

# Back to default which is TRUE
setFixest_notes(TRUE)
feols(Ozone ~ Solar.R, airquality)

</code></pre>

<hr>
<h2 id='setFixest_nthreads'>Sets/gets the number of threads to use in <code>fixest</code> functions</h2><span id='topic+setFixest_nthreads'></span><span id='topic+getFixest_nthreads'></span>

<h3>Description</h3>

<p>Sets/gets the default number of threads to used in <code>fixest</code> estimation functions. The default is the maximum number of threads minus two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFixest_nthreads(nthreads, save = FALSE)

getFixest_nthreads()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFixest_nthreads_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than, or equal to, the maximum number of threads; b) 0: meaning all available threads will be used; c) a number strictly between 0 and 1 which represents the fraction of all threads to use. If missing, the default is to use 50% of all threads.</p>
</td></tr>
<tr><td><code id="setFixest_nthreads_+3A_save">save</code></td>
<td>
<p>Either a logical or equal to <code>"reset"</code>. Default is <code>FALSE</code>. If <code>TRUE</code> then the value is set permanently at the project level, this means that if you restart R, you will still obtain the previously saved defaults. This is done by writing in the <code>".Renviron"</code> file, located in the project's working directory, hence we must have write permission there for this to work, and only works with Rstudio. If equal to &quot;reset&quot;, the default at the project level is erased. Since there is writing in a file involved, permission is asked to the user.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Gets the current number of threads
(nthreads_origin = getFixest_nthreads())

# To set multi-threading off:
setFixest_nthreads(1)

# To set it back to default at startup:
setFixest_nthreads()

# And back to the original value
setFixest_nthreads(nthreads_origin)


</code></pre>

<hr>
<h2 id='setFixest_vcov'>Sets the default type of standard errors to be used</h2><span id='topic+setFixest_vcov'></span><span id='topic+getFixest_vcov'></span>

<h3>Description</h3>

<p>This functions defines or extracts the default type of standard-errors to computed in <code>fixest</code> <code><a href="#topic+summary.fixest">summary</a></code>, and <code><a href="#topic+vcov.fixest">vcov</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFixest_vcov(
  no_FE = "iid",
  one_FE = "cluster",
  two_FE = "cluster",
  panel = "cluster",
  all = NULL,
  reset = FALSE
)

getFixest_vcov()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFixest_vcov_+3A_no_fe">no_FE</code></td>
<td>
<p>Character scalar equal to either: <code>"iid"</code> (default), or <code>"hetero"</code>. The type of standard-errors to use by default for estimations without fixed-effects.</p>
</td></tr>
<tr><td><code id="setFixest_vcov_+3A_one_fe">one_FE</code></td>
<td>
<p>Character scalar equal to either: <code>"iid"</code>, <code>"hetero"</code>, or <code>"cluster"</code> (default). The type of standard-errors to use by default for estimations with <em>one</em> fixed-effect.</p>
</td></tr>
<tr><td><code id="setFixest_vcov_+3A_two_fe">two_FE</code></td>
<td>
<p>Character scalar equal to either: <code>"iid"</code>, <code>"hetero"</code>, <code>"cluster"</code> (default), or <code>"twoway"</code>. The type of standard-errors to use by default for estimations with <em>two or more</em> fixed-effects.</p>
</td></tr>
<tr><td><code id="setFixest_vcov_+3A_panel">panel</code></td>
<td>
<p>Character scalar equal to either: <code>"iid"</code>, <code>"hetero"</code>, <code>"cluster"</code> (default), or <code>"driscoll_kraaay"</code>. The type of standard-errors to use by default for estimations with the argument <code>panel.id</code> set up. Note that panel has precedence over the presence of fixed-effects.</p>
</td></tr>
<tr><td><code id="setFixest_vcov_+3A_all">all</code></td>
<td>
<p>Character scalar equal to either: <code>"iid"</code>, or <code>"hetero"</code>. By default is is NULL. If provided, it sets all the SEs to that value.</p>
</td></tr>
<tr><td><code id="setFixest_vcov_+3A_reset">reset</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to reset to the default values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>getFixest_vcov()</code> returns a list with three elements containing the default for estimations i) without, ii) with one, or iii) with two or more fixed-effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# By default:
# - no fixed-effect (FE): standard
# - one or more FEs: cluster
# - panel: cluster on panel id

data(base_did)
est_no_FE  = feols(y ~ x1, base_did)
est_one_FE = feols(y ~ x1 | id, base_did)
est_two_FE = feols(y ~ x1 | id + period, base_did)
est_panel = feols(y ~ x1 | id + period, base_did, panel.id = ~id + period)

etable(est_no_FE, est_one_FE, est_two_FE)

# Changing the default standard-errors
setFixest_vcov(no_FE = "hetero", one_FE = "iid",
               two_FE = "twoway", panel = "drisc")
etable(est_no_FE, est_one_FE, est_two_FE, est_panel)

# Resetting the defaults
setFixest_vcov(reset = TRUE)


</code></pre>

<hr>
<h2 id='sigma.fixest'>Residual standard deviation of <code>fixest</code> estimations</h2><span id='topic+sigma.fixest'></span>

<h3>Description</h3>

<p>Extract the estimated standard deviation of the errors from <code>fixest</code> estimations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object.</p>
</td></tr>
<tr><td><code id="sigma.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric scalar.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">fepois</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+femlm">fenegbin</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
est = feols(Petal.Length ~ Petal.Width, iris)
sigma(est)



</code></pre>

<hr>
<h2 id='ssc'>Governs the small sample correction in <code>fixest</code> VCOVs</h2><span id='topic+ssc'></span><span id='topic+dof'></span><span id='topic+setFixest_ssc'></span><span id='topic+getFixest_ssc'></span>

<h3>Description</h3>

<p>Provides how the small sample correction should be calculated in <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>/<code><a href="#topic+summary.fixest">summary.fixest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssc(
  adj = TRUE,
  fixef.K = "nested",
  cluster.adj = TRUE,
  cluster.df = "min",
  t.df = "min",
  fixef.force_exact = FALSE
)

dof(
  adj = TRUE,
  fixef.K = "nested",
  cluster.adj = TRUE,
  cluster.df = "min",
  t.df = "min",
  fixef.force_exact = FALSE
)

setFixest_ssc(ssc.type = ssc())

getFixest_ssc()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssc_+3A_adj">adj</code></td>
<td>
<p>Logical scalar, defaults to <code>TRUE</code>. Whether to apply a small sample adjustment of the form <code>(n - 1) / (n - K)</code>, with <code>K</code> the number of estimated parameters. If <code>FALSE</code>, then no adjustment is made.</p>
</td></tr>
<tr><td><code id="ssc_+3A_fixef.k">fixef.K</code></td>
<td>
<p>Character scalar equal to <code>"nested"</code> (default), <code>"none"</code> or <code>"full"</code>. In the small sample adjustment, how to account for the fixed-effects parameters. If <code>"none"</code>, the fixed-effects parameters are discarded, meaning the number of parameters (<code>K</code>) is only equal to the number of variables. If <code>"full"</code>, then the number of parameters is equal to the number of variables plus the number of fixed-effects. Finally, if <code>"nested"</code>, then the number of parameters is equal to the number of variables plus the number of fixed-effects that <em>are not</em> nested in the clusters used to cluster the standard-errors.</p>
</td></tr>
<tr><td><code id="ssc_+3A_cluster.adj">cluster.adj</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. How to make the small sample correction when clustering the standard-errors? If <code>TRUE</code> a <code>G/(G-1)</code> correction is performed with <code>G</code> the number of cluster values.</p>
</td></tr>
<tr><td><code id="ssc_+3A_cluster.df">cluster.df</code></td>
<td>
<p>Either &quot;conventional&quot; or &quot;min&quot; (default). Only relevant when the variance-covariance matrix is two-way clustered (or higher). It governs how the small sample adjustment for the clusters is to be performed. [Sorry for the jargon that follows.] By default a unique adjustment is made, of the form G_min/(G_min-1) with G_min the smallest G_i. If <code>cluster.df="conventional"</code> then the i-th &quot;sandwich&quot; matrix is adjusted with G_i/(G_i-1) with G_i the number of unique clusters.</p>
</td></tr>
<tr><td><code id="ssc_+3A_t.df">t.df</code></td>
<td>
<p>Either &quot;conventional&quot;, &quot;min&quot; (default) or an integer scalar. Only relevant when the variance-covariance matrix is clustered. It governs how the p-values should be computed. By default, the degrees of freedom of the Student t distribution is equal to the minimum size of the clusters with which the VCOV has been clustered minus one. If <code>t.df="conventional"</code>, then the degrees of freedom of the Student t distribution is equal to the number of observations minus the number of estimated variables. You can also pass a number to manually specify the DoF of the t-distribution.</p>
</td></tr>
<tr><td><code id="ssc_+3A_fixef.force_exact">fixef.force_exact</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If there are 2 or more fixed-effects, these fixed-effects they can be irregular, meaning they can provide the same information. If so, the &quot;real&quot; number of parameters should be lower than the total number of fixed-effects. If <code>fixef.force_exact = TRUE</code>, then <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> is first run to determine the exact number of parameters among the fixed-effects. Mostly, panels of the type individual-firm require <code>fixef.force_exact = TRUE</code> (but it adds computational costs).</p>
</td></tr>
<tr><td><code id="ssc_+3A_ssc.type">ssc.type</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following vignette: <a href="https://lrberge.github.io/fixest/articles/standard_errors.html">On standard-errors</a>, describes in details how the standard-errors are computed in <code>fixest</code> and how you can replicate standard-errors from other software.
</p>


<h3>Value</h3>

<p>It returns a <code>ssc.type</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dof()</code>: This function is deprecated and will be removed at some point (in 6 months from August 2021). Exactly the same as <code>ssc</code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.fixest">summary.fixest</a></code>, <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Equivalence with lm/glm standard-errors
#

# LM
# In the absence of fixed-effects,
# by default, the standard-errors are computed in the same way

res = feols(Petal.Length ~ Petal.Width + Species, iris)
res_lm = lm(Petal.Length ~ Petal.Width + Species, iris)
vcov(res) / vcov(res_lm)

# GLM
# By default, there is no small sample adjustment in glm, as opposed to feglm.
# To get the same SEs, we need to use ssc(adj = FALSE)

res_pois = fepois(round(Petal.Length) ~ Petal.Width + Species, iris)
res_glm = glm(round(Petal.Length) ~ Petal.Width + Species, iris, family = poisson())
vcov(res_pois, ssc = ssc(adj = FALSE)) / vcov(res_glm)

# Same example with the Gamma
res_gamma = feglm(round(Petal.Length) ~ Petal.Width + Species, iris, family = Gamma())
res_glm_gamma = glm(round(Petal.Length) ~ Petal.Width + Species, iris, family = Gamma())
vcov(res_gamma, ssc = ssc(adj = FALSE)) / vcov(res_glm_gamma)

#
# Fixed-effects corrections
#

# We create "irregular" FEs
base = data.frame(x = rnorm(10))
base$y = base$x + rnorm(10)
base$fe1 = rep(1:3, c(4, 3, 3))
base$fe2 = rep(1:5, each = 2)

est = feols(y ~ x | fe1 + fe2, base)

# fe1: 3 FEs
# fe2: 5 FEs

#
# Clustered standard-errors: by fe1
#

# Default: fixef.K = "nested"
#  =&gt; adjustment K = 1 + 5 (i.e. x + fe2)
summary(est)
attributes(vcov(est, attr = TRUE))[c("ssc", "dof.K")]


# fixef.K = FALSE
#  =&gt; adjustment K = 1 (i.e. only x)
summary(est, ssc = ssc(fixef.K = "none"))
attr(vcov(est, ssc = ssc(fixef.K = "none"), attr = TRUE), "dof.K")


# fixef.K = TRUE
#  =&gt; adjustment K = 1 + 3 + 5 - 1 (i.e. x + fe1 + fe2 - 1 restriction)
summary(est, ssc = ssc(fixef.K = "full"))
attr(vcov(est, ssc = ssc(fixef.K = "full"), attr = TRUE), "dof.K")


# fixef.K = TRUE &amp; fixef.force_exact = TRUE
#  =&gt; adjustment K = 1 + 3 + 5 - 2 (i.e. x + fe1 + fe2 - 2 restrictions)
summary(est, ssc = ssc(fixef.K = "full", fixef.force_exact = TRUE))
attr(vcov(est, ssc = ssc(fixef.K = "full", fixef.force_exact = TRUE), attr = TRUE), "dof.K")

# There are two restrictions:
attr(fixef(est), "references")

#
# To permanently set the default ssc:
#

# eg no small sample adjustment:
setFixest_ssc(ssc(adj = FALSE))

# Factory default
setFixest_ssc()

</code></pre>

<hr>
<h2 id='stepwise'>Stepwise estimation tools</h2><span id='topic+stepwise'></span><span id='topic+sw'></span><span id='topic+csw'></span><span id='topic+sw0'></span><span id='topic+csw0'></span>

<h3>Description</h3>

<p>Functions to perform stepwise estimations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sw(...)

csw(...)

sw0(...)

csw0(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise_+3A_...">...</code></td>
<td>
<p>Represents formula variables to be added in a stepwise fashion to an estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To include multiple independent variables, you need to use the stepwise functions. There are 4 stepwise functions: sw, sw0, csw, csw0. Let's explain that.
</p>
<p>Assume you have the following formula: <code>fml = y ~ x1 + sw(x2, x3)</code>. The stepwise function <code>sw</code> will estimate the following two models: <code>y ~ x1 + x2</code> and <code>y ~ x1 + x3</code>. That is, each element in <code>sw()</code> is sequentially, and separately, added to the formula. Would have you used <code>sw0</code> in lieu of <code>sw</code>, then the model <code>y ~ x1</code> would also have been estimated. The <code>0</code> in the name implies that the model without any stepwise element will also be estimated.
</p>
<p>Finally, the prefix <code>c</code> means cumulative: each stepwise element is added to the next. That is, <code>fml = y ~ x1 + csw(x2, x3)</code> would lead to the following models <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>. The <code>0</code> has the same meaning and would also lead to the model without the stepwise elements to be estimated: in other words, <code>fml = y ~ x1 + csw0(x2, x3)</code> leads to the following three models: <code>y ~ x1</code>, <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

# Regular stepwise
feols(y ~ sw(x1, x2, x3), base)

# Cumulative stepwise
feols(y ~ csw(x1, x2, x3), base)

# Using the 0
feols(y ~ x1 + x2 + sw0(x3), base)

</code></pre>

<hr>
<h2 id='style.df'>Style of data.frames created by etable</h2><span id='topic+style.df'></span>

<h3>Description</h3>

<p>This function describes the style of data.frames created with the function <code><a href="#topic+etable">etable</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style.df(
  depvar.title = "Dependent Var.:",
  fixef.title = "Fixed-Effects:",
  fixef.line = "-",
  fixef.prefix = "",
  fixef.suffix = "",
  slopes.title = "Varying Slopes:",
  slopes.line = "-",
  slopes.format = "__var__ (__slope__)",
  stats.title = "_",
  stats.line = "_",
  yesNo = c("Yes", "No"),
  headers.sep = TRUE,
  signif.code = c(`***` = 0.001, `**` = 0.01, `*` = 0.05, . = 0.1),
  interaction.combine = " x ",
  i.equal = " = ",
  default = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style.df_+3A_depvar.title">depvar.title</code></td>
<td>
<p>Character scalar. Default is <code>"Dependent Var.:"</code>. The row name of the dependent variables.</p>
</td></tr>
<tr><td><code id="style.df_+3A_fixef.title">fixef.title</code></td>
<td>
<p>Character scalar. Default is <code>"Fixed-Effects:"</code>. The header preceding the fixed-effects. If equal to the empty string, then this line is removed.</p>
</td></tr>
<tr><td><code id="style.df_+3A_fixef.line">fixef.line</code></td>
<td>
<p>A single character. Default is <code>"-"</code>. A character that will be used to create a line of separation for the fixed-effects header. Used only if <code>fixef.title</code> is not the empty string.</p>
</td></tr>
<tr><td><code id="style.df_+3A_fixef.prefix">fixef.prefix</code></td>
<td>
<p>Character scalar. Default is <code>""</code>. A prefix to appear before each fixed-effect name.</p>
</td></tr>
<tr><td><code id="style.df_+3A_fixef.suffix">fixef.suffix</code></td>
<td>
<p>Character scalar. Default is <code>""</code>. A suffix to appear after each fixed-effect name.</p>
</td></tr>
<tr><td><code id="style.df_+3A_slopes.title">slopes.title</code></td>
<td>
<p>Character scalar. Default is <code>"Varying Slopes:"</code>. The header preceding the variables with varying slopes. If equal to the empty string, then this line is removed.</p>
</td></tr>
<tr><td><code id="style.df_+3A_slopes.line">slopes.line</code></td>
<td>
<p>Character scalar. Default is <code>"-"</code>. A character that will be used to create a line of separation for the variables with varying slopes header. Used only if <code>slopes.line</code> is not the empty string.</p>
</td></tr>
<tr><td><code id="style.df_+3A_slopes.format">slopes.format</code></td>
<td>
<p>Character scalar. Default is <code>"__var__ (__slope__)"</code>. The format of the name of the varying slopes. The values <code style="white-space: pre;">&#8288;__var__&#8288;</code> and <code style="white-space: pre;">&#8288;__slope__&#8288;</code> are special characters that will be replaced by the value of the variable name and slope name, respectively.</p>
</td></tr>
<tr><td><code id="style.df_+3A_stats.title">stats.title</code></td>
<td>
<p>Character scalar. Default is <code>"_"</code>. The header preceding the statistics section. If equal to the empty string, then this line is removed. If equal to single character (like in the default), then this character will be expanded to take the full column width.</p>
</td></tr>
<tr><td><code id="style.df_+3A_stats.line">stats.line</code></td>
<td>
<p>Character scalar. Default is <code>"_"</code>. A character that will be used to create a line of separation for the statistics header. Used only if <code>stats.title</code> is not the empty string.</p>
</td></tr>
<tr><td><code id="style.df_+3A_yesno">yesNo</code></td>
<td>
<p>Character vector of length 1 or 2. Default is <code>c("Yes", "No")</code>. Used to inform on the presence or absence of fixed-effects in the estimation. If of length 1, then automatically the second value is considered as the empty string.</p>
</td></tr>
<tr><td><code id="style.df_+3A_headers.sep">headers.sep</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether to add a line of separation between the headers and the coefficients.</p>
</td></tr>
<tr><td><code id="style.df_+3A_signif.code">signif.code</code></td>
<td>
<p>Named numeric vector, used to provide the significance codes with respect to the p-value of the coefficients. Default is <code>c("***"=0.001, "**"=0.01, "*"=0.05, "."=0.10)</code>. To suppress the significance codes, use <code>signif.code=NA</code> or <code>signif.code=NULL</code>. Can also be equal to <code>"letters"</code>, then the default becomes <code>c("a"=0.01, "b"=0.05, "c"=0.10)</code>.</p>
</td></tr>
<tr><td><code id="style.df_+3A_interaction.combine">interaction.combine</code></td>
<td>
<p>Character scalar, defaults to <code>" x "</code>. When the estimation contains interactions, then the variables names (after aliasing) are combined with this argument. For example: if <code>dict = c(x1="Wind", x2="Rain")</code> and you have the following interaction <code>x1:x2</code>, then it will be renamed (by default) <code style="white-space: pre;">&#8288;Wind x Rain&#8288;</code> &ndash; using <code>interaction.combine = "*"</code> would lead to <code>Wind*Rain</code>.</p>
</td></tr>
<tr><td><code id="style.df_+3A_i.equal">i.equal</code></td>
<td>
<p>Character scalar, defaults to <code>" = "</code>. Only affects factor variables created with the function <code><a href="#topic+i">i</a></code>, tells how the variable should be linked to its value. For example if you have the Species factor from the iris data set, by default the display of the variable is <code>Species = Setosa</code>, etc. If <code>i.equal = ": "</code> the display becomes <code>Species: Setosa</code>.</p>
</td></tr>
<tr><td><code id="style.df_+3A_default">default</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, all the values not provided by the user are set to their default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>@inheritParams etable
</p>
<p>The title elements (<code>depvar.title</code>, <code>fixef.title</code>, <code>slopes.title</code> and <code>stats.title</code>) will be the row names of the returned data.frame. Therefore keep in mind that any two of them should not be identical (since identical row names are forbidden in data.frames).
</p>


<h3>Value</h3>

<p>It returns an object of class <code>fixest_style_df</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Multiple estimations =&gt; see details in feols
aq = airquality
est = feols(c(Ozone, Solar.R) ~
                Wind + csw(Temp, Temp^2, Temp^3) | Month + Day,
            data = aq)


# Default result
etable(est)

# Playing a bit with the styles
etable(est, style.df = style.df(fixef.title = "", fixef.suffix = " FE",
                                 stats.line = " ", yesNo = "yes"))


</code></pre>

<hr>
<h2 id='style.tex'>Style definitions for Latex tables</h2><span id='topic+style.tex'></span>

<h3>Description</h3>

<p>This function describes the style of Latex tables to be exported with the function <code><a href="#topic+etable">etable</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style.tex(
  main = "base",
  depvar.title,
  model.title,
  model.format,
  line.top,
  line.bottom,
  var.title,
  fixef.title,
  fixef.prefix,
  fixef.suffix,
  fixef.where,
  slopes.title,
  slopes.format,
  fixef_sizes.prefix,
  fixef_sizes.suffix,
  stats.title,
  notes.intro,
  notes.tpt.intro,
  tablefoot,
  tablefoot.value,
  yesNo,
  tabular = "normal",
  depvar.style,
  no_border,
  caption.after,
  rules_width,
  signif.code,
  tpt,
  arraystretch,
  adjustbox = NULL,
  fontsize,
  interaction.combine = " $\\times$ ",
  i.equal = " $=$ "
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style.tex_+3A_main">main</code></td>
<td>
<p>Either &quot;base&quot;, &quot;aer&quot; or &quot;qje&quot;. Defines the basic style to start from. The styles &quot;aer&quot; and &quot;qje&quot; are almost identical and only differ on the top/bottom lines.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_depvar.title">depvar.title</code></td>
<td>
<p>A character scalar. The title of the line of the dependent variables (defaults to <code>"Dependent variable(s):"</code> if <code>main = "base"</code> (the 's' appears only if just one variable) and to <code>""</code> if <code>main = "aer"</code>).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_model.title">model.title</code></td>
<td>
<p>A character scalar. The title of the line of the models (defaults to <code>"Model:"</code> if <code>main = "base"</code> and to <code>""</code> if <code>main = "aer"</code>).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_model.format">model.format</code></td>
<td>
<p>A character scalar. The value to appear on top of each column. It defaults to <code>"(1)"</code>. Note that 1, i, I, a and A are special characters: if found, their values will be automatically incremented across columns.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_line.top">line.top</code></td>
<td>
<p>A character scalar equal to <code>"simple"</code>, <code>"double"</code>, or anything else. The line at the top of the table (defaults to <code>"double"</code> if <code>main = "base"</code> and to <code>"simple"</code> if <code>main = "aer"</code>). <code>"simple"</code> is equivalent to <code>"\\toprule"</code>, and <code>"double"</code> to <code>"\\tabularnewline \\midrule \\midrule"</code>.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_line.bottom">line.bottom</code></td>
<td>
<p>A character scalar equal to <code>"simple"</code>, <code>"double"</code>, or anything else. The line at the bottom of the table (defaults to <code>"double"</code> if <code>main = "base"</code> and to <code>"simple"</code> if <code>main = "aer"</code>). <code>"simple"</code> is equivalent to <code>"\\bottomrule"</code>, and <code>"double"</code> to <code>"\\midrule \\midrule &amp; \\tabularnewline"</code>.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_var.title">var.title</code></td>
<td>
<p>A character scalar. The title line appearing before the variables (defaults to <code>"\\midrule \\emph{Variables}"</code> if <code>main = "base"</code> and to <code>"\\midrule"</code> if <code>main = "aer"</code>). Note that the behavior of <code>var.title = " "</code> (a space) is different from <code>var.title = ""</code> (the empty string): in the first case you will get an empty row, while in the second case you get no empty row. To get a line without an empty row, use <code>"\\midrule"</code> (and not <code>"\\midrule "</code>!&ndash;the space!).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_fixef.title">fixef.title</code></td>
<td>
<p>A character scalar. The title line appearing before the fixed-effects (defaults to <code>"\\midrule \\emph{Fixed-effects}"</code> if <code>main = "base"</code> and to <code>" "</code> if <code>main = "aer"</code>). Note that the behavior of <code>fixef.title = " "</code> (a space) is different from <code>fixef.title = ""</code> (the empty string): in the first case you will get an empty row, while in the second case you get no empty row. To get a line without an empty row, use <code>"\\midrule"</code> (and not <code>"\\midrule "</code>!&ndash;the space!).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_fixef.prefix">fixef.prefix</code></td>
<td>
<p>A prefix to add to the fixed-effects names. Defaults to <code>""</code> (i.e. no prefix).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_fixef.suffix">fixef.suffix</code></td>
<td>
<p>A suffix to add to the fixed-effects names. Defaults to <code>""</code> if <code>main = "base"</code>) and to <code>"fixed-effects"</code> if <code>main = "aer"</code>).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_fixef.where">fixef.where</code></td>
<td>
<p>Either &quot;var&quot; or &quot;stats&quot;. Where to place the fixed-effects lines? Defaults to <code>"var"</code>, i.e. just after the variables, if <code>main = "base"</code>) and to <code>"stats"</code>, i.e. just after the statistics, if <code>main = "aer"</code>).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_slopes.title">slopes.title</code></td>
<td>
<p>A character scalar. The title line appearing before the variables with varying slopes (defaults to <code>"\\midrule \\emph{Varying Slopes}"</code> if <code>main = "base"</code> and to <code>""</code> if <code>main = "aer"</code>). Note that the behavior of <code>slopes.title = " "</code> (a space) is different from <code>slopes.title = ""</code> (the empty string): in the first case you will get an empty row, while in the second case you get no empty row. To get a line without an empty row, use <code>"\\midrule"</code> (and not <code>"\\midrule "</code>!&ndash;the space!).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_slopes.format">slopes.format</code></td>
<td>
<p>Character scalar representing the format of the slope variable name. There are two special characters: &quot;<strong>var</strong>&quot; and &quot;<strong>slope</strong>&quot;, placeholers for the variable and slope names. Defaults to <code>"__var__ (__slope__)"</code> if <code>main = "base"</code>) and to <code>"__var__ $\\times $ __slope__"</code> if <code>main = "aer"</code>).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_fixef_sizes.prefix">fixef_sizes.prefix</code></td>
<td>
<p>A prefix to add to the fixed-effects names. Defaults to <code>"# "</code>.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_fixef_sizes.suffix">fixef_sizes.suffix</code></td>
<td>
<p>A suffix to add to the fixed-effects names. Defaults to <code>""</code> (i.e. no suffix).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_stats.title">stats.title</code></td>
<td>
<p>A character scalar. The title line appearing before the statistics (defaults to <code style="white-space: pre;">&#8288;"\\midrule \\emph{Fit statistics"}&#8288;</code> if <code>main = "base"</code> and to <code>" "</code> if <code>main = "aer"</code>). Note that the behavior of <code>stats.title = " "</code> (a space) is different from <code>stats.title = ""</code> (the empty string): in the first case you will get an empty row, while in the second case you get no empty row. To get a line without an empty row, use <code>"\\midrule"</code> (and not <code>"\\midrule "</code>!&ndash;the space!).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_notes.intro">notes.intro</code></td>
<td>
<p>A character scalar. Some tex code appearing just before the notes, defaults to <code>"\\par \\raggedright \n"</code>.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_notes.tpt.intro">notes.tpt.intro</code></td>
<td>
<p>Character scalar. Only used if <code>tpt = TRUE</code>, it is some tex code that is passed before any <code>threeparttable</code> item (can be used for, typically, the font size). Default is the empty string.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_tablefoot">tablefoot</code></td>
<td>
<p>A logical scalar. Whether or not to display a footer within the table. Defaults to <code>TRUE</code> if <code>main = "aer"</code>) and <code>FALSE</code> if <code>main = "aer"</code>).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_tablefoot.value">tablefoot.value</code></td>
<td>
<p>A character scalar. The notes to be displayed in the footer. Defaults to <code>"default"</code> if <code>main = "base"</code>, which leads to custom footers informing on the type of standard-error and significance codes, depending on the estimations.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_yesno">yesNo</code></td>
<td>
<p>A character vector of length 1 or 2. Defaults to <code>"Yes"</code> if <code>main = "base"</code> and to <code>"$\\checkmark$"</code> if <code>main = "aer"</code> (from package <code>amssymb</code>). This is the message displayed when a given fixed-effect is (or is not) included in a regression. If <code>yesNo</code> is of length 1, then the second element is the empty string.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_tabular">tabular</code></td>
<td>
<p>(Tex only.) Character scalar equal to &quot;normal&quot; (default), <code>"*"</code> or <code>"X"</code>. Represents the type of tabular environment to use: either <code>tabular</code>, <code style="white-space: pre;">&#8288;tabular*&#8288;</code> or <code>tabularx</code>.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_depvar.style">depvar.style</code></td>
<td>
<p>Character scalar equal to either <code>" "</code> (default), <code>"*"</code> (italic), <code>"**"</code> (bold), <code>"***"</code> (italic-bold). How the name of the dependent variable should be displayed.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_no_border">no_border</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to remove any side border to the table (typically adds <code style="white-space: pre;">&#8288;@\{\&#8288;</code> to the sides of the tabular).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_caption.after">caption.after</code></td>
<td>
<p>Character scalar. Tex code that will be placed right after the caption. Defaults to <code>""</code> for <code>main = "base"</code> and <code>"\\medskip"</code> for <code>main = "aer"</code>.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_rules_width">rules_width</code></td>
<td>
<p>Character vector of length 1 or 2. This vector gives the width of the <code>booktabs</code> rules: the first element the heavy-width, the second element the light-width. NA values mean no modification. If of length 1, only the heavy rules are modified. The width are in Latex units (ex: <code>"0.1 em"</code>, etc).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_signif.code">signif.code</code></td>
<td>
<p>Named numeric vector, used to provide the significance codes with respect to the p-value of the coefficients. Default is <code>c("***"=0.01, "**"=0.05, "*"=0.10)</code>. To suppress the significance codes, use <code>signif.code=NA</code> or <code>signif.code=NULL</code>. Can also be equal to <code>"letters"</code>, then the default becomes <code>c("a"=0.01, "b"=0.05, "c"=0.10)</code>.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_tpt">tpt</code></td>
<td>
<p>(Tex only.) Logical scalar, default is FALSE. Whether to use the <code>threeparttable</code> environment. If so, the <code>notes</code> will be integrated into the <code>tablenotes</code> environment.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_arraystretch">arraystretch</code></td>
<td>
<p>(Tex only.) A numeric scalar, default is <code>NULL</code>. If provided, the command <code style="white-space: pre;">&#8288;\\renewcommand*{\\arraystretch{x}}&#8288;</code> is inserted, replacing <code>x</code> by the value of <code>arraystretch</code>. The changes are specific to the current table and do not affect the rest of the document.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_adjustbox">adjustbox</code></td>
<td>
<p>(Tex only.) A logical, numeric or character scalar, default is <code>NULL</code>. If not <code>NULL</code>, the table is inserted within the <code>adjustbox</code> environment. By default the options are <code style="white-space: pre;">&#8288;width = 1\\textwidth, center&#8288;</code> (if <code>TRUE</code>). A numeric value changes the value before <code style="white-space: pre;">&#8288;\\textwidth&#8288;</code>. You can also add a character of the form <code>"x tw"</code> or <code>"x th"</code> with <code>x</code> a number and where tw (th) stands for text-width (text-height). Finally any other character value is passed verbatim as an <code>adjustbox</code> option.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_fontsize">fontsize</code></td>
<td>
<p>(Tex only.) A character scalar, default is <code>NULL</code>. Can be equal to <code>tiny</code>, <code>scriptsize</code>, <code>footnotesize</code>, <code>small</code>, <code>normalsize</code>, <code>large</code>, or <code>Large</code>. The change affect the table only (and not the rest of the document).</p>
</td></tr>
<tr><td><code id="style.tex_+3A_interaction.combine">interaction.combine</code></td>
<td>
<p>Character scalar, defaults to <code>" $\\times$ "</code>. When the estimation contains interactions, then the variables names (after aliasing) are combined with this argument. For example: if <code>dict = c(x1="Wind", x2="Rain")</code> and you have the following interaction <code>x1:x2</code>, then it will be renamed (by default) <code style="white-space: pre;">&#8288;Wind $\\times$ Rain&#8288;</code> &ndash; using <code>interaction.combine = "*"</code> would lead to <code>Wind*Rain</code>.</p>
</td></tr>
<tr><td><code id="style.tex_+3A_i.equal">i.equal</code></td>
<td>
<p>Character scalar, defaults to <code>" $=$ "</code>. Only affects factor variables created with the function <code><a href="#topic+i">i</a></code>, tells how the variable should be linked to its value. For example if you have the Species factor from the iris data set, by default the display of the variable is <code style="white-space: pre;">&#8288;Species $=$ Setosa&#8288;</code>, etc. If <code>i.equal = ": "</code> the display becomes <code>Species: Setosa</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code style="white-space: pre;">&#8288;\\checkmark&#8288;</code> command, used in the &quot;aer&quot; style (in argument <code>yesNo</code>), is in the <code>amssymb</code> package.
</p>
<p>The commands <code style="white-space: pre;">&#8288;\\toprule&#8288;</code>, <code style="white-space: pre;">&#8288;\\midrule&#8288;</code> and <code style="white-space: pre;">&#8288;\\bottomrule&#8288;</code> are in the <code>booktabs</code> package. You can set the width of the top/bottom rules with <code style="white-space: pre;">&#8288;\\setlength\\heavyrulewidth\{wd\}&#8288;</code>, and of the midrule with <code style="white-space: pre;">&#8288;\\setlength\\lightrulewidth\{wd\}&#8288;</code>.
</p>
<p>Note that all titles (<code>depvar.title</code>, <code>depvar.title</code>, etc) are not escaped, so they must be valid Latex expressions.
</p>


<h3>Value</h3>

<p>Returns a list containing the style parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+etable">etable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Multiple estimations =&gt; see details in feols
aq = airquality
est = feols(c(Ozone, Solar.R) ~
                Wind + csw(Temp, Temp^2, Temp^3) | Month + Day,
            data = aq)

# Playing a bit with the styles
etable(est, tex = TRUE)
etable(est, tex = TRUE, style.tex = style.tex("aer"))

etable(est, tex = TRUE, style.tex = style.tex("aer",
                                      var.title = "\\emph{Expl. Vars.}",
                                      model.format = "[i]",
                                      yesNo = "x",
                                      tabular = "*"))

</code></pre>

<hr>
<h2 id='summary.fixest'>Summary of a <code>fixest</code> object. Computes different types of standard errors.</h2><span id='topic+summary.fixest'></span><span id='topic+summary.fixest_list'></span>

<h3>Description</h3>

<p>This function is similar to <code>print.fixest</code>. It provides the table of coefficients along with other information on the fit of the estimation. It can compute different types of standard errors. The new variance covariance matrix is an object returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
summary(
  object,
  vcov = NULL,
  cluster = NULL,
  ssc = NULL,
  .vcov = NULL,
  stage = NULL,
  lean = FALSE,
  agg = NULL,
  forceCovariance = FALSE,
  se = NULL,
  keepBounded = FALSE,
  n = 1000,
  nthreads = getFixest_nthreads(),
  ...
)

## S3 method for class 'fixest_list'
summary(
  object,
  se,
  cluster,
  ssc = getFixest_ssc(),
  .vcov,
  stage = 2,
  lean = FALSE,
  n,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_.vcov">.vcov</code></td>
<td>
<p>A user provided covariance matrix or a function computing this matrix. If a matrix, it must be a square matrix of the same number of rows as the number of variables estimated. If a function, it must return the previously mentioned matrix.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_stage">stage</code></td>
<td>
<p>Can be equal to <code>2</code> (default), <code>1</code>, <code>1:2</code> or <code>2:1</code>. Only used if the object is an IV estimation: defines the stage to which <code>summary</code> should be applied. If <code>stage = 1</code> and there are multiple endogenous regressors or if <code>stage</code> is of length 2, then an object of class <code>fixest_multi</code> is returned.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_lean">lean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Used to reduce the (memory) size of the summary object. If <code>TRUE</code>, then all objects of length N (the number of observations) are removed from the result. Note that some <code>fixest</code> methods may consequently not work when applied to the summary.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_agg">agg</code></td>
<td>
<p>A character scalar describing the variable names to be aggregated, it is pattern-based. For <code><a href="#topic+sunab">sunab</a></code> estimations, the following keywords work: &quot;att&quot;, &quot;period&quot;, &quot;cohort&quot; and <code>FALSE</code> (to have full disaggregation). All variables that match the pattern will be aggregated. It must be of the form <code>"(root)"</code>, the parentheses must be there and the resulting variable name will be <code>"root"</code>. You can add another root with parentheses: <code>"(root1)regex(root2)"</code>, in which case the resulting name is <code>"root1::root2"</code>. To name the resulting variable differently you can pass a named vector: <code>c("name" = "pattern")</code> or <code>c("name" = "pattern(root2)")</code>. It's a bit intricate sorry, please see the examples.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_forcecovariance">forceCovariance</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. In the peculiar case where the obtained Hessian is not invertible (usually because of collinearity of some variables), use this option to force the covariance matrix, by using a generalized inverse of the Hessian. This can be useful to spot where possible problems come from.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_keepbounded">keepBounded</code></td>
<td>
<p>(Advanced users &ndash; <code>feNmlm</code> with non-linear part and bounded coefficients only.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then the bounded coefficients (if any) are treated as unrestricted coefficients and their S.E. is computed (otherwise it is not).</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_n">n</code></td>
<td>
<p>Integer, default is 1000. Number of coefficients to display when the print method is used.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than, or equal to, the maximum number of threads; b) 0: meaning all available threads will be used; c) a number strictly between 0 and 1 which represents the fraction of all threads to use. The default is to use 50% of all threads. You can set permanently the number of threads used within this package using the function <code><a href="#topic+setFixest_nthreads">setFixest_nthreads</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fixest_+3A_...">...</code></td>
<td>
<p>Only used if the argument <code>.vocv</code> is provided and is a function: extra arguments to be passed to that function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a <code>fixest</code> object with:
</p>
<table>
<tr><td><code>cov.scaled</code></td>
<td>
<p>The new variance-covariance matrix (computed according to the argument <code>se</code>).</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The new standard-errors (computed according to the argument <code>se</code>).</p>
</td></tr>
<tr><td><code>coeftable</code></td>
<td>
<p>The table of coefficients with the new standard errors.</p>
</td></tr>
</table>


<h3>Compatibility with <span class="pkg">sandwich</span> package</h3>

<p>The VCOVs from <code>sandwich</code> can be used with <code>feols</code>, <code>feglm</code> and <code>fepois</code> estimations. If you want to have a <code>sandwich</code> VCOV when using <code>summary.fixest</code>, you can use the argument <code>vcov</code> to specify the VCOV function to use (see examples).
Note that if you do so and you use a formula in the <code>cluster</code> argument, an innocuous warning can pop up if you used several non-numeric fixed-effects in the estimation (this is due to the function <code><a href="stats.html#topic+expand.model.frame">expand.model.frame</a></code> used in <code>sandwich</code>).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. Use <code><a href="#topic+fixef.fixest">fixef.fixest</a></code> to extract the fixed-effects coefficients, and the function <code><a href="#topic+etable">etable</a></code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load trade data
data(trade)

# We estimate the effect of distance on trade (with 3 fixed-effects)
est_pois = fepois(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# Comparing different types of standard errors
sum_standard = summary(est_pois, vcov = "iid")
sum_hetero   = summary(est_pois, vcov = "hetero")
sum_oneway   = summary(est_pois, vcov = "cluster")
sum_twoway   = summary(est_pois, vcov = "twoway")

etable(sum_standard, sum_hetero, sum_oneway, sum_twoway)

# Alternative ways to cluster the SE:
summary(est_pois, vcov = cluster ~ Product + Origin)
summary(est_pois, vcov = ~Product + Origin)
summary(est_pois, cluster = ~Product + Origin)

# You can interact the clustering variables "live" using the var1 ^ var2 syntax.#'
summary(est_pois, vcov = ~Destination^Product)

#
# Newey-West and Driscoll-Kraay SEs
#

data(base_did)
# Simple estimation on a panel
est = feols(y ~ x1, base_did)

# --
# Newey-West
# Use the syntax NW ~ unit + time
summary(est, NW ~ id + period)

# Now take a lag of 3:
summary(est, NW(3) ~ id + period)

# --
# Driscoll-Kraay
# Use the syntax DK ~ time
summary(est, DK ~ period)

# Now take a lag of 3:
summary(est, DK(3) ~ period)

#--
# Implicit deductions
# When the estimation is done with a panel.id, you don't need to
# specify these values.

est_panel = feols(y ~ x1, base_did, panel.id = ~id + period)

# Both methods, NM and DK, now work automatically
summary(est_panel, "NW")
summary(est_panel, "DK")

#
# VCOVs robust to spatial correlation
#

data(quakes)
est_geo = feols(depth ~ mag, quakes)

# --
# Conley
# Use the syntax: conley(cutoff) ~ lat + lon
# with lat/lon the latitude/longitude variable names in the data set
summary(est_geo, conley(100) ~ lat + long)

# Change the cutoff, and how the distance is computed
summary(est_geo, conley(200, distance = "spherical") ~ lat + long)

# --
# Implicit deduction
# By default the latitude and longitude are directly fetched in the data based
# on pattern matching. So you don't have to specify them.
# Further an automatic cutoff is computed by default.

# The following works
summary(est_geo, "conley")



#
# Compatibility with sandwich
#

# You can use the VOCVs from sandwich by using the argument .vcov:
library(sandwich)
summary(est_pois, .vcov = vcovCL, cluster = trade[, c("Destination", "Product")])


</code></pre>

<hr>
<h2 id='summary.fixest_multi'>Summary for fixest_multi objects</h2><span id='topic+summary.fixest_multi'></span>

<h3>Description</h3>

<p>Summary information for fixest_multi objects. In particular, this is used to specify the type of standard-errors to be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest_multi'
summary(
  object,
  type = "short",
  vcov = NULL,
  se = NULL,
  cluster = NULL,
  ssc = NULL,
  .vcov = NULL,
  stage = 2,
  lean = FALSE,
  n = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fixest_multi_+3A_object">object</code></td>
<td>
<p>A <code>fixest_multi</code> object, obtained from a <code>fixest</code> estimation leading to multiple results.</p>
</td></tr>
<tr><td><code id="summary.fixest_multi_+3A_type">type</code></td>
<td>
<p>A character either equal to <code>"short"</code>, <code>"long"</code>, <code>"compact"</code>, <code>"se_compact"</code> or <code>"se_long"</code>. If <code>short</code>, only the table of coefficients is displayed for each estimation. If <code>long</code>, then the full results are displayed for each estimation. If <code>compact</code>, a <code>data.frame</code> is returned with one line per model and the formatted coefficients + standard-errors in the columns. If <code>se_compact</code>, a <code>data.frame</code> is returned with one line per model, one numeric column for each coefficient and one numeric column for each standard-error. If <code>"se_long"</code>, same as <code>"se_compact"</code> but the data is in a long format instead of wide.</p>
</td></tr>
<tr><td><code id="summary.fixest_multi_+3A_vcov">vcov</code>, <code id="summary.fixest_multi_+3A_.vcov">.vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="summary.fixest_multi_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="summary.fixest_multi_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="summary.fixest_multi_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="summary.fixest_multi_+3A_stage">stage</code></td>
<td>
<p>Can be equal to <code>2</code> (default), <code>1</code>, <code>1:2</code> or <code>2:1</code>. Only used if the object is an IV estimation: defines the stage to which <code>summary</code> should be applied. If <code>stage = 1</code> and there are multiple endogenous regressors or if <code>stage</code> is of length 2, then an object of class <code>fixest_multi</code> is returned.</p>
</td></tr>
<tr><td><code id="summary.fixest_multi_+3A_lean">lean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Used to reduce the (memory) size of the summary object. If <code>TRUE</code>, then all objects of length N (the number of observations) are removed from the result. Note that some <code>fixest</code> methods may consequently not work when applied to the summary.</p>
</td></tr>
<tr><td><code id="summary.fixest_multi_+3A_n">n</code></td>
<td>
<p>Integer, default is 1000. Number of coefficients to display when the print method is used.</p>
</td></tr>
<tr><td><code id="summary.fixest_multi_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns either an object of class <code>fixest_multi</code> (if <code>type</code> equals <code>short</code> or <code>long</code>), either a <code>data.frame</code> (if type equals <code>compact</code> or <code>se_compact</code>).
</p>


<h3>See Also</h3>

<p>The main fixest estimation functions: <code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">fepois</a></code>, <code><a href="#topic+femlm">fenegbin</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>. Tools for mutliple fixest estimations: <code><a href="#topic+summary.fixest_multi">summary.fixest_multi</a></code>, <code><a href="#topic+print.fixest_multi">print.fixest_multi</a></code>, <code><a href="#topic+as.list.fixest_multi">as.list.fixest_multi</a></code>, <code><a href="#topic+sub-sub-.fixest_multi">sub-sub-.fixest_multi</a></code>, <code><a href="#topic+sub-.fixest_multi">sub-.fixest_multi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

# Multiple estimation
res = feols(y ~ csw(x1, x2, x3), base, split = ~species)

# By default, the type is "short"
# You can still use the arguments from summary.fixest
summary(res, se = "hetero")

summary(res, type = "long")

summary(res, type = "compact")

summary(res, type = "se_compact")

summary(res, type = "se_long")


</code></pre>

<hr>
<h2 id='summary.fixest.fixef'>Summary method for fixed-effects coefficients</h2><span id='topic+summary.fixest.fixef'></span>

<h3>Description</h3>

<p>This function summarizes the main characteristics of the fixed-effects coefficients. It shows the number of fixed-effects that have been set as references and the first elements of the fixed-effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest.fixef'
summary(object, n = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fixest.fixef_+3A_object">object</code></td>
<td>
<p>An object returned by the function <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fixest.fixef_+3A_n">n</code></td>
<td>
<p>Positive integer, defaults to 5. The <code>n</code> first fixed-effects for each fixed-effect dimension are reported.</p>
</td></tr>
<tr><td><code id="summary.fixest.fixef_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It prints the number of fixed-effect coefficients per fixed-effect dimension, as well as the number of fixed-effects used as references for each dimension, and the mean and variance of the fixed-effect coefficients. Finally, it reports the first 5 (arg. <code>n</code>) elements of each fixed-effect.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>, <code><a href="#topic+plot.fixest.fixef">plot.fixest.fixef</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(trade)

# We estimate the effect of distance on trade
# =&gt; we account for 3 fixed-effects effects
est_pois = femlm(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# obtaining the fixed-effects coefficients
fe_trade = fixef(est_pois)

# printing some summary information on the fixed-effects coefficients:
summary(fe_trade)


</code></pre>

<hr>
<h2 id='sunab'>Sun and Abraham interactions</h2><span id='topic+sunab'></span><span id='topic+sunab_att'></span>

<h3>Description</h3>

<p>User-level method to implement staggered difference-in-difference estimations a la Sun and Abraham (Journal of Econometrics, forthcoming).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sunab(
  cohort,
  period,
  ref.c = NULL,
  ref.p = -1,
  bin,
  bin.rel,
  bin.c,
  bin.p,
  att = FALSE,
  no_agg = FALSE
)

sunab_att(cohort, period, ref.c = NULL, ref.p = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sunab_+3A_cohort">cohort</code></td>
<td>
<p>A vector representing the cohort. It should represent the period at which the treatment has been received (and thus be fixed for each unit).</p>
</td></tr>
<tr><td><code id="sunab_+3A_period">period</code></td>
<td>
<p>A vector representing the period. It can be either a relative time period (with negative values representing the before the treatment and positive values after the treatment), or a regular time period. In the latter case, the relative time period will be created from the cohort information (which represents the time at which the treatment has been received).</p>
</td></tr>
<tr><td><code id="sunab_+3A_ref.c">ref.c</code></td>
<td>
<p>A vector of references for the cohort. By default the never treated cohorts are taken as reference and the always treated are excluded from the estimation. You can add more references with this argument, which means that dummies will not be created for them (but they will remain in the estimation).</p>
</td></tr>
<tr><td><code id="sunab_+3A_ref.p">ref.p</code></td>
<td>
<p>A vector of references for the (relative!) period. By default the first relative period (RP) before the treatment, i.e. -1, is taken as reference. You can instead use your own references (i.e. RPs for which dummies will not be created &ndash; but these observations remain in the sample). Please note that you will need at least two references. You can use the special variables <code>.F</code> and <code>.L</code> to access the first and the last relative periods.</p>
</td></tr>
<tr><td><code id="sunab_+3A_bin">bin</code></td>
<td>
<p>A list of values to be grouped, a vector, or the special value <code>"bin::digit"</code>. The binning will be applied to both the cohort and the period (to bin them separately, see <code>bin.c</code> and <code>bin.p</code>). To create a new value from old values, use <code>bin = list("new_value"=old_values)</code> with <code>old_values</code> a vector of existing values. It accepts regular expressions, but they must start with an <code>"@"</code>, like in <code>bin="@Aug|Dec"</code>. The names of the list are the new names. If the new name is missing, the first value matched becomes the new name. Feeding in a vector is like using a list without name and only a single element. If the vector is numeric, you can use the special value <code>"bin::digit"</code> to group every <code>digit</code> element. For example if <code>x</code> represent years, using <code>bin="bin::2"</code> create bins of two years. Using <code>"!bin::digit"</code> groups every digit consecutive values starting from the first value. Using <code>"!!bin::digit"</code> is the same bu starting from the last value. In both cases, <code>x</code> is not required to be numeric.</p>
</td></tr>
<tr><td><code id="sunab_+3A_bin.rel">bin.rel</code></td>
<td>
<p>A list or a vector defining which values to bin. Only applies to the relative periods and <em>not</em> the cohorts. Please refer to the help of the argument <code>bin</code> to understand the different ways to do the binning (or look at the help of <code><a href="#topic+bin">bin</a></code>).</p>
</td></tr>
<tr><td><code id="sunab_+3A_bin.c">bin.c</code></td>
<td>
<p>A list or a vector defining which values to bin. Only applies to the cohort. Please refer to the help of the argument <code>bin</code> to understand the different ways to do the binning (or look at the help of <code><a href="#topic+bin">bin</a></code>).</p>
</td></tr>
<tr><td><code id="sunab_+3A_bin.p">bin.p</code></td>
<td>
<p>A list or a vector defining which values to bin. Only applies to the period. Please refer to the help of the argument <code>bin</code> to understand the different ways to do the binning (or look at the help of <code><a href="#topic+bin">bin</a></code>).</p>
</td></tr>
<tr><td><code id="sunab_+3A_att">att</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>: then the total average treatment effect for the treated is computed (instead of the ATT for each relative period).</p>
</td></tr>
<tr><td><code id="sunab_+3A_no_agg">no_agg</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>: then there is no aggregation, leading to the estimation of all <code style="white-space: pre;">&#8288;cohort x time to treatment&#8288;</code> coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a matrix of <code style="white-space: pre;">&#8288;cohort x relative_period&#8288;</code> interactions, and if used within a <code>fixest</code> estimation, the coefficients will automatically be aggregated to obtain the ATT for each relative period. In practice, the coefficients are aggregated with the <code><a href="#topic+aggregate.fixest">aggregate.fixest</a></code> function whose argument <code>agg</code> is automatically set to the appropriate value.
</p>
<p>The SA method requires relative periods (negative/positive for before/after the treatment). Either the user can compute the RP (relative periods) by his/her own, either the RPs are computed on the fly from the periods and the cohorts (which then should represent the treatment period).
</p>
<p>The never treated, which are the cohorts displaying only negative RPs are used as references (i.e. no dummy will be constructed for them). On the other hand, the always treated are removed from the estimation, by means of adding NAs for each of their observations.
</p>
<p>If the RPs have to be constructed on the fly, any cohort that is not present in the period is considered as never treated. This means that if the period ranges from 1995 to 2005, <code>cohort = 1994</code> will be considered as never treated, although it should be considered as always treated: so be careful.
</p>
<p>If you construct your own relative periods, the controls cohorts should have only negative RPs.
</p>


<h3>Value</h3>

<p>If not used within a <code>fixest</code> estimation, this function will return a matrix of interacted coefficients.
</p>


<h3>Binning</h3>

<p>You can bin periods with the arguments <code>bin</code>, <code>bin.c</code>, <code>bin.p</code> and/or <code>bin.rel</code>.
</p>
<p>The argument <code>bin</code> applies both to the original periods and cohorts (the cohorts will also be binned!). This argument only works when the <code>period</code> represent &quot;calendar&quot; periods (not relative ones!).
</p>
<p>Alternatively you can bin the periods with <code>bin.p</code> (either &quot;calendar&quot; or relative); or the cohorts with <code>bin.c</code>.
</p>
<p>The argument <code>bin.rel</code> applies only to the relative periods (hence not to the cohorts) once they have been created.
</p>
<p>To understand how binning works, please have a look at the help and examples of the function <code><a href="#topic+bin">bin</a></code>.
</p>
<p>Binning can be done in many different ways: just remember that it is not because it is possible that it does makes sense!
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple DiD example
data(base_stagg)
head(base_stagg)

# Note that the year_treated is set to 1000 for the never treated
table(base_stagg$year_treated)
table(base_stagg$time_to_treatment)

# The DiD estimation
res_sunab = feols(y ~ x1 + sunab(year_treated, year) | id + year, base_stagg)
etable(res_sunab)

# By default the reference periods are the first year and the year before the treatment
# i.e. ref.p = c(-1, .F); where .F is a shortcut for the first period.
# Say you want to set as references the first three periods on top of -1

res_sunab_3ref = feols(y ~ x1 + sunab(year_treated, year, ref.p = c(.F + 0:2, -1)) |
                         id + year, base_stagg)

# Display the two results
iplot(list(res_sunab, res_sunab_3ref))

# ... + show all refs
iplot(list(res_sunab, res_sunab_3ref), ref = "all")


#
# ATT
#

# To get the total ATT, you can use summary with the agg argument:
summary(res_sunab, agg = "ATT")

# You can also look at the total effect per cohort
summary(res_sunab, agg = "cohort")


#
# Binning
#

# Binning can be done in many different ways

# binning the cohort
est_bin.c   = feols(y ~ x1 + sunab(year_treated, year, bin.c = 3:2) | id + year, base_stagg)

# binning the period
est_bin.p   = feols(y ~ x1 + sunab(year_treated, year, bin.p = 3:1) | id + year, base_stagg)

# binning both the cohort and the period
est_bin     = feols(y ~ x1 + sunab(year_treated, year, bin = 3:1) | id + year, base_stagg)

# binning the relative period, grouping every two years
est_bin.rel = feols(y ~ x1 + sunab(year_treated, year, bin.rel = "bin::2") | id + year, base_stagg)

etable(est_bin.c, est_bin.p, est_bin, est_bin.rel, keep = "year")


</code></pre>

<hr>
<h2 id='terms.fixest'>Extract the terms</h2><span id='topic+terms.fixest'></span>

<h3>Description</h3>

<p>This function extracts the terms of a <code>fixest</code> estimation, excluding the fixed-effects part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.fixest_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="terms.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("terms", "formula")</code> which contains the terms representation of a symbolic model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple estimation on iris data, using "Species" fixed-effects
res = feols(Sepal.Length ~ Sepal.Width*Petal.Length +
            Petal.Width | Species, iris)

# Terms of the linear part
terms(res)


</code></pre>

<hr>
<h2 id='to_integer'>Fast transform of any type of vector(s) into an integer vector</h2><span id='topic+to_integer'></span>

<h3>Description</h3>

<p>Tool to transform any type of vector, or even combination of vectors, into an integer vector ranging from 1 to the number of unique values. This actually creates an unique identifier vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_integer(
  ...,
  sorted = FALSE,
  add_items = FALSE,
  items.list = FALSE,
  multi.df = FALSE,
  multi.join = "_",
  internal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_integer_+3A_...">...</code></td>
<td>
<p>Vectors of any type, to be transformed in integer.</p>
</td></tr>
<tr><td><code id="to_integer_+3A_sorted">sorted</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether the integer vector should make reference to sorted values?</p>
</td></tr>
<tr><td><code id="to_integer_+3A_add_items">add_items</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to add the unique values of the original vector(s). If requested, an attribute <code>items</code> is created containing the values (alternatively, they can appear in a list if <code>items.list=TRUE</code>).</p>
</td></tr>
<tr><td><code id="to_integer_+3A_items.list">items.list</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only used if <code>add_items=TRUE</code>. If <code>TRUE</code>, then a list of length 2 is returned with <code>x</code> the integer vector and <code>items</code> the vector of items.</p>
</td></tr>
<tr><td><code id="to_integer_+3A_multi.df">multi.df</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> then a data.frame listing the unique elements is returned in the form of a data.frame. Ignored if <code>add_items = FALSE</code>.</p>
</td></tr>
<tr><td><code id="to_integer_+3A_multi.join">multi.join</code></td>
<td>
<p>Character scalar used to join the items of multiple vectors. The default is <code>"_"</code>. Ignored if <code>add_items = FALSE</code>.</p>
</td></tr>
<tr><td><code id="to_integer_+3A_internal">internal</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. For programming only. If this function is used within another function, setting <code>internal = TRUE</code> is needed to make the evaluation of <code>...</code> valid. End users of <code>to_integer</code> should not care.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reruns a vector of the same length as the input vectors.
If <code>add_items=TRUE</code> and <code>items.list=TRUE</code>, a list of two elements is returned: <code>x</code> being the integer vector and <code>items</code> being the unique values to which the values in <code>x</code> make reference.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x1 = iris$Species
x2 = as.integer(iris$Sepal.Length)

# transforms the species vector into integers
to_integer(x1)

# To obtain the "items":
to_integer(x1, add_items = TRUE)
# same but in list form
to_integer(x1, add_items = TRUE, items.list = TRUE)

# transforms x2 into an integer vector from 1 to 4
to_integer(x2, add_items = TRUE)

# To have the sorted items:
to_integer(x2, add_items = TRUE, sorted = TRUE)

# The result can safely be used as an index
res = to_integer(x2, add_items = TRUE, sorted = TRUE, items.list = TRUE)
all(res$items[res$x] == x2)


#
# Multiple vectors
#

to_integer(x1, x2, add_items = TRUE)

# You can use multi.join to handle the join of the items:
to_integer(x1, x2, add_items = TRUE, multi.join = "; ")

</code></pre>

<hr>
<h2 id='trade'>Trade data sample</h2><span id='topic+trade'></span>

<h3>Description</h3>

<p>This data reports trade information between countries of the European Union (EU15).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(trade)
</code></pre>


<h3>Format</h3>

<p><code>trade</code> is a data frame with 38,325 observations and 6 variables named <code>Destination</code>, <code>Origin</code>, <code>Product</code>, <code>Year</code>, <code>dist_km</code> and <code>Euros</code>.
</p>

<ul>
<li><p> Origin: 2-digits codes of the countries of origin of the trade flow.
</p>
</li>
<li><p> Destination: 2-digits codes of the countries of destination of the trade flow.
</p>
</li>
<li><p> Products: Number representing the product categories (from 1 to 20).
</p>
</li>
<li><p> Year: Years from 2007 to 2016
</p>
</li>
<li><p> dist_km: Geographic distance in km between the centers of the countries of origin and destination.
</p>
</li>
<li><p> Euros: The total amount in euros of the trade flow for the specific year/product category/origin-destination country pair.
</p>
</li></ul>



<h3>Source</h3>

<p>This data has been extrated from Eurostat on October 2017.
</p>

<hr>
<h2 id='unpanel'>Dissolves a <code>fixest</code> panel</h2><span id='topic+unpanel'></span>

<h3>Description</h3>

<p>Transforms a <code>fixest_panel</code> object into a regular data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpanel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpanel_+3A_x">x</code></td>
<td>
<p>A <code>fixest_panel</code> object (obtained from function <code><a href="#topic+panel">panel</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data set of the exact same dimension. Only the attribute 'panel_info' is erased.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>Alternatively, the function <code><a href="#topic+panel">panel</a></code> changes a <code>data.frame</code> into a panel from which the functions <code>l</code> and <code>f</code> (creating leads and lags) can be called. Otherwise you can set the panel 'live' during the estimation using the argument <code>panel.id</code> (see for example in the function <code><a href="#topic+feols">feols</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(base_did)

# Setting a data set as a panel
pdat = panel(base_did, ~id+period)

# ... allows you to use leads and lags in estimations
feols(y~l(x1, 0:1), pdat)

# Now unpanel =&gt; returns the initial data set
class(pdat) ; dim(pdat)
new_base = unpanel(pdat)
class(new_base) ; dim(new_base)



</code></pre>

<hr>
<h2 id='update.fixest'>Updates a <code>fixest</code> estimation</h2><span id='topic+update.fixest'></span>

<h3>Description</h3>

<p>Updates and re-estimates a <code>fixest</code> model (estimated with <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>). This function updates the formulas and use previous starting values to estimate a new <code>fixest</code> model. The data is obtained from the original <code>call</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
update(object, fml.update, nframes = 1, evaluate = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="update.fixest_+3A_fml.update">fml.update</code></td>
<td>
<p>Changes to be made to the original argument <code>fml</code>. See more information on <code><a href="stats.html#topic+update.formula">update.formula</a></code>. You can add/withdraw both variables and fixed-effects. E.g. <code>. ~ . + x2 | . + z2</code> would add the variable <code>x2</code> and the cluster <code>z2</code> to the former estimation.</p>
</td></tr>
<tr><td><code id="update.fixest_+3A_nframes">nframes</code></td>
<td>
<p>(Advanced users.) Defaults to 1. Number of frames up the stack where to perform the evaluation of the updated call. By default, this is the parent frame.</p>
</td></tr>
<tr><td><code id="update.fixest_+3A_evaluate">evaluate</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>FALSE</code>, only the updated call is returned.</p>
</td></tr>
<tr><td><code id="update.fixest_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a <code>fixest</code> object (see details in <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. <code><a href="#topic+predict.fixest">predict.fixest</a></code>, <code><a href="#topic+summary.fixest">summary.fixest</a></code>, <code><a href="#topic+vcov.fixest">vcov.fixest</a></code>, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example using trade data
data(trade)

# main estimation
est_pois = fepois(Euros ~ log(dist_km) | Origin + Destination, trade)

# we add the variable log(Year)
est_2 = update(est_pois, . ~ . + log(Year))

# we add another fixed-effect: "Product"
est_3 = update(est_2, . ~ . | . + Product)

# we remove the fixed-effect "Origin" and the variable log(dist_km)
est_4 = update(est_3, . ~ . - log(dist_km) | . - Origin)

# Quick look at the 4 estimations
etable(est_pois, est_2, est_3, est_4)

</code></pre>

<hr>
<h2 id='vcov_cluster'>Clustered VCOV</h2><span id='topic+vcov_cluster'></span>

<h3>Description</h3>

<p>Computes the clustered VCOV of <code>fixest</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcov_cluster(x, cluster = NULL, ssc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_cluster_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object.</p>
</td></tr>
<tr><td><code id="vcov_cluster_+3A_cluster">cluster</code></td>
<td>
<p>Either i) a character vector giving the names of the variables onto which to cluster, or ii) a formula giving those names, or iii) a vector/list/data.frame giving the hard values of the clusters. Note that in cases i) and ii) the variables are fetched directly in the data set used for the estimation.</p>
</td></tr>
<tr><td><code id="vcov_cluster_+3A_ssc">ssc</code></td>
<td>
<p>An object returned by the function <code><a href="#topic+ssc">ssc</a></code>. It specifies how to perform the small sample correction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the first argument is a <code>fixest</code> object, then a VCOV is returned (i.e. a symmetric matrix).
</p>
<p>If the first argument is not a <code>fixest</code> object, then a) implicitly the arguments are shifted to the left (i.e. <code>vcov_cluster(~var1 + var2)</code> is equivalent to <code>vcov_cluster(cluster = ~var1 + var2)</code>) and b) a VCOV-<em>request</em> is returned and NOT a VCOV. That VCOV-request can then be used in the argument <code>vcov</code> of various <code>fixest</code> functions (e.g. <code><a href="#topic+vcov.fixest">vcov.fixest</a></code> or even in the estimation calls).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>References</h3>

<p>Cameron AC, Gelbach JB, Miller DL (2011). &quot;Robust Inference with Multiway Clustering.&quot; <em>Journal of Business &amp; Economic Statistics</em>, 29(2), 238-249. doi:10.1198/jbes.2010.07136.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")
base$clu = rep(1:5, 30)

est = feols(y ~ x1, base)

# VCOV: using a formula giving the name of the clusters
vcov_cluster(est, ~species + clu)

# works as well with a character vector
vcov_cluster(est, c("species", "clu"))

# you can also combine the two with '^'
vcov_cluster(est, ~species^clu)

#
# Using VCOV requests
#

# per se: pretty useless...
vcov_cluster(~species)

# ...but VCOV-requests can be used at estimation time:
# it may be more explicit than...
feols(y ~ x1, base, vcov = vcov_cluster("species"))

# ...the equivalent, built-in way:
feols(y ~ x1, base, vcov = ~species)

# The argument vcov does not accept hard values,
# so you can feed them with a VCOV-request:
feols(y ~ x1, base, vcov = vcov_cluster(rep(1:5, 30)))


</code></pre>

<hr>
<h2 id='vcov_conley'>Conley VCOV</h2><span id='topic+vcov_conley'></span><span id='topic+conley'></span>

<h3>Description</h3>

<p>Compute VCOVs robust to spatial correlation, a la Conley (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcov_conley(
  x,
  lat = NULL,
  lon = NULL,
  cutoff = NULL,
  pixel = 0,
  distance = "triangular",
  ssc = NULL
)

conley(cutoff = NULL, pixel = NULL, distance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_conley_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object.</p>
</td></tr>
<tr><td><code id="vcov_conley_+3A_lat">lat</code></td>
<td>
<p>A character scalar or a one sided formula giving the name of the variable representing the latitude. The latitude must lie in [-90, 90], [0, 180] or [-180, 0].</p>
</td></tr>
<tr><td><code id="vcov_conley_+3A_lon">lon</code></td>
<td>
<p>A character scalar or a one sided formula giving the name of the variable representing the longitude. The longitude must be in [-180, 180], [0, 360] or [-360, 0].</p>
</td></tr>
<tr><td><code id="vcov_conley_+3A_cutoff">cutoff</code></td>
<td>
<p>The distance cutoff, in km. You can express the cutoff in miles by writing the number in character form and adding &quot;mi&quot; as a suffix: cutoff = &quot;100mi&quot; would be 100 miles. If missing, a rule of thumb is used to deduce the cutoff.</p>
</td></tr>
<tr><td><code id="vcov_conley_+3A_pixel">pixel</code></td>
<td>
<p>A positive numeric scalar, default is 0. If a positive number, the coordinates of each observation are pooled into <code>pixel</code> x <code>pixel</code> km squares. This lowers the precision but can (depending on the cases) greatly improve computational speed at a low precision cost. Note that if the <code>cutoff</code> was expressed in miles, then <code>pixel</code> will also be in miles.</p>
</td></tr>
<tr><td><code id="vcov_conley_+3A_distance">distance</code></td>
<td>
<p>How to compute the distance between points. It can be equal to &quot;triangular&quot; (default) or &quot;spherical&quot;. The latter case corresponds to the great circle distance and is more precise than triangular but is a bit more intensive computationally.</p>
</td></tr>
<tr><td><code id="vcov_conley_+3A_ssc">ssc</code></td>
<td>
<p>An object returned by the function <code><a href="#topic+ssc">ssc</a></code>. It specifies how to perform the small sample correction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes VCOVs that are robust to spatial correlations by assuming a correlation between the units that are at a geographic distance lower than a given cutoff.
</p>
<p>The kernel is uniform.
</p>
<p>If the cutoff is not provided, an estimation of it is given. This cutoff ensures that a minimum of units lie within it and is robust to sub-sampling. This automatic cutoff is only here for convenience, the most appropriate cutoff shall depend on the application and shall be provided by the user.
</p>
<p>The function <code>conley</code> does not compute VCOVs directly but is meant to be used in the argument <code>vcov</code> of <code>fixest</code> functions (e.g. in <code><a href="#topic+vcov.fixest">vcov.fixest</a></code> or even in the estimation calls).
</p>


<h3>Value</h3>

<p>If the first argument is a <code>fixest</code> object, then a VCOV is returned (i.e. a symmetric matrix).
</p>
<p>If the first argument is not a <code>fixest</code> object, then a) implicitly the arguments are shifted to the left (i.e. <code>vcov_conley("lat", "long")</code> is equivalent to <code>vcov_conley(lat = "lat", lon = "long")</code>) and b) a VCOV-<em>request</em> is returned and NOT a VCOV. That VCOV-request can then be used in the argument <code>vcov</code> of various <code>fixest</code> functions (e.g. <code><a href="#topic+vcov.fixest">vcov.fixest</a></code> or even in the estimation calls).
</p>


<h3>References</h3>

<p>Conley TG (1999). &quot;GMM Estimation with Cross Sectional Dependence&quot;, <em>Journal of Econometrics</em>, 92, 1-45.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(quakes)

# We use conley() in the vcov argument of the estimation
feols(depth ~ mag, quakes, conley(100))

# Post estimation
est = feols(depth ~ mag, quakes)
vcov_conley(est, cutoff = 100)



</code></pre>

<hr>
<h2 id='vcov_hac'>HAC VCOVs</h2><span id='topic+vcov_hac'></span><span id='topic+vcov_DK'></span><span id='topic+vcov_NW'></span><span id='topic+NW'></span><span id='topic+newey_west'></span><span id='topic+DK'></span><span id='topic+driscoll_kraay'></span>

<h3>Description</h3>

<p>Set of functions to compute the VCOVs robust to different forms correlation in panel or time series settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcov_DK(x, time = NULL, lag = NULL, ssc = NULL)

vcov_NW(x, unit = NULL, time = NULL, lag = NULL, ssc = NULL)

NW(lag = NULL)

newey_west(lag = NULL)

DK(lag = NULL)

driscoll_kraay(lag = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_hac_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object.</p>
</td></tr>
<tr><td><code id="vcov_hac_+3A_time">time</code></td>
<td>
<p>A character scalar or a one sided formula giving the name of the variable representing the time.</p>
</td></tr>
<tr><td><code id="vcov_hac_+3A_lag">lag</code></td>
<td>
<p>An integer scalar, default is <code>NULL</code>. If <code>NULL</code>, then the default lag is equal to <code>n_t^0.25</code> with <code>n_t</code> the number of time periods (as of Newey and West 1987) for panel Newey-West and Driscoll-Kraay. The default for the time series Newey-West is computed via <code><a href="sandwich.html#topic+NeweyWest">bwNeweyWest</a></code> which implements the Newey and West 1994 method.</p>
</td></tr>
<tr><td><code id="vcov_hac_+3A_ssc">ssc</code></td>
<td>
<p>An object returned by the function <code><a href="#topic+ssc">ssc</a></code>. It specifies how to perform the small sample correction.</p>
</td></tr>
<tr><td><code id="vcov_hac_+3A_unit">unit</code></td>
<td>
<p>A character scalar or a one sided formula giving the name of the variable representing the units of the panel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are currently three VCOV types: Newey-West applied to time series, Newey-West applied to a panel setting (when the argument 'unit' is not missing), and Driscoll-Kraay.
</p>
<p>The functions on this page without the prefix &quot;vcov_&quot; do not compute VCOVs directly but are meant to be used in the argument <code>vcov</code> of <code>fixest</code> functions (e.g. in <code><a href="#topic+vcov.fixest">vcov.fixest</a></code> or even in the estimation calls).
</p>
<p>Note that for Driscoll-Kraay VCOVs, to ensure its properties the number of periods should be long enough (a minimum of 20 periods or so).
</p>


<h3>Value</h3>

<p>If the first argument is a <code>fixest</code> object, then a VCOV is returned (i.e. a symmetric matrix).
</p>
<p>If the first argument is not a <code>fixest</code> object, then a) implicitly the arguments are shifted to the left (i.e. <code>vcov_DK(~year)</code> is equivalent to <code>vcov_DK(time = ~year)</code>) and b) a VCOV-<em>request</em> is returned and NOT a VCOV. That VCOV-request can then be used in the argument <code>vcov</code> of various <code>fixest</code> functions (e.g. <code><a href="#topic+vcov.fixest">vcov.fixest</a></code> or even in the estimation calls).
</p>


<h3>Lag selection</h3>

<p>The default lag selection depends on whether the VCOV applies to a panel or a time series.
</p>
<p>For panels, i.e. panel Newey-West or Driscoll-Kraay VCOV, the default lag is <code>n_t^0.25</code> with <code>n_t</code> the number of time periods. This is based on Newey and West 1987.
</p>
<p>For time series Newey-West, the default lag is found thanks to the <code><a href="sandwich.html#topic+NeweyWest">bwNeweyWest</a></code> function from the <code>sandwich</code> package. It is based on Newey and West 1994.
</p>


<h3>References</h3>

<p>Newey WK, West KD (1987). &quot;A Simple, Positive Semi-Definite, Heteroskedasticity and Autocorrelation Consistent Covariance Matrix.&quot; <em>Econometrica</em>, 55(3), 703-708. doi:10.2307/1913610.
</p>
<p>Driscoll JC, Kraay AC (1998). &quot;Consistent Covariance Matrix Estimation with Spatially Dependent Panel Data.&quot; <em>The Review of Economics and Statistics</em>, 80(4), 549-560. doi:10.1162/003465398557825.
</p>
<p>Millo G (2017). &quot;Robust Standard Error Estimators for Panel Models: A Unifying Approach&quot; <em>Journal of Statistical Software</em>, 82(3). doi:10.18637/jss.v082.i03.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(base_did)

#
# During the estimation
#

# Panel Newey-West, lag = 2
feols(y ~ x1, base_did, NW(2) ~ id + period)

# Driscoll-Kraay
feols(y ~ x1, base_did, DK ~ period)

# If the estimation is made with a panel.id, the dimensions are
# automatically deduced:
est = feols(y ~ x1, base_did, "NW", panel.id = ~id + period)
est

#
# Post estimation
#

# If missing, the unit and time are automatically deduced from
# the panel.id used in the estimation
vcov_NW(est, lag = 2)


</code></pre>

<hr>
<h2 id='vcov.fixest'>Computes the variance/covariance of a <code>fixest</code> object</h2><span id='topic+vcov.fixest'></span>

<h3>Description</h3>

<p>This function extracts the variance-covariance of estimated parameters from a model estimated with <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
vcov(
  object,
  vcov = NULL,
  se = NULL,
  cluster,
  ssc = NULL,
  attr = FALSE,
  forceCovariance = FALSE,
  keepBounded = FALSE,
  nthreads = getFixest_nthreads(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.fixest_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="vcov.fixest_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="vcov.fixest_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="vcov.fixest_+3A_ssc">ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code><a href="#topic+ssc">ssc</a></code>. Represents how the degree of freedom correction should be done.You must use the function <code><a href="#topic+ssc">ssc</a></code> for this argument. The arguments and defaults of the function <code><a href="#topic+ssc">ssc</a></code> are: <code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>, <code>t.df = "min"</code>, <code style="white-space: pre;">&#8288;fixef.force_exact=FALSE)&#8288;</code>. See the help of the function <code><a href="#topic+ssc">ssc</a></code> for details.</p>
</td></tr>
<tr><td><code id="vcov.fixest_+3A_attr">attr</code></td>
<td>
<p>Logical, defaults to <code>FALSE</code>. Whether to include the attributes describing how the VCOV was computed.</p>
</td></tr>
<tr><td><code id="vcov.fixest_+3A_forcecovariance">forceCovariance</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. In the peculiar case where the obtained Hessian is not invertible (usually because of collinearity of some variables), use this option to force the covariance matrix, by using a generalized inverse of the Hessian. This can be useful to spot where possible problems come from.</p>
</td></tr>
<tr><td><code id="vcov.fixest_+3A_keepbounded">keepBounded</code></td>
<td>
<p>(Advanced users &ndash; <code>feNmlm</code> with non-linear part and bounded coefficients only.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then the bounded coefficients (if any) are treated as unrestricted coefficients and their S.E. is computed (otherwise it is not).</p>
</td></tr>
<tr><td><code id="vcov.fixest_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than, or equal to, the maximum number of threads; b) 0: meaning all available threads will be used; c) a number strictly between 0 and 1 which represents the fraction of all threads to use. The default is to use 50% of all threads. You can set permanently the number of threads used within this package using the function <code><a href="#topic+setFixest_nthreads">setFixest_nthreads</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.fixest_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+summary.fixest">summary.fixest</a></code>.
</p>
<p>The computation of the VCOV matrix is first done in <code><a href="#topic+summary.fixest">summary.fixest</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an explanation on how the standard-errors are computed and what is the exact meaning of the arguments, please have a look at the dedicated vignette: <a href="https://lrberge.github.io/fixest/articles/standard_errors.html">On standard-errors</a>.
</p>


<h3>Value</h3>

<p>It returns a <code class="reqn">K\times K</code> square matrix where <code class="reqn">K</code> is the number of variables of the fitted model.
If <code>attr = TRUE</code>, this matrix has an attribute &ldquo;type&rdquo; specifying how this variance/covariance matrix has been computed.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>You can also compute VCOVs with the following functions: <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_hac</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code>.
</p>
<p>See also the main estimation functions <code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or <code><a href="#topic+feglm">feglm</a></code>. <code><a href="#topic+summary.fixest">summary.fixest</a></code>, <code><a href="#topic+confint.fixest">confint.fixest</a></code>, <code><a href="#topic+resid.fixest">resid.fixest</a></code>, <code><a href="#topic+predict.fixest">predict.fixest</a></code>, <code><a href="#topic+fixef.fixest">fixef.fixest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load panel data
data(base_did)

# Simple estimation on a panel
est = feols(y ~ x1, base_did)

# ======== #
# IID VCOV #
# ======== #

# By default the VCOV assumes iid errors:
se(vcov(est))

# You can make the call for an iid VCOV explicitly:
se(vcov(est, "iid"))

#
# Heteroskedasticity-robust VCOV
#

# By default the VCOV assumes iid errors:
se(vcov(est, "hetero"))

# =&gt; note that it also accepts vcov = "White" and vcov = "HC1" as aliases.

# =============== #
# Clustered VCOVs #
# =============== #

# To cluster the VCOV, you can use a formula of the form cluster ~ var1 + var2 etc
# Let's cluster by the panel ID:
se(vcov(est, cluster ~ id))

# Alternative ways:

# -&gt; cluster is implicitly assumed when a one-sided formula is provided
se(vcov(est, ~ id))

# -&gt; using the argument cluster instead of vcov
se(vcov(est, cluster = ~ id))

# For two-/three- way clustering, just add more variables:
se(vcov(est, ~ id + period))

# -------------------|
# Implicit deduction |
# -------------------|
# When the estimation contains FEs, the dimension on which to cluster
# is directly inferred from the FEs used in the estimation, so you don't need
# to explicitly add them.

est_fe = feols(y ~ x1 | id + period, base_did)

# Clustered along "id"
se(vcov(est_fe, "cluster"))

# Clustered along "id" and "period"
se(vcov(est_fe, "twoway"))


# =========== #
# Panel VCOVs #
# =========== #

# ---------------------|
# Newey West (NW) VCOV |
# ---------------------|
# To obtain NW VCOVs, use a formula of the form NW ~ id + period
se(vcov(est, NW ~ id + period))

# If you want to change the lag:
se(vcov(est, NW(3) ~ id + period))

# Alternative way:

# -&gt; using the vcov_NW function
se(vcov(est, vcov_NW(unit = "id", time = "period", lag = 3)))

# -------------------------|
# Driscoll-Kraay (DK) VCOV |
# -------------------------|
# To obtain DK VCOVs, use a formula of the form DK ~ period

se(vcov(est, DK ~ period))

# If you want to change the lag:
se(vcov(est, DK(3) ~ period))

# Alternative way:

# -&gt; using the vcov_DK function
se(vcov(est, vcov_DK(time = "period", lag = 3)))

# -------------------|
# Implicit deduction |
# -------------------|
# When the estimation contains a panel identifier, you don't need
# to re-write them later on

est_panel = feols(y ~ x1, base_did, panel.id = ~id + period)

# Both methods, NM and DK, now work automatically
se(vcov(est_panel, "NW"))
se(vcov(est_panel, "DK"))


# =================================== #
# VCOVs robust to spatial correlation #
# =================================== #

data(quakes)
est_geo = feols(depth ~ mag, quakes)

# ------------|
# Conley VCOV |
# ------------|
# To obtain a Conley VCOV, use a formula of the form conley(cutoff) ~ lat + lon
# with lat/lon the latitude/longitude variable names in the data set
se(vcov(est_geo, conley(100) ~ lat + long))

# Alternative way:

# -&gt; using the vcov_DK function
se(vcov(est_geo, vcov_conley(lat = "lat", lon = "long", cutoff = 100)))

# -------------------|
# Implicit deduction |
# -------------------|
# By default the latitude and longitude are directly fetched in the data based
# on pattern matching. So you don't have to specify them.
# Furhter, an automatic cutoff is deduced by default.

# The following works:
se(vcov(est_geo, "conley"))


# ======================== #
# Small Sample Corrections #
# ======================== #

# You can change the way the small sample corrections are done with the argument ssc.
# The argument ssc must be created by the ssc function
se(vcov(est, ssc = ssc(adj = FALSE)))

# You can add directly the call to ssc in the vcov formula.
# You need to add it like a variable:
se(vcov(est, iid ~ ssc(adj = FALSE)))
se(vcov(est, DK ~ period + ssc(adj = FALSE)))



</code></pre>

<hr>
<h2 id='wald'>Wald test of nullity of coefficients</h2><span id='topic+wald'></span>

<h3>Description</h3>

<p>Wald test used to test the joint nullity of a set of coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wald(x, keep = NULL, drop = NULL, print = TRUE, vcov, se, cluster, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wald_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the methods
<code><a href="#topic+femlm">femlm</a></code>, <code><a href="#topic+feols">feols</a></code> or
<code><a href="#topic+feglm">feglm</a></code>.</p>
</td></tr>
<tr><td><code id="wald_+3A_keep">keep</code></td>
<td>
<p>Character vector. This element is used to display only a subset of variables. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be kept. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code>keep = "x[[:digit:]]$"</code>. If the first character is an exclamation mark, the effect is reversed (e.g. keep = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is kept). See details.</p>
</td></tr>
<tr><td><code id="wald_+3A_drop">drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed. This should be a vector of regular expressions (see <code><a href="base.html#topic+regex">base::regex</a></code> help for more info). Each variable satisfying any of the regular expressions will be discarded. This argument is applied post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display only <code>x1</code> to <code>x9</code>, then you could use <code style="white-space: pre;">&#8288;drop = "x[[:digit:]]{2}&#8288;</code>&quot;. If the first character is an exclamation mark, the effect is reversed (e.g. drop = &quot;!Intercept&quot; means: every variable that does not contain &ldquo;Intercept&rdquo; is dropped). See details.</p>
</td></tr>
<tr><td><code id="wald_+3A_print">print</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>TRUE</code>, then a verbose description of the test is prompted on the R console. Otherwise only a named vector containing the test statistics is returned.</p>
</td></tr>
<tr><td><code id="wald_+3A_vcov">vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The VCOV types implemented are: &quot;iid&quot;, &quot;hetero&quot; (or &quot;HC1&quot;), &quot;cluster&quot;, &quot;twoway&quot;, &quot;NW&quot; (or &quot;newey_west&quot;), &quot;DK&quot; (or &quot;driscoll_kraay&quot;), and &quot;conley&quot;. It also accepts object from <code><a href="#topic+vcov_cluster">vcov_cluster</a></code>, <code><a href="#topic+vcov_hac">vcov_NW</a></code>, <code><a href="#topic+vcov_hac">NW</a></code>, <code><a href="#topic+vcov_hac">vcov_DK</a></code>, <code><a href="#topic+vcov_hac">DK</a></code>, <code><a href="#topic+vcov_conley">vcov_conley</a></code> and <code><a href="#topic+vcov_conley">conley</a></code>. It also accepts covariance matrices computed externally. Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td></tr>
<tr><td><code id="wald_+3A_se">se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed: &ldquo;standard&rdquo;, &ldquo;hetero&rdquo;, &ldquo;cluster&rdquo;, &ldquo;twoway&rdquo;, &ldquo;threeway&rdquo; or &ldquo;fourway&rdquo;? By default if there are clusters in the estimation: <code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated, you should use <code>vcov</code> instead.</p>
</td></tr>
<tr><td><code id="wald_+3A_cluster">cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can be either a list of vectors, a character vector of variable names, a formula or an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments are valid and do the same thing: <code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as fixed-effects in the estimation, you can leave it blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td></tr>
<tr><td><code id="wald_+3A_...">...</code></td>
<td>
<p>Any other element to be passed to <code><a href="#topic+summary.fixest">summary.fixest</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type of VCOV matrix plays a crucial role in this test. Use the arguments <code>se</code> and <code>cluster</code> to change the type of VCOV for the test.
</p>


<h3>Value</h3>

<p>A named vector containing the following elements is returned: <code>stat</code>, <code>p</code>, <code>df1</code>, and <code>df2</code>. They correspond to the test statistic, the p-value, the first and second degrees of freedoms.
</p>
<p>If no valid coefficient is found, the value <code>NA</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(airquality)

est = feols(Ozone ~ Solar.R + Wind + poly(Temp, 3), airquality)

# Testing the joint nullity of the Temp polynomial
wald(est, "poly")

# Same but with clustered SEs
wald(est, "poly", cluster = "Month")

# Now: all vars but the polynomial and the intercept
wald(est, drop = "Inte|poly")

#
# Toy example: testing pre-trends
#

data(base_did)

est_did = feols(y ~ x1 + i(period, treat, 5) | id + period, base_did)

# The graph of the coefficients
coefplot(est_did)

# The pre-trend test
wald(est_did, "period::[1234]$")

# If "period::[1234]$" looks weird to you, check out
# regular expressions: e.g. see ?regex.
# Learn it, you won't regret it!


</code></pre>

<hr>
<h2 id='weights.fixest'>Extracts the weights from a <code>fixest</code> object</h2><span id='topic+weights.fixest'></span>

<h3>Description</h3>

<p>Simply extracts the weights used to estimate a <code>fixest</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
weights(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights.fixest_+3A_object">object</code></td>
<td>
<p>A <code>fixest</code> object.</p>
</td></tr>
<tr><td><code id="weights.fixest_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of the same length as the number of observations in the original data set. Ignored observations due to NA or perfect fit are re-introduced and their weights set to NA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feols">feols</a></code>, <code><a href="#topic+feglm">fepois</a></code>, <code><a href="#topic+feglm">feglm</a></code>, <code><a href="#topic+femlm">fenegbin</a></code>, <code><a href="#topic+feNmlm">feNmlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
est = feols(Petal.Length ~ Petal.Width, iris, weights = ~as.integer(Sepal.Length) - 3.99)
weights(est)

</code></pre>

<hr>
<h2 id='xpd'>Expands formula macros</h2><span id='topic+xpd'></span>

<h3>Description</h3>

<p>Create macros within formulas and expand them with character vectors or other formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xpd(fml, ..., add = NULL, lhs, rhs, data = NULL, frame = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xpd_+3A_fml">fml</code></td>
<td>
<p>A formula containing macros variables. Each macro variable must start with two dots. The macro variables can be set globally using <code>setFixest_fml</code>, or can be defined in <code>...</code>. Special macros of the form <code>..("regex")</code> can be used to fetch, through a regular expression, variables directly in a character vector (or in column names) given in the argument <code>data</code> (note that the algorithm tries to &quot;guess&quot; the argument data when nested in function calls [see example]). You can negate the regex by starting with a <code>"!"</code>. Square brackets have a special meaning: Values in them are evaluated and parsed accordingly. Example: <code>y~x.[1:2] + z.[i]</code> will lead to <code>y~x1+x2+z3</code> if <code>i==3</code>. You can trigger the auto-completion of variables by using the <code>'..'</code> suffix, like in <code>y ~ x..</code> which would include <code>x1</code> and <code>x2</code>, etc. See examples.</p>
</td></tr>
<tr><td><code id="xpd_+3A_...">...</code></td>
<td>
<p>Definition of the macro variables. Each argument name corresponds to the name of the macro variable. It is required that each macro variable name starts with two dots (e.g. <code>..ctrl</code>). The value of each argument must be a one-sided formula or a character vector, it is the definition of the macro variable. Example of a valid call: <code>setFixest_fml(..ctrl = ~ var1 + var2)</code>. In the function <code>xpd</code>, the default macro variables are taken from <code>getFixest_fml</code>, any variable in <code>...</code> will replace these values. You can enclose values in <code>.[]</code>, if so they will be evaluated from the current environment. For example <code>..ctrl = ~ x.[1:2] + .[z]</code> will lead to <code>~x1 + x2 + var</code> if <code>z</code> is equal to <code>"var"</code>.</p>
</td></tr>
<tr><td><code id="xpd_+3A_add">add</code></td>
<td>
<p>Either a character scalar or a one-sided formula. The elements will be added to the right-hand-side of the formula, before any macro expansion is applied.</p>
</td></tr>
<tr><td><code id="xpd_+3A_lhs">lhs</code></td>
<td>
<p>If present then a formula will be constructed with <code>lhs</code> as the full left-hand-side. The value of <code>lhs</code> can be a one-sided formula, a call, or a character vector. Note that the macro variables wont be applied. You can use it in combination with the argument <code>rhs</code>. Note that if <code>fml</code> is not missing, its LHS will be replaced by <code>lhs</code>.</p>
</td></tr>
<tr><td><code id="xpd_+3A_rhs">rhs</code></td>
<td>
<p>If present, then a formula will be constructed with <code>rhs</code> as the full right-hand-side. The value of <code>rhs</code> can be a one-sided formula, a call, or a character vector. Note that the macro variables wont be applied. You can use it in combination with the argument <code>lhs</code>. Note that if <code>fml</code> is not missing, its RHS will be replaced by <code>rhs</code>.</p>
</td></tr>
<tr><td><code id="xpd_+3A_data">data</code></td>
<td>
<p>Either a character vector or a data.frame. This argument will only be used if a macro of the type <code>..("regex")</code> is used in the formula of the argument <code>fml</code>. If so, any variable name from <code>data</code> that matches the regular expression will be added to the formula.</p>
</td></tr>
<tr><td><code id="xpd_+3A_frame">frame</code></td>
<td>
<p>The environment containing the values to be expanded with the dot square bracket operator. Default is <code>parent.frame()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>xpd</code>, the default macro variables are taken from <code>getFixest_fml</code>. Any value in the <code>...</code> argument of <code>xpd</code> will replace these default values.
</p>
<p>The definitions of the macro variables will replace in verbatim the macro variables. Therefore, you can include multi-part formulas if you wish but then beware of the order of the macros variable in the formula. For example, using the <code>airquality</code> data, say you want to set as controls the variable <code>Temp</code> and <code>Day</code> fixed-effects, you can do <code>setFixest_fml(..ctrl = ~Temp | Day)</code>, but then <code>feols(Ozone ~ Wind + ..ctrl, airquality)</code> will be quite different from <code>feols(Ozone ~ ..ctrl + Wind, airquality)</code>, so beware!
</p>


<h3>Value</h3>

<p>It returns a formula where all macros have been expanded.
</p>


<h3>Dot square bracket operator in formulas</h3>

<p>In a formula, the dot square bracket (DSB) operator can: i) create manifold variables at once, or ii) capture values from the current environment and put them verbatim in the formula.
</p>
<p>Say you want to include the variables <code>x1</code> to <code>x3</code> in your formula. You can use <code>xpd(y ~ x.[1:3])</code> and you'll get <code>y ~ x1 + x2 + x3</code>.
</p>
<p>To summon values from the environment, simply put the variable in square brackets. For example: <code>for(i in 1:3) xpd(y.[i] ~ x)</code> will create the formulas <code>y1 ~ x</code> to <code>y3 ~ x</code> depending on the value of <code>i</code>.
</p>
<p>You can include a full variable from the environment in the same way: <code>for(y in c("a", "b")) xpd(.[y] ~ x)</code> will create the two formulas <code>a ~ x</code> and <code>b ~ x</code>.
</p>
<p>The DSB can even be used within variable names, but then the variable must be nested in character form. For example <code>y ~ .["x.[1:2]_sq"]</code> will create <code>y ~ x1_sq + x2_sq</code>. Using the character form is important to avoid a formula parsing error. Double quotes must be used. Note that the character string that is nested will be parsed with the function <code><a href="#topic+dsb">dsb</a></code>, and thus it will return a vector.
</p>
<p>By default, the DSB operator expands vectors into sums. You can add a comma, like in <code>.[, x]</code>, to expand with commas&ndash;the content can then be used within functions. For instance: <code>c(x.[, 1:2])</code> will create <code>c(x1, x2)</code> (and <em>not</em> <code>c(x1 + x2)</code>).
</p>
<p>In all <code>fixest</code> estimations, this special parsing is enabled, so you don't need to use <code>xpd</code>.
</p>
<p>One-sided formulas can be expanded with the DSB operator: let <code>x = ~sepal + petal</code>, then <code>xpd(y ~ .[x])</code> leads to <code>color ~ sepal + petal</code>.
</p>
<p>You can even use multiple square brackets within a single variable, but then the use of nesting is required. For example, the following <code>xpd(y ~ .[".[letters[1:2]]_.[1:2]"])</code> will create <code>y ~ a_1 + b_2</code>. Remember that the nested character string is parsed with <code><a href="#topic+dsb">dsb</a></code>, which explains this behavior.
</p>
<p>When the element to be expanded i) is equal to the empty string or, ii) is of length 0, it is replaced with a neutral element, namely <code>1</code>. For example, <code style="white-space: pre;">&#8288;x = "" ; xpd(y ~ .[x])&#8288;</code> leads to <code>y ~ 1</code>.
</p>


<h3>Regular expressions</h3>

<p>You can catch several variable names at once by using regular expressions. To use regular expressions, you need to enclose it in the dot-dot or the regex function: <code>..("regex")</code> or <code>regex("regex")</code>. For example, <code>regex("Sepal")</code> will catch both the variables <code>Sepal.Length</code> and <code>Sepal.Width</code> from the <code>iris</code> data set. In a <code>fixest</code> estimation, the variables names from which the regex will be applied come from the data set. If you use <code>xpd</code>, you need to provide either a data set or a vector of names in the argument <code>data</code>.
</p>
<p>By default the variables are aggregated with a sum. For example in a data set with the variables x1 to x10, <code style="white-space: pre;">&#8288;regex("x(1|2)"&#8288;</code> will yield <code>x1 + x2 + x10</code>. You can instead ask for &quot;comma&quot; aggregation by using a comma first, just before the regular expression: <code>y ~ sw(regex(,"x(1|2)"))</code> would lead to <code>y ~ sw(x1, x2, x10)</code>.
</p>
<p>Note that the dot square bracket operator (DSB, see before) is applied before the regular expression is evaluated. This means that <code>regex("x.[3:4]_sq")</code> will lead, after evaluation of the DSB, to <code>regex("x3_sq|x4_sq")</code>. It is a handy way to insert range of numbers in a regular expression.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setFixest_fml">setFixest_fml</a></code> to set formula macros, and <code><a href="#topic+dsb">dsb</a></code> to modify character strings with the DSB operator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Small examples with airquality data
data(airquality)
# we set two macro variables
setFixest_fml(..ctrl = ~ Temp + Day,
              ..ctrl_long = ~ poly(Temp, 2) + poly(Day, 2))

# Using the macro in lm with xpd:
lm(xpd(Ozone ~ Wind + ..ctrl), airquality)
lm(xpd(Ozone ~ Wind + ..ctrl_long), airquality)

# You can use the macros without xpd() in fixest estimations
a = feols(Ozone ~ Wind + ..ctrl, airquality)
b = feols(Ozone ~ Wind + ..ctrl_long, airquality)
etable(a, b, keep = "Int|Win")


# Using .[]

base = setNames(iris, c("y", "x1", "x2", "x3", "species"))
i = 2:3
z = "species"
lm(xpd(y ~ x.[2:3] + .[z]), base)

# No xpd() needed in feols
feols(y ~ x.[2:3] + .[z], base)

#
# Auto completion with '..' suffix
#

# You can trigger variables autocompletion with the '..' suffix
# You need to provide the argument data
base = setNames(iris, c("y", "x1", "x2", "x3", "species"))
xpd(y ~ x.., data = base)

# In fixest estimations, this is automatically taken care of
feols(y ~ x.., data = base)


#
# You can use xpd for stepwise estimations
#

# Note that for stepwise estimations in fixest, you can use
# the stepwise functions: sw, sw0, csw, csw0
# -&gt; see help in feols or in the dedicated vignette

# we want to look at the effect of x1 on y
# controlling for different variables

base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

# We first create a matrix with all possible combinations of variables
my_args = lapply(names(base)[-(1:2)], function(x) c("", x))
(all_combs = as.matrix(do.call("expand.grid", my_args)))

res_all = list()
for(i in 1:nrow(all_combs)){
  res_all[[i]] = feols(xpd(y ~ x1 + ..v, ..v = all_combs[i, ]), base)
}

etable(res_all)
coefplot(res_all, group = list(Species = "^^species"))

#
# You can use macros to grep variables in your data set
#

# Example 1: setting a macro variable globally

data(longley)
setFixest_fml(..many_vars = grep("GNP|ployed", names(longley), value = TRUE))
feols(Armed.Forces ~ Population + ..many_vars, longley)

# Example 2: using ..("regex") or regex("regex") to grep the variables "live"

feols(Armed.Forces ~ Population + ..("GNP|ployed"), longley)

# Example 3: same as Ex.2 but without using a fixest estimation

# Here we need to use xpd():
lm(xpd(Armed.Forces ~ Population + regex("GNP|ployed"), data = longley), longley)

# Stepwise estimation with regex: use a comma after the parenthesis
feols(Armed.Forces ~ Population + sw(regex(,"GNP|ployed")), longley)

# Multiple LHS
etable(feols(..("GNP|ployed") ~ Population, longley))


#
# lhs and rhs arguments
#

# to create a one sided formula from a character vector
vars = letters[1:5]
xpd(rhs = vars)

# Alternatively, to replace the RHS
xpd(y ~ 1, rhs = vars)

# To create a two sided formula
xpd(lhs = "y", rhs = vars)

#
# argument 'add'
#

xpd(~x1, add = ~ x2 + x3)

# also works with character vectors
xpd(~x1, add = c("x2", "x3"))

# only adds to the RHS
xpd(y ~ x, add = ~bon + jour)

#
# Dot square bracket operator
#

# The basic use id to add variables in the formula
x = c("x1", "x2")
xpd(y ~ .[x])

# Alternatively, one-sided formulas can be used and their content will be inserted verbatim
x = ~x1 + x2
xpd(y ~ .[x])

# You can create multiple variables at once
xpd(y ~ x.[1:5] + z.[2:3])

# You can summon variables from the environment to complete variables names
var = "a"
xpd(y ~ x.[var])

# ... the variables can be multiple
vars = LETTERS[1:3]
xpd(y ~ x.[vars])

# You can have "complex" variable names but they must be nested in character form
xpd(y ~ .["x.[vars]_sq"])

# DSB can be used within regular expressions
re = c("GNP", "Pop")
xpd(Unemployed ~ regex(".[re]"), data = longley)

# =&gt; equivalent to regex("GNP|Pop")

# Use .[,var] (NOTE THE COMMA!) to expand with commas
# !! can break the formula if missused
vars = c("wage", "unemp")
xpd(c(y.[,1:3]) ~ csw(.[,vars]))


# Example of use of .[] within a loop
res_all = list()
for(p in 1:3){
  res_all[[p]] = feols(Ozone ~ Wind + poly(Temp, .[p]), airquality)
}

etable(res_all)

# The former can be compactly estimated with:
res_compact = feols(Ozone ~ Wind + sw(.[, "poly(Temp, .[1:3])"]), airquality)

etable(res_compact)

# How does it work?
# 1)  .[, stuff] evaluates stuff and, if a vector, aggregates it with commas
#     Comma aggregation is done thanks to the comma placed after the square bracket
#     If .[stuff], then aggregation is with sums.
# 2) stuff is evaluated, and if it is a character string, it is evaluated with
# the function dsb which expands values in .[]
#
# Wrapping up:
# 2) evaluation of dsb("poly(Temp, .[1:3])") leads to the vector:
#    c("poly(Temp, 1)", "poly(Temp, 2)", "poly(Temp, 3)")
# 1) .[, c("poly(Temp, 1)", "poly(Temp, 2)", "poly(Temp, 3)")] leads to
#    poly(Temp, 1), poly(Temp, 2), poly(Temp, 3)
#
# Hence sw(.[, "poly(Temp, .[1:3])"]) becomes:
#       sw(poly(Temp, 1), poly(Temp, 2), poly(Temp, 3))


#
# In non-fixest functions: guessing the data allows to use regex
#

# When used in non-fixest functions, the algorithm tries to "guess" the data
# so that ..("regex") can be directly evaluated without passing the argument 'data'
data(longley)
lm(xpd(Armed.Forces ~ Population + ..("GNP|ployed")), longley)

# same for the auto completion with '..'
lm(xpd(Armed.Forces ~ Population + GN..), longley)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
