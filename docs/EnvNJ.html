<!DOCTYPE html><html><head><title>Help for package EnvNJ</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EnvNJ}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aa.at'><p>Residue Found at the Requested Position</p></a></li>
<li><a href='#aa.comp'><p>Amino Acid Composition</p></a></li>
<li><a href='#aaf'><p>Compute the Frequency of Each Amino Acid in Each Species</p></a></li>
<li><a href='#bovids'><p>13 orthologous mtDNA-encoded proteins of 11 bovine species.</p></a></li>
<li><a href='#cos2dis'><p>Convert Cosines Between Vectors into Pairwise Dissimilarities</p></a></li>
<li><a href='#d.phy2df'><p>Convert a Phylip Distance Matrix into a DataFrame</p></a></li>
<li><a href='#df2fasta'><p>Convert Dataframe into Fasta File</p></a></li>
<li><a href='#env.extract'><p>Sequence Environment Around a Given Position</p></a></li>
<li><a href='#env.fasta'><p>Build Trees Based on the Environment Around the Indicated Amino Acid(s)</p></a></li>
<li><a href='#env.matrices'><p>Environment Matrices</p></a></li>
<li><a href='#env.sp'><p>Extract the Sequence Environments</p></a></li>
<li><a href='#envfascpp'><p>Convert Fasta Files into Environment Vectors</p></a></li>
<li><a href='#envnj'><p>Build Trees Based on the Environment Around the Indicated Amino Acid(s)</p></a></li>
<li><a href='#fastaconc'><p>Concatenate Fasta Files in a Single Multispecies Fasta File</p></a></li>
<li><a href='#metrics'><p>Pairwise Vector Dissimilarities</p></a></li>
<li><a href='#msa.merge'><p>Carry Out a MSA of a Set of Different Orthologous Proteins</p></a></li>
<li><a href='#msa.tree'><p>Infer a tree based on a MSA</p></a></li>
<li><a href='#ncd'><p>Compute Normalized Compression Distances</p></a></li>
<li><a href='#ncdnj'><p>Compute a Distance Matrix Using Normalized Compression Distance</p></a></li>
<li><a href='#ngram'><p>Compute n-Gram Frequencies Vector</p></a></li>
<li><a href='#ngraMatrix'><p>Compute n-Gram Frequencies Dataframe</p></a></li>
<li><a href='#otu.space'><p>Compute the Matrix Representing the Species Vector Subspace</p></a></li>
<li><a href='#otu.vector'><p>Convert a Set of Sequence Environments into a Vector</p></a></li>
<li><a href='#reyes'><p>13 orthologous mtDNA-encoded proteins of 34 mammalian species.</p></a></li>
<li><a href='#svdgram'><p>Compute Phylogenetic Trees Using an n-Gram and SVD Approach</p></a></li>
<li><a href='#vcos'><p>Compute Pairwise Cosines of the Angles Between Vectors</p></a></li>
<li><a href='#vdis'><p>Compute Pairwise Distances Between Vectors</p></a></li>
<li><a href='#vect2tree'><p>Convert a Set of Vectors into a Tree</p></a></li>
<li><a href='#vtree'><p>Build a Tree When Species Are Encoded by n-Dim Vectors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Whole Genome Phylogenies Using Sequence Environments</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains utilities for the analysis of protein sequences in a phylogenetic context. 
    Allows   the generation of phylogenetic trees base on protein sequences in an alignment-independent way. 
    Two different methods have been implemented. One approach is based on the frequency analysis of n-grams, 
    previously described in Stuart et al. (2002) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2F18.1.100">doi:10.1093/bioinformatics/18.1.100</a>&gt;. The other approach is based on the species-specific neighborhood preference around amino acids. Features include the conversion of a protein set into a vector 
    reflecting these neighborhood preferences, pairwise distances (dissimilarity) between these vectors, 
    and the generation of trees based on these distance matrices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, bio3d, graphics, phangorn, philentropy, seqinr, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-27 10:36:44 UTC; JCA</td>
</tr>
<tr>
<td>Author:</td>
<td>Juan Carlos Aledo <a href="https://orcid.org/0000-0002-3497-9945"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan Carlos Aledo &lt;caledo@uma.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-27 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aa.at'>Residue Found at the Requested Position</h2><span id='topic+aa.at'></span>

<h3>Description</h3>

<p>Returns the residue found at the requested position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa.at(at, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa.at_+3A_at">at</code></td>
<td>
<p>the position in the primary structure of the protein.</p>
</td></tr>
<tr><td><code id="aa.at_+3A_target">target</code></td>
<td>
<p>a character string specifying the sequence of the protein of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a single character representing the residue found at the indicated position in the indicated protein.
</p>


<h3>See Also</h3>

<p>aa.comp()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa.at(2, 'MFSQQQRCVE')
</code></pre>

<hr>
<h2 id='aa.comp'>Amino Acid Composition</h2><span id='topic+aa.comp'></span>

<h3>Description</h3>

<p>Returns a table with the amino acid composition of the target protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa.comp(target, uniprot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa.comp_+3A_target">target</code></td>
<td>
<p>a character string specifying the UniProt ID of the protein of interest or, alternatively, the sequence of that protein.</p>
</td></tr>
<tr><td><code id="aa.comp_+3A_uniprot">uniprot</code></td>
<td>
<p>logical, if TRUE the argument 'target' should be an ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with the absolute frequency of each type of residue found in the target peptide.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa.comp('MPSSVSWGILLLAGLCCLVPVSLAEDPQGDAAQK', uniprot = FALSE)
</code></pre>

<hr>
<h2 id='aaf'>Compute the Frequency of Each Amino Acid in Each Species</h2><span id='topic+aaf'></span>

<h3>Description</h3>

<p>Computes the frequency of each amino acid in each species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aaf(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aaf_+3A_data">data</code></td>
<td>
<p>input data must be a dataframe (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input data must be a dataframe where each row corresponds to an individual protein, and each column identifies a species. Therefore, the columns' names of this dataframe must be coherent with the names of the OTUs being analyzed.
</p>


<h3>Value</h3>

<p>A dataframe providing amino acid frequencies en the set of species. Rows correspond amino acids and columns to species.
</p>


<h3>See Also</h3>

<p>env.sp(), otu.vector(), otu.space()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aaf(bovids)
</code></pre>

<hr>
<h2 id='bovids'>13 orthologous mtDNA-encoded proteins of 11 bovine species.</h2><span id='topic+bovids'></span>

<h3>Description</h3>

<p>A dataset containing the sequences of mtDNA-encoded proteins from different bovids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bovids
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 rows (one per protein) and 11 variables (one per species)
</p>


<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/genome/organelle/">https://www.ncbi.nlm.nih.gov/genome/organelle/</a>
</p>

<hr>
<h2 id='cos2dis'>Convert Cosines Between Vectors into Pairwise Dissimilarities</h2><span id='topic+cos2dis'></span>

<h3>Description</h3>

<p>Converts cosines values into dissimilarities values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cos2dis(cos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cos2dis_+3A_cos">cos</code></td>
<td>
<p>a square upper triangular matrix where cos(i,j) is the cosine between the vector i and j.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cosines are standard measure of vector similarity, and can be converted into distance by dij = -log( (1 + cos(i,j) )/2).
</p>


<h3>Value</h3>

<p>A triangular matrix with the distances.
</p>


<h3>See Also</h3>

<p>vcos()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bovids)
vectors = otu.space(bovids[, 7:11])
cosData = vcos(vectors)
disData = cos2dis(cosData)
</code></pre>

<hr>
<h2 id='d.phy2df'>Convert a Phylip Distance Matrix into a DataFrame</h2><span id='topic+d.phy2df'></span>

<h3>Description</h3>

<p>Converts a phylip distance matrix into a either an R dataFrame or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.phy2df(phyfile, as = 'matrix')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.phy2df_+3A_phyfile">phyfile</code></td>
<td>
<p>path to the file containing the distances in phylip format.</p>
</td></tr>
<tr><td><code id="d.phy2df_+3A_as">as</code></td>
<td>
<p>class of the output R data. It should be either 'dataframe' or 'matrix'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a dataframe or a matrix containing the distances read from the phy file.
</p>


<h3>See Also</h3>

<p>d.df2pny()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: d.phy2df(phyfile = "./data_t/d_dummy.txt")
</code></pre>

<hr>
<h2 id='df2fasta'>Convert Dataframe into Fasta File</h2><span id='topic+df2fasta'></span>

<h3>Description</h3>

<p>Converts a dataframe into a fasta file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df2fasta(df, out.file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df2fasta_+3A_df">df</code></td>
<td>
<p>a named (both rows and cols) dataframe (see details).</p>
</td></tr>
<tr><td><code id="df2fasta_+3A_out.file">out.file</code></td>
<td>
<p>path and name of output file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format of the df should be as follows. Each row represents a protein sequence and each column a species.
</p>


<h3>Value</h3>

<p>A fasta file that is saved in the specified path.
</p>


<h3>See Also</h3>

<p>fastaconc()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: df2fasta(df = bovids, out.file = "./example.fasta")
</code></pre>

<hr>
<h2 id='env.extract'>Sequence Environment Around a Given Position</h2><span id='topic+env.extract'></span>

<h3>Description</h3>

<p>Extracts the sequence environment around a given position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env.extract(seq, c, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env.extract_+3A_seq">seq</code></td>
<td>
<p>a string protein sequence.</p>
</td></tr>
<tr><td><code id="env.extract_+3A_c">c</code></td>
<td>
<p>center of the environment.</p>
</td></tr>
<tr><td><code id="env.extract_+3A_r">r</code></td>
<td>
<p>radius of the environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a  a strings with the extracted environment sequence.
</p>


<h3>References</h3>

<p>Aledo et al. Sci Rep. 2015; 5: 16955. (PMID: 26597773)
</p>


<h3>See Also</h3>

<p>env.matrices(), env.sp()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env.extract('ARGGQQQCATSYV', c = 8,  r = 2)
</code></pre>

<hr>
<h2 id='env.fasta'>Build Trees Based on the Environment Around the Indicated Amino Acid(s)</h2><span id='topic+env.fasta'></span>

<h3>Description</h3>

<p>Builds trees based on the environment around the indicated amino acid(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env.fasta(file, r = 10, aa = 'all', out.file = 'any')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env.fasta_+3A_file">file</code></td>
<td>
<p>path to the single multispecies fasta file to be used as input.</p>
</td></tr>
<tr><td><code id="env.fasta_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the radius of the sequence segment considered as environment.</p>
</td></tr>
<tr><td><code id="env.fasta_+3A_aa">aa</code></td>
<td>
<p>the amino acid(s) to be used to encoded the species.</p>
</td></tr>
<tr><td><code id="env.fasta_+3A_out.file">out.file</code></td>
<td>
<p>path and name of output file. Only if intermediate results data want to be saved (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds alignment-independent phylogenetic trees. The input data is a fasta file. When an out.file path is provided, the environment sequences of each species and the vector representing each species are saved in the path provided.
</p>


<h3>Value</h3>

<p>A list with two objects, the first one is an inter-species distance matrix. The second one is an object of class 'phylo'.
</p>


<h3>See Also</h3>

<p>envnj(), fastaconc()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: env.fasta(file = "./data_t/sample5.fasta")
</code></pre>

<hr>
<h2 id='env.matrices'>Environment Matrices</h2><span id='topic+env.matrices'></span>

<h3>Description</h3>

<p>Provides the frequencies of each amino acid within the environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env.matrices(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env.matrices_+3A_env">env</code></td>
<td>
<p>a character string vector containing the environments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of two dataframes. The first, shown the environment in matrix form. The second provides the frequencies of each amino acid within the environments.
</p>


<h3>References</h3>

<p>Aledo et al. Sci Rep. 2015; 5: 16955. (PMID: 26597773)
</p>


<h3>See Also</h3>

<p>env.extract(), otu.vector()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env.matrices(c('ANQRmCTPQ', 'LYPPmQTPC', 'XXGSmSGXX'))
</code></pre>

<hr>
<h2 id='env.sp'>Extract the Sequence Environments</h2><span id='topic+env.sp'></span>

<h3>Description</h3>

<p>Extracts the sequence environments around the selected amino acid(s) in the chosen species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env.sp(data, sp, r = 10, aa = 'all', silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env.sp_+3A_data">data</code></td>
<td>
<p>input data must be a dataframe (see details).</p>
</td></tr>
<tr><td><code id="env.sp_+3A_sp">sp</code></td>
<td>
<p>the species of interest (it should be named as in the input dataframe).</p>
</td></tr>
<tr><td><code id="env.sp_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the radius of the sequence segment considered as environment.</p>
</td></tr>
<tr><td><code id="env.sp_+3A_aa">aa</code></td>
<td>
<p>the amino acid(s) which environments are going to be extracted.</p>
</td></tr>
<tr><td><code id="env.sp_+3A_silent">silent</code></td>
<td>
<p>logical. When FALSE the program progress is reported to alleviate loneliness.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input data must be a dataframe where each row corresponds to an individual protein. The columns contain the sequence of the protein corresponding to the row in each species. Therefore, the columns' names of this dataframe must be coherent with the names of the OTUs being analyzed.
</p>


<h3>Value</h3>

<p>A list of environment sequences. Each element from the list is a vector with the environment sequences around an amino acid. So, the length list is the same as the length of aa.
</p>


<h3>See Also</h3>

<p>otu.vector(), otu.space()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bovids)
env.sp(data = bovids, sp = "Bos_taurus", r = 2)
</code></pre>

<hr>
<h2 id='envfascpp'>Convert Fasta Files into Environment Vectors</h2><span id='topic+envfascpp'></span>

<h3>Description</h3>

<p>Converts fasta files into environment vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envfascpp(path, r = 10, exefile, outfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envfascpp_+3A_path">path</code></td>
<td>
<p>path to the folder that contain a the file 'list.txt', which contains the names of all the fasta files to be analyzed (one per line). The fasta files must be in the same path.</p>
</td></tr>
<tr><td><code id="envfascpp_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the radius of the sequence segment considered as environment.</p>
</td></tr>
<tr><td><code id="envfascpp_+3A_exefile">exefile</code></td>
<td>
<p>path to the directory containing the envfas executable.</p>
</td></tr>
<tr><td><code id="envfascpp_+3A_outfile">outfile</code></td>
<td>
<p>path to, and name of, output file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds and write vectors representing the species' proteome. To use this function, you must first download the source code envfas.cpp (https://bitbucket.org/jcaledo/envnj/src/master/AncillaryCode/envfas.cpp) and compile it.
</p>


<h3>Value</h3>

<p>A txt file per fasta file analyzed. Each txt file can be read as a vector. Thus the number of lines gives the dimension of the vector.
</p>


<h3>See Also</h3>

<p>envnj(), fastaconc()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: envfastacpp("./data_t/list.txt", 10, ".", "./MyResults")
</code></pre>

<hr>
<h2 id='envnj'>Build Trees Based on the Environment Around the Indicated Amino Acid(s)</h2><span id='topic+envnj'></span>

<h3>Description</h3>

<p>Builds trees based on the environment around the indicated amino acid(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envnj(data, r = 10, aa = 'all', metric = "cosine", clustering = "nj", outgroup = 'any')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envnj_+3A_data">data</code></td>
<td>
<p>input data must be a dataframe where each row corresponds to a protein sequence and each column to a species.</p>
</td></tr>
<tr><td><code id="envnj_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the radius of the sequence segment considered as environment.</p>
</td></tr>
<tr><td><code id="envnj_+3A_aa">aa</code></td>
<td>
<p>the amino acid(s) to be used to encoded the species.</p>
</td></tr>
<tr><td><code id="envnj_+3A_metric">metric</code></td>
<td>
<p>character string indicating the metric (see metrics() to see the methods allowed).</p>
</td></tr>
<tr><td><code id="envnj_+3A_clustering">clustering</code></td>
<td>
<p>string indicating the clustering method, either &quot;nj&quot; or &quot;upgma&quot;.</p>
</td></tr>
<tr><td><code id="envnj_+3A_outgroup">outgroup</code></td>
<td>
<p>when a rooted tree is desired, it indicates the species to be used as outgroup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds alignment-independent phylogenetic trees.
</p>


<h3>Value</h3>

<p>A list with two objects, the first one is an inter-species distance matrix. The second one is an object of class 'phylo'.
</p>


<h3>See Also</h3>

<p>otu.space(), metrics()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bovids)
envnj(bovids[, 7:11], aa = "all", outgroup = "Pseudoryx_nghetinhensis")

</code></pre>

<hr>
<h2 id='fastaconc'>Concatenate Fasta Files in a Single Multispecies Fasta File</h2><span id='topic+fastaconc'></span>

<h3>Description</h3>

<p>Concatenate fasta files from different species in a single multispecies fasta file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastaconc(otus, inputdir = ".", out.file = "./concatenated_multispecies.fasta")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastaconc_+3A_otus">otus</code></td>
<td>
<p>a character vector giving the otus' names.</p>
</td></tr>
<tr><td><code id="fastaconc_+3A_inputdir">inputdir</code></td>
<td>
<p>path to the directory containing the individual fasta files.</p>
</td></tr>
<tr><td><code id="fastaconc_+3A_out.file">out.file</code></td>
<td>
<p>path and name of output file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When we have fasta files (extension should be '.fasta'), each one for a species containing different sequences of the given species, this function concatenate the different sequences of the same species and writes it as a single sequence in a single multispecies fasta file. If the individual fasta files are found in the working directory, the inputdir argument don't need to be passed. The names of the individual fasta files must match the otus' names.
</p>


<h3>Value</h3>

<p>A single multispecies fasta file with the sequences of each species spliced in a single sequence.
</p>


<h3>See Also</h3>

<p>df2fasta()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: fastaconc(otus = c('Glis_glis', 'Ovis_aries', 'Sus_scrofa'))
</code></pre>

<hr>
<h2 id='metrics'>Pairwise Vector Dissimilarities</h2><span id='topic+metrics'></span>

<h3>Description</h3>

<p>Computes the dissimilarity between n-dimensional vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics(vset, method = 'euclidean', p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics_+3A_vset">vset</code></td>
<td>
<p>matrix (n x m) where each column is a n-dimensional vector.</p>
</td></tr>
<tr><td><code id="metrics_+3A_method">method</code></td>
<td>
<p>a character string indicating the distance/dissimilarity method to be used (see details).</p>
</td></tr>
<tr><td><code id="metrics_+3A_p">p</code></td>
<td>
<p>power of the Minkowski distance. This parameter is only relevant if the method 'minkowski' has been selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although many of the offered methods compute a proper distance, that is not always the case. For instance, for a non null vector, v, the 'cosine' method gives d(v, 2v) = 0, violating the coincidence axiom. For that reason we prefer to use the term dissimilarity instead of distance. The methods offered can be grouped into families.
</p>


<h4>L_p family:</h4>

<p>('euclidean', 'manhattan', 'minkowski', 'chebyshev')
</p>
<p>Euclidean = sqrt( sum | P_i - Q_i |^2)
</p>
<p>Manhattan = sum | P_i - Q_i |
</p>
<p>Minkowski = ( sum| P_i - Q_i |^p)^1/p
</p>
<p>Chebyshev = max | P_i - Q_i |
</p>



<h4>L_1 family:</h4>

<p>('sorensen', 'soergel', 'lorentzian', 'kulczynski', 'canberra')
</p>
<p>Sorensen = sum | P_i - Q_i | / sum (P_i + Q_i)
</p>
<p>Soergel = sum | P_i - Q_i | / sum max(P_i , Q_i)
</p>
<p>Lorentzian = sum ln(1 + | P_i - Q_i |)
</p>
<p>Kulczynski = sum | P_i - Q_i | / sum min(P_i , Q_i)
</p>
<p>Canberra = sum | P_i - Q_i | / (P_i + Q_i)
</p>



<h4>Intersection family:</h4>

<p>('non-intersection', 'wavehedges', 'czekanowski', 'motyka')
</p>
<p>Non-intersection = 1 - sum min(P_i , Q_i)
</p>
<p>Wave-Hedges = sum | P_i - Q_i | / max(P_i , Q_i)
</p>
<p>Czekanowski = sum | P_i - Q_i | / sum | P_i + Q_i |
</p>
<p>Motyka = sum max(P_i , Q_i) / sum (P_i , Q_i)
</p>



<h4>Inner product family:</h4>

<p>('cosine', 'jaccard')
</p>
<p>Cosine = - ln(0.5 (1 +  (P_i Q_i) / sqrt(sum P_i^2) sqrt(sum Q_i^2)))
</p>
<p>Jaccard = 1 - sum (P_i Q_i) / (sum P_i^2 + sum Q_i^2 - sum (P_i Q_i))
</p>



<h4>Squared-chord family:</h4>

<p>('bhattacharyya', 'squared_chord')
</p>
<p>Bhattacharyya = - ln sum sqrt(P_i Q_i)
</p>
<p>Squared-chord = sum ( sqrt(P_i) - sqrt(Q_i) )^2
</p>



<h4>Squared Chi family:</h4>

<p>('squared_chi')
</p>
<p>Squared-Chi = sum ( (P_i - Q_i )^2 / (P_i + Q_i) )
</p>



<h4>Shannon's entropy family:</h4>

<p>('kullback-leibler', 'jeffreys', 'jensen-shannon', 'jensen_difference')
</p>
<p>Kullback-Leibler = sum P_i * log(P_i / Q_i)
</p>
<p>Jeffreys = sum (P_i - Q_i) * log(P_i / Q_i)
</p>
<p>Jensen-Shannon = 0.5(sum P_i ln(2P_i / (P_i + Q_i)) + sum Q_i ln(2Q_i / (P_i + Q_i)))
</p>
<p>Jensen difference = sum (0.5(P_i log(P_i) + Q_i log(Q_i)) - 0.5(P_i + Q_i) ln(0.5(P_i + Q_i))
</p>



<h4>Mismatch family:</h4>

<p>('hamming', 'mismatch', 'mismatchZero', 'binary')
</p>
<p>Hamming = (# coordinates where P_i != Q_i) / n
</p>
<p>Mismatch = # coordinates where that P_i != Q_i
</p>
<p>MismatchZero = Same as mismatch but after removing the coordinates where both vectors have zero.
</p>
<p>Binary = (# coordinates where a vector has 0 and the other has a non-zero value) / n.
</p>



<h4>Combinations family:</h4>

<p>('taneja', 'kumar-johnson', 'avg')
</p>
<p>Taneja = sum ( P_i + Q_i / 2) log( P_i + Q_i / ( 2 sqrt( P_i * Q_i)) )
</p>
<p>Kumar-Johnson = sum (P_i^2 - Q_i^2)^2 / 2 (P_i Q_i)^1.5
</p>
<p>Avg = 0.5 (sum | P_i - Q_i| + max | P_i - Q_i |)
</p>



<h3>Value</h3>

<p>A matrix with the computed dissimilarity values.
</p>


<h3>References</h3>

<p>Sung-Hyuk Cha (2007). International Journal of Mathematical Models and Methods in Applied Sciences. Issue 4, vol. 1
</p>
<p>Luczac et al. (2019). Briefings in Bioinformatics 20: 1222-1237.
</p>
<p>https://r-snippets.readthedocs.io/en/latest/real_analysis/metrics.html
</p>


<h3>See Also</h3>

<p>vcos(), vdis()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>metrics(matrix(1:9, ncol =3), 'cosine')
</code></pre>

<hr>
<h2 id='msa.merge'>Carry Out a MSA of a Set of Different Orthologous Proteins</h2><span id='topic+msa.merge'></span>

<h3>Description</h3>

<p>Carries out a MSA of a set of different orthologous proteins in different species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msa.merge(data, outfile = 'any')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msa.merge_+3A_data">data</code></td>
<td>
<p>input data must be a dataframe where each row corresponds to a protein and each column to a species.</p>
</td></tr>
<tr><td><code id="msa.merge_+3A_outfile">outfile</code></td>
<td>
<p>path to the place where a fasta file is going to be saved. If 'any', no file is saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data has the same format that the input data used for EnvNJ or SVD-n-Gram methods. Thus, the name of columns must correspond to that of species.
</p>


<h3>Value</h3>

<p>A dataframe containing the MSA (species x position).
</p>


<h3>See Also</h3>

<p>msa.tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bovids)
msa.merge(bovids)
## End(Not run)
</code></pre>

<hr>
<h2 id='msa.tree'>Infer a tree based on a MSA</h2><span id='topic+msa.tree'></span>

<h3>Description</h3>

<p>Infers a tree base on a MSA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msa.tree(data, outgroup = 'any')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msa.tree_+3A_data">data</code></td>
<td>
<p>input data must be a dataframe where each row corresponds to a protein and each column to a species.</p>
</td></tr>
<tr><td><code id="msa.tree_+3A_outgroup">outgroup</code></td>
<td>
<p>when a rooted tree is desired, indicate the species to be used as outgroup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data has the same format that the input data used for EnvNJ or SVD-n-Gram methods. Thus, the name of columns must correspond to that of species.
</p>


<h3>Value</h3>

<p>A list containing the (i) MSA, (ii) the distance matrix and (iii) the tree.
</p>


<h3>See Also</h3>

<p>msa.merge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bovids)
msa.tree(bovids)
## End(Not run)
</code></pre>

<hr>
<h2 id='ncd'>Compute Normalized Compression Distances</h2><span id='topic+ncd'></span>

<h3>Description</h3>

<p>Computes normalized compression distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncd(seq1, seq2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncd_+3A_seq1">seq1</code></td>
<td>
<p>character string indicating the path to the first fasta file to be analyzed.</p>
</td></tr>
<tr><td><code id="ncd_+3A_seq2">seq2</code></td>
<td>
<p>character string indicating the path to the second fasta file to be analyzed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two fasta files must be in the working directory. This function use zpaq to compress files. Thus, the zpaq software must be installed on your system and in the search path for executables if you wish to use this function.
NCD = (Z(xy) - min(Z(x), Z(y))) / max(Z(x), Z(y))
Where Z(x), Z(y) and Z(xy) are the lengths of the compressed versions of seq1, seq2 and the concatenated sequences 1 and 2, respectively.
</p>


<h3>Value</h3>

<p>A non-negative real value reflecting the dissimilarity between seq1 and seq2.
</p>


<h3>See Also</h3>

<p>ncdnj()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>try(ncd(seq1 = "./A.fasta", seq2 = "./B.fasta"))
</code></pre>

<hr>
<h2 id='ncdnj'>Compute a Distance Matrix Using Normalized Compression Distance</h2><span id='topic+ncdnj'></span>

<h3>Description</h3>

<p>Computes a distance matrix using normalized compression distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncdnj(wd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncdnj_+3A_wd">wd</code></td>
<td>
<p>character string indicating the path to the directory where the input files can be found (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input files, which must be found at the wd provided, consist of a file named 'list.txt' containing the names of the fasta files to be analyzed (one per line). The referred fasta files also must be found at the provided wd. This function use zpaq to compress files. Thus, the zpaq software must be installed on your system and in the search path for executables if you wish to use this function.
</p>


<h3>Value</h3>

<p>A list where the first element is a symmetric distance matrix and the second one is a phylogenetic tree build using NJ.
</p>


<h3>See Also</h3>

<p>ncd()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>try(ncdnj("./data_t"))
</code></pre>

<hr>
<h2 id='ngram'>Compute n-Gram Frequencies Vector</h2><span id='topic+ngram'></span>

<h3>Description</h3>

<p>Computes the n-gram frequencies vector for a given protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngram(prot, k = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngram_+3A_prot">prot</code></td>
<td>
<p>a character string corresponding to the primary structure of the protein.</p>
</td></tr>
<tr><td><code id="ngram_+3A_k">k</code></td>
<td>
<p>a positive integer, between 1 and 5, indicating the k-mer of the words to be counted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The one letter code for amino acids is used (capital).
</p>


<h3>Value</h3>

<p>A dataframe with two columns, the first one given the peptides and the second one the corresponding absolute frequency.
</p>


<h3>References</h3>

<p>Stuart et al. Bioinformatics 2002; 18:100-108.
</p>


<h3>See Also</h3>

<p>ngraMatrix(), ffp(), svdgram()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ngram(bovids$Bos_taurus[1], k = 3)
</code></pre>

<hr>
<h2 id='ngraMatrix'>Compute n-Gram Frequencies Dataframe</h2><span id='topic+ngraMatrix'></span>

<h3>Description</h3>

<p>Computes the n-gram frequencies dataframe for the protein and species provides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngraMatrix(data, k = 4, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngraMatrix_+3A_data">data</code></td>
<td>
<p>a dataframe with as many columns as species and one row per orthologous protein. The rows and columns must be named accordingly.</p>
</td></tr>
<tr><td><code id="ngraMatrix_+3A_k">k</code></td>
<td>
<p>a positive integer, between 1 and 5, indicating the k-mer of the words to be counted.</p>
</td></tr>
<tr><td><code id="ngraMatrix_+3A_silent">silent</code></td>
<td>
<p>logical, set to FALSE to avoid loneliness.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument prot can be obtained using orth() and orth.seq().
</p>


<h3>Value</h3>

<p>A list with two dataframes. The first one with nsp * npr columns (nsp: number of species, npr: number of proteins per species) and npe rows (npe: number of peptides, 20 for n = 1, 400 for n = 2, 8000 for n = 3 and 160000 for n = 4). The entries of the dataframe are the number of times that the indicated peptide has been counted in the given protein. Orthologous proteins are in consecutive columns, thus the first nsp columns are the orthologous of protein 1 and so on. The second dataframe contains the Species Vector Sums (each vector describes one species).
</p>


<h3>References</h3>

<p>Stuart et al. Bioinformatics 2002; 18:100-108.
</p>


<h3>See Also</h3>

<p>ngram(), svdgram()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ngraMatrix(bovids[,1:3], k = 2)
</code></pre>

<hr>
<h2 id='otu.space'>Compute the Matrix Representing the Species Vector Subspace</h2><span id='topic+otu.space'></span>

<h3>Description</h3>

<p>Computes the matrix representing the species vector subspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otu.space(data, r = 10, aa = "all", silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otu.space_+3A_data">data</code></td>
<td>
<p>input data must be a dataframe (see details).</p>
</td></tr>
<tr><td><code id="otu.space_+3A_r">r</code></td>
<td>
<p>a positive integer indicating the radius of the sequence segment considered as environment.</p>
</td></tr>
<tr><td><code id="otu.space_+3A_aa">aa</code></td>
<td>
<p>the amino acid(s) to be used to encoded the species.</p>
</td></tr>
<tr><td><code id="otu.space_+3A_silent">silent</code></td>
<td>
<p>logical. If FALSE, the running progress is reported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input data must be a dataframe where each row corresponds to an individual protein, and each column identifies a species. Therefore, the columns' names of this dataframe must be coherent with the names of the OTUs being analyzed. The dimension of the vector representing each species will depend on the settings. For instance, if we choose a single amino acid and a radius of 10 for the sequence environment, then we will get a vector of dimension 400 (20 amino acids x 20 positions). If we opt for the 20 amino acids and r = 10, then the vector will be of dimension 8000 (400 for each amino acid * 20 amino acids). Please, note that r is selected in the function env.sp() that will provide the input dataframe for the current function.
</p>


<h3>Value</h3>

<p>A matrix representing the species vector subspace.
</p>


<h3>See Also</h3>

<p>env.sp(), otu.vector()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bovids)
otu.space(bovids[, 1:5], r = 2)
</code></pre>

<hr>
<h2 id='otu.vector'>Convert a Set of Sequence Environments into a Vector</h2><span id='topic+otu.vector'></span>

<h3>Description</h3>

<p>Converts a set of sequence environments into a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otu.vector(envl, sp = "", aa = "all", silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otu.vector_+3A_envl">envl</code></td>
<td>
<p>a list containing the sequence environment of a species (as the one returned by the function env.sp()).</p>
</td></tr>
<tr><td><code id="otu.vector_+3A_sp">sp</code></td>
<td>
<p>character string indicating the species being analyzed.</p>
</td></tr>
<tr><td><code id="otu.vector_+3A_aa">aa</code></td>
<td>
<p>the amino acid(s) to be used to encoded the species.</p>
</td></tr>
<tr><td><code id="otu.vector_+3A_silent">silent</code></td>
<td>
<p>logical. When FALSE the program progress is reported to alleviate loneliness.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dimension of the vector representing the species will depend on the settings. For instance, if we choose a single amino acid and a radius of 10 for the sequence environment, then we will get a vector of dimension 400 (20 amino acids x 20 positions). If we opt for the 20 amino acids and r = 10, then the vector will be of dimension 8000 (400 for each amino acid * 20 amino acids). Please, note that r is selected in the function env.sp() that will provide the input dataframe for the current function.
</p>


<h3>Value</h3>

<p>A matrix representing the species. This matrix can be converted into a vector representing the target species just typing as.vector(matrix). Each coordinate is the frequency of a given amino acid at a certain position from the environment (see details).
</p>


<h3>See Also</h3>

<p>env.sp(), otu.space()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bovids)
cow = env.sp(bovids, "Bos_taurus")
otu.vector(cow)
</code></pre>

<hr>
<h2 id='reyes'>13 orthologous mtDNA-encoded proteins of 34 mammalian species.</h2><span id='topic+reyes'></span>

<h3>Description</h3>

<p>A dataset containing the sequences of mtDNA-encoded proteins from different mammalian species (Reyes et al. 1996, Mol.Biol. Evol. 17:979)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reyes
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 rows (one per protein) and 34 variables (one per species)
</p>


<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/genome/organelle/">https://www.ncbi.nlm.nih.gov/genome/organelle/</a>
</p>

<hr>
<h2 id='svdgram'>Compute Phylogenetic Trees Using an n-Gram and SVD Approach</h2><span id='topic+svdgram'></span>

<h3>Description</h3>

<p>Computes phylogenetic trees using an n-gram and SVD approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdgram(matrix, rank, species, SVS = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svdgram_+3A_matrix">matrix</code></td>
<td>
<p>either a dataframe or a matrix where each row represents a property of a protein (for instance, the frequencies of tetrapeptides) and each column represents a different protein (or species).</p>
</td></tr>
<tr><td><code id="svdgram_+3A_rank">rank</code></td>
<td>
<p>a numeric array providing the ranks that want to be used to approach the data matrix using SVD.</p>
</td></tr>
<tr><td><code id="svdgram_+3A_species">species</code></td>
<td>
<p>character array providing the species' names.</p>
</td></tr>
<tr><td><code id="svdgram_+3A_svs">SVS</code></td>
<td>
<p>logical. When the matrix passed as argument correspond to the peptide-protein matrix and SVS is set to TRUE, then the function will compute a matrix where the columns are the Species Vector Sums. Alternatively, if the matrix passed as argument is already a matrix where the columns encode for species, SVS should be set to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the matrix passed as argument is a matrix of peptide-protein, the function implement the method described by Stuart et al. 2002 (see references).
</p>


<h3>Value</h3>

<p>An object of class multiPhylo containing a tree for each rank value required.
</p>


<h3>References</h3>

<p>Stuart et al. Bioinformatics 2002; 18:100-108.
</p>


<h3>See Also</h3>

<p>ngraMatrix()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- ngraMatrix(bovids[, 1:4], k = 2)[[2]][, -1]
species &lt;- names(a)
svdgram(matrix = a, rank = 4, species = species, SVS = FALSE)
</code></pre>

<hr>
<h2 id='vcos'>Compute Pairwise Cosines of the Angles Between Vectors</h2><span id='topic+vcos'></span>

<h3>Description</h3>

<p>Computes pairwise cosines of the angles between vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcos(vectors, silent = TRUE, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcos_+3A_vectors">vectors</code></td>
<td>
<p>a named list (or dataframe) containing n-dimensional vectors.</p>
</td></tr>
<tr><td><code id="vcos_+3A_silent">silent</code></td>
<td>
<p>logical, set to FALSE to avoid loneliness.</p>
</td></tr>
<tr><td><code id="vcos_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cosines are standard measure of vector similarity. If the angle between two vectors in n-dimensional space is small, then the individual elements of their vectors must be very similar to each other in value, and the calculated cosine derived from these values is near one. If the vectors point in opposite directions, then the individual elements of their vectors must be very dissimilar in value, an the calculated cosine is near minus one.
</p>


<h3>Value</h3>

<p>A triangular matrix with the cosines of the angles formed between the  given vectors.
</p>


<h3>See Also</h3>

<p>vdis()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcos(otu.space(bovids[, 1:4]))
</code></pre>

<hr>
<h2 id='vdis'>Compute Pairwise Distances Between Vectors</h2><span id='topic+vdis'></span>

<h3>Description</h3>

<p>Computes pairwise distances between vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdis(cos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vdis_+3A_cos">cos</code></td>
<td>
<p>a square upper triangular matrix where cos(i,j) is the cosine between the vector i and j.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cosines are standard measure of vector similarity, and can be converted into distance by dij = -log( (1 + cos(i,j) )/2).
</p>


<h3>Value</h3>

<p>A triangular matrix with the distances.
</p>


<h3>See Also</h3>

<p>vcos()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bovids)
vectors = otu.space(bovids[, 7:11])
cosData = vcos(vectors)
disData = suppressWarnings(vdis(cosData))
</code></pre>

<hr>
<h2 id='vect2tree'>Convert a Set of Vectors into a Tree</h2><span id='topic+vect2tree'></span>

<h3>Description</h3>

<p>Converts a set of vectors into a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vect2tree(path, metric = "cosine", clustering = "nj")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vect2tree_+3A_path">path</code></td>
<td>
<p>path to the working directory. This directory must contain a txt file per vector and an additional txt file named vlist.txt that provides the names (one per line) of the  vector txt files.</p>
</td></tr>
<tr><td><code id="vect2tree_+3A_metric">metric</code></td>
<td>
<p>character string indicating the metric (see metrics() to see the methods allowed).</p>
</td></tr>
<tr><td><code id="vect2tree_+3A_clustering">clustering</code></td>
<td>
<p>string indicating the clustering method, either &quot;nj&quot; or &quot;upgma&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the distance matrix and builds the corresponding tree.
</p>


<h3>Value</h3>

<p>a list with two elements: a distance matrix and a tree.
</p>


<h3>See Also</h3>

<p>envnj(), fastaconc(), envfascpp()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vec2tree("./data_t")
</code></pre>

<hr>
<h2 id='vtree'>Build a Tree When Species Are Encoded by n-Dim Vectors</h2><span id='topic+vtree'></span>

<h3>Description</h3>

<p>Builds a tree when species are encoded by n-dim vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vtree(matrix, outgroup = 'any')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vtree_+3A_matrix">matrix</code></td>
<td>
<p>either a dataframe or matrix where each column represents an OTU.</p>
</td></tr>
<tr><td><code id="vtree_+3A_outgroup">outgroup</code></td>
<td>
<p>when a rooted tree is desired, it indicates the species to be used as outgroup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is based on a distance matrix obtained after converting the cos between vector (similarity measurement) in a dissimilarity measurement.
</p>


<h3>Value</h3>

<p>A list with two objects, the first one is an inter-species distance matrix. The second one is an object of class 'phylo'.
</p>


<h3>See Also</h3>

<p>svdgram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bovids)
mymatrix &lt;- ngraMatrix(bovids[, 6:11], k = 2)[[2]][, 2:7]
vtree(mymatrix, outgroup = "Pseudoryx_nghetinhensis")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
