<!DOCTYPE html><html><head><title>Help for package voluModel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {voluModel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#areColors'><p>Are Colors</p></a></li>
<li><a href='#blendColor'><p>Blend Colors</p></a></li>
<li><a href='#bottomRaster'><p>Bottom raster generation</p></a></li>
<li><a href='#centerPointRasterTemplate'><p>Center Point Raster Template</p></a></li>
<li><a href='#columnParse'><p>Column Parsing</p></a></li>
<li><a href='#diversityStack'><p>Diversity stack</p></a></li>
<li><a href='#downsample'><p>Occurrence downsampling</p></a></li>
<li><a href='#interpolateRaster'><p>Interpolate patchily sampled rasters</p></a></li>
<li><a href='#marineBackground'><p>Marine background shapefile generation</p></a></li>
<li><a href='#MESS3D'><p>Calculate MESS</p></a></li>
<li><a href='#mSampling2D'><p>2D background sampling</p></a></li>
<li><a href='#mSampling3D'><p>3D background sampling</p></a></li>
<li><a href='#oneRasterPlot'><p>Single raster plot</p></a></li>
<li><a href='#plotLayers'><p>Plotting 3D model in 2D</p></a></li>
<li><a href='#pointCompMap'><p>Comparative point mapping</p></a></li>
<li><a href='#pointMap'><p>Point mapping</p></a></li>
<li><a href='#rasterComp'><p>Comparative raster mapping</p></a></li>
<li><a href='#smoothRaster'><p>Smooth rasters</p></a></li>
<li><a href='#testIntersection'><p>Test Intersection</p></a></li>
<li><a href='#transpColor'><p>Transparent Color</p></a></li>
<li><a href='#xyzSample'><p>Sampling from a <code>SpatRaster</code> vector using 3D coordinates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Modeling Species Distributions in Three Dimensions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hannah L. Owens &lt;hannah.owens@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates modeling species' ecological niches and 
  geographic distributions based on occurrences and environments that 
  have a vertical as well as horizontal component, and projecting models 
  into three-dimensional geographic space. Working in three dimensions is 
  useful in an aquatic context when the organisms one wishes to model can 
  be found across a wide range of depths in the water column. The package
  also contains functions to automatically generate marine training
  model training regions using machine learning, and interpolate and smooth
  patchily sampled environmental rasters using thin plate splines.
  Davis Rabosky AR, Cox CL, Rabosky DL, Title PO, Holmes IA, Feldman A, McGuire JA (2016) &lt;<a href="https://doi.org/10.1038%2Fncomms11484">doi:10.1038/ncomms11484</a>&gt;.
  Nychka D, Furrer R, Paige J, Sain S (2021) &lt;<a href="https://doi.org/10.5065%2FD6W957CT">doi:10.5065/D6W957CT</a>&gt;.
  Pateiro-Lopez B, Rodriguez-Casal A (2022) <a href="https://CRAN.R-project.org/package=alphahull">https://CRAN.R-project.org/package=alphahull</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hannahlowens.github.io/voluModel/">https://hannahlowens.github.io/voluModel/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hannahlowens/voluModel/issues">https://github.com/hannahlowens/voluModel/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, fields, ggplot2, ggtext, grDevices, methods, modEvA,
rangeBuilder (&ge; 2.0), terra, viridisLite, sf</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), nlme, knitr, covr, gridExtra, lattice,
rmarkdown, rnaturalearth, rnaturalearthdata, tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 14:23:44 UTC; HannahOwens</td>
</tr>
<tr>
<td>Author:</td>
<td>Hannah L. Owens <a href="https://orcid.org/0000-0003-0071-1745"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Carsten Rahbek <a href="https://orcid.org/0000-0003-4585-0300"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 14:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='areColors'>Are Colors</h2><span id='topic+areColors'></span>

<h3>Description</h3>

<p>Checks to see if a given vector can be
interpreted by R as a color or colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areColors(col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areColors_+3A_col">col</code></td>
<td>
<p>A vector of anything to be interpreted by <code>rgb</code>
as a color.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector stating whether inputs
can be interpreted as colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
areColors(col = c("red", "prairie_chicken", 2))

</code></pre>

<hr>
<h2 id='blendColor'>Blend Colors</h2><span id='topic+blendColor'></span>

<h3>Description</h3>

<p>Generates a blended color from two transparent colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blendColor(col1 = "#1b9e777F", col2 = "#7570b37F")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blendColor_+3A_col1">col1</code></td>
<td>
<p>Anything that can be interpreted by <code>rgb</code>
as a color.</p>
</td></tr>
<tr><td><code id="blendColor_+3A_col2">col2</code></td>
<td>
<p>Anything that can be interpreted by <code>rgb</code>
as a color.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> string with hex color, including
adjustment for transparency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
blendColor(col1 = "#1B9E777F", col2 = "#7570B37F")

</code></pre>

<hr>
<h2 id='bottomRaster'>Bottom raster generation</h2><span id='topic+bottomRaster'></span>

<h3>Description</h3>

<p>Samples deepest depth values from a
<code>SpatVector</code> data frame and generates a <code>SpatRaster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bottomRaster(rawPointData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bottomRaster_+3A_rawpointdata">rawPointData</code></td>
<td>
<p>A <code>SpatVector</code> object from which
bottom variables will be sampled. See Details for more about format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rawPointData</code> is a <code>SpatVector</code> object that
contains measurements of a single environmental variable (e.g.
salinity, temperature, etc.) with x, y, and z coordinates. The
measurements in the <code>data.frame</code> should be organized so that each
column is a depth slice, increasing in depth from left to right. The
function was designed around the oceanographic data shapefiles supplied
by the World Ocean Atlas
(<a href="https://www.ncei.noaa.gov/access/world-ocean-atlas-2018/">https://www.ncei.noaa.gov/access/world-ocean-atlas-2018/</a>).
The function selects the &quot;deepest&quot; (rightmost) measurement at each
x, y coordinate pair that contains data. These measurements are then
rasterized at the resolution and extent of the x,y coordinates, under
the assumption that x and y intervals are equal and represent the center
of a cell.
</p>


<h3>Value</h3>

<p>A <code>SpatRaster</code> designed to approximate sea bottom
measurements for modeling species' distributions and/or niches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

# Create point grid
coords &lt;- data.frame(x = rep(seq(1:5), times = 5),
                    y = unlist(lapply(1:5, FUN = function(x) {
                      rep(x, times = 5)})))

# Create data and add NAs to simulate uneven bottom depths
dd &lt;- data.frame(SURFACE = 1:25,
                d5M = 6:30,
                d10M = 11:35,
                d25M = 16:40)
dd$d25M[c(1:5, 18:25)] &lt;- NA
dd$d10M[c(3:5, 21:23)] &lt;- NA
dd$d5M[c(4, 22)] &lt;- NA

dd[,c("x","y")] &lt;- coords

# Create SpatialPointsDataFrame
sp &lt;- vect(dd, geom = c("x", "y"))

# Here's the function
result &lt;- bottomRaster(rawPointData = sp)
plot(result)

</code></pre>

<hr>
<h2 id='centerPointRasterTemplate'>Center Point Raster Template</h2><span id='topic+centerPointRasterTemplate'></span>

<h3>Description</h3>

<p>Creates a <code>SpatRaster</code> template from a
<code>SpatVector</code> point object in which the raster cells
are centered on the vector points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centerPointRasterTemplate(rawPointData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centerPointRasterTemplate_+3A_rawpointdata">rawPointData</code></td>
<td>
<p>A <code>SpatVector</code> object with points
that will represent the center of each cell in the output
template.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rawPointData</code> is a <code>SpatVector</code> object that
contains x and y coordinates.
</p>


<h3>Value</h3>

<p>An empty <code>SpatRaster</code> designed to serve as a template for
rasterizing <code>SpatVector</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+rasterize">rasterize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

# Create point grid
coords &lt;- data.frame(x = rep(seq(1:5), times = 5),
                    y = unlist(lapply(1:5, FUN = function(x) {
                      rep(x, times = 5)})))

# Create data and add NAs to simulate uneven bottom depths
dd &lt;- data.frame(SURFACE = 1:25,
                d5M = 6:30,
                d10M = 11:35,
                d25M = 16:40)
dd$d25M[c(1:5, 18:25)] &lt;- NA
dd$d10M[c(3:5, 21:23)] &lt;- NA
dd$d5M[c(4, 22)] &lt;- NA

dd[,c("x","y")] &lt;- coords

# Create SpatialPointsDataFrame
sp &lt;- vect(dd, geom = c("x", "y"))

# Here's the function
template &lt;- centerPointRasterTemplate(rawPointData = sp)
class(template)

</code></pre>

<hr>
<h2 id='columnParse'>Column Parsing</h2><span id='topic+columnParse'></span>

<h3>Description</h3>

<p>Parses column names from input occurrence
<code>data.frame</code> for more seamless function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>columnParse(occs, wDepth = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="columnParse_+3A_occs">occs</code></td>
<td>
<p>A <code>data.frame</code> with at least two columns
named &quot;longitude&quot; and &quot;latitude&quot; or that
can be coerced into this format.</p>
</td></tr>
<tr><td><code id="columnParse_+3A_wdepth">wDepth</code></td>
<td>
<p>Logical; flags whether a depth column should
also be sought.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function to return the putative
indices for latitude and longitude or x and y coordinates
of occurrences to allow for code that is more robust to
very common user error
</p>


<h3>Value</h3>

<p>A <code>list</code> of length 2 with indices of the x and y
columns, respectively, followed by a message with a plain
text report of which columns were interpreted as x and y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

# Create sample raster
r &lt;- rast(ncol=10, nrow=10)
values(r) &lt;- 1:100

# Create test occurrences
set.seed(0)
longitude &lt;- sample(ext(r)[1]:ext(r)[2],
                    size = 10, replace = FALSE)
set.seed(0)
latitude &lt;- sample(ext(r)[3]:ext(r)[4],
                   size = 10, replace = FALSE)
set.seed(0)
depth &lt;- sample(0:35, size = 10, replace = TRUE)
occurrences &lt;- as.data.frame(cbind(longitude,latitude,depth))

# Here's the function
result &lt;- columnParse(occs = occurrences[,1:2],
                      wDepth = FALSE)
result &lt;- columnParse(occs = occurrences,
                      wDepth = TRUE)

</code></pre>

<hr>
<h2 id='diversityStack'>Diversity stack</h2><span id='topic+diversityStack'></span>

<h3>Description</h3>

<p>Takes list of rasters of species distributions
(interpreted as 1 = presence, 0 = absence), which do not
have to have the same extents, and stack them to create an
estimate of species richness that matches the extent and
resolution of a template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversityStack(rasterList, template)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversityStack_+3A_rasterlist">rasterList</code></td>
<td>
<p>A <code>list</code> of <code>SpatRaster</code> objects, which
are interpreted as species distributions (1 = presence,
0 = absence).</p>
</td></tr>
<tr><td><code id="diversityStack_+3A_template">template</code></td>
<td>
<p>A <code>SpatRaster</code> with the desired extent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatRaster</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
rast1 &lt;- rast(ncol=10, nrow=10)
values(rast1) &lt;- rep(0:1, 50)

rast2 &lt;- rast(ncol=10, nrow=10)
values(rast2) &lt;- c(rep(0, 50), rep(1,50))

rastList &lt;- list(rast1, rast2)
result &lt;- diversityStack(rasterList = rastList,
                         template = rast2)
result
plot(result)

</code></pre>

<hr>
<h2 id='downsample'>Occurrence downsampling</h2><span id='topic+downsample'></span>

<h3>Description</h3>

<p>Reduces number of occurrences to resolution of input raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsample(occs, rasterTemplate, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsample_+3A_occs">occs</code></td>
<td>
<p>A <code>data.frame</code> with at least two columns
named &quot;longitude&quot; and &quot;latitude&quot; or that
can be coerced into this format.</p>
</td></tr>
<tr><td><code id="downsample_+3A_rastertemplate">rasterTemplate</code></td>
<td>
<p>A <code>SpatRaster</code> object to serve
as a template for the resolution at which <code>occs</code> should be
downsampled.</p>
</td></tr>
<tr><td><code id="downsample_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Switching to <code>FALSE</code> mutes message describing
which columns in <code>occs</code> are interpreted as x and y coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with two columns named &quot;longitude&quot;
and &quot;latitude&quot; or with names that were used when coercing
input data into this format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
# Create sample raster
r &lt;- rast(ncol=10, nrow=10)
values(r) &lt;- 1:100

# Create test occurrences
set.seed(0)
longitude &lt;- sample(ext(r)[1]:ext(r)[2],
                    size = 10, replace = FALSE)
set.seed(0)
latitude &lt;- sample(ext(r)[3]:ext(r)[4],
                   size = 10, replace = FALSE)
occurrences &lt;- as.data.frame(cbind(longitude,latitude))

# Here's the function
result &lt;- downsample(occs = occurrences, rasterTemplate = r)

</code></pre>

<hr>
<h2 id='interpolateRaster'>Interpolate patchily sampled rasters</h2><span id='topic+interpolateRaster'></span>

<h3>Description</h3>

<p>Uses thin plate spline regression from
<code>fields</code> package to interpolate missing two-dimensional
raster values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolateRaster(inputRaster, fast = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolateRaster_+3A_inputraster">inputRaster</code></td>
<td>
<p>An object of class <code>SpatRaster</code></p>
</td></tr>
<tr><td><code id="interpolateRaster_+3A_fast">fast</code></td>
<td>
<p>A logical operator. Setting to <code>TRUE</code> triggers use
of <code>fastTps</code> instead of <code>Tps</code>.</p>
</td></tr>
<tr><td><code id="interpolateRaster_+3A_...">...</code></td>
<td>
<p>For any additional arguments passed to <code>Tps</code> or <code>fastTps</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing data values from original raster
are replaced with interpolated values. User has the
option of choosing <code>fastTps</code> to speed calculation,
but be advised that this is only an approximation
of a true thin plate spline.
</p>


<h3>Value</h3>

<p>An object of class raster
</p>


<h3>See Also</h3>

<p><code><a href="fields.html#topic+Tps">Tps</a></code>, <code><a href="fields.html#topic+fastTps">fastTps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
library(fields)
# Create sample raster
r &lt;- rast(ncol=50, nrow=50)
values(r) &lt;- 1:2500

# Introduce a "hole"
values(r)[c(117:127, 167:177, 500:550)] &lt;- NA
plot(r)

# Patch hole with interpolateRaster
interpolatedRaster &lt;- interpolateRaster(r)
plot(interpolatedRaster)
fastInterp &lt;- interpolateRaster(r, fast = TRUE, aRange = 3.0)
plot(fastInterp)


</code></pre>

<hr>
<h2 id='marineBackground'>Marine background shapefile generation</h2><span id='topic+marineBackground'></span>

<h3>Description</h3>

<p>Automatically generates background
shapefiles for sampling pseudoabsences and/or background
points for niche modeling or species distribution modeling.
Delineating background sampling regions can be one of the
trickiest parts of generating a good model. Automatically
generated background shapefiles should be inspected
carefully prior to model use.
</p>
<p>Useful references, among others:
</p>

<ul>
<li><p> Barve N, Barve V, Jiménez-Valverde A, Lira-Noriega A,
Maher SP, Peterson AT, Soberón J, Villalobos F. 2011. The
crucial role of the accessible area in ecological niche
modeling and species distribution modeling.
<em>Ecological modelling</em> 222:1810-9.
</p>
</li>
<li><p> Merow, C, Smith MJ, Silander JA. 2013. A practical
guide to MaxEnt for modeling species’ distributions: what
it does, and why inputs and settings matter.&quot; <em>Ecography</em>
36: 1058-69.
</p>
</li>
<li><p> Murphy SJ. 2021. Sampling units derived from geopolitical
boundaries bias biodiversity analyses. <em>Global Ecology
and Biogeography</em> 30: 1876-88.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>marineBackground(occs, clipToOcean = TRUE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marineBackground_+3A_occs">occs</code></td>
<td>
<p>A <code>data.frame</code> with at least two columns
named &quot;longitude&quot; and &quot;latitude&quot; or that
can be coerced into this format.</p>
</td></tr>
<tr><td><code id="marineBackground_+3A_cliptoocean">clipToOcean</code></td>
<td>
<p><code>logical</code>. Clips shapefile to oceans where species
occurs. Useful in cases where buffers jump over narrow
peninsulas (e.g. Isthmus of Panama). Can be quite artificial at ocean
boundaries.</p>
</td></tr>
<tr><td><code id="marineBackground_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Switching to <code>FALSE</code> mutes message describing
which columns in <code>occs</code> are interpreted as x and y coordinates.</p>
</td></tr>
<tr><td><code id="marineBackground_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to pass to
<code>getDynamicAlphaHull</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The meat of this function is a special-case wrapper
around <code>getDynamicAlphaHull()</code> from the <code>rangeBuilder</code> package.
The function documented here is especially useful in cases where
one wants to automatically generate training regions that overlap
the international date line. Regions that exceed the line are cut
and pasted into the appropriate hemisphere instead of being
deleted.
</p>
<p>If the argument <code>buff</code> is not supplied, a buffer is
calculated by taking the mean between the 10th and 90th percentile
of horizontal distances between occurrence points.
</p>
<p>If <code>getDynamicAlphaHull()</code> cannot satisfy the provided conditions,
the occurrences are buffered and then a minimum convex hull is
drawn around the buffer polygons.
</p>


<h3>Value</h3>

<p>A <code>SpatVector</code>
</p>


<h3>See Also</h3>

<p><code><a href="rangeBuilder.html#topic+getDynamicAlphaHull">getDynamicAlphaHull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
# Create sample raster
r &lt;- rast(ncol=10, nrow=10)
values(r) &lt;- 1:100

# Create test occurrences
set.seed(0)
longitude &lt;- sample(-50:50,
                    size = 20, replace = FALSE)
set.seed(0)
latitude &lt;- sample(-30:30,
                   size = 20, replace = FALSE)
occurrences &lt;- as.data.frame(cbind(longitude,latitude))

# Here's the function
result &lt;- marineBackground(occs = occurrences, buff = 100000,
                           fraction = .9, partCount = 2, clipToOcean = FALSE)


</code></pre>

<hr>
<h2 id='MESS3D'>Calculate MESS</h2><span id='topic+MESS3D'></span>

<h3>Description</h3>

<p>Calculates multivariate environmental similarity
surface based on model calibration and projection data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MESS3D(calibration, projection)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MESS3D_+3A_calibration">calibration</code></td>
<td>
<p>A <code>data.frame</code> of environmental variables
used to calibrate an ecological niche model, one row for
measurements from each voxel included in the data used to
calibrate the model. Columns with names not corresponding to
<code>projection</code> <code>list</code> items are ignored.</p>
</td></tr>
<tr><td><code id="MESS3D_+3A_projection">projection</code></td>
<td>
<p>A named <code>list</code> of <code>SpatRaster</code> objects for
projection; names correspond to <code>calibration</code> column names.
Each <code>SpatRaster</code> should have the same number of layers,
corresponding to vertical depth slices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MESS3D</code> is a wrapper around <code>MESS</code> from the <code>modEvA</code>
package. It calculates MESS for each depth layer. Negative values
indicate areas of extrapolation which should be interpreted with
caution (see Elith <em>et al</em>, 2010 in <em>MEE</em>).
</p>


<h3>Value</h3>

<p>A <code>SpatRaster</code> vector with MESS scores for each
voxel; layer names correspond to layer names of first
<code>SpatRaster</code> vector in <code>projection</code> <code>list</code>.
</p>


<h3>Note</h3>

<p>The calibration dataset should include both presences
and background/pseudoabsence points used to calibrate an
ecological niche model.
</p>


<h3>References</h3>

<p>Elith J, Kearney M, and Phillips S. 2010.
The art of modelling range-shifting species.
<em>Methods in Ecology and Evolution</em>, 1, 330-342.
</p>


<h3>See Also</h3>

<p><code><a href="modEvA.html#topic+MESS">MESS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(dplyr)

# Create sample rasterBricks
r1 &lt;- rast(ncol=10, nrow=10)
values(r1) &lt;- 1:100
r2 &lt;- rast(ncol=10, nrow=10)
values(r2) &lt;- c(rep(20, times = 50), rep(60, times = 50))
r3 &lt;- rast(ncol=10, nrow=10)
values(r3) &lt;- 8
envBrick1 &lt;- c(r1, r2, r3)
names(envBrick1) &lt;- c(0, 10, 30)

r1 &lt;- rast(ncol=10, nrow=10)
values(r1) &lt;- 100:1
r2 &lt;- rast(ncol=10, nrow=10)
values(r2) &lt;- c(rep(10, times = 50), rep(20, times = 50))
r3 &lt;- rast(ncol=10, nrow=10)
values(r3) &lt;- c(rep(c(10,20,30,25), times = 25))
envBrick2 &lt;- c(r1, r2, r3)
names(envBrick2) &lt;- c(0, 10, 30)

rastList &lt;- list("temperature" = envBrick1, "salinity" = envBrick2)

# Create test reference set
set.seed(0)
longitude &lt;- sample(ext(envBrick1)[1]:ext(envBrick1)[2],
                    size = 10, replace = FALSE)
set.seed(0)
latitude &lt;- sample(ext(envBrick1)[3]:ext(envBrick1)[4],
                   size = 10, replace = FALSE)
set.seed(0)
depth &lt;- sample(0:35, size = 10, replace = TRUE)
occurrences &lt;- as.data.frame(cbind(longitude,latitude,depth))

# Calibration
calibration &lt;- lapply(rastList, FUN = function(x) xyzSample(occurrences, x)) %&gt;% bind_rows

# Run the function
messStack &lt;- MESS3D(calibration = calibration, projection = rastList)
plot(messStack)

</code></pre>

<hr>
<h2 id='mSampling2D'>2D background sampling</h2><span id='topic+mSampling2D'></span>

<h3>Description</h3>

<p>Samples in 2D at resolution of raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mSampling2D(occs, rasterTemplate, mShp, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mSampling2D_+3A_occs">occs</code></td>
<td>
<p>A dataframe with at least two columns
named &quot;longitude&quot; and &quot;latitude&quot;, or that can be
coerced into this format.</p>
</td></tr>
<tr><td><code id="mSampling2D_+3A_rastertemplate">rasterTemplate</code></td>
<td>
<p>A <code>SpatRaster</code> object to serve
as a template for generating background sampling
coordinates.</p>
</td></tr>
<tr><td><code id="mSampling2D_+3A_mshp">mShp</code></td>
<td>
<p>A shapefile defining the area from
which background points should be sampled.</p>
</td></tr>
<tr><td><code id="mSampling2D_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Switching to <code>FALSE</code> mutes message describing
which columns in <code>occs</code> are interpreted as x and y coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to sample background points
for distributional modeling in two dimensions. The returned
<code>data.frame</code> contains all points from across the designated
background. It is up to the user to determine how to
appropriately sample from those background points.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with 2D coordinates of points
for background sampling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

# Create sample raster
r &lt;- rast(ncol=10, nrow=10)
values(r) &lt;- 1:100

# Create test occurrences
set.seed(0)
longitude &lt;- sample(ext(r)[1]:ext(r)[2],
                    size = 10, replace = FALSE)
set.seed(0)
latitude &lt;- sample(ext(r)[3]:ext(r)[4],
                   size = 10, replace = FALSE)
occurrences &lt;- data.frame(longitude,latitude)

# Generate background sampling buffer
buffPts &lt;- vect(occurrences,
                c("longitude", "latitude"))
crs(buffPts) &lt;- crs(r)
mShp &lt;- aggregate(buffer(buffPts, width = 1000000))

# Here's the function
result &lt;- mSampling2D(occs = occurrences, rasterTemplate = r, mShp = mShp)

</code></pre>

<hr>
<h2 id='mSampling3D'>3D background sampling</h2><span id='topic+mSampling3D'></span>

<h3>Description</h3>

<p>Samples XYZ coordinates from a shapefile
from maximum to minimum occurrence depth at XYZ
resolution of envBrick.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mSampling3D(occs, envBrick, mShp, depthLimit = "all", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mSampling3D_+3A_occs">occs</code></td>
<td>
<p>A <code>data.frame</code> with at least three columns
named &quot;longitude&quot;, &quot;latitude&quot;, and &quot;depth&quot;, or that
can be coerced into this format.</p>
</td></tr>
<tr><td><code id="mSampling3D_+3A_envbrick">envBrick</code></td>
<td>
<p>A <code>SpatRaster</code> vector object to serve
as a template for generating background sampling
coordinates.</p>
</td></tr>
<tr><td><code id="mSampling3D_+3A_mshp">mShp</code></td>
<td>
<p>A shapefile defining the area from
which background points should be sampled.</p>
</td></tr>
<tr><td><code id="mSampling3D_+3A_depthlimit">depthLimit</code></td>
<td>
<p>An argument controlling the depth
extent of sampling. Refer to <code>Details</code> for more information.</p>
</td></tr>
<tr><td><code id="mSampling3D_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Switching to <code>FALSE</code> mutes message describing
which columns in <code>occs</code> are interpreted as x, y, and z coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to sample background points for
distributional modeling in three dimensions. If a voxel (3D pixel)
in the <code>SpatRaster</code> vector intersects with an occurrence from
<code>occs</code>, it is removed. Note that this function returns points
representing every voxel in the background area within the
specified depth range. It is up to the user to downsample from
these data as necessary, depending on the model type being used.
</p>
<p><code>depthLimit</code> argument options:
</p>

<ul>
<li> <p><code>occs</code> Samples background from the full depth extent of <code>occs</code>.
</p>
</li>
<li> <p><code>all</code> Samples background from the full depth extent of <code>envBrick</code>.
</p>
</li>
<li><p> A <code>vector</code> of length 2 with maximum and minimum depth values from
which to sample.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> with 3D coordinates of points for background
sampling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

# Create test raster
r1 &lt;- rast(ncol=10, nrow=10)
values(r1) &lt;- 1:100
r2 &lt;- rast(ncol=10, nrow=10)
values(r2) &lt;- c(rep(20, times = 50), rep(60, times = 50))
r3 &lt;- rast(ncol=10, nrow=10)
values(r3) &lt;- 8
envBrick &lt;- c(r1, r2, r3)
names(envBrick) &lt;- c(0, 10, 30)

# Create test occurrences
set.seed(0)
longitude &lt;- sample(ext(envBrick)[1]:ext(envBrick)[2],
                    size = 10, replace = FALSE)
set.seed(0)
latitude &lt;- sample(ext(envBrick)[3]:ext(envBrick)[4],
                   size = 10, replace = FALSE)
set.seed(0)
depth &lt;- sample(0:35, size = 10, replace = TRUE)
occurrences &lt;- data.frame(longitude,latitude,depth)

# Generate background sampling buffer
buffPts &lt;- vect(occurrences,
                c("longitude", "latitude"))
crs(buffPts) &lt;- crs(envBrick)
mShp &lt;- aggregate(buffer(buffPts, width = 1000000))

# Here's the function
occSample3d &lt;- mSampling3D(occs = occurrences,
                           envBrick = envBrick,
                           mShp = mShp,
                           depthLimit = "occs")

</code></pre>

<hr>
<h2 id='oneRasterPlot'>Single raster plot</h2><span id='topic+oneRasterPlot'></span>

<h3>Description</h3>

<p>A convenient wrapper around <code>ggplot</code>
to generate a formatted plot of a single raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneRasterPlot(
  rast,
  land = NA,
  landCol = "black",
  scaleRange = NA,
  graticule = TRUE,
  title = "A Raster",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneRasterPlot_+3A_rast">rast</code></td>
<td>
<p>A single <code>SpatRaster</code> layer on a continuous
scale.</p>
</td></tr>
<tr><td><code id="oneRasterPlot_+3A_land">land</code></td>
<td>
<p>An optional coastline polygon shapefile
of types <code>sf</code> or <code>SpatRaster</code> to provide geographic
context for the occurrence points.</p>
</td></tr>
<tr><td><code id="oneRasterPlot_+3A_landcol">landCol</code></td>
<td>
<p>Color for land on map.</p>
</td></tr>
<tr><td><code id="oneRasterPlot_+3A_scalerange">scaleRange</code></td>
<td>
<p>Optional numeric vector containing
maximum and minimum values for color scale. Helpful
when making multiple plots for comparison. Defaults
to minimum and maximum of input <code>rast</code>.</p>
</td></tr>
<tr><td><code id="oneRasterPlot_+3A_graticule">graticule</code></td>
<td>
<p><code>logical</code>. Do you want a grid of lon/lat lines?</p>
</td></tr>
<tr><td><code id="oneRasterPlot_+3A_title">title</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="oneRasterPlot_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Switching to <code>FALSE</code> mutes message alerting
user if input <code>rast</code> values exceed a specified <code>scaleRange</code>.</p>
</td></tr>
<tr><td><code id="oneRasterPlot_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to pass to
<code>plot</code> initial plot object or <code>viridis</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of mapping the values of the input raster layer
</p>


<h3>See Also</h3>

<p><code><a href="viridisLite.html#topic+viridis">viridis</a></code> <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
rast &lt;- rast(ncol=10, nrow=10)
values(rast) &lt;- seq(0,99, 1)

oneRasterPlot(rast = rast)

</code></pre>

<hr>
<h2 id='plotLayers'>Plotting 3D model in 2D</h2><span id='topic+plotLayers'></span>

<h3>Description</h3>

<p>This script plots a semitransparent layer
of suitable habitat for each depth layer. The redder
the color, the shallower the layer, the bluer, the
deeper. The more saturated the color, the more layers
with suitable habitat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLayers(
  rast,
  land = NA,
  landCol = "black",
  title = NULL,
  graticule = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLayers_+3A_rast">rast</code></td>
<td>
<p>A <code>SpatRaster</code> vector with the 3D presence/absence
distribution of a species (interpreted as 1 = presence,
0 = absence).</p>
</td></tr>
<tr><td><code id="plotLayers_+3A_land">land</code></td>
<td>
<p>An optional coastline polygon shapefile
of types <code>sf</code> or <code>SpatRaster</code> to provide geographic
context for the occurrence points.</p>
</td></tr>
<tr><td><code id="plotLayers_+3A_landcol">landCol</code></td>
<td>
<p>Color for land on map.</p>
</td></tr>
<tr><td><code id="plotLayers_+3A_title">title</code></td>
<td>
<p>A title for the plot. If not title is
supplied, the title &quot;Suitability from (MINIMUM
DEPTH) to (MAXIMUM DEPTH)&quot; is inferred from
names of <code>rast</code>.</p>
</td></tr>
<tr><td><code id="plotLayers_+3A_graticule">graticule</code></td>
<td>
<p>Do you want a grid of lon/lat lines?</p>
</td></tr>
<tr><td><code id="plotLayers_+3A_...">...</code></td>
<td>
<p>Additional optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of class <code>recordedplot</code>
</p>


<h3>Note</h3>

<p>Only include the depth layers that you actually
want to plot.
</p>


<h3>See Also</h3>

<p><code><a href="viridisLite.html#topic+viridis">viridis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

rast1 &lt;- rast(ncol=10, nrow=10)
values(rast1) &lt;- rep(0:1, 50)

rast2 &lt;- rast(ncol=10, nrow=10)
values(rast2) &lt;- c(rep(0, 50), rep(1,50))

rast3 &lt;- rast(ncol=10, nrow=10)
values(rast3) &lt;- rep(c(1,0,0,1), 25)

distBrick &lt;- c(rast1, rast2, rast3)

plotLayers(distBrick)

</code></pre>

<hr>
<h2 id='pointCompMap'>Comparative point mapping</h2><span id='topic+pointCompMap'></span>

<h3>Description</h3>

<p>A convenient wrapper around <code>ggplot</code>
to generate formatted plots comparing two sets of
occurrence point plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointCompMap(
  occs1,
  occs2,
  spName,
  land = NA,
  occs1Col = "#bd0026",
  occs2Col = "#fd8d3c",
  agreeCol = "black",
  occs1Name = "Set 1",
  occs2Name = "Set 2",
  landCol = "gray",
  waterCol = "steelblue",
  ptSize = 1,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointCompMap_+3A_occs1">occs1</code></td>
<td>
<p>A <code>data.frame</code> with at least two columns
named &quot;longitude&quot; and &quot;latitude&quot; or that
can be coerced into this format.</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_occs2">occs2</code></td>
<td>
<p>A <code>data.frame</code> with at least two columns
named &quot;longitude&quot; and &quot;latitude&quot; or that
can be coerced into this format.</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_spname">spName</code></td>
<td>
<p>A character string with the species
name to be used in the plot title.</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_land">land</code></td>
<td>
<p>An optional coastline polygon shapefile
of types <code>sf</code> or <code>SpatRaster</code> to provide geographic
context for the occurrence points.</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_occs1col">occs1Col</code></td>
<td>
<p>Color for occurrence points on map</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_occs2col">occs2Col</code></td>
<td>
<p>Color for occurrence points on map</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_agreecol">agreeCol</code></td>
<td>
<p>Color for occurrence points shared
between <code>occs1</code> and <code>occs2</code>.</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_occs1name">occs1Name</code></td>
<td>
<p>An optional name for the first set
of occurrences, which will be color-coded to
<code>occs1Col</code> in the resulting plot.</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_occs2name">occs2Name</code></td>
<td>
<p>An optional name for the first set
of occurrences, which will be color-coded to
<code>occs2Col</code> in the resulting plot.</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_landcol">landCol</code></td>
<td>
<p>Color for land on map</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_watercol">waterCol</code></td>
<td>
<p>Color for water on map</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_ptsize">ptSize</code></td>
<td>
<p><code>numeric</code> value for <code>cex</code>;
size of occurrence points on map.</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Switching to <code>FALSE</code> mutes message describing
which columns in <code>occs1</code> and <code>occs2</code> are interpreted as x and y coordinates.</p>
</td></tr>
<tr><td><code id="pointCompMap_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to pass to
<code>ggplot</code> initial plot object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> plot object.
</p>


<h3>Note</h3>

<p>The x and y column names of <code>occs1</code> and <code>occs2</code>
must match.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
occs &lt;- data.frame(cbind(decimalLatitude = sample(seq(7,35), 24),
                         decimalLongitude = sample(seq(-97, -70), 24)))

set.seed(0)
occs1 &lt;- occs[sample(1:nrow(occs),
                     size = 12, replace = FALSE),]
set.seed(10)
occs2 &lt;- occs[sample(1:nrow(occs),
                     size = 12, replace = FALSE),]

pointCompMap(occs1 = occs1, occs2 = occs2,
             occs1Col = "red", occs2Col = "orange",
             agreeCol = "purple",
             occs1Name = "2D",
             occs2Name = "3D",
             waterCol = "steelblue",
             spName = "Steindachneria argentea",
             ptSize = 2,
             verbose = FALSE)

</code></pre>

<hr>
<h2 id='pointMap'>Point mapping</h2><span id='topic+pointMap'></span>

<h3>Description</h3>

<p>A convenient wrapper around ggplot
to generate formatted occurrence point plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointMap(
  occs,
  spName,
  land = NA,
  ptCol = "#bd0026",
  landCol = "gray",
  waterCol = "steelblue",
  ptSize = 1,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointMap_+3A_occs">occs</code></td>
<td>
<p>A <code>data.frame</code> with at least two columns
named &quot;longitude&quot; and &quot;latitude&quot; or that
can be coerced into this format.</p>
</td></tr>
<tr><td><code id="pointMap_+3A_spname">spName</code></td>
<td>
<p>A character string with the species
name to be used in the plot title.</p>
</td></tr>
<tr><td><code id="pointMap_+3A_land">land</code></td>
<td>
<p>An optional coastline polygon shapefile
of types <code>sf</code> or <code>SpatRaster</code> to provide geographic
context for the occurrence points.</p>
</td></tr>
<tr><td><code id="pointMap_+3A_ptcol">ptCol</code></td>
<td>
<p>Color for occurrence points on map</p>
</td></tr>
<tr><td><code id="pointMap_+3A_landcol">landCol</code></td>
<td>
<p>Color for land on map</p>
</td></tr>
<tr><td><code id="pointMap_+3A_watercol">waterCol</code></td>
<td>
<p>Color for water on map</p>
</td></tr>
<tr><td><code id="pointMap_+3A_ptsize">ptSize</code></td>
<td>
<p><code>numeric</code> value for <code>cex</code>;
size of occurrence points on map.</p>
</td></tr>
<tr><td><code id="pointMap_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Switching to <code>FALSE</code> mutes message describing
which columns in <code>occs</code> are interpreted as x and y coordinates.</p>
</td></tr>
<tr><td><code id="pointMap_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to pass to
<code>ggplot</code> initial plot object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> plot object.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>occs &lt;- read.csv(system.file("extdata/Steindachneria_argentea.csv",
                             package='voluModel'))
spName &lt;- "Steindachneria argentea"
pointMap(occs = occs, spName = spName,
         land = rnaturalearth::ne_countries(scale = "small",
                                            returnclass = "sf")[1])

</code></pre>

<hr>
<h2 id='rasterComp'>Comparative raster mapping</h2><span id='topic+rasterComp'></span>

<h3>Description</h3>

<p>A convenient wrapper around <code>terra::plot</code>
to generate formatted plots comparing two rasters.
This is used in the context of voluModel to
overlay semi-transparent distributions (coded as 1)
in two different <code>RasterLayers</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterComp(
  rast1 = NULL,
  rast2 = NULL,
  col1 = "#1b9e777F",
  col2 = "#7570b37F",
  rast1Name = "Set 1",
  rast2Name = "Set 2",
  land = NA,
  landCol = "black",
  title = "A Raster Comparison",
  graticule = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterComp_+3A_rast1">rast1</code></td>
<td>
<p>A single <code>SpatRaster</code> showing the
distribution of the species corresponding to
<code>rast1Name</code>. Should have values of 0 (absence)
and 1 (presence). Can also be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rasterComp_+3A_rast2">rast2</code></td>
<td>
<p>A single <code>SpatRaster</code> showing the
distribution of the species corresponding to
<code>rast2Name</code>. Should have values of 0 (absence)
and 1 (presence). Must match the extent and
resolution of <code>rast1</code>. Can also be <code>NULL.</code></p>
</td></tr>
<tr><td><code id="rasterComp_+3A_col1">col1</code></td>
<td>
<p>Color for <code>rast1</code> presences</p>
</td></tr>
<tr><td><code id="rasterComp_+3A_col2">col2</code></td>
<td>
<p>Color for <code>rast2</code> presences</p>
</td></tr>
<tr><td><code id="rasterComp_+3A_rast1name">rast1Name</code></td>
<td>
<p>An optional name for the first set
of occurrences, which will be color-coded to
<code>occs1Col</code> in the resulting plot.</p>
</td></tr>
<tr><td><code id="rasterComp_+3A_rast2name">rast2Name</code></td>
<td>
<p>An optional name for the first set
of occurrences, which will be color-coded to
<code>occs2Col</code> in the resulting plot.</p>
</td></tr>
<tr><td><code id="rasterComp_+3A_land">land</code></td>
<td>
<p>An optional coastline polygon shapefile
of types <code>sf</code> or <code>SpatRaster</code> to provide geographic
context for the occurrence points.</p>
</td></tr>
<tr><td><code id="rasterComp_+3A_landcol">landCol</code></td>
<td>
<p>Color for land on map.</p>
</td></tr>
<tr><td><code id="rasterComp_+3A_title">title</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="rasterComp_+3A_graticule">graticule</code></td>
<td>
<p>Do you want a grid of lon/lat lines?</p>
</td></tr>
<tr><td><code id="rasterComp_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to pass to
<code>terra::plot()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of class <code>recordedplot</code> overlaying mapped,
semitransparent extents of the input rasters
</p>


<h3>Note</h3>

<p>The extents of <code>rast1</code> and <code>rast2</code>
must match.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
rast1 &lt;- rast(ncol=10, nrow=10)
values(rast1) &lt;- rep(0:1, 50)

rast2 &lt;- rast(ncol=10, nrow=10)
values(rast2) &lt;- c(rep(0, 50), rep(1,50))

rasterComp(rast1 = rast1, rast2 = rast2)

</code></pre>

<hr>
<h2 id='smoothRaster'>Smooth rasters</h2><span id='topic+smoothRaster'></span>

<h3>Description</h3>

<p>Uses thin plate spline regression from
<code>fields</code> package to smooth raster values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothRaster(inputRaster, fast = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothRaster_+3A_inputraster">inputRaster</code></td>
<td>
<p>An object of class <code>SpatRaster</code></p>
</td></tr>
<tr><td><code id="smoothRaster_+3A_fast">fast</code></td>
<td>
<p>A logical operator. Setting to <code>TRUE</code> triggers use
of <code>fastTps</code> instead of <code>Tps</code>.</p>
</td></tr>
<tr><td><code id="smoothRaster_+3A_...">...</code></td>
<td>
<p>For any additional arguments passed to <code>Tps</code> or <code>fastTps</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Original raster is smoothed using a thin
plate spline. This may be desirable in cases where
the user has a reasonable expectation of spatial autocorrelation,
but observes putative measurement errors in a raster. The user has
the option of choosing <code>fastTps</code> to speed calculation,
but be advised that this is only an approximation
of a true thin plate spline.
</p>


<h3>Value</h3>

<p>An object of class <code>SpatRaster</code>
</p>


<h3>See Also</h3>

<p><code><a href="fields.html#topic+Tps">Tps</a></code>, <code><a href="fields.html#topic+fastTps">fastTps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(fields)
# Create sample raster
r &lt;- rast(ncol=100, nrow=100)
values(r) &lt;- 1:10000

# Introduce a "bubble"
values(r)[720:725] &lt;- 9999
plot(r)

# Smooth bubble with smoothRaster
fastSmooth &lt;- smoothRaster(r, fast = TRUE, aRange = 10.0)
plot(fastSmooth)

</code></pre>

<hr>
<h2 id='testIntersection'>Test Intersection</h2><span id='topic+testIntersection'></span>

<h3>Description</h3>

<p>Tests whether two rasters overlap. Used in
<code style="white-space: pre;">&#8288;\code{\link[voluModel:diversityStack]{diversityStack}}&#8288;</code>
function to verify all rasters in list overlap with the
template raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testIntersection(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testIntersection_+3A_a">a</code></td>
<td>
<p>The first <code>SpatRaster</code> object</p>
</td></tr>
<tr><td><code id="testIntersection_+3A_b">b</code></td>
<td>
<p>The second <code>SpatRaster</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector stating whether the two
inputs overlap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
rast1 &lt;- rast(ncol=10, nrow=10)
values(rast1) &lt;- rep(0:1, 50)

rast2 &lt;- rast(ncol=10, nrow=10)
values(rast2) &lt;- c(rep(0, 50), rep(1,50))

testIntersection(rast1, rast2)

rast1 &lt;- crop(rast1, ext(10, 20, 30, 40))
rast2 &lt;- crop(rast2, ext(-20, -10, -40, -30))

testIntersection(rast1, rast2)

</code></pre>

<hr>
<h2 id='transpColor'>Transparent Color</h2><span id='topic+transpColor'></span>

<h3>Description</h3>

<p>Generates transparent colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transpColor(color, percent = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpColor_+3A_color">color</code></td>
<td>
<p>Anything that can be interpreted by <code>rgb</code>
as a color.</p>
</td></tr>
<tr><td><code id="transpColor_+3A_percent">percent</code></td>
<td>
<p>A whole number between 0 and 100 specifying
how transparent the color should be.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> string with hex color, including
adjustment for transparency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
transpColor(color = "red", percent = 50)

</code></pre>

<hr>
<h2 id='xyzSample'>Sampling from a <code>SpatRaster</code> vector using 3D coordinates</h2><span id='topic+xyzSample'></span>

<h3>Description</h3>

<p>Gets values at x,y,z occurrences from a
given 3D environmental variable brick
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyzSample(occs, envBrick, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyzSample_+3A_occs">occs</code></td>
<td>
<p>A <code>data.frame</code> with at least three columns
named &quot;longitude&quot;, &quot;latitude&quot;, and &quot;depth&quot;, or that
can be coerced into this format.</p>
</td></tr>
<tr><td><code id="xyzSample_+3A_envbrick">envBrick</code></td>
<td>
<p>A <code>SpatRaster</code> vector object with
one environmental variable. Each layer represents
a depth slice. See Details for more information.</p>
</td></tr>
<tr><td><code id="xyzSample_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Switching to <code>FALSE</code> mutes message
describing which columns in <code>occs1</code> and <code>occs2</code> are interpreted
as x, y, and z coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>SpatRaster</code> vector object should
have numeric names that correspond with the beginning
depth of a particular depth slice. For example, one
might have three layers, one from 0 to 10m, one from
10 to 30m, and one from 30 to 100m. You would name the
layers in this brick <code style="white-space: pre;">&#8288;names(envBrick) &lt;- c(0, 10, 30&#8288;</code>.
<code>xyzSample</code> identifies the layer name that is closest
to the depth layer value at a particular X, Y
coordinate, and samples the environmental value at that
3D coordinate.
</p>


<h3>Value</h3>

<p>Vector of environmental values equal in length
to number of rows of input <code>occs</code> <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

# Create test raster
r1 &lt;- rast(ncol=10, nrow=10)
values(r1) &lt;- 1:100
r2 &lt;- rast(ncol=10, nrow=10)
values(r2) &lt;- c(rep(20, times = 50), rep(60, times = 50))
r3 &lt;- rast(ncol=10, nrow=10)
values(r3) &lt;- 8
envBrick &lt;- c(r1, r2, r3)
names(envBrick) &lt;- c(0, 10, 30)

# Create test occurrences
set.seed(0)
longitude &lt;- sample(ext(envBrick)[1]:ext(envBrick)[2],
                    size = 10, replace = FALSE)
set.seed(0)
latitude &lt;- sample(ext(envBrick)[3]:ext(envBrick)[4],
                   size = 10, replace = FALSE)
set.seed(0)
depth &lt;- sample(0:35, size = 10, replace = TRUE)
occurrences &lt;- as.data.frame(cbind(longitude,latitude,depth))

# Test function
occSample3d &lt;- xyzSample(occurrences, envBrick)

# How to use
occurrences$envtValue &lt;- occSample3d

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
