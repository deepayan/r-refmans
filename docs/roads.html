<!DOCTYPE html><html lang="en"><head><title>Help for package roads</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {roads}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#roads-package'><p>roads: Road Network Projection</p></a></li>
<li><a href='#CLUSexample'><p>Data from the CLUS example</p></a></li>
<li><a href='#dem_example'><p>Grade penalty example data</p></a></li>
<li><a href='#demoScen'><p>Demonstration set of 10 input scenarios</p></a></li>
<li><a href='#getDistFromSource'><p>Moving window approach to get distance from source</p></a></li>
<li><a href='#getLandingsFromTarget'><p>Get landing target points within harvest blocks</p></a></li>
<li><a href='#gradePenaltyFn'><p>Grade penalty edge weight function</p></a></li>
<li><a href='#plotRoads'><p>Plot projected roads</p></a></li>
<li><a href='#prepExData'><p>Prepare example data</p></a></li>
<li><a href='#projectRoads'><p>Project road network</p></a></li>
<li><a href='#rasterizeLine'><p>Faster rasterize for lines</p></a></li>
<li><a href='#rasterToLineSegments'><p>Convert raster to lines</p></a></li>
<li><a href='#simpleCostFn'><p>Simple cost edge weight function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Road Network Projection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-26</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/LandSciTech/roads">https://github.com/LandSciTech/roads</a>,
<a href="https://landscitech.github.io/roads/">https://landscitech.github.io/roads/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Iterative least cost path and minimum spanning tree methods for projecting 
    forest road networks. The methods connect a set of target points to an existing 
    road network using 'igraph' <a href="https://igraph.org">https://igraph.org</a> to identify least cost routes.
    The cost of constructing a road segment between adjacent pixels is determined
    by a user supplied weight raster and a weight function; options include the
    average of adjacent weight raster values, and a function of the elevation 
    differences between adjacent cells that penalizes steep grades. These road
    network projection methods are intended for integration into R workflows and 
    modelling frameworks used for forecasting forest change, and can be applied 
    over multiple time-steps without rebuilding a graph at each time-step.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, igraph (&ge; 2.0.3), data.table, sf, units, rlang,
methods, tidyselect, terra</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, viridis, tmap, bench,
gdistance</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'CLUSexample.R' 'buildSimList.R' 'buildSnapRoads.R'
'demoScen.R' 'getClosestRoad.R' 'getDistFromSource.R'
'getGraph.R' 'weightFunctions.R' 'getLandingsFromTarget.R'
'lcpList.R' 'mstList.R' 'pathsToLines.R' 'projectRoads.R'
'rasterToLineSegments.R' 'shortestPaths.R' 'plotRoads.R'
'rasterizeLine.R' 'prepExData.R' 'roads-package.R'
'dem_example.R'</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LandSciTech/roads/issues">https://github.com/LandSciTech/roads/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-27 14:29:56 UTC; EndicottS</td>
</tr>
<tr>
<td>Author:</td>
<td>Sarah Endicott <a href="https://orcid.org/0000-0001-9644-5343"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kyle Lochhead [aut],
  Josie Hughes [aut],
  Patrick Kirby [aut],
  Her Majesty the Queen in Right of Canada as represented by the Minister
    of the Environment [cph] (Copyright holder for included functions
    buildSimList, getLandingsFromTarget, pathsToLines, plotRoads,
    projectRoads, rasterizeLine, rasterToLineSegments),
  Province of British Columbia [cph] (Copyright holder for included
    functions getGraph, lcpList, mstList, shortestPaths,
    getClosestRoad, buildSnapRoads)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sarah Endicott &lt;sarah.endicott@ec.gc.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-27 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='roads-package'>roads: Road Network Projection</h2><span id='topic+roads'></span><span id='topic+roads-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Iterative least cost path and minimum spanning tree methods for projecting forest road networks. The methods connect a set of target points to an existing road network using igraph <a href="https://igraph.org">https://igraph.org</a> to identify least cost routes. The cost of constructing a road segment between adjacent pixels is determined by a user supplied 'weightRaster' and a 'weightFunction'; options include the average of adjacent 'weightRaster' values, and a function of the elevation differences between adjacent cells that penalizes steep grades. These road network projection methods are intended for integration into R workflows and modelling frameworks used for forecasting forest change, and can be applied over multiple timesteps without rebuilding a graph at each timestep.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sarah Endicott <a href="mailto:sarah.endicott@ec.gc.ca">sarah.endicott@ec.gc.ca</a> (<a href="https://orcid.org/0000-0001-9644-5343">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Kyle Lochhead <a href="mailto:Kyle.Lochhead@gov.bc.ca">Kyle.Lochhead@gov.bc.ca</a>
</p>
</li>
<li><p> Josie Hughes <a href="mailto:josie.hughes@ec.gc.ca">josie.hughes@ec.gc.ca</a>
</p>
</li>
<li><p> Patrick Kirby
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Her Majesty the Queen in Right of Canada as represented by the Minister of the Environment (Copyright holder for included functions buildSimList, getLandingsFromTarget, pathsToLines, plotRoads, projectRoads, rasterizeLine, rasterToLineSegments) [copyright holder]
</p>
</li>
<li><p> Province of British Columbia (Copyright holder for included functions getGraph, lcpList, mstList, shortestPaths, getClosestRoad, buildSnapRoads) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/LandSciTech/roads">https://github.com/LandSciTech/roads</a>
</p>
</li>
<li> <p><a href="https://landscitech.github.io/roads/">https://landscitech.github.io/roads/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/LandSciTech/roads/issues">https://github.com/LandSciTech/roads/issues</a>
</p>
</li></ul>


<hr>
<h2 id='CLUSexample'>Data from the CLUS example</h2><span id='topic+CLUSexample'></span>

<h3>Description</h3>

<p>From Kyle Lochhead and Tyler Muhly's CLUS road simulation example. <code>SpatRaster</code>
files created with the terra package must be saved with <code><a href="terra.html#topic+wrap">terra::wrap()</a></code> and
need to be unwrapped before they are used. <code><a href="#topic+prepExData">prepExData()</a></code> does this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CLUSexample)
</code></pre>


<h3>Format</h3>

<p>A named list with components:
</p>

<ul>
<li><p> cost: a <code>PackedSpatRaster</code> representing road building cost.
</p>
</li>
<li><p> landings: an sf dataframe of points representing landing locations.
</p>
</li>
<li><p> roads: a <code>PackedSpatRaster</code> representing existing roads.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample
prepExData(CLUSexample)
</code></pre>

<hr>
<h2 id='dem_example'>Grade penalty example data</h2><span id='topic+dem_example'></span>

<h3>Description</h3>

<p>A list containing two rasters covering an area near Revelstoke, British
Columbia, Canada. <code>ex_elev</code> is elevation data and <code>ex_wat</code> is the proportion
of the cell that contains water. Both are subsets of data downloaded with the
geodata package at 30 arc seconds resolution.<code>SpatRaster</code> files created with
the terra package must be saved with <code><a href="terra.html#topic+wrap">terra::wrap()</a></code> and need to be unwrapped
before they are used. <code><a href="#topic+prepExData">prepExData()</a></code> does this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dem_example)
</code></pre>


<h3>Format</h3>

<p>A named list with components:
</p>

<ul>
<li><p> ex_elev: a <code>PackedSpatRaster</code> of elevation.
</p>
</li>
<li><p> ex_wat: a <code>PackedSpatRaster</code> of proportion water.
</p>
</li></ul>



<h3>Details</h3>

<p>Elevation data are primarily from Shuttle Radar Topography Mission (SRTM),
specifically the hole-filled CGIAR-SRTM (90 m resolution) from
https://srtm.csi.cgiar.org/.
</p>
<p>Water data are derived from the ESA WorldCover data set at 0.3-seconds
resolution. (License CC BY 4.0). See https://esa-worldcover.org/en for more
information.
</p>


<h3>References</h3>

<p>Zanaga, D., Van De Kerchove, R., De Keersmaecker, W., Souverijns,
N., Brockmann, C., Quast, R., Wevers, J., Grosu, A., Paccini, A., Vergnaud,
S., Cartus, O., Santoro, M., Fritz, S., Georgieva, I., Lesiv, M., Carter,
S., Herold, M., Li, Linlin, Tsendbazar, N.E., Ramoino, F., Arino, O., 2021.
ESA WorldCover 10 m 2020 v100. doi:10.5281/zenodo.5571936.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem_example
prepExData(dem_example)
</code></pre>

<hr>
<h2 id='demoScen'>Demonstration set of 10 input scenarios</h2><span id='topic+demoScen'></span>

<h3>Description</h3>

<p>A demonstration set of scenarios that can be used as input to
<code><a href="#topic+projectRoads">projectRoads()</a></code>. The data contains <code>SpatRaster</code> objects that
must be wrapped to be stored. To unwrap them use <code><a href="#topic+prepExData">prepExData()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(demoScen)
</code></pre>


<h3>Format</h3>

<p>A list of sub-lists, with each sub-list representing an input
scenario. The scenarios (sub-lists) each contain the following components:
</p>

<ul>
<li><p> scen.number: An integer value representing the scenario number (generated scenarios are numbered incrementally from 1).
</p>
</li>
<li><p> road.rast: A logical <code>PackedSpatRaster</code> representing existing roads.  TRUE is existing road. FALSE is not existing road.
</p>
</li>
<li><p> road.line: A sf object representing existing roads.
</p>
</li>
<li><p> cost.rast: A <code>PackedSpatRaster</code> representing the cost of developing new roads on a given cell.
</p>
</li>
<li><p> landings.points: A sf object representing landings sets and landing locations within each set. The data frame includes
a field named 'set' which contains integer values representing the landings set that each point belongs to
</p>
</li>
<li><p> landings.stack: A <code>PackedSpatRaster</code> with multiple layers representing the landings and landings sets. Each logical layer represents
one landings set. Values of TRUE are a landing in the given set. Values of FALSE are not.
</p>
</li>
<li><p> landings.poly: A sf object representing a single set of polygonal landings.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>projectRoads</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demoScen[[1]]
demoScen &lt;- prepExData(demoScen)
demoScen[[1]]

</code></pre>

<hr>
<h2 id='getDistFromSource'>Moving window approach to get distance from source</h2><span id='topic+getDistFromSource'></span>

<h3>Description</h3>

<p>This function is deprecated please use <code><a href="terra.html#topic+distance">terra::distance()</a></code>. Note that you need
to set <code>target = 0</code> to get distances from cells that are zero to cells that
are non-zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistFromSource(src, maxDist, kwidth = 3, method = "terra", override = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDistFromSource_+3A_src">src</code></td>
<td>
<p><code>SpatRaster</code> or RasterLayer, where all values &gt; 0 are treated as
source locations. NA values are treated as 0s.</p>
</td></tr>
<tr><td><code id="getDistFromSource_+3A_maxdist">maxDist</code></td>
<td>
<p>Numeric, maximum distance that should be calculated in units of
the CRS.</p>
</td></tr>
<tr><td><code id="getDistFromSource_+3A_kwidth">kwidth</code></td>
<td>
<p>Integer, for the &quot;pfocal&quot; and &quot;terra&quot; methods the width of the
moving window. For the &quot;pfocal2&quot; method the aggregation factor.</p>
</td></tr>
<tr><td><code id="getDistFromSource_+3A_method">method</code></td>
<td>
<p>Character, the method to use, currently only &quot;terra&quot; supported
with the CRAN version, while &quot;pfocal&quot; or &quot;pfocal2&quot; are available with the
development version. See below for details.</p>
</td></tr>
<tr><td><code id="getDistFromSource_+3A_override">override</code></td>
<td>
<p>Logical, if TRUE will use the old deprecated function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides three different methods for calculating the distance of
all points on a landscape from &quot;source&quot; locations. This is a computationally
intensive process so the function arguments can be used to balance the
tradeoffs between speed and accuracy. Note the pfocal versions are only
available in the development version of the package.
</p>
<p>The &quot;terra&quot; and &quot;pfocal&quot; methods use an iterative moving window approach and
assign each cell a distance based on the number of times the moving window is
repeated before it is included. This means that the moving window function is
run many times but for a small window relative to the size of the raster. The
<code>maxDist</code> argument determines the maximum distance calculated and affects the
number of iterations of the moving window that are needed. <code>kwidth</code> is the
radius of the moving window in number of cells, with larger values reducing
the number of iterations needed but also reducing the granularity of the
distances produced. The resulting distances will be in increments of <code>kwidth</code>
</p>

<ul>
<li><p> the resolution of the raster. The total number of iterations is <code>maxDist</code>/
<code>kwidth</code> * resolution. The only difference in these methods is the underlying
package used to do the moving window. The <code>terra</code> package has methods for
handling large rasters by writing them to disk, while the <code>pfocal</code> package
requires that the raster can be held in memory as a matrix.
</p>
</li></ul>

<p>The third method &quot;pfocal2&quot; uses a global moving window to calculate the
distance to the source. This means that the moving window only needs to be
applied once but the window size can be very large. In this case <code>maxDist</code>
determines the total size of the window. <code>kwidth</code> can be used to reduce the
number of cells included in the moving window by aggregating the source raster
by a factor of <code>kwidth</code>. This will increase the speed of computation but will
produce results with artefacts of the larger grid and which may be less
accurate since the output raster is disaggregated using bilinear
interpolation.
</p>


<h3>Value</h3>

<p>A SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CLUSexample &lt;-  prepExData(CLUSexample)
# Deprecated
# getDistFromSource(CLUSexample$roads, 5, 2)

# Use terra::distance instead
terra::distance(CLUSexample$roads, target = 0)


 library(sf)
 library(terra)

#make example roads from scratch
rds &lt;- data.frame(x = 1:1000/100, y = cos(1:1000/100)) %&gt;%
  st_as_sf(coords = c("x", "y")) %&gt;%
  st_union() %&gt;%
  st_cast("LINESTRING")

rds_rast &lt;- rasterize(vect(rds),
                      rast(nrows = 50, ncols = 50,
                           xmin = 0, xmax = 10,
                           ymin = -5, ymax = 5),
                      touches = TRUE)

terra::distance(rds_rast)

# or straight from the line
terra::distance(rds_rast, terra::vect(rds %&gt;% st_set_crs(st_crs(rds_rast))))

</code></pre>

<hr>
<h2 id='getLandingsFromTarget'>Get landing target points within harvest blocks</h2><span id='topic+getLandingsFromTarget'></span>

<h3>Description</h3>

<p>Generate landing points inside polygons representing harvested area. There
are three different sampling types available: <code>"centroid"</code> (default) returns
the centroid or a point inside the polygon if the
centroid is not (see <code><a href="sf.html#topic+geos_unary">sf::st_point_on_surface()</a></code>); <code>"random"</code> returns a
random sample given <code>landingDens</code> see
(<code><a href="sf.html#topic+st_sample">sf::st_sample()</a></code>); <code>"regular"</code> returns points on a regular grid with cell size <code>sqrt(1/landingDens)</code>
that intersect the polygon, or centroid if no grid points fall within the polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLandingsFromTarget(harvest, landingDens = NULL, sampleType = "centroid")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLandingsFromTarget_+3A_harvest">harvest</code></td>
<td>
<p><code>sf</code>, <code>SpatialPolygons</code>, <code>SpatRaster</code> or <code>RasterLayer</code> object with harvested
areas. If it is a raster with values outside 0,1, values are assumed
to be harvest block IDs. If raster values are in 0,1 they are assumed to be
a binary raster and <a href="terra.html#topic+patches">terra::patches</a> is used to identify harvest
blocks.</p>
</td></tr>
<tr><td><code id="getLandingsFromTarget_+3A_landingdens">landingDens</code></td>
<td>
<p>number of landings per unit area. This should be in the
same units as the CRS of the harvest. Note that 0.001 points per m2 is &gt; 1000
points per km2 so this number is usually very small for projected CRS.</p>
</td></tr>
<tr><td><code id="getLandingsFromTarget_+3A_sampletype">sampleType</code></td>
<td>
<p>character. <code>"centroid"</code> (default), <code>"regular"</code> or <code>"random"</code>.
<code>"centroid"</code> returns one landing per harvest block, which is guaranteed to be
in the harvest block for sf objects but not for rasters. <code>"regular"</code> returns
points from a grid with density <code>landingDens</code> that overlap the
harvested areas. <code>"random"</code> returns a random set of points from each polygon
determined by the area of the polygon and
<code>landingDens</code>. If <code>harvest</code> is a raster set of landings always includes the centroid
to ensure at least one landing for each harvest block.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <code>landingDens</code> is points per unit area where the unit of
area is determined by the CRS. For projected CRS this should likely be a very
small number i.e. &lt; 0.001.
</p>


<h3>Value</h3>

<p>an sf simple feature collection with an <code>ID</code> column and <code>POINT</code> geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>doPlots &lt;- interactive()
demoScen &lt;- prepExData(demoScen)

polys &lt;- demoScen[[1]]$landings.poly[1:2,]

# Get centroid
outCent &lt;- getLandingsFromTarget(polys)

if(doPlots){
  plot(sf::st_geometry(polys))
  plot(outCent, col = "red", add = TRUE)
}

# Get random sample with density 0.1 points per unit area
outRand &lt;- getLandingsFromTarget(polys, 0.1, sampleType = "random")

if(doPlots){
  plot(sf::st_geometry(polys))
  plot(outRand, col = "red", add = TRUE)
}

# Get regular sample with density 0.1 points per unit area
outReg &lt;- getLandingsFromTarget(polys, 0.1, sampleType = "regular")

if(doPlots){
  plot(sf::st_geometry(polys))
  plot(outReg, col = "red", add = TRUE)
}

</code></pre>

<hr>
<h2 id='gradePenaltyFn'>Grade penalty edge weight function</h2><span id='topic+gradePenaltyFn'></span>

<h3>Description</h3>

<p>Method for calculating the weight of an edge between two nodes from the value
of the input raster at each of those nodes (<code>x1</code> and <code>x2</code>), designed for a single
DEM input. The method assumes an input <code>weightRaster</code> in which:
</p>

<ul>
<li> <p><code>NA</code> indicates a road cannot be built
</p>
</li>
<li><p> Negative values are costs for crossing streams or other barriers that are
crossable but expensive. Edges that link to barrier penalty (negative value)
nodes are assigned the largest barrier penalty weight.
</p>
</li>
<li><p> Zero values are assumed to be existing roads.
</p>
</li>
<li><p> All other values are interpreted as elevation in the units of the raster
map (so that a difference between two cells equal to the map resolution can be
interpreted as 100% grade)
This is a simplified version of the grade penalty approach taken by Anderson and Nelson (2004):
The approach does not distinguish between adverse and favourable grades.
Default construction cost values are from the BC interior appraisal manual.
The approach ignores (unknown) grade penalties beside roads and barriers in order to
avoid increased memory and computational burden associated with multiple input rasters.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>gradePenaltyFn(
  x1,
  x2,
  hdistance,
  baseCost = 16178,
  limit = 20,
  penalty = 504,
  limitWeight = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gradePenaltyFn_+3A_x1">x1</code>, <code id="gradePenaltyFn_+3A_x2">x2</code></td>
<td>
<p>Number. Value of the input raster at two nodes.</p>
</td></tr>
<tr><td><code id="gradePenaltyFn_+3A_hdistance">hdistance</code></td>
<td>
<p>Number. Horizontal distance between nodes. <code>hdistance</code>, <code>x1</code>, and <code>x2</code>
should have the same units.</p>
</td></tr>
<tr><td><code id="gradePenaltyFn_+3A_basecost">baseCost</code></td>
<td>
<p>Number. Construction cost of 0% grade road per km.</p>
</td></tr>
<tr><td><code id="gradePenaltyFn_+3A_limit">limit</code></td>
<td>
<p>Number. Maximum grade (%) on which roads can be built.</p>
</td></tr>
<tr><td><code id="gradePenaltyFn_+3A_penalty">penalty</code></td>
<td>
<p>Number. Cost increase (per km) associated with each
additional % increase in road grade.</p>
</td></tr>
<tr><td><code id="gradePenaltyFn_+3A_limitweight">limitWeight</code></td>
<td>
<p>Number. Value assigned to edges that exceed the grade
limit. Try setting to a high (not <code>NA</code>) value if encountering problems with
disconnected graphs.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Anderson AE, Nelson J (2004) Projecting vector-based road networks with a
shortest path algorithm. Canadian Journal of Forest Research 34:1444–1457. https://doi.org/10.1139/x04-030
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gradePenaltyFn(0.5,0.51,1)
gradePenaltyFn(0.5,0.65,1)
# grade &gt; 20% so NA
gradePenaltyFn(0.5,0.75,1)
</code></pre>

<hr>
<h2 id='plotRoads'>Plot projected roads</h2><span id='topic+plotRoads'></span>

<h3>Description</h3>

<p>Plot the results of <code><a href="#topic+projectRoads">projectRoads()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRoads(sim, mainTitle, subTitle = paste0("Method: ", sim$roadMethod), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotRoads_+3A_sim">sim</code></td>
<td>
<p><code>sim</code> list result from <code>projectRoads</code></p>
</td></tr>
<tr><td><code id="plotRoads_+3A_maintitle">mainTitle</code></td>
<td>
<p>character. A title for the plot</p>
</td></tr>
<tr><td><code id="plotRoads_+3A_subtitle">subTitle</code></td>
<td>
<p>character. A sub title for the plot, by default the <code>roadMethod</code> is used</p>
</td></tr>
<tr><td><code id="plotRoads_+3A_...">...</code></td>
<td>
<p>Other arguments passed to raster plot call for the <code>weightRaster</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot using base graphics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample &lt;- prepExData(CLUSexample)
prRes &lt;- projectRoads(CLUSexample$landings, CLUSexample$cost, CLUSexample$roads)
if(interactive()){
  plotRoads(prRes, "Title")
}


</code></pre>

<hr>
<h2 id='prepExData'>Prepare example data</h2><span id='topic+prepExData'></span>

<h3>Description</h3>

<p>Prepare example data included in the package that contain wrapped terra
objects. This applies <code><a href="terra.html#topic+wrap">terra::unwrap()</a></code> recursively to the list provided so
that all <code>PackedSpatRasters</code> are converted to <code>SpatRasters</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepExData(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepExData_+3A_x">x</code></td>
<td>
<p>list. Contains elements some of which are packed <code>SpatRasters</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same list but with unwrapped <code>SpatRasters</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample
prepExData(CLUSexample)
</code></pre>

<hr>
<h2 id='projectRoads'>Project road network</h2><span id='topic+projectRoads'></span><span id='topic+projectRoads+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY+2Cmissing-method'></span><span id='topic+projectRoads+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY+2Clist-method'></span>

<h3>Description</h3>

<p>Project a road network that links target landings to existing roads. For all
methods except <code>"snap"</code>, a <code>weightRaster</code> and <code>weightFunction</code> together
determine the cost to build a road between two adjacent raster cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectRoads(
  landings = NULL,
  weightRaster = NULL,
  roads = NULL,
  roadMethod = "ilcp",
  plotRoads = FALSE,
  mainTitle = "",
  neighbourhood = "octagon",
  weightFunction = simpleCostFn,
  sim = NULL,
  roadsOut = NULL,
  roadsInWeight = TRUE,
  ordering = "closest",
  roadsConnected = FALSE,
  ...
)

## S4 method for signature 'ANY,ANY,ANY,ANY,ANY,ANY,ANY,ANY,missing'
projectRoads(
  landings = NULL,
  weightRaster = NULL,
  roads = NULL,
  roadMethod = "ilcp",
  plotRoads = FALSE,
  mainTitle = "",
  neighbourhood = "octagon",
  weightFunction = simpleCostFn,
  sim = NULL,
  roadsOut = NULL,
  roadsInWeight = TRUE,
  ordering = "closest",
  roadsConnected = FALSE,
  ...
)

## S4 method for signature 'ANY,ANY,ANY,ANY,ANY,ANY,ANY,ANY,list'
projectRoads(
  landings = NULL,
  weightRaster = NULL,
  roads = NULL,
  roadMethod = "ilcp",
  plotRoads = FALSE,
  mainTitle = "",
  neighbourhood = "octagon",
  weightFunction = simpleCostFn,
  sim = NULL,
  roadsOut = NULL,
  roadsInWeight = TRUE,
  ordering = "closest",
  roadsConnected = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projectRoads_+3A_landings">landings</code></td>
<td>
<p>sf polygons or points, <code>RasterLayer</code>, <code style="white-space: pre;">&#8288;SpatialPolygons*&#8288;</code>,
<code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code>, or matrix. Contains features to be connected
to the road network. Matrix should contain columns x, y with coordinates,
all other columns will be ignored. Polygon and raster inputs will be
processed by <code><a href="#topic+getLandingsFromTarget">getLandingsFromTarget()</a></code> to get the centroid of harvest blocks.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_weightraster">weightRaster</code></td>
<td>
<p><code>SpatRaster</code> or <code>RasterLayer</code>. A <code>weightRaster</code> and
<code>weightFunction</code> together determine the cost to build a road between two
adjacent raster cells. For the default <code>weightFunction = simpleCostFn</code>, the
<code>weightRaster</code> should specify the cost of construction across each raster
cell. The value of cells that contain existing roads should be set to 0; if
not set <code>roadsInWeight = FALSE</code> to adjust the cost of existing roads. To
use the alternative grade penalty method, set <code>weightFunction = gradePenaltyFn</code>,
and provide a <code>weightRaster</code> in which:
</p>

<ul>
<li><p> NA indicates a road cannot be built
</p>
</li>
<li><p> Negative values are costs for crossing streams or other barriers that are
crossable but expensive.
</p>
</li>
<li><p> Zero values are existing roads.
</p>
</li>
<li><p> All other values are interpreted as elevation in the units of the raster
map (so that a difference between two cells equal to the map resolution can be
interpreted as 100% grade).
</p>
</li></ul>
</td></tr>
<tr><td><code id="projectRoads_+3A_roads">roads</code></td>
<td>
<p>sf lines, <code style="white-space: pre;">&#8288;SpatialLines*&#8288;</code>, <code>RasterLayer</code>, <code>SpatRaster</code>. The existing road network.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_roadmethod">roadMethod</code></td>
<td>
<p>Character. Options are <code>"ilcp"</code>, <code>"mst"</code>, <code>"lcp"</code>, and <code>"snap"</code>.
See Details below.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_plotroads">plotRoads</code></td>
<td>
<p>Boolean. Should the resulting road network be plotted.
Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_maintitle">mainTitle</code></td>
<td>
<p>Character. A title for the plot.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>Character. <code>"rook"</code>, <code>"queen"</code>, or <code>"octagon"</code>.
Determines which cells are considered adjacent. The default <code>"octagon"</code>
option is a modified version of the queen's 8 cell neighbourhood in which
diagonal weights are multiplied by 2^0.5.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_weightfunction">weightFunction</code></td>
<td>
<p>function. Method for calculating the weight of an edge
between two nodes from the value of the <code>weightRaster</code> at each of those
nodes (<code>x1</code> and <code>x2</code>). The default <code>simpleCostFn</code> is the mean. The
alternative, <code>gradePenaltyFn</code>, sets edge weights as a function of the
difference between adjacent <code>weightRaster</code> cells to penalize steep grades.
Users supplying their own <code>weightFunction</code> should note that it must be
symmetric, meaning that the value returned should not depend on the
ordering of <code>x1</code> and <code>x2</code>. The <code>weightFunction</code> must include arguments
<code>x1</code>, <code>x2</code> and <code>...</code>.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_sim">sim</code></td>
<td>
<p>list. Returned from a previous iteration of <code>projectRoads</code>.
<code>weightRaster</code>, <code>roads</code>, and <code>roadMethod</code> are ignored if a <code>sim</code> list is provided.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_roadsout">roadsOut</code></td>
<td>
<p>Character. Either <code>"raster"</code>, <code>"sf"</code> or <code>NULL</code>. If <code>"raster"</code> roads
are returned as a <code>SpatRaster</code> in the <code>sim</code> list. If <code>"sf"</code> the roads are returned as
an sf object which will contain lines if the roads input was sf lines but a
geometry collection of lines and points if the roads input was a raster.
The points in the geometry collection represent the existing roads while
new roads are created as lines. If <code>NULL</code> (default) then the returned roads
are <code>sf</code> if the input is <code>sf</code> or <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> and <code>SpatRaster</code> if the input was a raster.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_roadsinweight">roadsInWeight</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default) the value of existing roads in the
<code>weightRaster</code> is assumed to be 0. If <code>FALSE</code> cells in the <code>weightRaster</code> that
contain existing roads will be set to 0.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_ordering">ordering</code></td>
<td>
<p>character. The order in which landings are processed when
<code>roadMethod = "ilcp"</code>. Options are <code>"closest"</code> (default) where landings
closest to existing roads are accessed first, or <code>"none"</code> where
landings are accessed in the order they are provided in.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_roadsconnected">roadsConnected</code></td>
<td>
<p>Logical. Are all roads fully connected? If <code>TRUE</code> and
<code>roadMethod = "mst"</code> the MST graph can be simplified and the projection
should be faster. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_...">...</code></td>
<td>
<p>Optional additional arguments to <code>weightFunction</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four road network projection methods are:
</p>

<ul>
<li> <p><code>"lcp"</code>: The Least Cost Path method connects each landing to the closest
road with a least cost path, without reference to other landings.
</p>
</li>
<li> <p><code>"ilcp"</code>: The Iterative Least Cost Path method iteratively connects each
landing to the closest road with a least cost path, so that the path to
each successive landing can include roads constructed to access previous
landings. The sequence of landings is determined by <code>ordering</code> and is
&quot;closest&quot; by default. The alternative &quot;none&quot; option processes landings in
the order supplied by the user.
</p>
</li>
<li> <p><code>"mst"</code>: The Minimum Spanning Tree method connects landings to the existing road
with a minimum spanning tree that does not require users to specify the
order in which landings are processed.
</p>
</li>
<li> <p><code>"snap"</code>: Connects each landing to the closest (by Euclidean distance) road without,
reference to the weights or other landings.
</p>
</li></ul>



<h3>Value</h3>

<p>a list with components:
</p>

<ul>
<li><p> roads: the projected road network, including new and input roads.
</p>
</li>
<li><p> weightRaster: the updated <code>weightRaster</code> in which new and old roads have value 0.
</p>
</li>
<li><p> roadMethod: the road simulation method used.
</p>
</li>
<li><p> landings: the landings used in the simulation.
</p>
</li>
<li><p> g: the graph that describes the cost of paths between each cell in the updated
<code>weightRaster</code>. Edges between vertices connected by new roads have weight 0.
<code>g</code> can be used to avoid the cost of rebuilding the graph in a simulation
with multiple time steps.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample &lt;- prepExData(CLUSexample)
doPlots &lt;- interactive()

projectRoads(CLUSexample$landings, CLUSexample$cost, CLUSexample$roads,
             "lcp", plotRoads = doPlots, mainTitle = "CLUSexample")


# More realistic examples that take longer to run


demoScen &lt;- prepExData(demoScen)

### using:  scenario 1 / sf landings / iterative least-cost path ("ilcp")
# demo scenario 1
scen &lt;- demoScen[[1]]

# landing set 1 of scenario 1:
land.pnts &lt;- scen$landings.points[scen$landings.points$set==1,]

prRes &lt;- projectRoads(land.pnts, scen$cost.rast, scen$road.line, "ilcp",
                         plotRoads = doPlots, mainTitle = "Scen 1: SPDF-LCP")

### using: scenario 1 / `SpatRaster` landings / minimum spanning tree ("mst")
# demo scenario 1
scen &lt;- demoScen[[1]]

# the RasterLayer version of landing set 1 of scenario 1:
land.rLyr &lt;- scen$landings.stack[[1]]

prRes &lt;- projectRoads(land.rLyr, scen$cost.rast, scen$road.line, "mst",
                         plotRoads = doPlots, mainTitle = "Scen 1: Raster-MST")


### using: scenario 2 / matrix landings raster roads / snapping ("snap")
# demo scenario 2
scen &lt;- demoScen[[2]]

# landing set 5 of scenario 2, as matrix:
land.mat  &lt;- scen$landings.points[scen$landings.points$set==5,] |&gt;
  sf::st_coordinates()

prRes &lt;- projectRoads(land.mat, scen$cost.rast, scen$road.rast, "snap",
                      plotRoads = doPlots, mainTitle = "Scen 2: Matrix-Snap")

## using scenario 7 / Polygon landings raster / minimum spanning tree
# demo scenario 7
scen &lt;- demoScen[[7]]
# rasterize polygonal landings of demo scenario 7:
land.polyR &lt;- terra::rasterize(scen$landings.poly, scen$cost.rast)

prRes &lt;- projectRoads(land.polyR, scen$cost.rast, scen$road.rast, "mst",
                         plotRoads = doPlots, mainTitle = "Scen 7: PolyRast-MST")


</code></pre>

<hr>
<h2 id='rasterizeLine'>Faster rasterize for lines</h2><span id='topic+rasterizeLine'></span>

<h3>Description</h3>

<p>Rasterize a line using <code>stars</code> because <code>fasterize</code> doesn't work on lines and
rasterize is slow. Deprecated use <code>terra::rasterize</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterizeLine(sfLine, rast, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rasterizeLine_+3A_sfline">sfLine</code></td>
<td>
<p>an sf object to be rasterized</p>
</td></tr>
<tr><td><code id="rasterizeLine_+3A_rast">rast</code></td>
<td>
<p>a raster to use as template for the output raster</p>
</td></tr>
<tr><td><code id="rasterizeLine_+3A_value">value</code></td>
<td>
<p>a number value to give the background ie 0 or NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a RasterLayer where the value of cells that touch the line will be
the row index of the line in the sf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample &lt;- prepExData(CLUSexample)
roadsLine &lt;- sf::st_sf(geometry = sf::st_sfc(sf::st_linestring(
matrix(c(0.5, 4.5, 4.5, 4.51),
       ncol = 2, byrow = TRUE) 
)))

# Deprecated rasterizeLine(roadsLine, CLUSexample$cost, 0)   
# Use terra::rasterize
terra::rasterize(roadsLine, CLUSexample$cost, background = 0)

</code></pre>

<hr>
<h2 id='rasterToLineSegments'>Convert raster to lines</h2><span id='topic+rasterToLineSegments'></span>

<h3>Description</h3>

<p>Converts rasters that represent lines into an sf object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToLineSegments(rast, method = "mst")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rasterToLineSegments_+3A_rast">rast</code></td>
<td>
<p><code>SpatRaster</code>. Raster representing lines all values &gt; 0 are assumed to be lines</p>
</td></tr>
<tr><td><code id="rasterToLineSegments_+3A_method">method</code></td>
<td>
<p>character. Method of building lines. Options are <code>"mst"</code> (default) or <code>"nearest"</code>.
See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>method = "nearest"</code> raster is first converted to points and then
lines are drawn between the nearest points. If there are two different ways
to connect the points that have the same distance both are kept which can
cause doubled lines. USE WITH CAUTION. <code>method = "mst"</code> converts the
raster to points, reclassifies the raster so roads are 0 and other cells are
1 and then uses <code>projectRoads</code> to connect all the points with a minimum
spanning tree. This will always connect all raster cells and is slower but
will not double lines as often. Neither method is likely to work for very
large rasters
</p>


<h3>Value</h3>

<p>an sf simple feature collection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample &lt;- prepExData(CLUSexample)
# works well for very simple roads
roadLine1 &lt;- rasterToLineSegments(CLUSexample$roads)

# longer running more realistic examples

demoScen &lt;- prepExData(demoScen)
# mst method works well in this case
roadLine2 &lt;- rasterToLineSegments(demoScen[[1]]$road.rast)

# nearest method has doubled line where the two roads meet
roadLine3 &lt;- rasterToLineSegments(demoScen[[1]]$road.rast, method = "nearest")

# The mst method can also produce odd results in some cases
roadLine4 &lt;- rasterToLineSegments(demoScen[[4]]$road.rast)



</code></pre>

<hr>
<h2 id='simpleCostFn'>Simple cost edge weight function</h2><span id='topic+simpleCostFn'></span>

<h3>Description</h3>

<p>Calculates the weight of an edge between two nodes as the mean value
of an input cost raster at each of those nodes (<code>x1</code> and <code>x2</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleCostFn(x1, x2, hdistance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpleCostFn_+3A_x1">x1</code>, <code id="simpleCostFn_+3A_x2">x2</code></td>
<td>
<p>Number. Value of the input cost raster at two nodes.</p>
</td></tr>
<tr><td><code id="simpleCostFn_+3A_hdistance">hdistance</code></td>
<td>
<p>Number. Horizontal distance between the nodes - for penalizing longer diagonal edges.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>simpleCostFn(0.5,0.7,1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
