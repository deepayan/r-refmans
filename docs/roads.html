<!DOCTYPE html><html><head><title>Help for package roads</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {roads}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#roads-package'><p>roads: Road Network Projection</p></a></li>
<li><a href='#CLUSexample'><p>Data from the CLUS example</p></a></li>
<li><a href='#demoScen'><p>Demonstration set of 10 input scenarios</p></a></li>
<li><a href='#getDistFromSource'><p>Moving window approach to get distance from source</p></a></li>
<li><a href='#getLandingsFromTarget'><p>Get landing points inside harvest blocks</p></a></li>
<li><a href='#plotRoads'><p>Plot projected roads</p></a></li>
<li><a href='#prepExData'><p>Prepare example data</p></a></li>
<li><a href='#projectRoads'><p>Project road network</p></a></li>
<li><a href='#rasterizeLine'><p>Faster rasterize for lines</p></a></li>
<li><a href='#rasterToLineSegments'><p>Convert raster to lines</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Road Network Projection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-23</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/LandSciTech/roads">https://github.com/LandSciTech/roads</a>,
<a href="https://landscitech.github.io/roads/">https://landscitech.github.io/roads/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Project road network development based on an existing road 
    network, target locations to be connected by roads and a cost surface. Road 
    projection methods include minimum spanning tree with least cost path 
    (Kruskal's algorithm (1956) &lt;<a href="https://doi.org/10.2307%2F2033241">doi:10.2307/2033241</a>&gt;), least cost path 
    (Dijkstra's algorithm (1959) &lt;<a href="https://doi.org/10.1007%2FBF01386390">doi:10.1007/BF01386390</a>&gt;) or snapping. 
    These road network projection methods are ideal for use with land cover
    change projection models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, igraph, data.table, sf, units, rlang, methods,
tidyselect, terra</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, viridis, tmap, bench</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'CLUSexample.R' 'buildSimList.R' 'buildSnapRoads.R'
'demoScen.R' 'getClosestRoad.R' 'getDistFromSource.R'
'getGraph.R' 'getLandingsFromTarget.R' 'lcpList.R' 'mstList.R'
'pathsToLines.R' 'projectRoads.R' 'rasterToLineSegments.R'
'shortestPaths.R' 'plotRoads.R' 'rasterizeLine.R'
'prepExData.R' 'roads-package.R'</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LandSciTech/roads/issues">https://github.com/LandSciTech/roads/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-23 20:35:54 UTC; EndicottS</td>
</tr>
<tr>
<td>Author:</td>
<td>Sarah Endicott <a href="https://orcid.org/0000-0001-9644-5343"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kyle Lochhead [aut],
  Josie Hughes [aut],
  Patrick Kirby [aut],
  Her Majesty the Queen in Right of Canada as represented by the Minister
    of the Environment [cph] (Copyright holder for included functions
    buildSimList, getLandingsFromTarget, pathsToLines, plotRoads,
    projectRoads, rasterizeLine, rasterToLineSegments),
  Province of British Columbia [cph] (Copyright holder for included
    functions getGraph, lcpList, mstList, shortestPaths,
    getClosestRoad, buildSnapRoads)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sarah Endicott &lt;sarah.endicott@ec.gc.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-24 04:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='roads-package'>roads: Road Network Projection</h2><span id='topic+roads'></span><span id='topic+roads-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Project road network development based on an existing road network, target locations to be connected by roads and a cost surface. Road projection methods include minimum spanning tree with least cost path (Kruskal's algorithm (1956) <a href="https://doi.org/10.2307/2033241">doi:10.2307/2033241</a>), least cost path (Dijkstra's algorithm (1959) <a href="https://doi.org/10.1007/BF01386390">doi:10.1007/BF01386390</a>) or snapping. These road network projection methods are ideal for use with land cover change projection models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sarah Endicott <a href="mailto:sarah.endicott@ec.gc.ca">sarah.endicott@ec.gc.ca</a> (<a href="https://orcid.org/0000-0001-9644-5343">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Kyle Lochhead <a href="mailto:Kyle.Lochhead@gov.bc.ca">Kyle.Lochhead@gov.bc.ca</a>
</p>
</li>
<li><p> Josie Hughes <a href="mailto:josie.hughes@ec.gc.ca">josie.hughes@ec.gc.ca</a>
</p>
</li>
<li><p> Patrick Kirby
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Her Majesty the Queen in Right of Canada as represented by the Minister of the Environment (Copyright holder for included functions buildSimList, getLandingsFromTarget, pathsToLines, plotRoads, projectRoads, rasterizeLine, rasterToLineSegments) [copyright holder]
</p>
</li>
<li><p> Province of British Columbia (Copyright holder for included functions getGraph, lcpList, mstList, shortestPaths, getClosestRoad, buildSnapRoads) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/LandSciTech/roads">https://github.com/LandSciTech/roads</a>
</p>
</li>
<li> <p><a href="https://landscitech.github.io/roads/">https://landscitech.github.io/roads/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/LandSciTech/roads/issues">https://github.com/LandSciTech/roads/issues</a>
</p>
</li></ul>


<hr>
<h2 id='CLUSexample'>Data from the CLUS example</h2><span id='topic+CLUSexample'></span>

<h3>Description</h3>

<p>From Kyle Lochhead and Tyler Muhly's CLUS road simulation example. SpatRaster
files created with the terra package must be saved with [terra::wrap()] and
need to be unwrapped before they are used. [prepExData()] is provided to do
this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CLUSexample)
</code></pre>


<h3>Format</h3>

<p>A named list where: $cost is an object of class PackedSpatRaster
representing road cost, $landings is an object of class sf representing
landing locations and $roads is an object of class PackedSpatRaster
representing existing roads
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample
prepExData(CLUSexample)
</code></pre>

<hr>
<h2 id='demoScen'>Demonstration set of 10 input scenarios</h2><span id='topic+demoScen'></span>

<h3>Description</h3>

<p>A demonstration set of scenarios that can be used as input to
<code><a href="#topic+projectRoads">projectRoads</a></code> method. The data contains &quot;SpatRaster&quot; objects that
must be wrapped to be stored. To unwrap them use [prepExData()]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(demoScen)
</code></pre>


<h3>Format</h3>

<p>A list of sub-lists, with each sub-list representing an input
scenario. The scenarios (sub-lists) each contain the following components:
</p>

<dl>
<dt>scen.number</dt><dd><p>An integer value representing the scenario number (generated scenarios are numbered incrementally from 1).</p>
</dd>
<dt>road.rast</dt><dd><p>A logical PackedSpatRaster representing existing roads.  TRUE is existing road. FALSE is not existing road.</p>
</dd>
<dt>road.line</dt><dd><p>A sf object representing existing roads.</p>
</dd>
<dt>cost.rast</dt><dd><p>A PackedSpatRaster representing the cost of developing new roads on a given cell.</p>
</dd>
<dt>landings.points</dt><dd><p>A sf object representing landings sets and landing locations within each set. The data frame includes
a field named 'set' which contains integer values representing the landings set that each point belongs to</p>
</dd>
<dt>landings.stack</dt><dd><p>A PackedSpatRaster with multiple layers representing the landings and landings sets. Each logical layer represents
one landings set. Values of TRUE are a landing in the given set. Values of FALSE are not.</p>
</dd>
<dt>landings.poly</dt><dd><p>A sf object representing a single set of polygonal landings.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+projectRoads">projectRoads</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demoScen[[1]]
demoScen &lt;- prepExData(demoScen)
demoScen[[1]]

</code></pre>

<hr>
<h2 id='getDistFromSource'>Moving window approach to get distance from source</h2><span id='topic+getDistFromSource'></span>

<h3>Description</h3>

<p>This function provides three different methods for calculating the distance
of all points on a landscape from &quot;source&quot; locations. This is a
computationally intensive process so the function arguments can be used to
balance the tradeoffs between speed and accuracy. Note the pfocal versions
are only available in the development version of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDistFromSource(src, maxDist, kwidth = 3, method = "terra")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDistFromSource_+3A_src">src</code></td>
<td>
<p>SpatRaster or RasterLayer, where all values &gt; 0 are treated as
source locations. NA values are treated as 0s.</p>
</td></tr>
<tr><td><code id="getDistFromSource_+3A_maxdist">maxDist</code></td>
<td>
<p>Numeric, maximum distance that should be calculated in units
of the CRS.</p>
</td></tr>
<tr><td><code id="getDistFromSource_+3A_kwidth">kwidth</code></td>
<td>
<p>Integer, for the &quot;pfocal&quot; and &quot;terra&quot; methods the width of the
moving window. For the &quot;pfocal2&quot; method the aggregation factor.</p>
</td></tr>
<tr><td><code id="getDistFromSource_+3A_method">method</code></td>
<td>
<p>Character, the method to use, one of &quot;terra&quot;, &quot;pfocal&quot; or
&quot;pfocal2&quot;. See below for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;terra&quot; and &quot;pfocal&quot; methods use an iterative moving window approach and
assign each cell a distance based on the number of times the moving window is
repeated before it is included. This means that the moving window function is
run many times but for a small window relative to the size of the raster. The
'maxDist' argument determines the maximum distance calculated and affects the
number of iterations of the moving window that are needed. 'kwidth' is the
radius of the moving window in number of cells, with larger values reducing
the number of iterations needed but also reducing the granularity of the
distances produced. The resulting distances will be in increments of 'kwidth'
* the resolution of the raster. The total number of iterations is 'maxDist'/
'kwidth' * resolution. The only difference in these methods is the underlying
package used to do the moving window. The 'terra' package has methods for
handling large rasters by writing them to disk, while the 'pfocal' package
requires that the raster can be held in memory as a matrix.
</p>
<p>The third method &quot;pfocal2&quot; uses a global moving window to calculate the
distance to the source. This means that the moving window only needs to be
applied once but the window size can be very large. In this case 'maxDist'
determines the total size of the window. 'kwidth' can be used to reduce the
number of cells included in the moving window by aggregating the source
raster by a factor of 'kwidth'. This will increase the speed of computation
but will produce results with artefacts of the larger grid and which may be
less accurate since the output raster is disaggregated using bilinear
interpolation.
</p>


<h3>Value</h3>

<p>A SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CLUSexample &lt;-  prepExData(CLUSexample)
getDistFromSource(CLUSexample$roads, 5, 2)


 library(sf)
 library(terra)

#make example roads from scratch
rds &lt;- data.frame(x = 1:1000/100, y = cos(1:1000/100)) %&gt;% 
  st_as_sf(coords = c("x", "y")) %&gt;% 
  st_union() %&gt;% 
  st_cast("LINESTRING")

rds_rast &lt;- rasterize(vect(rds), 
                      rast(nrows = 50, ncols = 50, 
                           xmin = 0, xmax = 10, 
                           ymin = -5, ymax = 5),
                      touches = TRUE)
                      
getDistFromSource(rds_rast, 5, 2)

</code></pre>

<hr>
<h2 id='getLandingsFromTarget'>Get landing points inside harvest blocks</h2><span id='topic+getLandingsFromTarget'></span>

<h3>Description</h3>

<p>Generate landing points inside polygons representing harvested area. There
are three different sampling types available: &quot;centroid&quot; is the default and
will return the centroid or a point that is inside the polygon if the
centroid is not (see <code><a href="sf.html#topic+geos_unary">st_point_on_surface</a></code>); &quot;random&quot; takes a
random sample based on the given <code>landingDens</code> see
(<code><a href="sf.html#topic+st_sample">st_sample</a></code>); &quot;regular&quot; intersects the polygons with a
regular grid with cell size <code>sqrt(1/landingDens)</code>, if a polygon does not
intersect with the grid its centroid is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLandingsFromTarget(harvest, landingDens = NULL, sampleType = "centroid")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLandingsFromTarget_+3A_harvest">harvest</code></td>
<td>
<p>sf, SpatialPolygons or RasterLayer object with harvested
areas. If it is a RasterLayer with more than one unique value other than 0
each value will be run separately which will produce different results from
a 0/1 raster but will be much slower.</p>
</td></tr>
<tr><td><code id="getLandingsFromTarget_+3A_landingdens">landingDens</code></td>
<td>
<p>number of landings per unit area. This should be in the
same units as the CRS of the harvest. Note that 0.001 points per m2 is &gt; 1000
points per km2 so this number is usually very small for projected CRS.</p>
</td></tr>
<tr><td><code id="getLandingsFromTarget_+3A_sampletype">sampleType</code></td>
<td>
<p>character. &quot;centroid&quot; (default), &quot;regular&quot; or &quot;random&quot;.
Centroid returns one landing per harvest block, which is guaranteed to be
in the harvest block for sf objects but not for rasters. Regular returns
points from a grid with density <code>landingDens</code> that overlap the
harvested areas. Random returns a random set of points from each polygon
where the number is determined by the area of the polygons and
<code>landingDens</code>. If <code>harvest</code> is a raster the centroid is always
returned as one of the landings to ensure all harvest areas get at least
one landing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <code>landingDens</code> is in points per unit area where the unit of
area is determined by the CRS. For projected CRS this should likely be a very
small number i.e. &lt; 0.001.
</p>


<h3>Value</h3>

<p>an sf simple feature collection with an ID column and POINT geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>doPlots &lt;- interactive()
demoScen &lt;- prepExData(demoScen)

polys &lt;- demoScen[[1]]$landings.poly[1:2,]

# Get centroid
outCent &lt;- getLandingsFromTarget(polys)

if(doPlots){
  plot(sf::st_geometry(polys))
  plot(outCent, col = "red", add = TRUE)
}

# Get random sample with density 0.1 points per unit area
outRand &lt;- getLandingsFromTarget(polys, 0.1, sampleType = "random")

if(doPlots){
  plot(sf::st_geometry(polys))
  plot(outRand, col = "red", add = TRUE)
}

# Get regular sample with density 0.1 points per unit area
outReg &lt;- getLandingsFromTarget(polys, 0.1, sampleType = "regular")

if(doPlots){
  plot(sf::st_geometry(polys))
  plot(outReg, col = "red", add = TRUE)
}

</code></pre>

<hr>
<h2 id='plotRoads'>Plot projected roads</h2><span id='topic+plotRoads'></span>

<h3>Description</h3>

<p>Plot the results of <code><a href="#topic+projectRoads">projectRoads</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRoads(sim, mainTitle, subTitle = paste0("Method: ", sim$roadMethod), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRoads_+3A_sim">sim</code></td>
<td>
<p>sim list result from <code>projectRoads</code></p>
</td></tr>
<tr><td><code id="plotRoads_+3A_maintitle">mainTitle</code></td>
<td>
<p>A title for the plot</p>
</td></tr>
<tr><td><code id="plotRoads_+3A_subtitle">subTitle</code></td>
<td>
<p>A sub title for the plot, by default the <code>roadMethod</code> is used</p>
</td></tr>
<tr><td><code id="plotRoads_+3A_...">...</code></td>
<td>
<p>Other arguments passed to raster plot call for the <code>costSurface</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Creates a plot using base graphics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample &lt;- prepExData(CLUSexample)
prRes &lt;- projectRoads(CLUSexample$landings, CLUSexample$cost, CLUSexample$roads)
if(interactive()){
  plotRoads(prRes, "Title")
}


</code></pre>

<hr>
<h2 id='prepExData'>Prepare example data</h2><span id='topic+prepExData'></span>

<h3>Description</h3>

<p>Prepare example data included in the package that contain wrapped terra
objects. This applies [terra::unwrap()] recursively to the list provided so
that all PackedSpatRasters are converted to SpatRasters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepExData(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepExData_+3A_x">x</code></td>
<td>
<p>A list containing elements some of which are packed SpatRasters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same list but with unwrapped SpatRasters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample
prepExData(CLUSexample)
</code></pre>

<hr>
<h2 id='projectRoads'>Project road network</h2><span id='topic+projectRoads'></span><span id='topic+projectRoads+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY+2Cmissing-method'></span><span id='topic+projectRoads+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY+2Clist-method'></span>

<h3>Description</h3>

<p>Project road locations based on existing roads, planned landings, and a cost
surface that defines the cost of building roads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectRoads(
  landings = NULL,
  cost = NULL,
  roads = NULL,
  roadMethod = "mst",
  plotRoads = FALSE,
  mainTitle = "",
  neighbourhood = "octagon",
  sim = NULL,
  roadsOut = NULL,
  roadsInCost = TRUE,
  ordering = "closest"
)

## S4 method for signature 'ANY,ANY,ANY,ANY,ANY,ANY,ANY,missing'
projectRoads(
  landings = NULL,
  cost = NULL,
  roads = NULL,
  roadMethod = "mst",
  plotRoads = FALSE,
  mainTitle = "",
  neighbourhood = "octagon",
  sim = NULL,
  roadsOut = NULL,
  roadsInCost = TRUE,
  ordering = "closest"
)

## S4 method for signature 'ANY,ANY,ANY,ANY,ANY,ANY,ANY,list'
projectRoads(
  landings = NULL,
  cost = NULL,
  roads = NULL,
  roadMethod = "mst",
  plotRoads = FALSE,
  mainTitle = "",
  neighbourhood = "octagon",
  sim = NULL,
  roadsOut = NULL,
  roadsInCost = TRUE,
  ordering = "closest"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectRoads_+3A_landings">landings</code></td>
<td>
<p>sf polygons or points, RasterLayer, SpatialPolygons*,
SpatialPoints*, matrix, containing features to be connected
to the road network. Matrix should contain columns x, y with coordinates,
all other columns will be ignored.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_cost">cost</code></td>
<td>
<p>RasterLayer. Cost surface where existing roads must be the only
cells with a cost of 0. If existing roads do not have 0 cost set
<code>roadsInCost = FALSE</code> and they will be burned in.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_roads">roads</code></td>
<td>
<p>sf lines, SpatialLines*, RasterLayer. Existing road network.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_roadmethod">roadMethod</code></td>
<td>
<p>Character. Options are &quot;mst&quot;, &quot;dlcp&quot;, &quot;lcp&quot;, &quot;snap&quot;.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_plotroads">plotRoads</code></td>
<td>
<p>Boolean. Should the resulting road network be plotted.
Default FALSE.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_maintitle">mainTitle</code></td>
<td>
<p>Character. A title for the plot</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>Character. 'rook','queen', or 'octagon'. The cells that
should be considered adjacent. 'octagon' option is a modified version of
the queen's 8 cell neighbourhood in which diagonals weights are 2^0.5x
higher than horizontal/vertical weights.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_sim">sim</code></td>
<td>
<p>list. Returned from a previous iteration of <code>projectRoads</code>.
cost, roads, and <code>roadMethod</code> are ignored if a <code>sim</code> list is provided.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_roadsout">roadsOut</code></td>
<td>
<p>Character. Either &quot;raster&quot;, &quot;sf&quot; or NULL. If &quot;raster&quot; roads
are returned as a raster in the <code>sim</code> list. If &quot;sf&quot; the roads are returned as
an sf object which will contain lines if the roads input was sf lines but a
geometry collection of lines and points if the roads input was a raster.
The points in the geometry collection represent the existing roads while
new roads are created as lines. If NULL (default) then the returned roads
are sf if the input is sf or Spatial* and raster if the input was a raster.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_roadsincost">roadsInCost</code></td>
<td>
<p>Logical. The default is TRUE which means the cost raster
is assumed to include existing roads as 0 in its cost surface. If FALSE
then the roads will be &quot;burned in&quot; to the cost raster with a cost of 0.</p>
</td></tr>
<tr><td><code id="projectRoads_+3A_ordering">ordering</code></td>
<td>
<p>character. The order in which roads should be built to
landings when 'roadMethod = &quot;dlcp&quot;'. Options are &quot;closest&quot; (default) where
landings closest to existing roads are accessed first, or &quot;none&quot; where
landings are accessed in the order they are provided in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four different methods for projecting road networks have been implemented:
</p>

<ul>
<li><p>&quot;snap&quot;: Connects each landing directly to the closest road without
reference to the cost or other landings
</p>
</li>
<li><p>&quot;lcp&quot;: Least Cost Path connects each landing to the closest point
on the road by determining the least cost path based on the cost surface
provided, it does not consider other landings
</p>
</li>
<li><p>&quot;dlcp&quot;: Dynamic Least Cost Path, same as &quot;lcp&quot; but it builds each
path sequentially so that later roads will use earlier roads. The sequence
of landings is determined by 'ordering' and is &quot;closest&quot; by default, the
other option is &quot;none&quot; which will use the order that landings are supplied
in.
</p>
</li>
<li><p>&quot;mst&quot;: Minimum Spanning Tree connects all landings to the road by
determining the least cost path to the road or other landings based on the
cost surface
</p>
</li></ul>



<h3>Value</h3>

<p>a list with components:
</p>

<ul>
<li><p>roads: the projected road network, including new and input roads.
</p>
</li>
<li><p>costSurface: the cost surface, updated to have 0 for new roads that
were added.
</p>
</li>
<li><p>roadMethod: the road simulation method used.
</p>
</li>
<li><p>landings: the landings used in the simulation.
</p>
</li>
<li><p>g: the graph that describes the cost of paths between each cell in the
cost raster. This is updated based on the new roads so that vertices 
were connected by new roads now have a cost of 0. This can be used to 
avoid recomputing the graph in a simulation with multiple time steps.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample &lt;- prepExData(CLUSexample)
doPlots &lt;- interactive()

projectRoads(CLUSexample$landings, CLUSexample$cost, CLUSexample$roads,
             "lcp", plotRoads = doPlots, mainTitle = "CLUSexample")
                         

# More realistic examples that take longer to run


demoScen &lt;- prepExData(demoScen)

### using:  scenario 1 / sf landings / least-cost path ("lcp")
# demo scenario 1
scen &lt;- demoScen[[1]]

# landing set 1 of scenario 1:
land.pnts &lt;- scen$landings.points[scen$landings.points$set==1,]

prRes &lt;- projectRoads(land.pnts, scen$cost.rast, scen$road.line, "lcp",
                         plotRoads = doPlots, mainTitle = "Scen 1: SPDF-LCP")

### using: scenario 1 / SpatRaster landings / minimum spanning tree ("mst")
# demo scenario 1
scen &lt;- demoScen[[1]]

# the RasterLayer version of landing set 1 of scenario 1:
land.rLyr &lt;- scen$landings.stack[[1]]

prRes &lt;- projectRoads(land.rLyr, scen$cost.rast, scen$road.line, "mst",
                         plotRoads = doPlots, mainTitle = "Scen 1: Raster-MST")


### using: scenario 2 / matrix landings raster roads / snapping ("snap")
# demo scenario 2
scen &lt;- demoScen[[2]]

# landing set 5 of scenario 2, as matrix:
land.mat  &lt;- scen$landings.points[scen$landings.points$set==5,] |&gt; 
  sf::st_coordinates()

prRes &lt;- projectRoads(land.mat, scen$cost.rast, scen$road.rast, "snap",
                      plotRoads = doPlots, mainTitle = "Scen 2: Matrix-Snap")

## using scenario 7 / Polygon landings raster / minimum spanning tree
# demo scenario 7
scen &lt;- demoScen[[7]]
# rasterize polygonal landings of demo scenario 7:
land.polyR &lt;- terra::rasterize(scen$landings.poly, scen$cost.rast)

prRes &lt;- projectRoads(land.polyR, scen$cost.rast, scen$road.rast, "mst",
                         plotRoads = doPlots, mainTitle = "Scen 7: PolyRast-MST")


</code></pre>

<hr>
<h2 id='rasterizeLine'>Faster rasterize for lines</h2><span id='topic+rasterizeLine'></span>

<h3>Description</h3>

<p>Rasterize a line using <code>stars</code> because <code>fasterize</code> doesn't work on lines and
rasterize is slow. Deprecated use <code>terra::rasterize</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterizeLine(sfLine, rast, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterizeLine_+3A_sfline">sfLine</code></td>
<td>
<p>an sf object to be rasterized</p>
</td></tr>
<tr><td><code id="rasterizeLine_+3A_rast">rast</code></td>
<td>
<p>a raster to use as template for the output raster</p>
</td></tr>
<tr><td><code id="rasterizeLine_+3A_value">value</code></td>
<td>
<p>a number value to give the background ie 0 or NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a RasterLayer where the value of cells that touch the line will be
the row index of the line in the sf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample &lt;- prepExData(CLUSexample)
roadsLine &lt;- sf::st_sf(geometry = sf::st_sfc(sf::st_linestring(
matrix(c(0.5, 4.5, 4.5, 4.51),
       ncol = 2, byrow = TRUE) 
)))

# Deprecated rasterizeLine(roadsLine, CLUSexample$cost, 0)   
# Use terra::rasterize
terra::rasterize(roadsLine, CLUSexample$cost, background = 0)

</code></pre>

<hr>
<h2 id='rasterToLineSegments'>Convert raster to lines</h2><span id='topic+rasterToLineSegments'></span>

<h3>Description</h3>

<p>Converts rasters that represent lines into an sf object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToLineSegments(rast, method = "mst")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterToLineSegments_+3A_rast">rast</code></td>
<td>
<p>raster representing lines all values &gt; 0 are assumed to be lines</p>
</td></tr>
<tr><td><code id="rasterToLineSegments_+3A_method">method</code></td>
<td>
<p>method of building lines. See Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>method = "nearest"</code> raster is first converted to points and then
lines are drawn between the nearest points. If there are two different ways
to connect the points that have the same distance both are kept which can
cause doubled lines. USE WITH CAUTION. <code>method = "mst"</code> converts the
raster to points, reclassifies the raster so roads are 0 and other cells are
1 and then uses <code>projectRoads</code> to connect all the points with a minimum
spanning tree. This will always connect all raster cells and is slower but
will not double lines as often. Neither method is likely to work for very
large rasters
</p>


<h3>Value</h3>

<p>an sf simple feature collection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CLUSexample &lt;- prepExData(CLUSexample)
# works well for very simple roads
roadLine1 &lt;- rasterToLineSegments(CLUSexample$roads)

# longer running more realistic examples

demoScen &lt;- prepExData(demoScen)
# mst method works well in this case
roadLine2 &lt;- rasterToLineSegments(demoScen[[1]]$road.rast)

# nearest method has doubled line where the two roads meet
roadLine3 &lt;- rasterToLineSegments(demoScen[[1]]$road.rast, method = "nearest")

# The mst method can also produce odd results in some cases
roadLine4 &lt;- rasterToLineSegments(demoScen[[4]]$road.rast)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
