<!DOCTYPE html><html><head><title>Help for package AssetPricing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AssetPricing}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AssetPricing-internal'><p>Internal AssetPricing functions</p></a></li>
<li><a href='#buildS'>
<p>Build a piecewise linear price sensitivity function</p></a></li>
<li><a href='#plot.AssetPricing'>
<p>Plot a list of asset pricing functions.</p></a></li>
<li><a href='#vsolve'>
<p>Solve for expected value of assets.</p></a></li>
<li><a href='#xsolve'>
<p>Optimal pricing policy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Pricing of Assets with Fixed Expiry Date</td>
</tr>
<tr>
<td>Author:</td>
<td>Rolf Turner &lt;r.turner@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rolf Turner &lt;r.turner@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 0.99)</td>
</tr>
<tr>
<td>Imports:</td>
<td>polynom, deSolve</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates the optimal price of assets (such as
	airline flight seats, hotel room bookings) whose value
	becomes zero after a fixed &ldquo;expiry date&rdquo;.  Assumes
	potential customers arrive (possibly in groups) according
	to a known inhomogeneous Poisson process.  Also assumes a
	known time-varying elasticity of demand (price sensitivity)
	function.  Uses elementary techniques based on ordinary
	differential equations.  Uses the package deSolve to effect
	the solution of these differential equations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.auckland.ac.nz/~rolf/">http://www.stat.auckland.ac.nz/~rolf/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-07 20:21:22 UTC; rolf</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-07 20:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='AssetPricing-internal'>Internal AssetPricing functions</h2><span id='topic+a2sf'></span><span id='topic+cev'></span><span id='topic+findSolType'></span><span id='topic+getPossPrices'></span><span id='topic+getS'></span><span id='topic+i2qj'></span><span id='topic+initx'></span><span id='topic+.newt'></span><span id='topic+plot.flap'></span><span id='topic+plot.stepfun'></span><span id='topic+progRep'></span><span id='topic+putAway'></span><span id='topic+qj2i'></span><span id='topic+scrF'></span><span id='topic+scrG'></span><span id='topic+turnPts'></span><span id='topic+vupdate'></span><span id='topic+xsolve.cont'></span><span id='topic+xsolve.disc'></span><span id='topic+xsolve.pwl'></span>

<h3>Description</h3>

<p>Internal AssetPricing functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2sf(x,tt,xlim,npts=1000)
cev(x,t,v,type,maximize=FALSE)
findSolType(S,prices)
getPossPrices(v,t,alpha,beta,kn,Kpa,type)
getS(dS,xc,t,jays)
i2qj(i,qmax,jmax)
initx(v,type)
.newt(fn,start,...,eps.p = 1e-08,eps.v = NULL,
     maxit = 50,verb = FALSE)
## S3 method for class 'flap'
plot(x,xlim=NULL,ylim=NULL,lty=NULL,cols=NULL,xlab=NULL,
                    ylab=NULL,main=NULL,main.panel= NULL,groups=NULL,
                    add=FALSE,gloss=FALSE,glind=NULL,extend=0.3,col.gloss=1,
                    cex.gloss=0.8,mfrow=NULL,...)
## S3 method for class 'stepfun'
plot(x, xval, xlim, ylim = range(c(y, Fn.kn)), xlab = "x",
                       ylab = "f(x)", main = NULL, add = FALSE, verticals = TRUE,
                       do.points = TRUE, pch = par("pch"), col = par("col"),
                       col.points = col, cex.points = par("cex"), col.hor = col,
                       col.vert = col, lty = par("lty"), lwd = par("lwd"), ...)
progRep(info,verbInt,tt,tmax)
putAway(odeRslt,type,jmax,qmax,soltype,x=NULL,prices=NULL)
qj2i(q,j,qmax)
scrG(tt,x,parms,verbInt,tmax,info,...)
scrF(tt,v,parms,verbInt,tmax,info,...)
turnPts(a,b,v,Kpa,xlo,xhi,type)
vupdate(x,tt,type)
xsolve.cont(S,lambda,gprob,tmax,qmax,nout,type,
                           alpha,salval,method,verbInt)
xsolve.disc(S,lambda,gprob,tmax,qmax,prices,nout,type,
                           alpha,salval,epsilon,method,verbInt)
xsolve.pwl(S,lambda,gprob,tmax,qmax,nout,type,
                           alpha,salval,epsilon,method,verbInt)
</code></pre>


<h3>Details</h3>

<p>These functions are auxiliary and are not intended to be called by
the user.
</p>

<hr>
<h2 id='buildS'>
Build a piecewise linear price sensitivity function
</h2><span id='topic+buildS'></span>

<h3>Description</h3>

<p>Builds a price sensitivity function which is piecewise linear
in price, in an automated manner, with built-in checks for
possible infelicities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   buildS(alpha, beta, kn, tmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildS_+3A_alpha">alpha</code></td>
<td>

<p>A list of functions of <code>t</code> giving the constant terms of
the linear functions comprising the price sensitivity function.
</p>
</td></tr>
<tr><td><code id="buildS_+3A_beta">beta</code></td>
<td>

<p>A list of functions of <code>t</code> giving the slopes of the linear
functions comprising the price sensitivity function.
</p>
</td></tr>
<tr><td><code id="buildS_+3A_kn">kn</code></td>
<td>

<p>The knots (with respect to price) of the piecewise linear
price sensitivity function.  The zero knot (which is always
the first knot) is <em>not</em> included in <code>kn</code>.
</p>
</td></tr>
<tr><td><code id="buildS_+3A_tmax">tmax</code></td>
<td>

<p>The maximum time value to which the price sensitivity function
is to be applied.  Needed for internal consistency checks.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The price sensitivity function is assumed to be of the form
</p>
<p style="text-align: center;"><code class="reqn">S(x,t) = \alpha_k(t) + \beta_k(t)x</code>
</p>
<p> for <code class="reqn">x_{k-1} \leq x \leq x_k</code> where <code class="reqn">x_1, x_2, \ldots, x_K</code> are the
(non-zero) knots of the function.  It is assumed that <code class="reqn">x_0
  = 0</code>.  The variable <code>x</code> represents price and the variable
<code>t</code> represents residual time.
</p>
<p>The function is defined over the rectangle
<code class="reqn">[0,x_K] \times [0,t_{\rm max}]</code>.
</p>
<p>Checks are done to make sure that
</p>

<dl>
<dt><code class="reqn">\bullet</code> <code class="reqn">S(x,t)</code> is continuous</dt><dd></dd>
<dt><code class="reqn">\bullet</code> <code class="reqn">S(0,t) = 1</code> for all <code class="reqn">t</code></dt><dd></dd>
<dt><code class="reqn">\bullet</code> <code class="reqn">S(x,t)</code> is non-increasing in <code class="reqn">x</code> for all t</dt><dd></dd>
<dt><code class="reqn">\bullet</code> <code class="reqn">S(x,t) \geq 0</code> for all <code class="reqn">x</code> and <code class="reqn">t</code></dt><dd></dd>
</dl>



<h3>Value</h3>

<p>A function of two variables <code>x</code> and <code>t</code>, which is
a price sensitivity function.  The argument <code>x</code> represents
price and the argument <code>t</code> represents (residual) time.
The value of the function is interpreted as the probability
that a customer &ldquo;arriving&rdquo; at time <code>t</code> will purchase
an item offered at price <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
<a href="http://www.stat.auckland.ac.nz/~rolf">http://www.stat.auckland.ac.nz/~rolf</a>
</p>


<h3>References</h3>

<p>P. K. Banerjee, and T. R. Turner (2012).
A flexible model for the pricing of perishable assets.
<em>Omega</em> <b>40</b>:5, 533&ndash;540.
DOI https://doi.org/10.1016/j.omega.2011.10.001
</p>
<p>Rolf Turner, Pradeep Banerjee and Rayomand Shahlori (2014).  Optimal
Asset Pricing.  <em>Journal of Statistical Software</em> <b>58</b>:11, 1&ndash;25.
DOI https://doi.org/10.18637/jss.v058.i11
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xsolve">xsolve</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   lambda &lt;- function(t) {
      tn &lt;- 1:4
      A &lt;- matrix(c(0,12,12,12,
              0,-16,16,64,
              20,30,30,0),nrow=4)
      B &lt;- matrix(c(12,0,0,0,
               0,16,0,-16,
               0,-10,-10,0),nrow=4)
      s &lt;- cut(t,breaks=c(0,tn),include.lowest=TRUE,labels=tn)
      s &lt;- as.numeric(levels(s)[s])
      M &lt;- matrix(A[s,] + B[s,]*t,ncol=ncol(A))
      M[!is.finite(M)] &lt;- 0
      M
   }

   alpha &lt;- vector("list",4)
   beta  &lt;- vector("list",4)
   alpha[[1]] &lt;- with(list(lambda=lambda),
	function(t) {
	A &lt;- c(1,1,1)
        lll &lt;- lambda(t)
        dnm &lt;- apply(lll,1,sum)
        dnm[dnm==0] &lt;- 1
        lll%*%A/dnm
   })
   beta[[1]] &lt;- with(list(lambda=lambda),
	function(t) {
	B &lt;- c(0,0,0)
        lll &lt;- lambda(t)
        dnm &lt;- apply(lll,1,sum)
        dnm[dnm==0] &lt;- 1
        lll%*%B/dnm
   })
   alpha[[2]] &lt;- with(list(lambda=lambda),
	function(t) {
	A &lt;- c(1.495,1,1)
        lll &lt;- lambda(t)
        dnm &lt;- apply(lll,1,sum)
        dnm[dnm==0] &lt;- 1
        lll%*%A/dnm
   })
   beta[[2]] &lt;- with(list(lambda=lambda),
	function(t) {
	B &lt;- c(-0.2475,0,0)
        lll &lt;- lambda(t)
        dnm &lt;- apply(lll,1,sum)
        dnm[dnm==0] &lt;- 1
        lll%*%B/dnm
   })
   alpha[[3]] &lt;- with(list(lambda=lambda),
	function(t) {
	A &lt;- c(0.01,2.485,1)
        lll &lt;- lambda(t)
        dnm &lt;- apply(lll,1,sum)
        dnm[dnm==0] &lt;- 1
        lll%*%A/dnm
   })
   beta[[3]] &lt;- with(list(lambda=lambda),
	function(t) {
	B &lt;- c(0,-0.2475,0)
        lll &lt;- lambda(t)
        dnm &lt;- apply(lll,1,sum)
        dnm[dnm==0] &lt;- 1
        lll%*%B/dnm
   })
   alpha[[4]] &lt;- with(list(lambda=lambda),
	function(t) {
	A &lt;- c(0.01,0.01,3.475)
        lll &lt;- lambda(t)
        dnm &lt;- apply(lll,1,sum)
        dnm[dnm==0] &lt;- 1
        lll%*%A/dnm
   })
   beta[[4]] &lt;- with(list(lambda=lambda),
	function(t) {
	B &lt;- c(0,0,-0.2475)
        lll &lt;- lambda(t)
        dnm &lt;- apply(lll,1,sum)
        dnm[dnm==0] &lt;- 1
        lll%*%B/dnm
   })
   kn &lt;- c(2,6,10,14)
   S  &lt;- buildS(alpha,beta,kn,4)
   x  &lt;- seq(0,14,length=41)
   t  &lt;- seq(0,4,length=41)
   z  &lt;- S(x,t)
## Not run: 
   persp(x,t,z,theta=150,phi=40,d=4,xlab="price",ylab="time",
         zlab="probability",ticktype="detailed")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.AssetPricing'>
Plot a list of asset pricing functions.
</h2><span id='topic+plot.AssetPricing'></span>

<h3>Description</h3>

<p>Plot a list of functions &mdash; in particular optimal price
functions or expected value functions or derivatives of the
expected value functions.  Such a list is assumed to occur as
a component of an object produced by <code><a href="#topic+xsolve">xsolve</a>()</code> of
<code><a href="#topic+vsolve">vsolve</a>()</code>.  The functions in the list are functions
of residual time.  The indices of the list correspond to the
number of items available for sale and possibly (for optimal
price functions) the size of the arriving group of customers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AssetPricing'
plot(x,witch=c("price","expVal","vdot"),
             xlim=NULL,ylim=NULL,lty=NULL,cols=NULL,xlab=NULL,
             ylab=NULL,main=NULL,main.panel= NULL,groups=NULL,
             add=FALSE,gloss=FALSE,glind=NULL,extend=0.3,col.gloss=1,
             cex.gloss=0.8,mfrow=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.AssetPricing_+3A_x">x</code></td>
<td>

<p>An object of class <code>AssetPricing</code>, i.e. an object
produced by <code><a href="#topic+vsolve">vsolve</a>()</code>, or <code><a href="#topic+xsolve">xsolve</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_witch">witch</code></td>
<td>

<p>A text string indicating which of the three possible components
of <code>x</code> should be plotted.  May be abbreviated, e.g. to
<code>p</code>, <code>e</code> or <code>v</code>.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_xlim">xlim</code></td>
<td>

<p>The <code>x</code> limits of the plot.  Defaults to the <code>tlim</code>
attribute of the object <code>x[[witch]]</code>.  If this attribute does not
exist and <code>xlim</code> is not supplied then an error is given.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_ylim">ylim</code></td>
<td>

<p>The <code>y</code> limits of the plot.  Defaults to the <code>ylim</code>
attribute of the object <code>x[[witch]]</code>.  If this attribute does not
exist and <code>ylim</code> is not supplied then an error is given.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_lty">lty</code></td>
<td>

<p>A vector of line types.  It will be replicated to have a length
equal to the number of rows of <code>groups</code> (see below).
Defaults to having all entries of the vector equal to <code>1</code>,
i.e. solid lines.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_cols">cols</code></td>
<td>

<p>A vector of colours for the plotted lines.  It will be replicated
to have a length equal to the number of rows of <code>groups</code>
(see below).  Defaults to having all entries of the vector equal
to <code>1</code>, i.e. black.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_xlab">xlab</code></td>
<td>

<p>A text string giving a label for the <code>x</code> axis (or axes).
Defaults to the null string.  Ignored if <code>add</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_ylab">ylab</code></td>
<td>

<p>A text string giving a label for the <code>y</code> axis (or axes).
Defaults to the null string.  Ignored if <code>add</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_main">main</code></td>
<td>

<p>A text string giving an overall title for the plot or for each
page of plots if there is more than one.  Defaults to the null
string and is ignored if <code>add</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_main.panel">main.panel</code></td>
<td>

<p>A text string which is replicated &ldquo;np&rdquo; times (where
&ldquo;np&rdquo; is the total number of panels) or a vector of text
strings of length equal to &ldquo;np&rdquo;.  Note that &ldquo;np&rdquo; will
be equal to the number of unique entries of <code>groups$group</code>.
(See below.)  The <code class="reqn">i^{th}</code> entry of the vector is
used as the title of the <code class="reqn">i^{th}</code> panel of the plots
that are created.  If <code>main.panel</code> is left <code>NULL</code>
the <code class="reqn">i^{th}</code> entry of the vector is set equal to
<code>paste("group",i)</code>.  This argument is ignored if there
is only a single panel.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_groups">groups</code></td>
<td>

<p>A data frame with one, two or three columns, named <code>group</code>,
<code>q</code> and <code>j</code>.  The total number of rows should be less
than or equal to the total number of entries of the function
list <code>x[[witch]]</code>.  Only those function traces corresponding to a
row of <code>groups</code> are plotted.  The traces corresponding to
an individual value in the <code>group</code> column are plotted in the
same panel of a multi-panel array of plots.  See <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_add">add</code></td>
<td>
<p> Logical scalar; should the plot be added to an
existing plot?
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_gloss">gloss</code></td>
<td>
<p> Either a logical scalar (should a &ldquo;marginal
gloss&rdquo; be added to the plot? &mdash; if <code>TRUE</code> then the gloss
is constructed internally; see <b>Details</b>)  or a vector of
character strings of which the marginal gloss is to consist.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_glind">glind</code></td>
<td>
<p> A logical vector indicating which entries of
<code>gloss</code> should actually be used (plotted).  I.e. marginal
gloss is added for the graphs of functions whose corresponding
values in the entries of <code>glind</code> are <code>TRUE</code>.  Ignored if
<code>gloss</code> is <code>FALSE</code>.  If <code>gloss</code> is <code>TRUE</code> or
is explicitly provided, then if <code>glind</code> is not specified it
defaults to a vector, of the same length as <code>gloss</code> all of
whose entries are <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_extend">extend</code></td>
<td>
<p> A scalar, between 0 and 1, indicating how much
the <code>x</code>-axis should be extended (to the right) in order to
accommodate the marginal gloss.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_col.gloss">col.gloss</code></td>
<td>
<p> Scalar specifying the colour in which the
marginal gloss is to be added, e.g. <code>"red"</code> (or equivalently
<code>2</code>).  The default, i.e. <code>1</code>, is black.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_cex.gloss">cex.gloss</code></td>
<td>
<p> Character expansion (<code>cex</code>) specifier for
the marginal gloss.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_mfrow">mfrow</code></td>
<td>
<p> The dimensions of the array(s) of panels in which
the functions are plotted.  If this argument is left as <code>NULL</code>
then the software makes a &ldquo;sensible&rdquo; choice for its value.
If this argument is set equal to <code>NA</code> then the current value
of <code>mfrow</code> for the plotting device is left &ldquo;as is&rdquo;. This
permits the setting up of an array of panels vi a call to <code>par(mfrow=...)</code>
<em>a priori</em> without the resulting setting being over-ridden by
the internal code of this plotting method.  One might wish to do this
e.g. for the purpose of <em>adding</em> plotted material to each
panel.
</p>
</td></tr>
<tr><td><code id="plot.AssetPricing_+3A_...">...</code></td>
<td>
<p> Extra arguments to be passed to <code>plot</code>
(effectively to <code><a href="graphics.html#topic+plot.function">plot.function</a>()</code> or to
<code><a href="#topic+plot.stepfun">plot.stepfun</a>()</code>).
</p>
</td></tr> </table>


<h3>Details</h3>

<p>If the argument <code>groups</code> is specified then:
</p>

<ul>
<li><p> it must <em>always</em> have a column <code>q</code>.  The values
in this column should be integers between <code>1</code> and <code>qmax</code>
(see below).
</p>
</li>
<li><p> if <code>jmax</code> (see below) is greater than 1 it must also
have a column <code>j</code>.  The entries of this column should be
integers between <code>1</code> and <code>jmax</code>.
</p>
</li>
<li><p> if <code>jmax</code> is equal to <code>1</code> then column <code>j</code>
need not be present.  In this case, it is internally set equal
to a column of <code>1</code>-s.
</p>
</li>
<li><p> if the <code>group</code> column is present its entries
should be (consecutive) positive integers running from <code>1</code>
to the total number of groups.
</p>
</li>
<li><p> if the <code>group</code> column is not present then this column
is internally set equal to a column of <code>1</code>-s i.e. there is
a single group of traces.
</p>
</li></ul>

<p>The value of <code>qmax</code> is the maximum number of items that
are available for sale in the time period under consideration.
It may be obtained as <code>attr(x,"qmax")</code>.
</p>
<p>The value of <code>jmax</code> is, when &ldquo;double indexing&rdquo;
applies, the maximum size of an arriving group of customers,
and is otherwise equal to <code>1</code>.  It may be obtained as
<code>attr(x,"jmax")</code>.  Note that &ldquo;double indexing&rdquo; can
<em>only</em> apply when <code>x[[witch]]</code> is a list of <em>price</em>
functions, i.e. when <code>witch</code> is equal to <code>price</code>.
Hence &ldquo;double indexing&rdquo; does not apply when <code>witch</code>
is equal to <code>expVal</code> or to <code>vdot</code>.  In these cases
<code>jmax</code> is equal to <code>1</code>.
</p>
<p>If <code>groups</code> is not specified then it defaults to a data
frame with number of rows equal to the length of <code>x[[witch]]</code>, The
<code>group</code> column has entries all equal to 1, i.e. there is
a single group of traces.  The <code>q</code> and <code>j</code> columns
contain all possible (valid) combinations of stock size and
customer group size.
</p>
<p>If <code>gloss</code> is <code>FALSE</code> then no marginal gloss is plotted.
If <code>gloss</code> is <code>TRUE</code> then the marginal gloss is created
from the values of the <code>q</code> and <code>j</code> entries in the
columns of <code>groups</code> using <code>paste()</code>.
</p>
<p>Note that if <code>add</code> is <code>TRUE</code> then the gloss may not
actually appear in the plot, since it is placed at the right
hand edge of the plot and may consequently be outside of the
plotting region.  Thus if you wish to use a gloss when adding to
an existing plot you will probably need to take steps to ensure
that there is room in the right hand margin for the plot to appear,
or possibly set <code>par(xpd=NA)</code>.
</p>
<p>If &ldquo;double indexing&rdquo; applies then <code>x[[i]]</code> corresponds
to a stock size of <code>q</code> and a customer group size of <code>j</code>
where <code>i = (j-1)*(qmax - j/2) + q</code>.
</p>
<p>To get traces plotted in individual panels (one trace per panel)
set the <code>group</code> column of <code>groups</code> to be <code>1:n</code>
where <code>n</code> is the total number of traces being plotted.
</p>
<p>This function (i.e. <code>plot.AssetPricing()</code> calls upon an
&ldquo;internal&rdquo; function <code>plot.flap()</code> to do the hard
yakka. (Note that <code>flap</code> stands for dQuotefunction list
for asset pricing.)
</p>
<p>The function <code>plot.flap()</code> makes use of a modified
version of <code>plot.stepfun()</code>, rather than the one which
appears in <code>package:stats</code>.  The modification causes
<code>plot.stepfun()</code> to treat the <code>xlim</code> argument in a manner
similar to the way in which it is treated by <code>plot.function</code>.
Note that <code>plot.stepfun()</code> is <em>not</em> exported from
this package.  On the advice of Kurt Hornik (31/03/2018) I
created a new generic <code>plot()</code> function in this package
(i.e. <code>AssetPricing</code>) with default method equal to
<code>graphics::plot()</code>, so as to properly accommodate the
existence of this modified <code>plot.stepfun()</code> method.
</p>


<h3>Value</h3>

<p>None.  This function exists only for its side effect, i.e.
the production of a plot or plots.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
<a href="http://www.stat.auckland.ac.nz/~rolf">http://www.stat.auckland.ac.nz/~rolf</a>
</p>


<h3>References</h3>

<p>P. K. Banerjee, and T. R. Turner (2012).
A flexible model for the pricing of perishable assets.
<em>Omega</em> <b>40</b>:5, 533&ndash;540.
DOI https://doi.org/10.1016/j.omega.2011.10.001
</p>
<p>Rolf Turner, Pradeep Banerjee and Rayomand Shahlori (2014).  Optimal
Asset Pricing.  <em>Journal of Statistical Software</em> <b>58</b>:11, 1&ndash;25.
DOI https://doi.org/10.18637/jss.v058.i11
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xsolve">xsolve</a>()</code>
<code><a href="#topic+vsolve">vsolve</a>()</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
S &lt;- expression(exp(-kappa*x/(1+gamma*exp(-beta*t))))
attr(S,"parvec") &lt;- c(kappa=10/1.5,gamma=9,beta=1)
LAMBDA &lt;- function(tt){
    if(tt&lt;0 | tt&gt; 1) 0 else 36*(1-tt)
}
OUT &lt;- xsolve(S=S,lambda=LAMBDA,gprob=(5:1)/15,tmax=1,qmax=30,
                  alpha=0.5,type="dip",verbInt=2)
GLND &lt;- rep(FALSE,30)
GLND[c(1:5,10,15,20,30)] &lt;- TRUE
plot(OUT,witch="e",xlab="residual time",ylab="expected revenue",
     gloss=TRUE,glind=GLND)
GRPS &lt;- data.frame(group=rep(1:6,each=5),q=1:30)
GLND &lt;- c(TRUE,FALSE,TRUE,FALSE,TRUE,rep(c(rep(FALSE,4),TRUE),5))
plot(OUT,witch="e",groups=GRPS,xlab="residual time",ylab="expected revenue",
     gloss=TRUE,glind=GLND)
GRPS &lt;- data.frame(group=rep(1:5,each=6),j=rep(1:5,each=6))
GRPS$q &lt;- with(GRPS,pmax(j,rep(c(1,6,11,16,21,26),5)))
GLND &lt;- rep(c(TRUE,TRUE,rep(FALSE,3),TRUE),5)
plot(OUT,witch="p",groups=GRPS,mfrow=c(3,2),gloss=TRUE,glind=GLND,xlab="price")
# Pretty messy looking:
GRPS$group &lt;- 1
GLND &lt;- unlist(lapply(1:5,function(k){(1:6)==k}))
plot(OUT,witch="p",groups=GRPS,gloss=TRUE,glind=GLND,cols=GRPS$j,xlab="price")

## End(Not run)
</code></pre>

<hr>
<h2 id='vsolve'>
Solve for expected value of assets.
</h2><span id='topic+vsolve'></span>

<h3>Description</h3>

<p>Solves a system of coupled differential equations for the expected
value of a number <code>q</code> of (&ldquo;perishable&rdquo;) assets, with
<code>q</code> running from <code>1</code> to <code>qmax</code>, <em>given</em> a pricing
policy.  Treats the system in a vectorized form and uses the method
of Runge-Kutta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    vsolve(S, lambda, gprob, tmax=NULL, x, nout=300,
           alpha=NULL, salval=0, method="lsoda",verbInt=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsolve_+3A_s">S</code></td>
<td>

<p>An expression, or list of expressions, or a function or list
of functions, specifying the price sensitivity functions
<code>S_j(x,t)</code>.  See <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="vsolve_+3A_lambda">lambda</code></td>
<td>

<p>A function (of residual time <code>t</code> &mdash; see <code>tmax</code>) or
a positive constant specifying the intensity of the (generally
inhomogeneous) Poisson process of arrival times of groups of
potential customers.
</p>
</td></tr>
<tr><td><code id="vsolve_+3A_gprob">gprob</code></td>
<td>

<p>A function (to calculate probabilities) or a numeric vector of 
probabilities determining the distribution of the size of
an arriving group of customers.  Must be compatible with
certain characteristics of <code>s</code> (see below).  See
<b>details</b>.
</p>
</td></tr>
<tr><td><code id="vsolve_+3A_tmax">tmax</code></td>
<td>

<p>The maximum residual time; think of this as being the initial
time at which the assets go on sale (with time <em>decreasing</em>
to zero, at which point the value of each asset drops to the
&ldquo;salvage value&rdquo; (<code>salval</code>), usually <code>0</code>).
The system of differential equations is solved over the time
interval [0,<code>tmax</code>].  See <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="vsolve_+3A_x">x</code></td>
<td>

<p>An object of class <code>flap</code> (see <code><a href="#topic+xsolve">xsolve</a>()</code>)
specifying the (given) pricing policy.  It has the form of
a list of functions <code>x_i(t)</code>, with <code>i</code> running
from 1 to <code>qmax</code> if <code>x</code> is &ldquo;singly indexed&rdquo;,
i.e. <em>not</em> of class <code>di.flap</code> or <code>x_ij(t)</code>, with
<code>i</code> running from 1 to <code>qmax</code> and <code>j</code> running from 1
to the maximum group size if <code>x</code> is &ldquo;doubly indexed&rdquo;,
i.e.  <em>is</em> of class <code>di.flap</code>.  Note that <code>x</code>
has (must have) an <em>attribute</em> <code>qmax</code> specifying the
maximum number of assets available for sale, i.e. the number of
assets available at the starting (residual) time <code>tmax</code>.
</p>
</td></tr>
<tr><td><code id="vsolve_+3A_nout">nout</code></td>
<td>

<p>The number of points at which values of the solution are to be
provided.  These are taken to be equispaced on
[0,<code>tmax</code>].
</p>
</td></tr>
<tr><td><code id="vsolve_+3A_alpha">alpha</code></td>
<td>

<p>A numeric scalar between 0 and 1 specifying the probability that an
arriving group of size <code>j &gt; q</code> (where <code>q</code> is the number
of assets remaining for sale) will <em>consider</em> purchasing
(all of) these remaining assets.  It is irrelevant (and defaults
to 1 as a &ldquo;place holder&rdquo;) if customers always arrive singly.
</p>
</td></tr>
<tr><td><code id="vsolve_+3A_salval">salval</code></td>
<td>

<p>A (non-negative) numeric scalar specifying the &ldquo;salvage
value&rdquo; of an asset &mdash; i.e. the quantity to which the value of an
asset drops at residual time <code>t=0</code>.  Usually <code>salval</code>
is equal to 0.
</p>
</td></tr>
<tr><td><code id="vsolve_+3A_method">method</code></td>
<td>

<p>Character string specified the solution method to be used
by the differential equation solver <code>ode</code>.  There is
a fairly large number of possible methods.  See
<code><a href="deSolve.html#topic+ode">ode</a>()</code> for details.
</p>
</td></tr>
<tr><td><code id="vsolve_+3A_verbint">verbInt</code></td>
<td>

<p>A scalar value which controls &ldquo;verbosity&rdquo;.
If <code>verbInt &gt; 0</code> then a &ldquo;progress report&rdquo;
is printed every <code>verbInt</code> <em>seconds</em> (roughly).
See <code><a href="#topic+xsolve">xsolve</a>()</code> for a bit more detail.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components of the argument <code>S</code> may be provided either
as expressions or functions.  If the former, these expressions
should be amenble to differentiation with respect to <code>x</code>
and <code>t</code> via the function <code>deriv3()</code>.  This is
essentially a matter of convenience; the derivatives are not
actually used by <code>vsolve</code>.  The expressions are turned into
functions by <code>deriv3()</code> in the same manner as is used by
<code><a href="#topic+xsolve">xsolve</a>()</code>.  See the help for <code><a href="#topic+xsolve">xsolve</a>()</code>
for further information about the required nature of <code>S</code>.
</p>
<p>The argument <code>tmax</code> (if specified) must be less than or equal
to the <code>tmax</code> attribute of argument <code>S</code> if <code>S</code> is a
piecewise linear price sensitivity function, and must also be less
than or equal to the <code>tlim</code> attribute of argument <code>x</code>.
</p>
<p>If <code>tmax</code> is not specified it will be set equal to the
<code>tmax</code> attribute of argument <code>S</code> if <code>S</code> is a
piecewise linear price sensitivity function, in which case
this attribute must be less than or equal to the <code>tlim</code>
attribute of argument <code>x</code>.  (If this is not so then <code>S</code>
and <code>x</code> are incompatible.)  Otherwise <code>tmax</code> will be
set equal to the <code>tlim</code> attribute of argument <code>x</code>.
</p>
<p>The argument <code>gprob</code> determines the range of possible values
of the size of an arriving group of customers.  The maximum value
of this group size is in effect that value of <code>j</code> for which
the corresponding probability value is numerically distinguishable
from zero.  If the argument <code>x</code> is a &ldquo;doubly indexed&rdquo;
list of functions (was created with <code>type="dip"</code>) then
the maximum value of group size as determined by <code>gprob</code>
must be compatible with the indexing scheme of <code>x</code>.
That is to say, it must be less than or equal to the <code>jmax</code>
attribute of <code>x</code>, otherwise an error is given.  Note that
if single indexing is in effect (i.e. <code>x</code> was created with
<code>type="sip"</code>) then this attribute is equal to 1, but for
single indexing <code>x</code> does not depend on group size and so no
restriction is imposed.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The argument <code>x</code> which was passed to <code>vsolve</code>,
possibly with its <code>tlim</code> attribute modified.  It is
an object of class <code>flap</code>.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>An object of class <code>flap</code> whose entries are
(spline) functions <code>v_q(t)</code> specifying the expected value of
<code>q</code> assets at time <code>t</code> as determined by numerically
solving the coupled system of differential equations.
</p>
</td></tr>
<tr><td><code>vdot</code></td>
<td>
<p>An object of class <code>flap</code> whose entries are
the derivatives (with respect to <code>t</code>) of the functions <code>v_q(t)</code>
described above.  The values of these derivatives are determined as
the left hand side of the differential equations being solved.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A substantial change was made to this package as of the change
of version number from 0.0-11 to 0.1-0.  Previously the differential
equations which arise were solved via a &ldquo;locally produced&rdquo;
roll-your-own Runge-Kutta procedure.  Now they are solved (in a
more sophisticated manner) using the package <code>deSolve</code>.  This
increases the solution speed by a factor of about 7.  There will
be (minor, it is to be hoped) numerical differences in solutions
produced from the same input.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
<a href="http://www.stat.auckland.ac.nz/~rolf">http://www.stat.auckland.ac.nz/~rolf</a>
</p>


<h3>References</h3>

<p>P. K. Banerjee and T. R. Turner (2012).
A flexible model for the pricing of perishable assets.
<em>Omega</em> <b>40</b>:5, 533&ndash;540.
DOI https://doi.org/10.1016/j.omega.2011.10.001
</p>
<p>Rolf Turner, Pradeep Banerjee and Rayomand Shahlori (2014).  Optimal
Asset Pricing.  <em>Journal of Statistical Software</em> <b>58</b>:11, 1&ndash;25.
DOI https://doi.org/10.18637/jss.v058.i11
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xsolve">xsolve</a>()</code>, <code><a href="#topic+plot.AssetPricing">plot.AssetPricing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# In these examples "qmax" has been set equal to 5 which is
# an unrealistically low value for the total number of assets.
# This is done so as to reduce the time for package checking on CRAN.
#
S &lt;- expression(exp(-kappa*x/(1+gamma*exp(-beta*t))))
attr(S,"parvec") &lt;- c(kappa=10/1.5,gamma=9,beta=1)
lambda1 &lt;- function(tt){
	84*(1-tt)
}

# Optimal pricing policy assuming customers arrive singly:
X &lt;- xsolve(S=S,lambda=lambda1,gprob=1,tmax=1,qmax=5)
lambda2 &lt;- function(tt){
	36*(1-tt)
}
# Expected values if the customers actually arrive in groups, using the
# (sub-optimal) pricing policy based on the (erroneous) assumption that
# they arrive singly.  Note that the two scenarios are ``comparable'' in
# that the expected total number of customers is 42 in each case.
V &lt;- vsolve(S=S,lambda=lambda2,gprob=(5:1)/15,x=X$x,alpha=0.5)
</code></pre>

<hr>
<h2 id='xsolve'>
Optimal pricing policy
</h2><span id='topic+xsolve'></span>

<h3>Description</h3>

<p>Determines (by solving a coupled system of differential equations)
the optimal prices as functions of (residual) time for a
number perishable assets. Prices may be discrete or continuous.
For continuous prices, the price sensitivity function may either
be a smooth (twice differentiable) function or a function which
is piecewise linear in price.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   xsolve(S, lambda, gprob=1, tmax=NULL, qmax, prices=NULL, nout=300,
          type="sip", alpha=NULL, salval=0, epsilon=NULL,
          method="lsoda",verbInt=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xsolve_+3A_s">S</code></td>
<td>

<p>An expression, or list of expressions, or a function or list
of functions, specifying the price sensitivity functions
<code>S_j(x,t)</code>.  See <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_lambda">lambda</code></td>
<td>

<p>A function (of residual time <code>t</code> &mdash; see <code>tmax</code>) or
a positive constant, specifying the intensity of the (generally
inhomogeneous) Poisson process of arrival times of groups of
potential customers.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_gprob">gprob</code></td>
<td>

<p>A function (to calculate probabilities) or a numeric vector of 
probabilities determining the distribution of the size of
an arriving group of customers.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_tmax">tmax</code></td>
<td>

<p>The maximum residual time; think of this as being the initial time
at which the assets go on sale (with time <em>decreasing</em> to zero,
at which point the value of each asset drops to the &ldquo;salvage
value&rdquo; (<code>salval</code>), usually <code>0</code>).  The system of differential
equations is solved over the time interval [0,<code>tmax</code>].
See <b>Details</b>.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_qmax">qmax</code></td>
<td>

<p>The maximum number of assets available for sale, i.e. the number
of assets available at the starting (residual) time <code>tmax</code>.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_prices">prices</code></td>
<td>

<p>A numeric vector (with positive values) listing the possible
prices at which items may be offered for sale in the discrete
pricing scenario.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_nout">nout</code></td>
<td>

<p>The number of points at which values of the solution are to be
provided.  These are taken to be equispaced on
[0,<code>tmax</code>].
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_type">type</code></td>
<td>

<p>Scalar character string taking one of the two values <code>"sip"</code>
(singly indexed prices) and <code>"dip"</code> (doubly indexed prices).
In the <code>"dip"</code> case the price of the asset which is quoted
to the arriving group is allowed to depend upon the group size
(as well as upon (residual) time as well as on the number of
assets remaining for sale.  In the <code>"sip"</code> case the quoted
price does not depend upon group size.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_alpha">alpha</code></td>
<td>

<p>A numeric scalar between 0 and 1 specifying the probability that an
arriving group of size <code>j &gt; q</code> (where <code>q</code> is the number
of assets remaining for sale) will <em>consider</em> purchasing
(all of) these remaining assets.  It is irrelevant (and defaults
to 1 as a &ldquo;place holder&rdquo;) if customers always arrive singly.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_salval">salval</code></td>
<td>

<p>A (non-negative) numeric scalar specifying the &ldquo;salvage
value&rdquo; of an asset &mdash; i.e. the quantity to which the value of an
asset drops at residual time <code>t=0</code>.  Usually <code>salval</code>
is equal to 0.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_epsilon">epsilon</code></td>
<td>

<p>A numeric scalar used in determining the optimal price
in settings in which this involves maximizing over a discrete set.
See <b>Details</b>.  It defaults to <code>.Machine$double.eps^0.25</code>
in the case of discrete prices and to <code>.Machine$double.eps^0.5</code>
when the price sensitivity function is piecewise linear.
It is ignored if the price sensitivity function is smooth.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_method">method</code></td>
<td>

<p>Character string specified the solution method to be used
by the differential equation solver <code>ode()</code>.  There is
a fairly large number of possible methods.  See
<code><a href="deSolve.html#topic+ode">ode</a>()</code> for details.
</p>
</td></tr>
<tr><td><code id="xsolve_+3A_verbint">verbInt</code></td>
<td>

<p>A scalar value which controls &ldquo;verbosity&rdquo;.
If <code>verbInt &gt; 0</code> then a &ldquo;progress report&rdquo; is
printed every <code>verbInt</code> <em>seconds</em> (roughly).  That is
if the current value of <code>Sys.time()</code> is greater than or
equal to the value stored at the time of the last report, plus
<code>verbInt</code> seconds, then a new &ldquo;report&rdquo; is printed out.
If <code>verbInt</code> is less than or equal to 0 then the solution
process runs &ldquo;silently&rdquo;.  See section <b>Progress
Reports</b> for a bit more detail.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If prices are modelled as being continuous, and if the price
sensitivity function is differentiable, a coupled system
of differential equations for the optimal prices is solved.
If the prices are modelled as being discrete or if the price
sensitivity function is piecewise linear in price, then a
coupled system of differential equations for the expected
value of the stock is solved, with the optimal price being
determined at each step by maximizing over an appropriate finite
discrete set.  These differential equations are solved by the
<code><a href="deSolve.html#topic+ode">ode</a>()</code> function from the <code>deSolve</code>
package.
</p>
<p>The components of the argument <code>S</code> should be provided as
expressions when the price sensitivity functions are assumed to
be smooth, and these should be amenable to differentiation with
respect to <code>x</code> and <code>t</code> via the function <code>deriv3()</code>.
</p>
<p>Note that in general the expression or expressions will depend upon
a number of <em>parameters</em> as well as upon <code>x</code> and <code>t</code>.
The values of these parameters are specified via an attribute or
attributes.  If <code>S</code> is a (single) expression it has (must have)
an attribute called <code>parvec</code> which is a <em>named</em> vector of
parameter values.  If <code>S</code> is a list of expressions each entry
of the list has (must have) such an attribute.
</p>
<p>In the &ldquo;piecewise linear&rdquo; context <code>S</code> can be
specified <em>only</em> as a single function.  It is then assumed
that the price sensitivity function for a group of size <code>j</code>
is given by <code>S_j(x,t) = S(x,t)^j</code>.  Such piecewise linear
price sensitivity functions should be built using the function
<code><a href="#topic+buildS">buildS</a>()</code>.
</p>
<p>In the case of discrete prices the argument <code>S</code> must be a
function or list of functions specifying the price sensitivity
functions <code>S_j(x,t)</code>.  These functions need only be defined
for the prices listed in the <code>prices</code> argument.
</p>
<p>If <code>S</code> is a single expression or function, then
<code>S_j(x,t)</code> is taken to be this expression or function raised
to the power <code>j</code>.  If <code>S</code> is a list, then <code>S_j(x,t)</code>
is taken to be its <code>j</code>-th entry.
</p>
<p>In the case where argument <code>S</code> is a piecewise linear
price sensitivity function, the argument <code>tmax</code> is, if not
specified, taken to be the value of the corresponding attribute
of <code>S</code>.  In this setting, if <code>tmax</code> <em>is</em> specified
it must be less than or equal to the corresponding attribute
of <code>S</code>.
</p>
<p>For discrete prices and for piecewise linear price sensitivity
functions, determining the optimal price involves maximizing
expected values over finite discrete sets.  It can happen that the
location of the maximum can make a sudden &ldquo;jump&rdquo; from one
time step to the next, causing anomalous looking discontinuities
in the optimal price functions.  To avoid this, we check on the
change in the expected value at each of the possible new prices
as compared with that at the &ldquo;previous&rdquo; price.
</p>
<p>If the maximal &ldquo;improvement&rdquo; in expected value is less
than or equal to <code>epsilon</code> then the &ldquo;new&rdquo; price is
set equal to the previous value.  If the maximal improvement
is greater than <code>epsilon</code> then those values of price,
where the expected value is greater than the maximum value minus
<code>epsilon</code>, are considered and the one which is closest to
the previous price is chosen.
</p>
<p>If <code>epsilon</code> is set equal to a value less than or equal to
<code>0</code> then the smoothing strategy described above is dispensed
with. In this case the maximum is taken to be the first of the
(possibly) multiple maxima of the expected value.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The optimal pricing policy, chosen to maximize the expected
value of the remaining assets at any given time; an object of
class <code>flap</code> (&ldquo;function list for asset pricing&rdquo;).  (In
the case of discrete prices it also inherits from <code>pwc.flap</code>
(<code>pwc</code> stands for &ldquo;piecewise constant&rdquo;), and if
<code>type=="dip"</code> it also inherits from <code>di.flap</code>.)
If <code>type=="sip"</code> it has the form of a list of functions
<code>x_q(t)</code>, with <code>q</code> running from 1 to <code>qmax</code>
If <code>type=="dip"</code> if has the form of a list of functions
<code>x_qj(t)</code> with <code>q</code> running from 1 to <code>qmax</code> and
<code>j</code> running from 1 to <code>min(q,jmax)</code> where <code>jmax</code>
is the maximum group size.
</p>
<p>In the case of continuous prices these functions will be
continuous functions created by <code><a href="stats.html#topic+splinefun">splinefun</a>()</code>.  In the
case of discrete prices these functions will be piecewise constant
(of class <code>stepfun</code>) created by <code><a href="stats.html#topic+stepfun">stepfun</a>()</code>.
</p>
<p>Note that <code>x</code> has an <em>attribute</em> <code>qmax</code> specifying
the maximum number of assets available for sale, i.e. the number
of assets available at the starting (residual) time <code>tmax</code>.
Of course if <code>type=="sip"</code> then this attribute is simply
the length of <code>x</code>.  Note that if <code>type == "dip"</code> then
the entry <code>x[[i]]</code> is equal to the function <code>x_qj(t)</code>
where <code>i = (j-1)*(qmax - j/2) + q</code>.
</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>An object of class <code>flap</code> whose entries are (spline)
functions <code>v_q(t)</code> specifying the (optimal) expected value
of <code>q</code> assets at time <code>t</code> corresponding to the (optimal)
pricing policy <code>x</code>.
</p>
</td></tr>
<tr><td><code>vdot</code></td>
<td>
<p>An object of class <code>flap</code> whose entries are
the derivatives (with respect to <code>t</code>) of the functions
<code>v_q(t)</code> described above.  The values of these derivatives
are determined sequentially in the process of solving the system
of differential equations for the optimal pricing policy.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A substantial change was made to this package as of the change
of version number from 0.0-11 to 0.1-0.  Previously the differential
equations which arise were solved via a &ldquo;locally produced&rdquo;
roll-your-own Runge-Kutta procedure.  Now they are solved (in a
more sophisticated manner) using the package <code>deSolve</code>.  This
increases the solution speed by a factor of about 7.  There will
be (minor, it is to be hoped) numerical differences in solutions
produced from the same input.
</p>


<h3>Progress Reports</h3>

<p>The &ldquo;progress reports&rdquo; produced when <code>verbInt &gt; 0</code>
consist of rough estimates of the percentage of <code>[0,tmax]</code>
(the interval over which the differential equation is being solved)
remaining to be covered.  A rough estimate of the total elapsed
time since the solution process started is also printed out.
</p>
<p>Having &ldquo;progress reports&rdquo; printed out appears to have no
(or at worst negligible) impact on computation time.'
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
<a href="http://www.stat.auckland.ac.nz/~rolf">http://www.stat.auckland.ac.nz/~rolf</a>
</p>


<h3>References</h3>

<p>P. K. Banerjee, and T. R. Turner (2012).
A flexible model for the pricing of perishable assets.
<em>Omega</em> <b>40</b>:5, 533&ndash;540.
DOI https://doi.org/10.1016/j.omega.2011.10.001
</p>
<p>Rolf Turner, Pradeep Banerjee and Rayomand Shahlori (2014).  Optimal
Asset Pricing.  <em>Journal of Statistical Software</em> <b>58</b>:11, 1&ndash;25.
DOI https://doi.org/10.18637/jss.v058.i11
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vsolve">vsolve</a>()</code>, <code><a href="#topic+plot.AssetPricing">plot.AssetPricing</a>()</code>,
<code><a href="#topic+buildS">buildS</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# In these examples "qmax" has been set equal to 5 which is
# an unrealistically low value for the total number of assets.
# This is done so as to reduce the time for package checking on CRAN.
#
# Smooth price sensitivity function.
S &lt;- expression(exp(-kappa*x/(1+gamma*exp(-beta*t))))
attr(S,"parvec") &lt;- c(kappa=10/1.5,gamma=9,beta=1)

# Optimal pricing policy assuming customers arrive singly:
lambda1 &lt;- function(tt){
	84*(1-tt)
}
X1 &lt;- xsolve(S=S,lambda=lambda1,gprob=1,tmax=1,qmax=5,
             type="sip",verbInt=5)
# Optimal pricing policy assuming customers arrive in groups of
# size up to 5, with group size probabilities 1/3, 4/15, 1/5, 2/15,
# and 1/15 respectively.
lambda2 &lt;- function(tt){
	36*(1-tt)
}
X2 &lt;- xsolve(S=S,lambda=lambda2,gprob=(5:1)/15,tmax=1,qmax=5,
             type="sip", alpha=0.5,verbInt=5)

# Note that the intensity functions lambda1() and lambda2() are
# such that the expected total number of customers is 42 in each case.

# Discrete prices:
lambda3 &lt;- function(t){42}
S      &lt;- function(x,t){
                e &lt;- numeric(2)
                e[x==1] &lt;- exp(-2*t)
                e[x==0.6] &lt;- 1.0
                e
          }
X3 &lt;- xsolve(S=S,lambda=lambda3,gprob=1,tmax=1,qmax=5,prices=c(1,0.6),
             type="sip",verbInt=5)

# Piecewise linear price sensitivity function.
#
# Take S as in the example for buildS.
# This takes a loonnngggg time; the procedure is slow
# in the piecewise linear setting.
## Not run: 
l0 &lt;- get("lambda",envir=environment(get("alpha",envir=environment(S))[[1]]))
lambda4 &lt;- function(t){apply(l0(t),1,sum)}
X4 &lt;- xsolve(S=S,lambda=lambda4,gprob=(5:1)/15,qmax=30,type="sip",
                   alpha=0.5,verbInt=20)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
