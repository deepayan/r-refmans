<!DOCTYPE html><html><head><title>Help for package ivtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ivtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ah'>
<p>Fitting semiparametric additive hazards regression models.</p></a></li>
<li><a href='#confint.ivmod'>
<p>Confidence interval</p></a></li>
<li><a href='#estfun'>
<p>Computes the estimating function sum for <code>"ivmod"</code></p>
objects, fitted with <code>estmethod="g"</code>.</a></li>
<li><a href='#ivah'>
<p>Instrumental variable estimation of the causal exposure effect in</p>
additive hazards (AH) models</a></li>
<li><a href='#ivbounds'>
<p>Bounds for counterfactual outcome probabilities in instrumental variables scenarios</p></a></li>
<li><a href='#ivcoxph'>
<p>Instrumental variable estimation of the causal exposure effect in</p>
Cox proportional hazards (PH) models</a></li>
<li><a href='#ivglm'>
<p>Instrumental variable estimation of the causal exposure effect in</p>
generalized linear models</a></li>
<li><a href='#plot.estfun'>
<p>Plots sums of estimating functions.</p></a></li>
<li><a href='#plot.ivah'>
<p>Plots result of G-estimation in causal AH model.</p></a></li>
<li><a href='#print.ivmod'>
<p>Prints output of instrumental variable estimation</p></a></li>
<li><a href='#print.summary.ivbounds'>
<p>Prints summary of instrumental variable bounds</p></a></li>
<li><a href='#print.summary.ivmod'>
<p>Prints summary of instrumental variable estimation</p></a></li>
<li><a href='#summary.ivbounds'>
<p>Summarizes instrumental variable estimation</p></a></li>
<li><a href='#summary.ivmod'>
<p>Summarizes instrumental variable estimation</p></a></li>
<li><a href='#VitD'><p>Data from a cohort study on Vitamin D and mortality.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Instrumental Variables</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Arvid Sjolander, Elisabeth Dahlqwist, Torben Martinussen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arvid Sjolander &lt;arvid.sjolander@ki.se&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains tools for instrumental variables estimation. Currently, non-parametric bounds, two-stage estimation and G-estimation are implemented. Balke, A. and Pearl, J. (1997) &lt;<a href="https://doi.org/10.2307%2F2965583">doi:10.2307/2965583</a>&gt;, Vansteelandt S., Bowden J., Babanezhad M., Goetghebeur E. (2011) &lt;<a href="https://doi.org/10.1214%2F11-STS360">doi:10.1214/11-STS360</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, data.table, numDeriv, nleqslv, survival, ahaz, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-24 07:19:06 UTC; arvsjo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-24 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ah'>
Fitting semiparametric additive hazards regression models. 
</h2><span id='topic+ah'></span>

<h3>Description</h3>

<p><code>ah</code> is a wrapper around the <code>ahaz</code> function in the <span class="pkg">ahaz</span>
package, with a more user-friendly and standard interface. Refer to the 
manual for <code>ahaz</code> for details. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ah(formula, data, weights, robust=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ah_+3A_formula">formula</code></td>
<td>

<p>an object of class &quot;formula&quot;: a symbolic description of the model to be fitted. 
</p>
</td></tr>
<tr><td><code id="ah_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables in the model. 
</p>
</td></tr>
<tr><td><code id="ah_+3A_weights">weights</code></td>
<td>

<p>an optional vector of prior weights to be used in the fitting process. 
</p>
</td></tr>
<tr><td><code id="ah_+3A_robust">robust</code></td>
<td>

<p>robust calculation of variance; see manual for <code>ahaz</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>See manual for <code>ahaz</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"ah"</code> is a list containing the same elements as 
an object of class <code>"ahaz"</code>, plus 
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>

<p>the formula argument.
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>

<p>a named vector of estimated coefficients. 
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>the variance-covariance matrix for the estimated coefficients.  
</p>
</td></tr>
<tr><td><code>incl</code></td>
<td>

<p>the <code>ahaz</code> function does not allow for missing data. Thus, if <code>data</code>
contains rows with missing data on any of the variables in the model, then 
these rows are excluded before calling <code>ahaz</code>. <code>incl</code> is a vector 
containing the rownames of those rows that are included in the analysis, 
that is, the rows with no missing data on any of the variables in the model.          
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>ahaz</code> function does not allow for ties. Thus, before calling 
<code>ah</code> any ties have to be manually broken.  
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>


<h3>References</h3>

<p>Lin D.Y., Ying Z. (1994). Semiparametric analysis of the additive risk model. 
<em>Biometrika</em> <b>81</b>(1), 61-71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ahaz)

##This example is adapted from the example given for the ahaz function 
##in the ahaz package 

data(sorlie)

# Break ties
set.seed(10101)
sorlie$time &lt;- sorlie$time+runif(nrow(sorlie))*1e-2

# Fit additive hazards model 
fit &lt;- ah(formula=Surv(time, status)~X13+X14+X15+X16+X17+X18+X19+X20+X21+X22, 
  data=sorlie)
summary(fit)


</code></pre>

<hr>
<h2 id='confint.ivmod'>
Confidence interval
</h2><span id='topic+confint.ivmod'></span>

<h3>Description</h3>

<p>This is a <code>confint</code> method for class <code>"ivmod"</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivmod'
confint(object, parm, level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.ivmod_+3A_object">object</code></td>
<td>

<p>an object of class <code>"ivmod"</code>.  
</p>
</td></tr> 
<tr><td><code id="confint.ivmod_+3A_parm">parm</code></td>
<td>

<p>not used.
</p>
</td></tr>
<tr><td><code id="confint.ivmod_+3A_level">level</code></td>
<td>

<p>the coverage probability of the confidence intervals. 
</p>
</td></tr>
<tr><td><code id="confint.ivmod_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>

<hr>
<h2 id='estfun'>
Computes the estimating function sum for <code>"ivmod"</code>  
objects, fitted with <code>estmethod="g"</code>.
</h2><span id='topic+estfun'></span>

<h3>Description</h3>

<p><code>estfun</code> computes the estimating function <code class="reqn">H(\psi)</code>
for a <code>"ivmod"</code> object, fitted with <code>estmethod="g"</code>, 
for a range of values of <code class="reqn">\psi</code>. The <code>estfun</code> is not implemented 
for <code>"ivah"</code> objects, since G-estimation in additive hazards models
is based on a recursive estimation technique, and not standard estimating equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estfun(object, lower, upper, step)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estfun_+3A_object">object</code></td>
<td>

<p>an object of class <code>"ivmod"</code>, fitted with <code>estmethod="g"</code>.   
</p>
</td></tr>
<tr><td><code id="estfun_+3A_lower">lower</code></td>
<td>

<p>an optional vector of lower values for <code class="reqn">\psi</code>. Defaults to <code class="reqn">\psi-0.5</code>. 
</p>
</td></tr>
<tr><td><code id="estfun_+3A_upper">upper</code></td>
<td>

<p>an optional vector of upper values for <code class="reqn">\psi</code>. Defaults to <code class="reqn">\psi+0.5</code>. 
</p>
</td></tr>
<tr><td><code id="estfun_+3A_step">step</code></td>
<td>

<p>an optional vector of steps between <code>lower</code> and <code>upper</code>. Defaults to 0.01
for each element of <code class="reqn">\psi</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p><code>estfun</code> may be useful for visual inspection of the estimating 
function, to make sure that a solution to the estimating equation 
</p>
<p style="text-align: center;"><code class="reqn">H(\psi)=0</code>
</p>

<p>was found, see &lsquo;Examples&rsquo;. For the <code class="reqn">i</code>:th element of <code class="reqn">\psi</code>, the estimating
function sum is computed for a range of values within (<code>lower[i]</code>, <code>upper[i]</code>), at the 
G-estimate of the remaining elements of <code class="reqn">\psi</code>.  
</p>


<h3>Value</h3>

<p>An object of class <code>"estfun"</code> is a list containing 
</p>
<table>
<tr><td><code>f</code></td>
<td>

<p>a named list of matricies; one matrix for each element of <code class="reqn">\psi</code>. 
The first column of the <code class="reqn">i</code>:th matrix contains the values for the <code class="reqn">i</code>:th
element of <code class="reqn">\psi</code> at which the estimating function sum is computed, the 
second column contains the values of the estimating function sum. 
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>the G-estimate of <code class="reqn">\psi</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>


<h3>References</h3>

<p>Burgess S, Granell R, Palmer TM, Sterne JA, Didelez V. (2014). 
Lack of identification in semiparametric instrumental variable models with 
binary outcomes. <em>American Journal of Epidemiology</em> <b>180</b>(1), 111-119.
</p>
<p>Vansteelandt S., Bowden J., Babanezhad M., Goetghebeur E. (2011). 
On instrumental variables estimation of causal odds ratios.
<em>Statistical Science</em> <b>26</b>(3), 403-422.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(9)

##Note: the parameter values in the examples below are chosen to make 
##Y0 independent of Z, which is necessary for Z to be a valid instrument.

n &lt;- 1000
psi0 &lt;- 0.5
psi1 &lt;- 0.2

##---Example 1: linear model and interaction between X and L---

L &lt;- rnorm(n)
Z &lt;- rnorm(n, mean=L)
X &lt;- rnorm(n, mean=Z)
m0 &lt;- X-Z+L 
Y &lt;- rnorm(n, mean=psi0*X+psi1*X*L+m0)
data &lt;- data.frame(L, Z, X, Y)

#G-estimation
fitZ.L &lt;- glm(formula=Z~L, data=data)
fitIV &lt;- ivglm(estmethod="g", X="X", Y="Y", fitZ.L=fitZ.L, data=data, 
  formula=~L, link="identity")
summary(fitIV)
H &lt;- estfun(fitIV)
plot(H)

##---Example 2: logistic model and no covariates--- 

Z &lt;- rbinom(n, 1, 0.5)
X &lt;- rbinom(n, 1, 0.7*Z+0.2*(1-Z)) 
m0 &lt;- plogis(1+0.8*X-0.39*Z)
Y &lt;- rbinom(n, 1, plogis(psi0*X+log(m0/(1-m0)))) 
data &lt;- data.frame(Z, X, Y)

#G-estimation
fitZ.L &lt;- glm(formula=Z~1, data=data)
fitY.LZX &lt;- glm(formula=Y~X+Z+X*Z, family="binomial", data=data)
fitIV &lt;- ivglm(estmethod="g", X="X", fitZ.L=fitZ.L, fitY.LZX=fitY.LZX, 
  data=data, link="logit")
summary(fitIV)
H &lt;- estfun(fitIV)
plot(H)

</code></pre>

<hr>
<h2 id='ivah'>
Instrumental variable estimation of the causal exposure effect in 
additive hazards (AH) models 
</h2><span id='topic+ivah'></span>

<h3>Description</h3>

<p><code>ivah</code> performs instrumental variable estimation of the causal exposure effect in 
AH models with individual-level data. Below, <code class="reqn">Z</code>, <code class="reqn">X</code>, and 
<code class="reqn">T</code> are the instrument, the exposure, and the outcome, respectively. 
<code class="reqn">L</code> is a vector of covariates that we wish to control for in the analysis; 
these would typically be confounders for the instrument and the outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivah(estmethod, X, T, fitZ.L=NULL, fitX.LZ=NULL, fitT.LX=NULL, data,  
  ctrl=FALSE, clusterid=NULL, event, max.time, max.time.psi, n.sim=100, 
  vcov.fit=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivah_+3A_estmethod">estmethod</code></td>
<td>

<p>a string specifying the desired estimation method; either <code>"ts"</code> for two-stage
estimation, or <code>"g"</code> for G-estimation. 
</p>
</td></tr>
<tr><td><code id="ivah_+3A_x">X</code></td>
<td>

<p>a string specifying the name of the exposure <code class="reqn">X</code> in <code>data</code>. This is not needed if 
<code>fitX.LZ</code> is specified.
</p>
</td></tr>
<tr><td><code id="ivah_+3A_t">T</code></td>
<td>

<p>a string specifying the name of the follow-up time <code class="reqn">T</code> in <code>data</code>. This is not needed if 
<code>fitT.LZ</code> is specified.
</p>
</td></tr>
<tr><td><code id="ivah_+3A_fitz.l">fitZ.L</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. This is a fitted GLM for <code class="reqn">E(Z|L)</code>. If there are no covariates,
then <code>fitZ.L</code> may be specified as a model with an intercept only. This argument
is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr>
<tr><td><code id="ivah_+3A_fitx.lz">fitX.LZ</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. This is a fitted GLM for <code class="reqn">E(X|L,Z)</code>. This argument
is not used when <code>estmethod="g"</code>. 
</p>
</td></tr>
<tr><td><code id="ivah_+3A_fitt.lx">fitT.LX</code></td>
<td>

<p>If <code>estmethod="ts"</code>, then this is an object of class <code>"ah"</code>, as 
returned by the <code>ah</code> function in the <span class="pkg">ivtools</span> package. 
In this case it is a fitted AH model for <code class="reqn">\lambda(t|L,X)</code>. 
This argument is not used when <code>estmethod="g"</code>.  
</p>
</td></tr> 
<tr><td><code id="ivah_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables in the model. The covariates, instrument,
exposure and outcome can have arbitrary names, e.g. they don't need to 
be called <code>L</code>, <code>Z</code>, <code>X</code> and <code>T</code>.
</p>
</td></tr>  
<tr><td><code id="ivah_+3A_ctrl">ctrl</code></td>
<td>

<p>logical. Should the control function <code class="reqn">R=X-\hat{X}</code> be used when re-fitting 
<code>fitY</code>? This argument is not used when <code>estmethod="g"</code>.   
</p>
</td></tr>
<tr><td><code id="ivah_+3A_clusterid">clusterid</code></td>
<td>

<p>an optional string containing the name of a cluster identification variable when 
data are clustered. Specifying <code>clusterid</code> corrects the standard errors
but does not affect the estimates. This argument is not used when 
<code>estmethod="g"</code>, since correction for clustered data is currently not implemented
for G-estimation. 
</p>
</td></tr>
<tr><td><code id="ivah_+3A_event">event</code></td>
<td>

<p>a string specifying the name of the status indicator, 0=&quot;no event&quot;, 1=&quot;event&quot;.
This argument is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr>
<tr><td><code id="ivah_+3A_max.time">max.time</code></td>
<td>

<p>optional follow-up for estimating <code class="reqn">B(t)</code> with G-estimation. 
Defaults to maximal observed follow-up time in <code>data</code>.
This argument is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr>
<tr><td><code id="ivah_+3A_max.time.psi">max.time.psi</code></td>
<td>

<p>optional follow-up for estimating <code class="reqn">\psi</code> with G-estimation. 
Defaults to maximal observed follow-up time in <code>data</code>.
This argument is not used when <code>estmethod="ts"</code>.
</p>
</td></tr>
<tr><td><code id="ivah_+3A_n.sim">n.sim</code></td>
<td>

<p>optional number of resamplings for testing goodness-of-fit of constant effects model
for G-estimation. Defaults to 100. This argument is not used when <code>estmethod="ts"</code>.  
</p>
</td></tr>
<tr><td><code id="ivah_+3A_vcov.fit">vcov.fit</code></td>
<td>

<p>logical. Should the variance-covariance matrix be computed? 
</p>
</td></tr>
<tr><td><code id="ivah_+3A_...">...</code></td>
<td>

<p>optional arguments passed on to the <code>nleqslv</code> function, which is used to 
solve the estimating equations when <code>estmethod="g"</code>. See the help pages 
for <code>nleqslv</code>. This argument is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr> 
</table>


<h3>Details</h3>

 
<p>The <code>ivah</code> estimates different parameters, depending on whether
<code>estmethod="ts"</code> or <code>estmethod="g"</code>. If <code>estmethod="ts"</code>, then 
<code>ivah</code> uses two-stage estimation to estimate the parameter <code class="reqn">\psi</code> in the causal AH model
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t|L,Z,X)-\lambda_0(t|L,Z,X)=m^T(L)X\psi.</code>
</p>

<p>Here, <code class="reqn">\lambda_0(t|L,Z,X)</code> is counterfactual hazard function,
had the exposure been set to 0. The vector function <code class="reqn">m(L)</code> contains interaction terms
between <code class="reqn">L</code> and <code class="reqn">X</code>. These are specified 
implicitly through the model <code>fitY</code>. The model <code>fitX.LZ</code> is used to 
construct predictions <code class="reqn">\hat{X}=\hat{E}(X|L,Z)</code>. These predictions are 
subsequently used to re-fit the model <code>fitY</code>, with <code class="reqn">X</code> replaced with 
<code class="reqn">\hat{X}</code>. The obtained coefficient(s) for <code class="reqn">X</code> is the two-stage 
estimator of <code class="reqn">\psi</code>.  
</p>
<p>If <code>estmethod="g"</code>, then <code>ivah</code> uses G-estimation to estimate the function 
<code class="reqn">B(t)</code> in the causal AH model
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t|L,Z,X)-\lambda_0(t|L,Z,X)=XdB(t).</code>
</p>
 
<p>It also delivers an estimate of <code class="reqn">dB(t)</code> assuming that this function is 
constant across time (=<code class="reqn">\psi</code>).
</p>


<h3>Value</h3>

<p><code>ivah</code> returns an object of class <code>"ivah"</code>, which inherits from 
class <code>"ivmod"</code>. An object of class <code>"ivah"</code> is a list containing 
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td></tr>
<tr><td><code>input</code></td>
<td>

<p><code>input</code> is a list containing all input arguments     
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>a vector containing the estimate of <code class="reqn">\psi</code>.  
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>the variance-covariance matrix for the estimate of <code class="reqn">\psi</code>, 
obtained with the sandwich formula. 
</p>
</td></tr>
<tr><td><code>estfunall</code></td>
<td>

<p>a matrix of all subject-specific contributions to the estimating functions used in the estimation process.
One row for each subject, one column for each parameter. If <code>estmethod="ts"</code>,
then the first columns correspond to the parameters estimated by <code>fitX.LZ</code>, and
the last columns correspond to the parameters estimated by the re-fitted model 
<code>fitY</code>. If <code>estmethod="g"</code>, then <code>estfunall</code> is NULL. 
</p>
</td></tr>
<tr><td><code>d.estfun</code></td>
<td>

<p>the jacobian matrix of <code>colMeans(estfun)</code>. If <code>estmethod="g"</code>, 
then <code>d.estfun</code> is NULL.    
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>logical. Was a solution found to the estimating equations?   
</p>
</td></tr>
<tr><td><code>fitY</code></td>
<td>

<p>the re-fitted model <code>fitY</code> used in the estimation process when <code>estmethod="ts"</code>.
This element is NULL when <code>estmethod="g"</code>.  
</p>
</td></tr>
<tr><td><code>stime</code></td>
<td>

<p>the ordered event times within (0,max.time). This element is NULL when <code>estmethod="ts"</code>. 
</p>
</td></tr>
<tr><td><code>B</code></td>
<td>

<p>the estimate of <code class="reqn">B(t)</code>. This element is NULL when <code>estmethod="ts"</code>.   
</p>
</td></tr>
<tr><td><code>se_B</code></td>
<td>

<p>the standard error of the estimate of <code class="reqn">B(t)</code>. This element is NULL when <code>estmethod="ts"</code>.
</p>
</td></tr>
<tr><td><code>pval_0</code></td>
<td>

<p>p-value corresponding to supremum test of the null <code class="reqn">B(t)=0</code>. 
This element is NULL when <code>estmethod="ts"</code>.
</p>
</td></tr>
<tr><td><code>eps_B</code></td>
<td>

<p>the iid-decomposition of <code class="reqn">\sqrt{n}(\hat{B}(t) - B(t))</code>. 
This element is NULL when <code>estmethod="ts"</code>.
</p>
</td></tr>
<tr><td><code>pval_psi</code></td>
<td>

<p>p-value corresponding to the null <code class="reqn">\psi=0</code>. 
This element is NULL when <code>estmethod="ts"</code>.
</p>
</td></tr>
<tr><td><code>pval_GOF_sup</code></td>
<td>

<p>p-value corresponding to supremum test of the null <code class="reqn">B(t)=\psi</code>.  
This element is NULL when <code>estmethod="ts"</code>.
</p>
</td></tr>
<tr><td><code>pval_GOF_CvM</code></td>
<td>

<p>as pval_GOF_sup but now based on the Cramer Von Mises test statistic.  
This element is NULL when <code>estmethod="ts"</code>.
</p>
</td></tr>
<tr><td><code>GOF.resamp</code></td>
<td>

<p>a matrix with first row the ordered jump times in (0,max.time.bet),
second row the observed test process, and the remaining rows are 
50 processes sampled under the null. 
This element is NULL when <code>estmethod="ts"</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>ivah</code> allows for weights. However, these are defined implicitly 
through the input models. Thus, when models are used as input to <code>ivah</code>, 
these models have to be fitted with the same weights.
</p>
<p>Left-truncation and correction of standard errors for clustered data are currently not
implemented when <code>estmethod="g"</code>.     
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander and Torben Martinussen. 
</p>


<h3>References</h3>

<p>Martinussen T., Vansteelandt S., Tchetgen Tchetgen E.J., Zucker D.M. (2017). 
Instrumental variables estimation of exposure effects on a time-to-event 
endpoint using structural cumulative survival models. 
<em>Epidemiology</em> <b>73</b>(4): 1140-1149.
</p>
<p>Sjolander A., Martinussen T. (2019). Instrumental variable estimation with the R package ivtools.
<em>Epidemiologic Methods</em> <b>8</b>(1), 1-20.
</p>
<p>Tchetgen Tchetgen E.J., Walter S., Vansteelandt S., Martinussen T., Glymour M. (2015).
Instrumental variable estimation in a survival context. <em>Epidemiology</em> <b>26</b>(3): 402-410. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ahaz)

set.seed(9)

n &lt;- 1000
psi0 &lt;- 0.2
psi1 &lt;- 0.0

U &lt;- runif(n)
L &lt;- runif(n)
Z &lt;- rbinom(n, 1, plogis(-0.5+L)) 
X &lt;- runif(n, min=Z+U, max=2+Z+U)
T &lt;- rexp(n, rate=psi0*X+psi1*X*L+0.2*U+0.2*L)
C &lt;- 5  #administrative censoring at t=5
d &lt;- as.numeric(T&lt;C)
T &lt;- pmin(T, C) 
data &lt;- data.frame(L, Z, X, T, d)
#break ties
data$T &lt;- data$T+rnorm(n=nrow(data), sd=0.001)

#two-stage estimation
fitX.LZ &lt;- glm(formula=X~Z+L, data=data)
fitT.LX &lt;- ah(formula=Surv(T, d)~X+L+X*L, data=data)
fitIV &lt;- ivah(estmethod="ts", fitX.LZ=fitX.LZ, fitT.LX=fitT.LX, data=data, 
  ctrl=TRUE)
summary(fitIV)

#G-estimation
fitZ.L &lt;- glm(formula=Z~L, family="binomial", data=data)
fitIV &lt;- ivah(estmethod="g", X="X", T="T", fitZ.L=fitZ.L, data=data,  
  event="d", max.time=4, max.time.psi=4, n.sim=100)
summary(fitIV)
plot(fitIV)



</code></pre>

<hr>
<h2 id='ivbounds'>
Bounds for counterfactual outcome probabilities in instrumental variables scenarios 
</h2><span id='topic+ivbounds'></span>

<h3>Description</h3>

<p><code>ivbounds</code> computes non-parametric bounds for counterfactual outcome probabilities
in instrumental variables scenarios. Let <code class="reqn">Y</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> 
be the outcome, exposure, and instrument, respectively. <code class="reqn">Y</code> and <code class="reqn">X</code> must be binary, 
whereas <code class="reqn">Z</code> can be either binary or ternary. 
Ternary instruments are common in, for instance, Mendelian randomization. 
Let <code class="reqn">p(Y_x=1)</code> be the counterfactual probability of the outcome, had all 
subjects been exposed to level <code class="reqn">x</code>. <code>ivbounds</code> computes bounds for the 
counterfactuals probabilities <code class="reqn">p(Y_1=1)</code> and <code class="reqn">p(Y_0=1)</code>. Below, we define
<code class="reqn">p_{yx.z}=p(Y=y,X=x|Z=x)</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivbounds(data, Z, X, Y, monotonicity=FALSE, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivbounds_+3A_data">data</code></td>
<td>

<p>either a data frame containing the variables in the model, or a named vector  
<code>(p00.0,...,p11.1)</code> when <code class="reqn">Z</code> is binary, or 
a named vector <code>(p00.0,...,p11.2)</code> when <code class="reqn">Z</code> is ternary.
</p>
</td></tr>
<tr><td><code id="ivbounds_+3A_z">Z</code></td>
<td>

<p>a string containing the name of the instrument <code class="reqn">Z</code> in <code>data</code> if
<code>data</code> is a data frame. In this case <code class="reqn">Z</code> has to be coded as (0,1) when
binary, and coded as (0,1,2) when ternary. <code>Z</code> is not specified if 
<code>data</code> is a vector of probabilities.  
</p>
</td></tr>
<tr><td><code id="ivbounds_+3A_x">X</code></td>
<td>

<p>a string containing the name of the exposure <code class="reqn">X</code> in <code>data</code> if
<code>data</code> is a data frame. In this case <code class="reqn">X</code> has to be coded as (0,1). 
<code>X</code> is not specified if <code>data</code> is a vector of probabilities. 
</p>
</td></tr>
<tr><td><code id="ivbounds_+3A_y">Y</code></td>
<td>

<p>a string containing the name of the outcome <code class="reqn">Y</code> in <code>data</code> if
<code>data</code> is a data frame. In this case <code class="reqn">Y</code> has to be coded as (0,1). 
<code>Y</code> is not specified if <code>data</code> is a vector of probabilities. 
</p>
</td></tr>
<tr><td><code id="ivbounds_+3A_monotonicity">monotonicity</code></td>
<td>

<p>logical. It is sometimes realistic to make the monotonicity assumption 
<code class="reqn">z \geq z' \Rightarrow X_z \geq X_{z'}</code>. Should the bounds be computed 
under this assumption?
</p>
</td></tr>
<tr><td><code id="ivbounds_+3A_weights">weights</code></td>
<td>

<p>an optional vector of &lsquo;prior weights&rsquo; to be used in the fitting process. 
Should be NULL or a numeric vector. Only applicable if <code>data</code> is 
a data frame.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ivbounds</code> uses linear programming techniques to bound the counterfactual probabilities
<code class="reqn">p(Y_1=1)</code> and <code class="reqn">p(Y_0=1)</code>. Bounds for a causal effect, defined as a contrast between these,
are obtained by plugging in the bounds for <code class="reqn">p(Y_1=1)</code> and <code class="reqn">p(Y_0=1)</code> into the 
contrast. For instance, bounds for the causal risk difference <code class="reqn">p(Y_1=1)-p(Y_0=1)</code>
are obtained as <code class="reqn">[min\{p(Y_1=1)\}-max\{p(Y_0=1)\},max\{p(Y_1=1)\}-min\{p(Y_0=1)\}]</code>.
In addition to the bounds, <code>ivbounds</code> evaluates the IV inequality
</p>
<p style="text-align: center;"><code class="reqn">\max\limits_{x}\sum_{y}\max\limits_{z}p_{yx.z}\leq 1.</code>
</p>
 


<h3>Value</h3>

<p>An object of class <code>"ivbounds"</code> is a list containing 
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td></tr>
<tr><td><code>p0</code></td>
<td>

<p>a named vector with elements <code>"min"</code> and <code>"max"</code>, containing the 
evaluated lower and upper bounds for <code class="reqn">p(Y_0=1)</code>, respectively. 
</p>
</td></tr>
<tr><td><code>p1</code></td>
<td>

<p>a named vector with elements <code>"min"</code> and <code>"max"</code>, containing the 
evaluated lower and upper bounds for <code class="reqn">p(Y_1=1)</code>, respectively. 
</p>
</td></tr>
<tr><td><code>p0.symbolic</code></td>
<td>

<p>a named vector with elements <code>"min"</code> and <code>"max"</code>, containing the 
lower and upper bounds for <code class="reqn">p(Y_0=1)</code>, respectively, on a symbolic form
(i.e. as strings). 
</p>
</td></tr>
<tr><td><code>p1.symbolic</code></td>
<td>

<p>a named vector with elements <code>"min"</code> and <code>"max"</code>, containing the 
lower and upper bounds for <code class="reqn">p(Y_1=1)</code>, respectively, on a symbolic form
(i.e. as strings). 
</p>
</td></tr>
<tr><td><code>IVinequality</code></td>
<td>

<p>logical. Does the IV inequality hold?  
</p>
</td></tr>
<tr><td><code>conditions</code></td>
<td>

<p>a character vector containing the violated condiations, if <code>IVinequality=FALSE</code>.  
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>


<h3>References</h3>

<p>Balke, A. and Pearl, J. (1997). <em>Bounds on treatment effects from studies with imperfect compliance</em>.
<em>Journal of the American Statistical Association</em> <b>92</b>(439), 1171-1176. 
</p>
<p>Sjolander A., Martinussen T. (2019). Instrumental variable estimation with the R package ivtools.
<em>Epidemiologic Methods</em> <b>8</b>(1), 1-20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Vitamin A example from Balke and Pearl (1997).
n000 &lt;- 74
n001 &lt;- 34
n010 &lt;- 0
n011 &lt;- 12
n100 &lt;- 11514
n101 &lt;- 2385
n110 &lt;- 0
n111 &lt;- 9663
n0 &lt;- n000+n010+n100+n110
n1 &lt;- n001+n011+n101+n111

#with data frame...
data &lt;- data.frame(Y=c(0,0,0,0,1,1,1,1), X=c(0,0,1,1,0,0,1,1), 
  Z=c(0,1,0,1,0,1,0,1))
n &lt;- c(n000, n001, n010, n011, n100, n101, n110, n111)
b &lt;- ivbounds(data=data, Z="Z", X="X", Y="Y", weights=n)
summary(b)

#...or with vector of probabilities
p &lt;- n/rep(c(n0, n1), 4)
names(p) &lt;- c("p00.0", "p00.1", "p01.0", "p01.1", 
  "p10.0", "p10.1", "p11.0", "p11.1") 
b &lt;- ivbounds(data=p)
summary(b)



</code></pre>

<hr>
<h2 id='ivcoxph'>
Instrumental variable estimation of the causal exposure effect in 
Cox proportional hazards (PH) models 
</h2><span id='topic+ivcoxph'></span>

<h3>Description</h3>

<p><code>ivcoxph</code> performs instrumental variable estimation of the causal exposure effect in 
Cox PH models with individual-level data. Below, <code class="reqn">Z</code>, <code class="reqn">X</code>, and 
<code class="reqn">T</code> are the instrument, the exposure, and the outcome, respectively. 
<code class="reqn">L</code> is a vector of covariates that we wish to control for in the analysis; 
these would typically be confounders for the instrument and the outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivcoxph(estmethod, X, fitZ.L=NULL, fitX.LZ=NULL, fitX.L=NULL, fitT.LX=NULL, 
  fitT.LZX=NULL, data, formula=~1, ctrl=FALSE, clusterid=NULL, t=NULL, 
  vcov.fit=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivcoxph_+3A_estmethod">estmethod</code></td>
<td>

<p>a string specifying the desired estimation method; either <code>"ts"</code> for two-stage
estimation, or <code>"g"</code> for G-estimation. 
</p>
</td></tr>
<tr><td><code id="ivcoxph_+3A_x">X</code></td>
<td>

<p>a string specifying the name of the exposure <code class="reqn">X</code> in <code>data</code>. This 
is not needed if <code>fitX.LZ</code> is specified. 
</p>
</td></tr>
<tr><td><code id="ivcoxph_+3A_fitz.l">fitZ.L</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. This is a fitted GLM for <code class="reqn">E(Z|L)</code>. If there are no covariates,
then <code>fitZ.L</code> may be specified as a model with an intercept only. This argument
is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr>
<tr><td><code id="ivcoxph_+3A_fitx.lz">fitX.LZ</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. This is a fitted GLM for <code class="reqn">E(X|L,Z)</code>. 
</p>
</td></tr>
<tr><td><code id="ivcoxph_+3A_fitx.l">fitX.L</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. This is a fitted GLM for <code class="reqn">E(X|L)</code>. If there are no covariates,
then <code>fitX.L</code> may be specified as a model with an intercept only. This argument
is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr>
<tr><td><code id="ivcoxph_+3A_fitt.lx">fitT.LX</code></td>
<td>

<p>an object of class <code>"coxph"</code>, as 
returned by the <code>coxph</code> function in the <span class="pkg">survival</span> package. 
This is a fitted Cox PH model for <code class="reqn">\lambda(t|L,X)</code>. 
This argument is not used when <code>estmethod="g"</code>.  
</p>
</td></tr> 
<tr><td><code id="ivcoxph_+3A_fitt.lzx">fitT.LZX</code></td>
<td>

<p>either an object of class <code>"coxph"</code> 
or an object of class <code>"survfit"</code>, as returned by the <code>coxph</code> function 
in the <span class="pkg">survival</span> package. This is a fitted Cox PH model for 
<code class="reqn">\lambda(t|L,Z,X)</code> or a non-parametric model for <code class="reqn">S(t|L,Z,X)</code>,
respectively. This argument is not used when <code>estmethod="ts"</code>.  
</p>
</td></tr> 
<tr><td><code id="ivcoxph_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables in the model. The covariates, instrument,
exposure and outcome can have arbitrary names, e.g. they don't need to 
be called <code>L</code>, <code>Z</code>, <code>X</code> and <code>T</code>.
</p>
</td></tr>  
<tr><td><code id="ivcoxph_+3A_formula">formula</code></td>
<td>

<p>an object of class <code>"formula"</code>, with no left-hand side. This specifies
the causal interaction terms <code class="reqn">m(L)</code>; see &lsquo;Details&rsquo;. Defaults to <code>~1</code>, i.e. 
main effect only. This argument is not used when <code>estmethod="ts"</code>.  
</p>
</td></tr>
<tr><td><code id="ivcoxph_+3A_ctrl">ctrl</code></td>
<td>

<p>logical. Should the control function <code class="reqn">R=X-\hat{X}</code> be used when re-fitting 
<code>fitT.LX</code>? This argument is not used when <code>estmethod="g"</code>.   
</p>
</td></tr>
<tr><td><code id="ivcoxph_+3A_clusterid">clusterid</code></td>
<td>

<p>an optional string containing the name of a cluster identification variable when 
data are clustered. Specifying <code>clusterid</code> corrects the standard errors
but does not affect the estimates. 
</p>
</td></tr>
<tr><td><code id="ivcoxph_+3A_t">t</code></td>
<td>

<p>a numeric scalar specifying the time point at which to solve the estimating 
equation when <code>estmethod="g"</code>; see &lsquo;Details&rsquo;. If not specified, then the estimating equation is solved 
at the optimal value of <code>t</code>, defined as the value that 
minimizes <code class="reqn">trace\{var(\hat{\psi})\}</code>; see Martinussen et al (2017).
This argument is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr>
<tr><td><code id="ivcoxph_+3A_vcov.fit">vcov.fit</code></td>
<td>

<p>logical. Should the variance-covariance matrix be computed?  
</p>
</td></tr>
<tr><td><code id="ivcoxph_+3A_...">...</code></td>
<td>

<p>optional arguments passed on to the <code>nleqslv</code> function, which is used to 
solve the estimating equations when <code>estmethod="g"</code>. See the help pages 
for <code>nleqslv</code>. This argument is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr> 
</table>


<h3>Details</h3>

 
<p><code>ivcoxph</code> estimates the parameter <code class="reqn">\psi</code> in the causal Cox PH model
</p>
<p style="text-align: center;"><code class="reqn">\textrm{log}\{\lambda(t|L,Z,X)\}-\textrm{log}\{\lambda_0(t|L,Z,X)\}=m^T(L)X\psi.</code>
</p>

<p>Here, <code class="reqn">\lambda_0(t|L,Z,X)</code> is counterfactual hazard function,
had the exposure been set to 0. The vector function <code class="reqn">m(L)</code> contains interaction terms
between <code class="reqn">L</code> and <code class="reqn">X</code>. If <code>estmethod="ts"</code>, then these are specified 
implicitly through the model <code>fitT.LX</code>. If <code>estmethod="g"</code>, then these     
are specified explicitly through the <code>formula</code> argument.
</p>
<p>If <code>estmethod="ts"</code>, then two-stage estimation of <code class="reqn">\psi</code> is performed.
In this case, the model <code>fitX.LZ</code> is used to construct predictions
<code class="reqn">\hat{X}=\hat{E}(X|L,Z)</code>. These predictions are subsequently used to re-fit 
the model <code>fitT.LX</code>, with <code class="reqn">X</code> replaced with <code class="reqn">\hat{X}</code>. The obtained 
coefficient(s) for <code class="reqn">\hat{X}</code> in the re-fitted model is the two-stage estimator of <code class="reqn">\psi</code>. 
</p>
<p>If <code>estmethod="g"</code>, then G-estimation of <code class="reqn">\psi</code> is performed. In this case,
the estimator is obtained as the solution to the estimating equation
</p>
<p style="text-align: center;"><code class="reqn">H(\psi)=\sum_{i=1}^n\hat{d}(L_i,Z_i)h_i(\psi;t)=0,</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">h_i(\psi;t)=\hat{S}(t|L_i,Z_i,X_i)^{\textrm{exp}\{-m^T(L_i)\psi X_i\}}.</code>
</p>

<p>The estimated function <code class="reqn">\hat{d}(L,Z)</code> is chosen so that the true function
has conditional mean 0, given <code class="reqn">L</code>; <code class="reqn">E\{d(L,Z)|L\}=0</code>. 
The specific form of <code class="reqn">\hat{d}(L,Z)</code> is determined by the user-specified models. 
If <code>fitX.LZ</code> and <code>fitX.L</code> are specified, then <code class="reqn">\hat{d}(L,Z)=m(L)\{\hat{E}(X|L,Z)-\hat{E}(X|L)\}</code>, 
where <code class="reqn">\hat{E}(X|L,Z)</code> and <code class="reqn">\hat{E}(X|L)</code> are obtained from <code>fitX.LZ</code>
and <code>fitX.L</code>, respectively. If these are not specified, then <code class="reqn">\hat{d}(L,Z)=m(L)\{Z-\hat{E}(Z|L)\}</code>, 
where <code class="reqn">\hat{E}(Z|L)</code> is obtained from <code>fitZ.L</code>, which then must be specified. 
The estimating equation is solved at the value of <code class="reqn">t</code> specified by the argument <code>t</code>.
<code class="reqn">\hat{S}(t|L_i,Z_i,X_i)</code> is an estimate of <code class="reqn">S(t|L_i,Z_i,X_i)</code> obtained 
from the model <code>fitT.LZX</code>. 
</p>


<h3>Value</h3>

<p><code>ivcoxph</code> returns an object of class <code>"ivcoxph"</code>, which inherits from 
class <code>"ivmod"</code>. An object of class <code>"ivcoxph"</code> is a list containing 
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td></tr>
<tr><td><code>input</code></td>
<td>

<p><code>input</code> is a list containing all input arguments     
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>a vector containing the estimate of <code class="reqn">\psi</code>. 
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>the variance-covariance matrix for the estimate of <code class="reqn">\psi</code>, 
obtained with the sandwich formula. 
</p>
</td></tr>
<tr><td><code>estfunall</code></td>
<td>

<p>a matrix of all subject-specific contributions to the estimating functions used in the estimation process.
One row for each subject, one column for each parameter. If <code>estmethod="ts"</code>,
then the first columns correspond to the parameters estimated by <code>fitX.LZ</code>, and
the last columns correspond to the parameters estimated by the re-fitted model 
<code>fitT.LX</code>. If <code>estmethod="g"</code>, then the first columns correspond to <code class="reqn">\psi</code>, 
and the remaining columns correspond the parameters estimated by <code>fitZ.L</code>,
<code>fitX.LZ</code>, <code>fitX.L</code> and <code>fitT.LZX</code>, whichever were used in the
estimation process.
</p>
</td></tr>
<tr><td><code>d.estfun</code></td>
<td>

<p>the jacobian matrix of <code>colMeans(estfunall)</code>.    
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>logical. Was a solution found to the estimating equations?   
</p>
</td></tr>
<tr><td><code>fitT.LX</code></td>
<td>

<p>the re-fitted model <code>fitT.LX</code> used in the estimation process when <code>estmethod="ts"</code>.
This element is NULL when <code>estmethod="g"</code>.  
</p>
</td></tr>
<tr><td><code>t</code></td>
<td>

<p>the value of <code>t</code> used in the estimation process. This element is NULL 
when <code>estmethod="ts"</code>. 
</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>ivcoxph</code> allows for weights. However, these are defined implicitly 
through the input models. Thus, when models are used as input to <code>ivcoxph</code>, 
these models have to be fitted with the same weights. When <code>estmethod="g"</code>
the weights are taken from <code>fitX.LZ</code>, if specified by the user. If <code>fitX.LZ</code> is not
specified then the weights are taken from <code>fitZ.L</code>. Hence, if weights are used,
then either <code>fitX.LZ</code> or <code>fitZ.L</code> must be specified.   
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>


<h3>References</h3>

<p>Martinussen T., Sorensen D.D., Vansteelandt S. (2019). 
Instrumental variables estimation under a structural Cox model.
<em>Biostatistics</em> <b>20</b>(1), 65-79.
</p>
<p>Sjolander A., Martinussen T. (2019). Instrumental variable estimation with the R package ivtools.
<em>Epidemiologic Methods</em> <b>8</b>(1), 1-20.
</p>
<p>Tchetgen Tchetgen E.J., Walter S., Vansteelandt S., Martinussen T., Glymour M. (2015).
Instrumental variable estimation in a survival context. <em>Epidemiology</em> <b>26</b>(3), 402-410. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(survival)

set.seed(9)

##Note: the parameter values in the examples below are chosen to make 
##Y0 independent of Z, which is necessary for Z to be a valid instrument.

n &lt;- 10000
psi0 &lt;- 0.5
Z &lt;- rbinom(n, 1, 0.5)
X &lt;- rbinom(n, 1, 0.7*Z+0.2*(1-Z))
m0 &lt;- exp(0.8*X-0.41*Z) #T0 independent of Z at t=1
T &lt;- rexp(n, rate=exp(psi0*X+log(m0)))
C &lt;- rexp(n, rate=exp(psi0*X+log(m0))) #50% censoring
d &lt;- as.numeric(T&lt;C)
T &lt;- pmin(T, C)
data &lt;- data.frame(Z, X, T, d)

#two-stage estimation
fitX.LZ &lt;- glm(formula=X~Z, data=data)
fitT.LX &lt;- coxph(formula=Surv(T, d)~X, data=data)
fitIV &lt;- ivcoxph(estmethod="ts", fitX.LZ=fitX.LZ, fitT.LX=fitT.LX, data=data, 
  ctrl=TRUE)
summary(fitIV)

#G-estimation with non-parametric model for S(t|L,Z,X) and model for Z
fitZ.L &lt;- glm(formula=Z~1, data=data)
fitT.LZX &lt;- survfit(formula=Surv(T, d)~X+Z, data=data)
fitIV &lt;- ivcoxph(estmethod="g", X="X", fitZ.L=fitZ.L, fitT.LZX=fitT.LZX, 
  data=data, t=1)
summary(fitIV)

#G-estimation with Cox model for \lambda(t|L,Z,X) and model for Z
fitZ.L &lt;- glm(formula=Z~1, data=data)
fitT.LZX &lt;- coxph(formula=Surv(T, d)~X+X+X*Z, data=data)
fitIV &lt;- ivcoxph(estmethod="g", X="X", fitZ.L=fitZ.L, fitT.LZX=fitT.LZX, 
  data=data, t=1)
summary(fitIV)

</code></pre>

<hr>
<h2 id='ivglm'>
Instrumental variable estimation of the causal exposure effect in 
generalized linear models 
</h2><span id='topic+ivglm'></span>

<h3>Description</h3>

<p><code>ivglm</code> performs instrumental variable estimation of the causal exposure effect in 
generalized linear models with individual-level data. Below, <code class="reqn">Z</code>, <code class="reqn">X</code>, and 
<code class="reqn">Y</code> are the instrument, the exposure, and the outcome, respectively. 
<code class="reqn">L</code> is a vector of covariates that we wish to control for in the analysis; 
these would typically be confounders for the instrument and the outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivglm(estmethod, X, Y, fitZ.L=NULL, fitX.LZ=NULL, fitX.L=NULL, fitY.LX=NULL, 
  fitY.LZX=NULL, data, formula=~1, ctrl=FALSE, clusterid=NULL, link, vcov.fit=TRUE, 
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivglm_+3A_estmethod">estmethod</code></td>
<td>

<p>a string specifying the desired estimation method; either <code>"ts"</code> for two-stage
estimation, or <code>"g"</code> for G-estimation. 
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_x">X</code></td>
<td>

<p>a string specifying the name of the exposure <code class="reqn">X</code> in <code>data</code>. This is not needed 
if <code>fitX.LZ</code> is specified. 
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_y">Y</code></td>
<td>

<p>a string specifying the name of the outcome <code class="reqn">Y</code> in <code>data</code>. This 
is not needed if <code>fitY.LX</code> or <code>fitY.LZX</code> is specified. 
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_fitz.l">fitZ.L</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. This is a fitted GLM for <code class="reqn">E(Z|L)</code>. If there are no covariates,
then <code>fitZ.L</code> may be specified as a model with an intercept only. This argument
is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_fitx.lz">fitX.LZ</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. This is a fitted GLM for <code class="reqn">E(X|L,Z)</code>. 
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_fitx.l">fitX.L</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. This is a fitted GLM for <code class="reqn">E(X|L)</code>. If there are no covariates,
then <code>fitX.L</code> may be specified as a model with an intercept only. This argument
is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_fity.lx">fitY.LX</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. This is a fitted GLM for <code class="reqn">E(Y|L,X)</code>. 
This argument is not used when <code>estmethod="g"</code>.  
</p>
</td></tr> 
<tr><td><code id="ivglm_+3A_fity.lzx">fitY.LZX</code></td>
<td>

<p>an object of class <code>"glm"</code>, as returned by the <code>glm</code> function 
in the <span class="pkg">stats</span> package. This is a fitted GLM for <code class="reqn">E(Y|L,Z,X)</code>. 
This argument is not used when <code>estmethod="ts"</code>. It is also not used 
when <code>estmethod="g"</code> and <code>link="identity"</code> or <code>link="log"</code>.  
</p>
</td></tr> 
<tr><td><code id="ivglm_+3A_data">data</code></td>
<td>

<p>a data frame containing the variables in the model. The covariates, instrument,
exposure and outcome can have arbitrary names, e.g. they don't need to 
be called <code>L</code>, <code>Z</code>, <code>X</code> and <code>Y</code>.
</p>
</td></tr>  
<tr><td><code id="ivglm_+3A_formula">formula</code></td>
<td>

<p>an object of class <code>"formula"</code>, with no left-hand side. This specifies
the causal interaction terms <code class="reqn">m(L)</code>; see &lsquo;Details&rsquo;. Defaults to <code>~1</code>, i.e. 
main effect only. This argument is not used when <code>estmethod="ts"</code>.  
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_ctrl">ctrl</code></td>
<td>

<p>logical. Should the control function <code class="reqn">R=X-\hat{X}</code> be used when re-fitting 
<code>fitY.LX</code>? This argument is not used when <code>estmethod="g"</code>.   
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_clusterid">clusterid</code></td>
<td>

<p>an optional string containing the name of a cluster identification variable when 
data are clustered. Specifying <code>clusterid</code> corrects the standard errors
but does not affect the estimates. 
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_link">link</code></td>
<td>

<p>a string specifying the link function for the causal generalized linear model;
see &lsquo;Details&rsquo;. Either <code>"identity"</code>, <code>"log"</code>, or <code>"logit"</code>. 
This argument is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_vcov.fit">vcov.fit</code></td>
<td>

<p>logical. Should the variance-covariance matrix be computed?  
</p>
</td></tr>
<tr><td><code id="ivglm_+3A_...">...</code></td>
<td>

<p>optional arguments passed on to the <code>nleqslv</code> function, which is used to 
solve the estimating equations when <code>estmethod="g"</code>. See the help pages 
for <code>nleqslv</code>. This argument is not used when <code>estmethod="ts"</code>. 
</p>
</td></tr> 
</table>


<h3>Details</h3>

 
<p><code>ivglm</code> estimates the parameter <code class="reqn">\psi</code> in the causal generalized linear model
</p>
<p style="text-align: center;"><code class="reqn">\eta\{E(Y|L,Z,X)\}-\eta\{E(Y_0|L,Z,X)\}=m^T(L)X\psi.</code>
</p>

<p>Here, <code class="reqn">E(Y_0|L,Z,X)</code> is counterfactual mean of the outcome, 
had the exposure been set to 0. The link function
<code class="reqn">\eta</code> is either the identity, log or logit link, as specified by 
the <code>link</code> argument. The vector function <code class="reqn">m(L)</code> contains interaction terms
between <code class="reqn">L</code> and <code class="reqn">X</code>. If <code>estmethod="ts"</code>, then these are specified 
implicitly through the model <code>fitY.LX</code>. If <code>estmethod="g"</code>, then these     
are specified explicitly through the <code>formula</code> argument.
</p>
<p>If <code>estmethod="ts"</code>, then two-stage estimation of <code class="reqn">\psi</code> is performed.
In this case, the model <code>fitX.LZ</code> is used to construct predictions
<code class="reqn">\hat{X}=\hat{E}(X|L,Z)</code>. These predictions are subsequently used to re-fit 
the model <code>fitY.LX</code>, with <code class="reqn">X</code> replaced with <code class="reqn">\hat{X}</code>. The obtained 
coefficient(s) for <code class="reqn">\hat{X}</code> in the re-fitted model is the two-stage estimator of <code class="reqn">\psi</code>. 
</p>
<p>If <code>estmethod="g"</code>, then G-estimation of <code class="reqn">\psi</code> is performed. In this case,
the estimator is obtained as the solution to the estimating equation
</p>
<p style="text-align: center;"><code class="reqn">H(\psi)=\sum_{i=1}^n\hat{d}(L_i,Z_i)h_i(\psi)=0.</code>
</p>

<p>The function <code class="reqn">h_i(\psi)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">h_i(\psi)=Y_i-m^T(L_i)\psi X_i</code>
</p>

<p>when <code>link="identity"</code>,
</p>
<p style="text-align: center;"><code class="reqn">h_i(\psi)=Y_i\textrm{exp}\{-m^T(L_i)\psi X_i\}</code>
</p>

<p>when <code>link="log"</code>, and
</p>
<p style="text-align: center;"><code class="reqn">h_i(\psi)=\textrm{expit}[\textrm{logit}\{\hat{E}(Y|L_i,Z_i,X_i)\}-m^T(L_i)\psi X_i]</code>
</p>

<p>when <code>link="logit"</code>. In the latter, <code class="reqn">\hat{E}(Y|L_i,Z_i,X_i)</code> is
an estimate of <code class="reqn">E(Y|L_i,Z_i,X_i)</code> obtained from the model <code>fitY.LZX</code>.
The estimated function <code class="reqn">\hat{d}(L,Z)</code> is chosen so that the true function
has conditional mean 0, given <code class="reqn">L</code>; <code class="reqn">E\{d(L,Z)|L\}=0</code>. 
The specific form of <code class="reqn">\hat{d}(L,Z)</code> is determined by the user-specified models. 
If <code>fitX.LZ</code> and <code>fitX.L</code> are specified, then <code class="reqn">\hat{d}(L,Z)=m(L)\{\hat{E}(X|L,Z)-\hat{E}(X|L)\}</code>, 
where <code class="reqn">\hat{E}(X|L,Z)</code> and <code class="reqn">\hat{E}(X|L)</code> are obtained from <code>fitX.LZ</code>
and <code>fitX.L</code>, respectively. If these are not specified, then <code class="reqn">\hat{d}(L,Z)=m(L)\{Z-\hat{E}(Z|L)\}</code>, 
where <code class="reqn">\hat{E}(Z|L)</code> is obtained from <code>fitZ.L</code>, which then must be specified. 
</p>


<h3>Value</h3>

<p><code>ivglm</code> returns an object of class <code>"ivglm"</code>, which inherits from 
class <code>"ivmod"</code>. An object of class <code>"ivglm"</code> is a list containing 
</p>
<table>
<tr><td><code>call</code></td>
<td>

<p>the matched call. 
</p>
</td></tr>
<tr><td><code>input</code></td>
<td>

<p><code>input</code> is a list containing all input arguments     
</p>
</td></tr>
<tr><td><code>est</code></td>
<td>

<p>a vector containing the estimate of <code class="reqn">\psi</code>. 
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>the variance-covariance matrix for the estimate of <code class="reqn">\psi</code>, 
obtained with the sandwich formula. 
</p>
</td></tr>
<tr><td><code>estfunall</code></td>
<td>

<p>a matrix of all subject-specific contributions to the estimating functions used in the estimation process.
One row for each subject, one column for each parameter. If <code>estmethod="ts"</code>,
then the first columns correspond to the parameters estimated by <code>fitX.LZ</code>, and
the last columns correspond to the parameters estimated by the re-fitted model 
<code>fitY.LX</code>. If <code>estmethod="g"</code>, then the first columns correspond to <code class="reqn">\psi</code>, 
and the remaining columns correspond to the parameters estimated by <code>fitZ.L</code>,
<code>fitX.LZ</code>, <code>fitX.L</code> and <code>fitY.LZX</code>, whichever were used in the
estimation process.    
</p>
</td></tr>
<tr><td><code>d.estfun</code></td>
<td>

<p>the jacobian matrix of <code>colMeans(estfunall)</code>.    
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>logical. Was a solution found to the estimating equations?   
</p>
</td></tr>
<tr><td><code>fitY.LX</code></td>
<td>

<p>the re-fitted model <code>fitY.LX</code> used in the estimation process when <code>estmethod="ts"</code>.
This element is NULL when <code>estmethod="g"</code>. 
</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>ivglm</code> allows for weights. However, these are defined implicitly 
through the input models. Thus, when models are used as input to <code>ivglm</code>, 
these models have to be fitted with the same weights. When <code>estmethod="g"</code>
the weights are taken from <code>fitX.LZ</code>, if specified by the user. If <code>fitX.LZ</code> is not
specified then the weights are taken from <code>fitZ.L</code>. Hence, if weights are used,
then either <code>fitX.LZ</code> or <code>fitZ.L</code> must be specified.
</p>


<h3>Author(s)</h3>

<p>Arvid Sjolander. 
</p>


<h3>References</h3>

<p>Bowden J., Vansteelandt S. (2011). Mendelian randomization analysis of
case-control data using structural mean models. <em>Statistics in Medicine</em>
<b>30</b>(6), 678-694.
</p>
<p>Sjolander A., Martinussen T. (2019). Instrumental variable estimation with the R package ivtools.
<em>Epidemiologic Methods</em> <b>8</b>(1), 1-20.
</p>
<p>Vansteelandt S., Bowden J., Babanezhad M., Goetghebeur E. (2011). 
On instrumental variables estimation of causal odds ratios.
<em>Statistical Science</em> <b>26</b>(3), 403-422.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(9)

##Note: the parameter values in the examples below are chosen to make 
##Y0 independent of Z, which is necessary for Z to be a valid instrument.

n &lt;- 1000
psi0 &lt;- 0.5
psi1 &lt;- 0.2

##---Example 1: linear model and interaction between X and L---

L &lt;- rnorm(n)
Z &lt;- rnorm(n, mean=L)
X &lt;- rnorm(n, mean=Z)
m0 &lt;- X-Z+L 
Y &lt;- rnorm(n, mean=psi0*X+psi1*X*L+m0)
data &lt;- data.frame(L, Z, X, Y)

#two-stage estimation
fitX.LZ &lt;- glm(formula=X~Z, data=data)
fitY.LX &lt;- glm(formula=Y~X+L+X*L, data=data)
fitIV &lt;- ivglm(estmethod="ts", fitX.LZ=fitX.LZ, fitY.LX=fitY.LX, data=data, 
  ctrl=TRUE) 
summary(fitIV)

#G-estimation with model for Z
fitZ.L &lt;- glm(formula=Z~L, data=data)
fitIV &lt;- ivglm(estmethod="g", X="X", Y="Y", fitZ.L=fitZ.L, data=data, 
  formula=~L, link="identity")
summary(fitIV)

#G-estimation with model for X
fitX.LZ &lt;- glm(formula=X~L+Z, data=data)
fitX.L &lt;- glm(formula=X~L, data=data)
fitIV &lt;- ivglm(estmethod="g", Y="Y", fitX.LZ=fitX.LZ, fitX.L=fitX.L, data=data, 
  formula=~L, link="identity")
summary(fitIV)

##---Example 2: logistic model and no covariates--- 

Z &lt;- rbinom(n, 1, 0.5)
X &lt;- rbinom(n, 1, 0.7*Z+0.2*(1-Z)) 
m0 &lt;- plogis(1+0.8*X-0.39*Z)
Y &lt;- rbinom(n, 1, plogis(psi0*X+log(m0/(1-m0)))) 
data &lt;- data.frame(Z, X, Y)

#two-stage estimation
fitX.LZ &lt;- glm(formula=X~Z, family="binomial", data=data)
fitY.LX &lt;- glm(formula=Y~X, family="binomial", data=data)
fitIV &lt;- ivglm(estmethod="ts", fitX.LZ=fitX.LZ, fitY.LX=fitY.LX, data=data, 
  ctrl=TRUE) 
summary(fitIV)

#G-estimation with model for Z
fitZ.L &lt;- glm(formula=Z~1, data=data)
fitY.LZX &lt;- glm(formula=Y~X+Z+X*Z, family="binomial", data=data)
fitIV &lt;- ivglm(estmethod="g", X="X", fitZ.L=fitZ.L, fitY.LZX=fitY.LZX, 
  data=data, link="logit")
summary(fitIV)


</code></pre>

<hr>
<h2 id='plot.estfun'>
Plots sums of estimating functions. 
</h2><span id='topic+plot.estfun'></span>

<h3>Description</h3>

<p>This is a <code>plot</code> method for class <code>"estfun"</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estfun'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.estfun_+3A_x">x</code></td>
<td>

<p>an object of class <code>"estfun"</code>, fitted with <code>method="g"</code>.
</p>
</td></tr>  
<tr><td><code id="plot.estfun_+3A_...">...</code></td>
<td>

<p>additional arguments to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for estfun.

</code></pre>

<hr>
<h2 id='plot.ivah'>
Plots result of G-estimation in causal AH model. 
</h2><span id='topic+plot.ivah'></span>

<h3>Description</h3>

<p>This is a <code>plot</code> method for class <code>"ivah"</code>. It only supports
objects fitted with <code>estmethod="g"</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivah'
plot(x, gof=FALSE, CI.level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ivah_+3A_x">x</code></td>
<td>

<p>an object of class <code>"ivah"</code>, fitted with <code>estmethod="g"</code>.
</p>
</td></tr> 
<tr><td><code id="plot.ivah_+3A_gof">gof</code></td>
<td>

<p>should we plot the goodness-of-fit process? If not, then <code class="reqn">B(t)</code> is plotted
together with confidence intervals.
</p>
</td></tr>  
<tr><td><code id="plot.ivah_+3A_ci.level">CI.level</code></td>
<td>

<p>level for the confidence intervals.
</p>
</td></tr> 
<tr><td><code id="plot.ivah_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander and Torben Martinussen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for ivah.

</code></pre>

<hr>
<h2 id='print.ivmod'>
Prints output of instrumental variable estimation
</h2><span id='topic+print.ivmod'></span>

<h3>Description</h3>

<p>This is a <code>print</code> method for class <code>"ivmod"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivmod'
print(x, digits=max(3L, getOption("digits")-3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ivmod_+3A_x">x</code></td>
<td>

<p>an object of class <code>"ivmod"</code>.
</p>
</td></tr>
<tr><td><code id="print.ivmod_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to use.
</p>
</td></tr>
<tr><td><code id="print.ivmod_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for ivglm, ivcoxph and ivah.

</code></pre>

<hr>
<h2 id='print.summary.ivbounds'>
Prints summary of instrumental variable bounds
</h2><span id='topic+print.summary.ivbounds'></span>

<h3>Description</h3>

<p>This is a <code>print</code> method for class <code>"summary.ivbounds"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ivbounds'
print(x, digits=max(3L, getOption("digits")-3L), 
   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.ivbounds_+3A_x">x</code></td>
<td>

<p>an object of class <code>"summary.ivbounds"</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.ivbounds_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to use.
</p>
</td></tr>
<tr><td><code id="print.summary.ivbounds_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for ivbounds.

</code></pre>

<hr>
<h2 id='print.summary.ivmod'>
Prints summary of instrumental variable estimation
</h2><span id='topic+print.summary.ivmod'></span>

<h3>Description</h3>

<p>This is a <code>print</code> method for class <code>"summary.ivmod"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.ivmod'
print(x, digits=max(3L, getOption("digits")-3L), 
  signif.stars=getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.ivmod_+3A_x">x</code></td>
<td>

<p>an object of class <code>"summary.ivmod"</code>.
</p>
</td></tr>
<tr><td><code id="print.summary.ivmod_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to use.
</p>
</td></tr>
<tr><td><code id="print.summary.ivmod_+3A_signif.stars">signif.stars</code></td>
<td>

<p>logical. If TRUE, &quot;significance stars&quot; are printed for each coefficient.
</p>
</td></tr>
<tr><td><code id="print.summary.ivmod_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for ivglm, ivcoxph and ivah.

</code></pre>

<hr>
<h2 id='summary.ivbounds'>
Summarizes instrumental variable estimation
</h2><span id='topic+summary.ivbounds'></span>

<h3>Description</h3>

<p>This is a <code>summary</code> method for class <code>"ivbounds"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivbounds'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ivbounds_+3A_object">object</code></td>
<td>

<p>an object of class <code>"ivbounds"</code>.
</p>
</td></tr> 
<tr><td><code id="summary.ivbounds_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides the lower and and upper bounds for 
</p>
<p style="text-align: center;"><code class="reqn">p_0=p(Y_0=1)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_1=p(Y_1=1)</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{CRD}=p_1-p_0</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{CRR}=p_1/p_0</code>
</p>

<p style="text-align: center;"><code class="reqn">\textrm{COR}=\frac{p_1/(1-p_1)}{p_0/(1-p_0)}</code>
</p>



<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for ivbounds.

</code></pre>

<hr>
<h2 id='summary.ivmod'>
Summarizes instrumental variable estimation
</h2><span id='topic+summary.ivmod'></span>

<h3>Description</h3>

<p>This is a <code>summary</code> method for class <code>"ivmod"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivmod'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ivmod_+3A_object">object</code></td>
<td>

<p>an object of class <code>"ivmod"</code>.
</p>
</td></tr> 
<tr><td><code id="summary.ivmod_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arvid Sjolander
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##See documentation for ivglm, ivcoxph and ivah.

</code></pre>

<hr>
<h2 id='VitD'>Data from a cohort study on Vitamin D and mortality.</h2><span id='topic+VitD'></span>

<h3>Description</h3>

<p>This dataset originates from a real cohort study on Vitamin D and mortailty,
described by Martinussen et al (2017). However, to allow public availability 
the data were slightly mutilated before inclusion in the 
<code>ivtools</code> package.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VitD)
</code></pre>


<h3>Format</h3>

<p>The dataset contains the following variables:
</p>

<dl>
<dt>age</dt><dd><p>age at baseline.</p>
</dd> 
<dt>filaggrin</dt><dd><p>binary indicator of whether the subject has mutations in the filaggrin gene.</p>
</dd>
<dt>vitd</dt><dd><p>vitamin D level at baseline, measured as serum 25-OH-D (nmol/L).</p>
</dd>
<dt>time</dt><dd><p>follow-up time.</p>
</dd>
<dt>death</dt><dd><p>indicator of whether the subject died during follow-up.</p>
</dd>
</dl>



<h3>References</h3>

<p>Martinussen T., Sorensen D.D., Vansteelandt S. (2019). 
Instrumental variables estimation under a structural Cox model.
<em>Biostatistics</em> <b>20</b>(1), 65-79.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
