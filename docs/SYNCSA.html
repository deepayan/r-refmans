<!DOCTYPE html><html lang="en"><head><title>Help for package SYNCSA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SYNCSA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ADRS'><p>Artificial Data for Run SYNCSA</p></a></li>
<li><a href='#belonging'><p>Degree of belonging of species</p></a></li>
<li><a href='#cent.norm'><p>Matrix centralization and standardization</p></a></li>
<li><a href='#CollectNames'><p>Collect names an entire list</p></a></li>
<li><a href='#cor.matrix'><p>Function to obtain the correlation between two matrices and partial matrix</p>
correlation between three matrices.</a></li>
<li><a href='#flona'><p>Hypothetical data for SYNCSA</p></a></li>
<li><a href='#matmult.syncsa'><p>Matrix multiplication</p></a></li>
<li><a href='#matrix.p'><p>Matrix P</p></a></li>
<li><a href='#matrix.t'><p>Matrix T</p></a></li>
<li><a href='#matrix.x'><p>Matrix X</p></a></li>
<li><a href='#optimal'><p>Searching for optimal traits</p></a></li>
<li><a href='#organize.syncsa'><p>Function for organize data for Package SYNCSA</p></a></li>
<li><a href='#part.cor'><p>First-order partial correlation coefficient</p></a></li>
<li><a href='#pca'><p>Principal Components Analysis (PCA) with NA (missing data)</p></a></li>
<li><a href='#permut.row.matrix'><p>Permutate rows in a matrix</p></a></li>
<li><a href='#permut.vector'><p>Permutate a vector</p></a></li>
<li><a href='#procrustes.syncsa'><p>Procrustes and Partial Procrustes correlations.</p></a></li>
<li><a href='#ProgressBAR'><p>Text Progress Bar</p></a></li>
<li><a href='#rao.diversity'><p>Rao's quadratic entropy</p></a></li>
<li><a href='#syncsa'><p>SYNCSA</p></a></li>
<li><a href='#var.dummy'><p>Generate dummy variable</p></a></li>
<li><a href='#var.type'><p>Check the type of variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Functional and Phylogenetic Patterns in
Metacommunities</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Vanderlei Julio Debastiani</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>vegan, FD, permute, RcppArmadillo, utils, stats, graphics,
parallel</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of metacommunities based on functional traits and
    phylogeny of the community components. The functions that are offered here
    implement for the R environment methods that have been available in the
    SYNCSA application written in C++ (by Valerio Pillar, available at 
    <a href="http://ecoqua.ecologia.ufrgs.br/SYNCSA.html">http://ecoqua.ecologia.ufrgs.br/SYNCSA.html</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'CollectNames.R' 'ProgressBAR.R' 'belonging.R' 'cent.norm.R'
'cor.matrix.R' 'cor.mantel.R' 'cor.matrix.partial.R'
'cor.matrix2.R' 'cor.procrustes.R' 'matmult.syncsa.R'
'matrix.p.R' 'matrix.t.R' 'matrix.x.R' 'optimal.R'
'organize.syncsa.R' 'part.cor.R' 'pca.R' 'permut.row.matrix.R'
'permut.vector.R' 'plot.pcasyncsa.R' 'print.optimal.R'
'syncsa.R' 'print.syncsa.R' 'pro.matrix.R'
'pro.matrix.partial.R' 'pro.matrix2.R' 'procrustes.syncsa.R'
'procrustes.partial.R' 'rao.diversity.R' 'startup.R'
'var.dummy.R' 'var.type.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-08 13:09:29 UTC; vdebastiani</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-09 18:30:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='ADRS'>Artificial Data for Run SYNCSA</h2><span id='topic+ADRS'></span>

<h3>Description</h3>

<p>Artificial data for run SYNCSA.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ADRS)
</code></pre>


<h3>Format</h3>

<p>A list with 4 matrices.
</p>

<dl>
<dt>commnunity</dt><dd><p>Community data, observations of six species in ten sites.</p>
</dd>
<dt>traits</dt><dd><p>Matrix data of species described by two traits.</p>
</dd>
<dt>phylo</dt><dd><p>Matrix containing phylogenetic distance between species.</p>
</dd>
<dt>envir</dt><dd><p>Two environmental variables for each community.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(ADRS)
</code></pre>

<hr>
<h2 id='belonging'>Degree of belonging of species</h2><span id='topic+belonging'></span>

<h3>Description</h3>

<p>Function to obtain a matrix containing the degrees of belongings of each
and every species. The degree of belonging of each species is defined based on
its ecological or phylogenetic resemblance to every other
species in the community. For more details, see <code><a href="#topic+matrix.p">matrix.p</a></code>,
<code><a href="#topic+matrix.x">matrix.x</a></code> and <code><a href="#topic+syncsa">syncsa</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belonging(dis, standardize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="belonging_+3A_dis">dis</code></td>
<td>
<p>Matrix containing distance between species.</p>
</td></tr>
<tr><td><code id="belonging_+3A_standardize">standardize</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if dis must
be standardized in values ranging from 0 to 1 (Default standardize = TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standardized matrix containing the degree of belonging of species in
relation to each other. Row totals (species) = 1.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Pillar, V.D.; Duarte, L.d.S. (2010). A framework for
metacommunity analysis of phylogenetic structure. Ecology Letters, 13,
587-596.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matrix.p">matrix.p</a></code>, <code><a href="#topic+matrix.x">matrix.x</a></code>,
<code><a href="#topic+syncsa">syncsa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ADRS)
belonging(ADRS$phylo)
</code></pre>

<hr>
<h2 id='cent.norm'>Matrix centralization and standardization</h2><span id='topic+cent.norm'></span>

<h3>Description</h3>

<p>Internal function for centralization and standardization in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cent.norm(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cent.norm_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="cent.norm_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if missing
observations are removed (Default na.rm = FALSE).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>
</p>

<hr>
<h2 id='CollectNames'>Collect names an entire list</h2><span id='topic+CollectNames'></span>

<h3>Description</h3>

<p>Internal function to collect names an entire list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CollectNames(l, prefix = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CollectNames_+3A_l">l</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="CollectNames_+3A_prefix">prefix</code></td>
<td>
<p>A prefix to nomes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The names.
</p>

<hr>
<h2 id='cor.matrix'>Function to obtain the correlation between two matrices and partial matrix
correlation between three matrices.</h2><span id='topic+cor.matrix'></span><span id='topic+cor.matrix.partial'></span><span id='topic+pro.matrix'></span><span id='topic+pro.matrix.partial'></span><span id='topic+cor.mantel'></span><span id='topic+cor.procrustes'></span><span id='topic+cor.matrix2'></span><span id='topic+pro.matrix2'></span>

<h3>Description</h3>

<p>The functions cor.matrix and cor.matrix.partial are similar the function
<code><a href="vegan.html#topic+mantel">mantel</a></code> and <code><a href="vegan.html#topic+mantel.partial">mantel.partial</a></code>, although the significance
of the statistics is evaluated differently from Mantel. The functions pro.matrix
and pro.matrix.partial use symmetric Procrustes as a measure of concordance between
data sets. The function cor.mantel is similar to the function <code><a href="vegan.html#topic+mantel">mantel</a></code>, but
allows the use of a set of predefined permutation. For more details, see
<code><a href="#topic+syncsa">syncsa</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.matrix(
  mx1,
  mx2,
  x,
  my1 = NULL,
  my2 = NULL,
  y,
  permute.my2 = FALSE,
  method = "pearson",
  dist = "euclidean",
  permutations = 999,
  norm = FALSE,
  norm.y = FALSE,
  strata = NULL,
  na.rm = FALSE,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

cor.mantel(
  dist.x,
  dist.y,
  method = "pearson",
  permutations = 999,
  strata = NULL,
  na.rm = FALSE,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

cor.matrix.partial(
  mx1,
  mx2,
  x,
  my1 = NULL,
  my2 = NULL,
  y,
  mz1 = NULL,
  mz2 = NULL,
  z,
  method = "pearson",
  dist = "euclidean",
  permute.my2 = FALSE,
  permute.mz2 = FALSE,
  permutations = 999,
  norm = FALSE,
  norm.y = FALSE,
  norm.z = FALSE,
  strata = NULL,
  na.rm = FALSE,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

cor.matrix2(
  mx1,
  mx2,
  x,
  y,
  method = "pearson",
  dist = "euclidean",
  put.together = NULL,
  permutations = 999,
  strata = NULL,
  na.rm = FALSE,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

cor.procrustes(
  x,
  y,
  permutations = 999,
  strata = NULL,
  na.rm = FALSE,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

pro.matrix(
  mx1,
  mx2,
  x,
  my1 = NULL,
  my2 = NULL,
  y,
  permute.my2 = FALSE,
  permutations = 999,
  norm = FALSE,
  norm.y = FALSE,
  strata = NULL,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

pro.matrix.partial(
  mx1,
  mx2,
  x,
  my1 = NULL,
  my2 = NULL,
  y,
  mz1 = NULL,
  mz2 = NULL,
  z,
  permute.my2 = FALSE,
  permute.mz2 = FALSE,
  permutations = 999,
  norm = FALSE,
  norm.y = FALSE,
  norm.z = FALSE,
  strata = NULL,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)

pro.matrix2(
  mx1,
  mx2,
  x,
  y,
  put.together = NULL,
  permutations = 999,
  strata = NULL,
  seqpermutation = NULL,
  parallel = NULL,
  newClusters = TRUE,
  CL = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor.matrix_+3A_mx1">mx1</code></td>
<td>
<p>Matrix that multiplied by mx2 results in the matrix x.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_mx2">mx2</code></td>
<td>
<p>Matrix that when multiplied by mx1 results in the matrix x. See
'details' below.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_x">x</code></td>
<td>
<p>Matrix that will be correlated with the matrix y.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_my1">my1</code></td>
<td>
<p>Matrix that multiplied by my2 results in the matrix y.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_my2">my2</code></td>
<td>
<p>Matrix that when multiplied by my1 results in the matrix y. See
'details' below.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_y">y</code></td>
<td>
<p>Matrix that will be correlated with the matrix x.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_permute.my2">permute.my2</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if realize
parallel permutation in matrix my2.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_method">method</code></td>
<td>
<p>Correlation method, as accepted by cor: &quot;pearson&quot;, &quot;spearman&quot;
or &quot;kendall&quot;.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_dist">dist</code></td>
<td>
<p>Dissimilarity index, as accepted by vegdist: &quot;manhattan&quot;,
&quot;euclidean&quot;, &quot;canberra&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;,
&quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot; , &quot;binomial&quot; or &quot;chao&quot;.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_permutations">permutations</code></td>
<td>
<p>Number of permutations in assessing significance.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_norm">norm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if x is standardized
within variables (Default norm = FALSE).</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_norm.y">norm.y</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if y is standardized
within variables (Default norm = FALSE).</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_strata">strata</code></td>
<td>
<p>Argument to specify restricting permutations within species
groups (Default strata = NULL).</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if pairwise
deletion of missing observations when computing dissimilarities (Default
na.rm = FALSE).</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_seqpermutation">seqpermutation</code></td>
<td>
<p>A set of predefined permutation, with the same dimensions of
permutations (Default seqpermutation = NULL).</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_parallel">parallel</code></td>
<td>
<p>Number of parallel processes.  Tip: use parallel::detectCores() (Default parallel = NULL).</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_newclusters">newClusters</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if make new parallel
processes or use predefined socket cluster. Only if parallel is different of NULL (Default newClusters = TRUE).</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_cl">CL</code></td>
<td>
<p>A predefined socket cluster done with parallel package.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_dist.x">dist.x</code></td>
<td>
<p>Dissimilarity matrices of class dist.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_dist.y">dist.y</code></td>
<td>
<p>Dissimilarity matrices of class dist.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_mz1">mz1</code></td>
<td>
<p>Matrix that multiplied by mz2 results in the matrix z.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_mz2">mz2</code></td>
<td>
<p>Matrix that when multiplied by mz1 results in the matrix z. See
'details' below.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_z">z</code></td>
<td>
<p>Matrix whose effect will be removed from the correlation between x
and y.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_permute.mz2">permute.mz2</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if realize
parallel permutation in matrix mz2.</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_norm.z">norm.z</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if z is standardized
within variables (Default norm = FALSE).</p>
</td></tr>
<tr><td><code id="cor.matrix_+3A_put.together">put.together</code></td>
<td>
<p>List to specify group of traits. Each group specify receive the
same weight that one trait outside any group, in the way each group is considered
as unique trait (Default put.together = NULL). This argument must be a list, see
examples in <code><a href="#topic+syncsa">syncsa</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null model is based on permutations in the matrix mx2, typically the
matrices B, U and Q, except in the function cor.mantel when the permutations
are done in one of distance matrix.
</p>
<p>Null model described by Pillar et al. (2009) and Pillar &amp; Duarte (2010). For
more details on the matrices and the null model, see <code><a href="#topic+syncsa">syncsa</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Obs</code></td>
<td>
<p>Correlation between matrices.</p>
</td></tr> <tr><td><code>p</code></td>
<td>
<p>Significance
level based on permutations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Pillar, V.D.; Duarte, L.d.S. (2010). A framework for
metacommunity analysis of phylogenetic structure. Ecology Letters, 13,
587-596.
</p>
<p>Pillar, V.D., Duarte, L.d.S., Sosinski, E.E. &amp; Joner, F. (2009).
Discriminating trait-convergence and trait-divergence assembly patterns in
ecological community gradients. Journal of Vegetation Science, 20, 334:348.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+organize.syncsa">organize.syncsa</a></code>, <code><a href="vegan.html#topic+mantel">mantel</a></code>,
<code><a href="vegan.html#topic+procrustes">procrustes</a></code>
</p>

<hr>
<h2 id='flona'>Hypothetical data for SYNCSA</h2><span id='topic+flona'></span>

<h3>Description</h3>

<p>Hypothetical data for running examples.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(flona)
</code></pre>


<h3>Format</h3>

<p>A list with 4 matrices.
</p>

<dl>
<dt>commnunity</dt><dd><p>Community data, observations of 59 species in 39 sites.</p>
</dd>
<dt>traits</dt><dd><p>Matrix data of species described by five traits.</p>
</dd>
<dt>phylo</dt><dd><p>Matrix containing phylogenetic distance between species.</p>
</dd>
<dt>environment</dt><dd><p>Three environmental variables for each community.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(flona)
</code></pre>

<hr>
<h2 id='matmult.syncsa'>Matrix multiplication</h2><span id='topic+matmult.syncsa'></span>

<h3>Description</h3>

<p>Internal function to get the matrix product when missing data (NA) is found in matrix Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matmult.syncsa(X, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matmult.syncsa_+3A_x">X</code></td>
<td>
<p>A matrix, typically the standardized community matrix (W).</p>
</td></tr>
<tr><td><code id="matmult.syncsa_+3A_y">Y</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function ignore missing data when found in matrix Y. Before multiplication of matrices
the missing data in Y are replaced by 0 and multiplication is performed, and then, an adjustment is
performed. This adjustment is done by divide each cell of the product matrix by the sum of
proportions of nonzero at X with complete data in Y. In SYNCSA context this adjustment is done by
divide each cell of the product matrix by the sum of species proportion with trait data in Y.
Important, the matrix X must be standardized, in other words, row totals must be equal to 1.
</p>


<h3>Value</h3>

<p>The matrix product.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="base.html#topic+matmult">matmult</a></code>,
</p>

<hr>
<h2 id='matrix.p'>Matrix P</h2><span id='topic+matrix.p'></span>

<h3>Description</h3>

<p>Function to obtain a matrix containing phylogeny-weighted species
composition. For more details, see <code><a href="#topic+syncsa">syncsa</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.p(comm, phylodist, notification = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix.p_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as
rows. This matrix can contain either presence/absence or abundance data.</p>
</td></tr>
<tr><td><code id="matrix.p_+3A_phylodist">phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distance between species.
Must be a complete matrix (not a diagonal resemblance matrix).</p>
</td></tr>
<tr><td><code id="matrix.p_+3A_notification">notification</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if
notifications for missing observations are to be shown (Default notification =
TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>matrix.w</code></td>
<td>
<p>Standardized community matrix, where rows are
communities and columns species. Row totals (communities) = 1.</p>
</td></tr>
<tr><td><code>matrix.q</code></td>
<td>
<p>Standardized matrix containing the degree of belonging of
species in relation to each other. Row totals (species) = 1.</p>
</td></tr>
<tr><td><code>matrix.P</code></td>
<td>
<p>Phylogeny-weighted species composition matrix. Row totals
(communities) = 1.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><strong>IMPORTANT</strong>: Species sequence in the community data
matrix MUST be the same as the one in the phylogenetic distance matrix. See
<code><a href="#topic+organize.syncsa">organize.syncsa</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Pillar, V.D.; Duarte, L.d.S. (2010). A framework for
metacommunity analysis of phylogenetic structure. Ecology Letters, 13,
587-596.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+organize.syncsa">organize.syncsa</a></code>, <code><a href="#topic+belonging">belonging</a></code>,
<code><a href="#topic+matrix.t">matrix.t</a></code>, <code><a href="#topic+matrix.x">matrix.x</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ADRS)
matrix.p(ADRS$community, ADRS$phylo)
</code></pre>

<hr>
<h2 id='matrix.t'>Matrix T</h2><span id='topic+matrix.t'></span>

<h3>Description</h3>

<p>Function to obtain a matrix containing trait averages at community level.
For more details, see <code><a href="#topic+syncsa">syncsa</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.t(comm, traits, scale = TRUE, ranks = TRUE, notification = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix.t_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as
rows. This matrix can contain either presence/absence or abundance data.</p>
</td></tr>
<tr><td><code id="matrix.t_+3A_traits">traits</code></td>
<td>
<p>Matrix or data frame of species described by traits, with traits as
columns and species as rows.</p>
</td></tr>
<tr><td><code id="matrix.t_+3A_scale">scale</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if the traits are
measured on different scales (Default scale = TRUE). When scale = TRUE traits
are measured on different scales and the matrix T is subjected to
standardization within each trait. When scale = FALSE traits are measured on
the same scale the matrix T is not subjected to standardization.</p>
</td></tr>
<tr><td><code id="matrix.t_+3A_ranks">ranks</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if ordinal variables are
convert to ranks (Default ranks = TRUE).</p>
</td></tr>
<tr><td><code id="matrix.t_+3A_notification">notification</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if
notifications of missing observations are shown (Default notification =
TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>matriz.w</code></td>
<td>
<p>Standardized community matrix, where rows are
communities and columns species. Row totals (communities) = 1.</p>
</td></tr>
<tr><td><code>matriz.b</code></td>
<td>
<p>Matrix of traits, exactly the same data input.</p>
</td></tr>
<tr><td><code>matriz.T</code></td>
<td>
<p>Matrix containing trait averages at community level. If
Scale = TRUE the matrix T is standardized within the traits.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><strong>IMPORTANT</strong>: The sequence species show up in community data
matrix MUST be the same as they show up in traits matrix. See
<code><a href="#topic+organize.syncsa">organize.syncsa</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Pillar, V.D.; Duarte, L.d.S. (2010). A framework for
metacommunity analysis of phylogenetic structure. Ecology Letters, 13,
587-596.
</p>
<p>Pillar, V.D., Duarte, L.d.S., Sosinski, E.E. &amp; Joner, F. (2009).
Discriminating trait-convergence and trait-divergence assembly patterns in
ecological community gradients. Journal of Vegetation Science, 20, 334:348.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+organize.syncsa">organize.syncsa</a></code>,
<code><a href="#topic+matrix.p">matrix.p</a></code>, <code><a href="#topic+matrix.x">matrix.x</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ADRS)
matrix.t(ADRS$community, ADRS$traits)
</code></pre>

<hr>
<h2 id='matrix.x'>Matrix X</h2><span id='topic+matrix.x'></span>

<h3>Description</h3>

<p>Function to obtain a matrix containing trait-weighted species composition.
For more details, see <code><a href="#topic+syncsa">syncsa</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.x(
  comm,
  traits,
  scale = TRUE,
  ranks = TRUE,
  ord,
  notification = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix.x_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as
rows. This matrix can contain either presence/absence or abundance data.</p>
</td></tr>
<tr><td><code id="matrix.x_+3A_traits">traits</code></td>
<td>
<p>Matrix or data frame of species described by traits, with traits as
columns and species as rows.</p>
</td></tr>
<tr><td><code id="matrix.x_+3A_scale">scale</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if the traits are
measured on different scales (Default scale = TRUE). When scale = TRUE traits
are measured on different scales the matrix of traits is subjected to
standardization within each trait, and Gower Index is used to calculate the
degree of belonging to the species. When scale = FALSE traits are measured on
the same scale the matrix of traits is not subjected to standardization,
and Euclidean distance is calculated to determine the degree of belonging to
the species.</p>
</td></tr>
<tr><td><code id="matrix.x_+3A_ranks">ranks</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if ordinal variables are
convert to ranks (Default ranks = TRUE).</p>
</td></tr>
<tr><td><code id="matrix.x_+3A_ord">ord</code></td>
<td>
<p>Method to be used for ordinal variables, see <code><a href="FD.html#topic+gowdis">gowdis</a></code>, if any
method is forneced the rank parameter is not apply.</p>
</td></tr>
<tr><td><code id="matrix.x_+3A_notification">notification</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if
notifications of missing observations are shown (Default notification =
TRUE).</p>
</td></tr>
<tr><td><code id="matrix.x_+3A_...">...</code></td>
<td>
<p>Parameters for <code><a href="FD.html#topic+gowdis">gowdis</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>matriz.w</code></td>
<td>
<p>Standardized community matrix, where rows are
communities and columns species. Row totals (communities) = 1.</p>
</td></tr>
<tr><td><code>matriz.u</code></td>
<td>
<p>Standardized matrix containing the degree of belonging of
each species in relation to each other species. Row totals (species) = 1.</p>
</td></tr>
<tr><td><code>matriz.X</code></td>
<td>
<p>Trait-weighted species composition matrix. Row totals
(communities) = 1.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><strong>IMPORTANT</strong>: The sequence species show up in community data
matrix MUST be the same as they show up in traits matrix. See
<code><a href="#topic+organize.syncsa">organize.syncsa</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Pillar, V.D.; Duarte, L.d.S. (2010). A framework for
metacommunity analysis of phylogenetic structure. Ecology Letters, 13,
587-596.
</p>
<p>Pillar, V.D., Duarte, L.d.S., Sosinski, E.E. &amp; Joner, F. (2009).
Discriminating trait-convergence and trait-divergence assembly patterns in
ecological community gradients. Journal of Vegetation Science, 20, 334:348.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+organize.syncsa">organize.syncsa</a></code>, <code><a href="#topic+belonging">belonging</a></code>,
<code><a href="#topic+matrix.t">matrix.t</a></code>, <code><a href="#topic+matrix.p">matrix.p</a></code>, <code><a href="FD.html#topic+gowdis">gowdis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ADRS)
matrix.x(ADRS$community, ADRS$traits)
</code></pre>

<hr>
<h2 id='optimal'>Searching for optimal traits</h2><span id='topic+optimal'></span><span id='topic+print.optimal'></span>

<h3>Description</h3>

<p>Maximize trait-convergence assembly patterns (TCAP = roTE), trait-divergence
assembly patterns (TDAP = roXE.T), maximize both trait-divergence assembly
patterns and trait-convergence assembly patterns (TCAP.TDAP = roXE) or
alpha divergence (roRE) For more details, see <code><a href="#topic+syncsa">syncsa</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal(
  comm,
  traits = NULL,
  envir = NULL,
  checkdata = TRUE,
  subset.min = 1,
  subset.max = ncol(traits),
  pattern = NULL,
  ro.method = "mantel",
  dist = "euclidean",
  method = "pearson",
  scale = TRUE,
  scale.envir = TRUE,
  ranks = TRUE,
  ord = "metric",
  put.together = NULL,
  na.rm = FALSE,
  notification = TRUE,
  progressbar = FALSE
)

## S3 method for class 'optimal'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimal_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as
rows. This matrix can contain either presence/absence or abundance data.
Alternatively comm can be an object of class metacommunity.data, an alternative
way to set all data.frames/matrices. When you use the class metacommunity.data the arguments
traits, envir and put.together must be null. See details.</p>
</td></tr>
<tr><td><code id="optimal_+3A_traits">traits</code></td>
<td>
<p>Matrix data of species described by traits, with traits as
columns and species as rows (Default traits = NULL).</p>
</td></tr>
<tr><td><code id="optimal_+3A_envir">envir</code></td>
<td>
<p>Environmental variables for each community, with variables as
columns and sampling units as rows (Default envir = NULL).</p>
</td></tr>
<tr><td><code id="optimal_+3A_checkdata">checkdata</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to check if species
sequence in the community data follows the same order as the one in the
trait and if sampling units in the community data follows the same order as the one in the
environmental matrices (Default checkdata = TRUE).</p>
</td></tr>
<tr><td><code id="optimal_+3A_subset.min">subset.min</code></td>
<td>
<p>Minimum of traits in each subset (Default subset.min = 1).</p>
</td></tr>
<tr><td><code id="optimal_+3A_subset.max">subset.max</code></td>
<td>
<p>Maximum of traits in each subset (Default subset.max = ncol(traits)).</p>
</td></tr>
<tr><td><code id="optimal_+3A_pattern">pattern</code></td>
<td>
<p>Patterns for maximize correlation, &quot;tcap&quot;, &quot;tdap&quot;,
&quot;tcap.tdap&quot; or &quot;rao&quot; (Default pattern = NULL).</p>
</td></tr>
<tr><td><code id="optimal_+3A_ro.method">ro.method</code></td>
<td>
<p>Method to obtain the correlation, &quot;mantel&quot; or &quot;procrustes&quot;
(Default ro.method = &quot;mantel&quot;).</p>
</td></tr>
<tr><td><code id="optimal_+3A_dist">dist</code></td>
<td>
<p>Dissimilarity index, as accepted by vegdist: &quot;manhattan&quot;,
&quot;euclidean&quot;, &quot;canberra&quot;, &quot;bray&quot;, &quot;kulczynski&quot;, &quot;jaccard&quot;, &quot;gower&quot;,
&quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot; , &quot;binomial&quot; or &quot;chao&quot;.</p>
</td></tr>
<tr><td><code id="optimal_+3A_method">method</code></td>
<td>
<p>Correlation method, as accepted by cor: &quot;pearson&quot;, &quot;spearman&quot;
or &quot;kendall&quot;.</p>
</td></tr>
<tr><td><code id="optimal_+3A_scale">scale</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if the traits are
measured on different scales (Default Scale = TRUE). When scale = TRUE traits
are measured on different scales and the matrix T is subjected to
standardization within each trait. When scale = FALSE if traits are measured on
the same scale and the matrix T is not subjected to standardization.
Furthermore, if scale = TRUE the matrix of traits is subjected to
standardization within each trait, and Gower Index is used to calculate the
degree of belonging to the species, and if scale = FALSE the matrix of
traits is not subjected to standardization, and Euclidean distance is
calculated to determine the degree of belonging to the species.</p>
</td></tr>
<tr><td><code id="optimal_+3A_scale.envir">scale.envir</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if the
environmental variables are measured on different scales (Default scale =
TRUE). If the enviromental variables are measured on different scales, the
matrix is subjected to centralization and standardization within each
variable.</p>
</td></tr>
<tr><td><code id="optimal_+3A_ranks">ranks</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if ordinal variables are
convert to ranks (Default ranks = TRUE).</p>
</td></tr>
<tr><td><code id="optimal_+3A_ord">ord</code></td>
<td>
<p>Method to be used for ordinal variables, see <code><a href="FD.html#topic+gowdis">gowdis</a></code>
(Default ord = &quot;metric&quot;).</p>
</td></tr>
<tr><td><code id="optimal_+3A_put.together">put.together</code></td>
<td>
<p>List to specify group traits that are added or removed
together (Default put.together = NULL). This argument must be a list, see
examples.</p>
</td></tr>
<tr><td><code id="optimal_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if pairwise
deletion of missing observations when computing dissimilarities (Default
na.rm = FALSE).</p>
</td></tr>
<tr><td><code id="optimal_+3A_notification">notification</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if
notifications of missing observations are shown (Default notification =
TRUE).</p>
</td></tr>
<tr><td><code id="optimal_+3A_progressbar">progressbar</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if display a
progress bar on the R console (Default progressbar = FALSE).</p>
</td></tr>
<tr><td><code id="optimal_+3A_x">x</code></td>
<td>
<p>An object of class optimal.</p>
</td></tr>
<tr><td><code id="optimal_+3A_...">...</code></td>
<td>
<p>Other parameters for the respective functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <strong>SYNCSA</strong> requires that the species and community sequence in
the data.frame or matrix must be the same for all dataframe/matrices.
The function <code><a href="#topic+organize.syncsa">organize.syncsa</a></code> organizes the data for the functions
of the package, placing the matrices of community, traits and
environmental varibles in the same order. The function
use of function organize.syncsa is not requered for run the functions, but
is recommended. In this way the arguments comm, traits, envir, as well as the argument
put.together, can be specified them as normal arguments or by passing them
with the object returned by the function <code><a href="#topic+organize.syncsa">organize.syncsa</a></code> using, in this
case only the argument comm. Using the object returned by organize.syncsa, the comm argument
is used as an alternative way of entering to set all data.frames/matrices, and therefore
the other arguments (traits, envir, and put.together) must be null.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Subset</code></td>
<td>
<p>Subset of traits that maximizes the correlation.</p>
</td></tr>
<tr><td><code>ro</code></td>
<td>
<p>Correlation for the subset of traits.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><strong>IMPORTANT</strong>: The sequence species show up in community data
matrix MUST be the same as they show up in traits matrix. See details and
<code><a href="#topic+organize.syncsa">organize.syncsa</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Pillar, V.D.; Duarte, L.d.S. (2010). A framework for
metacommunity analysis of phylogenetic structure. Ecology Letters, 13,
587-596.
</p>
<p>Pillar, V.D., Duarte, L.d.S., Sosinski, E.E. &amp; Joner, F. (2009).
Discriminating trait-convergence and trait-divergence assembly patterns in
ecological community gradients. Journal of Vegetation Science, 20, 334:348.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+organize.syncsa">organize.syncsa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(flona)
optimal(flona$community, flona$traits, flona$environment, subset.min = 3,
   subset.max = 5, pattern = "tcap")
optimal(flona$community, flona$traits, flona$environment, subset.min = 3,
   subset.max = 5, pattern = "tdap")
optimal(flona$community, flona$traits, flona$environment, subset.min = 3,
   subset.max = 5, pattern = "tcap.tdap")
put.together &lt;- list(c("fol", "sem"), c("tam", "red"))
put.together
optimal(flona$community, flona$traits, flona$environment, subset.min = 1,
   subset.max = 3, pattern = "tcap", put.together = put.together)
</code></pre>

<hr>
<h2 id='organize.syncsa'>Function for organize data for Package SYNCSA</h2><span id='topic+organize.syncsa'></span>

<h3>Description</h3>

<p>Package <strong>SYNCSA</strong> requires that the species and community sequence in
the data.frame or matrix must be the same for all data.frame/matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>organize.syncsa(
  comm,
  traits = NULL,
  phylodist = NULL,
  envir = NULL,
  strata = NULL,
  check.comm = TRUE,
  convert.traits = FALSE,
  ranks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="organize.syncsa_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as
rows.</p>
</td></tr>
<tr><td><code id="organize.syncsa_+3A_traits">traits</code></td>
<td>
<p>Matrix or data.frame of species described by traits, with traits as
columns and species as rows (Default traits = NULL).</p>
</td></tr>
<tr><td><code id="organize.syncsa_+3A_phylodist">phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distance between species.
Must be a complete matrix (not a half diagonal matrix).This matrix can be
larger than community data (more species) as long as it has at least all
species that are in community data (Default phylodist = NULL).</p>
</td></tr>
<tr><td><code id="organize.syncsa_+3A_envir">envir</code></td>
<td>
<p>Environmental variables for each community, with variables as
columns and sampling units as rows (Default envir = NULL).</p>
</td></tr>
<tr><td><code id="organize.syncsa_+3A_strata">strata</code></td>
<td>
<p>Strata named vector to specify restricting permutations within
species groups (Default strata = NULL).</p>
</td></tr>
<tr><td><code id="organize.syncsa_+3A_check.comm">check.comm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to remove sampling units and
species with total sums equal or less than zero (Default check.comm = TRUE).</p>
</td></tr>
<tr><td><code id="organize.syncsa_+3A_convert.traits">convert.traits</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to convert factor traits in
dummy traits and/or convert ordinal variables in numeric (see ranks argument)
(Default convert.traits = FALSE).</p>
</td></tr>
<tr><td><code id="organize.syncsa_+3A_ranks">ranks</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if ordinal variables are
convert to ranks. If ranks = TRUE all ordered variable are replaced by their ranks
and if ranks = FALSE all ordinal variables are simply treated as continuous variables
(Default ranks = TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function organizes the data for the functions of the package
SYNCSA, placing the matrices of community, traits, phylogenetic
distance, environmental varibles and strata vector in the same order.
The function use as reference the community data for organize all data.frame or matrices
in the same order that the sampling units names and species names found in community
data set. For this all data sets entered must be correctly named, with rows and columns
named. The matrices phylodist, traits, envir can be larger than community
data (more species and/or more sampling units) as long as it has at least
all species and/or sampling units that are in community data. The function
organizes the data despite the absence of one of the data.frames or matrices,
provided that the community data had been entered. Unspecified data will
appear as NULL.
</p>
<p>When trait is a data.frame with differents types of variables correctly identified and
the argument convert.traits is TRUE factor traits are expanded in dummy traits and ordinal variables
are converted in numeric according to ranks argument.
</p>
<p>The strata must be a named vector. The strata vector is a vector for restrict
permutation within species groups, insofar as the SYNCSA package the null
models are based in permutation of species rather than permutation of sample units.
</p>


<h3>Value</h3>

<p>A object of class metacommunity.data (also of the class list) with the data.frames or matrices:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The arguments used.</p>
</td></tr>
<tr><td><code>community</code></td>
<td>
<p>Community data.</p>
</td></tr>
<tr><td><code>traits</code></td>
<td>
<p>Traits data.</p>
</td></tr>
<tr><td><code>phylodist</code></td>
<td>
<p>Phylogenetic distance.</p>
</td></tr>
<tr><td><code>environmental</code></td>
<td>
<p>Environmental variables.</p>
</td></tr>
<tr><td><code>community.var.type</code></td>
<td>
<p>Type of each varible in community data,
where 'c' to continuous/numeric, 'o' to ordinal, 'b' to binary and 'f' to factor. Nominal are not allowed.</p>
</td></tr>
<tr><td><code>traits.var.type</code></td>
<td>
<p>Type of each varible in traits data. See labels above.</p>
</td></tr>
<tr><td><code>phylodist.var.type</code></td>
<td>
<p>Type of each varible in phylodist. See labels above.</p>
</td></tr>
<tr><td><code>environmental.var.type</code></td>
<td>
<p>Type of each varible in environmental data. See labels above.</p>
</td></tr>
<tr><td><code>strata</code></td>
<td>
<p>The strata vector for permutations.</p>
</td></tr>
<tr><td><code>put.together</code></td>
<td>
<p>A list with suggestion to group of traits that are analyzed together,
only if convert.traits is TRUE and if some traits are of factor class.</p>
</td></tr>
<tr><td><code>list.warning</code></td>
<td>
<p>A list of warning.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+var.dummy">var.dummy</a></code>, <code><a href="#topic+var.type">var.type</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ADRS)
organize.syncsa(ADRS$community, ADRS$traits, ADRS$phylo, ADRS$envir)
</code></pre>

<hr>
<h2 id='part.cor'>First-order partial correlation coefficient</h2><span id='topic+part.cor'></span>

<h3>Description</h3>

<p>Internal function to obtain the first-order partial correlation coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part.cor(rxy, rxz, ryz)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part.cor_+3A_rxy">rxy</code></td>
<td>
<p>Correlation between xy</p>
</td></tr>
<tr><td><code id="part.cor_+3A_rxz">rxz</code></td>
<td>
<p>Correlation between xz</p>
</td></tr>
<tr><td><code id="part.cor_+3A_ryz">ryz</code></td>
<td>
<p>Correlation between yz</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first-order partial correlation coefficient.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+cor.matrix">cor.matrix</a></code>,
</p>

<hr>
<h2 id='pca'>Principal Components Analysis (PCA) with NA (missing data)</h2><span id='topic+pca'></span><span id='topic+print.pcasyncsa'></span><span id='topic+plot.pcasyncsa'></span>

<h3>Description</h3>

<p>The function use the option &quot;pairwise.complete.obs&quot; (in function <code><a href="stats.html#topic+cor">cor</a></code>) for
calculate the correlation. The correlation between each pair of variables is computed
using all complete pairs of observations on those variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca(data)

## S3 method for class 'pcasyncsa'
plot(
  x,
  show = c("variables", "individuals"),
  axis = c(1, 2),
  xlab = axis[1],
  ylab = axis[2],
  arrows = TRUE,
  text = TRUE,
  points = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pca_+3A_data">data</code></td>
<td>
<p>A data frame  or matrix with individuals in rows and variables in columns.</p>
</td></tr>
<tr><td><code id="pca_+3A_x">x</code></td>
<td>
<p>A object of class pcasyncsa.</p>
</td></tr>
<tr><td><code id="pca_+3A_show">show</code></td>
<td>
<p>Draw &quot;variables&quot; or &quot;individuals&quot;.</p>
</td></tr>
<tr><td><code id="pca_+3A_axis">axis</code></td>
<td>
<p>Axis for draw, must have length equal to two (Default axis = c(1, 2)).</p>
</td></tr>
<tr><td><code id="pca_+3A_xlab">xlab</code></td>
<td>
<p>Text for x label (Default xlab = axis[1]).</p>
</td></tr>
<tr><td><code id="pca_+3A_ylab">ylab</code></td>
<td>
<p>Text for y label (Default ylab = axis[2]).</p>
</td></tr>
<tr><td><code id="pca_+3A_arrows">arrows</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if arrows are showed for variables (Default arrows = TRUE).</p>
</td></tr>
<tr><td><code id="pca_+3A_text">text</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if text are showed for individuals (Default text = TRUE).</p>
</td></tr>
<tr><td><code id="pca_+3A_points">points</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if points are showed for individuals (Default points = FALSE).</p>
</td></tr>
<tr><td><code id="pca_+3A_...">...</code></td>
<td>
<p>Parameters for <code><a href="base.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>decomposition</code></td>
<td>
<p>list with the results of decomposition of correlation matrix.</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>Data frame containing all the eigenvalues, the
percentage of inertia and the cumulative percentage of inertia.</p>
</td></tr>
<tr><td><code>individuals</code></td>
<td>
<p>Coordinates for the individuals.</p>
</td></tr>
<tr><td><code>variables</code></td>
<td>
<p>Correlation between original variables and axes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>
<code><a href="#topic+syncsa">syncsa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ADRS)
traits&lt;-ADRS$traits
# Some NA
traits[c(1,5),1]&lt;-NA
traits[3,2]&lt;-NA
traits
res&lt;-pca(traits)
res
plot(res, show = "variables", arrows = TRUE)
plot(res, show = "individuals", axis = c(1, 2), text = TRUE)
plot(res, show = "individuals", text = FALSE, points = TRUE)
</code></pre>

<hr>
<h2 id='permut.row.matrix'>Permutate rows in a matrix</h2><span id='topic+permut.row.matrix'></span>

<h3>Description</h3>

<p>Internal function to permutate rows in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permut.row.matrix(data, strata = NULL, seqpermutation = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permut.row.matrix_+3A_data">data</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="permut.row.matrix_+3A_strata">strata</code></td>
<td>
<p>Strata vector to specify restricting permutations in rows, must be the same length of number of rows in data matrix (Default strata = NULL).</p>
</td></tr>
<tr><td><code id="permut.row.matrix_+3A_seqpermutation">seqpermutation</code></td>
<td>
<p>A set of predefined permutation vector (Default seqpermutation = NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>permut.matrix</code></td>
<td>
<p>The matrix permuted.</p>
</td></tr> <tr><td><code>samp</code></td>
<td>
<p>The sequence of permutation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+permut.vector">permut.vector</a></code>
</p>

<hr>
<h2 id='permut.vector'>Permutate a vector</h2><span id='topic+permut.vector'></span>

<h3>Description</h3>

<p>Internal function to permutate a vector of size n using the function <code><a href="permute.html#topic+shuffleSet">shuffleSet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permut.vector(n, strata = NULL, nset = 999)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permut.vector_+3A_n">n</code></td>
<td>
<p>The length of vector.</p>
</td></tr>
<tr><td><code id="permut.vector_+3A_strata">strata</code></td>
<td>
<p>A vector to specify restricting permutations.</p>
</td></tr>
<tr><td><code id="permut.vector_+3A_nset">nset</code></td>
<td>
<p>The number of permutations to generate for the set (Default strata = NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of permutations, where each row is a separate permutation.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+permut.row.matrix">permut.row.matrix</a></code>
</p>

<hr>
<h2 id='procrustes.syncsa'>Procrustes and Partial Procrustes correlations.</h2><span id='topic+procrustes.syncsa'></span><span id='topic+procrustes.partial'></span>

<h3>Description</h3>

<p>Function to obtain the Procrustes correlation between two matrices and
partial Procrustes correlation between three matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procrustes.syncsa(x, y)

procrustes.partial(x, y, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="procrustes.syncsa_+3A_x">x</code>, <code id="procrustes.syncsa_+3A_y">y</code></td>
<td>
<p>Matrix that will be correlated.</p>
</td></tr>
<tr><td><code id="procrustes.syncsa_+3A_z">z</code></td>
<td>
<p>Matrix whose effect will be removed from the correlation between x
and y.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function procrustes.syncsa is a small change in the function
<code><a href="vegan.html#topic+procrustes">procrustes</a></code>. The function uses a correlation-like statistic
derived from the symmetric Procrustes sum of squares. Partial Procrustes
correlations is obtained by Procrustes correlation of residuals between
each variable in z being used as linear predictor of all variables in x and y.
For more details, see <code><a href="#topic+syncsa">syncsa</a></code>.
</p>


<h3>Value</h3>

<p>Procrustes correlation between matrices.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Peres-Neto, P.R. and Jackson, D.A. (2001). How well do
multivariate data sets match? The advantages of a Procrustean
superimposition approach over the Mantel test. Oecologia 129: 169-178.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+cor.matrix">cor.matrix</a></code>
</p>

<hr>
<h2 id='ProgressBAR'>Text Progress Bar</h2><span id='topic+ProgressBAR'></span>

<h3>Description</h3>

<p>Text progress bar in the R console. See <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProgressBAR(n, N, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ProgressBAR_+3A_n">n</code></td>
<td>
<p>Number of the current progress.</p>
</td></tr>
<tr><td><code id="ProgressBAR_+3A_n">N</code></td>
<td>
<p>Total number of cases.</p>
</td></tr>
<tr><td><code id="ProgressBAR_+3A_...">...</code></td>
<td>
<p>Other parameters for the txtProgressBar function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>

<hr>
<h2 id='rao.diversity'>Rao's quadratic entropy</h2><span id='topic+rao.diversity'></span>

<h3>Description</h3>

<p>Calculates Rao's quadratic entropy, functional and phylogenetic redundancy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rao.diversity(
  comm,
  traits = NULL,
  phylodist = NULL,
  checkdata = TRUE,
  ord = "metric",
  put.together = NULL,
  standardize = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rao.diversity_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as
rows. This matrix can contain either presence/absence or abundance data.
Alternatively comm can be an object of class metacommunity.data, an alternative
way to set all data.frames/matrices. When you use the class metacommunity.data the arguments
traits, phylodist and put.together must be null. See details.</p>
</td></tr>
<tr><td><code id="rao.diversity_+3A_traits">traits</code></td>
<td>
<p>Data frame or matrix data of species described by traits, with traits as
columns and species as rows (Default traits = NULL).</p>
</td></tr>
<tr><td><code id="rao.diversity_+3A_phylodist">phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distance between species
(Default phylodist = NULL).</p>
</td></tr>
<tr><td><code id="rao.diversity_+3A_checkdata">checkdata</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to check if species
sequence in the community data follows the same order as the one in the
trait and in the phylodist matrices (Default checkdata = TRUE).</p>
</td></tr>
<tr><td><code id="rao.diversity_+3A_ord">ord</code></td>
<td>
<p>Method to be used for ordinal variables, see <code><a href="FD.html#topic+gowdis">gowdis</a></code>
(Default ord = &quot;metric&quot;).</p>
</td></tr>
<tr><td><code id="rao.diversity_+3A_put.together">put.together</code></td>
<td>
<p>List to specify group of traits. Each group specify receive the
same weight that one trait outside any group, in the way each group is considered
as unique trait (Default put.together = NULL). This argument must be a list, see
examples in <code><a href="#topic+syncsa">syncsa</a></code>.</p>
</td></tr>
<tr><td><code id="rao.diversity_+3A_standardize">standardize</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if standardize phylogenetic
distance to range into range 0 to 1. (Default standardize = TRUE).</p>
</td></tr>
<tr><td><code id="rao.diversity_+3A_...">...</code></td>
<td>
<p>Parameters for <code><a href="FD.html#topic+gowdis">gowdis</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rao's quadratic entropy is a measure of diversity of ecological communities
defined by Rao (1982) and is based on the proportion of the abundance of
species present in a community and some measure of dissimilarity among them.
The dissimilarity range from 0 to 1 and is based on a set of specified
functional traits or in the phylogenetic dissimilarity.
</p>
<p>For the trait data, the function calculates the square root of the
one-complement of Gower's similarity index, in order to have a dissimilarity
matrix with Euclidean metric properties. Gower's index ranges from 0 to 1
and can handle traits measured indifferent scales. When the species are
completely different in terms of their traits, Rao quadratic entropy is
equivalent to the Gini-Simpson index. Traits data can be numeric, factor or
ordered factor. For this be considered traits data must be of data.frame
class and containing each variable type determined. For additional details and
requirements of function please see <code><a href="FD.html#topic+gowdis">gowdis</a></code>.
</p>
<p>Functional redundancy is defined purely as the difference between species
diversity and Rao's quadratic entropy based on their functional
dissimilarity (de Bello et al. 2007). The same definition is used for
phylogenetic redundancy.
</p>
<p>Package <strong>SYNCSA</strong> requires that the species and community sequence in
the data.frame or matrix must be the same for all dataframe/matrices.
The function <code><a href="#topic+organize.syncsa">organize.syncsa</a></code> organizes the data for the functions
of the package, placing the matrices of community, traits, phylogenetic distance
in the same order. The function use of function organize.syncsa is not requered
for run the functions, but is recommended. In this way the arguments comm, traits,
phylodist, as well as the argument put.together, can be specified them as normal
arguments or by passing them with the object returned by the function
<code><a href="#topic+organize.syncsa">organize.syncsa</a></code> using, in this case only the argument comm.
Using the object returned by organize.syncsa, the comm argument is used as an alternative
way of entering to set all data.frames/matrices, and therefore the other arguments
(traits, phylodist and put.together) must be null.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Simpson</code></td>
<td>
<p>Gini-Simpson index within each community (equivalent
to Rao quadratic entropy with null, crisp, similarities).</p>
</td></tr>
<tr><td><code>FunRao</code></td>
<td>
<p>Rao quadratic entropy within each community, considering trait distance.</p>
</td></tr>
<tr><td><code>FunRedundancy</code></td>
<td>
<p>Functional redundancy in each community.</p>
</td></tr>
<tr><td><code>PhyRao</code></td>
<td>
<p>Rao quadratic entropy within each community, considering phylogenetic distance.</p>
</td></tr>
<tr><td><code>PhyRedundancy</code></td>
<td>
<p>Phylogenetic redundancy in each community.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><strong>IMPORTANT</strong>: The sequence species show up in community data
matrix MUST be the same as they show up in traits and phylodist matrices.
See details and <code><a href="#topic+organize.syncsa">organize.syncsa</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>de Bello, F.; Leps, J.; Lavorel, S. &amp; Moretti, M. (2007).
Importance of species abundance for assessment of trait composition: an
example based on pollinator communities. Community Ecology, 8, 163:170.
</p>
<p>Pillar, V.D.; Blanco, C.C.; Muler, S.C.; Sosinski, E.E.; Joner, F. &amp; Duarte,
L.d.S. (2013). Functional redundancy and stability in plant communities.
Journal of Vegetation Science, 24, 963:974.
</p>
<p>Rao, C.R. (1982). Diversity and dissimilarity coefficients: a unified
approach. Theoretical Population Biology, 21, 24:43.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+organize.syncsa">organize.syncsa</a></code>, <code><a href="FD.html#topic+gowdis">gowdis</a></code>,
<code><a href="#topic+syncsa">syncsa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ADRS)
rao.diversity(ADRS$community)
rao.diversity(ADRS$community, traits = ADRS$traits)
</code></pre>

<hr>
<h2 id='syncsa'>SYNCSA</h2><span id='topic+syncsa'></span><span id='topic+SYNCSA'></span><span id='topic+print.syncsa'></span>

<h3>Description</h3>

<p>This function integrates several steps for the analysis of phylogenetic
assembly patterns and their links to traits and ecological processes in a
metacommunity (Pillar et al. 2009, Pillar &amp; Duarte 2010, Debastiani &amp; Pillar 2012). The
function implement methods that have been available in the SYNCSA
application written in C++ (by Valerio Pillar, available at
http://ecoqua.ecologia.ufrgs.br/SYNCSA.html). See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syncsa(
  comm,
  traits = NULL,
  phylodist = NULL,
  envir = NULL,
  checkdata = TRUE,
  ro.method = "mantel",
  method = "pearson",
  dist = "euclidean",
  scale = TRUE,
  scale.envir = TRUE,
  ranks = TRUE,
  ord,
  put.together = NULL,
  na.rm = FALSE,
  strata = NULL,
  permutations = 999,
  parallel = NULL,
  notification = TRUE
)

## S3 method for class 'syncsa'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="syncsa_+3A_comm">comm</code></td>
<td>
<p>Community data, with species as columns and sampling units as
rows. This matrix can contain either presence/absence or abundance data.
Alternatively comm can be an object of class metacommunity.data, an alternative
way to set all data.frames/matrices. When you use the class metacommunity.data the arguments
traits, phylodist, envir and put.together must be null. See details.</p>
</td></tr>
<tr><td><code id="syncsa_+3A_traits">traits</code></td>
<td>
<p>Data frame or matrix data of species described by traits, with traits as
columns and species as rows (Default traits = NULL).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_phylodist">phylodist</code></td>
<td>
<p>Matrix containing phylogenetic distance between species.
Must be a complete matrix, not a half diagonal matrix (Default phylodist = NULL).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_envir">envir</code></td>
<td>
<p>Environmental variables for each community, with variables as
columns and sampling units as rows (Default envir = NULL).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_checkdata">checkdata</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to check if species
sequence in the community data follows the same order as the one in the
trait and in the phylodist matrices and if sampling units in the community data follows
the same order as the one in the environmental data (Default checkdata = TRUE).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_ro.method">ro.method</code></td>
<td>
<p>Method to obtain the correlation, &quot;mantel&quot; or &quot;procrustes&quot;
(Default ro.method = &quot;mantel&quot;).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_method">method</code></td>
<td>
<p>Mantel correlation method, as accepted by cor: &quot;pearson&quot;,
&quot;spearman&quot; or &quot;kendall&quot; (Default method = &quot;pearson&quot;).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_dist">dist</code></td>
<td>
<p>Dissimilarity index used for Mantel correlation, as accepted by
vegdist: &quot;manhattan&quot;, &quot;euclidean&quot;, &quot;canberra&quot;, &quot;bray&quot;, &quot;kulczynski&quot;,
&quot;jaccard&quot;, &quot;gower&quot;, &quot;altGower&quot;, &quot;morisita&quot;, &quot;horn&quot;, &quot;mountford&quot;, &quot;raup&quot; ,
&quot;binomial&quot; or &quot;chao&quot; (Default dist = &quot;euclidean&quot;).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_scale">scale</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if the traits are
measured on different scales (Default Scale = TRUE). When scale = TRUE traits
are measured on different scales the the matrix T is subjected to
standardization within each trait. When scale = FALSE traits are measured on
the same scale and the matrix T is not subjected to standardization.
Furthermore, if scale = TRUE the matrix of traits is subjected to
standardization within each trait, and Gower Index is used to calculate the
degree of belonging to the species, and if scale = FALSE the matrix of
traits is not subjected to standardization, and Euclidean distance is
calculated to determine the degree of belonging to the species.</p>
</td></tr>
<tr><td><code id="syncsa_+3A_scale.envir">scale.envir</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if the
environmental variables are measured on different scales. If the
enviromental variables are measured on different scales, the scale.envir
= TRUE the matrix with enviromental variables is subjected to centralization
and standardization within each variable. (Default scale.envir = TRUE).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_ranks">ranks</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if ordinal variables are
convert to ranks (Default ranks = TRUE).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_ord">ord</code></td>
<td>
<p>Method to be used for ordinal variables, see <code><a href="FD.html#topic+gowdis">gowdis</a></code>.</p>
</td></tr>
<tr><td><code id="syncsa_+3A_put.together">put.together</code></td>
<td>
<p>List to specify group of traits. Each group specify receive the
same weight that one trait outside any group, in the way each group is considered
as unique trait (Default put.together = NULL). This argument must be a list, see
examples.</p>
</td></tr>
<tr><td><code id="syncsa_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if pairwise
distances should be deleted in cases of missing observations (Default na.rm
= FALSE).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_strata">strata</code></td>
<td>
<p>Strata named vector to specify restricting permutations within species
groups (Default strata = NULL).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_permutations">permutations</code></td>
<td>
<p>Number of permutations in assessing significance.</p>
</td></tr>
<tr><td><code id="syncsa_+3A_parallel">parallel</code></td>
<td>
<p>Number of parallel processes. Tip: use parallel::detectCores() (Default parallel = NULL).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_notification">notification</code></td>
<td>
<p>Logical argument (TRUE or FALSE) to specify if
notification of missing observations should to be shown (Default
notification = TRUE).</p>
</td></tr>
<tr><td><code id="syncsa_+3A_x">x</code></td>
<td>
<p>An object of class syncsa.</p>
</td></tr>
<tr><td><code id="syncsa_+3A_...">...</code></td>
<td>
<p>Other parameters for the respective functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <strong>SYNCSA</strong> requires that the species and community sequence in
the data.frame or matrix must be the same for all dataframe/matrices.
The function <code><a href="#topic+organize.syncsa">organize.syncsa</a></code> organizes the data for the functions
of the package, placing the matrices of community, traits, phylogenetic distance,
environmental varibles and strata vector in the same order. The function
use of function organize.syncsa is not requered for run the functions, but
is recommended. It requires data organized into the following matrices: (1) the
presences or abundances of species in a set of communities (<strong>W</strong>); (2) the
phylogenetic pairwise dissimilarities of these species (<strong>DF</strong>); (3) a set of
functional traits describing the species (<strong>B</strong>), which
may be a mixture of binary and quantitative traits (continual and ordinal),
but not nominal ones (these should be expanded into binary traits); and (4)
the ecological gradient of interest, which may be one or more factors to
which the communities respond or ecosystem effects of the communities
(<strong>E</strong>). In this way the arguments comm, traits, phylodist, envir,
as well as the arguments put.together and strata, can be specified them as normal
arguments or by passing them with the object returned by the function
<code><a href="#topic+organize.syncsa">organize.syncsa</a></code> using, in this case only the argument comm. Using the
object returned by organize.syncsa, the comm argument is used as an alternative way
of entering to set all data.frames/matrices, and therefore the other arguments
(traits, phylodist, envir, put.together and strata) must be null.
</p>
<p><strong>Correlations</strong>
</p>
<p>The function computes several correlations (Mantel or
Procrustes) that express trait-convergence assembly patterns (TCAP),
trait-divergence assembly patterns (TDAP), and phylogenetic signal in
functional traits at the species pool level and at the metacomunity level.
This function also generates P-values by permutation testing based on null
models (Pillar et al. 2009, Pillar &amp; Duarte 2010).
</p>
<p><strong>ro(TE)</strong>
</p>
<p>This correlation refers to trait-convergence assembly patterns related to
the ecological gradient (TCAP, Pillar et al. 2009). For evaluating TCAP, by
matrix multiplication we define <strong>T = WB</strong>, which with previous
standardization of <strong>W</strong> to unit column totals will contain the trait
averages in each community. The elements in <strong>T</strong> are community
weighted mean values or community functional parameters (Violle et al.
2007). Standardization of the traits (rows) in <strong>T</strong> is needed if the
trait set contains traits measured with different scales. By using matrix
correlation, we evaluate how the trait patterns in <strong>T</strong> are associated
to ecological gradients in <strong>E</strong>. For relating <strong>T</strong> to
<strong>E</strong>, using Mantel correlation we define a distance matrix of the
communities (<strong>DT</strong>) using <strong>T</strong>, and another distance matrix of
the community sites (<strong>DE</strong>) using <strong>E</strong>. The matrix correlation
ro(<strong>TE</strong>) = ro(<strong>DT</strong>;<strong>DE</strong>) measures the level of
congruence between TCAP and <strong>E</strong>. A strong correlation ro(<strong>TE</strong>)
indicates the factors directly or indirectly represented in <strong>E</strong> are
involved in ecological filtering of species that, at least for the traits
considered in the analysis, consistently produce trait-convergence assembly
patterns along the gradient comprising the metacommunity.
</p>
<p><strong>ro(XE) and ro(XE.T)</strong>
</p>
<p>These matrix correlations refer to trait-divergence assembly patterns
related to the ecological gradient (TDAP, Pillar et al. 2009). For the
identification of TDAP, in a first step the species pairwise similarities
(in the range 0 to 1) in matrix <strong>SB</strong> based on traits in <strong>B</strong>
are used to define matrix <strong>U</strong> with degrees of belonging of species to
fuzzy sets. By matrix multiplication <strong>X = WU</strong> will contain the
species composition of the communities after fuzzy-weighting by their trait
similarities (each row in <strong>X</strong> will refer to a species). Matrix
<strong>X</strong> expresses both TCAP and TDAP (Pillar et al. 2009). By using
matrix correlation, we evaluate how the trait patterns in <strong>X</strong> (TCAP
and TDAP) are associated to ecological gradients in <strong>E</strong>. For relating
<strong>X</strong> to <strong>E</strong>, we define a distance matrix of the communities
(<strong>DX</strong>) using <strong>X</strong>, and another distance matrix of the community
sites (<strong>DE</strong>) using <strong>E</strong>. The matrix correlation ro(<strong>XE</strong>)
= ro(<strong>DX</strong>;<strong>DE</strong>) between <strong>X</strong> and <strong>E</strong> is defined.
We then remove the trait-convergence component ro(<strong>TE</strong>) from
ro(<strong>XE</strong>) by computing the partial matrix correlation
ro(<strong>XE.T</strong>), which measures the level of congruence between TDAP and
<strong>E</strong>. Trait-divergence assembly patterns (TDAP, Pillar et al. 2009)
may result from community assembly processes related to biotic interactions
(Stubbs &amp; Wilson 2004; Wilson 2007).
</p>
<p><strong>ro(PE)</strong>
</p>
<p>This matrix correlation refers to the phylogenetic structure related to the
ecological gradient comprising the metacommunity. The phylogenetic pairwise
dissimilarities in <strong>DF</strong> are transformed into similarities and used to
define degrees of belonging qij to fuzzy sets. This is analogous to the
definition of functional fuzzy sets (Pillar &amp; Orloci 1991; Pillar et al.
2009). Based on the phylogenetic similarities, every species i among s
species in the metacommunity specifies a fuzzy set to which every species j
(j = 1 to s species, including species i) belongs with a certain degree of
belonging in the interval [0, 1]. In our definition, each row in matrix
<strong>Q</strong> with the degrees of belonging must add to unit, i.e., the degrees
of belonging of a given species across the fuzzy sets are standardized to
unit total. By matrix multiplication <strong>P = WQ</strong> will contain the
composition of the communities after fuzzy-weighting of species presences or
abundances by the species' phylogenetic similarities. Each column in matrix
<strong>P</strong> holds the phylogenetic structure of a community. The
standardization of <strong>Q</strong> is essential for the community totals in each
column in <strong>W</strong> remaining the same in <strong>P</strong>. Further, matrix
<strong>W</strong> is adjusted to unit column totals prior to multiplication, so
that the total richness or abundance within each community in <strong>W</strong>
will be standardized. Matrix correlation ro(<strong>PE</strong>) =
ro(<strong>DP</strong>;<strong>DE</strong>) measures the strength of the association between
community distances based on their phylogenetic structure in <strong>DP</strong> and
distances based on their ecological conditions (<strong>DE</strong>). Further,
<strong>P</strong> can be explored for phylogenetic patterns at the metacommunity
level by using, e.g., ordination techniques.
</p>
<p><strong>ro(PT) and ro(PX.T)</strong>
</p>
<p>These matrix correlations measure phylogenetic signal at the metacommunity
level related to TCAP and to TDAP. We define phylogenetic signal at the
metacommunity level related to TCAP (PSMT) as the correlation between the
phylogenetic structure described in matrix <strong>P</strong> and the
trait-convergence structure described in matrix <strong>T</strong>. For this, a
proper distance matrix (e.g. Euclidean distances) of communities
(<strong>DP</strong>) is computed using <strong>P</strong> and another distance matrix of
the same communities (<strong>DT</strong>) is computed using <strong>T</strong>. Then matrix
correlation ro(<strong>PT</strong>) = ro(<strong>DP</strong>;<strong>DT</strong>) will measure the
level of congruence between variation in <strong>P</strong> and <strong>T</strong>, which is
a measure of PSMT. A strong phylogenetic signal at the metacommunity level
is expected when communities that are more similar in terms of phylogenetic
structure are also similar regarding their average trait values. We also
define phylogenetic signal at the metacommunity level related to TDAP
(PSMX.T) as the partial matrix correlation ro(<strong>PX.T</strong>) =
ro(<strong>DP</strong>;<strong>DX.DT</strong>) between community distances DP computed on
phylogenetic structure and community distances <strong>DX</strong> computed on
species composition after fuzzy-weighting by the species, or trait
similarities, removing the effect of TCAP (<strong>DT</strong>). This is analogous
to TDAP.
</p>
<p><strong>ro(BF)</strong>
</p>
<p>This matrix correlation measures phylogenetic signal at the species pool
level (PSS, Pillar &amp; Duarte 2010). We define PSS as the matrix correlation
ro(<strong>FB</strong>) = ro(<strong>DF</strong>;<strong>DB</strong>) between species phylogenetic
dissimilarities (already defined as matrix <strong>DF</strong>) and species trait
dissimilarities (derived from already defined matrix <strong>SB</strong>) computed
on any number of traits from matrix <strong>B</strong>. The species pool refers to
the species present in the metacommunity.
</p>
<p><strong>Additional matrix correlations</strong>
</p>
<p>The matrix correlations ro(<strong>TE.P</strong>) and ro(<strong>XE.P</strong>) are also
computed, which may be useful for evaluating causal models in path analysis.
</p>
<p><strong>Mantel correlations</strong>
</p>
<p>The Mantel and Partial Mantel statistics are calculated simply as the correlation
entries the dissimilarity matrices, using standard Mantel test (see
<code><a href="vegan.html#topic+mantel">mantel</a></code> and <code><a href="#topic+cor.mantel">cor.mantel</a></code>). Partial Mantel
statistic use paired correlation between the three matrices and obtains the partial
correlation using the formula of first-order partial correlation coefficient. The
significances are obtained using a different procedure than standard Mantel test,
see section Testing against null models below.
</p>
<p><strong>Procrustes correlations</strong>
</p>
<p>The Procrustes correlation uses symmetric Procrustes as a measure of concordance
between the data matrices (see <code><a href="vegan.html#topic+procrustes">procrustes</a></code> and
<code><a href="#topic+cor.procrustes">cor.procrustes</a></code>). Procrustes procedure use rotation, translation,
and rescaling for minimizing sum of squared differences between two data sets.
The correlation of Procrustes is calculated as the statistic derived from the
symmetric Procrustes sum of squares, representing the optimal fit between the two
data matrices. Partial Procrustes correlation is obtained by Procrustes correlation
between residuals matrices. Firstly one Principal Components Analysis (PCA,
see <code><a href="stats.html#topic+prcomp">prcomp</a></code>) is performed in the matrix Z for dimensionality reduction.
The max number of axis kept in the analysis is the number of sampling units divided
by 2, this axes of PCA represent the total variation in the Z matrix. After the
kept axes are used as predictor in one linear model for each variable of the
matrices X and Y. For this a linear model is build using as response one variable
of X (same via for Y matrix) and as predictor all remaining axes of PCA, after model
fitted and the residual are extracted with the aim of form the residual matrix. The linear
model is repeated in the other variables, only with the changed the response variable.
The same procedure is performed in the matrix
Y. Both residual matrices are submitted to Procrustes analysis and the statistic is
returned as a partial correlation, the Partial Procrustes statistic. The significances
are obtained using the same procedure than Mantel test, see section Testing against
null models below.
</p>
<p><strong>Testing against null models</strong>
</p>
<p>All the matrix correlations are tested against null models. The null model
is defined accoding to the correlation being tested. Usually in the SYNCSA package
the null models are based in permutation of species rather than permutation
of sample units. For ro(<strong>TE</strong>),each permutation generates a random
matrix <strong>T</strong> calculated after the
permutation among the species vectors in matrix <strong>B</strong>. For
ro(<strong>XE</strong>) and ro(<strong>XE.T</strong>), each permutation generates a random
matrix <strong>X</strong> after the permutation among species fuzzy sets (rows) in
matrix <strong>U</strong>. For ro(<strong>PE</strong>), ro(<strong>PT</strong>), and
ro(<strong>PX.T</strong>), each permutation generates a random matrix <strong>P</strong>
after the permutation among species fuzzy sets (rows) in matrix <strong>Q</strong>.
For ro(<strong>BF</strong>), a conventional Mantel test is performed with
dissimilarity matrices <strong>DF</strong> and <strong>DB</strong>. Analogous null models
are used for testing the additional matrix correlations; that is, the same
null model for ro(<strong>TE</strong>) is used for ro(<strong>TE.P</strong>), the same model
for ro(<strong>XE</strong>) is used for ro(<strong>XE.P</strong>). The permutation can be restrict
within species groups specifying the strata argument.
</p>
<p><strong>Traits types</strong>
</p>
<p>Traits data can be numeric, factor or ordered factor. For this be considered in the
analyses traits data must be of data.frame class and containing each variable type
determined. Gower index is used to calculate the similarity between species, using
the function gowdis of package FD. For additional details and requirements of function
please see <code><a href="FD.html#topic+gowdis">gowdis</a></code>.
</p>
<p><strong>Missing data</strong>
</p>
<p>The functions ignore missing data when specified. In the case of direct
multiplication of matrices the missing data are replaced by 0, ignoring the cell with missing value. For the
matrix <strong>T = WB</strong> an adjustment is done by divide each cell of the product
matrix (<strong>T</strong>) by the sum of species proportion with trait data in <strong>B</strong>. Result
matrices are shown without missing values. Where the matrices are calculated
using a dissimilarity index (matrix <strong>U</strong> and correlations between
matrices) the missing data are ignored as in <code><a href="vegan.html#topic+vegdist">vegdist</a></code> function.
In some cases the dissimilarity matrices obtained by the function
<code><a href="vegan.html#topic+vegdist">vegdist</a></code> still contain some missing values. In these cases the
rest of the procedure will be affected. In these cases you can find
solutions in impute the missing values.
</p>
<p><strong>Error messenger and options</strong>
</p>
<p>The data pass by several ckeck points that can produce error messenger. The
matrices or data frames must be contain only numeric, binary or ordinal
variables, in the way that nominal variable should be expanded into binary
(see <code><a href="#topic+var.dummy">var.dummy</a></code>). For enhance the code speed some functions use
by default matrix algebra, this option can produce error under certain circumstances. This
global option can be changed using options(&quot;SYNCSA.speed&quot; = FALSE). If SYNCSA.speed = TRUE
for use matrix algebra and if SYNCSA.speed = FALSE use not another function of same procedure.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The arguments used.</p>
</td></tr> <tr><td><code>notes</code></td>
<td>
<p>Some notes about the statistics.</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>
<p>Correlations roTE, roXE, roPE, roPT, roPX.T, roXE.T, roTE.P, roXE.P
and roBF, and their significance levels based on permutations.</p>
</td></tr> <tr><td><code>matrices</code></td>
<td>
<p>The matrices
produced for the functions, see details.</p>
</td></tr> <tr><td><code>FunRao</code></td>
<td>
<p>Rao
quadratic entropy within each community, considering trait distance.</p>
</td></tr> <tr><td><code>weights</code></td>
<td>
<p>Weight for each trait.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function calculates the correlations despite the lack of one of
the matrices, provided that community data had been entered. Correlations
including unspecified matrices will appear with NA.
</p>
<p><strong>IMPORTANT</strong>: The sequence of species in the community data matrix
MUST be the same as that in the phylogenetic distance matrix and in traits
matrix. Similarly, the sequence of communities in the community data matrix
MUST be the same as that in the environmental data. See details and
<code><a href="#topic+organize.syncsa">organize.syncsa</a></code>.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>References</h3>

<p>Debastiani, V.J &amp; Pillar, V.D., (2012). SYNCSA-R tool for analysis of metacommunities
based on functional traits and phylogeny of the community components. Bioinformatics,
28(15), 20672068.
</p>
<p>Pillar, V.D.; Duarte, L.d.S., (2010). A framework for metacommunity analysis
of phylogenetic structure. Ecology Letters, 13, 587:596.
</p>
<p>Pillar, V.D., Duarte, L.d.S., Sosinski, E.E. &amp; Joner, F. (2009).
Discriminating trait-convergence and trait-divergence assembly patterns in
ecological community gradients. Journal of Vegetation Science, 20, 334:348.
</p>
<p>Pillar, V.D. &amp; Orloci, L., (1991). Fuzzy components in community level
comparisons. In: Computer Assisted Vegetation Analysis (eds Feoli, E. &amp;
Orloci, L.). Kluwer, Dordrecht, 87:93.
</p>
<p>Stubbs, W.J. &amp; Wilson, J.B., (2004). Evidence for limiting similarity in a
sand dune community. Journal of Ecology, 92, 557:567.
</p>
<p>Violle, C., Navas, M.L., Vile, D., Kazakou, E., Fortunel, C., Hummel, I. &amp;
Garnier, E., (2007). Let the concept of trait be functional! Oikos, 116,
882:892.
</p>
<p>Wilson, J.B., (2007). Trait-divergence assembly rules have been demonstrated:
limiting similarity lives! A reply to Grime. Journal of Vegetation Science,
18, 451:452.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+organize.syncsa">organize.syncsa</a></code>, <code><a href="#topic+matrix.t">matrix.t</a></code>,
<code><a href="#topic+matrix.x">matrix.x</a></code>, <code><a href="#topic+matrix.p">matrix.p</a></code>, <code><a href="#topic+optimal">optimal</a></code>,
<code><a href="#topic+rao.diversity">rao.diversity</a></code>, <code><a href="#topic+cor.matrix">cor.matrix</a></code>, <code><a href="#topic+var.type">var.type</a></code>,
<code><a href="#topic+var.dummy">var.dummy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ADRS)
syncsa(ADRS$community, ADRS$traits, ADRS$phylo, ADRS$envir, permutations = 99)
data(flona)
put.together&lt;-list(c("fol","sem"), c("tam", "red"))
put.together
res&lt;-syncsa(flona$community, flona$traits, envir = flona$environment,
   put.together = put.together, permutations = 99)
res$weights
</code></pre>

<hr>
<h2 id='var.dummy'>Generate dummy variable</h2><span id='topic+var.dummy'></span>

<h3>Description</h3>

<p>Function to expand factor variables in dummy variables in a data.frame. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.dummy(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.dummy_+3A_data">data</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variables in the data.frame of class factor is expanded in dummy variables. Each
level of factor produce a new column in the dataframe, with presence (1) or
absense (0) of level. The name of columns is a combination of orginal variable name
plus the level separate by underscore ( _ ). Ordered factor and character class are
not expanded.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The data with all variables of class factor expanded.</p>
</td></tr> <tr><td><code>together</code></td>
<td>
<p>A list
with sugestion to group of traits that are analysed together.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+organize.syncsa">organize.syncsa</a></code>, <code><a href="#topic+var.type">var.type</a></code>
</p>

<hr>
<h2 id='var.type'>Check the type of variables</h2><span id='topic+var.type'></span>

<h3>Description</h3>

<p>Function extracted (with small changes) of the function <code><a href="FD.html#topic+gowdis">gowdis</a></code>
to check the type of variables in a data.frame or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.type(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.type_+3A_data">data</code></td>
<td>
<p>A data.frame or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the variable types, where 'c' is continuous/numeric, 'o' is
ordinal, 'b' is binary, 'n' is nominal and 'f' is factor.
</p>


<h3>Author(s)</h3>

<p>Vanderlei Julio Debastiani &lt;vanderleidebastiani@yahoo.com.br&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syncsa">syncsa</a></code>, <code><a href="#topic+organize.syncsa">organize.syncsa</a></code>, <code><a href="#topic+var.dummy">var.dummy</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
